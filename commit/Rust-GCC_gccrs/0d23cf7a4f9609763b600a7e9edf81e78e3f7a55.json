{"sha": "0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQyM2NmN2E0Zjk2MDk3NjNiNjAwYTdlOWVkZjgxZTc4ZTNmN2E1NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-10-05T19:30:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-10-05T19:30:39Z"}, "message": "cp-tree.h (SIZEOF_EXPR_TYPE_P): Define.\n\ncp/\n\t* cp-tree.h (SIZEOF_EXPR_TYPE_P): Define.\n\t* tree.c (cp_tree_equal): Handle SIZEOF_EXPR with\n\tSIZEOF_EXPR_TYPE_P.\n\t* mangle.c (write_expression): Likewise.\n\t* cxx-pretty-print.c (pp_cxx_unary_expression): Likewise.\n\t* error.c (dump_expr): Likewise.\n\t* parser.c (cp_parser_unary_expression): For sizeof call\n\tcxx_sizeof_or_alignof_{type,expr} just for diagnostics and\n\treturn SIZEOF_EXPR with the operand.\n\t* pt.c (tsubst_copy, tsubst_copy_and_build): For SIZEOF_EXPR,\n\tcall cxx_sizeof_or_alignof_{type,expr} for diagnostics, but\n\treturn SIZEOF_EXPR with tsubsted operand.\n\t(value_dependent_expression_p): Handle SIZEOF_EXPR with\n\tSIZEOF_EXPR_TYPE_P.\n\t(instantiation_dependent_r): Likewise.\n\t* call.c (null_ptr_cst_p): Call maybe_constant_value for C++98.\n\t* semantics.c (finish_call_expr): Call\n\tsizeof_pointer_memaccess_warning if needed.\n\t(cxx_eval_constant_expression): Handle SIZEOF_EXPR.\n\t(potential_constant_expression_1): Remove early exit for\n\tC++98.  Handle PROPERTY_REF.\n\t* decl.c (duplicate_decls): When redeclaring a builtin function,\n\tkeep the merged decl builtin also if newdecl is a gnu_inline\n\tinline definition.\n\t(fold_sizeof_expr_r): New function.\n\t(compute_array_index_type): Fold SIZEOF_EXPRs in itype.\n\t* cp-gimplify.c (cp_genericize_r): Fold SIZEOF_EXPR.\n\t* typeck.c (cp_build_binary_op): For warn_for_sign_compare\n\ttry harder using maybe_constant_value to get INTEGER_CSTs.\n\n\t* decl.c (stabilize_vla_size): Call pointer_set_destroy\n\tat the end.\ntestsuite/\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: New test.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: New test.\n\t* g++.dg/warn/Wsign-compare-5.C: New test.\n\t* g++.dg/warn/Wsizeof-pointer-memaccess-1.C: New test.\n\t* g++.dg/warn/Wnull-conversion-1.C: For c++11 add dg-error.\n\t* g++.dg/ext/builtin30.C: New test.\n\t* g++.dg/ext/vla12.C: New test.\n\t* gcc.dg/builtins-85.c: New test.\nlibstdc++-v3/\n\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust line\n\tnumbers.\n\nFrom-SVN: r192141", "tree": {"sha": "cdaa38c550b113c61c8a82ec24f6b0febfad9e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdaa38c550b113c61c8a82ec24f6b0febfad9e1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94645a02dca8b5b103278ec48b4c7e0fe82ccfbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94645a02dca8b5b103278ec48b4c7e0fe82ccfbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94645a02dca8b5b103278ec48b4c7e0fe82ccfbf"}], "stats": {"total": 1921, "additions": 1843, "deletions": 78}, "files": [{"sha": "458b76231efae2425a8242bfe2c40d70f1518f94", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -1,3 +1,38 @@\n+2012-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (SIZEOF_EXPR_TYPE_P): Define.\n+\t* tree.c (cp_tree_equal): Handle SIZEOF_EXPR with\n+\tSIZEOF_EXPR_TYPE_P.\n+\t* mangle.c (write_expression): Likewise.\n+\t* cxx-pretty-print.c (pp_cxx_unary_expression): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* parser.c (cp_parser_unary_expression): For sizeof call\n+\tcxx_sizeof_or_alignof_{type,expr} just for diagnostics and\n+\treturn SIZEOF_EXPR with the operand.\n+\t* pt.c (tsubst_copy, tsubst_copy_and_build): For SIZEOF_EXPR,\n+\tcall cxx_sizeof_or_alignof_{type,expr} for diagnostics, but\n+\treturn SIZEOF_EXPR with tsubsted operand.\n+\t(value_dependent_expression_p): Handle SIZEOF_EXPR with\n+\tSIZEOF_EXPR_TYPE_P.\n+\t(instantiation_dependent_r): Likewise.\n+\t* call.c (null_ptr_cst_p): Call maybe_constant_value for C++98.\n+\t* semantics.c (finish_call_expr): Call\n+\tsizeof_pointer_memaccess_warning if needed.\n+\t(cxx_eval_constant_expression): Handle SIZEOF_EXPR.\n+\t(potential_constant_expression_1): Remove early exit for\n+\tC++98.  Handle PROPERTY_REF.\n+\t* decl.c (duplicate_decls): When redeclaring a builtin function,\n+\tkeep the merged decl builtin also if newdecl is a gnu_inline\n+\tinline definition.\n+\t(fold_sizeof_expr_r): New function.\n+\t(compute_array_index_type): Fold SIZEOF_EXPRs in itype.\n+\t* cp-gimplify.c (cp_genericize_r): Fold SIZEOF_EXPR.\n+\t* typeck.c (cp_build_binary_op): For warn_for_sign_compare\n+\ttry harder using maybe_constant_value to get INTEGER_CSTs.\n+\n+\t* decl.c (stabilize_vla_size): Call pointer_set_destroy\n+\tat the end.\n+\n 2012-10-04  Arnaud Charlet  <charlet@adacore.com>\n         \n         * decl2.c (cp_write_global_declarations): Fix handling of"}, {"sha": "006cf41bc0ef7d5e82086d8cda4fc9cf1a7b27f8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -557,7 +557,7 @@ null_ptr_cst_p (tree t)\n     {\n       /* Core issue 903 says only literal 0 is a null pointer constant.  */\n       if (cxx_dialect < cxx0x)\n-\tt = integral_constant_value (t);\n+\tt = maybe_constant_value (t);\n       STRIP_NOPS (t);\n       if (integer_zerop (t) && !TREE_OVERFLOW (t))\n \treturn true;"}, {"sha": "6178993fe892d04f585985ecd2c632beb1bccc8e", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -1,6 +1,7 @@\n /* C++-specific tree lowering bits; see also c-gimplify.c and tree-gimple.c.\n \n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,\n+   2012\n    Free Software Foundation, Inc.\n    Contributed by Jason Merrill <jason@redhat.com>\n \n@@ -1119,6 +1120,22 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     genericize_break_stmt (stmt_p);\n   else if (TREE_CODE (stmt) == OMP_FOR)\n     genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n+  else if (TREE_CODE (stmt) == SIZEOF_EXPR)\n+    {\n+      if (SIZEOF_EXPR_TYPE_P (stmt))\n+\t*stmt_p\n+\t  = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (stmt, 0)),\n+\t\t\t\t\tSIZEOF_EXPR, false);\n+      else if (TYPE_P (TREE_OPERAND (stmt, 0)))\n+\t*stmt_p = cxx_sizeof_or_alignof_type (TREE_OPERAND (stmt, 0),\n+\t\t\t\t\t      SIZEOF_EXPR, false);\n+      else\n+\t*stmt_p = cxx_sizeof_or_alignof_expr (TREE_OPERAND (stmt, 0),\n+\t\t\t\t\t      SIZEOF_EXPR, false);\n+      if (*stmt_p == error_mark_node)\n+\t*stmt_p = size_one_node;\n+      return NULL;\n+    }    \n \n   pointer_set_insert (p_set, *stmt_p);\n "}, {"sha": "034668d8500d82f59f19719fa65792f98351ad62", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -78,6 +78,7 @@ c-common.h, not after.\n       OVL_ARG_DEPENDENT (in OVERLOAD)\n       PACK_EXPANSION_LOCAL_P (in *_PACK_EXPANSION)\n       TINFO_RECHECK_ACCESS_P (in TEMPLATE_INFO)\n+      SIZEOF_EXPR_TYPE_P (in SIZEOF_EXPR)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -4055,6 +4056,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define CONVERT_EXPR_VBASE_PATH(NODE) \\\n   TREE_LANG_FLAG_0 (CONVERT_EXPR_CHECK (NODE))\n \n+/* True if SIZEOF_EXPR argument is type.  */\n+#define SIZEOF_EXPR_TYPE_P(NODE) \\\n+  TREE_LANG_FLAG_0 (SIZEOF_EXPR_CHECK (NODE))\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types {\n   none_type = 0, /* Not a tag type.  */"}, {"sha": "ce64a7b237740478bccfbce32656120f1636fe12", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of subroutines for the GNU C++ pretty-printer.\n    Copyright (C) 2003, 2004, 2005, 2007, 2008,\n-   2009, 2010, 2011 Free Software Foundation, Inc.\n+   2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -798,7 +798,13 @@ pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n     case ALIGNOF_EXPR:\n       pp_cxx_ws_string (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n       pp_cxx_whitespace (pp);\n-      if (TYPE_P (TREE_OPERAND (t, 0)))\n+      if (TREE_CODE (t) == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (t))\n+\t{\n+\t  pp_cxx_left_paren (pp);\n+\t  pp_cxx_type_id (pp, TREE_TYPE (TREE_OPERAND (t, 0)));\n+\t  pp_cxx_right_paren (pp);\n+\t}\n+      else if (TYPE_P (TREE_OPERAND (t, 0)))\n \t{\n \t  pp_cxx_left_paren (pp);\n \t  pp_cxx_type_id (pp, TREE_OPERAND (t, 0));"}, {"sha": "72754a92e997fe4be55b20423a151696334aa33f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -2160,39 +2160,40 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  DECL_ARGUMENTS (olddecl) = DECL_ARGUMENTS (newdecl);\n \t  DECL_RESULT (olddecl) = DECL_RESULT (newdecl);\n \t}\n+      /* If redeclaring a builtin function, it stays built in\n+\t if newdecl is a gnu_inline definition, or if newdecl is just\n+\t a declaration.  */\n+      if (DECL_BUILT_IN (olddecl)\n+\t  && (new_defines_function ? GNU_INLINE_P (newdecl) : types_match))\n+\t{\n+\t  DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n+\t  DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n+\t  /* If we're keeping the built-in definition, keep the rtl,\n+\t     regardless of declaration matches.  */\n+\t  COPY_DECL_RTL (olddecl, newdecl);\n+\t  if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)\n+\t    {\n+\t      enum built_in_function fncode = DECL_FUNCTION_CODE (newdecl);\n+\t      switch (fncode)\n+\t\t{\n+\t\t  /* If a compatible prototype of these builtin functions\n+\t\t     is seen, assume the runtime implements it with the\n+\t\t     expected semantics.  */\n+\t\tcase BUILT_IN_STPCPY:\n+\t\t  if (builtin_decl_explicit_p (fncode))\n+\t\t    set_builtin_decl_implicit_p (fncode, true);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n       if (new_defines_function)\n \t/* If defining a function declared with other language\n \t   linkage, use the previously declared language linkage.  */\n \tSET_DECL_LANGUAGE (newdecl, DECL_LANGUAGE (olddecl));\n       else if (types_match)\n \t{\n-\t  /* If redeclaring a builtin function, and not a definition,\n-\t     it stays built in.  */\n-\t  if (DECL_BUILT_IN (olddecl))\n-\t    {\n-\t      DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);\n-\t      DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n-\t      /* If we're keeping the built-in definition, keep the rtl,\n-\t\t regardless of declaration matches.  */\n-\t      COPY_DECL_RTL (olddecl, newdecl);\n-\t      if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)\n-\t\t{\n-\t\t  enum built_in_function fncode = DECL_FUNCTION_CODE (newdecl);\n-\t\t  switch (fncode)\n-\t\t    {\n-\t\t      /* If a compatible prototype of these builtin functions\n-\t\t\t is seen, assume the runtime implements it with the\n-\t\t\t expected semantics.  */\n-\t\t    case BUILT_IN_STPCPY:\n-\t\t      if (builtin_decl_explicit_p (fncode))\n-\t\t\tset_builtin_decl_implicit_p (fncode, true);\n-\t\t      break;\n-\t\t    default:\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n \t  /* Don't clear out the arguments if we're just redeclaring a\n \t     function.  */\n@@ -7931,6 +7932,36 @@ stabilize_vla_size (tree size)\n   struct pointer_set_t *pset = pointer_set_create ();\n   /* Break out any function calls into temporary variables.  */\n   cp_walk_tree (&size, stabilize_save_expr_r, pset, pset);\n+  pointer_set_destroy (pset);\n+}\n+\n+/* Helper function for compute_array_index_type.  Look for SIZEOF_EXPR\n+   not inside of SAVE_EXPR and fold them.  */\n+\n+static tree\n+fold_sizeof_expr_r (tree *expr_p, int *walk_subtrees, void *data)\n+{\n+  tree expr = *expr_p;\n+  if (TREE_CODE (expr) == SAVE_EXPR || TYPE_P (expr))\n+    *walk_subtrees = 0;\n+  else if (TREE_CODE (expr) == SIZEOF_EXPR)\n+    {\n+      *(bool *)data = true;\n+      if (SIZEOF_EXPR_TYPE_P (expr))\n+\texpr = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (expr, 0)),\n+\t\t\t\t\t   SIZEOF_EXPR, false);\n+      else if (TYPE_P (TREE_OPERAND (expr, 0)))\n+\texpr = cxx_sizeof_or_alignof_type (TREE_OPERAND (expr, 0), SIZEOF_EXPR,\n+\t\t\t\t\t   false);\n+      else\n+        expr = cxx_sizeof_or_alignof_expr (TREE_OPERAND (expr, 0), SIZEOF_EXPR,\n+\t\t\t\t\t   false);\n+      if (expr == error_mark_node)\n+        expr = size_one_node;\n+      *expr_p = expr;\n+      *walk_subtrees = 0;\n+    }\n+  return NULL;\n }\n \n /* Given the SIZE (i.e., number of elements) in an array, compute an\n@@ -8126,8 +8157,21 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n       processing_template_decl = saved_processing_template_decl;\n \n       if (!TREE_CONSTANT (itype))\n-\t/* A variable sized array.  */\n-\titype = variable_size (itype);\n+\t{\n+\t  /* A variable sized array.  */\n+\t  itype = variable_size (itype);\n+\t  if (TREE_CODE (itype) != SAVE_EXPR)\n+\t    {\n+\t      /* Look for SIZEOF_EXPRs in itype and fold them, otherwise\n+\t\t they might survive till gimplification.  */\n+\t      tree newitype = itype;\n+\t      bool found = false;\n+\t      cp_walk_tree_without_duplicates (&newitype,\n+\t\t\t\t\t       fold_sizeof_expr_r, &found);\n+\t      if (found)\n+\t\titype = variable_size (fold (newitype));\n+\t    }\n+\t}\n       /* Make sure that there was no overflow when creating to a signed\n \t index type.  (For example, on a 32-bit machine, an array with\n \t size 2^32 - 1 is too big.)  */"}, {"sha": "e1aa938ddc84a993b6ac1daf31b5c403d646c3aa", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -2312,7 +2312,9 @@ dump_expr (tree t, int flags)\n \t}\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_paren (cxx_pp);\n-      if (TYPE_P (TREE_OPERAND (t, 0)))\n+      if (TREE_CODE (t) == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (t))\n+\tdump_type (TREE_TYPE (TREE_OPERAND (t, 0)), flags);\n+      else if (TYPE_P (TREE_OPERAND (t, 0)))\n \tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n \tdump_expr (TREE_OPERAND (t, 0), flags);"}, {"sha": "eee44a1bae2a9ed66b86b58f75ed80bc9d9b1135", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -1,6 +1,6 @@\n /* Name mangling for the 3.0 C++ ABI.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010,\n-   2011  Free Software Foundation, Inc.\n+   2011, 2012  Free Software Foundation, Inc.\n    Written by Alex Samuel <samuel@codesourcery.com>\n \n    This file is part of GCC.\n@@ -2580,6 +2580,12 @@ write_expression (tree expr)\n       write_mangled_name (expr, false);\n       write_char ('E');\n     }\n+  else if (TREE_CODE (expr) == SIZEOF_EXPR\n+\t   && SIZEOF_EXPR_TYPE_P (expr))\n+    {\n+      write_string (\"st\");\n+      write_type (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+    }\n   else if (TREE_CODE (expr) == SIZEOF_EXPR\n \t   && TYPE_P (TREE_OPERAND (expr, 0)))\n     {"}, {"sha": "baaa80956027fe2675335712e134ec702d3510dc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -6383,17 +6383,19 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tcase RID_ALIGNOF:\n \tcase RID_SIZEOF:\n \t  {\n-\t    tree operand;\n+\t    tree operand, ret;\n \t    enum tree_code op;\n+\t    location_t first_loc;\n \n \t    op = keyword == RID_ALIGNOF ? ALIGNOF_EXPR : SIZEOF_EXPR;\n \t    /* Consume the token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n+\t    first_loc = cp_lexer_peek_token (parser->lexer)->location;\n \t    /* Parse the operand.  */\n \t    operand = cp_parser_sizeof_operand (parser, keyword);\n \n \t    if (TYPE_P (operand))\n-\t      return cxx_sizeof_or_alignof_type (operand, op, true);\n+\t      ret = cxx_sizeof_or_alignof_type (operand, op, true);\n \t    else\n \t      {\n \t\t/* ISO C++ defines alignof only with types, not with\n@@ -6404,8 +6406,29 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t   \"ISO C++ does not allow %<alignof%> \"\n \t\t\t   \"with a non-type\");\n \n-\t\treturn cxx_sizeof_or_alignof_expr (operand, op, true);\n+\t\tret = cxx_sizeof_or_alignof_expr (operand, op, true);\n \t      }\n+\t    /* For SIZEOF_EXPR, just issue diagnostics, but keep\n+\t       SIZEOF_EXPR with the original operand.  */\n+\t    if (op == SIZEOF_EXPR && ret != error_mark_node)\n+\t      {\n+\t\tif (TREE_CODE (ret) != SIZEOF_EXPR || TYPE_P (operand))\n+\t\t  {\n+\t\t    if (!processing_template_decl && TYPE_P (operand))\n+\t\t      {\n+\t\t\tret = build_min (SIZEOF_EXPR, size_type_node,\n+\t\t\t\t\t build1 (NOP_EXPR, operand,\n+\t\t\t\t\t\t error_mark_node));\n+\t\t\tSIZEOF_EXPR_TYPE_P (ret) = 1;\n+\t\t      }\n+\t\t    else\n+\t\t      ret = build_min (SIZEOF_EXPR, size_type_node, operand);\n+\t\t    TREE_SIDE_EFFECTS (ret) = 0;\n+\t\t    TREE_READONLY (ret) = 1;\n+\t\t  }\n+\t\tSET_EXPR_LOCATION (ret, first_loc);\n+\t      }\n+\t    return ret;\n \t  }\n \n \tcase RID_NEW:"}, {"sha": "c3fb5e8feb279f38ddc5c387cdd8ed16afcc8df1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 70, "deletions": 28, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -12031,14 +12031,16 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n         {\n \n-          tree expanded;\n+          tree expanded, op = TREE_OPERAND (t, 0);\n \t  int len = 0;\n \n+\t  if (SIZEOF_EXPR_TYPE_P (t))\n+\t    op = TREE_TYPE (op);\n+\n \t  ++cp_unevaluated_operand;\n \t  ++c_inhibit_evaluation_warnings;\n \t  /* We only want to compute the number of arguments.  */\n-\t  expanded = tsubst_pack_expansion (TREE_OPERAND (t, 0), args,\n-\t\t\t\t\t    complain, in_decl);\n+\t  expanded = tsubst_pack_expansion (op, args, complain, in_decl);\n \t  --cp_unevaluated_operand;\n \t  --c_inhibit_evaluation_warnings;\n \n@@ -12065,6 +12067,16 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  else\n \t    return build_int_cst (size_type_node, len);\n         }\n+      if (SIZEOF_EXPR_TYPE_P (t))\n+\t{\n+\t  r = tsubst_copy (TREE_TYPE (TREE_OPERAND (t, 0)),\n+\t\t\t   args, complain, in_decl);\n+\t  r = build1 (NOP_EXPR, r, error_mark_node);\n+\t  r = build1 (SIZEOF_EXPR,\n+\t\t      tsubst (TREE_TYPE (t), args, complain, in_decl), r);\n+\t  SIZEOF_EXPR_TYPE_P (r) = 1;\n+\t  return r;\n+\t}\n       /* Fall through */\n \n     case INDIRECT_REF:\n@@ -13468,31 +13480,56 @@ tsubst_copy_and_build (tree t,\n       /* Fall through */\n       \n     case ALIGNOF_EXPR:\n-      op1 = TREE_OPERAND (t, 0);\n-      if (!args)\n-\t{\n-\t  /* When there are no ARGS, we are trying to evaluate a\n-\t     non-dependent expression from the parser.  Trying to do\n-\t     the substitutions may not work.  */\n-\t  if (!TYPE_P (op1))\n-\t    op1 = TREE_TYPE (op1);\n-\t}\n-      else\n-\t{\n-\t  ++cp_unevaluated_operand;\n-\t  ++c_inhibit_evaluation_warnings;\n-\t  op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t       /*function_p=*/false,\n-\t\t\t\t       /*integral_constant_expression_p=*/false);\n-\t  --cp_unevaluated_operand;\n-\t  --c_inhibit_evaluation_warnings;\n-\t}\n-      if (TYPE_P (op1))\n-\tRETURN (cxx_sizeof_or_alignof_type (op1, TREE_CODE (t),\n-                                           complain & tf_error));\n-      else\n-\tRETURN (cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t),\n-                                           complain & tf_error));\n+      {\n+\ttree r;\n+\n+\top1 = TREE_OPERAND (t, 0);\n+\tif (TREE_CODE (t) == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (t))\n+\t  op1 = TREE_TYPE (op1);\n+        if (!args)\n+\t  {\n+\t    /* When there are no ARGS, we are trying to evaluate a\n+\t       non-dependent expression from the parser.  Trying to do\n+\t       the substitutions may not work.  */\n+\t    if (!TYPE_P (op1))\n+\t      op1 = TREE_TYPE (op1);\n+\t  }\n+\telse\n+\t  {\n+\t    ++cp_unevaluated_operand;\n+\t    ++c_inhibit_evaluation_warnings;\n+\t    op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n+\t\t\t\t\t /*function_p=*/false,\n+\t\t\t\t\t /*integral_constant_expression_p=*/\n+\t\t\t\t\t false);\n+\t    --cp_unevaluated_operand;\n+\t    --c_inhibit_evaluation_warnings;\n+\t  }\n+        if (TYPE_P (op1))\n+\t  r = cxx_sizeof_or_alignof_type (op1, TREE_CODE (t),\n+\t\t\t\t\t  complain & tf_error);\n+\telse\n+\t  r = cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t),\n+\t\t\t\t\t  complain & tf_error);\n+\tif (TREE_CODE (t) == SIZEOF_EXPR && r != error_mark_node)\n+\t  {\n+\t    if (TREE_CODE (r) != SIZEOF_EXPR || TYPE_P (op1))\n+\t      {\n+\t\tif (TYPE_P (op1))\n+\t\t  {\n+\t\t    r = build_min (SIZEOF_EXPR, size_type_node,\n+\t\t\t\t   build1 (NOP_EXPR, op1, error_mark_node));\n+\t\t    SIZEOF_EXPR_TYPE_P (r) = 1;\n+\t\t  }\n+\t\telse\n+\t\t  r = build_min (SIZEOF_EXPR, size_type_node, op1);\n+\t\tTREE_SIDE_EFFECTS (r) = 0;\n+\t\tTREE_READONLY (r) = 1;\n+\t      }\n+\t    SET_EXPR_LOCATION (r, EXPR_LOCATION (t));\n+\t  }\n+\tRETURN (r);\n+      }\n \n     case AT_ENCODE_EXPR:\n       {\n@@ -19288,6 +19325,9 @@ value_dependent_expression_p (tree expression)\n       }\n \n     case SIZEOF_EXPR:\n+      if (SIZEOF_EXPR_TYPE_P (expression))\n+\treturn dependent_type_p (TREE_TYPE (TREE_OPERAND (expression, 0)));\n+      /* FALLTHRU */\n     case ALIGNOF_EXPR:\n     case TYPEID_EXPR:\n       /* A `sizeof' expression is value-dependent if the operand is\n@@ -19627,6 +19667,8 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n     case TRAIT_EXPR:\n       {\n \ttree op = TREE_OPERAND (*tp, 0);\n+\tif (code == SIZEOF_EXPR && SIZEOF_EXPR_TYPE_P (*tp))\n+\t  op = TREE_TYPE (op);\n \tif (TYPE_P (op))\n \t  {\n \t    if (dependent_type_p (op)"}, {"sha": "17ac36f67b92c20f8d648dd2452923f71e7ad7db", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -2170,8 +2170,25 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n \tresult = resolve_overloaded_builtin (input_location, fn, *args);\n \n       if (!result)\n-\t/* A call to a namespace-scope function.  */\n-\tresult = build_new_function_call (fn, args, koenig_p, complain);\n+\t{\n+\t  if (warn_sizeof_pointer_memaccess\n+\t      && !VEC_empty(tree, *args)\n+\t      && TREE_CODE (VEC_last(tree, *args)) == SIZEOF_EXPR\n+\t      && !processing_template_decl)\n+\t    {\n+\t      tree sizeof_arg = VEC_last(tree, *args);\n+\t      if (SIZEOF_EXPR_TYPE_P (sizeof_arg))\n+\t\tsizeof_arg = TREE_TYPE (TREE_OPERAND (sizeof_arg, 0));\n+\t      else\n+\t\tsizeof_arg = TREE_OPERAND (sizeof_arg, 0);\n+\t      sizeof_pointer_memaccess_warning\n+\t\t(EXPR_LOCATION (VEC_last(tree, *args)), fn, *args,\n+\t\t sizeof_arg, same_type_ignoring_top_level_qualifiers_p);\n+\t    }\n+\n+\t  /* A call to a namespace-scope function.  */\n+\t  result = build_new_function_call (fn, args, koenig_p, complain);\n+\t}\n     }\n   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n     {\n@@ -7723,6 +7740,21 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t\t\t\t     non_constant_p);\n       break;\n \n+    case SIZEOF_EXPR:\n+      if (SIZEOF_EXPR_TYPE_P (t))\n+\tr = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (t, 0)),\n+\t\t\t\t\tSIZEOF_EXPR, false);\n+      else if (TYPE_P (TREE_OPERAND (t, 0)))\n+\tr = cxx_sizeof_or_alignof_type (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n+\t\t\t\t\tfalse);\n+      else\n+\tr = cxx_sizeof_or_alignof_expr (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n+\t\t\t\t\tfalse);\n+      if (r == error_mark_node)\n+\tr = size_one_node;\n+      VERIFY_CONSTANT (r);\n+      break;\n+\n     case COMPOUND_EXPR:\n       {\n \t/* check_return_expr sometimes wraps a TARGET_EXPR in a\n@@ -8107,12 +8139,6 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n   int i;\n   tree tmp;\n \n-  /* C++98 has different rules for the form of a constant expression that\n-     are enforced in the parser, so we can assume that anything that gets\n-     this far is suitable.  */\n-  if (cxx_dialect < cxx0x)\n-    return true;\n-\n   if (t == error_mark_node)\n     return false;\n   if (t == NULL_TREE)\n@@ -8633,6 +8659,9 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       return false;\n \n     default:\n+      if (objc_is_property_ref (t))\n+\treturn false;\n+\n       sorry (\"unexpected AST of kind %s\", tree_code_name[TREE_CODE (t)]);\n       gcc_unreachable();\n       return false;"}, {"sha": "60dc54959bb6bd7cfe04c9cb674e6e33fc4c1c4b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -2602,6 +2602,10 @@ cp_tree_equal (tree t1, tree t2)\n \ttree o1 = TREE_OPERAND (t1, 0);\n \ttree o2 = TREE_OPERAND (t2, 0);\n \n+\tif (SIZEOF_EXPR_TYPE_P (t1))\n+\t  o1 = TREE_TYPE (o1);\n+\tif (SIZEOF_EXPR_TYPE_P (t2))\n+\t  o2 = TREE_TYPE (o2);\n \tif (TREE_CODE (o1) != TREE_CODE (o2))\n \t  return false;\n \tif (TYPE_P (o1))"}, {"sha": "ce779075d3a63e45e5c6d9bcb4c6587a082c87b8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -4624,7 +4624,14 @@ cp_build_binary_op (location_t location,\n \t  && !enum_cast_to_int (orig_op0)\n \t  && !enum_cast_to_int (orig_op1))\n \t{\n-\t  warn_for_sign_compare (location, orig_op0, orig_op1, op0, op1, \n+\t  tree oop0 = maybe_constant_value (orig_op0);\n+\t  tree oop1 = maybe_constant_value (orig_op1);\n+\n+\t  if (TREE_CODE (oop0) != INTEGER_CST)\n+\t    oop0 = orig_op0;\n+\t  if (TREE_CODE (oop1) != INTEGER_CST)\n+\t    oop1 = orig_op1;\n+\t  warn_for_sign_compare (location, oop0, oop1, op0, op1, \n \t\t\t\t result_type, resultcode);\n \t}\n     }"}, {"sha": "28a4f57a6b5d8d15e05290c7889da70106030b1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -1,5 +1,14 @@\n 2012-10-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: New test.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: New test.\n+\t* g++.dg/warn/Wsign-compare-5.C: New test.\n+\t* g++.dg/warn/Wsizeof-pointer-memaccess-1.C: New test.\n+\t* g++.dg/warn/Wnull-conversion-1.C: For c++11 add dg-error.\n+\t* g++.dg/ext/builtin30.C: New test.\n+\t* g++.dg/ext/vla12.C: New test.\n+\t* gcc.dg/builtins-85.c: New test.\n+\n \tPR debug/54519\n \t* gcc.dg/guality/pr54519-1.c: New test.\n \t* gcc.dg/guality/pr54519-2.c: New test."}, {"sha": "d0a75fb173d38db92e6fe72bdb166bb06418461b", "filename": "gcc/testsuite/g++.dg/ext/builtin30.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin30.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" {\n+extern void __chk_fail (void);\n+extern int snprintf (char *, size_t, const char *, ...);\n+extern inline __attribute__((gnu_inline, always_inline)) int snprintf (char *a, size_t b, const char *fmt, ...)\n+{\n+  if (__builtin_object_size (a, 0) != -1UL && __builtin_object_size (a, 0) < b)\n+    __chk_fail ();\n+  return __builtin_snprintf (a, b, fmt, __builtin_va_arg_pack ());\n+}\n+extern int snprintf (char *, size_t, const char *, ...) __asm (\"mysnprintf\");\n+}\n+\n+char buf[10];\n+\n+int\n+main (void)\n+{\n+  snprintf (buf, 10, \"%d%d\\n\", 10, 10);\n+  return 0;\n+}\n+\n+// { dg-final { scan-assembler \"mysnprintf\" } }\n+// { dg-final { scan-assembler-not \"__chk_fail\" } }"}, {"sha": "bca836507a949d2900c428bc6526706471f52b93", "filename": "gcc/testsuite/g++.dg/ext/vla12.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla12.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,28 @@\n+// VLA sizeof test\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+int\n+f1 (int i)\n+{\n+  char a[sizeof (i) + 6 + i];\n+  char b[sizeof (a) + 1];\n+  return sizeof (b);\n+}\n+\n+int\n+f2 (int i)\n+{\n+  char a[sizeof (i) + 6 + i];\n+  char b[sizeof (a)];\n+  return sizeof (b);\n+}\n+\n+int\n+f3 (int i)\n+{\n+  char a[sizeof (i) + 6 + i];\n+  char b[sizeof (i) + i];\n+  char c[sizeof (a) + sizeof (b) + 7];\n+  return sizeof (c);\n+}"}, {"sha": "c57096cc063dde1806dd3f10eb440fbe8761b1a6", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "added", "additions": 702, "deletions": 0, "changes": 702, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,702 @@\n+// Test -Wsizeof-pointer-memaccess warnings.\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+// Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n+// { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n+// { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }\n+\n+extern \"C\" {\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memset (void *, int, size_t);\n+extern void *memcpy (void *__restrict, const void *__restrict, size_t);\n+extern void *memmove (void *__restrict, const void *__restrict, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *strncpy (char *__restrict, const char *__restrict, size_t);\n+extern char *strncat (char *__restrict, const char *__restrict, size_t);\n+extern char *strndup (const char *, size_t);\n+extern int strncmp (const char *, const char *, size_t);\n+extern int strncasecmp (const char *, const char *, size_t);\n+\n+#ifdef __OPTIMIZE__\n+# define bos(ptr) __builtin_object_size (ptr, 1)\n+# define bos0(ptr) __builtin_object_size (ptr, 0)\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memset (void *dest, int c, size_t len)\n+{\n+  return __builtin___memset_chk (dest, c, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memcpy (void *__restrict dest, const void *__restrict src, size_t len)\n+{\n+  return __builtin___memcpy_chk (dest, src, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memmove (void *dest, const void *src, size_t len)\n+{\n+  return __builtin___memmove_chk (dest, src, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+strncpy (char *__restrict dest, const char *__restrict src, size_t len)\n+{\n+  return __builtin___strncpy_chk (dest, src, len, bos (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+strncat (char *dest, const char *src, size_t len)\n+{\n+  return __builtin___strncat_chk (dest, src, len, bos (dest));\n+}\n+#endif\n+\n+}\n+\n+struct A { short a, b; int c, d; long e, f; };\n+typedef struct A TA;\n+typedef struct A *PA;\n+typedef TA *PTA;\n+struct B {};\n+typedef struct B TB;\n+typedef struct B *PB;\n+typedef TB *PTB;\n+typedef int X[3][3][3];\n+\n+int\n+f1 (void *x, int z)\n+{\n+  struct A a, *pa1 = &a;\n+  TA *pa2 = &a;\n+  PA pa3 = &a;\n+  PTA pa4 = &a;\n+  memset (&a, 0, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memset (pa1, 0, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa2, 0, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa3, 0, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa4, 0, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa1, 0, sizeof (struct A *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pa2, 0, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pa3, 0, sizeof (PA));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pa4, 0, sizeof (__typeof (pa4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (&a, x, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memcpy (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa2, x, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa4, x, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa1, x, sizeof (struct A *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pa2, x, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pa3, x, sizeof (PA));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pa4, x, sizeof (__typeof (pa4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (x, &a, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memcpy (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa2, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa4, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa1, sizeof (struct A *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pa2, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pa3, sizeof (PA));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pa4, sizeof (__typeof (pa4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (&a, x, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memmove (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa2, x, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa4, x, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa1, x, sizeof (struct A *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pa2, x, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pa4, x, sizeof (__typeof (pa4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (x, &a, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memmove (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa2, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa4, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa1, sizeof (struct A *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pa2, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pa4, sizeof (__typeof (pa4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (&a, x, sizeof (&a));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  z += memcmp (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa2, x, sizeof pa2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa4, x, sizeof pa4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa1, x, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa2, x, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &a, sizeof (&a));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa2, sizeof pa2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa4, sizeof pa4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa1, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa2, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  // These are correct, no warning. \n+  memset (&a, 0, sizeof a);\n+  memset (&a, 0, sizeof (a));\n+  memset (&a, 0, sizeof (struct A));\n+  memset (&a, 0, sizeof (const struct A));\n+  memset (&a, 0, sizeof (volatile struct A));\n+  memset (&a, 0, sizeof (volatile const struct A));\n+  memset (&a, 0, sizeof (TA));\n+  memset (&a, 0, sizeof (__typeof (*&a)));\n+  memset (pa1, 0, sizeof (*pa1));\n+  memset (pa2, 0, sizeof (*pa3));\n+  memset (pa3, 0, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memset ((void *) &a, 0, sizeof (&a));\n+  memset ((char *) &a, 0, sizeof (&a));\n+  memset (&a, 0, sizeof (&a) + 0);\n+  memset (&a, 0, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memcpy (&a, x, sizeof a);\n+  memcpy (&a, x, sizeof (a));\n+  memcpy (&a, x, sizeof (struct A));\n+  memcpy (&a, x, sizeof (const struct A));\n+  memcpy (&a, x, sizeof (volatile struct A));\n+  memcpy (&a, x, sizeof (volatile const struct A));\n+  memcpy (&a, x, sizeof (TA));\n+  memcpy (&a, x, sizeof (__typeof (*&a)));\n+  memcpy (pa1, x, sizeof (*pa1));\n+  memcpy (pa2, x, sizeof (*pa3));\n+  memcpy (pa3, x, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy ((void *) &a, x, sizeof (&a));\n+  memcpy ((char *) &a, x, sizeof (&a));\n+  memcpy (&a, x, sizeof (&a) + 0);\n+  memcpy (&a, x, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memcpy (x, &a, sizeof a);\n+  memcpy (x, &a, sizeof (a));\n+  memcpy (x, &a, sizeof (struct A));\n+  memcpy (x, &a, sizeof (const struct A));\n+  memcpy (x, &a, sizeof (volatile struct A));\n+  memcpy (x, &a, sizeof (volatile const struct A));\n+  memcpy (x, &a, sizeof (TA));\n+  memcpy (x, &a, sizeof (__typeof (*&a)));\n+  memcpy (x, pa1, sizeof (*pa1));\n+  memcpy (x, pa2, sizeof (*pa3));\n+  memcpy (x, pa3, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy (x, (void *) &a, sizeof (&a));\n+  memcpy (x, (char *) &a, sizeof (&a));\n+  memcpy (x, &a, sizeof (&a) + 0);\n+  memcpy (x, &a, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memmove (&a, x, sizeof a);\n+  memmove (&a, x, sizeof (a));\n+  memmove (&a, x, sizeof (struct A));\n+  memmove (&a, x, sizeof (const struct A));\n+  memmove (&a, x, sizeof (volatile struct A));\n+  memmove (&a, x, sizeof (volatile const struct A));\n+  memmove (&a, x, sizeof (TA));\n+  memmove (&a, x, sizeof (__typeof (*&a)));\n+  memmove (pa1, x, sizeof (*pa1));\n+  memmove (pa2, x, sizeof (*pa3));\n+  memmove (pa3, x, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove ((void *) &a, x, sizeof (&a));\n+  memmove ((char *) &a, x, sizeof (&a));\n+  memmove (&a, x, sizeof (&a) + 0);\n+  memmove (&a, x, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memmove (x, &a, sizeof a);\n+  memmove (x, &a, sizeof (a));\n+  memmove (x, &a, sizeof (struct A));\n+  memmove (x, &a, sizeof (const struct A));\n+  memmove (x, &a, sizeof (volatile struct A));\n+  memmove (x, &a, sizeof (volatile const struct A));\n+  memmove (x, &a, sizeof (TA));\n+  memmove (x, &a, sizeof (__typeof (*&a)));\n+  memmove (x, pa1, sizeof (*pa1));\n+  memmove (x, pa2, sizeof (*pa3));\n+  memmove (x, pa3, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove (x, (void *) &a, sizeof (&a));\n+  memmove (x, (char *) &a, sizeof (&a));\n+  memmove (x, &a, sizeof (&a) + 0);\n+  memmove (x, &a, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  z += memcmp (&a, x, sizeof a);\n+  z += memcmp (&a, x, sizeof (a));\n+  z += memcmp (&a, x, sizeof (struct A));\n+  z += memcmp (&a, x, sizeof (const struct A));\n+  z += memcmp (&a, x, sizeof (volatile struct A));\n+  z += memcmp (&a, x, sizeof (volatile const struct A));\n+  z += memcmp (&a, x, sizeof (TA));\n+  z += memcmp (&a, x, sizeof (__typeof (*&a)));\n+  z += memcmp (pa1, x, sizeof (*pa1));\n+  z += memcmp (pa2, x, sizeof (*pa3));\n+  z += memcmp (pa3, x, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp ((void *) &a, x, sizeof (&a));\n+  z += memcmp ((char *) &a, x, sizeof (&a));\n+  z += memcmp (&a, x, sizeof (&a) + 0);\n+  z += memcmp (&a, x, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  z += memcmp (x, &a, sizeof a);\n+  z += memcmp (x, &a, sizeof (a));\n+  z += memcmp (x, &a, sizeof (struct A));\n+  z += memcmp (x, &a, sizeof (const struct A));\n+  z += memcmp (x, &a, sizeof (volatile struct A));\n+  z += memcmp (x, &a, sizeof (volatile const struct A));\n+  z += memcmp (x, &a, sizeof (TA));\n+  z += memcmp (x, &a, sizeof (__typeof (*&a)));\n+  z += memcmp (x, pa1, sizeof (*pa1));\n+  z += memcmp (x, pa2, sizeof (*pa3));\n+  z += memcmp (x, pa3, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp (x, (void *) &a, sizeof (&a));\n+  z += memcmp (x, (char *) &a, sizeof (&a));\n+  z += memcmp (x, &a, sizeof (&a) + 0);\n+  z += memcmp (x, &a, 0 + sizeof (&a));\n+\n+  return z;\n+}\n+\n+int\n+f2 (void *x, int z)\n+{\n+  struct B b, *pb1 = &b;\n+  TB *pb2 = &b;\n+  PB pb3 = &b;\n+  PTB pb4 = &b;\n+  memset (&b, 0, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memset (pb1, 0, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb2, 0, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb3, 0, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb4, 0, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb1, 0, sizeof (struct B *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pb2, 0, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pb3, 0, sizeof (PB));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pb4, 0, sizeof (__typeof (pb4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (&b, x, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memcpy (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb2, x, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb4, x, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb1, x, sizeof (struct B *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pb2, x, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pb3, x, sizeof (PB));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pb4, x, sizeof (__typeof (pb4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (x, &b, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memcpy (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb2, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb4, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb1, sizeof (struct B *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pb2, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pb3, sizeof (PB));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pb4, sizeof (__typeof (pb4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (&b, x, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memmove (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb2, x, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb4, x, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb1, x, sizeof (struct B *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pb2, x, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pb4, x, sizeof (__typeof (pb4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (x, &b, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memmove (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb2, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb4, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb1, sizeof (struct B *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pb2, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pb4, sizeof (__typeof (pb4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (&b, x, sizeof (&b));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  z += memcmp (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb2, x, sizeof pb2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb4, x, sizeof pb4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb1, x, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb2, x, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &b, sizeof (&b));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb2, sizeof pb2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb4, sizeof pb4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb1, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb2, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  // These are correct, no warning. \n+  memset (&b, 0, sizeof b);\n+  memset (&b, 0, sizeof (b));\n+  memset (&b, 0, sizeof (struct B));\n+  memset (&b, 0, sizeof (const struct B));\n+  memset (&b, 0, sizeof (volatile struct B));\n+  memset (&b, 0, sizeof (volatile const struct B));\n+  memset (&b, 0, sizeof (TB));\n+  memset (&b, 0, sizeof (__typeof (*&b)));\n+  memset (pb1, 0, sizeof (*pb1));\n+  memset (pb2, 0, sizeof (*pb3));\n+  memset (pb3, 0, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memset ((void *) &b, 0, sizeof (&b));\n+  memset ((char *) &b, 0, sizeof (&b));\n+  memset (&b, 0, sizeof (&b) + 0);\n+  memset (&b, 0, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memcpy (&b, x, sizeof b);\n+  memcpy (&b, x, sizeof (b));\n+  memcpy (&b, x, sizeof (struct B));\n+  memcpy (&b, x, sizeof (const struct B));\n+  memcpy (&b, x, sizeof (volatile struct B));\n+  memcpy (&b, x, sizeof (volatile const struct B));\n+  memcpy (&b, x, sizeof (TB));\n+  memcpy (&b, x, sizeof (__typeof (*&b)));\n+  memcpy (pb1, x, sizeof (*pb1));\n+  memcpy (pb2, x, sizeof (*pb3));\n+  memcpy (pb3, x, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy ((void *) &b, x, sizeof (&b));\n+  memcpy ((char *) &b, x, sizeof (&b));\n+  memcpy (&b, x, sizeof (&b) + 0);\n+  memcpy (&b, x, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memcpy (x, &b, sizeof b);\n+  memcpy (x, &b, sizeof (b));\n+  memcpy (x, &b, sizeof (struct B));\n+  memcpy (x, &b, sizeof (const struct B));\n+  memcpy (x, &b, sizeof (volatile struct B));\n+  memcpy (x, &b, sizeof (volatile const struct B));\n+  memcpy (x, &b, sizeof (TB));\n+  memcpy (x, &b, sizeof (__typeof (*&b)));\n+  memcpy (x, pb1, sizeof (*pb1));\n+  memcpy (x, pb2, sizeof (*pb3));\n+  memcpy (x, pb3, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy (x, (void *) &b, sizeof (&b));\n+  memcpy (x, (char *) &b, sizeof (&b));\n+  memcpy (x, &b, sizeof (&b) + 0);\n+  memcpy (x, &b, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memmove (&b, x, sizeof b);\n+  memmove (&b, x, sizeof (b));\n+  memmove (&b, x, sizeof (struct B));\n+  memmove (&b, x, sizeof (const struct B));\n+  memmove (&b, x, sizeof (volatile struct B));\n+  memmove (&b, x, sizeof (volatile const struct B));\n+  memmove (&b, x, sizeof (TB));\n+  memmove (&b, x, sizeof (__typeof (*&b)));\n+  memmove (pb1, x, sizeof (*pb1));\n+  memmove (pb2, x, sizeof (*pb3));\n+  memmove (pb3, x, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove ((void *) &b, x, sizeof (&b));\n+  memmove ((char *) &b, x, sizeof (&b));\n+  memmove (&b, x, sizeof (&b) + 0);\n+  memmove (&b, x, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memmove (x, &b, sizeof b);\n+  memmove (x, &b, sizeof (b));\n+  memmove (x, &b, sizeof (struct B));\n+  memmove (x, &b, sizeof (const struct B));\n+  memmove (x, &b, sizeof (volatile struct B));\n+  memmove (x, &b, sizeof (volatile const struct B));\n+  memmove (x, &b, sizeof (TB));\n+  memmove (x, &b, sizeof (__typeof (*&b)));\n+  memmove (x, pb1, sizeof (*pb1));\n+  memmove (x, pb2, sizeof (*pb3));\n+  memmove (x, pb3, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove (x, (void *) &b, sizeof (&b));\n+  memmove (x, (char *) &b, sizeof (&b));\n+  memmove (x, &b, sizeof (&b) + 0);\n+  memmove (x, &b, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  z += memcmp (&b, x, sizeof b);\n+  z += memcmp (&b, x, sizeof (b));\n+  z += memcmp (&b, x, sizeof (struct B));\n+  z += memcmp (&b, x, sizeof (const struct B));\n+  z += memcmp (&b, x, sizeof (volatile struct B));\n+  z += memcmp (&b, x, sizeof (volatile const struct B));\n+  z += memcmp (&b, x, sizeof (TB));\n+  z += memcmp (&b, x, sizeof (__typeof (*&b)));\n+  z += memcmp (pb1, x, sizeof (*pb1));\n+  z += memcmp (pb2, x, sizeof (*pb3));\n+  z += memcmp (pb3, x, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp ((void *) &b, x, sizeof (&b));\n+  z += memcmp ((char *) &b, x, sizeof (&b));\n+  z += memcmp (&b, x, sizeof (&b) + 0);\n+  z += memcmp (&b, x, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  z += memcmp (x, &b, sizeof b);\n+  z += memcmp (x, &b, sizeof (b));\n+  z += memcmp (x, &b, sizeof (struct B));\n+  z += memcmp (x, &b, sizeof (const struct B));\n+  z += memcmp (x, &b, sizeof (volatile struct B));\n+  z += memcmp (x, &b, sizeof (volatile const struct B));\n+  z += memcmp (x, &b, sizeof (TB));\n+  z += memcmp (x, &b, sizeof (__typeof (*&b)));\n+  z += memcmp (x, pb1, sizeof (*pb1));\n+  z += memcmp (x, pb2, sizeof (*pb3));\n+  z += memcmp (x, pb3, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp (x, (void *) &b, sizeof (&b));\n+  z += memcmp (x, (char *) &b, sizeof (&b));\n+  z += memcmp (x, &b, sizeof (&b) + 0);\n+  z += memcmp (x, &b, 0 + sizeof (&b));\n+\n+  return z;\n+}\n+\n+int\n+f3 (void *x, char *y, int z, X w)\n+{\n+  unsigned char *y1 = (unsigned char *) __builtin_alloca (z + 16);\n+  char buf1[7];\n+  signed char buf2[z + 32];\n+  long buf3[17];\n+  int *buf4[9];\n+  signed char *y2 = buf2;\n+  char c;\n+  char *y3;\n+  memset (y, 0, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memset (y1, 0, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memset (y2, 0, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memset (&c, 0, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memset (w, 0, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  memcpy (y, x, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memcpy (y1, x, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memcpy (y2, x, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memcpy (&c, x, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memcpy (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  memcpy (x, y, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memcpy (x, y1, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memcpy (x, y2, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memcpy (x, &c, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memcpy (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+\n+  memmove (y, x, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memmove (y1, x, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memmove (y2, x, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memmove (&c, x, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memmove (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  memmove (x, y, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memmove (x, y1, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memmove (x, y2, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memmove (x, &c, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memmove (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+\n+  z += memcmp (y, x, sizeof (y));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += memcmp (y1, x, sizeof (y1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += memcmp (y2, x, sizeof (y2));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += memcmp (&c, x, sizeof (&c));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  z += memcmp (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  z += memcmp (x, y, sizeof (y));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y1, sizeof (y1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y2, sizeof (y2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, &c, sizeof (&c));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  z += memcmp (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+\n+  // These are correct, no warning. \n+  memset (y, 0, sizeof (*y));\n+  memset (y1, 0, sizeof (*y2));\n+  memset (buf1, 0, sizeof buf1);\n+  memset (buf3, 0, sizeof (buf3));\n+  memset (&buf3[0], 0, sizeof (buf3));\n+  memset (&buf4[0], 0, sizeof (buf4));\n+  memset (w, 0, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memset ((void *) y, 0, sizeof (y));\n+  memset ((char *) y1, 0, sizeof (y2));\n+  memset (y, 0, sizeof (y) + 0);\n+  memset (y1, 0, 0 + sizeof (y2));\n+  memset ((void *) &c, 0, sizeof (&c));\n+  memset ((signed char *) &c, 0, sizeof (&c));\n+  memset (&c, 0, sizeof (&c) + 0);\n+  memset (&c, 0, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memcpy (y, x, sizeof (*y));\n+  memcpy (y1, x, sizeof (*y2));\n+  memcpy (buf1, x, sizeof buf1);\n+  memcpy (buf3, x, sizeof (buf3));\n+  memcpy (&buf3[0], x, sizeof (buf3));\n+  memcpy (&buf4[0], x, sizeof (buf4));\n+  memcpy (&y3, y, sizeof (y3));\n+  memcpy ((char *) &y3, y, sizeof (y3));\n+  memcpy (w, x, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy ((void *) y, x, sizeof (y));\n+  memcpy ((char *) y1, x, sizeof (y2));\n+  memcpy (y, x, sizeof (y) + 0);\n+  memcpy (y1, x, 0 + sizeof (y2));\n+  memcpy ((void *) &c, x, sizeof (&c));\n+  memcpy ((signed char *) &c, x, sizeof (&c));\n+  memcpy (&c, x, sizeof (&c) + 0);\n+  memcpy (&c, x, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memcpy (x, y, sizeof (*y));\n+  memcpy (x, y1, sizeof (*y2));\n+  memcpy (x, buf1, sizeof buf1);\n+  memcpy (x, buf3, sizeof (buf3));\n+  memcpy (x, &buf3[0], sizeof (buf3));\n+  memcpy (x, &buf4[0], sizeof (buf4));\n+  memcpy (y, &y3, sizeof (y3));\n+  memcpy (y, (char *) &y3, sizeof (y3));\n+  memcpy (x, w, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy (x, (void *) y, sizeof (y));\n+  memcpy (x, (char *) y1, sizeof (y2));\n+  memcpy (x, y, sizeof (y) + 0);\n+  memcpy (x, y1, 0 + sizeof (y2));\n+  memcpy (x, (void *) &c, sizeof (&c));\n+  memcpy (x, (signed char *) &c, sizeof (&c));\n+  memcpy (x, &c, sizeof (&c) + 0);\n+  memcpy (x, &c, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memmove (y, x, sizeof (*y));\n+  memmove (y1, x, sizeof (*y2));\n+  memmove (buf1, x, sizeof buf1);\n+  memmove (buf3, x, sizeof (buf3));\n+  memmove (&buf3[0], x, sizeof (buf3));\n+  memmove (&buf4[0], x, sizeof (buf4));\n+  memmove (&y3, y, sizeof (y3));\n+  memmove ((char *) &y3, y, sizeof (y3));\n+  memmove (w, x, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove ((void *) y, x, sizeof (y));\n+  memmove ((char *) y1, x, sizeof (y2));\n+  memmove (y, x, sizeof (y) + 0);\n+  memmove (y1, x, 0 + sizeof (y2));\n+  memmove ((void *) &c, x, sizeof (&c));\n+  memmove ((signed char *) &c, x, sizeof (&c));\n+  memmove (&c, x, sizeof (&c) + 0);\n+  memmove (&c, x, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memmove (x, y, sizeof (*y));\n+  memmove (x, y1, sizeof (*y2));\n+  memmove (x, buf1, sizeof buf1);\n+  memmove (x, buf3, sizeof (buf3));\n+  memmove (x, &buf3[0], sizeof (buf3));\n+  memmove (x, &buf4[0], sizeof (buf4));\n+  memmove (y, &y3, sizeof (y3));\n+  memmove (y, (char *) &y3, sizeof (y3));\n+  memmove (x, w, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove (x, (void *) y, sizeof (y));\n+  memmove (x, (char *) y1, sizeof (y2));\n+  memmove (x, y, sizeof (y) + 0);\n+  memmove (x, y1, 0 + sizeof (y2));\n+  memmove (x, (void *) &c, sizeof (&c));\n+  memmove (x, (signed char *) &c, sizeof (&c));\n+  memmove (x, &c, sizeof (&c) + 0);\n+  memmove (x, &c, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  z += memcmp (y, x, sizeof (*y));\n+  z += memcmp (y1, x, sizeof (*y2));\n+  z += memcmp (buf1, x, sizeof buf1);\n+  z += memcmp (buf3, x, sizeof (buf3));\n+  z += memcmp (&buf3[0], x, sizeof (buf3));\n+  z += memcmp (&buf4[0], x, sizeof (buf4));\n+  z += memcmp (&y3, y, sizeof (y3));\n+  z += memcmp ((char *) &y3, y, sizeof (y3));\n+  z += memcmp (w, x, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp ((void *) y, x, sizeof (y));\n+  z += memcmp ((char *) y1, x, sizeof (y2));\n+  z += memcmp (y, x, sizeof (y) + 0);\n+  z += memcmp (y1, x, 0 + sizeof (y2));\n+  z += memcmp ((void *) &c, x, sizeof (&c));\n+  z += memcmp ((signed char *) &c, x, sizeof (&c));\n+  z += memcmp (&c, x, sizeof (&c) + 0);\n+  z += memcmp (&c, x, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  z += memcmp (x, y, sizeof (*y));\n+  z += memcmp (x, y1, sizeof (*y2));\n+  z += memcmp (x, buf1, sizeof buf1);\n+  z += memcmp (x, buf3, sizeof (buf3));\n+  z += memcmp (x, &buf3[0], sizeof (buf3));\n+  z += memcmp (x, &buf4[0], sizeof (buf4));\n+  z += memcmp (y, &y3, sizeof (y3));\n+  z += memcmp (y, (char *) &y3, sizeof (y3));\n+  z += memcmp (x, w, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp (x, (void *) y, sizeof (y));\n+  z += memcmp (x, (char *) y1, sizeof (y2));\n+  z += memcmp (x, y, sizeof (y) + 0);\n+  z += memcmp (x, y1, 0 + sizeof (y2));\n+  z += memcmp (x, (void *) &c, sizeof (&c));\n+  z += memcmp (x, (signed char *) &c, sizeof (&c));\n+  z += memcmp (x, &c, sizeof (&c) + 0);\n+  z += memcmp (x, &c, 0 + sizeof (&c));\n+\n+  return z;\n+}\n+\n+int\n+f4 (char *x, char **y, int z)\n+{\n+  const char *s1 = \"foobarbaz\";\n+  const char *s2 = \"abcde12345678\";\n+  strncpy (x, s1, sizeof (s1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  strncat (x, s2, sizeof (s2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  y[0] = strndup (s1, sizeof (s1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s1));   // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s2));   // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+\n+  // These are correct, no warning. \n+  const char s3[] = \"foobarbaz\";\n+  const char s4[] = \"abcde12345678\";\n+  strncpy (x, s3, sizeof (s3));\n+  strncat (x, s4, sizeof (s4));\n+  y[1] = strndup (s3, sizeof (s3));\n+  z += strncmp (s3, s4, sizeof (s3));\n+  z += strncmp (s3, s4, sizeof (s4));\n+  z += strncasecmp (s3, s4, sizeof (s3));\n+  z += strncasecmp (s3, s4, sizeof (s4));\n+\n+  return z;\n+}\n+\n+// { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" }"}, {"sha": "d5a29d8f582f0686779916dd2ce07e85f02693be", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess2.C", "status": "added", "additions": 716, "deletions": 0, "changes": 716, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,716 @@\n+// Test -Wsizeof-pointer-memaccess warnings.\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+// Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n+// { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n+// { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }\n+\n+extern \"C\" {\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memset (void *, int, size_t);\n+extern void *memcpy (void *__restrict, const void *__restrict, size_t);\n+extern void *memmove (void *__restrict, const void *__restrict, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *strncpy (char *__restrict, const char *__restrict, size_t);\n+extern char *strncat (char *__restrict, const char *__restrict, size_t);\n+extern char *strndup (const char *, size_t);\n+extern int strncmp (const char *, const char *, size_t);\n+extern int strncasecmp (const char *, const char *, size_t);\n+\n+#ifdef __OPTIMIZE__\n+# define bos(ptr) __builtin_object_size (ptr, 1)\n+# define bos0(ptr) __builtin_object_size (ptr, 0)\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memset (void *dest, int c, size_t len)\n+{\n+  return __builtin___memset_chk (dest, c, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memcpy (void *__restrict dest, const void *__restrict src, size_t len)\n+{\n+  return __builtin___memcpy_chk (dest, src, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline void *\n+memmove (void *dest, const void *src, size_t len)\n+{\n+  return __builtin___memmove_chk (dest, src, len, bos0 (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+strncpy (char *__restrict dest, const char *__restrict src, size_t len)\n+{\n+  return __builtin___strncpy_chk (dest, src, len, bos (dest));\n+}\n+\n+__attribute__((__always_inline__, __gnu_inline__, __artificial__))\n+extern inline char *\n+strncat (char *dest, const char *src, size_t len)\n+{\n+  return __builtin___strncat_chk (dest, src, len, bos (dest));\n+}\n+#endif\n+\n+}\n+\n+struct A { short a, b; int c, d; long e, f; };\n+typedef struct A TA;\n+typedef struct A *PA;\n+typedef TA *PTA;\n+struct B {};\n+typedef struct B TB;\n+typedef struct B *PB;\n+typedef TB *PTB;\n+typedef int X[3][3][3];\n+\n+template <int N>\n+int\n+f1 (void *x, int z)\n+{\n+  struct A a, *pa1 = &a;\n+  TA *pa2 = &a;\n+  PA pa3 = &a;\n+  PTA pa4 = &a;\n+  memset (&a, 0, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memset (pa1, 0, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa2, 0, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa3, 0, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa4, 0, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pa1, 0, sizeof (struct A *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pa2, 0, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pa3, 0, sizeof (PA));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pa4, 0, sizeof (__typeof (pa4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (&a, x, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memcpy (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa2, x, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa4, x, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pa1, x, sizeof (struct A *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pa2, x, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pa3, x, sizeof (PA));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pa4, x, sizeof (__typeof (pa4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (x, &a, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memcpy (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa2, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa4, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pa1, sizeof (struct A *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pa2, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pa3, sizeof (PA));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pa4, sizeof (__typeof (pa4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (&a, x, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memmove (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa2, x, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa4, x, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pa1, x, sizeof (struct A *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pa2, x, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pa4, x, sizeof (__typeof (pa4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (x, &a, sizeof (&a));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memmove (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa2, sizeof pa2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa4, sizeof pa4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pa1, sizeof (struct A *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pa2, sizeof (PTA));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pa4, sizeof (__typeof (pa4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (&a, x, sizeof (&a));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  z += memcmp (pa1, x, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa2, x, sizeof pa2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa3, x, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa4, x, sizeof pa4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pa1, x, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa2, x, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pa3, x, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &a, sizeof (&a));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pa1, sizeof (pa1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa2, sizeof pa2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa3, sizeof (pa3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa4, sizeof pa4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pa1, sizeof (struct A *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa2, sizeof (PTA));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pa3, sizeof (PA));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  // These are correct, no warning. \n+  memset (&a, 0, sizeof a);\n+  memset (&a, 0, sizeof (a));\n+  memset (&a, 0, sizeof (struct A));\n+  memset (&a, 0, sizeof (const struct A));\n+  memset (&a, 0, sizeof (volatile struct A));\n+  memset (&a, 0, sizeof (volatile const struct A));\n+  memset (&a, 0, sizeof (TA));\n+  memset (&a, 0, sizeof (__typeof (*&a)));\n+  memset (pa1, 0, sizeof (*pa1));\n+  memset (pa2, 0, sizeof (*pa3));\n+  memset (pa3, 0, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memset ((void *) &a, 0, sizeof (&a));\n+  memset ((char *) &a, 0, sizeof (&a));\n+  memset (&a, 0, sizeof (&a) + 0);\n+  memset (&a, 0, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memcpy (&a, x, sizeof a);\n+  memcpy (&a, x, sizeof (a));\n+  memcpy (&a, x, sizeof (struct A));\n+  memcpy (&a, x, sizeof (const struct A));\n+  memcpy (&a, x, sizeof (volatile struct A));\n+  memcpy (&a, x, sizeof (volatile const struct A));\n+  memcpy (&a, x, sizeof (TA));\n+  memcpy (&a, x, sizeof (__typeof (*&a)));\n+  memcpy (pa1, x, sizeof (*pa1));\n+  memcpy (pa2, x, sizeof (*pa3));\n+  memcpy (pa3, x, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy ((void *) &a, x, sizeof (&a));\n+  memcpy ((char *) &a, x, sizeof (&a));\n+  memcpy (&a, x, sizeof (&a) + 0);\n+  memcpy (&a, x, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memcpy (x, &a, sizeof a);\n+  memcpy (x, &a, sizeof (a));\n+  memcpy (x, &a, sizeof (struct A));\n+  memcpy (x, &a, sizeof (const struct A));\n+  memcpy (x, &a, sizeof (volatile struct A));\n+  memcpy (x, &a, sizeof (volatile const struct A));\n+  memcpy (x, &a, sizeof (TA));\n+  memcpy (x, &a, sizeof (__typeof (*&a)));\n+  memcpy (x, pa1, sizeof (*pa1));\n+  memcpy (x, pa2, sizeof (*pa3));\n+  memcpy (x, pa3, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy (x, (void *) &a, sizeof (&a));\n+  memcpy (x, (char *) &a, sizeof (&a));\n+  memcpy (x, &a, sizeof (&a) + 0);\n+  memcpy (x, &a, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memmove (&a, x, sizeof a);\n+  memmove (&a, x, sizeof (a));\n+  memmove (&a, x, sizeof (struct A));\n+  memmove (&a, x, sizeof (const struct A));\n+  memmove (&a, x, sizeof (volatile struct A));\n+  memmove (&a, x, sizeof (volatile const struct A));\n+  memmove (&a, x, sizeof (TA));\n+  memmove (&a, x, sizeof (__typeof (*&a)));\n+  memmove (pa1, x, sizeof (*pa1));\n+  memmove (pa2, x, sizeof (*pa3));\n+  memmove (pa3, x, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove ((void *) &a, x, sizeof (&a));\n+  memmove ((char *) &a, x, sizeof (&a));\n+  memmove (&a, x, sizeof (&a) + 0);\n+  memmove (&a, x, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  memmove (x, &a, sizeof a);\n+  memmove (x, &a, sizeof (a));\n+  memmove (x, &a, sizeof (struct A));\n+  memmove (x, &a, sizeof (const struct A));\n+  memmove (x, &a, sizeof (volatile struct A));\n+  memmove (x, &a, sizeof (volatile const struct A));\n+  memmove (x, &a, sizeof (TA));\n+  memmove (x, &a, sizeof (__typeof (*&a)));\n+  memmove (x, pa1, sizeof (*pa1));\n+  memmove (x, pa2, sizeof (*pa3));\n+  memmove (x, pa3, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove (x, (void *) &a, sizeof (&a));\n+  memmove (x, (char *) &a, sizeof (&a));\n+  memmove (x, &a, sizeof (&a) + 0);\n+  memmove (x, &a, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  z += memcmp (&a, x, sizeof a);\n+  z += memcmp (&a, x, sizeof (a));\n+  z += memcmp (&a, x, sizeof (struct A));\n+  z += memcmp (&a, x, sizeof (const struct A));\n+  z += memcmp (&a, x, sizeof (volatile struct A));\n+  z += memcmp (&a, x, sizeof (volatile const struct A));\n+  z += memcmp (&a, x, sizeof (TA));\n+  z += memcmp (&a, x, sizeof (__typeof (*&a)));\n+  z += memcmp (pa1, x, sizeof (*pa1));\n+  z += memcmp (pa2, x, sizeof (*pa3));\n+  z += memcmp (pa3, x, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp ((void *) &a, x, sizeof (&a));\n+  z += memcmp ((char *) &a, x, sizeof (&a));\n+  z += memcmp (&a, x, sizeof (&a) + 0);\n+  z += memcmp (&a, x, 0 + sizeof (&a));\n+\n+  // These are correct, no warning. \n+  z += memcmp (x, &a, sizeof a);\n+  z += memcmp (x, &a, sizeof (a));\n+  z += memcmp (x, &a, sizeof (struct A));\n+  z += memcmp (x, &a, sizeof (const struct A));\n+  z += memcmp (x, &a, sizeof (volatile struct A));\n+  z += memcmp (x, &a, sizeof (volatile const struct A));\n+  z += memcmp (x, &a, sizeof (TA));\n+  z += memcmp (x, &a, sizeof (__typeof (*&a)));\n+  z += memcmp (x, pa1, sizeof (*pa1));\n+  z += memcmp (x, pa2, sizeof (*pa3));\n+  z += memcmp (x, pa3, sizeof (__typeof (*pa3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp (x, (void *) &a, sizeof (&a));\n+  z += memcmp (x, (char *) &a, sizeof (&a));\n+  z += memcmp (x, &a, sizeof (&a) + 0);\n+  z += memcmp (x, &a, 0 + sizeof (&a));\n+\n+  return z;\n+}\n+\n+template <int N>\n+int\n+f2 (void *x, int z)\n+{\n+  struct B b, *pb1 = &b;\n+  TB *pb2 = &b;\n+  PB pb3 = &b;\n+  PTB pb4 = &b;\n+  memset (&b, 0, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memset (pb1, 0, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb2, 0, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb3, 0, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb4, 0, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memset (pb1, 0, sizeof (struct B *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pb2, 0, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pb3, 0, sizeof (PB));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memset (pb4, 0, sizeof (__typeof (pb4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (&b, x, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memcpy (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb2, x, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb4, x, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memcpy (pb1, x, sizeof (struct B *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pb2, x, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pb3, x, sizeof (PB));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (pb4, x, sizeof (__typeof (pb4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memcpy (x, &b, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memcpy (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb2, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb4, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memcpy (x, pb1, sizeof (struct B *));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pb2, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pb3, sizeof (PB));\t\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memcpy (x, pb4, sizeof (__typeof (pb4))); // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (&b, x, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memmove (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb2, x, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb4, x, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  memmove (pb1, x, sizeof (struct B *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pb2, x, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (pb4, x, sizeof (__typeof (pb4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  memmove (x, &b, sizeof (&b));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memmove (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb2, sizeof pb2);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb4, sizeof pb4);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  memmove (x, pb1, sizeof (struct B *));    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pb2, sizeof (PTB));    \t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  memmove (x, pb4, sizeof (__typeof (pb4)));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (&b, x, sizeof (&b));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  z += memcmp (pb1, x, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb2, x, sizeof pb2);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb3, x, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb4, x, sizeof pb4);\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+  z += memcmp (pb1, x, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb2, x, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (pb3, x, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the destination; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  z += memcmp (x, &b, sizeof (&b));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  z += memcmp (x, pb1, sizeof (pb1));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb2, sizeof pb2);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb3, sizeof (pb3));\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb4, sizeof pb4);\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+  z += memcmp (x, pb1, sizeof (struct B *));// { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb2, sizeof (PTB));       // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+  z += memcmp (x, pb3, sizeof (PB));\t    // { dg-warning \"call is the same pointer type \\[^\\n\\r\\]* as the source; expected \\[^\\n\\r\\]* or an explicit length\" }\n+\n+  // These are correct, no warning. \n+  memset (&b, 0, sizeof b);\n+  memset (&b, 0, sizeof (b));\n+  memset (&b, 0, sizeof (struct B));\n+  memset (&b, 0, sizeof (const struct B));\n+  memset (&b, 0, sizeof (volatile struct B));\n+  memset (&b, 0, sizeof (volatile const struct B));\n+  memset (&b, 0, sizeof (TB));\n+  memset (&b, 0, sizeof (__typeof (*&b)));\n+  memset (pb1, 0, sizeof (*pb1));\n+  memset (pb2, 0, sizeof (*pb3));\n+  memset (pb3, 0, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memset ((void *) &b, 0, sizeof (&b));\n+  memset ((char *) &b, 0, sizeof (&b));\n+  memset (&b, 0, sizeof (&b) + 0);\n+  memset (&b, 0, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memcpy (&b, x, sizeof b);\n+  memcpy (&b, x, sizeof (b));\n+  memcpy (&b, x, sizeof (struct B));\n+  memcpy (&b, x, sizeof (const struct B));\n+  memcpy (&b, x, sizeof (volatile struct B));\n+  memcpy (&b, x, sizeof (volatile const struct B));\n+  memcpy (&b, x, sizeof (TB));\n+  memcpy (&b, x, sizeof (__typeof (*&b)));\n+  memcpy (pb1, x, sizeof (*pb1));\n+  memcpy (pb2, x, sizeof (*pb3));\n+  memcpy (pb3, x, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy ((void *) &b, x, sizeof (&b));\n+  memcpy ((char *) &b, x, sizeof (&b));\n+  memcpy (&b, x, sizeof (&b) + 0);\n+  memcpy (&b, x, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memcpy (x, &b, sizeof b);\n+  memcpy (x, &b, sizeof (b));\n+  memcpy (x, &b, sizeof (struct B));\n+  memcpy (x, &b, sizeof (const struct B));\n+  memcpy (x, &b, sizeof (volatile struct B));\n+  memcpy (x, &b, sizeof (volatile const struct B));\n+  memcpy (x, &b, sizeof (TB));\n+  memcpy (x, &b, sizeof (__typeof (*&b)));\n+  memcpy (x, pb1, sizeof (*pb1));\n+  memcpy (x, pb2, sizeof (*pb3));\n+  memcpy (x, pb3, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy (x, (void *) &b, sizeof (&b));\n+  memcpy (x, (char *) &b, sizeof (&b));\n+  memcpy (x, &b, sizeof (&b) + 0);\n+  memcpy (x, &b, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memmove (&b, x, sizeof b);\n+  memmove (&b, x, sizeof (b));\n+  memmove (&b, x, sizeof (struct B));\n+  memmove (&b, x, sizeof (const struct B));\n+  memmove (&b, x, sizeof (volatile struct B));\n+  memmove (&b, x, sizeof (volatile const struct B));\n+  memmove (&b, x, sizeof (TB));\n+  memmove (&b, x, sizeof (__typeof (*&b)));\n+  memmove (pb1, x, sizeof (*pb1));\n+  memmove (pb2, x, sizeof (*pb3));\n+  memmove (pb3, x, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove ((void *) &b, x, sizeof (&b));\n+  memmove ((char *) &b, x, sizeof (&b));\n+  memmove (&b, x, sizeof (&b) + 0);\n+  memmove (&b, x, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  memmove (x, &b, sizeof b);\n+  memmove (x, &b, sizeof (b));\n+  memmove (x, &b, sizeof (struct B));\n+  memmove (x, &b, sizeof (const struct B));\n+  memmove (x, &b, sizeof (volatile struct B));\n+  memmove (x, &b, sizeof (volatile const struct B));\n+  memmove (x, &b, sizeof (TB));\n+  memmove (x, &b, sizeof (__typeof (*&b)));\n+  memmove (x, pb1, sizeof (*pb1));\n+  memmove (x, pb2, sizeof (*pb3));\n+  memmove (x, pb3, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove (x, (void *) &b, sizeof (&b));\n+  memmove (x, (char *) &b, sizeof (&b));\n+  memmove (x, &b, sizeof (&b) + 0);\n+  memmove (x, &b, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  z += memcmp (&b, x, sizeof b);\n+  z += memcmp (&b, x, sizeof (b));\n+  z += memcmp (&b, x, sizeof (struct B));\n+  z += memcmp (&b, x, sizeof (const struct B));\n+  z += memcmp (&b, x, sizeof (volatile struct B));\n+  z += memcmp (&b, x, sizeof (volatile const struct B));\n+  z += memcmp (&b, x, sizeof (TB));\n+  z += memcmp (&b, x, sizeof (__typeof (*&b)));\n+  z += memcmp (pb1, x, sizeof (*pb1));\n+  z += memcmp (pb2, x, sizeof (*pb3));\n+  z += memcmp (pb3, x, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp ((void *) &b, x, sizeof (&b));\n+  z += memcmp ((char *) &b, x, sizeof (&b));\n+  z += memcmp (&b, x, sizeof (&b) + 0);\n+  z += memcmp (&b, x, 0 + sizeof (&b));\n+\n+  // These are correct, no warning. \n+  z += memcmp (x, &b, sizeof b);\n+  z += memcmp (x, &b, sizeof (b));\n+  z += memcmp (x, &b, sizeof (struct B));\n+  z += memcmp (x, &b, sizeof (const struct B));\n+  z += memcmp (x, &b, sizeof (volatile struct B));\n+  z += memcmp (x, &b, sizeof (volatile const struct B));\n+  z += memcmp (x, &b, sizeof (TB));\n+  z += memcmp (x, &b, sizeof (__typeof (*&b)));\n+  z += memcmp (x, pb1, sizeof (*pb1));\n+  z += memcmp (x, pb2, sizeof (*pb3));\n+  z += memcmp (x, pb3, sizeof (__typeof (*pb3)));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp (x, (void *) &b, sizeof (&b));\n+  z += memcmp (x, (char *) &b, sizeof (&b));\n+  z += memcmp (x, &b, sizeof (&b) + 0);\n+  z += memcmp (x, &b, 0 + sizeof (&b));\n+\n+  return z;\n+}\n+\n+template <int N>\n+int\n+f3 (void *x, char *y, int z, X w)\n+{\n+  unsigned char *y1 = (unsigned char *) __builtin_alloca (z + 16);\n+  char buf1[7];\n+  signed char buf2[z + 32];\n+  long buf3[17];\n+  int *buf4[9];\n+  signed char *y2 = buf2;\n+  char c;\n+  char *y3;\n+  memset (y, 0, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memset (y1, 0, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memset (y2, 0, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memset (&c, 0, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memset (w, 0, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  memcpy (y, x, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memcpy (y1, x, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memcpy (y2, x, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memcpy (&c, x, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memcpy (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  memcpy (x, y, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memcpy (x, y1, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memcpy (x, y2, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memcpy (x, &c, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memcpy (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+\n+  memmove (y, x, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memmove (y1, x, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memmove (y2, x, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  memmove (&c, x, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  memmove (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  memmove (x, y, sizeof (y));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memmove (x, y1, sizeof (y1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memmove (x, y2, sizeof (y2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  memmove (x, &c, sizeof (&c));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  memmove (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+\n+  z += memcmp (y, x, sizeof (y));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += memcmp (y1, x, sizeof (y1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += memcmp (y2, x, sizeof (y2));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += memcmp (&c, x, sizeof (&c));\t    // { dg-warning \"call is the same expression as the destination; did you mean to remove the addressof\" }\n+  z += memcmp (w, x, sizeof w);\t\t    // { dg-warning \"call is the same expression as the destination; did you mean to dereference it\" }\n+\n+  z += memcmp (x, y, sizeof (y));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y1, sizeof (y1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, y2, sizeof (y2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += memcmp (x, &c, sizeof (&c));\t    // { dg-warning \"call is the same expression as the source; did you mean to remove the addressof\" }\n+  z += memcmp (x, w, sizeof w);\t\t    // { dg-warning \"call is the same expression as the source; did you mean to dereference it\" }\n+\n+  // These are correct, no warning. \n+  memset (y, 0, sizeof (*y));\n+  memset (y1, 0, sizeof (*y2));\n+  memset (buf1, 0, sizeof buf1);\n+  memset (buf3, 0, sizeof (buf3));\n+  memset (&buf3[0], 0, sizeof (buf3));\n+  memset (&buf4[0], 0, sizeof (buf4));\n+  memset (w, 0, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memset ((void *) y, 0, sizeof (y));\n+  memset ((char *) y1, 0, sizeof (y2));\n+  memset (y, 0, sizeof (y) + 0);\n+  memset (y1, 0, 0 + sizeof (y2));\n+  memset ((void *) &c, 0, sizeof (&c));\n+  memset ((signed char *) &c, 0, sizeof (&c));\n+  memset (&c, 0, sizeof (&c) + 0);\n+  memset (&c, 0, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memcpy (y, x, sizeof (*y));\n+  memcpy (y1, x, sizeof (*y2));\n+  memcpy (buf1, x, sizeof buf1);\n+  memcpy (buf3, x, sizeof (buf3));\n+  memcpy (&buf3[0], x, sizeof (buf3));\n+  memcpy (&buf4[0], x, sizeof (buf4));\n+  memcpy (&y3, y, sizeof (y3));\n+  memcpy ((char *) &y3, y, sizeof (y3));\n+  memcpy (w, x, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy ((void *) y, x, sizeof (y));\n+  memcpy ((char *) y1, x, sizeof (y2));\n+  memcpy (y, x, sizeof (y) + 0);\n+  memcpy (y1, x, 0 + sizeof (y2));\n+  memcpy ((void *) &c, x, sizeof (&c));\n+  memcpy ((signed char *) &c, x, sizeof (&c));\n+  memcpy (&c, x, sizeof (&c) + 0);\n+  memcpy (&c, x, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memcpy (x, y, sizeof (*y));\n+  memcpy (x, y1, sizeof (*y2));\n+  memcpy (x, buf1, sizeof buf1);\n+  memcpy (x, buf3, sizeof (buf3));\n+  memcpy (x, &buf3[0], sizeof (buf3));\n+  memcpy (x, &buf4[0], sizeof (buf4));\n+  memcpy (y, &y3, sizeof (y3));\n+  memcpy (y, (char *) &y3, sizeof (y3));\n+  memcpy (x, w, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memcpy (x, (void *) y, sizeof (y));\n+  memcpy (x, (char *) y1, sizeof (y2));\n+  memcpy (x, y, sizeof (y) + 0);\n+  memcpy (x, y1, 0 + sizeof (y2));\n+  memcpy (x, (void *) &c, sizeof (&c));\n+  memcpy (x, (signed char *) &c, sizeof (&c));\n+  memcpy (x, &c, sizeof (&c) + 0);\n+  memcpy (x, &c, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memmove (y, x, sizeof (*y));\n+  memmove (y1, x, sizeof (*y2));\n+  memmove (buf1, x, sizeof buf1);\n+  memmove (buf3, x, sizeof (buf3));\n+  memmove (&buf3[0], x, sizeof (buf3));\n+  memmove (&buf4[0], x, sizeof (buf4));\n+  memmove (&y3, y, sizeof (y3));\n+  memmove ((char *) &y3, y, sizeof (y3));\n+  memmove (w, x, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove ((void *) y, x, sizeof (y));\n+  memmove ((char *) y1, x, sizeof (y2));\n+  memmove (y, x, sizeof (y) + 0);\n+  memmove (y1, x, 0 + sizeof (y2));\n+  memmove ((void *) &c, x, sizeof (&c));\n+  memmove ((signed char *) &c, x, sizeof (&c));\n+  memmove (&c, x, sizeof (&c) + 0);\n+  memmove (&c, x, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  memmove (x, y, sizeof (*y));\n+  memmove (x, y1, sizeof (*y2));\n+  memmove (x, buf1, sizeof buf1);\n+  memmove (x, buf3, sizeof (buf3));\n+  memmove (x, &buf3[0], sizeof (buf3));\n+  memmove (x, &buf4[0], sizeof (buf4));\n+  memmove (y, &y3, sizeof (y3));\n+  memmove (y, (char *) &y3, sizeof (y3));\n+  memmove (x, w, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  memmove (x, (void *) y, sizeof (y));\n+  memmove (x, (char *) y1, sizeof (y2));\n+  memmove (x, y, sizeof (y) + 0);\n+  memmove (x, y1, 0 + sizeof (y2));\n+  memmove (x, (void *) &c, sizeof (&c));\n+  memmove (x, (signed char *) &c, sizeof (&c));\n+  memmove (x, &c, sizeof (&c) + 0);\n+  memmove (x, &c, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  z += memcmp (y, x, sizeof (*y));\n+  z += memcmp (y1, x, sizeof (*y2));\n+  z += memcmp (buf1, x, sizeof buf1);\n+  z += memcmp (buf3, x, sizeof (buf3));\n+  z += memcmp (&buf3[0], x, sizeof (buf3));\n+  z += memcmp (&buf4[0], x, sizeof (buf4));\n+  z += memcmp (&y3, y, sizeof (y3));\n+  z += memcmp ((char *) &y3, y, sizeof (y3));\n+  z += memcmp (w, x, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp ((void *) y, x, sizeof (y));\n+  z += memcmp ((char *) y1, x, sizeof (y2));\n+  z += memcmp (y, x, sizeof (y) + 0);\n+  z += memcmp (y1, x, 0 + sizeof (y2));\n+  z += memcmp ((void *) &c, x, sizeof (&c));\n+  z += memcmp ((signed char *) &c, x, sizeof (&c));\n+  z += memcmp (&c, x, sizeof (&c) + 0);\n+  z += memcmp (&c, x, 0 + sizeof (&c));\n+\n+  // These are correct, no warning. \n+  z += memcmp (x, y, sizeof (*y));\n+  z += memcmp (x, y1, sizeof (*y2));\n+  z += memcmp (x, buf1, sizeof buf1);\n+  z += memcmp (x, buf3, sizeof (buf3));\n+  z += memcmp (x, &buf3[0], sizeof (buf3));\n+  z += memcmp (x, &buf4[0], sizeof (buf4));\n+  z += memcmp (y, &y3, sizeof (y3));\n+  z += memcmp (y, (char *) &y3, sizeof (y3));\n+  z += memcmp (x, w, sizeof (X));\n+  // These are probably broken, but obfuscated, no warning. \n+  z += memcmp (x, (void *) y, sizeof (y));\n+  z += memcmp (x, (char *) y1, sizeof (y2));\n+  z += memcmp (x, y, sizeof (y) + 0);\n+  z += memcmp (x, y1, 0 + sizeof (y2));\n+  z += memcmp (x, (void *) &c, sizeof (&c));\n+  z += memcmp (x, (signed char *) &c, sizeof (&c));\n+  z += memcmp (x, &c, sizeof (&c) + 0);\n+  z += memcmp (x, &c, 0 + sizeof (&c));\n+\n+  return z;\n+}\n+\n+template <int N>\n+int\n+f4 (char *x, char **y, int z)\n+{\n+  const char *s1 = \"foobarbaz\";\n+  const char *s2 = \"abcde12345678\";\n+  strncpy (x, s1, sizeof (s1));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  strncat (x, s2, sizeof (s2));\t\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  y[0] = strndup (s1, sizeof (s1));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s1));\t    // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += strncmp (s1, s2, sizeof (s2));\t    // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s1));   // { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length\" }\n+  z += strncasecmp (s1, s2, sizeof (s2));   // { dg-warning \"call is the same expression as the source; did you mean to provide an explicit length\" }\n+\n+  // These are correct, no warning. \n+  const char s3[] = \"foobarbaz\";\n+  const char s4[] = \"abcde12345678\";\n+  strncpy (x, s3, sizeof (s3));\n+  strncat (x, s4, sizeof (s4));\n+  y[1] = strndup (s3, sizeof (s3));\n+  z += strncmp (s3, s4, sizeof (s3));\n+  z += strncmp (s3, s4, sizeof (s4));\n+  z += strncasecmp (s3, s4, sizeof (s3));\n+  z += strncasecmp (s3, s4, sizeof (s4));\n+\n+  return z;\n+}\n+\n+int\n+f (void *x, char *y, int z, X w, char **u)\n+{\n+  z += f1<0> (x, z);\n+  z += f2<0> (x, z);\n+  z += f3<0> (x, y, z, w);\n+  z += f4<0> (y, u, z);\n+  return z;\n+}\n+\n+// { dg-prune-output \"\\[\\n\\r\\]*will always overflow\\[\\n\\r\\]*\" }"}, {"sha": "84a1d380bb7cd7ecd8934cf7c7827716449e8a38", "filename": "gcc/testsuite/g++.dg/warn/Wnull-conversion-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWnull-conversion-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWnull-conversion-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWnull-conversion-1.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -9,7 +9,7 @@ void func2() {\n   int* t = false;             // { dg-warning \"converting 'false' to pointer\" }\n   int* p;\n   p = false;                  // { dg-warning \"converting 'false' to pointer\" }\n-  int* r = sizeof(char) / 2;\n+  int* r = sizeof(char) / 2;  // { dg-error \"invalid conversion from\" \"\" { target c++11 } }\n   func1(false);               // { dg-warning \"converting 'false' to pointer\" }\n   int i = NULL;               // { dg-warning \"converting to non-pointer\" }\n }"}, {"sha": "641c49972ee49de44ec04f09ca4540ed3147ef7a", "filename": "gcc/testsuite/g++.dg/warn/Wsign-compare-5.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-compare-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-compare-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsign-compare-5.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,20 @@\n+// Test that -Wsign-compare doesn't warn about\n+// equality/non-equality comparisons with sizeof.\n+// { dg-do compile }\n+// { dg-options \"-Wsign-compare\" }\n+\n+int\n+foo (int x)\n+{\n+  if (x != sizeof (sizeof (x)))\t\t// { dg-bogus \"comparison between signed and unsigned integer expressions\" }\n+    return 1;\n+  return 0;\n+}\n+\n+int\n+bar (int x)\n+{\n+  if (x == sizeof (sizeof (x)) + 1)\t// { dg-bogus \"comparison between signed and unsigned integer expressions\" }\n+    return 1;\n+  return 0;\n+}"}, {"sha": "e2ba8769b9a5a40b9fe8aba930a2f4c900be9991", "filename": "gcc/testsuite/g++.dg/warn/Wsizeof-pointer-memaccess-1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsizeof-pointer-memaccess-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsizeof-pointer-memaccess-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsizeof-pointer-memaccess-1.C?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,13 @@\n+// Test -Wsizeof-pointer-memaccess warnings.\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" void *memset (void *, int, size_t);\n+\n+int\n+foo (int x, char b[10])\n+{\n+  long a[memset (b, 0, sizeof (b)) ? x + 10 : x];\t// { dg-warning \"call is the same expression as the destination; did you mean to provide an explicit length?\" }\n+  return a[0];\n+}"}, {"sha": "0993fbc19f4b2a48456176be349358c69ac3cebb", "filename": "gcc/testsuite/gcc.dg/builtins-85.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-85.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-85.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-85.c?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void __chk_fail (void);\n+extern int snprintf (char *, size_t, const char *, ...);\n+extern inline __attribute__((gnu_inline, always_inline)) int snprintf (char *a, size_t b, const char *fmt, ...)\n+{\n+  if (__builtin_object_size (a, 0) != -1UL && __builtin_object_size (a, 0) < b)\n+    __chk_fail ();\n+  return __builtin_snprintf (a, b, fmt, __builtin_va_arg_pack ());\n+}\n+extern int snprintf (char *, size_t, const char *, ...) __asm (\"mysnprintf\");\n+\n+char buf[10];\n+\n+int\n+main (void)\n+{\n+  snprintf (buf, 10, \"%d%d\\n\", 10, 10);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mysnprintf\" } } */\n+/* { dg-final { scan-assembler-not \"__chk_fail\" } } */"}, {"sha": "ed0b7077f267e77b647a73e216da9e61da76d368", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -1,3 +1,8 @@\n+2012-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust line\n+\tnumbers.\n+\n 2012-10-05  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR libstdc++/54686"}, {"sha": "a2ceeb5c277df66cc2d1897ca5d491f893bfa778", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d23cf7a4f9609763b600a7e9edf81e78e3f7a55/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc?ref=0d23cf7a4f9609763b600a7e9edf81e78e3f7a55", "patch": "@@ -32,9 +32,9 @@ void test01()\n {\n   X* px = 0;\n   std::shared_ptr<X> p1(px);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 776 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 775 }\n \n   std::shared_ptr<X> p9(ap());  // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 310 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 307 }\n \n }"}]}