{"sha": "47b25362bc8f509e3e1852a4ec719494e6afaace", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiMjUzNjJiYzhmNTA5ZTNlMTg1MmE0ZWM3MTk0OTRlNmFmYWFjZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-12T12:49:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-12T12:49:14Z"}, "message": "genmatch.c (::gen_transform): Add capture_info and expand_compares arguments.\n\n2014-11-12  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (::gen_transform): Add capture_info and\n\texpand_compares arguments.\n\t(struct expr): Add is_generic flag.\n\t(lower_cond): New functions lowering [VEC_]COND_EXPR\n\tconditions to a GENERIC and a GIMPLE variant.\n\t(lower): Call lower_cond.\n\t(cmp_operand): Also compare the is_generic flag.\n\t(capture_info::cinfo): Add cond_expr_cond_p flag.\n\t(capture_info::capture_info): Pass down whether the\n\texpression argument is a COND_EXPR condition.\n\t(capture_info::walk_match): Likewise, mark captures\n\tcapturing COND_EXPR conditions with cond_expr_cond_p.\n\t(expr::gen_transform): Pass down whether we need to\n\texpand compares from COND_EXPR conditions.\n\t(capture::gen_transform): Expand compares substituted\n\tfrom COND_EXPR conditions into non-COND_EXPR conditions.\n\t(dt_operand::gen_gimple_expr): Handle explicitely marked\n\tGENERIC expressions as generic.\n\t(dt_simplify::gen): Pass whether we need to expand\n\tconditions to gen_transform.  Handle capture results\n\twhich are from COND_EXPR conditions.\n\t(main): Pass gimple flag down to lower.\n\nFrom-SVN: r217416", "tree": {"sha": "0d922379b068aa7f068f84da48c36830c63bae8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d922379b068aa7f068f84da48c36830c63bae8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47b25362bc8f509e3e1852a4ec719494e6afaace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b25362bc8f509e3e1852a4ec719494e6afaace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b25362bc8f509e3e1852a4ec719494e6afaace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b25362bc8f509e3e1852a4ec719494e6afaace/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1304953e4fa46305d1ce0b884bf2f58e08409ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1304953e4fa46305d1ce0b884bf2f58e08409ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1304953e4fa46305d1ce0b884bf2f58e08409ff3"}], "stats": {"total": 606, "additions": 404, "deletions": 202}, "files": [{"sha": "9b422f484548a409878499d60e5c218933bd81cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b25362bc8f509e3e1852a4ec719494e6afaace/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b25362bc8f509e3e1852a4ec719494e6afaace/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47b25362bc8f509e3e1852a4ec719494e6afaace", "patch": "@@ -1,3 +1,28 @@\n+2014-11-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (::gen_transform): Add capture_info and\n+\texpand_compares arguments.\n+\t(struct expr): Add is_generic flag.\n+\t(lower_cond): New functions lowering [VEC_]COND_EXPR\n+\tconditions to a GENERIC and a GIMPLE variant.\n+\t(lower): Call lower_cond.\n+\t(cmp_operand): Also compare the is_generic flag.\n+\t(capture_info::cinfo): Add cond_expr_cond_p flag.\n+\t(capture_info::capture_info): Pass down whether the\n+\texpression argument is a COND_EXPR condition.\n+\t(capture_info::walk_match): Likewise, mark captures\n+\tcapturing COND_EXPR conditions with cond_expr_cond_p.\n+\t(expr::gen_transform): Pass down whether we need to\n+\texpand compares from COND_EXPR conditions.\n+\t(capture::gen_transform): Expand compares substituted\n+\tfrom COND_EXPR conditions into non-COND_EXPR conditions.\n+\t(dt_operand::gen_gimple_expr): Handle explicitely marked\n+\tGENERIC expressions as generic.\n+\t(dt_simplify::gen): Pass whether we need to expand\n+\tconditions to gen_transform.  Handle capture results\n+\twhich are from COND_EXPR conditions.\n+\t(main): Pass gimple flag down to lower.\n+\n 2014-11-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/59708"}, {"sha": "437e29a34688b08032eee87448069a358413e400", "filename": "gcc/genmatch.c", "status": "modified", "additions": 379, "deletions": 202, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b25362bc8f509e3e1852a4ec719494e6afaace/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b25362bc8f509e3e1852a4ec719494e6afaace/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=47b25362bc8f509e3e1852a4ec719494e6afaace", "patch": "@@ -386,6 +386,7 @@ typedef hash_map<const char *, unsigned, capture_id_map_hasher> cid_map_t;\n /* The AST produced by parsing of the pattern definitions.  */\n \n struct dt_operand;\n+struct capture_info;\n \n /* The base class for operands.  */\n \n@@ -394,7 +395,9 @@ struct operand {\n   operand (enum op_type type_) : type (type_) {}\n   enum op_type type;\n   virtual void gen_transform (FILE *, const char *, bool, int,\n-\t\t\t      const char *, dt_operand ** = 0)\n+\t\t\t      const char *, capture_info *,\n+\t\t\t      dt_operand ** = 0,\n+\t\t\t      bool = true)\n     { gcc_unreachable  (); }\n };\n \n@@ -413,7 +416,8 @@ struct expr : public operand\n {\n   expr (id_base *operation_, bool is_commutative_ = false)\n     : operand (OP_EXPR), operation (operation_),\n-      ops (vNULL), expr_type (NULL), is_commutative (is_commutative_) {}\n+      ops (vNULL), expr_type (NULL), is_commutative (is_commutative_),\n+      is_generic (false) {}\n   void append_op (operand *op) { ops.safe_push (op); }\n   /* The operator and its operands.  */\n   id_base *operation;\n@@ -423,8 +427,11 @@ struct expr : public operand\n   /* Whether the operation is to be applied commutatively.  This is\n      later lowered to two separate patterns.  */\n   bool is_commutative;\n+  /* Whether the expression is expected to be in GENERIC form.  */\n+  bool is_generic;\n   virtual void gen_transform (FILE *f, const char *, bool, int,\n-\t\t\t      const char *, dt_operand ** = 0);\n+\t\t\t      const char *, capture_info *,\n+\t\t\t      dt_operand ** = 0, bool = true);\n };\n \n /* An operator that is represented by native C code.  This is always\n@@ -454,7 +461,8 @@ struct c_expr : public operand\n   /* The identifier replacement vector.  */\n   vec<id_tab> ids;\n   virtual void gen_transform (FILE *f, const char *, bool, int,\n-\t\t\t      const char *, dt_operand **);\n+\t\t\t      const char *, capture_info *,\n+\t\t\t      dt_operand ** = 0, bool = true);\n };\n \n /* A wrapper around another operand that captures its value.  */\n@@ -468,7 +476,8 @@ struct capture : public operand\n   /* The captured value.  */\n   operand *what;\n   virtual void gen_transform (FILE *f, const char *, bool, int,\n-\t\t\t      const char *, dt_operand ** = 0);\n+\t\t\t      const char *, capture_info *,\n+\t\t\t      dt_operand ** = 0, bool = true);\n };\n \n template<>\n@@ -817,6 +826,106 @@ lower_opt_convert (simplify *s, vec<simplify *>& simplifiers)\n     }\n }\n \n+/* Lower the compare operand of COND_EXPRs and VEC_COND_EXPRs to a\n+   GENERIC and a GIMPLE variant.  */\n+\n+static vec<operand *>\n+lower_cond (operand *o)\n+{\n+  vec<operand *> ro = vNULL;\n+\n+  if (capture *c = dyn_cast<capture *> (o))\n+    {\n+      if (c->what)\n+\t{\n+\t  vec<operand *> lop = vNULL;\n+\t  lop = lower_cond (c->what);\n+\n+\t  for (unsigned i = 0; i < lop.length (); ++i)\n+\t    ro.safe_push (new capture (c->where, lop[i]));\n+\t  return ro;\n+\t}\n+    }\n+\n+  expr *e = dyn_cast<expr *> (o);\n+  if (!e || e->ops.length () == 0)\n+    {\n+      ro.safe_push (o);\n+      return ro;\n+    }\n+\n+  vec< vec<operand *> > ops_vector = vNULL;\n+  for (unsigned i = 0; i < e->ops.length (); ++i)\n+    ops_vector.safe_push (lower_cond (e->ops[i]));\n+\n+  auto_vec< vec<operand *> > result;\n+  auto_vec<operand *> v (e->ops.length ());\n+  v.quick_grow_cleared (e->ops.length ());\n+  cartesian_product (ops_vector, result, v, 0);\n+\n+  for (unsigned i = 0; i < result.length (); ++i)\n+    {\n+      expr *ne = new expr (e->operation);\n+      for (unsigned j = 0; j < result[i].length (); ++j)\n+\tne->append_op (result[i][j]);\n+      ro.safe_push (ne);\n+      /* If this is a COND with a captured expression or an\n+         expression with two operands then also match a GENERIC\n+\t form on the compare.  */\n+      if ((*e->operation == COND_EXPR\n+\t   || *e->operation == VEC_COND_EXPR)\n+\t  && ((is_a <capture *> (e->ops[0])\n+\t       && as_a <capture *> (e->ops[0])->what\n+\t       && is_a <expr *> (as_a <capture *> (e->ops[0])->what)\n+\t       && as_a <expr *>\n+\t            (as_a <capture *> (e->ops[0])->what)->ops.length () == 2)\n+\t      || (is_a <expr *> (e->ops[0])\n+\t\t  && as_a <expr *> (e->ops[0])->ops.length () == 2)))\n+\t{\n+\t  expr *ne = new expr (e->operation);\n+\t  for (unsigned j = 0; j < result[i].length (); ++j)\n+\t    ne->append_op (result[i][j]);\n+\t  if (capture *c = dyn_cast <capture *> (ne->ops[0]))\n+\t    {\n+\t      expr *ocmp = as_a <expr *> (c->what);\n+\t      expr *cmp = new expr (ocmp->operation);\n+\t      for (unsigned j = 0; j < ocmp->ops.length (); ++j)\n+\t\tcmp->append_op (ocmp->ops[j]);\n+\t      cmp->is_generic = true;\n+\t      ne->ops[0] = new capture (c->where, cmp);\n+\t    }\n+\t  else\n+\t    {\n+\t      expr *ocmp = as_a <expr *> (ne->ops[0]);\n+\t      expr *cmp = new expr (ocmp->operation);\n+\t      for (unsigned j = 0; j < ocmp->ops.length (); ++j)\n+\t\tcmp->append_op (ocmp->ops[j]);\n+\t      cmp->is_generic = true;\n+\t      ne->ops[0] = cmp;\n+\t    }\n+\t  ro.safe_push (ne);\n+\t}\n+    }\n+\n+  return ro;\n+}\n+\n+/* Lower the compare operand of COND_EXPRs and VEC_COND_EXPRs to a\n+   GENERIC and a GIMPLE variant.  */\n+\n+static void\n+lower_cond (simplify *s, vec<simplify *>& simplifiers)\n+{\n+  vec<operand *> matchers = lower_cond (s->match);\n+  for (unsigned i = 0; i < matchers.length (); ++i)\n+    {\n+      simplify *ns = new simplify (matchers[i], s->match_location,\n+\t\t\t\t   s->result, s->result_location, s->ifexpr_vec,\n+\t\t\t\t   s->for_vec, s->capture_ids);\n+      simplifiers.safe_push (ns);\n+    }\n+}\n+\n /* In AST operand O replace operator ID with operator WITH.  */\n \n operand *\n@@ -912,19 +1021,27 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n /* Lower the AST for everything in SIMPLIFIERS.  */\n \n static void\n-lower (vec<simplify *>& simplifiers)\n+lower (vec<simplify *>& simplifiers, bool gimple)\n {\n-  auto_vec<simplify *> out_simplifiers0;\n+  auto_vec<simplify *> out_simplifiers;\n   for (unsigned i = 0; i < simplifiers.length (); ++i)\n-    lower_opt_convert (simplifiers[i], out_simplifiers0);\n+    lower_opt_convert (simplifiers[i], out_simplifiers);\n+\n+  simplifiers.truncate (0);\n+  for (unsigned i = 0; i < out_simplifiers.length (); ++i)\n+    lower_commutative (out_simplifiers[i], simplifiers);\n+\n+  out_simplifiers.truncate (0);\n+  if (gimple)\n+    for (unsigned i = 0; i < simplifiers.length (); ++i)\n+      lower_cond (simplifiers[i], out_simplifiers);\n+  else\n+    out_simplifiers.safe_splice (simplifiers);\n \n-  auto_vec<simplify *> out_simplifiers1;\n-  for (unsigned i = 0; i < out_simplifiers0.length (); ++i)\n-    lower_commutative (out_simplifiers0[i], out_simplifiers1);\n \n   simplifiers.truncate (0);\n-  for (unsigned i = 0; i < out_simplifiers1.length (); ++i)\n-    lower_for (out_simplifiers1[i], simplifiers);\n+  for (unsigned i = 0; i < out_simplifiers.length (); ++i)\n+    lower_for (out_simplifiers[i], simplifiers);\n }\n \n \n@@ -1044,7 +1161,8 @@ cmp_operand (operand *o1, operand *o2)\n     {\n       expr *e1 = static_cast<expr *>(o1);\n       expr *e2 = static_cast<expr *>(o2);\n-      return e1->operation == e2->operation;\n+      return (e1->operation == e2->operation\n+\t      && e1->is_generic == e2->is_generic);\n     }\n   else\n     return false;\n@@ -1281,6 +1399,190 @@ decision_tree::print (FILE *f)\n }\n \n \n+/* For GENERIC we have to take care of wrapping multiple-used\n+   expressions with side-effects in save_expr and preserve side-effects\n+   of expressions with omit_one_operand.  Analyze captures in\n+   match, result and with expressions and perform early-outs\n+   on the outermost match expression operands for cases we cannot\n+   handle.  */\n+\n+struct capture_info\n+{\n+  capture_info (simplify *s);\n+  void walk_match (operand *o, unsigned toplevel_arg, bool, bool);\n+  void walk_result (operand *o, bool);\n+  void walk_c_expr (c_expr *);\n+\n+  struct cinfo\n+    {\n+      bool expr_p;\n+      bool cse_p;\n+      bool force_no_side_effects_p;\n+      bool cond_expr_cond_p;\n+      unsigned long toplevel_msk;\n+      int result_use_count;\n+    };\n+\n+  auto_vec<cinfo> info;\n+  unsigned long force_no_side_effects;\n+};\n+\n+/* Analyze captures in S.  */\n+\n+capture_info::capture_info (simplify *s)\n+{\n+  expr *e;\n+  if (!s->result\n+      || ((e = dyn_cast <expr *> (s->result))\n+\t  && is_a <predicate_id *> (e->operation)))\n+    {\n+      force_no_side_effects = -1;\n+      return;\n+    }\n+\n+  force_no_side_effects = 0;\n+  info.safe_grow_cleared (s->capture_max + 1);\n+  e = as_a <expr *> (s->match);\n+  for (unsigned i = 0; i < e->ops.length (); ++i)\n+    walk_match (e->ops[i], i,\n+\t\t(i != 0 && *e->operation == COND_EXPR)\n+\t\t|| *e->operation == TRUTH_ANDIF_EXPR\n+\t\t|| *e->operation == TRUTH_ORIF_EXPR,\n+\t\ti == 0\n+\t\t&& (*e->operation == COND_EXPR\n+\t\t    || *e->operation == VEC_COND_EXPR));\n+\n+  walk_result (s->result, false);\n+\n+  for (unsigned i = 0; i < s->ifexpr_vec.length (); ++i)\n+    if (s->ifexpr_vec[i].is_with)\n+      walk_c_expr (as_a <c_expr *>(s->ifexpr_vec[i].cexpr));\n+}\n+\n+/* Analyze captures in the match expression piece O.  */\n+\n+void\n+capture_info::walk_match (operand *o, unsigned toplevel_arg,\n+\t\t\t  bool conditional_p, bool cond_expr_cond_p)\n+{\n+  if (capture *c = dyn_cast <capture *> (o))\n+    {\n+      info[c->where].toplevel_msk |= 1 << toplevel_arg;\n+      info[c->where].force_no_side_effects_p |= conditional_p;\n+      info[c->where].cond_expr_cond_p |= cond_expr_cond_p;\n+      /* Mark expr (non-leaf) captures and recurse.  */\n+      if (c->what\n+\t  && is_a <expr *> (c->what))\n+\t{\n+\t  info[c->where].expr_p = true;\n+\t  walk_match (c->what, toplevel_arg, conditional_p, false);\n+\t}\n+    }\n+  else if (expr *e = dyn_cast <expr *> (o))\n+    {\n+      for (unsigned i = 0; i < e->ops.length (); ++i)\n+\t{\n+\t  bool cond_p = conditional_p;\n+\t  bool cond_expr_cond_p = false;\n+\t  if (i != 0 && *e->operation == COND_EXPR)\n+\t    cond_p = true;\n+\t  else if (*e->operation == TRUTH_ANDIF_EXPR\n+\t\t   || *e->operation == TRUTH_ORIF_EXPR)\n+\t    cond_p = true;\n+\t  if (i == 0\n+\t      && (*e->operation == COND_EXPR\n+\t\t  || *e->operation == VEC_COND_EXPR))\n+\t    cond_expr_cond_p = true;\n+\t  walk_match (e->ops[i], toplevel_arg, cond_p, cond_expr_cond_p);\n+\t}\n+    }\n+  else if (is_a <predicate *> (o))\n+    {\n+      /* Mark non-captured leafs toplevel arg for checking.  */\n+      force_no_side_effects |= 1 << toplevel_arg;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Analyze captures in the result expression piece O.  */\n+\n+void\n+capture_info::walk_result (operand *o, bool conditional_p)\n+{\n+  if (capture *c = dyn_cast <capture *> (o))\n+    {\n+      info[c->where].result_use_count++;\n+      /* If we substitute an expression capture we don't know\n+         which captures this will end up using (well, we don't\n+\t compute that).  Force the uses to be side-effect free\n+\t which means forcing the toplevels that reach the\n+\t expression side-effect free.  */\n+      if (info[c->where].expr_p)\n+\tforce_no_side_effects |= info[c->where].toplevel_msk;\n+      /* Mark CSE capture capture uses as forced to have\n+         no side-effects. */\n+      if (c->what\n+\t  && is_a <expr *> (c->what))\n+\t{\n+\t  info[c->where].cse_p = true;\n+\t  walk_result (c->what, true);\n+\t}\n+    }\n+  else if (expr *e = dyn_cast <expr *> (o))\n+    {\n+      for (unsigned i = 0; i < e->ops.length (); ++i)\n+\t{\n+\t  bool cond_p = conditional_p;\n+\t  if (i != 0 && *e->operation == COND_EXPR)\n+\t    cond_p = true;\n+\t  else if (*e->operation == TRUTH_ANDIF_EXPR\n+\t\t   || *e->operation == TRUTH_ORIF_EXPR)\n+\t    cond_p = true;\n+\t  walk_result (e->ops[i], cond_p);\n+\t}\n+    }\n+  else if (c_expr *e = dyn_cast <c_expr *> (o))\n+    walk_c_expr (e);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Look for captures in the C expr E.  */\n+\n+void\n+capture_info::walk_c_expr (c_expr *e)\n+{\n+  /* Give up for C exprs mentioning captures not inside TREE_TYPE ().  */\n+  unsigned p_depth = 0;\n+  for (unsigned i = 0; i < e->code.length (); ++i)\n+    {\n+      const cpp_token *t = &e->code[i];\n+      const cpp_token *n = i < e->code.length () - 1 ? &e->code[i+1] : NULL;\n+      if (t->type == CPP_NAME\n+\t  && strcmp ((const char *)CPP_HASHNODE\n+\t\t       (t->val.node.node)->ident.str, \"TREE_TYPE\") == 0\n+\t  && n->type == CPP_OPEN_PAREN)\n+\tp_depth++;\n+      else if (t->type == CPP_CLOSE_PAREN\n+\t       && p_depth > 0)\n+\tp_depth--;\n+      else if (p_depth == 0\n+\t       && t->type == CPP_ATSIGN\n+\t       && (n->type == CPP_NUMBER\n+\t\t   || n->type == CPP_NAME)\n+\t       && !(n->flags & PREV_WHITE))\n+\t{\n+\t  const char *id;\n+\t  if (n->type == CPP_NUMBER)\n+\t    id = (const char *)n->val.str.text;\n+\t  else\n+\t    id = (const char *)CPP_HASHNODE (n->val.node.node)->ident.str;\n+\t  info[*e->capture_ids->get(id)].force_no_side_effects_p = true;\n+\t}\n+    }\n+}\n+\n \n /* Code generation off the decision tree and the refered AST nodes.  */\n \n@@ -1330,7 +1632,8 @@ get_operand_type (id_base *op, const char *in_type,\n \n void\n expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n-\t\t     const char *in_type, dt_operand **indexes)\n+\t\t     const char *in_type, capture_info *cinfo,\n+\t\t     dt_operand **indexes, bool)\n {\n   bool conversion_p = is_conversion (operation);\n   const char *type = expr_type;\n@@ -1377,7 +1680,10 @@ expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n       const char *optype\n \t= get_operand_type (operation, in_type, expr_type,\n \t\t\t    i == 0 ? NULL : op0type);\n-      ops[i]->gen_transform (f, dest, gimple, depth + 1, optype, indexes);\n+      ops[i]->gen_transform (f, dest, gimple, depth + 1, optype, cinfo, indexes,\n+\t\t\t     ((!(*operation == COND_EXPR)\n+\t\t\t       && !(*operation == VEC_COND_EXPR))\n+\t\t\t      || i != 0));\n     }\n \n   const char *opr;\n@@ -1427,7 +1733,8 @@ expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n \n void\n c_expr::gen_transform (FILE *f, const char *dest,\n-\t\t       bool, int, const char *, dt_operand **)\n+\t\t       bool, int, const char *, capture_info *,\n+\t\t       dt_operand **, bool)\n {\n   if (dest && nr_stmts == 1)\n     fprintf (f, \"%s = \", dest);\n@@ -1496,19 +1803,34 @@ c_expr::gen_transform (FILE *f, const char *dest,\n \n void\n capture::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n-\t\t\tconst char *in_type, dt_operand **indexes)\n+\t\t\tconst char *in_type, capture_info *cinfo,\n+\t\t\tdt_operand **indexes, bool expand_compares)\n {\n   if (what && is_a<expr *> (what))\n     {\n       if (indexes[where] == 0)\n \t{\n \t  char buf[20];\n \t  sprintf (buf, \"captures[%u]\", where);\n-\t  what->gen_transform (f, buf, gimple, depth, in_type, NULL);\n+\t  what->gen_transform (f, buf, gimple, depth, in_type, cinfo, NULL);\n \t}\n     }\n \n   fprintf (f, \"%s = captures[%u];\\n\", dest, where);\n+\n+  /* ???  Stupid tcc_comparison GENERIC trees in COND_EXPRs.  Deal\n+     with substituting a capture of that.\n+     ???  Returning false here will also not allow any other patterns\n+     to match.  */\n+  if (gimple && expand_compares\n+      && cinfo->info[where].cond_expr_cond_p)\n+    fprintf (f, \"if (COMPARISON_CLASS_P (%s))\\n\"\n+\t     \"  {\\n\"\n+\t     \"    if (!seq) return false;\\n\"\n+\t     \"    %s = gimple_build (seq, TREE_CODE (%s),\"\n+\t     \" TREE_TYPE (%s), TREE_OPERAND (%s, 0),\"\n+\t     \" TREE_OPERAND (%s, 1));\\n\"\n+\t     \"  }\\n\", dest, dest, dest, dest, dest, dest);\n }\n \n /* Return the name of the operand representing the decision tree node.\n@@ -1592,7 +1914,8 @@ dt_operand::gen_gimple_expr (FILE *f)\n \n       if (id->kind == id_base::CODE)\n \t{\n-\t  if (*id == REALPART_EXPR || *id == IMAGPART_EXPR\n+\t  if (e->is_generic\n+\t      || *id == REALPART_EXPR || *id == IMAGPART_EXPR\n \t      || *id == BIT_FIELD_REF || *id == VIEW_CONVERT_EXPR)\n \t    {\n \t      /* ???  If this is a memory operation we can't (and should not)\n@@ -1896,179 +2219,6 @@ dt_operand::gen (FILE *f, bool gimple)\n }\n \n \n-/* For GENERIC we have to take care of wrapping multiple-used\n-   expressions with side-effects in save_expr and preserve side-effects\n-   of expressions with omit_one_operand.  Analyze captures in\n-   match, result and with expressions and perform early-outs\n-   on the outermost match expression operands for cases we cannot\n-   handle.  */\n-\n-struct capture_info\n-{\n-  capture_info (simplify *s);\n-  void walk_match (operand *o, unsigned toplevel_arg, bool);\n-  void walk_result (operand *o, bool);\n-  void walk_c_expr (c_expr *);\n-\n-  struct cinfo\n-    {\n-      bool expr_p;\n-      bool cse_p;\n-      bool force_no_side_effects_p;\n-      unsigned long toplevel_msk;\n-      int result_use_count;\n-    };\n-\n-  auto_vec<cinfo> info;\n-  unsigned long force_no_side_effects;\n-};\n-\n-/* Analyze captures in S.  */\n-\n-capture_info::capture_info (simplify *s)\n-{\n-  expr *e;\n-  if (!s->result\n-      || ((e = dyn_cast <expr *> (s->result))\n-\t  && is_a <predicate_id *> (e->operation)))\n-    {\n-      force_no_side_effects = -1;\n-      return;\n-    }\n-\n-  force_no_side_effects = 0;\n-  info.safe_grow_cleared (s->capture_max + 1);\n-  e = as_a <expr *> (s->match);\n-  for (unsigned i = 0; i < e->ops.length (); ++i)\n-    walk_match (e->ops[i], i,\n-\t\t(i != 0 && *e->operation == COND_EXPR)\n-\t\t|| *e->operation == TRUTH_ANDIF_EXPR\n-\t\t|| *e->operation == TRUTH_ORIF_EXPR);\n-\n-  walk_result (s->result, false);\n-\n-  for (unsigned i = 0; i < s->ifexpr_vec.length (); ++i)\n-    if (s->ifexpr_vec[i].is_with)\n-      walk_c_expr (as_a <c_expr *>(s->ifexpr_vec[i].cexpr));\n-}\n-\n-/* Analyze captures in the match expression piece O.  */\n-\n-void\n-capture_info::walk_match (operand *o, unsigned toplevel_arg, bool conditional_p)\n-{\n-  if (capture *c = dyn_cast <capture *> (o))\n-    {\n-      info[c->where].toplevel_msk |= 1 << toplevel_arg;\n-      info[c->where].force_no_side_effects_p |= conditional_p;\n-      /* Mark expr (non-leaf) captures and recurse.  */\n-      if (c->what\n-\t  && is_a <expr *> (c->what))\n-\t{\n-\t  info[c->where].expr_p = true;\n-\t  walk_match (c->what, toplevel_arg, conditional_p);\n-\t}\n-    }\n-  else if (expr *e = dyn_cast <expr *> (o))\n-    {\n-      for (unsigned i = 0; i < e->ops.length (); ++i)\n-\t{\n-\t  bool cond_p = conditional_p;\n-\t  if (i != 0 && *e->operation == COND_EXPR)\n-\t    cond_p = true;\n-\t  else if (*e->operation == TRUTH_ANDIF_EXPR\n-\t\t   || *e->operation == TRUTH_ORIF_EXPR)\n-\t    cond_p = true;\n-\t  walk_match (e->ops[i], toplevel_arg, cond_p);\n-\t}\n-    }\n-  else if (is_a <predicate *> (o))\n-    {\n-      /* Mark non-captured leafs toplevel arg for checking.  */\n-      force_no_side_effects |= 1 << toplevel_arg;\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Analyze captures in the result expression piece O.  */\n-\n-void\n-capture_info::walk_result (operand *o, bool conditional_p)\n-{\n-  if (capture *c = dyn_cast <capture *> (o))\n-    {\n-      info[c->where].result_use_count++;\n-      /* If we substitute an expression capture we don't know\n-         which captures this will end up using (well, we don't\n-\t compute that).  Force the uses to be side-effect free\n-\t which means forcing the toplevels that reach the\n-\t expression side-effect free.  */\n-      if (info[c->where].expr_p)\n-\tforce_no_side_effects |= info[c->where].toplevel_msk;\n-      /* Mark CSE capture capture uses as forced to have\n-         no side-effects. */\n-      if (c->what\n-\t  && is_a <expr *> (c->what))\n-\t{\n-\t  info[c->where].cse_p = true;\n-\t  walk_result (c->what, true);\n-\t}\n-    }\n-  else if (expr *e = dyn_cast <expr *> (o))\n-    {\n-      for (unsigned i = 0; i < e->ops.length (); ++i)\n-\t{\n-\t  bool cond_p = conditional_p;\n-\t  if (i != 0 && *e->operation == COND_EXPR)\n-\t    cond_p = true;\n-\t  else if (*e->operation == TRUTH_ANDIF_EXPR\n-\t\t   || *e->operation == TRUTH_ORIF_EXPR)\n-\t    cond_p = true;\n-\t  walk_result (e->ops[i], cond_p);\n-\t}\n-    }\n-  else if (c_expr *e = dyn_cast <c_expr *> (o))\n-    walk_c_expr (e);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Look for captures in the C expr E.  */\n-\n-void\n-capture_info::walk_c_expr (c_expr *e)\n-{\n-  /* Give up for C exprs mentioning captures not inside TREE_TYPE ().  */\n-  unsigned p_depth = 0;\n-  for (unsigned i = 0; i < e->code.length (); ++i)\n-    {\n-      const cpp_token *t = &e->code[i];\n-      const cpp_token *n = i < e->code.length () - 1 ? &e->code[i+1] : NULL;\n-      if (t->type == CPP_NAME\n-\t  && strcmp ((const char *)CPP_HASHNODE\n-\t\t       (t->val.node.node)->ident.str, \"TREE_TYPE\") == 0\n-\t  && n->type == CPP_OPEN_PAREN)\n-\tp_depth++;\n-      else if (t->type == CPP_CLOSE_PAREN\n-\t       && p_depth > 0)\n-\tp_depth--;\n-      else if (p_depth == 0\n-\t       && t->type == CPP_ATSIGN\n-\t       && (n->type == CPP_NUMBER\n-\t\t   || n->type == CPP_NAME)\n-\t       && !(n->flags & PREV_WHITE))\n-\t{\n-\t  const char *id;\n-\t  if (n->type == CPP_NUMBER)\n-\t    id = (const char *)n->val.str.text;\n-\t  else\n-\t    id = (const char *)CPP_HASHNODE (n->val.node.node)->ident.str;\n-\t  info[*e->capture_ids->get(id)].force_no_side_effects_p = true;\n-\t}\n-    }\n-}\n-\n \n /* Generate code for the '(if ...)', '(with ..)' and actual transform\n    step of a '(simplify ...)' or '(match ...)'.  This handles everything\n@@ -2100,7 +2250,7 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t    {\n \t      fprintf (f, \"{\\n\");\n \t      output_line_directive (f, w.location);\n-\t      w.cexpr->gen_transform (f, NULL, true, 1, \"type\");\n+\t      w.cexpr->gen_transform (f, NULL, true, 1, \"type\", NULL);\n \t      n_braces++;\n \t    }\n \t  else\n@@ -2109,7 +2259,7 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t      fprintf (f, \"if (\");\n \t      if (i == s->ifexpr_vec.length () - 1\n \t\t  || s->ifexpr_vec[i+1].is_with)\n-\t\tw.cexpr->gen_transform (f, NULL, true, 1, \"type\");\n+\t\tw.cexpr->gen_transform (f, NULL, true, 1, \"type\", NULL);\n \t      else\n \t\t{\n \t\t  unsigned j = i;\n@@ -2123,7 +2273,8 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\t\t}\n \t\t      fprintf (f, \"(\");\n \t\t      s->ifexpr_vec[j].cexpr->gen_transform (f, NULL,\n-\t\t\t\t\t\t\t     true, 1, \"type\");\n+\t\t\t\t\t\t\t     true, 1, \"type\",\n+\t\t\t\t\t\t\t     NULL);\n \t\t      fprintf (f, \")\");\n \t\t      ++j;\n \t\t    }\n@@ -2200,7 +2351,18 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\t\t\t    \"type\", e->expr_type,\n \t\t\t\t    j == 0\n \t\t\t\t    ? NULL : \"TREE_TYPE (res_ops[0])\");\n-\t      e->ops[j]->gen_transform (f, dest, true, 1, optype, indexes);\n+\t      /* We need to expand GENERIC conditions we captured from\n+\t         COND_EXPRs.  */\n+\t      bool expand_generic_cond_exprs_p\n+\t        = (!is_predicate\n+\t\t   /* But avoid doing that if the GENERIC condition is\n+\t\t      valid - which it is in the first operand of COND_EXPRs\n+\t\t      and VEC_COND_EXRPs.  */\n+\t\t   && ((!(*e->operation == COND_EXPR)\n+\t\t\t&& !(*e->operation == VEC_COND_EXPR))\n+\t\t       || j != 0));\n+\t      e->ops[j]->gen_transform (f, dest, true, 1, optype, &cinfo,\n+\t\t\t\t\tindexes, expand_generic_cond_exprs_p);\n \t    }\n \n \t  /* Re-fold the toplevel result.  It's basically an embedded\n@@ -2212,8 +2374,21 @@ dt_simplify::gen (FILE *f, bool gimple)\n       else if (result->type == operand::OP_CAPTURE\n \t       || result->type == operand::OP_C_EXPR)\n \t{\n-\t  result->gen_transform (f, \"res_ops[0]\", true, 1, \"type\", indexes);\n+\t  result->gen_transform (f, \"res_ops[0]\", true, 1, \"type\",\n+\t\t\t\t &cinfo, indexes, false);\n \t  fprintf (f, \"*res_code = TREE_CODE (res_ops[0]);\\n\");\n+\t  if (is_a <capture *> (result)\n+\t      && cinfo.info[as_a <capture *> (result)->where].cond_expr_cond_p)\n+\t    {\n+\t      /* ???  Stupid tcc_comparison GENERIC trees in COND_EXPRs.  Deal\n+\t\t with substituting a capture of that.  */\n+\t      fprintf (f, \"if (COMPARISON_CLASS_P (res_ops[0]))\\n\"\n+\t\t       \"  {\\n\"\n+\t\t       \"    tree tem = res_ops[0];\\n\"\n+\t\t       \"    res_ops[0] = TREE_OPERAND (tem, 0);\\n\"\n+\t\t       \"    res_ops[1] = TREE_OPERAND (tem, 1);\\n\"\n+\t\t       \"  }\\n\");\n+\t    }\n \t}\n       else\n \tgcc_unreachable ();\n@@ -2252,7 +2427,8 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\t\t\t    \"type\", e->expr_type,\n \t\t\t\t    j == 0\n \t\t\t\t    ? NULL : \"TREE_TYPE (res_op0)\");\n-\t      e->ops[j]->gen_transform (f, dest, false, 1, optype, indexes);\n+\t      e->ops[j]->gen_transform (f, dest, false, 1, optype,\n+\t\t\t\t\t&cinfo, indexes);\n \t    }\n \t  if (is_predicate)\n \t    fprintf (f, \"return true;\\n\");\n@@ -2286,7 +2462,8 @@ dt_simplify::gen (FILE *f, bool gimple)\n \n \t{\n \t  fprintf (f, \"  tree res;\\n\");\n-\t  s->result->gen_transform (f, \" res\", false, 1, \"type\", indexes);\n+\t  s->result->gen_transform (f, \" res\", false, 1, \"type\",\n+\t\t\t\t    &cinfo, indexes);\n \t}\n       else\n \tgcc_unreachable ();\n@@ -3267,7 +3444,7 @@ add_operator (CONVERT2, \"CONVERT2\", \"tcc_unary\", 1);\n   for (unsigned i = 0; i < p.user_predicates.length (); ++i)\n     {\n       predicate_id *pred = p.user_predicates[i];\n-      lower (pred->matchers);\n+      lower (pred->matchers, gimple);\n \n       if (verbose)\n \tfor (unsigned i = 0; i < pred->matchers.length (); ++i)\n@@ -3284,7 +3461,7 @@ add_operator (CONVERT2, \"CONVERT2\", \"tcc_unary\", 1);\n     }\n \n   /* Lower the main simplifiers and generate code for them.  */\n-  lower (p.simplifiers);\n+  lower (p.simplifiers, gimple);\n \n   if (verbose)\n     for (unsigned i = 0; i < p.simplifiers.length (); ++i)"}]}