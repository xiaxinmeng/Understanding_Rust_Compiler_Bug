{"sha": "c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFkZDM0N2NiZDdjMWFjODdiNzUwYTkxMDBkZmJkZTJmMjE5MGM2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-12-24T11:26:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-12-24T11:26:15Z"}, "message": "ipa-devirt.c (dump_targets): Cap number of targets printed.\n\n\n\t* ipa-devirt.c (dump_targets): Cap number of targets printed.\n\t(dump_possible_polymorphic_call_targets): Add verbose parameter.\n\t(ipa_devirt): Use it.\n\t* ipa-utils.h (dump_possible_polymorphic_call_targets): Add verbose\n\tparametrs.\n\nFrom-SVN: r267400", "tree": {"sha": "58767bda9b1fd424ad53a10af66c53629def0dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58767bda9b1fd424ad53a10af66c53629def0dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/comments", "author": null, "committer": null, "parents": [{"sha": "3d7bef8def04568aa63743b7edd46a85af11152a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7bef8def04568aa63743b7edd46a85af11152a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7bef8def04568aa63743b7edd46a85af11152a"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "65f87a3ddfaf03cec30dd9b0e950931ce0b1efbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "patch": "@@ -1,3 +1,11 @@\n+2018-12-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (dump_targets): Cap number of targets printed.\n+\t(dump_possible_polymorphic_call_targets): Add verbose parameter.\n+\t(ipa_devirt): Use it.\n+\t* ipa-utils.h (dump_possible_polymorphic_call_targets): Add verbose\n+\tparametrs.\n+\n 2018-12-24  Jan Hubicka  <hubicka@ucw.cz>\n \t\n \tPR lto/88140"}, {"sha": "399a6e027cf6daff2060cef1f1b1a67ec5634186", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "patch": "@@ -3454,7 +3454,7 @@ add_decl_warning (const tree &key ATTRIBUTE_UNUSED, const decl_warn_count &value\n /* Dump target list TARGETS into FILE.  */\n \n static void\n-dump_targets (FILE *f, vec <cgraph_node *> targets)\n+dump_targets (FILE *f, vec <cgraph_node *> targets, bool verbose)\n {\n   unsigned int i;\n \n@@ -3471,6 +3471,13 @@ dump_targets (FILE *f, vec <cgraph_node *> targets)\n \tfprintf (f, \" (no definition%s)\",\n \t\t DECL_DECLARED_INLINE_P (targets[i]->decl)\n \t\t ? \" inline\" : \"\");\n+      /* With many targets for every call polymorphic dumps are going to\n+\t be quadratic in size.  */\n+      if (i > 10 && !verbose)\n+\t{\n+\t  fprintf (f, \" ... and %i more targets\\n\", targets.length () - i);\n+\t  return;\n+\t}\n     }\n   fprintf (f, \"\\n\");\n }\n@@ -3481,7 +3488,8 @@ void\n dump_possible_polymorphic_call_targets (FILE *f,\n \t\t\t\t\ttree otr_type,\n \t\t\t\t\tHOST_WIDE_INT otr_token,\n-\t\t\t\t\tconst ipa_polymorphic_call_context &ctx)\n+\t\t\t\t\tconst ipa_polymorphic_call_context &ctx,\n+\t\t\t\t\tbool verbose)\n {\n   vec <cgraph_node *> targets;\n   bool final;\n@@ -3506,15 +3514,15 @@ dump_possible_polymorphic_call_targets (FILE *f,\n \t   ctx.maybe_derived_type ? \" (derived types included)\" : \"\",\n \t   ctx.speculative_maybe_derived_type ? \" (speculative derived types included)\" : \"\");\n   len = targets.length ();\n-  dump_targets (f, targets);\n+  dump_targets (f, targets, verbose);\n \n   targets = possible_polymorphic_call_targets (otr_type, otr_token,\n \t\t\t\t\t       ctx,\n \t\t\t\t\t       &final, NULL, true);\n   if (targets.length () != len)\n     {\n       fprintf (f, \"  Speculative targets:\");\n-      dump_targets (f, targets);\n+      dump_targets (f, targets, verbose);\n     }\n   /* Ugly: during callgraph construction the target cache may get populated\n      before all targets are found.  While this is harmless (because all local\n@@ -3768,7 +3776,7 @@ ipa_devirt (void)\n \n \t    if (dump_file)\n \t      dump_possible_polymorphic_call_targets \n-\t\t(dump_file, e);\n+\t\t(dump_file, e, (dump_flags & TDF_DETAILS));\n \n \t    npolymorphic++;\n "}, {"sha": "02ce51b60830951f234c2fa7255bbc83de9ad014", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1dd347cbd7c1ac87b750a9100dfbde2f2190c63/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=c1dd347cbd7c1ac87b750a9100dfbde2f2190c63", "patch": "@@ -67,7 +67,8 @@ odr_type get_odr_type (tree, bool insert = false);\n bool odr_type_p (const_tree);\n bool possible_polymorphic_call_target_p (tree ref, gimple *stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t     const ipa_polymorphic_call_context &);\n+\t\t\t\t\t     const ipa_polymorphic_call_context &,\n+\t\t\t\t\t     bool verbose = true);\n bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n \t\t\t\t         const ipa_polymorphic_call_context &,\n \t\t\t\t\t struct cgraph_node *);\n@@ -137,13 +138,14 @@ possible_polymorphic_call_targets (tree ref,\n /* Dump possible targets of a polymorphic call E into F.  */\n \n inline void\n-dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n+dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e,\n+\t\t\t\t\tbool verbose = true)\n {\n   ipa_polymorphic_call_context context(e);\n \n   dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n \t\t\t\t\t  e->indirect_info->otr_token,\n-\t\t\t\t\t  context);\n+\t\t\t\t\t  context, verbose);\n }\n \n /* Return true if N can be possibly target of a polymorphic call of"}]}