{"sha": "e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNjYmE1ZTVhZmMzNDJhNzUwN2NiZjFjYzhmY2Q5MTU1MDRkYzkzMQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2009-02-27T14:56:19Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-02-27T14:56:19Z"}, "message": "s390.c: (s390_swap_cmp): Look for conditional jumps if COND is NULL.\n\n2009-02-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* gcc/config/s390/s390.c: (s390_swap_cmp): Look for conditional\n\tjumps if COND is NULL.\n\t(find_cond_jump): New function.\n\t(s390_z10_optimize_cmp): Handling for reg-reg compares added.\n\t* gcc/config/s390/s390.md: Remove z10_cobra attribute value.\n\nFrom-SVN: r144466", "tree": {"sha": "49f08a4d42a2d2487bc82fbdf0a9baa1d6190b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49f08a4d42a2d2487bc82fbdf0a9baa1d6190b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/comments", "author": null, "committer": null, "parents": [{"sha": "c9e9e11f464ea9b55afb257575e3d8b6c790c431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e9e11f464ea9b55afb257575e3d8b6c790c431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e9e11f464ea9b55afb257575e3d8b6c790c431"}], "stats": {"total": 206, "additions": 144, "deletions": 62}, "files": [{"sha": "27ccf26b107be9f572d50987eff7079b4016565e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "patch": "@@ -1,3 +1,11 @@\n+2009-02-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* gcc/config/s390/s390.c: (s390_swap_cmp): Look for conditional\n+\tjumps if COND is NULL.\n+\t(find_cond_jump): New function.\n+\t(s390_z10_optimize_cmp): Handling for reg-reg compares added.\n+\t* gcc/config/s390/s390.md: Remove z10_cobra attribute value.\n+\n 2009-02-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.h (alpha_expand_mov): Return false if"}, {"sha": "eb08828c29b21fd7ba6a477ecb3cfa2aa976014e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 131, "deletions": 56, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "patch": "@@ -9589,21 +9589,6 @@ s390_optimize_prologue (void)\n     }\n }\n \n-\n-/* Exchange the two operands of COND, and swap its mask so that the\n-   semantics does not change.  */\n-static void \n-s390_swap_cmp (rtx cond)\n-{\n-  enum rtx_code code = swap_condition (GET_CODE (cond));\n-  rtx tmp = XEXP (cond, 0);\n-\n-  XEXP (cond, 0) = XEXP (cond, 1);\n-  XEXP (cond, 1) = tmp;\n-  PUT_CODE (cond, code);\n-}\n-\n-\n /* Returns 1 if INSN reads the value of REG for purposes not related\n    to addressing of memory, and 0 otherwise.  */\n static int\n@@ -9613,6 +9598,71 @@ s390_non_addr_reg_read_p (rtx reg, rtx insn)\n     && !reg_used_in_mem_p (REGNO (reg), PATTERN (insn));\n }\n \n+/* Starting from INSN find_cond_jump looks downwards in the insn\n+   stream for a single jump insn which is the last user of the\n+   condition code set in INSN.  */\n+static rtx\n+find_cond_jump (rtx insn)\n+{\n+  for (; insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx ite, cc;\n+\n+      if (LABEL_P (insn))\n+\tbreak;\n+\n+      if (!JUMP_P (insn))\n+\t{\n+\t  if (reg_mentioned_p (gen_rtx_REG (CCmode, CC_REGNUM), insn))\n+\t    break;\n+\t  continue;\n+\t}\n+\n+      /* This will be triggered by a return.  */\n+      if (GET_CODE (PATTERN (insn)) != SET)\n+\tbreak;\n+\n+      gcc_assert (SET_DEST (PATTERN (insn)) == pc_rtx);\n+      ite = SET_SRC (PATTERN (insn));\n+\n+      if (GET_CODE (ite) != IF_THEN_ELSE)\n+\tbreak;\n+\n+      cc = XEXP (XEXP (ite, 0), 0);\n+      if (!REG_P (cc) || !CC_REGNO_P (REGNO (cc)))\n+\tbreak;\n+\n+      if (find_reg_note (insn, REG_DEAD, cc))\n+\treturn insn;\n+      break;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Swap the condition in COND and the operands in OP0 and OP1 so that\n+   the semantics does not change.  If NULL_RTX is passed as COND the\n+   function tries to find the conditional jump starting with INSN.  */\n+static void\n+s390_swap_cmp (rtx cond, rtx *op0, rtx *op1, rtx insn)\n+{\n+  rtx tmp = *op0;\n+\n+  if (cond == NULL_RTX)\n+    {\n+      rtx jump = find_cond_jump (NEXT_INSN (insn));\n+      jump = jump ? single_set (jump) : NULL_RTX;\n+\n+      if (jump == NULL_RTX)\n+\treturn;\n+\n+      cond = XEXP (XEXP (jump, 1), 0);\n+    }\n+\n+  *op0 = *op1;\n+  *op1 = tmp;\n+  PUT_CODE (cond, swap_condition (GET_CODE (cond)));\n+}\n \n /* On z10, instructions of the compare-and-branch family have the\n    property to access the register occurring as second operand with\n@@ -9622,62 +9672,87 @@ s390_non_addr_reg_read_p (rtx reg, rtx insn)\n    pipeline recycles, thereby causing significant performance decline.\n    This function locates such situations and exchanges the two\n    operands of the compare.  */\n-static void \n+static void\n s390_z10_optimize_cmp (void)\n {\n   rtx insn, prev_insn, next_insn;\n   int added_NOPs = 0;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n+      rtx cond, *op0, *op1;\n+\n       if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n \tcontinue;\n \n-      if (get_attr_z10prop (insn) == Z10PROP_Z10_COBRA)\n+      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t{\n-\t  rtx op0, op1, pattern, jump_expr, cond;\n+\t  /* Handle compare and branch and branch on count\n+\t     instructions.  */\n+\t  rtx pattern = single_set (insn);\n \n-\t  /* Extract the comparison\ufffds condition and its operands.  */\n-\t  pattern = single_set (insn);\n-\t  gcc_assert (GET_CODE (pattern) == SET);\n-\t  jump_expr = XEXP (pattern, 1);\n-\t  gcc_assert (GET_CODE (jump_expr) == IF_THEN_ELSE);\n-\t  cond = XEXP (jump_expr, 0);\n-\t  op0 = XEXP (cond, 0);\n-\t  op1 = XEXP (cond, 1);\n+\t  if (!pattern\n+\t      || SET_DEST (pattern) != pc_rtx\n+\t      || GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)\n+\t    continue;\n \n-\t  /* Swap the COMPARE\ufffds arguments and its mask if there is a\n-\t     conflicting access in the previous insn.  */\n-\t  prev_insn = PREV_INSN (insn);\n-          if (prev_insn != NULL_RTX && INSN_P (prev_insn) \n-              && reg_referenced_p (op1, PATTERN (prev_insn)))\n-\t    {\n-\t      s390_swap_cmp (cond);\n-   \t      op0 = XEXP (cond, 0);\n-\t      op1 = XEXP (cond, 1);\n-\t    }\n+\t  cond = XEXP (SET_SRC (pattern), 0);\n+\t  op0 = &XEXP (cond, 0);\n+\t  op1 = &XEXP (cond, 1);\n+\t}\n+      else if (GET_CODE (PATTERN (insn)) == SET)\n+\t{\n+\t  rtx src, dest;\n \n-\t  /* Check if there is a conflict with the next insn. If there\n-\t     was no conflict with the previous insn, then swap the\n-\t     COMPARE\u00b4s arguments and its mask.  If we already swapped\n-\t     the operands, or if swapping them would cause a conflict\n-\t     with the previous insn, issue a NOP after the COMPARE in\n-\t     order to separate the two instuctions.  */\n-\t  next_insn = NEXT_INSN (insn);\n-          if (next_insn != NULL_RTX && INSN_P (next_insn) \n-              && s390_non_addr_reg_read_p (op1, next_insn))\n-            {\n-\t      if (s390_non_addr_reg_read_p (op0, prev_insn))\n-\t\t{\n-                  if (REGNO(op1) == 0)\n-\t\t    emit_insn_after (gen_nop1 (), insn);\n-                  else\n-\t\t    emit_insn_after (gen_nop (), insn);\n-                  added_NOPs = 1;\n-                }\n+\t  /* Handle normal compare instructions.  */\n+\t  src = SET_SRC (PATTERN (insn));\n+\t  dest = SET_DEST (PATTERN (insn));\n+\n+\t  if (!REG_P (dest)\n+\t      || !CC_REGNO_P (REGNO (dest))\n+\t      || GET_CODE (src) != COMPARE)\n+\t    continue;\n+\n+\t  /* s390_swap_cmp will try to find the conditional\n+\t     jump when passing NULL_RTX as condition.  */\n+\t  cond = NULL_RTX;\n+\t  op0 = &XEXP (src, 0);\n+\t  op1 = &XEXP (src, 1);\n+\t}\n+      else\n+\tcontinue;\n+\n+      if (!REG_P (*op0) || !REG_P (*op1))\n+\tcontinue;\n+\n+      /* Swap the COMPARE arguments and its mask if there is a\n+\t conflicting access in the previous insn.  */\n+      prev_insn = PREV_INSN (insn);\n+      if (prev_insn != NULL_RTX && INSN_P (prev_insn)\n+\t  && reg_referenced_p (*op1, PATTERN (prev_insn)))\n+\ts390_swap_cmp (cond, op0, op1, insn);\n+\n+      /* Check if there is a conflict with the next insn. If there\n+\t was no conflict with the previous insn, then swap the\n+\t COMPARE arguments and its mask.  If we already swapped\n+\t the operands, or if swapping them would cause a conflict\n+\t with the previous insn, issue a NOP after the COMPARE in\n+\t order to separate the two instuctions.  */\n+      next_insn = NEXT_INSN (insn);\n+      if (next_insn != NULL_RTX && INSN_P (next_insn)\n+\t  && s390_non_addr_reg_read_p (*op1, next_insn))\n+\t{\n+\t  if (prev_insn != NULL_RTX && INSN_P (prev_insn)\n+\t      && s390_non_addr_reg_read_p (*op0, prev_insn))\n+\t    {\n+\t      if (REGNO (*op1) == 0)\n+\t\temit_insn_after (gen_nop1 (), insn);\n \t      else\n- \t        s390_swap_cmp (cond);\n+\t\temit_insn_after (gen_nop (), insn);\n+\t      added_NOPs = 1;\n \t    }\n+\t  else\n+\t    s390_swap_cmp (cond, op0, op1, insn);\n \t}\n     }\n \n@@ -9799,7 +9874,7 @@ s390_reorg (void)\n \n   /* Eliminate z10-specific pipeline recycles related to some compare\n      instructions.  */\n-  if (TARGET_Z10)\n+  if (s390_tune == PROCESSOR_2097_Z10)\n     s390_z10_optimize_cmp ();\n }\n "}, {"sha": "7ecc3ccb353aff159b397c05623f8e12c2c93e3c", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3cba5e5afc342a7507cbf1cc8fcd915504dc931/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=e3cba5e5afc342a7507cbf1cc8fcd915504dc931", "patch": "@@ -235,7 +235,6 @@\n ;;   can immediately read the new value.\n ;; z10_fr: union of Z10_fwd and z10_rec.\n ;; z10_c: second operand of instruction is a register and read with complemented bits.\n-;; z10_cobra: its a compare and branch instruction\n ;;\n ;; An additional suffix A1, A3, or E1 indicates the respective AGI bypass.\n \n@@ -245,7 +244,7 @@\n                         z10_fwd, z10_fwd_A1, z10_fwd_A3, z10_fwd_E1,\n                         z10_rec,\n                         z10_fr, z10_fr_A3, z10_fr_E1,\n-                        z10_c, z10_cobra\"\n+                        z10_c\"\n              (const_string \"none\"))\n \n \n@@ -774,7 +773,7 @@\n    cy\\t%0,%1\n    #\"\n   [(set_attr \"op_type\" \"RR,RI,RIL,RX,RXY,SS\")\n-   (set_attr \"z10prop\" \"z10_super,z10_super,z10_super,z10_super,z10_super,*\")])\n+   (set_attr \"z10prop\" \"z10_super_c,z10_super,z10_super,z10_super,z10_super,*\")])\n \n ; Compare (signed) instructions\n \n@@ -1043,7 +1042,7 @@\n }\n   [(set_attr \"op_type\" \"RIE\")\n    (set_attr \"type\"    \"branch\")\n-   (set_attr \"z10prop\" \"z10_cobra,z10_super\")\n+   (set_attr \"z10prop\" \"z10_super_c,z10_super\")\n    (set (attr \"length\")\n         (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))\n                       (const_int 6) (const_int 12)))]) ; 8 byte for cr/jg\n@@ -1071,7 +1070,7 @@\n }\n   [(set_attr \"op_type\" \"RIE\")\n    (set_attr \"type\"    \"branch\")\n-   (set_attr \"z10prop\" \"z10_cobra,z10_super\")\n+   (set_attr \"z10prop\" \"z10_super_c,z10_super\")\n    (set (attr \"length\")\n         (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))\n                       (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg\n@@ -7679,7 +7678,7 @@\n                       (const_string \"RR\") (const_string \"RX\")))\n    (set_attr \"type\"  \"branch\")\n    (set_attr \"atype\" \"agen\")\n-   (set_attr \"z10prop\"  \"z10_cobra\")])\n+   (set_attr \"z10prop\"  \"z10_c\")])\n \n (define_insn_and_split \"doloop_di\"\n   [(set (pc)"}]}