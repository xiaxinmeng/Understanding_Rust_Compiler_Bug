{"sha": "bfae1846ce6fb95a064520e4560fbd191abd2f04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhZTE4NDZjZTZmYjk1YTA2NDUyMGU0NTYwZmJkMTkxYWJkMmYwNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T10:04:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T10:04:58Z"}, "message": "[multiple changes]\n\n2010-10-08  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch4.adb: Minor reformatting.\n\n2010-10-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Flag 232 (formerly Implemented_By_Entry) is now unused.\n\t(Implemented_By_Entry): Removed.\n\t(Set_Implemented_By_Entry): Removed.\n\t(Write_Entity_Flags): Remove the output for Implemented_By_Entry.\n\t* einfo.ads: Remove flag Implemented_By_Entry and its usage in entities.\n\t(Implemented_By_Entry): Removed along with its associated pragma Inline.\n\t(Set_Implemented_By_Entry): Removed along with its associated pragma\n\tInline.\n\t* exp_ch9.adb: Alphabetize with and use clauses of Exp_Ch9.\n\t(Build_Dispatching_Call_Equivalent): New routine.\n\t(Build_Dispatching_Requeue): New routine.\n\t(Build_Dispatching_Requeue_To_Any): New routine.\n\t(Build_Normal_Requeue): New routine.\n\t(Build_Skip_Statement): New routine.\n\t(Expand_N_Requeue_Statement): Rewritten. The logic has been split into\n\tseveral subroutines.\n\t* par-prag.adb: Replace Pragma_Implemented_By_Entry by\n\tPragma_Implemented.\n\t* sem_ch3.adb (Check_Abstract_Overriding): Perform checks concerning\n\tpragma Implemented.\n\t(Check_Pragma_Implemented): New routines.\n\t(Inherit_Pragma_Implemented): New routine.\n\t* sem_ch9.adb (Analyze_Requeue): Update the predicate which detects a\n\tdispatching requeue.\n\t* sem_prag.adb: Update array Sig_Flags by removing Implemented_By_Entry\n\tand adding Implemented.\n\t(Ada_2012_Pragma): New routine.\n\t(Analyze_Pragma, case Implemented): Perform all necessary checks\n\tconcerning pragma Implemented and register the pragma as a\n\trepresentation item with the procedure_LOCAL_NAME.\n\t(Analyze_Pragma, case Implemented_By_Entry): Removed.\n\t* sem_util.adb (Implementation_Kind): New routine.\n\t* sem_util.ads (Implementation_Kind): New routine.\n\t* snames.ads-tmpl: Remove Name_Implemented_By_Entry and add\n\tName_Implemented. Remove pragma name Pragma_Implemented_By_Entry and\n\tadd Pragma_Implemented. Add special names By_Any, By_Entry and\n\tBy_Protected_Procedure.\n\n2010-10-08  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Expand_Freeeze_Record_Type): Code cleanup: remove local\n\tvariable Has_Static_DT by invocation of function Building_Static_DT.\n\n2010-10-08  Vincent Celier  <celier@adacore.com>\n\n\t* g-dirope.adb (Remove_Dir): Do not change the current directory when\n\tdoing a recursive remove of a subdirectory.\n\n2010-10-08  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.ad (Freeze_Subprogram): Factorize code.\n\t* exp_disp.adb (Make_Secondary_DT): Factorize code.\n\t(Make_DT): Factorize code.\n\nFrom-SVN: r165154", "tree": {"sha": "d43dbb67c7611ef8ce3182ec8f37d1efc078dd4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d43dbb67c7611ef8ce3182ec8f37d1efc078dd4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfae1846ce6fb95a064520e4560fbd191abd2f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfae1846ce6fb95a064520e4560fbd191abd2f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfae1846ce6fb95a064520e4560fbd191abd2f04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfae1846ce6fb95a064520e4560fbd191abd2f04/comments", "author": null, "committer": null, "parents": [{"sha": "40b93859aabbc52f61def4ad22f5e598a6e46c54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b93859aabbc52f61def4ad22f5e598a6e46c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b93859aabbc52f61def4ad22f5e598a6e46c54"}], "stats": {"total": 1145, "additions": 874, "deletions": 271}, "files": [{"sha": "364f268fc4f9cef48a7596c583b696326120618c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -1,3 +1,63 @@\n+2010-10-08  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch4.adb: Minor reformatting.\n+\n+2010-10-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Flag 232 (formerly Implemented_By_Entry) is now unused.\n+\t(Implemented_By_Entry): Removed.\n+\t(Set_Implemented_By_Entry): Removed.\n+\t(Write_Entity_Flags): Remove the output for Implemented_By_Entry.\n+\t* einfo.ads: Remove flag Implemented_By_Entry and its usage in entities.\n+\t(Implemented_By_Entry): Removed along with its associated pragma Inline.\n+\t(Set_Implemented_By_Entry): Removed along with its associated pragma\n+\tInline.\n+\t* exp_ch9.adb: Alphabetize with and use clauses of Exp_Ch9.\n+\t(Build_Dispatching_Call_Equivalent): New routine.\n+\t(Build_Dispatching_Requeue): New routine.\n+\t(Build_Dispatching_Requeue_To_Any): New routine.\n+\t(Build_Normal_Requeue): New routine.\n+\t(Build_Skip_Statement): New routine.\n+\t(Expand_N_Requeue_Statement): Rewritten. The logic has been split into\n+\tseveral subroutines.\n+\t* par-prag.adb: Replace Pragma_Implemented_By_Entry by\n+\tPragma_Implemented.\n+\t* sem_ch3.adb (Check_Abstract_Overriding): Perform checks concerning\n+\tpragma Implemented.\n+\t(Check_Pragma_Implemented): New routines.\n+\t(Inherit_Pragma_Implemented): New routine.\n+\t* sem_ch9.adb (Analyze_Requeue): Update the predicate which detects a\n+\tdispatching requeue.\n+\t* sem_prag.adb: Update array Sig_Flags by removing Implemented_By_Entry\n+\tand adding Implemented.\n+\t(Ada_2012_Pragma): New routine.\n+\t(Analyze_Pragma, case Implemented): Perform all necessary checks\n+\tconcerning pragma Implemented and register the pragma as a\n+\trepresentation item with the procedure_LOCAL_NAME.\n+\t(Analyze_Pragma, case Implemented_By_Entry): Removed.\n+\t* sem_util.adb (Implementation_Kind): New routine.\n+\t* sem_util.ads (Implementation_Kind): New routine.\n+\t* snames.ads-tmpl: Remove Name_Implemented_By_Entry and add\n+\tName_Implemented. Remove pragma name Pragma_Implemented_By_Entry and\n+\tadd Pragma_Implemented. Add special names By_Any, By_Entry and\n+\tBy_Protected_Procedure.\n+\n+2010-10-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_Freeeze_Record_Type): Code cleanup: remove local\n+\tvariable Has_Static_DT by invocation of function Building_Static_DT.\n+\n+2010-10-08  Vincent Celier  <celier@adacore.com>\n+\n+\t* g-dirope.adb (Remove_Dir): Do not change the current directory when\n+\tdoing a recursive remove of a subdirectory.\n+\n+2010-10-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.ad (Freeze_Subprogram): Factorize code.\n+\t* exp_disp.adb (Make_Secondary_DT): Factorize code.\n+\t(Make_DT): Factorize code.\n+\n 2010-10-08  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch4.adb: Minor reformatting."}, {"sha": "7ec3f8dc1b98a8f4cbde12947fe573e4a8c27720", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -493,7 +493,6 @@ package body Einfo is\n    --    Has_Pragma_Inline_Always        Flag230\n \n    --    Renamed_In_Spec                 Flag231\n-   --    Implemented_By_Entry            Flag232\n    --    Has_Pragma_Unmodified           Flag233\n    --    Is_Dispatch_Table_Entity        Flag234\n    --    Is_Trivial_Subprogram           Flag235\n@@ -512,6 +511,7 @@ package body Einfo is\n    --    OK_To_Rename                    Flag247\n \n    --    (unused)                        Flag200\n+   --    (unused)                        Flag232\n \n    -----------------------\n    -- Local subprograms --\n@@ -1536,12 +1536,6 @@ package body Einfo is\n       return Node4 (Id);\n    end Homonym;\n \n-   function Implemented_By_Entry (Id : E) return B is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n-      return Flag232 (Id);\n-   end Implemented_By_Entry;\n-\n    function Interfaces (Id : E) return L is\n    begin\n       pragma Assert (Is_Record_Type (Id));\n@@ -3958,12 +3952,6 @@ package body Einfo is\n       Set_Node4 (Id, V);\n    end Set_Homonym;\n \n-   procedure Set_Implemented_By_Entry (Id : E; V : B := True) is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n-      Set_Flag232 (Id, V);\n-   end Set_Implemented_By_Entry;\n-\n    procedure Set_Interfaces (Id : E; V : L) is\n    begin\n       pragma Assert (Is_Record_Type (Id));\n@@ -6958,7 +6946,6 @@ package body Einfo is\n       W (\"Has_Up_Level_Access\",             Flag215 (Id));\n       W (\"Has_Volatile_Components\",         Flag87  (Id));\n       W (\"Has_Xref_Entry\",                  Flag182 (Id));\n-      W (\"Implemented_By_Entry\",            Flag232 (Id));\n       W (\"In_Package_Body\",                 Flag48  (Id));\n       W (\"In_Private_Part\",                 Flag45  (Id));\n       W (\"In_Use\",                          Flag8   (Id));"}, {"sha": "074eefc160a54075339f6a7e08706327a292adef", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -1806,10 +1806,6 @@ package Einfo is\n --       that we still have a concrete type. For entities other than types,\n --       returns the entity unchanged.\n \n---    Implemented_By_Entry (Flag232)\n---       Applies to functions and procedures. Set if pragma Implemented_By_\n---       Entry is applied on the subprogram entity.\n-\n --    Interfaces (Elist25)\n --       Present in record types and subtypes. List of abstract interfaces\n --       implemented by a tagged type that are not already implemented by the\n@@ -5052,7 +5048,6 @@ package Einfo is\n    --    Has_Postconditions                  (Flag240)\n    --    Has_Recursive_Call                  (Flag143)\n    --    Has_Subprogram_Descriptor           (Flag93)\n-   --    Implemented_By_Entry                (Flag232)  (non-generic case only)\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Constructor                      (Flag76)\n@@ -5311,7 +5306,6 @@ package Einfo is\n    --    Has_Nested_Block_With_Handler       (Flag101)\n    --    Has_Postconditions                  (Flag240)\n    --    Has_Subprogram_Descriptor           (Flag93)\n-   --    Implemented_By_Entry                (Flag232)  (non-generic case only)\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Asynchronous                     (Flag81)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n@@ -5928,7 +5922,6 @@ package Einfo is\n    function Has_Xref_Entry                      (Id : E) return B;\n    function Hiding_Loop_Variable                (Id : E) return E;\n    function Homonym                             (Id : E) return E;\n-   function Implemented_By_Entry                (Id : E) return B;\n    function In_Package_Body                     (Id : E) return B;\n    function In_Private_Part                     (Id : E) return B;\n    function In_Use                              (Id : E) return B;\n@@ -6490,7 +6483,6 @@ package Einfo is\n    procedure Set_Has_Xref_Entry                  (Id : E; V : B := True);\n    procedure Set_Hiding_Loop_Variable            (Id : E; V : E);\n    procedure Set_Homonym                         (Id : E; V : E);\n-   procedure Set_Implemented_By_Entry            (Id : E; V : B := True);\n    procedure Set_Interfaces                      (Id : E; V : L);\n    procedure Set_In_Package_Body                 (Id : E; V : B := True);\n    procedure Set_In_Private_Part                 (Id : E; V : B := True);\n@@ -7150,7 +7142,6 @@ package Einfo is\n    pragma Inline (Has_Xref_Entry);\n    pragma Inline (Hiding_Loop_Variable);\n    pragma Inline (Homonym);\n-   pragma Inline (Implemented_By_Entry);\n    pragma Inline (Interfaces);\n    pragma Inline (In_Package_Body);\n    pragma Inline (In_Private_Part);\n@@ -7583,7 +7574,6 @@ package Einfo is\n    pragma Inline (Set_Has_Xref_Entry);\n    pragma Inline (Set_Hiding_Loop_Variable);\n    pragma Inline (Set_Homonym);\n-   pragma Inline (Set_Implemented_By_Entry);\n    pragma Inline (Set_Interfaces);\n    pragma Inline (Set_In_Package_Body);\n    pragma Inline (Set_In_Private_Part);"}, {"sha": "0995f5a1b0437bd3c3ae612b18c6c17870797a5d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -5863,7 +5863,6 @@ package body Exp_Ch3 is\n       Type_Decl     : constant Node_Id := Parent (Def_Id);\n       Comp          : Entity_Id;\n       Comp_Typ      : Entity_Id;\n-      Has_Static_DT : Boolean := False;\n       Predef_List   : List_Id;\n \n       Flist : Entity_Id := Empty;\n@@ -5982,9 +5981,6 @@ package body Exp_Ch3 is\n       --  just use it.\n \n       if Is_Tagged_Type (Def_Id) then\n-         Has_Static_DT :=\n-           Static_Dispatch_Tables\n-             and then Is_Library_Level_Tagged_Type (Def_Id);\n \n          --  Add the _Tag component\n \n@@ -6004,7 +6000,7 @@ package body Exp_Ch3 is\n             Set_CPP_Constructors (Def_Id);\n \n          else\n-            if not Has_Static_DT then\n+            if not Building_Static_DT (Def_Id) then\n \n                --  Usually inherited primitives are not delayed but the first\n                --  Ada extension of a CPP_Class is an exception since the\n@@ -6116,7 +6112,7 @@ package body Exp_Ch3 is\n                --  Dispatch tables of library level tagged types are built\n                --  later (see Analyze_Declarations).\n \n-               if not Has_Static_DT then\n+               if not Building_Static_DT (Def_Id) then\n                   Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n                end if;\n             end if;"}, {"sha": "6cfc955ffa5e9ef37b854192c1cc0bafa76f441d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -4998,10 +4998,8 @@ package body Exp_Ch6 is\n             --  Generate code to register the primitive in non statically\n             --  allocated dispatch tables\n \n-            elsif not Static_Dispatch_Tables\n-              or else not\n-                Is_Library_Level_Tagged_Type (Scope (DTC_Entity (Subp)))\n-            then\n+            elsif not Building_Static_DT (Scope (DTC_Entity (Subp))) then\n+\n                --  When a primitive is frozen, enter its name in its dispatch\n                --  table slot.\n "}, {"sha": "90853ea46e4f1c984950e2339b3e5da2179a6d5a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 458, "deletions": 128, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -29,8 +29,8 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch3;  use Exp_Ch3;\n-with Exp_Ch11; use Exp_Ch11;\n with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Disp; use Exp_Disp;\n with Exp_Sel;  use Exp_Sel;\n@@ -8310,8 +8310,10 @@ package body Exp_Ch9 is\n    --     when all others =>\n    --        Exceptional_Complete_Rendezvous (Get_GNAT_Exception);\n \n-   --  Ada 2005 (AI05-0030): Dispatching requeue from protected to interface\n-   --  class-wide type:\n+   --  Ada 2012 (AI05-0030): Dispatching requeue to an interface primitive\n+   --  marked by pragma Implemented (XXX, By_Entry).\n+\n+   --  The requeue is inside a protected entry:\n \n    --  procedure entE\n    --    (O : System.Address;\n@@ -8347,10 +8349,9 @@ package body Exp_Ch9 is\n    --     end;\n    --  end entE;\n \n-   --  Ada 2005 (AI05-0030): Dispatching requeue from task to interface\n-   --  class-wide type:\n+   --  The requeue is inside a task entry:\n \n-   --  Accept_Call (E, Ann);\n+   --    Accept_Call (E, Ann);\n    --     <start of statement sequence for accept statement>\n    --     _Disp_Requeue\n    --       (<interface class-wide object>,\n@@ -8370,63 +8371,159 @@ package body Exp_Ch9 is\n    --     when all others =>\n    --        Exceptional_Complete_Rendezvous (Get_GNAT_Exception);\n \n-   --  Further details on these expansions can be found in Expand_N_Protected_\n-   --  Body and Expand_N_Accept_Statement.\n+   --  Ada 2012 (AI05-0030): Dispatching requeue to an interface primitive\n+   --  marked by pragma Implemented (XXX, By_Protected_Procedure). The requeue\n+   --  statement is replaced by a dispatching call with actual parameters taken\n+   --  from the inner-most accept statement or entry body.\n+\n+   --    Target.Primitive (Param1, ..., ParamN);\n+\n+   --  Ada 2012 (AI05-0030): Dispatching requeue to an interface primitive\n+   --  marked by pragma Implemented (XXX, By_Any) or not marked at all.\n+\n+   --    declare\n+   --       S : constant Offset_Index :=\n+   --             Get_Offset_Index (Tag (Concval), DT_Position (Ename));\n+   --       C : constant Prim_Op_Kind := Get_Prim_Op_Kind (Tag (Concval), S);\n+\n+   --    begin\n+   --       if C = POK_Protected_Entry\n+   --         or else C = POK_Task_Entry\n+   --       then\n+   --          <statements for dispatching requeue>\n+\n+   --       elsif C = POK_Protected_Procedure then\n+   --          <dispatching call equivalent>\n+\n+   --       else\n+   --          raise Program_Error;\n+   --       end if;\n+   --    end;\n \n    procedure Expand_N_Requeue_Statement (N : Node_Id) is\n-      Loc        : constant Source_Ptr := Sloc (N);\n-      Abortable  : Node_Id;\n-      Acc_Stat   : Node_Id;\n-      Conc_Typ   : Entity_Id;\n-      Concval    : Node_Id;\n-      Ename      : Node_Id;\n-      Index      : Node_Id;\n-      Lab_Node   : Node_Id;\n-      New_Param  : Node_Id;\n-      Old_Typ    : Entity_Id;\n-      Params     : List_Id;\n-      Rcall      : Node_Id;\n-      RTS_Call   : Entity_Id;\n-      Self_Param : Node_Id;\n-      Skip_Stat  : Node_Id;\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Conc_Typ : Entity_Id;\n+      Concval  : Node_Id;\n+      Ename    : Node_Id;\n+      Index    : Node_Id;\n+      Old_Typ  : Entity_Id;\n+\n+      function Build_Dispatching_Call_Equivalent return Node_Id;\n+      --  Ada 2012 (AI05-0030): N denotes a dispatching requeue statement of\n+      --  the form Concval.Ename. It is statically known that Ename is allowed\n+      --  to be implemented by a protected procedure. Create a dispatching call\n+      --  equivalent of Concval.Ename taking the actual parameters from the\n+      --  inner-most accept statement or entry body.\n+\n+      function Build_Dispatching_Requeue return Node_Id;\n+      --  Ada 2012 (AI05-0030): N denotes a dispatching requeue statement of\n+      --  the form Concval.Ename. It is statically known that Ename is allowed\n+      --  to be implemented by a protected or a task entry. Create a call to\n+      --  primitive _Disp_Requeue which handles the low-level actions.\n+\n+      function Build_Dispatching_Requeue_To_Any return Node_Id;\n+      --  Ada 2012 (AI05-0030): N denotes a dispatching requeue statement of\n+      --  the form Concval.Ename. Ename is either marked by pragma Implemented\n+      --  (XXX, By_Any) or not marked at all. Create a block which determines\n+      --  at runtime whether Ename denotes an entry or a procedure and perform\n+      --  the appropriate kind of dispatching select.\n+\n+      function Build_Normal_Requeue return Node_Id;\n+      --  N denotes a non-dispatching requeue statement to either a task or a\n+      --  protected entry. Build the appropriate runtime call to perform the\n+      --  action.\n+\n+      function Build_Skip_Statement (Search : Node_Id) return Node_Id;\n+      --  For a protected entry, create a return statement to skip the rest of\n+      --  the entry body. Otherwise, create a goto statement to skip the rest\n+      --  of a task accept statement. The lookup for the enclosing entry body\n+      --  or accept statement starts from Search.\n \n-   begin\n-      Abortable :=\n-        New_Occurrence_Of (Boolean_Literals (Abort_Present (N)), Loc);\n+      ---------------------------------------\n+      -- Build_Dispatching_Call_Equivalent --\n+      ---------------------------------------\n \n-      --  Extract the components of the entry call\n+      function Build_Dispatching_Call_Equivalent return Node_Id is\n+         Call_Ent : constant Entity_Id := Entity (Ename);\n+         Obj      : constant Node_Id   := Original_Node (Concval);\n+         Acc_Ent  : Node_Id;\n+         Actuals  : List_Id;\n+         Formal   : Node_Id;\n+         Formals  : List_Id;\n \n-      Extract_Entry (N, Concval, Ename, Index);\n-      Conc_Typ := Etype (Concval);\n+      begin\n+         --  Climb the parent chain looking for the inner-most entry body or\n+         --  accept statement.\n \n-      --  Examine the scope stack in order to find nearest enclosing protected\n-      --  or task type. This will constitute our invocation source.\n+         Acc_Ent := N;\n+         while Present (Acc_Ent)\n+           and then not Nkind_In (Acc_Ent, N_Accept_Statement,\n+                                           N_Entry_Body)\n+         loop\n+            Acc_Ent := Parent (Acc_Ent);\n+         end loop;\n \n-      Old_Typ := Current_Scope;\n-      while Present (Old_Typ)\n-        and then not Is_Protected_Type (Old_Typ)\n-        and then not Is_Task_Type (Old_Typ)\n-      loop\n-         Old_Typ := Scope (Old_Typ);\n-      end loop;\n+         --  A requeue statement should be housed inside an entry body or an\n+         --  accept statement at some level. If this is not the case, then the\n+         --  tree is malformed.\n \n-      --  Generate the parameter list for all cases. The abortable flag is\n-      --  common among dispatching and regular requeue.\n+         pragma Assert (Present (Acc_Ent));\n \n-      Params := New_List (Abortable);\n+         --  Recover the list of formal parameters\n \n-      --  Ada 2005 (AI05-0030): We have a dispatching requeue of the form\n-      --  Concval.Ename where the type of Concval is class-wide concurrent\n-      --  interface.\n+         if Nkind (Acc_Ent) = N_Entry_Body then\n+            Acc_Ent := Entry_Body_Formal_Part (Acc_Ent);\n+         end if;\n \n-      if Ada_Version >= Ada_05\n-        and then Present (Concval)\n-        and then Is_Class_Wide_Type (Conc_Typ)\n-        and then Is_Concurrent_Interface (Conc_Typ)\n-      then\n-         RTS_Call := Make_Identifier (Loc, Name_uDisp_Requeue);\n+         Formals := Parameter_Specifications (Acc_Ent);\n+\n+         --  Create the actual parameters for the dispatching call. These are\n+         --  simply copies of the entry body or accept statement formals in the\n+         --  same order as they appear.\n+\n+         Actuals := No_List;\n+\n+         if Present (Formals) then\n+            Actuals := New_List;\n+            Formal  := First (Formals);\n+            while Present (Formal) loop\n+               Append_To (Actuals,\n+                 Make_Identifier (Loc, Chars (Defining_Identifier (Formal))));\n+               Next (Formal);\n+            end loop;\n+         end if;\n \n          --  Generate:\n+         --    Obj.Call_Ent (Actuals);\n+\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               Make_Selected_Component (Loc,\n+                 Prefix =>\n+                   Make_Identifier (Loc, Chars (Obj)),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Chars (Call_Ent))),\n+\n+             Parameter_Associations => Actuals);\n+      end Build_Dispatching_Call_Equivalent;\n+\n+      -------------------------------\n+      -- Build_Dispatching_Requeue --\n+      -------------------------------\n+\n+      function Build_Dispatching_Requeue return Node_Id is\n+         Params : constant List_Id := New_List;\n+\n+      begin\n+         --  Process the \"with abort\" parameter\n+\n+         Prepend_To (Params,\n+           New_Reference_To (Boolean_Literals (Abort_Present (N)), Loc));\n+\n+         --  Process the entry wrapper's position in the primary dispatch\n+         --  table parameter. Generate:\n+\n          --    Ada.Tags.Get_Offset_Index\n          --      (Ada.Tags.Tag (Concval),\n          --       <interface dispatch table position of Ename>)\n@@ -8435,156 +8532,389 @@ package body Exp_Ch9 is\n            Make_Function_Call (Loc,\n              Name =>\n                New_Reference_To (RTE (RE_Get_Offset_Index), Loc),\n-             Parameter_Associations =>\n-               New_List (\n-                 Unchecked_Convert_To (RTE (RE_Tag), Concval),\n-                 Make_Integer_Literal (Loc, DT_Position (Entity (Ename))))));\n \n-         --  Specific actuals for protected to interface class-wide type\n-         --  requeue.\n+             Parameter_Associations => New_List (\n+               Unchecked_Convert_To (RTE (RE_Tag), Concval),\n+               Make_Integer_Literal (Loc, DT_Position (Entity (Ename))))));\n+\n+         --  Specific actuals for protected to XXX requeue\n \n          if Is_Protected_Type (Old_Typ) then\n             Prepend_To (Params,\n               Make_Attribute_Reference (Loc,        --  _object'Address\n                 Prefix =>\n                   Concurrent_Ref (New_Occurrence_Of (Old_Typ, Loc)),\n-                Attribute_Name =>\n-                  Name_Address));\n+                Attribute_Name => Name_Address));\n+\n             Prepend_To (Params,                     --  True\n               New_Reference_To (Standard_True, Loc));\n \n-         --  Specific actuals for task to interface class-wide type requeue\n+         --  Specific actuals for task to XXX requeue\n \n          else\n             pragma Assert (Is_Task_Type (Old_Typ));\n \n             Prepend_To (Params,                     --  null\n               New_Reference_To (RTE (RE_Null_Address), Loc));\n+\n             Prepend_To (Params,                     --  False\n               New_Reference_To (Standard_False, Loc));\n          end if;\n \n-         --  Finally, add the common object parameter\n+         --  Add the object parameter\n \n          Prepend_To (Params, New_Copy_Tree (Concval));\n \n-      --  Regular requeue processing\n+         --  Generate:\n+         --    _Disp_Requeue (<Params>);\n \n-      else\n-         New_Param := Concurrent_Ref (Concval);\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               Make_Identifier (Loc, Name_uDisp_Requeue),\n+             Parameter_Associations => Params);\n+      end Build_Dispatching_Requeue;\n+\n+      --------------------------------------\n+      -- Build_Dispatching_Requeue_To_Any --\n+      --------------------------------------\n+\n+      function Build_Dispatching_Requeue_To_Any return Node_Id is\n+         Call_Ent : constant Entity_Id := Entity (Ename);\n+         Obj      : constant Node_Id   := Original_Node (Concval);\n+         Skip     : constant Node_Id   := Build_Skip_Statement (N);\n+         C        : Entity_Id;\n+         Decls    : List_Id;\n+         S        : Entity_Id;\n+         Stmts    : List_Id;\n+\n+      begin\n+         Decls := New_List;\n+         Stmts := New_List;\n \n-         --  The index expression is common among all four cases\n+         --  Dispatch table slot processing, generate:\n+         --    S : Integer;\n+\n+         S := Build_S (Loc, Decls);\n+\n+         --  Call kind processing, generate:\n+         --    C : Ada.Tags.Prim_Op_Kind;\n+\n+         C := Build_C (Loc, Decls);\n+\n+         --  Generate:\n+         --    S := Ada.Tags.Get_Offset_Index\n+         --           (Ada.Tags.Tag (Obj), DT_Position (Call_Ent));\n+\n+         Append_To (Stmts, Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+\n+         --  Generate:\n+         --    _Disp_Get_Prim_Op_Kind (Obj, S, C);\n+\n+         Append_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               New_Reference_To (\n+                 Find_Prim_Op (Etype (Etype (Obj)),\n+                   Name_uDisp_Get_Prim_Op_Kind),\n+                 Loc),\n+             Parameter_Associations => New_List (\n+               New_Copy_Tree (Obj),\n+               New_Reference_To (S, Loc),\n+               New_Reference_To (C, Loc))));\n+\n+         Append_To (Stmts,\n+\n+            --  if C = POK_Protected_Entry\n+            --    or else C = POK_Task_Entry\n+            --  then\n+\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Or (Loc,\n+                 Left_Opnd =>\n+                   Make_Op_Eq (Loc,\n+                     Left_Opnd =>\n+                       New_Reference_To (C, Loc),\n+                     Right_Opnd =>\n+                       New_Reference_To (RTE (RE_POK_Protected_Entry), Loc)),\n+\n+                 Right_Opnd =>\n+                   Make_Op_Eq (Loc,\n+                     Left_Opnd =>\n+                       New_Reference_To (C, Loc),\n+                     Right_Opnd =>\n+                       New_Reference_To (RTE (RE_POK_Task_Entry), Loc))),\n+\n+               --  Dispatching requeue equivalent\n+\n+             Then_Statements => New_List (\n+               Build_Dispatching_Requeue,\n+               Skip),\n+\n+               --  elsif C = POK_Protected_Procedure then\n+\n+             Elsif_Parts => New_List (\n+               Make_Elsif_Part (Loc,\n+                 Condition =>\n+                   Make_Op_Eq (Loc,\n+                     Left_Opnd =>\n+                       New_Reference_To (C, Loc),\n+                     Right_Opnd =>\n+                       New_Reference_To (\n+                         RTE (RE_POK_Protected_Procedure), Loc)),\n+\n+                  --  Dispatching call equivalent\n+\n+                 Then_Statements => New_List (\n+                   Build_Dispatching_Call_Equivalent))),\n+\n+            --  else\n+            --     raise Program_Error;\n+            --  end if;\n+\n+             Else_Statements => New_List (\n+               Make_Raise_Program_Error (Loc,\n+                 Reason => PE_Explicit_Raise))));\n+\n+         --  Wrap everything into a block\n+\n+         return\n+           Make_Block_Statement (Loc,\n+             Declarations => Decls,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stmts));\n+      end Build_Dispatching_Requeue_To_Any;\n+\n+      --------------------------\n+      -- Build_Normal_Requeue --\n+      --------------------------\n+\n+      function Build_Normal_Requeue return Node_Id is\n+         Params  : constant List_Id := New_List;\n+         Param   : Node_Id;\n+         RT_Call : Node_Id;\n+\n+      begin\n+         --  Process the \"with abort\" parameter\n \n          Prepend_To (Params,\n-           Entry_Index_Expression (Loc, Entity (Ename), Index, Conc_Typ));\n+           New_Reference_To (Boolean_Literals (Abort_Present (N)), Loc));\n \n-         if Is_Protected_Type (Old_Typ) then\n-            Self_Param :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix =>\n-                  Concurrent_Ref (New_Occurrence_Of (Old_Typ, Loc)),\n-                Attribute_Name =>\n-                  Name_Unchecked_Access);\n+         --  Add the index expression to the parameters. It is common among all\n+         --  four cases.\n \n-            --  Protected to protected requeue\n+         Prepend_To (Params,\n+           Entry_Index_Expression (Loc, Entity (Ename), Index, Conc_Typ));\n \n-            if Is_Protected_Type (Conc_Typ) then\n-               RTS_Call :=\n-                 New_Reference_To (RTE (RE_Requeue_Protected_Entry), Loc);\n+         if Is_Protected_Type (Old_Typ) then\n+            declare\n+               Self_Param : Node_Id;\n \n-               New_Param :=\n+            begin\n+               Self_Param :=\n                  Make_Attribute_Reference (Loc,\n                    Prefix =>\n-                     New_Param,\n+                     Concurrent_Ref (New_Occurrence_Of (Old_Typ, Loc)),\n                    Attribute_Name =>\n                      Name_Unchecked_Access);\n \n-            --  Protected to task requeue\n+               --  Protected to protected requeue\n \n-            else\n-               pragma Assert (Is_Task_Type (Conc_Typ));\n-               RTS_Call :=\n-                 New_Reference_To (\n-                   RTE (RE_Requeue_Protected_To_Task_Entry), Loc);\n-            end if;\n+               if Is_Protected_Type (Conc_Typ) then\n+                  RT_Call :=\n+                    New_Reference_To (\n+                      RTE (RE_Requeue_Protected_Entry), Loc);\n+\n+                  Param :=\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        Concurrent_Ref (Concval),\n+                      Attribute_Name =>\n+                        Name_Unchecked_Access);\n \n-            Prepend (New_Param, Params);\n-            Prepend (Self_Param, Params);\n+               --  Protected to task requeue\n \n-         else\n-            pragma Assert (Is_Task_Type (Old_Typ));\n+               else pragma Assert (Is_Task_Type (Conc_Typ));\n+                  RT_Call :=\n+                    New_Reference_To (\n+                      RTE (RE_Requeue_Protected_To_Task_Entry), Loc);\n+\n+                  Param := Concurrent_Ref (Concval);\n+               end if;\n+\n+               Prepend_To (Params, Param);\n+               Prepend_To (Params, Self_Param);\n+            end;\n+\n+         else pragma Assert (Is_Task_Type (Old_Typ));\n \n             --  Task to protected requeue\n \n             if Is_Protected_Type (Conc_Typ) then\n-               RTS_Call :=\n+               RT_Call :=\n                  New_Reference_To (\n                    RTE (RE_Requeue_Task_To_Protected_Entry), Loc);\n \n-               New_Param :=\n+               Param :=\n                  Make_Attribute_Reference (Loc,\n                    Prefix =>\n-                     New_Param,\n+                     Concurrent_Ref (Concval),\n                    Attribute_Name =>\n                      Name_Unchecked_Access);\n \n             --  Task to task requeue\n \n-            else\n-               pragma Assert (Is_Task_Type (Conc_Typ));\n-               RTS_Call :=\n+            else pragma Assert (Is_Task_Type (Conc_Typ));\n+               RT_Call :=\n                  New_Reference_To (RTE (RE_Requeue_Task_Entry), Loc);\n+\n+               Param := Concurrent_Ref (Concval);\n             end if;\n \n-            Prepend (New_Param, Params);\n+            Prepend_To (Params, Param);\n          end if;\n-      end if;\n \n-      --  Create the GNARLI or predefined primitive call\n-\n-      Rcall :=\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => RTS_Call,\n-          Parameter_Associations => Params);\n+         return\n+            Make_Procedure_Call_Statement (Loc,\n+              Name => RT_Call,\n+              Parameter_Associations => Params);\n+      end Build_Normal_Requeue;\n \n-      Rewrite (N, Rcall);\n-      Analyze (N);\n+      --------------------------\n+      -- Build_Skip_Statement --\n+      --------------------------\n \n-      if Is_Protected_Type (Old_Typ) then\n+      function Build_Skip_Statement (Search : Node_Id) return Node_Id is\n+         Skip_Stmt : Node_Id;\n \n-         --  Build the return statement to skip the rest of the entry body\n+      begin\n+         --  Build a return statement to skip the rest of the entire body\n \n-         Skip_Stat := Make_Simple_Return_Statement (Loc);\n+         if Is_Protected_Type (Old_Typ) then\n+            Skip_Stmt := Make_Simple_Return_Statement (Loc);\n \n-      else\n          --  If the requeue is within a task, find the end label of the\n-         --  enclosing accept statement.\n+         --  enclosing accept statement and create a goto statement to it.\n \n-         Acc_Stat := Parent (N);\n-         while Nkind (Acc_Stat) /= N_Accept_Statement loop\n-            Acc_Stat := Parent (Acc_Stat);\n-         end loop;\n+         else\n+            declare\n+               Acc   : Node_Id;\n+               Label : Node_Id;\n \n-         --  The last statement is the second label, used for completing the\n-         --  rendezvous the usual way. The label we are looking for is right\n-         --  before it.\n+            begin\n+               --  Climb the parent chain looking for the enclosing accept\n+               --  statement.\n+\n+               Acc := Parent (Search);\n+               while Present (Acc)\n+                 and then Nkind (Acc) /= N_Accept_Statement\n+               loop\n+                  Acc := Parent (Acc);\n+               end loop;\n \n-         Lab_Node :=\n-           Prev (Last (Statements (Handled_Statement_Sequence (Acc_Stat))));\n+               --  The last statement is the second label used for completing\n+               --  the rendezvous the usual way. The label we are looking for\n+               --  is right before it.\n \n-         pragma Assert (Nkind (Lab_Node) = N_Label);\n+               Label :=\n+                 Prev (Last (Statements (Handled_Statement_Sequence (Acc))));\n \n-         --  Build the goto statement to skip the rest of the accept\n-         --  statement.\n+               pragma Assert (Nkind (Label) = N_Label);\n \n-         Skip_Stat :=\n-           Make_Goto_Statement (Loc,\n-             Name => New_Occurrence_Of (Entity (Identifier (Lab_Node)), Loc));\n-      end if;\n+               --  Generate a goto statement to skip the rest of the accept\n+\n+               Skip_Stmt :=\n+                 Make_Goto_Statement (Loc,\n+                   Name =>\n+                     New_Occurrence_Of (Entity (Identifier (Label)), Loc));\n+            end;\n+         end if;\n+\n+         Set_Analyzed (Skip_Stmt);\n+\n+         return Skip_Stmt;\n+      end Build_Skip_Statement;\n+\n+   --  Start of processing for Expand_N_Requeue_Statement\n \n-      Set_Analyzed (Skip_Stat);\n+   begin\n+      --  Extract the components of the entry call\n+\n+      Extract_Entry (N, Concval, Ename, Index);\n+      Conc_Typ := Etype (Concval);\n+\n+      --  Examine the scope stack in order to find nearest enclosing protected\n+      --  or task type. This will constitute our invocation source.\n+\n+      Old_Typ := Current_Scope;\n+      while Present (Old_Typ)\n+        and then not Is_Protected_Type (Old_Typ)\n+        and then not Is_Task_Type (Old_Typ)\n+      loop\n+         Old_Typ := Scope (Old_Typ);\n+      end loop;\n \n-      Insert_After (N, Skip_Stat);\n+      --  Ada 2012 (AI05-0030): We have a dispatching requeue of the form\n+      --  Concval.Ename where the type of Concval is class-wide concurrent\n+      --  interface.\n+\n+      if Ada_Version >= Ada_2012\n+        and then Present (Concval)\n+        and then Is_Class_Wide_Type (Conc_Typ)\n+        and then Is_Concurrent_Interface (Conc_Typ)\n+      then\n+         declare\n+            Has_Impl  : Boolean := False;\n+            Impl_Kind : Name_Id := No_Name;\n+\n+         begin\n+            --  Check whether the Ename is flagged by pragma Implemented\n+\n+            if Has_Rep_Pragma (Entity (Ename), Name_Implemented) then\n+               Has_Impl  := True;\n+               Impl_Kind := Implementation_Kind (Entity (Ename));\n+            end if;\n+\n+            --  The procedure_or_entry_NAME is guaranteed to be overridden by\n+            --  an entry. Create a call to predefined primitive _Disp_Requeue.\n+\n+            if Has_Impl\n+              and then Impl_Kind = Name_By_Entry\n+            then\n+               Rewrite (N, Build_Dispatching_Requeue);\n+               Analyze (N);\n+               Insert_After (N, Build_Skip_Statement (N));\n+\n+            --  The procedure_or_entry_NAME is guaranteed to be overridden by\n+            --  a protected procedure. In this case the requeue is transformed\n+            --  into a dispatching call.\n+\n+            elsif Has_Impl\n+              and then Impl_Kind = Name_By_Protected_Procedure\n+            then\n+               Rewrite (N, Build_Dispatching_Call_Equivalent);\n+               Analyze (N);\n+\n+            --  The procedure_or_entry_NAME's implementation kind is either\n+            --  By_Any or pragma Implemented was not applied at all. In this\n+            --  case a runtime test determines whether Ename denotes an entry\n+            --  or a protected procedure and performs the appropriate call.\n+\n+            else\n+               Rewrite (N, Build_Dispatching_Requeue_To_Any);\n+               Analyze (N);\n+            end if;\n+         end;\n+\n+      --  Processing for regular (non-dispatching) requeues\n+\n+      else\n+         Rewrite (N, Build_Normal_Requeue);\n+         Analyze (N);\n+         Insert_After (N, Build_Skip_Statement (N));\n+      end if;\n    end Expand_N_Requeue_Statement;\n \n    -------------------------------"}, {"sha": "af3a0b38536d5bd1f3efefd696efcf6b680082e0", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -4060,8 +4060,7 @@ package body Exp_Disp is\n             Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n \n          elsif Is_Abstract_Type (Typ)\n-           or else not Static_Dispatch_Tables\n-           or else not Is_Library_Level_Tagged_Type (Typ)\n+           or else not Building_Static_DT (Typ)\n          then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n@@ -5614,9 +5613,7 @@ package body Exp_Disp is\n          if Nb_Prim = 0 then\n             Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n \n-         elsif not Static_Dispatch_Tables\n-           or else not Is_Library_Level_Tagged_Type (Typ)\n-         then\n+         elsif not Building_Static_DT (Typ) then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List, Make_Null (Loc));\n             end loop;\n@@ -5768,9 +5765,7 @@ package body Exp_Disp is\n       --  because the whole dispatch table (including inherited primitives) has\n       --  been already built.\n \n-      if Static_Dispatch_Tables\n-        and then Is_Library_Level_Tagged_Type (Typ)\n-      then\n+      if Building_Static_DT (Typ) then\n          null;\n \n       --  If the ancestor is a CPP_Class type we inherit the dispatch tables"}, {"sha": "50e8b47855626bfcc745e826c7840b188c329655", "filename": "gcc/ada/g-dirope.adb", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2009, AdaCore                     --\n+--                     Copyright (C) 1998-2010, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -719,11 +719,10 @@ package body GNAT.Directory_Operations is\n       Recursive : Boolean := False)\n    is\n       C_Dir_Name  : constant String := Dir_Name & ASCII.NUL;\n-      Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n       Last        : Integer;\n       Str         : String (1 .. Filename_Max);\n       Success     : Boolean;\n-      Working_Dir : Dir_Type;\n+      Current_Dir : Dir_Type;\n \n    begin\n       --  Remove the directory only if it is empty\n@@ -736,51 +735,40 @@ package body GNAT.Directory_Operations is\n       --  Remove directory and all files and directories that it may contain\n \n       else\n-         --  Substantial comments needed. See RH for revision 1.50 ???\n+         Open (Current_Dir, Dir_Name);\n \n-         begin\n-            Change_Dir (Dir_Name);\n-            Open (Working_Dir, \".\");\n-\n-            loop\n-               Read (Working_Dir, Str, Last);\n-               exit when Last = 0;\n-\n-               if GNAT.OS_Lib.Is_Directory (Str (1 .. Last)) then\n-                  if Str (1 .. Last) /= \".\"\n-                       and then\n-                     Str (1 .. Last) /= \"..\"\n-                  then\n-                     Remove_Dir (Str (1 .. Last), True);\n-                  end if;\n-\n-               else\n-                  GNAT.OS_Lib.Delete_File (Str (1 .. Last), Success);\n+         loop\n+            Read (Current_Dir, Str, Last);\n+            exit when Last = 0;\n \n-                  if not Success then\n-                     Change_Dir (Current_Dir);\n-                     raise Directory_Error;\n-                  end if;\n+            if GNAT.OS_Lib.Is_Directory\n+                 (Dir_Name & Dir_Separator &  Str (1 .. Last))\n+            then\n+               if Str (1 .. Last) /= \".\"\n+                 and then\n+                   Str (1 .. Last) /= \"..\"\n+               then\n+                  --  Recursive call to remove a subdirectory and all its\n+                  --  files.\n+\n+                  Remove_Dir\n+                    (Dir_Name & Dir_Separator &  Str (1 .. Last),\n+                     True);\n                end if;\n-            end loop;\n-\n-            Change_Dir (Current_Dir);\n-            Close (Working_Dir);\n-            Remove_Dir (Dir_Name);\n-\n-         exception\n-            when others =>\n \n-               --  An exception occurred. We must make sure the current working\n-               --  directory is unchanged.\n-\n-               Change_Dir (Current_Dir);\n+            else\n+               GNAT.OS_Lib.Delete_File\n+                 (Dir_Name & Dir_Separator &  Str (1 .. Last),\n+                  Success);\n \n-               --  What if the Change_Dir raises an exception itself, shouldn't\n-               --  that be protected? ???\n+               if not Success then\n+                  raise Directory_Error;\n+               end if;\n+            end if;\n+         end loop;\n \n-               raise;\n-         end;\n+         Close (Current_Dir);\n+         Remove_Dir (Dir_Name);\n       end if;\n    end Remove_Dir;\n "}, {"sha": "190c9cc1529353fd80222a4baac92cebe58e60a4", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -1123,7 +1123,7 @@ begin\n            Pragma_Finalize_Storage_Only         |\n            Pragma_Float_Representation          |\n            Pragma_Ident                         |\n-           Pragma_Implemented_By_Entry          |\n+           Pragma_Implemented                   |\n            Pragma_Implicit_Packing              |\n            Pragma_Import                        |\n            Pragma_Import_Exception              |"}, {"sha": "18aced728e389fb8ac26b80434c2706e82fdeab8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 185, "deletions": 21, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -8375,6 +8375,155 @@ package body Sem_Ch3 is\n       Subp       : Entity_Id;\n       Type_Def   : Node_Id;\n \n+      procedure Check_Pragma_Implemented (Subp : Entity_Id);\n+      --  Ada 2012 (AI05-0030): Subprogram Subp overrides an interface routine\n+      --  which has pragma Implemented already set. Check whether Subp's entity\n+      --  kind conforms to the implementation kind of the overridden routine.\n+\n+      procedure Check_Pragma_Implemented\n+        (Subp       : Entity_Id;\n+         Iface_Subp : Entity_Id);\n+      --  Ada 2012 (AI05-0030): Subprogram Subp overrides interface routine\n+      --  Iface_Subp and both entities have pragma Implemented already set on\n+      --  them. Check whether the two implementation kinds are conforming.\n+\n+      procedure Inherit_Pragma_Implemented\n+        (Subp       : Entity_Id;\n+         Iface_Subp : Entity_Id);\n+      --  Ada 2012 (AI05-0030): Interface primitive Subp overrides interface\n+      --  subprogram Iface_Subp which has been marked by pragma Implemented.\n+      --  Propagate the implementation kind of Iface_Subp to Subp.\n+\n+      ------------------------------\n+      -- Check_Pragma_Implemented --\n+      ------------------------------\n+\n+      procedure Check_Pragma_Implemented (Subp : Entity_Id) is\n+         Iface_Alias : constant Entity_Id := Interface_Alias (Subp);\n+         Impl_Kind   : constant Name_Id   := Implementation_Kind (Iface_Alias);\n+         Contr_Typ   : Entity_Id;\n+\n+      begin\n+         --  Subp must have an alias since it is a hidden entity used to link\n+         --  an interface subprogram to its overriding counterpart.\n+\n+         pragma Assert (Present (Alias (Subp)));\n+\n+         --  Extract the type of the controlling formal\n+\n+         Contr_Typ := Etype (First_Formal (Alias (Subp)));\n+\n+         if Is_Concurrent_Record_Type (Contr_Typ) then\n+            Contr_Typ := Corresponding_Concurrent_Type (Contr_Typ);\n+         end if;\n+\n+         --  An interface subprogram whose implementation kind is By_Entry must\n+         --  be implemented by an entry.\n+\n+         if Impl_Kind = Name_By_Entry\n+           and then Ekind (Wrapped_Entity (Alias (Subp))) /= E_Entry\n+         then\n+            Error_Msg_Node_2 := Iface_Alias;\n+            Error_Msg_NE\n+              (\"type & must implement abstract subprogram & with an entry\",\n+               Alias (Subp), Contr_Typ);\n+\n+         elsif Impl_Kind = Name_By_Protected_Procedure then\n+\n+            --  An interface subprogram whose implementation kind is By_\n+            --  Protected_Procedure cannot be implemented by a primitive\n+            --  procedure of a task type.\n+\n+            if Ekind (Contr_Typ) /= E_Protected_Type then\n+               Error_Msg_Node_2 := Contr_Typ;\n+               Error_Msg_NE\n+                 (\"interface subprogram & cannot be implemented by a \" &\n+                  \"primitive procedure of task type &\", Alias (Subp),\n+                  Iface_Alias);\n+\n+            --  An interface subprogram whose implementation kind is By_\n+            --  Protected_Procedure must be implemented by a procedure.\n+\n+            elsif Is_Primitive_Wrapper (Alias (Subp))\n+              and then Ekind (Wrapped_Entity (Alias (Subp))) /= E_Procedure\n+            then\n+               Error_Msg_Node_2 := Iface_Alias;\n+               Error_Msg_NE\n+                 (\"type & must implement abstract subprogram & with a \" &\n+                  \"procedure\", Alias (Subp), Contr_Typ);\n+            end if;\n+         end if;\n+      end Check_Pragma_Implemented;\n+\n+      ------------------------------\n+      -- Check_Pragma_Implemented --\n+      ------------------------------\n+\n+      procedure Check_Pragma_Implemented\n+        (Subp       : Entity_Id;\n+         Iface_Subp : Entity_Id)\n+      is\n+         Iface_Kind : constant Name_Id := Implementation_Kind (Iface_Subp);\n+         Subp_Kind  : constant Name_Id := Implementation_Kind (Subp);\n+\n+      begin\n+         --  Ada 2012 (AI05-0030): The implementation kinds of an overridden\n+         --  and overriding subprogram are different. In general this is an\n+         --  error except when the implementation kind of the overridden\n+         --  subprograms is By_Any.\n+\n+         if Iface_Kind /= Subp_Kind\n+           and then Iface_Kind /= Name_By_Any\n+         then\n+            if Iface_Kind = Name_By_Entry then\n+               Error_Msg_N\n+                 (\"incompatible implementation kind, overridden subprogram \" &\n+                  \"is marked By_Entry\", Subp);\n+            else\n+               Error_Msg_N\n+                 (\"incompatible implementation kind, overridden subprogram \" &\n+                  \"is marked By_Protected_Procedure\", Subp);\n+            end if;\n+         end if;\n+      end Check_Pragma_Implemented;\n+\n+      --------------------------------\n+      -- Inherit_Pragma_Implemented --\n+      --------------------------------\n+\n+      procedure Inherit_Pragma_Implemented\n+        (Subp       : Entity_Id;\n+         Iface_Subp : Entity_Id)\n+      is\n+         Iface_Kind : constant Name_Id    := Implementation_Kind (Iface_Subp);\n+         Loc        : constant Source_Ptr := Sloc (Subp);\n+         Impl_Prag  : Node_Id;\n+\n+      begin\n+         --  Since the implementation kind is stored as a representation item\n+         --  rather than a flag, create a pragma node.\n+\n+         Impl_Prag :=\n+           Make_Pragma (Loc,\n+             Chars => Name_Implemented,\n+             Pragma_Argument_Associations => New_List (\n+               Make_Pragma_Argument_Association (Loc,\n+                 Expression =>\n+                   New_Reference_To (Subp, Loc)),\n+\n+               Make_Pragma_Argument_Association (Loc,\n+                 Expression =>\n+                   Make_Identifier (Loc, Iface_Kind))));\n+\n+         --  The pragma doesn't need to be analyzed because it is internaly\n+         --  build. It is safe to directly register it as a rep item since we\n+         --  are only interested in the characters of the implementation kind.\n+\n+         Record_Rep_Item (Subp, Impl_Prag);\n+      end Inherit_Pragma_Implemented;\n+\n+   --  Start of processing for Check_Abstract_Overriding\n+\n    begin\n       Op_List := Primitive_Operations (T);\n \n@@ -8584,33 +8733,48 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  Ada 2005 (AI05-0030): Inspect hidden subprograms which provide\n-         --  the mapping between interface and implementing type primitives.\n-         --  If the interface alias is marked as Implemented_By_Entry, the\n-         --  alias must be an entry wrapper.\n+         --  Ada 2012 (AI05-0030): Perform some checks related to pragma\n+         --  Implemented\n \n-         if Ada_Version >= Ada_05\n+         --  Subp is an expander-generated procedure which maps an interface\n+         --  alias to a protected wrapper. The interface alias is flagged by\n+         --  pragma Implemented. Ensure that Subp is a procedure when the\n+         --  implementation kind is By_Protected_Procedure or an entry when\n+         --  By_Entry.\n+\n+         if Ada_Version >= Ada_2012\n            and then Is_Hidden (Subp)\n            and then Present (Interface_Alias (Subp))\n-           and then Implemented_By_Entry (Interface_Alias (Subp))\n-           and then Present (Alias_Subp)\n-           and then\n-             (not Is_Primitive_Wrapper (Alias_Subp)\n-                or else Ekind (Wrapped_Entity (Alias_Subp)) /= E_Entry)\n+           and then Has_Rep_Pragma (Interface_Alias (Subp), Name_Implemented)\n          then\n-            declare\n-               Error_Ent : Entity_Id := T;\n+            Check_Pragma_Implemented (Subp);\n+         end if;\n \n-            begin\n-               if Is_Concurrent_Record_Type (Error_Ent) then\n-                  Error_Ent := Corresponding_Concurrent_Type (Error_Ent);\n-               end if;\n+         --  Subp is an interface primitive which overrides another interface\n+         --  primitive marked with pragma Implemented.\n \n-               Error_Msg_Node_2 := Interface_Alias (Subp);\n-               Error_Msg_NE\n-                 (\"type & must implement abstract subprogram & with an entry\",\n-                  Error_Ent, Error_Ent);\n-            end;\n+         if Ada_Version >= Ada_2012\n+           and then Is_Overriding_Operation (Subp)\n+           and then Present (Overridden_Operation (Subp))\n+           and then Has_Rep_Pragma\n+                      (Overridden_Operation (Subp), Name_Implemented)\n+         then\n+            --  If the overriding routine is also marked by Implemented, check\n+            --  that the two implementation kinds are conforming.\n+\n+            if Has_Rep_Pragma (Subp, Name_Implemented) then\n+               Check_Pragma_Implemented\n+                 (Subp       => Subp,\n+                  Iface_Subp => Overridden_Operation (Subp));\n+\n+            --  Otherwise the overriding routine inherits the implementation\n+            --  kind from the overridden subprogram.\n+\n+            else\n+               Inherit_Pragma_Implemented\n+                 (Subp       => Subp,\n+                  Iface_Subp => Overridden_Operation (Subp));\n+            end if;\n          end if;\n \n          Next_Elmt (Elmt);"}, {"sha": "154b5d3376d8660941e5594821f7e2ee33ab9e1c", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -507,7 +507,7 @@ package body Sem_Ch4 is\n             --  be a null object, and we can insert an unconditional raise\n             --  before the allocator.\n \n-            --  Ada2012 (AI-104): a not null indication here is altogether\n+            --  Ada 2012 (AI-104): A not null indication here is altogether\n             --  illegal.\n \n             if Can_Never_Be_Null (Type_Id) then"}, {"sha": "136dfb353b449ae069e17afcc483e92141c27f4e", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -1423,18 +1423,17 @@ package body Sem_Ch9 is\n          Entry_Id := Entity (Entry_Name);\n       end if;\n \n-      --  Ada 2005 (AI05-0030): Potential dispatching requeue statement. The\n+      --  Ada 2012 (AI05-0030): Potential dispatching requeue statement. The\n       --  target type must be a concurrent interface class-wide type and the\n-      --  entry name must be a procedure, flagged by pragma Implemented_By_\n-      --  Entry.\n+      --  target must be a procedure, flagged by pragma Implemented.\n \n       Is_Disp_Req :=\n-        Ada_Version >= Ada_05\n+        Ada_Version >= Ada_2012\n           and then Present (Target_Obj)\n           and then Is_Class_Wide_Type (Etype (Target_Obj))\n           and then Is_Concurrent_Interface (Etype (Target_Obj))\n           and then Ekind (Entry_Id) = E_Procedure\n-          and then Implemented_By_Entry (Entry_Id);\n+          and then Has_Rep_Pragma (Entry_Id, Name_Implemented);\n \n       --  Resolve entry, and check that it is subtype conformant with the\n       --  enclosing construct if this construct has formals (RM 9.5.4(5)).\n@@ -1462,11 +1461,13 @@ package body Sem_Ch9 is\n                return;\n             end if;\n \n-            --  Ada 2005 (AI05-0030): Perform type conformance after skipping\n+            --  Ada 2012 (AI05-0030): Perform type conformance after skipping\n             --  the first parameter of Entry_Id since it is the interface\n             --  controlling formal.\n \n-            if Is_Disp_Req then\n+            if Ada_Version >= Ada_2012\n+              and then Is_Disp_Req\n+            then\n                declare\n                   Enclosing_Formal : Entity_Id;\n                   Target_Formal    : Entity_Id;"}, {"sha": "1ad6c67d7f47fcd6ed40c092a3fd8e5f8a8fb9ce", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -310,7 +310,12 @@ package body Sem_Prag is\n       procedure Ada_2005_Pragma;\n       --  Called for pragmas defined in Ada 2005, that are not in Ada 95. In\n       --  Ada 95 mode, these are implementation defined pragmas, so should be\n-      --  caught by the No_Implementation_Pragmas restriction\n+      --  caught by the No_Implementation_Pragmas restriction.\n+\n+      procedure Ada_2012_Pragma;\n+      --  Called for pragmas defined in Ada 2012, that are not in Ada 95 or 05.\n+      --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n+      --  should be caught by the No_Implementation_Pragmas restriction.\n \n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n@@ -733,6 +738,17 @@ package body Sem_Prag is\n          end if;\n       end Ada_2005_Pragma;\n \n+      ---------------------\n+      -- Ada_2012_Pragma --\n+      ---------------------\n+\n+      procedure Ada_2012_Pragma is\n+      begin\n+         if Ada_Version <= Ada_05 then\n+            Check_Restriction (No_Implementation_Pragmas, N);\n+         end if;\n+      end Ada_2012_Pragma;\n+\n       --------------------------\n       -- Check_Ada_83_Warning --\n       --------------------------\n@@ -7979,45 +7995,101 @@ package body Sem_Prag is\n             end;\n          end Ident;\n \n-         --------------------------\n-         -- Implemented_By_Entry --\n-         --------------------------\n+         -----------------\n+         -- Implemented --\n+         -----------------\n \n-         --  pragma Implemented_By_Entry (DIRECT_NAME);\n+         --  pragma Implemented (procedure_LOCAL_NAME, implementation_kind);\n+         --  implementation_kind ::= By_Entry | By_Protected_Procedure | By_Any\n \n-         when Pragma_Implemented_By_Entry => Implemented_By_Entry : declare\n-            Ent : Entity_Id;\n+         when Pragma_Implemented => Implemented : declare\n+            Proc_Id : Entity_Id;\n+            Typ     : Entity_Id;\n \n          begin\n-            Ada_2005_Pragma;\n-            Check_Arg_Count (1);\n+            Ada_2012_Pragma;\n+            Check_Arg_Count (2);\n             Check_No_Identifiers;\n             Check_Arg_Is_Identifier (Arg1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Ent := Entity (Expression (Arg1));\n+            Check_Arg_Is_One_Of\n+              (Arg2, Name_By_Any, Name_By_Entry, Name_By_Protected_Procedure);\n+\n+            --  Extract the name of the local procedure\n \n-            --  Pragma Implemented_By_Entry must be applied only to protected\n-            --  synchronized or task interface primitives.\n+            Proc_Id := Entity (Expression (Arg1));\n \n-            if (Ekind (Ent) /= E_Function\n-                  and then Ekind (Ent) /= E_Procedure)\n-               or else not Present (First_Formal (Ent))\n-               or else not Is_Concurrent_Interface (Etype (First_Formal (Ent)))\n+            --  Ada 2012 (AI05-0030): The procedure_LOCAL_NAME must denote a\n+            --  primitive procedure of a synchronized tagged type.\n+\n+            if Ekind (Proc_Id) = E_Procedure\n+              and then Is_Primitive (Proc_Id)\n+              and then Present (First_Formal (Proc_Id))\n             then\n-               Error_Pragma_Arg\n-                 (\"pragma % must be applied to a concurrent interface \" &\n-                  \"primitive\", Arg1);\n+               Typ := Etype (First_Formal (Proc_Id));\n \n-            else\n-               if Einfo.Implemented_By_Entry (Ent)\n-                 and then Warn_On_Redundant_Constructs\n+               if Is_Tagged_Type (Typ)\n+                 and then\n+\n+                  --  Check for a protected, a synchronized or a task interface\n+\n+                   ((Is_Interface (Typ)\n+                       and then Is_Synchronized_Interface (Typ))\n+\n+                  --  Check for a protected type or a task type that implements\n+                  --  an interface.\n+\n+                   or else\n+                    (Is_Concurrent_Record_Type (Typ)\n+                       and then Present (Interfaces (Typ)))\n+\n+                  --  Check for a private record extension with keyword\n+                  --  \"synchronized\".\n+\n+                   or else\n+                    (Ekind_In (Typ, E_Record_Type_With_Private,\n+                                    E_Record_Subtype_With_Private)\n+                       and then Synchronized_Present (Parent (Typ))))\n                then\n-                  Error_Pragma (\"?duplicate pragma%!\");\n+                  null;\n                else\n-                  Set_Implemented_By_Entry (Ent);\n+                  Error_Pragma_Arg\n+                    (\"controlling formal must be of synchronized \" &\n+                     \"tagged type\", Arg1);\n+                  return;\n                end if;\n+\n+            --  Procedures declared inside a protected type must be accepted\n+\n+            elsif Ekind (Proc_Id) = E_Procedure\n+              and then Is_Protected_Type (Scope (Proc_Id))\n+            then\n+               null;\n+\n+            --  The first argument is not a primitive procedure\n+\n+            else\n+               Error_Pragma_Arg\n+                 (\"pragma % must be applied to a primitive procedure\", Arg1);\n+               return;\n             end if;\n-         end Implemented_By_Entry;\n+\n+            --  Ada 2012 (AI05-0030): Implementation_kind \"By_Protected_\n+            --  Procedure\" cannot be applied to the primitive procedure of a\n+            --  task interface.\n+\n+            if Chars (Arg2) = Name_By_Protected_Procedure\n+              and then Is_Interface (Typ)\n+              and then Is_Task_Interface (Typ)\n+            then\n+               Error_Pragma_Arg\n+                 (\"implementation kind By_Protected_Procedure cannot be \" &\n+                  \"applied to a task interface primitive\", Arg2);\n+               return;\n+            end if;\n+\n+            Record_Rep_Item (Proc_Id, N);\n+         end Implemented;\n \n          -----------------------\n          -- Implicit_Packing --\n@@ -12946,7 +13018,7 @@ package body Sem_Prag is\n       Pragma_Finalize_Storage_Only         =>  0,\n       Pragma_Float_Representation          =>  0,\n       Pragma_Ident                         => -1,\n-      Pragma_Implemented_By_Entry          => -1,\n+      Pragma_Implemented                   => -1,\n       Pragma_Implicit_Packing              =>  0,\n       Pragma_Import                        => +2,\n       Pragma_Import_Exception              =>  0,"}, {"sha": "d9991ce3e589190e37128b3395fc2359de7dd631", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -5237,6 +5237,20 @@ package body Sem_Util is\n       end if;\n    end Has_Tagged_Component;\n \n+   -------------------------\n+   -- Implementation_Kind --\n+   -------------------------\n+\n+   function Implementation_Kind (Subp : Entity_Id) return Name_Id is\n+      Impl_Prag : constant Node_Id := Get_Rep_Pragma (Subp, Name_Implemented);\n+\n+   begin\n+      pragma Assert (Present (Impl_Prag));\n+\n+      return\n+        Chars (Expression (Last (Pragma_Argument_Associations (Impl_Prag))));\n+   end Implementation_Kind;\n+\n    --------------------------\n    -- Implements_Interface --\n    --------------------------"}, {"sha": "faa363cbcc6de94d6382bbd224217291ab8d61b0", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -586,11 +586,16 @@ package Sem_Util is\n    --  component is present. This function is used to check if \"=\" has to be\n    --  expanded into a bunch component comparisons.\n \n+   function Implementation_Kind (Subp : Entity_Id) return Name_Id;\n+   --  Subp is a subprogram marked with pragma Implemented. Return the specific\n+   --  implementation requirement which the pragma imposes. The return value is\n+   --  either Name_By_Any, Name_By_Entry or Name_By_Protected_Procedure.\n+\n    function Implements_Interface\n      (Typ_Ent         : Entity_Id;\n       Iface_Ent       : Entity_Id;\n       Exclude_Parents : Boolean := False) return Boolean;\n-   --  Returns true if the Typ implements interface Iface\n+   --  Returns true if the Typ_Ent implements interface Iface_Ent\n \n    function In_Instance return Boolean;\n    --  Returns True if the current scope is within a generic instance"}, {"sha": "0425cccc77e4777ca7c07d2bd03473d697fe0e1b", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfae1846ce6fb95a064520e4560fbd191abd2f04/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=bfae1846ce6fb95a064520e4560fbd191abd2f04", "patch": "@@ -445,7 +445,7 @@ package Snames is\n    Name_External                       : constant Name_Id := N + $; -- GNAT\n    Name_Finalize_Storage_Only          : constant Name_Id := N + $; -- GNAT\n    Name_Ident                          : constant Name_Id := N + $; -- VMS\n-   Name_Implemented_By_Entry           : constant Name_Id := N + $; -- Ada 05\n+   Name_Implemented                    : constant Name_Id := N + $; -- Ada 12\n    Name_Import                         : constant Name_Id := N + $;\n    Name_Import_Exception               : constant Name_Id := N + $; -- VMS\n    Name_Import_Function                : constant Name_Id := N + $; -- GNAT\n@@ -594,6 +594,9 @@ package Snames is\n    Name_Attribute_Name                 : constant Name_Id := N + $;\n    Name_Body_File_Name                 : constant Name_Id := N + $;\n    Name_Boolean_Entry_Barriers         : constant Name_Id := N + $;\n+   Name_By_Any                         : constant Name_Id := N + $;\n+   Name_By_Entry                       : constant Name_Id := N + $;\n+   Name_By_Protected_Procedure         : constant Name_Id := N + $;\n    Name_Casing                         : constant Name_Id := N + $;\n    Name_Code                           : constant Name_Id := N + $;\n    Name_Component                      : constant Name_Id := N + $;\n@@ -1520,7 +1523,7 @@ package Snames is\n       Pragma_External,\n       Pragma_Finalize_Storage_Only,\n       Pragma_Ident,\n-      Pragma_Implemented_By_Entry,\n+      Pragma_Implemented,\n       Pragma_Import,\n       Pragma_Import_Exception,\n       Pragma_Import_Function,"}]}