{"sha": "3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MxMmZjYzI3ODA5YTIyMzAzMmUxYjBhZDJiZWJhMWY2ODQ0YTVjNg==", "commit": {"author": {"name": "Greg McGary", "email": "gkm@gnu.org", "date": "1999-12-03T19:02:20Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-12-03T19:02:20Z"}, "message": "flags.h (warn_padded, [...]): Add global var decls.\n\n* flags.h (warn_padded, warn_packed): Add global var decls.\n* toplev.c (warn_padded, warn_packed): Add global var defns.\n(W_options): Add warnings `-Wpacked' and `-Wpadded'.\n* stor-layout.c (layout_record): Add local variable `type'\nto hold often-used TREE_TYPE (field).  Add local variable\n`unpacked_align' to hold alignment that would be in force\nif no `packed' attribute were present.  Warn if `packed' attribute\nis unnecessary, or even harmful.  Warn when gcc inserts padding\nto satisfy alignment requirements of members.  Use NULL_TREE\nwhen checking whether var_size is set.\n* invoke.texi: Document new flags.\n\nCo-Authored-By: Geoff Keating <geoffk@cygnus.com>\n\nFrom-SVN: r30770", "tree": {"sha": "7d5534785288859eef23b404bed24959cca1f313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d5534785288859eef23b404bed24959cca1f313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/comments", "author": null, "committer": null, "parents": [{"sha": "7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7337695dc2c8f106fbad8b59ad2b4a2c9d413710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7337695dc2c8f106fbad8b59ad2b4a2c9d413710"}], "stats": {"total": 186, "additions": 161, "deletions": 25}, "files": [{"sha": "2fbc0721964bf3b2def003aba20d1ab279ddafad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "patch": "@@ -1,3 +1,18 @@\n+Thu Dec  2 21:22:45 1999  Greg McGary  <gkm@gnu.org>\n+\t\t\t  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* flags.h (warn_padded, warn_packed): Add global var decls.\n+\t* toplev.c (warn_padded, warn_packed): Add global var defns.\n+\t(W_options): Add warnings `-Wpacked' and `-Wpadded'.\n+\t* stor-layout.c (layout_record): Add local variable `type'\n+\tto hold often-used TREE_TYPE (field).  Add local variable\n+\t`unpacked_align' to hold alignment that would be in force\n+\tif no `packed' attribute were present.  Warn if `packed' attribute\n+\tis unnecessary, or even harmful.  Warn when gcc inserts padding\n+\tto satisfy alignment requirements of members.  Use NULL_TREE\n+\twhen checking whether var_size is set.\n+\t* invoke.texi: Document new flags.\n+\n 1999-12-03  Nathan Sidwell  <nathan@acm.org>\n \n \t* frame.c (fde_split): Reimplement to avoid variable sized array."}, {"sha": "c93784cdee6a5713741e55385ba17f3555ef6370", "filename": "gcc/flags.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "patch": "@@ -141,6 +141,14 @@ extern unsigned larger_than_size;\n \n extern int warn_aggregate_return;\n \n+/* Warn if packed attribute on struct is unnecessary and inefficient.  */\n+\n+extern int warn_packed;\n+\n+/* Warn when gcc pads a structure to an alignment boundary.  */\n+\n+extern int warn_padded;\n+\n /* Nonzero if generating code to do profiling.  */\n \n extern int profile_flag;"}, {"sha": "ea90467f4747fbd4127f370b65e15a17d53d548b", "filename": "gcc/invoke.texi", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "patch": "@@ -128,7 +128,7 @@ in the following sections.\n -Werror-implicit-function-declaration  -Wfloat-equal -Winline\n -Wlarger-than-@var{len}  -Wlong-long\n -Wmain  -Wmissing-declarations  -Wmissing-noreturn\n--Wmultichar  -Wno-import  \n+-Wmultichar  -Wno-import  -Wpacked  -Wpadded\n -Wparentheses -Wpointer-arith  -Wredundant-decls\n -Wreturn-type -Wshadow  -Wsign-compare -Wswitch\n -Wtrigraphs -Wundef  -Wuninitialized  -Wunknown-pragmas -Wunreachable-code \n@@ -1430,7 +1430,7 @@ arguments, two, or three arguments of appropriate types.\n Warn if a multicharacter constant (@samp{'FOOF'}) is used.  Usually they\n indicate a typo in the user's code, as they have implementation-defined\n values, and should not be used in portable code.\n-  \n+\n @item -Wparentheses\n Warn if parentheses are omitted in certain contexts, such\n as when there is an assignment in a context where a truth value\n@@ -1798,6 +1798,33 @@ be taken to manually verify functions actually do not ever return before\n adding the @code{noreturn} attribute, otherwise subtle code generation\n bugs could be introduced.\n \n+@item -Wpacked\n+Warn if a structure is given the packed attribute, but the packed\n+attribute has no effect on the layout or size of the structure.  \n+Such structures may be mis-aligned for little benefit.  For\n+instance, in this code, the variable @code{f.x} in @code{struct bar}\n+will be misaligned even though @code{struct bar} does not itself\n+have the packed attribute:\n+\n+@smallexample\n+@group\n+struct foo @{\n+  int x;\n+  char a, b, c, d;\n+@} __attribute__((packed));\n+struct bar @{\n+  char z;\n+  struct foo f;\n+@};\n+@end group\n+@end smallexample\n+\n+@item -Wpadded\n+Warn if padding is included in a structure, either to align an element\n+of the structure or to align the whole structure.  Sometimes when this\n+happens it is possible to rearrange the fields of the structure to\n+reduce the padding and so make the structure smaller.\n+\n @item -Wredundant-decls\n Warn if anything is declared more than once in the same scope, even in\n cases where multiple declaration is valid and changes nothing."}, {"sha": "1688fc30a00f0516c3c1ffffbc2a1a7d8beddd5a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 96, "deletions": 22, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "patch": "@@ -347,18 +347,20 @@ layout_record (rec)\n {\n   register tree field;\n   unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n+  unsigned unpacked_align = record_align;\n   /* These must be laid out *after* the record is.  */\n   tree pending_statics = NULL_TREE;\n   /* Record size so far is CONST_SIZE + VAR_SIZE bits,\n      where CONST_SIZE is an integer\n      and VAR_SIZE is a tree expression.\n      If VAR_SIZE is null, the size is just CONST_SIZE.\n      Naturally we try to avoid using VAR_SIZE.  */\n- register HOST_WIDE_INT const_size = 0;\n+  register HOST_WIDE_INT const_size = 0;\n   register tree var_size = 0;\n   /* Once we start using VAR_SIZE, this is the maximum alignment\n      that we know VAR_SIZE has.  */\n   register int var_align = BITS_PER_UNIT;\n+  int packed_maybe_necessary = 0;\n \n #ifdef STRUCTURE_SIZE_BOUNDARY\n   /* Packed structures don't need to have minimum size.  */\n@@ -370,6 +372,7 @@ layout_record (rec)\n     {\n       register int known_align = var_size ? var_align : const_size;\n       register int desired_align = 0;\n+      tree type = TREE_TYPE (field);\n \n       /* If FIELD is static, then treat it like a separate variable,\n \t not really like a structure field.\n@@ -408,12 +411,10 @@ layout_record (rec)\n \t Otherwise, the alignment of the field within the record\n \t is meaningless.  */\n \n-#ifndef PCC_BITFIELD_TYPE_MATTERS\n-      record_align = MAX (record_align, desired_align);\n-#else\n-      if (PCC_BITFIELD_TYPE_MATTERS && TREE_TYPE (field) != error_mark_node\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+      if (PCC_BITFIELD_TYPE_MATTERS && type != error_mark_node\n \t  && DECL_BIT_FIELD_TYPE (field)\n-\t  && ! integer_zerop (TYPE_SIZE (TREE_TYPE (field))))\n+\t  && ! integer_zerop (TYPE_SIZE (type)))\n \t{\n \t  /* For these machines, a zero-length field does not\n \t     affect the alignment of the structure as a whole.\n@@ -422,36 +423,63 @@ layout_record (rec)\n \t  if (! integer_zerop (DECL_SIZE (field)))\n \t    record_align = MAX ((int)record_align, desired_align);\n \t  else if (! DECL_PACKED (field))\n-\t    desired_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t    desired_align = TYPE_ALIGN (type);\n \t  /* A named bit field of declared type `int'\n \t     forces the entire structure to have `int' alignment.  */\n \t  if (DECL_NAME (field) != 0)\n \t    {\n-\t      int type_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t      int type_align = TYPE_ALIGN (type);\n \t      if (maximum_field_alignment != 0)\n \t\ttype_align = MIN (type_align, maximum_field_alignment);\n \t      else if (DECL_PACKED (field))\n \t\ttype_align = MIN (type_align, BITS_PER_UNIT);\n \n-\t      record_align = MAX ((int)record_align, type_align);\n+\t      record_align = MAX ((int) record_align, type_align);\n+\t      if (warn_packed)\n+\t\tunpacked_align = MAX (unpacked_align, TYPE_ALIGN (type));\n \t    }\n \t}\n       else\n-\trecord_align = MAX ((int)record_align, desired_align);\n #endif\n+\t{\n+\t  record_align = MAX ((int) record_align, desired_align);\n+\t  if (warn_packed)\n+\t    unpacked_align = MAX (unpacked_align, TYPE_ALIGN (type));\n+\t}\n+\n+      if (warn_packed && DECL_PACKED (field))\n+\t{\n+\t  if (const_size % TYPE_ALIGN (type) == 0\n+\t      || (var_align % TYPE_ALIGN (type) == 0\n+\t\t  && var_size != NULL_TREE))\n+\t    {\n+\t      if (TYPE_ALIGN (type) > desired_align)\n+\t\t{\n+\t\t  if (STRICT_ALIGNMENT)\n+\t\t    warning_with_decl (field, \"packed attribute causes inefficient alignment for `%s'\");\n+\t\t  else\n+\t\t    warning_with_decl (field, \"packed attribute is unnecessary for `%s'\");\n+\t\t}\n+\t    }\n+\t  else\n+\t    packed_maybe_necessary = 1;\n+\t}\n \n       /* Does this field automatically have alignment it needs\n \t by virtue of the fields that precede it and the record's\n \t own alignment?  */\n \n       if (const_size % desired_align != 0\n \t  || (var_align % desired_align != 0\n-\t      && var_size != 0))\n+\t      && var_size != NULL_TREE))\n \t{\n \t  /* No, we need to skip space before this field.\n \t     Bump the cumulative size to multiple of field alignment.  */\n \n-\t  if (var_size == 0\n+\t  if (warn_padded)\n+\t    warning_with_decl (field, \"padding struct to align `%s'\");\n+\n+\t  if (var_size == NULL_TREE\n \t      || var_align % desired_align == 0)\n \t    const_size\n \t      = CEIL (const_size, desired_align) * desired_align;\n@@ -469,13 +497,13 @@ layout_record (rec)\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n       if (PCC_BITFIELD_TYPE_MATTERS\n \t  && TREE_CODE (field) == FIELD_DECL\n-\t  && TREE_TYPE (field) != error_mark_node\n+\t  && type != error_mark_node\n \t  && DECL_BIT_FIELD_TYPE (field)\n \t  && !DECL_PACKED (field)\n \t  && maximum_field_alignment == 0\n \t  && !integer_zerop (DECL_SIZE (field)))\n \t{\n-\t  int type_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t  int type_align = TYPE_ALIGN (type);\n \t  register tree dsize = DECL_SIZE (field);\n \t  int field_size = TREE_INT_CST_LOW (dsize);\n \n@@ -493,12 +521,12 @@ layout_record (rec)\n #ifdef BITFIELD_NBYTES_LIMITED\n       if (BITFIELD_NBYTES_LIMITED\n \t  && TREE_CODE (field) == FIELD_DECL\n-\t  && TREE_TYPE (field) != error_mark_node\n+\t  && type != error_mark_node\n \t  && DECL_BIT_FIELD_TYPE (field)\n \t  && !DECL_PACKED (field)\n \t  && !integer_zerop (DECL_SIZE (field)))\n \t{\n-\t  int type_align = TYPE_ALIGN (TREE_TYPE (field));\n+\t  int type_align = TYPE_ALIGN (type);\n \t  register tree dsize = DECL_SIZE (field);\n \t  int field_size = TREE_INT_CST_LOW (dsize);\n \n@@ -556,7 +584,7 @@ layout_record (rec)\n \t  const_size += TREE_INT_CST_LOW (dsize);\n \telse\n \t  {\n-\t    if (var_size == 0)\n+\t    if (var_size == NULL_TREE)\n \t      var_size = dsize;\n \t    else\n \t      var_size = size_binop (PLUS_EXPR, var_size, dsize);\n@@ -568,7 +596,7 @@ layout_record (rec)\n      as one expression and store in the record type.\n      Round it up to a multiple of the record's alignment.  */\n \n-  if (var_size == 0)\n+  if (var_size == NULL_TREE)\n     {\n       TYPE_SIZE (rec) = bitsize_int (const_size, 0L);\n     }\n@@ -591,13 +619,59 @@ layout_record (rec)\n      the size of TYPE_BINFO to make sure that BINFO_SIZE is available.  */\n   if (TYPE_BINFO (rec) && TREE_VEC_LENGTH (TYPE_BINFO (rec)) > 6)\n     TYPE_BINFO_SIZE (rec) = TYPE_SIZE (rec);\n-\n+  \n+  {\n+    tree unpadded_size = TYPE_SIZE (rec);\n #ifdef ROUND_TYPE_SIZE\n-  TYPE_SIZE (rec) = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+    TYPE_SIZE (rec) = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), TYPE_ALIGN (rec));\n #else\n-  /* Round the size up to be a multiple of the required alignment */\n-  TYPE_SIZE (rec) = round_up (TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+    /* Round the size up to be a multiple of the required alignment */\n+    TYPE_SIZE (rec) = round_up (TYPE_SIZE (rec), TYPE_ALIGN (rec));\n #endif\n+    if (warn_padded && var_size == NULL_TREE\n+\t&& simple_cst_equal (unpadded_size, TYPE_SIZE (rec)) == 0)\n+      warning (\"padding struct size to alignment boundary\");\n+  }\n+  \n+  if (warn_packed && TYPE_PACKED (rec) && !packed_maybe_necessary\n+      && var_size == NULL_TREE)\n+    {\n+      tree unpacked_size;\n+      TYPE_PACKED (rec) = 0;\n+#ifdef ROUND_TYPE_ALIGN\n+      unpacked_align = ROUND_TYPE_ALIGN (rec, TYPE_ALIGN (rec), unpacked_align);\n+#else\n+      unpacked_align = MAX (TYPE_ALIGN (rec), unpacked_align);\n+#endif\n+#ifdef ROUND_TYPE_SIZE\n+      unpacked_size = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), unpacked_align);\n+#else\n+      unpacked_size = round_up (TYPE_SIZE (rec), unpacked_align);\n+#endif\n+      if (simple_cst_equal (unpacked_size, TYPE_SIZE (rec)))\n+\t{\n+\t  if (TYPE_NAME (rec))\n+\t    {\n+\t      char *name;\n+\t      if (TREE_CODE (TYPE_NAME (rec)) == IDENTIFIER_NODE)\n+\t\tname = IDENTIFIER_POINTER (TYPE_NAME (rec));\n+\t      else\n+\t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (rec)));\n+\t      if (STRICT_ALIGNMENT)\n+\t\twarning (\"packed attribute causes inefficient alignment for `%s'\", name);\n+\t      else\n+\t\twarning (\"packed attribute is unnecessary for `%s'\", name);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (STRICT_ALIGNMENT)\n+\t\twarning (\"packed attribute causes inefficient alignment\");\n+\t      else\n+\t\twarning (\"packed attribute is unnecessary\");\n+\t    }\n+\t}\n+      TYPE_PACKED (rec) = 1;\n+    }\n \n   return pending_statics;\n }"}, {"sha": "70ea2a15945b81841d1a6b13f482e5801e8c6ba2", "filename": "gcc/toplev.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c12fcc27809a223032e1b0ad2beba1f6844a5c6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "patch": "@@ -1258,6 +1258,14 @@ int warn_inline;\n \n int warn_aggregate_return;\n \n+/* Warn if packed attribute on struct is unnecessary and inefficient.  */\n+\n+int warn_packed;\n+\n+/* Warn when gcc pads a structure to an alignment boundary.  */\n+\n+int warn_padded;\n+\n /* Likewise for -W.  */\n \n lang_independent_options W_options[] =\n@@ -1276,7 +1284,11 @@ lang_independent_options W_options[] =\n   {\"uninitialized\", &warn_uninitialized, 1,\n    \"Warn about unitialized automatic variables\"},\n   {\"inline\", &warn_inline, 1,\n-   \"Warn when an inlined function cannot be inlined\"}\n+   \"Warn when an inlined function cannot be inlined\"},\n+  {\"packed\", &warn_packed, 1,\n+   \"Warn when the packed attribute has no effect on struct layout\"},\n+  {\"padded\", &warn_padded, 1,\n+   \"Warn when padding is required to align struct members\"}\n };\n \f\n /* Output files for assembler code (real compiler output)"}]}