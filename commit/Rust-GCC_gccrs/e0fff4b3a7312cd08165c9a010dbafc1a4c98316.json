{"sha": "e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBmZmY0YjNhNzMxMmNkMDgxNjVjOWEwMTBkYmFmYzFhNGM5ODMxNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-02-18T19:08:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-02-18T19:08:00Z"}, "message": "Do put the VTT parameter in DECL_ARGUMENTS.\n\n        * cp-tree.h (struct cp_language_function): Add x_vtt_parm.\n        (current_vtt_parm): New macro.\n        (struct lang_decl_flags): Add has_vtt_parm_p, remove vtt_parm.\n        (DECL_HAS_VTT_PARM_P): New macro.\n        (DECL_VTT_PARM): Remove.\n        (FUNCTION_FIRST_USER_PARMTYPE, FUNCTION_FIRST_USER_PARM): New macros.\n        * decl.c (duplicate_decls): Only copy the operator code if\n        appropriate.\n        (start_function): Set current_vtt_parm.\n        (lang_mark_tree): Don't mark vtt_parm.\n        * decl2.c (maybe_retrofit_in_chrg): Do add the VTT parm to\n        DECL_ARGUMENTS.  Set DECL_HAS_VTT_PARM_P.\n        * class.c (build_clone): Maybe remove the VTT parm.\n        * optimize.c (maybe_clone_body): Set up the VTT parm.\n        * pt.c (copy_default_args_to_explicit_spec): Preserve the VTT parm.\n        * call.c (build_over_call): Just allow the VTT arg.\n        * method.c (make_thunk): Don't set DECL_VTT_PARM.\n        (do_build_copy_constructor): Use FUNCTION_FIRST_USER_PARM.\n        (synthesize_method): Use FUNCTION_FIRST_USER_PARMTYPE.\n        * decl.c (grokdeclarator, copy_args_p, grok_ctor_properties): Likewise.\n        * error.c (dump_function_decl): Likewise.\n        * call.c (build_user_type_conversion_1, convert_like_real): Abort\n        if we try to call a constructor with in-charge or VTT parms.\n        * method.c (skip_artificial_parms_for): New fn.\n        * call.c (add_function_candidate, build_over_call): Call it.\n        * call.c (build_new_method_call): Use current_vtt_parm.\n        * init.c (expand_virtual_init): Likewise.\n        * class.c (same_signature_p): No longer static.\n        * cp-tree.h: Declare it.\n        * search.c (look_for_overrides_r): Use it.\n\nFrom-SVN: r39841", "tree": {"sha": "78833bf4bd67d918c1690aabd6f664e5a2d426ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78833bf4bd67d918c1690aabd6f664e5a2d426ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31189758710a6ea118e5f8a65aad04ea5ef968fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31189758710a6ea118e5f8a65aad04ea5ef968fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31189758710a6ea118e5f8a65aad04ea5ef968fd"}], "stats": {"total": 327, "additions": 195, "deletions": 132}, "files": [{"sha": "b94cd78b4ad99c5a4e8b16d347ab751529b8c8f0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -1,3 +1,37 @@\n+2001-02-18  Jason Merrill  <jason@redhat.com>\n+\n+\tDo put the VTT parameter in DECL_ARGUMENTS.\n+\t* cp-tree.h (struct cp_language_function): Add x_vtt_parm.\n+\t(current_vtt_parm): New macro.\n+\t(struct lang_decl_flags): Add has_vtt_parm_p, remove vtt_parm.\n+\t(DECL_HAS_VTT_PARM_P): New macro.\n+\t(DECL_VTT_PARM): Remove.\n+\t(FUNCTION_FIRST_USER_PARMTYPE, FUNCTION_FIRST_USER_PARM): New macros.\n+\t* decl.c (duplicate_decls): Only copy the operator code if\n+\tappropriate.\n+\t(start_function): Set current_vtt_parm.\n+\t(lang_mark_tree): Don't mark vtt_parm.\n+\t* decl2.c (maybe_retrofit_in_chrg): Do add the VTT parm to \n+\tDECL_ARGUMENTS.  Set DECL_HAS_VTT_PARM_P.\n+\t* class.c (build_clone): Maybe remove the VTT parm.\n+\t* optimize.c (maybe_clone_body): Set up the VTT parm.\n+\t* pt.c (copy_default_args_to_explicit_spec): Preserve the VTT parm.\n+\t* call.c (build_over_call): Just allow the VTT arg.\n+\t* method.c (make_thunk): Don't set DECL_VTT_PARM.\n+\t(do_build_copy_constructor): Use FUNCTION_FIRST_USER_PARM.\n+\t(synthesize_method): Use FUNCTION_FIRST_USER_PARMTYPE.\n+\t* decl.c (grokdeclarator, copy_args_p, grok_ctor_properties): Likewise.\n+\t* error.c (dump_function_decl): Likewise.\n+\t* call.c (build_user_type_conversion_1,\tconvert_like_real): Abort\n+\tif we try to call a constructor with in-charge or VTT parms.\n+\t* method.c (skip_artificial_parms_for): New fn.\n+\t* call.c (add_function_candidate, build_over_call): Call it.\n+\t* call.c (build_new_method_call): Use current_vtt_parm.\n+\t* init.c (expand_virtual_init): Likewise.\n+\t* class.c (same_signature_p): No longer static.\n+\t* cp-tree.h: Declare it.\n+\t* search.c (look_for_overrides_r): Use it.\n+\n 2001-02-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* init.c (build_new): Allow enumeration types for the array-bounds"}, {"sha": "b7e6e943c6b71ff5945d1355869fb2dd2a7a7588", "filename": "gcc/cp/call.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -1305,17 +1305,12 @@ add_function_candidate (candidates, fn, ctype, arglist, flags)\n   tree parmnode, argnode;\n   int viable = 1;\n \n-  /* The `this' and `in_chrg' arguments to constructors are not considered\n-     in overload resolution.  */\n+  /* The `this', `in_chrg' and VTT arguments to constructors are not\n+     considered in overload resolution.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n-      parmlist = TREE_CHAIN (parmlist);\n-      arglist = TREE_CHAIN (arglist);\n-      if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n-\t{\n-\t  parmlist = TREE_CHAIN (parmlist);\n-\t  arglist = TREE_CHAIN (arglist);\n-\t}\n+      parmlist = skip_artificial_parms_for (fn, parmlist);\n+      arglist = skip_artificial_parms_for (fn, arglist);\n     }\n \n   len = list_length (arglist);\n@@ -2382,10 +2377,11 @@ build_user_type_conversion_1 (totype, expr, flags)\n       t = build_int_2 (0, 0);\n       TREE_TYPE (t) = build_pointer_type (totype);\n       args = build_tree_list (NULL_TREE, expr);\n-      if (DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors)))\n-\targs = tree_cons (NULL_TREE, \n-\t\t\t  in_charge_arg_for_name (complete_ctor_identifier), \n-\t\t\t  args);\n+      if (DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n+\t  || DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)))\n+\t/* We should never try to call the abstract or base constructor\n+\t   from here.  */\n+\tabort ();\n       args = tree_cons (NULL_TREE, t, args);\n     }\n   for (; ctors; ctors = OVL_NEXT (ctors))\n@@ -3735,8 +3731,11 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (convfn));\n \n \t    args = build_tree_list (NULL_TREE, expr);\n-\t    if (DECL_HAS_IN_CHARGE_PARM_P (convfn))\n-\t      args = tree_cons (NULL_TREE, integer_one_node, args);\n+\t    if (DECL_HAS_IN_CHARGE_PARM_P (convfn)\n+\t\t|| DECL_HAS_VTT_PARM_P (convfn))\n+\t      /* We should never try to call the abstract or base constructor\n+\t\t from here.  */\n+\t      abort ();\n \t    args = tree_cons (NULL_TREE, t, args);\n \t  }\n \telse\n@@ -4065,6 +4064,9 @@ build_over_call (cand, args, flags)\n       arg = TREE_CHAIN (arg);\n       parm = TREE_CHAIN (parm);\n       if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n+\t/* We should never try to call the abstract constructor.  */\n+\tabort ();\n+      if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n \t  converted_args = tree_cons\n \t    (NULL_TREE, TREE_VALUE (arg), converted_args);\n@@ -4169,9 +4171,7 @@ build_over_call (cand, args, flags)\n \t   && DECL_COPY_CONSTRUCTOR_P (fn))\n     {\n       tree targ;\n-      arg = TREE_CHAIN (converted_args);\n-      if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n-\targ = TREE_CHAIN (arg);\n+      arg = skip_artificial_parms_for (fn, converted_args);\n       arg = TREE_VALUE (arg);\n \n       /* Pull out the real argument, disregarding const-correctness.  */\n@@ -4439,7 +4439,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t  vtt = build (COND_EXPR, TREE_TYPE (vtt),\n \t\t       build (EQ_EXPR, boolean_type_node,\n \t\t\t      current_in_charge_parm, integer_zero_node),\n-\t\t       DECL_VTT_PARM (current_function_decl),\n+\t\t       current_vtt_parm,\n \t\t       vtt);\n \t  if (TREE_VIA_VIRTUAL (basebinfo))\n \t    basebinfo = binfo_for_vbase (basetype, current_class_type);"}, {"sha": "7c2102101b3235f3922759fd59622ffe828aad49", "filename": "gcc/cp/class.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -119,7 +119,6 @@ static void delete_duplicate_fields PARAMS ((tree));\n static void finish_struct_bits PARAMS ((tree));\n static int alter_access PARAMS ((tree, tree, tree));\n static void handle_using_decl PARAMS ((tree, tree));\n-static int same_signature_p PARAMS ((tree, tree));\n static int strictly_overrides PARAMS ((tree, tree));\n static void mark_overriders PARAMS ((tree, tree));\n static void check_for_override PARAMS ((tree, tree));\n@@ -2460,7 +2459,7 @@ layout_vtable_decl (binfo, n)\n /* True iff FNDECL and BASE_FNDECL (both non-static member functions)\n    have the same signature.  */\n \n-static int\n+int\n same_signature_p (fndecl, base_fndecl)\n      tree fndecl, base_fndecl;\n {\n@@ -4188,8 +4187,6 @@ build_clone (fn, name)\n   DECL_PENDING_INLINE_P (clone) = 0;\n   /* And it hasn't yet been deferred.  */\n   DECL_DEFERRED_FN (clone) = 0;\n-  /* There's no magic VTT parameter in the clone.  */\n-  DECL_VTT_PARM (clone) = NULL_TREE;\n \n   /* The base-class destructor is not virtual.  */\n   if (name == base_dtor_identifier)\n@@ -4214,10 +4211,12 @@ build_clone (fn, name)\n       parmtypes = TREE_CHAIN (parmtypes);\n       /* Skip the in-charge parameter.  */\n       parmtypes = TREE_CHAIN (parmtypes);\n+      /* And the VTT parm, in a complete [cd]tor.  */\n+      if (DECL_HAS_VTT_PARM_P (fn)\n+\t  && ! DECL_NEEDS_VTT_PARM_P (clone))\n+\tparmtypes = TREE_CHAIN (parmtypes);\n        /* If this is subobject constructor or destructor, add the vtt\n \t parameter.  */\n-      if (DECL_NEEDS_VTT_PARM_P (clone))\n-\tparmtypes = hash_tree_chain (vtt_parm_type, parmtypes);\n       TREE_TYPE (clone) \n \t= build_cplus_method_type (basetype,\n \t\t\t\t   TREE_TYPE (TREE_TYPE (clone)),\n@@ -4227,8 +4226,8 @@ build_clone (fn, name)\n \t\t\t\t\t\t     exceptions);\n     }\n \n-  /* Copy the function parameters.  But, DECL_ARGUMENTS aren't\n-     function parameters; instead, those are the template parameters.  */\n+  /* Copy the function parameters.  But, DECL_ARGUMENTS on a TEMPLATE_DECL\n+     aren't function parameters; those are the template parameters.  */\n   if (TREE_CODE (clone) != TEMPLATE_DECL)\n     {\n       DECL_ARGUMENTS (clone) = copy_list (DECL_ARGUMENTS (clone));\n@@ -4239,16 +4238,17 @@ build_clone (fn, name)\n \t    = TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n \t  DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n \t}\n-\n-      /* Add the VTT parameter.  */\n-      if (DECL_NEEDS_VTT_PARM_P (clone))\n+      /* And the VTT parm, in a complete [cd]tor.  */\n+      if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n-\t  tree parm;\n-\n-\t  parm = build_artificial_parm (vtt_parm_identifier,\n-\t\t\t\t\tvtt_parm_type);\n-\t  TREE_CHAIN (parm) = TREE_CHAIN (DECL_ARGUMENTS (clone));\n-\t  TREE_CHAIN (DECL_ARGUMENTS (clone)) = parm;\n+\t  if (DECL_NEEDS_VTT_PARM_P (clone))\n+\t    DECL_HAS_VTT_PARM_P (clone) = 1;\n+\t  else\n+\t    {\n+\t      TREE_CHAIN (DECL_ARGUMENTS (clone))\n+\t\t= TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n+\t      DECL_HAS_VTT_PARM_P (clone) = 0;\n+\t    }\n \t}\n \n       for (parms = DECL_ARGUMENTS (clone); parms; parms = TREE_CHAIN (parms))"}, {"sha": "f7ed02c9990651dd9a106419d68e9d7e358d2cd4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -881,6 +881,7 @@ struct cp_language_function\n   tree x_current_class_ref;\n   tree x_eh_spec_try_block;\n   tree x_in_charge_parm;\n+  tree x_vtt_parm;\n \n   tree *x_vcalls_possible_p;\n \n@@ -927,10 +928,15 @@ struct cp_language_function\n #define current_eh_spec_try_block cp_function_chain->x_eh_spec_try_block\n \n /* The `__in_chrg' parameter for the current function.  Only used for\n-   destructors.  */\n+   constructors and destructors.  */\n \n #define current_in_charge_parm cp_function_chain->x_in_charge_parm\n \n+/* The `__vtt_parm' parameter for the current function.  Only used for\n+   constructors and destructors.  */\n+\n+#define current_vtt_parm cp_function_chain->x_vtt_parm\n+\n /* In destructors, this is a pointer to a condition in an\n    if-statement.  If the pointed-to value is boolean_true_node, then\n    there may be virtual function calls in this destructor.  */\n@@ -1249,7 +1255,18 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    ? (ENTRY)\t\t\t\t\t\t\t\t\\\n    : DECL_INITIAL (TREE_OPERAND ((ENTRY), 0)))\n \n-#define FUNCTION_ARG_CHAIN(NODE) (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n+#define FUNCTION_ARG_CHAIN(NODE) \\\n+  (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n+\n+/* Given a FUNCTION_DECL, returns the first TREE_LIST out of TYPE_ARG_TYPES\n+   which refers to a user-written parameter.  */\n+#define FUNCTION_FIRST_USER_PARMTYPE(NODE) \\\n+  (skip_artificial_parms_for (NODE, TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n+\n+/* Similarly, but for DECL_ARGUMENTS.  */\n+#define FUNCTION_FIRST_USER_PARM(NODE) \\\n+  (skip_artificial_parms_for (NODE, DECL_ARGUMENTS (NODE)))\n+\n #define PROMOTES_TO_AGGR_TYPE(NODE,CODE)\t\\\n   (((CODE) == TREE_CODE (NODE)\t\t\t\\\n        && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\\\n@@ -1825,7 +1842,7 @@ struct lang_decl_flags\n   unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n   unsigned generate_with_vtable_p : 1;\n-  unsigned dummy : 1;\n+  unsigned has_vtt_parm_p : 1;\n \n   union {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n@@ -1876,9 +1893,6 @@ struct lang_decl\n     /* In an overloaded operator, this is the value of\n        DECL_OVERLOADED_OPERATOR_P.  */\n     enum tree_code operator_code;\n-    /* In a maybe-in-charge constructor or destructor, this is\n-       DECL_VTT_PARM.  */\n-    tree vtt_parm;\n   } u2;\n };\n \n@@ -1978,10 +1992,9 @@ struct lang_decl\n #define DECL_CLONED_FUNCTION(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->cloned_function)\n \n-/* In a maybe-in-charge constructor or destructor, this is the VTT\n-   parameter.  It's not actually on the DECL_ARGUMENTS list.  */\n-#define DECL_VTT_PARM(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u2.vtt_parm)\n+/* Non-zero if the VTT parm has been added to NODE.  */\n+#define DECL_HAS_VTT_PARM_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.has_vtt_parm_p)\n \n /* Non-zero if NODE is a FUNCTION_DECL for which a VTT parameter is\n    required.  */\n@@ -3723,6 +3736,7 @@ extern void pop_lang_context\t\t\tPARAMS ((void));\n extern tree instantiate_type\t\t\tPARAMS ((tree, tree, enum instantiate_type_flags));\n extern void print_class_statistics\t\tPARAMS ((void));\n extern void build_self_reference\t\tPARAMS ((void));\n+extern int same_signature_p\t\t\tPARAMS ((tree, tree));\n extern void warn_hidden\t\t\t\tPARAMS ((tree));\n extern tree get_enclosing_class\t\t\tPARAMS ((tree));\n int is_base_of_enclosing_class\t\t\tPARAMS ((tree, tree));\n@@ -4085,6 +4099,7 @@ extern tree make_thunk\t\t\t\tPARAMS ((tree, tree, tree, int));\n extern void use_thunk\t\t\t\tPARAMS ((tree, int));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n extern tree implicitly_declare_fn               PARAMS ((special_function_kind, tree, int));\n+extern tree skip_artificial_parms_for\t\tPARAMS ((tree, tree));\n \n /* In optimize.c */\n extern void optimize_function                   PARAMS ((tree));"}, {"sha": "3b38d68c98712756a6f1557473db5ed2285b3a94", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -3399,7 +3399,9 @@ duplicate_decls (newdecl, olddecl)\n       DECL_VIRTUAL_P (newdecl) |= DECL_VIRTUAL_P (olddecl);\n       DECL_NEEDS_FINAL_OVERRIDER_P (newdecl) |= DECL_NEEDS_FINAL_OVERRIDER_P (olddecl);\n       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);\n-      DECL_LANG_SPECIFIC (newdecl)->u2 = DECL_LANG_SPECIFIC (olddecl)->u2;\n+      if (DECL_OVERLOADED_OPERATOR_P (olddecl) != ERROR_MARK)\n+\tSET_OVERLOADED_OPERATOR_CODE\n+\t  (newdecl, DECL_OVERLOADED_OPERATOR_P (olddecl));\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n       /* Optionally warn about more than one declaration for the same\n@@ -11300,15 +11302,8 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t\t/* The constructor can be called with exactly one\n \t\t   parameter if there is at least one parameter, and\n \t\t   any subsequent parameters have default arguments.\n-\t\t   We don't look at the first parameter, which is\n-\t\t   really just the `this' parameter for the new\n-\t\t   object.  */\n-\t\ttree arg_types =\n-\t\t  TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl)));\n-\n-\t\t/* Skip the `in_chrg' argument too, if present.  */\n-\t\tif (DECL_HAS_IN_CHARGE_PARM_P (decl))\n-\t\t  arg_types = TREE_CHAIN (arg_types);\n+\t\t   Ignore any compiler-added parms.  */\n+\t\ttree arg_types = FUNCTION_FIRST_USER_PARMTYPE (decl);\n \n \t\tif (arg_types == void_list_node\n \t\t    || (arg_types\n@@ -11923,9 +11918,7 @@ copy_args_p (d)\n   if (!DECL_FUNCTION_MEMBER_P (d))\n     return 0;\n \n-  t = FUNCTION_ARG_CHAIN (d);\n-  if (DECL_CONSTRUCTOR_P (d) && DECL_HAS_IN_CHARGE_PARM_P (d))\n-    t = TREE_CHAIN (t);\n+  t = FUNCTION_FIRST_USER_PARMTYPE (d);\n   if (t && TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n       && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (t)))\n \t  == DECL_CONTEXT (d))\n@@ -11948,22 +11941,9 @@ int\n grok_ctor_properties (ctype, decl)\n      tree ctype, decl;\n {\n-  tree parmtypes = FUNCTION_ARG_CHAIN (decl);\n+  tree parmtypes = FUNCTION_FIRST_USER_PARMTYPE (decl);\n   tree parmtype = parmtypes ? TREE_VALUE (parmtypes) : void_type_node;\n \n-  /* When a type has virtual baseclasses, a magical first int argument is\n-     added to any ctor so we can tell if the class has been initialized\n-     yet.  This could screw things up in this function, so we deliberately\n-     ignore the leading int if we're in that situation.  */\n-  if (DECL_HAS_IN_CHARGE_PARM_P (decl))\n-    {\n-      my_friendly_assert (parmtypes\n-\t\t\t  && TREE_VALUE (parmtypes) == integer_type_node,\n-\t\t\t  980529);\n-      parmtypes = TREE_CHAIN (parmtypes);\n-      parmtype = TREE_VALUE (parmtypes);\n-    }\n-\n   /* [class.copy]\n \n      A non-template constructor for class X is a copy constructor if\n@@ -13473,8 +13453,18 @@ start_function (declspecs, declarator, attrs, flags)\n \n       /* Constructors and destructors need to know whether they're \"in\n \t charge\" of initializing virtual base classes.  */\n+      t = TREE_CHAIN (t);\n       if (DECL_HAS_IN_CHARGE_PARM_P (decl1))\n-\tcurrent_in_charge_parm = TREE_CHAIN (t);\n+\t{\n+\t  current_in_charge_parm = t;\n+\t  t = TREE_CHAIN (t);\n+\t}\n+      if (DECL_HAS_VTT_PARM_P (decl1))\n+\t{\n+\t  if (DECL_NAME (t) != vtt_parm_identifier)\n+\t    abort ();\n+\t  current_vtt_parm = t;\n+\t}\n     }\n \n   if (DECL_INTERFACE_KNOWN (decl1))\n@@ -14425,8 +14415,6 @@ lang_mark_tree (t)\n \t      ggc_mark_tree (ld->befriending_classes);\n \t      ggc_mark_tree (ld->context);\n \t      ggc_mark_tree (ld->cloned_function);\n-\t      if (!DECL_OVERLOADED_OPERATOR_P (t))\n-\t\tggc_mark_tree (ld->u2.vtt_parm);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n \t      else if (TREE_CODE (t) == FUNCTION_DECL"}, {"sha": "37e6d4ad692d5ac7c2e3e041f76eff099d954ad1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -932,7 +932,10 @@ build_artificial_parm (name, type)\n \n    This function adds the \"in-charge\" flag to member function FN if\n    appropriate.  It is called from grokclassfn and tsubst.\n-   FN must be either a constructor or destructor.  */\n+   FN must be either a constructor or destructor.\n+\n+   The in-charge flag follows the 'this' parameter, and is followed by the\n+   VTT parm (if any), then the user-written parms.  */\n \n void\n maybe_retrofit_in_chrg (fn)\n@@ -955,17 +958,38 @@ maybe_retrofit_in_chrg (fn)\n       && !TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n     return;\n \n-  /* First add it to DECL_ARGUMENTS...  */\n-  parm = build_artificial_parm (in_charge_identifier, integer_type_node);\n-  TREE_READONLY (parm) = 1;\n-  parms = DECL_ARGUMENTS (fn);\n-  TREE_CHAIN (parm) = TREE_CHAIN (parms);\n-  TREE_CHAIN (parms) = parm;\n-\n-  /* ...and then to TYPE_ARG_TYPES.  */\n   arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   basetype = TREE_TYPE (TREE_VALUE (arg_types));\n-  arg_types = hash_tree_chain (integer_type_node, TREE_CHAIN (arg_types));\n+  arg_types = TREE_CHAIN (arg_types);\n+\n+  parms = TREE_CHAIN (DECL_ARGUMENTS (fn));\n+\n+  /* If this is a subobject constructor or destructor, our caller will\n+     pass us a pointer to our VTT.  */\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+    {\n+      parm = build_artificial_parm (vtt_parm_identifier, vtt_parm_type);\n+\n+      /* First add it to DECL_ARGUMENTS between 'this' and the real args...  */\n+      TREE_CHAIN (parm) = parms;\n+      parms = parm;\n+\n+      /* ...and then to TYPE_ARG_TYPES.  */\n+      arg_types = hash_tree_chain (vtt_parm_type, arg_types);\n+\n+      DECL_HAS_VTT_PARM_P (fn) = 1;\n+    }\n+\n+  /* Then add the in-charge parm (before the VTT parm).  */\n+  parm = build_artificial_parm (in_charge_identifier, integer_type_node);\n+  TREE_CHAIN (parm) = parms;\n+  parms = parm;\n+  arg_types = hash_tree_chain (integer_type_node, arg_types);\n+\n+  /* Insert our new parameter(s) into the list.  */\n+  TREE_CHAIN (DECL_ARGUMENTS (fn)) = parms;\n+\n+  /* And rebuild the function type.  */\n   fntype = build_cplus_method_type (basetype, TREE_TYPE (TREE_TYPE (fn)),\n \t\t\t\t    arg_types);\n   if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)))\n@@ -975,15 +999,6 @@ maybe_retrofit_in_chrg (fn)\n \n   /* Now we've got the in-charge parameter.  */\n   DECL_HAS_IN_CHARGE_PARM_P (fn) = 1;\n-\n-  /* If this is a subobject constructor or destructor, our caller will\n-     pass us a pointer to our VTT.  */\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n-    {\n-      DECL_VTT_PARM (fn) = build_artificial_parm (vtt_parm_identifier, \n-\t\t\t\t\t\t  vtt_parm_type);\n-      DECL_CONTEXT (DECL_VTT_PARM (fn)) = fn;\n-    }\n }\n \n /* Classes overload their constituent function names automatically."}, {"sha": "0ec740532dc9ada4686a08fd358088605f39b2e5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -1203,7 +1203,7 @@ dump_function_decl (t, flags)\n     }\n \n   fntype = TREE_TYPE (t);\n-  parmtypes = TYPE_ARG_TYPES (fntype);\n+  parmtypes = FUNCTION_FIRST_USER_PARMTYPE (t);\n \n   if (DECL_CLASS_SCOPE_P (t))\n     cname = DECL_CONTEXT (t);\n@@ -1241,14 +1241,6 @@ dump_function_decl (t, flags)\n \n   if (flags & TFF_DECL_SPECIFIERS) \n     {\n-      if (TREE_CODE (fntype) == METHOD_TYPE && parmtypes)\n-\t/* Skip \"this\" parameter.  */\n-\tparmtypes = TREE_CHAIN (parmtypes);\n-\n-      /* Skip past the \"in_charge\" parameter.  */\n-      if (DECL_HAS_IN_CHARGE_PARM_P (t))\n-\tparmtypes = TREE_CHAIN (parmtypes);\n-\n       dump_parameters (parmtypes, flags);\n \n       if (show_return)"}, {"sha": "4d498aa9e96ba110c5c6e3845b3373c4d5ec687a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -860,7 +860,7 @@ expand_virtual_init (binfo, decl)\n       tree vtt_parm;\n \n       /* Compute the value to use, when there's a VTT.  */\n-      vtt_parm = DECL_VTT_PARM (current_function_decl);\n+      vtt_parm = current_vtt_parm;\n       vtbl2 = build (PLUS_EXPR, \n \t\t     TREE_TYPE (vtt_parm), \n \t\t     vtt_parm,"}, {"sha": "349afcbb60badd58c7e44c802365bc8f54375650", "filename": "gcc/cp/method.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -364,7 +364,6 @@ make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n       DECL_CONSTRUCTOR_P (thunk) = 0;\n       DECL_EXTERNAL (thunk) = 1;\n       DECL_ARTIFICIAL (thunk) = 1;\n-      DECL_VTT_PARM (thunk) = NULL_TREE;\n       /* Even if this thunk is a member of a local class, we don't\n \t need a static chain.  */\n       DECL_NO_STATIC_CHAIN (thunk) = 1;\n@@ -536,11 +535,9 @@ static void\n do_build_copy_constructor (fndecl)\n      tree fndecl;\n {\n-  tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+  tree parm = FUNCTION_FIRST_USER_PARM (fndecl);\n   tree t;\n \n-  if (DECL_HAS_IN_CHARGE_PARM_P (fndecl))\n-    parm = TREE_CHAIN (parm);\n   parm = convert_from_reference (parm);\n \n   if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type)\n@@ -760,9 +757,7 @@ synthesize_method (fndecl)\n     setup_vtbl_ptr (NULL_TREE, NULL_TREE);\n   else\n     {\n-      tree arg_chain = FUNCTION_ARG_CHAIN (fndecl);\n-      if (DECL_HAS_IN_CHARGE_PARM_P (fndecl))\n-\targ_chain = TREE_CHAIN (arg_chain);\n+      tree arg_chain = FUNCTION_FIRST_USER_PARMTYPE (fndecl);\n       if (arg_chain != void_list_node)\n \tdo_build_copy_constructor (fndecl);\n       else if (TYPE_NEEDS_CONSTRUCTING (current_class_type))\n@@ -1041,3 +1036,22 @@ implicitly_declare_fn (kind, type, const_p)\n   \n   return fn;\n }\n+\n+/* Given a FUNCTION_DECL FN and a chain LIST, skip as many elements of LIST\n+   as there are artificial parms in FN.  */\n+\n+tree\n+skip_artificial_parms_for (fn, list)\n+     tree fn, list;\n+{\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+    list = TREE_CHAIN (list);\n+  else\n+    return list;\n+\n+  if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n+    list = TREE_CHAIN (list);\n+  if (DECL_HAS_VTT_PARM_P (fn))\n+    list = TREE_CHAIN (list);\n+  return list;\n+}"}, {"sha": "9d700f60904c6f777db28ba41d64f818d60256b3", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -981,22 +981,25 @@ maybe_clone_body (fn)\n \t      splay_tree_insert (id.decl_map,\n \t\t\t\t (splay_tree_key) parm,\n \t\t\t\t (splay_tree_value) in_charge);\n-\n+\t    }\n+\t  else if (DECL_ARTIFICIAL (parm)\n+\t\t   && DECL_NAME (parm) == vtt_parm_identifier)\n+\t    {\n \t      /* For a subobject constructor or destructor, the next\n \t\t argument is the VTT parameter.  Remap the VTT_PARM\n \t\t from the CLONE to this parameter.  */\n-\t      if (DECL_NEEDS_VTT_PARM_P (clone))\n+\t      if (DECL_HAS_VTT_PARM_P (clone))\n \t\t{\n \t\t  splay_tree_insert (id.decl_map,\n-\t\t\t\t     (splay_tree_key) DECL_VTT_PARM (fn),\n+\t\t\t\t     (splay_tree_key) parm,\n \t\t\t\t     (splay_tree_value) clone_parm);\n \t\t  clone_parm = TREE_CHAIN (clone_parm);\n \t\t}\n \t      /* Otherwise, map the VTT parameter to `NULL'.  */\n-\t      else if (DECL_VTT_PARM (fn))\n+\t      else\n \t\t{\n \t\t  splay_tree_insert (id.decl_map,\n-\t\t\t\t     (splay_tree_key) DECL_VTT_PARM (fn),\n+\t\t\t\t     (splay_tree_key) parm,\n \t\t\t\t     (splay_tree_value) null_pointer_node);\n \t\t}\n \t    }"}, {"sha": "ab420b55379e3cbad2eb7c5f6a9fd7926e5fc2a7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -1208,6 +1208,7 @@ copy_default_args_to_explicit_spec (decl)\n   tree t;\n   tree object_type = NULL_TREE;\n   tree in_charge = NULL_TREE;\n+  tree vtt = NULL_TREE;\n \n   /* See if there's anything we need to do.  */\n   tmpl = DECL_TI_TEMPLATE (decl);\n@@ -1236,6 +1237,11 @@ copy_default_args_to_explicit_spec (decl)\n           in_charge = spec_types;\n \t  spec_types = TREE_CHAIN (spec_types);\n \t}\n+      if (DECL_HAS_VTT_PARM_P (decl))\n+\t{\n+\t  vtt = spec_types;\n+\t  spec_types = TREE_CHAIN (spec_types);\n+\t}\n     }\n \n   /* Compute the merged default arguments.  */\n@@ -1245,6 +1251,11 @@ copy_default_args_to_explicit_spec (decl)\n   /* Compute the new FUNCTION_TYPE.  */\n   if (object_type)\n     {\n+      if (vtt)\n+        new_spec_types = hash_tree_cons (TREE_PURPOSE (vtt),\n+\t\t\t  \t         TREE_VALUE (vtt),\n+\t\t\t\t         new_spec_types);\n+\n       if (in_charge)\n         /* Put the in-charge parameter back.  */\n         new_spec_types = hash_tree_cons (TREE_PURPOSE (in_charge),"}, {"sha": "6b13469da94c71cb22a540170362f9873a201e05", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0fff4b3a7312cd08165c9a010dbafc1a4c98316/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e0fff4b3a7312cd08165c9a010dbafc1a4c98316", "patch": "@@ -2046,22 +2046,13 @@ look_for_overrides_r (type, fndecl)\n                   return 1;\n                 }\n             }\n-          else\n+          else if (same_signature_p (fndecl, fn))\n             {\n-              if (/* The first parameter is the `this' parameter,\n-\t             which has POINTER_TYPE, and we can therefore\n-\t             safely use TYPE_QUALS, rather than\n-\t\t     CP_TYPE_QUALS.  */\n-\t          (TYPE_QUALS (TREE_TYPE (TREE_VALUE (btypes)))\n-\t           == TYPE_QUALS (thistype))\n-\t          && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes)))\n-                {\n-                  /* It's definitely virtual, even if not explicitly set.  */\n-                  DECL_VIRTUAL_P (fndecl) = 1;\n-\t          check_final_overrider (fndecl, fn);\n-\t      \n-\t          return 1;\n-\t        }\n+\t      /* It's definitely virtual, even if not explicitly set.  */\n+\t      DECL_VIRTUAL_P (fndecl) = 1;\n+\t      check_final_overrider (fndecl, fn);\n+\n+\t      return 1;\n \t    }\n \t}\n     }"}]}