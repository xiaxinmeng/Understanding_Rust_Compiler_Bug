{"sha": "7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U5ZGM0MjFlNTYxOWM1M2VmMTIxOTI0NTBlZjAzZmQ0ZDdmNWQ2Mw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-11-04T17:24:37Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2009-11-04T17:24:37Z"}, "message": "gcc.c (process_command): Handle arguments name@offset.\n\n2009-11-04  Richard Guenther  <rguenther@suse.de>\n            Rafael Avila de Espindola  <espindola@google.com>\n \n\t* gcc.c (process_command): Handle arguments name@offset.\n\n2009-11-04  Richard Guenther  <rguenther@suse.de>\n            Rafael Avila de Espindola  <espindola@google.com>\n\n\t* lto-elf.c (lto_elf_build_section_table): Add the base offset.\n\t(lto_elf_file_open): Handle offsets in arguments name@offest.\n\n2009-11-04  Richard Guenther  <rguenther@suse.de>\n            Rafael Avila de Espindola  <espindola@google.com>\n\n\t* lto-plugin.c (plugin_file_info): Remove temp field.\n\t(cleanup_handler): Don't delete temporary objects.\n\t(claim_file_handler): Don't create temporary objects.\n\n\nCo-Authored-By: Rafael Avila de Espindola <espindola@google.com>\n\nFrom-SVN: r153903", "tree": {"sha": "bbdb30714a65a45ea093d3c41499626e8893a5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbdb30714a65a45ea093d3c41499626e8893a5bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43a8b705906034ecb3edfb54558a34bd362a7213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a8b705906034ecb3edfb54558a34bd362a7213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a8b705906034ecb3edfb54558a34bd362a7213"}], "stats": {"total": 180, "additions": 112, "deletions": 68}, "files": [{"sha": "619e45045b6b75f6324d29d4784d41d4e4c6f59b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "patch": "@@ -1,3 +1,8 @@\n+2009-11-04  Richard Guenther  <rguenther@suse.de>\n+            Rafael Avila de Espindola  <espindola@google.com>\n+ \n+\t* gcc.c (process_command): Handle arguments name@offset.\n+ \n 2009-11-04  Harsha Jagasia  <harsha.jagasia@amd.com>\n \t    Dwarakanath Rajagopal  <dwarak.rajagopal@amd.com>\n \t"}, {"sha": "6bc8e150a6798e54e21214b68a5c144888e8a0de", "filename": "gcc/gcc.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "patch": "@@ -4568,20 +4568,32 @@ process_command (int argc, const char **argv)\n \t}\n       else\n \t{\n+          const char *p = strchr (argv[i], '@');\n+          char *fname;\n #ifdef HAVE_TARGET_OBJECT_SUFFIX\n \t  argv[i] = convert_filename (argv[i], 0, access (argv[i], F_OK));\n #endif\n+          if (!p)\n+            fname = xstrdup (argv[i]);\n+          else\n+            {\n+              fname = (char *)xmalloc (p - argv[i] + 1);\n+              memcpy (fname, argv[i], p - argv[i]);\n+              fname[p - argv[i]] = '\\0';\n+            }\n+\n+          if (strcmp (fname, \"-\") != 0 && access (fname, F_OK) < 0)\n+            {\n+              perror_with_name (fname);\n+              error_count++;\n+            }\n+          else\n+            {\n+              infiles[n_infiles].language = spec_lang;\n+              infiles[n_infiles++].name = argv[i];\n+            }\n \n-\t  if (strcmp (argv[i], \"-\") != 0 && access (argv[i], F_OK) < 0)\n-\t    {\n-\t      perror_with_name (argv[i]);\n-\t      error_count++;\n-\t    }\n-\t  else\n-\t    {\n-\t      infiles[n_infiles].language = spec_lang;\n-\t      infiles[n_infiles++].name = argv[i];\n-\t    }\n+          free (fname);\n \t}\n     }\n "}, {"sha": "3334de7eb956e052464fde2bb44fe73a01595699", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "patch": "@@ -1,3 +1,9 @@\n+2009-11-04  Richard Guenther  <rguenther@suse.de>\n+            Rafael Avila de Espindola  <espindola@google.com>\n+\n+\t* lto-elf.c (lto_elf_build_section_table): Add the base offset.\n+\t(lto_elf_file_open): Handle offsets in arguments name@offest.\n+\n 2009-10-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41858"}, {"sha": "ee587f7a7502c5634e1f429fc7442c0bb999e928", "filename": "gcc/lto/lto-elf.c", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2Flto%2Flto-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/gcc%2Flto%2Flto-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-elf.c?ref=7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "patch": "@@ -167,9 +167,11 @@ lto_elf_build_section_table (lto_file *lto_file)\n   lto_elf_file *elf_file = (lto_elf_file *)lto_file;\n   htab_t section_hash_table;\n   Elf_Scn *section;\n+  size_t base_offset;\n \n   section_hash_table = htab_create (37, hash_name, eq_name, free);\n \n+  base_offset = elf_getbase (elf_file->elf);\n   for (section = elf_getscn (elf_file->elf, 0);\n        section;\n        section = elf_nextscn (elf_file->elf, section)) \n@@ -206,7 +208,7 @@ lto_elf_build_section_table (lto_file *lto_file)\n \n \t  new_slot->name = new_name;\n \t  /* The offset into the file for this section.  */\n-\t  new_slot->start = shdr->sh_offset;\n+\t  new_slot->start = base_offset + shdr->sh_offset;\n \t  new_slot->len = shdr->sh_size;\n \t  *slot = new_slot;\n \t}\n@@ -530,7 +532,6 @@ init_ehdr (lto_elf_file *elf_file)\n     }\n }\n \n-\n /* Open ELF file FILENAME.  If WRITABLE is true, the file is opened for write\n    and, if necessary, created.  Otherwise, the file is opened for reading.\n    Returns the opened file.  */\n@@ -540,18 +541,42 @@ lto_elf_file_open (const char *filename, bool writable)\n {\n   lto_elf_file *elf_file;\n   lto_file *result;\n+  off_t offset;\n+  const char *offset_p;\n+  char *fname;\n+\n+  offset_p = strchr (filename, '@');\n+  if (!offset_p)\n+    {\n+      fname = xstrdup (filename);\n+      offset = 0;\n+    }\n+  else\n+    {\n+      int64_t t;\n+      fname = (char *) xmalloc (offset_p - filename + 1);\n+      memcpy (fname, filename, offset_p - filename);\n+      fname[offset_p - filename] = '\\0';\n+      offset_p++;\n+      sscanf(offset_p, \"%\" PRId64 , &t);\n+      offset = t;\n+      /* elf_rand expects the offset to point to the ar header, not the\n+         object itself. Subtract the size of the ar header (60 bytes).\n+         We don't uses sizeof (struct ar_hd) to avoid including ar.h */\n+      offset -= 60;\n+    }\n \n   /* Set up.  */\n   elf_file = XCNEW (lto_elf_file);\n   result = (lto_file *) elf_file;\n-  lto_file_init (result, filename);\n+  lto_file_init (result, fname);\n   elf_file->fd = -1;\n \n   /* Open the file.  */\n-  elf_file->fd = open (filename, writable ? O_WRONLY|O_CREAT : O_RDONLY, 0666);\n+  elf_file->fd = open (fname, writable ? O_WRONLY|O_CREAT : O_RDONLY, 0666);\n   if (elf_file->fd == -1)\n     {\n-      error (\"could not open file %s\", filename);\n+      error (\"could not open file %s\", fname);\n       goto fail;\n     }\n \n@@ -571,6 +596,26 @@ lto_elf_file_open (const char *filename, bool writable)\n       goto fail;\n     }\n \n+  if (offset != 0)\n+    {\n+      Elf *e;\n+      off_t t = elf_rand (elf_file->elf, offset);\n+      if (t != offset)\n+        {\n+          error (\"could not seek in archive\");\n+          goto fail;\n+        }\n+\n+      e = elf_begin (elf_file->fd, ELF_C_READ, elf_file->elf);\n+      if (e == NULL)\n+        {\n+          error(\"could not find archive member\");\n+          goto fail;\n+        }\n+      elf_end (elf_file->elf);\n+      elf_file->elf = e;\n+    }\n+\n   if (writable)\n     {\n       init_ehdr (elf_file);"}, {"sha": "f241a664bcee38d4efeeee4c17cc932920cd22e4", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "patch": "@@ -1,3 +1,10 @@\n+2009-11-04  Richard Guenther  <rguenther@suse.de>\n+            Rafael Avila de Espindola  <espindola@google.com>\n+\n+\t* lto-plugin.c (plugin_file_info): Remove temp field.\n+\t(cleanup_handler): Don't delete temporary objects.\n+\t(claim_file_handler): Don't create temporary objects.\n+\n 2009-11-04  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* lto-plugin.c (cleanup_handler): Don't cleanup if debugging."}, {"sha": "3cf4e7cbb576cd68ddebc86610efda71ae20e564", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 22, "deletions": 53, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9dc421e5619c53ef12192450ef03fd4d7f5d63/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=7e9dc421e5619c53ef12192450ef03fd4d7f5d63", "patch": "@@ -37,7 +37,6 @@ along with this program; see the file COPYING3.  If not see\n #include <stdlib.h>\n #include <stdio.h>\n #include <inttypes.h>\n-#include <ar.h>\n #include <sys/stat.h>\n #include <unistd.h>\n #include <fcntl.h>\n@@ -70,7 +69,6 @@ struct plugin_file_info\n   char *name;\n   void *handle;\n   struct plugin_symtab symtab;\n-  unsigned char temp;\n };\n \n \n@@ -513,20 +511,9 @@ static enum ld_plugin_status\n cleanup_handler (void)\n {\n   int t;\n-  unsigned i;\n   char *arguments;\n   struct stat buf;\n \n-  for (i = 0; i < num_claimed_files; i++)\n-    {\n-      struct plugin_file_info *info = &claimed_files[i];\n-      if (info->temp)\n-\t{\n-\t  t = unlink (info->name);\n-\t  check (t == 0, LDPL_FATAL, \"could not unlink temporary file\");\n-\t}\n-    }\n-\n   if (debug)\n     return LDPS_OK;\n \n@@ -558,49 +545,39 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   Elf *elf;\n   struct plugin_file_info lto_file;\n   Elf_Data *symtab;\n-  int lto_file_fd;\n \n   if (file->offset != 0)\n     {\n-      /* FIXME lto: lto1 should know how to handle archives. */\n-      int fd;\n-      off_t size = file->filesize;\n-      off_t offset;\n-\n-      static int objnum = 0;\n       char *objname;\n-      int t = asprintf (&objname, \"%s/obj%d.o\",\n-\t\t\ttemp_obj_dir_name, objnum);\n+      Elf *archive;\n+      off_t offset;\n+      /* We pass the offset of the actual file, not the archive header. */\n+      int t = asprintf (&objname, \"%s@%\" PRId64, file->name,\n+                        (int64_t) file->offset);\n       check (t >= 0, LDPL_FATAL, \"asprintf failed\");\n-      objnum++;\n-\n-      fd = open (objname, O_RDWR | O_CREAT, 0666);\n-      check (fd > 0, LDPL_FATAL, \"could not open/create temporary file\");\n-      offset = lseek (file->fd, file->offset, SEEK_SET);\n-      check (offset == file->offset, LDPL_FATAL, \"could not seek\");\n-      while (size > 0)\n-\t{\n-\t  ssize_t r, written;\n-\t  char buf[1000];\n-\t  off_t s = sizeof (buf) < size ? sizeof (buf) : size;\n-\t  r = read (file->fd, buf, s);\n-\t  written = write (fd, buf, r);\n-\t  check (written == r, LDPL_FATAL, \"could not write to temporary file\");\n-\t  size -= r;\n-\t}\n       lto_file.name = objname;\n-      lto_file_fd = fd;\n-      lto_file.handle = file->handle;\n-      lto_file.temp = 1;\n+\n+      archive = elf_begin (file->fd, ELF_C_READ, NULL);\n+      check (elf_kind (archive) == ELF_K_AR, LDPL_FATAL,\n+             \"Not an archive and offset not 0\");\n+\n+      /* elf_rand expects the offset to point to the ar header, not the\n+         object itself. Subtract the size of the ar header (60 bytes).\n+         We don't uses sizeof (struct ar_hd) to avoid including ar.h */\n+\n+      offset = file->offset - 60;\n+      check (offset == elf_rand (archive, offset), LDPL_FATAL,\n+             \"could not seek in archive\");\n+      elf = elf_begin (file->fd, ELF_C_READ, archive);\n+      check (elf != NULL, LDPL_FATAL, \"could not find archive member\");\n+      elf_end (archive);\n     }\n   else\n     {\n       lto_file.name = strdup (file->name);\n-      lto_file_fd = file->fd;\n-      lto_file.handle = file->handle;\n-      lto_file.temp = 0;\n+      elf = elf_begin (file->fd, ELF_C_READ, NULL);\n     }\n-  elf = elf_begin (lto_file_fd, ELF_C_READ, NULL);\n+  lto_file.handle = file->handle;\n \n   *claimed = 0;\n \n@@ -627,20 +604,12 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   goto cleanup;\n \n  err:\n-  if (file->offset != 0)\n-    {\n-      int t = unlink (lto_file.name);\n-      check (t == 0, LDPL_FATAL, \"could not unlink file\");\n-    }\n   free (lto_file.name);\n \n  cleanup:\n   if (elf)\n     elf_end (elf);\n \n-  if (file->offset != 0)\n-    close (lto_file_fd);\n-\n   return LDPS_OK;\n }\n "}]}