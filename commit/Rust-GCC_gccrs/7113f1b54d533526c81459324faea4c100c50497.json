{"sha": "7113f1b54d533526c81459324faea4c100c50497", "node_id": "C_kwDOANBUbNoAKDcxMTNmMWI1NGQ1MzM1MjZjODE0NTkzMjRmYWVhNGMxMDBjNTA0OTc", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-09-15T13:49:02Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-10-20T12:27:49Z"}, "message": "Rename asm_out_file function arguments.\n\nAs preparation for a new global object that will encapsulate\nasm_out_file, we would need to live with a macro that will\ndefine asm_out_file as casm->out_file and thus the name\ncan't be used in function arguments.\n\ngcc/ChangeLog:\n\n\t* config/arm/arm.c (arm_unwind_emit_sequence): Do not declare\n\talready declared global variable.\n\t(arm_unwind_emit_set): Use out_file as function argument.\n\t(arm_unwind_emit): Likewise.\n\t* config/darwin.c (machopic_output_data_section_indirection): Likewise.\n\t(machopic_output_stub_indirection): Likewise.\n\t(machopic_output_indirection): Likewise.\n\t(machopic_finish): Likewise.\n\t* config/i386/i386.c (ix86_asm_output_function_label): Likewise.\n\t* config/i386/winnt.c (i386_pe_seh_unwind_emit): Likewise.\n\t* config/ia64/ia64.c (process_epilogue): Likewise.\n\t(process_cfa_adjust_cfa): Likewise.\n\t(process_cfa_register): Likewise.\n\t(process_cfa_offset): Likewise.\n\t(ia64_asm_unwind_emit): Likewise.\n\t* config/s390/s390.c (s390_asm_output_function_label): Likewise.", "tree": {"sha": "2936a60771849d613c6be75e98eeb9c82223db3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2936a60771849d613c6be75e98eeb9c82223db3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7113f1b54d533526c81459324faea4c100c50497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7113f1b54d533526c81459324faea4c100c50497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7113f1b54d533526c81459324faea4c100c50497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7113f1b54d533526c81459324faea4c100c50497/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25ab851dd333d7369229050536bd7238091139bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ab851dd333d7369229050536bd7238091139bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25ab851dd333d7369229050536bd7238091139bb"}], "stats": {"total": 214, "additions": 106, "deletions": 108}, "files": [{"sha": "c4ff06b087ebecc91c419cb4ecf009c3535955df", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=7113f1b54d533526c81459324faea4c100c50497", "patch": "@@ -838,8 +838,6 @@ static char *         minipool_startobj;\n    will be conditionalised if possible.  */\n static int max_insns_skipped = 5;\n \n-extern FILE * asm_out_file;\n-\n /* True if we are currently building a constant table.  */\n int making_const_table;\n \n@@ -29408,7 +29406,7 @@ arm_dwarf_register_span (rtx rtl)\n    epilogue.  */\n \n static void\n-arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n+arm_unwind_emit_sequence (FILE * out_file, rtx p)\n {\n   int i;\n   HOST_WIDE_INT offset;\n@@ -29452,14 +29450,14 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n \tpadlast = offset - 4;\n       gcc_assert (padlast == 0 || padlast == 4);\n       if (padlast == 4)\n-\tfprintf (asm_out_file, \"\\t.pad #4\\n\");\n+\tfprintf (out_file, \"\\t.pad #4\\n\");\n       reg_size = 4;\n-      fprintf (asm_out_file, \"\\t.save {\");\n+      fprintf (out_file, \"\\t.save {\");\n     }\n   else if (IS_VFP_REGNUM (reg))\n     {\n       reg_size = 8;\n-      fprintf (asm_out_file, \"\\t.vsave {\");\n+      fprintf (out_file, \"\\t.vsave {\");\n     }\n   else\n     /* Unknown register type.  */\n@@ -29485,13 +29483,13 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n       gcc_assert (reg >= lastreg);\n \n       if (i != 1)\n-\tfprintf (asm_out_file, \", \");\n+\tfprintf (out_file, \", \");\n       /* We can't use %r for vfp because we need to use the\n \t double precision register names.  */\n       if (IS_VFP_REGNUM (reg))\n-\tasm_fprintf (asm_out_file, \"d%d\", (reg - FIRST_VFP_REGNUM) / 2);\n+\tasm_fprintf (out_file, \"d%d\", (reg - FIRST_VFP_REGNUM) / 2);\n       else\n-\tasm_fprintf (asm_out_file, \"%r\", reg);\n+\tasm_fprintf (out_file, \"%r\", reg);\n \n       if (flag_checking)\n \t{\n@@ -29509,15 +29507,15 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n \t  offset += reg_size;\n \t}\n     }\n-  fprintf (asm_out_file, \"}\\n\");\n+  fprintf (out_file, \"}\\n\");\n   if (padfirst)\n-    fprintf (asm_out_file, \"\\t.pad #%d\\n\", padfirst);\n+    fprintf (out_file, \"\\t.pad #%d\\n\", padfirst);\n }\n \n /*  Emit unwind directives for a SET.  */\n \n static void\n-arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n+arm_unwind_emit_set (FILE * out_file, rtx p)\n {\n   rtx e0;\n   rtx e1;\n@@ -29534,12 +29532,12 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \t  || REGNO (XEXP (XEXP (e0, 0), 0)) != SP_REGNUM)\n \tabort ();\n \n-      asm_fprintf (asm_out_file, \"\\t.save \");\n+      asm_fprintf (out_file, \"\\t.save \");\n       if (IS_VFP_REGNUM (REGNO (e1)))\n-\tasm_fprintf(asm_out_file, \"{d%d}\\n\",\n+\tasm_fprintf(out_file, \"{d%d}\\n\",\n \t\t    (REGNO (e1) - FIRST_VFP_REGNUM) / 2);\n       else\n-\tasm_fprintf(asm_out_file, \"{%r}\\n\", REGNO (e1));\n+\tasm_fprintf(out_file, \"{%r}\\n\", REGNO (e1));\n       break;\n \n     case REG:\n@@ -29552,7 +29550,7 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \t      || !CONST_INT_P (XEXP (e1, 1)))\n \t    abort ();\n \n-\t  asm_fprintf (asm_out_file, \"\\t.pad #%wd\\n\",\n+\t  asm_fprintf (out_file, \"\\t.pad #%wd\\n\",\n \t\t       -INTVAL (XEXP (e1, 1)));\n \t}\n       else if (REGNO (e0) == HARD_FRAME_POINTER_REGNUM)\n@@ -29566,14 +29564,14 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \t\tabort ();\n \t      reg = REGNO (XEXP (e1, 0));\n \t      offset = INTVAL (XEXP (e1, 1));\n-\t      asm_fprintf (asm_out_file, \"\\t.setfp %r, %r, #%wd\\n\",\n+\t      asm_fprintf (out_file, \"\\t.setfp %r, %r, #%wd\\n\",\n \t\t\t   HARD_FRAME_POINTER_REGNUM, reg,\n \t\t\t   offset);\n \t    }\n \t  else if (REG_P (e1))\n \t    {\n \t      reg = REGNO (e1);\n-\t      asm_fprintf (asm_out_file, \"\\t.setfp %r, %r\\n\",\n+\t      asm_fprintf (out_file, \"\\t.setfp %r, %r\\n\",\n \t\t\t   HARD_FRAME_POINTER_REGNUM, reg);\n \t    }\n \t  else\n@@ -29582,15 +29580,15 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n       else if (REG_P (e1) && REGNO (e1) == SP_REGNUM)\n \t{\n \t  /* Move from sp to reg.  */\n-\t  asm_fprintf (asm_out_file, \"\\t.movsp %r\\n\", REGNO (e0));\n+\t  asm_fprintf (out_file, \"\\t.movsp %r\\n\", REGNO (e0));\n \t}\n      else if (GET_CODE (e1) == PLUS\n \t      && REG_P (XEXP (e1, 0))\n \t      && REGNO (XEXP (e1, 0)) == SP_REGNUM\n \t      && CONST_INT_P (XEXP (e1, 1)))\n \t{\n \t  /* Set reg to offset from sp.  */\n-\t  asm_fprintf (asm_out_file, \"\\t.movsp %r, #%d\\n\",\n+\t  asm_fprintf (out_file, \"\\t.movsp %r, #%d\\n\",\n \t\t       REGNO (e0), (int)INTVAL(XEXP (e1, 1)));\n \t}\n       else\n@@ -29606,7 +29604,7 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n /* Emit unwind directives for the given insn.  */\n \n static void\n-arm_unwind_emit (FILE * asm_out_file, rtx_insn *insn)\n+arm_unwind_emit (FILE * out_file, rtx_insn *insn)\n {\n   rtx note, pat;\n   bool handled_one = false;\n@@ -29649,7 +29647,7 @@ arm_unwind_emit (FILE * asm_out_file, rtx_insn *insn)\n \n \t    gcc_assert (src == stack_pointer_rtx);\n \t    reg = REGNO (dest);\n-\t    asm_fprintf (asm_out_file, \"\\t.unwind_raw 0, 0x%x @ vsp = r%d\\n\",\n+\t    asm_fprintf (out_file, \"\\t.unwind_raw 0, 0x%x @ vsp = r%d\\n\",\n \t\t\t reg + 0x90, reg);\n \t  }\n \t  handled_one = true;\n@@ -29682,12 +29680,12 @@ arm_unwind_emit (FILE * asm_out_file, rtx_insn *insn)\n   switch (GET_CODE (pat))\n     {\n     case SET:\n-      arm_unwind_emit_set (asm_out_file, pat);\n+      arm_unwind_emit_set (out_file, pat);\n       break;\n \n     case SEQUENCE:\n       /* Store multiple.  */\n-      arm_unwind_emit_sequence (asm_out_file, pat);\n+      arm_unwind_emit_sequence (out_file, pat);\n       break;\n \n     default:"}, {"sha": "204114c96a26648b2beaff632fbc692e752dbf1d", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=7113f1b54d533526c81459324faea4c100c50497", "patch": "@@ -1059,7 +1059,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)\n \n int\n machopic_output_data_section_indirection (machopic_indirection **slot,\n-\t\t\t\t\t  FILE *asm_out_file)\n+\t\t\t\t\t  FILE *out_file)\n {\n   machopic_indirection *p = *slot;\n \n@@ -1074,7 +1074,7 @@ machopic_output_data_section_indirection (machopic_indirection **slot,\n \n   switch_to_section (data_section);\n   assemble_align (GET_MODE_ALIGNMENT (Pmode));\n-  assemble_label (asm_out_file, ptr_name);\n+  assemble_label (out_file, ptr_name);\n   assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),\n \t\t    GET_MODE_SIZE (Pmode),\n \t\t    GET_MODE_ALIGNMENT (Pmode), 1);\n@@ -1084,7 +1084,7 @@ machopic_output_data_section_indirection (machopic_indirection **slot,\n \n int\n machopic_output_stub_indirection (machopic_indirection **slot,\n-\t\t\t\t  FILE *asm_out_file)\n+\t\t\t\t  FILE *out_file)\n {\n   machopic_indirection *p = *slot;\n \n@@ -1122,13 +1122,13 @@ machopic_output_stub_indirection (machopic_indirection **slot,\n   else\n     sprintf (stub, \"%s%s\", user_label_prefix, ptr_name);\n \n-  machopic_output_stub (asm_out_file, sym, stub);\n+  machopic_output_stub (out_file, sym, stub);\n \n   return 1;\n }\n \n int\n-machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)\n+machopic_output_indirection (machopic_indirection **slot, FILE *out_file)\n {\n   machopic_indirection *p = *slot;\n \n@@ -1160,18 +1160,18 @@ machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)\n \t     storage has been allocated.  */\n \t  && !TREE_STATIC (decl))\n \t{\n-\t  fputs (\"\\t.weak_reference \", asm_out_file);\n-\t  assemble_name (asm_out_file, sym_name);\n-\t  fputc ('\\n', asm_out_file);\n+\t  fputs (\"\\t.weak_reference \", out_file);\n+\t  assemble_name (out_file, sym_name);\n+\t  fputc ('\\n', out_file);\n \t}\n     }\n \n-  assemble_name (asm_out_file, ptr_name);\n-  fprintf (asm_out_file, \":\\n\");\n+  assemble_name (out_file, ptr_name);\n+  fprintf (out_file, \":\\n\");\n \n-  fprintf (asm_out_file, \"\\t.indirect_symbol \");\n-  assemble_name (asm_out_file, sym_name);\n-  fprintf (asm_out_file, \"\\n\");\n+  fprintf (out_file, \"\\t.indirect_symbol \");\n+  assemble_name (out_file, sym_name);\n+  fprintf (out_file, \"\\n\");\n \n   /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to\n      have their symbol name instead of 0 in the second entry of\n@@ -1191,21 +1191,21 @@ machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)\n }\n \n static void\n-machopic_finish (FILE *asm_out_file)\n+machopic_finish (FILE *out_file)\n {\n   if (!machopic_indirections)\n     return;\n \n   /* First output an symbol indirections that have been placed into .data\n      (we don't expect these now).  */\n   machopic_indirections->traverse_noresize\n-    <FILE *, machopic_output_data_section_indirection> (asm_out_file);\n+    <FILE *, machopic_output_data_section_indirection> (out_file);\n \n   machopic_indirections->traverse_noresize\n-    <FILE *, machopic_output_stub_indirection> (asm_out_file);\n+    <FILE *, machopic_output_stub_indirection> (out_file);\n \n   machopic_indirections->traverse_noresize\n-    <FILE *, machopic_output_indirection> (asm_out_file);\n+    <FILE *, machopic_output_indirection> (out_file);\n }\n \n int"}, {"sha": "e3988f82b566b0fdd60d7999b5235c7091d3d621", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7113f1b54d533526c81459324faea4c100c50497", "patch": "@@ -1567,7 +1567,7 @@ ix86_function_naked (const_tree fn)\n /* Write the extra assembler code needed to declare a function properly.  */\n \n void\n-ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n+ix86_asm_output_function_label (FILE *out_file, const char *fname,\n \t\t\t\ttree decl)\n {\n   bool is_ms_hook = ix86_function_ms_hook_prologue (decl);\n@@ -1581,14 +1581,14 @@ ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n       unsigned int filler_cc = 0xcccccccc;\n \n       for (i = 0; i < filler_count; i += 4)\n-        fprintf (asm_out_file, ASM_LONG \" %#x\\n\", filler_cc);\n+\tfprintf (out_file, ASM_LONG \" %#x\\n\", filler_cc);\n     }\n \n #ifdef SUBTARGET_ASM_UNWIND_INIT\n-  SUBTARGET_ASM_UNWIND_INIT (asm_out_file);\n+  SUBTARGET_ASM_UNWIND_INIT (out_file);\n #endif\n \n-  ASM_OUTPUT_LABEL (asm_out_file, fname);\n+  ASM_OUTPUT_LABEL (out_file, fname);\n \n   /* Output magic byte marker, if hot-patch attribute is set.  */\n   if (is_ms_hook)\n@@ -1597,14 +1597,14 @@ ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n \t{\n \t  /* leaq [%rsp + 0], %rsp  */\n \t  fputs (ASM_BYTE \"0x48, 0x8d, 0xa4, 0x24, 0x00, 0x00, 0x00, 0x00\\n\",\n-\t\t asm_out_file);\n+\t\t out_file);\n \t}\n       else\n \t{\n           /* movl.s %edi, %edi\n \t     push   %ebp\n \t     movl.s %esp, %ebp */\n-\t  fputs (ASM_BYTE \"0x8b, 0xff, 0x55, 0x8b, 0xec\\n\", asm_out_file);\n+\t  fputs (ASM_BYTE \"0x8b, 0xff, 0x55, 0x8b, 0xec\\n\", out_file);\n \t}\n     }\n }"}, {"sha": "7c0ea4f731cc195532a8e52b6ac9ecc232d9cb86", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=7113f1b54d533526c81459324faea4c100c50497", "patch": "@@ -1231,7 +1231,7 @@ seh_frame_related_expr (FILE *f, struct seh_frame_state *seh, rtx pat)\n    required for unwind of this insn.  */\n \n void\n-i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n+i386_pe_seh_unwind_emit (FILE *out_file, rtx_insn *insn)\n {\n   rtx note, pat;\n   bool handled_one = false;\n@@ -1246,8 +1246,8 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n       /* See ix86_seh_fixup_eh_fallthru for the rationale.  */\n       rtx_insn *prev = prev_active_insn (insn);\n       if (prev && !insn_nothrow_p (prev))\n-\tfputs (\"\\tnop\\n\", asm_out_file);\n-      fputs (\"\\t.seh_endproc\\n\", asm_out_file);\n+\tfputs (\"\\tnop\\n\", out_file);\n+      fputs (\"\\t.seh_endproc\\n\", out_file);\n       seh->in_cold_section = true;\n       return;\n     }\n@@ -1286,15 +1286,15 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n \t      if (GET_CODE (pat) == PARALLEL)\n \t\tpat = XVECEXP (pat, 0, 0);\n \t    }\n-\t  seh_cfa_adjust_cfa (asm_out_file, seh, pat);\n+\t  seh_cfa_adjust_cfa (out_file, seh, pat);\n \t  handled_one = true;\n \t  break;\n \n \tcase REG_CFA_OFFSET:\n \t  pat = XEXP (note, 0);\n \t  if (pat == NULL)\n \t    pat = single_set (insn);\n-\t  seh_cfa_offset (asm_out_file, seh, pat);\n+\t  seh_cfa_offset (out_file, seh, pat);\n \t  handled_one = true;\n \t  break;\n \n@@ -1306,7 +1306,7 @@ i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n     return;\n   pat = PATTERN (insn);\n  found:\n-  seh_frame_related_expr (asm_out_file, seh, pat);\n+  seh_frame_related_expr (out_file, seh, pat);\n }\n \n void"}, {"sha": "96c0efb4afdddabce22cd2f792df66eb7fc6cf32", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=7113f1b54d533526c81459324faea4c100c50497", "patch": "@@ -10044,7 +10044,7 @@ static bool need_copy_state;\n /* The function emits unwind directives for the start of an epilogue.  */\n \n static void\n-process_epilogue (FILE *asm_out_file, rtx insn ATTRIBUTE_UNUSED,\n+process_epilogue (FILE *out_file, rtx insn ATTRIBUTE_UNUSED,\n \t\t  bool unwind, bool frame ATTRIBUTE_UNUSED)\n {\n   /* If this isn't the last block of the function, then we need to label the\n@@ -10053,19 +10053,19 @@ process_epilogue (FILE *asm_out_file, rtx insn ATTRIBUTE_UNUSED,\n   if (!last_block)\n     {\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.label_state %d\\n\",\n+\tfprintf (out_file, \"\\t.label_state %d\\n\",\n \t\t ++cfun->machine->state_num);\n       need_copy_state = true;\n     }\n \n   if (unwind)\n-    fprintf (asm_out_file, \"\\t.restore sp\\n\");\n+    fprintf (out_file, \"\\t.restore sp\\n\");\n }\n \n /* This function processes a SET pattern for REG_CFA_ADJUST_CFA.  */\n \n static void\n-process_cfa_adjust_cfa (FILE *asm_out_file, rtx pat, rtx insn,\n+process_cfa_adjust_cfa (FILE *out_file, rtx pat, rtx insn,\n \t\t\tbool unwind, bool frame)\n {\n   rtx dest = SET_DEST (pat);\n@@ -10084,17 +10084,17 @@ process_cfa_adjust_cfa (FILE *asm_out_file, rtx pat, rtx insn,\n \t    {\n \t      gcc_assert (!frame_pointer_needed);\n \t      if (unwind)\n-\t\tfprintf (asm_out_file,\n+\t\tfprintf (out_file,\n \t\t\t \"\\t.fframe \" HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t\t\t -INTVAL (op1));\n \t    }\n \t  else\n-\t    process_epilogue (asm_out_file, insn, unwind, frame);\n+\t    process_epilogue (out_file, insn, unwind, frame);\n \t}\n       else\n \t{\n \t  gcc_assert (src == hard_frame_pointer_rtx);\n-\t  process_epilogue (asm_out_file, insn, unwind, frame);\n+\t  process_epilogue (out_file, insn, unwind, frame);\n \t}\n     }\n   else if (dest == hard_frame_pointer_rtx)\n@@ -10103,7 +10103,7 @@ process_cfa_adjust_cfa (FILE *asm_out_file, rtx pat, rtx insn,\n       gcc_assert (frame_pointer_needed);\n \n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.vframe r%d\\n\",\n+\tfprintf (out_file, \"\\t.vframe r%d\\n\",\n \t\t ia64_dbx_register_number (REGNO (dest)));\n     }\n   else\n@@ -10113,7 +10113,7 @@ process_cfa_adjust_cfa (FILE *asm_out_file, rtx pat, rtx insn,\n /* This function processes a SET pattern for REG_CFA_REGISTER.  */\n \n static void\n-process_cfa_register (FILE *asm_out_file, rtx pat, bool unwind)\n+process_cfa_register (FILE *out_file, rtx pat, bool unwind)\n {\n   rtx dest = SET_DEST (pat);\n   rtx src = SET_SRC (pat);\n@@ -10124,7 +10124,7 @@ process_cfa_register (FILE *asm_out_file, rtx pat, bool unwind)\n     {\n       /* Saving return address pointer.  */\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n+\tfprintf (out_file, \"\\t.save rp, r%d\\n\",\n \t\t ia64_dbx_register_number (dest_regno));\n       return;\n     }\n@@ -10136,21 +10136,21 @@ process_cfa_register (FILE *asm_out_file, rtx pat, bool unwind)\n     case PR_REG (0):\n       gcc_assert (dest_regno == current_frame_info.r[reg_save_pr]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save pr, r%d\\n\",\n+\tfprintf (out_file, \"\\t.save pr, r%d\\n\",\n \t\t ia64_dbx_register_number (dest_regno));\n       break;\n \n     case AR_UNAT_REGNUM:\n       gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_unat]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save ar.unat, r%d\\n\",\n+\tfprintf (out_file, \"\\t.save ar.unat, r%d\\n\",\n \t\t ia64_dbx_register_number (dest_regno));\n       break;\n \n     case AR_LC_REGNUM:\n       gcc_assert (dest_regno == current_frame_info.r[reg_save_ar_lc]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save ar.lc, r%d\\n\",\n+\tfprintf (out_file, \"\\t.save ar.lc, r%d\\n\",\n \t\t ia64_dbx_register_number (dest_regno));\n       break;\n \n@@ -10163,7 +10163,7 @@ process_cfa_register (FILE *asm_out_file, rtx pat, bool unwind)\n /* This function processes a SET pattern for REG_CFA_OFFSET.  */\n \n static void\n-process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n+process_cfa_offset (FILE *out_file, rtx pat, bool unwind)\n {\n   rtx dest = SET_DEST (pat);\n   rtx src = SET_SRC (pat);\n@@ -10203,35 +10203,35 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n     case BR_REG (0):\n       gcc_assert (!current_frame_info.r[reg_save_b0]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t%s rp, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\tfprintf (out_file, \"\\t%s rp, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t saveop, off);\n       break;\n \n     case PR_REG (0):\n       gcc_assert (!current_frame_info.r[reg_save_pr]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t%s pr, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\tfprintf (out_file, \"\\t%s pr, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t saveop, off);\n       break;\n \n     case AR_LC_REGNUM:\n       gcc_assert (!current_frame_info.r[reg_save_ar_lc]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t%s ar.lc, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\tfprintf (out_file, \"\\t%s ar.lc, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t saveop, off);\n       break;\n \n     case AR_PFS_REGNUM:\n       gcc_assert (!current_frame_info.r[reg_save_ar_pfs]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t%s ar.pfs, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\tfprintf (out_file, \"\\t%s ar.pfs, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t saveop, off);\n       break;\n \n     case AR_UNAT_REGNUM:\n       gcc_assert (!current_frame_info.r[reg_save_ar_unat]);\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t%s ar.unat, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\tfprintf (out_file, \"\\t%s ar.unat, \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t saveop, off);\n       break;\n \n@@ -10240,7 +10240,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n     case GR_REG (6):\n     case GR_REG (7):\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n+\tfprintf (out_file, \"\\t.save.g 0x%x\\n\",\n \t\t 1 << (src_regno - GR_REG (4)));\n       break;\n \n@@ -10250,7 +10250,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n     case BR_REG (4):\n     case BR_REG (5):\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save.b 0x%x\\n\",\n+\tfprintf (out_file, \"\\t.save.b 0x%x\\n\",\n \t\t 1 << (src_regno - BR_REG (1)));\n       break;\n \n@@ -10259,7 +10259,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n     case FR_REG (4):\n     case FR_REG (5):\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save.f 0x%x\\n\",\n+\tfprintf (out_file, \"\\t.save.f 0x%x\\n\",\n \t\t 1 << (src_regno - FR_REG (2)));\n       break;\n \n@@ -10268,7 +10268,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n     case FR_REG (24): case FR_REG (25): case FR_REG (26): case FR_REG (27):\n     case FR_REG (28): case FR_REG (29): case FR_REG (30): case FR_REG (31):\n       if (unwind)\n-\tfprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n+\tfprintf (out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n \t\t 1 << (src_regno - FR_REG (12)));\n       break;\n \n@@ -10283,7 +10283,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n    required to unwind this insn.  */\n \n static void\n-ia64_asm_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n+ia64_asm_unwind_emit (FILE *out_file, rtx_insn *insn)\n {\n   bool unwind = ia64_except_unwind_info (&global_options) == UI_TARGET;\n   bool frame = dwarf2out_do_frame ();\n@@ -10303,8 +10303,8 @@ ia64_asm_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n \t{\n \t  if (unwind)\n \t    {\n-\t      fprintf (asm_out_file, \"\\t.body\\n\");\n-\t      fprintf (asm_out_file, \"\\t.copy_state %d\\n\",\n+\t      fprintf (out_file, \"\\t.body\\n\");\n+\t      fprintf (out_file, \"\\t.copy_state %d\\n\",\n \t\t       cfun->machine->state_num);\n \t    }\n \t  need_copy_state = false;\n@@ -10325,7 +10325,7 @@ ia64_asm_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n       if (dest_regno == current_frame_info.r[reg_save_ar_pfs])\n \t{\n \t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n+\t    fprintf (out_file, \"\\t.save ar.pfs, r%d\\n\",\n \t\t     ia64_dbx_register_number (dest_regno));\n \t}\n       else\n@@ -10338,9 +10338,9 @@ ia64_asm_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n \t     sp\" now.  */\n \t  if (current_frame_info.total_size == 0 && !frame_pointer_needed)\n \t    /* if haven't done process_epilogue() yet, do it now */\n-\t    process_epilogue (asm_out_file, insn, unwind, frame);\n+\t    process_epilogue (out_file, insn, unwind, frame);\n \t  if (unwind)\n-\t    fprintf (asm_out_file, \"\\t.prologue\\n\");\n+\t    fprintf (out_file, \"\\t.prologue\\n\");\n \t}\n       return;\n     }\n@@ -10353,23 +10353,23 @@ ia64_asm_unwind_emit (FILE *asm_out_file, rtx_insn *insn)\n \tpat = XEXP (note, 0);\n \tif (pat == NULL)\n \t  pat = PATTERN (insn);\n-\tprocess_cfa_adjust_cfa (asm_out_file, pat, insn, unwind, frame);\n+\tprocess_cfa_adjust_cfa (out_file, pat, insn, unwind, frame);\n \thandled_one = true;\n \tbreak;\n \n       case REG_CFA_OFFSET:\n \tpat = XEXP (note, 0);\n \tif (pat == NULL)\n \t  pat = PATTERN (insn);\n-\tprocess_cfa_offset (asm_out_file, pat, unwind);\n+\tprocess_cfa_offset (out_file, pat, unwind);\n \thandled_one = true;\n \tbreak;\n \n       case REG_CFA_REGISTER:\n \tpat = XEXP (note, 0);\n \tif (pat == NULL)\n \t  pat = PATTERN (insn);\n-\tprocess_cfa_register (asm_out_file, pat, unwind);\n+\tprocess_cfa_register (out_file, pat, unwind);\n \thandled_one = true;\n \tbreak;\n "}, {"sha": "b2f2f6417b39f1158260c02ff0ad01c550b66331", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7113f1b54d533526c81459324faea4c100c50497/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=7113f1b54d533526c81459324faea4c100c50497", "patch": "@@ -7808,7 +7808,7 @@ s390_asm_declare_function_size (FILE *asm_out_file,\n /* Write the extra assembler code needed to declare a function properly.  */\n \n void\n-s390_asm_output_function_label (FILE *asm_out_file, const char *fname,\n+s390_asm_output_function_label (FILE *out_file, const char *fname,\n \t\t\t\ttree decl)\n {\n   int hw_before, hw_after;\n@@ -7822,11 +7822,11 @@ s390_asm_output_function_label (FILE *asm_out_file, const char *fname,\n       /* Add a trampoline code area before the function label and initialize it\n \t with two-byte nop instructions.  This area can be overwritten with code\n \t that jumps to a patched version of the function.  */\n-      asm_fprintf (asm_out_file, \"\\tnopr\\t%%r0\"\n+      asm_fprintf (out_file, \"\\tnopr\\t%%r0\"\n \t\t   \"\\t# pre-label NOPs for hotpatch (%d halfwords)\\n\",\n \t\t   hw_before);\n       for (i = 1; i < hw_before; i++)\n-\tfputs (\"\\tnopr\\t%r0\\n\", asm_out_file);\n+\tfputs (\"\\tnopr\\t%r0\\n\", out_file);\n \n       /* Note:  The function label must be aligned so that (a) the bytes of the\n \t following nop do not cross a cacheline boundary, and (b) a jump address\n@@ -7843,35 +7843,35 @@ s390_asm_output_function_label (FILE *asm_out_file, const char *fname,\n \tfunction_alignment\n \t  = MAX (function_alignment,\n \t\t (unsigned int) align_functions.levels[0].get_value ());\n-      fputs (\"\\t# alignment for hotpatch\\n\", asm_out_file);\n-      ASM_OUTPUT_ALIGN (asm_out_file, align_functions.levels[0].log);\n+      fputs (\"\\t# alignment for hotpatch\\n\", out_file);\n+      ASM_OUTPUT_ALIGN (out_file, align_functions.levels[0].log);\n     }\n \n   if (S390_USE_TARGET_ATTRIBUTE && TARGET_DEBUG_ARG)\n     {\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s ar%d\\n\", fname, s390_arch);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s tu%d\\n\", fname, s390_tune);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s sg%d\\n\", fname, s390_stack_guard);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s ss%d\\n\", fname, s390_stack_size);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s bc%d\\n\", fname, s390_branch_cost);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s wf%d\\n\", fname,\n+      asm_fprintf (out_file, \"\\t# fn:%s ar%d\\n\", fname, s390_arch);\n+      asm_fprintf (out_file, \"\\t# fn:%s tu%d\\n\", fname, s390_tune);\n+      asm_fprintf (out_file, \"\\t# fn:%s sg%d\\n\", fname, s390_stack_guard);\n+      asm_fprintf (out_file, \"\\t# fn:%s ss%d\\n\", fname, s390_stack_size);\n+      asm_fprintf (out_file, \"\\t# fn:%s bc%d\\n\", fname, s390_branch_cost);\n+      asm_fprintf (out_file, \"\\t# fn:%s wf%d\\n\", fname,\n \t\t   s390_warn_framesize);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s ba%d\\n\", fname, TARGET_BACKCHAIN);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s hd%d\\n\", fname, TARGET_HARD_DFP);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s hf%d\\n\", fname, !TARGET_SOFT_FLOAT);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s ht%d\\n\", fname, TARGET_OPT_HTM);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s vx%d\\n\", fname, TARGET_OPT_VX);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s ps%d\\n\", fname,\n+      asm_fprintf (out_file, \"\\t# fn:%s ba%d\\n\", fname, TARGET_BACKCHAIN);\n+      asm_fprintf (out_file, \"\\t# fn:%s hd%d\\n\", fname, TARGET_HARD_DFP);\n+      asm_fprintf (out_file, \"\\t# fn:%s hf%d\\n\", fname, !TARGET_SOFT_FLOAT);\n+      asm_fprintf (out_file, \"\\t# fn:%s ht%d\\n\", fname, TARGET_OPT_HTM);\n+      asm_fprintf (out_file, \"\\t# fn:%s vx%d\\n\", fname, TARGET_OPT_VX);\n+      asm_fprintf (out_file, \"\\t# fn:%s ps%d\\n\", fname,\n \t\t   TARGET_PACKED_STACK);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s se%d\\n\", fname, TARGET_SMALL_EXEC);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s mv%d\\n\", fname, TARGET_MVCLE);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s zv%d\\n\", fname, TARGET_ZVECTOR);\n-      asm_fprintf (asm_out_file, \"\\t# fn:%s wd%d\\n\", fname,\n+      asm_fprintf (out_file, \"\\t# fn:%s se%d\\n\", fname, TARGET_SMALL_EXEC);\n+      asm_fprintf (out_file, \"\\t# fn:%s mv%d\\n\", fname, TARGET_MVCLE);\n+      asm_fprintf (out_file, \"\\t# fn:%s zv%d\\n\", fname, TARGET_ZVECTOR);\n+      asm_fprintf (out_file, \"\\t# fn:%s wd%d\\n\", fname,\n \t\t   s390_warn_dynamicstack_p);\n     }\n-  ASM_OUTPUT_LABEL (asm_out_file, fname);\n+  ASM_OUTPUT_LABEL (out_file, fname);\n   if (hw_after > 0)\n-    asm_fprintf (asm_out_file,\n+    asm_fprintf (out_file,\n \t\t \"\\t# post-label NOPs for hotpatch (%d halfwords)\\n\",\n \t\t hw_after);\n }"}]}