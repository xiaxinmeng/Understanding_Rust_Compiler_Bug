{"sha": "56b67510587aa6aa75884ee45f4ddd9108bde7c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiNjc1MTA1ODdhYTZhYTc1ODg0ZWU0NWY0ZGRkOTEwOGJkZTdjMw==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2011-03-15T18:15:01Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2011-03-15T18:15:01Z"}, "message": "Fix pr47837\n\nFrom-SVN: r171008", "tree": {"sha": "ee7eab64f77b120e42f52216833d657c1ba45c6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee7eab64f77b120e42f52216833d657c1ba45c6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b67510587aa6aa75884ee45f4ddd9108bde7c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b67510587aa6aa75884ee45f4ddd9108bde7c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b67510587aa6aa75884ee45f4ddd9108bde7c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b67510587aa6aa75884ee45f4ddd9108bde7c3/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df06baf294c756b2d00c0e28186cf35988f5b8c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df06baf294c756b2d00c0e28186cf35988f5b8c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df06baf294c756b2d00c0e28186cf35988f5b8c0"}], "stats": {"total": 272, "additions": 272, "deletions": 0}, "files": [{"sha": "493629e2af9b07a39fb53ec3adde244d562dc904", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56b67510587aa6aa75884ee45f4ddd9108bde7c3", "patch": "@@ -1,3 +1,10 @@\n+2011-03-15  Xinliang David Li  <davidxl@google.com>\n+\n+\tPR c/47837\n+\t* tree-ssa-uninit.c (pred_chain_length_cmp): New function.\n+\t(normalize_preds): New function.\n+\t(is_use_properly_guarded): Normalize def predicates.\n+\n 2011-03-15  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n \tPR target/46778"}, {"sha": "3947797014be952b5b70325709c1a1a7d2dd4323", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56b67510587aa6aa75884ee45f4ddd9108bde7c3", "patch": "@@ -1,3 +1,9 @@\n+2011-03-15  Xinliang David Li  <davidxl@google.com>\n+\n+\tPR c/47837\n+\t* gcc.dg/uninit-pred-7_d.c: New test.\n+\t* gcc.dg/uninit-pred-8_d.c: New test.\n+\n 2011-03-15  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \n \tPR target/46788"}, {"sha": "06111731a630d92dca2eb2f507439b3690ff23ff", "filename": "gcc/testsuite/gcc.dg/uninit-pred-7_d.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_d.c?ref=56b67510587aa6aa75884ee45f4ddd9108bde7c3", "patch": "@@ -0,0 +1,54 @@\n+\n+/* { dg-do compile  { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-Wuninitialized -O2 -mbranch-cost=0\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( l )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if (m || l)\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  if ( l )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "ccdea2967addeaa338affdb72e7d1c7eb9804b98", "filename": "gcc/testsuite/gcc.dg/uninit-pred-8_d.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_d.c?ref=56b67510587aa6aa75884ee45f4ddd9108bde7c3", "patch": "@@ -0,0 +1,45 @@\n+\n+/* { dg-do compile  { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-Wuninitialized -O2 -mbranch-cost=0\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || m || r || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n ||  m || r || l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( l )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || m || r )\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n || m || r || l)\n+      blah(v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "02b166ab883902f3aa33627a4cf3ac4e25632179", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b67510587aa6aa75884ee45f4ddd9108bde7c3/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=56b67510587aa6aa75884ee45f4ddd9108bde7c3", "patch": "@@ -1605,6 +1605,157 @@ is_superset_of (VEC(use_pred_info_t, heap) **preds1,\n   return true;\n }\n \n+/* Comparison function used by qsort. It is used to\n+   sort predicate chains to allow predicate\n+   simplification.  */\n+\n+static int\n+pred_chain_length_cmp (const void *p1, const void *p2)\n+{\n+  use_pred_info_t i1, i2;\n+  VEC(use_pred_info_t, heap) * const *chain1\n+      = (VEC(use_pred_info_t, heap) * const *)p1;\n+  VEC(use_pred_info_t, heap) * const *chain2\n+      = (VEC(use_pred_info_t, heap) * const *)p2;\n+\n+  if (VEC_length (use_pred_info_t, *chain1)\n+      != VEC_length (use_pred_info_t, *chain2))\n+    return (VEC_length (use_pred_info_t, *chain1)\n+            - VEC_length (use_pred_info_t, *chain2));\n+\n+  i1 = VEC_index (use_pred_info_t, *chain1, 0);\n+  i2 = VEC_index (use_pred_info_t, *chain2, 0);\n+\n+  /* Allow predicates with similar prefix come together.  */\n+  if (!i1->invert && i2->invert)\n+    return -1;\n+  else if (i1->invert && !i2->invert)\n+    return 1;\n+\n+  return gimple_uid (i1->cond) - gimple_uid (i2->cond);\n+}\n+\n+/* x OR (!x AND y) is equivalent to x OR y.\n+   This function normalizes x1 OR (!x1 AND x2) OR (!x1 AND !x2 AND x3)\n+   into x1 OR x2 OR x3.  PREDS is the predicate chains, and N is\n+   the number of chains. Returns true if normalization happens.  */\n+\n+static bool\n+normalize_preds (VEC(use_pred_info_t, heap) **preds, size_t *n)\n+{\n+  size_t i, j, ll;\n+  VEC(use_pred_info_t, heap) *pred_chain;\n+  VEC(use_pred_info_t, heap) *x = 0;\n+  use_pred_info_t xj = 0, nxj = 0;\n+\n+  if (*n < 2)\n+    return false;\n+\n+  /* First sort the chains in ascending order of lengths.  */\n+  qsort (preds, *n, sizeof (void *), pred_chain_length_cmp);\n+  pred_chain = preds[0];\n+  ll = VEC_length (use_pred_info_t, pred_chain);\n+  if (ll != 1)\n+   {\n+     if (ll == 2)\n+       {\n+         use_pred_info_t xx, yy, xx2, nyy;\n+         VEC(use_pred_info_t, heap) *pred_chain2 = preds[1];\n+         if (VEC_length (use_pred_info_t, pred_chain2) != 2)\n+           return false;\n+\n+         /* See if simplification x AND y OR x AND !y is possible.  */\n+         xx = VEC_index (use_pred_info_t, pred_chain, 0);\n+         yy = VEC_index (use_pred_info_t, pred_chain, 1);\n+         xx2 = VEC_index (use_pred_info_t, pred_chain2, 0);\n+         nyy = VEC_index (use_pred_info_t, pred_chain2, 1);\n+         if (gimple_cond_lhs (xx->cond) != gimple_cond_lhs (xx2->cond)\n+             || gimple_cond_rhs (xx->cond) != gimple_cond_rhs (xx2->cond)\n+             || gimple_cond_code (xx->cond) != gimple_cond_code (xx2->cond)\n+             || (xx->invert != xx2->invert))\n+           return false;\n+         if (gimple_cond_lhs (yy->cond) != gimple_cond_lhs (nyy->cond)\n+             || gimple_cond_rhs (yy->cond) != gimple_cond_rhs (nyy->cond)\n+             || gimple_cond_code (yy->cond) != gimple_cond_code (nyy->cond)\n+             || (yy->invert == nyy->invert))\n+           return false;\n+\n+         /* Now merge the first two chains.  */\n+         free (yy);\n+         free (nyy);\n+         free (xx2);\n+         VEC_free (use_pred_info_t, heap, pred_chain);\n+         VEC_free (use_pred_info_t, heap, pred_chain2);\n+         pred_chain = 0;\n+         VEC_safe_push (use_pred_info_t, heap, pred_chain, xx);\n+         preds[0] = pred_chain;\n+         for (i = 1; i < *n - 1; i++)\n+           preds[i] = preds[i + 1];\n+\n+         preds[*n - 1] = 0;\n+         *n = *n - 1;\n+       }\n+     else\n+       return false;\n+   }\n+\n+  VEC_safe_push (use_pred_info_t, heap, x,\n+                 VEC_index (use_pred_info_t, pred_chain, 0));\n+\n+  /* The loop extracts x1, x2, x3, etc from chains\n+     x1 OR (!x1 AND x2) OR (!x1 AND !x2 AND x3) OR ...  */\n+  for (i = 1; i < *n; i++)\n+    {\n+      pred_chain = preds[i];\n+      if (VEC_length (use_pred_info_t, pred_chain) != i + 1)\n+        return false;\n+\n+      for (j = 0; j < i; j++)\n+        {\n+          xj = VEC_index (use_pred_info_t, x, j);\n+          nxj = VEC_index (use_pred_info_t, pred_chain, j);\n+\n+          /* Check if nxj is !xj  */\n+          if (gimple_cond_lhs (xj->cond) != gimple_cond_lhs (nxj->cond)\n+              || gimple_cond_rhs (xj->cond) != gimple_cond_rhs (nxj->cond)\n+              || gimple_cond_code (xj->cond) != gimple_cond_code (nxj->cond)\n+              || (xj->invert == nxj->invert))\n+            return false;\n+        }\n+\n+      VEC_safe_push (use_pred_info_t, heap, x,\n+                     VEC_index (use_pred_info_t, pred_chain, i));\n+    }\n+\n+  /* Now normalize the pred chains using the extraced x1, x2, x3 etc.  */\n+  for (j = 0; j < *n; j++)\n+    {\n+      use_pred_info_t t;\n+      xj = VEC_index (use_pred_info_t, x, j);\n+\n+      t = XNEW (struct use_pred_info);\n+      *t = *xj;\n+\n+      VEC_replace (use_pred_info_t, x, j, t);\n+    }\n+\n+  for (i = 0; i < *n; i++)\n+    {\n+      pred_chain = preds[i];\n+      for (j = 0; j < VEC_length (use_pred_info_t, pred_chain); j++)\n+        free (VEC_index (use_pred_info_t, pred_chain, j));\n+      VEC_free (use_pred_info_t, heap, pred_chain);\n+      pred_chain = 0;\n+      /* A new chain.  */\n+      VEC_safe_push (use_pred_info_t, heap, pred_chain,\n+                     VEC_index (use_pred_info_t, x, i));\n+      preds[i] = pred_chain;\n+    }\n+  return true;\n+}\n+\n+\n+\n /* Computes the predicates that guard the use and checks\n    if the incoming paths that have empty (or possibly\n    empty) defintion can be pruned/filtered. The function returns\n@@ -1658,9 +1809,18 @@ is_use_properly_guarded (gimple use_stmt,\n \n   if (has_valid_preds)\n     {\n+      bool normed;\n       if (dump_file)\n         dump_predicates (phi, num_def_preds, def_preds,\n                          \"Operand defs of phi \");\n+\n+      normed = normalize_preds (def_preds, &num_def_preds);\n+      if (normed && dump_file)\n+        {\n+          fprintf (dump_file, \"\\nNormalized to\\n\");\n+          dump_predicates (phi, num_def_preds, def_preds,\n+                           \"Operand defs of phi \");\n+        }\n       is_properly_guarded =\n           is_superset_of (def_preds, num_def_preds,\n                           preds, num_preds);"}]}