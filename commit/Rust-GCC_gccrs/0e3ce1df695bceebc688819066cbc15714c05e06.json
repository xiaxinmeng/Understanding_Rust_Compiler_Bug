{"sha": "0e3ce1df695bceebc688819066cbc15714c05e06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzY2UxZGY2OTViY2VlYmM2ODg4MTkwNjZjYmMxNTcxNGMwNWUwNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-14T16:58:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-14T16:58:37Z"}, "message": "Initial revision\n\nFrom-SVN: r7772", "tree": {"sha": "a8cad406d3f873da8c79b252ded9d221b79349f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8cad406d3f873da8c79b252ded9d221b79349f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3ce1df695bceebc688819066cbc15714c05e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3ce1df695bceebc688819066cbc15714c05e06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3ce1df695bceebc688819066cbc15714c05e06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3ce1df695bceebc688819066cbc15714c05e06/comments", "author": null, "committer": null, "parents": [{"sha": "62874575d9628c6e7b3bf072ca754c74b64fd3a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62874575d9628c6e7b3bf072ca754c74b64fd3a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62874575d9628c6e7b3bf072ca754c74b64fd3a0"}], "stats": {"total": 912, "additions": 912, "deletions": 0}, "files": [{"sha": "0dc5f302c8c5e95e36637fb326613714221c8cc9", "filename": "gcc/config/convex/fixinc.convex", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3ce1df695bceebc688819066cbc15714c05e06/gcc%2Fconfig%2Fconvex%2Ffixinc.convex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3ce1df695bceebc688819066cbc15714c05e06/gcc%2Fconfig%2Fconvex%2Ffixinc.convex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Ffixinc.convex?ref=0e3ce1df695bceebc688819066cbc15714c05e06", "patch": "@@ -0,0 +1,416 @@\n+\n+# This is a shell archive.  Remove anything before this line,\n+# then unpack it by saving it in a file and typing \"sh file\".\n+#\n+# Wrapped by  on Fri Mar 12 08:41:28 CST 1993\n+# Contents:  include/ include/limits.h include/math.h include/stddef.h\n+#\tinclude/stdlib.h\n+ \n+echo mkdir - include\n+mkdir include\n+chmod u=rwx,g=rwx,o=rx include\n+ \n+echo x - include/limits.h\n+sed 's/^@//' > \"include/limits.h\" <<'@//E*O*F include/limits.h//'\n+#ifndef _LIMITS_H\n+#define _LIMITS_H\n+\n+#include_next <limits.h>\n+\n+/* Minimum and maximum values a `char' can hold.  */\n+#ifdef __CHAR_UNSIGNED__\n+#undef CHAR_MIN\n+#define CHAR_MIN 0\n+#undef CHAR_MAX\n+#define CHAR_MAX 255\n+#endif\n+\n+#endif /* _LIMITS_H */\n+@//E*O*F include/limits.h//\n+chmod u=rw,g=rw,o=r include/limits.h\n+ \n+echo x - include/math.h\n+sed 's/^@//' > \"include/math.h\" <<'@//E*O*F include/math.h//'\n+#ifndef _MATH_H\n+#define _MATH_H\n+\n+#include_next <math.h>\n+\n+#undef HUGE_VAL\n+\n+#if _IEEE_FLOAT_\n+#define HUGE_VAL 1.79769313486231570e+308\n+#else\n+#define HUGE_VAL 8.98846567431157854e+307\n+#endif\n+\n+#if __OPTIMIZE__ && ! __NO_INLINE\n+\n+#define frexp(x,y)\t__inline_frexp ((x), (y))\n+#define ldexp(x,y)\t__inline_ldexp ((x), (y))\n+#define irint(x)\t__inline_irint (x)\n+#define frexpf(x,y)\t__inline_frexpf ((x), (y))\n+#define ldexpf(x,y)\t__inline_ldexpf ((x), (y))\n+#define irintf(x)\t__inline_irintf (x)\n+\n+#if __convex_c2__ || __convex_c32__ || __convex_c34__ || __convex_c38__\n+\n+#define atan(x)\t\t__inline_atan (x)\n+#define ceil(x)\t\t__inline_ceil (x)\n+#define cos(x)\t\t__inline_cos (x)\n+#define exp(x)\t\t__inline_exp (x)\n+#define floor(x)\t__inline_floor (x)\n+#define log(x)\t\t__inline_log (x)\n+#define log10(x)\t__inline_log10 (x)\n+#define modf(x,y)\t__inline_modf ((x), (y))\n+#define rint(x)\t\t__inline_rint (x)\n+#define sin(x)\t\t__inline_sin (x)\n+#define sqrt(x)\t\t__inline_sqrt (x)\n+\n+#define atanf(x)\t__inline_atanf (x)\n+#define ceilf(x)\t__inline_ceilf (x)\n+#define cosf(x)\t\t__inline_cosf (x)\n+#define expf(x)\t\t__inline_expf (x)\n+#define floorf(x)\t__inline_floorf (x)\n+#define logf(x)\t\t__inline_logf (x)\n+#define log10f(x)\t__inline_log10f (x)\n+#define modff(x,y)\t__inline_modff ((x), (y))\n+#define rintf(x)\t__inline_rintf (x)\n+#define sinf(x)\t\t__inline_sinf (x)\n+#define sqrtf(x)\t__inline_sqrtf (x)\n+\n+#endif /* __convex_c[23*]__ */\n+\n+#endif /* __OPTIMIZE__ */\n+\n+static __inline__ __const__ double __inline_atan (double x)\n+{\n+  double z;\n+  __asm__ (\"atan.d %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_atanf (float x)\n+{\n+  float z;\n+  __asm__ (\"atan.s %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_cos (double x)\n+{\n+  double z;\n+  __asm__ (\"cos.d %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_cosf (float x)\n+{\n+  float z;\n+  __asm__ (\"cos.s %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_exp (double x)\n+{\n+  double z;\n+  __asm__ (\"exp.d %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_expf (float x)\n+{\n+  float z;\n+  __asm__ (\"exp.s %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_log (double x)\n+{\n+  double z;\n+  __asm__ (\"ln.d %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_logf (float x)\n+{\n+  float z;\n+  __asm__ (\"ln.s %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_sin (double x)\n+{\n+  double z;\n+  __asm__ (\"sin.d %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_sinf (float x)\n+{\n+  float z;\n+  __asm__ (\"sin.s %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_sqrt (double x)\n+{\n+  double z;\n+  __asm__ (\"sqrt.d %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_sqrtf (float x)\n+{\n+  float z;\n+  __asm__ (\"sqrt.s %0\" : \"=d\" (z) : \"0\" (x));\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_ceil (double x)\n+{\n+  double z;\n+  __asm__ (\"frint.d %1,%0\" : \"=d\" (z) : \"d\" (x));\n+  if (z < x) z += 1.0;\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_ceilf (float x)\n+{\n+  float z;\n+  __asm__ (\"frint.s %1,%0\" : \"=d\" (z) : \"d\" (x));\n+  if (z < x) z += 1.0F;\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_floor (double x)\n+{\n+  double z;\n+  __asm__ (\"frint.d %1,%0\" : \"=d\" (z) : \"d\" (x));\n+  if (z > x) z -= 1.0;\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_floorf (float x)\n+{\n+  float z;\n+  __asm__ (\"frint.s %1,%0\" : \"=d\" (z) : \"d\" (x));\n+  if (z > x) z -= 1.0F;\n+  return z;\n+}\n+\n+static __inline__ __const__ double __inline_log10 (double x)\n+{\n+  return 0.43429448190325182765 * __inline_log (x);\n+}\n+\n+static __inline__ __const__ float __inline_log10f (float x)\n+{\n+  return 0.43429448190325182765F * __inline_logf (x);\n+}\n+\n+static __inline__ double __inline_modf (double x, double *np)\n+{\n+  double intpart;\n+  __asm__ (\"frint.d %1,%0\" : \"=d\" (intpart) : \"d\" (x));\n+  *np = intpart;\n+  return x - intpart;\n+}\n+\n+static __inline__ float __inline_modff (float x, float *np)\n+{\n+  float intpart;\n+  __asm__ (\"frint.s %1,%0\" : \"=d\" (intpart) : \"d\" (x));\n+  *np = intpart;\n+  return x - intpart;\n+}\n+\n+static __inline__ double __inline_frexp (double x, int *np)\n+{\n+  union u { double d; unsigned long long ll; } u;\n+  if ((u.d = x) == 0)\n+    *np = 0;\n+  else\n+    {\n+#if _IEEE_FLOAT_\n+      *np = ((u.ll >> 52) & 03777) - 01776;\n+      u.ll = (u.ll & 0x800fffffffffffffLL) | 0x3fe0000000000000LL;\n+#else\n+      *np = ((u.ll >> 52) & 03777) - 02000;\n+      u.ll = (u.ll & 0x800fffffffffffffLL) | 0x4000000000000000LL;\n+#endif\n+    }\n+  return u.d;\n+}\n+\n+static __inline__ float __inline_frexpf (float x, int *np)\n+{\n+  union u { float f; unsigned int i; } u;\n+  if ((u.f = x) == 0)\n+    *np = 0;\n+  else\n+    {\n+#if _IEEE_FLOAT_\n+      *np = ((u.i >> 23) & 0377) - 0176;\n+      u.i = (u.i & 0x807fffff) | 0x3f000000;\n+#else\n+      *np = ((u.i >> 23) & 0377) - 0200;\n+      u.i = (u.i & 0x807fffff) | 0x40000000;\n+#endif\n+    }\n+  return u.f;\n+}\n+\n+static __inline__ double __inline_ldexp (double x, int n)\n+{\n+  extern int errno;\n+  union { double d; long long ll; unsigned sexp : 12; } u;\n+  if ((u.d = x) != 0)\n+    {\n+      int exp = n + (u.sexp & 03777);\n+      long long nn = (long long) n << 52;\n+#if _IEEE_FLOAT_\n+      if (exp <= 0)\n+\tu.ll &= 0x8000000000000000LL, errno = 34;\n+      else if (exp > 03776)\n+\tu.ll = u.ll & 0x8000000000000000LL | 0x7fefffffffffffffLL, errno = 34;\n+#else\n+      if (exp <= 0)\n+\tu.ll = 0, errno = 34;\n+      else if (exp > 03777)\n+\tu.ll |= 0x7fffffffffffffffLL, errno = 34;\n+#endif\n+      else\n+\tu.ll += nn;\n+    }\n+  return u.d;\n+}\n+\n+static __inline__ float __inline_ldexpf (float x, int n)\n+{\n+  extern int errno;\n+  union { float f; int i; unsigned sexp : 9; } u;\n+  if ((u.f = x) != 0)\n+    {\n+      int exp = n + (u.sexp & 0377);\n+      int nn = n << 23;\n+#if _IEEE_FLOAT_\n+      if (exp <= 0)\n+\tu.i &= 0x80000000, errno = 34;\n+      else if (exp > 0376)\n+\tu.i = u.i & 0x80000000 | 0x7f7fffff, errno = 34;\n+#else\n+      if (exp <= 0)\n+\tu.i = 0, errno = 34;\n+      else if (exp > 0377)\n+\tu.i |= 0x7fffffff, errno = 34;\n+#endif\n+      else\n+\tu.i += nn;\n+    }\n+  return u.f;\n+}\n+\n+static __inline__ __const__ double __inline_rint (double x)\n+{\n+  double z;\n+  union { double d; unsigned long long ll; } u;\n+  u.d = x;\n+#if _IEEE_FLOAT_\n+  u.ll = (u.ll & 0x8000000000000000LL) | 0x3fe0000000000000LL;\n+#else\n+  u.ll = (u.ll & 0x8000000000000000LL) | 0x4000000000000000LL;\n+#endif\n+  __asm__ (\"frint.d %1,%0\" : \"=d\" (z) : \"d\" (x + u.d));\n+  return z;\n+}\n+\n+static __inline__ __const__ float __inline_rintf (float x)\n+{\n+  float z;\n+  union { float f; unsigned int i; } u;\n+  u.f = x;\n+#if _IEEE_FLOAT_\n+  u.i = (u.i & 0x80000000) | 0x3f000000;\n+#else\n+  u.i = (u.i & 0x80000000) | 0x40000000;\n+#endif\n+  __asm__ (\"frint.s %1,%0\" : \"=d\" (z) : \"d\" (x + u.f));\n+  return z;\n+}\n+\n+static __inline__ __const__ int __inline_irint (double x)\n+{\n+  union { double d; unsigned long long ll; } u;\n+  u.d = x;\n+#if _IEEE_FLOAT_\n+  u.ll = (u.ll & 0x8000000000000000LL) | 0x3fe0000000000000LL;\n+#else\n+  u.ll = (u.ll & 0x8000000000000000LL) | 0x4000000000000000LL;\n+#endif\n+  return x + u.d;\n+}\n+\n+static __inline__ __const__ int __inline_irintf (float x)\n+{\n+  union { float f; unsigned int i; } u;\n+  u.f = x;\n+#if _IEEE_FLOAT_\n+  u.i = (u.i & 0x80000000) | 0x3f000000;\n+#else\n+  u.i = (u.i & 0x80000000) | 0x40000000;\n+#endif\n+  return x + u.f;\n+}\n+\n+#endif /* _MATH_H */\n+@//E*O*F include/math.h//\n+chmod u=rw,g=rw,o=r include/math.h\n+ \n+echo x - include/stddef.h\n+sed 's/^@//' > \"include/stddef.h\" <<'@//E*O*F include/stddef.h//'\n+#ifndef _STDDEF_H\n+#define _STDDEF_H\n+\n+#ifndef __WCHAR_T\n+#define __WCHAR_T\n+\n+#ifdef __GNUG__\n+/* In C++, wchar_t is a distinct basic type,\n+   and we can expect __wchar_t to be defined by cc1plus.  */\n+typedef __wchar_t wchar_t;\n+#else\n+/* In C, cpp tells us which type to make an alias for.  */\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+#endif /* __WCHAR_T */\n+\n+#include_next <stddef.h>\n+\n+#endif /* _STDDEF_H */\n+@//E*O*F include/stddef.h//\n+chmod u=rw,g=rw,o=r include/stddef.h\n+ \n+echo x - include/stdlib.h\n+sed 's/^@//' > \"include/stdlib.h\" <<'@//E*O*F include/stdlib.h//'\n+#ifndef\t_STDLIB_H\n+#define _STDLIB_H\n+\n+#if _CONVEX_SOURCE\n+\n+#define alloca __non_builtin_alloca\n+#include_next <stdlib.h>\n+#undef alloca\n+\n+#else\n+\n+#include_next <stdlib.h>\n+\n+#endif  /* _CONVEX_SOURCE */\n+\n+#endif\t/* _STDLIB_H */\n+@//E*O*F include/stdlib.h//\n+chmod u=rw,g=rw,o=r include/stdlib.h\n+ \n+exit 0"}, {"sha": "98a8d25e10807762314be983d4d9ac3824e6d9f6", "filename": "gcc/config/i386/freebsd.h", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3ce1df695bceebc688819066cbc15714c05e06/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3ce1df695bceebc688819066cbc15714c05e06/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd.h?ref=0e3ce1df695bceebc688819066cbc15714c05e06", "patch": "@@ -0,0 +1,320 @@\n+/* Definitions of target machine for GNU compiler for Intel 80386\n+   running FreeBSD.\n+   Copyright (C) 1988, 1992, 1994 Free Software Foundation, Inc.\n+   Contributed by Poul-Henning Kamp <phk@login.dkuug.dk>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This goes away when the math-emulator is fixed */\n+#define TARGET_CPU_DEFAULT 0400\t\t/* TARGET_NO_FANCY_MATH_387 */\n+\n+/* This is tested by i386gas.h.  */\n+#define YES_UNDERSCORES\n+\n+#include \"i386/gstabs.h\"\n+\n+/* Get perform_* macros to build libgcc.a.  */\n+#include \"i386/perform.h\"\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dunix -Di386 -D__FreeBSD__ -D__386BSD__ -Asystem(unix) -Asystem(FreeBSD) -Acpu(i386) -Amachine(i386)\"\n+\n+#define INCLUDE_DEFAULTS { \\\n+\t{ \"/usr/include\", 0 }, \\\n+\t{ \"/usr/include/g++\", 1 }, \\\n+\t{ 0, 0} \\\n+\t}\n+\n+/* Like the default, except no -lg.  */\n+#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\"\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+\n+#define WCHAR_UNSIGNED 1\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 16\n+\n+#define HAVE_ATEXIT\n+\n+/* Redefine this to use %eax instead of %edx.  */\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%eax\\n\",\t\t\\\n+\t       LPREFIX, (LABELNO));\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tcall *mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovl $%sP%d,%%eax\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf (FILE, \"\\tcall mcount\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* There are conflicting reports about whether this system uses\n+   a different assembler syntax.  wilson@cygnus.com says # is right.  */\n+#undef COMMENT_BEGIN\n+#define COMMENT_BEGIN \"#\"\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\f\n+/* The following macros are stolen from i386v4.h */\n+/* These have to be defined to get PIC code correct */\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   This is only used for PIC code.  See comments by the `casesi' insn in\n+   i386.md for an explanation of the expression this outputs. */\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n+   we want to retain compatibility with older gcc versions.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/*\n+ * Some imports from svr4.h in support of shared libraries.\n+ * Currently, we need the DECLARE_OBJECT_SIZE stuff.\n+ */\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+#define WEAK_ASM_OP\t\".weak\"\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare a function properly.\n+   Some svr4 assemblers need to also have something extra said about the\n+   function's return value.  We allow for that here.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        size_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)        \\\n+do {                                                                    \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);                  \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t        \\\n+         && ! AT_END && TOP_LEVEL                                       \\\n+         && DECL_INITIAL (DECL) == error_mark_node                      \\\n+         && !size_directive_output)                                     \\\n+       {                                                                \\\n+         fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);                        \\\n+\t assemble_name (FILE, name);                                    \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\\\n+\t}\t\t\t\t\t\t\t\t\\\n+   } while (0)\n+\n+\n+/* This is how to declare the size of a function.  */\n+\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define ASM_SPEC   \" %| %{fpic:-k} %{fPIC:-k}\"\n+#define LINK_SPEC \\\n+  \"%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp %{static:-Bstatic} %{assert*}\"\n+\n+/* This section copied from i386/osfrose.h */\n+\n+/* A C statement or compound statement to output to FILE some\n+   assembler code to initialize basic-block profiling for the current\n+   object module.  This code should call the subroutine\n+   `__bb_init_func' once per object module, passing it as its sole\n+   argument the address of a block allocated in the object module.\n+\n+   The name of the block is a local symbol made with this statement:\n+\n+\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+   Of course, since you are writing the definition of\n+   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+   can take a short cut in the definition of this macro and use the\n+   name that you know will result.\n+\n+   The first word of this block is a flag which will be nonzero if the\n+   object module has already been initialized.  So test this word\n+   first, and do not call `__bb_init_func' if the flag is nonzero.  */\n+\n+#undef\tFUNCTION_BLOCK_PROFILER\n+#define FUNCTION_BLOCK_PROFILER(STREAM, LABELNO)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tcmpl $0,%sPBX0\\n\", LPREFIX);\t\t\\\n+\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl $%sPBX0\\n\", LPREFIX);\t\t\t\\\n+\tfprintf (STREAM, \"\\tcall ___bb_init_func\\n\");\t\t\t\\\n+\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tmovl %sPBX0@GOT(%ebx),%eax\\n\");\t\t\\\n+\tfprintf (STREAM, \"\\tcmpl $0,(%eax)\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tcall ___bb_init_func@PLT\\n\");\t\t\\\n+\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* A C statement or compound statement to increment the count\n+   associated with the basic block number BLOCKNO.  Basic blocks are\n+   numbered separately from zero within each compilation.  The count\n+   associated with block number BLOCKNO is at index BLOCKNO in a\n+   vector of words; the name of this array is a local symbol made\n+   with this statement:\n+\n+\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+   Of course, since you are writing the definition of\n+   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+   can take a short cut in the definition of this macro and use the\n+   name that you know will result.  */\n+\n+#undef\tBLOCK_PROFILER\n+#define BLOCK_PROFILER(STREAM, BLOCKNO)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_pic)\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\tincl %sPBX2+%d\\n\", LPREFIX, (BLOCKNO)*4);\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tmovl %sPBX2@GOT(%ebx),%eax\\n\", LPREFIX);\t\\\n+\tfprintf (STREAM, \"\\tincl %d(%eax)\\n\", (BLOCKNO)*4);\t\t\\\n+\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* This is defined when gcc is compiled in the BSD-directory-tree, and must\n+ * make up for the gap to all the stuff done in the GNU-makefiles.\n+ */\n+\n+#ifdef FREEBSD_NATIVE\n+\n+#undef MD_EXEC_PREFIX\n+#define MD_EXEC_PREFIX \"/usr/libexec/\"\n+\n+#undef STANDARD_STARTFILE_PREFIX\n+#define STANDARD_STARTFILE_PREFIX \"/usr/lib\"\n+\n+#define DEFAULT_TARGET_MACHINE \"i386-unknown-freebsd_1.0\"\n+#define GPLUSPLUS_INCLUDE_DIR \"/usr/local/lib/gcc-lib/i386-unknown-freebsd_1.0/2.5.8/include\"\n+#define TOOL_INCLUDE_DIR \"/usr/local/i386-unknown-freebsd_1.0/include\"\n+#define GCC_INCLUDE_DIR \"/usr/local/lib/gcc-lib/i386-unknown-freebsd_1.0/2.5.8/include\"\n+\n+#endif /* FREEBSD_NATIVE */"}, {"sha": "caa13fe88ed51d33925c824dbb00121cd675039c", "filename": "gcc/config/netbsd.h", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3ce1df695bceebc688819066cbc15714c05e06/gcc%2Fconfig%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3ce1df695bceebc688819066cbc15714c05e06/gcc%2Fconfig%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnetbsd.h?ref=0e3ce1df695bceebc688819066cbc15714c05e06", "patch": "@@ -0,0 +1,176 @@\n+/* Look for the include files in the system-defined places.  */\n+\n+#undef GPLUSPLUS_INCLUDE_DIR\n+#define GPLUSPLUS_INCLUDE_DIR \"/usr/include/g++\"\n+\n+#undef GCC_INCLUDE_DIR\n+#define GCC_INCLUDE_DIR \"/usr/include\"\n+\n+#undef INCLUDE_DEFAULTS\n+#define INCLUDE_DEFAULTS\t\t\\\n+  {\t\t\t\t\t\\\n+    { GPLUSPLUS_INCLUDE_DIR, 1, 1 },\t\\\n+    { GCC_INCLUDE_DIR, 0, 0 },\t\t\\\n+    { 0, 0, 0 }\t\t\t\t\\\n+  }\n+\n+\n+/* Under NetBSD, the normal location of the `ld' and `as' programs is the\n+   /usr/bin directory.  */\n+\n+#undef MD_EXEC_PREFIX\n+#define MD_EXEC_PREFIX \"/usr/bin/\"\n+\n+/* Under NetBSD, the normal location of the various *crt*.o files is the\n+   /usr/lib directory.  */\n+\n+#undef MD_STARTFILE_PREFIX\n+#define MD_STARTFILE_PREFIX \"/usr/lib/\"\n+\n+\n+/* Provide a CPP_SPEC appropriate for NetBSD.  Current we just deal with\n+   the GCC option `-posix'.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{posix:-D_POSIX_SOURCE}\"\n+\n+/* Provide an ASM_SPEC appropriate for NetBSD.  Currently we only deal\n+   with the options for generating PIC code.  */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \" %| %{fpic:-k} %{fPIC:-k -K}\"\n+\n+/* Provide a LIB_SPEC appropriate for NetBSD.  Just select the appropriate\n+   libc, depending on whether we're doing profiling.  */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\"\n+\n+/* Provide a LINK_SPEC appropriate for NetBSD.  Here we provide support\n+   for the special GCC options -static, -assert, and -nostdlib.  */\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+  \"%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp %{static:-Bstatic} %{assert*}\"\n+\n+\n+/* We have atexit(3).  */\n+\n+#define HAVE_ATEXIT\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\f\n+/*\n+ * Some imports from svr4.h in support of shared libraries.\n+ * Currently, we need the DECLARE_OBJECT_SIZE stuff.\n+ */\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+#define WEAK_ASM_OP\t\".weak\"\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare a function properly.\n+   Some svr4 assemblers need to also have something extra said about the\n+   function's return value.  We allow for that here.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n+/* This is how to declare the size of a function.  */\n+\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)"}]}