{"sha": "3cb251b77933671acc8717ede172be28d839927f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NiMjUxYjc3OTMzNjcxYWNjODcxN2VkZTE3MmJlMjhkODM5OTI3Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-12-07T07:35:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-12-07T07:35:11Z"}, "message": "symtab.c (symtab_node::equal_address_to): New function.\n\n\n\t* symtab.c (symtab_node::equal_address_to): New function.\n\t* cgraph.h (symtab_node::equal_address_to): Declare.\n\t* fold-const.c (fold_comparison, fold_binary_loc): Use it.\n\n\t* c-family/c-common.c: Refuse weaks for symbols that can not change\n\tvisibility.\n\n\t* gcc.dg/addr_equal-1.c: New testcase.\n\nFrom-SVN: r218462", "tree": {"sha": "94cb96a4a951949b96e031fdf5a464a3bdc185de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94cb96a4a951949b96e031fdf5a464a3bdc185de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cb251b77933671acc8717ede172be28d839927f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb251b77933671acc8717ede172be28d839927f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb251b77933671acc8717ede172be28d839927f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb251b77933671acc8717ede172be28d839927f/comments", "author": null, "committer": null, "parents": [{"sha": "8c8d3b4c128996f8188d76a0fe61e79b8304f0a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c8d3b4c128996f8188d76a0fe61e79b8304f0a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c8d3b4c128996f8188d76a0fe61e79b8304f0a8"}], "stats": {"total": 273, "additions": 235, "deletions": 38}, "files": [{"sha": "e233e6582aa895acbd63c98e0ee5f7d84ff5a2d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -1,3 +1,11 @@\n+2014-12-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* symtab.c (symtab_node::equal_address_to): New function.\n+\t* cgraph.h (symtab_node::equal_address_to): Declare.\n+\t* fold-const.c (fold_comparison, fold_binary_loc): Use it.\n+\t* c-family/c-common.c: Refuse weaks for symbols that can not change\n+\tvisibility.\n+\n 2014-12-07  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/invoke.texi (Warning Options): Fix spelling and grammar."}, {"sha": "1066c6b96a799f152427f9f352a3709063683bca", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -7781,7 +7781,12 @@ handle_weak_attribute (tree *node, tree name,\n     }\n   else if (TREE_CODE (*node) == FUNCTION_DECL\n \t   || TREE_CODE (*node) == VAR_DECL)\n-    declare_weak (*node);\n+    {\n+      struct symtab_node *n = symtab_node::get (*node);\n+      if (n && n->refuse_visibility_changes)\n+\terror (\"%+D declared weak after being used\", *node);\n+      declare_weak (*node);\n+    }\n   else\n     warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n "}, {"sha": "997414ce894aab146860fab2c1d4adeff3dcba9a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -332,6 +332,11 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return true if symbol is known to be nonzero.  */\n   bool nonzero_address ();\n \n+  /* Return 0 if symbol is known to have different address than S2,\n+     Return 1 if symbol is known to have same address as S2,\n+     return 2 otherwise.   */\n+  int equal_address_to (symtab_node *s2);\n+\n   /* Return symbol table node associated with DECL, if any,\n      and NULL otherwise.  */\n   static inline symtab_node *get (const_tree decl)"}, {"sha": "94d1cbfc2b238f53ddbb9035646c0e19d1dacaa1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -8985,24 +8985,21 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t    }\n \t}\n       /* For non-equal bases we can simplify if they are addresses\n-\t of local binding decls or constants.  */\n+\t declarations with different addresses.  */\n       else if (indirect_base0 && indirect_base1\n \t       /* We know that !operand_equal_p (base0, base1, 0)\n \t\t  because the if condition was false.  But make\n \t\t  sure two decls are not the same.  */\n \t       && base0 != base1\n \t       && TREE_CODE (arg0) == ADDR_EXPR\n \t       && TREE_CODE (arg1) == ADDR_EXPR\n-\t       && (((TREE_CODE (base0) == VAR_DECL\n-\t\t     || TREE_CODE (base0) == PARM_DECL)\n-\t\t    && (targetm.binds_local_p (base0)\n-\t\t\t|| CONSTANT_CLASS_P (base1)))\n-\t\t   || CONSTANT_CLASS_P (base0))\n-\t       && (((TREE_CODE (base1) == VAR_DECL\n-\t\t     || TREE_CODE (base1) == PARM_DECL)\n-\t\t    && (targetm.binds_local_p (base1)\n-\t\t\t|| CONSTANT_CLASS_P (base0)))\n-\t\t   || CONSTANT_CLASS_P (base1)))\n+\t       && DECL_P (base0)\n+\t       && DECL_P (base1)\n+\t       /* Watch for aliases.  */\n+\t       && (!decl_in_symtab_p (base0)\n+\t\t   || !decl_in_symtab_p (base1)\n+\t\t   || !symtab_node::get_create (base0)->equal_address_to\n+\t\t\t (symtab_node::get_create (base1))))\n \t{\n \t  if (code == EQ_EXPR)\n \t    return omit_two_operands_loc (loc, type, boolean_false_node,\n@@ -12257,33 +12254,23 @@ fold_binary_loc (location_t loc,\n \t unaliased symbols neither of which are extern (since we do not\n \t have access to attributes for externs), then we know the result.  */\n       if (TREE_CODE (arg0) == ADDR_EXPR\n-\t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg0, 0))\n-\t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n-\t  && ! lookup_attribute (\"alias\",\n-\t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg0, 0)))\n-\t  && ! DECL_EXTERNAL (TREE_OPERAND (arg0, 0))\n+\t  && DECL_P (TREE_OPERAND (arg0, 0))\n \t  && TREE_CODE (arg1) == ADDR_EXPR\n-\t  && VAR_OR_FUNCTION_DECL_P (TREE_OPERAND (arg1, 0))\n-\t  && ! DECL_WEAK (TREE_OPERAND (arg1, 0))\n-\t  && ! lookup_attribute (\"alias\",\n-\t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg1, 0)))\n-\t  && ! DECL_EXTERNAL (TREE_OPERAND (arg1, 0)))\n-\t{\n-\t  /* We know that we're looking at the address of two\n-\t     non-weak, unaliased, static _DECL nodes.\n-\n-\t     It is both wasteful and incorrect to call operand_equal_p\n-\t     to compare the two ADDR_EXPR nodes.  It is wasteful in that\n-\t     all we need to do is test pointer equality for the arguments\n-\t     to the two ADDR_EXPR nodes.  It is incorrect to use\n-\t     operand_equal_p as that function is NOT equivalent to a\n-\t     C equality test.  It can in fact return false for two\n-\t     objects which would test as equal using the C equality\n-\t     operator.  */\n-\t  bool equal = TREE_OPERAND (arg0, 0) == TREE_OPERAND (arg1, 0);\n-\t  return constant_boolean_node (equal\n-\t\t\t\t        ? code == EQ_EXPR : code != EQ_EXPR,\n-\t\t\t\t        type);\n+\t  && DECL_P (TREE_OPERAND (arg1, 0)))\n+\t{\n+\t  int equal;\n+\n+\t  if (decl_in_symtab_p (TREE_OPERAND (arg0, 0))\n+\t      && decl_in_symtab_p (TREE_OPERAND (arg1, 0)))\n+\t    equal = symtab_node::get_create (TREE_OPERAND (arg0, 0))\n+\t\t    ->equal_address_to (symtab_node::get_create\n+\t\t\t\t\t  (TREE_OPERAND (arg1, 0)));\n+\t  else\n+\t    equal = TREE_OPERAND (arg0, 0) == TREE_OPERAND (arg1, 0);\n+\t  if (equal != 2)\n+\t    return constant_boolean_node (equal\n+\t\t\t\t          ? code == EQ_EXPR : code != EQ_EXPR,\n+\t\t\t\t          type);\n \t}\n \n       /* Similarly for a NEGATE_EXPR.  */"}, {"sha": "3eceb88340f504a9aeefe3d9ad372e31a6c588a2", "filename": "gcc/symtab.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -1860,3 +1860,90 @@ symtab_node::nonzero_address ()\n     return true;\n   return false;\n }\n+\n+/* Return 0 if symbol is known to have different address than S2,\n+   Return 1 if symbol is known to have same address as S2,\n+   return 2 otherwise.   */\n+int\n+symtab_node::equal_address_to (symtab_node *s2)\n+{\n+  enum availability avail1, avail2;\n+\n+  /* A Shortcut: equivalent symbols are always equivalent.  */\n+  if (this == s2)\n+    return 1;\n+\n+  /* For non-interposable aliases, lookup and compare their actual definitions.\n+     Also check if the symbol needs to bind to given definition.  */\n+  symtab_node *rs1 = ultimate_alias_target (&avail1);\n+  symtab_node *rs2 = s2->ultimate_alias_target (&avail2);\n+  bool binds_local1 = rs1->analyzed && decl_binds_to_current_def_p (this->decl);\n+  bool binds_local2 = rs2->analyzed && decl_binds_to_current_def_p (s2->decl);\n+  bool really_binds_local1 = binds_local1;\n+  bool really_binds_local2 = binds_local2;\n+\n+  /* Addresses of vtables and virtual functions can not be used by user\n+     code and are used only within speculation.  In this case we may make\n+     symbol equivalent to its alias even if interposition may break this\n+     rule.  Doing so will allow us to turn speculative inlining into\n+     non-speculative more agressively.  */\n+  if (DECL_VIRTUAL_P (this->decl) && avail1 >= AVAIL_AVAILABLE)\n+    binds_local1 = true;\n+  if (DECL_VIRTUAL_P (s2->decl) && avail2 >= AVAIL_AVAILABLE)\n+    binds_local2 = true;\n+\n+  /* If both definitions are available we know that even if they are bound\n+     to other unit they must be defined same way and therefore we can use\n+     equivalence test.  */\n+  if (rs1 != rs2 && avail1 >= AVAIL_AVAILABLE && avail2 >= AVAIL_AVAILABLE)\n+    binds_local1 = binds_local2 = true;\n+\n+  if ((binds_local1 ? rs1 : this)\n+       == (binds_local2 ? rs2 : s2))\n+    {\n+      /* We made use of the fact that alias is not weak.  */\n+      if (binds_local1 && rs1 != this)\n+        refuse_visibility_changes = true;\n+      if (binds_local2 && rs2 != s2)\n+        s2->refuse_visibility_changes = true;\n+      return 1;\n+    }\n+\n+  /* If both symbols may resolve to NULL, we can not really prove them different.  */\n+  if (!nonzero_address () && !s2->nonzero_address ())\n+    return 2;\n+\n+  /* Except for NULL, functions and variables never overlap.  */\n+  if (TREE_CODE (decl) != TREE_CODE (s2->decl))\n+    return 0;\n+\n+  /* If one of the symbols is unresolved alias, punt.  */\n+  if (rs1->alias || rs2->alias)\n+    return 2;\n+\n+  /* If we have a non-interposale definition of at least one of the symbols\n+     and the other symbol is different, we know other unit can not interpose\n+     it to the first symbol; all aliases of the definition needs to be \n+     present in the current unit.  */\n+  if (((really_binds_local1 || really_binds_local2)\n+      /* If we have both definitions and they are different, we know they\n+\t will be different even in units they binds to.  */\n+       || (binds_local1 && binds_local2))\n+      && rs1 != rs2)\n+    {\n+      /* We make use of the fact that one symbol is not alias of the other\n+\t and that the definition is non-interposable.  */\n+      refuse_visibility_changes = true;\n+      s2->refuse_visibility_changes = true;\n+      rs1->refuse_visibility_changes = true;\n+      rs2->refuse_visibility_changes = true;\n+      return 0;\n+    }\n+\n+  /* TODO: Alias oracle basically assume that addresses of global variables\n+     are different unless they are declared as alias of one to another.\n+     We probably should be consistent and use this fact here, too, and update\n+     alias oracle to use this predicate.  */\n+\n+  return 2;\n+}"}, {"sha": "d96c4ec68a0d8e249727694442afa6b009ccf060", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -1,3 +1,7 @@\n+2014-12-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/addr_equal-1.c: New testcase.\n+\n 2014-12-06  James Greenhalgh  <james.greenhalgh@arm.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n \t    Brian Rzycki  <b.rzycki@samsung.com>"}, {"sha": "b033f50bfe756e2b92eb34718456cfe6d58f7abd", "filename": "gcc/testsuite/gcc.dg/addr_equal-1.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb251b77933671acc8717ede172be28d839927f/gcc%2Ftestsuite%2Fgcc.dg%2Faddr_equal-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb251b77933671acc8717ede172be28d839927f/gcc%2Ftestsuite%2Fgcc.dg%2Faddr_equal-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Faddr_equal-1.c?ref=3cb251b77933671acc8717ede172be28d839927f", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do run } */\n+/* { dg-require-weak \"\" } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O2\" } */\n+void abort (void);\n+extern int undef_var0, undef_var1;\n+extern __attribute__ ((weak)) int weak_undef_var0;\n+extern __attribute__ ((weak)) int weak_undef_var1;\n+__attribute__ ((weak)) int weak_def_var0;\n+int def_var0=0, def_var1=0;\n+static int alias_var0 __attribute__ ((alias(\"def_var0\")));\n+extern int weak_alias_var0 __attribute__ ((alias(\"def_var0\"))) __attribute__ ((weak));\n+void undef_fn0(void);\n+void undef_fn1(void);\n+void def_fn0(void)\n+{\n+}\n+void def_fn1(void)\n+{\n+}\n+__attribute__ ((weak))\n+void weak_def_fn0(void)\n+{\n+}\n+__attribute__ ((weak))\n+void weak_def_fn1(void)\n+{\n+}\n+__attribute__ ((weak)) void weak_undef_fn0(void);\n+\n+inline\n+void inline_fn0(void)\n+{\n+}\n+inline\n+void inline_fn1(void)\n+{\n+}\n+\n+int\n+main(int argc, char **argv)\n+{\n+  /* Two definitions are always different unless they can be interposed.  */\n+  if (!__builtin_constant_p (def_fn0 == def_fn1))\n+    abort();\n+  if (def_fn0 == def_fn1)\n+    abort();\n+\n+  if (!__builtin_constant_p (&def_var0 == &def_var1))\n+    abort();\n+  if (&def_var0 == &def_var1)\n+    abort();\n+\n+  /* Same symbol is the same no matter on interposition.  */\n+  if (!__builtin_constant_p (undef_fn0 != undef_fn0))\n+    abort ();\n+  if (undef_fn0 != undef_fn0)\n+    abort ();\n+\n+  /* Do not get confused by same offset.  */\n+  if (!__builtin_constant_p (&undef_var0 + argc != &undef_var0 + argc))\n+    abort ();\n+  if (&undef_var0 + argc != &undef_var0 + argc)\n+    abort ();\n+\n+  /* Alias and its target is equivalent unless one of them can be interposed.  */\n+  if (!__builtin_constant_p (&def_var0 != &alias_var0))\n+    abort ();\n+  if (&def_var0 != &alias_var0 )\n+    abort ();\n+\n+  if (__builtin_constant_p (&def_var0 != &weak_alias_var0))\n+    abort ();\n+  if (&def_var0 != &weak_alias_var0)\n+    abort ();\n+\n+  /* Weak definitions may be both NULL.  */\n+  if (__builtin_constant_p ((void *)weak_undef_fn0 == (void *)&weak_undef_var0))\n+    abort ();\n+  if ((void *)weak_undef_fn0 != (void *)&weak_undef_var0)\n+    abort ();\n+\n+  /* Variables and functions do not share same memory locations otherwise.  */\n+  if (!__builtin_constant_p ((void *)undef_fn0 == (void *)&undef_var0))\n+    abort ();\n+  if ((void *)undef_fn0 == (void *)&undef_var0)\n+    abort ();\n+\n+  /* This works for cases where one object is just weakly defined, too.  */\n+  if (!__builtin_constant_p ((void *)weak_undef_fn0 == (void *)&weak_def_var0))\n+    abort ();\n+  if ((void *)weak_undef_fn0 == (void *)&weak_def_var0)\n+    abort ();\n+\n+  /* Inline functions are known to be different.  */\n+  if (!__builtin_constant_p (inline_fn0 != inline_fn1))\n+    abort ();\n+  if (inline_fn0 == inline_fn1)\n+    abort ();\n+  return 0;\n+}"}]}