{"sha": "4fd78fe6b06038331d017caff80972836b51e3c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZkNzhmZTZiMDYwMzgzMzFkMDE3Y2FmZjgwOTcyODM2YjUxZTNjMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-23T11:32:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-23T11:32:58Z"}, "message": "* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Subtype>\n\tFor packed array types, make the original array type a parallel type\n\tfor the modular type and its JM wrapper if the type is bit-packed.\n\t<E_Array_Subtype>: Likewise.  Do not generate the special XA parallel\n\trecord type for packed array types.  Remove kludge.\n\nFrom-SVN: r146647", "tree": {"sha": "8ac3b485df51fd738868f148dfcb12cbd120b2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ac3b485df51fd738868f148dfcb12cbd120b2fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fd78fe6b06038331d017caff80972836b51e3c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd78fe6b06038331d017caff80972836b51e3c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd78fe6b06038331d017caff80972836b51e3c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd78fe6b06038331d017caff80972836b51e3c0/comments", "author": null, "committer": null, "parents": [{"sha": "111a28c29e1f0af6064dd1a3ba2f9eac09ad00eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111a28c29e1f0af6064dd1a3ba2f9eac09ad00eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111a28c29e1f0af6064dd1a3ba2f9eac09ad00eb"}], "stats": {"total": 68, "additions": 53, "deletions": 15}, "files": [{"sha": "90e7821e7dd83faed6163db6dcbce1a34d92f098", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd78fe6b06038331d017caff80972836b51e3c0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd78fe6b06038331d017caff80972836b51e3c0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4fd78fe6b06038331d017caff80972836b51e3c0", "patch": "@@ -1,3 +1,11 @@\n+2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Subtype>\n+\tFor packed array types, make the original array type a parallel type\n+\tfor the modular type and its JM wrapper if the type is bit-packed.\n+\t<E_Array_Subtype>: Likewise.  Do not generate the special XA parallel\n+\trecord type for packed array types.  Remove kludge.\n+\n 2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (create_index_type): Adjust head comment."}, {"sha": "746e1e8d3f8af91d7127a551d0736272ba7b2c9a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd78fe6b06038331d017caff80972836b51e3c0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd78fe6b06038331d017caff80972836b51e3c0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=4fd78fe6b06038331d017caff80972836b51e3c0", "patch": "@@ -1586,11 +1586,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       layout_type (gnu_type);\n \n+      /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n+      TYPE_STUB_DECL (gnu_type)\n+\t= create_type_stub_decl (gnu_entity_name, gnu_type);\n+\n       /* Inherit our alias set from what we're a subtype of.  Subtypes\n \t are not different types and a pointer can designate any instance\n \t within a subtype hierarchy.  */\n       relate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n \n+      /* For a packed array, make the original array type a parallel type.  */\n+      if (debug_info_p\n+\t  && Is_Packed_Array_Type (gnat_entity)\n+\t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n+\tadd_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\t\t   gnat_to_gnu_type\n+\t\t\t   (Original_Array_Type (gnat_entity)));\n+\n       /* If the type we are dealing with represents a bit-packed array,\n \t we need to have the bits left justified on big-endian targets\n \t and right justified on little-endian targets.  We also need to\n@@ -1630,10 +1642,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n \t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n \n-\t  finish_record_type (gnu_type, gnu_field, 0, false);\n+\t  /* Do not finalize it until after the parallel type is added.  */\n+\t  finish_record_type (gnu_type, gnu_field, 0, true);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n+\n+\t  /* Make the original array type a parallel type.  */\n+\t  if (debug_info_p\n+\t      && present_gnu_tree (Original_Array_Type (gnat_entity)))\n+\t    add_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\t\t       gnat_to_gnu_type\n+\t\t\t       (Original_Array_Type (gnat_entity)));\n+\n+\t  rest_of_record_type_compilation (gnu_type);\n \t}\n \n       /* If the type we are dealing with has got a smaller alignment than the\n@@ -2357,9 +2379,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n-\t  if (need_index_type_struct)\n-\t    TYPE_STUB_DECL (gnu_type)\n-\t      = create_type_stub_decl (gnu_entity_name, gnu_type);\n+\t  TYPE_STUB_DECL (gnu_type)\n+\t    = create_type_stub_decl (gnu_entity_name, gnu_type);\n \n \t  /* If we are at file level and this is a multi-dimensional array, we\n \t     need to make a variable corresponding to the stride of the\n@@ -2402,11 +2423,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t    }\n \n-\t  /* If we need to write out a record type giving the names of\n-\t     the bounds, do it now.  Make sure to reference the index\n-\t     types themselves, not just their names, as the debugger\n-\t     may fall back on them in some cases.  */\n-\t  if (need_index_type_struct && debug_info_p)\n+\t  /* If we need to write out a record type giving the names of the\n+\t     bounds for debugging purposes, do it now and make the record\n+\t     type a parallel type.  This is not needed for a packed array\n+\t     since the bounds are conveyed by the original array type.  */\n+\t  if (need_index_type_struct\n+\t      && debug_info_p\n+\t      && !Is_Packed_Array_Type (gnat_entity))\n \t    {\n \t      tree gnu_bound_rec = make_node (RECORD_TYPE);\n \t      tree gnu_field_list = NULL_TREE;\n@@ -2423,6 +2446,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  if (TREE_CODE (gnu_index_name) == TYPE_DECL)\n \t\t    gnu_index_name = DECL_NAME (gnu_index_name);\n \n+\t\t  /* Make sure to reference the types themselves, and not just\n+\t\t     their names, as the debugger may fall back on them.  */\n \t\t  gnu_field = create_field_decl (gnu_index_name, gnu_index,\n \t\t\t\t\t\t gnu_bound_rec,\n \t\t\t\t\t\t 0, NULL_TREE, NULL_TREE, 0);\n@@ -2434,6 +2459,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      add_parallel_type (TYPE_STUB_DECL (gnu_type), gnu_bound_rec);\n \t    }\n \n+\t  /* Otherwise, for a packed array, make the original array type a\n+\t     parallel type.  */\n+\t  else if (debug_info_p\n+\t\t   && Is_Packed_Array_Type (gnat_entity)\n+\t\t   && present_gnu_tree (Original_Array_Type (gnat_entity)))\n+\t    add_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\t\t       gnat_to_gnu_type\n+\t\t\t       (Original_Array_Type (gnat_entity)));\n+\n \t  TYPE_CONVENTION_FORTRAN_P (gnu_type)\n \t    = (Convention (gnat_entity) == Convention_Fortran);\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type)\n@@ -2476,13 +2510,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t     | (TYPE_QUAL_VOLATILE\n \t\t\t\t\t* Treat_As_Volatile (gnat_entity))));\n \n-\t  /* Make it artificial only if the base type was artificial as well.\n-\t     That's sort of \"morally\" true and will make it possible for the\n-\t     debugger to look it up by name in DWARF more easily.  */\n \t  gnu_decl\n \t    = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n-\t\t\t\t!Comes_From_Source (gnat_entity)\n-\t\t\t\t&& !Comes_From_Source (Etype (gnat_entity)),\n+\t\t\t\t!Comes_From_Source (gnat_entity),\n \t\t\t\tdebug_info_p, gnat_entity);\n \n \t  /* Save it as our equivalent in case the call below elaborates\n@@ -5932,7 +5962,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n     }\n \n   /* If the size is either not being changed or is being made smaller (which\n-     is not done here (and is only valid for bitfields anyway), show the size\n+     is not done here and is only valid for bitfields anyway), show the size\n      isn't changing.  Likewise, clear the alignment if it isn't being\n      changed.  Then return if we aren't doing anything.  */\n   if (size"}]}