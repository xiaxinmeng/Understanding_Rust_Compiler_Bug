{"sha": "d5a2f455e69040cec63269e12307c4c4699850d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVhMmY0NTVlNjkwNDBjZWM2MzI2OWUxMjMwN2M0YzQ2OTk4NTBkNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-10T13:12:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-10T13:12:57Z"}, "message": "cp-tree.h (add_method, [...]): Change last arg to bool.\n\n\tgcc/cp/\n\t* cp-tree.h (add_method, clone_function_decl): Change last arg to\n\tbool.\n\t* class.c (add_method): Change third arg to bool.  Adjust.\n\t(one_inheriting_sig, one_inherited_ctor): Adjust.\n\t(clone_function_decl): Change 2nd arg to bool.  Adjust.\n\t(clone_constructors_and_destructors): Adjust.\n\t* lambda.c (maybe_add_lambda_conv_op): Adjust.\n\t* method.c (lazily_declare_fn): Adjust.\n\t* pt.c (tsubst_decl, instantiate_template_1): Adjust.\n\t* semantics.c (finish_member_declaration): Adjust.\n\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_build_decl): Adjust add_method call.\n\nFrom-SVN: r247834", "tree": {"sha": "5a3ad15efba35f76f3ecbb3841eb39bdd7ad713f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a3ad15efba35f76f3ecbb3841eb39bdd7ad713f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5a2f455e69040cec63269e12307c4c4699850d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5a2f455e69040cec63269e12307c4c4699850d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5a2f455e69040cec63269e12307c4c4699850d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5a2f455e69040cec63269e12307c4c4699850d5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a529e0a697f7cbc16f4d8ea9c2dad9b4b761d96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a529e0a697f7cbc16f4d8ea9c2dad9b4b761d96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a529e0a697f7cbc16f4d8ea9c2dad9b4b761d96c"}], "stats": {"total": 102, "additions": 58, "deletions": 44}, "files": [{"sha": "aca1cbb98e423d38f9b29c85abd466271efbb7ee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -1,3 +1,16 @@\n+2017-05-10  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (add_method, clone_function_decl): Change last arg to\n+\tbool.\n+\t* class.c (add_method): Change third arg to bool.  Adjust.\n+\t(one_inheriting_sig, one_inherited_ctor): Adjust.\n+\t(clone_function_decl): Change 2nd arg to bool.  Adjust.\n+\t(clone_constructors_and_destructors): Adjust.\n+\t* lambda.c (maybe_add_lambda_conv_op): Adjust.\n+\t* method.c (lazily_declare_fn): Adjust.\n+\t* pt.c (tsubst_decl, instantiate_template_1): Adjust.\n+\t* semantics.c (finish_member_declaration): Adjust.\n+\n 2017-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/80145"}, {"sha": "f8e4e1f35412102b0dd99a456c5292610edbe818", "filename": "gcc/cp/class.c", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -1002,12 +1002,12 @@ modify_vtable_entry (tree t,\n }\n \n \f\n-/* Add method METHOD to class TYPE.  If USING_DECL is non-null, it is\n-   the USING_DECL naming METHOD.  Returns true if the method could be\n-   added to the method vec.  */\n+/* Add method METHOD to class TYPE.  If VIA_USING indicates whether\n+   METHOD is being injected via a using_decl.  Returns true if the\n+   method could be added to the method vec.  */\n \n bool\n-add_method (tree type, tree method, tree using_decl)\n+add_method (tree type, tree method, bool via_using)\n {\n   unsigned slot;\n   tree overload;\n@@ -1097,7 +1097,7 @@ add_method (tree type, tree method, tree using_decl)\n \n       /* Two using-declarations can coexist, we'll complain about ambiguity in\n \t overload resolution.  */\n-      if (using_decl && TREE_CODE (fns) == OVERLOAD && OVL_USED (fns)\n+      if (via_using && TREE_CODE (fns) == OVERLOAD && OVL_USED (fns)\n \t  /* Except handle inherited constructors specially.  */\n \t  && ! DECL_CONSTRUCTOR_P (fn))\n \tgoto cont;\n@@ -1221,12 +1221,10 @@ add_method (tree type, tree method, tree using_decl)\n \t      /* Otherwise defer to the other function.  */\n \t      return false;\n \t    }\n-\t  if (using_decl)\n-\t    {\n-\t      if (DECL_CONTEXT (fn) == type)\n-\t\t/* Defer to the local function.  */\n-\t\treturn false;\n-\t    }\n+\n+\t  if (via_using)\n+\t    /* Defer to the local function.  */\n+\t    return false;\n \t  else if (flag_new_inheriting_ctors\n \t\t   && DECL_INHERITED_CTOR (fn))\n \t    {\n@@ -1238,13 +1236,9 @@ add_method (tree type, tree method, tree using_decl)\n \t    {\n \t      error (\"%q+#D cannot be overloaded\", method);\n \t      error (\"with %q+#D\", fn);\n+\t      return false;\n \t    }\n \n-\t  /* We don't call duplicate_decls here to merge the\n-\t     declarations because that will confuse things if the\n-\t     methods have inline definitions.  In particular, we\n-\t     will crash while processing the definitions.  */\n-\t  return false;\n \t}\n \n     cont:\n@@ -1259,7 +1253,7 @@ add_method (tree type, tree method, tree using_decl)\n     return false;\n \n   /* Add the new binding.  */\n-  if (using_decl)\n+  if (via_using)\n     {\n       overload = ovl_cons (method, current_fns);\n       OVL_USED (overload) = true;\n@@ -3340,7 +3334,7 @@ one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n   tree fn = implicitly_declare_fn (sfk_inheriting_constructor,\n \t\t\t\t   t, false, ctor, parmlist);\n   gcc_assert (TYPE_MAIN_VARIANT (t) == t);\n-  if (add_method (t, fn, NULL_TREE))\n+  if (add_method (t, fn, false))\n     {\n       DECL_CHAIN (fn) = TYPE_METHODS (t);\n       TYPE_METHODS (t) = fn;\n@@ -3359,7 +3353,7 @@ one_inherited_ctor (tree ctor, tree t, tree using_decl)\n     {\n       ctor = implicitly_declare_fn (sfk_inheriting_constructor,\n \t\t\t\t    t, /*const*/false, ctor, parms);\n-      add_method (t, ctor, using_decl);\n+      add_method (t, ctor, using_decl != NULL_TREE);\n       TYPE_HAS_USER_CONSTRUCTOR (t) = true;\n       return;\n     }\n@@ -4890,11 +4884,12 @@ decl_cloned_function_p (const_tree decl, bool just_testing)\n }\n \n /* Produce declarations for all appropriate clones of FN.  If\n-   UPDATE_METHOD_VEC_P is nonzero, the clones are added to the\n-   CLASTYPE_METHOD_VEC as well.  */\n+   UPDATE_METHODS is true, the clones are added to the\n+   CLASTYPE_METHOD_VEC.  VIA_USING indicates whether these are cloning\n+   decls brought in via using declarations (i.e. inheriting ctors).  */\n \n void\n-clone_function_decl (tree fn, int update_method_vec_p)\n+clone_function_decl (tree fn, bool update_methods)\n {\n   tree clone;\n \n@@ -4908,11 +4903,11 @@ clone_function_decl (tree fn, int update_method_vec_p)\n       /* For each constructor, we need two variants: an in-charge version\n \t and a not-in-charge version.  */\n       clone = build_clone (fn, complete_ctor_identifier);\n-      if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, NULL_TREE);\n+      if (update_methods)\n+\tadd_method (DECL_CONTEXT (clone), clone, false);\n       clone = build_clone (fn, base_ctor_identifier);\n-      if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, NULL_TREE);\n+      if (update_methods)\n+\tadd_method (DECL_CONTEXT (clone), clone, false);\n     }\n   else\n     {\n@@ -4930,15 +4925,15 @@ clone_function_decl (tree fn, int update_method_vec_p)\n       if (DECL_VIRTUAL_P (fn))\n \t{\n \t  clone = build_clone (fn, deleting_dtor_identifier);\n-\t  if (update_method_vec_p)\n-\t    add_method (DECL_CONTEXT (clone), clone, NULL_TREE);\n+\t  if (update_methods)\n+\t    add_method (DECL_CONTEXT (clone), clone, false);\n \t}\n       clone = build_clone (fn, complete_dtor_identifier);\n-      if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, NULL_TREE);\n+      if (update_methods)\n+\tadd_method (DECL_CONTEXT (clone), clone, false);\n       clone = build_clone (fn, base_dtor_identifier);\n-      if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, NULL_TREE);\n+      if (update_methods)\n+\tadd_method (DECL_CONTEXT (clone), clone, false);\n     }\n \n   /* Note that this is an abstract function that is never emitted.  */\n@@ -5041,10 +5036,12 @@ clone_constructors_and_destructors (tree t)\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return;\n \n+  /* While constructors can be via a using declaration, at this point\n+     we no longer need to know that.  */\n   for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    clone_function_decl (OVL_CURRENT (fns), /*update_method_vec_p=*/1);\n+    clone_function_decl (OVL_CURRENT (fns), /*update_methods=*/true);\n   for (fns = CLASSTYPE_DESTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n-    clone_function_decl (OVL_CURRENT (fns), /*update_method_vec_p=*/1);\n+    clone_function_decl (OVL_CURRENT (fns), /*update_methods=*/true);\n }\n \n /* Deduce noexcept for a destructor DTOR.  */"}, {"sha": "e746450a71696be5bd11b667c312c3f791fc1266", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -5722,7 +5722,7 @@ extern tree build_vfn_ref\t\t\t(tree, tree);\n extern tree get_vtable_decl\t\t\t(tree, int);\n extern void resort_type_method_vec\t\t(void *, void *,\n \t\t\t\t\t\t gt_pointer_operator, void *);\n-extern bool add_method\t\t\t\t(tree, tree, tree);\n+extern bool add_method\t\t\t\t(tree, tree, bool);\n extern tree declared_access\t\t\t(tree);\n extern tree currently_open_class\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n@@ -5785,7 +5785,7 @@ extern tree missing_abi_tags\t\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n extern void fixup_attribute_variants\t\t(tree);\n extern tree* decl_cloned_function_p\t\t(const_tree, bool);\n-extern void clone_function_decl\t\t\t(tree, int);\n+extern void clone_function_decl\t\t\t(tree, bool);\n extern void adjust_clone_args\t\t\t(tree);\n extern void deduce_noexcept_on_destructor       (tree);\n extern void insert_late_enum_def_into_classtype_sorted_fields (tree, tree);"}, {"sha": "66b5312567e087b4fb2ea8efa14b6e1569aed8d4", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -1110,7 +1110,7 @@ maybe_add_lambda_conv_op (tree type)\n   if (generic_lambda_p)\n     fn = add_inherited_template_parms (fn, DECL_TI_TEMPLATE (callop));\n \n-  add_method (type, fn, NULL_TREE);\n+  add_method (type, fn, false);\n \n   /* Generic thunk code fails for varargs; we'll complain in mark_used if\n      the conversion op is used.  */\n@@ -1156,7 +1156,7 @@ maybe_add_lambda_conv_op (tree type)\n       cplus_decl_attributes (&fn, attrs, 0);\n     }\n \n-  add_method (type, fn, NULL_TREE);\n+  add_method (type, fn, false);\n \n   if (nested)\n     push_function_context ();"}, {"sha": "a0ca36dfd0246a122bc2808b88814e821269c26a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -2359,7 +2359,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n       || sfk == sfk_copy_assignment)\n     check_for_override (fn, type);\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n-  add_method (type, fn, NULL_TREE);\n+  add_method (type, fn, false);\n   /* Add it to TYPE_METHODS.  */\n   if (sfk == sfk_destructor\n       && DECL_VIRTUAL_P (fn))\n@@ -2375,7 +2375,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n       || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n     /* Create appropriate clones.  */\n-    clone_function_decl (fn, /*update_method_vec=*/true);\n+    clone_function_decl (fn, /*update_methods=*/true);\n \n   return fn;\n }"}, {"sha": "657bc06f9c7fe4c7b4fc94842c38d756452e03cd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -12413,7 +12413,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t       If it isn't, that'll be handled by\n \t       clone_constructors_and_destructors.  */\n \t    if (PRIMARY_TEMPLATE_P (gen_tmpl))\n-\t      clone_function_decl (r, /*update_method_vec_p=*/0);\n+\t      clone_function_decl (r, /*update_methods=*/false);\n \t  }\n \telse if ((complain & tf_error) != 0\n \t\t && IDENTIFIER_OPNAME_P (DECL_NAME (r))\n@@ -18205,7 +18205,7 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n      by cloning the instantiation of the main entry point, not by\n      instantiating the template clones.  */\n   if (DECL_CHAIN (gen_tmpl) && DECL_CLONED_FUNCTION_P (DECL_CHAIN (gen_tmpl)))\n-    clone_function_decl (fndecl, /*update_method_vec_p=*/0);\n+    clone_function_decl (fndecl, /*update_methods=*/false);\n \n   if (!access_ok)\n     {"}, {"sha": "8c6e11becbb88d762a8e29144fa744ee10654964", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -3018,7 +3018,7 @@ finish_member_declaration (tree decl)\n     {\n       /* We also need to add this function to the\n \t CLASSTYPE_METHOD_VEC.  */\n-      if (add_method (current_class_type, decl, NULL_TREE))\n+      if (add_method (current_class_type, decl, false))\n \t{\n \t  gcc_assert (TYPE_MAIN_VARIANT (current_class_type) == current_class_type);\n \t  DECL_CHAIN (decl) = TYPE_METHODS (current_class_type);"}, {"sha": "17310a0f794f3a94d5f524df9cd0f4ad6d32b070", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -1,3 +1,7 @@\n+2017-05-10  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libcp1plugin.cc (plugin_build_decl): Adjust add_method call.\n+\n 2017-04-15  Alexandre Oliva <aoliva@redhat.com>\n \n \t* libcp1plugin.cc (plugin_build_decl): Call name_unnamed_type."}, {"sha": "f67f8b34f5853650b8f1d3ee0fab128d5495ad8c", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5a2f455e69040cec63269e12307c4c4699850d5/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5a2f455e69040cec63269e12307c4c4699850d5/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=d5a2f455e69040cec63269e12307c4c4699850d5", "patch": "@@ -1579,7 +1579,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n \t reversal.  */\n       tree save = DECL_CHAIN (decl);\n       DECL_CHAIN (decl) = NULL_TREE;\n-      clone_function_decl (decl, /*update_method_vec_p=*/1);\n+      clone_function_decl (decl, /*update_methods=*/true);\n       gcc_assert (TYPE_METHODS (current_class_type) == decl);\n       TYPE_METHODS (current_class_type)\n \t= nreverse (TYPE_METHODS (current_class_type));"}]}