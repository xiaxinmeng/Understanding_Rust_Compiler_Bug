{"sha": "9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "node_id": "C_kwDOANBUbNoAKDlkNjE1YTRiNmU4YjllMGNmMWNkODYyYTY5ZDZhZDFhNzc4OGYzOTY", "commit": {"author": {"name": "Patrick Bernardi", "email": "bernardi@adacore.com", "date": "2021-10-04T21:37:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-11T13:38:11Z"}, "message": "[Ada] RTEMS: use hardware interrupts instead of signals for interrupt handling\n\ngcc/ada/\n\n\t* Makefile.rtl (VxWorks): Rename s-inmaop__vxworks.adb to\n\ts-inmaop__hwint.adb.\n\t(RTEMS): Use s-inmaop__hwint.adb, s-intman__rtems.adb/s,\n\ts-taprop__rtems.adb.\n\t* libgnarl/a-intnam__rtems.ads: Remove signals definitions and\n\treplace with Hardware_Interrupts.\n\t* libgnarl/s-inmaop__vxworks.adb: Rename as...\n\t* libgnarl/s-inmaop__hwint.adb: ... this.\n\t* libgnarl/s-interr__hwint.adb: Remove unnecessary comments.\n\t* libgnarl/s-intman__rtems.ads, libgnarl/s-intman__rtems.adb:\n\tNew files.\n\t* libgnarl/s-osinte__rtems.adb: Add RTEMS API bindings.\n\t(Binary_Semaphore_Create, Binary_Semaphore_Delete,\n\tBinary_Semaphore_Obtain, Binary_Semaphore_Release,\n\tBinary_Semaphore_Flush, Interrupt_Connect,\n\tInterrupt_Number_To_Vector): New functions.\n\t* libgnarl/s-osinte__rtems.ads (Num_HW_Interrupts, Signal):\n\tRemoved.\n\t(NSIG, Interrupt_Range): New.\n\t(Binary_Semaphore_Create, Binary_Semaphore_Delete,\n\tBinary_Semaphore_Obtain, Binary_Semaphore_Release,\n\tBinary_Semaphore_Flush, Interrupt_Connect,\n\tInterrupt_Number_To_Vector): Remove Import pragma.\n\t* libgnarl/s-taprop__rtems.adb: New file.", "tree": {"sha": "41782f0dd6e8d1fcf05fb1ec5ffd46222f851572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41782f0dd6e8d1fcf05fb1ec5ffd46222f851572"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/comments", "author": {"login": "burratoo", "id": 23646118, "node_id": "MDQ6VXNlcjIzNjQ2MTE4", "avatar_url": "https://avatars.githubusercontent.com/u/23646118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/burratoo", "html_url": "https://github.com/burratoo", "followers_url": "https://api.github.com/users/burratoo/followers", "following_url": "https://api.github.com/users/burratoo/following{/other_user}", "gists_url": "https://api.github.com/users/burratoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/burratoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/burratoo/subscriptions", "organizations_url": "https://api.github.com/users/burratoo/orgs", "repos_url": "https://api.github.com/users/burratoo/repos", "events_url": "https://api.github.com/users/burratoo/events{/privacy}", "received_events_url": "https://api.github.com/users/burratoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cea83351a2a023a07ba5577cd91b5edcd690299b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea83351a2a023a07ba5577cd91b5edcd690299b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea83351a2a023a07ba5577cd91b5edcd690299b"}], "stats": {"total": 1884, "additions": 1732, "deletions": 152}, "files": [{"sha": "7fef51713115550311141a005826969ddd89d242", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -1084,7 +1084,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks vxworksspe vxworks7% vxworks7spe\n   a-nuaufl.ads<libgnat/a-nuaufl__wraplf.ads \\\n   a-nashfl.ads<libgnat/a-nashfl__wraplf.ads \\\n   s-dorepr.adb<libgnat/s-dorepr__fma.adb \\\n-  s-inmaop.adb<libgnarl/s-inmaop__vxworks.adb \\\n+  s-inmaop.adb<libgnarl/s-inmaop__hwint.adb \\\n   s-intman.ads<libgnarl/s-intman__vxworks.ads \\\n   s-intman.adb<libgnarl/s-intman__vxworks.adb \\\n   s-osinte.ads<libgnarl/s-osinte__vxworks.ads \\\n@@ -1207,7 +1207,7 @@ ifeq ($(strip $(filter-out %86 x86_64 wrs vxworks vxworks7%,$(target_cpu) $(targ\n   a-nashfl.ads<libgnat/a-nashfl__wraplf.ads \\\n   s-osinte.adb<libgnarl/s-osinte__vxworks.adb \\\n   s-osinte.ads<libgnarl/s-osinte__vxworks.ads \\\n-  s-inmaop.adb<libgnarl/s-inmaop__vxworks.adb \\\n+  s-inmaop.adb<libgnarl/s-inmaop__hwint.adb \\\n   s-intman.ads<libgnarl/s-intman__vxworks.ads \\\n   s-intman.adb<libgnarl/s-intman__vxworks.adb \\\n   s-osprim.adb<libgnat/s-osprim__posix.adb \\\n@@ -1351,7 +1351,7 @@ ifeq ($(strip $(filter-out aarch64 arm% coff wrs vx%,$(target_cpu) $(target_vend\n   a-naliop.ads<libgnat/a-naliop__nolibm.ads \\\n   a-nuaufl.ads<libgnat/a-nuaufl__wraplf.ads \\\n   a-nashfl.ads<libgnat/a-nashfl__wraplf.ads \\\n-  s-inmaop.adb<libgnarl/s-inmaop__vxworks.adb \\\n+  s-inmaop.adb<libgnarl/s-inmaop__hwint.adb \\\n   s-interr.adb<libgnarl/s-interr__vxworks.adb \\\n   s-intman.ads<libgnarl/s-intman__vxworks.ads \\\n   s-intman.adb<libgnarl/s-intman__vxworks.adb \\\n@@ -2047,14 +2047,15 @@ ifeq ($(strip $(filter-out rtems%,$(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   system.ads<libgnat/system-rtems.ads \\\n   a-intnam.ads<libgnarl/a-intnam__rtems.ads \\\n-  s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n-  s-intman.adb<libgnarl/s-intman__posix.adb \\\n+  s-inmaop.adb<libgnarl/s-inmaop__hwint.adb \\\n+  s-intman.adb<libgnarl/s-intman__rtems.adb \\\n+  s-intman.ads<libgnarl/s-intman__rtems.ads \\\n   s-osinte.adb<libgnarl/s-osinte__rtems.adb \\\n   s-osinte.ads<libgnarl/s-osinte__rtems.ads \\\n   s-osprim.adb<libgnat/s-osprim__rtems.adb \\\n   s-parame.adb<libgnat/s-parame__rtems.adb \\\n   s-parame.ads<libgnat/s-parame__posix2008.ads \\\n-  s-taprop.adb<libgnarl/s-taprop__posix.adb \\\n+  s-taprop.adb<libgnarl/s-taprop__rtems.adb \\\n   s-taspri.ads<libgnarl/s-taspri__posix.ads \\\n   s-tpopsp.adb<libgnarl/s-tpopsp__tls.adb \\\n   s-interr.adb<libgnarl/s-interr__hwint.adb"}, {"sha": "4654f00bbe74cdf5730dc108c31a786514b6bae5", "filename": "gcc/ada/libgnarl/a-intnam__rtems.ads", "status": "modified", "additions": 5, "deletions": 69, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fa-intnam__rtems.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fa-intnam__rtems.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-intnam__rtems.ads?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -34,81 +34,17 @@\n ------------------------------------------------------------------------------\n \n --  This is a RTEMS version of this package\n---\n---  The following signals are reserved by the run time:\n---\n---  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,\n---  SIGALRM, SIGEMT, SIGKILL\n---\n---  The pragma Unreserve_All_Interrupts affects the following signal(s):\n---\n---  SIGINT: made available for Ada handlers\n-\n---  This target-dependent package spec contains names of interrupts\n---  supported by the local system.\n \n with System.OS_Interface;\n---  used for names of interrupts\n \n package Ada.Interrupts.Names is\n \n-   --  Beware that the mapping of names to signals may be\n-   --  many-to-one.  There may be aliases.  Also, for all\n-   --  signal names that are not supported on the current system\n-   --  the value of the corresponding constant will be zero.\n-\n-   SIGHUP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGHUP;      --  hangup\n-\n-   SIGINT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGINT;      --  interrupt (rubout)\n-\n-   SIGQUIT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)\n-\n-   SIGILL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)\n-\n-   SIGTRAP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)\n-\n-   SIGIOT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGIOT;      --  IOT instruction\n-\n-   SIGABRT : constant Interrupt_ID := --  used by abort,\n-     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future\n-\n-   SIGEMT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGEMT;      --  EMT instruction\n-\n-   SIGFPE : constant Interrupt_ID :=\n-     System.OS_Interface.SIGFPE;      --  floating point exception\n-\n-   SIGKILL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)\n-\n-   SIGBUS : constant Interrupt_ID :=\n-     System.OS_Interface.SIGBUS;      --  bus error\n-\n-   SIGSEGV : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSEGV;     --  segmentation violation\n-\n-   SIGSYS : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSYS;      --  bad argument to system call\n-\n-   SIGPIPE : constant Interrupt_ID := --  write on a pipe with\n-     System.OS_Interface.SIGPIPE;     --  no one to read it\n-\n-   SIGALRM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGALRM;     --  alarm clock\n-\n-   SIGTERM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTERM;     --  software termination signal from kill\n+   --  All identifiers in this unit are implementation defined\n \n-   SIGUSR1 : constant Interrupt_ID :=\n-     System.OS_Interface.SIGUSR1;     --  user defined signal 1\n+   pragma Implementation_Defined;\n \n-   SIGUSR2 : constant Interrupt_ID :=\n-     System.OS_Interface.SIGUSR2;     --  user defined signal 2\n+   subtype Hardware_Interrupts is Interrupt_ID\n+     range Interrupt_ID'First .. System.OS_Interface.Max_HW_Interrupt;\n+   --  Range of values that can be used for hardware interrupts\n \n end Ada.Interrupts.Names;"}, {"sha": "52a92ac1beed3e202cd0af36f3ce1350e27142a6", "filename": "gcc/ada/libgnarl/s-inmaop__hwint.adb", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-inmaop__hwint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-inmaop__hwint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-inmaop__hwint.adb?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -30,9 +30,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a VxWorks version of this package. Many operations are null as this\n---  package supports the use of Ada interrupt handling facilities for signals,\n---  while those facilities are used for hardware interrupts on these targets.\n+--  This is a hardware interrupt version of this package. Many operations are\n+--  null as this package supports the use of Ada interrupt handling facilities\n+--  for signals, while those facilities are used for hardware interrupts on\n+--  these targets.\n \n with Ada.Exceptions;\n ", "previous_filename": "gcc/ada/libgnarl/s-inmaop__vxworks.adb"}, {"sha": "5f801749c45a1052983823c6061150533c11e3f3", "filename": "gcc/ada/libgnarl/s-interr__hwint.adb", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-interr__hwint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-interr__hwint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-interr__hwint.adb?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -29,40 +29,22 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Invariants:\n-\n---  All user-handlable signals are masked at all times in all tasks/threads\n---  except possibly for the Interrupt_Manager task.\n-\n---  When a user task wants to have the effect of masking/unmasking an signal,\n---  it must call Block_Interrupt/Unblock_Interrupt, which will have the effect\n---  of unmasking/masking the signal in the Interrupt_Manager task. These\n---  comments do not apply to vectored hardware interrupts, which may be masked\n---  or unmasked using routined interfaced to the relevant embedded RTOS system\n---  calls.\n+--  This is reasonably generic version of this package, supporting vectored\n+--  hardware interrupts using non-RTOS specific adapter routines which should\n+--  easily implemented on any RTOS capable of supporting GNAT.\n \n---  Once we associate a Signal_Server_Task with an signal, the task never goes\n---  away, and we never remove the association. On the other hand, it is more\n---  convenient to terminate an associated Interrupt_Server_Task for a vectored\n---  hardware interrupt (since we use a binary semaphore for synchronization\n---  with the umbrella handler).\n+--  Invariants:\n \n---  There is no more than one signal per Signal_Server_Task and no more than\n---  one Signal_Server_Task per signal. The same relation holds for hardware\n---  interrupts and Interrupt_Server_Task's at any given time. That is, only\n---  one non-terminated Interrupt_Server_Task exists for a give interrupt at\n---  any time.\n+--  There is no more than one interrupt per Interrupt_Server_Task and no more\n+--  than one Interrupt_Server_Task per interrupt. If an interrupt handler is\n+--  detached, the corresponding Interrupt_Server_Task is terminated.\n \n --  Within this package, the lock L is used to protect the various status\n --  tables. If there is a Server_Task associated with a signal or interrupt,\n --  we use the per-task lock of the Server_Task instead so that we protect the\n --  status between Interrupt_Manager and Server_Task. Protection among service\n --  requests are ensured via user calls to the Interrupt_Manager entries.\n \n---  This is reasonably generic version of this package, supporting vectored\n---  hardware interrupts using non-RTOS specific adapter routines which should\n---  easily implemented on any RTOS capable of supporting GNAT.\n-\n with Ada.Unchecked_Conversion;\n with Ada.Task_Identification;\n \n@@ -151,13 +133,13 @@ package body System.Interrupts is\n      (others => (null, Static => False));\n    pragma Volatile_Components (User_Handler);\n    --  Holds the protected procedure handler (if any) and its Static\n-   --  information for each interrupt or signal. A handler is static iff it\n+   --  information for each interrupt. A handler is static if and only if it\n    --  is specified through the pragma Attach_Handler.\n \n    User_Entry : array (Interrupt_ID) of Entry_Assoc :=\n                   (others => (T => Null_Task, E => Null_Task_Entry));\n    pragma Volatile_Components (User_Entry);\n-   --  Holds the task and entry index (if any) for each interrupt / signal\n+   --  Holds the task and entry index (if any) for each interrupt\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n    --  Handlers. These definitions are used to register the handlers"}, {"sha": "dedc67c4a60b1aa2198fe044b15f7376c90cf3b2", "filename": "gcc/ada/libgnarl/s-intman__rtems.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-intman__rtems.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-intman__rtems.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-intman__rtems.adb?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -0,0 +1,93 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the RTEMS version of this package\n+\n+--  It is simpler than other versions because the Ada interrupt handling\n+--  mechanisms are used for hardware interrupts rather than signals.\n+\n+package body System.Interrupt_Management is\n+\n+   use System.OS_Interface;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function State (Int : Interrupt_ID) return Character;\n+   pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+   --  Get interrupt state. Defined in init.c The input argument is the\n+   --  hardware interrupt number, and the result is one of the following:\n+\n+   Runtime : constant Character := 'r';\n+   Default : constant Character := 's';\n+   --    'n'   this interrupt not set by any Interrupt_State pragma\n+   --    'u'   Interrupt_State pragma set state to User\n+   --    'r'   Interrupt_State pragma set state to Runtime\n+   --    's'   Interrupt_State pragma set state to System (use \"default\"\n+   --           system handler)\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   Initialized : Boolean := False;\n+   --  Set to True once Initialize is called, further calls have no effect\n+\n+   procedure Initialize is\n+\n+   begin\n+      if Initialized then\n+         return;\n+      end if;\n+\n+      Initialized := True;\n+\n+      --  Set the signal used to signal an abort to another task as defined in\n+      --  System.OS_Interface.\n+\n+      Abort_Task_Interrupt := SIGADAABORT;\n+\n+      --  Initialize hardware interrupt handling\n+\n+      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n+\n+      --  Check all interrupts for state that requires keeping them reserved\n+\n+      for J in Interrupt_ID'Range loop\n+         if State (J) = Default or else State (J) = Runtime then\n+            Reserve (J) := True;\n+         end if;\n+      end loop;\n+\n+   end Initialize;\n+\n+end System.Interrupt_Management;"}, {"sha": "f3d53ecfbcbd0e2a51a4c4e5ddbaff95c3270e84", "filename": "gcc/ada/libgnarl/s-intman__rtems.ads", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-intman__rtems.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-intman__rtems.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-intman__rtems.ads?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -0,0 +1,99 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T         --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the RTEMS version of this package\n+\n+--  This package encapsulates and centralizes information about all\n+--  uses of interrupts (or signals), including the target-dependent\n+--  mapping of interrupts (or signals) to exceptions.\n+\n+--  Unlike the original design, System.Interrupt_Management can only\n+--  be used for tasking systems.\n+\n+--  PLEASE DO NOT put any subprogram declarations with arguments of\n+--  type Interrupt_ID into the visible part of this package. The type\n+--  Interrupt_ID is used to derive the type in Ada.Interrupts, and\n+--  adding more operations to that type would be illegal according\n+--  to the Ada Reference Manual. This is the reason why the signals\n+--  sets are implemented using visible arrays rather than functions.\n+\n+with System.OS_Interface;\n+\n+with Interfaces.C;\n+\n+package System.Interrupt_Management is\n+   pragma Preelaborate;\n+\n+   type Interrupt_Mask is limited private;\n+\n+   type Interrupt_ID is new Interfaces.C.int\n+     range 0 .. System.OS_Interface.Max_Interrupt;\n+\n+   type Interrupt_Set is array (Interrupt_ID) of Boolean;\n+\n+   subtype Signal_ID is Interrupt_ID range 0 .. System.OS_Interface.NSIG - 1;\n+\n+   type Signal_Set is array (Signal_ID) of Boolean;\n+\n+   --  The following objects serve as constants, but are initialized in the\n+   --  body to aid portability. This permits us to use more portable names for\n+   --  interrupts, where distinct names may map to the same interrupt ID\n+   --  value.\n+\n+   --  For example, suppose SIGRARE is a signal that is not defined on all\n+   --  systems, but is always reserved when it is defined. If we have the\n+   --  convention that ID zero is not used for any \"real\" signals, and SIGRARE\n+   --  = 0 when SIGRARE is not one of the locally supported signals, we can\n+   --  write:\n+   --     Reserved (SIGRARE) := True;\n+   --  and the initialization code will be portable.\n+\n+   Abort_Task_Interrupt : Signal_ID;\n+   --  The signal that is used to implement task abort if an interrupt is used\n+   --  for that purpose. This is one of the reserved signals.\n+\n+   Reserve : Interrupt_Set := (others => False);\n+   --  Reserve (I) is true iff the interrupt I is one that cannot be permitted\n+   --  to be attached to a user handler. The possible reasons are many. For\n+   --  example, it may be mapped to an exception used to implement task abort,\n+   --  or used to implement time delays.\n+\n+   procedure Initialize;\n+   --  Initialize the various variables defined in this package. This procedure\n+   --  must be called before accessing any object from this package and can be\n+   --  called multiple times (only the first call has any effect).\n+\n+private\n+   type Interrupt_Mask is new System.OS_Interface.sigset_t;\n+   --  In some implementation Interrupt_Mask can be represented as a linked\n+   --  list.\n+\n+end System.Interrupt_Management;"}, {"sha": "96883afcf25dca6e98ca9ad1121b4349c382e6ff", "filename": "gcc/ada/libgnarl/s-osinte__rtems.adb", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-osinte__rtems.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-osinte__rtems.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte__rtems.adb?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -44,6 +44,54 @@ with Interfaces.C; use Interfaces.C;\n \n package body System.OS_Interface is\n \n+   ---------------\n+   -- RTEMS API --\n+   ---------------\n+\n+   type RTEMS_Attributes is new unsigned;\n+\n+   RTEMS_SIMPLE_BINARY_SEMAPHORE : constant := 16#00000020#;\n+   RTEMS_FIFO                    : constant := 16#00000000#;\n+\n+   type RTEMS_Interval is new unsigned;\n+\n+   RTEMS_NO_TIMEOUT : constant := 0;\n+\n+   type RTEMS_Options is new unsigned;\n+\n+   RTEMS_WAIT             : constant := 16#00000000#;\n+   RTEMS_INTERRUPT_UNIQUE : constant := 16#00000001#;\n+\n+   type RTEMS_Name is new unsigned;\n+\n+   function RTEMS_Build_Name (C1, C2, C3, C4 : Character) return RTEMS_Name\n+     with Import, External_Name => \"rtems_build_name\", Convention => C;\n+\n+   function RTEMS_Semaphore_Create\n+     (Name             : RTEMS_Name;\n+      Count            : unsigned;\n+      Attributes       : RTEMS_Attributes;\n+      Priority_Ceiling : unsigned;\n+      Semaphore        : out Binary_Semaphore_Id) return int\n+     with Import, External_Name => \"rtems_semaphore_create\", Convention => C;\n+\n+   function RTEMS_Semaphore_Delete (Semaphore : Binary_Semaphore_Id) return int\n+     with Import, External_Name => \"rtems_semaphore_delete\", Convention => C;\n+\n+   function RTEMS_Semaphore_Flush (Semaphore : Binary_Semaphore_Id)\n+     return int\n+     with Import, External_Name => \"rtems_semaphore_flush\", Convention => C;\n+\n+   function RTEMS_Semaphore_Obtain\n+     (Semaphore : Binary_Semaphore_Id;\n+      Options   : RTEMS_Options;\n+      Timeout   : RTEMS_Interval) return int\n+     with Import, External_Name => \"rtems_semaphore_obtain\", Convention => C;\n+\n+   function RTEMS_Semaphore_Release (Semaphore : Binary_Semaphore_Id)\n+     return int\n+     with Import, External_Name => \"rtems_semaphore_release\", Convention => C;\n+\n    -----------------\n    -- To_Duration --\n    -----------------\n@@ -85,6 +133,108 @@ package body System.OS_Interface is\n                        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n    end To_Timespec;\n \n+   -----------------------------\n+   -- Binary_Semaphore_Create --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Create return Binary_Semaphore_Id is\n+      Semaphore : Binary_Semaphore_Id;\n+      Status    : int;\n+   begin\n+      Status :=\n+        RTEMS_Semaphore_Create\n+          (Name             => RTEMS_Build_Name ('G', 'N', 'A', 'T'),\n+           Count            => 0,\n+           Attributes       => RTEMS_SIMPLE_BINARY_SEMAPHORE or RTEMS_FIFO,\n+           Priority_Ceiling => 0,\n+           Semaphore        => Semaphore);\n+\n+      pragma Assert (Status = 0);\n+\n+      return Semaphore;\n+   end Binary_Semaphore_Create;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Delete --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Delete (ID : Binary_Semaphore_Id)\n+     return int is\n+   begin\n+      return RTEMS_Semaphore_Delete (ID);\n+   end Binary_Semaphore_Delete;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Obtain --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Obtain (ID : Binary_Semaphore_Id)\n+     return int is\n+   begin\n+      return RTEMS_Semaphore_Obtain (ID, RTEMS_WAIT, RTEMS_NO_TIMEOUT);\n+   end Binary_Semaphore_Obtain;\n+\n+   ------------------------------\n+   -- Binary_Semaphore_Release --\n+   ------------------------------\n+\n+   function Binary_Semaphore_Release (ID : Binary_Semaphore_Id)\n+     return int is\n+   begin\n+      return RTEMS_Semaphore_Release (ID);\n+   end Binary_Semaphore_Release;\n+\n+   ----------------------------\n+   -- Binary_Semaphore_Flush --\n+   ----------------------------\n+\n+   function Binary_Semaphore_Flush (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return RTEMS_Semaphore_Flush (ID);\n+   end Binary_Semaphore_Flush;\n+\n+   -----------------------\n+   -- Interrupt_Connect --\n+   -----------------------\n+\n+   function Interrupt_Connect\n+     (Vector    : Interrupt_Vector;\n+      Handler   : Interrupt_Handler;\n+      Parameter : System.Address := System.Null_Address) return int\n+   is\n+      function RTEMS_Interrupt_Handler_Install\n+         (Vector    : Interrupt_Vector;\n+          Info      : char_array;\n+          Options   : RTEMS_Options;\n+          Handler   : Interrupt_Handler;\n+          Parameter : System.Address) return int\n+        with Import,\n+             External_Name => \"rtems_interrupt_handler_install\",\n+             Convention => C;\n+\n+      Info_String : constant char_array := To_C (\"GNAT Interrupt Handler\");\n+      --  Handler name that is registered with RTEMS\n+   begin\n+      return\n+        RTEMS_Interrupt_Handler_Install\n+          (Vector    => Vector,\n+           Info      => Info_String,\n+           Options   => RTEMS_INTERRUPT_UNIQUE,\n+           Handler   => Handler,\n+           Parameter => Parameter);\n+   end Interrupt_Connect;\n+\n+   --------------------------------\n+   -- Interrupt_Number_To_Vector --\n+   --------------------------------\n+\n+   function Interrupt_Number_To_Vector (intNum : int)\n+     return Interrupt_Vector\n+   is\n+   begin\n+      return Interrupt_Vector (intNum);\n+   end Interrupt_Number_To_Vector;\n+\n    ------------------\n    -- pthread_init --\n    ------------------"}, {"sha": "5743a6aa46809de8a26eac8ddb07731febd5a4d8", "filename": "gcc/ada/libgnarl/s-osinte__rtems.ads", "status": "modified", "additions": 18, "deletions": 47, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-osinte__rtems.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-osinte__rtems.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte__rtems.ads?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -85,18 +85,20 @@ package System.OS_Interface is\n    ENOMEM    : constant := System.OS_Constants.ENOMEM;\n    ETIMEDOUT : constant := System.OS_Constants.ETIMEDOUT;\n \n-   -------------\n-   -- Signals --\n-   -------------\n+   ----------------------------\n+   -- Signals and Interrupts --\n+   ----------------------------\n \n-   Num_HW_Interrupts : constant := 256;\n+   NSIG : constant := 64;\n+   --  Number of signals on the target OS\n+   type Signal is new int range 0 .. Interfaces.C.\"-\" (NSIG, 1);\n \n-   Max_HW_Interrupt : constant := Num_HW_Interrupts - 1;\n+   Max_HW_Interrupt : constant := 255;\n    type HW_Interrupt is new int range 0 .. Max_HW_Interrupt;\n \n    Max_Interrupt : constant := Max_HW_Interrupt;\n-\n-   type Signal is new int range 0 .. Max_Interrupt;\n+   subtype Interrupt_Range is Natural range 0 .. Max_HW_Interrupt;\n+   --  For s-interr\n \n    SIGXCPU     : constant := 0; --  XCPU\n    SIGHUP      : constant := 1; --  hangup\n@@ -546,71 +548,40 @@ package System.OS_Interface is\n    type Binary_Semaphore_Id is new rtems_id;\n \n    function Binary_Semaphore_Create return Binary_Semaphore_Id;\n-   pragma Import (\n-      C,\n-      Binary_Semaphore_Create,\n-      \"__gnat_binary_semaphore_create\");\n+   pragma Inline (Binary_Semaphore_Create);\n \n    function Binary_Semaphore_Delete (ID : Binary_Semaphore_Id) return int;\n-   pragma Import (\n-      C,\n-      Binary_Semaphore_Delete,\n-      \"__gnat_binary_semaphore_delete\");\n+   pragma Inline (Binary_Semaphore_Delete);\n \n    function Binary_Semaphore_Obtain (ID : Binary_Semaphore_Id) return int;\n-   pragma Import (\n-      C,\n-      Binary_Semaphore_Obtain,\n-      \"__gnat_binary_semaphore_obtain\");\n+   pragma Inline (Binary_Semaphore_Obtain);\n \n    function Binary_Semaphore_Release (ID : Binary_Semaphore_Id) return int;\n-   pragma Import (\n-      C,\n-      Binary_Semaphore_Release,\n-      \"__gnat_binary_semaphore_release\");\n+   pragma Inline (Binary_Semaphore_Release);\n \n    function Binary_Semaphore_Flush (ID : Binary_Semaphore_Id) return int;\n-   pragma Import (\n-      C,\n-      Binary_Semaphore_Flush,\n-      \"__gnat_binary_semaphore_flush\");\n+   pragma Inline (Binary_Semaphore_Flush);\n \n    ------------------------------------------------------------\n    -- Hardware Interrupt Wrappers to Support Interrupt Tasks --\n    ------------------------------------------------------------\n \n    type Interrupt_Handler is access procedure (parameter : System.Address);\n    pragma Convention (C, Interrupt_Handler);\n+\n    type Interrupt_Vector is new System.Address;\n \n    function Interrupt_Connect\n-     (vector    : Interrupt_Vector;\n-      handler   : Interrupt_Handler;\n-      parameter : System.Address := System.Null_Address) return int;\n-   pragma Import (C, Interrupt_Connect, \"__gnat_interrupt_connect\");\n+     (Vector    : Interrupt_Vector;\n+      Handler   : Interrupt_Handler;\n+      Parameter : System.Address := System.Null_Address) return int;\n    --  Use this to set up an user handler. The routine installs a\n    --  a user handler which is invoked after RTEMS has saved enough\n    --  context for a high-level language routine to be safely invoked.\n \n-   function Interrupt_Vector_Get\n-     (Vector : Interrupt_Vector) return Interrupt_Handler;\n-   pragma Import (C, Interrupt_Vector_Get, \"__gnat_interrupt_get\");\n-   --  Use this to get the existing handler for later restoral.\n-\n-   procedure Interrupt_Vector_Set\n-     (Vector  : Interrupt_Vector;\n-      Handler : Interrupt_Handler);\n-   pragma Import (C, Interrupt_Vector_Set, \"__gnat_interrupt_set\");\n-   --  Use this to restore a handler obtained using Interrupt_Vector_Get.\n-\n    function Interrupt_Number_To_Vector (intNum : int) return Interrupt_Vector;\n    --  Convert a logical interrupt number to the hardware interrupt vector\n    --  number used to connect the interrupt.\n-   pragma Import (\n-      C,\n-      Interrupt_Number_To_Vector,\n-      \"__gnat_interrupt_number_to_vector\"\n-   );\n \n private\n "}, {"sha": "9153032337f13715f51a230fb6bec83e6691ebde", "filename": "gcc/ada/libgnarl/s-taprop__rtems.adb", "status": "added", "additions": 1347, "deletions": 0, "changes": 1347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-taprop__rtems.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396/gcc%2Fada%2Flibgnarl%2Fs-taprop__rtems.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__rtems.adb?ref=9d615a4b6e8b9e0cf1cd862a69d6ad1a7788f396", "patch": "@@ -0,0 +1,1347 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the RTEMS version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly with\n+--  the underlying OS.\n+\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C;\n+\n+with System.Tasking.Debug;\n+with System.Interrupt_Management;\n+with System.OS_Constants;\n+with System.OS_Primitives;\n+with System.Task_Info;\n+\n+with System.Soft_Links;\n+--  We use System.Soft_Links instead of System.Tasking.Initialization\n+--  because the later is a higher level package that we shouldn't depend on.\n+--  For example when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Stages.\n+\n+package body System.Task_Primitives.Operations is\n+\n+   package OSC renames System.OS_Constants;\n+   package SSL renames System.Soft_Links;\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   ----------------\n+   -- Local Data --\n+   ----------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used to protect All_Tasks_List\n+\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task\n+\n+   Locking_Policy : constant Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+   --  Value of the pragma Locking_Policy:\n+   --    'C' for Ceiling_Locking\n+   --    'I' for Inherit_Locking\n+   --    ' ' for none.\n+\n+   --  The followings are internal configuration constants needed\n+\n+   Next_Serial_Number : Task_Serial_Number := 100;\n+   --  We start at 100, to reserve some special values for\n+   --  using in error checking.\n+\n+   Time_Slice_Val : constant Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+\n+   Dispatching_Policy : constant Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   Foreign_Task_Elaborated : aliased Boolean := True;\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n+\n+   Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n+   --  Whether to use an alternate signal stack for stack overflows\n+\n+   Abort_Handler_Installed : Boolean := False;\n+   --  True if a handler for the abort signal is installed\n+\n+   --------------------\n+   -- Local Packages --\n+   --------------------\n+\n+   package Specific is\n+\n+      procedure Initialize (Environment_Task : Task_Id);\n+      pragma Inline (Initialize);\n+      --  Initialize various data needed by this package\n+\n+      function Is_Valid_Task return Boolean;\n+      pragma Inline (Is_Valid_Task);\n+      --  Does executing thread have a TCB?\n+\n+      procedure Set (Self_Id : Task_Id);\n+      pragma Inline (Set);\n+      --  Set the self id for the current task\n+\n+      function Self return Task_Id;\n+      pragma Inline (Self);\n+      --  Return a pointer to the Ada Task Control Block of the calling task\n+\n+   end Specific;\n+\n+   package body Specific is separate;\n+   --  The body of this package is target specific\n+\n+   package Monotonic is\n+\n+      function Monotonic_Clock return Duration;\n+      pragma Inline (Monotonic_Clock);\n+      --  Returns an absolute time, represented as an offset relative to some\n+      --  unspecified starting point, typically system boot time.  This clock\n+      --  is not affected by discontinuous jumps in the system time.\n+\n+      function RT_Resolution return Duration;\n+      pragma Inline (RT_Resolution);\n+      --  Returns resolution of the underlying clock used to implement RT_Clock\n+\n+      procedure Timed_Sleep\n+        (Self_ID  : ST.Task_Id;\n+         Time     : Duration;\n+         Mode     : ST.Delay_Modes;\n+         Reason   : System.Tasking.Task_States;\n+         Timedout : out Boolean;\n+         Yielded  : out Boolean);\n+      --  Combination of Sleep (above) and Timed_Delay\n+\n+      procedure Timed_Delay\n+        (Self_ID : ST.Task_Id;\n+         Time    : Duration;\n+         Mode    : ST.Delay_Modes);\n+      --  Implement the semantics of the delay statement.\n+      --  The caller should be abort-deferred and should not hold any locks.\n+\n+   end Monotonic;\n+\n+   package body Monotonic is separate;\n+\n+   ----------------------------------\n+   -- ATCB allocation/deallocation --\n+   ----------------------------------\n+\n+   package body ATCB_Allocation is separate;\n+   --  The body of this package is shared across several targets\n+\n+   ---------------------------------\n+   -- Support for foreign threads --\n+   ---------------------------------\n+\n+   function Register_Foreign_Thread\n+     (Thread         : Thread_Id;\n+      Sec_Stack_Size : Size_Type := Unspecified_Size) return Task_Id;\n+   --  Allocate and initialize a new ATCB for the current Thread. The size of\n+   --  the secondary stack can be optionally specified.\n+\n+   function Register_Foreign_Thread\n+     (Thread         : Thread_Id;\n+      Sec_Stack_Size : Size_Type := Unspecified_Size)\n+     return Task_Id is separate;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Abort_Handler (Sig : Signal);\n+   --  Signal handler used to implement asynchronous abort.\n+   --  See also comment before body, below.\n+\n+   function To_Address is\n+     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n+\n+   function GNAT_pthread_condattr_setup\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C,\n+     GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   --  Target-dependent binding of inter-thread Abort signal to the raising of\n+   --  the Abort_Signal exception.\n+\n+   --  The technical issues and alternatives here are essentially the\n+   --  same as for raising exceptions in response to other signals\n+   --  (e.g. Storage_Error). See code and comments in the package body\n+   --  System.Interrupt_Management.\n+\n+   --  Some implementations may not allow an exception to be propagated out of\n+   --  a handler, and others might leave the signal or interrupt that invoked\n+   --  this handler masked after the exceptional return to the application\n+   --  code.\n+\n+   --  GNAT exceptions are originally implemented using setjmp()/longjmp(). On\n+   --  most UNIX systems, this will allow transfer out of a signal handler,\n+   --  which is usually the only mechanism available for implementing\n+   --  asynchronous handlers of this kind. However, some systems do not\n+   --  restore the signal mask on longjmp(), leaving the abort signal masked.\n+\n+   procedure Abort_Handler (Sig : Signal) is\n+      pragma Unreferenced (Sig);\n+\n+      T              : constant Task_Id := Self;\n+      Old_Set        : aliased sigset_t;\n+      Unblocked_Mask : aliased sigset_t;\n+      Result         : Interfaces.C.int;\n+      pragma Warnings (Off, Result);\n+\n+   begin\n+      --  It's not safe to raise an exception when using GCC ZCX mechanism.\n+      --  Note that we still need to install a signal handler, since in some\n+      --  cases (e.g. shutdown of the Server_Task in System.Interrupts) we\n+      --  need to send the Abort signal to a task.\n+\n+      if ZCX_By_Default then\n+         return;\n+      end if;\n+\n+      if T.Deferral_Level = 0\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n+        not T.Aborting\n+      then\n+         T.Aborting := True;\n+\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := sigemptyset (Unblocked_Mask'Access);\n+         pragma Assert (Result = 0);\n+         Result :=\n+           sigaddset\n+           (Unblocked_Mask'Access,\n+            Signal (Interrupt_Management.Abort_Task_Interrupt));\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGBUS);\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGFPE);\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGILL);\n+         pragma Assert (Result = 0);\n+         Result := sigaddset (Unblocked_Mask'Access, SIGSEGV);\n+         pragma Assert (Result = 0);\n+\n+         Result :=\n+           pthread_sigmask\n+             (SIG_UNBLOCK,\n+              Unblocked_Mask'Access,\n+              Old_Set'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Standard'Abort_Signal;\n+      end if;\n+   end Abort_Handler;\n+\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n+\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n+      Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n+      Page_Size  : Address;\n+      Res        : Interfaces.C.int;\n+\n+   begin\n+      if Stack_Base_Available then\n+\n+         --  Compute the guard page address\n+\n+         Page_Size := Address (Get_Page_Size);\n+         Res :=\n+           mprotect\n+             (Stack_Base - (Stack_Base mod Page_Size) + Page_Size,\n+              size_t (Page_Size),\n+              prot => (if On then PROT_ON else PROT_OFF));\n+         pragma Assert (Res = 0);\n+      end if;\n+   end Stack_Guard;\n+\n+   --------------------\n+   -- Get_Thread_Id  --\n+   --------------------\n+\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_Id renames Specific.Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore raising Storage_Error in the following\n+   --  routines should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : not null access Lock)\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, Interfaces.C.int (Prio));\n+         pragma Assert (Result = 0);\n+\n+      elsif Locking_Policy = 'I' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L.WO'Access, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock\n+     (L : not null access RTS_Lock; Level : Lock_Level)\n+   is\n+      pragma Unreferenced (Level);\n+\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n+         pragma Assert (Result = 0);\n+\n+      elsif Locking_Policy = 'I' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : not null access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L.WO'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : not null access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean)\n+   is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L.WO'Access);\n+\n+      --  The cause of EINVAL is a priority ceiling violation\n+\n+      Ceiling_Violation := Result = EINVAL;\n+      pragma Assert (Result = 0 or else Ceiling_Violation);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock\n+     (L : not null access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : not null access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (L.WO'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (L : not null access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   -----------------\n+   -- Set_Ceiling --\n+   -----------------\n+\n+   --  Dynamic priority ceilings are not supported by the underlying system\n+\n+   procedure Set_Ceiling\n+     (L    : not null access Lock;\n+      Prio : System.Any_Priority)\n+   is\n+      pragma Unreferenced (L, Prio);\n+   begin\n+      null;\n+   end Set_Ceiling;\n+\n+   -----------\n+   -- Sleep --\n+   -----------\n+\n+   procedure Sleep\n+     (Self_ID : Task_Id;\n+      Reason  : System.Tasking.Task_States)\n+   is\n+      pragma Unreferenced (Reason);\n+\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => Self_ID.Common.LL.L'Access);\n+\n+      --  EINTR is not considered a failure\n+\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_Id;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean) renames Monotonic.Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is abort-deferred but is holding no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID : Task_Id;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes) renames Monotonic.Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration renames Monotonic.Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration renames Monotonic.RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n+      pragma Unreferenced (Reason);\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+      pragma Unreferenced (Result);\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T                   : Task_Id;\n+      Prio                : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      pragma Unreferenced (Loss_Of_Inheritance);\n+\n+      Result : Interfaces.C.int;\n+      Param  : aliased struct_sched_param;\n+\n+      function Get_Policy (Prio : System.Any_Priority) return Character;\n+      pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n+      --  Get priority specific dispatching policy\n+\n+      Priority_Specific_Policy : constant Character := Get_Policy (Prio);\n+      --  Upper case first character of the policy name corresponding to the\n+      --  task as set by a Priority_Specific_Dispatching pragma.\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+      Param.sched_priority := To_Target_Priority (Prio);\n+\n+      if Time_Slice_Supported\n+        and then (Dispatching_Policy = 'R'\n+                  or else Priority_Specific_Policy = 'R'\n+                  or else Time_Slice_Val > 0)\n+      then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+\n+      elsif Dispatching_Policy = 'F'\n+        or else Priority_Specific_Policy = 'F'\n+        or else Time_Slice_Val = 0\n+      then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+\n+      else\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_Id) is\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Self_ID.Common.LL.LWP := lwp_self;\n+\n+      Specific.Set (Self_ID);\n+\n+      if Use_Alternate_Stack then\n+         declare\n+            Stack  : aliased stack_t;\n+            Result : Interfaces.C.int;\n+         begin\n+            Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n+            Stack.ss_size  := Alternate_Stack_Size;\n+            Stack.ss_flags := 0;\n+            Result := sigaltstack (Stack'Access, null);\n+            pragma Assert (Result = 0);\n+         end;\n+      end if;\n+   end Enter_Task;\n+\n+   -------------------\n+   -- Is_Valid_Task --\n+   -------------------\n+\n+   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;\n+\n+   -----------------------------\n+   -- Register_Foreign_Thread --\n+   -----------------------------\n+\n+   function Register_Foreign_Thread return Task_Id is\n+   begin\n+      if Is_Valid_Task then\n+         return Self;\n+      else\n+         return Register_Foreign_Thread (pthread_self);\n+      end if;\n+   end Register_Foreign_Thread;\n+\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+\n+   begin\n+      --  Give the task a unique serial number\n+\n+      Self_ID.Serial_Number := Next_Serial_Number;\n+      Next_Serial_Number := Next_Serial_Number + 1;\n+      pragma Assert (Next_Serial_Number /= 0);\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         if Locking_Policy = 'C' then\n+            Result :=\n+              pthread_mutexattr_setprotocol\n+                (Mutex_Attr'Access,\n+                 PTHREAD_PRIO_PROTECT);\n+            pragma Assert (Result = 0);\n+\n+            Result :=\n+              pthread_mutexattr_setprioceiling\n+                (Mutex_Attr'Access,\n+                 Interfaces.C.int (System.Any_Priority'Last));\n+            pragma Assert (Result = 0);\n+\n+         elsif Locking_Policy = 'I' then\n+            Result :=\n+              pthread_mutexattr_setprotocol\n+                (Mutex_Attr'Access,\n+                 PTHREAD_PRIO_INHERIT);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n+         Result :=\n+           pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access,\n+              Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_Id;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes          : aliased pthread_attr_t;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Page_Size           : constant Interfaces.C.size_t :=\n+                              Interfaces.C.size_t (Get_Page_Size);\n+      Result              : Interfaces.C.int;\n+\n+      function Thread_Body_Access is new\n+        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+\n+      use System.Task_Info;\n+\n+   begin\n+      Adjusted_Stack_Size :=\n+         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n+\n+      if Stack_Base_Available then\n+\n+         --  If Stack Checking is supported then allocate 2 additional pages:\n+\n+         --  In the worst case, stack is allocated at something like\n+         --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n+         --  to be sure the effective stack size is greater than what\n+         --  has been asked.\n+\n+         Adjusted_Stack_Size := Adjusted_Stack_Size + 2 * Page_Size;\n+      end if;\n+\n+      --  Round stack size as this is required by some OSes (Darwin)\n+\n+      Adjusted_Stack_Size := Adjusted_Stack_Size + Page_Size - 1;\n+      Adjusted_Stack_Size :=\n+        Adjusted_Stack_Size - Adjusted_Stack_Size mod Page_Size;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result :=\n+        pthread_attr_setdetachstate\n+          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      pragma Assert (Result = 0);\n+\n+      Result :=\n+        pthread_attr_setstacksize\n+          (Attributes'Access, Adjusted_Stack_Size);\n+      pragma Assert (Result = 0);\n+\n+      if T.Common.Task_Info /= Default_Scope then\n+         case T.Common.Task_Info is\n+            when System.Task_Info.Process_Scope =>\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n+\n+            when System.Task_Info.System_Scope =>\n+               Result :=\n+                 pthread_attr_setscope\n+                   (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n+\n+            when System.Task_Info.Default_Scope =>\n+               Result := 0;\n+         end case;\n+\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      --  Note: the use of Unrestricted_Access in the following call is needed\n+      --  because otherwise we have an error of getting a access-to-volatile\n+      --  value which points to a non-volatile object. But in this case it is\n+      --  safe to do this, since we know we have no problems with aliasing and\n+      --  Unrestricted_Access bypasses this check.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Unrestricted_Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+\n+      if Succeeded then\n+         Set_Priority (T, Priority);\n+      end if;\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+\n+      ATCB_Allocation.Free_ATCB (T);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      --  Mark this task as unknown, so that if Self is called, it won't\n+      --  return a dangling pointer.\n+\n+      Specific.Set (null);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_Id) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if Abort_Handler_Installed then\n+         Result :=\n+           pthread_kill\n+             (T.Common.LL.Thread,\n+              Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      --  Initialize internal state (always to False (RM D.10 (6)))\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Storage_Error is propagated as intended if the allocation of the\n+         --  underlying OS entities fails.\n+\n+         raise Storage_Error;\n+\n+      else\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_condattr_destroy (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         --  Storage_Error is propagated as intended if the allocation of the\n+         --  underlying OS entities fails.\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      SSL.Abort_Undefer.all;\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in (RM D.10(9)). Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      SSL.Abort_Undefer.all;\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (RM D.10(10)).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         SSL.Abort_Undefer.all;\n+\n+         raise Program_Error;\n+\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+\n+            loop\n+               --  Loop in case pthread_cond_wait returns earlier than expected\n+               --  (e.g. in case of EINTR caused by a signal).\n+\n+               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+               pragma Assert (Result = 0 or else Result = EINTR);\n+\n+               exit when not S.Waiting;\n+            end loop;\n+         end if;\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         SSL.Abort_Undefer.all;\n+      end if;\n+   end Suspend_Until_True;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy version\n+\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (Self_ID);\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (Self_ID);\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_Id is\n+   begin\n+      return Environment_Task_Id;\n+   end Environment_Task;\n+\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n+\n+   procedure Lock_RTS is\n+   begin\n+      Write_Lock (Single_RTS_Lock'Access);\n+   end Lock_RTS;\n+\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n+\n+   procedure Unlock_RTS is\n+   begin\n+      Unlock (Single_RTS_Lock'Access);\n+   end Unlock_RTS;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_Id;\n+      Thread_Self : Thread_Id) return Boolean\n+   is\n+      pragma Unreferenced (T, Thread_Self);\n+   begin\n+      return False;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_Id;\n+      Thread_Self : Thread_Id) return Boolean\n+   is\n+      pragma Unreferenced (T, Thread_Self);\n+   begin\n+      return False;\n+   end Resume_Task;\n+\n+   --------------------\n+   -- Stop_All_Tasks --\n+   --------------------\n+\n+   procedure Stop_All_Tasks is\n+   begin\n+      null;\n+   end Stop_All_Tasks;\n+\n+   ---------------\n+   -- Stop_Task --\n+   ---------------\n+\n+   function Stop_Task (T : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (T);\n+   begin\n+      return False;\n+   end Stop_Task;\n+\n+   -------------------\n+   -- Continue_Task --\n+   -------------------\n+\n+   function Continue_Task (T : ST.Task_Id) return Boolean is\n+      pragma Unreferenced (T);\n+   begin\n+      return False;\n+   end Continue_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_Id) is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Tmp_Set : aliased sigset_t;\n+      Result  : Interfaces.C.int;\n+\n+      function State\n+        (Int : System.Interrupt_Management.Interrupt_ID) return Character;\n+      pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+      --  Get interrupt state.  Defined in a-init.c\n+      --  The input argument is the interrupt number,\n+      --  and the result is one of the following:\n+\n+      Default : constant Character := 's';\n+      --    'n'   this interrupt not set by any Interrupt_State pragma\n+      --    'u'   Interrupt_State pragma set state to User\n+      --    'r'   Interrupt_State pragma set state to Runtime\n+      --    's'   Interrupt_State pragma set state to System (use \"default\"\n+      --           system handler)\n+\n+   begin\n+      Environment_Task_Id := Environment_Task;\n+\n+      Interrupt_Management.Initialize;\n+\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n+\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n+\n+      Specific.Initialize (Environment_Task);\n+\n+      if Use_Alternate_Stack then\n+         Environment_Task.Common.Task_Alternate_Stack :=\n+           Alternate_Stack'Address;\n+      end if;\n+\n+      --  Make environment task known here because it doesn't go through\n+      --  Activate_Tasks, which does it for all other tasks.\n+\n+      Known_Tasks (Known_Tasks'First) := Environment_Task;\n+      Environment_Task.Known_Tasks_Index := Known_Tasks'First;\n+\n+      Enter_Task (Environment_Task);\n+\n+      if State\n+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n+      then\n+         act.sa_flags := 0;\n+         act.sa_handler := Abort_Handler'Address;\n+\n+         Result := sigemptyset (Tmp_Set'Access);\n+         pragma Assert (Result = 0);\n+         act.sa_mask := Tmp_Set;\n+\n+         Result :=\n+           sigaction\n+             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+              act'Unchecked_Access,\n+              old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+         Abort_Handler_Installed := True;\n+      end if;\n+   end Initialize;\n+\n+   -----------------------\n+   -- Set_Task_Affinity --\n+   -----------------------\n+\n+   procedure Set_Task_Affinity (T : ST.Task_Id) is\n+      pragma Unreferenced (T);\n+\n+   begin\n+      --  Setting task affinity is not supported by the underlying system\n+\n+      null;\n+   end Set_Task_Affinity;\n+\n+end System.Task_Primitives.Operations;"}]}