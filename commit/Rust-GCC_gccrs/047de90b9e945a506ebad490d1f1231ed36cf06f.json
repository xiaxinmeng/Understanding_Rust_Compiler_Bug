{"sha": "047de90b9e945a506ebad490d1f1231ed36cf06f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ3ZGU5MGI5ZTk0NWE1MDZlYmFkNDkwZDFmMTIzMWVkMzZjZjA2Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-04T19:11:28Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-04T19:11:28Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r682", "tree": {"sha": "497de7942fe821b229e61091af88909c98945698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497de7942fe821b229e61091af88909c98945698"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/047de90b9e945a506ebad490d1f1231ed36cf06f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047de90b9e945a506ebad490d1f1231ed36cf06f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/047de90b9e945a506ebad490d1f1231ed36cf06f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047de90b9e945a506ebad490d1f1231ed36cf06f/comments", "author": null, "committer": null, "parents": [{"sha": "65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806"}], "stats": {"total": 108, "additions": 65, "deletions": 43}, "files": [{"sha": "91043fd3743828eee2814c70b7f2a5203dbc8744", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047de90b9e945a506ebad490d1f1231ed36cf06f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047de90b9e945a506ebad490d1f1231ed36cf06f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=047de90b9e945a506ebad490d1f1231ed36cf06f", "patch": "@@ -389,8 +389,10 @@ binary_op_error (code)\n     case RSHIFT_EXPR:\n       opname = \">>\"; break;\n     case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n       opname = \"%\"; break;\n     case TRUNC_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n       opname = \"/\"; break;\n     case BIT_AND_EXPR:\n       opname = \"&\"; break;\n@@ -402,6 +404,9 @@ binary_op_error (code)\n       opname = \"||\"; break;\n     case BIT_XOR_EXPR:\n       opname = \"^\"; break;\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      opname = \"rotate\"; break;\n     }\n   error (\"invalid operands to binary %s\", opname);\n }"}, {"sha": "5a54d8f05236e002c1d33af5a838b8e4c4080013", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 60, "deletions": 43, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047de90b9e945a506ebad490d1f1231ed36cf06f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047de90b9e945a506ebad490d1f1231ed36cf06f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=047de90b9e945a506ebad490d1f1231ed36cf06f", "patch": "@@ -1714,6 +1714,10 @@ check_format (info, params)\n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n       if (i == fci->pointer_count && wanted_type != 0\n \t  && wanted_type != cur_type\n+\t  /* If we want `void *', allow any pointer type.\n+\t     (Anything else would already have got a warning.)  */\n+\t  && ! (wanted_type == void_type_node\n+\t\t&& fci->pointer_count > 0)\n \t  /* Don't warn about differences merely in signedness.  */\n \t  && !(TREE_CODE (wanted_type) == INTEGER_TYPE\n \t       && TREE_CODE (cur_type) == INTEGER_TYPE\n@@ -1724,9 +1728,12 @@ check_format (info, params)\n   \n \t  this = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n \t  that = 0;\n-\t  if (TYPE_NAME (cur_type) != 0)\n-\t    if (DECL_NAME (TYPE_NAME (cur_type)) != 0)\n-\t      that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n+\t  if (TYPE_NAME (cur_type) != 0\n+\t      && TREE_CODE (cur_type) != INTEGER_TYPE\n+\t      && !(TREE_CODE (cur_type) == POINTER_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (cur_type)) == INTEGER_TYPE)\n+\t      && DECL_NAME (TYPE_NAME (cur_type)) != 0)\n+\t    that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n \n \t  /* A nameless type can't possibly match what the format wants.\n \t     So there will be a warning for it.\n@@ -1949,8 +1956,6 @@ convert_arguments (typelist, values, name)\n \t      if (warn_conversion)\n \t\t{\n \t\t  int formal_prec = TYPE_PRECISION (type);\n-\t\t  int actual_prec = TYPE_PRECISION (TREE_TYPE (val));\n-\t\t  int int_prec = TYPE_PRECISION (integer_type_node);\n \n \t\t  if (TREE_CODE (type) != REAL_TYPE\n \t\t      && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)\n@@ -1962,7 +1967,7 @@ convert_arguments (typelist, values, name)\n \t\t\t   && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)\n \t\t    {\n \t\t      /* Warn if any argument is passed as `float',\n-\t\t\t since withtout a prototype it would be `double'.  */\n+\t\t\t since without a prototype it would be `double'.  */\n \t\t      if (formal_prec == TYPE_PRECISION (float_type_node))\n \t\t\twarning (\"floating argument passed as `float' rather than `double'\");\n \t\t    }\n@@ -1975,7 +1980,7 @@ convert_arguments (typelist, values, name)\n \t\t      tree would_have_been = default_conversion (val);\n \t\t      tree type1 = TREE_TYPE (would_have_been);\n \n-\t\t      if (TYPE_PRECISION (type) != TYPE_PRECISION (type))\n+\t\t      if (formal_prec != TYPE_PRECISION (type))\n \t\t\twarning (\"prototype changes width used for integer argument\");\n \t\t      else if (TREE_UNSIGNED (type) == TREE_UNSIGNED (type1))\n \t\t\t;\n@@ -1984,6 +1989,12 @@ convert_arguments (typelist, values, name)\n \t\t\t/* Change in signedness doesn't matter\n \t\t\t   if a constant value is unaffected.  */\n \t\t\t;\n+\t\t      else if (TREE_CODE (TREE_TYPE (val)) == ENUMERAL_TYPE\n+\t\t\t       && int_fits_type_p (TYPE_MIN_VALUE (TREE_TYPE (val)), type)\n+\t\t\t       && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (val)), type))\n+\t\t\t/* Change in signedness doesn't matter\n+\t\t\t   if an enum value is unaffected.  */\n+\t\t\t;\n \t\t      else if (TREE_UNSIGNED (type))\n \t\t\twarning (\"argument passed as unsigned due to prototype\");\n \t\t      else\n@@ -2288,6 +2299,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       break;\n \n     case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \tshorten = 1;\n       break;\n@@ -4334,13 +4346,15 @@ get_spelling (errtype)\n       /* Avoid counting chars */\n       static char message[] = \"initialization of `%s'\";\n       register int needed = sizeof (message) + spelling_length () + 1;\n+      char *temp;\n \n       if (size < 0)\n \tbuffer = (char *) xmalloc (size = needed);\n       if (needed > size)\n \tbuffer = (char *) xrealloc (buffer, size = needed);\n \n-      sprintf (buffer, message, print_spelling (alloca (needed)));\n+      temp = (char *) alloca (needed);\n+      sprintf (buffer, message, print_spelling (temp));\n       return buffer;\n     }\n \n@@ -4429,6 +4443,7 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n      tree node which has no TREE_TYPE.  */\n   int raw_constructor\n     = TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == 0;\n+  tree inside_init = init;\n \n   /* By default, assume we use one element from a list.\n      We correct this later in the sole case where it is not true.  */\n@@ -4444,13 +4459,13 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n-    init = TREE_OPERAND (init, 0);\n+    inside_init = TREE_OPERAND (init, 0);\n \n   if (init && raw_constructor\n-      && CONSTRUCTOR_ELTS (init) != 0\n-      && TREE_CHAIN (CONSTRUCTOR_ELTS (init)) == 0)\n+      && CONSTRUCTOR_ELTS (inside_init) != 0\n+      && TREE_CHAIN (CONSTRUCTOR_ELTS (inside_init)) == 0)\n     {\n-      element = TREE_VALUE (CONSTRUCTOR_ELTS (init));\n+      element = TREE_VALUE (CONSTRUCTOR_ELTS (inside_init));\n       /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n       if (element && TREE_CODE (element) == NON_LVALUE_EXPR)\n \telement = TREE_OPERAND (element, 0);\n@@ -4467,10 +4482,10 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t   || typ1 == unsigned_char_type_node\n \t   || typ1 == unsigned_wchar_type_node\n \t   || typ1 == signed_wchar_type_node)\n-\t  && ((init && TREE_CODE (init) == STRING_CST)\n+\t  && ((inside_init && TREE_CODE (inside_init) == STRING_CST)\n \t      || (element && TREE_CODE (element) == STRING_CST)))\n \t{\n-\t  tree string = element ? element : init;\n+\t  tree string = element ? element : inside_init;\n \n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n \t       != char_type_node)\n@@ -4510,44 +4525,45 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n      from an expression of the same type, optionally with braces.\n      For an array, this is allowed only for a string constant.  */\n \n-  if (init && (TREE_TYPE (init) == type\n-\t       || (code == ARRAY_TYPE && TREE_TYPE (init)\n-\t\t   && comptypes (TREE_TYPE (init), type))\n+  if (inside_init && (TREE_TYPE (inside_init) == type\n+\t       || (code == ARRAY_TYPE && TREE_TYPE (inside_init)\n+\t\t   && comptypes (TREE_TYPE (inside_init), type))\n \t       || (code == POINTER_TYPE\n-\t\t   && TREE_TYPE (init) != 0\n-\t\t   && (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n-\t\t       || TREE_CODE (TREE_TYPE (init)) == FUNCTION_TYPE)\n-\t\t   && comptypes (TREE_TYPE (TREE_TYPE (init)),\n+\t\t   && TREE_TYPE (inside_init) != 0\n+\t\t   && (TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n+\t\t       || TREE_CODE (TREE_TYPE (inside_init)) == FUNCTION_TYPE)\n+\t\t   && comptypes (TREE_TYPE (TREE_TYPE (inside_init)),\n \t\t\t\t TREE_TYPE (type)))))\n     {\n       if (code == POINTER_TYPE\n-\t  && (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n-\t      || TREE_CODE (TREE_TYPE (init)) == FUNCTION_TYPE))\n-\tinit = default_conversion (init);\n-      else if (code == ARRAY_TYPE && TREE_CODE (init) != STRING_CST)\n+\t  && (TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n+\t      || TREE_CODE (TREE_TYPE (inside_init)) == FUNCTION_TYPE))\n+\tinside_init = default_conversion (inside_init);\n+      else if (code == ARRAY_TYPE && TREE_CODE (inside_init) != STRING_CST)\n \t{\n \t  error_init (\"array%s initialized from non-constant array expression\",\n \t\t      \" `%s'\", ofwhat);\n \t  return error_mark_node;\n \t}\n \n-      if (optimize && TREE_READONLY (init) && TREE_CODE (init) == VAR_DECL)\n-\tinit = decl_constant_value (init);\n+      if (optimize && TREE_READONLY (inside_init)\n+\t  && TREE_CODE (inside_init) == VAR_DECL)\n+\tinside_init = decl_constant_value (inside_init);\n \n-      if (require_constant && ! TREE_CONSTANT (init))\n+      if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n \t  error_init (\"initializer element%s is not constant\",\n \t\t      \" for `%s'\", ofwhat);\n-\t  init = error_mark_node;\n+\t  inside_init = error_mark_node;\n \t}\n-      else if (require_constant && initializer_constant_valid_p (init) == 0)\n+      else if (require_constant && initializer_constant_valid_p (inside_init) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n \t\t      \" for `%s'\", ofwhat);\n-\t  init = error_mark_node;\n+\t  inside_init = error_mark_node;\n \t}\n \n-      return init;\n+      return inside_init;\n     }\n \n   if (element && (TREE_TYPE (element) == type\n@@ -4608,7 +4624,7 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n \n \t  if (raw_constructor)\n-\t    result = process_init_constructor (type, init, 0,\n+\t    result = process_init_constructor (type, inside_init, 0,\n \t\t\t\t\t       require_constant,\n \t\t\t\t\t       constructor_constant, 0);\n \t  else if (tail != 0)\n@@ -4640,11 +4656,11 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t\t  \" `%s'\", ofwhat);\n \t      return error_mark_node;\n \t    }\n-\t  init = element;\n+\t  inside_init = element;\n \t}\n \n #if 0  /* A non-raw constructor is an actual expression.  */\n-      if (TREE_CODE (init) == CONSTRUCTOR)\n+      if (TREE_CODE (inside_init) == CONSTRUCTOR)\n \t{\n \t  error_init (\"initializer for scalar%s has extra braces\",\n \t\t      \" `%s'\", ofwhat);\n@@ -4656,24 +4672,24 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t({\n \t  if (ofwhat)\n \t    push_string (ofwhat);\n-\t  init = convert_for_assignment (type, default_conversion (init),\n+\t  inside_init = convert_for_assignment (type, default_conversion (init),\n \t\t\t\t\t &initialization_message, NULL_TREE, 0);\n \t});\n \n-      if (require_constant && ! TREE_CONSTANT (init))\n+      if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n \t  error_init (\"initializer element%s is not constant\",\n \t\t      \" for `%s'\", ofwhat);\n-\t  init = error_mark_node;\n+\t  inside_init = error_mark_node;\n \t}\n-      else if (require_constant && initializer_constant_valid_p (init) == 0)\n+      else if (require_constant && initializer_constant_valid_p (inside_init) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n \t\t      \" for `%s'\", ofwhat);\n-\t  init = error_mark_node;\n+\t  inside_init = error_mark_node;\n \t}\n \n-      return init;\n+      return inside_init;\n     }\n \n   /* Come here only for records and arrays.  */\n@@ -4688,7 +4704,8 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n   if (code == ARRAY_TYPE || code == RECORD_TYPE)\n     {\n       if (raw_constructor)\n-\treturn process_init_constructor (type, init, 0, constructor_constant,\n+\treturn process_init_constructor (type, inside_init,\n+\t\t\t\t\t 0, constructor_constant,\n \t\t\t\t\t constructor_constant, ofwhat);\n       else if (tail != 0)\n \t{\n@@ -4700,7 +4717,7 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t/* Traditionally one can say `char x[100] = 0;'.  */\n \treturn process_init_constructor (type,\n \t\t\t\t\t build_nt (CONSTRUCTOR, 0,\n-\t\t\t\t\t\t   tree_cons (0, init, 0)),\n+\t\t\t\t\t\t   tree_cons (0, inside_init, 0)),\n \t\t\t\t\t 0, constructor_constant,\n \t\t\t\t\t constructor_constant, ofwhat);\n     }"}]}