{"sha": "367b1cf5cfd8762d9d709a0ab810185cb6379b1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY3YjFjZjVjZmQ4NzYyZDlkNzA5YTBhYjgxMDE4NWNiNjM3OWIxYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-12-21T13:56:28Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-12-21T13:56:28Z"}, "message": "Break up emit_reload_insns.\n\nFrom-SVN: r31052", "tree": {"sha": "1277f66fa70eddcc91a9561ebc66b82136cb9083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1277f66fa70eddcc91a9561ebc66b82136cb9083"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/367b1cf5cfd8762d9d709a0ab810185cb6379b1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/367b1cf5cfd8762d9d709a0ab810185cb6379b1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/367b1cf5cfd8762d9d709a0ab810185cb6379b1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/367b1cf5cfd8762d9d709a0ab810185cb6379b1c/comments", "author": null, "committer": null, "parents": [{"sha": "ca098a1ddf082c8597f6b9b36b45d22dfd7a35b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca098a1ddf082c8597f6b9b36b45d22dfd7a35b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca098a1ddf082c8597f6b9b36b45d22dfd7a35b3"}], "stats": {"total": 1604, "additions": 824, "deletions": 780}, "files": [{"sha": "1dc34b0e19893227dc467246ae1a75baacfdc52e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367b1cf5cfd8762d9d709a0ab810185cb6379b1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367b1cf5cfd8762d9d709a0ab810185cb6379b1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=367b1cf5cfd8762d9d709a0ab810185cb6379b1c", "patch": "@@ -1,3 +1,15 @@\n+1999-12-21  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload1.c (emit_reload_insns): Break out code and variables into...\n+\t(input_reload_insns, other_input_address_reload_insns,\n+\tother_input_reload_insns, input_address_reload_insns,\n+\tinpaddr_address_reload_insns, output_reload_insns,\n+\toutput_address_reload_insns, outaddr_address_reload_insns,\n+\toperand_reload_insns, other_operand_reload_insns,\n+\tother_output_reload_insns): ... new static variables, and...\n+\t(emit_input_reload_insns, emit_output_reload_insns, do_input_reload,\n+\tdo_output_reload): ... new functions.\n+\n Tue Dec 21 07:06:36 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* pa.h (FUNCTION_ARG_BOUNDARY): Never return 0."}, {"sha": "8df32e68c36a603e20f45b765f1a3b7a8d800149", "filename": "gcc/reload1.c", "status": "modified", "additions": 812, "deletions": 780, "changes": 1592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367b1cf5cfd8762d9d709a0ab810185cb6379b1c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367b1cf5cfd8762d9d709a0ab810185cb6379b1c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=367b1cf5cfd8762d9d709a0ab810185cb6379b1c", "patch": "@@ -414,6 +414,14 @@ static int set_reload_reg\t\tPROTO((int, int));\n static void choose_reload_regs_init\tPROTO((struct insn_chain *, rtx *));\n static void choose_reload_regs\t\tPROTO((struct insn_chain *));\n static void merge_assigned_reloads\tPROTO((rtx));\n+static void emit_input_reload_insns\tPROTO((struct insn_chain *,\n+\t\t\t\t\t       struct reload *, rtx, int));\n+static void emit_output_reload_insns\tPROTO((struct insn_chain *,\n+\t\t\t\t\t       struct reload *, int));\n+static void do_input_reload\t\tPROTO((struct insn_chain *,\n+\t\t\t\t\t       struct reload *, int));\n+static void do_output_reload\t\tPROTO((struct insn_chain *,\n+\t\t\t\t\t       struct reload *, int));\n static void emit_reload_insns\t\tPROTO((struct insn_chain *));\n static void delete_output_reload\tPROTO((rtx, int, int));\n static void delete_address_reloads\tPROTO((rtx, rtx));\n@@ -5834,867 +5842,891 @@ merge_assigned_reloads (insn)\n }\n \n \f\n-/* Output insns to reload values in and out of the chosen reload regs.  */\n-\n+/* These arrays are filled by emit_reload_insns and its subroutines.  */\n+static rtx input_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx other_input_address_reload_insns = 0;\n+static rtx other_input_reload_insns = 0;\n+static rtx input_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx inpaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx output_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx output_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx outaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n+static rtx operand_reload_insns = 0;\n+static rtx other_operand_reload_insns = 0;\n+static rtx other_output_reload_insns[MAX_RECOG_OPERANDS];\n+\n+/* Values to be put in spill_reg_store are put here first.  */\n+static rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n+static HARD_REG_SET reg_reloaded_died;\n+\n+/* Generate insns to perform reload RL, which is for the insn in CHAIN and\n+   has the number J.  OLD contains the value to be used as input.  */\n static void\n-emit_reload_insns (chain)\n+emit_input_reload_insns (chain, rl, old, j)\n      struct insn_chain *chain;\n+     struct reload *rl;\n+     rtx old;\n+     int j;\n {\n   rtx insn = chain->insn;\n+  register rtx reloadreg = rl->reg_rtx;\n+  rtx oldequiv_reg = 0;\n+  rtx oldequiv = 0;\n+  int special = 0;\n+  enum machine_mode mode;\n+  rtx *where;\n+\n+  /* Determine the mode to reload in.\n+     This is very tricky because we have three to choose from.\n+     There is the mode the insn operand wants (rl->inmode).\n+     There is the mode of the reload register RELOADREG.\n+     There is the intrinsic mode of the operand, which we could find\n+     by stripping some SUBREGs.\n+     It turns out that RELOADREG's mode is irrelevant:\n+     we can change that arbitrarily.\n+\n+     Consider (SUBREG:SI foo:QI) as an operand that must be SImode;\n+     then the reload reg may not support QImode moves, so use SImode.\n+     If foo is in memory due to spilling a pseudo reg, this is safe,\n+     because the QImode value is in the least significant part of a\n+     slot big enough for a SImode.  If foo is some other sort of\n+     memory reference, then it is impossible to reload this case,\n+     so previous passes had better make sure this never happens.\n+\n+     Then consider a one-word union which has SImode and one of its\n+     members is a float, being fetched as (SUBREG:SF union:SI).\n+     We must fetch that as SFmode because we could be loading into\n+     a float-only register.  In this case OLD's mode is correct.\n+\n+     Consider an immediate integer: it has VOIDmode.  Here we need\n+     to get a mode from something else.\n+\n+     In some cases, there is a fourth mode, the operand's\n+     containing mode.  If the insn specifies a containing mode for\n+     this operand, it overrides all others.\n+\n+     I am not sure whether the algorithm here is always right,\n+     but it does the right things in those cases.  */\n+\n+  mode = GET_MODE (old);\n+  if (mode == VOIDmode)\n+    mode = rl->inmode;\n \n-  register int j;\n-  rtx input_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx other_input_address_reload_insns = 0;\n-  rtx other_input_reload_insns = 0;\n-  rtx input_address_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx inpaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx output_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx output_address_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx outaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx operand_reload_insns = 0;\n-  rtx other_operand_reload_insns = 0;\n-  rtx other_output_reload_insns[MAX_RECOG_OPERANDS];\n-  rtx following_insn = NEXT_INSN (insn);\n-  rtx before_insn = PREV_INSN (insn);\n-  int special;\n-  /* Values to be put in spill_reg_store are put here first.  */\n-  rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n-  HARD_REG_SET reg_reloaded_died;\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+  /* If we need a secondary register for this operation, see if\n+     the value is already in a register in that class.  Don't\n+     do this if the secondary register will be used as a scratch\n+     register.  */\n+\n+  if (rl->secondary_in_reload >= 0\n+      && rl->secondary_in_icode == CODE_FOR_nothing\n+      && optimize)\n+    oldequiv\n+      = find_equiv_reg (old, insn,\n+\t\t\trld[rl->secondary_in_reload].class,\n+\t\t\t-1, NULL_PTR, 0, mode);\n+#endif\n \n-  CLEAR_HARD_REG_SET (reg_reloaded_died);\n+  /* If reloading from memory, see if there is a register\n+     that already holds the same value.  If so, reload from there.\n+     We can pass 0 as the reload_reg_p argument because\n+     any other reload has either already been emitted,\n+     in which case find_equiv_reg will see the reload-insn,\n+     or has yet to be emitted, in which case it doesn't matter\n+     because we will use this equiv reg right away.  */\n+\n+  if (oldequiv == 0 && optimize\n+      && (GET_CODE (old) == MEM\n+\t  || (GET_CODE (old) == REG\n+\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n+\t      && reg_renumber[REGNO (old)] < 0)))\n+    oldequiv = find_equiv_reg (old, insn, ALL_REGS,\n+\t\t\t       -1, NULL_PTR, 0, mode);\n+\n+  if (oldequiv)\n+    {\n+      int regno = true_regnum (oldequiv);\n+\n+      /* Don't use OLDEQUIV if any other reload changes it at an\n+\t earlier stage of this insn or at this stage.  */\n+      if (! reload_reg_free_for_value_p (regno, rl->opnum,\n+\t\t\t\t\t rl->when_needed,\n+\t\t\t\t\t rl->in, const0_rtx, j,\n+\t\t\t\t\t 0))\n+\toldequiv = 0;\n+\n+      /* If it is no cheaper to copy from OLDEQUIV into the\n+\t reload register than it would be to move from memory,\n+\t don't use it. Likewise, if we need a secondary register\n+\t or memory.   */\n+\n+      if (oldequiv != 0\n+\t  && ((REGNO_REG_CLASS (regno) != rl->class\n+\t       && (REGISTER_MOVE_COST (REGNO_REG_CLASS (regno),\n+\t\t\t\t       rl->class)\n+\t\t   >= MEMORY_MOVE_COST (mode, rl->class, 1)))\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+\t      || (SECONDARY_INPUT_RELOAD_CLASS (rl->class,\n+\t\t\t\t\t\tmode, oldequiv)\n+\t\t  != NO_REGS)\n+#endif\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (regno),\n+\t\t\t\t\t  rl->class,\n+\t\t\t\t\t  mode)\n+#endif\n+\t      ))\n+\toldequiv = 0;\n+    }\n \n-  for (j = 0; j < reload_n_operands; j++)\n-    input_reload_insns[j] = input_address_reload_insns[j]\n-      = inpaddr_address_reload_insns[j]\n-      = output_reload_insns[j] = output_address_reload_insns[j]\n-      = outaddr_address_reload_insns[j]\n-      = other_output_reload_insns[j] = 0;\n+  /* delete_output_reload is only invoked properly if old contains\n+     the original pseudo register.  Since this is replaced with a\n+     hard reg when RELOAD_OVERRIDE_IN is set, see if we can\n+     find the pseudo in RELOAD_IN_REG.  */\n+  if (oldequiv == 0\n+      && reload_override_in[j]\n+      && GET_CODE (rl->in_reg) == REG)\n+    {\n+      oldequiv = old;\n+      old = rl->in_reg;\n+    }\n+  if (oldequiv == 0)\n+    oldequiv = old;\n+  else if (GET_CODE (oldequiv) == REG)\n+    oldequiv_reg = oldequiv;\n+  else if (GET_CODE (oldequiv) == SUBREG)\n+    oldequiv_reg = SUBREG_REG (oldequiv);\n+\n+  /* If we are reloading from a register that was recently stored in\n+     with an output-reload, see if we can prove there was\n+     actually no need to store the old value in it.  */\n+\n+  if (optimize && GET_CODE (oldequiv) == REG\n+      && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n+      && spill_reg_store[REGNO (oldequiv)]\n+      && GET_CODE (old) == REG\n+      && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (oldequiv)])\n+\t  || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n+\t\t\t  rl->out_reg)))\n+    delete_output_reload (insn, j, REGNO (oldequiv));\n+\n+  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n+     then load RELOADREG from OLDEQUIV.  Note that we cannot use\n+     gen_lowpart_common since it can do the wrong thing when\n+     RELOADREG has a multi-word mode.  Note that RELOADREG\n+     must always be a REG here.  */\n+\n+  if (GET_MODE (reloadreg) != mode)\n+    reloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n+  while (GET_CODE (oldequiv) == SUBREG && GET_MODE (oldequiv) != mode)\n+    oldequiv = SUBREG_REG (oldequiv);\n+  if (GET_MODE (oldequiv) != VOIDmode\n+      && mode != GET_MODE (oldequiv))\n+    oldequiv = gen_rtx_SUBREG (mode, oldequiv, 0);\n+\n+  /* Switch to the right place to emit the reload insns.  */\n+  switch (rl->when_needed)\n+    {\n+    case RELOAD_OTHER:\n+      where = &other_input_reload_insns;\n+      break;\n+    case RELOAD_FOR_INPUT:\n+      where = &input_reload_insns[rl->opnum];\n+      break;\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      where = &input_address_reload_insns[rl->opnum];\n+      break;\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n+      where = &inpaddr_address_reload_insns[rl->opnum];\n+      break;\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      where = &output_address_reload_insns[rl->opnum];\n+      break;\n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n+      where = &outaddr_address_reload_insns[rl->opnum];\n+      break;\n+    case RELOAD_FOR_OPERAND_ADDRESS:\n+      where = &operand_reload_insns;\n+      break;\n+    case RELOAD_FOR_OPADDR_ADDR:\n+      where = &other_operand_reload_insns;\n+      break;\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      where = &other_input_address_reload_insns;\n+      break;\n+    default:\n+      abort ();\n+    }\n \n-  /* Now output the instructions to copy the data into and out of the\n-     reload registers.  Do these in the order that the reloads were reported,\n-     since reloads of base and index registers precede reloads of operands\n-     and the operands may need the base and index registers reloaded.  */\n+  push_to_sequence (*where);\n \n-  for (j = 0; j < n_reloads; j++)\n+  /* Auto-increment addresses must be reloaded in a special way.  */\n+  if (rl->out && ! rl->out_reg)\n     {\n-      register rtx old;\n-      rtx oldequiv_reg = 0;\n-      rtx this_reload_insn = 0;\n-      int expect_occurrences = 1;\n-\n-      if (rld[j].reg_rtx\n-\t  && REGNO (rld[j].reg_rtx) < FIRST_PSEUDO_REGISTER)\n-\tnew_spill_reg_store[REGNO (rld[j].reg_rtx)] = 0;\n+      /* We are not going to bother supporting the case where a\n+\t incremented register can't be copied directly from\n+\t OLDEQUIV since this seems highly unlikely.  */\n+      if (rl->secondary_in_reload >= 0)\n+\tabort ();\n \n-      old = (rld[j].in && GET_CODE (rld[j].in) == MEM\n-\t     ? rld[j].in_reg : rld[j].in);\n+      if (reload_inherited[j])\n+\toldequiv = reloadreg;\n \n-      if (old != 0\n-\t  /* AUTO_INC reloads need to be handled even if inherited.  We got an\n-\t     AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */\n-\t  && (! reload_inherited[j] || (rld[j].out && ! rld[j].out_reg))\n-\t  && ! rtx_equal_p (rld[j].reg_rtx, old)\n-\t  && rld[j].reg_rtx != 0)\n-\t{\n-\t  register rtx reloadreg = rld[j].reg_rtx;\n-\t  rtx oldequiv = 0;\n-\t  enum machine_mode mode;\n-\t  rtx *where;\n-\n-\t  /* Determine the mode to reload in.\n-\t     This is very tricky because we have three to choose from.\n-\t     There is the mode the insn operand wants (rld[J].inmode).\n-\t     There is the mode of the reload register RELOADREG.\n-\t     There is the intrinsic mode of the operand, which we could find\n-\t     by stripping some SUBREGs.\n-\t     It turns out that RELOADREG's mode is irrelevant:\n-\t     we can change that arbitrarily.\n-\n-\t     Consider (SUBREG:SI foo:QI) as an operand that must be SImode;\n-\t     then the reload reg may not support QImode moves, so use SImode.\n-\t     If foo is in memory due to spilling a pseudo reg, this is safe,\n-\t     because the QImode value is in the least significant part of a\n-\t     slot big enough for a SImode.  If foo is some other sort of\n-\t     memory reference, then it is impossible to reload this case,\n-\t     so previous passes had better make sure this never happens.\n-\n-\t     Then consider a one-word union which has SImode and one of its\n-\t     members is a float, being fetched as (SUBREG:SF union:SI).\n-\t     We must fetch that as SFmode because we could be loading into\n-\t     a float-only register.  In this case OLD's mode is correct.\n-\n-\t     Consider an immediate integer: it has VOIDmode.  Here we need\n-\t     to get a mode from something else.\n-\n-\t     In some cases, there is a fourth mode, the operand's\n-\t     containing mode.  If the insn specifies a containing mode for\n-\t     this operand, it overrides all others.\n-\n-\t     I am not sure whether the algorithm here is always right,\n-\t     but it does the right things in those cases.  */\n-\n-\t  mode = GET_MODE (old);\n-\t  if (mode == VOIDmode)\n-\t    mode = rld[j].inmode;\n+      old = XEXP (rl->in_reg, 0);\n \n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t  /* If we need a secondary register for this operation, see if\n-\t     the value is already in a register in that class.  Don't\n-\t     do this if the secondary register will be used as a scratch\n-\t     register.  */\n-\n-\t  if (rld[j].secondary_in_reload >= 0\n-\t      && rld[j].secondary_in_icode == CODE_FOR_nothing\n-\t      && optimize)\n-\t    oldequiv\n-\t      = find_equiv_reg (old, insn,\n-\t\t\t\trld[rld[j].secondary_in_reload].class,\n-\t\t\t\t-1, NULL_PTR, 0, mode);\n-#endif\n+      if (optimize && GET_CODE (oldequiv) == REG\n+\t  && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n+\t  && spill_reg_store[REGNO (oldequiv)]\n+\t  && GET_CODE (old) == REG\n+\t  && (dead_or_set_p (insn,\n+\t\t\t     spill_reg_stored_to[REGNO (oldequiv)])\n+\t      || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n+\t\t\t      old)))\n+\tdelete_output_reload (insn, j, REGNO (oldequiv));\n+\n+      /* Prevent normal processing of this reload.  */\n+      special = 1;\n+      /* Output a special code sequence for this case.  */\n+      new_spill_reg_store[REGNO (reloadreg)]\n+\t= inc_for_reload (reloadreg, oldequiv, rl->out,\n+\t\t\t  rl->inc);\n+    }\n \n-\t  /* If reloading from memory, see if there is a register\n-\t     that already holds the same value.  If so, reload from there.\n-\t     We can pass 0 as the reload_reg_p argument because\n-\t     any other reload has either already been emitted,\n-\t     in which case find_equiv_reg will see the reload-insn,\n-\t     or has yet to be emitted, in which case it doesn't matter\n-\t     because we will use this equiv reg right away.  */\n-\n-\t  if (oldequiv == 0 && optimize\n-\t      && (GET_CODE (old) == MEM\n-\t\t  || (GET_CODE (old) == REG\n-\t\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n-\t\t      && reg_renumber[REGNO (old)] < 0)))\n-\t    oldequiv = find_equiv_reg (old, insn, ALL_REGS,\n-\t\t\t\t       -1, NULL_PTR, 0, mode);\n-\n-\t  if (oldequiv)\n+  /* If we are reloading a pseudo-register that was set by the previous\n+     insn, see if we can get rid of that pseudo-register entirely\n+     by redirecting the previous insn into our reload register.  */\n+\n+  else if (optimize && GET_CODE (old) == REG\n+\t   && REGNO (old) >= FIRST_PSEUDO_REGISTER\n+\t   && dead_or_set_p (insn, old)\n+\t   /* This is unsafe if some other reload\n+\t      uses the same reg first.  */\n+\t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n+\t\t\t\t\t   rl->opnum,\n+\t\t\t\t\t   rl->when_needed,\n+\t\t\t\t\t   old, rl->out,\n+\t\t\t\t\t   j, 0))\n+    {\n+      rtx temp = PREV_INSN (insn);\n+      while (temp && GET_CODE (temp) == NOTE)\n+\ttemp = PREV_INSN (temp);\n+      if (temp\n+\t  && GET_CODE (temp) == INSN\n+\t  && GET_CODE (PATTERN (temp)) == SET\n+\t  && SET_DEST (PATTERN (temp)) == old\n+\t  /* Make sure we can access insn_operand_constraint.  */\n+\t  && asm_noperands (PATTERN (temp)) < 0\n+\t  /* This is unsafe if prev insn rejects our reload reg.  */\n+\t  && constraint_accepts_reg_p (insn_data[recog_memoized (temp)].operand[0].constraint,\n+\t\t\t\t       reloadreg)\n+\t  /* This is unsafe if operand occurs more than once in current\n+\t     insn.  Perhaps some occurrences aren't reloaded.  */\n+\t  && count_occurrences (PATTERN (insn), old) == 1\n+\t  /* Don't risk splitting a matching pair of operands.  */\n+\t  && ! reg_mentioned_p (old, SET_SRC (PATTERN (temp))))\n+\t{\n+\t  /* Store into the reload register instead of the pseudo.  */\n+\t  SET_DEST (PATTERN (temp)) = reloadreg;\n+\n+\t  /* If the previous insn is an output reload, the source is\n+\t     a reload register, and its spill_reg_store entry will\n+\t     contain the previous destination.  This is now\n+\t     invalid.  */\n+\t  if (GET_CODE (SET_SRC (PATTERN (temp))) == REG\n+\t      && REGNO (SET_SRC (PATTERN (temp))) < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      int regno = true_regnum (oldequiv);\n-\n-\t      /* Don't use OLDEQUIV if any other reload changes it at an\n-\t\t earlier stage of this insn or at this stage.  */\n-\t      if (! reload_reg_free_for_value_p (regno, rld[j].opnum,\n-\t\t\t\t\t\t rld[j].when_needed,\n-\t\t\t\t\t\t rld[j].in, const0_rtx, j,\n-\t\t\t\t\t\t 0))\n-\t\toldequiv = 0;\n-\n-\t      /* If it is no cheaper to copy from OLDEQUIV into the\n-\t\t reload register than it would be to move from memory,\n-\t\t don't use it. Likewise, if we need a secondary register\n-\t\t or memory.   */\n-\n-\t      if (oldequiv != 0\n-\t\t  && ((REGNO_REG_CLASS (regno) != rld[j].class\n-\t\t       && (REGISTER_MOVE_COST (REGNO_REG_CLASS (regno),\n-\t\t\t\t\t       rld[j].class)\n-\t\t\t   >= MEMORY_MOVE_COST (mode, rld[j].class, 1)))\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t\t      || (SECONDARY_INPUT_RELOAD_CLASS (rld[j].class,\n-\t\t\t\t\t\t\tmode, oldequiv)\n-\t\t\t  != NO_REGS)\n-#endif\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t\t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (regno),\n-\t\t\t\t\t\t  rld[j].class,\n-\t\t\t\t\t\t  mode)\n-#endif\n-\t\t      ))\n-\t\toldequiv = 0;\n+\t      spill_reg_store[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n+\t      spill_reg_stored_to[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n \t    }\n \n-\t  /* delete_output_reload is only invoked properly if old contains\n-\t     the original pseudo register.  Since this is replaced with a\n-\t     hard reg when RELOAD_OVERRIDE_IN is set, see if we can\n-\t     find the pseudo in RELOAD_IN_REG.  */\n-\t  if (oldequiv == 0\n-\t      && reload_override_in[j]\n-\t      && GET_CODE (rld[j].in_reg) == REG)\n+\t  /* If these are the only uses of the pseudo reg,\n+\t     pretend for GDB it lives in the reload reg we used.  */\n+\t  if (REG_N_DEATHS (REGNO (old)) == 1\n+\t      && REG_N_SETS (REGNO (old)) == 1)\n \t    {\n-\t      oldequiv = old;\n-\t      old = rld[j].in_reg;\n-\t    }\n-\t  if (oldequiv == 0)\n-\t    oldequiv = old;\n-\t  else if (GET_CODE (oldequiv) == REG)\n-\t    oldequiv_reg = oldequiv;\n-\t  else if (GET_CODE (oldequiv) == SUBREG)\n-\t    oldequiv_reg = SUBREG_REG (oldequiv);\n-\n-\t  /* If we are reloading from a register that was recently stored in\n-\t     with an output-reload, see if we can prove there was\n-\t     actually no need to store the old value in it.  */\n-\n-\t  if (optimize && GET_CODE (oldequiv) == REG\n-\t      && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n-\t      && spill_reg_store[REGNO (oldequiv)]\n-\t      && GET_CODE (old) == REG\n-\t      && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (oldequiv)])\n-\t\t  || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n-\t\t\t\t  rld[j].out_reg)))\n-\t    delete_output_reload (insn, j, REGNO (oldequiv));\n-\n-\t  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n-\t     then load RELOADREG from OLDEQUIV.  Note that we cannot use\n-\t     gen_lowpart_common since it can do the wrong thing when\n-\t     RELOADREG has a multi-word mode.  Note that RELOADREG\n-\t     must always be a REG here.  */\n-\n-\t  if (GET_MODE (reloadreg) != mode)\n-\t    reloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n-\t  while (GET_CODE (oldequiv) == SUBREG && GET_MODE (oldequiv) != mode)\n-\t    oldequiv = SUBREG_REG (oldequiv);\n-\t  if (GET_MODE (oldequiv) != VOIDmode\n-\t      && mode != GET_MODE (oldequiv))\n-\t    oldequiv = gen_rtx_SUBREG (mode, oldequiv, 0);\n-\n-\t  /* Switch to the right place to emit the reload insns.  */\n-\t  switch (rld[j].when_needed)\n-\t    {\n-\t    case RELOAD_OTHER:\n-\t      where = &other_input_reload_insns;\n-\t      break;\n-\t    case RELOAD_FOR_INPUT:\n-\t      where = &input_reload_insns[rld[j].opnum];\n-\t      break;\n-\t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t      where = &input_address_reload_insns[rld[j].opnum];\n-\t      break;\n-\t    case RELOAD_FOR_INPADDR_ADDRESS:\n-\t      where = &inpaddr_address_reload_insns[rld[j].opnum];\n-\t      break;\n-\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t      where = &output_address_reload_insns[rld[j].opnum];\n-\t      break;\n-\t    case RELOAD_FOR_OUTADDR_ADDRESS:\n-\t      where = &outaddr_address_reload_insns[rld[j].opnum];\n-\t      break;\n-\t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t      where = &operand_reload_insns;\n-\t      break;\n-\t    case RELOAD_FOR_OPADDR_ADDR:\n-\t      where = &other_operand_reload_insns;\n-\t      break;\n-\t    case RELOAD_FOR_OTHER_ADDRESS:\n-\t      where = &other_input_address_reload_insns;\n-\t      break;\n-\t    default:\n-\t      abort ();\n+\t      reg_renumber[REGNO (old)] = REGNO (rl->reg_rtx);\n+\t      alter_reg (REGNO (old), -1);\n \t    }\n+\t  return;\n+\t}\n+    }\n \n-\t  push_to_sequence (*where);\n-\t  special = 0;\n+  /* We can't do that, so output an insn to load RELOADREG.  */\n \n-\t  /* Auto-increment addresses must be reloaded in a special way.  */\n-\t  if (rld[j].out && ! rld[j].out_reg)\n-\t    {\n-\t      /* We are not going to bother supporting the case where a\n-\t\t incremented register can't be copied directly from\n-\t\t OLDEQUIV since this seems highly unlikely.  */\n-\t      if (rld[j].secondary_in_reload >= 0)\n-\t\tabort ();\n-\n-\t      if (reload_inherited[j])\n-\t\toldequiv = reloadreg;\n-\n-\t      old = XEXP (rld[j].in_reg, 0);\n-\n-\t      if (optimize && GET_CODE (oldequiv) == REG\n-\t\t  && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n-\t\t  && spill_reg_store[REGNO (oldequiv)]\n-\t\t  && GET_CODE (old) == REG\n-\t\t  && (dead_or_set_p (insn,\n-\t\t\t\t     spill_reg_stored_to[REGNO (oldequiv)])\n-\t\t      || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n-\t\t\t\t      old)))\n-\t\tdelete_output_reload (insn, j, REGNO (oldequiv));\n-\n-\t      /* Prevent normal processing of this reload.  */\n-\t      special = 1;\n-\t      /* Output a special code sequence for this case.  */\n-\t      new_spill_reg_store[REGNO (reloadreg)]\n-\t\t= inc_for_reload (reloadreg, oldequiv, rld[j].out,\n-\t\t\t\t  rld[j].inc);\n-\t    }\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+  /* If we have a secondary reload, pick up the secondary register\n+     and icode, if any.  If OLDEQUIV and OLD are different or\n+     if this is an in-out reload, recompute whether or not we\n+     still need a secondary register and what the icode should\n+     be.  If we still need a secondary register and the class or\n+     icode is different, go back to reloading from OLD if using\n+     OLDEQUIV means that we got the wrong type of register.  We\n+     cannot have different class or icode due to an in-out reload\n+     because we don't make such reloads when both the input and\n+     output need secondary reload registers.  */\n+\n+  if (rl->secondary_in_reload >= 0)\n+    {\n+      rtx second_reload_reg = 0;\n+      int secondary_reload = rl->secondary_in_reload;\n+      rtx real_oldequiv = oldequiv;\n+      rtx real_old = old;\n+      rtx tmp;\n+      enum insn_code icode;\n+\n+      /* If OLDEQUIV is a pseudo with a MEM, get the real MEM\n+\t and similarly for OLD.\n+\t See comments in get_secondary_reload in reload.c.  */\n+      /* If it is a pseudo that cannot be replaced with its\n+\t equivalent MEM, we must fall back to reload_in, which\n+\t will have all the necessary substitutions registered.\n+\t Likewise for a pseudo that can't be replaced with its\n+\t equivalent constant.\n+\n+\t Take extra care for subregs of such pseudos.  Note that\n+\t we cannot use reg_equiv_mem in this case because it is\n+\t not in the right mode.  */\n+\n+      tmp = oldequiv;\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG\n+\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n+\t  && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n+\t      || reg_equiv_constant[REGNO (tmp)] != 0))\n+\t{\n+\t  if (! reg_equiv_mem[REGNO (tmp)]\n+\t      || num_not_at_initial_offset\n+\t      || GET_CODE (oldequiv) == SUBREG)\n+\t    real_oldequiv = rl->in;\n+\t  else\n+\t    real_oldequiv = reg_equiv_mem[REGNO (tmp)];\n+\t}\n+\n+      tmp = old;\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG\n+\t  && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n+\t  && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n+\t      || reg_equiv_constant[REGNO (tmp)] != 0))\n+\t{\n+\t  if (! reg_equiv_mem[REGNO (tmp)]\n+\t      || num_not_at_initial_offset\n+\t      || GET_CODE (old) == SUBREG)\n+\t    real_old = rl->in;\n+\t  else\n+\t    real_old = reg_equiv_mem[REGNO (tmp)];\n+\t}\n+\n+      second_reload_reg = rld[secondary_reload].reg_rtx;\n+      icode = rl->secondary_in_icode;\n+\n+      if ((old != oldequiv && ! rtx_equal_p (old, oldequiv))\n+\t  || (rl->in != 0 && rl->out != 0))\n+\t{\n+\t  enum reg_class new_class\n+\t    = SECONDARY_INPUT_RELOAD_CLASS (rl->class,\n+\t\t\t\t\t    mode, real_oldequiv);\n \n-\t  /* If we are reloading a pseudo-register that was set by the previous\n-\t     insn, see if we can get rid of that pseudo-register entirely\n-\t     by redirecting the previous insn into our reload register.  */\n-\n-\t  else if (optimize && GET_CODE (old) == REG\n-\t\t   && REGNO (old) >= FIRST_PSEUDO_REGISTER\n-\t\t   && dead_or_set_p (insn, old)\n-\t\t   /* This is unsafe if some other reload\n-\t\t      uses the same reg first.  */\n-\t\t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n-\t\t\t\t\t\t   rld[j].opnum,\n-\t\t\t\t\t\t   rld[j].when_needed,\n-\t\t\t\t\t\t   old, rld[j].out,\n-\t\t\t\t\t\t   j, 0))\n+\t  if (new_class == NO_REGS)\n+\t    second_reload_reg = 0;\n+\t  else\n \t    {\n-\t      rtx temp = PREV_INSN (insn);\n-\t      while (temp && GET_CODE (temp) == NOTE)\n-\t\ttemp = PREV_INSN (temp);\n-\t      if (temp\n-\t\t  && GET_CODE (temp) == INSN\n-\t\t  && GET_CODE (PATTERN (temp)) == SET\n-\t\t  && SET_DEST (PATTERN (temp)) == old\n-\t\t  /* Make sure we can access insn_operand_constraint.  */\n-\t\t  && asm_noperands (PATTERN (temp)) < 0\n-\t\t  /* This is unsafe if prev insn rejects our reload reg.  */\n-\t\t  && constraint_accepts_reg_p (insn_data[recog_memoized (temp)].operand[0].constraint,\n-\t\t\t\t\t       reloadreg)\n-\t\t  /* This is unsafe if operand occurs more than once in current\n-\t\t     insn.  Perhaps some occurrences aren't reloaded.  */\n-\t\t  && count_occurrences (PATTERN (insn), old) == 1\n-\t\t  /* Don't risk splitting a matching pair of operands.  */\n-\t\t  && ! reg_mentioned_p (old, SET_SRC (PATTERN (temp))))\n+\t      enum insn_code new_icode;\n+\t      enum machine_mode new_mode;\n+\n+\t      if (! TEST_HARD_REG_BIT (reg_class_contents[(int) new_class],\n+\t\t\t\t       REGNO (second_reload_reg)))\n+\t\toldequiv = old, real_oldequiv = real_old;\n+\t      else\n \t\t{\n-\t\t  /* Store into the reload register instead of the pseudo.  */\n-\t\t  SET_DEST (PATTERN (temp)) = reloadreg;\n-\n-\t\t  /* If the previous insn is an output reload, the source is\n-\t\t     a reload register, and its spill_reg_store entry will\n-\t\t     contain the previous destination.  This is now\n-\t\t     invalid.  */\n-\t\t  if (GET_CODE (SET_SRC (PATTERN (temp))) == REG\n-\t\t      && REGNO (SET_SRC (PATTERN (temp))) < FIRST_PSEUDO_REGISTER)\n-\t\t    {\n-\t\t      spill_reg_store[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n-\t\t      spill_reg_stored_to[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n-\t\t    }\n+\t\t  new_icode = reload_in_optab[(int) mode];\n+\t\t  if (new_icode != CODE_FOR_nothing\n+\t\t      && ((insn_data[(int) new_icode].operand[0].predicate\n+\t\t\t   && ! ((*insn_data[(int) new_icode].operand[0].predicate)\n+\t\t\t\t (reloadreg, mode)))\n+\t\t\t  || (insn_data[(int) new_icode].operand[1].predicate\n+\t\t\t      && ! ((*insn_data[(int) new_icode].operand[1].predicate)\n+\t\t\t\t    (real_oldequiv, mode)))))\n+\t\t    new_icode = CODE_FOR_nothing;\n+\n+\t\t  if (new_icode == CODE_FOR_nothing)\n+\t\t    new_mode = mode;\n+\t\t  else\n+\t\t    new_mode = insn_data[(int) new_icode].operand[2].mode;\n \n-\t\t  /* If these are the only uses of the pseudo reg,\n-\t\t     pretend for GDB it lives in the reload reg we used.  */\n-\t\t  if (REG_N_DEATHS (REGNO (old)) == 1\n-\t\t      && REG_N_SETS (REGNO (old)) == 1)\n+\t\t  if (GET_MODE (second_reload_reg) != new_mode)\n \t\t    {\n-\t\t      reg_renumber[REGNO (old)] = REGNO (rld[j].reg_rtx);\n-\t\t      alter_reg (REGNO (old), -1);\n+\t\t      if (!HARD_REGNO_MODE_OK (REGNO (second_reload_reg),\n+\t\t\t\t\t       new_mode))\n+\t\t\toldequiv = old, real_oldequiv = real_old;\n+\t\t      else\n+\t\t\tsecond_reload_reg\n+\t\t\t  = gen_rtx_REG (new_mode,\n+\t\t\t\t\t REGNO (second_reload_reg));\n \t\t    }\n-\t\t  special = 1;\n \t\t}\n \t    }\n+\t}\n \n-\t  /* We can't do that, so output an insn to load RELOADREG.  */\n+      /* If we still need a secondary reload register, check\n+\t to see if it is being used as a scratch or intermediate\n+\t register and generate code appropriately.  If we need\n+\t a scratch register, use REAL_OLDEQUIV since the form of\n+\t the insn may depend on the actual address if it is\n+\t a MEM.  */\n \n-\t  if (! special)\n+      if (second_reload_reg)\n+\t{\n+\t  if (icode != CODE_FOR_nothing)\n \t    {\n-#ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t      rtx second_reload_reg = 0;\n-\t      enum insn_code icode;\n-\n-\t      /* If we have a secondary reload, pick up the secondary register\n-\t\t and icode, if any.  If OLDEQUIV and OLD are different or\n-\t\t if this is an in-out reload, recompute whether or not we\n-\t\t still need a secondary register and what the icode should\n-\t\t be.  If we still need a secondary register and the class or\n-\t\t icode is different, go back to reloading from OLD if using\n-\t\t OLDEQUIV means that we got the wrong type of register.  We\n-\t\t cannot have different class or icode due to an in-out reload\n-\t\t because we don't make such reloads when both the input and\n-\t\t output need secondary reload registers.  */\n-\n-\t      if (rld[j].secondary_in_reload >= 0)\n-\t\t{\n-\t\t  int secondary_reload = rld[j].secondary_in_reload;\n-\t\t  rtx real_oldequiv = oldequiv;\n-\t\t  rtx real_old = old;\n-\t\t  rtx tmp;\n-\n-\t\t  /* If OLDEQUIV is a pseudo with a MEM, get the real MEM\n-\t\t     and similarly for OLD.\n-\t\t     See comments in get_secondary_reload in reload.c.  */\n-\t\t  /* If it is a pseudo that cannot be replaced with its\n-\t\t     equivalent MEM, we must fall back to reload_in, which\n-\t\t     will have all the necessary substitutions registered.\n-\t\t     Likewise for a pseudo that can't be replaced with its\n-\t\t     equivalent constant.\n-\n-\t\t     Take extra care for subregs of such pseudos.  Note that\n-\t\t     we cannot use reg_equiv_mem in this case because it is\n-\t\t     not in the right mode.  */\n-\n-\t\t  tmp = oldequiv;\n-\t\t  if (GET_CODE (tmp) == SUBREG)\n-\t\t    tmp = SUBREG_REG (tmp);\n-\t\t  if (GET_CODE (tmp) == REG\n-\t\t      && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n-\t\t      && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n-\t\t\t  || reg_equiv_constant[REGNO (tmp)] != 0))\n-\t\t    {\n-\t\t      if (! reg_equiv_mem[REGNO (tmp)]\n-\t\t\t  || num_not_at_initial_offset\n-\t\t\t  || GET_CODE (oldequiv) == SUBREG)\n-\t\t\treal_oldequiv = rld[j].in;\n-\t\t      else\n-\t\t\treal_oldequiv = reg_equiv_mem[REGNO (tmp)];\n-\t\t    }\n+\t      emit_insn (GEN_FCN (icode) (reloadreg, real_oldequiv,\n+\t\t\t\t\t  second_reload_reg));\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* See if we need a scratch register to load the\n+\t\t intermediate register (a tertiary reload).  */\n+\t      enum insn_code tertiary_icode\n+\t\t= rld[secondary_reload].secondary_in_icode;\n \n-\t\t  tmp = old;\n-\t\t  if (GET_CODE (tmp) == SUBREG)\n-\t\t    tmp = SUBREG_REG (tmp);\n-\t\t  if (GET_CODE (tmp) == REG\n-\t\t      && REGNO (tmp) >= FIRST_PSEUDO_REGISTER\n-\t\t      && (reg_equiv_memory_loc[REGNO (tmp)] != 0\n-\t\t\t  || reg_equiv_constant[REGNO (tmp)] != 0))\n-\t\t    {\n-\t\t      if (! reg_equiv_mem[REGNO (tmp)]\n-\t\t\t  || num_not_at_initial_offset\n-\t\t\t  || GET_CODE (old) == SUBREG)\n-\t\t\treal_old = rld[j].in;\n-\t\t      else\n-\t\t\treal_old = reg_equiv_mem[REGNO (tmp)];\n-\t\t    }\n+\t      if (tertiary_icode != CODE_FOR_nothing)\n+\t\t{\n+\t\t  rtx third_reload_reg\n+\t\t    = rld[rld[secondary_reload].secondary_in_reload].reg_rtx;\n \n-\t\t  second_reload_reg = rld[secondary_reload].reg_rtx;\n-\t\t  icode = rld[j].secondary_in_icode;\n+\t\t  emit_insn ((GEN_FCN (tertiary_icode)\n+\t\t\t      (second_reload_reg, real_oldequiv,\n+\t\t\t       third_reload_reg)));\n+\t\t}\n+\t      else\n+\t\tgen_reload (second_reload_reg, real_oldequiv,\n+\t\t\t    rl->opnum,\n+\t\t\t    rl->when_needed);\n \n-\t\t  if ((old != oldequiv && ! rtx_equal_p (old, oldequiv))\n-\t\t      || (rld[j].in != 0 && rld[j].out != 0))\n-\t\t    {\n-\t\t      enum reg_class new_class\n-\t\t\t= SECONDARY_INPUT_RELOAD_CLASS (rld[j].class,\n-\t\t\t\t\t\t\tmode, real_oldequiv);\n+\t      oldequiv = second_reload_reg;\n+\t    }\n+\t}\n+    }\n+#endif\n \n-\t\t      if (new_class == NO_REGS)\n-\t\t\tsecond_reload_reg = 0;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  enum insn_code new_icode;\n-\t\t\t  enum machine_mode new_mode;\n+  if (! rtx_equal_p (reloadreg, oldequiv))\n+    {\n+      rtx real_oldequiv = oldequiv;\n+\n+      if ((GET_CODE (oldequiv) == REG\n+\t   && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n+\t   && (reg_equiv_memory_loc[REGNO (oldequiv)] != 0\n+\t       || reg_equiv_constant[REGNO (oldequiv)] != 0))\n+\t  || (GET_CODE (oldequiv) == SUBREG\n+\t      && GET_CODE (SUBREG_REG (oldequiv)) == REG\n+\t      && (REGNO (SUBREG_REG (oldequiv))\n+\t\t  >= FIRST_PSEUDO_REGISTER)\n+\t      && ((reg_equiv_memory_loc\n+\t\t   [REGNO (SUBREG_REG (oldequiv))] != 0)\n+\t\t  || (reg_equiv_constant\n+\t\t      [REGNO (SUBREG_REG (oldequiv))] != 0))))\n+\treal_oldequiv = rl->in;\n+      gen_reload (reloadreg, real_oldequiv, rl->opnum,\n+\t\t  rl->when_needed);\n+    }\n \n-\t\t\t  if (! TEST_HARD_REG_BIT (reg_class_contents[(int) new_class],\n-\t\t\t\t\t\t   REGNO (second_reload_reg)))\n-\t\t\t    oldequiv = old, real_oldequiv = real_old;\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      new_icode = reload_in_optab[(int) mode];\n-\t\t\t      if (new_icode != CODE_FOR_nothing\n-\t\t\t\t  && ((insn_data[(int) new_icode].operand[0].predicate\n-\t\t\t\t       && ! ((*insn_data[(int) new_icode].operand[0].predicate)\n-\t\t\t\t\t     (reloadreg, mode)))\n-\t\t\t\t      || (insn_data[(int) new_icode].operand[1].predicate\n-\t\t\t\t\t  && ! ((*insn_data[(int) new_icode].operand[1].predicate)\n-\t\t\t\t\t\t(real_oldequiv, mode)))))\n-\t\t\t\tnew_icode = CODE_FOR_nothing;\n-\n-\t\t\t      if (new_icode == CODE_FOR_nothing)\n-\t\t\t\tnew_mode = mode;\n-\t\t\t      else\n-\t\t\t\tnew_mode = insn_data[(int) new_icode].operand[2].mode;\n+  /* End this sequence.  */\n+  *where = get_insns ();\n+  end_sequence ();\n \n-\t\t\t      if (GET_MODE (second_reload_reg) != new_mode)\n-\t\t\t\t{\n-\t\t\t\t  if (!HARD_REGNO_MODE_OK (REGNO (second_reload_reg),\n-\t\t\t\t\t\t\t   new_mode))\n-\t\t\t\t    oldequiv = old, real_oldequiv = real_old;\n-\t\t\t\t  else\n-\t\t\t\t    second_reload_reg\n-\t\t\t\t      = gen_rtx_REG (new_mode,\n-\t\t\t\t\t\t     REGNO (second_reload_reg));\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n+  /* Update reload_override_in so that delete_address_reloads_1\n+     can see the actual register usage.  */\n+  if (oldequiv_reg)\n+    reload_override_in[j] = oldequiv;\n+}\n \n-\t\t  /* If we still need a secondary reload register, check\n-\t\t     to see if it is being used as a scratch or intermediate\n-\t\t     register and generate code appropriately.  If we need\n-\t\t     a scratch register, use REAL_OLDEQUIV since the form of\n-\t\t     the insn may depend on the actual address if it is\n-\t\t     a MEM.  */\n+/* Generate insns to for the output reload RL, which is for the insn described\n+   by CHAIN and has the number J.  */\n+static void\n+emit_output_reload_insns (chain, rl, j)\n+     struct insn_chain *chain;\n+     struct reload *rl;\n+     int j;\n+{\n+  rtx reloadreg = rl->reg_rtx;\n+  rtx insn = chain->insn;\n+  int special = 0;\n+  rtx old = rl->out;\n+  enum machine_mode mode = GET_MODE (old);\n+  rtx p;\n \n-\t\t  if (second_reload_reg)\n-\t\t    {\n-\t\t      if (icode != CODE_FOR_nothing)\n-\t\t\t{\n-\t\t\t  emit_insn (GEN_FCN (icode) (reloadreg, real_oldequiv,\n-\t\t\t\t\t\t      second_reload_reg));\n-\t\t\t  special = 1;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* See if we need a scratch register to load the\n-\t\t\t     intermediate register (a tertiary reload).  */\n-\t\t\t  enum insn_code tertiary_icode\n-\t\t\t    = rld[secondary_reload].secondary_in_icode;\n+  if (rl->when_needed == RELOAD_OTHER)\n+    start_sequence ();\n+  else\n+    push_to_sequence (output_reload_insns[rl->opnum]);\n \n-\t\t\t  if (tertiary_icode != CODE_FOR_nothing)\n-\t\t\t    {\n-\t\t\t      rtx third_reload_reg\n-\t\t\t\t= rld[rld[secondary_reload].secondary_in_reload].reg_rtx;\n+  /* Determine the mode to reload in.\n+     See comments above (for input reloading).  */\n \n-\t\t\t      emit_insn ((GEN_FCN (tertiary_icode)\n-\t\t\t\t\t  (second_reload_reg, real_oldequiv,\n-\t\t\t\t\t   third_reload_reg)));\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    gen_reload (second_reload_reg, real_oldequiv,\n-\t\t\t\t\trld[j].opnum,\n-\t\t\t\t\trld[j].when_needed);\n+  if (mode == VOIDmode)\n+    {\n+      /* VOIDmode should never happen for an output.  */\n+      if (asm_noperands (PATTERN (insn)) < 0)\n+\t/* It's the compiler's fault.  */\n+\tfatal_insn (\"VOIDmode on an output\", insn);\n+      error_for_asm (insn, \"output operand is constant in `asm'\");\n+      /* Prevent crash--use something we know is valid.  */\n+      mode = word_mode;\n+      old = gen_rtx_REG (mode, REGNO (reloadreg));\n+    }\n \n-\t\t\t  oldequiv = second_reload_reg;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-#endif\n+  if (GET_MODE (reloadreg) != mode)\n+    reloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n \n-\t      if (! special && ! rtx_equal_p (reloadreg, oldequiv))\n-\t\t{\n-\t\t  rtx real_oldequiv = oldequiv;\n-\n-\t\t  if ((GET_CODE (oldequiv) == REG\n-\t\t       && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n-\t\t       && (reg_equiv_memory_loc[REGNO (oldequiv)] != 0\n-\t\t\t   || reg_equiv_constant[REGNO (oldequiv)] != 0))\n-\t\t      || (GET_CODE (oldequiv) == SUBREG\n-\t\t\t  && GET_CODE (SUBREG_REG (oldequiv)) == REG\n-\t\t\t  && (REGNO (SUBREG_REG (oldequiv))\n-\t\t\t      >= FIRST_PSEUDO_REGISTER)\n-\t\t\t  && ((reg_equiv_memory_loc\n-\t\t\t       [REGNO (SUBREG_REG (oldequiv))] != 0)\n-\t\t\t      || (reg_equiv_constant\n-\t\t\t\t  [REGNO (SUBREG_REG (oldequiv))] != 0))))\n-\t\t    real_oldequiv = rld[j].in;\n-\t\t  gen_reload (reloadreg, real_oldequiv, rld[j].opnum,\n-\t\t\t      rld[j].when_needed);\n-\t\t}\n+#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \n-\t    }\n+  /* If we need two reload regs, set RELOADREG to the intermediate\n+     one, since it will be stored into OLD.  We might need a secondary\n+     register only for an input reload, so check again here.  */\n \n-\t  this_reload_insn = get_last_insn ();\n-\t  /* End this sequence.  */\n-\t  *where = get_insns ();\n-\t  end_sequence ();\n+  if (rl->secondary_out_reload >= 0)\n+    {\n+      rtx real_old = old;\n \n-\t  /* Update reload_override_in so that delete_address_reloads_1\n-\t     can see the actual register usage.  */\n-\t  if (oldequiv_reg)\n-\t    reload_override_in[j] = oldequiv;\n-\t}\n+      if (GET_CODE (old) == REG && REGNO (old) >= FIRST_PSEUDO_REGISTER\n+\t  && reg_equiv_mem[REGNO (old)] != 0)\n+\treal_old = reg_equiv_mem[REGNO (old)];\n \n-      /* When inheriting a wider reload, we have a MEM in rld[j].in,\n-\t e.g. inheriting a SImode output reload for\n-\t (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */\n-      if (optimize && reload_inherited[j] && rld[j].in\n-\t  && GET_CODE (rld[j].in) == MEM\n-\t  && GET_CODE (rld[j].in_reg) == MEM\n-\t  && reload_spill_index[j] >= 0\n-\t  && TEST_HARD_REG_BIT (reg_reloaded_valid, reload_spill_index[j]))\n+      if ((SECONDARY_OUTPUT_RELOAD_CLASS (rl->class,\n+\t\t\t\t\t  mode, real_old)\n+\t   != NO_REGS))\n \t{\n-\t  expect_occurrences\n-\t    = count_occurrences (PATTERN (insn), rld[j].in) == 1 ? 0 : -1;\n-\t  rld[j].in\n-\t    = regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n-\t}\n-\n-      /* If we are reloading a register that was recently stored in with an\n-\t output-reload, see if we can prove there was\n-\t actually no need to store the old value in it.  */\n+\t  rtx second_reloadreg = reloadreg;\n+\t  reloadreg = rld[rl->secondary_out_reload].reg_rtx;\n \n-      if (optimize\n-\t  && (reload_inherited[j] || reload_override_in[j])\n-\t  && rld[j].reg_rtx\n-\t  && GET_CODE (rld[j].reg_rtx) == REG\n-\t  && spill_reg_store[REGNO (rld[j].reg_rtx)] != 0\n-#if 0\n-\t  /* There doesn't seem to be any reason to restrict this to pseudos\n-\t     and doing so loses in the case where we are copying from a\n-\t     register of the wrong class.  */\n-\t  && (REGNO (spill_reg_stored_to[REGNO (rld[j].reg_rtx)])\n-\t      >= FIRST_PSEUDO_REGISTER)\n-#endif\n-\t  /* The insn might have already some references to stackslots\n-\t     replaced by MEMs, while reload_out_reg still names the\n-\t     original pseudo.  */\n-\t  && (dead_or_set_p (insn,\n-\t\t\t     spill_reg_stored_to[REGNO (rld[j].reg_rtx)])\n-\t      || rtx_equal_p (spill_reg_stored_to[REGNO (rld[j].reg_rtx)],\n-\t\t\t      rld[j].out_reg)))\n-\tdelete_output_reload (insn, j, REGNO (rld[j].reg_rtx));\n+\t  /* See if RELOADREG is to be used as a scratch register\n+\t     or as an intermediate register.  */\n+\t  if (rl->secondary_out_icode != CODE_FOR_nothing)\n+\t    {\n+\t      emit_insn ((GEN_FCN (rl->secondary_out_icode)\n+\t\t\t  (real_old, second_reloadreg, reloadreg)));\n+\t      special = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* See if we need both a scratch and intermediate reload\n+\t\t register.  */\n \n-      /* Input-reloading is done.  Now do output-reloading,\n-\t storing the value from the reload-register after the main insn\n-\t if rld[j].out is nonzero.\n+\t      int secondary_reload = rl->secondary_out_reload;\n+\t      enum insn_code tertiary_icode\n+\t\t= rld[secondary_reload].secondary_out_icode;\n \n-\t ??? At some point we need to support handling output reloads of\n-\t JUMP_INSNs or insns that set cc0.  */\n+\t      if (GET_MODE (reloadreg) != mode)\n+\t\treloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n \n-      /* If this is an output reload that stores something that is\n-\t not loaded in this same reload, see if we can eliminate a previous\n-\t store.  */\n-      {\n-\trtx pseudo = rld[j].out_reg;\n+\t      if (tertiary_icode != CODE_FOR_nothing)\n+\t\t{\n+\t\t  rtx third_reloadreg\n+\t\t    = rld[rld[secondary_reload].secondary_out_reload].reg_rtx;\n+\t\t  rtx tem;\n+\n+\t\t  /* Copy primary reload reg to secondary reload reg.\n+\t\t     (Note that these have been swapped above, then\n+\t\t     secondary reload reg to OLD using our insn.  */\n+\n+\t\t  /* If REAL_OLD is a paradoxical SUBREG, remove it\n+\t\t     and try to put the opposite SUBREG on\n+\t\t     RELOADREG.  */\n+\t\t  if (GET_CODE (real_old) == SUBREG\n+\t\t      && (GET_MODE_SIZE (GET_MODE (real_old))\n+\t\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (real_old))))\n+\t\t      && 0 != (tem = gen_lowpart_common\n+\t\t\t       (GET_MODE (SUBREG_REG (real_old)),\n+\t\t\t\treloadreg)))\n+\t\t    real_old = SUBREG_REG (real_old), reloadreg = tem;\n+\n+\t\t  gen_reload (reloadreg, second_reloadreg,\n+\t\t\t      rl->opnum, rl->when_needed);\n+\t\t  emit_insn ((GEN_FCN (tertiary_icode)\n+\t\t\t      (real_old, reloadreg, third_reloadreg)));\n+\t\t  special = 1;\n+\t\t}\n \n-\tif (pseudo\n-\t    && GET_CODE (pseudo) == REG\n-\t    && ! rtx_equal_p (rld[j].in_reg, pseudo)\n-\t    && REGNO (pseudo) >= FIRST_PSEUDO_REGISTER\n-\t    && reg_last_reload_reg[REGNO (pseudo)])\n-\t  {\n-\t    int pseudo_no = REGNO (pseudo);\n-\t    int last_regno = REGNO (reg_last_reload_reg[pseudo_no]);\n-\n-\t    /* We don't need to test full validity of last_regno for\n-\t       inherit here; we only want to know if the store actually\n-\t       matches the pseudo.  */\n-\t    if (reg_reloaded_contents[last_regno] == pseudo_no\n-\t\t&& spill_reg_store[last_regno]\n-\t\t&& rtx_equal_p (pseudo, spill_reg_stored_to[last_regno]))\n-\t      delete_output_reload (insn, j, last_regno);\n-\t  }\n-      }\n+\t      else\n+\t\t/* Copy between the reload regs here and then to\n+\t\t   OUT later.  */\n \n-      old = rld[j].out_reg;\n-      if (old != 0\n-\t  && rld[j].reg_rtx != old\n-\t  && rld[j].reg_rtx != 0)\n-\t{\n-\t  register rtx reloadreg = rld[j].reg_rtx;\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t  register rtx second_reloadreg = 0;\n-#endif\n-\t  rtx note, p;\n-\t  enum machine_mode mode;\n-\t  int special = 0;\n-\n-\t  /* An output operand that dies right away does need a reload,\n-\t     but need not be copied from it.  Show the new location in the\n-\t     REG_UNUSED note.  */\n-\t  if ((GET_CODE (old) == REG || GET_CODE (old) == SCRATCH)\n-\t      && (note = find_reg_note (insn, REG_UNUSED, old)) != 0)\n-\t    {\n-\t      XEXP (note, 0) = rld[j].reg_rtx;\n-\t      continue;\n-\t    }\n-\t  /* Likewise for a SUBREG of an operand that dies.  */\n-\t  else if (GET_CODE (old) == SUBREG\n-\t\t   && GET_CODE (SUBREG_REG (old)) == REG\n-\t\t   && 0 != (note = find_reg_note (insn, REG_UNUSED,\n-\t\t\t\t\t\t  SUBREG_REG (old))))\n-\t    {\n-\t      XEXP (note, 0) = gen_lowpart_common (GET_MODE (old),\n-\t\t\t\t\t\t   rld[j].reg_rtx);\n-\t      continue;\n+\t\tgen_reload (reloadreg, second_reloadreg,\n+\t\t\t    rl->opnum, rl->when_needed);\n \t    }\n-\t  else if (GET_CODE (old) == SCRATCH)\n-\t    /* If we aren't optimizing, there won't be a REG_UNUSED note,\n-\t       but we don't want to make an output reload.  */\n-\t    continue;\n-\n-#if 0\n-\t  /* Strip off of OLD any size-increasing SUBREGs such as\n-\t     (SUBREG:SI foo:QI 0).  */\n-\n-\t  while (GET_CODE (old) == SUBREG && SUBREG_WORD (old) == 0\n-\t\t && (GET_MODE_SIZE (GET_MODE (old))\n-\t\t     > GET_MODE_SIZE (GET_MODE (SUBREG_REG (old)))))\n-\t    old = SUBREG_REG (old);\n+\t}\n+    }\n #endif\n \n-\t  /* If is a JUMP_INSN, we can't support output reloads yet.  */\n-\t  if (GET_CODE (insn) == JUMP_INSN)\n-\t    abort ();\n+  /* Output the last reload insn.  */\n+  if (! special)\n+    {\n+      rtx set;\n+\n+      /* Don't output the last reload if OLD is not the dest of\n+\t INSN and is in the src and is clobbered by INSN. */\n+      if (! flag_expensive_optimizations\n+\t  || GET_CODE (old) != REG\n+\t  || !(set = single_set (insn))\n+\t  || rtx_equal_p (old, SET_DEST (set))\n+\t  || !reg_mentioned_p (old, SET_SRC (set))\n+\t  || !regno_clobbered_p (REGNO (old), insn))\n+\tgen_reload (old, reloadreg, rl->opnum,\n+\t\t    rl->when_needed);\n+    }\n \n-\t  if (rld[j].when_needed == RELOAD_OTHER)\n-\t    start_sequence ();\n-\t  else\n-\t    push_to_sequence (output_reload_insns[rld[j].opnum]);\n+  /* Look at all insns we emitted, just to be safe.  */\n+  for (p = get_insns (); p; p = NEXT_INSN (p))\n+    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n+      {\n+\trtx pat = PATTERN (p);\n \n-\t  old = rld[j].out;\n+\t/* If this output reload doesn't come from a spill reg,\n+\t   clear any memory of reloaded copies of the pseudo reg.\n+\t   If this output reload comes from a spill reg,\n+\t   reg_has_output_reload will make this do nothing.  */\n+\tnote_stores (pat, forget_old_reloads_1, NULL);\n \n-\t  /* Determine the mode to reload in.\n-\t     See comments above (for input reloading).  */\n+\tif (reg_mentioned_p (rl->reg_rtx, pat))\n+\t  {\n+\t    rtx set = single_set (insn);\n+\t    if (reload_spill_index[j] < 0\n+\t\t&& set\n+\t\t&& SET_SRC (set) == rl->reg_rtx)\n+\t      {\n+\t\tint src = REGNO (SET_SRC (set));\n \n-\t  mode = GET_MODE (old);\n-\t  if (mode == VOIDmode)\n-\t    {\n-\t      /* VOIDmode should never happen for an output.  */\n-\t      if (asm_noperands (PATTERN (insn)) < 0)\n-\t\t/* It's the compiler's fault.  */\n-\t\tfatal_insn (\"VOIDmode on an output\", insn);\n-\t      error_for_asm (insn, \"output operand is constant in `asm'\");\n-\t      /* Prevent crash--use something we know is valid.  */\n-\t      mode = word_mode;\n-\t      old = gen_rtx_REG (mode, REGNO (reloadreg));\n-\t    }\n+\t\treload_spill_index[j] = src;\n+\t\tSET_HARD_REG_BIT (reg_is_output_reload, src);\n+\t\tif (find_regno_note (insn, REG_DEAD, src))\n+\t\t  SET_HARD_REG_BIT (reg_reloaded_died, src);\n+\t      }\n+\t    if (REGNO (rl->reg_rtx) < FIRST_PSEUDO_REGISTER)\n+\t      {\n+\t\tint s = rl->secondary_out_reload;\n+\t\tset = single_set (p);\n+\t\t/* If this reload copies only to the secondary reload\n+\t\t   register, the secondary reload does the actual\n+\t\t   store.  */\n+\t\tif (s >= 0 && set == NULL_RTX)\n+\t\t  ; /* We can't tell what function the secondary reload\n+\t\t       has and where the actual store to the pseudo is\n+\t\t       made; leave new_spill_reg_store alone.  */\n+\t\telse if (s >= 0\n+\t\t\t && SET_SRC (set) == rl->reg_rtx\n+\t\t\t && SET_DEST (set) == rld[s].reg_rtx)\n+\t\t  {\n+\t\t    /* Usually the next instruction will be the\n+\t\t       secondary reload insn;  if we can confirm\n+\t\t       that it is, setting new_spill_reg_store to\n+\t\t       that insn will allow an extra optimization.  */\n+\t\t    rtx s_reg = rld[s].reg_rtx;\n+\t\t    rtx next = NEXT_INSN (p);\n+\t\t    rld[s].out = rl->out;\n+\t\t    rld[s].out_reg = rl->out_reg;\n+\t\t    set = single_set (next);\n+\t\t    if (set && SET_SRC (set) == s_reg\n+\t\t\t&& ! new_spill_reg_store[REGNO (s_reg)])\n+\t\t      {\n+\t\t\tSET_HARD_REG_BIT (reg_is_output_reload,\n+\t\t\t\t\t  REGNO (s_reg));\n+\t\t\tnew_spill_reg_store[REGNO (s_reg)] = next;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  new_spill_reg_store[REGNO (rl->reg_rtx)] = p;\n+\t      }\n+\t  }\n+      }\n \n-\t  if (GET_MODE (reloadreg) != mode)\n-\t    reloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n+  if (rl->when_needed == RELOAD_OTHER)\n+    {\n+      emit_insns (other_output_reload_insns[rl->opnum]);\n+      other_output_reload_insns[rl->opnum] = get_insns ();\n+    }\n+  else\n+    output_reload_insns[rl->opnum] = get_insns ();\n \n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n+  end_sequence (); \n+}\n \n-\t  /* If we need two reload regs, set RELOADREG to the intermediate\n-\t     one, since it will be stored into OLD.  We might need a secondary\n-\t     register only for an input reload, so check again here.  */\n+/* Do input reloading for reload RL, which is for the insn described by CHAIN\n+   and has the number J.  */\n+static void\n+do_input_reload (chain, rl, j)\n+     struct insn_chain *chain;\n+     struct reload *rl;\n+     int j;\n+{\n+  int expect_occurrences = 1;\n+  rtx insn = chain->insn;\n+  rtx old = (rl->in && GET_CODE (rl->in) == MEM\n+\t     ? rl->in_reg : rl->in);\n+\n+  if (old != 0\n+      /* AUTO_INC reloads need to be handled even if inherited.  We got an\n+\t AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */\n+      && (! reload_inherited[j] || (rl->out && ! rl->out_reg))\n+      && ! rtx_equal_p (rl->reg_rtx, old)\n+      && rl->reg_rtx != 0)\n+    {\n+      emit_input_reload_insns (chain, rld + j, old, j);\n+    }\n \n-\t  if (rld[j].secondary_out_reload >= 0)\n-\t    {\n-\t      rtx real_old = old;\n+  /* When inheriting a wider reload, we have a MEM in rl->in,\n+     e.g. inheriting a SImode output reload for\n+     (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */\n+  if (optimize && reload_inherited[j] && rl->in\n+      && GET_CODE (rl->in) == MEM\n+      && GET_CODE (rl->in_reg) == MEM\n+      && reload_spill_index[j] >= 0\n+      && TEST_HARD_REG_BIT (reg_reloaded_valid, reload_spill_index[j]))\n+    {\n+      expect_occurrences\n+\t= count_occurrences (PATTERN (insn), rl->in) == 1 ? 0 : -1;\n+      rl->in\n+\t= regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n+    }\n \n-\t      if (GET_CODE (old) == REG && REGNO (old) >= FIRST_PSEUDO_REGISTER\n-\t\t  && reg_equiv_mem[REGNO (old)] != 0)\n-\t\treal_old = reg_equiv_mem[REGNO (old)];\n+  /* If we are reloading a register that was recently stored in with an\n+     output-reload, see if we can prove there was\n+     actually no need to store the old value in it.  */\n \n-\t      if((SECONDARY_OUTPUT_RELOAD_CLASS (rld[j].class,\n-\t\t\t\t\t\t mode, real_old)\n-\t\t  != NO_REGS))\n-\t\t{\n-\t\t  second_reloadreg = reloadreg;\n-\t\t  reloadreg = rld[rld[j].secondary_out_reload].reg_rtx;\n+  if (optimize\n+      && (reload_inherited[j] || reload_override_in[j])\n+      && rl->reg_rtx\n+      && GET_CODE (rl->reg_rtx) == REG\n+      && spill_reg_store[REGNO (rl->reg_rtx)] != 0\n+#if 0\n+      /* There doesn't seem to be any reason to restrict this to pseudos\n+\t and doing so loses in the case where we are copying from a\n+\t register of the wrong class.  */\n+      && (REGNO (spill_reg_stored_to[REGNO (rl->reg_rtx)])\n+\t  >= FIRST_PSEUDO_REGISTER)\n+#endif\n+      /* The insn might have already some references to stackslots\n+\t replaced by MEMs, while reload_out_reg still names the\n+\t original pseudo.  */\n+      && (dead_or_set_p (insn,\n+\t\t\t spill_reg_stored_to[REGNO (rl->reg_rtx)])\n+\t  || rtx_equal_p (spill_reg_stored_to[REGNO (rl->reg_rtx)],\n+\t\t\t  rl->out_reg)))\n+    delete_output_reload (insn, j, REGNO (rl->reg_rtx));\n+}\n \n-\t\t  /* See if RELOADREG is to be used as a scratch register\n-\t\t     or as an intermediate register.  */\n-\t\t  if (rld[j].secondary_out_icode != CODE_FOR_nothing)\n-\t\t    {\n-\t\t      emit_insn ((GEN_FCN (rld[j].secondary_out_icode)\n-\t\t\t\t  (real_old, second_reloadreg, reloadreg)));\n-\t\t      special = 1;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* See if we need both a scratch and intermediate reload\n-\t\t\t register.  */\n+/* Do output reloading for reload RL, which is for the insn described by\n+   CHAIN and has the number J.\n+   ??? At some point we need to support handling output reloads of\n+   JUMP_INSNs or insns that set cc0.  */\n+static void\n+do_output_reload (chain, rl, j)\n+     struct insn_chain *chain;\n+     struct reload *rl;\n+     int j;\n+{\n+  rtx note, old;\n+  rtx insn = chain->insn;\n+  /* If this is an output reload that stores something that is\n+     not loaded in this same reload, see if we can eliminate a previous\n+     store.  */\n+  rtx pseudo = rl->out_reg;\n+\n+  if (pseudo\n+      && GET_CODE (pseudo) == REG\n+      && ! rtx_equal_p (rl->in_reg, pseudo)\n+      && REGNO (pseudo) >= FIRST_PSEUDO_REGISTER\n+      && reg_last_reload_reg[REGNO (pseudo)])\n+    {\n+      int pseudo_no = REGNO (pseudo);\n+      int last_regno = REGNO (reg_last_reload_reg[pseudo_no]);\n+\n+      /* We don't need to test full validity of last_regno for\n+\t inherit here; we only want to know if the store actually\n+\t matches the pseudo.  */\n+      if (reg_reloaded_contents[last_regno] == pseudo_no\n+\t  && spill_reg_store[last_regno]\n+\t  && rtx_equal_p (pseudo, spill_reg_stored_to[last_regno]))\n+\tdelete_output_reload (insn, j, last_regno);\n+    }\n \n-\t\t      int secondary_reload = rld[j].secondary_out_reload;\n-\t\t      enum insn_code tertiary_icode\n-\t\t\t= rld[secondary_reload].secondary_out_icode;\n+  old = rl->out_reg;\n+  if (old == 0\n+      || rl->reg_rtx == old\n+      || rl->reg_rtx == 0)\n+    return;\n \n-\t\t      if (GET_MODE (reloadreg) != mode)\n-\t\t\treloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n+  /* An output operand that dies right away does need a reload,\n+     but need not be copied from it.  Show the new location in the\n+     REG_UNUSED note.  */\n+  if ((GET_CODE (old) == REG || GET_CODE (old) == SCRATCH)\n+      && (note = find_reg_note (insn, REG_UNUSED, old)) != 0)\n+    {\n+      XEXP (note, 0) = rl->reg_rtx;\n+      return;\n+    }\n+  /* Likewise for a SUBREG of an operand that dies.  */\n+  else if (GET_CODE (old) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (old)) == REG\n+\t   && 0 != (note = find_reg_note (insn, REG_UNUSED,\n+\t\t\t\t\t  SUBREG_REG (old))))\n+    {\n+      XEXP (note, 0) = gen_lowpart_common (GET_MODE (old),\n+\t\t\t\t\t   rl->reg_rtx);\n+      return;\n+    }\n+  else if (GET_CODE (old) == SCRATCH)\n+    /* If we aren't optimizing, there won't be a REG_UNUSED note,\n+       but we don't want to make an output reload.  */\n+    return;\n \n-\t\t      if (tertiary_icode != CODE_FOR_nothing)\n-\t\t\t{\n-\t\t\t  rtx third_reloadreg\n-\t\t\t    = rld[rld[secondary_reload].secondary_out_reload].reg_rtx;\n-\t\t\t  rtx tem;\n-\n-\t\t\t  /* Copy primary reload reg to secondary reload reg.\n-\t\t\t     (Note that these have been swapped above, then\n-\t\t\t     secondary reload reg to OLD using our insn.  */\n-\n-\t\t\t  /* If REAL_OLD is a paradoxical SUBREG, remove it\n-\t\t\t     and try to put the opposite SUBREG on\n-\t\t\t     RELOADREG.  */\n-\t\t\t  if (GET_CODE (real_old) == SUBREG\n-\t\t\t      && (GET_MODE_SIZE (GET_MODE (real_old))\n-\t\t\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (real_old))))\n-\t\t\t      && 0 != (tem = gen_lowpart_common\n-\t\t\t\t       (GET_MODE (SUBREG_REG (real_old)),\n-\t\t\t\t\treloadreg)))\n-\t\t\t    real_old = SUBREG_REG (real_old), reloadreg = tem;\n-\n-\t\t\t  gen_reload (reloadreg, second_reloadreg,\n-\t\t\t\t      rld[j].opnum, rld[j].when_needed);\n-\t\t\t  emit_insn ((GEN_FCN (tertiary_icode)\n-\t\t\t\t      (real_old, reloadreg, third_reloadreg)));\n-\t\t\t  special = 1;\n-\t\t\t}\n+  /* If is a JUMP_INSN, we can't support output reloads yet.  */\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    abort ();\n \n-\t\t      else\n-\t\t\t/* Copy between the reload regs here and then to\n-\t\t\t   OUT later.  */\n+  emit_output_reload_insns (chain, rld + j, j);\n+}\n \n-\t\t\tgen_reload (reloadreg, second_reloadreg,\n-\t\t\t\t    rld[j].opnum, rld[j].when_needed);\n-\t\t    }\n-\t\t}\n-\t    }\n-#endif\n+/* Output insns to reload values in and out of the chosen reload regs.  */\n \n-\t  /* Output the last reload insn.  */\n-\t  if (! special)\n-\t    {\n-\t      rtx set;\n-\n-\t      /* Don't output the last reload if OLD is not the dest of\n-\t\t INSN and is in the src and is clobbered by INSN. */\n-\t      if (! flag_expensive_optimizations\n-\t\t  || GET_CODE (old) != REG\n-\t\t  || !(set = single_set (insn))\n-\t\t  || rtx_equal_p (old, SET_DEST (set))\n-\t\t  || !reg_mentioned_p (old, SET_SRC (set))\n-\t\t  || !regno_clobbered_p (REGNO (old), insn))\n-\t\tgen_reload (old, reloadreg, rld[j].opnum,\n-\t\t\t    rld[j].when_needed);\n-\t    }\n+static void\n+emit_reload_insns (chain)\n+     struct insn_chain *chain;\n+{\n+  rtx insn = chain->insn;\n \n-\t  /* Look at all insns we emitted, just to be safe.  */\n-\t  for (p = get_insns (); p; p = NEXT_INSN (p))\n-\t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n-\t      {\n-\t\trtx pat = PATTERN (p);\n+  register int j;\n+  rtx following_insn = NEXT_INSN (insn);\n+  rtx before_insn = PREV_INSN (insn);\n \n-\t\t/* If this output reload doesn't come from a spill reg,\n-\t\t   clear any memory of reloaded copies of the pseudo reg.\n-\t\t   If this output reload comes from a spill reg,\n-\t\t   reg_has_output_reload will make this do nothing.  */\n-\t\tnote_stores (pat, forget_old_reloads_1, NULL);\n+  CLEAR_HARD_REG_SET (reg_reloaded_died);\n \n-\t\tif (reg_mentioned_p (rld[j].reg_rtx, pat))\n-\t\t  {\n-\t\t    rtx set = single_set (insn);\n-\t\t    if (reload_spill_index[j] < 0\n-\t\t\t&& set\n-\t\t\t&& SET_SRC (set) == rld[j].reg_rtx)\n-\t\t      {\n-\t\t\tint src = REGNO (SET_SRC (set));\n+  for (j = 0; j < reload_n_operands; j++)\n+    input_reload_insns[j] = input_address_reload_insns[j]\n+      = inpaddr_address_reload_insns[j]\n+      = output_reload_insns[j] = output_address_reload_insns[j]\n+      = outaddr_address_reload_insns[j]\n+      = other_output_reload_insns[j] = 0;\n+  other_input_address_reload_insns = 0;\n+  other_input_reload_insns = 0;\n+  operand_reload_insns = 0;\n+  other_operand_reload_insns = 0;\n \n-\t\t\treload_spill_index[j] = src;\n-\t\t\tSET_HARD_REG_BIT (reg_is_output_reload, src);\n-\t\t\tif (find_regno_note (insn, REG_DEAD, src))\n-\t\t\t  SET_HARD_REG_BIT (reg_reloaded_died, src);\n-\t\t      }\n-\t\t    if (REGNO (rld[j].reg_rtx) < FIRST_PSEUDO_REGISTER)\n-\t\t      {\n-\t\t\tint s = rld[j].secondary_out_reload;\n-\t\t\tset = single_set (p);\n-\t\t\t/* If this reload copies only to the secondary reload\n-\t\t\t   register, the secondary reload does the actual\n-\t\t\t   store.  */\n-\t\t\tif (s >= 0 && set == NULL_RTX)\n-\t\t\t  ; /* We can't tell what function the secondary reload\n-\t\t\t       has and where the actual store to the pseudo is\n-\t\t\t       made; leave new_spill_reg_store alone.  */\n-\t\t\telse if (s >= 0\n-\t\t\t\t && SET_SRC (set) == rld[j].reg_rtx\n-\t\t\t\t && SET_DEST (set) == rld[s].reg_rtx)\n-\t\t\t  {\n-\t\t\t    /* Usually the next instruction will be the\n-\t\t\t       secondary reload insn;  if we can confirm\n-\t\t\t       that it is, setting new_spill_reg_store to\n-\t\t\t       that insn will allow an extra optimization.  */\n-\t\t\t    rtx s_reg = rld[s].reg_rtx;\n-\t\t\t    rtx next = NEXT_INSN (p);\n-\t\t\t    rld[s].out = rld[j].out;\n-\t\t\t    rld[s].out_reg = rld[j].out_reg;\n-\t\t\t    set = single_set (next);\n-\t\t\t    if (set && SET_SRC (set) == s_reg\n-\t\t\t\t&& ! new_spill_reg_store[REGNO (s_reg)])\n-\t\t\t      {\n-\t\t\t\tSET_HARD_REG_BIT (reg_is_output_reload,\n-\t\t\t\t\t\t  REGNO (s_reg));\n-\t\t\t\tnew_spill_reg_store[REGNO (s_reg)] = next;\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  new_spill_reg_store[REGNO (rld[j].reg_rtx)] = p;\n-\t\t      }\n-\t\t  }\n-\t      }\n+  /* Now output the instructions to copy the data into and out of the\n+     reload registers.  Do these in the order that the reloads were reported,\n+     since reloads of base and index registers precede reloads of operands\n+     and the operands may need the base and index registers reloaded.  */\n \n-\t  if (rld[j].when_needed == RELOAD_OTHER)\n-\t    {\n-\t      emit_insns (other_output_reload_insns[rld[j].opnum]);\n-\t      other_output_reload_insns[rld[j].opnum] = get_insns ();\n-\t    }\n-\t  else\n-\t    output_reload_insns[rld[j].opnum] = get_insns ();\n+  for (j = 0; j < n_reloads; j++)\n+    {\n+      if (rld[j].reg_rtx\n+\t  && REGNO (rld[j].reg_rtx) < FIRST_PSEUDO_REGISTER)\n+\tnew_spill_reg_store[REGNO (rld[j].reg_rtx)] = 0;\n \n-\t  end_sequence ();\n-\t}\n+      do_input_reload (chain, rld + j, j);\n+      do_output_reload (chain, rld + j, j);\n     }\n \n   /* Now write all the insns we made for reloads in the order expected by"}]}