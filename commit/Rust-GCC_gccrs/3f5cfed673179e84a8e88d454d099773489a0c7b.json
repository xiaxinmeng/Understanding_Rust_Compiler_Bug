{"sha": "3f5cfed673179e84a8e88d454d099773489a0c7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1Y2ZlZDY3MzE3OWU4NGE4ZTg4ZDQ1NGQwOTk3NzM0ODlhMGM3Yg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-03-21T04:53:32Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-03-21T04:53:32Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r542", "tree": {"sha": "97cd693f31ff92a0856e8593d3aad915219c3f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97cd693f31ff92a0856e8593d3aad915219c3f19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f5cfed673179e84a8e88d454d099773489a0c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5cfed673179e84a8e88d454d099773489a0c7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5cfed673179e84a8e88d454d099773489a0c7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5cfed673179e84a8e88d454d099773489a0c7b/comments", "author": null, "committer": null, "parents": [{"sha": "31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a"}], "stats": {"total": 101, "additions": 60, "deletions": 41}, "files": [{"sha": "62a549d19a7201d2dae452ce6e276f940e41db2b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5cfed673179e84a8e88d454d099773489a0c7b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5cfed673179e84a8e88d454d099773489a0c7b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=3f5cfed673179e84a8e88d454d099773489a0c7b", "patch": "@@ -58,7 +58,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    A store insn is a SET whose SET_DEST is FIRST_STACK_REG, and whose\n    SET_SRC is REG or MEM.\n \n-   The case where both the SET_SRC and SET_DEST FIRST_STACK_REG\n+   The case where the SET_SRC and SET_DEST are both FIRST_STACK_REG\n    appears ambiguous.  As a special case, the presence of a REG_DEAD note\n    for FIRST_STACK_REG differentiates between a load insn and a pop.\n \n@@ -809,24 +809,27 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n   /* Set up CLOBBER_REG.  */\n \n   n_clobbers = 0;\n-  clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n \n   if (GET_CODE (body) == PARALLEL)\n-    for (i = 0; i < XVECLEN (body, 0); i++)\n-      if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n-\t{\n-\t  rtx clobber = XVECEXP (body, 0, i);\n-\t  rtx reg = XEXP (clobber, 0);\n+    {\n+      clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n \n-\t  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n-\t    reg = SUBREG_REG (reg);\n+      for (i = 0; i < XVECLEN (body, 0); i++)\n+\tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n+\t  {\n+\t    rtx clobber = XVECEXP (body, 0, i);\n+\t    rtx reg = XEXP (clobber, 0);\n \n-\t  if (STACK_REG_P (reg))\n-\t    {\n-\t      clobber_reg[n_clobbers] = reg;\n-\t      n_clobbers++;\n-\t    }\n-\t}\n+\t    if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t      reg = SUBREG_REG (reg);\n+\n+\t    if (STACK_REG_P (reg))\n+\t      {\n+\t\tclobber_reg[n_clobbers] = reg;\n+\t\tn_clobbers++;\n+\t      }\n+\t  }\n+    }\n \n   /* Enforce rule #4: Output operands must specifically indicate which\n      reg an output appears in after an asm.  \"=f\" is not allowed: the\n@@ -2130,30 +2133,33 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n   /* Set up CLOBBER_REG and CLOBBER_LOC.  */\n \n   n_clobbers = 0;\n-  clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n-  clobber_loc = (rtx **) alloca (XVECLEN (body, 0) * sizeof (rtx **));\n \n   if (GET_CODE (body) == PARALLEL)\n-    for (i = 0; i < XVECLEN (body, 0); i++)\n-      if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n-\t{\n-\t  rtx clobber = XVECEXP (body, 0, i);\n-\t  rtx reg = XEXP (clobber, 0);\n-\t  rtx *loc = & XEXP (clobber, 0);\n+    {\n+      clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n+      clobber_loc = (rtx **) alloca (XVECLEN (body, 0) * sizeof (rtx **));\n \n-\t  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n-\t    {\n-\t      loc = & SUBREG_REG (reg);\n-\t      reg = SUBREG_REG (reg);\n-\t    }\n+      for (i = 0; i < XVECLEN (body, 0); i++)\n+\tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n+\t  {\n+\t    rtx clobber = XVECEXP (body, 0, i);\n+\t    rtx reg = XEXP (clobber, 0);\n+\t    rtx *loc = & XEXP (clobber, 0);\n \n-\t  if (STACK_REG_P (reg))\n-\t    {\n-\t      clobber_reg[n_clobbers] = reg;\n-\t      clobber_loc[n_clobbers] = loc;\n-\t      n_clobbers++;\n-\t    }\n-\t}\n+\t    if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t      {\n+\t\tloc = & SUBREG_REG (reg);\n+\t\treg = SUBREG_REG (reg);\n+\t      }\n+\n+\t    if (STACK_REG_P (reg))\n+\t      {\n+\t\tclobber_reg[n_clobbers] = reg;\n+\t\tclobber_loc[n_clobbers] = loc;\n+\t\tn_clobbers++;\n+\t      }\n+\t  }\n+    }\n \n   bcopy (regstack, &temp_stack, sizeof (temp_stack));\n \n@@ -2287,22 +2293,35 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \n   /* Now emit a pop insn for any REG_UNUSED output, or any REG_DEAD\n      input that the asm didn't implicitly pop.  If the asm didn't\n-     implicitly pop a reg, that reg will still be live.\n+     implicitly pop an input reg, that reg will still be live.\n \n      Note that we can't use find_regno_note here: the register numbers\n      in the death notes have already been substituted.  */\n \n-  for (i = 0; i < n_outputs + n_inputs; i++)\n+  for (i = 0; i < n_outputs; i++)\n+    if (STACK_REG_P (operands[i]))\n+      {\n+\tint j;\n+\n+\tfor (j = 0; j < n_notes; j++)\n+\t  if (REGNO (operands[i]) == REGNO (note_reg[j])\n+\t      && note_kind[j] == REG_UNUSED)\n+\t    {\n+\t      insn = emit_pop_insn (insn, regstack, operands[i],\n+\t\t\t\t    emit_insn_after);\n+\t      break;\n+\t    }\n+      }\n+\n+  for (i = first_input; i < first_input + n_inputs; i++)\n     if (STACK_REG_P (operands[i]))\n       {\n \tint j;\n \n \tfor (j = 0; j < n_notes; j++)\n \t  if (REGNO (operands[i]) == REGNO (note_reg[j])\n-\t      && (note_kind[j] == REG_UNUSED\n-\t\t  || (note_kind[j] == REG_DEAD\n-\t\t      && TEST_HARD_REG_BIT (regstack->reg_set,\n-\t\t\t\t\t    REGNO (operands[i])))))\n+\t      && note_kind[j] == REG_DEAD\n+\t      && TEST_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i])))\n \t    {\n \t      insn = emit_pop_insn (insn, regstack, operands[i],\n \t\t\t\t    emit_insn_after);"}]}