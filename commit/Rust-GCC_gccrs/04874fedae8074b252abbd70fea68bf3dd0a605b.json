{"sha": "04874fedae8074b252abbd70fea68bf3dd0a605b", "node_id": "C_kwDOANBUbNoAKDA0ODc0ZmVkYWU4MDc0YjI1MmFiYmQ3MGZlYTY4YmYzZGQwYTYwNWI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-14T13:29:23Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-17T13:13:55Z"}, "message": "Fix nan updating in range-ops.\n\nCalling clean_nan on an undefined type traps, set_varying first. Other\ntweaks for correctness.\n\n\t* range-op-float.cc (foperator_not_equal::op1_range): Check for\n\tVREL_EQ after singleton.\n\t(foperator_unordered::op1_range): Set VARYING before calling\n\tclear_nan().\n\t(foperator_ordered::op1_range): Set rather than clear NAN if both\n\toperands are the same.", "tree": {"sha": "6563185f47c4c65c0054693f051119ba399149b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6563185f47c4c65c0054693f051119ba399149b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04874fedae8074b252abbd70fea68bf3dd0a605b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04874fedae8074b252abbd70fea68bf3dd0a605b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04874fedae8074b252abbd70fea68bf3dd0a605b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04874fedae8074b252abbd70fea68bf3dd0a605b/comments", "author": null, "committer": null, "parents": [{"sha": "fca529517484bf19098ca9efa77e95534086abdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca529517484bf19098ca9efa77e95534086abdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fca529517484bf19098ca9efa77e95534086abdc"}], "stats": {"total": 23, "additions": 10, "deletions": 13}, "files": [{"sha": "6cf2180ce599e7cfcd33e437c685c291960bf99c", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04874fedae8074b252abbd70fea68bf3dd0a605b/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04874fedae8074b252abbd70fea68bf3dd0a605b/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=04874fedae8074b252abbd70fea68bf3dd0a605b", "patch": "@@ -510,19 +510,19 @@ foperator_not_equal::op1_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      // The TRUE side of op1 != op1 implies op1 is NAN.\n-      if (rel == VREL_EQ)\n-\tr.set_nan (type);\n       // If the result is true, the only time we know anything is if\n       // OP2 is a constant.\n-      else if (op2.singleton_p ())\n+      if (op2.singleton_p ())\n \t{\n \t  // This is correct even if op1 is NAN, because the following\n \t  // range would be ~[tmp, tmp] with the NAN property set to\n \t  // maybe (VARYING).\n \t  REAL_VALUE_TYPE tmp = op2.lower_bound ();\n \t  r.set (type, tmp, tmp, VR_ANTI_RANGE);\n \t}\n+      // The TRUE side of op1 != op1 implies op1 is NAN.\n+      else if (rel == VREL_EQ)\n+\tr.set_nan (type);\n       else\n \tr.set_varying (type);\n       break;\n@@ -1045,22 +1045,18 @@ foperator_unordered::op1_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (rel == VREL_EQ)\n-\tr.set_nan (type);\n       // Since at least one operand must be NAN, if one of them is\n       // not, the other must be.\n-      else if (!op2.maybe_isnan ())\n+      if (rel == VREL_EQ || !op2.maybe_isnan ())\n \tr.set_nan (type);\n       else\n \tr.set_varying (type);\n       break;\n \n     case BRS_FALSE:\n-      if (rel == VREL_EQ)\n-\tr.clear_nan ();\n       // A false UNORDERED means both operands are !NAN, so it's\n       // impossible for op2 to be a NAN.\n-      else if (op2.known_isnan ())\n+      if (op2.known_isnan ())\n \tr.set_undefined ();\n       else\n \t{\n@@ -1132,10 +1128,11 @@ foperator_ordered::op1_range (frange &r, tree type,\n       break;\n \n     case BRS_FALSE:\n-      r.set_varying (type);\n-      // The FALSE side of op1 ORDERED op1 implies op1 is !NAN.\n+      // The FALSE side of op1 ORDERED op1 implies op1 is NAN.\n       if (rel == VREL_EQ)\n-\tr.clear_nan ();\n+\tr.set_nan (type);\n+      else\n+\tr.set_varying (type);\n       break;\n \n     default:"}]}