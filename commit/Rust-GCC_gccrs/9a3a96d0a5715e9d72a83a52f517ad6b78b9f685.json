{"sha": "9a3a96d0a5715e9d72a83a52f517ad6b78b9f685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzYTk2ZDBhNTcxNWU5ZDcyYTgzYTUyZjUxN2FkNmI3OGI5ZjY4NQ==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-12-16T11:46:23Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-16T11:46:23Z"}, "message": "ObjectInputStream.java (setBooleanField): Throw an InvalidClassException if the field hasn't the required type...\n\n 2003-12-16 Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/io/ObjectInputStream.java (setBooleanField):\n\tThrow an InvalidClassException if the field hasn't the required type,\n\tdocumentation added.\n\t(setByteField) Likewise.\n\t(setCharField) Likewise.\n\t(setDoubleField) Likewise.\n\t(setFloatField) Likewise.\n\t(setIntField) Likewise.\n\t(setShortField) Likewise.\n\t(setLongField) Likewise.\n\t(setObjectField) Likewise.\n\nFrom-SVN: r74688", "tree": {"sha": "d5d41ed47d51ef3b7b8d4be16b846215637f0f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5d41ed47d51ef3b7b8d4be16b846215637f0f7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685/comments", "author": null, "committer": null, "parents": [{"sha": "5ecc3a7676ce8e4e2da59d7fb8d826f0b3b832c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ecc3a7676ce8e4e2da59d7fb8d826f0b3b832c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ecc3a7676ce8e4e2da59d7fb8d826f0b3b832c7"}], "stats": {"total": 183, "additions": 166, "deletions": 17}, "files": [{"sha": "fe9cd81b27f2507f0a0137a9e652569a667309ab", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9a3a96d0a5715e9d72a83a52f517ad6b78b9f685", "patch": "@@ -1,3 +1,17 @@\n+ 2003-12-16 Guilhem Lavaux <guilhem@kaffe.org>\n+  \n+\t* java/io/ObjectInputStream.java (setBooleanField):\n+\tThrow an InvalidClassException if the field hasn't the required type,\n+\tdocumentation added.\n+\t(setByteField) Likewise.\n+\t(setCharField) Likewise.\n+\t(setDoubleField) Likewise.\n+\t(setFloatField) Likewise.\n+\t(setIntField) Likewise.\n+\t(setShortField) Likewise.\n+\t(setLongField) Likewise.\n+\t(setObjectField) Likewise.\n+\n 2003-12-16 Guilhem Lavaux <guilhem@kaffe.org>\n            Helmer Kraemer <hkraemer@freenet.de>\n  "}, {"sha": "c11299efcb479cf6a5af77d4e1d2e61f65ef77c3", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 152, "deletions": 17, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3a96d0a5715e9d72a83a52f517ad6b78b9f685/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=9a3a96d0a5715e9d72a83a52f517ad6b78b9f685", "patch": "@@ -1482,125 +1482,260 @@ private native Object allocateObject (Class clazz)\n \n   private native void callConstructor (Class clazz, Object obj);\n \n+  /**\n+   * This method writes a \"boolean\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The boolean value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setBooleanField (Object obj, Class klass, String field_name,\n-\t\t\t\tboolean val)\n+\t\t\t\tboolean val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setBoolean (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n+  /**\n+   * This method writes a \"byte\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The byte value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setByteField (Object obj, Class klass, String field_name,\n-\t\t\t     byte val)\n+\t\t\t     byte val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setByte (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n+  /**\n+   * This method writes a \"character\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The character value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setCharField (Object obj, Class klass, String field_name,\n-\t\t\t     char val)\n+\t\t\t     char val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setChar (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n+  /**\n+   * This method writes a \"double\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The double value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setDoubleField (Object obj, Class klass, String field_name,\n-\t\t\t       double val)\n+\t\t\t       double val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setDouble (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n+  /**\n+   * This method writes a \"float\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The float value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setFloatField (Object obj, Class klass, String field_name,\n-\t\t\t      float val)\n+\t\t\t      float val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setFloat (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n+  /**\n+   * This method writes an \"integer\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The integer value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setIntField (Object obj, Class klass, String field_name,\n-\t\t\t    int val)\n+\t\t\t    int val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setInt (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n-\n+  /**\n+   * This method writes the long value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The long value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setLongField (Object obj, Class klass, String field_name,\n-\t\t\t     long val)\n+\t\t\t     long val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setLong (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n-\n+  /**\n+   * This method writes a \"short\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The short value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setShortField (Object obj, Class klass, String field_name,\n-\t\t\t      short val)\n+\t\t\t      short val) throws IOException, InvalidClassException\n   {\n     try\n       {\n \tField f = getField (klass, field_name);\n \tf.setShort (obj, val);\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+      }\n     catch (Exception _)\n       {\n       }    \n   }\n \n-\n+  /**\n+   * This method writes an \"object\" value <code>val</code> in the specified field\n+   * of the instance <code>obj</code> of the type <code>klass</code>.\n+   *\n+   * @param obj Instance to setup.\n+   * @param klass Class type of the specified instance.\n+   * @param field_name Name of the field in the specified class type.\n+   * @param val The \"object\" value to write into the field.\n+   * @throws InvalidClassException if the specified field has not the required type.\n+   * @throws IOException if there is no field of that name in the specified class.\n+   */\n   private void setObjectField (Object obj, Class klass, String field_name,\n-\t\t\t       String type_code, Object val)\n+\t\t\t       String type_code, Object val) throws IOException, InvalidClassException\n   {\n     try\n       {\n-\tField f = getField (klass, field_name);\n-\t// FIXME: We should check the type_code here\n-\tf.set (obj, val);\n+ \tField f = getField (klass, field_name);\n+\tObjectStreamField of = new ObjectStreamField(field_name, f.getType());\n+\t\n+\tif (of.getTypeString() == null ||\n+\t    !of.getTypeString().equals(type_code))\n+          throw new InvalidClassException(\"incompatible field type for \" + klass.getName() + \".\" + field_name);\n+ \tf.set (obj, val);\n       }\n-    catch (Exception _)\n+    catch (InvalidClassException e)\n       {\n-      }    \n+\tthrow e;\n+      }\n+    catch (Exception _)\n+      {}\n   }\n \n   private static final int BUFFER_SIZE = 1024;"}]}