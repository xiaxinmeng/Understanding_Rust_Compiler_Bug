{"sha": "ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWExYzY3ZTZlM2ZlNjljMTkyNmI4YmJiYTc1OTk4ZDE0N2RkNTU2NQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-11-19T21:25:00Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-11-19T21:25:00Z"}, "message": "re PR bootstrap/37859 (Bootstrap failure on mips64octeon-unknown-linux-gnu)\n\n2008-11-19  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR bootstrap/37859\n\t* ira-int.h (struct ira_loop_tree_node): New member\n\tentered_from_non_parent_p.\n\n\t* ira-color.c (print_loop_title): Print loop bbs.\n\n\t* ira-emit.c (entered_from_non_parent_p,\n\tsetup_entered_from_non_parent_p): New functions.\n\t(not_modified_p): Rename to store_can_be_removed_p.  Check there\n\tis no side entries.\n\t(generate_edge_moves): Use store_can_be_removed_p instead of\n\tnot_modified_p.\n\t(ira_emit): Call setup_entered_from_non_parent_p.\n\t\n\t* ira-build.c (copy_info_to_removed_store_destinations):\n\tAccumulate CALL_FREQ, CALL_CROSSED_NUM, and\n\tALLOCNO_EXCESS_PRESSURE_POINTS_NUM.\n\t(ira_flattening): Don't CHECK MEM_OPTIMIZED_DEST[_P], always\n\tupdate all accumulated attributes.\n\nFrom-SVN: r142018", "tree": {"sha": "abbc12ec53d3e488d10d9e7e19b31568683777b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abbc12ec53d3e488d10d9e7e19b31568683777b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3553f0bb324124195a64ce30c0832463e9082461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553f0bb324124195a64ce30c0832463e9082461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3553f0bb324124195a64ce30c0832463e9082461"}], "stats": {"total": 167, "additions": 135, "deletions": 32}, "files": [{"sha": "b21a632bcf5a447a9d84a72bf916b8d1ac8112aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "patch": "@@ -1,4 +1,26 @@\n-2008-11-15  Vladimir Makarov  <vmakarov@redhat.com>\n+2008-11-19  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR bootstrap/37859\n+\t* ira-int.h (struct ira_loop_tree_node): New member\n+\tentered_from_non_parent_p.\n+\n+\t* ira-color.c (print_loop_title): Print loop bbs.\n+\n+\t* ira-emit.c (entered_from_non_parent_p,\n+\tsetup_entered_from_non_parent_p): New functions.\n+\t(not_modified_p): Rename to store_can_be_removed_p.  Check there\n+\tis no side entries.\n+\t(generate_edge_moves): Use store_can_be_removed_p instead of\n+\tnot_modified_p.\n+\t(ira_emit): Call setup_entered_from_non_parent_p.\n+\t\n+\t* ira-build.c (copy_info_to_removed_store_destinations):\n+\tAccumulate CALL_FREQ, CALL_CROSSED_NUM, and\n+\tALLOCNO_EXCESS_PRESSURE_POINTS_NUM.\n+\t(ira_flattening): Don't CHECK MEM_OPTIMIZED_DEST[_P], always\n+\tupdate all accumulated attributes.\n+\t\n+2008-11-19  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR bootstrap/37790\n \t* ira-int.h (ira_copy_allocno_live_range_list,"}, {"sha": "e4ed60141fa0d796d5c4dc7260eea2dafb2f5484", "filename": "gcc/ira-build.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "patch": "@@ -2193,6 +2193,11 @@ copy_info_to_removed_store_destinations (int regno)\n       if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n \tALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n #endif\n+      ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n+      ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n+\t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n+      ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n+\t+= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n       merged_p = true;\n     }\n   return merged_p;\n@@ -2208,7 +2213,7 @@ void\n ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n {\n   int i, j, num;\n-  bool stop_p, keep_p;\n+  bool keep_p;\n   int hard_regs_num;\n   bool new_pseudos_p, merged_p, mem_dest_p;\n   unsigned int n;\n@@ -2293,26 +2298,15 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t      continue;\n \t    }\n \t  new_pseudos_p = true;\n-\t  first = ALLOCNO_MEM_OPTIMIZED_DEST (a) == NULL ? NULL : a;\n-\t  stop_p = false;\n \t  for (;;)\n \t    {\n-\t      if (first == NULL\n-\t\t  && ALLOCNO_MEM_OPTIMIZED_DEST (parent_a) != NULL)\n-\t\tfirst = parent_a;\n \t      ALLOCNO_NREFS (parent_a) -= ALLOCNO_NREFS (a);\n \t      ALLOCNO_FREQ (parent_a) -= ALLOCNO_FREQ (a);\n-\t      if (first != NULL\n-\t\t  && ALLOCNO_MEM_OPTIMIZED_DEST (first) == parent_a)\n-\t\tstop_p = true;\n-\t      else if (!stop_p)\n-\t\t{\n-\t\t  ALLOCNO_CALL_FREQ (parent_a) -= ALLOCNO_CALL_FREQ (a);\n-\t\t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n-\t\t    -= ALLOCNO_CALLS_CROSSED_NUM (a);\n-\t\t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n-\t\t    -= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n-\t\t}\n+\t      ALLOCNO_CALL_FREQ (parent_a) -= ALLOCNO_CALL_FREQ (a);\n+\t      ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n+\t\t-= ALLOCNO_CALLS_CROSSED_NUM (a);\n+\t      ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n+\t\t-= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t      ira_assert (ALLOCNO_CALLS_CROSSED_NUM (parent_a) >= 0\n \t\t\t  && ALLOCNO_NREFS (parent_a) >= 0\n \t\t\t  && ALLOCNO_FREQ (parent_a) >= 0);"}, {"sha": "c3b63cc3d5d3b8ab3036fec2b28bd233a5bf81a9", "filename": "gcc/ira-color.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "patch": "@@ -1703,15 +1703,32 @@ print_loop_title (ira_loop_tree_node_t loop_tree_node)\n {\n   unsigned int j;\n   bitmap_iterator bi;\n+  ira_loop_tree_node_t subloop_node, dest_loop_node;\n+  edge e;\n+  edge_iterator ei;\n \n   ira_assert (loop_tree_node->loop != NULL);\n   fprintf (ira_dump_file,\n-\t   \"\\n  Loop %d (parent %d, header bb%d, depth %d)\\n    all:\",\n+\t   \"\\n  Loop %d (parent %d, header bb%d, depth %d)\\n    bbs:\",\n \t   loop_tree_node->loop->num,\n \t   (loop_tree_node->parent == NULL\n \t    ? -1 : loop_tree_node->parent->loop->num),\n \t   loop_tree_node->loop->header->index,\n \t   loop_depth (loop_tree_node->loop));\n+  for (subloop_node = loop_tree_node->children;\n+       subloop_node != NULL;\n+       subloop_node = subloop_node->next)\n+    if (subloop_node->bb != NULL)\n+      {\n+\tfprintf (ira_dump_file, \" %d\", subloop_node->bb->index);\n+\tFOR_EACH_EDGE (e, ei, subloop_node->bb->succs)\n+\t  if (e->dest != EXIT_BLOCK_PTR\n+\t      && ((dest_loop_node = IRA_BB_NODE (e->dest)->parent)\n+\t\t  != loop_tree_node))\n+\t    fprintf (ira_dump_file, \"(->%d:l%d)\",\n+\t\t     e->dest->index, dest_loop_node->loop->num);\n+      }\n+  fprintf (ira_dump_file, \"\\n    all:\");\n   EXECUTE_IF_SET_IN_BITMAP (loop_tree_node->all_allocnos, 0, j, bi)\n     fprintf (ira_dump_file, \" %dr%d\", j, ALLOCNO_REGNO (ira_allocnos[j]));\n   fprintf (ira_dump_file, \"\\n    modified regnos:\");"}, {"sha": "29f3fdf6fa7adb1c4d2ca679a3f58dd25d286260", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "patch": "@@ -260,12 +260,63 @@ set_allocno_reg (ira_allocno_t allocno, rtx reg)\n     }\n }\n \n-/* Return TRUE if move of SRC_ALLOCNO to DEST_ALLOCNO does not change\n-   value of the destination.  One possible reason for this is the\n-   situation when SRC_ALLOCNO is not modified in the corresponding\n-   loop.  */\n+/* Return true if there is an entry to given loop not from its parent\n+   (or grandparent) block.  For example, it is possible for two\n+   adjacent loops inside another loop.  */\n static bool\n-not_modified_p (ira_allocno_t src_allocno, ira_allocno_t dest_allocno)\n+entered_from_non_parent_p (ira_loop_tree_node_t loop_node)\n+{\n+  ira_loop_tree_node_t bb_node, src_loop_node, parent;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (bb_node = loop_node->children; bb_node != NULL; bb_node = bb_node->next)\n+    if (bb_node->bb != NULL)\n+      {\n+\tFOR_EACH_EDGE (e, ei, bb_node->bb->preds)\n+\t  if (e->src != ENTRY_BLOCK_PTR\n+\t      && (src_loop_node = IRA_BB_NODE (e->src)->parent) != loop_node)\n+\t    {\n+\t      for (parent = src_loop_node->parent;\n+\t\t   parent != NULL;\n+\t\t   parent = parent->parent)\n+\t\tif (parent == loop_node)\n+\t\t  break;\n+\t      if (parent != NULL)\n+\t\t/* That is an exit from a nested loop -- skip it.  */\n+\t\tcontinue;\n+\t      for (parent = loop_node->parent;\n+\t\t   parent != NULL;\n+\t\t   parent = parent->parent)\n+\t\tif (src_loop_node == parent)\n+\t\t  break;\n+\t      if (parent == NULL)\n+\t\treturn true;\n+\t    }\n+      }\n+  return false;\n+}\n+\n+/* Set up ENTERED_FROM_NON_PARENT_P for each loop region.  */\n+static void\n+setup_entered_from_non_parent_p (void)\n+{\n+  unsigned int i;\n+  loop_p loop;\n+\n+  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+    if (ira_loop_nodes[i].regno_allocno_map != NULL)\n+      ira_loop_nodes[i].entered_from_non_parent_p\n+\t= entered_from_non_parent_p (&ira_loop_nodes[i]);\n+}\n+\n+/* Return TRUE if move of SRC_ALLOCNO (assigned to hard register) to\n+   DEST_ALLOCNO (assigned to memory) can be removed beacuse it does\n+   not change value of the destination.  One possible reason for this\n+   is the situation when SRC_ALLOCNO is not modified in the\n+   corresponding loop.  */\n+static bool\n+store_can_be_removed_p (ira_allocno_t src_allocno, ira_allocno_t dest_allocno)\n {\n   int regno, orig_regno;\n   ira_allocno_t a;\n@@ -278,13 +329,26 @@ not_modified_p (ira_allocno_t src_allocno, ira_allocno_t dest_allocno)\n   for (node = ALLOCNO_LOOP_TREE_NODE (src_allocno);\n        node != NULL;\n        node = node->parent)\n-    if ((a = node->regno_allocno_map[orig_regno]) == NULL)\n-      break;\n-    else if (REGNO (ALLOCNO_REG (a)) == (unsigned) regno)\n-      return true;\n-    else if (bitmap_bit_p (node->modified_regnos, orig_regno))\n-      return false;\n-  return node != NULL;\n+    {\n+      a = node->regno_allocno_map[orig_regno];\n+      ira_assert (a != NULL);\n+      if (REGNO (ALLOCNO_REG (a)) == (unsigned) regno)\n+\t/* We achieved the destination and everything is ok.  */\n+\treturn true;\n+      else if (bitmap_bit_p (node->modified_regnos, orig_regno))\n+\treturn false;\n+      else if (node->entered_from_non_parent_p)\n+\t/* If there is a path from a destination loop block to the\n+\t   source loop header containing basic blocks of non-parents\n+\t   (grandparents) of the source loop, we should have checked\n+\t   modifications of the pseudo on this path too to decide\n+\t   about possibility to remove the store.  It could be done by\n+\t   solving a data-flow problem.  Unfortunately such global\n+\t   solution would complicate IR flattening.  Therefore we just\n+\t   prohibit removal of the store in such complicated case.  */\n+\treturn false;\n+    }\n+  gcc_unreachable ();\n }\n \n /* Generate and attach moves to the edge E.  This looks at the final\n@@ -322,7 +386,7 @@ generate_edge_moves (edge e)\n \t   change_loop).  */\n  \tif (ALLOCNO_HARD_REGNO (dest_allocno) < 0\n \t    && ALLOCNO_HARD_REGNO (src_allocno) >= 0\n-\t    && not_modified_p (src_allocno, dest_allocno))\n+\t    && store_can_be_removed_p (src_allocno, dest_allocno))\n \t  {\n \t    ALLOCNO_MEM_OPTIMIZED_DEST (src_allocno) = dest_allocno;\n \t    ALLOCNO_MEM_OPTIMIZED_DEST_P (dest_allocno) = true;\n@@ -983,6 +1047,7 @@ ira_emit (bool loops_p)\n   ira_free_bitmap (used_regno_bitmap);\n   ira_free_bitmap (renamed_regno_bitmap);\n   ira_free_bitmap (local_allocno_bitmap);\n+  setup_entered_from_non_parent_p ();\n   FOR_EACH_BB (bb)\n     {\n       at_bb_start[bb->index] = NULL;"}, {"sha": "659c1eeb2ab2ebfdcc8089fb2f286f847358f5a8", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1c67e6e3fe69c1926b8bbba75998d147dd5565/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=ea1c67e6e3fe69c1926b8bbba75998d147dd5565", "patch": "@@ -107,6 +107,11 @@ struct ira_loop_tree_node\n      one cap with the same regno in a region).  */\n   ira_allocno_t *regno_allocno_map;\n \n+  /* True if there is an entry to given loop not from its parent (or\n+     grandparent) basic block.  For example, it is possible for two\n+     adjacent loops inside another loop.  */\n+  bool entered_from_non_parent_p;\n+\n   /* Maximal register pressure inside loop for given register class\n      (defined only for the cover classes).  */\n   int reg_pressure[N_REG_CLASSES];"}]}