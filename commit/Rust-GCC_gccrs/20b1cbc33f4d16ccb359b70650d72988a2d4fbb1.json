{"sha": "20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBiMWNiYzMzZjRkMTZjY2IzNTliNzA2NTBkNzI5ODhhMmQ0ZmJiMQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2006-04-05T04:47:51Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2006-04-05T04:47:51Z"}, "message": "re PR fortran/25619 (temporary array of constant size character type goes wrong)\n\ngcc/fortran/\n\n2006-04-04  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR fortran/25619\n\t* trans-array.c (gfc_conv_expr_descriptor): Only dereference\n\tcharacter pointer when copying temporary.\n\n\tPR fortran/23634\n\t* trans-array.c (gfc_conv_expr_descriptor): Properly copy\n\ttemporary character with non constant size.\n\ngcc/testsuite/\n\n2006-04-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23634\n\tPR fortran/25619\n\t* gfortran.dg/actual_array_constructor_1.f90: New testcase.\n\nFrom-SVN: r112695", "tree": {"sha": "6c69f4803b48dee15416ebf0372df25c81515254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c69f4803b48dee15416ebf0372df25c81515254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/comments", "author": null, "committer": null, "parents": [{"sha": "4dea2268c3e078f87b7d6dae58c01ef816cb4ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dea2268c3e078f87b7d6dae58c01ef816cb4ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dea2268c3e078f87b7d6dae58c01ef816cb4ef9"}], "stats": {"total": 138, "additions": 123, "deletions": 15}, "files": [{"sha": "0f09fef47aaa6ba5ad9ba886fc7f64bf3b00104a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "patch": "@@ -1,3 +1,13 @@\n+2006-04-04  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR fortran/25619\n+\t* trans-array.c (gfc_conv_expr_descriptor): Only dereference\n+\tcharacter pointer when copying temporary.\n+\n+\tPR fortran/23634\n+\t* trans-array.c (gfc_conv_expr_descriptor): Properly copy\n+\ttemporary character with non constant size.\n+\n 2006-04-03  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26981"}, {"sha": "4bdc784f11c8a73ec597bab2b42eac0bd27fc43e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "patch": "@@ -3973,23 +3973,32 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->next = gfc_ss_terminator;\n       if (expr->ts.type == BT_CHARACTER)\n \t{\n-\t  gcc_assert (expr->ts.cl && expr->ts.cl->length\n-\t\t      && expr->ts.cl->length->expr_type == EXPR_CONSTANT);\n-\t  loop.temp_ss->string_length = gfc_conv_mpz_to_tree\n-\t\t\t(expr->ts.cl->length->value.integer,\n-\t\t\t expr->ts.cl->length->ts.kind);\n-\t  expr->ts.cl->backend_decl = loop.temp_ss->string_length;\n-\t}\n-        loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n-\n-      /* ... which can hold our string, if present.  */\n-      if (expr->ts.type == BT_CHARACTER)\n-\t{\n-\t  loop.temp_ss->string_length = TYPE_SIZE_UNIT (loop.temp_ss->data.temp.type);\n+\t  if (expr->ts.cl\n+\t      && expr->ts.cl->length\n+\t      && expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      expr->ts.cl->backend_decl\n+\t\t= gfc_conv_mpz_to_tree (expr->ts.cl->length->value.integer,\n+\t\t\t\t\texpr->ts.cl->length->ts.kind);\n+\t      loop.temp_ss->data.temp.type\n+\t\t= gfc_typenode_for_spec (&expr->ts);\n+\t      loop.temp_ss->string_length\n+\t\t= TYPE_SIZE_UNIT (loop.temp_ss->data.temp.type);\n+\t    }\n+\t  else\n+\t    {\n+\t      loop.temp_ss->data.temp.type\n+\t\t= gfc_typenode_for_spec (&expr->ts);\n+\t      loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+\t    }\n \t  se->string_length = loop.temp_ss->string_length;\n \t}\n       else\n-\tloop.temp_ss->string_length = NULL;\n+\t{\n+\t  loop.temp_ss->data.temp.type\n+\t    = gfc_typenode_for_spec (&expr->ts);\n+\t  loop.temp_ss->string_length = NULL;\n+\t}\n       loop.temp_ss->data.temp.dimen = loop.dimen;\n       gfc_add_ss_to_loop (&loop, loop.temp_ss);\n     }\n@@ -4022,7 +4031,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       if (expr->ts.type == BT_CHARACTER)\n \t{\n \t  gfc_conv_expr (&rse, expr);\n-\t  rse.expr = build_fold_indirect_ref (rse.expr);\n+\t  if (POINTER_TYPE_P (TREE_TYPE (rse.expr)))\n+\t    rse.expr = build_fold_indirect_ref (rse.expr);\n \t}\n       else\n         gfc_conv_expr_val (&rse, expr);"}, {"sha": "da9fedb6c58c4cdda7578650d0dbef49cff59fc1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "patch": "@@ -1,3 +1,9 @@\n+2006-04-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23634\n+\tPR fortran/25619\n+\t* gfortran.dg/actual_array_constructor_1.f90: New testcase.\n+\n 2006-04-04  Eric Christopher  <echristo@apple.com>\n \n \t* gcc.target/i386/387-1.c: Allow regexp to match darwin"}, {"sha": "69bfcd05a530843a0c5594dd7b6d94df99f7afb1", "filename": "gcc/testsuite/gfortran.dg/actual_array_constructor_1.f90", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_constructor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b1cbc33f4d16ccb359b70650d72988a2d4fbb1/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_constructor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_constructor_1.f90?ref=20b1cbc33f4d16ccb359b70650d72988a2d4fbb1", "patch": "@@ -0,0 +1,82 @@\n+! { dg-do run }\n+! Test the fix by HJ Lu for PR23634 and friends. All involve the ICE\n+! that arose from a character array constructor usedas an actual\n+! argument.\n+!\n+! The various parts of this test are taken from the PRs.\n+!\n+! Test PR26491\n+module global\n+  public    p, line\n+  interface p\n+    module procedure p\n+  end interface\n+  character(128) :: line = 'abcdefghijklmnopqrstuvwxyz'\n+contains\n+  subroutine p()\n+    character(128) :: word\n+    word = line\n+    call redirect_((/word/))\n+  end subroutine\n+  subroutine redirect_ (ch)\n+    character(*) :: ch(:)\n+    if (ch(1) /= line) call abort ()\n+  end subroutine redirect_\n+end module global\n+\n+! Test PR26550\n+module my_module\n+  implicit none\n+  type point\n+    real :: x\n+  end type point\n+  type(point), pointer, public :: stdin => NULL()\n+contains\n+  subroutine my_p(w)\n+    character(128) :: w\n+    call r(stdin,(/w/))\n+  end subroutine my_p\n+  subroutine r(ptr, io)\n+    use global\n+    type(point), pointer :: ptr\n+    character(128) :: io(:)\n+    if (associated (ptr)) call abort ()\n+    if (io(1) .ne. line) call abort ()\n+  end subroutine r\n+end module my_module\n+\n+program main\n+  use global\n+  use my_module\n+\n+  integer :: i(6) = (/1,6,3,4,5,2/)\n+  character (6) :: a = 'hello ', t\n+  character(len=1) :: s(6) = (/'g','g','d','d','a','o'/)\n+  equivalence (s, t)\n+\n+  call option_stopwatch_s (a) ! Call test of PR25619\n+  call p ()                   ! Call test of PR26491\n+  call my_p (line)            ! Call test of PR26550\n+\n+! Test Vivek Rao's bug, as reported in PR25619.\n+  s = s(i)\n+  call option_stopwatch_a ((/a,'hola! ', t/))\n+\n+contains\n+\n+! Test PR23634\n+  subroutine option_stopwatch_s(a)\n+    character (*), intent(in) :: a\n+    character (len=len(a)) :: b\n+\n+    b = 'hola! '\n+    call option_stopwatch_a((/a, b, 'goddag'/))\n+  end subroutine option_stopwatch_s \n+  subroutine option_stopwatch_a (a)\n+    character (*) :: a(:)\n+    if (any (a .ne. (/'hello ','hola! ','goddag'/))) call abort ()\n+  end subroutine option_stopwatch_a\n+\n+end program main\n+! { dg-final { cleanup-modules \"global my_module\" } }\n+"}]}