{"sha": "8fb74da43bd12ea5008ba9fba2173b455d494b2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZiNzRkYTQzYmQxMmVhNTAwOGJhOWZiYTIxNzNiNDU1ZDQ5NGIyYw==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2008-07-02T19:53:37Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2008-07-02T19:53:37Z"}, "message": "re PR fortran/32580 (iso_c_binding c_f_procpointer / procedure pointers)\n\n2008-07-02  Janus Weil  <janus@gcc.gnu.org>\n\t    Tobias Burnus  <burnus@net-b.de>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/32580\n\t* gfortran.h (struct gfc_symbol): New member \"proc_pointer\".\n\t* check.c (gfc_check_associated,gfc_check_null): Implement\n\tprocedure pointers.\n\t* decl.c (match_procedure_decl): Ditto.\n\t* expr.c (gfc_check_pointer_assign,gfc_check_assign_symbol): Ditto.\n\t* interface.c (compare_actual_formal): Ditto.\n\t* match.h: Ditto.\n\t* match.c (gfc_match_pointer_assignment): Ditto.\n\t* parse.c (parse_interface): Ditto.\n\t* primary.c (gfc_match_rvalue,match_variable): Ditto.\n\t* resolve.c (resolve_fl_procedure): Ditto.\n\t* symbol.c (check_conflict,gfc_add_external,gfc_add_pointer,\n\tgfc_copy_attr,gen_fptr_param,build_formal_args): Ditto.\n\t* trans-decl.c (get_proc_pointer_decl,gfc_get_extern_function_decl,\n\tcreate_function_arglist): Ditto.\n\t* trans-expr.c (gfc_conv_variable,gfc_conv_function_val,\n\tgfc_conv_function_call,gfc_trans_pointer_assignment): Ditto.\n\n\n2008-07-02  Janus Weil  <janus@gcc.gnu.org>\n\t    Tobias Burnus  <burnus@net-b.de>\n\n\tPR fortran/32580\n\t* gfortran.dg/c_f_pointer_tests_3.f90: Updated.\n\t* gfortran.dg/proc_decl_1.f90: Updated.\n\t* gfortran.dg/proc_ptr_1.f90: New.\n\t* gfortran.dg/proc_ptr_2.f90: New.\n\t* gfortran.dg/proc_ptr_3.f90: New.\n\t* gfortran.dg/proc_ptr_4.f90: New.\n\t* gfortran.dg/proc_ptr_5.f90: New.\n\t* gfortran.dg/proc_ptr_6.f90: New.\n\t* gfortran.dg/proc_ptr_7.f90: New.\n\t* gfortran.dg/proc_ptr_8.f90: New.\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\nCo-Authored-By: Tobias Burnus <burnus@net-b.de>\n\nFrom-SVN: r137386", "tree": {"sha": "22cdfa5a0f9753aaa861e0696994a9d143ec1e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22cdfa5a0f9753aaa861e0696994a9d143ec1e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fb74da43bd12ea5008ba9fba2173b455d494b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fb74da43bd12ea5008ba9fba2173b455d494b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fb74da43bd12ea5008ba9fba2173b455d494b2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fb74da43bd12ea5008ba9fba2173b455d494b2c/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658896fbb85ebf48d21c9a08e405d0916ca1d45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/658896fbb85ebf48d21c9a08e405d0916ca1d45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/658896fbb85ebf48d21c9a08e405d0916ca1d45a"}], "stats": {"total": 674, "additions": 625, "deletions": 49}, "files": [{"sha": "7b641f077ba64a6f3bac198d2b3b8be2a32cdc03", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -1,3 +1,26 @@\n+2008-07-02  Janus Weil  <janus@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/32580\n+\t* gfortran.h (struct gfc_symbol): New member \"proc_pointer\".\n+\t* check.c (gfc_check_associated,gfc_check_null): Implement\n+\tprocedure pointers.\n+\t* decl.c (match_procedure_decl): Ditto.\n+\t* expr.c (gfc_check_pointer_assign,gfc_check_assign_symbol): Ditto.\n+\t* interface.c (compare_actual_formal): Ditto.\n+\t* match.h: Ditto.\n+\t* match.c (gfc_match_pointer_assignment): Ditto.\n+\t* parse.c (parse_interface): Ditto.\n+\t* primary.c (gfc_match_rvalue,match_variable): Ditto.\n+\t* resolve.c (resolve_fl_procedure): Ditto.\n+\t* symbol.c (check_conflict,gfc_add_external,gfc_add_pointer,\n+\tgfc_copy_attr,gen_fptr_param,build_formal_args): Ditto.\n+\t* trans-decl.c (get_proc_pointer_decl,gfc_get_extern_function_decl,\n+\tcreate_function_arglist): Ditto.\n+\t* trans-expr.c (gfc_conv_variable,gfc_conv_function_val,\n+\tgfc_conv_function_call,gfc_trans_pointer_assignment): Ditto.\n+\n 2008-07-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/36590"}, {"sha": "c0f9891bd980d832857d45875b3a9c423f47045a", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -584,23 +584,23 @@ gfc_check_x_yd (gfc_expr *x, gfc_expr *y)\n try\n gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n {\n-  symbol_attribute attr;\n+  symbol_attribute attr1, attr2;\n   int i;\n   try t;\n   locus *where;\n \n   where = &pointer->where;\n \n   if (pointer->expr_type == EXPR_VARIABLE)\n-    attr = gfc_variable_attr (pointer, NULL);\n+    attr1 = gfc_variable_attr (pointer, NULL);\n   else if (pointer->expr_type == EXPR_FUNCTION)\n-    attr = pointer->symtree->n.sym->attr;\n+    attr1 = pointer->symtree->n.sym->attr;\n   else if (pointer->expr_type == EXPR_NULL)\n     goto null_arg;\n   else\n     gcc_assert (0); /* Pointer must be a variable or a function.  */\n \n-  if (!attr.pointer)\n+  if (!attr1.pointer && !attr1.proc_pointer)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n \t\t gfc_current_intrinsic_arg[0], gfc_current_intrinsic,\n@@ -617,9 +617,9 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n     goto null_arg;\n \n   if (target->expr_type == EXPR_VARIABLE)\n-    attr = gfc_variable_attr (target, NULL);\n+    attr2 = gfc_variable_attr (target, NULL);\n   else if (target->expr_type == EXPR_FUNCTION)\n-    attr = target->symtree->n.sym->attr;\n+    attr2 = target->symtree->n.sym->attr;\n   else\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a pointer \"\n@@ -628,7 +628,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n       return FAILURE;\n     }\n \n-  if (!attr.pointer && !attr.target)\n+  if (attr1.pointer && !attr2.pointer && !attr2.target)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER \"\n \t\t \"or a TARGET\", gfc_current_intrinsic_arg[1],\n@@ -2071,7 +2071,7 @@ gfc_check_null (gfc_expr *mold)\n \n   attr = gfc_variable_attr (mold, NULL);\n \n-  if (!attr.pointer)\n+  if (!attr.pointer && !attr.proc_pointer)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n \t\t gfc_current_intrinsic_arg[0],"}, {"sha": "d23a32946efb0b1a60069c5faea19f710a5e7119", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -4065,6 +4065,7 @@ match_procedure_decl (void)\n   locus old_loc, entry_loc;\n   gfc_symbol *sym, *proc_if = NULL;\n   int num;\n+  gfc_expr *initializer = NULL;\n \n   old_loc = entry_loc = gfc_current_locus;\n \n@@ -4183,7 +4184,7 @@ match_procedure_decl (void)\n \t    return MATCH_ERROR;\n \t}\n \n-      if (!sym->attr.pointer && gfc_add_external (&sym->attr, NULL) == FAILURE)\n+      if (gfc_add_external (&sym->attr, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n       if (gfc_add_proc (&sym->attr, sym->name, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n@@ -4203,6 +4204,40 @@ match_procedure_decl (void)\n \t  sym->attr.function = sym->ts.interface->attr.function;\n \t}\n \n+      if (gfc_match (\" =>\") == MATCH_YES)\n+\t{\n+\t  if (!current_attr.pointer)\n+\t    {\n+\t      gfc_error (\"Initialization at %C isn't for a pointer variable\");\n+\t      m = MATCH_ERROR;\n+\t      goto cleanup;\n+\t    }\n+\n+\t  m = gfc_match_null (&initializer);\n+\t  if (m == MATCH_NO)\n+\t    {\n+\t      gfc_error (\"Pointer initialization requires a NULL() at %C\");\n+\t      m = MATCH_ERROR;\n+\t    }\n+\n+\t  if (gfc_pure (NULL))\n+\t    {\n+\t      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n+\t\t\t \"a PURE procedure\");\n+\t      m = MATCH_ERROR;\n+\t    }\n+\n+\t  if (m != MATCH_YES)\n+\t    goto cleanup;\n+\n+\t  if (add_init_expr_to_sym (sym->name, &initializer, &gfc_current_locus)\n+\t      != SUCCESS)\n+\t    goto cleanup;\n+\n+\t}\n+\n+      gfc_set_sym_referenced (sym);\n+\n       if (gfc_match_eos () == MATCH_YES)\n \treturn MATCH_YES;\n       if (gfc_match_char (',') != MATCH_YES)\n@@ -4212,6 +4247,11 @@ match_procedure_decl (void)\n syntax:\n   gfc_error (\"Syntax error in PROCEDURE statement at %C\");\n   return MATCH_ERROR;\n+\n+cleanup:\n+  /* Free stuff up and return.  */\n+  gfc_free_expr (initializer);\n+  return m;\n }\n \n "}, {"sha": "12987e6b748e78e2e7b1e911e64852f1c124aa09", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -2874,7 +2874,8 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   int is_pure;\n   int pointer, check_intent_in;\n \n-  if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN)\n+  if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN\n+      && !lvalue->symtree->n.sym->attr.proc_pointer)\n     {\n       gfc_error (\"Pointer assignment target is not a POINTER at %L\",\n \t\t &lvalue->where);\n@@ -2894,7 +2895,8 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   /* Check INTENT(IN), unless the object itself is the component or\n      sub-component of a pointer.  */\n   check_intent_in = 1;\n-  pointer = lvalue->symtree->n.sym->attr.pointer;\n+  pointer = lvalue->symtree->n.sym->attr.pointer\n+\t      | lvalue->symtree->n.sym->attr.proc_pointer;\n \n   for (ref = lvalue->ref; ref; ref = ref->next)\n     {\n@@ -2933,6 +2935,10 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   if (rvalue->expr_type == EXPR_NULL && rvalue->ts.type == BT_UNKNOWN)\n     return SUCCESS;\n \n+  /* TODO checks on rvalue for a procedure pointer assignment.  */\n+  if (lvalue->symtree->n.sym->attr.proc_pointer)\n+    return SUCCESS;\n+\n   if (!gfc_compare_types (&lvalue->ts, &rvalue->ts))\n     {\n       gfc_error (\"Different types in pointer assignment at %L; attempted \"\n@@ -3024,7 +3030,7 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n   lvalue.symtree->n.sym = sym;\n   lvalue.where = sym->declared_at;\n \n-  if (sym->attr.pointer)\n+  if (sym->attr.pointer || sym->attr.proc_pointer)\n     r = gfc_check_pointer_assign (&lvalue, rvalue);\n   else\n     r = gfc_check_assign (&lvalue, rvalue, 1);"}, {"sha": "aa2296c72a54182df45a679b86880fa79e5105a3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -620,7 +620,7 @@ typedef struct\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, target:1, value:1, volatile_:1,\n     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,\n-    implied_index:1, subref_array_pointer:1;\n+    implied_index:1, subref_array_pointer:1, proc_pointer:1;\n \n   ENUM_BITFIELD (save_state) save:2;\n "}, {"sha": "a20319976bba3b5b857ae40da3d0cd24ec212d32", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -1959,6 +1959,17 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return  0;\n \t}\n \n+      /* Satisfy 12.4.1.3 by ensuring that a procedure pointer actual argument\n+\t is provided for a procedure pointer formal argument.  */\n+      if (f->sym->attr.proc_pointer\n+\t  && !a->expr->symtree->n.sym->attr.proc_pointer)\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Expected a procedure pointer for argument '%s' at %L\",\n+\t\t       f->sym->name, &a->expr->where);\n+\t  return 0;\n+\t}\n+\n       /* Satisfy 12.4.1.2 by ensuring that a procedure actual argument is\n \t provided for a procedure formal argument.  */\n       if (a->expr->ts.type != BT_PROCEDURE"}, {"sha": "d501d682475920d7a8eeba07f31c469b55861e61", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"parse.h\"\n \n+int gfc_matching_procptr_assignment = 0;\n \n /* For debugging and diagnostic purposes.  Return the textual representation\n    of the intrinsic operator OP.  */\n@@ -1329,6 +1330,7 @@ gfc_match_pointer_assignment (void)\n   old_loc = gfc_current_locus;\n \n   lvalue = rvalue = NULL;\n+  gfc_matching_procptr_assignment = 0;\n \n   m = gfc_match (\" %v =>\", &lvalue);\n   if (m != MATCH_YES)\n@@ -1337,7 +1339,11 @@ gfc_match_pointer_assignment (void)\n       goto cleanup;\n     }\n \n+  if (lvalue->symtree->n.sym->attr.proc_pointer)\n+    gfc_matching_procptr_assignment = 1;\n+\n   m = gfc_match (\" %e%t\", &rvalue);\n+  gfc_matching_procptr_assignment = 0;\n   if (m != MATCH_YES)\n     goto cleanup;\n "}, {"sha": "21a2479566457db30c35c46aea24b3cfd791f33e", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -33,6 +33,8 @@ extern gfc_symbol *gfc_new_block;\n    separate.  */\n extern gfc_st_label *gfc_statement_label;\n \n+extern int gfc_matching_procptr_assignment;\n+\n /****************** All gfc_match* routines *****************/\n \n /* match.c.  */"}, {"sha": "781efbc205df8e597af88272c507d6dbdda90326", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -1992,6 +1992,11 @@ parse_interface (void)\n \tnew_state = COMP_SUBROUTINE;\n       else if (st == ST_FUNCTION)\n \tnew_state = COMP_FUNCTION;\n+      if (gfc_new_block->attr.pointer)\n+\t{\n+\t  gfc_new_block->attr.pointer = 0;\n+\t  gfc_new_block->attr.proc_pointer = 1;\n+\t}\n       if (gfc_add_explicit_interface (gfc_new_block, IFSRC_IFBODY,\n \t\t\t\t  gfc_new_block->formal, NULL) == FAILURE)\n \t{"}, {"sha": "c67f2bd18733d77d82916ed423c21d4b70cbf630", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -2323,6 +2323,9 @@ gfc_match_rvalue (gfc_expr **result)\n \t}\n     }\n \n+  if (gfc_matching_procptr_assignment)\n+    goto procptr0;\n+\n   if (sym->attr.function || sym->attr.external || sym->attr.intrinsic)\n     goto function0;\n \n@@ -2399,6 +2402,27 @@ gfc_match_rvalue (gfc_expr **result)\n     /* If we're here, then the name is known to be the name of a\n        procedure, yet it is not sure to be the name of a function.  */\n     case FL_PROCEDURE:\n+\n+    /* Procedure Pointer Assignments. */\n+    procptr0:\n+      if (gfc_matching_procptr_assignment)\n+\t{\n+\t  gfc_gobble_whitespace ();\n+\t  if (sym->attr.function && gfc_peek_ascii_char () == '(')\n+\t    /* Parse functions returning a procptr.  */\n+\t    goto function0;\n+\n+\t  if (sym->attr.flavor == FL_UNKNOWN) sym->attr.flavor = FL_PROCEDURE;\n+\t  if (gfc_intrinsic_name (sym->name, 0)\n+\t      || gfc_intrinsic_name (sym->name, 1))\n+\t    sym->attr.intrinsic = 1;\n+\t  e = gfc_get_expr ();\n+\t  e->expr_type = EXPR_VARIABLE;\n+\t  e->symtree = symtree;\n+\t  m = match_varspec (e, 0);\n+\t  break;\n+\t}\n+\n       if (sym->attr.subroutine)\n \t{\n \t  gfc_error (\"Unexpected use of subroutine name '%s' at %C\",\n@@ -2780,6 +2804,9 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  break;\n \t}\n \n+      if (sym->attr.proc_pointer)\n+\tbreak;\n+\n       /* Fall through to error */\n \n     default:"}, {"sha": "c0ec7847747ca57d1c3dde495f68ede6b71fb0a8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -7330,16 +7330,17 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t}\n     }\n \n-  if (sym->attr.function && sym->value && sym->attr.proc != PROC_ST_FUNCTION)\n+  if (sym->attr.function && sym->value && sym->attr.proc != PROC_ST_FUNCTION\n+      && !sym->attr.proc_pointer)\n     {\n       gfc_error (\"Function '%s' at %L cannot have an initializer\",\n \t\t sym->name, &sym->declared_at);\n       return FAILURE;\n     }\n \n   /* An external symbol may not have an initializer because it is taken to be\n-     a procedure.  */\n-  if (sym->attr.external && sym->value)\n+     a procedure. Exception: Procedure Pointers.  */\n+  if (sym->attr.external && sym->value && !sym->attr.proc_pointer)\n     {\n       gfc_error (\"External object '%s' at %L may not have an initializer\",\n \t\t sym->name, &sym->declared_at);"}, {"sha": "f91ef9157c0fdfde3e5f9bb5a030022b767409f6", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -410,13 +410,19 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  case FL_BLOCK_DATA:\n \t  case FL_MODULE:\n \t  case FL_LABEL:\n-\t  case FL_PROCEDURE:\n \t  case FL_DERIVED:\n \t  case FL_PARAMETER:\n             a1 = gfc_code2string (flavors, attr->flavor);\n             a2 = save;\n \t    goto conflict;\n \n+\t  case FL_PROCEDURE:\n+\t    if (attr->proc_pointer)\n+\t      break;\n+\t    a1 = gfc_code2string (flavors, attr->flavor);\n+\t    a2 = save;\n+\t    goto conflict;\n+\n \t  case FL_VARIABLE:\n \t  case FL_NAMELIST:\n \t  default:\n@@ -557,13 +563,6 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (procedure, value)\n   conf (procedure, volatile_)\n   conf (procedure, entry)\n-  /* TODO: Implement procedure pointers.  */\n-  if (attr->procedure && attr->pointer)\n-    {\n-      gfc_error (\"Fortran 2003: Procedure pointers at %L are \"\n-\t\t \"not yet implemented in gfortran\", where);\n-      return FAILURE;\n-    }\n \n   a1 = gfc_code2string (flavors, attr->flavor);\n \n@@ -619,11 +618,11 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       break;\n \n     case FL_PROCEDURE:\n-      conf2 (intent);\n+      if (!attr->proc_pointer)\n+        conf2 (intent);\n \n       if (attr->subroutine)\n \t{\n-\t  conf2 (pointer);\n \t  conf2 (target);\n \t  conf2 (allocatable);\n \t  conf2 (result);\n@@ -866,6 +865,12 @@ gfc_add_external (symbol_attribute *attr, locus *where)\n       return FAILURE;\n     }\n \n+  if (attr->pointer && attr->if_source != IFSRC_IFBODY)\n+    {\n+      attr->pointer = 0;\n+      attr->proc_pointer = 1;\n+    }\n+\n   attr->external = 1;\n \n   return check_conflict (attr, NULL, where);\n@@ -916,7 +921,20 @@ gfc_add_pointer (symbol_attribute *attr, locus *where)\n   if (check_used (attr, NULL, where))\n     return FAILURE;\n \n-  attr->pointer = 1;\n+  if (attr->pointer && !(attr->if_source == IFSRC_IFBODY\n+      && gfc_find_state (COMP_INTERFACE) == FAILURE))\n+    {\n+      duplicate_attr (\"POINTER\", where);\n+      return FAILURE;\n+    }\n+\n+  if (attr->procedure || (attr->external && attr->if_source != IFSRC_IFBODY)\n+      || (attr->if_source == IFSRC_IFBODY\n+      && gfc_find_state (COMP_INTERFACE) == FAILURE))\n+    attr->proc_pointer = 1;\n+  else\n+    attr->pointer = 1;\n+\n   return check_conflict (attr, NULL, where);\n }\n \n@@ -1641,6 +1659,8 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n     goto fail;\n   if (src->intrinsic && gfc_add_intrinsic (dest, where) == FAILURE)\n     goto fail;\n+  if (src->proc_pointer)\n+    dest->proc_pointer = 1;\n \n   return SUCCESS;\n \n@@ -3574,7 +3594,7 @@ static void\n gen_fptr_param (gfc_formal_arglist **head,\n                 gfc_formal_arglist **tail,\n                 const char *module_name,\n-                gfc_namespace *ns, const char *f_ptr_name)\n+                gfc_namespace *ns, const char *f_ptr_name, int proc)\n {\n   gfc_symbol *param_sym = NULL;\n   gfc_symtree *param_symtree = NULL;\n@@ -3593,7 +3613,10 @@ gen_fptr_param (gfc_formal_arglist **head,\n \n   /* Set up the necessary fields for the fptr output param sym.  */\n   param_sym->refs++;\n-  param_sym->attr.pointer = 1;\n+  if (proc)\n+    param_sym->attr.proc_pointer = 1;\n+  else\n+    param_sym->attr.pointer = 1;\n   param_sym->attr.dummy = 1;\n   param_sym->attr.use_assoc = 1;\n \n@@ -3773,21 +3796,23 @@ build_formal_args (gfc_symbol *new_proc_sym,\n   gfc_current_ns->proc_name = new_proc_sym;\n \n   /* Generate the params.  */\n-  if ((old_sym->intmod_sym_id == ISOCBINDING_F_POINTER) ||\n-      (old_sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n+  if (old_sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER)\n     {\n       gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n \t\t      gfc_current_ns, \"cptr\", old_sym->intmod_sym_id);\n       gen_fptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"fptr\");\n-\n+\t\t      gfc_current_ns, \"fptr\", 1);\n+    }\n+  else if (old_sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n+    {\n+      gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n+\t\t      gfc_current_ns, \"cptr\", old_sym->intmod_sym_id);\n+      gen_fptr_param (&head, &tail, (const char *) new_proc_sym->module,\n+\t\t      gfc_current_ns, \"fptr\", 0);\n       /* If we're dealing with c_f_pointer, it has an optional third arg.  */\n-      if (old_sym->intmod_sym_id == ISOCBINDING_F_POINTER)\n-\t{\n-\t  gen_shape_param (&head, &tail,\n-\t\t\t   (const char *) new_proc_sym->module,\n-\t\t\t   gfc_current_ns, \"shape\");\n-\t}\n+      gen_shape_param (&head, &tail,(const char *) new_proc_sym->module,\n+\t\t       gfc_current_ns, \"shape\");\n+\n     }\n   else if (old_sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n     {"}, {"sha": "e960fa026b1fc00d9b81a1fc48b911c8f724e26b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -1104,6 +1104,44 @@ gfc_restore_sym (gfc_symbol * sym, gfc_saved_var * save)\n }\n \n \n+/* Declare a procedure pointer.  */\n+\n+static tree\n+get_proc_pointer_decl (gfc_symbol *sym)\n+{\n+  tree decl;\n+\n+  decl = sym->backend_decl;\n+  if (decl)\n+    return decl;\n+\n+  decl = build_decl (VAR_DECL, get_identifier (sym->name),\n+\t\t     build_pointer_type (gfc_get_function_type (sym)));\n+\n+  if (sym->ns->proc_name->backend_decl == current_function_decl\n+      || sym->attr.contained)\n+    gfc_add_decl_to_function (decl);\n+  else\n+    gfc_add_decl_to_parent_function (decl);\n+\n+  sym->backend_decl = decl;\n+\n+  if (!sym->attr.use_assoc\n+\t&& (sym->attr.save != SAVE_NONE || sym->attr.data\n+\t      || (sym->value && sym->ns->proc_name->attr.is_main_program)))\n+    TREE_STATIC (decl) = 1;\n+\n+  if (TREE_STATIC (decl) && sym->value)\n+    {\n+      /* Add static initializer.  */\n+      DECL_INITIAL (decl) = gfc_conv_initializer (sym->value, &sym->ts,\n+\t  TREE_TYPE (decl), sym->attr.dimension, sym->attr.proc_pointer);\n+    }\n+\n+  return decl;\n+}\n+\n+\n /* Get a basic decl for an external function.  */\n \n tree\n@@ -1126,6 +1164,9 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n      to know that.  */\n   gcc_assert (!(sym->attr.entry || sym->attr.entry_master));\n \n+  if (sym->attr.proc_pointer)\n+    return get_proc_pointer_decl (sym);\n+\n   if (sym->attr.intrinsic)\n     {\n       /* Call the resolution function to get the actual name.  This is\n@@ -1540,6 +1581,9 @@ create_function_arglist (gfc_symbol * sym)\n \t    type = gfc_sym_type (f->sym);\n \t}\n \n+      if (f->sym->attr.proc_pointer)\n+        type = build_pointer_type (type);\n+\n       /* Build a the argument declaration.  */\n       parm = build_decl (PARM_DECL, gfc_sym_identifier (f->sym), type);\n "}, {"sha": "570e07b5a06c135b32ea27628902403b9e5fb1fe", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -480,8 +480,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       else if (sym->attr.flavor == FL_PROCEDURE\n \t       && se->expr != current_function_decl)\n \t{\n-\t  gcc_assert (se->want_pointer);\n-\t  if (!sym->attr.dummy)\n+\t  if (!sym->attr.dummy && !sym->attr.proc_pointer)\n \t    {\n \t      gcc_assert (TREE_CODE (se->expr) == FUNCTION_DECL);\n \t      se->expr = build_fold_addr_expr (se->expr);\n@@ -1372,6 +1371,8 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n   if (sym->attr.dummy)\n     {\n       tmp = gfc_get_symbol_decl (sym);\n+      if (sym->attr.proc_pointer)\n+        tmp = build_fold_indirect_ref (tmp);\n       gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (tmp))) == FUNCTION_TYPE);\n     }\n@@ -2498,9 +2499,10 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      else\n \t\t{\n \t\t  gfc_conv_expr_reference (&parmse, e);\n-\t\t  if (fsym && fsym->attr.pointer\n-\t\t      && fsym->attr.flavor != FL_PROCEDURE\n-\t\t      && e->expr_type != EXPR_NULL)\n+\t\t  if (fsym && e->expr_type != EXPR_NULL\n+\t\t      && ((fsym->attr.pointer\n+\t\t\t   && fsym->attr.flavor != FL_PROCEDURE)\n+\t\t\t  || fsym->attr.proc_pointer))\n \t\t    {\n \t\t      /* Scalar pointer dummy args require an extra level of\n \t\t\t indirection. The null pointer already contains\n@@ -3867,6 +3869,11 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_init_se (&rse, NULL);\n       rse.want_pointer = 1;\n       gfc_conv_expr (&rse, expr2);\n+\n+      if (expr1->symtree->n.sym->attr.proc_pointer\n+\t  && expr1->symtree->n.sym->attr.dummy)\n+\tlse.expr = build_fold_indirect_ref (lse.expr);\n+\n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n       gfc_add_modify_expr (&block, lse.expr,"}, {"sha": "78562ce90a11e678ad868e1b7b3b98e50e57c4ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -1,3 +1,18 @@\n+2008-07-02  Janus Weil  <janus@gcc.gnu.org>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/32580\n+\t* gfortran.dg/c_f_pointer_tests_3.f90: Updated.\n+\t* gfortran.dg/proc_decl_1.f90: Updated.\n+\t* gfortran.dg/proc_ptr_1.f90: New.\n+\t* gfortran.dg/proc_ptr_2.f90: New.\n+\t* gfortran.dg/proc_ptr_3.f90: New.\n+\t* gfortran.dg/proc_ptr_4.f90: New.\n+\t* gfortran.dg/proc_ptr_5.f90: New.\n+\t* gfortran.dg/proc_ptr_6.f90: New.\n+\t* gfortran.dg/proc_ptr_7.f90: New.\n+\t* gfortran.dg/proc_ptr_8.f90: New.\n+\n 2008-07-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.target/arm/neon/polytypes.c: Use dg-message separately from"}, {"sha": "3b28f52b4e7a6a993bae7c1e43ead3ac55ff0aca", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_tests_3.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_tests_3.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -14,11 +14,11 @@ program test\n   type(c_funptr) :: cfunptr\n   integer(4), pointer :: fptr\n   integer(4), pointer :: fptr_array(:)\n-!  procedure(integer(4)), pointer :: fprocptr ! TODO\n+  procedure(integer(4)), pointer :: fprocptr\n \n   call c_f_pointer(cptr, fptr)\n   call c_f_pointer(cptr, fptr_array, [ 1 ])\n-!  call c_f_procpointer(cfunptr, fprocptr) ! TODO\n+  call c_f_procpointer(cfunptr, fprocptr)\n end program test\n \n ! Make sure there is only a single function call:\n@@ -30,6 +30,6 @@ end program test\n ! { dg-final { scan-tree-dump-times \"  fptr = .integer.kind=4. .. cptr\" 1 \"original\" } }\n !\n ! Check c_f_procpointer\n-!   TODO     { scan-tree-dump-times \"  fprocptr = .integer.kind=4. .\\\\*<.*>. .void.. cfunptr;\" 1 \"original\" } }  TODO\n+! { dg-final { scan-tree-dump-times \"  fprocptr = .integer.kind=4. .\\\\*<.*>. .void.. cfunptr;\" 1 \"original\" } }\n !\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "3e7a3d18fb7f3f992e921f8042a18a0b3c8a208d", "filename": "gcc/testsuite/gfortran.dg/proc_decl_1.f90", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_1.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -40,8 +40,6 @@ subroutine z2(a)\n   procedure(dcos) :: my1\n   procedure(amax0) :: my2  ! { dg-error \"not allowed in PROCEDURE statement\" }\n \n-  procedure(),pointer:: ptr  ! { dg-error \"not yet implemented\" }\n-\n   type t\n     procedure(),pointer:: p  ! { dg-error \"not yet implemented\" }\n   end type"}, {"sha": "fe8e201000e676ec27cf33730874c46ce95b726a", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_1.f90", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_1.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,73 @@\n+! { dg-do run }\n+!\n+! basic tests of PROCEDURE POINTERS\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+contains\n+  subroutine proc1(arg)\n+    character (5) :: arg\n+    arg = \"proc1\"\n+  end subroutine\n+  integer function proc2(arg)\n+    integer, intent(in) :: arg\n+    proc2 = arg**2\n+  end function\n+  complex function proc3(re, im)\n+    real, intent(in) :: re, im\n+    proc3 = complex (re, im)\n+  end function\n+end module\n+\n+subroutine foo1\n+end subroutine\n+\n+real function foo2()\n+  foo2=6.3\n+end function\n+\n+program procPtrTest\n+  use m, only: proc1, proc2, proc3\n+  character (5) :: str\n+  PROCEDURE(proc1), POINTER :: ptr1\n+  PROCEDURE(proc2), POINTER :: ptr2\n+  PROCEDURE(proc3), POINTER :: ptr3 => NULL()\n+  PROCEDURE(REAL), SAVE, POINTER :: ptr4\n+  PROCEDURE(), POINTER :: ptr5,ptr6\n+\n+  EXTERNAL :: foo1,foo2\n+  real :: foo2\n+\n+  if(ASSOCIATED(ptr3)) call abort()\n+\n+  NULLIFY(ptr1)\n+  if (ASSOCIATED(ptr1)) call abort()\n+  ptr1 => proc1\n+  if (.not. ASSOCIATED(ptr1)) call abort()\n+  call ptr1 (str)\n+  if (str .ne. \"proc1\") call abort ()\n+\n+  ptr2 => NULL()\n+  if (ASSOCIATED(ptr2)) call abort()\n+  ptr2 => proc2\n+  if (.not. ASSOCIATED(ptr2,proc2)) call abort()\n+  if (10*ptr2 (10) .ne. 1000) call abort ()\n+\n+  ptr3 => NULL (ptr3)\n+  if (ASSOCIATED(ptr3)) call abort()\n+  ptr3 => proc3\n+  if (ptr3 (1.0, 2.0) .ne. (1.0, 2.0)) call abort ()\n+\n+  ptr4 => cos\n+  if (ptr4(0.0)/=1.0) call abort()\n+\n+  ptr5 => foo1\n+  call ptr5()\n+\n+  ptr6 => foo2\n+  if (ptr6()/=6.3) call abort()\n+\n+end program \n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "d19b81d6e472b9db9297ecc797ca76c7944f123a", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_2.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_2.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+!\n+! checking invalid code for PROCEDURE POINTERS\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+PROCEDURE(REAL), POINTER :: ptr\n+PROCEDURE(REAL), SAVE    :: noptr    ! { dg-error \"attribute conflicts with\" }\n+\n+ptr => cos(4.0)        ! { dg-error \"Invalid character\" }\n+\n+ALLOCATE(ptr)          ! { dg-error \"must be ALLOCATABLE\" }\n+\n+end"}, {"sha": "34d4f1625fb6523c5c4b33152ca1904eebfcf311", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_3.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_3.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+!\n+! PROCEDURE POINTERS without the PROCEDURE statement\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+real function e1(x)\n+  real :: x\n+  print *,'e1!',x\n+  e1 = x * 3.0\n+end function\n+\n+subroutine e2(a,b)\n+  real, intent(inout) :: a\n+  real, intent(in) :: b\n+  print *,'e2!',a,b\n+  a = a + b\n+end subroutine\n+\n+program proc_ptr_3\n+\n+real, external, pointer :: fp\n+\n+pointer :: sp\n+interface\n+  subroutine sp(a,b)\n+    real, intent(inout) :: a\n+    real, intent(in) :: b\n+  end subroutine sp\n+end interface\n+\n+external :: e1,e2\n+real :: c = 1.2\n+\n+fp => e1\n+\n+if (abs(fp(2.5)-7.5)>0.01) call abort()\n+\n+sp => e2\n+\n+call sp(c,3.4)\n+\n+if (abs(c-4.6)>0.01) call abort()\n+\n+end"}, {"sha": "60b9e73af8283eb4abc0d0bd24669417612783a0", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_4.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_4.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+!\n+! PROCEDURE POINTERS & pointer-valued functions\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+interface\n+  integer function f1()\n+  end function\n+end interface\n+\n+interface\n+ function f2()\n+   integer, pointer :: f2\n+ end function\n+end interface\n+\n+interface\n+ function pp1()\n+   integer :: pp1\n+ end function\n+end interface\n+pointer :: pp1\n+\n+pointer :: pp2\n+interface\n+  function pp2()\n+    integer :: pp2\n+  end function\n+end interface\n+\n+pointer :: pp3\n+interface\n+  function pp3()\n+    integer, pointer :: pp3\n+  end function\n+end interface\n+\n+interface\n+  function pp4()\n+    integer, pointer :: pp4\n+  end function\n+end interface\n+pointer :: pp4\n+\n+\n+pp1 => f1\n+\n+pp2 => pp1\n+\n+f2 => f1\t! { dg-error \"is not a variable\" }\n+\n+pp3 => f2\n+\n+pp4 => pp3\n+\n+end\n\\ No newline at end of file"}, {"sha": "61cf8a35d10123d85306958a19957979992765c4", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_5.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_5.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+!\n+! NULL() initialization for PROCEDURE POINTERS\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+program main\n+implicit none\n+call test(.true.)\n+call test(.false.)\n+\n+contains\n+\n+integer function hello()\n+ hello = 42\n+end function hello\n+\n+subroutine test(first)\n+ logical :: first\n+ integer :: i\n+ procedure(integer), pointer :: x => null()\n+\n+ if(first) then\n+  if(associated(x)) call abort()\n+  x => hello\n+ else\n+  if(.not. associated(x)) call abort()\n+  i = x()\n+  if(i /= 42) call abort()\n+ end if\n+ end subroutine test\n+\n+end program main"}, {"sha": "6a5c7e5f462505f444d48e930037945d0956f524", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_6.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_6.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! PROCEDURE POINTERS as actual/formal arguments\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+subroutine foo(j)\n+  INTEGER, INTENT(OUT) :: j\n+  j = 6\n+end subroutine\n+\n+program proc_ptr_6\n+\n+PROCEDURE(),POINTER :: ptr1\n+PROCEDURE(REAL),POINTER :: ptr2\n+EXTERNAL foo\n+INTEGER :: k = 0\n+\n+ptr1 => foo\n+call s_in(ptr1,k)\n+if (k /= 6) call abort()\n+\n+call s_out(ptr2)\n+if (ptr2(-3.0) /= 3.0) call abort()\n+\n+contains\n+\n+subroutine s_in(p,i)\n+  PROCEDURE(),POINTER,INTENT(IN) :: p\n+  INTEGER, INTENT(OUT) :: i\n+  call p(i)\n+end subroutine\n+\n+subroutine s_out(p)\n+  PROCEDURE(REAL),POINTER,INTENT(OUT) :: p\n+  p => abs\n+end subroutine\n+\n+end program"}, {"sha": "7e9542fd86e9df39fadf38bbd17598cfc6c55604", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_7.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_7.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,10 @@\n+/* Procedure pointer test. Used by proc_ptr_7.f90.\n+   PR fortran/32580.  */\n+\n+int f(void) {\n+  return 42;\n+}\n+\n+void assignf_(int(**ptr)(void)) {\n+  *ptr = f;\n+}"}, {"sha": "8b1ea0a44b38137a31c1ed51f980d9bb98bd18a4", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_7.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_7.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! { dg-additional-sources proc_ptr_7.c }\n+!\n+! PR fortran/32580\n+! Procedure pointer test\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+program proc_pointer_test\n+  use iso_c_binding, only: c_int\n+  implicit none\n+\n+  interface\n+    subroutine assignF(f)\n+      import c_int\n+      procedure(Integer(c_int)), pointer :: f\n+    end subroutine\n+  end interface\n+\n+  procedure(Integer(c_int)), pointer :: ptr\n+\n+  call assignF(ptr)\n+  if(ptr() /= 42) call abort()\n+\n+  ptr => f55\n+  if(ptr() /= 55) call abort()  \n+\n+  call foo(ptr)\n+  if(ptr() /= 65) call abort()  \n+\n+contains\n+\n+ subroutine foo(a)\n+   procedure(integer(c_int)), pointer :: a\n+   if(a() /= 55) call abort()\n+   a => f65\n+   if(a() /= 65) call abort()\n+ end subroutine foo\n+\n+ integer(c_int) function f55()\n+    f55 = 55\n+ end function f55\n+\n+ integer(c_int) function f65()\n+    f65 = 65\n+ end function f65\n+end program proc_pointer_test"}, {"sha": "c732ff6667c0f230f8bb602b30801d7ede9ca967", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_8.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_8.c?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,14 @@\n+/* Used by proc_ptr_8.f90.\n+   PR fortran/32580.  */\n+\n+int (*funpointer)(int);\n+\n+int f(int t)\n+{\n+  return t*3;\n+}\n+\n+void init()\n+{\n+ funpointer=f;\n+}"}, {"sha": "80d26619bc01acaa88ad7dbba70cd66d3f46d708", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_8.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fb74da43bd12ea5008ba9fba2173b455d494b2c/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_8.f90?ref=8fb74da43bd12ea5008ba9fba2173b455d494b2c", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! { dg-additional-sources proc_ptr_8.c }\n+!\n+! PR fortran/32580\n+! Original test case\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+\n+MODULE X\n+\n+  USE ISO_C_BINDING\n+  INTERFACE\n+    INTEGER(KIND=C_INT) FUNCTION mytype( a ) BIND(C)\n+       USE ISO_C_BINDING\n+       INTEGER(KIND=C_INT), VALUE :: a\n+    END FUNCTION\n+    SUBROUTINE init() BIND(C,name=\"init\")\n+    END SUBROUTINE\n+  END INTERFACE\n+\n+  TYPE(C_FUNPTR), BIND(C,name=\"funpointer\") :: funpointer\n+\n+END MODULE X\n+\n+USE X\n+PROCEDURE(mytype), POINTER :: ptype\n+\n+CALL init()\n+CALL C_F_PROCPOINTER(funpointer,ptype)\n+if (ptype(3) /= 9) call abort()\n+\n+END\n+\n+! { dg-final { cleanup-modules \"X\" } }"}]}