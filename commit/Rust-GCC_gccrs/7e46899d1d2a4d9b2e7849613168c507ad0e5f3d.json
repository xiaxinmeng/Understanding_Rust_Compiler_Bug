{"sha": "7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0Njg5OWQxZDJhNGQ5YjJlNzg0OTYxMzE2OGM1MDdhZDBlNWYzZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:36:49Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:36:49Z"}, "message": "Change use to type-based pool allocator in\n\n\t* var-tracking.c (variable_htab_free):Use new type-based pool allocator.\n\t(attrs_list_clear) Likewise.\n\t(attrs_list_insert) Likewise.\n\t(attrs_list_copy) Likewise.\n\t(shared_hash_unshare) Likewise.\n\t(shared_hash_destroy) Likewise.\n\t(unshare_variable) Likewise.\n\t(var_reg_delete_and_set) Likewise.\n\t(var_reg_delete) Likewise.\n\t(var_regno_delete) Likewise.\n\t(drop_overlapping_mem_locs) Likewise.\n\t(variable_union) Likewise.\n\t(insert_into_intersection) Likewise.\n\t(canonicalize_values_star) Likewise.\n\t(variable_merge_over_cur) Likewise.\n\t(dataflow_set_merge) Likewise.\n\t(remove_duplicate_values) Likewise.\n\t(variable_post_merge_new_vals) Likewise.\n\t(dataflow_set_preserve_mem_locs) Likewise.\n\t(dataflow_set_remove_mem_locs) Likewise.\n\t(variable_from_dropped) Likewise.\n\t(variable_was_changed) Likewise.\n\t(set_slot_part) Likewise.\n\t(clobber_slot_part) Likewise.\n\t(delete_slot_part) Likewise.\n\t(loc_exp_insert_dep) Likewise.\n\t(notify_dependents_of_changed_value) Likewise.\n\t(emit_notes_for_differences_1) Likewise.\n\t(vt_emit_notes) Likewise.\n\t(vt_initialize) Likewise.\n\t(vt_finalize) Likewise.\n\nFrom-SVN: r223947", "tree": {"sha": "18066ae94ff5990fc8aef2047279bdfafd6258a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18066ae94ff5990fc8aef2047279bdfafd6258a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b17d27f7661cc7376c6b12be514f1bc69191ff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b17d27f7661cc7376c6b12be514f1bc69191ff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b17d27f7661cc7376c6b12be514f1bc69191ff7"}], "stats": {"total": 235, "additions": 156, "deletions": 79}, "files": [{"sha": "0fa51f71c78d79c93494eebb45853d036ead34e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "patch": "@@ -1,3 +1,37 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* var-tracking.c (variable_htab_free):Use new type-based pool allocator.\n+\t(attrs_list_clear) Likewise.\n+\t(attrs_list_insert) Likewise.\n+\t(attrs_list_copy) Likewise.\n+\t(shared_hash_unshare) Likewise.\n+\t(shared_hash_destroy) Likewise.\n+\t(unshare_variable) Likewise.\n+\t(var_reg_delete_and_set) Likewise.\n+\t(var_reg_delete) Likewise.\n+\t(var_regno_delete) Likewise.\n+\t(drop_overlapping_mem_locs) Likewise.\n+\t(variable_union) Likewise.\n+\t(insert_into_intersection) Likewise.\n+\t(canonicalize_values_star) Likewise.\n+\t(variable_merge_over_cur) Likewise.\n+\t(dataflow_set_merge) Likewise.\n+\t(remove_duplicate_values) Likewise.\n+\t(variable_post_merge_new_vals) Likewise.\n+\t(dataflow_set_preserve_mem_locs) Likewise.\n+\t(dataflow_set_remove_mem_locs) Likewise.\n+\t(variable_from_dropped) Likewise.\n+\t(variable_was_changed) Likewise.\n+\t(set_slot_part) Likewise.\n+\t(clobber_slot_part) Likewise.\n+\t(delete_slot_part) Likewise.\n+\t(loc_exp_insert_dep) Likewise.\n+\t(notify_dependents_of_changed_value) Likewise.\n+\t(emit_notes_for_differences_1) Likewise.\n+\t(vt_emit_notes) Likewise.\n+\t(vt_initialize) Likewise.\n+\t(vt_finalize) Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* ira-color.c (init_update_cost_records):Use new type-based pool allocator."}, {"sha": "0b240073bb3a2d28a537ccd332eb27ecd88764be", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 122, "deletions": 79, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e46899d1d2a4d9b2e7849613168c507ad0e5f3d/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=7e46899d1d2a4d9b2e7849613168c507ad0e5f3d", "patch": "@@ -282,6 +282,21 @@ typedef struct attrs_def\n \n   /* Offset from start of DECL.  */\n   HOST_WIDE_INT offset;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((attrs_def *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<attrs_def> pool;\n } *attrs;\n \n /* Structure for chaining the locations.  */\n@@ -298,6 +313,21 @@ typedef struct location_chain_def\n \n   /* Initialized? */\n   enum var_init_status init;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((location_chain_def *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<location_chain_def> pool;\n } *location_chain;\n \n /* A vector of loc_exp_dep holds the active dependencies of a one-part\n@@ -315,6 +345,21 @@ typedef struct loc_exp_dep_s\n   /* A pointer to the pointer to this entry (head or prev's next) in\n      the doubly-linked list.  */\n   struct loc_exp_dep_s **pprev;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((loc_exp_dep_s *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<loc_exp_dep_s> pool;\n } loc_exp_dep;\n \n \n@@ -554,6 +599,21 @@ typedef struct shared_hash_def\n \n   /* Actual hash table.  */\n   variable_table_type *htab;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((shared_hash_def *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<shared_hash_def> pool;\n } *shared_hash;\n \n /* Structure holding the IN or OUT set for a basic block.  */\n@@ -598,22 +658,28 @@ typedef struct variable_tracking_info_def\n } *variable_tracking_info;\n \n /* Alloc pool for struct attrs_def.  */\n-static alloc_pool attrs_pool;\n+pool_allocator<attrs_def> attrs_def::pool (\"attrs_def pool\", 1024);\n \n /* Alloc pool for struct variable_def with MAX_VAR_PARTS entries.  */\n-static alloc_pool var_pool;\n+\n+static pool_allocator<variable_def> var_pool\n+  (\"variable_def pool\", 64,\n+   (MAX_VAR_PARTS - 1) * sizeof (((variable)NULL)->var_part[0]));\n \n /* Alloc pool for struct variable_def with a single var_part entry.  */\n-static alloc_pool valvar_pool;\n+static pool_allocator<variable_def> valvar_pool\n+  (\"small variable_def pool\", 256);\n \n /* Alloc pool for struct location_chain_def.  */\n-static alloc_pool loc_chain_pool;\n+pool_allocator<location_chain_def> location_chain_def::pool\n+  (\"location_chain_def pool\", 1024);\n \n /* Alloc pool for struct shared_hash_def.  */\n-static alloc_pool shared_hash_pool;\n+pool_allocator<shared_hash_def> shared_hash_def::pool\n+  (\"shared_hash_def pool\", 256);\n \n /* Alloc pool for struct loc_exp_dep_s for NOT_ONEPART variables.  */\n-static alloc_pool loc_exp_dep_pool;\n+pool_allocator<loc_exp_dep> loc_exp_dep::pool (\"loc_exp_dep pool\", 64);\n \n /* Changed variables, notes will be emitted for them.  */\n static variable_table_type *changed_variables;\n@@ -784,7 +850,7 @@ stack_adjust_offset_pre_post (rtx pattern, HOST_WIDE_INT *pre,\n \t*post += INTVAL (XEXP (src, 1));\n       else\n \t*post -= INTVAL (XEXP (src, 1));\n-      return;\t\n+      return;\n     }\n   HOST_WIDE_INT res[2] = { 0, 0 };\n   for_each_inc_dec (pattern, stack_adjust_offset_pre_post_cb, res);\n@@ -1374,7 +1440,7 @@ dv_onepart_p (decl_or_value dv)\n }\n \n /* Return the variable pool to be used for a dv of type ONEPART.  */\n-static inline alloc_pool\n+static inline pool_allocator <variable_def> &\n onepart_pool (onepart_enum_t onepart)\n {\n   return onepart ? valvar_pool : var_pool;\n@@ -1457,7 +1523,7 @@ variable_htab_free (void *elem)\n       for (node = var->var_part[i].loc_chain; node; node = next)\n \t{\n \t  next = node->next;\n-\t  pool_free (loc_chain_pool, node);\n+\t  delete node;\n \t}\n       var->var_part[i].loc_chain = NULL;\n     }\n@@ -1472,7 +1538,7 @@ variable_htab_free (void *elem)\n       if (var->onepart == ONEPART_DEXPR)\n \tset_dv_changed (var->dv, true);\n     }\n-  pool_free (onepart_pool (var->onepart), var);\n+  onepart_pool (var->onepart).remove (var);\n }\n \n /* Initialize the set (array) SET of attrs to empty lists.  */\n@@ -1496,7 +1562,7 @@ attrs_list_clear (attrs *listp)\n   for (list = *listp; list; list = next)\n     {\n       next = list->next;\n-      pool_free (attrs_pool, list);\n+      delete list;\n     }\n   *listp = NULL;\n }\n@@ -1518,9 +1584,7 @@ static void\n attrs_list_insert (attrs *listp, decl_or_value dv,\n \t\t   HOST_WIDE_INT offset, rtx loc)\n {\n-  attrs list;\n-\n-  list = (attrs) pool_alloc (attrs_pool);\n+  attrs list = new attrs_def;\n   list->loc = loc;\n   list->dv = dv;\n   list->offset = offset;\n@@ -1533,12 +1597,10 @@ attrs_list_insert (attrs *listp, decl_or_value dv,\n static void\n attrs_list_copy (attrs *dstp, attrs src)\n {\n-  attrs n;\n-\n   attrs_list_clear (dstp);\n   for (; src; src = src->next)\n     {\n-      n = (attrs) pool_alloc (attrs_pool);\n+      attrs n = new attrs_def;\n       n->loc = src->loc;\n       n->dv = src->dv;\n       n->offset = src->offset;\n@@ -1612,7 +1674,7 @@ shared_var_p (variable var, shared_hash vars)\n static shared_hash\n shared_hash_unshare (shared_hash vars)\n {\n-  shared_hash new_vars = (shared_hash) pool_alloc (shared_hash_pool);\n+  shared_hash new_vars = new shared_hash_def;\n   gcc_assert (vars->refcount > 1);\n   new_vars->refcount = 1;\n   new_vars->htab = new variable_table_type (vars->htab->elements () + 3);\n@@ -1640,7 +1702,7 @@ shared_hash_destroy (shared_hash vars)\n   if (--vars->refcount == 0)\n     {\n       delete vars->htab;\n-      pool_free (shared_hash_pool, vars);\n+      delete vars;\n     }\n }\n \n@@ -1738,7 +1800,7 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n   variable new_var;\n   int i;\n \n-  new_var = (variable) pool_alloc (onepart_pool (var->onepart));\n+  new_var = onepart_pool (var->onepart).allocate ();\n   new_var->dv = var->dv;\n   new_var->refcount = 1;\n   var->refcount--;\n@@ -1771,7 +1833,7 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n \t{\n \t  location_chain new_lc;\n \n-\t  new_lc = (location_chain) pool_alloc (loc_chain_pool);\n+\t  new_lc = new location_chain_def;\n \t  new_lc->next = NULL;\n \t  if (node->init > initialized)\n \t    new_lc->init = node->init;\n@@ -1936,7 +1998,7 @@ var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify,\n       if (dv_as_opaque (node->dv) != decl || node->offset != offset)\n \t{\n \t  delete_variable_part (set, node->loc, node->dv, node->offset);\n-\t  pool_free (attrs_pool, node);\n+\t  delete node;\n \t  *nextp = next;\n \t}\n       else\n@@ -1977,7 +2039,7 @@ var_reg_delete (dataflow_set *set, rtx loc, bool clobber)\n       if (clobber || !dv_onepart_p (node->dv))\n \t{\n \t  delete_variable_part (set, node->loc, node->dv, node->offset);\n-\t  pool_free (attrs_pool, node);\n+\t  delete node;\n \t  *nextp = next;\n \t}\n       else\n@@ -1997,7 +2059,7 @@ var_regno_delete (dataflow_set *set, int regno)\n     {\n       next = node->next;\n       delete_variable_part (set, node->loc, node->dv, node->offset);\n-      pool_free (attrs_pool, node);\n+      delete node;\n     }\n   *reg = NULL;\n }\n@@ -2047,7 +2109,7 @@ get_addr_from_global_cache (rtx const loc)\n   rtx x;\n \n   gcc_checking_assert (GET_CODE (loc) == VALUE);\n-  \n+\n   bool existed;\n   rtx *slot = &global_get_addr_cache->get_or_insert (loc, &existed);\n   if (existed)\n@@ -2085,14 +2147,14 @@ get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n   location_chain l;\n \n   gcc_checking_assert (GET_CODE (loc) == VALUE);\n-  \n+\n   bool existed;\n   rtx *slot = &local_get_addr_cache->get_or_insert (loc, &existed);\n   if (existed)\n     return *slot;\n \n   x = get_addr_from_global_cache (loc);\n-  \n+\n   /* Tentative, avoiding infinite recursion.  */\n   *slot = x;\n \n@@ -2304,7 +2366,7 @@ drop_overlapping_mem_locs (variable_def **slot, overlapping_mems *coms)\n \t      if (VAR_LOC_1PAUX (var))\n \t\tVAR_LOC_FROM (var) = NULL;\n \t    }\n-\t  pool_free (loc_chain_pool, loc);\n+\t  delete loc;\n \t}\n \n       if (!var->var_part[0].loc_chain)\n@@ -2538,7 +2600,7 @@ val_reset (dataflow_set *set, decl_or_value dv)\n   if (var->onepart == ONEPART_VALUE)\n     {\n       rtx x = dv_as_value (dv);\n-      \n+\n       /* Relationships in the global cache don't change, so reset the\n \t local cache entry only.  */\n       rtx *slot = local_get_addr_cache->get (x);\n@@ -2807,7 +2869,7 @@ variable_union (variable src, dataflow_set *set)\n \t\t  goto restart_onepart_unshared;\n \t\t}\n \n-\t      *nodep = nnode = (location_chain) pool_alloc (loc_chain_pool);\n+\t      *nodep = nnode = new location_chain_def;\n \t      nnode->loc = snode->loc;\n \t      nnode->init = snode->init;\n \t      if (!snode->set_src || MEM_P (snode->set_src))\n@@ -2927,7 +2989,7 @@ variable_union (variable src, dataflow_set *set)\n \t\t    location_chain new_node;\n \n \t\t    /* Copy the location from SRC.  */\n-\t\t    new_node = (location_chain) pool_alloc (loc_chain_pool);\n+\t\t    new_node = new location_chain_def;\n \t\t    new_node->loc = node->loc;\n \t\t    new_node->init = node->init;\n \t\t    if (!node->set_src || MEM_P (node->set_src))\n@@ -2982,7 +3044,7 @@ variable_union (variable src, dataflow_set *set)\n \t\t      location_chain new_node;\n \n \t\t      /* Copy the location from SRC.  */\n-\t\t      new_node = (location_chain) pool_alloc (loc_chain_pool);\n+\t\t      new_node = new location_chain_def;\n \t\t      new_node->loc = node->loc;\n \t\t      new_node->init = node->init;\n \t\t      if (!node->set_src || MEM_P (node->set_src))\n@@ -3078,7 +3140,7 @@ variable_union (variable src, dataflow_set *set)\n \t    {\n \t      location_chain new_lc;\n \n-\t      new_lc = (location_chain) pool_alloc (loc_chain_pool);\n+\t      new_lc = new location_chain_def;\n \t      new_lc->next = NULL;\n \t      new_lc->init = node->init;\n \t      if (!node->set_src || MEM_P (node->set_src))\n@@ -3296,7 +3358,7 @@ insert_into_intersection (location_chain *nodep, rtx loc,\n     else if (r > 0)\n       break;\n \n-  node = (location_chain) pool_alloc (loc_chain_pool);\n+  node = new location_chain_def;\n \n   node->loc = loc;\n   node->set_src = NULL;\n@@ -3817,7 +3879,7 @@ canonicalize_values_star (variable_def **slot, dataflow_set *set)\n \t\t    if (dv_as_opaque (list->dv) == dv_as_opaque (cdv))\n \t\t      {\n \t\t\t*listp = list->next;\n-\t\t\tpool_free (attrs_pool, list);\n+\t\t\tdelete list;\n \t\t\tlist = *listp;\n \t\t\tbreak;\n \t\t      }\n@@ -3835,7 +3897,7 @@ canonicalize_values_star (variable_def **slot, dataflow_set *set)\n \t\t    if (dv_as_opaque (list->dv) == dv_as_opaque (dv))\n \t\t      {\n \t\t\t*listp = list->next;\n-\t\t\tpool_free (attrs_pool, list);\n+\t\t\tdelete list;\n \t\t\tlist = *listp;\n \t\t\tbreak;\n \t\t      }\n@@ -4016,7 +4078,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t{\n \t  if (node)\n \t    {\n-\t      dvar = (variable) pool_alloc (onepart_pool (onepart));\n+\t      dvar = onepart_pool (onepart).allocate ();\n \t      dvar->dv = dv;\n \t      dvar->refcount = 1;\n \t      dvar->n_var_parts = 1;\n@@ -4152,8 +4214,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n \t\t\t\t\t\t\t  INSERT);\n \t\t  if (!*slot)\n \t\t    {\n-\t\t      variable var = (variable) pool_alloc (onepart_pool\n-\t\t\t\t\t\t\t    (ONEPART_VALUE));\n+\t\t      variable var = onepart_pool (ONEPART_VALUE).allocate ();\n \t\t      var->dv = dv;\n \t\t      var->refcount = 1;\n \t\t      var->n_var_parts = 1;\n@@ -4240,7 +4301,7 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   dataflow_set_init (dst);\n   dst->stack_adjust = cur.stack_adjust;\n   shared_hash_destroy (dst->vars);\n-  dst->vars = (shared_hash) pool_alloc (shared_hash_pool);\n+  dst->vars = new shared_hash_def;\n   dst->vars->refcount = 1;\n   dst->vars->htab = new variable_table_type (MAX (src1_elems, src2_elems));\n \n@@ -4366,7 +4427,7 @@ remove_duplicate_values (variable var)\n \t    {\n \t      /* Remove duplicate value node.  */\n \t      *nodep = node->next;\n-\t      pool_free (loc_chain_pool, node);\n+\t      delete node;\n \t      continue;\n \t    }\n \t  else\n@@ -4519,7 +4580,7 @@ variable_post_merge_new_vals (variable_def **slot, dfset_post_merge *dfpm)\n \t\t to be added when we bring perm in.  */\n \t      att = *curp;\n \t      *curp = att->next;\n-\t      pool_free (attrs_pool, att);\n+\t      delete att;\n \t    }\n \t}\n \n@@ -4779,7 +4840,7 @@ dataflow_set_preserve_mem_locs (variable_def **slot, dataflow_set *set)\n \t\t}\n \t    }\n \t  *locp = loc->next;\n-\t  pool_free (loc_chain_pool, loc);\n+\t  delete loc;\n \t}\n \n       if (!var->var_part[0].loc_chain)\n@@ -4851,7 +4912,7 @@ dataflow_set_remove_mem_locs (variable_def **slot, dataflow_set *set)\n \t      if (VAR_LOC_1PAUX (var))\n \t\tVAR_LOC_FROM (var) = NULL;\n \t    }\n-\t  pool_free (loc_chain_pool, loc);\n+\t  delete loc;\n \t}\n \n       if (!var->var_part[0].loc_chain)\n@@ -7302,7 +7363,7 @@ variable_from_dropped (decl_or_value dv, enum insert_option insert)\n \n   gcc_checking_assert (onepart == ONEPART_VALUE || onepart == ONEPART_DEXPR);\n \n-  empty_var = (variable) pool_alloc (onepart_pool (onepart));\n+  empty_var = onepart_pool (onepart).allocate ();\n   empty_var->dv = dv;\n   empty_var->refcount = 1;\n   empty_var->n_var_parts = 0;\n@@ -7406,7 +7467,7 @@ variable_was_changed (variable var, dataflow_set *set)\n \n \t  if (!empty_var)\n \t    {\n-\t      empty_var = (variable) pool_alloc (onepart_pool (onepart));\n+\t      empty_var = onepart_pool (onepart).allocate ();\n \t      empty_var->dv = var->dv;\n \t      empty_var->refcount = 1;\n \t      empty_var->n_var_parts = 0;\n@@ -7530,7 +7591,7 @@ set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n   if (!var)\n     {\n       /* Create new variable information.  */\n-      var = (variable) pool_alloc (onepart_pool (onepart));\n+      var = onepart_pool (onepart).allocate ();\n       var->dv = dv;\n       var->refcount = 1;\n       var->n_var_parts = 1;\n@@ -7725,7 +7786,7 @@ set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t\tset_src = node->set_src;\n \t      if (var->var_part[pos].cur_loc == node->loc)\n \t\tvar->var_part[pos].cur_loc = NULL;\n-\t      pool_free (loc_chain_pool, node);\n+\t      delete node;\n \t      *nextp = next;\n \t      break;\n \t    }\n@@ -7737,7 +7798,7 @@ set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n     }\n \n   /* Add the location to the beginning.  */\n-  node = (location_chain) pool_alloc (loc_chain_pool);\n+  node = new location_chain_def;\n   node->loc = loc;\n   node->init = initialized;\n   node->set_src = set_src;\n@@ -7819,7 +7880,7 @@ clobber_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t\t      if (dv_as_opaque (anode->dv) == dv_as_opaque (var->dv)\n \t\t\t  && anode->offset == offset)\n \t\t\t{\n-\t\t\t  pool_free (attrs_pool, anode);\n+\t\t\t  delete anode;\n \t\t\t  *anextp = anext;\n \t\t\t}\n \t\t      else\n@@ -7919,7 +7980,7 @@ delete_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t\t  if (pos == 0 && var->onepart && VAR_LOC_1PAUX (var))\n \t\t    VAR_LOC_FROM (var) = NULL;\n \t\t}\n-\t      pool_free (loc_chain_pool, node);\n+\t      delete node;\n \t      *nextp = next;\n \t      break;\n \t    }\n@@ -8080,7 +8141,7 @@ loc_exp_insert_dep (variable var, rtx x, variable_table_type *vars)\n     return;\n \n   if (var->onepart == NOT_ONEPART)\n-    led = (loc_exp_dep *) pool_alloc (loc_exp_dep_pool);\n+    led = new loc_exp_dep;\n   else\n     {\n       loc_exp_dep empty;\n@@ -8888,7 +8949,7 @@ notify_dependents_of_changed_value (rtx val, variable_table_type *htab,\n \t  break;\n \n \tcase NOT_ONEPART:\n-\t  pool_free (loc_exp_dep_pool, led);\n+\t  delete led;\n \t  ivar = htab->find_with_hash (ldv, dv_htab_hash (ldv));\n \t  if (ivar)\n \t    {\n@@ -9010,7 +9071,7 @@ emit_notes_for_differences_1 (variable_def **slot, variable_table_type *new_vars\n \n       if (!empty_var)\n \t{\n-\t  empty_var = (variable) pool_alloc (onepart_pool (old_var->onepart));\n+\t  empty_var = onepart_pool (old_var->onepart).allocate ();\n \t  empty_var->dv = old_var->dv;\n \t  empty_var->refcount = 0;\n \t  empty_var->n_var_parts = 0;\n@@ -9451,8 +9512,6 @@ vt_emit_notes (void)\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       dropped_values = new variable_table_type (cselib_get_next_uid () * 2);\n-      loc_exp_dep_pool = create_alloc_pool (\"loc_exp_dep pool\",\n-\t\t\t\t\t    sizeof (loc_exp_dep), 64);\n     }\n \n   dataflow_set_init (&cur);\n@@ -9871,18 +9930,7 @@ vt_initialize (void)\n \n   alloc_aux_for_blocks (sizeof (struct variable_tracking_info_def));\n \n-  attrs_pool = create_alloc_pool (\"attrs_def pool\",\n-\t\t\t\t  sizeof (struct attrs_def), 1024);\n-  var_pool = create_alloc_pool (\"variable_def pool\",\n-\t\t\t\tsizeof (struct variable_def)\n-\t\t\t\t+ (MAX_VAR_PARTS - 1)\n-\t\t\t\t* sizeof (((variable)NULL)->var_part[0]), 64);\n-  loc_chain_pool = create_alloc_pool (\"location_chain_def pool\",\n-\t\t\t\t      sizeof (struct location_chain_def),\n-\t\t\t\t      1024);\n-  shared_hash_pool = create_alloc_pool (\"shared_hash_def pool\",\n-\t\t\t\t\tsizeof (struct shared_hash_def), 256);\n-  empty_shared_hash = (shared_hash) pool_alloc (shared_hash_pool);\n+  empty_shared_hash = new shared_hash_def;\n   empty_shared_hash->refcount = 1;\n   empty_shared_hash->htab = new variable_table_type (1);\n   changed_variables = new variable_table_type (10);\n@@ -9901,15 +9949,12 @@ vt_initialize (void)\n     {\n       cselib_init (CSELIB_RECORD_MEMORY | CSELIB_PRESERVE_CONSTANTS);\n       scratch_regs = BITMAP_ALLOC (NULL);\n-      valvar_pool = create_alloc_pool (\"small variable_def pool\",\n-\t\t\t\t       sizeof (struct variable_def), 256);\n       preserved_values.create (256);\n       global_get_addr_cache = new hash_map<rtx, rtx>;\n     }\n   else\n     {\n       scratch_regs = NULL;\n-      valvar_pool = NULL;\n       global_get_addr_cache = NULL;\n     }\n \n@@ -10243,20 +10288,18 @@ vt_finalize (void)\n   empty_shared_hash->htab = NULL;\n   delete changed_variables;\n   changed_variables = NULL;\n-  free_alloc_pool (attrs_pool);\n-  free_alloc_pool (var_pool);\n-  free_alloc_pool (loc_chain_pool);\n-  free_alloc_pool (shared_hash_pool);\n+  attrs_def::pool.release ();\n+  var_pool.release ();\n+  location_chain_def::pool.release ();\n+  shared_hash_def::pool.release ();\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       if (global_get_addr_cache)\n \tdelete global_get_addr_cache;\n       global_get_addr_cache = NULL;\n-      if (loc_exp_dep_pool)\n-\tfree_alloc_pool (loc_exp_dep_pool);\n-      loc_exp_dep_pool = NULL;\n-      free_alloc_pool (valvar_pool);\n+      loc_exp_dep::pool.release ();\n+      valvar_pool.release ();\n       preserved_values.release ();\n       cselib_finish ();\n       BITMAP_FREE (scratch_regs);"}]}