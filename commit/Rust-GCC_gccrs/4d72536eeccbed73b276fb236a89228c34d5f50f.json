{"sha": "4d72536eeccbed73b276fb236a89228c34d5f50f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3MjUzNmVlY2NiZWQ3M2IyNzZmYjIzNmE4OTIyOGMzNGQ1ZjUwZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-03-22T09:55:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-03-22T09:55:03Z"}, "message": "abi64.h (SETUP_INCOMING_VARARGS): Undefine.\n\n\t* config/mips/abi64.h (SETUP_INCOMING_VARARGS): Undefine.\n\t* config/mips/mips-protos.h (mips_setup_incoming_varargs): Declare.\n\t(function_arg): Constify CUMULATIVE_ARGS.\n\t(function_arg_partial_nregs, function_arg_pass_by_reference): Likewise.\n\t* config/mips/mips.h (UNITS_PER_FPVALUE): Zero when TARGET_SOFT_FLOAT.\n\t(UNITS_PER_DOUBLE): New macro.\n\t(SETUP_INCOMING_VARARGS): Define.  Use mips_setup_incoming_varargs.\n\t(CUMULATIVE_ARGS): Reformat.  Remove num_adjusts workaround and\n\tlast_arg_fp field.  Replace arg_words and fp_arg_words with gp_regs,\n\tfp_regs and stack_words.\n\t(EABI_FLOAT_VARARGS_P): New macro.\n\t* config/mips/mips.c (struct mips_arg_info): New.\n\t(mips_arg_info): New function.\n\t(function_arg_advance): Use it.  Add adjustment instructions here\n\trather than in function_arg.\n\t(function_arg): Constify CUMULATIVE_ARGS.  Use mips_arg_info.  Check\n\tfor VOIDmode at the beginning of the function.\n\t(function_partial_nregs): Constify CUMULATIVE_ARGS.  Use mips_arg_info.\n\t(function_arg_pass_by_reference): Likewise.\n\t(mips_setup_incoming_varags): New, largely based on old abi64.h code.\n\t(mips_build_va_list): Test EABI_FLOAT_VARARGS_P.\n\t(mips_va_start): Likewise.  Use the new stack_words field of\n\tCUMULATIVE_ARGS to set up overflow area.  Reformat.\n\t(mips_va_arg): Test EABI_FLOAT_VARARGS_P.  Unify EABI handling of\n\tdoubles and other types, aligning the overflow pointer for non-doubles\n\ttoo.  Remove some code duplication.  Replace hard-coded constants.\n\nFrom-SVN: r51167", "tree": {"sha": "2b34aeb080522c674434cc281e4179ead1084609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b34aeb080522c674434cc281e4179ead1084609"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d72536eeccbed73b276fb236a89228c34d5f50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d72536eeccbed73b276fb236a89228c34d5f50f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d72536eeccbed73b276fb236a89228c34d5f50f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d72536eeccbed73b276fb236a89228c34d5f50f/comments", "author": null, "committer": null, "parents": [{"sha": "e6f884cdac3ca7194b8cf8113702251aac072fa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f884cdac3ca7194b8cf8113702251aac072fa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f884cdac3ca7194b8cf8113702251aac072fa9"}], "stats": {"total": 1346, "additions": 641, "deletions": 705}, "files": [{"sha": "eadd60735300ff930d58ff4f89fba64260d4df56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d72536eeccbed73b276fb236a89228c34d5f50f", "patch": "@@ -1,3 +1,32 @@\n+2002-03-22  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/abi64.h (SETUP_INCOMING_VARARGS): Undefine.\n+\t* config/mips/mips-protos.h (mips_setup_incoming_varargs): Declare.\n+\t(function_arg): Constify CUMULATIVE_ARGS.\n+\t(function_arg_partial_nregs, function_arg_pass_by_reference): Likewise.\n+\t* config/mips/mips.h (UNITS_PER_FPVALUE): Zero when TARGET_SOFT_FLOAT.\n+\t(UNITS_PER_DOUBLE): New macro.\n+\t(SETUP_INCOMING_VARARGS): Define.  Use mips_setup_incoming_varargs.\n+\t(CUMULATIVE_ARGS): Reformat.  Remove num_adjusts workaround and\n+\tlast_arg_fp field.  Replace arg_words and fp_arg_words with gp_regs,\n+\tfp_regs and stack_words.\n+\t(EABI_FLOAT_VARARGS_P): New macro.\n+\t* config/mips/mips.c (struct mips_arg_info): New.\n+\t(mips_arg_info): New function.\n+\t(function_arg_advance): Use it.  Add adjustment instructions here\n+\trather than in function_arg.\n+\t(function_arg): Constify CUMULATIVE_ARGS.  Use mips_arg_info.  Check\n+\tfor VOIDmode at the beginning of the function.\n+\t(function_partial_nregs): Constify CUMULATIVE_ARGS.  Use mips_arg_info.\n+\t(function_arg_pass_by_reference): Likewise.\n+\t(mips_setup_incoming_varags): New, largely based on old abi64.h code.\n+\t(mips_build_va_list): Test EABI_FLOAT_VARARGS_P.\n+\t(mips_va_start): Likewise.  Use the new stack_words field of\n+\tCUMULATIVE_ARGS to set up overflow area.  Reformat.\n+\t(mips_va_arg): Test EABI_FLOAT_VARARGS_P.  Unify EABI handling of\n+\tdoubles and other types, aligning the overflow pointer for non-doubles\n+\ttoo.  Remove some code duplication.  Replace hard-coded constants.\n+\n 2002-03-22  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.h (FUNCTION_ARG_REGNO_P): Simplify."}, {"sha": "5ba856f17a1b26dc6e35f80b39eeaaabdf2c9967", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=4d72536eeccbed73b276fb236a89228c34d5f50f", "patch": "@@ -102,96 +102,6 @@ Boston, MA 02111-1307, USA.  */\n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE, FUNC)\tmips_function_value (VALTYPE, FUNC)\n \n-/* For varargs, we must save the current argument, because it is the fake\n-   argument va_alist, and will need to be converted to the real argument.\n-   For stdarg, we do not need to save the current argument, because it\n-   is a real argument.  */\n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n-{ unsigned int mips_off\t\t\t\t\t\t\t\\\n-    = (! current_function_varargs) && (! (CUM).last_arg_fp);\t\t\\\n-    unsigned int mips_fp_off\t\t\t\t\t\t\\\n-    = (! current_function_varargs) && ((CUM).last_arg_fp); \t\t\\\n-  if (((mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t\\\n-       && (CUM).arg_words < MAX_ARGS_IN_REGISTERS - mips_off)\t\t\\\n-      || (mips_abi == ABI_EABI\t\t\t\t\t\t\\\n-\t  && ! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t  && (CUM).fp_arg_words < MAX_ARGS_IN_REGISTERS - mips_fp_off))\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int mips_save_gp_regs\t\t\t\t\t\t\\\n-        = MAX_ARGS_IN_REGISTERS - (CUM).arg_words - mips_off;\t\t\\\n-      int mips_save_fp_regs\t\t\t\t\t\t\\\n-        = (mips_abi != ABI_EABI ? 0\t\t\t\t\t\\\n-\t   : MAX_ARGS_IN_REGISTERS - (CUM).fp_arg_words - mips_fp_off);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (mips_save_gp_regs < 0)\t\t\t\t\t\\\n-\tmips_save_gp_regs = 0;\t\t\t\t\t\t\\\n-      if (mips_save_fp_regs < 0)\t\t\t\t\t\\\n-\tmips_save_fp_regs = 0;\t\t\t\t\t\t\\\n-      PRETEND_SIZE = ((mips_save_gp_regs * UNITS_PER_WORD)\t\t\\\n-\t\t      + (mips_save_fp_regs * UNITS_PER_FPREG));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (! (NO_RTL))\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if ((CUM).arg_words < MAX_ARGS_IN_REGISTERS - mips_off)\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      rtx ptr, mem;\t\t\t\t\t\t\\\n-\t      if (mips_abi != ABI_EABI)\t\t\t\t\t\\\n-\t\tptr = virtual_incoming_args_rtx;\t\t\t\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tptr = plus_constant (virtual_incoming_args_rtx,\t\t\\\n-\t\t\t\t     - (mips_save_gp_regs\t\t\\\n-\t\t\t\t\t* UNITS_PER_WORD));\t\t\\\n-\t      mem = gen_rtx_MEM (BLKmode, ptr);\t\t\t\\\n-\t      /* va_arg is an array access in this case, which causes\t\\\n-\t\t it to get MEM_IN_STRUCT_P set.  We must set it here\t\\\n-\t\t so that the insn scheduler won't assume that these\t\\\n-\t\t stores can't possibly overlap with the va_arg loads.  */ \\\n-\t      if (mips_abi != ABI_EABI && BYTES_BIG_ENDIAN)\t\t\\\n-\t        MEM_SET_IN_STRUCT_P (mem, 1);\t\t\t\t\\\n-\t      move_block_from_reg\t\t\t\t\t\\\n-\t\t((CUM).arg_words + GP_ARG_FIRST + mips_off,\t\t\\\n-\t\t mem,\t\t\t\t\t\t\t\\\n-\t\t mips_save_gp_regs,\t\t\t\t\t\\\n-\t\t mips_save_gp_regs * UNITS_PER_WORD);\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  if (mips_abi == ABI_EABI\t\t\t\t\t\\\n-\t      && ! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n-\t      && (CUM).fp_arg_words < MAX_ARGS_IN_REGISTERS - mips_fp_off) \\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      enum machine_mode mode = TARGET_SINGLE_FLOAT ? SFmode : DFmode; \\\n-\t      int size = GET_MODE_SIZE (mode);\t\t\t\t\\\n-\t      int off;\t\t\t\t\t\t\t\\\n-\t      int i;\t\t\t\t\t\t\t\\\n-\t      /* We can't use move_block_from_reg, because it will use\t\\\n-                 the wrong mode.  */\t\t\t\t\t\\\n-\t      off = - (mips_save_gp_regs * UNITS_PER_WORD);\t\t\\\n-\t      if (! TARGET_SINGLE_FLOAT)\t\t\t\t\\\n-\t        off &= ~ 7;\t\t\t\t\t\t\\\n-\t      if (! TARGET_FLOAT64 || TARGET_SINGLE_FLOAT)\t\t\\\n-\t\toff -= (mips_save_fp_regs / 2) * size;\t\t\t\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\toff -= mips_save_fp_regs * size;\t\t\t\\\n-\t      for (i = 0; i < mips_save_fp_regs; i++)\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  rtx tem =\t\t\t\t\t\t\\\n-\t\t    gen_rtx_MEM (mode,\t\t\t\t\t\\\n-\t\t\t\t plus_constant (virtual_incoming_args_rtx, \\\n-\t\t\t\t\t\toff));\t\t\t\\\n-\t\t  emit_move_insn (tem,\t\t\t\t\t\\\n-\t\t\t\t  gen_rtx_REG (mode,\t\t\t\\\n-\t\t\t\t\t       ((CUM).fp_arg_words\t\\\n-\t\t\t\t\t\t+ FP_ARG_FIRST\t\t\\\n-\t\t\t\t\t\t+ i\t\t\t\\\n-\t\t\t\t\t\t+ mips_fp_off)));\t\\\n-\t\t  off += size;\t\t\t\t\t\t\\\n-\t\t  if (! TARGET_FLOAT64 || TARGET_SINGLE_FLOAT)\t\t\\\n-\t\t    ++i;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n #define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \n /* A C expression that indicates when an argument must be passed by"}, {"sha": "8332782db5a167db90b20ee91d267894f87f6bfe", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=4d72536eeccbed73b276fb236a89228c34d5f50f", "patch": "@@ -56,16 +56,21 @@ extern unsigned int\tmips_hard_regno_nregs PARAMS ((int,\n \t\t\t\t\t\t       enum machine_mode));\n extern int              mips_return_in_memory PARAMS ((tree));\n \n-extern struct rtx_def  *function_arg PARAMS ((CUMULATIVE_ARGS *,\n+extern struct rtx_def  *function_arg PARAMS ((const CUMULATIVE_ARGS *,\n \t\t\t\t\t      enum machine_mode, tree, int));\n extern void\t\tfunction_arg_advance PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t      enum machine_mode,\n \t\t\t\t\t\t      tree, int));\n-extern int\t\tfunction_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t\t    enum machine_mode,\n-\t\t\t\t\t\t\t    tree, int));\n+extern int\t\tfunction_arg_partial_nregs\n+\t\t\t\tPARAMS ((const CUMULATIVE_ARGS *,\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t tree, int));\n+extern int\t\tmips_setup_incoming_varargs\n+\t\t\t\tPARAMS ((const CUMULATIVE_ARGS *,\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t tree, int));\n extern int\t\tfunction_arg_pass_by_reference\n-\t\t\t\tPARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\tPARAMS ((const CUMULATIVE_ARGS *,\n \t\t\t\t\t enum machine_mode, tree, int));\n extern int\t\tmips16_constant_after_function_p PARAMS ((tree));\n extern int\t\tmips_output_external PARAMS ((FILE *, tree,"}, {"sha": "f5bf7773fe9fdc720ae8da0055669e6b8d5e2cd5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 521, "deletions": 585, "changes": 1106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4d72536eeccbed73b276fb236a89228c34d5f50f", "patch": "@@ -86,6 +86,7 @@ enum internal_test {\n \n \n struct constant;\n+struct mips_arg_info;\n static enum internal_test map_test_to_internal_test\tPARAMS ((enum rtx_code));\n static int mips16_simple_memory_operand\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\tenum machine_mode));\n@@ -95,6 +96,10 @@ static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t int,\n \t\t\t\t\t\t\t rtx, rtx));\n static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n+static void mips_arg_info\t\tPARAMS ((const CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t tree, int,\n+\t\t\t\t\t\t struct mips_arg_info *));\n static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t\t\t FILE *));\n static void mips_annotate_frame_insn\t\tPARAMS ((rtx, rtx));\n@@ -150,6 +155,34 @@ struct machine_function {\n   rtx mips16_gp_pseudo_rtx;\n };\n \n+/* Information about a single argument.  */\n+struct mips_arg_info\n+{\n+  /* True if the argument is a record or union type.  */\n+  bool struct_p;\n+\n+  /* True if the argument is passed in a floating-point register, or\n+     would have been if we hadn't run out of registers.  */\n+  bool fpr_p;\n+\n+  /* The argument's size, in bytes.  */\n+  unsigned int num_bytes;\n+\n+  /* The number of words passed in registers, rounded up.  */\n+  unsigned int reg_words;\n+\n+  /* The offset of the first register from GP_ARG_FIRST or FP_ARG_FIRST,\n+     or MAX_ARGS_IN_REGISTERS if the argument is passed entirely\n+     on the stack.  */\n+  unsigned int reg_offset;\n+\n+  /* The number of words that must be passed on the stack, rounded up.  */\n+  unsigned int stack_words;\n+\n+  /* The offset from the start of the stack overflow area of the argument's\n+     first stack word.  Only meaningful when STACK_WORDS is non-zero.  */\n+  unsigned int stack_offset;\n+};\n \n /* Global variables for machine-dependent things.  */\n \n@@ -3918,6 +3951,103 @@ init_cumulative_args (cum, fntype, libname)\n     }\n }\n \n+static void\n+mips_arg_info (cum, mode, type, named, info)\n+     const CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+     struct mips_arg_info *info;\n+{\n+  bool even_reg_p;\n+  unsigned int num_words, max_regs;\n+\n+  info->struct_p = (type != 0\n+\t\t    && (TREE_CODE (type) == RECORD_TYPE\n+\t\t\t|| TREE_CODE (type) == UNION_TYPE\n+\t\t\t|| TREE_CODE (type) == QUAL_UNION_TYPE));\n+\n+  /* Decide whether this argument should go in a floating-point register,\n+     assuming one is free.  Later code checks for availablity.  */\n+\n+  info->fpr_p = false;\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE)\n+    {\n+      switch (mips_abi)\n+\t{\n+\tcase ABI_32:\n+\tcase ABI_O64:\n+\t  info->fpr_p = (!cum->gp_reg_found && cum->arg_number < 2);\n+\t  break;\n+\n+\tcase ABI_EABI:\n+\t  info->fpr_p = true;\n+\t  break;\n+\n+\tcase ABI_MEABI:\n+\t  /* The MIPS eabi says only structures containing doubles get\n+\t     passed in a fp register, so force a structure containing\n+\t     a float to be passed in the integer registers.  */\n+\t  info->fpr_p = (named && !(mode == SFmode && info->struct_p));\n+\t  break;\n+\n+\tdefault:\n+\t  info->fpr_p = named;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Now decide whether the argument must go in an even-numbered register.  */\n+\n+  even_reg_p = false;\n+  if (info->fpr_p)\n+    {\n+      /* Under the O64 ABI, the second float argument goes in $f13 if it\n+\t is a double, but $f14 if it is a single.  Otherwise, on a\n+\t 32-bit double-float machine, each FP argument must start in a\n+\t new register pair.  */\n+      even_reg_p = ((mips_abi == ABI_O64 && mode == SFmode) || FP_INC > 1);\n+    }\n+  else if (!TARGET_64BIT)\n+    {\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\teven_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n+\n+      else if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD)\n+\teven_reg_p = true;\n+    }\n+\n+  /* Set REG_OFFSET to the register count we're interested in.\n+     The EABI allocates the floating-point registers separately,\n+     but the other ABIs allocate them like integer registers.  */\n+  info->reg_offset = (mips_abi == ABI_EABI && info->fpr_p\n+\t\t      ? cum->fp_regs\n+\t\t      : cum->gp_regs);\n+\n+  if (even_reg_p)\n+    info->reg_offset += info->reg_offset & 1;\n+\n+  /* The alignment applied to registers is also applied to stack arguments.  */\n+  info->stack_offset = cum->stack_words;\n+  if (even_reg_p)\n+    info->stack_offset += info->stack_offset & 1;\n+\n+  if (mode == BLKmode)\n+    info->num_bytes = int_size_in_bytes (type);\n+  else\n+    info->num_bytes = GET_MODE_SIZE (mode);\n+\n+  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  max_regs = MAX_ARGS_IN_REGISTERS - info->reg_offset;\n+\n+  /* Partition the argument between registers and stack.  */\n+  info->reg_words = MIN (num_words, max_regs);\n+  info->stack_words = num_words - info->reg_words;\n+}\n+\n+\n /* Advance the argument to the next argument position.  */\n \n void\n@@ -3927,399 +4057,282 @@ function_arg_advance (cum, mode, type, named)\n      tree type;\t\t\t/* type of the argument or 0 if lib support */\n      int named;\t\t\t/* whether or not the argument was named */\n {\n-  if (TARGET_DEBUG_E_MODE)\n+  struct mips_arg_info info;\n+\n+  mips_arg_info (cum, mode, type, named, &info);\n+\n+  /* The following is a hack in order to pass 1 byte structures\n+     the same way that the MIPS compiler does (namely by passing\n+     the structure in the high byte or half word of the register).\n+     This also makes varargs work.  If we have such a structure,\n+     we save the adjustment RTL, and the call define expands will\n+     emit them.  For the VOIDmode argument (argument after the\n+     last real argument), pass back a parallel vector holding each\n+     of the adjustments.  */\n+\n+  /* ??? This scheme requires everything smaller than the word size to\n+     shifted to the left, but when TARGET_64BIT and ! TARGET_INT64,\n+     that would mean every int needs to be shifted left, which is very\n+     inefficient.  Let's not carry this compatibility to the 64 bit\n+     calling convention for now.  */\n+\n+  if (info.struct_p\n+      && info.reg_words == 1\n+      && info.num_bytes < UNITS_PER_WORD\n+      && !TARGET_64BIT\n+      && mips_abi != ABI_EABI\n+      && mips_abi != ABI_MEABI)\n     {\n-      fprintf (stderr,\n-\t       \"function_adv({gp reg found = %d, arg # = %2d, words = %2d}, %4s, \",\n-\t       cum->gp_reg_found, cum->arg_number, cum->arg_words,\n-\t       GET_MODE_NAME (mode));\n-      fprintf (stderr, HOST_PTR_PRINTF, (const PTR) type);\n-      fprintf (stderr, \", %d )\\n\\n\", named);\n-    }\n+      rtx amount = GEN_INT (BITS_PER_WORD - info.num_bytes * BITS_PER_UNIT);\n+      rtx reg = gen_rtx_REG (word_mode, GP_ARG_FIRST + info.reg_offset);\n \n-  cum->arg_number++;\n-  switch (mode)\n-    {\n-    case VOIDmode:\n-      break;\n-\n-    default:\n-      if (GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n-\t  && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-\tabort ();\n-\n-      cum->gp_reg_found = 1;\n-      cum->arg_words += ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n-\t\t\t / UNITS_PER_WORD);\n-      break;\n+      if (TARGET_64BIT)\n+\tcum->adjust[cum->num_adjusts++] = gen_ashldi3 (reg, reg, amount);\n+      else\n+\tcum->adjust[cum->num_adjusts++] = gen_ashlsi3 (reg, reg, amount);\n+    }\n \n-    case BLKmode:\n-      cum->gp_reg_found = 1;\n-      cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n-\t\t\t / UNITS_PER_WORD);\n-      break;\n+  if (!info.fpr_p)\n+    cum->gp_reg_found = true;\n \n-    case SFmode:\n-      if (mips_abi == ABI_EABI && ! TARGET_SOFT_FLOAT)\n-\tcum->fp_arg_words++;\n-      else\n-\tcum->arg_words++;\n-      if (! cum->gp_reg_found && cum->arg_number <= 2)\n-\tcum->fp_code += 1 << ((cum->arg_number - 1) * 2);\n-      break;\n+  /* See the comment above the cumulative args structure in mips.h\n+     for an explanation of what this code does.  It assumes the O32\n+     ABI, which passes at most 2 arguments in float registers.  */\n+  if (cum->arg_number < 2 && info.fpr_p)\n+    cum->fp_code += (mode == SFmode ? 1 : 2) << ((cum->arg_number - 1) * 2);\n \n-    case DFmode:\n-      if (mips_abi == ABI_EABI && ! TARGET_SOFT_FLOAT && ! TARGET_SINGLE_FLOAT)\n-\tcum->fp_arg_words += (TARGET_64BIT ? 1 : 2);\n-      else\n-\tcum->arg_words += (TARGET_64BIT ? 1 : 2);\n-      if (! cum->gp_reg_found && ! TARGET_SINGLE_FLOAT && cum->arg_number <= 2)\n-\tcum->fp_code += 2 << ((cum->arg_number - 1) * 2);\n-      break;\n+  if (mips_abi != ABI_EABI || !info.fpr_p)\n+    cum->gp_regs = info.reg_offset + info.reg_words;\n+  else if (info.reg_words > 0)\n+    cum->fp_regs += FP_INC;\n \n-    case DImode:\n-    case TImode:\n-      cum->gp_reg_found = 1;\n-      cum->arg_words += (TARGET_64BIT ? 1 : 2);\n-      break;\n+  if (info.stack_words > 0)\n+    cum->stack_words = info.stack_offset + info.stack_words;\n \n-    case QImode:\n-    case HImode:\n-    case SImode:\n-      cum->gp_reg_found = 1;\n-      cum->arg_words++;\n-      break;\n-    }\n+  cum->arg_number++;\n }\n \n /* Return an RTL expression containing the register for the given mode,\n    or 0 if the argument is to be passed on the stack.  */\n \n struct rtx_def *\n function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     const CUMULATIVE_ARGS *cum; /* current arg information */\n      enum machine_mode mode;\t/* current arg mode */\n      tree type;\t\t\t/* type of the argument or 0 if lib support */\n      int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n {\n-  rtx ret;\n-  int regbase = -1;\n-  int bias = 0;\n-  unsigned int *arg_words = &cum->arg_words;\n-  int struct_p = (type != 0\n-\t\t  && (TREE_CODE (type) == RECORD_TYPE\n-\t\t      || TREE_CODE (type) == UNION_TYPE\n-\t\t      || TREE_CODE (type) == QUAL_UNION_TYPE));\n-\n-  if (TARGET_DEBUG_E_MODE)\n-    {\n-      fprintf (stderr,\n-\t       \"function_arg( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, \",\n-\t       cum->gp_reg_found, cum->arg_number, cum->arg_words,\n-\t       GET_MODE_NAME (mode));\n-      fprintf (stderr, HOST_PTR_PRINTF, (const PTR) type);\n-      fprintf (stderr, \", %d ) = \", named);\n-    }\n-\n+  struct mips_arg_info info;\n \n-  cum->last_arg_fp = 0;\n-  switch (mode)\n+  /* We will be called with a mode of VOIDmode after the last argument\n+     has been seen.  Whatever we return will be passed to the call\n+     insn.  If we need any shifts for small structures, return them in\n+     a PARALLEL; in that case, stuff the mips16 fp_code in as the\n+     mode.  Otherwise, if we need a mips16 fp_code, return a REG\n+     with the code stored as the mode.  */\n+  if (mode == VOIDmode)\n     {\n-    case SFmode:\n-      if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n-\t{\n-\t  if (cum->gp_reg_found || cum->arg_number >= 2 || TARGET_SOFT_FLOAT)\n-\t    regbase = GP_ARG_FIRST;\n-\t  else\n-\t    {\n-\t      regbase = FP_ARG_FIRST;\n-\n-\t      /* If the first arg was a float in a floating point register,\n-\t\t then set bias to align this float arg properly.  */\n-\t      if (cum->arg_words == 1)\n-\t\tbias = 1;\n-\t    }\n-\t}\n-      else if (mips_abi == ABI_EABI && ! TARGET_SOFT_FLOAT)\n-\t{\n-\t  if (! TARGET_64BIT)\n-\t    cum->fp_arg_words += cum->fp_arg_words & 1;\n-\t  cum->last_arg_fp = 1;\n-\t  arg_words = &cum->fp_arg_words;\n-\t  regbase = FP_ARG_FIRST;\n-\t}\n-      /* The MIPS eabi says only structures containing doubles get passed in a\n-         fp register, so force a structure containing a float to be passed in\n-         the integer registers.  */\n-      else if (mips_abi == ABI_MEABI && struct_p)\n-\tregbase = GP_ARG_FIRST;\n-      else\n-\tregbase = (TARGET_SOFT_FLOAT || ! named ? GP_ARG_FIRST : FP_ARG_FIRST);\n-      break;\n+      if (cum->num_adjusts > 0)\n+\treturn gen_rtx_PARALLEL ((enum machine_mode) cum->fp_code,\n+\t\t\t\t gen_rtvec_v (cum->num_adjusts,\n+\t\t\t\t\t      (rtx *) cum->adjust));\n \n-    case DFmode:\n-      if (! TARGET_64BIT)\n-\t{\n-\t  if (mips_abi == ABI_EABI\n-\t      && ! TARGET_SOFT_FLOAT && ! TARGET_SINGLE_FLOAT)\n-\t    cum->fp_arg_words += cum->fp_arg_words & 1;\n-\t  else\n-\t    cum->arg_words += cum->arg_words & 1;\n-\t}\n+      else if (TARGET_MIPS16 && cum->fp_code != 0)\n+\treturn gen_rtx_REG ((enum machine_mode) cum->fp_code, 0);\n \n-      if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n-\tregbase = ((cum->gp_reg_found\n-\t\t    || TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT\n-\t\t    || cum->arg_number >= 2)\n-\t\t   ? GP_ARG_FIRST : FP_ARG_FIRST);\n-      else if (mips_abi == ABI_EABI\n-\t       && ! TARGET_SOFT_FLOAT && ! TARGET_SINGLE_FLOAT)\n-\t{\n-\t  cum->last_arg_fp = 1;\n-\t  arg_words = &cum->fp_arg_words;\n-\t  regbase = FP_ARG_FIRST;\n-\t}\n       else\n-\tregbase = (TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT || ! named\n-\t\t   ? GP_ARG_FIRST : FP_ARG_FIRST);\n-      break;\n-\n-    default:\n-      if (GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n-\t  && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-\tabort ();\n-\n-      /* Drops through.  */\n-    case BLKmode:\n-      if (type != NULL_TREE && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD\n-\t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n-\tcum->arg_words += (cum->arg_words & 1);\n-      regbase = GP_ARG_FIRST;\n-      break;\n-\n-    case VOIDmode:\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-      regbase = GP_ARG_FIRST;\n-      break;\n-\n-    case DImode:\n-    case TImode:\n-      if (! TARGET_64BIT)\n-\tcum->arg_words += (cum->arg_words & 1);\n-      regbase = GP_ARG_FIRST;\n+\treturn 0;\n     }\n \n-  if (*arg_words >= (unsigned) MAX_ARGS_IN_REGISTERS)\n-    {\n-      if (TARGET_DEBUG_E_MODE)\n-\tfprintf (stderr, \"<stack>%s\\n\", struct_p ? \", [struct]\" : \"\");\n+  mips_arg_info (cum, mode, type, named, &info);\n \n-      ret = 0;\n-    }\n-  else\n-    {\n-      if (regbase == -1)\n-\tabort ();\n+  /* Return straight away if the whole argument is passed on the stack.  */\n+  if (info.reg_offset == MAX_ARGS_IN_REGISTERS)\n+    return 0;\n \n-      if (! type || TREE_CODE (type) != RECORD_TYPE\n-\t  || mips_abi == ABI_32  || mips_abi == ABI_EABI\n-\t  || mips_abi == ABI_O64 || mips_abi == ABI_MEABI\n-\t  || ! named\n-\t  || ! TYPE_SIZE_UNIT (type)\n-\t  || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n-\t{\n+  if (type != 0\n+      && TREE_CODE (type) == RECORD_TYPE\n+      && (mips_abi == ABI_N32 || mips_abi == ABI_64)\n+      && TYPE_SIZE_UNIT (type)\n+      && host_integerp (TYPE_SIZE_UNIT (type), 1)\n+      && named\n+      && mode != DFmode)\n+    {\n+      /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n+\t structure contains a double in its entirety, then that 64 bit\n+\t chunk is passed in a floating point register.  */\n+      tree field;\n+\n+      /* First check to see if there is any such field.  */\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t    && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n+\t    && host_integerp (bit_position (field), 0)\n+\t    && int_bit_position (field) % BITS_PER_WORD == 0)\n+\t  break;\n \n-\t  unsigned int arg_reg = (regbase + *arg_words + bias);\n-\t  ret = gen_rtx_REG (mode, arg_reg);\n-\t  if (mips_abi == ABI_MEABI\n-\t      && regbase == FP_ARG_FIRST\n-\t      && ! cum->prototype)\n-\t    {\n-              /* To make K&R varargs work we need to pass floating\n-                 point arguments in both integer and FP registers.  */\n-              ret = gen_rtx_PARALLEL (mode,\n-\t\t\t\t      gen_rtvec (2,\n-\t\t\t\t\t\t gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t\t\t    gen_rtx_REG (mode,\n-\t\t\t\t\t\t\t\t\t\t arg_reg + GP_ARG_FIRST - FP_ARG_FIRST),\n-\t\t\t\t\t\t\t\t    const0_rtx),                                                gen_rtx_EXPR_LIST (VOIDmode, ret, const0_rtx)));\n-            }\n-\t}\n-      else\n+      if (field != 0)\n \t{\n-\t  /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n-\t     structure contains a double in its entirety, then that 64 bit\n-\t     chunk is passed in a floating point register.  */\n-\t  tree field;\n-\n-\t  /* First check to see if there is any such field.  */\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t    if (TREE_CODE (field) == FIELD_DECL\n-\t\t&& TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n-\t\t&& TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n-\t\t&& host_integerp (bit_position (field), 0)\n-\t\t&& int_bit_position (field) % BITS_PER_WORD == 0)\n-\t      break;\n-\n-\t  /* If the whole struct fits a DFmode register,\n-\t     we don't need the PARALLEL.  */\n-\t  if (! field || mode == DFmode)\n-\t    ret = gen_rtx_REG (mode, regbase + *arg_words + bias);\n-\t  else\n-\t    {\n-\t      /* Now handle the special case by returning a PARALLEL\n-\t\t indicating where each 64 bit chunk goes.  */\n-\t      unsigned int chunks;\n-\t      HOST_WIDE_INT bitpos;\n-\t      unsigned int regno;\n-\t      unsigned int i;\n-\n-\t      /* ??? If this is a packed structure, then the last hunk won't\n-\t\t be 64 bits.  */\n-\n-\t      chunks\n-\t\t= tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n-\t      if (chunks + *arg_words + bias > (unsigned) MAX_ARGS_IN_REGISTERS)\n-\t\tchunks = MAX_ARGS_IN_REGISTERS - *arg_words - bias;\n-\n-\t      /* assign_parms checks the mode of ENTRY_PARM, so we must\n-\t\t use the actual mode here.  */\n-\t      ret = gen_rtx_PARALLEL (mode, rtvec_alloc (chunks));\n-\n-\t      bitpos = 0;\n-\t      regno = regbase + *arg_words + bias;\n-\t      field = TYPE_FIELDS (type);\n-\t      for (i = 0; i < chunks; i++)\n-\t\t{\n-\t\t  rtx reg;\n-\n-\t\t  for (; field; field = TREE_CHAIN (field))\n-\t\t    if (TREE_CODE (field) == FIELD_DECL\n-\t\t\t&& int_bit_position (field) >= bitpos)\n-\t\t      break;\n-\n-\t\t  if (field\n-\t\t      && int_bit_position (field) == bitpos\n-\t\t      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n-\t\t      && !TARGET_SOFT_FLOAT\n-\t\t      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n-\t\t    reg = gen_rtx_REG (DFmode,\n-\t\t\t\t       regno + FP_ARG_FIRST - GP_ARG_FIRST);\n-\t\t  else\n-\t\t    reg = gen_rtx_REG (word_mode, regno);\n-\n-\t\t  XVECEXP (ret, 0, i)\n-\t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg,\n-\t\t\t\t\t GEN_INT (bitpos / BITS_PER_UNIT));\n+\t  /* Now handle the special case by returning a PARALLEL\n+\t     indicating where each 64 bit chunk goes.  INFO.REG_WORDS\n+\t     chunks are passed in registers.  */\n+\t  unsigned int i;\n+\t  HOST_WIDE_INT bitpos;\n+\t  rtx ret;\n \n-\t\t  bitpos += 64;\n-\t\t  regno++;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (TARGET_DEBUG_E_MODE)\n-\tfprintf (stderr, \"%s%s\\n\", reg_names[regbase + *arg_words + bias],\n-\t\t struct_p ? \", [struct]\" : \"\");\n+\t  /* assign_parms checks the mode of ENTRY_PARM, so we must\n+\t     use the actual mode here.  */\n+\t  ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n \n-      /* The following is a hack in order to pass 1 byte structures\n-\t the same way that the MIPS compiler does (namely by passing\n-\t the structure in the high byte or half word of the register).\n-\t This also makes varargs work.  If we have such a structure,\n-\t we save the adjustment RTL, and the call define expands will\n-\t emit them.  For the VOIDmode argument (argument after the\n-\t last real argument), pass back a parallel vector holding each\n-\t of the adjustments.  */\n+\t  bitpos = 0;\n+\t  field = TYPE_FIELDS (type);\n+\t  for (i = 0; i < info.reg_words; i++)\n+\t    {\n+\t      rtx reg;\n \n-      /* ??? function_arg can be called more than once for each argument.\n-\t As a result, we compute more adjustments than we need here.\n-\t See the CUMULATIVE_ARGS definition in mips.h.  */\n+\t      for (; field; field = TREE_CHAIN (field))\n+\t\tif (TREE_CODE (field) == FIELD_DECL\n+\t\t    && int_bit_position (field) >= bitpos)\n+\t\t  break;\n \n-      /* ??? This scheme requires everything smaller than the word size to\n-\t shifted to the left, but when TARGET_64BIT and ! TARGET_INT64,\n-\t that would mean every int needs to be shifted left, which is very\n-\t inefficient.  Let's not carry this compatibility to the 64 bit\n-\t calling convention for now.  */\n+\t      if (field\n+\t\t  && int_bit_position (field) == bitpos\n+\t\t  && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+\t\t  && !TARGET_SOFT_FLOAT\n+\t\t  && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n+\t\treg = gen_rtx_REG (DFmode, FP_ARG_FIRST + info.reg_offset + i);\n+\t      else\n+\t\treg = gen_rtx_REG (DImode, GP_ARG_FIRST + info.reg_offset + i);\n \n-      if (struct_p && int_size_in_bytes (type) < UNITS_PER_WORD\n-\t  && ! TARGET_64BIT\n-\t  && mips_abi != ABI_EABI\n-\t  && mips_abi != ABI_MEABI)\n-\t{\n-\t  rtx amount = GEN_INT (BITS_PER_WORD\n-\t\t\t\t- int_size_in_bytes (type) * BITS_PER_UNIT);\n-\t  rtx reg = gen_rtx_REG (word_mode, regbase + *arg_words + bias);\n+\t      XVECEXP (ret, 0, i)\n+\t\t= gen_rtx_EXPR_LIST (VOIDmode, reg,\n+\t\t\t\t     GEN_INT (bitpos / BITS_PER_UNIT));\n \n-\t  if (TARGET_64BIT)\n-\t    cum->adjust[cum->num_adjusts++] = gen_ashldi3 (reg, reg, amount);\n-\t  else\n-\t    cum->adjust[cum->num_adjusts++] = gen_ashlsi3 (reg, reg, amount);\n+\t      bitpos += BITS_PER_WORD;\n+\t    }\n+\t  return ret;\n \t}\n     }\n \n-  /* We will be called with a mode of VOIDmode after the last argument\n-     has been seen.  Whatever we return will be passed to the call\n-     insn.  If we need any shifts for small structures, return them in\n-     a PARALLEL; in that case, stuff the mips16 fp_code in as the\n-     mode.  Otherwise, if we have need a mips16 fp_code, return a REG\n-     with the code stored as the mode.  */\n-  if (mode == VOIDmode)\n+  if (mips_abi == ABI_MEABI && info.fpr_p && !cum->prototype)\n     {\n-      if (cum->num_adjusts > 0)\n-\tret = gen_rtx (PARALLEL, (enum machine_mode) cum->fp_code,\n-\t\t       gen_rtvec_v (cum->num_adjusts, cum->adjust));\n-      else if (TARGET_MIPS16 && cum->fp_code != 0)\n-\tret = gen_rtx (REG, (enum machine_mode) cum->fp_code, 0);\n+      /* To make K&R varargs work we need to pass floating\n+\t point arguments in both integer and FP registers.  */\n+      return gen_rtx_PARALLEL\n+\t(mode,\n+\t gen_rtvec (2,\n+\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t       gen_rtx_REG (mode,\n+\t\t\t\t\t\t    GP_ARG_FIRST\n+\t\t\t\t\t\t    + info.reg_offset),\n+\t\t\t\t       const0_rtx),\n+\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t       gen_rtx_REG (mode,\n+\t\t\t\t\t\t    FP_ARG_FIRST\n+\t\t\t\t\t\t    + info.reg_offset),\n+\t\t\t\t       const0_rtx)));\n     }\n \n-  return ret;\n+  if (info.fpr_p)\n+    return gen_rtx_REG (mode, FP_ARG_FIRST + info.reg_offset);\n+  else\n+    return gen_rtx_REG (mode, GP_ARG_FIRST + info.reg_offset);\n }\n \n int\n function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     const CUMULATIVE_ARGS *cum; /* current arg information */\n      enum machine_mode mode;\t/* current arg mode */\n      tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named ATTRIBUTE_UNUSED;/* != 0 for normal args, == 0 for ... args */\n-{\n-  if ((mode == BLKmode\n-       || GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n-       || GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-      && cum->arg_words < (unsigned) MAX_ARGS_IN_REGISTERS\n-      && mips_abi != ABI_EABI)\n-    {\n-      int words;\n-      if (mode == BLKmode)\n-\twords = ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n-\t\t / UNITS_PER_WORD);\n-      else\n-\twords = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+{\n+  struct mips_arg_info info;\n \n-      if (words + cum->arg_words <= (unsigned) MAX_ARGS_IN_REGISTERS)\n-\treturn 0;\t\t/* structure fits in registers */\n+  mips_arg_info (cum, mode, type, named, &info);\n+  return info.stack_words > 0 ? info.reg_words : 0;\n+}\n+\f\n+int\n+mips_setup_incoming_varargs (cum, mode, type, no_rtl)\n+     const CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int no_rtl;\n+{\n+  CUMULATIVE_ARGS local_cum;\n+  int gp_saved, fp_saved;\n \n-      if (TARGET_DEBUG_E_MODE)\n-\tfprintf (stderr, \"function_arg_partial_nregs = %d\\n\",\n-\t\t MAX_ARGS_IN_REGISTERS - cum->arg_words);\n+  if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n+    return 0;\n \n-      return MAX_ARGS_IN_REGISTERS - cum->arg_words;\n-    }\n+  /* The caller has advanced CUM up to, but not beyond, the last named\n+     argument.  Advance a local copy of CUM past the last \"real\" named\n+     argument, to find out how many registers are left over.\n \n-  else if (mode == DImode\n-\t   && cum->arg_words == MAX_ARGS_IN_REGISTERS - (unsigned)1\n-\t   && ! TARGET_64BIT && mips_abi != ABI_EABI)\n+     For K&R varargs, the last named argument is a dummy word-sized one,\n+     so CUM already contains the information we need.  For stdarg, it is\n+     a real argument (such as the format in printf()) and we need to\n+     step over it.  */\n+  local_cum = *cum;\n+  if (!current_function_varargs)\n+    FUNCTION_ARG_ADVANCE (local_cum, mode, type, 1);\n+\n+  /* Found out how many registers we need to save.  */\n+  gp_saved = MAX_ARGS_IN_REGISTERS - local_cum.gp_regs;\n+  fp_saved = (EABI_FLOAT_VARARGS_P\n+\t      ? MAX_ARGS_IN_REGISTERS - local_cum.fp_regs\n+\t      : 0);\n+\n+  if (!no_rtl)\n     {\n-      if (TARGET_DEBUG_E_MODE)\n-\tfprintf (stderr, \"function_arg_partial_nregs = 1\\n\");\n+      if (gp_saved > 0)\n+\t{\n+\t  rtx ptr, mem;\n \n-      return 1;\n-    }\n+\t  ptr = virtual_incoming_args_rtx;\n+\t  if (mips_abi == ABI_EABI)\n+\t    ptr = plus_constant (ptr, -gp_saved * UNITS_PER_WORD);\n+\t  mem = gen_rtx_MEM (BLKmode, ptr);\n \n-  return 0;\n+\t  /* va_arg is an array access in this case, which causes\n+\t     it to get MEM_IN_STRUCT_P set.  We must set it here\n+\t     so that the insn scheduler won't assume that these\n+\t     stores can't possibly overlap with the va_arg loads.  */\n+\t  if (mips_abi != ABI_EABI && BYTES_BIG_ENDIAN)\n+\t    MEM_SET_IN_STRUCT_P (mem, 1);\n+\n+\t  move_block_from_reg (local_cum.gp_regs + GP_ARG_FIRST, mem,\n+\t\t\t       gp_saved, gp_saved * UNITS_PER_WORD);\n+\t}\n+      if (fp_saved > 0)\n+\t{\n+\t  /* We can't use move_block_from_reg, because it will use\n+\t     the wrong mode. */\n+\t  enum machine_mode mode;\n+\t  int off, i;\n+\n+\t  /* Set OFF to the offset from virtual_incoming_args_rtx of\n+\t     the first float register.   The FP save area lies below\n+\t     the integer one, and is aligned to UNITS_PER_FPVALUE bytes.  */\n+\t  off = -gp_saved * UNITS_PER_WORD;\n+\t  off &= ~(UNITS_PER_FPVALUE - 1);\n+\t  off -= fp_saved * UNITS_PER_FPREG;\n+\n+\t  mode = TARGET_SINGLE_FLOAT ? SFmode : DFmode;\n+\n+\t  for (i = local_cum.fp_regs; i < MAX_ARGS_IN_REGISTERS; i += FP_INC)\n+\t    {\n+\t      rtx ptr = plus_constant (virtual_incoming_args_rtx, off);\n+\t      emit_move_insn (gen_rtx_MEM (mode, ptr),\n+\t\t\t      gen_rtx_REG (mode, FP_ARG_FIRST + i));\n+\t      off += UNITS_PER_FPVALUE;\n+\t    }\n+\t}\n+    }\n+  return (gp_saved * UNITS_PER_WORD) + (fp_saved * UNITS_PER_FPREG);\n }\n-\f\n+\n /* Create the va_list data type.\n    We keep 3 pointers, and two offsets.\n    Two pointers are to the overflow area, which starts at the CFA.\n@@ -4332,9 +4345,9 @@ function_arg_partial_nregs (cum, mode, type, named)\n      These are downcounted as float or non-float arguments are used,\n      and when they get to zero, the argument must be obtained from the\n      overflow region.\n-   If TARGET_SOFT_FLOAT or TARGET_SINGLE_FLOAT, then no FPR save area exists,\n-     and a single pointer is enough.  It's started at the GPR save area,\n-     and is advanced, period.\n+   If !EABI_FLOAT_VARARGS_P, then no FPR save area exists, and a single\n+     pointer is enough.  It's started at the GPR save area, and is\n+     advanced, period.\n    Note that the GPR save area is not constant size, due to optimization\n      in the prologue.  Hence, we can't use a design with two pointers\n      and two offsets, although we could have designed this with two pointers\n@@ -4344,7 +4357,7 @@ function_arg_partial_nregs (cum, mode, type, named)\n tree\n mips_build_va_list ()\n {\n-  if (mips_abi == ABI_EABI && !TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n+  if (EABI_FLOAT_VARARGS_P)\n     {\n       tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff, record;\n \n@@ -4392,37 +4405,24 @@ mips_va_start (stdarg_p, valist, nextarg)\n      tree valist;\n      rtx nextarg;\n {\n-  int int_arg_words;\n-  tree t;\n-\n-  /* Find out how many non-float named formals */\n-  int_arg_words = current_function_args_info.arg_words;\n+  const CUMULATIVE_ARGS *cum = &current_function_args_info;\n \n   if (mips_abi == ABI_EABI)\n     {\n       int gpr_save_area_size;\n-      /* Note UNITS_PER_WORD is 4 bytes or 8, depending on TARGET_64BIT.  */\n-      if (int_arg_words < 8 )\n-\t/* Adjust for the prologue's economy measure */\n-\tgpr_save_area_size = (8 - int_arg_words) * UNITS_PER_WORD;\n-      else\n-\tgpr_save_area_size = 0;\n \n-      if (!TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n+      gpr_save_area_size\n+\t= (MAX_ARGS_IN_REGISTERS - cum->gp_regs) * UNITS_PER_WORD;\n+\n+      if (EABI_FLOAT_VARARGS_P)\n \t{\n \t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n \t  tree ovfl, gtop, ftop, goff, foff;\n-\t  tree gprv;\n-\t  int float_formals, fpr_offset, size_excess, floats_passed_in_regs;\n-\t  int fpr_save_offset;\n-\n-\t  float_formals = current_function_args_info.fp_arg_words;\n-\t  /* If mips2, the number of formals is half the reported # of words */\n-\t  if (!TARGET_64BIT)\n-\t    float_formals /= 2;\n-\t  floats_passed_in_regs = (TARGET_64BIT ? 8 : 4);\n+\t  tree t;\n+\t  int fpr_offset;\n+\t  int fpr_save_area_size;\n \n-\t  f_ovfl  = TYPE_FIELDS (va_list_type_node);\n+\t  f_ovfl = TYPE_FIELDS (va_list_type_node);\n \t  f_gtop = TREE_CHAIN (f_ovfl);\n \t  f_ftop = TREE_CHAIN (f_gtop);\n \t  f_goff = TREE_CHAIN (f_ftop);\n@@ -4434,84 +4434,49 @@ mips_va_start (stdarg_p, valist, nextarg)\n \t  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n \t  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n \n-\t  /* Emit code setting a pointer into the overflow (shared-stack) area.\n-\t     If there were more than 8 non-float formals, or more than 8\n-\t     float formals, then this pointer isn't to the base of the area.\n-\t     In that case, it must point to where the first vararg is.  */\n-\t  size_excess = 0;\n-\t  if (float_formals > floats_passed_in_regs)\n-\t    size_excess += (float_formals-floats_passed_in_regs) * 8;\n-\t  if (int_arg_words > 8)\n-\t    size_excess += (int_arg_words-8) * UNITS_PER_WORD;\n-\n-\t  /* FIXME: for mips2, the above size_excess can be wrong.  Because the\n-\t     overflow stack holds mixed size items, there can be alignments,\n-\t     so that an 8 byte double following a 4 byte int will be on an\n-\t     8 byte boundary.  This means that the above calculation should\n-\t     take into account the exact sequence of floats and non-floats\n-\t     which make up the excess.  That calculation should be rolled\n-\t     into the code which sets the current_function_args_info struct.\n-\t     The above then reduces to a fetch from that struct.  */\n-\n-\n+\t  /* Emit code to initialize OVFL, which points to the next varargs\n+\t     stack argument.  CUM->STACK_WORDS gives the number of stack\n+\t     words used by named arguments.  */\n \t  t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n-\t  if (size_excess)\n+\t  if (cum->stack_words > 0)\n \t    t = build (PLUS_EXPR, TREE_TYPE (ovfl), t,\n-\t\tbuild_int_2 (size_excess, 0));\n+\t\t       build_int_2 (cum->stack_words * UNITS_PER_WORD, 0));\n \t  t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n  \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  /* Emit code setting a ptr to the base of the overflow area.  */\n+\t  /* Emit code to initialize GTOP, the top of the GPR save area.  */\n \t  t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n \t  t = build (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n  \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  /* Emit code setting a pointer to the GPR save area.\n-\t     More precisely, a pointer to off-the-end of the FPR save area.\n-\t     If mips4, this is gpr_save_area_size below the overflow area.\n-\t     If mips2, also round down to an 8-byte boundary, since the FPR\n-\t     save area is 8-byte aligned, and GPR is 4-byte-aligned.\n-\t     Therefore there can be a 4-byte gap between the save areas.  */\n-\t  gprv = make_tree (TREE_TYPE (ftop), virtual_incoming_args_rtx);\n-\t  fpr_save_offset = gpr_save_area_size;\n-\t  if (!TARGET_64BIT)\n-\t    {\n-\t      if (fpr_save_offset & 7)\n-\t        fpr_save_offset += 4;\n-\t    }\n-\t  if (fpr_save_offset)\n-\t    gprv = build (PLUS_EXPR, TREE_TYPE (ftop), gprv,\n-\t      \tbuild_int_2 (-fpr_save_offset,-1));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, gprv);\n+\t  /* Emit code to initialize FTOP, the top of the FPR save area.\n+\t     This address is gpr_save_area_bytes below GTOP, rounded\n+\t     down to the next fp-aligned boundary.  */\n+\t  t = make_tree (TREE_TYPE (ftop), virtual_incoming_args_rtx);\n+\t  fpr_offset = gpr_save_area_size + UNITS_PER_FPVALUE - 1;\n+\t  fpr_offset &= ~(UNITS_PER_FPVALUE - 1);\n+\t  if (fpr_offset)\n+\t    t = build (PLUS_EXPR, TREE_TYPE (ftop), t,\n+\t\t       build_int_2 (-fpr_offset, -1));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  /* Emit code initting an offset to the size of the GPR save area */\n+\t  /* Emit code to initialize GOFF, the offset from GTOP of the\n+\t     next GPR argument.  */\n \t  t = build (MODIFY_EXPR, TREE_TYPE (goff), goff,\n-\t      \tbuild_int_2 (gpr_save_area_size,0));\n+\t\t     build_int_2 (gpr_save_area_size, 0));\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  /* Emit code initting an offset from ftop to the first float\n-\t     vararg.  This varies in size, since any float\n-\t     varargs are put in the FPR save area after the formals.\n-\t     Note it's 8 bytes/formal regardless of TARGET_64BIT.\n-\t     However, mips2 stores 4 GPRs, mips4 stores 8 GPRs.\n-\t     If there are 8 or more float formals, init to zero.\n-\t     (In fact, the formals aren't stored in the bottom of the\n-\t     FPR save area: they are elsewhere, and the size of the FPR\n-\t     save area is economized by the prologue.  But this code doesn't\n-\t     care.  This design is unaffected by that fact.) */\n-\t  if (float_formals >= floats_passed_in_regs)\n-\t    fpr_offset = 0;\n-\t  else\n-\t    fpr_offset = (floats_passed_in_regs - float_formals) * 8;\n+\t  /* Likewise emit code to initialize FOFF, the offset from FTOP\n+\t     of the next FPR argument.  */\n+\t  fpr_save_area_size\n+\t    = (MAX_ARGS_IN_REGISTERS - cum->fp_regs) * UNITS_PER_FPREG;\n \t  t = build (MODIFY_EXPR, TREE_TYPE (foff), foff,\n-\t\t     build_int_2 (fpr_offset,0));\n+\t\t     build_int_2 (fpr_save_area_size, 0));\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t}\n       else\n \t{\n-\t  /* TARGET_SOFT_FLOAT or TARGET_SINGLE_FLOAT */\n-\n \t  /* Everything is in the GPR save area, or in the overflow\n \t     area which is contiguous with it.  */\n \n@@ -4534,10 +4499,10 @@ mips_va_start (stdarg_p, valist, nextarg)\n \t  /* ??? This had been conditional on\n \t       _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32\n \t     and both iris5.h and iris6.h define _MIPS_SIM.  */\n-\t  if (mips_abi == ABI_N32 || mips_abi == ABI_64)\n- \t    ofs = (int_arg_words >= 8 ? -UNITS_PER_WORD : 0);\n-\t  else if (mips_abi == ABI_MEABI)\n-\t    ofs = (int_arg_words >= 8 ? -UNITS_PER_WORD : 0);\n+\t  if (mips_abi == ABI_N32\n+\t      || mips_abi == ABI_64\n+\t      || mips_abi == ABI_MEABI)\n+ \t    ofs = (cum->gp_regs < MAX_ARGS_IN_REGISTERS ? 0 : -UNITS_PER_WORD);\n \t  else\n \t    ofs = -UNITS_PER_WORD;\n \t}\n@@ -4562,13 +4527,12 @@ mips_va_arg (valist, type)\n \n   if (mips_abi == ABI_EABI)\n     {\n-      int indirect;\n-      rtx r, lab_over = NULL_RTX, lab_false;\n-      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n-      tree ovfl, gtop, ftop, goff, foff;\n+      bool indirect;\n+      rtx r;\n \n       indirect\n \t= function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n+\n       if (indirect)\n \t{\n \t  size = POINTER_SIZE / BITS_PER_UNIT;\n@@ -4577,187 +4541,166 @@ mips_va_arg (valist, type)\n \n       addr_rtx = gen_reg_rtx (Pmode);\n \n-      if (TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT)\n+      if (!EABI_FLOAT_VARARGS_P)\n \t{\n-\t  /* Case of all args in a merged stack. No need to check bounds,\n+\t  /* Case of all args in a merged stack.  No need to check bounds,\n \t     just advance valist along the stack.  */\n \n \t  tree gpr = valist;\n-      \t  if (! indirect\n-\t      && ! TARGET_64BIT\n+\t  if (!indirect\n+\t      && !TARGET_64BIT\n \t      && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n \t    {\n+\t      /* Align the pointer using: ap = (ap + align - 1) & -align,\n+\t\t where align is 2 * UNITS_PER_WORD.  */\n \t      t = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t     build_int_2 (2*UNITS_PER_WORD - 1, 0));\n+\t\t\t build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n \t      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t     build_int_2 (-2*UNITS_PER_WORD, -1));\n+\t\t\t build_int_2 (-2 * UNITS_PER_WORD, -1));\n \t      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n \t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t    }\n \n-      \t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr,\n-\t\tsize_int (rsize));\n-      \t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-     \t  if (r != addr_rtx)\n+\t  /* Emit code to set addr_rtx to the valist, and postincrement\n+\t     the valist by the size of the argument, rounded up to the\n+\t     next word.\t */\n+\t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t     size_int (rsize));\n+\t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n \t    emit_move_insn (addr_rtx, r);\n \n-      \t  /* flush the POSTINCREMENT */\n-      \t  emit_queue();\n-\n-      \t  if (indirect)\n-\t    {\n-\t      r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t      set_mem_alias_set (r, get_varargs_alias_set ());\n-\t      emit_move_insn (addr_rtx, r);\n-\t    }\n-      \t  else\n-\t    {\n-\t      if (BYTES_BIG_ENDIAN && rsize != size)\n-\t      addr_rtx = plus_constant (addr_rtx, rsize - size);\n-\t    }\n-      \t  return addr_rtx;\n+\t  /* Flush the POSTINCREMENT.  */\n+\t  emit_queue();\n \t}\n+      else\n+\t{\n+\t  /* Not a simple merged stack.\t */\n \n-      /* Not a simple merged stack.  Need ptrs and indexes left by va_start.  */\n+\t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n+\t  tree ovfl, top, off;\n+\t  rtx lab_over = NULL_RTX, lab_false;\n \n-      f_ovfl  = TYPE_FIELDS (va_list_type_node);\n-      f_gtop = TREE_CHAIN (f_ovfl);\n-      f_ftop = TREE_CHAIN (f_gtop);\n-      f_goff = TREE_CHAIN (f_ftop);\n-      f_foff = TREE_CHAIN (f_goff);\n+\t  f_ovfl = TYPE_FIELDS (va_list_type_node);\n+\t  f_gtop = TREE_CHAIN (f_ovfl);\n+\t  f_ftop = TREE_CHAIN (f_gtop);\n+\t  f_goff = TREE_CHAIN (f_ftop);\n+\t  f_foff = TREE_CHAIN (f_goff);\n \n-      ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n-      gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n-      ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n-      goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n-      foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n+\t  /* We maintain separate pointers and offsets for floating-point\n+\t     and integer arguments, but we need similar code in both cases.\n+\t     Let:\n \n-      lab_false = gen_label_rtx ();\n-      lab_over = gen_label_rtx ();\n+\t\t TOP be the top of the register save area;\n+\t\t OFF be the offset from TOP of the next register;\n+\t\t ADDR_RTX be the address of the argument; and\n+\t\t RSIZE be the number of bytes used to store the argument.\n \n-      if (TREE_CODE (type) == REAL_TYPE)\n-        {\n+\t     The code we want is:\n \n-\t  /* Emit code to branch if foff == 0.  */\n-          r = expand_expr (foff, NULL_RTX, TYPE_MODE (TREE_TYPE (foff)),\n-\t     \tEXPAND_NORMAL);\n-          emit_cmp_and_jump_insns (r, const0_rtx, EQ, const1_rtx, GET_MODE (r),\n-\t\t\t\t   1, lab_false);\n+\t\t  1: off &= -rsize;\t  // round down\n+\t\t  2: if (off != 0)\n+\t\t  3:   {\n+\t\t  4:\t addr_rtx = top - off;\n+\t\t  5:\t off -= rsize;\n+\t\t  6:   }\n+\t\t  7: else\n+\t\t  8:   {\n+\t\t  9:\t ovfl += ((intptr_t) ovfl + rsize - 1) & -rsize;\n+\t\t 10:\t addr_rtx = ovfl;\n+\t\t 11:\t ovfl += rsize;\n+\t\t 12:   }\n \n-          /* Emit code for addr_rtx = ftop - foff */\n-          t = build (MINUS_EXPR, TREE_TYPE (ftop), ftop, foff );\n-          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-          if (r != addr_rtx)\n-      \t    emit_move_insn (addr_rtx, r);\n+\t     [1] and [9] can sometimes be optimized away.  */\n \n-          /* Emit code for foff-=8.\n-      \t     Advances the offset up FPR save area by one double */\n-          t = build (MINUS_EXPR, TREE_TYPE (foff), foff, build_int_2 (8, 0));\n-          t = build (MODIFY_EXPR, TREE_TYPE (foff), foff, t);\n-          expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  lab_false = gen_label_rtx ();\n+\t  lab_over = gen_label_rtx ();\n \n-          emit_queue();\n-          emit_jump (lab_over);\n-          emit_barrier ();\n-          emit_label (lab_false);\n+\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n \n-\t  if (!TARGET_64BIT)\n+\t  if (TREE_CODE (type) == REAL_TYPE)\n \t    {\n-\t      /* For mips2, the overflow area contains mixed size items.\n-\t\t If a 4-byte int is followed by an 8-byte float, then\n-\t\t natural alignment causes a 4 byte gap.\n-\t\t So, dynamically adjust ovfl up to a multiple of 8.  */\n-\t      t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), ovfl,\n-\t\t\tbuild_int_2 (7, 0));\n-\t      t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, t);\n-\t      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n-\t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t    }\n-\n-          /* Emit code for addr_rtx = the ovfl pointer into overflow area.\n-\t     Regardless of mips2, postincrement the ovfl pointer by 8.  */\n-          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n-\t\tsize_int (8));\n-          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-          if (r != addr_rtx)\n-      \t    emit_move_insn (addr_rtx, r);\n-\n-          emit_queue();\n-          emit_label (lab_over);\n-       \t  return addr_rtx;\n-        }\n-      else\n-        {\n-          /* not REAL_TYPE */\n-\t  int step_size;\n+\t      top = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n+\t      off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n \n-\t  if (! TARGET_64BIT\n-\t      && TREE_CODE (type) == INTEGER_TYPE\n-\t      && TYPE_PRECISION (type) == 64)\n+\t      /* When floating-point registers are saved to the stack,\n+\t\t each one will take up UNITS_PER_FPVALUE bytes, regardless\n+\t\t of the float's precision.  */\n+\t      rsize = UNITS_PER_FPVALUE;\n+\t    }\n+\t  else\n \t    {\n-\t      /* In mips2, int takes 32 bits of the GPR save area, but\n-\t\t longlong takes an aligned 64 bits.  So, emit code\n-\t\t to zero the low order bits of goff, thus aligning\n-\t\t the later calculation of (gtop-goff) upwards.  */\n-\t       t = build (BIT_AND_EXPR, TREE_TYPE (goff), goff,\n-\t\t\tbuild_int_2 (-8, -1));\n-\t       t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n-\t       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t      top = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n+\t      off = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n+\t      if (rsize > UNITS_PER_WORD)\n+\t\t{\n+\t\t  /* [1] Emit code for: off &= -rsize.\t*/\n+\t\t  t = build (BIT_AND_EXPR, TREE_TYPE (off), off,\n+\t\t\t     build_int_2 (-rsize, -1));\n+\t\t  t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n+\t\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t\t}\n \t    }\n \n-\t  /* Emit code to branch if goff == 0.  */\n-          r = expand_expr (goff, NULL_RTX, TYPE_MODE (TREE_TYPE (goff)),\n-\t     \tEXPAND_NORMAL);\n-          emit_cmp_and_jump_insns (r, const0_rtx, EQ, const1_rtx, GET_MODE (r),\n+\t  /* [2] Emit code to branch if off == 0.  */\n+\t  r = expand_expr (off, NULL_RTX, TYPE_MODE (TREE_TYPE (off)),\n+\t\t\t   EXPAND_NORMAL);\n+\t  emit_cmp_and_jump_insns (r, const0_rtx, EQ, const1_rtx, GET_MODE (r),\n \t\t\t\t   1, lab_false);\n \n-          /* Emit code for addr_rtx = gtop - goff.  */\n-          t = build (MINUS_EXPR, TREE_TYPE (gtop), gtop, goff);\n-          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-          if (r != addr_rtx)\n-      \t    emit_move_insn (addr_rtx, r);\n+\t  /* [4] Emit code for: addr_rtx = top - off.  */\n+\t  t = build (MINUS_EXPR, TREE_TYPE (top), top, off);\n+\t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n \n-\t  /* Note that mips2 int is 32 bit, but mips2 longlong is 64.  */\n-\t  if (! TARGET_64BIT && TYPE_PRECISION (type) == 64)\n-\t    step_size = 8;\n-\t  else\n-\t    step_size = UNITS_PER_WORD;\n-\n-          /* Emit code for goff = goff - step_size.\n-      \t     Advances the offset up GPR save area over the item.  */\n-          t = build (MINUS_EXPR, TREE_TYPE (goff), goff,\n-\t\tbuild_int_2 (step_size, 0));\n-          t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n-          expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-          emit_queue();\n-          emit_jump (lab_over);\n-          emit_barrier ();\n-          emit_label (lab_false);\n-\n-          /* Emit code for addr_rtx -> overflow area, postinc by step_size */\n-          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n-\t    \tsize_int (step_size));\n-          r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-          if (r != addr_rtx)\n-    \t    emit_move_insn (addr_rtx, r);\n-\n-          emit_queue();\n-          emit_label (lab_over);\n+\t  /* [5] Emit code for: off -= rsize.  */\n+\t  t = build (MINUS_EXPR, TREE_TYPE (off), off, build_int_2 (rsize, 0));\n+\t  t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n+\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-\t  if (BYTES_BIG_ENDIAN && rsize != size)\n-\t    addr_rtx = plus_constant (addr_rtx, rsize - size);\n+\t  /* [7] Emit code to jump over the else clause, then the label\n+\t     that starts it.  */\n+\t  emit_queue();\n+\t  emit_jump (lab_over);\n+\t  emit_barrier ();\n+\t  emit_label (lab_false);\n \n-          if (indirect)\n-   \t    {\n-\t      addr_rtx = force_reg (Pmode, addr_rtx);\n-\t      r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t      set_mem_alias_set (r, get_varargs_alias_set ());\n-\t      emit_move_insn (addr_rtx, r);\n+\t  if (rsize > UNITS_PER_WORD)\n+\t    {\n+\t      /* [9] Emit: ovfl += ((intptr_t) ovfl + rsize - 1) & -rsize.  */\n+\t      t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl,\n+\t\t\t build_int_2 (rsize - 1, 0));\n+\t      t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), t,\n+\t\t\t build_int_2 (-rsize, -1));\n+\t      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+\t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t    }\n \n-      \t  return addr_rtx;\n+\t  /* [10, 11].\tEmit code to store ovfl in addr_rtx, then\n+\t     post-increment ovfl by rsize.  */\n+\t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl,\n+\t\t     size_int (rsize));\n+\t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n+\n+\t  emit_queue();\n+\t  emit_label (lab_over);\n \t}\n+      if (indirect)\n+\t{\n+\t  addr_rtx = force_reg (Pmode, addr_rtx);\n+\t  r = gen_rtx_MEM (Pmode, addr_rtx);\n+\t  set_mem_alias_set (r, get_varargs_alias_set ());\n+\t  emit_move_insn (addr_rtx, r);\n+\t}\n+      else\n+\t{\n+\t  if (BYTES_BIG_ENDIAN && rsize != size)\n+\t    addr_rtx = plus_constant (addr_rtx, rsize - size);\n+\t}\n+      return addr_rtx;\n     }\n   else\n     {\n@@ -8083,7 +8026,7 @@ mips_function_value (valtype, func)\n \n int\n function_arg_pass_by_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n+     const CUMULATIVE_ARGS *cum;\n      enum machine_mode mode;\n      tree type;\n      int named ATTRIBUTE_UNUSED;\n@@ -8103,16 +8046,9 @@ function_arg_pass_by_reference (cum, mode, type, named)\n   /* ??? cum can be NULL when called from mips_va_arg.  The problem handled\n      here hopefully is not relevant to mips_va_arg.  */\n   if (cum && MUST_PASS_IN_STACK (mode, type)\n-      && mips_abi != ABI_MEABI)\n-     {\n-       /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n-\t  get double copies of any offsets generated for small structs\n-\t  passed in registers.  */\n-       CUMULATIVE_ARGS temp;\n-       temp = *cum;\n-       if (FUNCTION_ARG (temp, mode, type, named) != 0)\n-\t return 1;\n-     }\n+      && mips_abi != ABI_MEABI\n+      && FUNCTION_ARG (*cum, mode, type, named) != 0)\n+    return 1;\n \n   /* Otherwise, we only do this if EABI is selected.  */\n   if (mips_abi != ABI_EABI)"}, {"sha": "7b01130a3877054609a59fcec2cd955d5aada93b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 81, "deletions": 25, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d72536eeccbed73b276fb236a89228c34d5f50f/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=4d72536eeccbed73b276fb236a89228c34d5f50f", "patch": "@@ -1595,7 +1595,10 @@ do {\t\t\t\t\t\t\t\\\n #define FP_INC (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT ? 1 : 2)\n \n /* The largest size of value that can be held in floating-point registers.  */\n-#define UNITS_PER_FPVALUE (FP_INC * UNITS_PER_FPREG)\n+#define UNITS_PER_FPVALUE (TARGET_SOFT_FLOAT ? 0 : FP_INC * UNITS_PER_FPREG)\n+\n+/* The number of bytes in a double.  */\n+#define UNITS_PER_DOUBLE (TYPE_PRECISION (double_type_node) / BITS_PER_UNIT)\n \n /* A C expression for the size in bits of the type `int' on the\n    target machine.  If you don't define this, the default is one\n@@ -2737,6 +2740,10 @@ extern struct mips_frame_info current_frame_info;\n \n #define RETURN_IN_MEMORY(TYPE)\t\\\n \tmips_return_in_memory (TYPE)\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+\t(PRETEND_SIZE) = mips_setup_incoming_varargs (&(CUM), (MODE),\t\\\n+\t\t\t\t\t\t      (TYPE), (NO_RTL))\n \f\n \n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n@@ -2748,32 +2755,75 @@ extern struct mips_frame_info current_frame_info;\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On the mips16, we need to keep track of which floating point\n-   arguments were passed in general registers, but would have been\n-   passed in the FP regs if this were a 32 bit function, so that we\n-   can move them to the FP regs if we wind up calling a 32 bit\n-   function.  We record this information in fp_code, encoded in base\n-   four.  A zero digit means no floating point argument, a one digit\n-   means an SFmode argument, and a two digit means a DFmode argument,\n-   and a three digit is not used.  The low order digit is the first\n-   argument.  Thus 6 == 1 * 4 + 2 means a DFmode argument followed by\n-   an SFmode argument.  ??? A more sophisticated approach will be\n-   needed if MIPS_ABI != ABI_32.  */\n+   This structure has to cope with two different argument allocation\n+   schemes.  Most MIPS ABIs view the arguments as a struct, of which the\n+   first N words go in registers and the rest go on the stack.  If I < N,\n+   the Ith word might go in Ith integer argument register or the\n+   Ith floating-point one.  In some cases, it has to go in both (see\n+   function_arg).  For these ABIs, we only need to remember the number\n+   of words passed so far.\n+\n+   The EABI instead allocates the integer and floating-point arguments\n+   separately.  The first N words of FP arguments go in FP registers,\n+   the rest go on the stack.  Likewise, the first N words of the other\n+   arguments go in integer registers, and the rest go on the stack.  We\n+   need to maintain three counts: the number of integer registers used,\n+   the number of floating-point registers used, and the number of words\n+   passed on the stack.\n+\n+   We could keep separate information for the two ABIs (a word count for\n+   the standard ABIs, and three separate counts for the EABI).  But it\n+   seems simpler to view the standard ABIs as forms of EABI that do not\n+   allocate floating-point registers.\n+\n+   So for the standard ABIs, the first N words are allocated to integer\n+   registers, and function_arg decides on an argument-by-argument basis\n+   whether that argument should really go in an integer register, or in\n+   a floating-point one.  */\n \n typedef struct mips_args {\n-  int gp_reg_found;\t\t/* whether a gp register was found yet */\n-  unsigned int arg_number;\t/* argument number */\n-  unsigned int arg_words;\t/* # total words the arguments take */\n-  unsigned int fp_arg_words;\t/* # words for FP args (MIPS_EABI only) */\n-  int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n-  int fp_code;\t\t\t/* Mode of FP arguments (mips16) */\n-  unsigned int num_adjusts;\t/* number of adjustments made */\n-\t\t\t\t/* Adjustments made to args pass in regs.  */\n-\t\t\t\t/* ??? The size is doubled to work around a\n-\t\t\t\t   bug in the code that sets the adjustments\n-\t\t\t\t   in function_arg.  */\n-  int prototype;                /* True if the function has a prototype.  */\n-  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS*2];\n+  /* Always true for varargs functions.  Otherwise true if at least\n+     one argument has been passed in an integer register.  */\n+  int gp_reg_found;\n+\n+  /* The number of arguments seen so far.  */\n+  unsigned int arg_number;\n+\n+  /* For EABI, the number of integer registers used so far.  For other\n+     ABIs, the number of words passed in registers (whether integer\n+     or floating-point).  */\n+  unsigned int gp_regs;\n+\n+  /* For EABI, the number of floating-point registers used so far.  */\n+  unsigned int fp_regs;\n+\n+  /* The number of words passed on the stack.  */\n+  unsigned int stack_words;\n+\n+  /* On the mips16, we need to keep track of which floating point\n+     arguments were passed in general registers, but would have been\n+     passed in the FP regs if this were a 32 bit function, so that we\n+     can move them to the FP regs if we wind up calling a 32 bit\n+     function.  We record this information in fp_code, encoded in base\n+     four.  A zero digit means no floating point argument, a one digit\n+     means an SFmode argument, and a two digit means a DFmode argument,\n+     and a three digit is not used.  The low order digit is the first\n+     argument.  Thus 6 == 1 * 4 + 2 means a DFmode argument followed by\n+     an SFmode argument.  ??? A more sophisticated approach will be\n+     needed if MIPS_ABI != ABI_32.  */\n+  int fp_code;\n+\n+  /* True if the function has a prototype.  */\n+  int prototype;\n+\n+  /* When a structure does not take up a full register, the argument\n+     should sometimes be shifted left so that it occupies the high part\n+     of the register.  These two fields describe an array of ashl\n+     patterns for doing this.  See function_arg_advance, which creates\n+     the shift patterns, and function_arg, which returns them when given\n+     a VOIDmode argument.  */\n+  unsigned int num_adjusts;\n+  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS];\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -2828,6 +2878,12 @@ typedef struct mips_args {\n \t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n \t\t: GET_MODE_ALIGNMENT(MODE)))\n \n+/* True if using EABI and varargs can be passed in floating-point\n+   registers.  Under these conditions, we need a more complex form\n+   of va_list, which tracks GPR, FPR and stack arguments separately.  */\n+#define EABI_FLOAT_VARARGS_P \\\n+\t(mips_abi == ABI_EABI && UNITS_PER_FPVALUE >= UNITS_PER_DOUBLE)\n+\n \f\n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n "}]}