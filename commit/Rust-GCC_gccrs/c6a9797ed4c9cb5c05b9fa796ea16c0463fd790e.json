{"sha": "c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZhOTc5N2VkNGM5Y2I1YzA1YjlmYTc5NmVhMTZjMDQ2M2ZkNzkwZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-04-08T06:51:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:51:27Z"}, "message": "freeze.adb (Freeze_Entity): Improve warnings on access types in pure units.\n\n2008-04-08  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Improve warnings on access types in pure\n\tunits.\n\t(Size_Known): Generic formal scalar types have known at compile\n\ttime size, so remove check.\n\tFix casing error in formal parameter name in call\n\t(Freeze_Subprogram): If the subprogram is a user-defined operator,\n\trecheck its overriding indication.\n\nFrom-SVN: r134033", "tree": {"sha": "ebb9bc1f791aeea2ab29b5deee33f55ee85c7425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebb9bc1f791aeea2ab29b5deee33f55ee85c7425"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e/comments", "author": null, "committer": null, "parents": [{"sha": "9cf50493b26f417dd358003ce0718315c7a262e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf50493b26f417dd358003ce0718315c7a262e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cf50493b26f417dd358003ce0718315c7a262e2"}], "stats": {"total": 99, "additions": 75, "deletions": 24}, "files": [{"sha": "f2bd7b13b673d2b2cbddda77b5a0414f3bf4dce5", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 75, "deletions": 24, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c6a9797ed4c9cb5c05b9fa796ea16c0463fd790e", "patch": "@@ -617,17 +617,29 @@ package body Freeze is\n          if Size_Known_At_Compile_Time (T) then\n             return True;\n \n+         --  Always True for scalar types. This is true even for generic formal\n+         --  scalar types. We used to return False in the latter case, but the\n+         --  size is known at compile time, even in the template, we just do\n+         --  not know the exact size but that's not the point of this routine.\n+\n          elsif Is_Scalar_Type (T)\n            or else Is_Task_Type (T)\n          then\n-            return not Is_Generic_Type (T);\n+            return True;\n+\n+         --  Array types\n \n          elsif Is_Array_Type (T) then\n+\n+            --  String literals always have known size, and we can set it\n+\n             if Ekind (T) = E_String_Literal_Subtype then\n                Set_Small_Size (T, Component_Size (T)\n                                * String_Literal_Length (T));\n                return True;\n \n+            --  Unconstrained types never have known at compile time size\n+\n             elsif not Is_Constrained (T) then\n                return False;\n \n@@ -637,6 +649,8 @@ package body Freeze is\n             elsif Error_Posted (T) then\n                return False;\n \n+            --  Otherwise if component size unknown, then array size unknown\n+\n             elsif not Size_Known (Component_Type (T)) then\n                return False;\n             end if;\n@@ -685,9 +699,13 @@ package body Freeze is\n                return True;\n             end;\n \n+         --  Access types always have known at compile time sizes\n+\n          elsif Is_Access_Type (T) then\n             return True;\n \n+         --  For non-generic private types, go to underlying type if present\n+\n          elsif Is_Private_Type (T)\n            and then not Is_Generic_Type (T)\n            and then Present (Underlying_Type (T))\n@@ -701,6 +719,8 @@ package body Freeze is\n                return Size_Known (Underlying_Type (T));\n             end if;\n \n+         --  Record types\n+\n          elsif Is_Record_Type (T) then\n \n             --  A class-wide type is never considered to have a known size\n@@ -906,6 +926,8 @@ package body Freeze is\n                return True;\n             end;\n \n+         --  All other cases, size not known at compile time\n+\n          else\n             return False;\n          end if;\n@@ -1100,8 +1122,8 @@ package body Freeze is\n          New_N :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp,\n-             Object_definition => New_Occurrence_Of (Typ, Loc),\n-             Expression => Relocate_Node (E));\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+             Expression          => Relocate_Node (E));\n          Insert_Before (Parent (E), New_N);\n          Analyze (New_N);\n \n@@ -1298,7 +1320,7 @@ package body Freeze is\n       --  We also add finalization chains to access types whose designated\n       --  types are controlled. This is normally done when freezing the type,\n       --  but this misses recursive type definitions where the later members\n-      --  of the recursion introduce controlled components (e.g. 5624-001).\n+      --  of the recursion introduce controlled components.\n \n       --  Loop through entities\n \n@@ -3516,9 +3538,23 @@ package body Freeze is\n \n             if Is_Pure_Unit_Access_Type (E)\n               and then (Ada_Version < Ada_05\n-                        or else not No_Pool_Assigned (E))\n+                         or else not No_Pool_Assigned (E))\n             then\n                Error_Msg_N (\"named access type not allowed in pure unit\", E);\n+\n+               if Ada_Version >= Ada_05 then\n+                  Error_Msg_N\n+                    (\"\\would be legal if Storage_Size of 0 given?\", E);\n+\n+               elsif No_Pool_Assigned (E) then\n+                  Error_Msg_N\n+                    (\"\\would be legal in Ada 2005?\", E);\n+\n+               else\n+                  Error_Msg_N\n+                    (\"\\would be legal in Ada 2005 if \"\n+                     & \"Storage_Size of 0 given?\", E);\n+               end if;\n             end if;\n          end if;\n \n@@ -3807,12 +3843,12 @@ package body Freeze is\n    -----------------------\n \n    procedure Freeze_Expression (N : Node_Id) is\n-      In_Def_Exp : constant Boolean := In_Default_Expression;\n-      Typ        : Entity_Id;\n-      Nam        : Entity_Id;\n-      Desig_Typ  : Entity_Id;\n-      P          : Node_Id;\n-      Parent_P   : Node_Id;\n+      In_Spec_Exp : constant Boolean := In_Spec_Expression;\n+      Typ         : Entity_Id;\n+      Nam         : Entity_Id;\n+      Desig_Typ   : Entity_Id;\n+      P           : Node_Id;\n+      Parent_P    : Node_Id;\n \n       Freeze_Outside : Boolean := False;\n       --  This flag is set true if the entity must be frozen outside the\n@@ -3883,7 +3919,7 @@ package body Freeze is\n       --  make sure that we actually have a real expression (if we have\n       --  a subtype indication, we can't test Is_Static_Expression!)\n \n-      if In_Def_Exp\n+      if In_Spec_Exp\n         and then Nkind (N) in N_Subexpr\n         and then not Is_Static_Expression (N)\n       then\n@@ -4015,7 +4051,7 @@ package body Freeze is\n \n                --  For either of these cases, we skip the freezing\n \n-               if not In_Default_Expression\n+               if not In_Spec_Expression\n                  and then Nkind (N) = N_Identifier\n                  and then (Present (Entity (N)))\n                then\n@@ -4202,11 +4238,11 @@ package body Freeze is\n       --  static type, and the freeze scope needs to be the outer scope, not\n       --  the scope of the subprogram with the default parameter.\n \n-      --  For default expressions in generic units, the Move_Freeze_Nodes\n-      --  mechanism (see sem_ch12.adb) takes care of placing them at the proper\n-      --  place, after the generic unit.\n+      --  For default expressions and other spec expressions in generic units,\n+      --  the Move_Freeze_Nodes mechanism (see sem_ch12.adb) takes care of\n+      --  placing them at the proper place, after the generic unit.\n \n-      if (In_Def_Exp and not Inside_A_Generic)\n+      if (In_Spec_Exp and not Inside_A_Generic)\n         or else Freeze_Outside\n         or else (Is_Type (Current_Scope)\n                   and then (not Is_Concurrent_Type (Current_Scope)\n@@ -4254,15 +4290,15 @@ package body Freeze is\n       end if;\n \n       --  Now we have the right place to do the freezing. First, a special\n-      --  adjustment, if we are in default expression analysis mode, these\n-      --  freeze actions must not be thrown away (normally all inserted actions\n-      --  are thrown away in this mode. However, the freeze actions are from\n-      --  static expressions and one of the important reasons we are doing this\n+      --  adjustment, if we are in spec-expression analysis mode, these freeze\n+      --  actions must not be thrown away (normally all inserted actions are\n+      --  thrown away in this mode. However, the freeze actions are from static\n+      --  expressions and one of the important reasons we are doing this\n       --  special analysis is to get these freeze actions. Therefore we turn\n-      --  off the In_Default_Expression mode to propagate these freeze actions.\n+      --  off the In_Spec_Expression mode to propagate these freeze actions.\n       --  This also means they get properly analyzed and expanded.\n \n-      In_Default_Expression := False;\n+      In_Spec_Expression := False;\n \n       --  Freeze the designated type of an allocator (RM 13.14(13))\n \n@@ -4283,7 +4319,9 @@ package body Freeze is\n          Freeze_Before (P, Nam);\n       end if;\n \n-      In_Default_Expression := In_Def_Exp;\n+      --  Restore In_Spec_Expression flag\n+\n+      In_Spec_Expression := In_Spec_Exp;\n    end Freeze_Expression;\n \n    -----------------------------\n@@ -5080,6 +5118,19 @@ package body Freeze is\n          Error_Msg_N\n            (\"pragma Inline_Always not allowed for dispatching subprograms\", E);\n       end if;\n+\n+      --  Because of the implicit representation of inherited predefined\n+      --  operators in the front-end, the overriding status of the operation\n+      --  may be affected when a full view of a type is analyzed, and this is\n+      --  not captured by the analysis of the corresponding type declaration.\n+      --  Therefore the correctness of a not-overriding indicator must be\n+      --  rechecked when the subprogram is frozen.\n+\n+      if Nkind (E) = N_Defining_Operator_Symbol\n+        and then not Error_Posted (Parent (E))\n+      then\n+         Check_Overriding_Indicator (E, Empty, Is_Primitive (E));\n+      end if;\n    end Freeze_Subprogram;\n \n    ----------------------"}]}