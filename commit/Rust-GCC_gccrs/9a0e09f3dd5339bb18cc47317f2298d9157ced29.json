{"sha": "9a0e09f3dd5339bb18cc47317f2298d9157ced29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwZTA5ZjNkZDUzMzliYjE4Y2M0NzMxN2YyMjk4ZDkxNTdjZWQyOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-04-15T06:34:26Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-04-15T06:34:26Z"}, "message": "Fortran: Fix class reallocate on assignment [PR99307].\n\n2021-04-15  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/99307\n\t* symbol.c: Remove trailing white space.\n\t* trans-array.c (gfc_trans_create_temp_array): Create a class\n\ttemporary for class expressions and assign the new descriptor\n\tto the data field.\n\t(build_class_array_ref): If the class expr can be extracted,\n\tthen use that for 'decl'. Class function results are reliably\n\thandled this way. Call gfc_find_and_cut_at_last_class_ref to\n\teliminate largely redundant code. Remove dead code and recast\n\tthe rest of the code to extract 'decl' for remaining cases.\n\tCall gfc_build_spanned_array_ref.\n\t(gfc_alloc_allocatable_for_assignment): Use class descriptor\n\telement length for 'elemsize1'. Eliminate repeat set of dtype\n\tfor class expressions.\n\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Include\n\tadditional code from build_class_array_ref, and use optional\n\tgfc_typespec pointer argument.\n\t(gfc_trans_scalar_assign): Make use of pre and post blocks for\n\tall class expressions.\n\t* trans.c (get_array_span): For unlimited polymorphic exprs\n\tmultiply the span by the value of the _len field.\n\t(gfc_build_spanned_array_ref): New function.\n\t(gfc_build_array_ref): Call gfc_build_spanned_array_ref and\n\teliminate repeated code.\n\t* trans.h: Add arg to gfc_find_and_cut_at_last_class_ref and\n\tadd prototype for gfc_build_spanned_array_ref.", "tree": {"sha": "f658aeb53db0845fa4210a728a1e2e3e2136464f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f658aeb53db0845fa4210a728a1e2e3e2136464f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0e09f3dd5339bb18cc47317f2298d9157ced29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0e09f3dd5339bb18cc47317f2298d9157ced29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0e09f3dd5339bb18cc47317f2298d9157ced29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0e09f3dd5339bb18cc47317f2298d9157ced29/comments", "author": null, "committer": null, "parents": [{"sha": "417c36cfd620bf2b047852c2aa9ac49004aed2bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417c36cfd620bf2b047852c2aa9ac49004aed2bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/417c36cfd620bf2b047852c2aa9ac49004aed2bc"}], "stats": {"total": 346, "additions": 177, "deletions": 169}, "files": [{"sha": "6d61bf4982bf4daf699d7ef56c19a102a6df2f1b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=9a0e09f3dd5339bb18cc47317f2298d9157ced29", "patch": "@@ -4391,7 +4391,7 @@ get_iso_c_binding_dt (int sym_id)\n \t  if (dt_list->from_intmod != INTMOD_NONE\n \t      && dt_list->intmod_sym_id == sym_id)\n \t    return dt_list;\n-\t\n+\n \t  dt_list = dt_list->dt_next;\n \t}\n     }"}, {"sha": "ca90142530c24ce0048270a11dcb0e800171387d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 79, "deletions": 125, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=9a0e09f3dd5339bb18cc47317f2298d9157ced29", "patch": "@@ -1403,9 +1403,6 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   desc = gfc_create_var (type, \"atmp\");\n   GFC_DECL_PACKED_ARRAY (desc) = 1;\n \n-  info->descriptor = desc;\n-  size = gfc_index_one_node;\n-\n   /* Emit a DECL_EXPR for the variable sized array type in\n      GFC_TYPE_ARRAY_DATAPTR_TYPE so the gimplification of its type\n      sizes works correctly.  */\n@@ -1416,9 +1413,40 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   gfc_add_expr_to_block (pre, build1 (DECL_EXPR,\n \t\t\t\t      arraytype, TYPE_NAME (arraytype)));\n \n-  /* Fill in the array dtype.  */\n-  tmp = gfc_conv_descriptor_dtype (desc);\n-  gfc_add_modify (pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+  if (class_expr != NULL_TREE)\n+    {\n+      tree class_data;\n+      tree dtype;\n+\n+      /* Create a class temporary.  */\n+      tmp = gfc_create_var (TREE_TYPE (class_expr), \"ctmp\");\n+      gfc_add_modify (pre, tmp, class_expr);\n+\n+      /* Assign the new descriptor to the _data field. This allows the\n+\t vptr _copy to be used for scalarized assignment since the class\n+\t temporary can be found from the descriptor.  */\n+      class_data = gfc_class_data_get (tmp);\n+      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t     TREE_TYPE (desc), desc);\n+      gfc_add_modify (pre, class_data, tmp);\n+\n+      /* Take the dtype from the class expression.  */\n+      dtype = gfc_conv_descriptor_dtype (gfc_class_data_get (class_expr));\n+      tmp = gfc_conv_descriptor_dtype (class_data);\n+      gfc_add_modify (pre, tmp, dtype);\n+\n+      /* Point desc to the class _data field.  */\n+      desc = class_data;\n+    }\n+  else\n+    {\n+      /* Fill in the array dtype.  */\n+      tmp = gfc_conv_descriptor_dtype (desc);\n+      gfc_add_modify (pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+    }\n+\n+  info->descriptor = desc;\n+  size = gfc_index_one_node;\n \n   /*\n      Fill in the bounds and stride.  This is a packed array, so:\n@@ -3424,134 +3452,73 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n static bool\n build_class_array_ref (gfc_se *se, tree base, tree index)\n {\n-  tree type;\n   tree size;\n-  tree offset;\n   tree decl = NULL_TREE;\n   tree tmp;\n   gfc_expr *expr = se->ss->info->expr;\n-  gfc_ref *ref;\n-  gfc_ref *class_ref = NULL;\n+  gfc_expr *class_expr;\n   gfc_typespec *ts;\n+  gfc_symbol *sym;\n \n-  if (se->expr && DECL_P (se->expr) && DECL_LANG_SPECIFIC (se->expr)\n-      && GFC_DECL_SAVED_DESCRIPTOR (se->expr)\n-      && GFC_CLASS_TYPE_P (TREE_TYPE (GFC_DECL_SAVED_DESCRIPTOR (se->expr))))\n-    decl = se->expr;\n+  tmp = !VAR_P (base) ? gfc_get_class_from_expr (base) : NULL_TREE;\n+\n+  if (tmp != NULL_TREE)\n+    decl = tmp;\n   else\n     {\n-      if (expr == NULL\n+      /* The base expression does not contain a class component, either\n+\t because it is a temporary array or array descriptor.  Class\n+\t array functions are correctly resolved above.  */\n+      if (!expr\n \t  || (expr->ts.type != BT_CLASS\n-\t      && !gfc_is_class_array_function (expr)\n \t      && !gfc_is_class_array_ref (expr, NULL)))\n \treturn false;\n \n-      if (expr->symtree && expr->symtree->n.sym->ts.type == BT_CLASS)\n-\tts = &expr->symtree->n.sym->ts;\n-      else\n-\tts = NULL;\n-\n-      for (ref = expr->ref; ref; ref = ref->next)\n-\t{\n-\t  if (ref->type == REF_COMPONENT\n-\t      && ref->u.c.component->ts.type == BT_CLASS\n-\t      && ref->next && ref->next->type == REF_COMPONENT\n-\t      && strcmp (ref->next->u.c.component->name, \"_data\") == 0\n-\t      && ref->next->next\n-\t      && ref->next->next->type == REF_ARRAY\n-\t      && ref->next->next->u.ar.type != AR_ELEMENT)\n-\t    {\n-\t      ts = &ref->u.c.component->ts;\n-\t      class_ref = ref;\n-\t      break;\n-\t    }\n-\t}\n+      /* Obtain the expression for the class entity or component that is\n+\t followed by an array reference, which is not an element, so that\n+\t the span of the array can be obtained.  */\n+      class_expr = gfc_find_and_cut_at_last_class_ref (expr, false, &ts);\n \n-      if (ts == NULL)\n+      if (!ts)\n \treturn false;\n-    }\n \n-  if (class_ref == NULL && expr && expr->symtree->n.sym->attr.function\n-      && expr->symtree->n.sym == expr->symtree->n.sym->result\n-      && expr->symtree->n.sym->backend_decl == current_function_decl)\n-    {\n-      decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);\n-    }\n-  else if (expr && gfc_is_class_array_function (expr))\n-    {\n-      size = NULL_TREE;\n-      decl = NULL_TREE;\n-      for (tmp = base; tmp; tmp = TREE_OPERAND (tmp, 0))\n-\t{\n-\t  tree type;\n-\t  type = TREE_TYPE (tmp);\n-\t  while (type)\n-\t    {\n-\t      if (GFC_CLASS_TYPE_P (type))\n-\t\tdecl = tmp;\n-\t      if (type != TYPE_CANONICAL (type))\n-\t\ttype = TYPE_CANONICAL (type);\n-\t      else\n-\t\ttype = NULL_TREE;\n-\t    }\n-\t  if (VAR_P (tmp))\n-\t    break;\n+      sym = (!class_expr && expr) ? expr->symtree->n.sym : NULL;\n+      if (sym && sym->attr.function\n+\t  && sym == sym->result\n+\t  && sym->backend_decl == current_function_decl)\n+\t/* The temporary is the data field of the class data component\n+\t   of the current function.  */\n+\tdecl = gfc_get_fake_result_decl (sym, 0);\n+      else if (sym)\n+\t{\n+\t  if (decl == NULL_TREE)\n+\t    decl = expr->symtree->n.sym->backend_decl;\n+\t  /* For class arrays the tree containing the class is stored in\n+\t     GFC_DECL_SAVED_DESCRIPTOR of the sym's backend_decl.\n+\t     For all others it's sym's backend_decl directly.  */\n+\t  if (DECL_LANG_SPECIFIC (decl) && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+\t    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n \t}\n+      else\n+\tdecl = gfc_get_class_from_gfc_expr (class_expr);\n \n-      if (decl == NULL_TREE)\n-\treturn false;\n+      if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+\tdecl = build_fold_indirect_ref_loc (input_location, decl);\n \n-      se->class_vptr = gfc_evaluate_now (gfc_class_vptr_get (decl), &se->pre);\n-    }\n-  else if (class_ref == NULL)\n-    {\n-      if (decl == NULL_TREE)\n-\tdecl = expr->symtree->n.sym->backend_decl;\n-      /* For class arrays the tree containing the class is stored in\n-\t GFC_DECL_SAVED_DESCRIPTOR of the sym's backend_decl.\n-\t For all others it's sym's backend_decl directly.  */\n-      if (DECL_LANG_SPECIFIC (decl) && GFC_DECL_SAVED_DESCRIPTOR (decl))\n-\tdecl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n-    }\n-  else\n-    {\n-      /* Remove everything after the last class reference, convert the\n-\t expression and then recover its tailend once more.  */\n-      gfc_se tmpse;\n-      ref = class_ref->next;\n-      class_ref->next = NULL;\n-      gfc_init_se (&tmpse, NULL);\n-      gfc_conv_expr (&tmpse, expr);\n-      gfc_add_block_to_block (&se->pre, &tmpse.pre);\n-      decl = tmpse.expr;\n-      class_ref->next = ref;\n+      if (!GFC_CLASS_TYPE_P (TREE_TYPE (decl)))\n+\treturn false;\n     }\n \n-  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n-    decl = build_fold_indirect_ref_loc (input_location, decl);\n-\n-  if (!GFC_CLASS_TYPE_P (TREE_TYPE (decl)))\n-    return false;\n+  se->class_vptr = gfc_evaluate_now (gfc_class_vptr_get (decl), &se->pre);\n \n   size = gfc_class_vtab_size_get (decl);\n-\n   /* For unlimited polymorphic entities then _len component needs to be\n      multiplied with the size.  */\n   size = gfc_resize_class_size_with_len (&se->pre, decl, size);\n-\n   size = fold_convert (TREE_TYPE (index), size);\n \n-  /* Build the address of the element.  */\n-  type = TREE_TYPE (TREE_TYPE (base));\n-  offset = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t    gfc_array_index_type,\n-\t\t\t    index, size);\n-  tmp = gfc_build_addr_expr (pvoid_type_node, base);\n-  tmp = fold_build_pointer_plus_loc (input_location, tmp, offset);\n-  tmp = fold_convert (build_pointer_type (type), tmp);\n-\n   /* Return the element in the se expression.  */\n-  se->expr = build_fold_indirect_ref_loc (input_location, tmp);\n+  se->expr = gfc_build_spanned_array_ref (base, index, size);\n   return true;\n }\n \n@@ -10280,23 +10247,10 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n     }\n   else if (expr1->ts.type == BT_CLASS)\n     {\n-      tmp = expr1->rank ? gfc_get_class_from_expr (desc) : NULL_TREE;\n-      if (tmp == NULL_TREE)\n-\ttmp = gfc_get_class_from_gfc_expr (expr1);\n-\n-      if (tmp != NULL_TREE)\n-\t{\n-\t  tmp2 = gfc_class_vptr_get (tmp);\n-\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  logical_type_node, tmp2,\n-\t\t\t\t  build_int_cst (TREE_TYPE (tmp2), 0));\n-\t  elemsize1 = gfc_class_vtab_size_get (tmp);\n-\t  elemsize1 = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t      gfc_array_index_type, cond,\n-\t\t\t\t      elemsize1, gfc_index_zero_node);\n-\t}\n-      else\n-\telemsize1 = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&CLASS_DATA (expr1)->ts));\n+      /* Unfortunately, the lhs vptr is set too early in many cases.\n+\t Play it safe by using the descriptor element length.  */\n+      tmp = gfc_conv_descriptor_elem_len (desc);\n+      elemsize1 = fold_convert (gfc_array_index_type, tmp);\n     }\n   else\n     elemsize1 = NULL_TREE;\n@@ -10770,11 +10724,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \n \n   /* We already set the dtype in the case of deferred character\n-     length arrays and unlimited polymorphic arrays.  */\n+     length arrays and class lvalues.  */\n   if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n \t&& ((expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n \t    || coarray))\n-      && !UNLIMITED_POLY (expr1))\n+      && expr1->ts.type != BT_CLASS)\n     {\n       tmp = gfc_conv_descriptor_dtype (desc);\n       gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));"}, {"sha": "213f32b0a672f99c339de98fa7507cf27aacdc95", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 69, "deletions": 29, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=9a0e09f3dd5339bb18cc47317f2298d9157ced29", "patch": "@@ -380,43 +380,80 @@ gfc_vptr_size_get (tree vptr)\n #undef VTABLE_FINAL_FIELD\n \n \n-/* Search for the last _class ref in the chain of references of this\n-   expression and cut the chain there.  Albeit this routine is similiar\n-   to class.c::gfc_add_component_ref (), is there a significant\n-   difference: gfc_add_component_ref () concentrates on an array ref to\n-   be the last ref in the chain.  This routine is oblivious to the kind\n-   of refs following.  */\n+/* IF ts is null (default), search for the last _class ref in the chain\n+   of references of the expression and cut the chain there.  Although\n+   this routine is similiar to class.c:gfc_add_component_ref (), there\n+   is a significant difference: gfc_add_component_ref () concentrates\n+   on an array ref that is the last ref in the chain and is oblivious\n+   to the kind of refs following.\n+   ELSE IF ts is non-null the cut is at the class entity or component\n+   that is followed by an array reference, which is not an element.\n+   These calls come from trans-array.c:build_class_array_ref, which\n+   handles scalarized class array references.*/\n \n gfc_expr *\n-gfc_find_and_cut_at_last_class_ref (gfc_expr *e, bool is_mold)\n+gfc_find_and_cut_at_last_class_ref (gfc_expr *e, bool is_mold,\n+\t\t\t\t    gfc_typespec **ts)\n {\n   gfc_expr *base_expr;\n   gfc_ref *ref, *class_ref, *tail = NULL, *array_ref;\n \n   /* Find the last class reference.  */\n   class_ref = NULL;\n   array_ref = NULL;\n-  for (ref = e->ref; ref; ref = ref->next)\n+\n+  if (ts)\n     {\n-      if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n-\tarray_ref = ref;\n+      if (e->symtree\n+\t  && e->symtree->n.sym->ts.type == BT_CLASS)\n+\t*ts = &e->symtree->n.sym->ts;\n+      else\n+\t*ts = NULL;\n+    }\n \n-      if (ref->type == REF_COMPONENT\n-\t  && ref->u.c.component->ts.type == BT_CLASS)\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ts)\n \t{\n-\t  /* Component to the right of a part reference with nonzero rank\n-\t     must not have the ALLOCATABLE attribute.  If attempts are\n-\t     made to reference such a component reference, an error results\n-\t     followed by an ICE.  */\n-\t  if (array_ref && CLASS_DATA (ref->u.c.component)->attr.allocatable)\n-\t    return NULL;\n-\t  class_ref = ref;\n+\t  if (ref->type == REF_COMPONENT\n+\t      && ref->u.c.component->ts.type == BT_CLASS\n+\t      && ref->next && ref->next->type == REF_COMPONENT\n+\t      && !strcmp (ref->next->u.c.component->name, \"_data\")\n+\t      && ref->next->next\n+\t      && ref->next->next->type == REF_ARRAY\n+\t      && ref->next->next->u.ar.type != AR_ELEMENT)\n+\t    {\n+\t      *ts = &ref->u.c.component->ts;\n+\t      class_ref = ref;\n+\t      break;\n+\t    }\n+\n+\t  if (ref->next == NULL)\n+\t    break;\n \t}\n+      else\n+\t{\n+\t  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n+\t    array_ref = ref;\n \n-      if (ref->next == NULL)\n-\tbreak;\n+\t  if (ref->type == REF_COMPONENT\n+\t      && ref->u.c.component->ts.type == BT_CLASS)\n+\t    {\n+\t      /* Component to the right of a part reference with nonzero\n+\t\t rank must not have the ALLOCATABLE attribute.  If attempts\n+\t\t are made to reference such a component reference, an error\n+\t\t results followed by an ICE.  */\n+\t      if (array_ref\n+\t\t  && CLASS_DATA (ref->u.c.component)->attr.allocatable)\n+\t\treturn NULL;\n+\t      class_ref = ref;\n+\t    }\n+\t}\n     }\n \n+  if (ts && *ts == NULL)\n+    return NULL;\n+\n   /* Remove and store all subsequent references after the\n      CLASS reference.  */\n   if (class_ref)\n@@ -10005,17 +10042,20 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_add_modify (&block, lse->expr, tmp);\n     }\n   /* If possible use the rhs vptr copy with trans_scalar_class_assign....  */\n-  else if (ts.type == BT_CLASS\n-\t   && !trans_scalar_class_assign (&block, lse, rse))\n+  else if (ts.type == BT_CLASS)\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n-      /* ...otherwise assignment suffices. Note the use of VIEW_CONVERT_EXPR\n-\t for the lhs which ensures that class data rhs cast as a string assigns\n-\t correctly.  */\n-      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n-\t\t\t     TREE_TYPE (rse->expr), lse->expr);\n-      gfc_add_modify (&block, tmp, rse->expr);\n+\n+      if (!trans_scalar_class_assign (&block, lse, rse))\n+\t{\n+\t  /* ...otherwise assignment suffices. Note the use of VIEW_CONVERT_EXPR\n+\t  for the lhs which ensures that class data rhs cast as a string assigns\n+\t  correctly.  */\n+\t  tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t\t TREE_TYPE (rse->expr), lse->expr);\n+\t  gfc_add_modify (&block, tmp, rse->expr);\n+\t}\n     }\n   else if (ts.type != BT_CLASS)\n     {"}, {"sha": "9e8e8619ff837ba18dfd9374794db0eb9b0d380b", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=9a0e09f3dd5339bb18cc47317f2298d9157ced29", "patch": "@@ -422,6 +422,9 @@ get_array_span (tree type, tree decl)\n \t\treturn NULL_TREE;\n \t    }\n \t  span = gfc_class_vtab_size_get (decl);\n+\t  /* For unlimited polymorphic entities then _len component needs\n+\t     to be multiplied with the size.  */\n+\t  span = gfc_resize_class_size_with_len (NULL, decl, span);\n \t}\n       else if (GFC_DECL_PTR_ARRAY_P (decl))\n \t{\n@@ -439,13 +442,31 @@ get_array_span (tree type, tree decl)\n }\n \n \n+tree\n+gfc_build_spanned_array_ref (tree base, tree offset, tree span)\n+{\n+  tree type;\n+  tree tmp;\n+  type = TREE_TYPE (TREE_TYPE (base));\n+  offset = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t    gfc_array_index_type,\n+\t\t\t    offset, span);\n+  tmp = gfc_build_addr_expr (pvoid_type_node, base);\n+  tmp = fold_build_pointer_plus_loc (input_location, tmp, offset);\n+  tmp = fold_convert (build_pointer_type (type), tmp);\n+  if ((TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != ARRAY_TYPE)\n+      || !TYPE_STRING_FLAG (type))\n+    tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+  return tmp;\n+}\n+\n+\n /* Build an ARRAY_REF with its natural type.  */\n \n tree\n gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n {\n   tree type = TREE_TYPE (base);\n-  tree tmp;\n   tree span = NULL_TREE;\n \n   if (GFC_ARRAY_TYPE_P (type) && GFC_TYPE_ARRAY_RANK (type) == 0)\n@@ -488,18 +509,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n   /* If a non-null span has been generated reference the element with\n      pointer arithmetic.  */\n   if (span != NULL_TREE)\n-    {\n-      offset = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\tgfc_array_index_type,\n-\t\t\t\toffset, span);\n-      tmp = gfc_build_addr_expr (pvoid_type_node, base);\n-      tmp = fold_build_pointer_plus_loc (input_location, tmp, offset);\n-      tmp = fold_convert (build_pointer_type (type), tmp);\n-      if ((TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != ARRAY_TYPE)\n-\t  || !TYPE_STRING_FLAG (type))\n-\ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n-      return tmp;\n-    }\n+    return gfc_build_spanned_array_ref (base, offset, span);\n   /* Otherwise use a straightforward array reference.  */\n   else\n     return build4_loc (input_location, ARRAY_REF, type, base, offset,"}, {"sha": "8c6f82ff1b121d51b04b1a0e26fb2c708562838c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0e09f3dd5339bb18cc47317f2298d9157ced29/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=9a0e09f3dd5339bb18cc47317f2298d9157ced29", "patch": "@@ -424,7 +424,8 @@ tree gfc_class_vptr_get (tree);\n tree gfc_class_len_get (tree);\n tree gfc_class_len_or_zero_get (tree);\n tree gfc_resize_class_size_with_len (stmtblock_t *, tree, tree);\n-gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);\n+gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false,\n+\t\t\t\t\t       gfc_typespec **ts = NULL);\n /* Get an accessor to the class' vtab's * field, when a class handle is\n    available.  */\n tree gfc_class_vtab_hash_get (tree);\n@@ -622,6 +623,9 @@ tree gfc_build_addr_expr (tree, tree);\n /* Build an ARRAY_REF.  */\n tree gfc_build_array_ref (tree, tree, tree, tree vptr = NULL_TREE);\n \n+/* Build an array ref using pointer arithmetic.  */\n+tree gfc_build_spanned_array_ref (tree base, tree offset, tree span);\n+\n /* Creates a label.  Decl is artificial if label_id == NULL_TREE.  */\n tree gfc_build_label_decl (tree);\n "}]}