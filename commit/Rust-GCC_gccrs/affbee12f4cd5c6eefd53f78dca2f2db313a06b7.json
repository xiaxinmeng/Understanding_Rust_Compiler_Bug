{"sha": "affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZmYmVlMTJmNGNkNWM2ZWVmZDUzZjc4ZGNhMmYyZGIzMTNhMDZiNw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:06:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:06:54Z"}, "message": "sem_ch13.adb: Storage pool cannot be given for access to subprogram type.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb: Storage pool cannot be given for access to subprogram\n\ttype.\n\t(New_Stream_Subprogram): When processing an attribute definition clause\n\tfor a stream-oriented subprogram, record an entity node occurring at\n\tthe point of clause to use for checking the visibility of the clause,\n\tas defined by 8.3(23) as amended by AI-195.\n\t(New_Stream_Subprogram): New procedure, factoring behaviour from both\n\t New_Stream_Function and New_Stream_Procedure.\n\t(New_Stream_Function, New_Stream_Procedure): Removed.\n\t(Analyze_Attribute_Definition_Clause, case Address): Check new\n\tAlignment_Check check\n\nFrom-SVN: r118301", "tree": {"sha": "ec514e71e7c10f3801e31afab79e000bb96d6cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec514e71e7c10f3801e31afab79e000bb96d6cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affbee12f4cd5c6eefd53f78dca2f2db313a06b7/comments", "author": null, "committer": null, "parents": [{"sha": "097fdf65a05396d05141261b11af098ad63b346e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097fdf65a05396d05141261b11af098ad63b346e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097fdf65a05396d05141261b11af098ad63b346e"}], "stats": {"total": 410, "additions": 198, "deletions": 212}, "files": [{"sha": "6a49bd565ca8c1b1479a6471f7a1d50cfd7b7aca", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 198, "deletions": 212, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/affbee12f4cd5c6eefd53f78dca2f2db313a06b7/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/affbee12f4cd5c6eefd53f78dca2f2db313a06b7/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "patch": "@@ -43,6 +43,7 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n+with Sem_Warn; use Sem_Warn;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n@@ -92,38 +93,26 @@ package body Sem_Ch13 is\n    --  the expression N is of the form of K'Address, then the entity that\n    --  is associated with K is marked as volatile.\n \n-   procedure New_Stream_Function\n+   procedure New_Stream_Subprogram\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n       Subp : Entity_Id;\n       Nam  : TSS_Name_Type);\n-   --  Create a function renaming of a given stream attribute to the\n-   --  designated subprogram and then in the tagged case, provide this as\n-   --  a primitive operation, or in the non-tagged case make an appropriate\n-   --  TSS entry. Used for Input. This is more properly an expansion activity\n-   --  than just semantics, but the presence of user-defined stream functions\n-   --  for limited types is a legality check, which is why this takes place\n-   --  here rather than in exp_ch13, where it was previously. Nam indicates\n-   --  the name of the TSS function to be generated.\n+   --  Create a subprogram renaming of a given stream attribute to the\n+   --  designated subprogram and then in the tagged case, provide this as a\n+   --  primitive operation, or in the non-tagged case make an appropriate TSS\n+   --  entry. This is more properly an expansion activity than just semantics,\n+   --  but the presence of user-defined stream functions for limited types is a\n+   --  legality check, which is why this takes place here rather than in\n+   --  exp_ch13, where it was previously. Nam indicates the name of the TSS\n+   --  function to be generated.\n    --\n    --  To avoid elaboration anomalies with freeze nodes, for untagged types\n    --  we generate both a subprogram declaration and a subprogram renaming\n    --  declaration, so that the attribute specification is handled as a\n    --  renaming_as_body. For tagged types, the specification is one of the\n    --  primitive specs.\n \n-   procedure New_Stream_Procedure\n-     (N     : Node_Id;\n-      Ent   : Entity_Id;\n-      Subp  : Entity_Id;\n-      Nam   : TSS_Name_Type;\n-      Out_P : Boolean := False);\n-   --  Create a procedure renaming of a given stream attribute to the\n-   --  designated subprogram and then in the tagged case, provide this as\n-   --  a primitive operation, or in the non-tagged case make an appropriate\n-   --  TSS entry. Used for Read, Output, Write. Nam indicates the name of\n-   --  the TSS procedure to be generated.\n-\n    ----------------------------------------------\n    -- Table for Validate_Unchecked_Conversions --\n    ----------------------------------------------\n@@ -322,7 +311,21 @@ package body Sem_Ch13 is\n \n          Pnam := TSS (Base_Type (U_Ent), TSS_Nam);\n \n-         if Present (Pnam) and then Has_Good_Profile (Pnam) then\n+         --  If Pnam is present, it can be either inherited from an ancestor\n+         --  type (in which case it is legal to redefine it for this type), or\n+         --  be a previous definition of the attribute for the same type (in\n+         --  which case it is illegal).\n+\n+         --  In the first case, it will have been analyzed already, and we\n+         --  can check that its profile does not match the expected profile\n+         --  for a stream attribute of U_Ent. In the second case, either Pnam\n+         --  has been analyzed (and has the expected profile), or it has not\n+         --  been analyzed yet (case of a type that has not been frozen yet\n+         --  and for which the stream attribute has been set using Set_TSS).\n+\n+         if Present (Pnam)\n+           and then (No (First_Entity (Pnam)) or else Has_Good_Profile (Pnam))\n+         then\n             Error_Msg_Sloc := Sloc (Pnam);\n             Error_Msg_Name_1 := Attr;\n             Error_Msg_N (\"% attribute already defined #\", Nam);\n@@ -360,12 +363,7 @@ package body Sem_Ch13 is\n             Set_Entity (Expr, Subp);\n             Set_Etype (Expr, Etype (Subp));\n \n-            if TSS_Nam = TSS_Stream_Input then\n-               New_Stream_Function (N, U_Ent, Subp, TSS_Nam);\n-            else\n-               New_Stream_Procedure (N, U_Ent, Subp, TSS_Nam,\n-                                     Out_P => Is_Read);\n-            end if;\n+            New_Stream_Subprogram (N, U_Ent, Subp, TSS_Nam);\n \n          else\n             Error_Msg_Name_1 := Attr;\n@@ -623,11 +621,14 @@ package body Sem_Ch13 is\n                         Nam);\n                   end if;\n \n-                  --  Entity has delayed freeze, so we will generate\n-                  --  an alignment check at the freeze point.\n+                  --  Entity has delayed freeze, so we will generate an\n+                  --  alignment check at the freeze point unless suppressed.\n \n-                  Set_Check_Address_Alignment\n-                    (N, not Range_Checks_Suppressed (U_Ent));\n+                  if not Range_Checks_Suppressed (U_Ent)\n+                    and then not Alignment_Checks_Suppressed (U_Ent)\n+                  then\n+                     Set_Check_Address_Alignment (N);\n+                  end if;\n \n                   --  Kill the size check code, since we are not allocating\n                   --  the variable, it is somewhere else.\n@@ -1046,75 +1047,6 @@ package body Sem_Ch13 is\n             end if;\n          end Small;\n \n-         ------------------\n-         -- Storage_Size --\n-         ------------------\n-\n-         --  Storage_Size attribute definition clause\n-\n-         when Attribute_Storage_Size => Storage_Size : declare\n-            Btype : constant Entity_Id := Base_Type (U_Ent);\n-            Sprag : Node_Id;\n-\n-         begin\n-            if Is_Task_Type (U_Ent) then\n-               Check_Restriction (No_Obsolescent_Features, N);\n-\n-               if Warn_On_Obsolescent_Feature then\n-                  Error_Msg_N\n-                    (\"storage size clause for task is an \" &\n-                     \"obsolescent feature ('R'M 'J.9)?\", N);\n-                  Error_Msg_N\n-                    (\"\\use Storage_Size pragma instead?\", N);\n-               end if;\n-\n-               FOnly := True;\n-            end if;\n-\n-            if not Is_Access_Type (U_Ent)\n-              and then Ekind (U_Ent) /= E_Task_Type\n-            then\n-               Error_Msg_N (\"storage size cannot be given for &\", Nam);\n-\n-            elsif Is_Access_Type (U_Ent) and Is_Derived_Type (U_Ent) then\n-               Error_Msg_N\n-                 (\"storage size cannot be given for a derived access type\",\n-                  Nam);\n-\n-            elsif Has_Storage_Size_Clause (Btype) then\n-               Error_Msg_N (\"storage size already given for &\", Nam);\n-\n-            else\n-               Analyze_And_Resolve (Expr, Any_Integer);\n-\n-               if Is_Access_Type (U_Ent) then\n-\n-                  if Present (Associated_Storage_Pool (U_Ent)) then\n-                     Error_Msg_N (\"storage pool already given for &\", Nam);\n-                     return;\n-                  end if;\n-\n-                  if Compile_Time_Known_Value (Expr)\n-                    and then Expr_Value (Expr) = 0\n-                  then\n-                     Set_No_Pool_Assigned (Btype);\n-                  end if;\n-\n-               else -- Is_Task_Type (U_Ent)\n-                  Sprag := Get_Rep_Pragma (Btype, Name_Storage_Size);\n-\n-                  if Present (Sprag) then\n-                     Error_Msg_Sloc := Sloc (Sprag);\n-                     Error_Msg_N\n-                       (\"Storage_Size already specified#\", Nam);\n-                     return;\n-                  end if;\n-               end if;\n-\n-               Set_Has_Storage_Size_Clause (Btype);\n-            end if;\n-         end Storage_Size;\n-\n          ------------------\n          -- Storage_Pool --\n          ------------------\n@@ -1126,11 +1058,17 @@ package body Sem_Ch13 is\n             T    : Entity_Id;\n \n          begin\n-            if Ekind (U_Ent) /= E_Access_Type\n+            if Ekind (U_Ent) = E_Access_Subprogram_Type then\n+               Error_Msg_N\n+                 (\"storage pool cannot be given for access-to-subprogram type\",\n+                  Nam);\n+               return;\n+\n+            elsif Ekind (U_Ent) /= E_Access_Type\n               and then Ekind (U_Ent) /= E_General_Access_Type\n             then\n-               Error_Msg_N (\n-                 \"storage pool can only be given for access types\", Nam);\n+               Error_Msg_N\n+                 (\"storage pool can only be given for access types\", Nam);\n                return;\n \n             elsif Is_Derived_Type (U_Ent) then\n@@ -1229,6 +1167,74 @@ package body Sem_Ch13 is\n             end if;\n          end Storage_Pool;\n \n+         ------------------\n+         -- Storage_Size --\n+         ------------------\n+\n+         --  Storage_Size attribute definition clause\n+\n+         when Attribute_Storage_Size => Storage_Size : declare\n+            Btype : constant Entity_Id := Base_Type (U_Ent);\n+            Sprag : Node_Id;\n+\n+         begin\n+            if Is_Task_Type (U_Ent) then\n+               Check_Restriction (No_Obsolescent_Features, N);\n+\n+               if Warn_On_Obsolescent_Feature then\n+                  Error_Msg_N\n+                    (\"storage size clause for task is an \" &\n+                     \"obsolescent feature ('R'M 'J.9)?\", N);\n+                  Error_Msg_N\n+                    (\"\\use Storage_Size pragma instead?\", N);\n+               end if;\n+\n+               FOnly := True;\n+            end if;\n+\n+            if not Is_Access_Type (U_Ent)\n+              and then Ekind (U_Ent) /= E_Task_Type\n+            then\n+               Error_Msg_N (\"storage size cannot be given for &\", Nam);\n+\n+            elsif Is_Access_Type (U_Ent) and Is_Derived_Type (U_Ent) then\n+               Error_Msg_N\n+                 (\"storage size cannot be given for a derived access type\",\n+                  Nam);\n+\n+            elsif Has_Storage_Size_Clause (Btype) then\n+               Error_Msg_N (\"storage size already given for &\", Nam);\n+\n+            else\n+               Analyze_And_Resolve (Expr, Any_Integer);\n+\n+               if Is_Access_Type (U_Ent) then\n+                  if Present (Associated_Storage_Pool (U_Ent)) then\n+                     Error_Msg_N (\"storage pool already given for &\", Nam);\n+                     return;\n+                  end if;\n+\n+                  if Compile_Time_Known_Value (Expr)\n+                    and then Expr_Value (Expr) = 0\n+                  then\n+                     Set_No_Pool_Assigned (Btype);\n+                  end if;\n+\n+               else -- Is_Task_Type (U_Ent)\n+                  Sprag := Get_Rep_Pragma (Btype, Name_Storage_Size);\n+\n+                  if Present (Sprag) then\n+                     Error_Msg_Sloc := Sloc (Sprag);\n+                     Error_Msg_N\n+                       (\"Storage_Size already specified#\", Nam);\n+                     return;\n+                  end if;\n+               end if;\n+\n+               Set_Has_Storage_Size_Clause (Btype);\n+            end if;\n+         end Storage_Size;\n+\n          -----------------\n          -- Stream_Size --\n          -----------------\n@@ -1349,6 +1355,8 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n+      Check_Code_Statement (N);\n+\n       --  Make sure we appear in the handled statement sequence of a\n       --  subprogram (RM 13.8(3)).\n \n@@ -2630,7 +2638,7 @@ package body Sem_Ch13 is\n             when N_Null =>\n                return;\n \n-            when N_Binary_Op | N_And_Then | N_Or_Else | N_In | N_Not_In =>\n+            when N_Binary_Op | N_And_Then | N_Or_Else | N_Membership_Test =>\n                Check_Expr_Constants (Left_Opnd (Nod));\n                Check_Expr_Constants (Right_Opnd (Nod));\n \n@@ -3116,15 +3124,15 @@ package body Sem_Ch13 is\n       return S;\n    end Minimum_Size;\n \n-   -------------------------\n-   -- New_Stream_Function --\n-   -------------------------\n+   ---------------------------\n+   -- New_Stream_Subprogram --\n+   ---------------------------\n \n-   procedure New_Stream_Function\n-     (N    : Node_Id;\n-      Ent  : Entity_Id;\n-      Subp : Entity_Id;\n-      Nam  : TSS_Name_Type)\n+   procedure New_Stream_Subprogram\n+     (N     : Node_Id;\n+      Ent   : Entity_Id;\n+      Subp  : Entity_Id;\n+      Nam   : TSS_Name_Type)\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Sname     : constant Name_Id    := Make_TSS_Name (Base_Type (Ent), Nam);\n@@ -3133,6 +3141,14 @@ package body Sem_Ch13 is\n       F         : Entity_Id;\n       Etyp      : Entity_Id;\n \n+      Defer_Declaration : constant Boolean :=\n+                            Is_Tagged_Type (Ent) or else Is_Private_Type (Ent);\n+      --  For a tagged type, there is a declaration for each stream attribute\n+      --  at the freeze point, and we must generate only a completion of this\n+      --  declaration. We do the same for private types, because the full view\n+      --  might be tagged. Otherwise we generate a declaration at the point of\n+      --  the attribute definition clause.\n+\n       function Build_Spec return Node_Id;\n       --  Used for declaration and renaming declaration, so that this is\n       --  treated as a renaming_as_body.\n@@ -3142,139 +3158,109 @@ package body Sem_Ch13 is\n       ----------------\n \n       function Build_Spec return Node_Id is\n+         Out_P   : constant Boolean := (Nam = TSS_Stream_Read);\n+         Formals : List_Id;\n+         Spec    : Node_Id;\n+         T_Ref   : constant Node_Id := New_Reference_To (Etyp, Loc);\n+\n       begin\n          Subp_Id := Make_Defining_Identifier (Loc, Sname);\n \n-         return\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name => Subp_Id,\n-             Parameter_Specifications =>\n-               New_List (\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Name_S),\n-                   Parameter_Type =>\n-                     Make_Access_Definition (Loc,\n-                       Subtype_Mark =>\n-                         New_Reference_To (\n-                           Designated_Type (Etype (F)), Loc)))),\n-\n-             Result_Definition =>\n-               New_Reference_To (Etyp, Loc));\n-      end Build_Spec;\n+         --  S : access Root_Stream_Type'Class\n+\n+         Formals := New_List (\n+                      Make_Parameter_Specification (Loc,\n+                        Defining_Identifier =>\n+                          Make_Defining_Identifier (Loc, Name_S),\n+                        Parameter_Type =>\n+                          Make_Access_Definition (Loc,\n+                            Subtype_Mark =>\n+                              New_Reference_To (\n+                                Designated_Type (Etype (F)), Loc))));\n+\n+         if Nam = TSS_Stream_Input then\n+            Spec := Make_Function_Specification (Loc,\n+                      Defining_Unit_Name       => Subp_Id,\n+                      Parameter_Specifications => Formals,\n+                      Result_Definition        => T_Ref);\n+         else\n+            --  V : [out] T\n \n-   --  Start of processing for New_Stream_Function\n+            Append_To (Formals,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n+                Out_Present         => Out_P,\n+                Parameter_Type      => T_Ref));\n \n-   begin\n-      F    := First_Formal (Subp);\n-      Etyp := Etype (Subp);\n+            Spec := Make_Procedure_Specification (Loc,\n+                      Defining_Unit_Name       => Subp_Id,\n+                      Parameter_Specifications => Formals);\n+         end if;\n \n-      if not Is_Tagged_Type (Ent) then\n-         Subp_Decl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Build_Spec);\n-         Insert_Action (N, Subp_Decl);\n-      end if;\n+         return Spec;\n+      end Build_Spec;\n \n-      Subp_Decl :=\n-        Make_Subprogram_Renaming_Declaration (Loc,\n-          Specification => Build_Spec,\n-          Name => New_Reference_To (Subp, Loc));\n+   --  Start of processing for New_Stream_Subprogram\n \n-      if Is_Tagged_Type (Ent) then\n-         Set_TSS (Base_Type (Ent), Subp_Id);\n+   begin\n+      F := First_Formal (Subp);\n+\n+      if Ekind (Subp) = E_Procedure then\n+         Etyp := Etype (Next_Formal (F));\n       else\n-         Insert_Action (N, Subp_Decl);\n-         Copy_TSS (Subp_Id, Base_Type (Ent));\n+         Etyp := Etype (Subp);\n       end if;\n-   end New_Stream_Function;\n-\n-   --------------------------\n-   -- New_Stream_Procedure --\n-   --------------------------\n-\n-   procedure New_Stream_Procedure\n-     (N     : Node_Id;\n-      Ent   : Entity_Id;\n-      Subp  : Entity_Id;\n-      Nam   : TSS_Name_Type;\n-      Out_P : Boolean := False)\n-   is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Sname     : constant Name_Id    := Make_TSS_Name (Base_Type (Ent), Nam);\n-      Subp_Id   : Entity_Id;\n-      Subp_Decl : Node_Id;\n-      F         : Entity_Id;\n-      Etyp      : Entity_Id;\n-\n-      function Build_Spec return Node_Id;\n-      --  Used for declaration and renaming declaration, so that this is\n-      --  treated as a renaming_as_body.\n \n-      ----------------\n-      -- Build_Spec --\n-      ----------------\n+      --  Prepare subprogram declaration and insert it as an action on the\n+      --  clause node. The visibility for this entity is used to test for\n+      --  visibility of the attribute definition clause (in the sense of\n+      --  8.3(23) as amended by AI-195).\n \n-      function Build_Spec return Node_Id is\n-      begin\n-         Subp_Id := Make_Defining_Identifier (Loc, Sname);\n-\n-         return\n-           Make_Procedure_Specification (Loc,\n-             Defining_Unit_Name => Subp_Id,\n-             Parameter_Specifications =>\n-               New_List (\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Name_S),\n-                   Parameter_Type =>\n-                     Make_Access_Definition (Loc,\n-                       Subtype_Mark =>\n-                         New_Reference_To (\n-                           Designated_Type (Etype (F)), Loc))),\n-\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Name_V),\n-                   Out_Present => Out_P,\n-                   Parameter_Type =>\n-                     New_Reference_To (Etyp, Loc))));\n-      end Build_Spec;\n-\n-      --  Start of processing for New_Stream_Procedure\n-\n-   begin\n-      F        := First_Formal (Subp);\n-      Etyp     := Etype (Next_Formal (F));\n-\n-      if not Is_Tagged_Type (Ent) then\n+      if not Defer_Declaration then\n          Subp_Decl :=\n            Make_Subprogram_Declaration (Loc,\n              Specification => Build_Spec);\n-         Insert_Action (N, Subp_Decl);\n+\n+      --  For a tagged type, there is always a visible declaration for each\n+      --  stream TSS (it is a predefined primitive operation), and the for the\n+      --  completion of this declaration occurs at the freeze point, which is\n+      --  not always visible at places where the attribute definition clause is\n+      --  visible. So, we create a dummy entity here for the purpose of\n+      --  tracking the visibility of the attribute definition clause itself.\n+\n+      else\n+         Subp_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Sname, 'V'));\n+         Subp_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Subp_Id,\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc));\n       end if;\n \n+      Insert_Action (N, Subp_Decl);\n+      Set_Entity (N, Subp_Id);\n+\n       Subp_Decl :=\n         Make_Subprogram_Renaming_Declaration (Loc,\n           Specification => Build_Spec,\n           Name => New_Reference_To (Subp, Loc));\n \n-      if Is_Tagged_Type (Ent) then\n+      if Defer_Declaration then\n          Set_TSS (Base_Type (Ent), Subp_Id);\n       else\n          Insert_Action (N, Subp_Decl);\n          Copy_TSS (Subp_Id, Base_Type (Ent));\n       end if;\n-   end New_Stream_Procedure;\n+   end New_Stream_Subprogram;\n \n    ------------------------\n    -- Rep_Item_Too_Early --\n    ------------------------\n \n    function Rep_Item_Too_Early (T : Entity_Id; N : Node_Id) return Boolean is\n    begin\n-      --  Cannot apply rep items that are not operational items\n-      --  to generic types\n+      --  Cannot apply non-operational rep items to generic types\n \n       if Is_Operational_Item (N) then\n          return False;"}]}