{"sha": "cb0ceeaee9e041aaac3edd089b07b439621d0f29", "node_id": "C_kwDOANBUbNoAKGNiMGNlZWFlZTllMDQxYWFhYzNlZGQwODliMDdiNDM5NjIxZDBmMjk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-07T14:17:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-07T14:17:21Z"}, "message": "libstdc++: Update from latest fast_float [PR107468]\n\nThe following patch updates from fast_float trunk.  That way\nit grabs two of the 4 LOCAL_PATCHES, some smaller tweaks, to_extended\ncleanups and most importantly fix for the incorrect rounding case,\nPR107468 aka https://github.com/fastfloat/fast_float/issues/149\nUsing std::fegetround showed in benchmarks too slow, so instead of\ndoing that the patch limits the fast path where it uses floating\npoint multiplication rather than integral to cases where we can\nprove there will be no rounding (the multiplication will be exact, not\njust that the two multiplication or division operation arguments are\nexactly representable).\n\n2022-11-07  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/107468\n\t* src/c++17/fast_float/MERGE: Adjust for merge from upstream.\n\t* src/c++17/fast_float/LOCAL_PATCHES: Remove commits that were\n\tupstreamed.\n\t* src/c++17/fast_float/README.md: Merge from fast_float\n\t662497742fea7055f0e0ee27e5a7ddc382c2c38e commit.\n\t* src/c++17/fast_float/fast_float.h: Likewise.\n\t* testsuite/20_util/from_chars/pr107468.cc: New test.", "tree": {"sha": "0a3d7a25efa2f353e1cf17254d0ce93eb695af96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a3d7a25efa2f353e1cf17254d0ce93eb695af96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb0ceeaee9e041aaac3edd089b07b439621d0f29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0ceeaee9e041aaac3edd089b07b439621d0f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb0ceeaee9e041aaac3edd089b07b439621d0f29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0ceeaee9e041aaac3edd089b07b439621d0f29/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5bcbcd04cfcb2f8635ea8431f4e77065e44b0bd"}], "stats": {"total": 310, "additions": 211, "deletions": 99}, "files": [{"sha": "71495d6728bf115bd4eaacc717e947de1ac8828e", "filename": "libstdc++-v3/src/c++17/fast_float/LOCAL_PATCHES", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FLOCAL_PATCHES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FLOCAL_PATCHES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FLOCAL_PATCHES?ref=cb0ceeaee9e041aaac3edd089b07b439621d0f29", "patch": "@@ -1,4 +1,2 @@\n r12-6647\n r12-6648\n-r12-6664\n-r12-6665"}, {"sha": "20eae9d710f88a7f17cd1061d251d60b3f94d702", "filename": "libstdc++-v3/src/c++17/fast_float/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FMERGE?ref=cb0ceeaee9e041aaac3edd089b07b439621d0f29", "patch": "@@ -1,4 +1,4 @@\n-d35368cae610b4edeec61cd41e4d2367a4d33f58\n+662497742fea7055f0e0ee27e5a7ddc382c2c38e\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "d6ae279527c6e63f93687ae041add4e74788b65a", "filename": "libstdc++-v3/src/c++17/fast_float/README.md", "status": "modified", "additions": 57, "deletions": 34, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FREADME.md?ref=cb0ceeaee9e041aaac3edd089b07b439621d0f29", "patch": "@@ -1,12 +1,5 @@\n ## fast_float number parsing library: 4x faster than strtod\n \n-![Ubuntu 20.04 CI (GCC 9)](https://github.com/lemire/fast_float/workflows/Ubuntu%2020.04%20CI%20(GCC%209)/badge.svg)\n-![Ubuntu 18.04 CI (GCC 7)](https://github.com/lemire/fast_float/workflows/Ubuntu%2018.04%20CI%20(GCC%207)/badge.svg)\n-![Alpine Linux](https://github.com/lemire/fast_float/workflows/Alpine%20Linux/badge.svg)\n-![MSYS2-CI](https://github.com/lemire/fast_float/workflows/MSYS2-CI/badge.svg)\n-![VS16-CLANG-CI](https://github.com/lemire/fast_float/workflows/VS16-CLANG-CI/badge.svg)\n-[![VS16-CI](https://github.com/fastfloat/fast_float/actions/workflows/vs16-ci.yml/badge.svg)](https://github.com/fastfloat/fast_float/actions/workflows/vs16-ci.yml)\n-\n The fast_float library provides fast header-only implementations for the C++ from_chars\n functions for `float` and `double` types.  These functions convert ASCII strings representing\n decimal values (e.g., `1.3e10`) into binary types. We provide exact rounding (including\n@@ -28,8 +21,8 @@ struct from_chars_result {\n ```\n \n It parses the character sequence [first,last) for a number. It parses floating-point numbers expecting\n-a locale-independent format equivalent to the C++17 from_chars function. \n-The resulting floating-point value is the closest floating-point values (using either float or double), \n+a locale-independent format equivalent to the C++17 from_chars function.\n+The resulting floating-point value is the closest floating-point values (using either float or double),\n using the \"round to even\" convention for values that would otherwise fall right in-between two values.\n That is, we provide exact parsing according to the IEEE standard.\n \n@@ -47,7 +40,7 @@ Example:\n ``` C++\n #include \"fast_float/fast_float.h\"\n #include <iostream>\n- \n+\n int main() {\n     const std::string input =  \"3.1416 xyz \";\n     double result;\n@@ -60,15 +53,15 @@ int main() {\n \n \n Like the C++17 standard, the `fast_float::from_chars` functions take an optional last argument of\n-the type `fast_float::chars_format`. It is a bitset value: we check whether \n+the type `fast_float::chars_format`. It is a bitset value: we check whether\n `fmt & fast_float::chars_format::fixed` and `fmt & fast_float::chars_format::scientific` are set\n to determine whether we allow the fixed point and scientific notation respectively.\n The default is  `fast_float::chars_format::general` which allows both `fixed` and `scientific`.\n \n-The library seeks to follow the C++17 (see [20.19.3](http://eel.is/c++draft/charconv.from.chars).(7.1))  specification. \n+The library seeks to follow the C++17 (see [20.19.3](http://eel.is/c++draft/charconv.from.chars).(7.1))  specification.\n * The `from_chars` function does not skip leading white-space characters.\n * [A leading `+` sign](https://en.cppreference.com/w/cpp/utility/from_chars) is forbidden.\n-* It is generally impossible to represent a decimal value exactly as binary floating-point number (`float` and `double` types). We seek the nearest value. We round to an even mantissa when we are in-between two binary floating-point numbers. \n+* It is generally impossible to represent a decimal value exactly as binary floating-point number (`float` and `double` types). We seek the nearest value. We round to an even mantissa when we are in-between two binary floating-point numbers.\n \n Furthermore, we have the following restrictions:\n * We only support `float` and `double` types at this time.\n@@ -77,22 +70,22 @@ Furthermore, we have the following restrictions:\n \n We support Visual Studio, macOS, Linux, freeBSD. We support big and little endian. We support 32-bit and 64-bit systems.\n \n-\n+We assume that the rounding mode is set to nearest (`std::fegetround() == FE_TONEAREST`).\n \n ## Using commas as decimal separator\n \n \n The C++ standard stipulate that `from_chars` has to be locale-independent. In\n-particular, the decimal separator has to be the period (`.`). However, \n-some users still want to use the `fast_float` library with in a locale-dependent \n+particular, the decimal separator has to be the period (`.`). However,\n+some users still want to use the `fast_float` library with in a locale-dependent\n manner. Using a separate function called `from_chars_advanced`, we allow the users\n-to pass a `parse_options` instance which contains a custom decimal separator (e.g., \n+to pass a `parse_options` instance which contains a custom decimal separator (e.g.,\n the comma). You may use it as follows.\n \n ```C++\n #include \"fast_float/fast_float.h\"\n #include <iostream>\n- \n+\n int main() {\n     const std::string input =  \"3,1416 xyz \";\n     double result;\n@@ -104,25 +97,55 @@ int main() {\n }\n ```\n \n+You can parse delimited numbers:\n+```C++\n+  const std::string input =   \"234532.3426362,7869234.9823,324562.645\";\n+  double result;\n+  auto answer = fast_float::from_chars(input.data(), input.data()+input.size(), result);\n+  if(answer.ec != std::errc()) {\n+    // check error\n+  }\n+  // we have result == 234532.3426362.\n+  if(answer.ptr[0] != ',') {\n+    // unexpected delimiter\n+  }\n+  answer = fast_float::from_chars(answer.ptr + 1, input.data()+input.size(), result);\n+  if(answer.ec != std::errc()) {\n+    // check error\n+  }\n+  // we have result == 7869234.9823.\n+  if(answer.ptr[0] != ',') {\n+    // unexpected delimiter\n+  }\n+  answer = fast_float::from_chars(answer.ptr + 1, input.data()+input.size(), result);\n+  if(answer.ec != std::errc()) {\n+    // check error\n+  }\n+  // we have result == 324562.645.\n+```\n \n ## Reference\n \n-- Daniel Lemire, [Number Parsing at a Gigabyte per Second](https://arxiv.org/abs/2101.11408), Software: Pratice and Experience 51 (8), 2021.\n+- Daniel Lemire, [Number Parsing at a Gigabyte per Second](https://arxiv.org/abs/2101.11408), Software: Practice and Experience 51 (8), 2021.\n \n ## Other programming languages\n \n - [There is an R binding](https://github.com/eddelbuettel/rcppfastfloat) called `rcppfastfloat`.\n - [There is a Rust port of the fast_float library](https://github.com/aldanor/fast-float-rust/) called `fast-float-rust`.\n-- [There is a Java port of the fast_float library](https://github.com/wrandelshofer/FastDoubleParser) called `FastDoubleParser`.\n+- [There is a Java port of the fast_float library](https://github.com/wrandelshofer/FastDoubleParser) called `FastDoubleParser`. It used for important systems such as [Jackson](https://github.com/FasterXML/jackson-core).\n - [There is a C# port of the fast_float library](https://github.com/CarlVerret/csFastFloat) called `csFastFloat`.\n \n \n ## Relation With Other Work\n \n-The fastfloat algorithm is part of the [LLVM standard libraries](https://github.com/llvm/llvm-project/commit/87c016078ad72c46505461e4ff8bfa04819fe7ba). \n+The fast_float library is part of GCC (as of version 12): the `from_chars` function in GCC relies on fast_float.\n+\n+The fastfloat algorithm is part of the [LLVM standard libraries](https://github.com/llvm/llvm-project/commit/87c016078ad72c46505461e4ff8bfa04819fe7ba).\n \n The fast_float library provides a performance similar to that of the [fast_double_parser](https://github.com/lemire/fast_double_parser) library but using an updated algorithm reworked from the ground up, and while offering an API more in line with the expectations of C++ programmers. The fast_double_parser library is part of the [Microsoft LightGBM machine-learning framework](https://github.com/microsoft/LightGBM).\n \n+There is a [derived implementation part of AdaCore](https://github.com/AdaCore/VSS).\n+\n ## Users\n \n The fast_float library is used by [Apache Arrow](https://github.com/apache/arrow/pull/8494) where it multiplied the number parsing speed by two or three times. It is also used by [Yandex ClickHouse](https://github.com/ClickHouse/ClickHouse) and by [Google Jsonnet](https://github.com/google/jsonnet).\n@@ -135,14 +158,14 @@ It can parse random floating-point numbers at a speed of 1 GB/s on some systems.\n <img src=\"http://lemire.me/blog/wp-content/uploads/2020/11/fastfloat_speed.png\" width=\"400\">\n \n ```\n-$ ./build/benchmarks/benchmark \n+$ ./build/benchmarks/benchmark\n # parsing random integers in the range [0,1)\n-volume = 2.09808 MB \n-netlib                                  :   271.18 MB/s (+/- 1.2 %)    12.93 Mfloat/s  \n-doubleconversion                        :   225.35 MB/s (+/- 1.2 %)    10.74 Mfloat/s  \n-strtod                                  :   190.94 MB/s (+/- 1.6 %)     9.10 Mfloat/s  \n-abseil                                  :   430.45 MB/s (+/- 2.2 %)    20.52 Mfloat/s  \n-fastfloat                               :  1042.38 MB/s (+/- 9.9 %)    49.68 Mfloat/s  \n+volume = 2.09808 MB\n+netlib                                  :   271.18 MB/s (+/- 1.2 %)    12.93 Mfloat/s \n+doubleconversion                        :   225.35 MB/s (+/- 1.2 %)    10.74 Mfloat/s \n+strtod                                  :   190.94 MB/s (+/- 1.6 %)     9.10 Mfloat/s \n+abseil                                  :   430.45 MB/s (+/- 2.2 %)    20.52 Mfloat/s \n+fastfloat                               :  1042.38 MB/s (+/- 9.9 %)    49.68 Mfloat/s \n ```\n \n See https://github.com/lemire/simple_fastfloat_benchmark for our benchmarking code.\n@@ -183,23 +206,23 @@ You should change the `GIT_TAG` line so that you recover the version you wish to\n \n ## Using as single header\n \n-The script `script/amalgamate.py` may be used to generate a single header \n+The script `script/amalgamate.py` may be used to generate a single header\n version of the library if so desired.\n-Just run the script from the root directory of this repository. \n+Just run the script from the root directory of this repository.\n You can customize the license type and output file if desired as described in\n the command line help.\n \n You may directly download automatically generated single-header files:\n \n-https://github.com/fastfloat/fast_float/releases/download/v1.1.2/fast_float.h\n+https://github.com/fastfloat/fast_float/releases/download/v3.4.0/fast_float.h\n \n ## Credit\n \n-Though this work is inspired by many different people, this work benefited especially from exchanges with \n-Michael Eisel, who motivated the original research with his key insights, and with Nigel Tao who provided \n+Though this work is inspired by many different people, this work benefited especially from exchanges with\n+Michael Eisel, who motivated the original research with his key insights, and with Nigel Tao who provided\n invaluable feedback. R\u00e9my Oudompheng first implemented a fast path we use in the case of long digits.\n \n-The library includes code adapted from Google Wuffs (written by Nigel Tao) which was originally published \n+The library includes code adapted from Google Wuffs (written by Nigel Tao) which was originally published\n under the Apache 2.0 license.\n \n ## License"}, {"sha": "5da55e2fe0ad4d92b2bf0384379bee2f03136ba6", "filename": "libstdc++-v3/src/c++17/fast_float/fast_float.h", "status": "modified", "additions": 111, "deletions": 62, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2Ffast_float.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2Ffast_float.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2Ffast_float.h?ref=cb0ceeaee9e041aaac3edd089b07b439621d0f29", "patch": "@@ -74,7 +74,7 @@ struct parse_options {\n  * Like the C++17 standard, the `fast_float::from_chars` functions take an optional last argument of\n  * the type `fast_float::chars_format`. It is a bitset value: we check whether\n  * `fmt & fast_float::chars_format::fixed` and `fmt & fast_float::chars_format::scientific` are set\n- * to determine whether we allowe the fixed point and scientific notation respectively.\n+ * to determine whether we allow the fixed point and scientific notation respectively.\n  * The default is  `fast_float::chars_format::general` which allows both `fixed` and `scientific`.\n  */\n template<typename T>\n@@ -98,12 +98,11 @@ from_chars_result from_chars_advanced(const char *first, const char *last,\n        || defined(__amd64) || defined(__aarch64__) || defined(_M_ARM64) \\\n        || defined(__MINGW64__)                                          \\\n        || defined(__s390x__)                                            \\\n-       || (defined(__ppc64__) || defined(__PPC64__) || defined(__ppc64le__) || defined(__PPC64LE__)) \\\n-       || defined(__EMSCRIPTEN__))\n+       || (defined(__ppc64__) || defined(__PPC64__) || defined(__ppc64le__) || defined(__PPC64LE__)) )\n #define FASTFLOAT_64BIT\n #elif (defined(__i386) || defined(__i386__) || defined(_M_IX86)   \\\n      || defined(__arm__) || defined(_M_ARM)                   \\\n-     || defined(__MINGW32__))\n+     || defined(__MINGW32__) || defined(__EMSCRIPTEN__))\n #define FASTFLOAT_32BIT\n #else\n   // Need to check incrementally, since SIZE_MAX is a size_t, avoid overflow.\n@@ -128,7 +127,7 @@ from_chars_result from_chars_advanced(const char *first, const char *last,\n #define FASTFLOAT_VISUAL_STUDIO 1\n #endif\n \n-#ifdef __BYTE_ORDER__\n+#if defined __BYTE_ORDER__ && defined __ORDER_BIG_ENDIAN__\n #define FASTFLOAT_IS_BIG_ENDIAN (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n #elif defined _WIN32\n #define FASTFLOAT_IS_BIG_ENDIAN 0\n@@ -271,8 +270,9 @@ fastfloat_really_inline uint64_t _umul128(uint64_t ab, uint64_t cd,\n fastfloat_really_inline value128 full_multiplication(uint64_t a,\n                                                      uint64_t b) {\n   value128 answer;\n-#ifdef _M_ARM64\n+#if defined(_M_ARM64) && !defined(__MINGW32__)\n   // ARM64 has native support for 64-bit multiplications, no need to emulate\n+  // But MinGW on ARM64 doesn't have native support for 64-bit multiplications\n   answer.high = __umulh(a, b);\n   answer.low = a * b;\n #elif defined(FASTFLOAT_32BIT) || (defined(_WIN64) && !defined(__clang__))\n@@ -307,21 +307,69 @@ constexpr static double powers_of_ten_double[] = {\n     1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22};\n constexpr static float powers_of_ten_float[] = {1e0, 1e1, 1e2, 1e3, 1e4, 1e5,\n                                                 1e6, 1e7, 1e8, 1e9, 1e10};\n+// used for max_mantissa_double and max_mantissa_float\n+constexpr uint64_t constant_55555 = 5 * 5 * 5 * 5 * 5;\n+// Largest integer value v so that (5**index * v) <= 1<<53.\n+// 0x10000000000000 == 1 << 53\n+constexpr static uint64_t max_mantissa_double[] = {\n+      0x10000000000000,\n+      0x10000000000000 / 5,\n+      0x10000000000000 / (5 * 5),\n+      0x10000000000000 / (5 * 5 * 5),\n+      0x10000000000000 / (5 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555),\n+      0x10000000000000 / (constant_55555 * 5),\n+      0x10000000000000 / (constant_55555 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * 5 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555),\n+      0x10000000000000 / (constant_55555 * constant_55555 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * 5 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * constant_55555),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * constant_55555 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * constant_55555 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * constant_55555 * 5 * 5 * 5),\n+      0x10000000000000 / (constant_55555 * constant_55555 * constant_55555 * constant_55555 * 5 * 5 * 5 * 5)};\n+  // Largest integer value v so that (5**index * v) <= 1<<24.\n+  // 0x1000000 == 1<<24\n+  constexpr static uint64_t max_mantissa_float[] = {\n+      0x1000000,\n+      0x1000000 / 5,\n+      0x1000000 / (5 * 5),\n+      0x1000000 / (5 * 5 * 5),\n+      0x1000000 / (5 * 5 * 5 * 5),\n+      0x1000000 / (constant_55555),\n+      0x1000000 / (constant_55555 * 5),\n+      0x1000000 / (constant_55555 * 5 * 5),\n+      0x1000000 / (constant_55555 * 5 * 5 * 5),\n+      0x1000000 / (constant_55555 * 5 * 5 * 5 * 5),\n+      0x1000000 / (constant_55555 * constant_55555),\n+      0x1000000 / (constant_55555 * constant_55555 * 5)};\n \n template <typename T> struct binary_format {\n+  using equiv_uint = typename std::conditional<sizeof(T) == 4, uint32_t, uint64_t>::type;\n+\n   static inline constexpr int mantissa_explicit_bits();\n   static inline constexpr int minimum_exponent();\n   static inline constexpr int infinite_power();\n   static inline constexpr int sign_index();\n-  static inline constexpr int min_exponent_fast_path();\n   static inline constexpr int max_exponent_fast_path();\n   static inline constexpr int max_exponent_round_to_even();\n   static inline constexpr int min_exponent_round_to_even();\n-  static inline constexpr uint64_t max_mantissa_fast_path();\n+  static inline constexpr uint64_t max_mantissa_fast_path(int64_t power);\n   static inline constexpr int largest_power_of_ten();\n   static inline constexpr int smallest_power_of_ten();\n   static inline constexpr T exact_power_of_ten(int64_t power);\n   static inline constexpr size_t max_digits();\n+  static inline constexpr equiv_uint exponent_mask();\n+  static inline constexpr equiv_uint mantissa_mask();\n+  static inline constexpr equiv_uint hidden_bit_mask();\n };\n \n template <> inline constexpr int binary_format<double>::mantissa_explicit_bits() {\n@@ -364,33 +412,24 @@ template <> inline constexpr int binary_format<float>::infinite_power() {\n template <> inline constexpr int binary_format<double>::sign_index() { return 63; }\n template <> inline constexpr int binary_format<float>::sign_index() { return 31; }\n \n-template <> inline constexpr int binary_format<double>::min_exponent_fast_path() {\n-#if (FLT_EVAL_METHOD != 1) && (FLT_EVAL_METHOD != 0)\n-  return 0;\n-#else\n-  return -22;\n-#endif\n-}\n-template <> inline constexpr int binary_format<float>::min_exponent_fast_path() {\n-#if (FLT_EVAL_METHOD != 1) && (FLT_EVAL_METHOD != 0)\n-  return 0;\n-#else\n-  return -10;\n-#endif\n-}\n-\n template <> inline constexpr int binary_format<double>::max_exponent_fast_path() {\n   return 22;\n }\n template <> inline constexpr int binary_format<float>::max_exponent_fast_path() {\n   return 10;\n }\n \n-template <> inline constexpr uint64_t binary_format<double>::max_mantissa_fast_path() {\n-  return uint64_t(2) << mantissa_explicit_bits();\n+template <> inline constexpr uint64_t binary_format<double>::max_mantissa_fast_path(int64_t power) {\n+  // caller is responsible to ensure that\n+  // power >= 0 && power <= 22\n+  //\n+  return max_mantissa_double[power];\n }\n-template <> inline constexpr uint64_t binary_format<float>::max_mantissa_fast_path() {\n-  return uint64_t(2) << mantissa_explicit_bits();\n+template <> inline constexpr uint64_t binary_format<float>::max_mantissa_fast_path(int64_t power) {\n+  // caller is responsible to ensure that\n+  // power >= 0 && power <= 10\n+  //\n+  return max_mantissa_float[power];\n }\n \n template <>\n@@ -429,6 +468,33 @@ template <> inline constexpr size_t binary_format<float>::max_digits() {\n   return 114;\n }\n \n+template <> inline constexpr binary_format<float>::equiv_uint\n+    binary_format<float>::exponent_mask() {\n+  return 0x7F800000;\n+}\n+template <> inline constexpr binary_format<double>::equiv_uint\n+    binary_format<double>::exponent_mask() {\n+  return 0x7FF0000000000000;\n+}\n+\n+template <> inline constexpr binary_format<float>::equiv_uint\n+    binary_format<float>::mantissa_mask() {\n+  return 0x007FFFFF;\n+}\n+template <> inline constexpr binary_format<double>::equiv_uint\n+    binary_format<double>::mantissa_mask() {\n+  return 0x000FFFFFFFFFFFFF;\n+}\n+\n+template <> inline constexpr binary_format<float>::equiv_uint\n+    binary_format<float>::hidden_bit_mask() {\n+  return 0x00800000;\n+}\n+template <> inline constexpr binary_format<double>::equiv_uint\n+    binary_format<double>::hidden_bit_mask() {\n+  return 0x0010000000000000;\n+}\n+\n template<typename T>\n fastfloat_really_inline void to_float(bool negative, adjusted_mantissa am, T &value) {\n   uint64_t word = am.mantissa;\n@@ -2410,40 +2476,24 @@ fastfloat_really_inline int32_t scientific_exponent(parsed_number_string& num) n\n // this converts a native floating-point number to an extended-precision float.\n template <typename T>\n fastfloat_really_inline adjusted_mantissa to_extended(T value) noexcept {\n+  using equiv_uint = typename binary_format<T>::equiv_uint;\n+  constexpr equiv_uint exponent_mask = binary_format<T>::exponent_mask();\n+  constexpr equiv_uint mantissa_mask = binary_format<T>::mantissa_mask();\n+  constexpr equiv_uint hidden_bit_mask = binary_format<T>::hidden_bit_mask();\n+\n   adjusted_mantissa am;\n   int32_t bias = binary_format<T>::mantissa_explicit_bits() - binary_format<T>::minimum_exponent();\n-  if (std::is_same<T, float>::value) {\n-    constexpr uint32_t exponent_mask = 0x7F800000;\n-    constexpr uint32_t mantissa_mask = 0x007FFFFF;\n-    constexpr uint64_t hidden_bit_mask = 0x00800000;\n-    uint32_t bits;\n-    ::memcpy(&bits, &value, sizeof(T));\n-    if ((bits & exponent_mask) == 0) {\n-      // denormal\n-      am.power2 = 1 - bias;\n-      am.mantissa = bits & mantissa_mask;\n-    } else {\n-      // normal\n-      am.power2 = int32_t((bits & exponent_mask) >> binary_format<T>::mantissa_explicit_bits());\n-      am.power2 -= bias;\n-      am.mantissa = (bits & mantissa_mask) | hidden_bit_mask;\n-    }\n+  equiv_uint bits;\n+  ::memcpy(&bits, &value, sizeof(T));\n+  if ((bits & exponent_mask) == 0) {\n+    // denormal\n+    am.power2 = 1 - bias;\n+    am.mantissa = bits & mantissa_mask;\n   } else {\n-    constexpr uint64_t exponent_mask = 0x7FF0000000000000;\n-    constexpr uint64_t mantissa_mask = 0x000FFFFFFFFFFFFF;\n-    constexpr uint64_t hidden_bit_mask = 0x0010000000000000;\n-    uint64_t bits;\n-    ::memcpy(&bits, &value, sizeof(T));\n-    if ((bits & exponent_mask) == 0) {\n-      // denormal\n-      am.power2 = 1 - bias;\n-      am.mantissa = bits & mantissa_mask;\n-    } else {\n-      // normal\n-      am.power2 = int32_t((bits & exponent_mask) >> binary_format<T>::mantissa_explicit_bits());\n-      am.power2 -= bias;\n-      am.mantissa = (bits & mantissa_mask) | hidden_bit_mask;\n-    }\n+    // normal\n+    am.power2 = int32_t((bits & exponent_mask) >> binary_format<T>::mantissa_explicit_bits());\n+    am.power2 -= bias;\n+    am.mantissa = (bits & mantissa_mask) | hidden_bit_mask;\n   }\n \n   return am;\n@@ -2869,11 +2919,10 @@ from_chars_result from_chars_advanced(const char *first, const char *last,\n   }\n   answer.ec = std::errc(); // be optimistic\n   answer.ptr = pns.lastmatch;\n-  // Next is Clinger's fast path.\n-  if (binary_format<T>::min_exponent_fast_path() <= pns.exponent && pns.exponent <= binary_format<T>::max_exponent_fast_path() && pns.mantissa <=binary_format<T>::max_mantissa_fast_path() && !pns.too_many_digits) {\n+  // Next is a modified Clinger's fast path, inspired by Jakub Jel\u00ednek's proposal\n+  if (pns.exponent >= 0 && pns.exponent <= binary_format<T>::max_exponent_fast_path() && pns.mantissa <=binary_format<T>::max_mantissa_fast_path(pns.exponent) && !pns.too_many_digits) {\n     value = T(pns.mantissa);\n-    if (pns.exponent < 0) { value = value / binary_format<T>::exact_power_of_ten(-pns.exponent); }\n-    else { value = value * binary_format<T>::exact_power_of_ten(pns.exponent); }\n+    value = value * binary_format<T>::exact_power_of_ten(pns.exponent);\n     if (pns.negative) { value = -value; }\n     return answer;\n   }"}, {"sha": "95bf669c945ba036e448f744e11a4229a8b31344", "filename": "libstdc++-v3/testsuite/20_util/from_chars/pr107468.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2Fpr107468.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ceeaee9e041aaac3edd089b07b439621d0f29/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2Fpr107468.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2Fpr107468.cc?ref=cb0ceeaee9e041aaac3edd089b07b439621d0f29", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++17 } }\n+// { dg-add-options ieee }\n+\n+#include <charconv>\n+#include <string>\n+#include <cfenv>\n+#include <testsuite_hooks.h>\n+\n+int\n+main()\n+{\n+  // FP from_char not available otherwise.\n+#if __cpp_lib_to_chars >= 201611L \\\n+    && _GLIBCXX_USE_C99_FENV_TR1 \\\n+    && defined(FE_DOWNWARD) \\\n+    && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  // PR libstdc++/107468\n+  float f;\n+  char buf[] = \"3.355447e+07\";\n+  std::fesetround(FE_DOWNWARD);\n+  auto [ptr, ec] = std::from_chars(buf, buf + sizeof(buf) - 1, f, std::chars_format::scientific);\n+  VERIFY( ec == std::errc() && ptr == buf + sizeof(buf) - 1 );\n+  VERIFY( f == 33554472.0f );\n+#endif\n+}"}]}