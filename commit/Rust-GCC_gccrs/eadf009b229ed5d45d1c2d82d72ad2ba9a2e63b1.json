{"sha": "eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkZjAwOWIyMjllZDVkNDVkMWMyZDgyZDcyYWQyYmE5YTJlNjNiMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-03-31T18:34:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-03-31T18:45:56Z"}, "message": "improve future::poll calibration loop\n\nThe calibration loop I've recently added to the libstdc++\nfuture/members/poll.cc tests could still select iteration counts that\nmight yield zero-time measurements for the wait_for when ready loop.\n\nWaiting for a future that has already had a value set is presumably\nuniformly faster than a zero-timed wait for a result, so I've changed\nthe calibration loop to use the former.\n\nWe might still be unlucky and get nonzero from the initial loop, so\nthat the calibration is skipped altogether, but then get zero from the\nlater when-ready loop.  I'm not dealing with this case in this patch.\n\n\nfor  libstdc++-v3/ChangeLog\n\n\t* testsuite/30_threads/future/members/poll.cc: Use faster\n\tafter-ready call in the calibration loop.", "tree": {"sha": "bf3c9b6fdc0982826faea209160172e08e936e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf3c9b6fdc0982826faea209160172e08e936e86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1/comments", "author": null, "committer": null, "parents": [{"sha": "c778968339afd140380a46edbade054667c7dce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c778968339afd140380a46edbade054667c7dce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c778968339afd140380a46edbade054667c7dce2"}], "stats": {"total": 8, "additions": 7, "deletions": 1}, "files": [{"sha": "4c846d0b7baf5cec7b51f3c35501637488254a8c", "filename": "libstdc++-v3/testsuite/30_threads/future/members/poll.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc?ref=eadf009b229ed5d45d1c2d82d72ad2ba9a2e63b1", "patch": "@@ -55,6 +55,12 @@ int main()\n      Attempt to calibrate it.  */\n   if (start == stop)\n     {\n+      /* After set_value, wait_for is faster, so use that for the\n+\t calibration to avoid zero at low clock resultions.  */\n+      promise<int> pc;\n+      future<int> fc = pc.get_future();\n+      pc.set_value(1);\n+\n       /* Loop until the clock advances, so that start is right after a\n \t time increment.  */\n       do\n@@ -65,7 +71,7 @@ int main()\n \t after another time increment.  */\n       do\n \t{\n-\t  f.wait_for(chrono::seconds(0));\n+\t  fc.wait_for(chrono::seconds(0));\n \t  stop = chrono::high_resolution_clock::now();\n \t  i++;\n \t}"}]}