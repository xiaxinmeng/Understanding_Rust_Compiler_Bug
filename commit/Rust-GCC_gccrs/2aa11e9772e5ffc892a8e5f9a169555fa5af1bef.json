{"sha": "2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFhMTFlOTc3MmU1ZmZjODkyYThlNWY5YTE2OTU1NWZhNWFmMWJlZg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-03-12T18:19:04Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-03-12T18:19:04Z"}, "message": "parse.y (java_stabilize_reference): Return NODE when patching a COMPOUND_EXPR.\n\n1999-03-12  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (java_stabilize_reference): Return NODE when patching a\n\tCOMPOUND_EXPR.\n\t(java_complete_lhs): Put parenthesis around truth values.\n1999-03-12  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (layout_class_method): Don't make rtl for interface\n\tmethods.\n\t* parse.h (GET_TYPE_NAME): New macro.\n\t* parse.y (if_then_statement:): Fixed indentation.\n\t(if_then_else_statement:): Likewise.\n\t(for_statement:): Fixed spacing.\n\t(try_statement:): Fixed indentation.\n\t(create_interface): Don't force interfaces to be abstract.\n\t(method_header): Abstract methods are OK in interfaces.\n\t(declare_local_variables): Fixed typo in comment.\n\t(java_complete_expand_method): Fixed indentation.\n\t(resolve_qualified_expression_name): Use GET_TYPE_NAME to report\n\tnon accessible fields.\n\t(java_stabilize_reference): New function.\n\t(java_complete_lhs): Fixed indentation. Use\n\tjava_stabilize_reference in compound assignement. Insert the\n\tcast. If not processing `+' fix string constants before processing\n\tbinop.\n\nFrom-SVN: r25733", "tree": {"sha": "829080f77242a542fa4b3ead2a4d30e264856c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/829080f77242a542fa4b3ead2a4d30e264856c16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/comments", "author": null, "committer": null, "parents": [{"sha": "8084bf81c782ec5d2831db7fa576089ccb0c5d49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8084bf81c782ec5d2831db7fa576089ccb0c5d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8084bf81c782ec5d2831db7fa576089ccb0c5d49"}], "stats": {"total": 717, "additions": 417, "deletions": 300}, "files": [{"sha": "d39c4b870caabee914d81505798b3b415d75dfc8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "patch": "@@ -1,3 +1,30 @@\n+1999-03-12  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (java_stabilize_reference): Return NODE when patching a\n+\tCOMPOUND_EXPR.\n+\t(java_complete_lhs): Put parenthesis around truth values.\n+\n+1999-03-12  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (layout_class_method): Don't make rtl for interface\n+\tmethods.\n+\t* parse.h (GET_TYPE_NAME): New macro.\n+\t* parse.y (if_then_statement:): Fixed indentation.\n+\t(if_then_else_statement:): Likewise.\n+\t(for_statement:): Fixed spacing.\n+\t(try_statement:): Fixed indentation.\n+\t(create_interface): Don't force interfaces to be abstract.\n+\t(method_header): Abstract methods are OK in interfaces.\n+\t(declare_local_variables): Fixed typo in comment.\n+\t(java_complete_expand_method): Fixed indentation.\n+\t(resolve_qualified_expression_name): Use GET_TYPE_NAME to report\n+\tnon accessible fields.\n+\t(java_stabilize_reference): New function.\n+\t(java_complete_lhs): Fixed indentation. Use\n+\tjava_stabilize_reference in compound assignement. Insert the\n+\tcast. If not processing `+' fix string constants before processing\n+\tbinop.\n+\n Fri Mar 12 19:42:55 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* constants.c (find_class_or_string_constant): Cast variable `j'\n@@ -37,6 +64,11 @@ Wed Mar 10 23:20:11 1999  Per Bothner  <bothner@cygnus.com>\n \n \t* jcf-write.c (generate_bytecode_insns):  Handle __builtin_fmod, for %.\n \n+  Tue Mar  9 11:52:08 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+  \n+ \t* parse.y (method_header): Don't set ACC_ABSTRACT flags on\n+  \tinterfaces.\n+  \n Fri Mar  5 15:17:29 1999  Per Bothner  <bothner@cygnus.com>\n \n \t* lex.c (java_parse_end_comment):  Take extra parameter (next char).\n@@ -54,7 +86,7 @@ Fri Mar  5 15:17:29 1999  Per Bothner  <bothner@cygnus.com>\n \t* parse.y (find_expr_with_wfl):  Optimize tail-calls.\n \t(build_array_from_name):  Re-order &index[string] to &string[index].\n \n-\t* parse.y (java_complete_tree):  Don't call patch_assignment if rhs is\n+\t* parse.y (java_complete_lhs):  Don't call patch_assignment if rhs is\n \terror_mark (it might catch more errors, but it is more likely to lose).\n \n Sat Mar  6 11:17:16 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>"}, {"sha": "f05cf16099c06d0a490ae2014b4cb19875114167", "filename": "gcc/java/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "patch": "@@ -1604,7 +1604,8 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n   obstack_1grow (&temporary_obstack, '\\0');\n   asm_name = obstack_finish (&temporary_obstack);\n   DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n-  if (! METHOD_ABSTRACT (method_decl))\n+  if (! METHOD_ABSTRACT (method_decl) \n+      && ! CLASS_INTERFACE (TYPE_NAME (this_class)))\n     make_function_rtl (method_decl);\n   obstack_free (&temporary_obstack, asm_name);\n   "}, {"sha": "30ecc5f95cfbb31007733ba5f860f6c2616a257f", "filename": "gcc/java/parse.c", "status": "modified", "additions": 308, "deletions": 266, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "patch": "@@ -5,6 +5,13 @@\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n+#define yyparse java_parse\n+#define yylex java_lex\n+#define yyerror java_error\n+#define yylval java_lval\n+#define yychar java_char\n+#define yydebug java_debug\n+#define yynerrs java_nerrs\n #define\tPLUS_TK\t258\n #define\tMINUS_TK\t259\n #define\tMULT_TK\t260\n@@ -687,32 +694,32 @@ static const short yyrline[] = { 0,\n   1205,  1206,  1207,  1208,  1209,  1210,  1211,  1212,  1213,  1214,\n   1217,  1222,  1233,  1240,  1244,  1255,  1265,  1271,  1277,  1283,\n   1285,  1291,  1293,  1299,  1301,  1303,  1305,  1307,  1311,  1313,\n-  1314,  1315,  1316,  1317,  1318,  1321,  1324,  1326,  1328,  1332,\n-  1337,  1342,  1348,  1358,  1364,  1366,  1368,  1375,  1378,  1380,\n-  1382,  1386,  1388,  1391,  1395,  1397,  1400,  1407,  1413,  1415,\n-  1417,  1421,  1429,  1432,  1434,  1436,  1440,  1445,  1454,  1459,\n-  1462,  1469,  1471,  1473,  1477,  1480,  1489,  1496,  1498,  1502,\n-  1515,  1517,  1523,  1529,  1533,  1535,  1539,  1542,  1544,  1548,\n-  1551,  1553,  1555,  1559,  1562,  1564,  1566,  1570,  1573,  1575,\n-  1577,  1581,  1587,  1589,  1593,  1600,  1602,  1604,  1606,  1610,\n-  1618,  1621,  1623,  1628,  1632,  1634,  1641,  1649,  1666,  1668,\n-  1670,  1674,  1677,  1682,  1684,  1687,  1689,  1691,  1693,  1694,\n-  1695,  1696,  1700,  1702,  1704,  1709,  1711,  1713,  1715,  1717,\n-  1721,  1724,  1729,  1731,  1736,  1737,  1738,  1739,  1740,  1742,\n-  1744,  1746,  1748,  1750,  1754,  1756,  1759,  1765,  1770,  1774,\n-  1777,  1779,  1781,  1785,  1787,  1789,  1791,  1795,  1798,  1802,\n-  1808,  1810,  1818,  1845,  1847,  1851,  1856,  1864,  1868,  1871,\n-  1873,  1884,  1895,  1900,  1909,  1911,  1915,  1918,  1920,  1925,\n-  1930,  1935,  1942,  1944,  1945,  1946,  1949,  1954,  1959,  1961,\n-  1962,  1964,  1966,  1967,  1969,  1973,  1976,  1980,  1983,  1987,\n-  1989,  1991,  1993,  1994,  1996,  2000,  2009,  2011,  2013,  2026,\n-  2028,  2034,  2036,  2038,  2042,  2044,  2049,  2054,  2059,  2061,\n-  2063,  2067,  2069,  2074,  2079,  2081,  2085,  2087,  2092,  2097,\n-  2102,  2104,  2106,  2110,  2112,  2117,  2122,  2127,  2132,  2134,\n-  2136,  2138,  2140,  2142,  2146,  2148,  2153,  2158,  2160,  2164,\n-  2166,  2171,  2175,  2177,  2182,  2186,  2188,  2193,  2197,  2199,\n-  2204,  2208,  2210,  2215,  2219,  2221,  2226,  2232,  2234,  2238,\n-  2240,  2243,  2246,  2254,  2256,  2257,  2260,  2262,  2265,  2269\n+  1314,  1315,  1316,  1317,  1318,  1321,  1327,  1329,  1331,  1335,\n+  1340,  1345,  1351,  1361,  1367,  1369,  1371,  1378,  1381,  1383,\n+  1385,  1389,  1391,  1394,  1398,  1400,  1403,  1410,  1416,  1418,\n+  1420,  1424,  1432,  1435,  1437,  1439,  1443,  1448,  1457,  1462,\n+  1465,  1472,  1474,  1476,  1480,  1483,  1492,  1499,  1501,  1505,\n+  1518,  1520,  1526,  1532,  1536,  1538,  1542,  1545,  1547,  1551,\n+  1554,  1556,  1558,  1562,  1565,  1567,  1569,  1573,  1576,  1578,\n+  1580,  1584,  1590,  1592,  1596,  1603,  1605,  1607,  1609,  1613,\n+  1621,  1624,  1626,  1631,  1635,  1637,  1644,  1652,  1669,  1671,\n+  1673,  1677,  1680,  1685,  1687,  1690,  1692,  1694,  1696,  1697,\n+  1698,  1699,  1703,  1705,  1707,  1712,  1714,  1716,  1718,  1720,\n+  1724,  1727,  1732,  1734,  1739,  1740,  1741,  1742,  1743,  1745,\n+  1747,  1749,  1751,  1753,  1757,  1759,  1762,  1768,  1773,  1777,\n+  1780,  1782,  1784,  1788,  1790,  1792,  1794,  1798,  1801,  1805,\n+  1811,  1813,  1821,  1848,  1850,  1854,  1859,  1867,  1871,  1874,\n+  1876,  1887,  1898,  1903,  1912,  1914,  1918,  1921,  1923,  1928,\n+  1933,  1938,  1945,  1947,  1948,  1949,  1952,  1957,  1962,  1964,\n+  1965,  1967,  1969,  1970,  1972,  1976,  1979,  1983,  1986,  1990,\n+  1992,  1994,  1996,  1997,  1999,  2003,  2012,  2014,  2016,  2029,\n+  2031,  2037,  2039,  2041,  2045,  2047,  2052,  2057,  2062,  2064,\n+  2066,  2070,  2072,  2077,  2082,  2084,  2088,  2090,  2095,  2100,\n+  2105,  2107,  2109,  2113,  2115,  2120,  2125,  2130,  2135,  2137,\n+  2139,  2141,  2143,  2145,  2149,  2151,  2156,  2161,  2163,  2167,\n+  2169,  2174,  2178,  2180,  2185,  2189,  2191,  2196,  2200,  2202,\n+  2207,  2211,  2213,  2218,  2222,  2224,  2229,  2235,  2237,  2241,\n+  2243,  2246,  2249,  2257,  2259,  2260,  2263,  2265,  2268,  2272\n };\n #endif\n \n@@ -2210,7 +2217,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/local/gnu/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2403,7 +2410,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/local/gnu/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -3581,36 +3588,39 @@ case 238:\n     break;}\n case 246:\n #line 1323 \"./parse.y\"\n-{ yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node, NULL_TREE); ;\n+{ \n+\t\t  yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, \n+\t\t\t\t\t\tyyvsp[0].node, NULL_TREE);\n+\t\t;\n     break;}\n case 247:\n-#line 1325 \"./parse.y\"\n+#line 1328 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 248:\n-#line 1327 \"./parse.y\"\n+#line 1330 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 249:\n-#line 1329 \"./parse.y\"\n+#line 1332 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 250:\n-#line 1334 \"./parse.y\"\n+#line 1337 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 251:\n-#line 1339 \"./parse.y\"\n+#line 1342 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 252:\n-#line 1344 \"./parse.y\"\n+#line 1347 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 253:\n-#line 1348 \"./parse.y\"\n+#line 1351 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own\n@@ -3621,112 +3631,112 @@ case 253:\n \t\t;\n     break;}\n case 254:\n-#line 1360 \"./parse.y\"\n+#line 1363 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 255:\n-#line 1365 \"./parse.y\"\n+#line 1368 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 256:\n-#line 1367 \"./parse.y\"\n+#line 1370 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 257:\n-#line 1369 \"./parse.y\"\n+#line 1372 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 258:\n-#line 1377 \"./parse.y\"\n+#line 1380 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 259:\n-#line 1379 \"./parse.y\"\n+#line 1382 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 260:\n-#line 1381 \"./parse.y\"\n+#line 1384 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 261:\n-#line 1383 \"./parse.y\"\n+#line 1386 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 267:\n-#line 1402 \"./parse.y\"\n+#line 1405 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 268:\n-#line 1408 \"./parse.y\"\n+#line 1411 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 269:\n-#line 1414 \"./parse.y\"\n+#line 1417 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 270:\n-#line 1416 \"./parse.y\"\n+#line 1419 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 271:\n-#line 1418 \"./parse.y\"\n+#line 1421 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 272:\n-#line 1423 \"./parse.y\"\n+#line 1426 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 273:\n-#line 1431 \"./parse.y\"\n+#line 1434 \"./parse.y\"\n { yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 274:\n-#line 1433 \"./parse.y\"\n+#line 1436 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 275:\n-#line 1435 \"./parse.y\"\n+#line 1438 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 276:\n-#line 1437 \"./parse.y\"\n+#line 1440 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 277:\n-#line 1442 \"./parse.y\"\n+#line 1445 \"./parse.y\"\n { yyval.node = complete_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 278:\n-#line 1447 \"./parse.y\"\n+#line 1450 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 279:\n-#line 1456 \"./parse.y\"\n+#line 1459 \"./parse.y\"\n { yyval.node = complete_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 280:\n-#line 1461 \"./parse.y\"\n-{ yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n+#line 1464 \"./parse.y\"\n+{ yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 281:\n-#line 1463 \"./parse.y\"\n+#line 1466 \"./parse.y\"\n { \n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3735,23 +3745,23 @@ case 281:\n \t\t;\n     break;}\n case 282:\n-#line 1470 \"./parse.y\"\n+#line 1473 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 283:\n-#line 1472 \"./parse.y\"\n+#line 1475 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 284:\n-#line 1474 \"./parse.y\"\n+#line 1477 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 285:\n-#line 1479 \"./parse.y\"\n+#line 1482 \"./parse.y\"\n { yyval.node = complete_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 286:\n-#line 1481 \"./parse.y\"\n+#line 1484 \"./parse.y\"\n { \n \t\t  yyval.node = complete_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3760,23 +3770,23 @@ case 286:\n \t\t;\n     break;}\n case 287:\n-#line 1491 \"./parse.y\"\n+#line 1494 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 288:\n-#line 1497 \"./parse.y\"\n+#line 1500 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 289:\n-#line 1499 \"./parse.y\"\n+#line 1502 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 290:\n-#line 1504 \"./parse.y\"\n+#line 1507 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -3789,179 +3799,179 @@ case 290:\n \t\t;\n     break;}\n case 291:\n-#line 1516 \"./parse.y\"\n+#line 1519 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 292:\n-#line 1518 \"./parse.y\"\n+#line 1521 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 293:\n-#line 1524 \"./parse.y\"\n+#line 1527 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 294:\n-#line 1530 \"./parse.y\"\n+#line 1533 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 295:\n-#line 1534 \"./parse.y\"\n+#line 1537 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 296:\n-#line 1536 \"./parse.y\"\n+#line 1539 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 297:\n-#line 1541 \"./parse.y\"\n+#line 1544 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 298:\n-#line 1543 \"./parse.y\"\n+#line 1546 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 299:\n-#line 1545 \"./parse.y\"\n+#line 1548 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 300:\n-#line 1550 \"./parse.y\"\n+#line 1553 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 301:\n-#line 1552 \"./parse.y\"\n+#line 1555 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 302:\n-#line 1554 \"./parse.y\"\n+#line 1557 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 303:\n-#line 1556 \"./parse.y\"\n+#line 1559 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 304:\n-#line 1561 \"./parse.y\"\n+#line 1564 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 305:\n-#line 1563 \"./parse.y\"\n+#line 1566 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 306:\n-#line 1565 \"./parse.y\"\n+#line 1568 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 307:\n-#line 1567 \"./parse.y\"\n+#line 1570 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 308:\n-#line 1572 \"./parse.y\"\n+#line 1575 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 309:\n-#line 1574 \"./parse.y\"\n+#line 1577 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 310:\n-#line 1576 \"./parse.y\"\n+#line 1579 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 311:\n-#line 1578 \"./parse.y\"\n+#line 1581 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 312:\n-#line 1583 \"./parse.y\"\n+#line 1586 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 313:\n-#line 1588 \"./parse.y\"\n+#line 1591 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 314:\n-#line 1590 \"./parse.y\"\n+#line 1593 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 315:\n-#line 1595 \"./parse.y\"\n+#line 1598 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 316:\n-#line 1601 \"./parse.y\"\n+#line 1604 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 317:\n-#line 1603 \"./parse.y\"\n+#line 1606 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 318:\n-#line 1605 \"./parse.y\"\n+#line 1608 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 319:\n-#line 1607 \"./parse.y\"\n+#line 1610 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 320:\n-#line 1612 \"./parse.y\"\n+#line 1615 \"./parse.y\"\n {\n \t\t  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)\n \t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << yyvsp[0].value));\n \t\t;\n     break;}\n case 321:\n-#line 1620 \"./parse.y\"\n+#line 1623 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 322:\n-#line 1622 \"./parse.y\"\n+#line 1625 \"./parse.y\"\n { yyval.node = build_try_finally_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 323:\n-#line 1624 \"./parse.y\"\n-{ yyval.node = build_try_finally_statement (yyvsp[-3].operator.location,\n-\t\t\t\t\t\t    build_try_statement (yyvsp[-3].operator.location,\n-\t\t\t\t\t\t\t\t\t yyvsp[-2].node, yyvsp[-1].node),\n-\t\t\t\t\t\t    yyvsp[0].node); ;\n+#line 1627 \"./parse.y\"\n+{ yyval.node = build_try_finally_statement \n+\t\t    (yyvsp[-3].operator.location, build_try_statement (yyvsp[-3].operator.location,\n+\t\t\t\t\t\t       yyvsp[-2].node, yyvsp[-1].node), yyvsp[0].node);\n+\t\t;\n     break;}\n case 324:\n-#line 1629 \"./parse.y\"\n+#line 1632 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 326:\n-#line 1635 \"./parse.y\"\n+#line 1638 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 327:\n-#line 1643 \"./parse.y\"\n+#line 1646 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 328:\n-#line 1651 \"./parse.y\"\n+#line 1654 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -3979,184 +3989,184 @@ case 328:\n \t\t;\n     break;}\n case 329:\n-#line 1667 \"./parse.y\"\n+#line 1670 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 330:\n-#line 1669 \"./parse.y\"\n+#line 1672 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 331:\n-#line 1671 \"./parse.y\"\n+#line 1674 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 332:\n-#line 1676 \"./parse.y\"\n+#line 1679 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 333:\n-#line 1678 \"./parse.y\"\n+#line 1681 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 337:\n-#line 1690 \"./parse.y\"\n+#line 1693 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 338:\n-#line 1692 \"./parse.y\"\n+#line 1695 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 343:\n-#line 1701 \"./parse.y\"\n+#line 1704 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 344:\n-#line 1703 \"./parse.y\"\n+#line 1706 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 345:\n-#line 1705 \"./parse.y\"\n+#line 1708 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 346:\n-#line 1710 \"./parse.y\"\n+#line 1713 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 347:\n-#line 1712 \"./parse.y\"\n+#line 1715 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 348:\n-#line 1714 \"./parse.y\"\n+#line 1717 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 349:\n-#line 1716 \"./parse.y\"\n+#line 1719 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1718 \"./parse.y\"\n+#line 1721 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1723 \"./parse.y\"\n+#line 1726 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 352:\n-#line 1725 \"./parse.y\"\n+#line 1728 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 353:\n-#line 1730 \"./parse.y\"\n+#line 1733 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 354:\n-#line 1732 \"./parse.y\"\n+#line 1735 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 359:\n-#line 1741 \"./parse.y\"\n+#line 1744 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 360:\n-#line 1743 \"./parse.y\"\n+#line 1746 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 361:\n-#line 1745 \"./parse.y\"\n+#line 1748 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 362:\n-#line 1747 \"./parse.y\"\n+#line 1750 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1749 \"./parse.y\"\n+#line 1752 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 364:\n-#line 1751 \"./parse.y\"\n+#line 1754 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 367:\n-#line 1761 \"./parse.y\"\n+#line 1764 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 368:\n-#line 1766 \"./parse.y\"\n+#line 1769 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 369:\n-#line 1771 \"./parse.y\"\n+#line 1774 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 370:\n-#line 1776 \"./parse.y\"\n+#line 1779 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 371:\n-#line 1778 \"./parse.y\"\n+#line 1781 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 372:\n-#line 1780 \"./parse.y\"\n+#line 1783 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 373:\n-#line 1782 \"./parse.y\"\n+#line 1785 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 374:\n-#line 1786 \"./parse.y\"\n+#line 1789 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 375:\n-#line 1788 \"./parse.y\"\n+#line 1791 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 376:\n-#line 1790 \"./parse.y\"\n+#line 1793 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 377:\n-#line 1792 \"./parse.y\"\n+#line 1795 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 378:\n-#line 1797 \"./parse.y\"\n+#line 1800 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 379:\n-#line 1799 \"./parse.y\"\n+#line 1802 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 380:\n-#line 1804 \"./parse.y\"\n+#line 1807 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 381:\n-#line 1809 \"./parse.y\"\n+#line 1812 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 382:\n-#line 1811 \"./parse.y\"\n+#line 1814 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 383:\n-#line 1820 \"./parse.y\"\n+#line 1823 \"./parse.y\"\n { \n \t\t  int allocate = 0;\n \t\t  /* If not initialized, allocate memory for the osb\n@@ -4184,19 +4194,19 @@ case 383:\n \t\t;\n     break;}\n case 384:\n-#line 1846 \"./parse.y\"\n+#line 1849 \"./parse.y\"\n { CURRENT_OSB (ctxp)++; ;\n     break;}\n case 385:\n-#line 1848 \"./parse.y\"\n+#line 1851 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 386:\n-#line 1853 \"./parse.y\"\n+#line 1856 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 387:\n-#line 1857 \"./parse.y\"\n+#line 1860 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node, \n@@ -4206,19 +4216,19 @@ case 387:\n \t\t;\n     break;}\n case 388:\n-#line 1865 \"./parse.y\"\n+#line 1868 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 389:\n-#line 1870 \"./parse.y\"\n+#line 1873 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 390:\n-#line 1872 \"./parse.y\"\n+#line 1875 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 391:\n-#line 1874 \"./parse.y\"\n+#line 1877 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4231,7 +4241,7 @@ case 391:\n \t\t;\n     break;}\n case 392:\n-#line 1885 \"./parse.y\"\n+#line 1888 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4244,121 +4254,121 @@ case 392:\n \t\t;\n     break;}\n case 393:\n-#line 1896 \"./parse.y\"\n+#line 1899 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 394:\n-#line 1901 \"./parse.y\"\n+#line 1904 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 395:\n-#line 1910 \"./parse.y\"\n+#line 1913 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 396:\n-#line 1912 \"./parse.y\"\n+#line 1915 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 397:\n-#line 1917 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 398:\n-#line 1919 \"./parse.y\"\n+#line 1922 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 399:\n-#line 1921 \"./parse.y\"\n+#line 1924 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 400:\n-#line 1926 \"./parse.y\"\n+#line 1929 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 401:\n-#line 1931 \"./parse.y\"\n+#line 1934 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 402:\n-#line 1936 \"./parse.y\"\n+#line 1939 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 407:\n-#line 1951 \"./parse.y\"\n+#line 1954 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 408:\n-#line 1956 \"./parse.y\"\n+#line 1959 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 411:\n-#line 1963 \"./parse.y\"\n+#line 1966 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 412:\n-#line 1965 \"./parse.y\"\n+#line 1968 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 414:\n-#line 1968 \"./parse.y\"\n+#line 1971 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 415:\n-#line 1970 \"./parse.y\"\n+#line 1973 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 416:\n-#line 1975 \"./parse.y\"\n+#line 1978 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 417:\n-#line 1977 \"./parse.y\"\n+#line 1980 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 418:\n-#line 1982 \"./parse.y\"\n+#line 1985 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 419:\n-#line 1984 \"./parse.y\"\n+#line 1987 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 421:\n-#line 1990 \"./parse.y\"\n+#line 1993 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 422:\n-#line 1992 \"./parse.y\"\n+#line 1995 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 1995 \"./parse.y\"\n+#line 1998 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 1997 \"./parse.y\"\n+#line 2000 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 426:\n-#line 2002 \"./parse.y\"\n+#line 2005 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4368,15 +4378,15 @@ case 426:\n \t\t;\n     break;}\n case 427:\n-#line 2010 \"./parse.y\"\n+#line 2013 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 428:\n-#line 2012 \"./parse.y\"\n+#line 2015 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 429:\n-#line 2014 \"./parse.y\"\n+#line 2017 \"./parse.y\"\n { \n \t\t  char *ptr;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4391,275 +4401,275 @@ case 429:\n \t\t;\n     break;}\n case 430:\n-#line 2027 \"./parse.y\"\n+#line 2030 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 431:\n-#line 2029 \"./parse.y\"\n+#line 2032 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 432:\n-#line 2035 \"./parse.y\"\n+#line 2038 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 433:\n-#line 2037 \"./parse.y\"\n+#line 2040 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 434:\n-#line 2039 \"./parse.y\"\n+#line 2042 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 436:\n-#line 2045 \"./parse.y\"\n+#line 2048 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 437:\n-#line 2050 \"./parse.y\"\n+#line 2053 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 438:\n-#line 2055 \"./parse.y\"\n+#line 2058 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 439:\n-#line 2060 \"./parse.y\"\n+#line 2063 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 440:\n-#line 2062 \"./parse.y\"\n+#line 2065 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 441:\n-#line 2064 \"./parse.y\"\n+#line 2067 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 2070 \"./parse.y\"\n+#line 2073 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 444:\n-#line 2075 \"./parse.y\"\n+#line 2078 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 445:\n-#line 2080 \"./parse.y\"\n+#line 2083 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 446:\n-#line 2082 \"./parse.y\"\n+#line 2085 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 448:\n-#line 2088 \"./parse.y\"\n+#line 2091 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 2093 \"./parse.y\"\n+#line 2096 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 450:\n-#line 2098 \"./parse.y\"\n+#line 2101 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 451:\n-#line 2103 \"./parse.y\"\n+#line 2106 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 452:\n-#line 2105 \"./parse.y\"\n+#line 2108 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 453:\n-#line 2107 \"./parse.y\"\n+#line 2110 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 455:\n-#line 2113 \"./parse.y\"\n+#line 2116 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 456:\n-#line 2118 \"./parse.y\"\n+#line 2121 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 457:\n-#line 2123 \"./parse.y\"\n+#line 2126 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 2128 \"./parse.y\"\n+#line 2131 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 2133 \"./parse.y\"\n+#line 2136 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 460:\n-#line 2135 \"./parse.y\"\n+#line 2138 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 461:\n-#line 2137 \"./parse.y\"\n+#line 2140 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 2139 \"./parse.y\"\n+#line 2142 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 2141 \"./parse.y\"\n+#line 2144 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 464:\n-#line 2143 \"./parse.y\"\n+#line 2146 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 466:\n-#line 2149 \"./parse.y\"\n+#line 2152 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 2154 \"./parse.y\"\n+#line 2157 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 468:\n-#line 2159 \"./parse.y\"\n+#line 2162 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 469:\n-#line 2161 \"./parse.y\"\n+#line 2164 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 2167 \"./parse.y\"\n+#line 2170 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 472:\n-#line 2172 \"./parse.y\"\n+#line 2175 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 474:\n-#line 2178 \"./parse.y\"\n+#line 2181 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 475:\n-#line 2183 \"./parse.y\"\n+#line 2186 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 477:\n-#line 2189 \"./parse.y\"\n+#line 2192 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 478:\n-#line 2194 \"./parse.y\"\n+#line 2197 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 480:\n-#line 2200 \"./parse.y\"\n+#line 2203 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 481:\n-#line 2205 \"./parse.y\"\n+#line 2208 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 483:\n-#line 2211 \"./parse.y\"\n+#line 2214 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 484:\n-#line 2216 \"./parse.y\"\n+#line 2219 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 486:\n-#line 2222 \"./parse.y\"\n+#line 2225 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 487:\n-#line 2227 \"./parse.y\"\n+#line 2230 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 488:\n-#line 2233 \"./parse.y\"\n+#line 2236 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 489:\n-#line 2235 \"./parse.y\"\n+#line 2238 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 492:\n-#line 2245 \"./parse.y\"\n+#line 2248 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 493:\n-#line 2247 \"./parse.y\"\n+#line 2250 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4668,7 +4678,7 @@ case 493:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/local/gnu/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -4864,7 +4874,7 @@ case 493:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2273 \"./parse.y\"\n+#line 2276 \"./parse.y\"\n \n \f\n \n@@ -5532,7 +5542,7 @@ create_interface (flags, id, super)\n   decl = maybe_create_class_interface_decl (decl, q_name, id);\n \n   /* Set super info and mark the class a complete */\n-  set_super_info (ACC_ABSTRACT | ACC_INTERFACE | flags, TREE_TYPE (decl), \n+  set_super_info (ACC_INTERFACE | flags, TREE_TYPE (decl), \n \t\t  object_type_node, ctxp->interface_number);\n   ctxp->interface_number = 0;\n   CLASS_COMPLETE_P (decl) = 1;\n@@ -5892,7 +5902,8 @@ method_header (flags, type, mdecl, throws)\n       ABSTRACT_CHECK (flags, ACC_FINAL, id, \"Final\");\n       ABSTRACT_CHECK (flags, ACC_NATIVE, id, \"Native\");\n       ABSTRACT_CHECK (flags, ACC_SYNCHRONIZED,id, \"Synchronized\");\n-      if (!CLASS_ABSTRACT (TYPE_NAME (this_class)))\n+      if (!CLASS_ABSTRACT (TYPE_NAME (this_class))\n+\t  && !CLASS_INTERFACE (TYPE_NAME (this_class)))\n \tparse_error_context \n \t  (id, \"Class `%s' must be declared abstract to define abstract \"\n \t   \"method `%s'\", \n@@ -7843,7 +7854,7 @@ declare_local_variables (modifier, type, vlist)\n   tree type_wfl = NULL_TREE;\n   int must_chain = 0;\n \n-  /* Push a new block if statement were seen between the last time we\n+  /* Push a new block if statements were seen between the last time we\n      pushed a block and now. Keep a cound of block to close */\n   if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (current_function_decl)))\n     {\n@@ -8989,7 +9000,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      parse_error_context \n \t\t(qual_wfl, \"Can't access %s field `%s.%s' from `%s'\",\n \t\t java_accstring_lookup (get_access_flags_from_decl (decl)),\n-\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n+\t\t GET_TYPE_NAME (type),\n \t\t IDENTIFIER_POINTER (DECL_NAME (decl)),\n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n \t      return 1;\n@@ -9050,9 +9061,9 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      if (field_decl == NULL_TREE)\n \t\t{\n \t\t  parse_error_context \n-\t\t    (qual_wfl, \"No variable `%s' defined in class `%s'\",\n+\t\t    (qual_wfl, \"No variable `%s' defined in type `%s'\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)), \n-\t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+\t\t     GET_TYPE_NAME (type));\n \t\t  return 1;\n \t\t}\n \t      if (field_decl == error_mark_node)\n@@ -9081,7 +9092,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t     \"Can't access %s field `%s.%s' from `%s'\",\n \t\t     java_accstring_lookup \n \t\t       (get_access_flags_from_decl (field_decl)),\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n+\t\t     GET_TYPE_NAME (type),\n \t\t     IDENTIFIER_POINTER (DECL_NAME (field_decl)),\n \t\t     IDENTIFIER_POINTER \n \t\t       (DECL_NAME (TYPE_NAME (current_class))));\n@@ -10112,6 +10123,22 @@ java_complete_tree (node)\n   return node;\n }\n \n+static tree\n+java_stabilize_reference (node)\n+     tree node;\n+{\n+  if (TREE_CODE (node) == COMPOUND_EXPR)\n+    {\n+      tree op0 = TREE_OPERAND (node, 0);\n+      tree op1 = TREE_OPERAND (node, 1);\n+      TREE_OPERAND (node, 0) = build1 (SAVE_EXPR, TREE_TYPE (op0), op0);\n+      TREE_OPERAND (node, 1) = java_stabilize_reference (op1);\n+      return node;\n+    }\n+  else\n+    return stabilize_reference (node);\n+}\n+\n /* Patch tree nodes in a function body. When a BLOCK is found, push\n    local variable decls if present.\n    Same as java_complete_tree, but does not resolve static finals to values. */\n@@ -10239,13 +10266,15 @@ java_complete_lhs (node)\n     case CLEANUP_POINT_EXPR:\n       COMPLETE_CHECK_OP_0 (node);\n       TREE_TYPE (node) = void_type_node;\n-      CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n+      CAN_COMPLETE_NORMALLY (node) = \n+\tCAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n       return node;\n \n     case WITH_CLEANUP_EXPR:\n       COMPLETE_CHECK_OP_0 (node);\n       COMPLETE_CHECK_OP_2 (node);\n-      CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n+      CAN_COMPLETE_NORMALLY (node) = \n+\tCAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n       TREE_TYPE (node) = void_type_node;\n       return node;\n \n@@ -10508,26 +10537,33 @@ java_complete_lhs (node)\n \n       if (COMPOUND_ASSIGN_P (wfl_op2))\n \t{\n-\t  tree lvalue;\n-\t  tree other = \n-\t    java_complete_tree (TREE_OPERAND (wfl_op2, 0));\n+\t  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); \n \n \t  /* Hand stablize the lhs on both places */\n-\t  lvalue = stabilize_reference (other); \n \t  TREE_OPERAND (node, 0) = lvalue;\n \t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;\n+\n+\t  /* Now complete the RHS. We write it back later on. */\n+\t  nn = java_complete_tree (TREE_OPERAND (node, 1));\n+\n+\t  /* The last part of the rewrite for E1 op= E2 is to have \n+\t     E1 = (T)(E1 op E2), with T being the type of E1. */\n+\t  nn = build_cast (EXPR_WFL_LINECOL (wfl_op2), TREE_TYPE (lvalue), nn);\n \t}\n \n       /* If we're about to patch a NEW_ARRAY_INIT, we call a special\n \t function to complete this RHS */\n-      if (TREE_CODE (wfl_op2) == NEW_ARRAY_INIT)\n+      else if (TREE_CODE (wfl_op2) == NEW_ARRAY_INIT)\n \tnn = patch_new_array_init (TREE_TYPE (TREE_OPERAND (node, 0)),\n \t\t\t\t   TREE_OPERAND (node, 1));\n+      /* Otherwise we simply complete the RHS */\n       else\n \tnn = java_complete_tree (TREE_OPERAND (node, 1));\n \n       if (nn == error_mark_node)\n \treturn error_mark_node;\n+\n+      /* Write back the RHS as we evaluated it. */\n       TREE_OPERAND (node, 1) = nn;\n \n       /* In case we're handling = with a String as a RHS, we need to\n@@ -10576,17 +10612,23 @@ java_complete_lhs (node)\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Don't complete string nodes if dealing with the PLUS operand. */\n       if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op1))\n-\t{\n-\t  TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n-\t  if (TREE_OPERAND (node, 0) == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n+        {\n+          nn = java_complete_tree (wfl_op1);\n+          if (nn == error_mark_node)\n+            return error_mark_node;\n+          if ((cn = patch_string (nn)))\n+            nn = cn;\n+          TREE_OPERAND (node, 0) = nn;\n+        }\n       if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op2))\n-\t{\n-\t  TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n-\t  if (TREE_OPERAND (node, 1) == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n+        {\n+          nn = java_complete_tree (wfl_op2);\n+          if (nn == error_mark_node)\n+            return error_mark_node;\n+          if ((cn = patch_string (nn)))\n+            nn = cn;\n+          TREE_OPERAND (node, 1) = nn;\n+        }\n       return force_evaluation_order (patch_binop (node, wfl_op1, wfl_op2));\n \n     case INSTANCEOF_EXPR:"}, {"sha": "c78c5bb680714231e1c430168bf0fbb30efeff14", "filename": "gcc/java/parse.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "patch": "@@ -129,6 +129,13 @@ extern tree stabilize_reference PROTO ((tree));\n   (TREE_CODE (DECL_NAME (METHOD)) == EXPR_WITH_FILE_LOCATION ?\t\\\n    EXPR_WFL_NODE (DECL_NAME (METHOD)) : DECL_NAME (METHOD))\n \n+/* Get TYPE name string, regardless whether TYPE is a class or an\n+   array. */\n+#define GET_TYPE_NAME(TYPE)\t\t\t\t\\\n+  (TREE_CODE (TYPE_NAME (TYPE)) == IDENTIFIER_NODE ?\t\\\n+   IDENTIFIER_POINTER (TYPE_NAME (TYPE)) :\t\t\\\n+   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TYPE))))\n+\n /* Pedantic warning on obsolete modifiers. Note: when cl is NULL,\n    flags was set artificially, such as for a interface method */\n #define OBSOLETE_MODIFIER_WARNING(cl, flags, modifier, format, arg)          \\"}, {"sha": "c4378dae51da9246018bb9e2591554763fb06183", "filename": "gcc/java/parse.y", "status": "modified", "additions": 67, "deletions": 32, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa11e9772e5ffc892a8e5f9a169555fa5af1bef/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=2aa11e9772e5ffc892a8e5f9a169555fa5af1bef", "patch": "@@ -1320,7 +1320,10 @@ statement_expression:\n \n if_then_statement:\n \tIF_TK OP_TK expression CP_TK statement\n-\t{ $$ = build_if_else_statement ($2.location, $3, $5, NULL_TREE); }\n+\t\t{ \n+\t\t  $$ = build_if_else_statement ($2.location, $3, \n+\t\t\t\t\t\t$5, NULL_TREE);\n+\t\t}\n |\tIF_TK error\n \t\t{yyerror (\"'(' expected\"); RECOVER;}\n |\tIF_TK OP_TK error\n@@ -1331,12 +1334,12 @@ if_then_statement:\n \n if_then_else_statement:\n \tIF_TK OP_TK expression CP_TK statement_nsi ELSE_TK statement\n-\t{ $$ = build_if_else_statement ($2.location, $3, $5, $7); }\n+\t\t{ $$ = build_if_else_statement ($2.location, $3, $5, $7); }\n ;\n \n if_then_else_statement_nsi:\n \tIF_TK OP_TK expression CP_TK statement_nsi ELSE_TK statement_nsi\n-\t{ $$ = build_if_else_statement ($2.location, $3, $5, $7); }\n+\t\t{ $$ = build_if_else_statement ($2.location, $3, $5, $7); }\n ;\n \n switch_statement:\n@@ -1458,7 +1461,7 @@ do_statement:\n \n for_statement:\n \tfor_begin SC_TK expression SC_TK for_update CP_TK statement\n-\t\t{ $$ = complete_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7);}\n+\t\t{ $$ = complete_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7); }\n |\tfor_begin SC_TK SC_TK for_update CP_TK statement\n \t\t{ \n \t\t  $$ = complete_for_loop (0, NULL_TREE, $4, $6);\n@@ -1621,10 +1624,10 @@ try_statement:\n |\tTRY_TK block finally\n \t\t{ $$ = build_try_finally_statement ($1.location, $2, $3); }\n |\tTRY_TK block catches finally\n-\t\t{ $$ = build_try_finally_statement ($1.location,\n-\t\t\t\t\t\t    build_try_statement ($1.location,\n-\t\t\t\t\t\t\t\t\t $2, $3),\n-\t\t\t\t\t\t    $4); }\n+\t\t{ $$ = build_try_finally_statement \n+\t\t    ($1.location, build_try_statement ($1.location,\n+\t\t\t\t\t\t       $2, $3), $4);\n+\t\t}\n |\tTRY_TK error\n \t\t{yyerror (\"'{' expected\"); DRECOVER (try_statement);}\n ;\n@@ -2937,7 +2940,7 @@ create_interface (flags, id, super)\n   decl = maybe_create_class_interface_decl (decl, q_name, id);\n \n   /* Set super info and mark the class a complete */\n-  set_super_info (ACC_ABSTRACT | ACC_INTERFACE | flags, TREE_TYPE (decl), \n+  set_super_info (ACC_INTERFACE | flags, TREE_TYPE (decl), \n \t\t  object_type_node, ctxp->interface_number);\n   ctxp->interface_number = 0;\n   CLASS_COMPLETE_P (decl) = 1;\n@@ -3297,7 +3300,8 @@ method_header (flags, type, mdecl, throws)\n       ABSTRACT_CHECK (flags, ACC_FINAL, id, \"Final\");\n       ABSTRACT_CHECK (flags, ACC_NATIVE, id, \"Native\");\n       ABSTRACT_CHECK (flags, ACC_SYNCHRONIZED,id, \"Synchronized\");\n-      if (!CLASS_ABSTRACT (TYPE_NAME (this_class)))\n+      if (!CLASS_ABSTRACT (TYPE_NAME (this_class))\n+\t  && !CLASS_INTERFACE (TYPE_NAME (this_class)))\n \tparse_error_context \n \t  (id, \"Class `%s' must be declared abstract to define abstract \"\n \t   \"method `%s'\", \n@@ -5248,7 +5252,7 @@ declare_local_variables (modifier, type, vlist)\n   tree type_wfl = NULL_TREE;\n   int must_chain = 0;\n \n-  /* Push a new block if statement were seen between the last time we\n+  /* Push a new block if statements were seen between the last time we\n      pushed a block and now. Keep a cound of block to close */\n   if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (current_function_decl)))\n     {\n@@ -6394,7 +6398,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      parse_error_context \n \t\t(qual_wfl, \"Can't access %s field `%s.%s' from `%s'\",\n \t\t java_accstring_lookup (get_access_flags_from_decl (decl)),\n-\t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n+\t\t GET_TYPE_NAME (type),\n \t\t IDENTIFIER_POINTER (DECL_NAME (decl)),\n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n \t      return 1;\n@@ -6455,9 +6459,9 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      if (field_decl == NULL_TREE)\n \t\t{\n \t\t  parse_error_context \n-\t\t    (qual_wfl, \"No variable `%s' defined in class `%s'\",\n+\t\t    (qual_wfl, \"No variable `%s' defined in type `%s'\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)), \n-\t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n+\t\t     GET_TYPE_NAME (type));\n \t\t  return 1;\n \t\t}\n \t      if (field_decl == error_mark_node)\n@@ -6486,7 +6490,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t     \"Can't access %s field `%s.%s' from `%s'\",\n \t\t     java_accstring_lookup \n \t\t       (get_access_flags_from_decl (field_decl)),\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n+\t\t     GET_TYPE_NAME (type),\n \t\t     IDENTIFIER_POINTER (DECL_NAME (field_decl)),\n \t\t     IDENTIFIER_POINTER \n \t\t       (DECL_NAME (TYPE_NAME (current_class))));\n@@ -7517,6 +7521,22 @@ java_complete_tree (node)\n   return node;\n }\n \n+static tree\n+java_stabilize_reference (node)\n+     tree node;\n+{\n+  if (TREE_CODE (node) == COMPOUND_EXPR)\n+    {\n+      tree op0 = TREE_OPERAND (node, 0);\n+      tree op1 = TREE_OPERAND (node, 1);\n+      TREE_OPERAND (node, 0) = build1 (SAVE_EXPR, TREE_TYPE (op0), op0);\n+      TREE_OPERAND (node, 1) = java_stabilize_reference (op1);\n+      return node;\n+    }\n+  else\n+    return stabilize_reference (node);\n+}\n+\n /* Patch tree nodes in a function body. When a BLOCK is found, push\n    local variable decls if present.\n    Same as java_complete_tree, but does not resolve static finals to values. */\n@@ -7644,13 +7664,15 @@ java_complete_lhs (node)\n     case CLEANUP_POINT_EXPR:\n       COMPLETE_CHECK_OP_0 (node);\n       TREE_TYPE (node) = void_type_node;\n-      CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n+      CAN_COMPLETE_NORMALLY (node) = \n+\tCAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n       return node;\n \n     case WITH_CLEANUP_EXPR:\n       COMPLETE_CHECK_OP_0 (node);\n       COMPLETE_CHECK_OP_2 (node);\n-      CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n+      CAN_COMPLETE_NORMALLY (node) = \n+\tCAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0));\n       TREE_TYPE (node) = void_type_node;\n       return node;\n \n@@ -7913,26 +7935,33 @@ java_complete_lhs (node)\n \n       if (COMPOUND_ASSIGN_P (wfl_op2))\n \t{\n-\t  tree lvalue;\n-\t  tree other = \n-\t    java_complete_tree (TREE_OPERAND (wfl_op2, 0));\n+\t  tree lvalue = java_stabilize_reference (TREE_OPERAND (node, 0)); \n \n \t  /* Hand stablize the lhs on both places */\n-\t  lvalue = stabilize_reference (other); \n \t  TREE_OPERAND (node, 0) = lvalue;\n \t  TREE_OPERAND (TREE_OPERAND (node, 1), 0) = lvalue;\n+\n+\t  /* Now complete the RHS. We write it back later on. */\n+\t  nn = java_complete_tree (TREE_OPERAND (node, 1));\n+\n+\t  /* The last part of the rewrite for E1 op= E2 is to have \n+\t     E1 = (T)(E1 op E2), with T being the type of E1. */\n+\t  nn = build_cast (EXPR_WFL_LINECOL (wfl_op2), TREE_TYPE (lvalue), nn);\n \t}\n \n       /* If we're about to patch a NEW_ARRAY_INIT, we call a special\n \t function to complete this RHS */\n-      if (TREE_CODE (wfl_op2) == NEW_ARRAY_INIT)\n+      else if (TREE_CODE (wfl_op2) == NEW_ARRAY_INIT)\n \tnn = patch_new_array_init (TREE_TYPE (TREE_OPERAND (node, 0)),\n \t\t\t\t   TREE_OPERAND (node, 1));\n+      /* Otherwise we simply complete the RHS */\n       else\n \tnn = java_complete_tree (TREE_OPERAND (node, 1));\n \n       if (nn == error_mark_node)\n \treturn error_mark_node;\n+\n+      /* Write back the RHS as we evaluated it. */\n       TREE_OPERAND (node, 1) = nn;\n \n       /* In case we're handling = with a String as a RHS, we need to\n@@ -7981,17 +8010,23 @@ java_complete_lhs (node)\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Don't complete string nodes if dealing with the PLUS operand. */\n       if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op1))\n-\t{\n-\t  TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n-\t  if (TREE_OPERAND (node, 0) == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n+        {\n+          nn = java_complete_tree (wfl_op1);\n+          if (nn == error_mark_node)\n+            return error_mark_node;\n+          if ((cn = patch_string (nn)))\n+            nn = cn;\n+          TREE_OPERAND (node, 0) = nn;\n+        }\n       if (TREE_CODE (node) != PLUS_EXPR || !JSTRING_P (wfl_op2))\n-\t{\n-\t  TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n-\t  if (TREE_OPERAND (node, 1) == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n+        {\n+          nn = java_complete_tree (wfl_op2);\n+          if (nn == error_mark_node)\n+            return error_mark_node;\n+          if ((cn = patch_string (nn)))\n+            nn = cn;\n+          TREE_OPERAND (node, 1) = nn;\n+        }\n       return force_evaluation_order (patch_binop (node, wfl_op1, wfl_op2));\n \n     case INSTANCEOF_EXPR:"}]}