{"sha": "afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlOTZkNDE1ZDhhMDhlYzJmNDI4YmRlYTBjZmFhODgyMDdlNGI2ZQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "francois.cppdevs@free.fr", "date": "2010-11-25T20:53:39Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2010-11-25T20:53:39Z"}, "message": "debug.cc: Introduce a mutex pool in get_safe_base_mutex.\n\n2010-11-25  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n\n\t* src/debug.cc: Introduce a mutex pool in get_safe_base_mutex.\n\tMove code used to manipulate sequence safe iterators from safe\n\titerator methods to safe sequence ones. Remove usage of safe iterator\n\tmutex, keep _Safe_iterator_base::_M_get_mutex for library backward\n\tbinary compatibility.\n\t* src/Makefile.am: Build debug.cc in gnu++0x mode for _Hash_impl usage.\n\t* src/Makefile.in: Regenerate\n\t* include/debug/safe_base.h: Add _Safe_iterator_base _M_invalidate\n\tand _M_reset. Add _Safe_sequence_base _M_attach, _M_attach_single,\n\t_M_detach and _M_detach_single.\n\t* include/debug.safe_iterator.h, safe_iterator.tcc: Remove\n\t_Safe_iterator _M_invalidate and _M_invalidate_single. Implement all\n\tmethods in terms of normal iterators rather than safe ones.\n\t* include/debug/safe_sequence.h: Replace _Safe_sequence\n\t_M_transfe_iter with _M_transfer_from_if taking the source sequence\n\tand a predicate signaling when a safe iterator shall be transfered.\n\tAdd _Equal_to predicate.\n\t* include/debug/safe_sequence.tcc: New.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\t* include/debug/forward_list: Swap safe iterators in move constructor.\n\tDo not invalidate before begin in _M_invalidate_all method.\n\tReimplement safe methods using normal iterators rather than safe ones.\n\t* include/debug/set.h, unordered_map, multiset.h, vector,\n\tunordered_set, deque, map.h, list, multimap.h: Reimplement safe method\n\tusing normal iterators rather than safe ones.\n\t* testsuite/23_containers/forward_list/debug/clear.cc, swap.cc,\n\tmove_constructor.cc, splice_after.cc, splice_after1.cc,\n\tsplice_after2.cc, splice_after3.cc, splice_after4.cc: New.\n\t* testsuite/23_containers/vector/debug/multithreaded_swap.cc: New.\n\nFrom-SVN: r167152", "tree": {"sha": "655bd05d685adc6a2c1cc45fb794a00e1ae25b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/655bd05d685adc6a2c1cc45fb794a00e1ae25b76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/comments", "author": null, "committer": null, "parents": [{"sha": "24e1ee321921eed8f9dc58cd099fd9d0ff090ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24e1ee321921eed8f9dc58cd099fd9d0ff090ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24e1ee321921eed8f9dc58cd099fd9d0ff090ce4"}], "stats": {"total": 1948, "additions": 1360, "deletions": 588}, "files": [{"sha": "dc22b52a12efc45990987d9bd39236b94973b39f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -1,3 +1,36 @@\n+2010-11-25  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n+\n+\t* src/debug.cc: Introduce a mutex pool in get_safe_base_mutex.\n+\tMove code used to manipulate sequence safe iterators from safe\n+\titerator methods to safe sequence ones. Remove usage of safe iterator\n+\tmutex, keep _Safe_iterator_base::_M_get_mutex for library backward\n+\tbinary compatibility.\n+\t* src/Makefile.am: Build debug.cc in gnu++0x mode for _Hash_impl usage.\n+\t* src/Makefile.in: Regenerate\n+\t* include/debug/safe_base.h: Add _Safe_iterator_base _M_invalidate\n+\tand _M_reset. Add _Safe_sequence_base _M_attach, _M_attach_single,\n+\t_M_detach and _M_detach_single.\n+\t* include/debug.safe_iterator.h, safe_iterator.tcc: Remove\n+\t_Safe_iterator _M_invalidate and _M_invalidate_single. Implement all\n+\tmethods in terms of normal iterators rather than safe ones.\n+\t* include/debug/safe_sequence.h: Replace _Safe_sequence\n+\t_M_transfe_iter with _M_transfer_from_if taking the source sequence\n+\tand a predicate signaling when a safe iterator shall be transfered.\n+\tAdd _Equal_to predicate.\n+\t* include/debug/safe_sequence.tcc: New.\n+\t* include/Makefile.am: Adjust.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/debug/forward_list: Swap safe iterators in move constructor.\n+\tDo not invalidate before begin in _M_invalidate_all method.\n+\tReimplement safe methods using normal iterators rather than safe ones.\n+\t* include/debug/set.h, unordered_map, multiset.h, vector,\n+\tunordered_set, deque, map.h, list, multimap.h: Reimplement safe method\n+\tusing normal iterators rather than safe ones.\n+\t* testsuite/23_containers/forward_list/debug/clear.cc, swap.cc,\n+\tmove_constructor.cc, splice_after.cc, splice_after1.cc,\n+\tsplice_after2.cc, splice_after3.cc, splice_after4.cc: New.\n+\t* testsuite/23_containers/vector/debug/multithreaded_swap.cc: New.\n+\n 2010-11-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/std/tuple: Mark more constructors constexpr."}, {"sha": "6587179a4ef21d2b59d7f050bb17c2a99621fdee", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -708,6 +708,7 @@ debug_headers = \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n \t${debug_srcdir}/safe_sequence.h \\\n+\t${debug_srcdir}/safe_sequence.tcc \\\n \t${debug_srcdir}/set \\\n \t${debug_srcdir}/set.h \\\n \t${debug_srcdir}/string \\"}, {"sha": "7ed93210258ae3fc56a40154844f930753d92c74", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -941,6 +941,7 @@ debug_headers = \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\\n \t${debug_srcdir}/safe_sequence.h \\\n+\t${debug_srcdir}/safe_sequence.tcc \\\n \t${debug_srcdir}/set \\\n \t${debug_srcdir}/set.h \\\n \t${debug_srcdir}/string \\"}, {"sha": "cf63c3af090c3414947d2ca1c649e190729a8c3f", "filename": "libstdc++-v3/include/debug/deque", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -47,14 +47,17 @@ namespace __debug\n       typedef  _GLIBCXX_STD_D::deque<_Tp, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<deque> _Safe_base;\n \n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n     public:\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,deque>\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,deque>\n \t\t\t\t\t\t    iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,deque>\n-\t\t\t\t\t\t     const_iterator;\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,deque>\n+\t\t\t\t\t\t    const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n       typedef typename _Base::difference_type       difference_type;\n@@ -219,6 +222,15 @@ namespace __debug\n       { return const_reverse_iterator(begin()); }\n #endif\n \n+    private:\n+      void\n+      _M_invalidate_after_nth(difference_type __n)\n+      {\n+\ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n+\tthis->_M_invalidate_if(_After_nth(__n, _Base::begin()));\n+      }\n+      \n+    public:\n       // 23.2.1.2 capacity:\n       using _Base::size;\n       using _Base::max_size;\n@@ -227,12 +239,9 @@ namespace __debug\n       void\n       resize(size_type __sz)\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n-\n \tbool __invalidate_all = __sz > this->size();\n \tif (__sz < this->size())\n-\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__sz);\n \n \t_Base::resize(__sz);\n \n@@ -243,12 +252,9 @@ namespace __debug\n       void\n       resize(size_type __sz, const _Tp& __c)\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n-\n \tbool __invalidate_all = __sz > this->size();\n \tif (__sz < this->size())\n-\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__sz);\n \n \t_Base::resize(__sz, __c);\n \n@@ -259,12 +265,9 @@ namespace __debug\n       void\n       resize(size_type __sz, _Tp __c = _Tp())\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n-\n \tbool __invalidate_all = __sz > this->size();\n \tif (__sz < this->size())\n-\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__sz);\n \n \t_Base::resize(__sz, __c);\n \n@@ -369,8 +372,8 @@ namespace __debug\n         emplace(iterator __position, _Args&&... __args)\n \t{\n \t  __glibcxx_check_insert(__position);\n-\t  typename _Base::iterator __res = _Base::emplace(__position.base(),\n-\t\t\t\t\t    std::forward<_Args>(__args)...);\n+\t  _Base_iterator __res = _Base::emplace(__position.base(),\n+\t\t\t\t\t\tstd::forward<_Args>(__args)...);\n \t  this->_M_invalidate_all();\n \t  return iterator(__res, this);\n \t}\n@@ -380,7 +383,7 @@ namespace __debug\n       insert(iterator __position, const _Tp& __x)\n       {\n \t__glibcxx_check_insert(__position);\n-\ttypename _Base::iterator __res = _Base::insert(__position.base(), __x);\n+\t_Base_iterator __res = _Base::insert(__position.base(), __x);\n \tthis->_M_invalidate_all();\n \treturn iterator(__res, this);\n       }\n@@ -421,33 +424,31 @@ namespace __debug\n       pop_front()\n       {\n \t__glibcxx_check_nonempty();\n-\titerator __victim = begin();\n-\t__victim._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(_Base::begin()));\n \t_Base::pop_front();\n       }\n \n       void\n       pop_back()\n       {\n \t__glibcxx_check_nonempty();\n-\titerator __victim = end();\n-\t--__victim;\n-\t__victim._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(--_Base::end()));\n \t_Base::pop_back();\n       }\n \n       iterator\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\tif (__position == begin() || __position == end()-1)\n+\t_Base_iterator __victim = __position.base();\n+\tif (__victim == _Base::begin() || __victim == _Base::end()-1)\n \t  {\n-\t    __position._M_invalidate();\n-\t    return iterator(_Base::erase(__position.base()), this);\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    return iterator(_Base::erase(__victim), this);\n \t  }\n \telse\n \t  {\n-\t    typename _Base::iterator __res = _Base::erase(__position.base());\n+\t    _Base_iterator __res = _Base::erase(__victim);\n \t    this->_M_invalidate_all();\n \t    return iterator(__res, this);\n \t  }\n@@ -459,13 +460,13 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-        if (__first == begin() || __last == end())\n+        if (__first.base() == _Base::begin() || __last.base() == _Base::end())\n \t  {\n \t    this->_M_detach_singular();\n-\t    for (iterator __position = __first; __position != __last; )\n+\t    for (_Base_iterator __position = __first.base();\n+\t\t __position != __last.base(); ++__position)\n \t      {\n-\t\titerator __victim = __position++;\n-\t\t__victim._M_invalidate();\n+\t\tthis->_M_invalidate_if(_Equal(__position));\n \t      }\n \t    __try\n \t      {\n@@ -480,8 +481,8 @@ namespace __debug\n \t  }\n \telse\n \t  {\n-\t    typename _Base::iterator __res = _Base::erase(__first.base(),\n-\t\t\t\t\t\t\t  __last.base());\n+\t    _Base_iterator __res = _Base::erase(__first.base(),\n+\t\t\t\t\t\t__last.base());\n \t    this->_M_invalidate_all();\n \t    return iterator(__res, this);\n \t  }"}, {"sha": "03b661ec221f6cccfdbb582b378f15fc9735a86e", "filename": "libstdc++-v3/include/debug/forward_list", "status": "modified", "additions": 111, "deletions": 97, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -48,13 +48,15 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::forward_list<_Tp, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<forward_list> _Safe_base;\n \n+      typedef typename _Base::iterator       _Base_iterator;\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n     public:\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n \t\t\t\t\t  forward_list> iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  forward_list> const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n@@ -75,7 +77,7 @@ namespace __debug\n       { }\n \n       forward_list(forward_list&& __list, const _Alloc& __al)\n-      : _Base(std::move(__list), __al)\n+      : _Base(std::move(__list._M_base()), __al)\n       {\n \tthis->_M_swap(__list);\n       }\n@@ -103,7 +105,10 @@ namespace __debug\n       { }\n \n       forward_list(forward_list&& __list)\n-      : _Base(std::move(__list)) { }\n+      : _Base(std::move(__list._M_base()))\n+      {\n+\tthis->_M_swap(__list);\n+      }\n \n       forward_list(std::initializer_list<_Tp> __il,\n                    const _Alloc& __al = _Alloc())\n@@ -231,8 +236,8 @@ namespace __debug\n       pop_front()\n       {\n \t__glibcxx_check_nonempty();\n-\titerator __victim = begin();\n-\t__victim._M_invalidate();\n+\tthis->_M_invalidate_if([this](_Base_const_iterator __it)\n+\t  { return __it == this->_M_base().cbegin(); });\n \t_Base::pop_front();\n       }\n \n@@ -288,25 +293,37 @@ namespace __debug\n \treturn iterator(_Base::insert_after(__pos.base(), __il), this);\n       }\n \n+    private:\n+      _Base_iterator\n+      _M_erase_after(_Base_const_iterator __pos)\n+      {\n+\t_Base_const_iterator __next = std::next(__pos);\n+\tthis->_M_invalidate_if([__next](_Base_const_iterator __it)\n+\t  { return __it == __next; });\n+\treturn _Base::erase_after(__pos);\n+      }\n+    public:\n       iterator\n       erase_after(const_iterator __pos)\n       {\n \t__glibcxx_check_erase_after(__pos);\n-\tconst_iterator __victim = __pos;\n-\t++__victim;\n-\t__victim._M_invalidate();\n-\treturn iterator(_Base::erase_after(__pos.base()), this);\n+\treturn iterator(_M_erase_after(__pos.base()), this);\n       }\n \n       iterator\n       erase_after(const_iterator __pos, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range_after(__pos, __last);\n-\tfor (const_iterator __victim = std::next(__pos); __victim != __last; )\n+\tfor (_Base_const_iterator __victim = std::next(__pos.base());\n+\t    __victim != __last.base(); ++__victim)\n \t  {\n-\t    const_iterator __old = __victim;\n-\t    ++__victim;\n-\t    __old._M_invalidate();\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range2)\n+\t\t\t\t  ._M_sequence(*this, \"this\")\n+\t\t\t\t  ._M_iterator(__pos, \"pos\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t      { return __it == __victim; });\n \t  }\n \treturn iterator(_Base::erase_after(__pos.base(), __last.base()), this);\n       }\n@@ -324,15 +341,15 @@ namespace __debug\n \tthis->_M_detach_singular();\n \n \t// if __sz < size(), invalidate all iterators in [begin+__sz, end()\n-\titerator __victim = begin();\n-\titerator __end = end();\n+\t_Base_iterator __victim = _Base::begin();\n+\t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n-\twhile (__victim != __end)\n+\tfor (; __victim != __end; ++__victim)\n \t  {\n-\t    iterator __real_victim = __victim++;\n-\t    __real_victim._M_invalidate();\n+\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t      { return __it == __victim; });\n \t  }\n \n \t__try\n@@ -352,15 +369,15 @@ namespace __debug\n \tthis->_M_detach_singular();\n \n \t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n-\titerator __victim = begin();\n-\titerator __end = end();\n+\t_Base_iterator __victim = _Base::begin();\n+\t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n-\twhile (__victim != __end)\n+\tfor (; __victim != __end; ++__victim)\n \t  {\n-\t    iterator __real_victim = __victim++;\n-\t    __real_victim._M_invalidate();\n+\t    this->_M_invalidate_if([__victim](_Base_const_iterator __it)\n+\t      { return __it == __victim; });\n \t  }\n \n \t__try\n@@ -382,38 +399,19 @@ namespace __debug\n       }\n \n       // 23.2.3.5 forward_list operations:\n-    private:\n-      void\n-      _M_splice_after(const_iterator __pos, forward_list&& __list,\n-\t\t      const_iterator __before, const_iterator __last)\n-      {\n-\tfor (const_iterator __tmp = std::next(__before); __tmp != __last; )\n-\t  {\n-\t    _GLIBCXX_DEBUG_VERIFY(&__list != this || __tmp != __pos,\n-                                  _M_message(__gnu_debug::__msg_splice_overlap)\n-                                  ._M_iterator(__tmp, \"position\")\n-\t\t\t\t  ._M_iterator(__before, \"before\")\n-\t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    const_iterator __victim = __tmp++;\n-\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t    // 250. splicing invalidates iterators\n-\t    this->_M_transfer_iter(__victim);\n-\t  }\n-\n-\t_Base::splice_after(__pos.base(), std::move(__list._M_base()),\n-\t\t\t    __before.base(), __last.base());\n-      }\n-\n-    public:\n       void\n       splice_after(const_iterator __pos, forward_list&& __list)\n       {\n         __glibcxx_check_insert_after(__pos);\n \t_GLIBCXX_DEBUG_VERIFY(&__list != this,\n \t\t\t      _M_message(__gnu_debug::__msg_self_splice)\n \t\t\t      ._M_sequence(*this, \"this\"));\n-\t_M_splice_after(__pos, std::move(__list),\n-\t\t\t__list.before_begin(), __list.end());\n+\tthis->_M_transfer_from_if(__list, [&__list](_Base_const_iterator __it)\n+\t  {\n+\t    return __it != __list._M_base().cbefore_begin()\n+\t\t   && __it != __list._M_base().end();\n+\t  });\n+\t_Base::splice_after(__pos.base(), std::move(__list._M_base()));\n       }\n \n       void\n@@ -431,7 +429,9 @@ namespace __debug\n \n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 250. splicing invalidates iterators\n-\tthis->_M_transfer_iter(__i);\n+\t_Base_const_iterator __next = std::next(__i.base());\n+\tthis->_M_transfer_from_if(__list, [__next](_Base_const_iterator __it)\n+\t  { return __it == __next; });\n \t_Base::splice_after(__pos.base(), std::move(__list._M_base()),\n \t\t\t    __i.base());\n       }\n@@ -457,21 +457,39 @@ namespace __debug\n \t\t\t      ._M_sequence(__list, \"list\")\n \t\t\t      ._M_iterator(__before, \"before\")\n \t\t\t      ._M_iterator(__last, \"last\"));\n-\t_M_splice_after(__pos, std::move(__list), __before, __last);\n+\n+\tfor (_Base_const_iterator __tmp = std::next(__before.base());\n+\t     __tmp != __last.base(); ++__tmp)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != __list._M_base().end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range2)\n+\t\t\t\t  ._M_sequence(__list, \"list\")\n+\t\t\t\t  ._M_iterator(__before, \"before\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    _GLIBCXX_DEBUG_VERIFY(&__list != this || __tmp != __pos.base(),\n+                                  _M_message(__gnu_debug::__msg_splice_overlap)\n+                                  ._M_iterator(__tmp, \"position\")\n+\t\t\t\t  ._M_iterator(__before, \"before\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t    // 250. splicing invalidates iterators\n+\t    this->_M_transfer_from_if(__list, [__tmp](_Base_const_iterator __it)\n+\t      { return __it == __tmp; });\n+\t  }\n+\n+\t_Base::splice_after(__pos.base(), std::move(__list._M_base()),\n+\t\t\t    __before.base(), __last.base());\n       }\n \n       void\n       remove(const _Tp& __val)\n       {\n-\titerator __x = before_begin();\n-\titerator __old = __x++;\n-\twhile (__x.base() != _Base::end())\n+\t_Base_iterator __x = _Base::before_begin();\n+\t_Base_iterator __old = __x++;\n+\twhile (__x != _Base::end())\n \t  {\n \t    if (*__x == __val)\n-\t      {\n-\t\terase_after(__old);\n-\t\t__x = __old; ++__x;\n-\t      }\n+\t      __x = _M_erase_after(__old);\n \t    else\n \t      __old = __x++;\n \t  }\n@@ -481,15 +499,12 @@ namespace __debug\n         void\n         remove_if(_Pred __pred)\n \t{\n-\t  iterator __x = before_begin();\n-\t  iterator __old = __x++;\n-\t  while (__x.base() != _Base::end())\n+\t  _Base_iterator __x = _Base::before_begin();\n+\t  _Base_iterator __old = __x++;\n+\t  while (__x != _Base::end())\n \t    {\n \t      if (__pred(*__x))\n-\t\t{\n-\t\t  erase_after(__old);\n-\t\t  __x = std::next(__old);\n-\t\t}\n+\t\t__x = _M_erase_after(__old);\n \t      else\n \t\t__old = __x++;\n \t    }\n@@ -498,41 +513,35 @@ namespace __debug\n       void\n       unique()\n       {\n-\titerator __first = begin();\n-\titerator __last = end();\n+\t_Base_iterator __first = _Base::begin();\n+\t_Base_iterator __last = _Base::end();\n \tif (__first == __last)\n \t  return;\n-\titerator __next = __first;\n-\twhile (++__next != __last)\n+\t_Base_iterator __next = std::next(__first);\n+\twhile (__next != __last)\n \t  {\n \t    if (*__first == *__next)\n-\t      {\n-\t\terase_after(__first);\n-\t\t__next = __first;\n-\t      }\n+\t      __next = _M_erase_after(__first);\n \t    else\n-\t      __first = __next;\n+\t      __first = __next++;\n \t  }\n       }\n \n       template<typename _BinPred>\n         void\n         unique(_BinPred __binary_pred)\n \t{\n-\t  iterator __first = begin();\n-\t  iterator __last = end();\n+\t  _Base_iterator __first = _Base::begin();\n+\t  _Base_iterator __last = _Base::end();\n \t  if (__first == __last)\n \t    return;\n-\t  iterator __next = __first;\n-\t  while (++__next != __last)\n+\t  _Base_iterator __next = std::next(__first);\n+\t  while (__next != __last)\n \t    {\n \t      if (__binary_pred(*__first, *__next))\n-\t\t{\n-\t\t  erase_after(__first);\n-\t\t  __next = __first;\n-\t\t}\n+\t\t__next = _M_erase_after(__first);\n \t      else\n-\t\t__first = __next;\n+\t\t__first = __next++;\n \t    }\n \t}\n \n@@ -544,11 +553,11 @@ namespace __debug\n \t  __glibcxx_check_sorted(_Base::begin(), _Base::end());\n \t  __glibcxx_check_sorted(__list._M_base().begin(),\n \t\t\t\t __list._M_base().end());\n-\t  for (iterator __tmp = __list.begin(); __tmp != __list.end();)\n+\t  this->_M_transfer_from_if(__list, [&__list](_Base_const_iterator __it)\n \t    {\n-\t      iterator __victim = __tmp++;\n-\t      this->_M_transfer_iter(__victim);\n-\t    }\n+\t      return __it != __list._M_base().cbefore_begin()\n+\t\t     && __it != __list._M_base().cend();\n+\t    });\n \t  _Base::merge(std::move(__list._M_base()));\n \t}\n       }\n@@ -562,11 +571,12 @@ namespace __debug\n \t    __glibcxx_check_sorted_pred(_Base::begin(), _Base::end(), __comp);\n \t    __glibcxx_check_sorted_pred(__list._M_base().begin(),\n \t\t\t\t\t__list._M_base().end(), __comp);\n-\t    for (iterator __tmp = __list.begin(); __tmp != __list.end();)\n+\t    this->_M_transfer_from_if(__list,\n+\t\t\t\t      [&__list](_Base_const_iterator __it)\n \t      {\n-\t\titerator __victim = __tmp++;\n-\t\tthis->_M_transfer_iter(__victim);\n-\t      }\n+\t        return __it != __list._M_base().cbefore_begin()\n+\t\t       && __it != __list._M_base().cend();\n+\t      });\n \t    _Base::merge(std::move(__list._M_base()), __comp);\n \t  }\n \t}\n@@ -584,9 +594,11 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if([this](_Base_const_iterator __it)\n+\t  {\n+\t    return __it != this->_M_base().cbefore_begin()\n+\t\t   && __it != this->_M_base().cend();\n+\t  });\n       }\n     };\n \n@@ -644,11 +656,13 @@ namespace __gnu_debug\n   template<class _Tp, class _Alloc>\n     struct _BeforeBeginHelper<std::__debug::forward_list<_Tp, _Alloc> >\n     {\n-      typedef typename forward_list<_Tp, _Alloc>::const_iterator _It;\n+      typedef std::__debug::forward_list<_Tp, _Alloc> _Sequence;\n+      typedef typename _Sequence::const_iterator _It;\n+      typedef typename _It::iterator_type _BaseIt;\n \n       static bool\n-      _M_Is(_It __it, const forward_list<_Tp, _Alloc>* __seq)\n-      { return __it == __seq->before_begin(); }\n+      _M_Is(_BaseIt __it, const _Sequence* __seq)\n+      { return __it == __seq->_M_base().cbefore_begin(); }\n     };\n }\n "}, {"sha": "54b736c8a9c5490882d0f3cd563a75651a73392f", "filename": "libstdc++-v3/include/debug/list", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -47,13 +47,17 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::list<_Tp, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<list>  _Safe_base;\n \n+      typedef typename _Base::iterator       _Base_iterator;\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n+      typedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n     public:\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, list>\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator, list>\n \t\t\t\t\t\t    iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, list>\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator, list>\n \t\t\t\t\t\t    const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n@@ -230,15 +234,14 @@ namespace __debug\n \tthis->_M_detach_singular();\n \n \t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n-\titerator __victim = begin();\n-\titerator __end = end();\n+\t_Base_iterator __victim = _Base::begin();\n+\t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n-\twhile (__victim != __end)\n+\tfor (; __victim != __end; ++__victim)\n \t  {\n-\t    iterator __real_victim = __victim++;\n-\t    __real_victim._M_invalidate();\n+\t    this->_M_invalidate_if(_Equal(__victim));\n \t  }\n \n \t__try\n@@ -258,15 +261,14 @@ namespace __debug\n \tthis->_M_detach_singular();\n \n \t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n-\titerator __victim = begin();\n-\titerator __end = end();\n+\t_Base_iterator __victim = _Base::begin();\n+\t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n-\twhile (__victim != __end)\n+\tfor (; __victim != __end; ++__victim)\n \t  {\n-\t    iterator __real_victim = __victim++;\n-\t    __real_victim._M_invalidate();\n+\t    this->_M_invalidate_if(_Equal(__victim));\n \t  }\n \n \t__try\n@@ -286,15 +288,14 @@ namespace __debug\n \tthis->_M_detach_singular();\n \n \t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n-\titerator __victim = begin();\n-\titerator __end = end();\n+\t_Base_iterator __victim = _Base::begin();\n+\t_Base_iterator __end = _Base::end();\n \tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n \t  ++__victim;\n \n-\twhile (__victim != __end)\n+\tfor (; __victim != __end; ++__victim)\n \t  {\n-\t    iterator __real_victim = __victim++;\n-\t    __real_victim._M_invalidate();\n+\t    this->_M_invalidate_if(_Equal(__victim));\n \t  }\n \n \t__try\n@@ -349,8 +350,7 @@ namespace __debug\n       pop_front()\n       {\n \t__glibcxx_check_nonempty();\n-\titerator __victim = begin();\n-\t__victim._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(_Base::begin()));\n \t_Base::pop_front();\n       }\n \n@@ -364,9 +364,7 @@ namespace __debug\n       pop_back()\n       {\n \t__glibcxx_check_nonempty();\n-\titerator __victim = end();\n-\t--__victim;\n-\t__victim._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(--_Base::end()));\n \t_Base::pop_back();\n       }\n \n@@ -418,12 +416,19 @@ namespace __debug\n \t\t\t\t\t   __gnu_debug::__base(__last));\n \t}\n \n+    private:\n+      _Base_iterator\n+      _M_erase(_Base_iterator __position)\n+      {\n+\tthis->_M_invalidate_if(_Equal(__position));\n+\treturn _Base::erase(__position);\n+      }\n+    public:\n       iterator\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n-\treturn iterator(_Base::erase(__position.base()), this);\n+\treturn iterator(_M_erase(__position.base()), this);\n       }\n \n       iterator\n@@ -432,11 +437,14 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__position, __last);\n-\tfor (iterator __victim = __position; __victim != __last; )\n+\tfor (_Base_iterator __victim = __position.base();\n+\t     __victim != __last.base(); ++__victim)\n \t  {\n-\t    iterator __old = __victim;\n-\t    ++__victim;\n-\t    __old._M_invalidate();\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t          _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__position, \"position\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n \t  }\n \treturn iterator(_Base::erase(__position.base(), __last.base()), this);\n       }\n@@ -466,7 +474,8 @@ namespace __debug\n \t_GLIBCXX_DEBUG_VERIFY(&__x != this,\n \t\t\t      _M_message(__gnu_debug::__msg_self_splice)\n \t\t\t      ._M_sequence(*this, \"this\"));\n-\tthis->splice(__position, _GLIBCXX_MOVE(__x), __x.begin(), __x.end());\n+\tthis->_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));\n+\t_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()));\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -496,7 +505,7 @@ namespace __debug\n \n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 250. splicing invalidates iterators\n-\tthis->_M_transfer_iter(__i);\n+\tthis->_M_transfer_from_if(__x, _Equal(__i.base()));\n \t_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),\n \t\t      __i.base());\n       }\n@@ -526,17 +535,21 @@ namespace __debug\n \t// We used to perform the splice_alloc check:  not anymore, redundant\n \t// after implementing the relevant bits of N1599.\n \n-\tfor (iterator __tmp = __first; __tmp != __last; )\n+\tfor (_Base_iterator __tmp = __first.base();\n+\t     __tmp != __last.base(); ++__tmp)\n \t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n \t    _GLIBCXX_DEBUG_VERIFY(&__x != this || __tmp != __position,\n \t\t\t\t_M_message(__gnu_debug::__msg_splice_overlap)\n \t\t\t\t  ._M_iterator(__tmp, \"position\")\n \t\t\t\t  ._M_iterator(__first, \"first\")\n \t\t\t\t  ._M_iterator(__last, \"last\"));\n-\t    iterator __victim = __tmp++;\n \t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t    // 250. splicing invalidates iterators\n-\t    this->_M_transfer_iter(__victim);\n+\t    this->_M_transfer_from_if(__x, _Equal(__tmp));\n \t  }\n \n \t_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),\n@@ -552,10 +565,10 @@ namespace __debug\n       void\n       remove(const _Tp& __value)\n       {\n-\tfor (iterator __x = begin(); __x.base() != _Base::end(); )\n+\tfor (_Base_iterator __x = _Base::begin(); __x != _Base::end(); )\n \t  {\n \t    if (*__x == __value)\n-\t      __x = erase(__x);\n+\t      __x = _M_erase(__x);\n \t    else\n \t      ++__x;\n \t  }\n@@ -565,10 +578,10 @@ namespace __debug\n         void\n         remove_if(_Predicate __pred)\n         {\n-\t  for (iterator __x = begin(); __x.base() != _Base::end(); )\n+\t  for (_Base_iterator __x = _Base::begin(); __x != _Base::end(); )\n \t    {\n \t      if (__pred(*__x))\n-\t\t__x = erase(__x);\n+\t\t__x = _M_erase(__x);\n \t      else\n \t\t++__x;\n \t    }\n@@ -577,37 +590,35 @@ namespace __debug\n       void\n       unique()\n       {\n-\titerator __first = begin();\n-\titerator __last = end();\n+\t_Base_iterator __first = _Base::begin();\n+\t_Base_iterator __last = _Base::end();\n \tif (__first == __last)\n \t  return;\n-\titerator __next = __first;\n-\twhile (++__next != __last)\n+\t_Base_iterator __next = __first; ++__next;\n+\twhile (__next != __last)\n \t  {\n \t    if (*__first == *__next)\n-\t      erase(__next);\n+\t      __next = _M_erase(__next);\n \t    else\n-\t      __first = __next;\n-\t    __next = __first;\n+\t      __first = __next++;\n \t  }\n       }\n \n       template<class _BinaryPredicate>\n         void\n         unique(_BinaryPredicate __binary_pred)\n         {\n-\t  iterator __first = begin();\n-\t  iterator __last = end();\n+\t  _Base_iterator __first = _Base::begin();\n+\t  _Base_iterator __last = _Base::end();\n \t  if (__first == __last)\n \t    return;\n-\t  iterator __next = __first;\n-\t  while (++__next != __last)\n+\t  _Base_iterator __next = __first; ++__next;\n+\t  while (__next != __last)\n \t    {\n \t      if (__binary_pred(*__first, *__next))\n-\t\terase(__next);\n+\t\t__next = _M_erase(__next);\n \t      else\n-\t\t__first = __next;\n-\t      __next = __first;\n+\t\t__first = __next++;\n \t    }\n \t}\n \n@@ -624,11 +635,7 @@ namespace __debug\n \t  {\n \t    __glibcxx_check_sorted(_Base::begin(), _Base::end());\n \t    __glibcxx_check_sorted(__x.begin().base(), __x.end().base());\n-\t    for (iterator __tmp = __x.begin(); __tmp != __x.end();)\n-\t      {\n-\t\titerator __victim = __tmp++;\n-\t\tthis->_M_transfer_iter(__victim);\n-\t      }\n+\t    this->_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));\n \t    _Base::merge(_GLIBCXX_MOVE(__x._M_base()));\n \t  }\n       }\n@@ -655,11 +662,7 @@ namespace __debug\n \t\t\t\t\t  __comp);\n \t      __glibcxx_check_sorted_pred(__x.begin().base(), __x.end().base(),\n \t\t\t\t\t  __comp);\n-\t      for (iterator __tmp = __x.begin(); __tmp != __x.end();)\n-\t\t{\n-\t\t  iterator __victim = __tmp++;\n-\t\t  this->_M_transfer_iter(__victim);\n-\t\t}\n+\t      this->_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));\n \t      _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp);\n \t    }\n \t}\n@@ -690,9 +693,7 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n "}, {"sha": "79f9b8287d43232a1d15839dfc394511aa2c48fd", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -48,6 +48,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::map<_Key, _Tp, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<map> _Safe_base;\n \n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n     public:\n       // types:\n       typedef _Key                                  key_type;\n@@ -269,31 +272,31 @@ namespace __debug\n       erase(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \treturn iterator(_Base::erase(__position.base()), this);\n       }\n #else\n       void\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \t_Base::erase(__position.base());\n       }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\titerator __victim = find(__x);\n-\tif (__victim == end())\n+\t_Base_iterator __victim = _Base::find(__x);\n+\tif (__victim == _Base::end())\n \t  return 0;\n \telse\n-\t{\n-\t  __victim._M_invalidate();\n-\t  _Base::erase(__victim.base());\n-\t  return 1;\n-\t}\n+\t  {\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim);\n+\t    return 1;\n+\t  }\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -303,9 +306,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n-\treturn iterator(__last.base()._M_const_cast(), this);\n+\tfor (_Base_const_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\treturn iterator(_Base::erase(__first.base(), __last.base()), this);\n       }\n #else\n       void\n@@ -314,8 +324,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n+\tfor (_Base_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\t_Base::erase(__first.base(), __last.base());\n       }\n #endif\n \n@@ -328,7 +346,10 @@ namespace __debug\n \n       void\n       clear()\n-      { this->erase(begin(), end()); }\n+      {\n+\tthis->_M_invalidate_all();\n+\t_Base::clear();\n+      }\n \n       // observers:\n       using _Base::key_comp;"}, {"sha": "58673cc7adf5117c5946de99ef51e12b143cde41", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -49,6 +49,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<multimap> _Safe_base;\n \n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n     public:\n       // types:\n       typedef _Key\t\t\t\t     key_type;\n@@ -59,9 +62,9 @@ namespace __debug\n       typedef typename _Base::reference              reference;\n       typedef typename _Base::const_reference        const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, multimap>\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator, multimap>\n                                                      iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n                                            multimap> const_iterator;\n \n       typedef typename _Base::size_type              size_type;\n@@ -216,7 +219,7 @@ namespace __debug\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       insert(const_iterator __position, const value_type& __x)\n #else\n-      insert(iterator __position, const value_type& __x)\t\n+      insert(iterator __position, const value_type& __x)\n #endif\n       {\n \t__glibcxx_check_insert(__position);\n@@ -250,31 +253,32 @@ namespace __debug\n       erase(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \treturn iterator(_Base::erase(__position.base()), this);\n       }\n #else\n       void\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \t_Base::erase(__position.base());\n       }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n+\tstd::pair<_Base_iterator, _Base_iterator> __victims =\n+\t  _Base::equal_range(__x);\n \tsize_type __count = 0;\n-\twhile (__victims.first != __victims.second)\n-\t{\n-\t  iterator __victim = __victims.first++;\n-\t  __victim._M_invalidate();\n-\t  _Base::erase(__victim.base());\n-\t  ++__count;\n-\t}\n+\t_Base_iterator __victim = __victims.first;\n+\twhile (__victim !=  __victims.second)\n+\t  {\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim++);\n+\t    ++__count;\n+\t  }\n \treturn __count;\n       }\n \n@@ -285,9 +289,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n-\treturn iterator(__last.base()._M_const_cast(), this);\n+\tfor (_Base_const_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\treturn iterator(_Base::erase(__first.base(), __last.base()), this);\n       }\n #else\n       void\n@@ -296,8 +307,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n+\tfor (_Base_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\t_Base::erase(__first.base(), __last.base());\n       }\n #endif\n \n@@ -310,7 +329,10 @@ namespace __debug\n \n       void\n       clear()\n-      { this->erase(begin(), end()); }\n+      {\n+\tthis->_M_invalidate_all();\n+\t_Base::clear();\n+      }\n \n       // observers:\n       using _Base::key_comp;\n@@ -346,7 +368,6 @@ namespace __debug\n       std::pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n \tstd::pair<_Base_iterator, _Base_iterator> __res =\n \t_Base::equal_range(__x);\n \treturn std::make_pair(iterator(__res.first, this),\n@@ -356,9 +377,8 @@ namespace __debug\n       std::pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n-\t_Base::equal_range(__x);\n+\t  _Base::equal_range(__x);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n@@ -373,9 +393,8 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n "}, {"sha": "8462586b844378409b9fce533014e22dae7c1c62", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -48,6 +48,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::multiset<_Key, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<multiset> _Safe_base;\n \n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n     public:\n       // types:\n       typedef _Key\t\t\t\t     key_type;\n@@ -58,9 +61,9 @@ namespace __debug\n       typedef typename _Base::reference\t             reference;\n       typedef typename _Base::const_reference        const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, multiset>\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator, multiset>\n       iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  multiset> const_iterator;\n \n       typedef typename _Base::size_type              size_type;\n@@ -237,31 +240,32 @@ namespace __debug\n       erase(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \treturn iterator(_Base::erase(__position.base()), this);\n       }\n #else\n       void\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \t_Base::erase(__position.base());\n       }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n+\tstd::pair<_Base_iterator, _Base_iterator> __victims =\n+\t  _Base::equal_range(__x);\n \tsize_type __count = 0;\n-\twhile (__victims.first != __victims.second)\n-\t{\n-\t  iterator __victim = __victims.first++;\n-\t  __victim._M_invalidate();\n-\t  _Base::erase(__victim.base());\n-\t  ++__count;\n-\t}\n+\t_Base_iterator __victim = __victims.first;\n+\twhile (__victim != __victims.second)\n+\t  {\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim++);\n+\t    ++__count;\n+\t  }\n \treturn __count;\n       }\n \n@@ -272,9 +276,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n-\treturn __last; // iterator == const_iterator\n+\tfor (_Base_const_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\treturn iterator(_Base::erase(__first.base(), __last.base()), this);\n       }\n #else\n       void\n@@ -283,8 +294,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n+\tfor (_Base_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\t_Base::erase(__first.base(), __last.base());\n       }\n #endif\n \n@@ -297,7 +316,10 @@ namespace __debug\n \n       void\n       clear()\n-      { this->erase(begin(), end()); }\n+      {\n+\tthis->_M_invalidate_all();\n+\t_Base::clear();\n+      }\n \n       // observers:\n       using _Base::key_comp;\n@@ -339,9 +361,8 @@ namespace __debug\n       std::pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n \tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n+\t  _Base::equal_range(__x);\n \treturn std::make_pair(iterator(__res.first, this),\n \t\t\t      iterator(__res.second, this));\n       }\n@@ -351,9 +372,8 @@ namespace __debug\n       std::pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\tstd::pair<_Base_iterator, _Base_iterator> __res =\n-        _Base::equal_range(__x);\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t  _Base::equal_range(__x);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n@@ -368,9 +388,8 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n "}, {"sha": "2ebdd89b58f5a35e5efa850e33097a3930cd15a0", "filename": "libstdc++-v3/include/debug/safe_base.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -137,6 +137,15 @@ namespace __gnu_debug\n \tReturns true if both iterators are nonsingular and reference\n \tthe same sequence. */\n     _GLIBCXX_PURE bool _M_can_compare(const _Safe_iterator_base& __x) const throw ();\n+\n+    /** Invalidate the iterator, making it singular. */\n+    void\n+    _M_invalidate()\n+    { _M_version = 0; }\n+\n+    /** Reset all member variables */\n+    void\n+    _M_reset() throw ();\n   };\n \n   /**\n@@ -214,6 +223,22 @@ namespace __gnu_debug\n     void\n     _M_invalidate_all() const\n     { if (++_M_version == 0) _M_version = 1; }\n+\n+    /** Attach an iterator to this sequence. */\n+    void\n+    _M_attach(_Safe_iterator_base* __it, bool __constant);\n+\n+    /** Likewise but not thread safe. */\n+    void\n+    _M_attach_single(_Safe_iterator_base* __it, bool __constant) throw ();\n+\n+    /** Detach an iterator from this sequence */\n+    void\n+    _M_detach(_Safe_iterator_base* __it);\n+\n+    /** Likewise but not thread safe. */\n+    void\n+    _M_detach_single(_Safe_iterator_base* __it) throw ();\n   };\n } // namespace __gnu_debug\n "}, {"sha": "733a2c6a0a7c4b88264b9e052923eb4dc9a1dbb9", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -47,9 +47,10 @@ namespace __gnu_debug\n     struct _BeforeBeginHelper\n     {\n       typedef typename _Sequence::const_iterator _It;\n+      typedef typename _It::iterator_type _BaseIt;\n \n       static bool\n-      _M_Is(_It __it, const _Sequence* __seq)\n+      _M_Is(_BaseIt __it, const _Sequence* __seq)\n       { return false; }\n     };\n \n@@ -176,7 +177,7 @@ namespace __gnu_debug\n \t\t\t      ._M_iterator(*this, \"this\")\n \t\t\t      ._M_iterator(__x, \"other\"));\n \t_M_current = __x._M_current;\n-\tthis->_M_attach(static_cast<_Sequence*>(__x._M_sequence));\n+\tthis->_M_attach(__x._M_sequence);\n \treturn *this;\n       }\n \n@@ -331,28 +332,18 @@ namespace __gnu_debug\n \n       /** Attach iterator to the given sequence. */\n       void\n-      _M_attach(const _Sequence* __seq)\n+      _M_attach(_Safe_sequence_base* __seq)\n       {\n-\t_Safe_iterator_base::_M_attach(const_cast<_Sequence*>(__seq),\n-\t\t\t\t       _M_constant());\n+\t_Safe_iterator_base::_M_attach(__seq, _M_constant());\n       }\n \n       /** Likewise, but not thread-safe. */\n       void\n-      _M_attach_single(const _Sequence* __seq)\n+      _M_attach_single(_Safe_sequence_base* __seq)\n       {\n-\t_Safe_iterator_base::_M_attach_single(const_cast<_Sequence*>(__seq),\n-\t\t\t\t\t      _M_constant());\n+\t_Safe_iterator_base::_M_attach_single(__seq, _M_constant());\n       }\n \n-      /** Invalidate the iterator, making it singular. */\n-      void\n-      _M_invalidate();\n-\n-      /** Likewise, but not thread-safe. */\n-      void\n-      _M_invalidate_single();\n-\n       /// Is the iterator dereferenceable?\n       bool\n       _M_dereferenceable() const\n@@ -405,31 +396,26 @@ namespace __gnu_debug\n       static std::pair<difference_type, _Distance_precision>\n       _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n \t\t      std::random_access_iterator_tag)\n-      {\n-        return std::make_pair(__rhs.base() - __lhs.base(), __dp_exact);\n-      }\n+      { return std::make_pair(__rhs - __lhs, __dp_exact); }\n \n     template<typename _Iterator1, typename _Iterator2>\n       static std::pair<difference_type, _Distance_precision>\n       _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n \t\t    std::forward_iterator_tag)\n-      {\n-        return std::make_pair(__lhs.base() == __rhs.base()? 0 : 1,\n-\t\t\t      __dp_equality);\n-      }\n+      { return std::make_pair(__lhs == __rhs? 0 : 1, __dp_equality); }\n \n       /// Is this iterator equal to the sequence's begin() iterator?\n       bool _M_is_begin() const\n-      { return *this == _M_get_sequence()->begin(); }\n+      { return base() == _M_get_sequence()->_M_base().begin(); }\n \n       /// Is this iterator equal to the sequence's end() iterator?\n       bool _M_is_end() const\n-      { return *this == _M_get_sequence()->end(); }\n+      { return base() == _M_get_sequence()->_M_base().end(); }\n \n       /// Is this iterator equal to the sequence's before_begin() iterator if\n       /// any?\n       bool _M_is_before_begin() const\n-      { return _BeforeBeginHelper<_Sequence>::_M_Is(*this, _M_get_sequence()); }\n+      { return _BeforeBeginHelper<_Sequence>::_M_Is(base(), _M_get_sequence()); }\n     };\n \n   template<typename _IteratorL, typename _IteratorR, typename _Sequence>"}, {"sha": "fe93c95c59fc5ffdf12e6e2ad88d0dc200781dfc", "filename": "libstdc++-v3/include/debug/safe_iterator.tcc", "status": "modified", "additions": 10, "deletions": 47, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -37,28 +37,27 @@ namespace __gnu_debug\n     _Safe_iterator<_Iterator, _Sequence>::\n     _M_can_advance(const difference_type& __n) const\n     {\n-      typedef typename _Sequence::const_iterator const_iterator;\n+      typedef typename _Sequence::const_iterator const_debug_iterator;\n+      typedef typename const_debug_iterator::iterator_type const_iterator;\n \n       if (this->_M_singular())\n \treturn false;\n       if (__n == 0)\n \treturn true;\n       if (__n < 0)\n \t{\n-\t  const_iterator __begin =\n-\t    static_cast<const _Sequence*>(_M_sequence)->begin();\n+\t  const_iterator __begin = _M_get_sequence()->_M_base().begin();\n \t  std::pair<difference_type, _Distance_precision> __dist =\n-\t    this->_M_get_distance(__begin, *this);\n+\t    this->_M_get_distance(__begin, base());\n \t  bool __ok =  ((__dist.second == __dp_exact && __dist.first >= -__n)\n \t\t\t|| (__dist.second != __dp_exact && __dist.first > 0));\n \t  return __ok;\n \t}\n       else\n \t{\n-\t  const_iterator __end =\n-\t    static_cast<const _Sequence*>(_M_sequence)->end();\n+\t  const_iterator __end = _M_get_sequence()->_M_base().end();\n \t  std::pair<difference_type, _Distance_precision> __dist =\n-\t    this->_M_get_distance(*this, __end);\n+\t    this->_M_get_distance(base(), __end);\n \t  bool __ok = ((__dist.second == __dp_exact && __dist.first >= __n)\n \t\t       || (__dist.second != __dp_exact && __dist.first > 0));\n \t  return __ok;\n@@ -77,7 +76,7 @@ namespace __gnu_debug\n \t/* Determine if we can order the iterators without the help of\n \t   the container */\n \tstd::pair<difference_type, _Distance_precision> __dist =\n-\t  this->_M_get_distance(*this, __rhs);\n+\t  this->_M_get_distance(base(), __rhs.base());\n \tswitch (__dist.second) {\n \tcase __dp_equality:\n \t  if (__dist.first == 0)\n@@ -91,52 +90,16 @@ namespace __gnu_debug\n \n \t/* We can only test for equality, but check if one of the\n \t   iterators is at an extreme. */\n+\t/* Optim for classic [begin, it) or [it, end) ranges, limit checks\n+\t * when code is valid. */\n \tif (_M_is_begin() || __rhs._M_is_end())\n \t  return true;\n-\telse if (_M_is_end() || __rhs._M_is_begin())\n+\tif (_M_is_end() || __rhs._M_is_begin())\n \t  return false;\n \n \t// Assume that this is a valid range; we can't check anything else\n \treturn true;\n       }\n-\n-  template<typename _Iterator, typename _Sequence>\n-    void\n-    _Safe_iterator<_Iterator, _Sequence>::\n-    _M_invalidate()\n-    {\n-      __gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n-      _M_invalidate_single();\n-    }\n-\n-  template<typename _Iterator, typename _Sequence>\n-    void\n-    _Safe_iterator<_Iterator, _Sequence>::\n-    _M_invalidate_single()\n-    {\n-      typedef typename _Sequence::iterator iterator;\n-      typedef typename _Sequence::const_iterator const_iterator;\n-\n-      if (!this->_M_singular())\n-\t{\n-\t  for (_Safe_iterator_base* __iter = _M_sequence->_M_iterators;\n-\t       __iter; __iter = __iter->_M_next)\n-\t    {\n-\t      iterator* __victim = static_cast<iterator*>(__iter);\n-\t      if (this->base() == __victim->base())\n-\t\t__victim->_M_version = 0;\n-\t    }\n-\n-\t  for (_Safe_iterator_base* __iter2 = _M_sequence->_M_const_iterators;\n-\t       __iter2; __iter2 = __iter2->_M_next)\n-\t    {\n-\t      const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n-\t      if (__victim->base() == this->base())\n-\t\t__victim->_M_version = 0;\n-\t    }\n-\t  _M_version = 0;\n-\t}\n-    }\n } // namespace __gnu_debug\n \n #endif"}, {"sha": "843c9b11710e2ae4589fd690a0b7e61ac465216a", "filename": "libstdc++-v3/include/debug/safe_sequence.h", "status": "modified", "additions": 27, "deletions": 73, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -57,6 +57,21 @@ namespace __gnu_debug\n       { return __value != __x; }\n     };\n \n+  /** A simple function object that returns true if the passed-in\n+   *  value is equal to the stored value. */\n+  template <typename _Type>\n+    class _Equal_to\n+    {\n+      _Type __value;\n+\n+    public:\n+      explicit _Equal_to(const _Type& __v) : __value(__v) { }\n+\n+      bool\n+      operator()(const _Type& __x) const\n+      { return __value == __x; }\n+    };\n+\n   /** A function object that returns true when the given random access\n       iterator is at least @c n steps away from the given iterator. */\n   template<typename _Iterator>\n@@ -99,85 +114,24 @@ namespace __gnu_debug\n     public:\n       /** Invalidates all iterators @c x that reference this sequence,\n \t  are not singular, and for which @c pred(x) returns @c\n-\t  true. The user of this routine should be careful not to make\n-\t  copies of the iterators passed to @p pred, as the copies may\n-\t  interfere with the invalidation. */\n+\t  true. @c pred will be invoked with the normal iterators nested\n+\t  in the safe ones. */\n       template<typename _Predicate>\n         void\n         _M_invalidate_if(_Predicate __pred);\n \n-      /** Transfers all iterators that reference this memory location\n-\t  to this sequence from whatever sequence they are attached\n-\t  to. */\n-      template<typename _Iterator>\n+      /** Transfers all iterators @c x that reference @c from sequence,\n+\t  are not singular, and for which @c pred(x) returns @c\n+\t  true. @c pred will be invoked with the normal iterators nested\n+\t  in the safe ones. */\n+      template<typename _Predicate>\n         void\n-        _M_transfer_iter(const _Safe_iterator<_Iterator, _Sequence>& __x);\n+        _M_transfer_from_if(_Safe_sequence& __from, _Predicate __pred);\n     };\n-\n-  template<typename _Sequence>\n-    template<typename _Predicate>\n-      void\n-      _Safe_sequence<_Sequence>::\n-      _M_invalidate_if(_Predicate __pred)\n-      {\n-        typedef typename _Sequence::iterator iterator;\n-        typedef typename _Sequence::const_iterator const_iterator;\n-\n-\t__gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n-        for (_Safe_iterator_base* __iter = _M_iterators; __iter;)\n-\t  {\n-\t    iterator* __victim = static_cast<iterator*>(__iter);\n-\t    __iter = __iter->_M_next;\n-\t    if (!__victim->_M_singular())\n-\t      {\n-\t\tif (__pred(__victim->base()))\n-\t\t  __victim->_M_invalidate_single();\n-\t      }\n-\t  }\n-\n-        for (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n-\t  {\n-\t    const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n-\t    __iter2 = __iter2->_M_next;\n-\t    if (!__victim->_M_singular())\n-\t      {\n-\t\tif (__pred(__victim->base()))\n-\t\t  __victim->_M_invalidate_single();\n-\t      }\n-\t  }\n-      }\n-\n-  template<typename _Sequence>\n-    template<typename _Iterator>\n-      void\n-      _Safe_sequence<_Sequence>::\n-      _M_transfer_iter(const _Safe_iterator<_Iterator, _Sequence>& __x)\n-      {\n-\t_Safe_sequence_base* __from = __x._M_sequence;\n-\tif (!__from)\n-\t  return;\n-\n-        typedef typename _Sequence::iterator iterator;\n-        typedef typename _Sequence::const_iterator const_iterator;\n-\n-\t__gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n-        for (_Safe_iterator_base* __iter = __from->_M_iterators; __iter;)\n-\t  {\n-\t    iterator* __victim = static_cast<iterator*>(__iter);\n-\t    __iter = __iter->_M_next;\n-\t    if (!__victim->_M_singular() && __victim->base() == __x.base())\n-\t      __victim->_M_attach_single(static_cast<_Sequence*>(this));\n-\t  }\n-\n-        for (_Safe_iterator_base* __iter2 = __from->_M_const_iterators; \n-\t     __iter2;)\n-\t  {\n-\t    const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n-\t    __iter2 = __iter2->_M_next;\n-\t    if (!__victim->_M_singular() && __victim->base() == __x.base())\n-\t      __victim->_M_attach_single(static_cast<_Sequence*>(this));\n-\t  }\n-      }\n } // namespace __gnu_debug\n \n+#ifndef _GLIBCXX_EXPORT_TEMPLATE\n+#  include <debug/safe_sequence.tcc>\n+#endif\n+\n #endif"}, {"sha": "bf0295cfd05c560a5b879db21743e5bc453176e5", "filename": "libstdc++-v3/include/debug/safe_sequence.tcc", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.tcc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,150 @@\n+// Safe sequence implementation  -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/safe_sequence.tcc\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_SEQUENCE_TCC\n+#define _GLIBCXX_DEBUG_SAFE_SEQUENCE_TCC 1\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Sequence>\n+    template<typename _Predicate>\n+      void\n+      _Safe_sequence<_Sequence>::\n+      _M_invalidate_if(_Predicate __pred)\n+      {\n+        typedef typename _Sequence::iterator iterator;\n+        typedef typename _Sequence::const_iterator const_iterator;\n+\n+\t__gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n+        for (_Safe_iterator_base* __iter = _M_iterators; __iter;)\n+\t  {\n+\t    iterator* __victim = static_cast<iterator*>(__iter);\n+\t    __iter = __iter->_M_next;\n+\t    if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t      {\n+\t\t__victim->_M_invalidate();\n+\t      }\n+\t  }\n+\n+        for (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n+\t  {\n+\t    const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n+\t    __iter2 = __iter2->_M_next;\n+\t    if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t      {\n+\t\t__victim->_M_invalidate();\n+\t      }\n+\t  }\n+      }\n+\n+  template<typename _Sequence>\n+    template<typename _Predicate>\n+      void\n+      _Safe_sequence<_Sequence>::\n+      _M_transfer_from_if(_Safe_sequence& __from, _Predicate __pred)\n+      {\n+        typedef typename _Sequence::iterator iterator;\n+        typedef typename _Sequence::const_iterator const_iterator;\n+\n+\t_Safe_iterator_base* __transfered_iterators = 0;\n+\t_Safe_iterator_base* __transfered_const_iterators = 0;\n+\t_Safe_iterator_base* __last_iterator = 0;\n+\t_Safe_iterator_base* __last_const_iterator = 0;\n+\t{\n+\t  // We lock __from first and detach iterator(s) to transfer\n+\t  __gnu_cxx::__scoped_lock sentry(__from._M_get_mutex());\n+\n+          for (_Safe_iterator_base* __iter = __from._M_iterators; __iter;)\n+\t    {\n+\t      iterator* __victim = static_cast<iterator*>(__iter);\n+\t      __iter = __iter->_M_next;\n+\t      if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t\t{\n+\t\t  __victim->_M_detach_single();\n+\t\t  if (__transfered_iterators)\n+\t\t    {\n+\t\t      __victim->_M_next = __transfered_iterators;\n+\t\t      __transfered_iterators->_M_prior = __victim;\n+\t\t    }\n+\t\t  else\n+\t\t    __last_iterator = __victim;\n+\t\t  __victim->_M_sequence = this;\n+\t\t  __victim->_M_version = this->_M_version;\n+\t\t  __transfered_iterators = __victim;\n+\t\t}\n+\t    }\n+\n+\t  for (_Safe_iterator_base* __iter2 = __from._M_const_iterators;\n+\t\t __iter2;)\n+\t    {\n+\t      const_iterator* __victim = static_cast<const_iterator*>(__iter2);\n+\t      __iter2 = __iter2->_M_next;\n+\t      if (!__victim->_M_singular() && __pred(__victim->base()))\n+\t\t{\n+\t\t  __victim->_M_detach_single();\n+\t\t  if (__transfered_const_iterators)\n+\t\t    {\n+\t\t      __victim->_M_next = __transfered_const_iterators;\n+\t\t      __transfered_const_iterators->_M_prior = __victim;\n+\t\t    }\n+\t\t  else\n+\t\t    __last_const_iterator = __victim;\n+\t\t  __victim->_M_sequence = this;\n+\t\t  __victim->_M_version = this->_M_version;\n+\t\t  __transfered_const_iterators = __victim;\n+\t\t}\n+\t    }\n+\t}\n+\n+\t// Now we can lock *this and add the transfered iterators if any\n+\tif (__last_iterator || __last_const_iterator)\n+\t  {\n+\t    __gnu_cxx::__scoped_lock sentry(this->_M_get_mutex());\n+\t    if (__last_iterator)\n+\t      {\n+\t\tif (this->_M_iterators)\n+\t\t  {\n+\t\t    this->_M_iterators->_M_prior = __last_iterator;\n+\t\t    __last_iterator->_M_next = this->_M_iterators;\n+\t\t  }\n+\t\tthis->_M_iterators = __transfered_iterators;\n+\t      }\n+\t    if (__last_const_iterator)\n+\t      {\n+\t\tif (this->_M_const_iterators)\n+\t\t  {\n+\t\t    this->_M_const_iterators->_M_prior = __last_const_iterator;\n+\t\t    __last_const_iterator->_M_next = this->_M_const_iterators;\n+\t\t  }\n+\t\tthis->_M_const_iterators = __transfered_const_iterators;\n+\t      }\n+\t  }\n+      }\n+} // namespace __gnu_debug\n+\n+#endif"}, {"sha": "60fbd38f26b910ba7649803051456bc58cbd5f5a", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -48,6 +48,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::set<_Key, _Compare, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<set> _Safe_base;\n \n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n     public:\n       // types:\n       typedef _Key\t\t\t\t    key_type;\n@@ -58,9 +61,9 @@ namespace __debug\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, set>\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator, set>\n                                                     iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, set>\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator, set>\n                                                     const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n@@ -193,7 +196,6 @@ namespace __debug\n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n \tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n \treturn std::pair<iterator, bool>(iterator(__res.first, this),\n \t\t\t\t\t __res.second);\n@@ -248,31 +250,31 @@ namespace __debug\n       erase(const_iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \treturn iterator(_Base::erase(__position.base()), this);\n       }\n #else\n       void\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\t__position._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__position.base()));\n \t_Base::erase(__position.base());\n       }\n #endif\n \n       size_type\n       erase(const key_type& __x)\n       {\n-\titerator __victim = find(__x);\n-\tif (__victim == end())\n+\t_Base_iterator __victim = _Base::find(__x);\n+\tif (__victim == _Base::end())\n           return 0;\n \telse\n-        {\n-\t  __victim._M_invalidate();\n-\t  _Base::erase(__victim.base());\n-\t  return 1;\n-        }\n+\t  {\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim);\n+\t    return 1;\n+\t  }\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -282,9 +284,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n-\treturn __last; // iterator == const_iterator\n+\tfor (_Base_const_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\treturn iterator(_Base::erase(__first.base(), __last.base()), this);\n       }\n #else\n       void\n@@ -293,8 +302,16 @@ namespace __debug\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n-\twhile (__first != __last)\n-\t  this->erase(__first++);\n+\tfor (_Base_iterator __victim = __first.base();\n+\t     __victim != __last.base(); ++__victim)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t  }\n+\t_Base::erase(__first.base(), __last.base());\n       }\n #endif\n \n@@ -307,7 +324,10 @@ namespace __debug\n \n       void\n       clear()\n-      { this->erase(begin(), end()); }\n+      {\n+\tthis->_M_invalidate_all();\n+\t_Base::clear();\n+      }\n \n       // observers:\n       using _Base::key_comp;\n@@ -349,7 +369,6 @@ namespace __debug\n       std::pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n \tstd::pair<_Base_iterator, _Base_iterator> __res =\n         _Base::equal_range(__x);\n \treturn std::make_pair(iterator(__res.first, this),\n@@ -361,7 +380,6 @@ namespace __debug\n       std::pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n \tstd::pair<_Base_iterator, _Base_iterator> __res =\n         _Base::equal_range(__x);\n \treturn std::make_pair(const_iterator(__res.first, this),\n@@ -378,7 +396,6 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n \tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n       }"}, {"sha": "29484c1ccdc50dfe893ff5c898ce38c394b79fd4", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -55,6 +55,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::unordered_map<_Key, _Tp, _Hash,\n \t\t\t\t\t    _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_map> _Safe_base;\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -65,9 +68,9 @@ namespace __debug\n       typedef typename _Base::key_type        key_type;\n       typedef typename _Base::value_type      value_type;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n \t\t\t\t\t  unordered_map> iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_map> const_iterator;\n \n       explicit\n@@ -177,17 +180,14 @@ namespace __debug\n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(__obj);\n+\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__obj);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n \n       iterator\n       insert(const_iterator, const value_type& __obj)\n       {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(__obj);\n-\treturn iterator(__res.first, this);\n+\treturn iterator(_Base::insert(__obj).first, this);\n       }\n \n       template<typename _Pair, typename = typename\n@@ -196,8 +196,8 @@ namespace __debug\n         std::pair<iterator, bool>\n         insert(_Pair&& __obj)\n         {\n-\t  typedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t  __pair_type __res = _Base::insert(std::forward<_Pair>(__obj));\n+\t  std::pair<_Base_iterator, bool> __res =\n+\t    _Base::insert(std::forward<_Pair>(__obj));\n \t  return std::make_pair(iterator(__res.first, this), __res.second);\n \t}\n \n@@ -207,9 +207,8 @@ namespace __debug\n         iterator\n         insert(const_iterator, _Pair&& __obj)\n         {\n-\t  typedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t  __pair_type __res = _Base::insert(std::forward<_Pair>(__obj));\n-\t  return iterator(__res.first, this);\n+\t  return iterator(_Base::insert(std::forward<_Pair>(__obj)).first,\n+\t\t\t  this);\n \t}\n \n       void\n@@ -236,19 +235,17 @@ namespace __debug\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+\t  _Base::equal_range(__key);\n \treturn std::make_pair(iterator(__res.first, this),\n \t\t\t      iterator(__res.second, this));\n       }\n \n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t  _Base::equal_range(__key);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n@@ -257,10 +254,11 @@ namespace __debug\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\titerator __victim(_Base::find(__key), this);\n-\tif (__victim != end())\n+\t_Base_iterator __victim(_Base::find(__key));\n+\tif (__victim != _Base::end())\n \t  {\n-\t    this->erase(__victim);\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -270,19 +268,23 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__it.base()));\n \treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (const_iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  const_iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n+\tfor (_Base_const_iterator __tmp = __first.base();\n+\t     __tmp != __last.base(); ++__tmp)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t  }\n \treturn iterator(_Base::erase(__first.base(),\n \t\t\t\t     __last.base()), this);\n       }\n@@ -297,9 +299,8 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n \n@@ -339,6 +340,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::unordered_multimap<_Key, _Tp, _Hash,\n \t\t\t\t\t\t _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_multimap> _Safe_base;\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -349,9 +353,9 @@ namespace __debug\n       typedef typename _Base::key_type        key_type;\n       typedef typename _Base::value_type      value_type;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n \t\t\t\t\t  unordered_multimap> iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_multimap> const_iterator;\n \n       explicit\n@@ -476,9 +480,9 @@ namespace __debug\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_convertible<_Pair,\n \t\t\t\t\t\t  value_type>::value>::type>\n-        iterator\n-        insert(const_iterator, _Pair&& __obj)\n-        { return iterator(_Base::insert(std::forward<_Pair>(__obj)), this); }\n+\titerator\n+\tinsert(const_iterator, _Pair&& __obj)\n+\t{ return iterator(_Base::insert(std::forward<_Pair>(__obj)), this); }\n \n       void\n       insert(std::initializer_list<value_type> __l)\n@@ -504,19 +508,17 @@ namespace __debug\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+\t  _Base::equal_range(__key);\n \treturn std::make_pair(iterator(__res.first, this),\n \t\t\t      iterator(__res.second, this));\n       }\n \n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t  _Base::equal_range(__key);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n@@ -525,10 +527,11 @@ namespace __debug\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\titerator __victim(_Base::find(__key), this);\n-\tif (__victim != end())\n+\t_Base_iterator __victim(_Base::find(__key));\n+\tif (__victim != _Base::end())\n \t  {\n-\t    this->erase(__victim);\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -538,19 +541,23 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__it.base()));\n \treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (const_iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  const_iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n+\tfor (_Base_const_iterator __tmp = __first.base();\n+\t     __tmp != __last.base(); ++__tmp)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t  }\n \treturn iterator(_Base::erase(__first.base(),\n \t\t\t\t     __last.base()), this);\n       }\n@@ -565,9 +572,8 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n "}, {"sha": "a606efec26f420efe7d1898104e55ed8cda89573", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -55,6 +55,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::unordered_set<_Value, _Hash,\n \t\t\t\t\t    _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_set> _Safe_base;\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -65,9 +68,9 @@ namespace __debug\n       typedef typename _Base::key_type        key_type;\n       typedef typename _Base::value_type      value_type;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n \t\t\t\t\t  unordered_set> iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_set> const_iterator;\n \n       explicit\n@@ -177,15 +180,15 @@ namespace __debug\n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\ttypedef std::pair<_Base_iterator, bool> __pair_type;\n \t__pair_type __res = _Base::insert(__obj);\n \treturn std::make_pair(iterator(__res.first, this), __res.second);\n       }\n \n       iterator\n       insert(const_iterator, const value_type& __obj)\n       {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\ttypedef std::pair<_Base_iterator, bool> __pair_type;\n \t__pair_type __res = _Base::insert(__obj);\n \treturn iterator(__res.first, this);\n       }\n@@ -230,7 +233,6 @@ namespace __debug\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n \ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n \t__pair_type __res = _Base::equal_range(__key);\n \treturn std::make_pair(iterator(__res.first, this),\n@@ -240,9 +242,8 @@ namespace __debug\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator>\n+\t  __res = _Base::equal_range(__key);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n@@ -251,10 +252,11 @@ namespace __debug\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\titerator __victim(_Base::find(__key), this);\n-\tif (__victim != end())\n+\t_Base_iterator __victim(_Base::find(__key));\n+\tif (__victim != _Base::end())\n \t  {\n-\t    this->erase(__victim);\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -264,19 +266,23 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__it.base()));\n \treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (const_iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  const_iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n+\tfor (_Base_const_iterator __tmp = __first.base();\n+\t     __tmp != __last.base(); ++__tmp)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t  }\n \treturn iterator(_Base::erase(__first.base(),\n \t\t\t\t     __last.base()), this);\n       }\n@@ -291,9 +297,8 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n \n@@ -329,6 +334,9 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::unordered_multiset<_Value, _Hash,\n \t\t\t\t\t\t _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_multiset> _Safe_base;\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef typename _Base::iterator _Base_iterator;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n     public:\n       typedef typename _Base::size_type       size_type;\n@@ -339,9 +347,9 @@ namespace __debug\n       typedef typename _Base::key_type        key_type;\n       typedef typename _Base::value_type      value_type;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,\n \t\t\t\t\t  unordered_multiset> iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,\n \t\t\t\t\t  unordered_multiset> const_iterator;\n \n       explicit\n@@ -488,7 +496,6 @@ namespace __debug\n       std::pair<iterator, iterator>\n       equal_range(const key_type& __key)\n       {\n-\ttypedef typename _Base::iterator _Base_iterator;\n \ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n \t__pair_type __res = _Base::equal_range(__key);\n \treturn std::make_pair(iterator(__res.first, this),\n@@ -498,9 +505,8 @@ namespace __debug\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __key) const\n       {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator>\n+\t  __res = _Base::equal_range(__key);\n \treturn std::make_pair(const_iterator(__res.first, this),\n \t\t\t      const_iterator(__res.second, this));\n       }\n@@ -509,10 +515,11 @@ namespace __debug\n       erase(const key_type& __key)\n       {\n \tsize_type __ret(0);\n-\titerator __victim(_Base::find(__key), this);\n-\tif (__victim != end())\n+\t_Base_iterator __victim(_Base::find(__key));\n+\tif (__victim != _Base::end())\n \t  {\n-\t    this->erase(__victim);\n+\t    this->_M_invalidate_if(_Equal(__victim));\n+\t    _Base::erase(__victim);\n \t    __ret = 1;\n \t  }\n \treturn __ret;\n@@ -522,19 +529,23 @@ namespace __debug\n       erase(const_iterator __it)\n       {\n \t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(__it.base()));\n \treturn iterator(_Base::erase(__it.base()), this);\n       }\n \n       iterator\n       erase(const_iterator __first, const_iterator __last)\n       {\n \t__glibcxx_check_erase_range(__first, __last);\n-\tfor (const_iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  const_iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n+\tfor (_Base_const_iterator __tmp = __first.base();\n+\t     __tmp != __last.base(); ++__tmp)\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),\n+\t\t\t\t  _M_message(__gnu_debug::__msg_valid_range)\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    this->_M_invalidate_if(_Equal(__tmp));\n+\t  }\n \treturn iterator(_Base::erase(__first.base(),\n \t\t\t\t     __last.base()), this);\n       }\n@@ -549,9 +560,8 @@ namespace __debug\n       void\n       _M_invalidate_all()\n       {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_Base::end()));\n       }\n     };\n "}, {"sha": "322c170289a89f123abe1b550bef6ef23df81466", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -49,16 +49,17 @@ namespace __debug\n       typedef _GLIBCXX_STD_D::vector<_Tp, _Allocator> _Base;\n       typedef __gnu_debug::_Safe_sequence<vector>              _Safe_base;\n \n+      typedef typename _Base::iterator _Base_iterator;\n       typedef typename _Base::const_iterator _Base_const_iterator;\n-      typedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n+      typedef __gnu_debug::_Equal_to<_Base_const_iterator> _Equal;\n \n     public:\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,vector>\n+      typedef __gnu_debug::_Safe_iterator<_Base_iterator,vector>\n       iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,vector>\n+      typedef __gnu_debug::_Safe_iterator<_Base_const_iterator,vector>\n       const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n@@ -246,7 +247,7 @@ namespace __debug\n       {\n \tbool __realloc = _M_requires_reallocation(__sz);\n \tif (__sz < this->size())\n-\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__sz);\n \t_Base::resize(__sz);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n@@ -258,7 +259,7 @@ namespace __debug\n       {\n \tbool __realloc = _M_requires_reallocation(__sz);\n \tif (__sz < this->size())\n-\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__sz);\n \t_Base::resize(__sz, __c);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n@@ -270,7 +271,7 @@ namespace __debug\n       {\n \tbool __realloc = _M_requires_reallocation(__sz);\n \tif (__sz < this->size())\n-\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__sz);\n \t_Base::resize(__sz, __c);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n@@ -388,8 +389,7 @@ namespace __debug\n       pop_back()\n       {\n \t__glibcxx_check_nonempty();\n-\titerator __victim = end() - 1;\n-\t__victim._M_invalidate();\n+\tthis->_M_invalidate_if(_Equal(--_Base::end()));\n \t_Base::pop_back();\n       }\n \n@@ -400,13 +400,13 @@ namespace __debug\n \t{\n \t  __glibcxx_check_insert(__position);\n \t  bool __realloc = _M_requires_reallocation(this->size() + 1);\n-\t  difference_type __offset = __position - begin();\n-\t  typename _Base::iterator __res = _Base::emplace(__position.base(),\n-\t\t\t\t\t    std::forward<_Args>(__args)...);\n+\t  difference_type __offset = __position.base() - _Base::begin();\n+\t  _Base_iterator __res = _Base::emplace(__position.base(),\n+\t\t\t\t\t\tstd::forward<_Args>(__args)...);\n \t  if (__realloc)\n \t    this->_M_invalidate_all();\n \t  else\n-\t    this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t    this->_M_invalidate_after_nth(__offset);\n \t  _M_update_guaranteed_capacity();\n \t  return iterator(__res, this);\n \t}\n@@ -417,12 +417,12 @@ namespace __debug\n       {\n \t__glibcxx_check_insert(__position);\n \tbool __realloc = _M_requires_reallocation(this->size() + 1);\n-\tdifference_type __offset = __position - begin();\n-\ttypename _Base::iterator __res = _Base::insert(__position.base(),__x);\n+\tdifference_type __offset = __position.base() - _Base::begin();\n+\t_Base_iterator __res = _Base::insert(__position.base(), __x);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n \telse\n-\t  this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__offset);\n \t_M_update_guaranteed_capacity();\n \treturn iterator(__res, this);\n       }\n@@ -444,12 +444,12 @@ namespace __debug\n       {\n \t__glibcxx_check_insert(__position);\n \tbool __realloc = _M_requires_reallocation(this->size() + __n);\n-\tdifference_type __offset = __position - begin();\n+\tdifference_type __offset = __position.base() - _Base::begin();\n \t_Base::insert(__position.base(), __n, __x);\n \tif (__realloc)\n \t  this->_M_invalidate_all();\n \telse\n-\t  this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t  this->_M_invalidate_after_nth(__offset);\n \t_M_update_guaranteed_capacity();\n       }\n \n@@ -463,25 +463,25 @@ namespace __debug\n \t  /* Hard to guess if invalidation will occur, because __last\n \t     - __first can't be calculated in all cases, so we just\n \t     punt here by checking if it did occur. */\n-\t  typename _Base::iterator __old_begin = _M_base().begin();\n-\t  difference_type __offset = __position - begin();\n+\t  _Base_iterator __old_begin = _M_base().begin();\n+\t  difference_type __offset = __position.base() - _Base::begin();\n \t  _Base::insert(__position.base(), __gnu_debug::__base(__first),\n \t\t\t\t\t   __gnu_debug::__base(__last));\n \n \t  if (_M_base().begin() != __old_begin)\n \t    this->_M_invalidate_all();\n \t  else\n-\t    this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t    this->_M_invalidate_after_nth(__offset);\n \t  _M_update_guaranteed_capacity();\n \t}\n \n       iterator\n       erase(iterator __position)\n       {\n \t__glibcxx_check_erase(__position);\n-\tdifference_type __offset = __position - begin();\n-\ttypename _Base::iterator __res = _Base::erase(__position.base());\n-\tthis->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\tdifference_type __offset = __position.base() - _Base::begin();\n+\t_Base_iterator __res = _Base::erase(__position.base());\n+\tthis->_M_invalidate_after_nth(__offset);\n \treturn iterator(__res, this);\n       }\n \n@@ -492,10 +492,10 @@ namespace __debug\n \t// 151. can't currently clear() empty container\n \t__glibcxx_check_erase_range(__first, __last);\n \n-\tdifference_type __offset = __first - begin();\n-\ttypename _Base::iterator __res = _Base::erase(__first.base(),\n-\t\t\t\t\t\t\t __last.base());\n-\tthis->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\tdifference_type __offset = __first.base() - _Base::begin();\n+\t_Base_iterator __res = _Base::erase(__first.base(),\n+\t\t\t\t\t\t      __last.base());\n+\tthis->_M_invalidate_after_nth(__offset);\n \treturn iterator(__res, this);\n       }\n \n@@ -534,6 +534,13 @@ namespace __debug\n \tif (this->size() > _M_guaranteed_capacity)\n \t  _M_guaranteed_capacity = this->size();\n       }\n+\n+      void\n+      _M_invalidate_after_nth(difference_type __n)\n+      {\n+\ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n+\tthis->_M_invalidate_if(_After_nth(__n, _Base::begin()));\n+      }\n     };\n \n   template<typename _Tp, typename _Alloc>"}, {"sha": "28a924e9f41f699f4b8e7ecc82cf50929a586fa2", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -349,6 +349,11 @@ future.lo: future.cc\n future.o: future.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+debug.lo: debug.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+debug.o: debug.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n if GLIBCXX_LDBL_COMPAT\n # Use special rules for compatibility-ldbl.cc compilation, as we need to\n # pass -mlong-double-64."}, {"sha": "fe38f37afcd99af7ab20c6aee2b0078b6fc80be6", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -925,6 +925,11 @@ future.lo: future.cc\n future.o: future.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+debug.lo: debug.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+debug.o: debug.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n # Use special rules for compatibility-ldbl.cc compilation, as we need to\n # pass -mlong-double-64.\n @GLIBCXX_LDBL_COMPAT_TRUE@compatibility-ldbl.lo: compatibility-ldbl.cc"}, {"sha": "188495a3ea8fb14847e6cee4499eb02b0dd941a6", "filename": "libstdc++-v3/src/debug.cc", "status": "modified", "additions": 119, "deletions": 49, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -32,16 +32,40 @@\n #include <cctype>\n #include <cstdio>\n #include <cstdlib>\n+#include <functional>\n \n using namespace std;\n \n namespace\n {\n+  /** Returns different instances of __mutex depending on the passed address\n+   *  in order to limit contention without breaking current library binary\n+   *  compatibility. */\n   __gnu_cxx::__mutex&\n-  get_safe_base_mutex()\n+  get_safe_base_mutex(void* __address)\n   {\n-    static __gnu_cxx::__mutex safe_base_mutex;\n-    return safe_base_mutex;\n+    const size_t mask = 0xf;\n+    static __gnu_cxx::__mutex safe_base_mutex[mask + 1];\n+    const size_t index = _Hash_impl::hash(__address) & mask;\n+    return safe_base_mutex[index];\n+  }\n+\n+  void\n+  swap_seq(__gnu_debug::_Safe_sequence_base& __lhs,\n+\t   __gnu_debug::_Safe_sequence_base& __rhs)\n+  {\n+    swap(__lhs._M_iterators, __rhs._M_iterators);\n+    swap(__lhs._M_const_iterators, __rhs._M_const_iterators);\n+    swap(__lhs._M_version, __rhs._M_version);\n+    __gnu_debug::_Safe_iterator_base* __iter;\n+    for (__iter = __rhs._M_iterators; __iter; __iter = __iter->_M_next)\n+      __iter->_M_sequence = &__rhs;\n+    for (__iter = __lhs._M_iterators; __iter; __iter = __iter->_M_next)\n+      __iter->_M_sequence = &__lhs;\n+    for (__iter = __rhs._M_const_iterators; __iter; __iter = __iter->_M_next)\n+      __iter->_M_sequence = &__rhs;\n+    for (__iter = __lhs._M_const_iterators; __iter; __iter = __iter->_M_next)\n+      __iter->_M_sequence = &__lhs;\n   }\n } // anonymous namespace\n \n@@ -122,15 +146,17 @@ namespace __gnu_debug\n       {\n \t_Safe_iterator_base* __old = __iter;\n \t__iter = __iter->_M_next;\n-\t__old->_M_detach_single();\n+\t__old->_M_reset();\n       }\n+    _M_iterators = 0;\n     \n     for (_Safe_iterator_base* __iter2 = _M_const_iterators; __iter2;)\n       {\n \t_Safe_iterator_base* __old = __iter2;\n \t__iter2 = __iter2->_M_next;\n-\t__old->_M_detach_single();\n+\t__old->_M_reset();\n       }\n+    _M_const_iterators = 0;\n   }\n \n   void\n@@ -173,32 +199,88 @@ namespace __gnu_debug\n   _Safe_sequence_base::\n   _M_swap(_Safe_sequence_base& __x)\n   {\n-    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n-    swap(_M_iterators, __x._M_iterators);\n-    swap(_M_const_iterators, __x._M_const_iterators);\n-    swap(_M_version, __x._M_version);\n-    _Safe_iterator_base* __iter;\n-    for (__iter = _M_iterators; __iter; __iter = __iter->_M_next)\n-      __iter->_M_sequence = this;\n-    for (__iter = __x._M_iterators; __iter; __iter = __iter->_M_next)\n-      __iter->_M_sequence = &__x;\n-    for (__iter = _M_const_iterators; __iter; __iter = __iter->_M_next)\n-      __iter->_M_sequence = this;\n-    for (__iter = __x._M_const_iterators; __iter; __iter = __iter->_M_next)\n-      __iter->_M_sequence = &__x;\n+    // We need to lock both sequences to swap\n+    using namespace __gnu_cxx;\n+    __mutex *__this_mutex = &_M_get_mutex();\n+    __mutex *__x_mutex = &__x._M_get_mutex();\n+    if (__this_mutex == __x_mutex)\n+      {\n+\t__scoped_lock __lock(*__this_mutex);\n+\tswap_seq(*this, __x);\n+      }\n+    else\n+      {\n+\t__scoped_lock __l1(__this_mutex < __x_mutex\n+\t\t\t     ? *__this_mutex : *__x_mutex);\n+\t__scoped_lock __l2(__this_mutex < __x_mutex\n+\t\t\t     ? *__x_mutex : *__this_mutex);\n+\tswap_seq(*this, __x);\n+      }\n   }\n \n   __gnu_cxx::__mutex&\n   _Safe_sequence_base::\n   _M_get_mutex() throw ()\n-  { return get_safe_base_mutex(); }\n+  { return get_safe_base_mutex(this); }\n+\n+  void\n+  _Safe_sequence_base::\n+  _M_attach(_Safe_iterator_base* __it, bool __constant)\n+  {\n+    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n+    _M_attach_single(__it, __constant);\n+  }\n+\n+  void\n+  _Safe_sequence_base::\n+  _M_attach_single(_Safe_iterator_base* __it, bool __constant) throw ()\n+  {\n+    _Safe_iterator_base*& __its =\n+      __constant ? _M_const_iterators : _M_iterators;\n+    __it->_M_next = __its;\n+    if (__it->_M_next)\n+      __it->_M_next->_M_prior = __it;\n+    __its = __it;\n+  }\n+\n+  void\n+  _Safe_sequence_base::\n+  _M_detach(_Safe_iterator_base* __it)\n+  {\n+    // Remove __it from this sequence's list\n+    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n+    _M_detach_single(__it);\n+  }\n+\n+  void\n+  _Safe_sequence_base::\n+  _M_detach_single(_Safe_iterator_base* __it) throw ()\n+  {\n+    // Remove __it from this sequence's list\n+    if (__it->_M_prior)\n+      __it->_M_prior->_M_next = __it->_M_next;\n+    if (__it->_M_next)\n+      __it->_M_next->_M_prior = __it->_M_prior;\n+\t\n+    if (_M_const_iterators == __it)\n+      _M_const_iterators = __it->_M_next;\n+    if (_M_iterators == __it)\n+      _M_iterators = __it->_M_next;\n+  }\n \n   void\n   _Safe_iterator_base::\n   _M_attach(_Safe_sequence_base* __seq, bool __constant)\n   {\n-    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n-    _M_attach_single(__seq, __constant);\n+    _M_detach();\n+    \n+    // Attach to the new sequence (if there is one)\n+    if (__seq)\n+      {\n+\t_M_sequence = __seq;\n+\t_M_version = _M_sequence->_M_version;\n+\t_M_sequence->_M_attach(this, __constant);\n+      }\n   }\n   \n   void\n@@ -212,30 +294,20 @@ namespace __gnu_debug\n       {\n \t_M_sequence = __seq;\n \t_M_version = _M_sequence->_M_version;\n-\t_M_prior = 0;\n-\tif (__constant)\n-\t  {\n-\t    _M_next = _M_sequence->_M_const_iterators;\n-\t    if (_M_next)\n-\t      _M_next->_M_prior = this;\n-\t    _M_sequence->_M_const_iterators = this;\n-\t  }\n-\telse\n-\t  {\n-\t    _M_next = _M_sequence->_M_iterators;\n-\t    if (_M_next)\n-\t      _M_next->_M_prior = this;\n-\t    _M_sequence->_M_iterators = this;\n-\t  }\n+\t_M_sequence->_M_attach_single(this, __constant);\n       }\n   }\n \n   void\n   _Safe_iterator_base::\n   _M_detach()\n   {\n-    __gnu_cxx::__scoped_lock sentry(_M_get_mutex());\n-    _M_detach_single();\n+    if (_M_sequence)\n+      {\n+\t_M_sequence->_M_detach(this);\n+      }\n+\n+    _M_reset();\n   }\n \n   void\n@@ -244,18 +316,16 @@ namespace __gnu_debug\n   {\n     if (_M_sequence)\n       {\n-\t// Remove us from this sequence's list\n-\tif (_M_prior) \n-\t  _M_prior->_M_next = _M_next;\n-\tif (_M_next)  \n-\t  _M_next->_M_prior = _M_prior;\n-\t\n-\tif (_M_sequence->_M_const_iterators == this)\n-\t  _M_sequence->_M_const_iterators = _M_next;\n-\tif (_M_sequence->_M_iterators == this)\n-\t  _M_sequence->_M_iterators = _M_next;\n+\t_M_sequence->_M_detach_single(this);\n       }\n \n+    _M_reset();\n+  }\n+\n+  void\n+  _Safe_iterator_base::\n+  _M_reset() throw ()\n+  {\n     _M_sequence = 0;\n     _M_version = 0;\n     _M_prior = 0;\n@@ -278,7 +348,7 @@ namespace __gnu_debug\n   __gnu_cxx::__mutex&\n   _Safe_iterator_base::\n   _M_get_mutex() throw ()\n-  { return get_safe_base_mutex(); }\n+  { return get_safe_base_mutex(_M_sequence); }\n \n   void\n   _Error_formatter::_Parameter::"}, {"sha": "23ea900b87d73db2a1b37650efc33a981ddc48cc", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/clear.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fclear.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fclear.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fclear.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Check that iterators ownership is correctly manage on swap.\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::forward_list<int> fl{1, 2, 3};\n+\n+  auto before = fl.before_begin();\n+  auto end = fl.end();\n+  fl.clear();\n+\n+  VERIFY( end == fl.end() );\n+  VERIFY( before == fl.before_begin() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4a93666b224c860dabef66c378900ce5313ab4af", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/move_constructor.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_constructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_constructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fmove_constructor.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Check that iterators ownership is correctly manage on swap.\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::forward_list<int> fl1{1, 3, 5};\n+\n+  auto flit = fl1.before_begin();\n+  std::forward_list<int> fl2(std::move(fl1));\n+\n+#if !_GLIBCXX_DEBUG\n+  VERIFY( flit == fl1.before_begin() );\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "60297551dcd0472d5a23258ab3cf4d7aacee7a6e", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/splice_after.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Check that iterators ownership is correctly manage on swap.\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{4, 5, 6};\n+\n+  auto before = fl1.before_begin();\n+  auto end = fl1.end();\n+  fl2.splice_after(fl2.before_begin(), std::move(fl1));\n+\n+  VERIFY( before == fl1.before_begin() );\n+  VERIFY( end == fl1.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3ee7f689aeb656aad9c119803296ecd8ca99db08", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/splice_after1.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after1.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  fl1.splice_after(fl1.begin(), std::move(fl1));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6a7fcfb22c2f62438fa328ea62f0977ea0dd43b1", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/splice_after2.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after2.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{1, 2, 3};\n+\n+  fl1.splice_after(fl1.before_begin(), std::move(fl2), fl1.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "55e50dc0511ff7b2c69f3e144328416ef65a706e", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/splice_after3.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after3.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{1, 2, 3};\n+\n+  fl1.splice_after(fl1.before_begin(), std::move(fl2), fl2.end());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4c161906e0acaf8b62388c34842744dbc61d4754", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/splice_after4.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fsplice_after4.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{1, 2, 3};\n+\n+  fl1.splice_after(fl1.before_begin(),\n+\t\t   std::move(fl2), ++(++fl2.begin()), ++fl2.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0105791bedce7996e883d0b913a94b57285125a1", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/swap.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Fswap.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,83 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Check that iterators ownership is correctly manage on swap.\n+#include <vector>\n+#include <forward_list>\n+#include <iostream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::forward_list<int> fl1{1, 3, 5};\n+  std::forward_list<int> fl2{2, 4, 6};\n+\n+  std::vector<std::forward_list<int>::iterator> fl1_its;\n+  fl1_its.push_back(fl1.before_begin());\n+  for (std::forward_list<int>::iterator it = fl1.begin();\n+       it != fl1.end(); ++it)\n+    {\n+      fl1_its.push_back(it);\n+    }\n+  fl1_its.push_back(fl1.end());\n+\n+  std::vector<std::forward_list<int>::iterator> fl2_its;\n+  fl2_its.push_back(fl2.before_begin());\n+  for (std::forward_list<int>::iterator it = fl2.begin();\n+       it != fl2.end(); ++it)\n+    {\n+      fl2_its.push_back(it);\n+    }\n+  fl2_its.push_back(fl2.end());\n+\n+  fl1.swap(fl2);\n+\n+  auto fit = fl1.before_begin();\n+  // before-begin iterator is not transfered:\n+  // TODO: Validate with LWG group how before begin should be\n+  // treated.\n+#if !_GLIBCXX_DEBUG\n+  VERIFY( fit == fl1_its[0] );\n+#endif\n+  // All others are, even paste-the-end one:\n+  for (size_t i = 1; i != fl2_its.size(); ++i)\n+  {\n+    VERIFY( ++fit == fl2_its[i] );\n+  }\n+\n+  fit = fl2.before_begin();\n+  // TODO: Validate with LWG group how before begin should be\n+  // treated.\n+#if !_GLIBCXX_DEBUG\n+  VERIFY( fit == fl2_its[0] );\n+#endif\n+  for (size_t i = 1; i != fl1_its.size(); ++i)\n+  {\n+    VERIFY( ++fit == fl1_its[i] );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b2a50aa21c8a8485169e4d41858ed6f37fd8da18", "filename": "libstdc++-v3/testsuite/23_containers/vector/debug/multithreaded_swap.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdebug%2Fmultithreaded_swap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe96d415d8a08ec2f428bdea0cfaa88207e4b6e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdebug%2Fmultithreaded_swap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fdebug%2Fmultithreaded_swap.cc?ref=afe96d415d8a08ec2f428bdea0cfaa88207e4b6e", "patch": "@@ -0,0 +1,100 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-debug-mode \"\" }\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+// This test check for potential deadlock when swaping sequences in debug\n+// mode as it requires acquiring 2 locks at the same time.\n+\n+#include <vector>\n+#include <thread>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+// The following function mimic the one in src/debug.cc to associate a mutex\n+// to a given safe sequence instance.\n+size_t\n+get_index(std::vector<int>& v)\n+{\n+  const size_t mask = 0xf;\n+  // We have to check the address of the internal safe sequence that starts\n+  // after the normal vector memory footprint that is to say a 3 pointers\n+  // offset:\n+  void* __address = reinterpret_cast<char*>(&v) + 3 * sizeof(void*);\n+  return std::_Hash_impl::hash(__address) & mask;\n+}\n+\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+  vector<int> v1, v2;\n+  vector<shared_ptr<vector<int> > > vs;\n+  vector<int> *pv3 = 0, *pv4 = 0;\n+  const int nb_attempts = 100;\n+  for (int i = 0; i != nb_attempts; ++i)\n+    {\n+      vs.push_back(shared_ptr<vector<int> >(new vector<int>()));\n+      if (!pv3)\n+\t{\n+\t  if (get_index(*vs.back()) == get_index(v1))\n+\t    pv3 = vs.back().get();\n+\t}\n+      else if (!pv4)\n+\t{\n+\t  if (get_index(*vs.back()) == get_index(v2))\n+\t    {\n+\t      pv4 = vs.back().get();\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (!pv3 || !pv4)\n+    // Maybe an other time...\n+    return;\n+\n+  vector<int> &v3 = *pv3, &v4 = *pv4;\n+\n+  // v1 and v3 shares the same mutex instance, like v2 and v4\n+  // thread t1 lock v1 and v2\n+  thread t1([&v1, &v2]()\n+    {\n+      for (int i = 0; i != 1000; ++i)\n+\tv1.swap(v2);\n+    });\n+  // thread t2 lock v4 and v3\n+  thread t2([&v3, &v4]()\n+    {\n+      for (int i = 0; i != 1000; ++i)\n+\tv4.swap(v3);\n+    });\n+  t2.join();\n+  t1.join();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}