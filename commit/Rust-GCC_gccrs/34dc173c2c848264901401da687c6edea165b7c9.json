{"sha": "34dc173c2c848264901401da687c6edea165b7c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkYzE3M2MyYzg0ODI2NDkwMTQwMWRhNjg3YzZlZGVhMTY1YjdjOQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-05-10T22:59:04Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-05-10T22:59:04Z"}, "message": "except.c (EH_RETURN_STACKADJ_RTX): Do not define.\n\n\t* except.c (EH_RETURN_STACKADJ_RTX): Do not define.\n\t(EH_RETURN_HANDLER_RTX): Likewise.\n\t(expand_builtin_eh_return): Do not copy stack adjustment\n\tif EH_RETURN_STACKADJ_RTX is not defined.\n\t(expand_eh_return): Likewise.  Also, do not pass stack\n\tadjustment as argument to the eh_return pattern.\n\t* except.h (MUST_USE_SJLJ_EXCEPTIONS): Do not define just\n\tbecause EH_RETURN_STACKADJ_RTX is not defined.\n\t* unwind-dw.c (uw_update_context_1): If EH_RETURN_STACKADJ_RTX\n\tis not defined, treat stack pointer like a regular register.\n\t(uw_init_context_1): Set up fake initial stack pointer register.\n\t(uw_install_context_1): Do not compute stack adjustment if\n\tEH_RETURN_STACKADJ_RTX is not defined.\n\n\t* config/i386/i386.md (\"eh_return\"): Remove first argument.\n\t* config/mips/mips.md (\"eh_return\"): Likewise.\n\t* config/rs6000/rs6000.md (\"eh_return\"): Likewise.\n\t* config/sh/sh.md (\"eh_return\"): Likewise.\n\n\t* config/s390/s390.h (EH_RETURN_STACKADJ_RTX): Remove.\n\nFrom-SVN: r66672", "tree": {"sha": "576cc3eb0bc73f866abed200b78ada8bb9e6cdc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/576cc3eb0bc73f866abed200b78ada8bb9e6cdc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34dc173c2c848264901401da687c6edea165b7c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34dc173c2c848264901401da687c6edea165b7c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34dc173c2c848264901401da687c6edea165b7c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34dc173c2c848264901401da687c6edea165b7c9/comments", "author": null, "committer": null, "parents": [{"sha": "a64d0bc69ea6a927a0a16d71681b00099e285d1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64d0bc69ea6a927a0a16d71681b00099e285d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64d0bc69ea6a927a0a16d71681b00099e285d1e"}], "stats": {"total": 223, "additions": 120, "deletions": 103}, "files": [{"sha": "cbc986a6b386e9061e207d7139c8cb75a1ac0f9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -1,3 +1,26 @@\n+2003-05-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* except.c (EH_RETURN_STACKADJ_RTX): Do not define.\n+\t(EH_RETURN_HANDLER_RTX): Likewise.\n+\t(expand_builtin_eh_return): Do not copy stack adjustment\n+\tif EH_RETURN_STACKADJ_RTX is not defined.\n+\t(expand_eh_return): Likewise.  Also, do not pass stack\n+\tadjustment as argument to the eh_return pattern.\n+\t* except.h (MUST_USE_SJLJ_EXCEPTIONS): Do not define just\n+\tbecause EH_RETURN_STACKADJ_RTX is not defined.\n+\t* unwind-dw.c (uw_update_context_1): If EH_RETURN_STACKADJ_RTX\n+\tis not defined, treat stack pointer like a regular register.\n+\t(uw_init_context_1): Set up fake initial stack pointer register.\n+\t(uw_install_context_1): Do not compute stack adjustment if\n+\tEH_RETURN_STACKADJ_RTX is not defined.\n+\n+\t* config/i386/i386.md (\"eh_return\"): Remove first argument.\n+\t* config/mips/mips.md (\"eh_return\"): Likewise.\n+\t* config/rs6000/rs6000.md (\"eh_return\"): Likewise.\n+\t* config/sh/sh.md (\"eh_return\"): Likewise.\n+\n+\t* config/s390/s390.h (EH_RETURN_STACKADJ_RTX): Remove.\n+\n 2003-05-10  Alexander Aganichev  <aaganichev@yandex.ru>\n \n \t* config/i386/i386.h (MODES_TIEABLE_P): Fix typo."}, {"sha": "64d37f608824051e5911cf54ec0a8e0c9589a199", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -14284,11 +14284,10 @@\n   \"ix86_expand_epilogue (0); DONE;\")\n \n (define_expand \"eh_return\"\n-  [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand 1 \"register_operand\" \"\"))]\n+  [(use (match_operand 0 \"register_operand\" \"\"))]\n   \"\"\n {\n-  rtx tmp, sa = operands[0], ra = operands[1];\n+  rtx tmp, sa = EH_RETURN_STACKADJ_RTX, ra = operands[0];\n \n   /* Tricky bit: we write the address of the handler to which we will\n      be returning into someone else's stack frame, one word below the"}, {"sha": "718e0393ab0c7bbf195eddd88f59184d8b214f71", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -9779,21 +9779,19 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n \n ;; This is used in compiling the unwind routines.\n (define_expand \"eh_return\"\n-  [(use (match_operand 0 \"general_operand\" \"\"))\n-   (use (match_operand 1 \"general_operand\" \"\"))]\n+  [(use (match_operand 0 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n   enum machine_mode gpr_mode = TARGET_64BIT ? DImode : SImode;\n \n-  if (GET_MODE (operands[1]) != gpr_mode)\n-    operands[1] = convert_to_mode (gpr_mode, operands[1], 0);\n+  if (GET_MODE (operands[0]) != gpr_mode)\n+    operands[0] = convert_to_mode (gpr_mode, operands[0], 0);\n   if (TARGET_64BIT)\n-    emit_insn (gen_eh_set_lr_di (operands[1]));\n+    emit_insn (gen_eh_set_lr_di (operands[0]));\n   else\n-    emit_insn (gen_eh_set_lr_si (operands[1]));\n+    emit_insn (gen_eh_set_lr_si (operands[0]));\n \n-  emit_move_insn (EH_RETURN_STACKADJ_RTX, operands[0]);\n   DONE;\n }\")\n "}, {"sha": "a40dc2b0293fbb53dfdc7f201119d6c8392c668a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -14392,19 +14392,17 @@\n \n ; This is used in compiling the unwind routines.\n (define_expand \"eh_return\"\n-  [(use (match_operand 0 \"general_operand\" \"\"))\n-   (use (match_operand 1 \"general_operand\" \"\"))]\n+  [(use (match_operand 0 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n #if TARGET_AIX\n-    rs6000_emit_eh_toc_restore (operands[0]);\n+  rs6000_emit_eh_toc_restore (EH_RETURN_STACKADJ_RTX);\n #endif\n   if (TARGET_32BIT)\n-    emit_insn (gen_eh_set_lr_si (operands[1]));\n+    emit_insn (gen_eh_set_lr_si (operands[0]));\n   else\n-    emit_insn (gen_eh_set_lr_di (operands[1]));\n-  emit_move_insn (EH_RETURN_STACKADJ_RTX, operands[0]);\n+    emit_insn (gen_eh_set_lr_di (operands[0]));\n   DONE;\n }\")\n "}, {"sha": "824a6e277688fbc71dd4d917dc1ad51e6c442f2f", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -550,7 +550,6 @@ extern int current_function_outgoing_args_size;\n \n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 6 : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, 10)\n #define EH_RETURN_HANDLER_RTX \\\n   gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, \\\n                                      TARGET_64BIT? -48 : -40))"}, {"sha": "eb6353840ff3db5a8aec4d8248e2db5b1e50cfb4", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -7311,18 +7311,16 @@ mov.l\\\\t1f,r0\\\\n\\\\\n }\")\n \n (define_expand \"eh_return\"\n-  [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand 1 \"register_operand\" \"\"))]\n+  [(use (match_operand 0 \"register_operand\" \"\"))]\n   \"\"\n {\n-  rtx tmp, sa = operands[0], ra = operands[1];\n+  rtx tmp, ra = operands[0];\n \n   if (TARGET_SHMEDIA64)\n     emit_insn (gen_eh_set_ra_di (ra));\n   else\n     emit_insn (gen_eh_set_ra_si (ra));\n \n-  emit_move_insn (EH_RETURN_STACKADJ_RTX, sa);\n   DONE;\n })\n "}, {"sha": "f078520ab3d448608babb5d8476308cd0354775a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -3374,17 +3374,17 @@ and thence the call frame exception handling library routines, are\n built.  It is intended to handle non-trivial actions needed along\n the abnormal return path.\n \n-The pattern takes two arguments.  The first is an offset to be applied\n-to the stack pointer.  It will have been copied to some appropriate\n-location (typically @code{EH_RETURN_STACKADJ_RTX}) which will survive\n-until after reload to when the normal epilogue is generated.\n-The second argument is the address of the exception handler to which\n-the function should return.  This will normally need to copied by the\n-pattern to some special register or memory location.\n-\n-This pattern only needs to be defined if call frame exception handling\n-is to be used, and simple moves involving @code{EH_RETURN_STACKADJ_RTX}\n-and @code{EH_RETURN_HANDLER_RTX} are not sufficient.\n+The address of the exception handler to which the function should return\n+is passed as operand to this pattern.  It will normally need to copied by \n+the pattern to some special register or memory location.\n+If the pattern needs to determine the location of the target call\n+frame in order to do so, it may use @code{EH_RETURN_STACKADJ_RTX},\n+if defined; it will have already been assigned.\n+\n+If this pattern is not defined, the default action will be to simply\n+copy the return address to @code{EH_RETURN_HANDLER_RTX}.  Either\n+that macro or this pattern needs to be defined if call frame exception\n+handling is to be used.\n \n @cindex @code{prologue} instruction pattern\n @anchor{prologue instruction pattern}"}, {"sha": "c7c65a59febff477f898a819b3ae54650f538292", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -3016,8 +3016,12 @@ It will be assigned zero on code paths that return normally.\n Typically this is a call-clobbered hard register that is otherwise\n untouched by the epilogue, but could also be a stack slot.\n \n-You must define this macro if you want to support call frame exception\n-handling like that provided by DWARF 2.\n+Do not define this macro if the stack pointer is saved and restored\n+by the regular prolog and epilog code in the call frame itself; in \n+this case, the exception handling library routines will update the \n+stack location to be restored in place.  Otherwise, you must define \n+this macro if you want to support call frame exception handling like \n+that provided by DWARF 2.\n \n @findex EH_RETURN_HANDLER_RTX\n @item EH_RETURN_HANDLER_RTX\n@@ -3029,8 +3033,9 @@ Typically this is the location in the call frame at which the normal\n return address is stored.  For targets that return by popping an\n address off the stack, this might be a memory address just below\n the @emph{target} call frame rather than inside the current call\n-frame.  @code{EH_RETURN_STACKADJ_RTX} will have already been assigned,\n-so it may be used to calculate the location of the target call frame.\n+frame.  If defined, @code{EH_RETURN_STACKADJ_RTX} will have already \n+been assigned, so it may be used to calculate the location of the \n+target call frame.\n \n Some targets have more complex requirements than storing to an\n address calculable during initial code generation.  In that case"}, {"sha": "d6ab26c6007d21ae1263f11617a7ecbbad24fbeb", "filename": "gcc/except.c", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -76,12 +76,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Provide defaults for stuff that may not be defined when using\n    sjlj exceptions.  */\n-#ifndef EH_RETURN_STACKADJ_RTX\n-#define EH_RETURN_STACKADJ_RTX 0\n-#endif\n-#ifndef EH_RETURN_HANDLER_RTX\n-#define EH_RETURN_HANDLER_RTX 0\n-#endif\n #ifndef EH_RETURN_DATA_REGNO\n #define EH_RETURN_DATA_REGNO(N) INVALID_REGNUM\n #endif\n@@ -3077,77 +3071,73 @@ expand_builtin_frob_return_addr (addr_tree)\n \n void\n expand_builtin_eh_return (stackadj_tree, handler_tree)\n-    tree stackadj_tree, handler_tree;\n+    tree stackadj_tree ATTRIBUTE_UNUSED;\n+    tree handler_tree;\n {\n-  rtx stackadj, handler;\n-\n-  stackadj = expand_expr (stackadj_tree, cfun->eh->ehr_stackadj, VOIDmode, 0);\n-  handler = expand_expr (handler_tree, cfun->eh->ehr_handler, VOIDmode, 0);\n+  rtx tmp;\n \n+#ifdef EH_RETURN_STACKADJ_RTX\n+  tmp = expand_expr (stackadj_tree, cfun->eh->ehr_stackadj, VOIDmode, 0);\n #ifdef POINTERS_EXTEND_UNSIGNED\n-  if (GET_MODE (stackadj) != Pmode)\n-    stackadj = convert_memory_address (Pmode, stackadj);\n-\n-  if (GET_MODE (handler) != Pmode)\n-    handler = convert_memory_address (Pmode, handler);\n+  if (GET_MODE (tmp) != Pmode)\n+    tmp = convert_memory_address (Pmode, tmp);\n+#endif\n+  if (!cfun->eh->ehr_stackadj)\n+    cfun->eh->ehr_stackadj = copy_to_reg (tmp);\n+  else if (tmp != cfun->eh->ehr_stackadj)\n+    emit_move_insn (cfun->eh->ehr_stackadj, tmp);\n #endif\n \n-  if (! cfun->eh->ehr_label)\n-    {\n-      cfun->eh->ehr_stackadj = copy_to_reg (stackadj);\n-      cfun->eh->ehr_handler = copy_to_reg (handler);\n-      cfun->eh->ehr_label = gen_label_rtx ();\n-    }\n-  else\n-    {\n-      if (stackadj != cfun->eh->ehr_stackadj)\n-\temit_move_insn (cfun->eh->ehr_stackadj, stackadj);\n-      if (handler != cfun->eh->ehr_handler)\n-\temit_move_insn (cfun->eh->ehr_handler, handler);\n-    }\n+  tmp = expand_expr (handler_tree, cfun->eh->ehr_handler, VOIDmode, 0);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  if (GET_MODE (tmp) != Pmode)\n+    tmp = convert_memory_address (Pmode, tmp);\n+#endif\n+  if (!cfun->eh->ehr_handler)\n+    cfun->eh->ehr_handler = copy_to_reg (tmp);\n+  else if (tmp != cfun->eh->ehr_handler)\n+    emit_move_insn (cfun->eh->ehr_handler, tmp);\n \n+  if (!cfun->eh->ehr_label)\n+    cfun->eh->ehr_label = gen_label_rtx ();\n   emit_jump (cfun->eh->ehr_label);\n }\n \n void\n expand_eh_return ()\n {\n-  rtx sa, ra, around_label;\n+  rtx around_label;\n \n   if (! cfun->eh->ehr_label)\n     return;\n \n-  sa = EH_RETURN_STACKADJ_RTX;\n-  if (! sa)\n-    {\n-      error (\"__builtin_eh_return not supported on this target\");\n-      return;\n-    }\n-\n   current_function_calls_eh_return = 1;\n \n+#ifdef EH_RETURN_STACKADJ_RTX\n+  emit_move_insn (EH_RETURN_STACKADJ_RTX, const0_rtx);\n+#endif\n+\n   around_label = gen_label_rtx ();\n-  emit_move_insn (sa, const0_rtx);\n   emit_jump (around_label);\n \n   emit_label (cfun->eh->ehr_label);\n   clobber_return_register ();\n \n+#ifdef EH_RETURN_STACKADJ_RTX\n+  emit_move_insn (EH_RETURN_STACKADJ_RTX, cfun->eh->ehr_stackadj);\n+#endif\n+\n #ifdef HAVE_eh_return\n   if (HAVE_eh_return)\n-    emit_insn (gen_eh_return (cfun->eh->ehr_stackadj, cfun->eh->ehr_handler));\n+    emit_insn (gen_eh_return (cfun->eh->ehr_handler));\n   else\n #endif\n     {\n-      ra = EH_RETURN_HANDLER_RTX;\n-      if (! ra)\n-\t{\n-\t  error (\"__builtin_eh_return not supported on this target\");\n-\t  ra = gen_reg_rtx (Pmode);\n-\t}\n-\n-      emit_move_insn (sa, cfun->eh->ehr_stackadj);\n-      emit_move_insn (ra, cfun->eh->ehr_handler);\n+#ifdef EH_RETURN_HANDLER_RTX\n+      emit_move_insn (EH_RETURN_HANDLER_RTX, cfun->eh->ehr_handler);\n+#else\n+      error (\"__builtin_eh_return not supported on this target\");\n+#endif\n     }\n \n   emit_label (around_label);"}, {"sha": "d44c4b8d9ce60756e81c6a76b9f323ec57685bf7", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -146,7 +146,6 @@ extern tree (*lang_eh_runtime_type) PARAMS ((tree));\n #if ! (defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n        && (defined (IA64_UNWIND_INFO)\t\t\t\\\n \t   || (DWARF2_UNWIND_INFO\t\t\t\\\n-\t       && defined (EH_RETURN_STACKADJ_RTX)\t\\\n \t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n \t\t   || defined (HAVE_eh_return)))))\n #define MUST_USE_SJLJ_EXCEPTIONS\t1\n@@ -163,9 +162,6 @@ extern tree (*lang_eh_runtime_type) PARAMS ((tree));\n #  ifndef EH_RETURN_DATA_REGNO\n     #error \"EH_RETURN_DATA_REGNO required\"\n #  endif\n-#  ifndef EH_RETURN_STACKADJ_RTX\n-    #error \"EH_RETURN_STACKADJ_RTX required\"\n-#  endif\n #  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)\n     #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n #  endif"}, {"sha": "673d164695dbed0fac720f93794b55a64edca85b", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34dc173c2c848264901401da687c6edea165b7c9/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=34dc173c2c848264901401da687c6edea165b7c9", "patch": "@@ -1076,10 +1076,10 @@ static void\n uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {\n   struct _Unwind_Context orig_context = *context;\n-  _Unwind_Word tmp_sp;\n   void *cfa;\n   long i;\n \n+#ifdef EH_RETURN_STACKADJ_RTX\n   /* Special handling here: Many machines do not use a frame pointer,\n      and track the CFA only through offsets from the stack pointer from\n      one frame to the next.  In this case, the stack pointer is never\n@@ -1094,12 +1094,16 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n      frame, and be able to use much easier CFA mechanisms to do it.\n      Always zap the saved stack pointer value for the next frame; carrying\n      the value over from one frame to another doesn't make sense.  */\n+\n+  _Unwind_Word tmp_sp;\n+\n   if (!_Unwind_GetGRPtr (&orig_context, __builtin_dwarf_sp_column ()))\n     {\n       tmp_sp = (_Unwind_Ptr) context->cfa;\n       _Unwind_SetGRPtr (&orig_context, __builtin_dwarf_sp_column (), &tmp_sp);\n     }\n   _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), NULL);\n+#endif\n \n   /* Compute this frame's CFA.  */\n   switch (fs->cfa_how)\n@@ -1202,7 +1206,7 @@ uw_init_context_1 (struct _Unwind_Context *context,\n     abort ();\n \n   /* Force the frame state to use the known cfa value.  */\n-  context->cfa = outer_cfa;\n+  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), &outer_cfa);\n   fs.cfa_how = CFA_REG_OFFSET;\n   fs.cfa_reg = __builtin_dwarf_sp_column ();\n   fs.cfa_offset = 0;\n@@ -1240,7 +1244,6 @@ uw_install_context_1 (struct _Unwind_Context *current,\n \t\t      struct _Unwind_Context *target)\n {\n   long i;\n-  void *target_cfa;\n \n #if __GTHREADS\n   {\n@@ -1263,18 +1266,26 @@ uw_install_context_1 (struct _Unwind_Context *current,\n \tmemcpy (c, t, dwarf_reg_size_table[i]);\n     }\n \n-  /* If the last frame records a saved stack pointer, use it.  */\n-  if (_Unwind_GetGRPtr (target, __builtin_dwarf_sp_column ()))\n-    target_cfa = (void *)(_Unwind_Ptr)\n-      _Unwind_GetGR (target, __builtin_dwarf_sp_column ());\n-  else\n-    target_cfa = target->cfa;\n-\n-  /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */\n-  if (STACK_GROWS_DOWNWARD)\n-    return target_cfa - current->cfa + target->args_size;\n-  else\n-    return current->cfa - target_cfa - target->args_size;\n+#ifdef EH_RETURN_STACKADJ_RTX\n+  {\n+    void *target_cfa;\n+\n+    /* If the last frame records a saved stack pointer, use it.  */\n+    if (_Unwind_GetGRPtr (target, __builtin_dwarf_sp_column ()))\n+      target_cfa = (void *)(_Unwind_Ptr)\n+        _Unwind_GetGR (target, __builtin_dwarf_sp_column ());\n+    else\n+      target_cfa = target->cfa;\n+\n+    /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */\n+    if (STACK_GROWS_DOWNWARD)\n+      return target_cfa - current->cfa + target->args_size;\n+    else\n+      return current->cfa - target_cfa - target->args_size;\n+  }\n+#else\n+  return 0;\n+#endif\n }\n \n static inline _Unwind_Ptr"}]}