{"sha": "9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhNjZiZjViOWM2OWUwZTJiY2QxYjJhYjg4MTYwYmY5YjJhYTQxNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-31T10:09:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-31T10:09:43Z"}, "message": "configure.ac: Compute and substitute omp_device_properties and omp_device_property_deps.\n\n\t* configure.ac: Compute and substitute omp_device_properties and\n\tomp_device_property_deps.\n\t* Makefile.in (generated_files): Add omp-device-properties.h.\n\t(omp-general.o): Depend on omp-device-properties.h.\n\t(omp_device_properties): New make variable.\n\t(omp-device-properties.h, s-omp-device-properties-h,\n\tinstall-omp-device-properties): New goals.\n\t(install): Depend on install-omp-device-properties for accelerators.\n\t* target.def (TARGET_OMP_DEVICE_KIND_ARCH_ISA): New target hook.\n\t* target.h (enum omp_device_kind_arch_isa): New enum.\n\t* doc/tm.texi.in: Add placeholder for TARGET_OMP_DEVICE_KIND_ARCH_ISA\n\tdocumentation.\n\t* omp-general.c: Include omp-device-properties.h.\n\t(omp_max_simt_vf): Expect OFFLOAD_TARGET_NAMES to be separated by\n\tcolon instead of comma.\n\t(omp_offload_device_kind_arch_isa, omp_maybe_offloaded): New\n\tfunctions.\n\t(omp_context_selector_matches): Implement device set arch/isa\n\tselectors, improve device set kind selector handling.\n\t* config/i386/i386-options.h (ix86_omp_device_kind_arch_isa): Declare.\n\t* config/i386/i386.c (TARGET_SIMD_CLONE_ADJUST,\n\tTARGET_SIMD_CLONE_USABLE): Formatting fix.\n\t(TARGET_OMP_DEVICE_KIND_ARCH_ISA): Redefine to\n\tix86_omp_device_kind_arch_isa.\n\t* config/i386/i386-options.c (struct ix86_target_opts): Move type\n\tdefinition from ix86_target_string to file scope.\n\t(isa2_opts, isa_opts): Moved arrays from ix86_target_string function\n\tto file scope.\n\t(ix86_omp_device_kind_arch_isa): New function.\n\t(ix86_target_string): Moved struct ix86_target_opts, isa2_opts and\n\tisa_opts definitions to file scope.\n\t* config/i386/t-intelmic (omp-device-properties): New goal.\n\t* config/nvptx/t-nvptx (omp-device-properties): Likewise.\n\t* config/nvptx/nvptx.c (nvptx_omp_device_kind_arch_isa): New function.\n\t(TARGET_OMP_DEVICE_KIND_ARCH_ISA): Redefine to\n\tnvptx_omp_device_kind_arch_isa.\n\t* configure: Regenerate.\n\t* doc/tm.texi: Regenerate.\ntestsuite/\n\t* c-c++-common/gomp/declare-variant-9.c: New test.\n\t* c-c++-common/gomp/declare-variant-10.c: New test.\n\nFrom-SVN: r277662", "tree": {"sha": "338ea6aaa57ed2fb13975081ccabdc86eb70eb90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/338ea6aaa57ed2fb13975081ccabdc86eb70eb90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6409a3c0369313f604b349ffc53efd78d873f790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6409a3c0369313f604b349ffc53efd78d873f790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6409a3c0369313f604b349ffc53efd78d873f790"}], "stats": {"total": 801, "additions": 665, "deletions": 136}, "files": [{"sha": "c068ac865c326c9f170b0885a145d827b54a66df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -1,5 +1,44 @@\n 2019-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* configure.ac: Compute and substitute omp_device_properties and\n+\tomp_device_property_deps.\n+\t* Makefile.in (generated_files): Add omp-device-properties.h.\n+\t(omp-general.o): Depend on omp-device-properties.h.\n+\t(omp_device_properties): New make variable.\n+\t(omp-device-properties.h, s-omp-device-properties-h,\n+\tinstall-omp-device-properties): New goals.\n+\t(install): Depend on install-omp-device-properties for accelerators.\n+\t* target.def (TARGET_OMP_DEVICE_KIND_ARCH_ISA): New target hook.\n+\t* target.h (enum omp_device_kind_arch_isa): New enum.\n+\t* doc/tm.texi.in: Add placeholder for TARGET_OMP_DEVICE_KIND_ARCH_ISA\n+\tdocumentation.\n+\t* omp-general.c: Include omp-device-properties.h.\n+\t(omp_max_simt_vf): Expect OFFLOAD_TARGET_NAMES to be separated by\n+\tcolon instead of comma.\n+\t(omp_offload_device_kind_arch_isa, omp_maybe_offloaded): New\n+\tfunctions.\n+\t(omp_context_selector_matches): Implement device set arch/isa\n+\tselectors, improve device set kind selector handling.\n+\t* config/i386/i386-options.h (ix86_omp_device_kind_arch_isa): Declare.\n+\t* config/i386/i386.c (TARGET_SIMD_CLONE_ADJUST,\n+\tTARGET_SIMD_CLONE_USABLE): Formatting fix.\n+\t(TARGET_OMP_DEVICE_KIND_ARCH_ISA): Redefine to\n+\tix86_omp_device_kind_arch_isa.\n+\t* config/i386/i386-options.c (struct ix86_target_opts): Move type\n+\tdefinition from ix86_target_string to file scope.\n+\t(isa2_opts, isa_opts): Moved arrays from ix86_target_string function\n+\tto file scope.\n+\t(ix86_omp_device_kind_arch_isa): New function.\n+\t(ix86_target_string): Moved struct ix86_target_opts, isa2_opts and\n+\tisa_opts definitions to file scope.\n+\t* config/i386/t-intelmic (omp-device-properties): New goal.\n+\t* config/nvptx/t-nvptx (omp-device-properties): Likewise.\n+\t* config/nvptx/nvptx.c (nvptx_omp_device_kind_arch_isa): New function.\n+\t(TARGET_OMP_DEVICE_KIND_ARCH_ISA): Redefine to\n+\tnvptx_omp_device_kind_arch_isa.\n+\t* configure: Regenerate.\n+\t* doc/tm.texi: Regenerate.\n+\n \tPR middle-end/92231\n \t* tree.h (fndecl_built_in_p): Use fndecl_built_in_p instead of\n \tDECL_BUILT_IN in comment.  Remove redundant ()s around return"}, {"sha": "551674b0d39fe66a488f99ac26a63119f24c0c61", "filename": "gcc/Makefile.in", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -2645,7 +2645,7 @@ generated_files = config.h tm.h $(TM_P_H) $(TM_D_H) $(TM_H) multilib.h \\\n        common/common-target-hooks-def.h pass-instances.def \\\n        c-family/c-target-hooks-def.h d/d-target-hooks-def.h \\\n        params.list params.options case-cfn-macros.h \\\n-       cfn-operators.pd\n+       cfn-operators.pd omp-device-properties.h\n \n #\f\n # How to compile object files to run on the build machine.\n@@ -2854,6 +2854,30 @@ $(genprog:%=build/gen%$(build_exeext)): build/gen%$(build_exeext): build/gen%.o\n \t+$(LINKER_FOR_BUILD) $(BUILD_LINKERFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n \t    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)\n \n+omp-general.o: omp-device-properties.h\n+\n+omp_device_properties = @omp_device_properties@\n+omp-device-properties.h: s-omp-device-properties-h ; @true\n+s-omp-device-properties-h: @omp_device_property_deps@\n+\t-rm -f tmp-omp-device-properties.h; \\\n+\tfor kind in kind arch isa; do \\\n+\t  echo 'const char omp_offload_device_'$${kind}'[] = ' \\\n+\t    >> tmp-omp-device-properties.h; \\\n+\t  for prop in none $(omp_device_properties); do \\\n+\t    [ \"$$prop\" = \"none\" ] && continue; \\\n+\t    tgt=`echo \"$$prop\" | sed 's/=.*$$//'`; \\\n+\t    props=`echo \"$$prop\" | sed 's/.*=//'`; \\\n+\t    echo \"\\\"$$tgt\\\\0\\\"\" >> tmp-omp-device-properties.h; \\\n+\t    sed -n 's/^'$${kind}': //p' $${props} \\\n+\t      | sed 's/[[:blank:]]/ /g;s/  */ /g;s/^ //;s/ $$//;s/ /\\\\0/g;s/^/\"/;s/$$/\\\\0\\\\0\"/' \\\n+\t      >> tmp-omp-device-properties.h; \\\n+\t  done; \\\n+\t  echo '\"\";' >> tmp-omp-device-properties.h; \\\n+\tdone; \\\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-omp-device-properties.h \\\n+\t  omp-device-properties.h\n+\t$(STAMP) s-omp-device-properties-h\n+\n # Generated source files for gengtype.  Prepend inclusion of\n # config.h/bconfig.h because AIX requires _LARGE_FILES to be defined before\n # any system header is included.\n@@ -3452,6 +3476,10 @@ ifeq ($(enable_plugin),yes)\n install: install-plugin\n endif\n \n+ifeq ($(enable_as_accelerator),yes)\n+install: install-omp-device-properties\n+endif\n+\n install-strip: override INSTALL_PROGRAM = $(INSTALL_STRIP_PROGRAM)\n ifneq ($(STRIP),)\n install-strip: STRIPPROG = $(STRIP)\n@@ -3637,6 +3665,11 @@ install-driver: installdirs xgcc$(exeext)\n \t  fi; \\\n \tfi\n \n+# Install omp-device-properties file for accelerator compilers.\n+install-omp-device-properties: omp-device-properties installdirs\n+\t$(INSTALL_DATA) omp-device-properties \\\n+\t  $(DESTDIR)$(libsubdir)/omp-device-properties\n+\n # Install the info files.\n # $(INSTALL_DATA) might be a relative pathname, so we can't cd into srcdir\n # to do the install."}, {"sha": "dfc8ae23ba0b2692cd04f9f185d9e00888106059", "filename": "gcc/config/i386/i386-options.c", "status": "modified", "additions": 161, "deletions": 95, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Fi386-options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Fi386-options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.c?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -178,6 +178,167 @@ static unsigned HOST_WIDE_INT initial_ix86_tune_features[X86_TUNE_LAST] = {\n /* Feature tests against the various architecture variations.  */\n unsigned char ix86_arch_features[X86_ARCH_LAST];\n \n+struct ix86_target_opts\n+{\n+  const char *option;\t\t/* option string */\n+  HOST_WIDE_INT mask;\t\t/* isa mask options */\n+};\n+\n+/* This table is ordered so that options like -msse4.2 that imply other\n+   ISAs come first.  Target string will be displayed in the same order.  */\n+static struct ix86_target_opts isa2_opts[] =\n+{\n+  { \"-mcx16\",\t\tOPTION_MASK_ISA_CX16 },\n+  { \"-mvaes\",\t\tOPTION_MASK_ISA_VAES },\n+  { \"-mrdpid\",\t\tOPTION_MASK_ISA_RDPID },\n+  { \"-mpconfig\",\tOPTION_MASK_ISA_PCONFIG },\n+  { \"-mwbnoinvd\",\tOPTION_MASK_ISA_WBNOINVD },\n+  { \"-mavx512vp2intersect\", OPTION_MASK_ISA_AVX512VP2INTERSECT },\n+  { \"-msgx\",\t\tOPTION_MASK_ISA_SGX },\n+  { \"-mavx5124vnniw\",\tOPTION_MASK_ISA_AVX5124VNNIW },\n+  { \"-mavx5124fmaps\",\tOPTION_MASK_ISA_AVX5124FMAPS },\n+  { \"-mhle\",\t\tOPTION_MASK_ISA_HLE },\n+  { \"-mmovbe\",\t\tOPTION_MASK_ISA_MOVBE },\n+  { \"-mclzero\",\t\tOPTION_MASK_ISA_CLZERO },\n+  { \"-mmwaitx\",\t\tOPTION_MASK_ISA_MWAITX },\n+  { \"-mmovdir64b\",\tOPTION_MASK_ISA_MOVDIR64B },\n+  { \"-mwaitpkg\",\tOPTION_MASK_ISA_WAITPKG },\n+  { \"-mcldemote\",\tOPTION_MASK_ISA_CLDEMOTE },\n+  { \"-mptwrite\",\tOPTION_MASK_ISA_PTWRITE },\n+  { \"-mavx512bf16\",\tOPTION_MASK_ISA_AVX512BF16 },\n+  { \"-menqcmd\",\t\tOPTION_MASK_ISA_ENQCMD }\n+};\n+static struct ix86_target_opts isa_opts[] =\n+{\n+  { \"-mavx512vpopcntdq\", OPTION_MASK_ISA_AVX512VPOPCNTDQ },\n+  { \"-mavx512bitalg\",\tOPTION_MASK_ISA_AVX512BITALG },\n+  { \"-mvpclmulqdq\",\tOPTION_MASK_ISA_VPCLMULQDQ },\n+  { \"-mgfni\",\t\tOPTION_MASK_ISA_GFNI },\n+  { \"-mavx512vnni\",\tOPTION_MASK_ISA_AVX512VNNI },\n+  { \"-mavx512vbmi2\",\tOPTION_MASK_ISA_AVX512VBMI2 },\n+  { \"-mavx512vbmi\",\tOPTION_MASK_ISA_AVX512VBMI },\n+  { \"-mavx512ifma\",\tOPTION_MASK_ISA_AVX512IFMA },\n+  { \"-mavx512vl\",\tOPTION_MASK_ISA_AVX512VL },\n+  { \"-mavx512bw\",\tOPTION_MASK_ISA_AVX512BW },\n+  { \"-mavx512dq\",\tOPTION_MASK_ISA_AVX512DQ },\n+  { \"-mavx512er\",\tOPTION_MASK_ISA_AVX512ER },\n+  { \"-mavx512pf\",\tOPTION_MASK_ISA_AVX512PF },\n+  { \"-mavx512cd\",\tOPTION_MASK_ISA_AVX512CD },\n+  { \"-mavx512f\",\tOPTION_MASK_ISA_AVX512F },\n+  { \"-mavx2\",\t\tOPTION_MASK_ISA_AVX2 },\n+  { \"-mfma\",\t\tOPTION_MASK_ISA_FMA },\n+  { \"-mxop\",\t\tOPTION_MASK_ISA_XOP },\n+  { \"-mfma4\",\t\tOPTION_MASK_ISA_FMA4 },\n+  { \"-mf16c\",\t\tOPTION_MASK_ISA_F16C },\n+  { \"-mavx\",\t\tOPTION_MASK_ISA_AVX },\n+/*{ \"-msse4\"\t\tOPTION_MASK_ISA_SSE4 }, */\n+  { \"-msse4.2\",\t\tOPTION_MASK_ISA_SSE4_2 },\n+  { \"-msse4.1\",\t\tOPTION_MASK_ISA_SSE4_1 },\n+  { \"-msse4a\",\t\tOPTION_MASK_ISA_SSE4A },\n+  { \"-mssse3\",\t\tOPTION_MASK_ISA_SSSE3 },\n+  { \"-msse3\",\t\tOPTION_MASK_ISA_SSE3 },\n+  { \"-maes\",\t\tOPTION_MASK_ISA_AES },\n+  { \"-msha\",\t\tOPTION_MASK_ISA_SHA },\n+  { \"-mpclmul\",\t\tOPTION_MASK_ISA_PCLMUL },\n+  { \"-msse2\",\t\tOPTION_MASK_ISA_SSE2 },\n+  { \"-msse\",\t\tOPTION_MASK_ISA_SSE },\n+  { \"-m3dnowa\",\t\tOPTION_MASK_ISA_3DNOW_A },\n+  { \"-m3dnow\",\t\tOPTION_MASK_ISA_3DNOW },\n+  { \"-mmmx\",\t\tOPTION_MASK_ISA_MMX },\n+  { \"-mrtm\",\t\tOPTION_MASK_ISA_RTM },\n+  { \"-mprfchw\",\t\tOPTION_MASK_ISA_PRFCHW },\n+  { \"-mrdseed\",\t\tOPTION_MASK_ISA_RDSEED },\n+  { \"-madx\",\t\tOPTION_MASK_ISA_ADX },\n+  { \"-mprefetchwt1\",\tOPTION_MASK_ISA_PREFETCHWT1 },\n+  { \"-mclflushopt\",\tOPTION_MASK_ISA_CLFLUSHOPT },\n+  { \"-mxsaves\",\t\tOPTION_MASK_ISA_XSAVES },\n+  { \"-mxsavec\",\t\tOPTION_MASK_ISA_XSAVEC },\n+  { \"-mxsaveopt\",\tOPTION_MASK_ISA_XSAVEOPT },\n+  { \"-mxsave\",\t\tOPTION_MASK_ISA_XSAVE },\n+  { \"-mabm\",\t\tOPTION_MASK_ISA_ABM },\n+  { \"-mbmi\",\t\tOPTION_MASK_ISA_BMI },\n+  { \"-mbmi2\",\t\tOPTION_MASK_ISA_BMI2 },\n+  { \"-mlzcnt\",\t\tOPTION_MASK_ISA_LZCNT },\n+  { \"-mtbm\",\t\tOPTION_MASK_ISA_TBM },\n+  { \"-mpopcnt\",\t\tOPTION_MASK_ISA_POPCNT },\n+  { \"-msahf\",\t\tOPTION_MASK_ISA_SAHF },\n+  { \"-mcrc32\",\t\tOPTION_MASK_ISA_CRC32 },\n+  { \"-mfsgsbase\",\tOPTION_MASK_ISA_FSGSBASE },\n+  { \"-mrdrnd\",\t\tOPTION_MASK_ISA_RDRND },\n+  { \"-mpku\",\t\tOPTION_MASK_ISA_PKU },\n+  { \"-mlwp\",\t\tOPTION_MASK_ISA_LWP },\n+  { \"-mfxsr\",\t\tOPTION_MASK_ISA_FXSR },\n+  { \"-mclwb\",\t\tOPTION_MASK_ISA_CLWB },\n+  { \"-mshstk\",\t\tOPTION_MASK_ISA_SHSTK },\n+  { \"-mmovdiri\",\tOPTION_MASK_ISA_MOVDIRI }\n+};\n+\n+/* Return 1 if TRAIT NAME is present in the OpenMP context's\n+   device trait set, return 0 if not present in any OpenMP context in the\n+   whole translation unit, or -1 if not present in the current OpenMP context\n+   but might be present in another OpenMP context in the same TU.  */\n+\n+int\n+ix86_omp_device_kind_arch_isa (enum omp_device_kind_arch_isa trait,\n+\t\t\t       const char *name)\n+{\n+  switch (trait)\n+    {\n+    case omp_device_kind:\n+      return strcmp (name, \"cpu\") == 0;\n+    case omp_device_arch:\n+      if (strcmp (name, \"x86\") == 0)\n+\treturn 1;\n+      if (TARGET_64BIT)\n+\t{\n+\t  if (TARGET_X32)\n+\t    return strcmp (name, \"x32\") == 0;\n+\t  else\n+\t    return strcmp (name, \"x86_64\") == 0;\n+\t}\n+      if (strcmp (name, \"ia32\") == 0 || strcmp (name, \"i386\") == 0)\n+\treturn 1;\n+      if (strcmp (name, \"i486\") == 0)\n+\treturn ix86_arch != PROCESSOR_I386 ? 1 : -1;\n+      if (strcmp (name, \"i586\") == 0)\n+\treturn (ix86_arch != PROCESSOR_I386\n+\t\t&& ix86_arch != PROCESSOR_I486) ? 1 : -1;\n+      if (strcmp (name, \"i686\") == 0)\n+\treturn (ix86_arch != PROCESSOR_I386\n+\t\t&& ix86_arch != PROCESSOR_I486\n+\t\t&& ix86_arch != PROCESSOR_LAKEMONT\n+\t\t&& ix86_arch != PROCESSOR_PENTIUM) ? 1 : -1;\n+      return 0;\n+    case omp_device_isa:\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  struct ix86_target_opts *opts = i ? isa2_opts : isa_opts;\n+\t  size_t nopts = i ? ARRAY_SIZE (isa2_opts) : ARRAY_SIZE (isa_opts);\n+\t  HOST_WIDE_INT mask = i ? ix86_isa_flags2 : ix86_isa_flags;\n+\t  for (size_t n = 0; n < nopts; n++)\n+\t    {\n+\t      const char *option = opts[n].option + 2;\n+\t      /* -msse4.2 and -msse4.1 options contain dot, which is not valid\n+\t\t in identifiers.  Use underscore instead, and handle sse4\n+\t\t as an alias to sse4_2.  */\n+\t      if (opts[n].mask == OPTION_MASK_ISA_SSE4_2)\n+\t\t{\n+\t\t  option = \"sse4_2\";\n+\t\t  if (strcmp (name, \"sse4\") == 0)\n+\t\t    return (mask & opts[n].mask) != 0 ? 1 : -1;\n+\t\t}\n+\t      else if (opts[n].mask == OPTION_MASK_ISA_SSE4_1)\n+\t\toption = \"sse4_1\";\n+\t      if (strcmp (name, option) == 0)\n+\t\treturn (mask & opts[n].mask) != 0 ? 1 : -1;\n+\t    }\n+\t}\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Return a string that documents the current -m options.  The caller is\n    responsible for freeing the string.  */\n \n@@ -187,101 +348,6 @@ ix86_target_string (HOST_WIDE_INT isa, HOST_WIDE_INT isa2,\n \t\t    const char *arch, const char *tune,\n \t\t    enum fpmath_unit fpmath, bool add_nl_p, bool add_abi_p)\n {\n-  struct ix86_target_opts\n-  {\n-    const char *option;\t\t/* option string */\n-    HOST_WIDE_INT mask;\t\t/* isa mask options */\n-  };\n-\n-  /* This table is ordered so that options like -msse4.2 that imply other\n-     ISAs come first.  Target string will be displayed in the same order.  */\n-  static struct ix86_target_opts isa2_opts[] =\n-  {\n-    { \"-mcx16\",\t\tOPTION_MASK_ISA_CX16 },\n-    { \"-mvaes\",\t\tOPTION_MASK_ISA_VAES },\n-    { \"-mrdpid\",\tOPTION_MASK_ISA_RDPID },\n-    { \"-mpconfig\",\tOPTION_MASK_ISA_PCONFIG },\n-    { \"-mwbnoinvd\",     OPTION_MASK_ISA_WBNOINVD },\n-    { \"-mavx512vp2intersect\", OPTION_MASK_ISA_AVX512VP2INTERSECT },\n-    { \"-msgx\",\t\tOPTION_MASK_ISA_SGX },\n-    { \"-mavx5124vnniw\", OPTION_MASK_ISA_AVX5124VNNIW },\n-    { \"-mavx5124fmaps\", OPTION_MASK_ISA_AVX5124FMAPS },\n-    { \"-mhle\",\t\tOPTION_MASK_ISA_HLE },\n-    { \"-mmovbe\",\tOPTION_MASK_ISA_MOVBE },\n-    { \"-mclzero\",\tOPTION_MASK_ISA_CLZERO },\n-    { \"-mmwaitx\",\tOPTION_MASK_ISA_MWAITX },\n-    { \"-mmovdir64b\",\tOPTION_MASK_ISA_MOVDIR64B },\n-    { \"-mwaitpkg\",\tOPTION_MASK_ISA_WAITPKG },\n-    { \"-mcldemote\",\tOPTION_MASK_ISA_CLDEMOTE },\n-    { \"-mptwrite\",\tOPTION_MASK_ISA_PTWRITE },\n-    { \"-mavx512bf16\",\tOPTION_MASK_ISA_AVX512BF16 },\n-    { \"-menqcmd\",       OPTION_MASK_ISA_ENQCMD }\n-  };\n-  static struct ix86_target_opts isa_opts[] =\n-  {\n-    { \"-mavx512vpopcntdq\", OPTION_MASK_ISA_AVX512VPOPCNTDQ },\n-    { \"-mavx512bitalg\", OPTION_MASK_ISA_AVX512BITALG },\n-    { \"-mvpclmulqdq\",\tOPTION_MASK_ISA_VPCLMULQDQ },\n-    { \"-mgfni\",\t\tOPTION_MASK_ISA_GFNI },\n-    { \"-mavx512vnni\",\tOPTION_MASK_ISA_AVX512VNNI },\n-    { \"-mavx512vbmi2\",\tOPTION_MASK_ISA_AVX512VBMI2 },\n-    { \"-mavx512vbmi\",\tOPTION_MASK_ISA_AVX512VBMI },\n-    { \"-mavx512ifma\",\tOPTION_MASK_ISA_AVX512IFMA },\n-    { \"-mavx512vl\",\tOPTION_MASK_ISA_AVX512VL },\n-    { \"-mavx512bw\",\tOPTION_MASK_ISA_AVX512BW },\n-    { \"-mavx512dq\",\tOPTION_MASK_ISA_AVX512DQ },\n-    { \"-mavx512er\",\tOPTION_MASK_ISA_AVX512ER },\n-    { \"-mavx512pf\",\tOPTION_MASK_ISA_AVX512PF },\n-    { \"-mavx512cd\",\tOPTION_MASK_ISA_AVX512CD },\n-    { \"-mavx512f\",\tOPTION_MASK_ISA_AVX512F },\n-    { \"-mavx2\",\t\tOPTION_MASK_ISA_AVX2 },\n-    { \"-mfma\",\t\tOPTION_MASK_ISA_FMA },\n-    { \"-mxop\",\t\tOPTION_MASK_ISA_XOP },\n-    { \"-mfma4\",\t\tOPTION_MASK_ISA_FMA4 },\n-    { \"-mf16c\",\t\tOPTION_MASK_ISA_F16C },\n-    { \"-mavx\",\t\tOPTION_MASK_ISA_AVX },\n-/*  { \"-msse4\"\t\tOPTION_MASK_ISA_SSE4 }, */\n-    { \"-msse4.2\",\tOPTION_MASK_ISA_SSE4_2 },\n-    { \"-msse4.1\",\tOPTION_MASK_ISA_SSE4_1 },\n-    { \"-msse4a\",\tOPTION_MASK_ISA_SSE4A },\n-    { \"-mssse3\",\tOPTION_MASK_ISA_SSSE3 },\n-    { \"-msse3\",\t\tOPTION_MASK_ISA_SSE3 },\n-    { \"-maes\",\t\tOPTION_MASK_ISA_AES },\n-    { \"-msha\",\t\tOPTION_MASK_ISA_SHA },\n-    { \"-mpclmul\",\tOPTION_MASK_ISA_PCLMUL },\n-    { \"-msse2\",\t\tOPTION_MASK_ISA_SSE2 },\n-    { \"-msse\",\t\tOPTION_MASK_ISA_SSE },\n-    { \"-m3dnowa\",\tOPTION_MASK_ISA_3DNOW_A },\n-    { \"-m3dnow\",\tOPTION_MASK_ISA_3DNOW },\n-    { \"-mmmx\",\t\tOPTION_MASK_ISA_MMX },\n-    { \"-mrtm\",\t\tOPTION_MASK_ISA_RTM },\n-    { \"-mprfchw\",\tOPTION_MASK_ISA_PRFCHW },\n-    { \"-mrdseed\",\tOPTION_MASK_ISA_RDSEED },\n-    { \"-madx\",\t\tOPTION_MASK_ISA_ADX },\n-    { \"-mprefetchwt1\",\tOPTION_MASK_ISA_PREFETCHWT1 },\n-    { \"-mclflushopt\",\tOPTION_MASK_ISA_CLFLUSHOPT },\n-    { \"-mxsaves\",\tOPTION_MASK_ISA_XSAVES },\n-    { \"-mxsavec\",\tOPTION_MASK_ISA_XSAVEC },\n-    { \"-mxsaveopt\",\tOPTION_MASK_ISA_XSAVEOPT },\n-    { \"-mxsave\",\tOPTION_MASK_ISA_XSAVE },\n-    { \"-mabm\",\t\tOPTION_MASK_ISA_ABM },\n-    { \"-mbmi\",\t\tOPTION_MASK_ISA_BMI },\n-    { \"-mbmi2\",\t\tOPTION_MASK_ISA_BMI2 },\n-    { \"-mlzcnt\",\tOPTION_MASK_ISA_LZCNT },\n-    { \"-mtbm\",\t\tOPTION_MASK_ISA_TBM },\n-    { \"-mpopcnt\",\tOPTION_MASK_ISA_POPCNT },\n-    { \"-msahf\",\t\tOPTION_MASK_ISA_SAHF },\n-    { \"-mcrc32\",\tOPTION_MASK_ISA_CRC32 },\n-    { \"-mfsgsbase\",\tOPTION_MASK_ISA_FSGSBASE },\n-    { \"-mrdrnd\",\tOPTION_MASK_ISA_RDRND },\n-    { \"-mpku\",\t\tOPTION_MASK_ISA_PKU },\n-    { \"-mlwp\",\t\tOPTION_MASK_ISA_LWP },\n-    { \"-mfxsr\",\t\tOPTION_MASK_ISA_FXSR },\n-    { \"-mclwb\",\t\tOPTION_MASK_ISA_CLWB },\n-    { \"-mshstk\",\tOPTION_MASK_ISA_SHSTK },\n-    { \"-mmovdiri\",\tOPTION_MASK_ISA_MOVDIRI }\n-  };\n-\n   /* Flag options.  */\n   static struct ix86_target_opts flag_opts[] =\n   {"}, {"sha": "1d46aa1d1cebb3cd6a75f123307796ad2a1c3cd5", "filename": "gcc/config/i386/i386-options.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Fi386-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Fi386-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.h?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -19,6 +19,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_I386_OPTIONS_H\n #define GCC_I386_OPTIONS_H\n \n+extern int ix86_omp_device_kind_arch_isa (enum omp_device_kind_arch_isa trait,\n+\t\t\t\t\t  const char *name);\n+\n char *ix86_target_string (HOST_WIDE_INT isa, HOST_WIDE_INT isa2,\n \t\t\t  int flags, int flags2,\n \t\t\t  const char *arch, const char *tune,"}, {"sha": "03a7082d2fc3e66b36760154b1c376e8bfa2cfad", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -23034,12 +23034,13 @@ ix86_run_selftests (void)\n   ix86_simd_clone_compute_vecsize_and_simdlen\n \n #undef TARGET_SIMD_CLONE_ADJUST\n-#define TARGET_SIMD_CLONE_ADJUST \\\n-  ix86_simd_clone_adjust\n+#define TARGET_SIMD_CLONE_ADJUST ix86_simd_clone_adjust\n \n #undef TARGET_SIMD_CLONE_USABLE\n-#define TARGET_SIMD_CLONE_USABLE \\\n-  ix86_simd_clone_usable\n+#define TARGET_SIMD_CLONE_USABLE ix86_simd_clone_usable\n+\n+#undef TARGET_OMP_DEVICE_KIND_ARCH_ISA\n+#define TARGET_OMP_DEVICE_KIND_ARCH_ISA ix86_omp_device_kind_arch_isa\n \n #undef TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P\n #define TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P \\"}, {"sha": "58f166803bf86e872313fd894848603e5e8efa88", "filename": "gcc/config/i386/t-intelmic", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Ft-intelmic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fi386%2Ft-intelmic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-intelmic?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -8,3 +8,10 @@ ALL_HOST_OBJS += mkoffload.o\n mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBDEPS)\n \t$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n \t  mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)\n+\n+omp-device-properties: $(srcdir)/config/i386/i386-options.c\n+\techo kind: cpu > omp-device-properties\n+\techo arch: x86 x86_64 i386 i486 i586 i686 ia32 >> omp-device-properties\n+\techo isa: sse4 `sed -n '/^static struct ix86_target_opts isa2\\?_opts\\[\\] =/,/^};/p' \\\n+\t  $(srcdir)/config/i386/i386-options.c | \\\n+\t  sed -n 's/\",.*$$//;s/\\./_/;s/^  { \"-m//p'` >> omp-device-properties"}, {"sha": "0d6e884085200c5487e15a62d1f25d84ac4dfd44", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -5474,6 +5474,32 @@ nvptx_simt_vf ()\n   return PTX_WARP_SIZE;\n }\n \n+/* Return 1 if TRAIT NAME is present in the OpenMP context's\n+   device trait set, return 0 if not present in any OpenMP context in the\n+   whole translation unit, or -1 if not present in the current OpenMP context\n+   but might be present in another OpenMP context in the same TU.  */\n+\n+int\n+nvptx_omp_device_kind_arch_isa (enum omp_device_kind_arch_isa trait,\n+\t\t\t\tconst char *name)\n+{\n+  switch (trait)\n+    {\n+    case omp_device_kind:\n+      return strcmp (name, \"gpu\") == 0;\n+    case omp_device_arch:\n+      return strcmp (name, \"nvptx\") == 0;\n+    case omp_device_isa:\n+      if (strcmp (name, \"sm_30\") == 0)\n+\treturn !TARGET_SM35;\n+      if (strcmp (name, \"sm_35\") == 0)\n+\treturn TARGET_SM35;\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n static bool\n nvptx_welformed_vector_length_p (int l)\n {\n@@ -6539,6 +6565,9 @@ nvptx_set_current_function (tree fndecl)\n #undef TARGET_SIMT_VF\n #define TARGET_SIMT_VF nvptx_simt_vf\n \n+#undef TARGET_OMP_DEVICE_KIND_ARCH_ISA\n+#define TARGET_OMP_DEVICE_KIND_ARCH_ISA nvptx_omp_device_kind_arch_isa\n+\n #undef TARGET_GOACC_VALIDATE_DIMS\n #define TARGET_GOACC_VALIDATE_DIMS nvptx_goacc_validate_dims\n "}, {"sha": "d692594a3773537a9f43acd8a39c6b0665d5d15c", "filename": "gcc/config/nvptx/t-nvptx", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -10,3 +10,8 @@ mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY)\n \t  mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)\n \n MULTILIB_OPTIONS = mgomp\n+\n+omp-device-properties: $(srcdir)/config/nvptx/nvptx.c\n+\techo kind: gpu > omp-device-properties\n+\techo arch: nvptx >> omp-device-properties\n+\techo isa: sm_30 sm_35 >> omp-device-properties"}, {"sha": "13935222228ad5969b8e12cbbcc2b1d80439a100", "filename": "gcc/configure", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -811,6 +811,8 @@ LN\n LN_S\n AWK\n SET_MAKE\n+omp_device_property_deps\n+omp_device_properties\n accel_dir_suffix\n real_target_noncanonical\n enable_as_accelerator\n@@ -7879,12 +7881,20 @@ fi\n \n \n for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n+  tgt_dir=`echo $tgt | sed -n 's/.*=//p'`\n   tgt=`echo $tgt | sed 's/=.*//'`\n \n   if echo \"$tgt\" | grep \"^hsa\" > /dev/null ; then\n     enable_hsa=1\n   else\n     enable_offloading=1\n+    if test -n \"$tgt_dir\"; then\n+      omp_device_property=\"${tgt_dir}/lib/gcc/\\$(real_target_noncanonical)/\\$(version)/accel/${tgt}/omp-device-properties\"\n+    else\n+      omp_device_property=\"\\$(libsubdir)/accel/${tgt}/omp-device-properties\"\n+    fi\n+    omp_device_properties=\"${omp_device_properties} ${tgt}=${omp_device_property}\"\n+    omp_device_property_deps=\"${omp_device_property_deps} ${omp_device_property}\"\n   fi\n \n   if test x\"$offload_targets\" = x; then\n@@ -7894,6 +7904,9 @@ for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n   fi\n done\n \n+\n+\n+\n cat >>confdefs.h <<_ACEOF\n #define OFFLOAD_TARGETS \"$offload_targets\"\n _ACEOF\n@@ -18851,7 +18864,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18854 \"configure\"\n+#line 18867 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -18957,7 +18970,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18960 \"configure\"\n+#line 18973 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "695e994ec9fe4175867230546ff28259ef752006", "filename": "gcc/configure.ac", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -1026,12 +1026,20 @@ AC_SUBST(real_target_noncanonical)\n AC_SUBST(accel_dir_suffix)\n \n for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n+  tgt_dir=`echo $tgt | sed -n 's/.*=//p'`\n   tgt=`echo $tgt | sed 's/=.*//'`\n \n   if echo \"$tgt\" | grep \"^hsa\" > /dev/null ; then\n     enable_hsa=1\n   else\n     enable_offloading=1\n+    if test -n \"$tgt_dir\"; then\n+      omp_device_property=\"${tgt_dir}/lib/gcc/\\$(real_target_noncanonical)/\\$(version)/accel/${tgt}/omp-device-properties\"\n+    else\n+      omp_device_property=\"\\$(libsubdir)/accel/${tgt}/omp-device-properties\"\n+    fi\n+    omp_device_properties=\"${omp_device_properties} ${tgt}=${omp_device_property}\"\n+    omp_device_property_deps=\"${omp_device_property_deps} ${omp_device_property}\"\n   fi\n \n   if test x\"$offload_targets\" = x; then\n@@ -1040,6 +1048,9 @@ for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n     offload_targets=\"$offload_targets,$tgt\"\n   fi\n done\n+AC_SUBST(omp_device_properties)\n+AC_SUBST(omp_device_property_deps)\n+\n AC_DEFINE_UNQUOTED(OFFLOAD_TARGETS, \"$offload_targets\",\n   [Define to offload targets, separated by commas.])\n if test x\"$enable_offloading\" != x; then"}, {"sha": "cd9aed9874f4e6b2b0e2f8956ed6155975e643a8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -6103,6 +6103,13 @@ to use it.\n Return number of threads in SIMT thread group on the target.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_OMP_DEVICE_KIND_ARCH_ISA (enum omp_device_kind_arch_isa @var{trait}, const char *@var{name})\n+Return 1 if @var{trait} @var{name} is present in the OpenMP context's\n+device trait set, return 0 if not present in any OpenMP context in the\n+whole translation unit, or -1 if not present in the current OpenMP context\n+but might be present in another OpenMP context in the same TU.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_GOACC_VALIDATE_DIMS (tree @var{decl}, int *@var{dims}, int @var{fn_level}, unsigned @var{used})\n This hook should check the launch dimensions provided for an OpenACC\n compute region, or routine.  Defaulted values are represented as -1"}, {"sha": "2739e9ceec5ad7253ff9135da8dbe3bf6010e8d7", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -4205,6 +4205,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_SIMT_VF\n \n+@hook TARGET_OMP_DEVICE_KIND_ARCH_ISA\n+\n @hook TARGET_GOACC_VALIDATE_DIMS\n \n @hook TARGET_GOACC_DIM_LIMIT"}, {"sha": "82f474674992ca773b6d669d20d0db9a7be8bfef", "filename": "gcc/omp-general.c", "status": "modified", "additions": 180, "deletions": 34, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"symbol-summary.h\"\n #include \"hsa-common.h\"\n #include \"tree-pass.h\"\n+#include \"omp-device-properties.h\"\n \n enum omp_requires omp_requires_mask;\n \n@@ -537,7 +538,7 @@ omp_max_simt_vf (void)\n       {\n \tif (!strncmp (c, \"nvptx\", strlen (\"nvptx\")))\n \t  return 32;\n-\telse if ((c = strchr (c, ',')))\n+\telse if ((c = strchr (c, ':')))\n \t  c++;\n       }\n   return 0;\n@@ -571,6 +572,79 @@ omp_constructor_traits_to_codes (tree ctx, enum tree_code *constructs)\n   return nconstructs;\n }\n \n+/* Return true if PROP is possibly present in one of the offloading target's\n+   OpenMP contexts.  The format of PROPS string is always offloading target's\n+   name terminated by '\\0', followed by properties for that offloading\n+   target separated by '\\0' and terminated by another '\\0'.  The strings\n+   are created from omp-device-properties installed files of all configured\n+   offloading targets.  */\n+\n+static bool\n+omp_offload_device_kind_arch_isa (const char *props, const char *prop)\n+{\n+  const char *names = getenv (\"OFFLOAD_TARGET_NAMES\");\n+  if (names == NULL || *names == '\\0')\n+    return false;\n+  while (*props != '\\0')\n+    {\n+      size_t name_len = strlen (props);\n+      bool matches = false;\n+      for (const char *c = names; c; )\n+\t{\n+\t  if (strncmp (props, c, name_len) == 0\n+\t      && (c[name_len] == '\\0'\n+\t\t  || c[name_len] == ':'\n+\t\t  || c[name_len] == '='))\n+\t    {\n+\t      matches = true;\n+\t      break;\n+\t    }\n+\t  else if ((c = strchr (c, ':')))\n+\t    c++;\n+\t}\n+      props = props + name_len + 1;\n+      while (*props != '\\0')\n+\t{\n+\t  if (matches && strcmp (props, prop) == 0)\n+\t    return true;\n+\t  props = strchr (props, '\\0') + 1;\n+\t}\n+      props++;\n+    }\n+  return false;\n+}\n+\n+/* Return true if the current code location is or might be offloaded.\n+   Return true in declare target functions, or when nested in a target\n+   region or when unsure, return false otherwise.  */\n+\n+static bool\n+omp_maybe_offloaded (void)\n+{\n+  if (!hsa_gen_requested_p ())\n+    {\n+      if (!ENABLE_OFFLOADING)\n+\treturn false;\n+      const char *names = getenv (\"OFFLOAD_TARGET_NAMES\");\n+      if (names == NULL || *names == '\\0')\n+\treturn false;\n+    }\n+  if (symtab->state == PARSING)\n+    /* Maybe.  */\n+    return true;\n+  if (current_function_decl\n+      && lookup_attribute (\"omp declare target\",\n+\t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n+    return true;\n+  if (cfun && (cfun->curr_properties & PROP_gimple_any) == 0)\n+    {\n+      enum tree_code construct = OMP_TARGET;\n+      if (omp_construct_selector_matches (&construct, 1))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Return 1 if context selector matches the current OpenMP context, 0\n    if it does not and -1 if it is unknown and need to be determined later.\n    Some properties can be checked right away during parsing (this routine),\n@@ -667,8 +741,45 @@ omp_context_selector_matches (tree ctx)\n \t\t    return 0;\n \t\t}\n \t      if (set == 'd' && !strcmp (sel, \"arch\"))\n-\t\t/* For now, need a target hook.  */\n-\t\tret = -1;\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  {\n+\t\t    const char *arch = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    int r = 0;\n+\t\t    if (targetm.omp.device_kind_arch_isa != NULL)\n+\t\t      r = targetm.omp.device_kind_arch_isa (omp_device_arch,\n+\t\t\t\t\t\t\t    arch);\n+\t\t    if (r == 0 || (r == -1 && symtab->state != PARSING))\n+\t\t      {\n+\t\t\t/* If we are or might be in a target region or\n+\t\t\t   declare target function, need to take into account\n+\t\t\t   also offloading values.  */\n+\t\t\tif (!omp_maybe_offloaded ())\n+\t\t\t  return 0;\n+\t\t\tif (strcmp (arch, \"hsa\") == 0\n+\t\t\t    && hsa_gen_requested_p ())\n+\t\t\t  {\n+\t\t\t    ret = -1;\n+\t\t\t    continue;\n+\t\t\t  }\n+\t\t\tif (ENABLE_OFFLOADING)\n+\t\t\t  {\n+\t\t\t    const char *arches = omp_offload_device_arch;\n+\t\t\t    if (omp_offload_device_kind_arch_isa (arches,\n+\t\t\t\t\t\t\t\t  arch))\n+\t\t\t      {\n+\t\t\t\tret = -1;\n+\t\t\t\tcontinue;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\treturn 0;\n+\t\t      }\n+\t\t    else if (r == -1)\n+\t\t      ret = -1;\n+\t\t    /* If arch matches on the host, it still might not match\n+\t\t       in the offloading region.  */\n+\t\t    else if (omp_maybe_offloaded ())\n+\t\t      ret = -1;\n+\t\t  }\n \t      break;\n \t    case 'u':\n \t      if (set == 'i' && !strcmp (sel, \"unified_address\"))\n@@ -729,57 +840,92 @@ omp_context_selector_matches (tree ctx)\n \t\t    const char *prop = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n \t\t    if (!strcmp (prop, \"any\"))\n \t\t      continue;\n-\t\t    if (!strcmp (prop, \"fpga\"))\n-\t\t      return 0;\t/* Right now GCC doesn't support any fpgas.  */\n \t\t    if (!strcmp (prop, \"host\"))\n \t\t      {\n-\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n+\t\t\tif (omp_maybe_offloaded ())\n \t\t\t  ret = -1;\n \t\t\tcontinue;\n \t\t      }\n \t\t    if (!strcmp (prop, \"nohost\"))\n \t\t      {\n-\t\t\tif (ENABLE_OFFLOADING || hsa_gen_requested_p ())\n+\t\t\tif (omp_maybe_offloaded ())\n \t\t\t  ret = -1;\n \t\t\telse\n \t\t\t  return 0;\n \t\t\tcontinue;\n \t\t      }\n-\t\t    if (!strcmp (prop, \"cpu\") || !strcmp (prop, \"gpu\"))\n+\t\t    int r = 0;\n+\t\t    if (targetm.omp.device_kind_arch_isa != NULL)\n+\t\t      r = targetm.omp.device_kind_arch_isa (omp_device_kind,\n+\t\t\t\t\t\t\t    prop);\n+\t\t    else\n+\t\t      r = strcmp (prop, \"cpu\") == 0;\n+\t\t    if (r == 0 || (r == -1 && symtab->state != PARSING))\n \t\t      {\n-\t\t\tbool maybe_gpu = false;\n-\t\t\tif (hsa_gen_requested_p ())\n-\t\t\t  maybe_gpu = true;\n-\t\t\telse if (ENABLE_OFFLOADING)\n-\t\t\t  for (const char *c = getenv (\"OFFLOAD_TARGET_NAMES\");\n-\t\t\t       c; )\n-\t\t\t    {\n-\t\t\t      if (!strncmp (c, \"nvptx\", strlen (\"nvptx\"))\n-\t\t\t\t  || !strncmp (c, \"amdgcn\", strlen (\"amdgcn\")))\n-\t\t\t\t{\n-\t\t\t\t  maybe_gpu = true;\n-\t\t\t\t  break;\n-\t\t\t\t}\n-\t\t\t      else if ((c = strchr (c, ',')))\n-\t\t\t\tc++;\n-\t\t\t    }\n-\t\t\tif (!maybe_gpu)\n+\t\t\t/* If we are or might be in a target region or\n+\t\t\t   declare target function, need to take into account\n+\t\t\t   also offloading values.  */\n+\t\t\tif (!omp_maybe_offloaded ())\n+\t\t\t  return 0;\n+\t\t\tif (strcmp (prop, \"gpu\") == 0\n+\t\t\t    && hsa_gen_requested_p ())\n \t\t\t  {\n-\t\t\t    if (prop[0] == 'g')\n-\t\t\t      return 0;\n+\t\t\t    ret = -1;\n+\t\t\t    continue;\n \t\t\t  }\n-\t\t\telse\n-\t\t\t  ret = -1;\n-\t\t\tcontinue;\n+\t\t\tif (ENABLE_OFFLOADING)\n+\t\t\t  {\n+\t\t\t    const char *kinds = omp_offload_device_kind;\n+\t\t\t    if (omp_offload_device_kind_arch_isa (kinds, prop))\n+\t\t\t      {\n+\t\t\t\tret = -1;\n+\t\t\t\tcontinue;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\treturn 0;\n \t\t      }\n-\t\t    /* Any other kind doesn't match.  */\n-\t\t    return 0;\n+\t\t    else if (r == -1)\n+\t\t      ret = -1;\n+\t\t    /* If kind matches on the host, it still might not match\n+\t\t       in the offloading region.  */\n+\t\t    else if (omp_maybe_offloaded ())\n+\t\t      ret = -1;\n \t\t  }\n \t      break;\n \t    case 'i':\n \t      if (set == 'd' && !strcmp (sel, \"isa\"))\n-\t\t/* For now, need a target hook.  */\n-\t\tret = -1;\n+\t\tfor (tree t3 = TREE_VALUE (t2); t3; t3 = TREE_CHAIN (t3))\n+\t\t  {\n+\t\t    const char *isa = IDENTIFIER_POINTER (TREE_PURPOSE (t3));\n+\t\t    int r = 0;\n+\t\t    if (targetm.omp.device_kind_arch_isa != NULL)\n+\t\t      r = targetm.omp.device_kind_arch_isa (omp_device_isa,\n+\t\t\t\t\t\t\t    isa);\n+\t\t    if (r == 0 || (r == -1 && symtab->state != PARSING))\n+\t\t      {\n+\t\t\t/* If we are or might be in a target region or\n+\t\t\t   declare target function, need to take into account\n+\t\t\t   also offloading values.  */\n+\t\t\tif (!omp_maybe_offloaded ())\n+\t\t\t  return 0;\n+\t\t\tif (ENABLE_OFFLOADING)\n+\t\t\t  {\n+\t\t\t    const char *isas = omp_offload_device_isa;\n+\t\t\t    if (omp_offload_device_kind_arch_isa (isas, isa))\n+\t\t\t      {\n+\t\t\t\tret = -1;\n+\t\t\t\tcontinue;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\treturn 0;\n+\t\t      }\n+\t\t    else if (r == -1)\n+\t\t      ret = -1;\n+\t\t    /* If isa matches on the host, it still might not match\n+\t\t       in the offloading region.  */\n+\t\t    else if (omp_maybe_offloaded ())\n+\t\t      ret = -1;\n+\t\t  }\n \t      break;\n \t    case 'c':\n \t      if (set == 'u' && !strcmp (sel, \"condition\"))"}, {"sha": "8e83c2c7a7136511c07a5bc9e18876c91a38b955", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -1669,6 +1669,21 @@ int, (void), NULL)\n \n HOOK_VECTOR_END (simt)\n \n+/* Functions relating to OpenMP.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_OMP_\"\n+HOOK_VECTOR (TARGET_OMP, omp)\n+\n+DEFHOOK\n+(device_kind_arch_isa,\n+\"Return 1 if @var{trait} @var{name} is present in the OpenMP context's\\n\\\n+device trait set, return 0 if not present in any OpenMP context in the\\n\\\n+whole translation unit, or -1 if not present in the current OpenMP context\\n\\\n+but might be present in another OpenMP context in the same TU.\",\n+int, (enum omp_device_kind_arch_isa trait, const char *name), NULL)\n+\n+HOOK_VECTOR_END (omp)\n+\n /* Functions relating to openacc.  */\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_GOACC_\""}, {"sha": "843c3d7887f8b49edfe9e45abf9de760176896e4", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -211,6 +211,13 @@ typedef vec<poly_uint64> vector_sizes;\n    automatically freed.  */\n typedef auto_vec<poly_uint64, 8> auto_vector_sizes;\n \n+/* First argument of targetm.omp.device_kind_arch_isa.  */\n+enum omp_device_kind_arch_isa {\n+  omp_device_kind,\n+  omp_device_arch,\n+  omp_device_isa\n+};\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "8e6588a8b0248151a50e0a5665d36ccba0c4bb07", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -1,3 +1,8 @@\n+2019-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/declare-variant-9.c: New test.\n+\t* c-c++-common/gomp/declare-variant-10.c: New test.\n+\n 2019-10-31  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/92277"}, {"sha": "ad886cfb8879c21a385a73276f1917bb71c5ac69", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-10.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-10.c?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-foffload=disable -fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-mavx512bw\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#undef i386\n+void f01 (void);\n+#pragma omp declare variant (f01) match (device={isa(avx512f,avx512bw)})\n+void f02 (void);\n+void f03 (void);\n+#pragma omp declare variant (f03) match (device={kind(any),arch(x86_64),isa(avx512f,avx512bw)})\n+void f04 (void);\n+void f05 (void);\n+#pragma omp declare variant (f05) match (device={kind(gpu)})\n+void f06 (void);\n+void f07 (void);\n+#pragma omp declare variant (f07) match (device={kind(cpu)})\n+void f08 (void);\n+void f09 (void);\n+#pragma omp declare variant (f09) match (device={isa(sm_35)})\n+void f10 (void);\n+void f11 (void);\n+#pragma omp declare variant (f11) match (device={arch(nvptx)})\n+void f12 (void);\n+void f13 (void);\n+#pragma omp declare variant (f13) match (device={arch(i386),isa(sse4)})\n+void f14 (void);\n+void f15 (void);\n+#pragma omp declare variant (f15) match (device={isa(sse4,ssse3),arch(i386)})\n+void f16 (void);\n+void f17 (void);\n+#pragma omp declare variant (f17) match (device={kind(any,fpga)})\n+void f18 (void);\n+\n+#pragma omp declare target\n+void\n+test1 (void)\n+{\n+  int i;\n+  f02 ();\t/* { dg-final { scan-tree-dump-times \"f01 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } } */\n+  f14 ();\t/* { dg-final { scan-tree-dump-times \"f13 \\\\\\(\\\\\\);\" 1 \"gimple\" { target ia32 } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! ia32 } } } } */\n+  f18 ();\t/* { dg-final { scan-tree-dump-times \"f18 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+#pragma omp end declare target\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+__attribute__((target (\"avx512f,avx512bw\")))\n+#endif\n+void\n+test2 (void)\n+{\n+  #pragma omp target\n+  f04 ();\t/* { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f04 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { ! lp64 } || { ! { i?86-*-* x86_64-*-* } } } } } } */\n+  #pragma omp target\n+  f16 ();\t/* { dg-final { scan-tree-dump-times \"f15 \\\\\\(\\\\\\);\" 1 \"gimple\" { target ia32 } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f16 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! ia32 } } } } */\n+}\n+\n+void\n+test3 (void)\n+{\n+  f06 ();\t/* { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+  f08 ();\t/* { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+}\n+#pragma omp declare target to (test3)\n+\n+void\n+test4 (void)\n+{\n+  #pragma omp target\n+  f10 ();\t/* { dg-final { scan-tree-dump-times \"f10 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+  #pragma omp target\n+  f12 ();\t/* { dg-final { scan-tree-dump-times \"f12 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* } } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { nvptx*-*-* } } } } */\n+}"}, {"sha": "21ddc56681b37ce1fed8e998942c597ab006dc01", "filename": "gcc/testsuite/c-c++-common/gomp/declare-variant-9.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-variant-9.c?ref=9ba66bf5b9c69e0e2bcd1b2ab88160bf9b2aa417", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+/* { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#undef i386\n+void f01 (void);\n+#pragma omp declare variant (f01) match (device={isa(avx512f,avx512bw)})\n+void f02 (void);\n+void f03 (void);\n+#pragma omp declare variant (f03) match (device={kind(any),arch(x86_64),isa(avx512f,avx512bw)})\n+void f04 (void);\n+void f05 (void);\n+#pragma omp declare variant (f05) match (device={kind(gpu)})\n+void f06 (void);\n+void f07 (void);\n+#pragma omp declare variant (f07) match (device={kind(cpu)})\n+void f08 (void);\n+void f09 (void);\n+#pragma omp declare variant (f09) match (device={isa(sm_35)})\n+void f10 (void);\n+void f11 (void);\n+#pragma omp declare variant (f11) match (device={arch(nvptx)})\n+void f12 (void);\n+void f13 (void);\n+#pragma omp declare variant (f13) match (device={arch(i386),isa(sse4)})\n+void f14 (void);\n+void f15 (void);\n+#pragma omp declare variant (f15) match (device={isa(sse4,ssse3),arch(i386)})\n+void f16 (void);\n+void f17 (void);\n+#pragma omp declare variant (f17) match (device={kind(any,fpga)})\n+void f18 (void);\n+\n+void\n+test1 (void)\n+{\n+  int i;\n+  f02 ();\t/* { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  f14 ();\t/* { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  f18 ();\t/* { dg-final { scan-tree-dump-times \"f18 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+}\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+__attribute__((target (\"avx512f,avx512bw\")))\n+#endif\n+void\n+test2 (void)\n+{\n+  f04 ();\t/* { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f04 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { ! lp64 } || { ! { i?86-*-* x86_64-*-* } } } } } } */\n+  f16 ();\t/* { dg-final { scan-tree-dump-times \"f15 \\\\\\(\\\\\\);\" 1 \"gimple\" { target ia32 } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f16 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! ia32 } } } } */\n+}\n+\n+void\n+test3 (void)\n+{\n+  f06 ();\t/* { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+  f08 ();\t/* { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+  f10 ();\t/* { dg-final { scan-tree-dump-times \"f10 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } } */\n+  f12 ();\t/* { dg-final { scan-tree-dump-times \"f12 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* } } } } } */\n+\t\t/* { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { nvptx*-*-* } } } } */\n+}"}]}