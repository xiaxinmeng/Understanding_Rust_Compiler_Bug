{"sha": "bd793c65b96361f4ab1f47f4c8488c664f55954b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ3OTNjNjViOTYzNjFmNGFiMWY0N2Y0Yzg0ODhjNjY0ZjU1OTU0Yg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-18T09:50:19Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-18T09:50:19Z"}, "message": "MMX/SSE builtin support\n\nFrom-SVN: r36487", "tree": {"sha": "c2e90550e0162c803177a18b3f004edce2606f9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2e90550e0162c803177a18b3f004edce2606f9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd793c65b96361f4ab1f47f4c8488c664f55954b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd793c65b96361f4ab1f47f4c8488c664f55954b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd793c65b96361f4ab1f47f4c8488c664f55954b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd793c65b96361f4ab1f47f4c8488c664f55954b/comments", "author": null, "committer": null, "parents": [{"sha": "cf67d231989b77c4689a67aa925572e52c1ce2da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf67d231989b77c4689a67aa925572e52c1ce2da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf67d231989b77c4689a67aa925572e52c1ce2da"}], "stats": {"total": 1477, "additions": 1468, "deletions": 9}, "files": [{"sha": "8145f5fffb7a0e3f567584dcafe4d8fe25e98bc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd793c65b96361f4ab1f47f4c8488c664f55954b", "patch": "@@ -2,6 +2,23 @@\n \n \t* optabs.c (emit_libcall_block): Set CONST_CALL_P for the call.\n \n+\t* i386-protos.h (ix86_init_builtins, ix86_expand_builtin): Declare.\n+\t* i386.c (struct builtin_description): New.\n+\t(bdesc_comi, bdesc_2arg, bdesc_1arg): New arrays.\n+\t(mmx_reg_operand): Declare MODE arg as unused.\n+\t(ix86_expand_sse_comi, ix86_expand_sse_compare, safe_vector_operand,\n+\tix86_expand_unop1_builtin, ix86_expand_unop_builtin,\n+\tix86_expand_binop_builtin, ix86_expand_store_builtin,\n+\tix86_init_builtins, ix86_expand_builtin): New functions.\n+\t* i386.h (ix86_builtins): New enumeration.\n+\t(MD_INIT_BUILTINS, MD_EXPAND_BUILTIN): New macros.\n+\t* i386.md (attr length_immediate): 0 for mmx/sse types.\n+\t(attr prefix_0f): 1 for mmx/sse types.\n+\t(setcc_2): Remove \"*\" so we get gen_setcc_2.\n+\t(emms): Account for changed register numbering.  Set \"memory\" attr\n+\tto unknown.\n+\t(sfence): Set \"memory\" attr to unknown.\n+\n 2000-09-18  Andreas Jaeger  <aj@suse.de>\n \n \t* configure.in: Define _GNU_SOURCE only when using the GNU C"}, {"sha": "263f52688591738d0847ed36d314ae07f1d222c5", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=bd793c65b96361f4ab1f47f4c8488c664f55954b", "patch": "@@ -131,6 +131,8 @@ extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));\n extern rtx function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\ttree, int));\n+extern void ix86_init_builtins PARAMS ((void));\n+extern rtx ix86_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n #endif\n \n #endif"}, {"sha": "2dbac7abef4e9ea956507e248c3c2c0a6b75ada5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1223, "deletions": 1, "changes": 1224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bd793c65b96361f4ab1f47f4c8488c664f55954b", "patch": "@@ -426,6 +426,17 @@ struct ix86_address\n };\n \n static int ix86_decompose_address PARAMS ((rtx, struct ix86_address *));\n+\n+struct builtin_description;\n+static rtx ix86_expand_sse_comi PARAMS ((struct builtin_description *, tree,\n+\t\t\t\t\t rtx));\n+static rtx ix86_expand_sse_compare PARAMS ((struct builtin_description *, tree,\n+\t\t\t\t\t    rtx));\n+static rtx ix86_expand_unop1_builtin PARAMS ((enum insn_code, tree, rtx));\n+static rtx ix86_expand_unop_builtin PARAMS ((enum insn_code, tree, rtx, int));\n+static rtx ix86_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));\n+static rtx ix86_expand_store_builtin PARAMS ((enum insn_code, tree, int));\n+static rtx safe_vector_operand PARAMS ((rtx, enum machine_mode));\n \f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -1177,7 +1188,7 @@ reg_no_sp_operand (op, mode)\n int\n mmx_reg_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return MMX_REG_P (op);\n }\n@@ -7053,3 +7064,1214 @@ ix86_local_alignment (type, align)\n     }\n   return align;\n }\n+\n+#define def_builtin(NAME, TYPE, CODE) \\\n+  builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL_PTR)\n+struct builtin_description\n+{\n+  enum insn_code icode;\n+  const char * name;\n+  enum ix86_builtins code;\n+  enum rtx_code comparison;\n+  unsigned int flag;\n+};\n+\n+static struct builtin_description bdesc_comi[] =\n+{\n+  { CODE_FOR_sse_comi, \"__builtin_ia32_comieq\", IX86_BUILTIN_COMIEQSS, EQ, 0 },\n+  { CODE_FOR_sse_comi, \"__builtin_ia32_comilt\", IX86_BUILTIN_COMILTSS, LT, 0 },\n+  { CODE_FOR_sse_comi, \"__builtin_ia32_comile\", IX86_BUILTIN_COMILESS, LE, 0 },\n+  { CODE_FOR_sse_comi, \"__builtin_ia32_comigt\", IX86_BUILTIN_COMIGTSS, LT, 1 },\n+  { CODE_FOR_sse_comi, \"__builtin_ia32_comige\", IX86_BUILTIN_COMIGESS, LE, 1 },\n+  { CODE_FOR_sse_comi, \"__builtin_ia32_comineq\", IX86_BUILTIN_COMINEQSS, NE, 0 },\n+  { CODE_FOR_sse_ucomi, \"__builtin_ia32_ucomieq\", IX86_BUILTIN_UCOMIEQSS, EQ, 0 },\n+  { CODE_FOR_sse_ucomi, \"__builtin_ia32_ucomilt\", IX86_BUILTIN_UCOMILTSS, LT, 0 },\n+  { CODE_FOR_sse_ucomi, \"__builtin_ia32_ucomile\", IX86_BUILTIN_UCOMILESS, LE, 0 },\n+  { CODE_FOR_sse_ucomi, \"__builtin_ia32_ucomigt\", IX86_BUILTIN_UCOMIGTSS, LT, 1 },\n+  { CODE_FOR_sse_ucomi, \"__builtin_ia32_ucomige\", IX86_BUILTIN_UCOMIGESS, LE, 1 },\n+  { CODE_FOR_sse_ucomi, \"__builtin_ia32_ucomineq\", IX86_BUILTIN_UCOMINEQSS, NE, 0 }\n+};\n+\n+static struct builtin_description bdesc_2arg[] =\n+{\n+  /* SSE */\n+  { CODE_FOR_addv4sf3, \"__builtin_ia32_addps\", IX86_BUILTIN_ADDPS, 0, 0 },\n+  { CODE_FOR_subv4sf3, \"__builtin_ia32_subps\", IX86_BUILTIN_SUBPS, 0, 0 },\n+  { CODE_FOR_mulv4sf3, \"__builtin_ia32_mulps\", IX86_BUILTIN_MULPS, 0, 0 },\n+  { CODE_FOR_divv4sf3, \"__builtin_ia32_divps\", IX86_BUILTIN_DIVPS, 0, 0 },\n+  { CODE_FOR_vmaddv4sf3,  \"__builtin_ia32_addss\", IX86_BUILTIN_ADDSS, 0, 0 },\n+  { CODE_FOR_vmsubv4sf3,  \"__builtin_ia32_subss\", IX86_BUILTIN_SUBSS, 0, 0 },\n+  { CODE_FOR_vmmulv4sf3,  \"__builtin_ia32_mulss\", IX86_BUILTIN_MULSS, 0, 0 },\n+  { CODE_FOR_vmdivv4sf3,  \"__builtin_ia32_divss\", IX86_BUILTIN_DIVSS, 0, 0 },\n+\n+  { CODE_FOR_maskcmpv4sf3, \"__builtin_ia32_cmpeqps\", IX86_BUILTIN_CMPEQPS, EQ, 0 },\n+  { CODE_FOR_maskcmpv4sf3, \"__builtin_ia32_cmpltps\", IX86_BUILTIN_CMPLTPS, LT, 0 },\n+  { CODE_FOR_maskcmpv4sf3, \"__builtin_ia32_cmpleps\", IX86_BUILTIN_CMPLEPS, LE, 0 },\n+  { CODE_FOR_maskcmpv4sf3, \"__builtin_ia32_cmpgtps\", IX86_BUILTIN_CMPGTPS, LT, 1 },\n+  { CODE_FOR_maskcmpv4sf3, \"__builtin_ia32_cmpgeps\", IX86_BUILTIN_CMPGEPS, LE, 1 },\n+  { CODE_FOR_maskcmpv4sf3, \"__builtin_ia32_cmpunordps\", IX86_BUILTIN_CMPUNORDPS, UNORDERED, 0 },\n+  { CODE_FOR_maskncmpv4sf3, \"__builtin_ia32_cmpneqps\", IX86_BUILTIN_CMPNEQPS, EQ, 0 },\n+  { CODE_FOR_maskncmpv4sf3, \"__builtin_ia32_cmpnltps\", IX86_BUILTIN_CMPNLTPS, LT, 0 },\n+  { CODE_FOR_maskncmpv4sf3, \"__builtin_ia32_cmpnleps\", IX86_BUILTIN_CMPNLEPS, LE, 0 },\n+  { CODE_FOR_maskncmpv4sf3, \"__builtin_ia32_cmpngtps\", IX86_BUILTIN_CMPNGTPS, LT, 1 },\n+  { CODE_FOR_maskncmpv4sf3, \"__builtin_ia32_cmpngeps\", IX86_BUILTIN_CMPNGEPS, LE, 1 },\n+  { CODE_FOR_maskncmpv4sf3, \"__builtin_ia32_cmpordps\", IX86_BUILTIN_CMPORDPS, UNORDERED, 0 },\n+  { CODE_FOR_vmmaskcmpv4sf3, \"__builtin_ia32_cmpeqss\", IX86_BUILTIN_CMPEQSS, EQ, 0 },\n+  { CODE_FOR_vmmaskcmpv4sf3, \"__builtin_ia32_cmpltss\", IX86_BUILTIN_CMPLTSS, LT, 0 },\n+  { CODE_FOR_vmmaskcmpv4sf3, \"__builtin_ia32_cmpless\", IX86_BUILTIN_CMPLESS, LE, 0 },\n+  { CODE_FOR_vmmaskcmpv4sf3, \"__builtin_ia32_cmpgtss\", IX86_BUILTIN_CMPGTSS, LT, 1 },\n+  { CODE_FOR_vmmaskcmpv4sf3, \"__builtin_ia32_cmpgess\", IX86_BUILTIN_CMPGESS, LE, 1 },\n+  { CODE_FOR_vmmaskcmpv4sf3, \"__builtin_ia32_cmpunordss\", IX86_BUILTIN_CMPUNORDSS, UNORDERED, 0 },\n+  { CODE_FOR_vmmaskncmpv4sf3, \"__builtin_ia32_cmpneqss\", IX86_BUILTIN_CMPNEQSS, EQ, 0 },\n+  { CODE_FOR_vmmaskncmpv4sf3, \"__builtin_ia32_cmpnltss\", IX86_BUILTIN_CMPNLTSS, LT, 0 },\n+  { CODE_FOR_vmmaskncmpv4sf3, \"__builtin_ia32_cmpnless\", IX86_BUILTIN_CMPNLESS, LE, 0 },\n+  { CODE_FOR_vmmaskncmpv4sf3, \"__builtin_ia32_cmpngtss\", IX86_BUILTIN_CMPNGTSS, LT, 1 },\n+  { CODE_FOR_vmmaskncmpv4sf3, \"__builtin_ia32_cmpngess\", IX86_BUILTIN_CMPNGESS, LE, 1 },\n+  { CODE_FOR_vmmaskncmpv4sf3, \"__builtin_ia32_cmpordss\", IX86_BUILTIN_CMPORDSS, UNORDERED, 0 },\n+\n+  { CODE_FOR_sminv4sf3, \"__builtin_ia32_minps\", IX86_BUILTIN_MINPS, 0, 0 },\n+  { CODE_FOR_smaxv4sf3, \"__builtin_ia32_maxps\", IX86_BUILTIN_MAXPS, 0, 0 },\n+  { CODE_FOR_vmsminv4sf3, \"__builtin_ia32_minss\", IX86_BUILTIN_MINSS, 0, 0 },\n+  { CODE_FOR_vmsmaxv4sf3, \"__builtin_ia32_maxss\", IX86_BUILTIN_MAXSS, 0, 0 },\n+\n+  { CODE_FOR_sse_andti3, \"__builtin_ia32_andps\", IX86_BUILTIN_ANDPS, 0, 0 },\n+  { CODE_FOR_sse_nandti3,  \"__builtin_ia32_andnps\", IX86_BUILTIN_ANDNPS, 0, 0 },\n+  { CODE_FOR_sse_iorti3, \"__builtin_ia32_orps\", IX86_BUILTIN_ORPS, 0, 0 },\n+  { CODE_FOR_sse_xorti3,  \"__builtin_ia32_xorps\", IX86_BUILTIN_XORPS, 0, 0 },\n+\n+  { CODE_FOR_sse_movss,  \"__builtin_ia32_movss\", IX86_BUILTIN_MOVSS, 0, 0 },\n+  { CODE_FOR_sse_movhlps,  \"__builtin_ia32_movhlps\", IX86_BUILTIN_MOVHLPS, 0, 0 },\n+  { CODE_FOR_sse_movlhps,  \"__builtin_ia32_movlhps\", IX86_BUILTIN_MOVLHPS, 0, 0 },\n+  { CODE_FOR_sse_unpckhps, \"__builtin_ia32_unpckhps\", IX86_BUILTIN_UNPCKHPS, 0, 0 },\n+  { CODE_FOR_sse_unpcklps, \"__builtin_ia32_unpcklps\", IX86_BUILTIN_UNPCKLPS, 0, 0 },\n+\n+  /* MMX */\n+  { CODE_FOR_addv8qi3, \"__builtin_ia32_paddb\", IX86_BUILTIN_PADDB, 0, 0 },\n+  { CODE_FOR_addv4hi3, \"__builtin_ia32_paddw\", IX86_BUILTIN_PADDW, 0, 0 },\n+  { CODE_FOR_addv2si3, \"__builtin_ia32_paddd\", IX86_BUILTIN_PADDD, 0, 0 },\n+  { CODE_FOR_subv8qi3, \"__builtin_ia32_psubb\", IX86_BUILTIN_PSUBB, 0, 0 },\n+  { CODE_FOR_subv4hi3, \"__builtin_ia32_psubw\", IX86_BUILTIN_PSUBW, 0, 0 },\n+  { CODE_FOR_subv2si3, \"__builtin_ia32_psubd\", IX86_BUILTIN_PSUBD, 0, 0 },\n+\n+  { CODE_FOR_ssaddv8qi3, \"__builtin_ia32_paddsb\", IX86_BUILTIN_PADDSB, 0, 0 },\n+  { CODE_FOR_ssaddv4hi3, \"__builtin_ia32_paddsw\", IX86_BUILTIN_PADDSW, 0, 0 },\n+  { CODE_FOR_sssubv8qi3, \"__builtin_ia32_psubsb\", IX86_BUILTIN_PSUBSB, 0, 0 },\n+  { CODE_FOR_sssubv4hi3, \"__builtin_ia32_psubsw\", IX86_BUILTIN_PSUBSW, 0, 0 },\n+  { CODE_FOR_usaddv8qi3, \"__builtin_ia32_paddusb\", IX86_BUILTIN_PADDUSB, 0, 0 },\n+  { CODE_FOR_usaddv4hi3, \"__builtin_ia32_paddusw\", IX86_BUILTIN_PADDUSW, 0, 0 },\n+  { CODE_FOR_ussubv8qi3, \"__builtin_ia32_psubusb\", IX86_BUILTIN_PSUBUSB, 0, 0 },\n+  { CODE_FOR_ussubv4hi3, \"__builtin_ia32_psubusw\", IX86_BUILTIN_PSUBUSW, 0, 0 },\n+\n+  { CODE_FOR_mulv4hi3, \"__builtin_ia32_pmullw\", IX86_BUILTIN_PMULLW, 0, 0 },\n+  { CODE_FOR_smulv4hi3_highpart, \"__builtin_ia32_pmulhw\", IX86_BUILTIN_PMULHW, 0, 0 },\n+  { CODE_FOR_umulv4hi3_highpart, \"__builtin_ia32_pmulhuw\", IX86_BUILTIN_PMULHUW, 0, 0 },\n+\n+  { CODE_FOR_mmx_anddi3, \"__builtin_ia32_pand\", IX86_BUILTIN_PAND, 0, 0 },\n+  { CODE_FOR_mmx_nanddi3, \"__builtin_ia32_pandn\", IX86_BUILTIN_PANDN, 0, 0 },\n+  { CODE_FOR_mmx_iordi3, \"__builtin_ia32_por\", IX86_BUILTIN_POR, 0, 0 },\n+  { CODE_FOR_mmx_xordi3, \"__builtin_ia32_pxor\", IX86_BUILTIN_PXOR, 0, 0 },\n+\n+  { CODE_FOR_mmx_uavgv8qi3, \"__builtin_ia32_pavgb\", IX86_BUILTIN_PAVGB, 0, 0 },\n+  { CODE_FOR_mmx_uavgv4hi3, \"__builtin_ia32_pavgw\", IX86_BUILTIN_PAVGW, 0, 0 },\n+\n+  { CODE_FOR_eqv8qi3, \"__builtin_ia32_pcmpeqb\", IX86_BUILTIN_PCMPEQB, 0, 0 },\n+  { CODE_FOR_eqv4hi3, \"__builtin_ia32_pcmpeqw\", IX86_BUILTIN_PCMPEQW, 0, 0 },\n+  { CODE_FOR_eqv2si3, \"__builtin_ia32_pcmpeqd\", IX86_BUILTIN_PCMPEQD, 0, 0 },\n+  { CODE_FOR_gtv8qi3, \"__builtin_ia32_pcmpgtb\", IX86_BUILTIN_PCMPGTB, 0, 0 },\n+  { CODE_FOR_gtv4hi3, \"__builtin_ia32_pcmpgtw\", IX86_BUILTIN_PCMPGTW, 0, 0 },\n+  { CODE_FOR_gtv2si3, \"__builtin_ia32_pcmpgtd\", IX86_BUILTIN_PCMPGTD, 0, 0 },\n+\n+  { CODE_FOR_umaxv8qi3, \"__builtin_ia32_pmaxub\", IX86_BUILTIN_PMAXUB, 0, 0 },\n+  { CODE_FOR_smaxv4hi3, \"__builtin_ia32_pmaxsw\", IX86_BUILTIN_PMAXSW, 0, 0 },\n+  { CODE_FOR_uminv8qi3, \"__builtin_ia32_pminub\", IX86_BUILTIN_PMINUB, 0, 0 },\n+  { CODE_FOR_sminv4hi3, \"__builtin_ia32_pminsw\", IX86_BUILTIN_PMINSW, 0, 0 },\n+\n+  { CODE_FOR_mmx_punpckhbw, \"__builtin_ia32_punpckhbw\", IX86_BUILTIN_PUNPCKHBW, 0, 0 },\n+  { CODE_FOR_mmx_punpckhwd, \"__builtin_ia32_punpckhwd\", IX86_BUILTIN_PUNPCKHWD, 0, 0 },\n+  { CODE_FOR_mmx_punpckhdq, \"__builtin_ia32_punpckhdq\", IX86_BUILTIN_PUNPCKHDQ, 0, 0 },\n+  { CODE_FOR_mmx_punpcklbw, \"__builtin_ia32_punpcklbw\", IX86_BUILTIN_PUNPCKLBW, 0, 0 },\n+  { CODE_FOR_mmx_punpcklwd, \"__builtin_ia32_punpcklwd\", IX86_BUILTIN_PUNPCKLWD, 0, 0 },\n+  { CODE_FOR_mmx_punpckldq, \"__builtin_ia32_punpckldq\", IX86_BUILTIN_PUNPCKLDQ, 0, 0 },\n+\n+  /* Special.  */\n+  { CODE_FOR_mmx_packsswb, 0, IX86_BUILTIN_PACKSSWB, 0, 0 },\n+  { CODE_FOR_mmx_packssdw, 0, IX86_BUILTIN_PACKSSDW, 0, 0 },\n+  { CODE_FOR_mmx_packuswb, 0, IX86_BUILTIN_PACKUSWB, 0, 0 },\n+\n+  { CODE_FOR_cvtpi2ps, 0, IX86_BUILTIN_CVTPI2PS, 0, 0 },\n+  { CODE_FOR_cvtsi2ss, 0, IX86_BUILTIN_CVTSI2SS, 0, 0 },\n+\n+  { CODE_FOR_ashlv4hi3, 0, IX86_BUILTIN_PSLLW, 0, 0 },\n+  { CODE_FOR_ashlv4hi3, 0, IX86_BUILTIN_PSLLWI, 0, 0 },\n+  { CODE_FOR_ashlv2si3, 0, IX86_BUILTIN_PSLLD, 0, 0 },\n+  { CODE_FOR_ashlv2si3, 0, IX86_BUILTIN_PSLLDI, 0, 0 },\n+  { CODE_FOR_mmx_ashldi3, 0, IX86_BUILTIN_PSLLQ, 0, 0 },\n+  { CODE_FOR_mmx_ashldi3, 0, IX86_BUILTIN_PSLLQI, 0, 0 },\n+\n+  { CODE_FOR_lshrv4hi3, 0, IX86_BUILTIN_PSRLW, 0, 0 },\n+  { CODE_FOR_lshrv4hi3, 0, IX86_BUILTIN_PSRLWI, 0, 0 },\n+  { CODE_FOR_lshrv2si3, 0, IX86_BUILTIN_PSRLD, 0, 0 },\n+  { CODE_FOR_lshrv2si3, 0, IX86_BUILTIN_PSRLDI, 0, 0 },\n+  { CODE_FOR_mmx_lshrdi3, 0, IX86_BUILTIN_PSRLQ, 0, 0 },\n+  { CODE_FOR_mmx_lshrdi3, 0, IX86_BUILTIN_PSRLQI, 0, 0 },\n+\n+  { CODE_FOR_ashrv4hi3, 0, IX86_BUILTIN_PSRAW, 0, 0 },\n+  { CODE_FOR_ashrv4hi3, 0, IX86_BUILTIN_PSRAWI, 0, 0 },\n+  { CODE_FOR_ashrv2si3, 0, IX86_BUILTIN_PSRAD, 0, 0 },\n+  { CODE_FOR_ashrv2si3, 0, IX86_BUILTIN_PSRADI, 0, 0 },\n+\n+  { CODE_FOR_mmx_psadbw, 0, IX86_BUILTIN_PSADBW, 0, 0 },\n+  { CODE_FOR_mmx_pmaddwd, 0, IX86_BUILTIN_PMADDWD, 0, 0 }\n+\n+};\n+\n+static struct builtin_description bdesc_1arg[] =\n+{\n+  { CODE_FOR_mmx_pmovmskb, 0, IX86_BUILTIN_PMOVMSKB, 0, 0 },\n+  { CODE_FOR_sse_movmskps, 0, IX86_BUILTIN_MOVMSKPS, 0, 0 },\n+\n+  { CODE_FOR_sqrtv4sf2, 0, IX86_BUILTIN_SQRTPS, 0, 0 },\n+  { CODE_FOR_rsqrtv4sf2, 0, IX86_BUILTIN_RSQRTPS, 0, 0 },\n+  { CODE_FOR_rcpv4sf2, 0, IX86_BUILTIN_RCPPS, 0, 0 },\n+\n+  { CODE_FOR_cvtps2pi, 0, IX86_BUILTIN_CVTPS2PI, 0, 0 },\n+  { CODE_FOR_cvtss2si, 0, IX86_BUILTIN_CVTSS2SI, 0, 0 },\n+  { CODE_FOR_cvttps2pi, 0, IX86_BUILTIN_CVTTPS2PI, 0, 0 },\n+  { CODE_FOR_cvttss2si, 0, IX86_BUILTIN_CVTTSS2SI, 0, 0 }\n+\n+};\n+\n+/* Expand all the target specific builtins.  This is not called if TARGET_MMX\n+   is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX\n+   builtins.  */\n+void\n+ix86_init_builtins ()\n+{\n+  struct builtin_description * d;\n+  int i;\n+  tree endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+\n+  tree pchar_type_node = build_pointer_type (char_type_node);\n+  tree pfloat_type_node = build_pointer_type (float_type_node);\n+  tree pv2si_type_node = build_pointer_type (V2SI_type_node);\n+  tree pdi_type_node = build_pointer_type (long_long_unsigned_type_node);\n+\n+  /* Comparisons.  */\n+  tree int_ftype_v4sf_v4sf\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t V4SF_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4si_ftype_v4sf_v4sf\n+    = build_function_type (V4SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t V4SF_type_node,\n+\t\t\t\t\t\t endlink)));\n+  /* MMX/SSE/integer conversions.  */\n+  tree int_ftype_v4sf_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree int_ftype_v4sf\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      endlink));\n+  tree int_ftype_v8qi\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      endlink));\n+  tree int_ftype_v2si\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      endlink));\n+  tree v2si_ftype_int\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t      endlink));\n+  tree v4sf_ftype_v4sf_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4sf_ftype_v4sf_v2si\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree int_ftype_v4hi_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v4hi_int_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  /* Miscellaneous.  */\n+  tree v8qi_ftype_v4hi_v4hi\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v2si_v2si\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4sf_ftype_v4sf_v4sf_int\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  tree v4hi_ftype_v8qi_v8qi\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v4hi_v4hi\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v4hi_int\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree di_ftype_di_int\n+    = build_function_type (long_long_unsigned_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_long_unsigned_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v8qi_ftype_v8qi_di\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v4hi_di\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v2si_di\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree void_ftype_void\n+    = build_function_type (void_type_node, endlink);\n+  tree void_ftype_pchar_int\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, pchar_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree void_ftype_unsigned\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, unsigned_type_node,\n+\t\t\t\t      endlink));\n+  tree unsigned_ftype_void\n+    = build_function_type (unsigned_type_node, endlink);\n+  tree di_ftype_void\n+    = build_function_type (long_long_unsigned_type_node, endlink);\n+  tree ti_ftype_void\n+    = build_function_type (intTI_type_node, endlink);\n+  tree v2si_ftype_v4sf\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      endlink));\n+  /* Loads/stores.  */\n+  tree maskmovq_args = tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t  tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t\t     tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\tpchar_type_node,\n+\t\t\t\t\t\t\tendlink)));\n+  tree void_ftype_v8qi_v8qi_pchar\n+    = build_function_type (void_type_node, maskmovq_args);\n+  tree v4sf_ftype_pfloat\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, pfloat_type_node,\n+\t\t\t\t      endlink));\n+  tree v4sf_ftype_float\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, float_type_node,\n+\t\t\t\t      endlink));\n+  tree v4sf_ftype_float_float_float_float\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, float_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, float_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    float_type_node,\n+\t\t\t\t\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t\t       float_type_node,\n+\t\t\t\t\t\t\t\t       endlink)))));\n+  /* @@@ the type is bogus */\n+  tree v4sf_ftype_v4sf_pv2si\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, pv2si_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4sf_ftype_pv2si_v4sf\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, pv2si_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree void_ftype_pfloat_v4sf\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, pfloat_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree void_ftype_pdi_di\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, pdi_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_unsigned_type_node,\n+\t\t\t\t\t\t endlink)));\n+  /* Normal vector unops.  */\n+  tree v4sf_ftype_v4sf\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      endlink));\n+\t\t\t   \n+  /* Normal vector binops.  */\n+  tree v4sf_ftype_v4sf_v4sf\n+    = build_function_type (V4SF_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4SF_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v8qi_ftype_v8qi_v8qi\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v4hi_v4hi\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v2si_v2si\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree ti_ftype_ti_ti\n+    = build_function_type (intTI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, intTI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, intTI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree di_ftype_di_di\n+    = build_function_type (long_long_unsigned_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_long_unsigned_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_unsigned_type_node,\n+\t\t\t\t\t\t endlink)));\n+\n+  /* Add all builtins that are more or less simple operations on two\n+     operands.  */\n+  for (i = 0, d = bdesc_2arg; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n+    {\n+      /* Use one of the operands; the target can have a different mode for\n+\t mask-generating compares.  */\n+      enum machine_mode mode;\n+      tree type;\n+\n+      if (d->name == 0)\n+\tcontinue;\n+      mode = insn_data[d->icode].operand[1].mode;\n+\n+      if (! TARGET_SSE && ! VALID_MMX_REG_MODE (mode))\n+\tcontinue;\n+\n+      switch (mode)\n+\t{\n+\tcase V4SFmode:\n+\t  type = v4sf_ftype_v4sf_v4sf;\n+\t  break;\n+\tcase V8QImode:\n+\t  type = v8qi_ftype_v8qi_v8qi;\n+\t  break;\n+\tcase V4HImode:\n+\t  type = v4hi_ftype_v4hi_v4hi;\n+\t  break;\n+\tcase V2SImode:\n+\t  type = v2si_ftype_v2si_v2si;\n+\t  break;\n+\tcase TImode:\n+\t  type = ti_ftype_ti_ti;\n+\t  break;\n+\tcase DImode:\n+\t  type = di_ftype_di_di;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      \n+      /* Override for comparisons.  */\n+      if (d->icode == CODE_FOR_maskcmpv4sf3\n+\t  || d->icode == CODE_FOR_maskncmpv4sf3\n+\t  || d->icode == CODE_FOR_vmmaskcmpv4sf3\n+\t  || d->icode == CODE_FOR_vmmaskncmpv4sf3)\n+\ttype = v4si_ftype_v4sf_v4sf;\n+\n+      def_builtin (d->name, type, d->code);\n+    }\n+\n+  /* Add the remaining MMX insns with somewhat more complicated types.  */\n+  def_builtin (\"__builtin_ia32_m_from_int\", v2si_ftype_int, IX86_BUILTIN_M_FROM_INT);\n+  def_builtin (\"__builtin_ia32_m_to_int\", int_ftype_v2si, IX86_BUILTIN_M_TO_INT);\n+  def_builtin (\"__builtin_ia32_mmx_zero\", di_ftype_void, IX86_BUILTIN_MMX_ZERO);\n+  def_builtin (\"__builtin_ia32_emms\", void_ftype_void, IX86_BUILTIN_EMMS);\n+  def_builtin (\"__builtin_ia32_ldmxcsr\", void_ftype_unsigned, IX86_BUILTIN_LDMXCSR);\n+  def_builtin (\"__builtin_ia32_stmxcsr\", unsigned_ftype_void, IX86_BUILTIN_STMXCSR);\n+  def_builtin (\"__builtin_ia32_psllw\", v4hi_ftype_v4hi_di, IX86_BUILTIN_PSLLW);\n+  def_builtin (\"__builtin_ia32_pslld\", v2si_ftype_v2si_di, IX86_BUILTIN_PSLLD);\n+  def_builtin (\"__builtin_ia32_psllq\", di_ftype_di_di, IX86_BUILTIN_PSLLQ);\n+\n+  def_builtin (\"__builtin_ia32_psrlw\", v4hi_ftype_v4hi_di, IX86_BUILTIN_PSRLW);\n+  def_builtin (\"__builtin_ia32_psrld\", v2si_ftype_v2si_di, IX86_BUILTIN_PSRLD);\n+  def_builtin (\"__builtin_ia32_psrlq\", di_ftype_di_di, IX86_BUILTIN_PSRLQ);\n+\n+  def_builtin (\"__builtin_ia32_psraw\", v4hi_ftype_v4hi_di, IX86_BUILTIN_PSRAW);\n+  def_builtin (\"__builtin_ia32_psrad\", v2si_ftype_v2si_di, IX86_BUILTIN_PSRAD);\n+\n+  def_builtin (\"__builtin_ia32_pshufw\", v4hi_ftype_v4hi_int, IX86_BUILTIN_PSHUFW);\n+  def_builtin (\"__builtin_ia32_pmaddwd\", v2si_ftype_v4hi_v4hi, IX86_BUILTIN_PMADDWD);\n+\n+  /* Everything beyond this point is SSE only.  */\n+  if (! TARGET_SSE)\n+    return;\n+  \n+  /* comi/ucomi insns.  */\n+  for (i = 0, d = bdesc_comi; i < sizeof (bdesc_comi) / sizeof *d; i++, d++)\n+    def_builtin (d->name, int_ftype_v4sf_v4sf, d->code);\n+\n+  def_builtin (\"__builtin_ia32_packsswb\", v8qi_ftype_v4hi_v4hi, IX86_BUILTIN_PACKSSWB);\n+  def_builtin (\"__builtin_ia32_packssdw\", v4hi_ftype_v2si_v2si, IX86_BUILTIN_PACKSSDW);\n+  def_builtin (\"__builtin_ia32_packuswb\", v8qi_ftype_v4hi_v4hi, IX86_BUILTIN_PACKUSWB);\n+\n+  def_builtin (\"__builtin_ia32_cvtpi2ps\", v4sf_ftype_v4sf_v2si, IX86_BUILTIN_CVTPI2PS);\n+  def_builtin (\"__builtin_ia32_cvtps2pi\", v2si_ftype_v4sf, IX86_BUILTIN_CVTPS2PI);\n+  def_builtin (\"__builtin_ia32_cvtsi2ss\", v4sf_ftype_v4sf_int, IX86_BUILTIN_CVTSI2SS);\n+  def_builtin (\"__builtin_ia32_cvtss2si\", int_ftype_v4sf, IX86_BUILTIN_CVTSS2SI);\n+  def_builtin (\"__builtin_ia32_cvttps2pi\", v2si_ftype_v4sf, IX86_BUILTIN_CVTTPS2PI);\n+  def_builtin (\"__builtin_ia32_cvttss2si\", int_ftype_v4sf, IX86_BUILTIN_CVTTSS2SI);\n+\n+  def_builtin (\"__builtin_ia32_pextrw\", int_ftype_v4hi_int, IX86_BUILTIN_PEXTRW);\n+  def_builtin (\"__builtin_ia32_pinsrw\", v4hi_ftype_v4hi_int_int, IX86_BUILTIN_PINSRW);\n+\n+  def_builtin (\"__builtin_ia32_maskmovq\", void_ftype_v8qi_v8qi_pchar, IX86_BUILTIN_MASKMOVQ);\n+\n+  def_builtin (\"__builtin_ia32_loadaps\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADAPS);\n+  def_builtin (\"__builtin_ia32_loadups\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADUPS);\n+  def_builtin (\"__builtin_ia32_loadss\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADSS);\n+  def_builtin (\"__builtin_ia32_storeaps\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREAPS);\n+  def_builtin (\"__builtin_ia32_storeups\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREUPS);\n+  def_builtin (\"__builtin_ia32_storess\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STORESS);\n+\n+  def_builtin (\"__builtin_ia32_loadhps\", v4sf_ftype_v4sf_pv2si, IX86_BUILTIN_LOADHPS);\n+  def_builtin (\"__builtin_ia32_loadlps\", v4sf_ftype_v4sf_pv2si, IX86_BUILTIN_LOADLPS);\n+  def_builtin (\"__builtin_ia32_storehps\", v4sf_ftype_pv2si_v4sf, IX86_BUILTIN_STOREHPS);\n+  def_builtin (\"__builtin_ia32_storelps\", v4sf_ftype_pv2si_v4sf, IX86_BUILTIN_STORELPS);\n+\n+  def_builtin (\"__builtin_ia32_movmskps\", int_ftype_v4sf, IX86_BUILTIN_MOVMSKPS);\n+  def_builtin (\"__builtin_ia32_pmovmskb\", int_ftype_v8qi, IX86_BUILTIN_PMOVMSKB);\n+  def_builtin (\"__builtin_ia32_movntps\", void_ftype_pfloat_v4sf, IX86_BUILTIN_MOVNTPS);\n+  def_builtin (\"__builtin_ia32_movntq\", void_ftype_pdi_di, IX86_BUILTIN_MOVNTQ);\n+\n+  def_builtin (\"__builtin_ia32_sfence\", void_ftype_void, IX86_BUILTIN_SFENCE);\n+  def_builtin (\"__builtin_ia32_prefetch\", void_ftype_pchar_int, IX86_BUILTIN_PREFETCH);\n+\n+  def_builtin (\"__builtin_ia32_psadbw\", v4hi_ftype_v8qi_v8qi, IX86_BUILTIN_PSADBW);\n+\n+  def_builtin (\"__builtin_ia32_rcpps\", v4sf_ftype_v4sf, IX86_BUILTIN_RCPPS);\n+  def_builtin (\"__builtin_ia32_rcpss\", v4sf_ftype_v4sf, IX86_BUILTIN_RCPSS);\n+  def_builtin (\"__builtin_ia32_rsqrtps\", v4sf_ftype_v4sf, IX86_BUILTIN_RSQRTPS);\n+  def_builtin (\"__builtin_ia32_rsqrtss\", v4sf_ftype_v4sf, IX86_BUILTIN_RSQRTSS);\n+  def_builtin (\"__builtin_ia32_sqrtps\", v4sf_ftype_v4sf, IX86_BUILTIN_SQRTPS);\n+  def_builtin (\"__builtin_ia32_sqrtss\", v4sf_ftype_v4sf, IX86_BUILTIN_SQRTSS);\n+\n+  def_builtin (\"__builtin_ia32_shufps\", v4sf_ftype_v4sf_v4sf_int, IX86_BUILTIN_SHUFPS);\n+\n+  /* Composite intrinsics.  */\n+  def_builtin (\"__builtin_ia32_setps1\", v4sf_ftype_float, IX86_BUILTIN_SETPS1);\n+  def_builtin (\"__builtin_ia32_setps\", v4sf_ftype_float_float_float_float, IX86_BUILTIN_SETPS);\n+  def_builtin (\"__builtin_ia32_setzerops\", ti_ftype_void, IX86_BUILTIN_CLRPS);\n+  def_builtin (\"__builtin_ia32_loadps1\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADPS1);\n+  def_builtin (\"__builtin_ia32_loadrps\", v4sf_ftype_pfloat, IX86_BUILTIN_LOADRPS);\n+  def_builtin (\"__builtin_ia32_storeps1\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STOREPS1);\n+  def_builtin (\"__builtin_ia32_storerps\", void_ftype_pfloat_v4sf, IX86_BUILTIN_STORERPS);\n+}\n+\n+/* Errors in the source file can cause expand_expr to return const0_rtx\n+   where we expect a vector.  To avoid crashing, use one of the vector\n+   clear instructions.  */\n+static rtx\n+safe_vector_operand (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (x != const0_rtx)\n+    return x;\n+  x = gen_reg_rtx (mode);\n+\n+  if (VALID_MMX_REG_MODE (mode))\n+    emit_insn (gen_mmx_clrdi (mode == DImode ? x\n+\t\t\t      : gen_rtx_SUBREG (DImode, x, 0)));\n+  else\n+    emit_insn (gen_sse_clrti (mode == TImode ? x\n+\t\t\t      : gen_rtx_SUBREG (TImode, x, 0)));\n+  return x;\n+}\n+\n+/* Subroutine of ix86_expand_builtin to take care of binop insns.  */\n+\n+static rtx\n+ix86_expand_binop_builtin (icode, arglist, target)\n+     enum insn_code icode;\n+     tree arglist;\n+     rtx target;\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+  if (VECTOR_MODE_P (mode1))\n+    op1 = safe_vector_operand (op1, mode1);\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  /* In case the insn wants input operands in modes different from\n+     the result, abort.  */\n+  if (GET_MODE (op0) != mode0 || GET_MODE (op1) != mode1)\n+    abort ();\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  pat = GEN_FCN (icode) (target, op0, op1);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Subroutine of ix86_expand_builtin to take care of stores.  */\n+\n+static rtx\n+ix86_expand_store_builtin (icode, arglist, shuffle)\n+     enum insn_code icode;\n+     tree arglist;\n+     int shuffle;\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[1].mode;\n+\n+  if (VECTOR_MODE_P (mode1))\n+    op1 = safe_vector_operand (op1, mode1);\n+\n+  op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+  if (shuffle >= 0 || ! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+  if (shuffle >= 0)\n+    emit_insn (gen_sse_shufps (op1, op1, op1, GEN_INT (shuffle)));\n+  pat = GEN_FCN (icode) (op0, op1);\n+  if (pat)\n+    emit_insn (pat);\n+  return 0;\n+}\n+\n+/* Subroutine of ix86_expand_builtin to take care of unop insns.  */\n+\n+static rtx\n+ix86_expand_unop_builtin (icode, arglist, target, do_load)\n+     enum insn_code icode;\n+     tree arglist;\n+     rtx target;\n+     int do_load;\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+  if (do_load)\n+    op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+  else\n+    {\n+      if (VECTOR_MODE_P (mode0))\n+\top0 = safe_vector_operand (op0, mode0);\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+    }\n+\n+  pat = GEN_FCN (icode) (target, op0);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Subroutine of ix86_expand_builtin to take care of three special unop insns:\n+   sqrtss, rsqrtss, rcpss.  */\n+\n+static rtx\n+ix86_expand_unop1_builtin (icode, arglist, target)\n+     enum insn_code icode;\n+     tree arglist;\n+     rtx target;\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+\n+  pat = GEN_FCN (icode) (target, op0, op0);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Subroutine of ix86_expand_builtin to take care of comparison insns.  */\n+\n+static rtx\n+ix86_expand_sse_compare (d, arglist, target)\n+     struct builtin_description *d;\n+     tree arglist;\n+     rtx target;\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  rtx op2;\n+  enum machine_mode tmode = insn_data[d->icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[d->icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[d->icode].operand[2].mode;\n+  enum rtx_code comparison = d->comparison;\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+  if (VECTOR_MODE_P (mode1))\n+    op1 = safe_vector_operand (op1, mode1);\n+\n+  /* Swap operands if we have a comparison that isn't available in\n+     hardware.  */\n+  if (d->flag)\n+    {\n+      target = gen_reg_rtx (tmode);\n+      emit_move_insn (target, op1);\n+      op1 = op0;\n+      op0 = target;\n+      comparison = swap_condition (comparison);\n+    }\n+  else if (! target\n+\t   || GET_MODE (target) != tmode\n+\t   || ! (*insn_data[d->icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  if (! (*insn_data[d->icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (! (*insn_data[d->icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  op2 = gen_rtx_fmt_ee (comparison, mode0, op0, op1);\n+  pat = GEN_FCN (d->icode) (target, op0, op1, op2);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Subroutine of ix86_expand_builtin to take care of comi insns.  */\n+\n+static rtx\n+ix86_expand_sse_comi (d, arglist, target)\n+     struct builtin_description *d;\n+     tree arglist;\n+     rtx target;\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  rtx op2;\n+  enum machine_mode mode0 = insn_data[d->icode].operand[0].mode;\n+  enum machine_mode mode1 = insn_data[d->icode].operand[1].mode;\n+  enum rtx_code comparison = d->comparison;\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+  if (VECTOR_MODE_P (mode1))\n+    op1 = safe_vector_operand (op1, mode1);\n+\n+  /* Swap operands if we have a comparison that isn't available in\n+     hardware.  */\n+  if (d->flag)\n+    {\n+      rtx tmp = op1;\n+      op1 = op0;\n+      op0 = tmp;\n+      comparison = swap_condition (comparison);\n+    }\n+\n+  target = gen_reg_rtx (SImode);\n+  emit_move_insn (target, const0_rtx);\n+  target = gen_rtx_SUBREG (QImode, target, 0);\n+\n+  if (! (*insn_data[d->icode].operand[0].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (! (*insn_data[d->icode].operand[1].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  op2 = gen_rtx_fmt_ee (comparison, mode0, op0, op1);\n+  pat = GEN_FCN (d->icode) (op0, op1, op2);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  emit_insn (gen_setcc_2 (target, op2));\n+\n+  return target;\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+rtx\n+ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n+{\n+  struct builtin_description *d;\n+  int i;\n+  enum insn_code icode;\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0, arg1, arg2, arg3;\n+  rtx op0, op1, op2, pat;\n+  enum machine_mode tmode, mode0, mode1, mode2;\n+  int fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  switch (fcode)\n+    {\n+    case IX86_BUILTIN_EMMS:\n+      emit_insn (gen_emms ());\n+      return 0;\n+\n+    case IX86_BUILTIN_SFENCE:\n+      emit_insn (gen_sfence ());\n+      return 0;\n+\n+    case IX86_BUILTIN_M_FROM_INT:\n+      target = gen_reg_rtx (DImode);\n+      op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+      emit_move_insn (gen_rtx_SUBREG (SImode, target, 0), op0);\n+      return target;\n+\n+    case IX86_BUILTIN_M_TO_INT:\n+      op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+      op0 = copy_to_mode_reg (DImode, op0);\n+      target = gen_reg_rtx (SImode);\n+      emit_move_insn (target, gen_rtx_SUBREG (SImode, op0, 0));\n+      return target;\n+\n+    case IX86_BUILTIN_PEXTRW:\n+      icode = CODE_FOR_mmx_pextrw;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"selector must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case IX86_BUILTIN_PINSRW:\n+      icode = CODE_FOR_mmx_pinsrw;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+      mode2 = insn_data[icode].operand[3].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\top1 = copy_to_mode_reg (mode1, op1);\n+      if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"selector must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case IX86_BUILTIN_MASKMOVQ:\n+      icode = CODE_FOR_mmx_maskmovq;\n+      /* Note the arg order is different from the operand order.  */\n+      arg1 = TREE_VALUE (arglist);\n+      arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+      mode0 = insn_data[icode].operand[0].mode;\n+      mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n+\top1 = copy_to_mode_reg (mode1, op1);\n+      if (! (*insn_data[icode].operand[2].predicate) (op2, mode2))\n+\top2 = copy_to_mode_reg (mode2, op2);\n+      pat = GEN_FCN (icode) (op0, op1, op2);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return 0;\n+\n+    case IX86_BUILTIN_SQRTSS:\n+      return ix86_expand_unop1_builtin (CODE_FOR_vmsqrtv4sf2, arglist, target);\n+    case IX86_BUILTIN_RSQRTSS:\n+      return ix86_expand_unop1_builtin (CODE_FOR_vmrsqrtv4sf2, arglist, target);\n+    case IX86_BUILTIN_RCPSS:\n+      return ix86_expand_unop1_builtin (CODE_FOR_vmrcpv4sf2, arglist, target);\n+\n+    case IX86_BUILTIN_LOADAPS:\n+      return ix86_expand_unop_builtin (CODE_FOR_sse_movaps, arglist, target, 1);\n+\n+    case IX86_BUILTIN_LOADUPS:\n+      return ix86_expand_unop_builtin (CODE_FOR_sse_movups, arglist, target, 1);\n+\n+    case IX86_BUILTIN_STOREAPS:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movaps, arglist, -1);\n+    case IX86_BUILTIN_STOREUPS:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movups, arglist, -1);\n+\n+    case IX86_BUILTIN_LOADSS:\n+      return ix86_expand_unop_builtin (CODE_FOR_sse_loadss, arglist, target, 1);\n+\n+    case IX86_BUILTIN_STORESS:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_storess, arglist, -1);\n+\n+    case IX86_BUILTIN_LOADHPS:      \n+    case IX86_BUILTIN_LOADLPS:\n+      icode = (fcode == IX86_BUILTIN_LOADHPS\n+\t       ? CODE_FOR_sse_movhps : CODE_FOR_sse_movlps);\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      op1 = gen_rtx_MEM (mode1, copy_to_mode_reg (Pmode, op1));\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+      \n+    case IX86_BUILTIN_STOREHPS:\n+    case IX86_BUILTIN_STORELPS:\n+      icode = (fcode == IX86_BUILTIN_STOREHPS\n+\t       ? CODE_FOR_sse_movhps : CODE_FOR_sse_movlps);\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+\n+      op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\top1 = copy_to_mode_reg (mode1, op1);\n+\n+      pat = GEN_FCN (icode) (op0, op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return 0;\n+\n+    case IX86_BUILTIN_MOVNTPS:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movntv4sf, arglist, -1);\n+    case IX86_BUILTIN_MOVNTQ:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movntdi, arglist, -1);\n+\n+    case IX86_BUILTIN_LDMXCSR:\n+      op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+      target = assign_386_stack_local (SImode, 0);\n+      emit_move_insn (target, op0);\n+      emit_insn (gen_ldmxcsr (target));\n+      return 0;\n+\n+    case IX86_BUILTIN_STMXCSR:\n+      target = assign_386_stack_local (SImode, 0);\n+      emit_insn (gen_stmxcsr (target));\n+      return copy_to_mode_reg (SImode, target);\n+\n+    case IX86_BUILTIN_PREFETCH:\n+      icode = CODE_FOR_prefetch;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+\n+      op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"selector must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+\n+      pat = GEN_FCN (icode) (op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+  \n+    case IX86_BUILTIN_SHUFPS:\n+      icode = CODE_FOR_sse_shufps;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+      mode2 = insn_data[icode].operand[3].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\top1 = copy_to_mode_reg (mode1, op1);\n+      if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"mask must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case IX86_BUILTIN_PSHUFW:\n+      icode = CODE_FOR_mmx_pshufw;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[2].mode;\n+      mode1 = insn_data[icode].operand[3].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[3].predicate) (op1, mode1))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"mask must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, target, op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+      /* Composite intrinsics.  */\n+    case IX86_BUILTIN_SETPS1:\n+      target = assign_386_stack_local (SFmode, 0);\n+      arg0 = TREE_VALUE (arglist);\n+      emit_move_insn (change_address (target, SFmode, XEXP (target, 0)),\n+\t\t      expand_expr (arg0, NULL_RTX, VOIDmode, 0));\n+      op0 = gen_reg_rtx (V4SFmode);\n+      emit_insn (gen_sse_loadss (op0, change_address (target, V4SFmode,\n+\t\t\t\t\t\t      XEXP (target, 0))));\n+      emit_insn (gen_sse_shufps (op0, op0, op0, GEN_INT (0)));\n+      return op0;\n+      \n+    case IX86_BUILTIN_SETPS:\n+      target = assign_386_stack_local (V4SFmode, 0);\n+      op0 = change_address (target, SFmode, XEXP (target, 0));\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+      emit_move_insn (op0,\n+\t\t      expand_expr (arg0, NULL_RTX, VOIDmode, 0));\n+      emit_move_insn (adj_offsettable_operand (op0, 4),\n+\t\t      expand_expr (arg1, NULL_RTX, VOIDmode, 0));\n+      emit_move_insn (adj_offsettable_operand (op0, 8),\n+\t\t      expand_expr (arg2, NULL_RTX, VOIDmode, 0));\n+      emit_move_insn (adj_offsettable_operand (op0, 12),\n+\t\t      expand_expr (arg3, NULL_RTX, VOIDmode, 0));\n+      op0 = gen_reg_rtx (V4SFmode);\n+      emit_insn (gen_sse_movaps (op0, target));\n+      return op0;\n+\n+    case IX86_BUILTIN_CLRPS:\n+      target = gen_reg_rtx (TImode);\n+      emit_insn (gen_sse_clrti (target));\n+      return target;\n+\n+    case IX86_BUILTIN_LOADRPS:\n+      target = ix86_expand_unop_builtin (CODE_FOR_sse_movaps, arglist,\n+\t\t\t\t\t gen_reg_rtx (V4SFmode), 1);\n+      emit_insn (gen_sse_shufps (target, target, target, GEN_INT (0x1b)));\n+      return target;\n+\n+    case IX86_BUILTIN_LOADPS1:\n+      target = ix86_expand_unop_builtin (CODE_FOR_sse_loadss, arglist,\n+\t\t\t\t\t gen_reg_rtx (V4SFmode), 1);\n+      emit_insn (gen_sse_shufps (target, target, target, const0_rtx));\n+      return target;\n+\n+    case IX86_BUILTIN_STOREPS1:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movaps, arglist, 0);\n+    case IX86_BUILTIN_STORERPS:\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movaps, arglist, 0x1B);\n+\n+    case IX86_BUILTIN_MMX_ZERO:\n+      target = gen_reg_rtx (DImode);\n+      emit_insn (gen_mmx_clrdi (target));\n+      return target;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = 0, d = bdesc_2arg; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n+    if (d->code == fcode)\n+      {\n+\t/* Compares are treated specially.  */\n+\tif (d->icode == CODE_FOR_maskcmpv4sf3\n+\t    || d->icode == CODE_FOR_vmmaskcmpv4sf3\n+\t    || d->icode == CODE_FOR_maskncmpv4sf3\n+\t    || d->icode == CODE_FOR_vmmaskncmpv4sf3)\n+\t  return ix86_expand_sse_compare (d, arglist, target);\n+\n+\treturn ix86_expand_binop_builtin (d->icode, arglist, target);\n+      }\n+\n+  for (i = 0, d = bdesc_1arg; i < sizeof (bdesc_1arg) / sizeof *d; i++, d++)\n+    if (d->code == fcode)\n+      return ix86_expand_unop_builtin (d->icode, arglist, target, 0);\n+  \n+  for (i = 0, d = bdesc_comi; i < sizeof (bdesc_comi) / sizeof *d; i++, d++)\n+    if (d->code == fcode)\n+      return ix86_expand_sse_comi (d, arglist, target);\n+  \n+ fail:\n+  /* @@@ Should really do something sensible here.  */\n+  return 0;\n+  \n+}"}, {"sha": "442b205fb4c5a00a585bbc51cd5e5a56d82d5ca9", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=bd793c65b96361f4ab1f47f4c8488c664f55954b", "patch": "@@ -1721,6 +1721,222 @@ pop{l} %0\"\t\t\t\t\t\t\t\\\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n  if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC) goto LABEL\n \f\n+/* Codes for all the SSE/MMX builtins.  */\n+enum ix86_builtins\n+{\n+  IX86_BUILTIN_ADDPS,\n+  IX86_BUILTIN_ADDSS,\n+  IX86_BUILTIN_DIVPS,\n+  IX86_BUILTIN_DIVSS,\n+  IX86_BUILTIN_MULPS,\n+  IX86_BUILTIN_MULSS,\n+  IX86_BUILTIN_SUBPS,\n+  IX86_BUILTIN_SUBSS,\n+\n+  IX86_BUILTIN_CMPEQPS,\n+  IX86_BUILTIN_CMPLTPS,\n+  IX86_BUILTIN_CMPLEPS,\n+  IX86_BUILTIN_CMPGTPS,\n+  IX86_BUILTIN_CMPGEPS,\n+  IX86_BUILTIN_CMPNEQPS,\n+  IX86_BUILTIN_CMPNLTPS,\n+  IX86_BUILTIN_CMPNLEPS,\n+  IX86_BUILTIN_CMPNGTPS,\n+  IX86_BUILTIN_CMPNGEPS,\n+  IX86_BUILTIN_CMPORDPS,\n+  IX86_BUILTIN_CMPUNORDPS,\n+  IX86_BUILTIN_CMPNEPS,\n+  IX86_BUILTIN_CMPEQSS,\n+  IX86_BUILTIN_CMPLTSS,\n+  IX86_BUILTIN_CMPLESS,\n+  IX86_BUILTIN_CMPGTSS,\n+  IX86_BUILTIN_CMPGESS,\n+  IX86_BUILTIN_CMPNEQSS,\n+  IX86_BUILTIN_CMPNLTSS,\n+  IX86_BUILTIN_CMPNLESS,\n+  IX86_BUILTIN_CMPNGTSS,\n+  IX86_BUILTIN_CMPNGESS,\n+  IX86_BUILTIN_CMPORDSS,\n+  IX86_BUILTIN_CMPUNORDSS,\n+  IX86_BUILTIN_CMPNESS,\n+\n+  IX86_BUILTIN_COMIEQSS,\n+  IX86_BUILTIN_COMILTSS,\n+  IX86_BUILTIN_COMILESS,\n+  IX86_BUILTIN_COMIGTSS,\n+  IX86_BUILTIN_COMIGESS,\n+  IX86_BUILTIN_COMINEQSS,\n+  IX86_BUILTIN_UCOMIEQSS,\n+  IX86_BUILTIN_UCOMILTSS,\n+  IX86_BUILTIN_UCOMILESS,\n+  IX86_BUILTIN_UCOMIGTSS,\n+  IX86_BUILTIN_UCOMIGESS,\n+  IX86_BUILTIN_UCOMINEQSS,\n+\n+  IX86_BUILTIN_CVTPI2PS,\n+  IX86_BUILTIN_CVTPS2PI,\n+  IX86_BUILTIN_CVTSI2SS,\n+  IX86_BUILTIN_CVTSS2SI,\n+  IX86_BUILTIN_CVTTPS2PI,\n+  IX86_BUILTIN_CVTTSS2SI,\n+  IX86_BUILTIN_M_FROM_INT,\n+  IX86_BUILTIN_M_TO_INT,\n+\n+  IX86_BUILTIN_MAXPS,\n+  IX86_BUILTIN_MAXSS,\n+  IX86_BUILTIN_MINPS,\n+  IX86_BUILTIN_MINSS,\n+\n+  IX86_BUILTIN_LOADAPS,\n+  IX86_BUILTIN_LOADUPS,\n+  IX86_BUILTIN_STOREAPS,\n+  IX86_BUILTIN_STOREUPS,\n+  IX86_BUILTIN_LOADSS,\n+  IX86_BUILTIN_STORESS,\n+  IX86_BUILTIN_MOVSS,\n+\n+  IX86_BUILTIN_MOVHLPS,\n+  IX86_BUILTIN_MOVLHPS,\n+  IX86_BUILTIN_LOADHPS,\n+  IX86_BUILTIN_LOADLPS,\n+  IX86_BUILTIN_STOREHPS,\n+  IX86_BUILTIN_STORELPS,\n+\n+  IX86_BUILTIN_MASKMOVQ,\n+  IX86_BUILTIN_MOVMSKPS,\n+  IX86_BUILTIN_PMOVMSKB,\n+\n+  IX86_BUILTIN_MOVNTPS,\n+  IX86_BUILTIN_MOVNTQ,\n+\n+  IX86_BUILTIN_PACKSSWB,\n+  IX86_BUILTIN_PACKSSDW,\n+  IX86_BUILTIN_PACKUSWB,\n+\n+  IX86_BUILTIN_PADDB,\n+  IX86_BUILTIN_PADDW,\n+  IX86_BUILTIN_PADDD,\n+  IX86_BUILTIN_PADDSB,\n+  IX86_BUILTIN_PADDSW,\n+  IX86_BUILTIN_PADDUSB,\n+  IX86_BUILTIN_PADDUSW,\n+  IX86_BUILTIN_PSUBB,\n+  IX86_BUILTIN_PSUBW,\n+  IX86_BUILTIN_PSUBD,\n+  IX86_BUILTIN_PSUBSB,\n+  IX86_BUILTIN_PSUBSW,\n+  IX86_BUILTIN_PSUBUSB,\n+  IX86_BUILTIN_PSUBUSW,\n+\n+  IX86_BUILTIN_PAND,\n+  IX86_BUILTIN_PANDN,\n+  IX86_BUILTIN_POR,\n+  IX86_BUILTIN_PXOR,\n+\n+  IX86_BUILTIN_PAVGB,\n+  IX86_BUILTIN_PAVGW,\n+\n+  IX86_BUILTIN_PCMPEQB,\n+  IX86_BUILTIN_PCMPEQW,\n+  IX86_BUILTIN_PCMPEQD,\n+  IX86_BUILTIN_PCMPGTB,\n+  IX86_BUILTIN_PCMPGTW,\n+  IX86_BUILTIN_PCMPGTD,\n+\n+  IX86_BUILTIN_PEXTRW,\n+  IX86_BUILTIN_PINSRW,\n+\n+  IX86_BUILTIN_PMADDWD,\n+\n+  IX86_BUILTIN_PMAXSW,\n+  IX86_BUILTIN_PMAXUB,\n+  IX86_BUILTIN_PMINSW,\n+  IX86_BUILTIN_PMINUB,\n+\n+  IX86_BUILTIN_PMULHUW,\n+  IX86_BUILTIN_PMULHW,\n+  IX86_BUILTIN_PMULLW,\n+\n+  IX86_BUILTIN_PSADBW,\n+  IX86_BUILTIN_PSHUFW,\n+\n+  IX86_BUILTIN_PSLLW,\n+  IX86_BUILTIN_PSLLD,\n+  IX86_BUILTIN_PSLLQ,\n+  IX86_BUILTIN_PSRAW,\n+  IX86_BUILTIN_PSRAD,\n+  IX86_BUILTIN_PSRLW,\n+  IX86_BUILTIN_PSRLD,\n+  IX86_BUILTIN_PSRLQ,\n+  IX86_BUILTIN_PSLLWI,\n+  IX86_BUILTIN_PSLLDI,\n+  IX86_BUILTIN_PSLLQI,\n+  IX86_BUILTIN_PSRAWI,\n+  IX86_BUILTIN_PSRADI,\n+  IX86_BUILTIN_PSRLWI,\n+  IX86_BUILTIN_PSRLDI,\n+  IX86_BUILTIN_PSRLQI,\n+\n+  IX86_BUILTIN_PUNPCKHBW,\n+  IX86_BUILTIN_PUNPCKHWD,\n+  IX86_BUILTIN_PUNPCKHDQ,\n+  IX86_BUILTIN_PUNPCKLBW,\n+  IX86_BUILTIN_PUNPCKLWD,\n+  IX86_BUILTIN_PUNPCKLDQ,\n+\n+  IX86_BUILTIN_SHUFPS,\n+\n+  IX86_BUILTIN_RCPPS,\n+  IX86_BUILTIN_RCPSS,\n+  IX86_BUILTIN_RSQRTPS,\n+  IX86_BUILTIN_RSQRTSS,\n+  IX86_BUILTIN_SQRTPS,\n+  IX86_BUILTIN_SQRTSS,\n+  \n+  IX86_BUILTIN_UNPCKHPS,\n+  IX86_BUILTIN_UNPCKLPS,\n+\n+  IX86_BUILTIN_ANDPS,\n+  IX86_BUILTIN_ANDNPS,\n+  IX86_BUILTIN_ORPS,\n+  IX86_BUILTIN_XORPS,\n+\n+  IX86_BUILTIN_EMMS,\n+  IX86_BUILTIN_LDMXCSR,\n+  IX86_BUILTIN_STMXCSR,\n+  IX86_BUILTIN_SFENCE,\n+  IX86_BUILTIN_PREFETCH,\n+\n+  /* Composite builtins, expand to more than one insn.  */\n+  IX86_BUILTIN_SETPS1,\n+  IX86_BUILTIN_SETPS,\n+  IX86_BUILTIN_CLRPS,\n+  IX86_BUILTIN_SETRPS,\n+  IX86_BUILTIN_LOADPS1,\n+  IX86_BUILTIN_LOADRPS,\n+  IX86_BUILTIN_STOREPS1,\n+  IX86_BUILTIN_STORERPS,\n+\n+  IX86_BUILTIN_MMX_ZERO,\n+\n+  IX86_BUILTIN_MAX\n+};\n+\n+/* Initialize the target-specific builtin functions.  Only do something\n+   if TARGET_MMX is nonzero; we take care in ix86_init_builtins not to\n+   enable any SSE builtins if TARGET_SSE is zero.  */\n+#define MD_INIT_BUILTINS\t\\\n+  do\t\t\t\t\\\n+    {\t\t\t\t\\\n+      if (TARGET_MMX)\t\t\\\n+\tix86_init_builtins ();\t\\\n+    }\t\t\t\t\\\n+  while (0)\n+\n+/* Expand a target-specific builtin function.  */\n+#define MD_EXPAND_BUILTIN(EXP, TARGET, SUBTARGET, MODE, IGNORE) \\\n+  ix86_expand_builtin (EXP, TARGET, SUBTARGET, MODE, IGNORE)\n+\f\n /* Define this macro if references to a symbol must be treated\n    differently depending on something about the variable or\n    function named by the symbol (such as what section it is in)."}, {"sha": "a8555089f577de8f7c6fc4ef7946dadd8ec20f17", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd793c65b96361f4ab1f47f4c8488c664f55954b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=bd793c65b96361f4ab1f47f4c8488c664f55954b", "patch": "@@ -117,7 +117,7 @@\n \n ;; The (bounding maximum) length of an instruction immediate.\n (define_attr \"length_immediate\" \"\"\n-  (cond [(eq_attr \"type\" \"incdec,setcc,icmov,ibr,str,cld,lea,other,multi,idiv\")\n+  (cond [(eq_attr \"type\" \"incdec,setcc,icmov,ibr,str,cld,lea,other,multi,idiv,sse,mmx\")\n \t   (const_int 0)\n \t (eq_attr \"i387\" \"1\")\n \t   (const_int 0)\n@@ -167,7 +167,7 @@\n \n ;; Set when 0f opcode prefix is used.\n (define_attr \"prefix_0f\" \"\"\n-  (if_then_else (eq_attr \"type\" \"imovx,setcc,icmov\")\n+  (if_then_else (eq_attr \"type\" \"imovx,setcc,icmov,sse,mmx\")\n     (const_int 1)\n     (const_int 0)))\n \n@@ -8311,7 +8311,7 @@\n   [(set_attr \"type\" \"setcc\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*setcc_2\"\n+(define_insn \"setcc_2\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n \t(match_operator:QI 1 \"ix86_comparison_operator\"\n \t  [(reg 17) (const_int 0)]))]\n@@ -13068,17 +13068,18 @@\n    (clobber (reg:XF 13))\n    (clobber (reg:XF 14))\n    (clobber (reg:XF 15))\n-   (clobber (reg:DI 27))\n-   (clobber (reg:DI 28))\n    (clobber (reg:DI 29))\n    (clobber (reg:DI 30))\n    (clobber (reg:DI 31))\n    (clobber (reg:DI 32))\n    (clobber (reg:DI 33))\n-   (clobber (reg:DI 34))]\n+   (clobber (reg:DI 34))\n+   (clobber (reg:DI 35))\n+   (clobber (reg:DI 36))]\n   \"TARGET_MMX\"\n   \"emms\"\n-  [(set_attr \"type\" \"mmx\")])\n+  [(set_attr \"type\" \"mmx\")\n+   (set_attr \"memory\" \"unknown\")])\n \n (define_insn \"ldmxcsr\"\n   [(unspec_volatile [(match_operand:SI 0 \"memory_operand\" \"m\")] 37)]\n@@ -13108,7 +13109,8 @@\n \t(unspec:BLK [(match_dup 0)] 44))]\n   \"TARGET_SSE\"\n   \"sfence\"\n-  [(set_attr \"type\" \"sse\")])\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"memory\" \"unknown\")])\n \n (define_insn \"prefetch\"\n   [(unspec [(match_operand:SI 0 \"address_operand\" \"p\")"}]}