{"sha": "8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI4NGM1OTY2ZmRkZWZkNTE0NzVkNGRmMGZiMmYxYTY5OWJhMjNmZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-07-26T22:53:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-07-26T22:53:50Z"}, "message": "re PR target/44132 (emutls is broken under a range of circumstances.)\n\nPR target/44132\nEmulated TLS rewrite.\n\nFrom-SVN: r162549", "tree": {"sha": "566634468015c713398a1fcd59ec66da7138545a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/566634468015c713398a1fcd59ec66da7138545a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/comments", "author": null, "committer": null, "parents": [{"sha": "b57c6b13e0d950ba0771b1688cf6e57e3a5beae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57c6b13e0d950ba0771b1688cf6e57e3a5beae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b57c6b13e0d950ba0771b1688cf6e57e3a5beae6"}], "stats": {"total": 1758, "additions": 1214, "deletions": 544}, "files": [{"sha": "0ef4b455686ebcda790bbd59b3cb7e2c81686597", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,3 +1,40 @@\n+2010-07-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/44132\n+\t* tree-emutls.c: New file.\n+\t* Makefile.in (OBJS-common): Add it.\n+\t* tree-pass.h (pass_ipa_lower_emutls): Declare.\n+\t* passes.c (init_optimization_passes): Add it.\n+\n+\t* dwarf2out.c (loc_list_from_tree): If emutls.debug_form_tls_address,\n+\tpull the control variable from DECL_VALUE_EXPR, not emutls_decl.\n+\t* expr.c (emutls_var_address): Delete.\n+\t(expand_expr_addr_expr_1, expand_expr_real_1): Don't use it.\n+\t* output.h (SECCAT_EMUTLS_VAR, SECCAT_EMUTLS_TMPL): Delete.\n+\t(emutls_finish): Delete.\n+\t* toplev.c (compile_file): Don't call it.\n+\t* tree.h (emutls_decl): Delete.\n+\t* varasm.c (emutls_htab, DECL_EMUTLS_VAR_P): Delete.\n+\t(emutls_finish, emutls_finalize_control_var): Delete.\n+\t(emutls_object_type): Move to tree-emutls.c.\n+\t(EMUTLS_SEPARATOR, prefix_name, get_emutls_object_name,\n+\tdefault_emutls_var_fields, get_emutls_object_type,\n+\tget_emutls_init_templ_addr, emutls_decl, emutls_common_1\n+\tdefault_emutls_var_init): Likewise.\n+\t(get_variable_section): Don't special case emutls.\n+\t(assemble_variable, do_assemble_alias, categorize_decl_for_section,\n+\tdefault_elf_select_section, default_unique_section,\n+\tdefault_encode_section_info): Likewise.\n+\t* varpool.c (decide_is_variable_needed): Likewise.\n+\t* gimple-iterator.c (update_call_edge_frequencies): New\n+\t(gsi_insert_on_edge_immediate): Use it.\n+\t(gsi_insert_seq_on_edge_immediate): Likewise.\n+\t(gsi_commit_one_edge_insert): Likewise.\n+\n+\t* config/i386/i386.c (x86_64_elf_select_section): Don't handle\n+\tSECCAT_EMUTLS_VAR, SECCAT_EMUTLS_TMPL.\n+\t(x86_64_elf_unique_section): Likewise.\n+\n 2010-07-26  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-streamer.h (struct lto_file_decl_data): Mark resolutions with"}, {"sha": "3ce39140e9e92a9f452dbb088434b7fb5967bd50", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1357,6 +1357,7 @@ OBJS-common = \\\n \ttree-diagnostic.o \\\n \ttree-dump.o \\\n \ttree-eh.o \\\n+\ttree-emutls.o \\\n \ttree-if-conv.o \\\n \ttree-into-ssa.o \\\n \ttree-iterator.o \\\n@@ -3145,6 +3146,9 @@ tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n     $(TM_H) $(FLAGS_H) $(TREE_FLOW_H) $(GIMPLE_H) \\\n     tree-iterator.h $(TREE_PASS_H) tree-ssa-propagate.h $(DIAGNOSTIC_H)\n+tree-emutls.o : tree-emutls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n+    $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) $(CGRAPH_H) langhooks.h \\\n+    $(TARGET_H) targhooks.h tree-iterator.h\n tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(TM_H) $(TREE_FLOW_H) $(GIMPLE_H) tree-iterator.h $(TREE_PASS_H) \\\n     $(FLAGS_H) $(OPTABS_H) $(MACHMODE_H) $(EXPR_H) \\"}, {"sha": "bd0de275c8d349cf367c17a806be9ad6a20d4ee9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -4355,9 +4355,6 @@ x86_64_elf_select_section (tree decl, int reloc,\n \t  /* We don't split these for medium model.  Place them into\n \t     default sections and hope for best.  */\n \t  break;\n-\tcase SECCAT_EMUTLS_VAR:\n-\tcase SECCAT_EMUTLS_TMPL:\n-\t  gcc_unreachable ();\n \t}\n       if (sname)\n \t{\n@@ -4415,12 +4412,6 @@ x86_64_elf_unique_section (tree decl, int reloc)\n \t  /* We don't split these for medium model.  Place them into\n \t     default sections and hope for best.  */\n \t  break;\n-\tcase SECCAT_EMUTLS_VAR:\n-\t  prefix = targetm.emutls.var_section;\n-\t  break;\n-\tcase SECCAT_EMUTLS_TMPL:\n-\t  prefix = targetm.emutls.tmpl_section;\n-\t  break;\n \t}\n       if (prefix)\n \t{"}, {"sha": "1ca53bb96c13c5364c6b6fcdc93e7daccb12e1f1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -15111,7 +15111,11 @@ loc_list_from_tree (tree loc, int want_address)\n \t      if (!targetm.emutls.debug_form_tls_address\n \t\t  || !(dwarf_version >= 3 || !dwarf_strict))\n \t\treturn 0;\n-\t      loc = emutls_decl (loc);\n+\t      /* We stuffed the control variable into the DECL_VALUE_EXPR\n+\t\t to signal (via DECL_HAS_VALUE_EXPR_P) that the decl should\n+\t\t no longer appear in gimple code.  We used the control\n+\t\t variable in specific so that we could pick it up here.  */\n+\t      loc = DECL_VALUE_EXPR (loc);\n \t      first_op = DW_OP_addr;\n \t      second_op = DW_OP_form_tls_address;\n \t    }"}, {"sha": "57f9eff859b2e86772031e46008c5da3c594a43e", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -6818,19 +6818,6 @@ highest_pow2_factor_for_target (const_tree target, const_tree exp)\n   return MAX (factor, talign);\n }\n \f\n-/* Return &VAR expression for emulated thread local VAR.  */\n-\n-static tree\n-emutls_var_address (tree var)\n-{\n-  tree emuvar = emutls_decl (var);\n-  tree fn = built_in_decls [BUILT_IN_EMUTLS_GET_ADDRESS];\n-  tree arg = build_fold_addr_expr_with_type (emuvar, ptr_type_node);\n-  tree call = build_call_expr (fn, 1, arg);\n-  return fold_convert (build_pointer_type (TREE_TYPE (var)), call);\n-}\n-\f\n-\n /* Subroutine of expand_expr.  Expand the two operands of a binary\n    expression EXP0 and EXP1 placing the results in OP0 and OP1.\n    The value may be stored in TARGET if TARGET is nonzero.  The\n@@ -6933,18 +6920,6 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n       inner = TREE_OPERAND (exp, 0);\n       break;\n \n-    case VAR_DECL:\n-      /* TLS emulation hook - replace __thread VAR's &VAR with\n-\t __emutls_get_address (&_emutls.VAR).  */\n-      if (! targetm.have_tls\n-\t  && TREE_CODE (exp) == VAR_DECL\n-\t  && DECL_THREAD_LOCAL_P (exp))\n-\t{\n-\t  exp = emutls_var_address (exp);\n-\t  return expand_expr (exp, target, tmode, modifier);\n-\t}\n-      /* Fall through.  */\n-\n     default:\n       /* If the object is a DECL, then expand it for its rtl.  Don't bypass\n \t expand_expr, as that can have various side effects; LABEL_DECLs for\n@@ -8382,16 +8357,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n \tlayout_decl (exp, 0);\n \n-      /* TLS emulation hook - replace __thread vars with\n-\t *__emutls_get_address (&_emutls.var).  */\n-      if (! targetm.have_tls\n-\t  && TREE_CODE (exp) == VAR_DECL\n-\t  && DECL_THREAD_LOCAL_P (exp))\n-\t{\n-\t  exp = build_fold_indirect_ref_loc (loc, emutls_var_address (exp));\n-\t  return expand_expr_real_1 (exp, target, tmode, modifier, NULL);\n-\t}\n-\n       /* ... fall through ...  */\n \n     case FUNCTION_DECL:"}, {"sha": "cd8e6e4ed9ebc3b905bf45ba3c7512c2421fdb19", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,3 +1,9 @@\n+2010-07-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/44132\n+\t* f95-lang.c (LANG_HOOKS_WRITE_GLOBALS): New.\n+\t(gfc_write_global_declarations): New.\n+\n 2010-07-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/45066"}, {"sha": "9d0bf446babbec3eddc6a32659207133d3560483", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -88,6 +88,7 @@ static void gfc_init_builtin_functions (void);\n /* Each front end provides its own.  */\n static bool gfc_init (void);\n static void gfc_finish (void);\n+static void gfc_write_global_declarations (void);\n static void gfc_print_identifier (FILE *, tree, int);\n void do_function_end (void);\n int global_bindings_p (void);\n@@ -99,6 +100,7 @@ static void gfc_init_ts (void);\n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n #undef LANG_HOOKS_FINISH\n+#undef LANG_HOOKS_WRITE_GLOBALS\n #undef LANG_HOOKS_INIT_OPTIONS\n #undef LANG_HOOKS_HANDLE_OPTION\n #undef LANG_HOOKS_POST_OPTIONS\n@@ -127,6 +129,7 @@ static void gfc_init_ts (void);\n #define LANG_HOOKS_NAME                 \"GNU Fortran\"\n #define LANG_HOOKS_INIT                 gfc_init\n #define LANG_HOOKS_FINISH               gfc_finish\n+#define LANG_HOOKS_WRITE_GLOBALS\tgfc_write_global_declarations\n #define LANG_HOOKS_INIT_OPTIONS         gfc_init_options\n #define LANG_HOOKS_HANDLE_OPTION        gfc_handle_option\n #define LANG_HOOKS_POST_OPTIONS\t\tgfc_post_options\n@@ -282,6 +285,33 @@ gfc_finish (void)\n   return;\n }\n \n+/* ??? This is something of a hack.\n+\n+   Emulated tls lowering needs to see all TLS variables before we call\n+   cgraph_finalize_compilation_unit.  The C/C++ front ends manage this\n+   by calling decl_rest_of_compilation on each global and static variable\n+   as they are seen.  The Fortran front end waits until this hook.\n+\n+   A Correct solution is for cgraph_finalize_compilation_unit not to be\n+   called during the WRITE_GLOBALS langhook, and have that hook only do what\n+   its name suggests and write out globals.  But the C++ and Java front ends\n+   have (unspecified) problems with aliases that gets in the way.  It has\n+   been suggested that these problems would be solved by completing the\n+   conversion to cgraph-based aliases.  */\n+\n+static void\n+gfc_write_global_declarations (void)\n+{\n+  tree decl;\n+\n+  /* Finalize all of the globals.  */\n+  for (decl = getdecls(); decl ; decl = DECL_CHAIN (decl))\n+    rest_of_decl_compilation (decl, true, true);\n+\n+  write_global_declarations ();\n+}\n+\n+\n static void\n gfc_print_identifier (FILE * file ATTRIBUTE_UNUSED,\n \t\t      tree node ATTRIBUTE_UNUSED,"}, {"sha": "064b7feef4962d829090889bf615d36ec555e673", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -65,6 +65,35 @@ update_bb_for_stmts (gimple_seq_node first, basic_block bb)\n     gimple_set_bb (n->stmt, bb);\n }\n \n+/* Set the frequencies for the cgraph_edges for each of the calls\n+   starting at FIRST for their new position within BB.  */\n+\n+static void\n+update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n+{\n+  struct cgraph_node *cfun_node = NULL;\n+  int bb_freq = 0;\n+  gimple_seq_node n;\n+\n+  for (n = first; n ; n = n->next)\n+    if (is_gimple_call (n->stmt))\n+      {\n+\tstruct cgraph_edge *e;\n+\n+\t/* These function calls are expensive enough that we want\n+\t   to avoid calling them if we never see any calls.  */\n+\tif (cfun_node == NULL)\n+\t  {\n+\t    cfun_node = cgraph_node (current_function_decl);\n+\t    bb_freq = (compute_call_stmt_bb_frequency\n+\t\t       (current_function_decl, bb));\n+\t  }\n+\n+\te = cgraph_edge (cfun_node, n->stmt);\n+\tif (e != NULL)\n+\t  e->frequency = bb_freq;\n+      }\n+}\n \n /* Insert the sequence delimited by nodes FIRST and LAST before\n    iterator I.  M specifies how to update iterator I after insertion\n@@ -696,11 +725,19 @@ basic_block\n gsi_insert_on_edge_immediate (edge e, gimple stmt)\n {\n   gimple_stmt_iterator gsi;\n+  struct gimple_seq_node_d node;\n   basic_block new_bb = NULL;\n+  bool ins_after;\n \n   gcc_assert (!PENDING_STMT (e));\n \n-  if (gimple_find_edge_insert_loc (e, &gsi, &new_bb))\n+  ins_after = gimple_find_edge_insert_loc (e, &gsi, &new_bb);\n+\n+  node.stmt = stmt;\n+  node.prev = node.next = NULL;\n+  update_call_edge_frequencies (&node, gsi.bb);\n+\n+  if (ins_after)\n     gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n   else\n     gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n@@ -716,10 +753,14 @@ gsi_insert_seq_on_edge_immediate (edge e, gimple_seq stmts)\n {\n   gimple_stmt_iterator gsi;\n   basic_block new_bb = NULL;\n+  bool ins_after;\n \n   gcc_assert (!PENDING_STMT (e));\n \n-  if (gimple_find_edge_insert_loc (e, &gsi, &new_bb))\n+  ins_after = gimple_find_edge_insert_loc (e, &gsi, &new_bb);\n+  update_call_edge_frequencies (gimple_seq_first (stmts), gsi.bb);\n+\n+  if (ins_after)\n     gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n   else\n     gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n@@ -758,10 +799,14 @@ gsi_commit_one_edge_insert (edge e, basic_block *new_bb)\n     {\n       gimple_stmt_iterator gsi;\n       gimple_seq seq = PENDING_STMT (e);\n+      bool ins_after;\n \n       PENDING_STMT (e) = NULL;\n \n-      if (gimple_find_edge_insert_loc (e, &gsi, new_bb))\n+      ins_after = gimple_find_edge_insert_loc (e, &gsi, new_bb);\n+      update_call_edge_frequencies (gimple_seq_first (seq), gsi.bb);\n+\n+      if (ins_after)\n \tgsi_insert_seq_after (&gsi, seq, GSI_NEW_STMT);\n       else\n \tgsi_insert_seq_before (&gsi, seq, GSI_NEW_STMT);"}, {"sha": "e4679a57eb17576b4b03241c2708e993da975326", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -165,9 +165,6 @@ extern void merge_weak (tree, tree);\n /* Emit any pending weak declarations.  */\n extern void weak_finish (void);\n \n-/* Emit any pending emutls declarations and initializations.  */\n-extern void emutls_finish (void);\n-\n /* Return the default TLS model for a given variable.  */\n extern enum tls_model decl_default_tls_model (const_tree);\n \n@@ -479,10 +476,7 @@ enum section_category\n \n   SECCAT_BSS,\n   SECCAT_SBSS,\n-  SECCAT_TBSS,\n-\n-  SECCAT_EMUTLS_VAR,\n-  SECCAT_EMUTLS_TMPL\n+  SECCAT_TBSS\n };\n \n /* Information that is provided by all instances of the section type.  */"}, {"sha": "5a4cdc83a6e711c4a5bbcbf573ec3a3ce5eec514", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -804,6 +804,7 @@ init_optimization_passes (void)\n     }\n   NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_matrix_reorg);\n+  NEXT_PASS (pass_ipa_lower_emutls);\n   *p = NULL;\n \n   p = &all_regular_ipa_passes;"}, {"sha": "de8eb354a8ccf08d512c113b6a28dbe673bf76f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,3 +1,43 @@\n+2010-07-19  Iain Sandoe  <iains@gcc.gnu.org>\n+\t    Jack Howarth  <howarth@bromo.med.uc.edu>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/44132\n+\t* gcc.dg/tls/thr-init-1.c: New.\n+\t* gcc.dg/tls/thr-init-2.c: New.\n+\t* gcc.dg/torture/tls New.\n+\t* gcc.dg/torture/tls/tls-test.c: New.\n+\t* gcc.dg/torture/tls/thr-init-1.c: New.\n+\t* gcc.dg/torture/tls/tls.exp: New.\n+\t* gcc.dg/torture/tls/thr-init-2.c: New.\n+\t* gcc.dg/tls/emutls-2.c: New test\n+\n+\t* g++.dg/gomp/clause-3.C: Require tls, not tls_native.\n+\t* g++.dg/gomp/copyin-1.C, g++.dg/gomp/pr35244.C,\n+\tg++.dg/gomp/sharing-1.C, g++.dg/gomp/tls-1.C, g++.dg/gomp/tls-2.C,\n+\tg++.dg/gomp/tls-3.C, g++.dg/gomp/tls-4.C, g++.dg/tls/diag-1.C,\n+\tg++.dg/tls/diag-2.C, g++.dg/tls/diag-3.C, g++.dg/tls/diag-4.C,\n+\tg++.dg/tls/diag-5.C, g++.dg/tls/init-1.C, g++.dg/tls/init-2.C,\n+\tg++.dg/tls/trivial.C, gcc.dg/gomp/appendix-a/a.22.1.c,\n+\tgcc.dg/gomp/appendix-a/a.22.2.c, gcc.dg/gomp/appendix-a/a.24.1.c,\n+\tgcc.dg/gomp/appendix-a/a.32.1.c, gcc.dg/gomp/appendix-a/a.33.1.c,\n+\tgcc.dg/gomp/clause-1.c, gcc.dg/gomp/copyin-1.c, gcc.dg/gomp/pr35244.c,\n+\tgcc.dg/gomp/sharing-1.c, gcc.dg/gomp/tls-1.c, gcc.dg/gomp/tls-2.c,\n+\tgcc.dg/tls/opt-1.c, gcc.dg/tls/opt-13.c, gcc.dg/tls/opt-14.c,\n+\tgcc.dg/tls/opt-15.c, gcc.dg/tls/opt-2.c, gcc.dg/tls/opt-3.c,\n+\tgcc.dg/tls/opt-7.c, gfortran.dg/gomp/appendix-a/a.22.1.f90,\n+\tgfortran.dg/gomp/appendix-a/a.22.4.f90,\n+\tgfortran.dg/gomp/appendix-a/a.22.5.f90,\n+\tgfortran.dg/gomp/appendix-a/a.22.6.f90,\n+\tgfortran.dg/gomp/appendix-a/a.24.1.f90,\n+\tgfortran.dg/gomp/appendix-a/a.32.1.f90,\n+\tgfortran.dg/gomp/appendix-a/a.33.1.f90, gfortran.dg/gomp/crayptr2.f90,\n+\tgfortran.dg/gomp/fixed-1.f, gfortran.dg/gomp/free-1.f90,\n+\tgfortran.dg/gomp/omp_threadprivate1.f90,\n+\tgfortran.dg/gomp/omp_threadprivate2.f90,\n+\tgfortran.dg/gomp/reduction1.f90,\n+\tgfortran.dg/gomp/sharing-1.f90: Likewise.\n+\n 2010-07-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/torture/pr44900.C: Use dg-require-effective-target"}, {"sha": "6b3d410a9334c442405287bd8889526dcd6ee69c", "filename": "gcc/testsuite/g++.dg/gomp/clause-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n #define p parallel\n "}, {"sha": "117f82f8134f75d3ff67a8d53132f3769fbdb003", "filename": "gcc/testsuite/g++.dg/gomp/copyin-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcopyin-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcopyin-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcopyin-1.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n int i, j;\n "}, {"sha": "022f9d0a0a950cb6527e5a46a3f2afc5827a49f8", "filename": "gcc/testsuite/g++.dg/gomp/pr35244.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr35244.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr35244.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr35244.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n // PR c++/35244\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n // { dg-options \"-fopenmp\" }\n \n int v1;"}, {"sha": "83b818098342580e903b64b4d17a26ba2ef74b7e", "filename": "gcc/testsuite/g++.dg/gomp/sharing-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n int thrglobalvar;\n #pragma omp threadprivate (thrglobalvar)"}, {"sha": "bfe62cb009b300d6f9c5c575af695517d87f97ef", "filename": "gcc/testsuite/g++.dg/gomp/tls-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-1.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n int tp1;\n static int tp2;"}, {"sha": "80275f9081c20e98be4166769c4df415b167e3a6", "filename": "gcc/testsuite/g++.dg/gomp/tls-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-2.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n extern char buf[];\n #pragma omp threadprivate (buf)\t/* { dg-error \"has incomplete type\" } */"}, {"sha": "c710b6d183582c8ff5f621b164c4b641ba9f94f0", "filename": "gcc/testsuite/g++.dg/gomp/tls-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n #define thr threadprivate\n "}, {"sha": "f6c039e3dbe8d817fbb51351f27a85d53af486eb", "filename": "gcc/testsuite/g++.dg/gomp/tls-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-4.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n #define thr threadprivate\n "}, {"sha": "af538719d243732d3ef9fe3580346bae57a54f46", "filename": "gcc/testsuite/g++.dg/tls/diag-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-1.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // Valid __thread specifiers.\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n __thread int g1;\n extern __thread int g2;"}, {"sha": "484b18845150cb90346061b3a14ffd99818190e7", "filename": "gcc/testsuite/g++.dg/tls/diag-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-2.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* Invalid __thread specifiers.  */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n __thread extern int g1;\t\t/* { dg-error \"'__thread' before 'extern'\" } */\n __thread static int g2;\t\t/* { dg-error \"'__thread' before 'static'\" } */"}, {"sha": "ea5158b898fff486c82664677636391e03e5bb72", "filename": "gcc/testsuite/g++.dg/tls/diag-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-3.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // Report invalid extern and __thread combinations.\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n extern int j;\t\t// { dg-error \"previously declared here\" }\n __thread int j;\t\t// { dg-error \"follows non-thread-local\" }"}, {"sha": "55e985e9261da7029b5b23d7f5284ea4bf117e5f", "filename": "gcc/testsuite/g++.dg/tls/diag-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-4.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* Invalid __thread specifiers.  */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n __thread typedef int g4;\t/* { dg-error \"multiple storage classes\" } */\n "}, {"sha": "ca92b3074288ae1ce4a425a0602798e510b74ca3", "filename": "gcc/testsuite/g++.dg/tls/diag-5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-5.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // PR c++/30536\n // Invalid __thread specifiers.\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n struct A { __thread register int i; }; // { dg-error \"multiple storage classes|storage class specified\" }"}, {"sha": "97867123a95f70f0aab0c8c10b46dea0b0d095cb", "filename": "gcc/testsuite/g++.dg/tls/init-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-1.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* Valid initializations.  */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n __thread int i = 42;\n "}, {"sha": "c9f646d3a1d93db2f4f1dbd71ea5304131be0fb5", "filename": "gcc/testsuite/g++.dg/tls/init-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-2.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* Invalid initializations.  */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n extern __thread int i;\n __thread int *p = &i;\t/* { dg-error \"dynamically initialized\" } */"}, {"sha": "e2b8f45b84543d3b1ccce19342d915e195b7d1b5", "filename": "gcc/testsuite/g++.dg/tls/trivial.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Ftrivial.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Ftrivial.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Ftrivial.C?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,3 +1,3 @@\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n __thread int i;"}, {"sha": "e3586838a34086ff082afbdf439fcdc0674beacb", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.22.1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n int counter = 0;\n #pragma omp threadprivate(counter)"}, {"sha": "7a6e901a8c73806ae5a337900480820a78df0ac7", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.22.2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.2.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n int\n increment_counter_2 ()"}, {"sha": "9d8baa37f2341a87618be3e56a03ec96d9b30144", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.24.1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n extern int omp_get_num_threads (void);\n int x, y, t, z[1000];"}, {"sha": "d2cb316f3cc0ec4cb15b898a7fcb4756f67f6a45", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.32.1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.32.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.32.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.32.1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n #include <stdlib.h>\n float *work;"}, {"sha": "99c06da6a5dc305f2153c7b5950c75b983091fba", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.33.1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n #include <stdio.h>\n float x, y;"}, {"sha": "ace9738043a98016e8f6ed24653e3398f79f3ec6", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n #define p parallel\n "}, {"sha": "117f82f8134f75d3ff67a8d53132f3769fbdb003", "filename": "gcc/testsuite/gcc.dg/gomp/copyin-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcopyin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcopyin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcopyin-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n int i, j;\n "}, {"sha": "92d6a1c4ff43b76cb2555726766da6cfe83b085b", "filename": "gcc/testsuite/gcc.dg/gomp/pr35244.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr35244.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr35244.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr35244.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n /* PR c++/35244 */\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n /* { dg-options \"-fopenmp\" } */\n \n int v1;"}, {"sha": "90d389b7292592fcb53f02997f5d8d07dde48d39", "filename": "gcc/testsuite/gcc.dg/gomp/sharing-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n #include <stdlib.h>\n "}, {"sha": "9dc102e7e61db44454bca6484931faf94b5c50c9", "filename": "gcc/testsuite/gcc.dg/gomp/tls-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-require-effective-target tls_native }\n+// { dg-require-effective-target tls }\n \n int tp1;\n static int tp2;"}, {"sha": "80275f9081c20e98be4166769c4df415b167e3a6", "filename": "gcc/testsuite/gcc.dg/gomp/tls-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-2.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n extern char buf[];\n #pragma omp threadprivate (buf)\t/* { dg-error \"has incomplete type\" } */"}, {"sha": "1e26d5fe116e4c7f3b76be19e1844f088dd93496", "filename": "gcc/testsuite/gcc.dg/tls/emutls-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Femutls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Femutls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Femutls-2.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+/* { dg-options \"-O2\" } */\n+\n+/* With emulated TLS, the constructor generated during IPA\n+   was not properly lowered to SSA form.  */\n+\n+__thread int i __attribute__((common));"}, {"sha": "f9399e04a88e4717e7a2b7253345f597f17e10a3", "filename": "gcc/testsuite/gcc.dg/tls/opt-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fPIC\" } */\n /* { dg-options \"-O2 -fPIC -mtune=i686\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n /* { dg-require-effective-target fpic } */\n \n extern __thread int thr;"}, {"sha": "8eea76b68ab5f72cac09a8f7efedf37962e736ff", "filename": "gcc/testsuite/gcc.dg/tls/opt-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-13.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n __thread struct\n {"}, {"sha": "5abeacea7d31e9e67a66be9ee870d22ff4244489", "filename": "gcc/testsuite/gcc.dg/tls/opt-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-14.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -3,7 +3,7 @@\n    used.  */\n /* { dg-do assemble } */\n /* { dg-options \"-O2\" } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n \n struct __res_state\n {"}, {"sha": "a6cc7214a23e9fedebfe942d4c41972742dd82ad", "filename": "gcc/testsuite/gcc.dg/tls/opt-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-15.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -3,7 +3,7 @@\n \n /* { dg-do compile } */\n /* { dg-options \"-O -fPIC\" } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n /* { dg-require-effective-target fpic } */\n \n extern void *memset(void *s, int c, __SIZE_TYPE__ n);"}, {"sha": "3ede35290e5e4103bab18efa32247030c1875353", "filename": "gcc/testsuite/gcc.dg/tls/opt-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-2.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -5,7 +5,7 @@\n /* { dg-do link } */\n /* { dg-options \"-O2 -ftls-model=initial-exec\" } */\n /* { dg-options \"-O2 -ftls-model=initial-exec -march=i686\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n /* { dg-require-effective-target tls_runtime  } */\n \n __thread int thr;"}, {"sha": "dd37dbc828a954d0da57b7e57dabf53342607506", "filename": "gcc/testsuite/gcc.dg/tls/opt-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-3.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fpic\" } */\n /* { dg-options \"-O2 -fpic -mregparm=3\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n /* { dg-require-effective-target fpic } */\n \n extern __thread int i, j, k;"}, {"sha": "44b900f542a72ea0708f70ba7dc15f55c5e224d5", "filename": "gcc/testsuite/gcc.dg/tls/opt-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-7.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fPIC\" } */\n-/* { dg-require-effective-target tls_native } */\n+/* { dg-require-effective-target tls } */\n /* { dg-require-effective-target fpic } */\n \n static __thread void *baz [4] __attribute__((tls_model (\"initial-exec\")));"}, {"sha": "de273d930aa538ae7a88c67e64bf66251edbede3", "filename": "gcc/testsuite/gcc.dg/tls/thr-init-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-require-effective-target tls } */\n+/* { dg-do compile } */\n+\n+static __thread int fstat ;\n+static __thread int fstat = 1 ;\n+static __thread int fstat ;\n+static __thread int fstat = 2; /* { dg-error \"redefinition of 'fstat'\" } */\n+\t\t\t\t/* { dg-message \"note: previous definition of 'fstat' was here\" \"\" { target *-*-* } 5 } */"}, {"sha": "6d00d8ce39ede052bcd87b1fd258850b29667d75", "filename": "gcc/testsuite/gcc.dg/tls/thr-init-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-init-2.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-require-effective-target tls } */\n+/* { dg-do run } */\n+\n+extern void abort() ;\n+\n+static __thread int fstat ;\n+static __thread int fstat = 1;\n+\n+int test_code(int b)\n+{\n+  fstat += b ;\n+  return fstat;\n+}\n+\n+int main (int ac, char *av[])\n+{\n+  int a = test_code(1);\n+  \n+  if ((a != 2) || (fstat != 2))\n+    abort () ;\n+  \n+  return 0;\n+}"}, {"sha": "89725c3d4aa1d2d11c47e283e192351eaa71016f", "filename": "gcc/testsuite/gcc.dg/torture/tls/thr-init-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-1.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target tls } */\n+\n+extern int printf (char *,...);\n+extern void abort() ;\n+\n+int test_code(int b)\n+{\n+static __thread int fstat = 1;\n+  fstat += b ;\n+  return fstat;\n+}\n+\n+int main (int ac, char *av[])\n+{\n+  int a = test_code(1);\n+  \n+  if ( a != 2 )\n+    {\n+      printf (\"a=%d\\n\", a) ;\n+      abort ();\n+    }\n+  \n+  return 0;\n+}"}, {"sha": "9d093197a33ca6ac30fb3fce5a656e141a80c49c", "filename": "gcc/testsuite/gcc.dg/torture/tls/thr-init-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Fthr-init-2.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target tls } */\n+\n+extern int printf (char *,...);\n+extern void abort() ;\n+\n+static __thread int fstat ;\n+static __thread int fstat = 1;\n+static __thread int fstat ;\n+\n+int test_code(int b)\n+{\n+  fstat += b ;\n+  return fstat;\n+}\n+\n+int main (int ac, char *av[])\n+{\n+  int a = test_code(1);\n+  \n+  if ( a != 2 || fstat != 2 )\n+    {\n+    printf (\"a=%d fstat=%d\\n\", a, fstat) ;\n+    abort ();\n+    }\n+  \n+  return 0;\n+}"}, {"sha": "8a23e77c17991f020e6b4c03506370dd240a074c", "filename": "gcc/testsuite/gcc.dg/torture/tls/tls-test.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Ftls-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Ftls-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Ftls-test.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run }  */\n+/* { dg-require-effective-target tls  }  */\n+/* { dg-require-effective-target pthread } */\n+/* { dg-options \"-pthread\" } */\n+\n+#include <pthread.h>\n+extern int printf (char *,...);\n+__thread int a = 5; \n+int *volatile a_in_other_thread = (int *) 12345;\n+\n+static void *\n+thread_func (void *arg)\n+{\n+  a_in_other_thread = &a;\n+  a+=5;\n+  *((int *) arg) = a;\n+  return (void *)0;\n+}\n+\n+int\n+main ()\n+{\n+  pthread_t thread;\n+  void *thread_retval;\n+  int *volatile a_in_main_thread;\n+  int *volatile again ;\n+  int thr_a;\n+\n+  a_in_main_thread = &a;\n+\n+  if (pthread_create (&thread, (pthread_attr_t *)0, thread_func, &thr_a))\n+    return 0;\n+\n+  if (pthread_join (thread, &thread_retval))\n+    return 0;\n+\n+  again = &a;\n+  if (again != a_in_main_thread)\n+    {\n+      printf (\"FAIL: main thread addy changed from 0x%0x to 0x%0x\\n\", \n+\t\ta_in_other_thread, again);\n+      return 1;\n+    }\n+\n+  if (a != 5 || thr_a != 10 || (a_in_other_thread == a_in_main_thread))\n+    {\n+      printf (\"FAIL: a= %d, thr_a = %d Addr = 0x%0x\\n\", \n+\t\ta, thr_a, a_in_other_thread);\n+      return 1;\n+    }\n+  return 0;\n+}"}, {"sha": "91c8843c42f3cac31caff9354da460c30a315517", "filename": "gcc/testsuite/gcc.dg/torture/tls/tls.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Ftls.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Ftls.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ftls%2Ftls.exp?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,36 @@\n+#   Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+        $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "cc94b140384c55e9fdfd20f1ae1d0ab2f6f5e4ae", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n       INTEGER FUNCTION INCREMENT_COUNTER()\n         COMMON/A22_COMMON/COUNTER"}, {"sha": "2a637580ba7ade20bf3a37b220845d7f548ac510", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.4.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n       MODULE A22_MODULE\n       COMMON /T/ A"}, {"sha": "6531d826c576d8a77bfc59f89f062a7ca8200a4f", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.5.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n       SUBROUTINE A22_5_WRONG()\n         COMMON /T/ A"}, {"sha": "0a2e6a6836f88d07797700ffd3f9a24bb619c094", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.6.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n        SUBROUTINE A22_6_GOOD()\n              COMMON /T/ A"}, {"sha": "e5b95450d28bbba2cfd7e49836cc108adc37b63e", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.24.1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.24.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.24.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.24.1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n       SUBROUTINE A24(A)\n       INTEGER A"}, {"sha": "498a6d324a6bf6cc10c5b5eb876fcbfbb551fa01", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.32.1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.32.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.32.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.32.1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n       MODULE M\n         REAL, POINTER, SAVE :: WORK(:)"}, {"sha": "05145b1715f460339ff61ecca233361d64f303bf", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.33.1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n       SUBROUTINE INIT(A,B)\n       REAL A, B"}, {"sha": "476d7b9e771c2fabaf236620f44f370eba601865", "filename": "gcc/testsuite/gfortran.dg/gomp/crayptr2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr2.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do compile }\n ! { dg-options \"-fopenmp -fcray-pointer\" }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n module crayptr2\n   integer :: e\t\t! { dg-error \"CRAY POINTEE attribute conflicts with THREADPRIVATE\" }"}, {"sha": "d61f2ba638d7fa8731bfd59077886071e471724e", "filename": "gcc/testsuite/gfortran.dg/gomp/fixed-1.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffixed-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffixed-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffixed-1.f?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n C PR fortran/24493\n C { dg-do compile }\n-C { dg-require-effective-target tls_native }\n+C { dg-require-effective-target tls }\n       INTEGER I, J, K, L, M\n C$OMP THREADPRIVATE(I)\n C SOME COMMENT"}, {"sha": "f6f9de4441bc6b8bf22a7a087b13648ae0927e38", "filename": "gcc/testsuite/gfortran.dg/gomp/free-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffree-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffree-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffree-1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,4 +1,4 @@\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n subroutine foo\n integer, save :: i ! Some comment"}, {"sha": "2ccf93caca56d5a3c653ce5bbec1ed2f273bf667", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_threadprivate1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,4 +1,4 @@\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n       module omp_threadprivate1\n \tcommon /T/ a\n       end module omp_threadprivate1"}, {"sha": "cd1ab5cd60a3fc248c78b3c568454e002c13573a", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_threadprivate2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate2.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n       subroutine bad1\n \tdouble precision :: d\t! { dg-error \"isn't SAVEd\" }\n !$omp threadprivate (d)"}, {"sha": "4912f7178c1c1a30cf47d58cdba72509b072d061", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do compile }\n ! { dg-options \"-fopenmp -fmax-errors=100\" }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n subroutine foo (ia1)\n integer :: i1, i2, i3"}, {"sha": "7a107ffe7cbd9a61e8ef0530000a1cdaeb925966", "filename": "gcc/testsuite/gfortran.dg/gomp/sharing-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-1.f90?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-require-effective-target tls_native }\n+! { dg-require-effective-target tls }\n \n   integer :: thrpriv, thr, i, j, s, g1, g2, m\n   integer, dimension (6) :: p"}, {"sha": "3836d0c50cf64ee115eeed66ae87c813e1ffc7cf", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -959,11 +959,6 @@ compile_file (void)\n   if (seen_error ())\n     return;\n \n-  /* Ensure that emulated TLS control vars are finalized and build \n-     a static constructor for them, when it is required.  */\n-  if (!targetm.have_tls)\n-    emutls_finish ();\n-\n   varpool_assemble_pending_decls ();\n   finish_aliases_2 ();\n "}, {"sha": "17f97be1104bf56fac85189e97da9330fc78d5e1", "filename": "gcc/tree-emutls.c", "status": "added", "additions": 802, "deletions": 0, "changes": 802, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -0,0 +1,802 @@\n+/* Lower TLS operations to emulation functions.\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n+#include \"cgraph.h\"\n+#include \"langhooks.h\"\n+#include \"target.h\"\n+#include \"targhooks.h\"\n+#include \"tree-iterator.h\"\n+\n+\n+/* Whenever a target does not support thread-local storage (TLS) natively,\n+   we can emulate it with some run-time support in libgcc.  This will in\n+   turn rely on \"keyed storage\" a-la pthread_key_create; essentially all\n+   thread libraries provide such functionality.\n+\n+   In order to coordinate with the libgcc runtime, each TLS variable is\n+   described by a \"control variable\".  This control variable records the\n+   required size, alignment, and initial value of the TLS variable for\n+   instantiation at runtime.  It also stores an integer token to be used\n+   by the runtime to find the address of the variable within each thread.\n+\n+   On the compiler side, this means that we need to replace all instances\n+   of \"tls_var\" in the code with \"*__emutls_get_addr(&control_var)\".  We\n+   also need to eliminate \"tls_var\" from the symbol table and introduce\n+   \"control_var\".\n+\n+   We used to perform all of the transformations during conversion to rtl,\n+   and the variable substitutions magically within assemble_variable.\n+   However, this late fiddling of the symbol table conflicts with LTO and\n+   whole-program compilation.  Therefore we must now make all the changes\n+   to the symbol table early in the GIMPLE optimization path, before we\n+   write things out to LTO intermediate files.  */\n+\n+/* These two vectors, once fully populated, are kept in lock-step so that\n+   the index of a TLS variable equals the index of its control variable in\n+   the other vector.  */\n+static varpool_node_set tls_vars;\n+static VEC(varpool_node_ptr, heap) *control_vars;\n+\n+/* For the current basic block, an SSA_NAME that has computed the address \n+   of the TLS variable at the corresponding index.  */\n+static VEC(tree, heap) *access_vars;\n+\n+/* The type of the control structure, shared with the emutls.c runtime.  */\n+static tree emutls_object_type;\n+\n+#if !defined (NO_DOT_IN_LABEL)\n+# define EMUTLS_SEPARATOR\t\".\"\n+#elif !defined (NO_DOLLAR_IN_LABEL)\n+# define EMUTLS_SEPARATOR\t\"$\"\n+#else\n+# define EMUTLS_SEPARATOR\t\"_\"\n+#endif\n+\n+/* Create an IDENTIFIER_NODE by prefixing PREFIX to the\n+   IDENTIFIER_NODE NAME's name.  */\n+\n+static tree\n+prefix_name (const char *prefix, tree name)\n+{\n+  unsigned plen = strlen (prefix);\n+  unsigned nlen = strlen (IDENTIFIER_POINTER (name));\n+  char *toname = (char *) alloca (plen + nlen + 1);\n+\n+  memcpy (toname, prefix, plen);\n+  memcpy (toname + plen, IDENTIFIER_POINTER (name), nlen + 1);\n+\n+  return get_identifier (toname);\n+}\n+\n+/* Create an identifier for the struct __emutls_object, given an identifier\n+   of the DECL_ASSEMBLY_NAME of the original object.  */\n+\n+static tree\n+get_emutls_object_name (tree name)\n+{\n+  const char *prefix = (targetm.emutls.var_prefix\n+\t\t\t? targetm.emutls.var_prefix\n+\t\t\t: \"__emutls_v\" EMUTLS_SEPARATOR);\n+  return prefix_name (prefix, name);\n+}\n+\n+/* Create the fields of the type for the control variables.  Ordinarily\n+   this must match struct __emutls_object defined in emutls.c.  However\n+   this is a target hook so that VxWorks can define its own layout.  */\n+\n+tree\n+default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)\n+{\n+  tree word_type_node, field, next_field;\n+\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__templ\"), ptr_type_node);\n+  DECL_CONTEXT (field) = type;\n+  next_field = field;\n+\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__offset\"),\n+\t\t      ptr_type_node);\n+  DECL_CONTEXT (field) = type;\n+  DECL_CHAIN (field) = next_field;\n+  next_field = field;\n+\n+  word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__align\"),\n+\t\t      word_type_node);\n+  DECL_CONTEXT (field) = type;\n+  DECL_CHAIN (field) = next_field;\n+  next_field = field;\n+\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n+  DECL_CONTEXT (field) = type;\n+  DECL_CHAIN (field) = next_field;\n+\n+  return field;\n+}\n+\n+/* Initialize emulated tls object TO, which refers to TLS variable DECL and\n+   is initialized by PROXY.  As above, this is the default implementation of\n+   a target hook overridden by VxWorks.  */\n+\n+tree\n+default_emutls_var_init (tree to, tree decl, tree proxy)\n+{\n+  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n+  constructor_elt *elt;\n+  tree type = TREE_TYPE (to);\n+  tree field = TYPE_FIELDS (type);\n+\n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  elt->index = field;\n+  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n+\n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = DECL_CHAIN (field);\n+  elt->index = field;\n+  elt->value = build_int_cst (TREE_TYPE (field),\n+\t\t\t      DECL_ALIGN_UNIT (decl));\n+\n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = DECL_CHAIN (field);\n+  elt->index = field;\n+  elt->value = null_pointer_node;\n+\n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = DECL_CHAIN (field);\n+  elt->index = field;\n+  elt->value = proxy;\n+\n+  return build_constructor (type, v);\n+}\n+\n+/* Create the structure for struct __emutls_object.  This should match the\n+   structure at the top of emutls.c, modulo the union there.  */\n+\n+static tree\n+get_emutls_object_type (void)\n+{\n+  tree type, type_name, field;\n+\n+  type = emutls_object_type;\n+  if (type)\n+    return type;\n+\n+  emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);\n+  type_name = NULL;\n+  field = targetm.emutls.var_fields (type, &type_name);\n+  if (!type_name)\n+    type_name = get_identifier (\"__emutls_object\");\n+  type_name = build_decl (UNKNOWN_LOCATION,\n+\t\t\t  TYPE_DECL, type_name, type);\n+  TYPE_NAME (type) = type_name;\n+  TYPE_FIELDS (type) = field;\n+  layout_type (type);\n+\n+  return type;\n+}\n+\n+/* Create a read-only variable like DECL, with the same DECL_INITIAL.\n+   This will be used for initializing the emulated tls data area.  */\n+\n+static tree\n+get_emutls_init_templ_addr (tree decl)\n+{\n+  tree name, to;\n+\n+  if (targetm.emutls.register_common && !DECL_INITIAL (decl)\n+      && !DECL_SECTION_NAME (decl))\n+    return null_pointer_node;\n+\n+  name = DECL_ASSEMBLER_NAME (decl);\n+  if (!targetm.emutls.tmpl_prefix || targetm.emutls.tmpl_prefix[0])\n+    {\n+      const char *prefix = (targetm.emutls.tmpl_prefix\n+\t\t\t    ? targetm.emutls.tmpl_prefix\n+\t\t\t    : \"__emutls_t\" EMUTLS_SEPARATOR);\n+      name = prefix_name (prefix, name);\n+    }\n+\n+  to = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t   VAR_DECL, name, TREE_TYPE (decl));\n+  SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n+\n+  DECL_ARTIFICIAL (to) = 1;\n+  TREE_USED (to) = TREE_USED (decl);\n+  TREE_READONLY (to) = 1;\n+  DECL_IGNORED_P (to) = 1;\n+  DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n+  DECL_SECTION_NAME (to) = DECL_SECTION_NAME (decl);\n+  DECL_PRESERVE_P (to) = DECL_PRESERVE_P (decl);\n+\n+  DECL_WEAK (to) = DECL_WEAK (decl);\n+  if (DECL_ONE_ONLY (decl))\n+    {\n+      make_decl_one_only (to, DECL_ASSEMBLER_NAME (to));\n+      TREE_STATIC (to) = TREE_STATIC (decl);\n+      TREE_PUBLIC (to) = TREE_PUBLIC (decl);\n+      DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);\n+    }\n+  else\n+    TREE_STATIC (to) = 1;\n+\n+  DECL_VISIBILITY_SPECIFIED (to) = DECL_VISIBILITY_SPECIFIED (decl);\n+  DECL_INITIAL (to) = DECL_INITIAL (decl);\n+  DECL_INITIAL (decl) = NULL;\n+\n+  if (targetm.emutls.tmpl_section)\n+    {\n+      DECL_SECTION_NAME (to)\n+        = build_string (strlen (targetm.emutls.tmpl_section),\n+\t\t\ttargetm.emutls.tmpl_section);\n+    }\n+\n+  varpool_finalize_decl (to);\n+  return build_fold_addr_expr (to);\n+}\n+\n+/* Create and return the control variable for the TLS variable DECL.  */\n+\n+static tree\n+new_emutls_decl (tree decl)\n+{\n+  tree name, to;\n+\n+  name = DECL_ASSEMBLER_NAME (decl);\n+  to = build_decl (DECL_SOURCE_LOCATION (decl), VAR_DECL,\n+                   get_emutls_object_name (name),\n+                   get_emutls_object_type ());\n+\n+  SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n+\n+  DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;\n+  DECL_ARTIFICIAL (to) = 1;\n+  DECL_IGNORED_P (to) = 1;\n+  TREE_READONLY (to) = 0;\n+  TREE_STATIC (to) = 1;\n+\n+  DECL_PRESERVE_P (to) = DECL_PRESERVE_P (decl);\n+  DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n+  TREE_USED (to) = TREE_USED (decl);\n+  TREE_PUBLIC (to) = TREE_PUBLIC (decl);\n+  DECL_EXTERNAL (to) = DECL_EXTERNAL (decl);\n+  DECL_COMMON (to) = DECL_COMMON (decl);\n+  DECL_WEAK (to) = DECL_WEAK (decl);\n+  DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);\n+  DECL_VISIBILITY_SPECIFIED (to) = DECL_VISIBILITY_SPECIFIED (decl);\n+  DECL_RESTRICTED_P (to) = DECL_RESTRICTED_P (decl);\n+  DECL_DLLIMPORT_P (to) = DECL_DLLIMPORT_P (decl);\n+\n+  DECL_ATTRIBUTES (to) = targetm.merge_decl_attributes (decl, to);\n+\n+  if (DECL_ONE_ONLY (decl))\n+    make_decl_one_only (to, DECL_ASSEMBLER_NAME (to));\n+\n+  /* If we're not allowed to change the proxy object's alignment,\n+     pretend it has been set by the user.  */\n+  if (targetm.emutls.var_align_fixed)\n+    DECL_USER_ALIGN (to) = 1;\n+\n+  /* If the target wants the control variables grouped, do so.  */\n+  if (!DECL_COMMON (to) && targetm.emutls.var_section)\n+    {\n+      DECL_SECTION_NAME (to)\n+        = build_string (strlen (targetm.emutls.tmpl_section),\n+\t\t\ttargetm.emutls.tmpl_section);\n+    }\n+\n+  /* If this variable is defined locally, then we need to initialize the\n+     control structure with size and alignment information.  Initialization\n+     of COMMON block variables happens elsewhere via a constructor.  */\n+  if (!DECL_EXTERNAL (to)\n+      && (!DECL_COMMON (to)\n+          || (DECL_INITIAL (decl)\n+              && DECL_INITIAL (decl) != error_mark_node)))\n+    {\n+      tree tmpl = get_emutls_init_templ_addr (decl);\n+      DECL_INITIAL (to) = targetm.emutls.var_init (to, decl, tmpl);\n+      record_references_in_initializer (to, false);\n+    }\n+\n+  varpool_finalize_decl (to);\n+  return to;\n+}\n+\n+/* Look up the index of the TLS variable DECL.  This index can then be\n+   used in both the control_vars and access_vars arrays.  */\n+\n+static unsigned int\n+emutls_index (tree decl)\n+{\n+  varpool_node_set_iterator i;\n+  \n+  i = varpool_node_set_find (tls_vars, varpool_get_node (decl));\n+  gcc_assert (i.index != ~0u);\n+\n+  return i.index;\n+}\n+\n+/* Look up the control variable for the TLS variable DECL.  */\n+\n+static tree\n+emutls_decl (tree decl)\n+{\n+  struct varpool_node *var;\n+  unsigned int i;\n+\n+  i = emutls_index (decl);\n+  var = VEC_index (varpool_node_ptr, control_vars, i);\n+  return var->decl;\n+}\n+\n+/* Generate a call statement to initialize CONTROL_DECL for TLS_DECL.\n+   This only needs to happen for TLS COMMON variables; non-COMMON\n+   variables can be initialized statically.  Insert the generated\n+   call statement at the end of PSTMTS.  */\n+   \n+static void\n+emutls_common_1 (tree tls_decl, tree control_decl, tree *pstmts)\n+{\n+  tree x;\n+  tree word_type_node;\n+\n+  if (! DECL_COMMON (tls_decl)\n+      || (DECL_INITIAL (tls_decl)\n+\t  && DECL_INITIAL (tls_decl) != error_mark_node))\n+    return;\n+\n+  word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n+\n+  x = build_call_expr (built_in_decls[BUILT_IN_EMUTLS_REGISTER_COMMON], 4,\n+\t\t       build_fold_addr_expr (control_decl),\n+\t\t       fold_convert (word_type_node,\n+\t\t\t\t     DECL_SIZE_UNIT (tls_decl)),\n+\t\t       build_int_cst (word_type_node,\n+\t\t\t\t      DECL_ALIGN_UNIT (tls_decl)),\n+\t\t       get_emutls_init_templ_addr (tls_decl));\n+\n+  append_to_statement_list (x, pstmts);\n+}\n+\n+struct lower_emutls_data\n+{\n+  struct cgraph_node *cfun_node;\n+  struct cgraph_node *builtin_node;\n+  tree builtin_decl;\n+  basic_block bb;\n+  int bb_freq;\n+  location_t loc;\n+  gimple_seq seq;\n+};\n+\n+/* Given a TLS variable DECL, return an SSA_NAME holding its address.\n+   Append any new computation statements required to D->SEQ.  */\n+\n+static tree\n+gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n+{\n+  unsigned int index;\n+  tree addr;\n+\n+  /* Compute the address of the TLS variable with help from runtime.  */\n+  index = emutls_index (decl);\n+  addr = VEC_index (tree, access_vars, index);\n+  if (addr == NULL)\n+    {\n+      struct varpool_node *cvar;\n+      tree cdecl;\n+      gimple x;\n+\n+      cvar = VEC_index (varpool_node_ptr, control_vars, index);\n+      cdecl = cvar->decl;\n+      TREE_ADDRESSABLE (cdecl) = 1;\n+\n+      addr = create_tmp_var (build_pointer_type (TREE_TYPE (decl)), NULL);\n+      x = gimple_build_call (d->builtin_decl, 1, build_fold_addr_expr (cdecl));\n+      gimple_set_location (x, d->loc);\n+\n+      addr = make_ssa_name (addr, x);\n+      gimple_call_set_lhs (x, addr);\n+\n+      gimple_seq_add_stmt (&d->seq, x);\n+\n+      cgraph_create_edge (d->cfun_node, d->builtin_node, x,\n+                          d->bb->count, d->bb_freq, d->bb->loop_depth);\n+\n+      /* We may be adding a new reference to a new variable to the function.\n+         This means we have to play with the ipa-reference web.  */\n+      ipa_record_reference (d->cfun_node, NULL, NULL, cvar, IPA_REF_ADDR, x);\n+\n+      /* Record this ssa_name for possible use later in the basic block.  */\n+      VEC_replace (tree, access_vars, index, addr);\n+    }\n+\n+  return addr;\n+}\n+\n+/* Callback for walk_gimple_op.  D = WI->INFO is a struct lower_emutls_data.\n+   Given an operand *PTR within D->STMT, if the operand references a TLS\n+   variable, then lower the reference to a call to the runtime.  Insert\n+   any new statements required into D->SEQ; the caller is responsible for\n+   placing those appropriately.  */\n+\n+static tree\n+lower_emutls_1 (tree *ptr, int *walk_subtrees, void *cb_data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) cb_data;\n+  struct lower_emutls_data *d = (struct lower_emutls_data *) wi->info;\n+  tree t = *ptr;\n+  bool is_addr = false;\n+  tree addr;\n+\n+  *walk_subtrees = 0;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ADDR_EXPR:\n+      /* If this is not a straight-forward \"&var\", but rather something\n+\t like \"&var.a\", then we may need special handling.  */\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) != VAR_DECL)\n+\t{\n+\t  bool save_changed;\n+\n+\t  /* If we're allowed more than just is_gimple_val, continue.  */\n+\t  if (!wi->val_only)\n+\t    {\n+\t      *walk_subtrees = 1;\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  /* See if any substitution would be made.  */\n+\t  save_changed = wi->changed;\n+\t  wi->changed = false;\n+\t  wi->val_only = false;\n+\t  walk_tree (&TREE_OPERAND (t, 0), lower_emutls_1, wi, NULL);\n+\t  wi->val_only = true;\n+\n+\t  /* If so, then extract this entire sub-expression \"&p->a\" into a\n+\t     new assignment statement, and substitute yet another SSA_NAME.  */\n+\t  if (wi->changed)\n+\t    {\n+\t      gimple x;\n+\n+\t      addr = create_tmp_var (TREE_TYPE (t), NULL);\n+\t      x = gimple_build_assign (addr, t);\n+\t      gimple_set_location (x, d->loc);\n+\n+\t      addr = make_ssa_name (addr, x);\n+\t      gimple_assign_set_lhs (x, addr);\n+\n+\t      gimple_seq_add_stmt (&d->seq, x);\n+\n+\t      *ptr = addr;\n+\t    }\n+\t  else\n+\t    wi->changed = save_changed;\n+\n+\t  return NULL_TREE;\n+\t}\n+\n+      t = TREE_OPERAND (t, 0);\n+      is_addr = true;\n+      /* FALLTHRU */\n+\n+    case VAR_DECL:\n+      if (!DECL_THREAD_LOCAL_P (t))\n+\treturn NULL_TREE;\n+      break;\n+\n+    default:\n+      /* We're not interested in other decls or types, only subexpressions.  */\n+      if (EXPR_P (t))\n+        *walk_subtrees = 1;\n+      /* FALLTHRU */\n+\n+    case SSA_NAME:\n+      /* Special-case the return of SSA_NAME, since it's so common.  */\n+      return NULL_TREE;\n+    }\n+\n+  addr = gen_emutls_addr (t, d);\n+  if (is_addr)\n+    {\n+      /* Replace \"&var\" with \"addr\" in the statement.  */\n+      *ptr = addr;\n+    }\n+  else\n+    {\n+      /* Replace \"var\" with \"*addr\" in the statement.  */\n+      t = build2 (MEM_REF, TREE_TYPE (t), addr,\n+\t          build_int_cst (TREE_TYPE (addr), 0));\n+      *ptr = t;\n+    }\n+\n+  wi->changed = true;\n+  return NULL_TREE;\n+}\n+\n+/* Lower all of the operands of STMT.  */\n+\n+static void\n+lower_emutls_stmt (gimple stmt, struct lower_emutls_data *d)\n+{\n+  struct walk_stmt_info wi;\n+\n+  d->loc = gimple_location (stmt);\n+\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = d;\n+  wi.val_only = true;\n+  walk_gimple_op (stmt, lower_emutls_1, &wi);\n+\n+  if (wi.changed)\n+    update_stmt (stmt);\n+}\n+\n+/* Lower the I'th operand of PHI.  */\n+\n+static void\n+lower_emutls_phi_arg (gimple phi, unsigned int i, struct lower_emutls_data *d)\n+{\n+  struct walk_stmt_info wi;\n+  struct phi_arg_d *pd = gimple_phi_arg (phi, i);\n+\n+  /* Early out for a very common case we don't care about.  */\n+  if (TREE_CODE (pd->def) == SSA_NAME)\n+    return;\n+\n+  d->loc = pd->locus;\n+\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = d;\n+  wi.val_only = true;\n+  walk_tree (&pd->def, lower_emutls_1, &wi, NULL);\n+\n+  /* For normal statements, we let update_stmt do its job.  But for phi\n+     nodes, we have to manipulate the immediate use list by hand.  */\n+  if (wi.changed)\n+    {\n+      gcc_assert (TREE_CODE (pd->def) == SSA_NAME);\n+      link_imm_use_stmt (&pd->imm_use, pd->def, phi);\n+    }\n+}\n+\n+/* Clear the ACCESS_VARS array, in order to begin a new block.  */\n+\n+static inline void\n+clear_access_vars (void)\n+{\n+  memset (VEC_address (tree, access_vars), 0,\n+          VEC_length (tree, access_vars) * sizeof(tree));\n+}\n+\n+/* Lower the entire function NODE.  */\n+\n+static void\n+lower_emutls_function_body (struct cgraph_node *node)\n+{\n+  struct lower_emutls_data d;\n+  bool any_edge_inserts = false;\n+\n+  current_function_decl = node->decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+  d.cfun_node = node;\n+  d.builtin_decl = built_in_decls[BUILT_IN_EMUTLS_GET_ADDRESS];\n+  d.builtin_node = cgraph_node (d.builtin_decl);\n+\n+  FOR_EACH_BB (d.bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+      unsigned int i, nedge;\n+\n+      /* Lower each of the PHI nodes of the block, as we may have \n+\t propagated &tlsvar into a PHI argument.  These loops are\n+\t arranged so that we process each edge at once, and each\n+\t PHI argument for that edge.  */\n+      if (!gimple_seq_empty_p (phi_nodes (d.bb)))\n+\t{\n+\t  /* The calls will be inserted on the edges, and the frequencies\n+\t     will be computed during the commit process.  */\n+\t  d.bb_freq = 0;\n+\n+\t  nedge = EDGE_COUNT (d.bb->preds);\n+\t  for (i = 0; i < nedge; ++i)\n+\t    {\n+\t      edge e = EDGE_PRED (d.bb, i);\n+\n+\t      /* We can re-use any SSA_NAME created on this edge.  */\n+\t      clear_access_vars ();\n+\t      d.seq = NULL;\n+\n+\t      for (gsi = gsi_start_phis (d.bb);\n+\t\t   !gsi_end_p (gsi);\n+\t\t   gsi_next (&gsi))\n+\t\tlower_emutls_phi_arg (gsi_stmt (gsi), i, &d);\n+\n+\t      /* Insert all statements generated by all phi nodes for this\n+\t\t particular edge all at once.  */\n+\t      if (d.seq)\n+\t\t{\n+\t\t  gsi_insert_seq_on_edge (e, d.seq);\n+\t\t  any_edge_inserts = true;\n+\t\t}\n+\t    }\n+\t}\n+\n+      d.bb_freq = compute_call_stmt_bb_frequency (current_function_decl, d.bb);\n+\n+      /* We can re-use any SSA_NAME created during this basic block.  */\n+      clear_access_vars ();\n+\n+      /* Lower each of the statements of the block.  */\n+      for (gsi = gsi_start_bb (d.bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+          d.seq = NULL;\n+\t  lower_emutls_stmt (gsi_stmt (gsi), &d);\n+\n+\t  /* If any new statements were created, insert them immediately\n+\t     before the first use.  This prevents variable lifetimes from\n+\t     becoming unnecessarily long.  */\n+\t  if (d.seq)\n+\t    gsi_insert_seq_before (&gsi, d.seq, GSI_SAME_STMT);\n+\t}\n+    }\n+\n+  if (any_edge_inserts)\n+    gsi_commit_edge_inserts ();\n+\n+  pop_cfun ();\n+  current_function_decl = NULL;\n+}\n+\n+/* Main entry point to the tls lowering pass.  */\n+\n+static unsigned int\n+ipa_lower_emutls (void)\n+{\n+  struct varpool_node *var;\n+  struct cgraph_node *func;\n+  bool any_aliases = false;\n+  tree ctor_body = NULL;\n+  unsigned int i, n_tls;\n+\n+  tls_vars = varpool_node_set_new ();\n+\n+  /* Examine all global variables for TLS variables.  */\n+  for (var = varpool_nodes; var ; var = var->next)\n+    if (DECL_THREAD_LOCAL_P (var->decl))\n+      {\n+\tgcc_checking_assert (TREE_STATIC (var->decl)\n+\t\t\t     || DECL_EXTERNAL (var->decl));\n+\tvarpool_node_set_add (tls_vars, var);\n+      }\n+\n+  /* If we found no TLS variables, then there is no further work to do.  */\n+  if (tls_vars->nodes == NULL)\n+    {\n+      tls_vars = NULL;\n+      if (dump_file)\n+\tfprintf (dump_file, \"No TLS variables found.\\n\");\n+      return 0;\n+    }\n+\n+  /* Allocate the on-the-side arrays that share indicies with the TLS vars.  */\n+  n_tls = VEC_length (varpool_node_ptr, tls_vars->nodes);\n+  control_vars = VEC_alloc (varpool_node_ptr, heap, n_tls);\n+  access_vars = VEC_alloc (tree, heap, n_tls);\n+  VEC_safe_grow (tree, heap, access_vars, n_tls);\n+\n+  /* Create the control variables for each TLS variable.  */\n+  for (i = 0; VEC_iterate (varpool_node_ptr, tls_vars->nodes, i, var); ++i)\n+    {\n+      tree cdecl;\n+      struct varpool_node *cvar;\n+\n+      var = VEC_index (varpool_node_ptr, tls_vars->nodes, i);\n+      cdecl = new_emutls_decl (var->decl);\n+\n+      cvar = varpool_get_node (cdecl);\n+      VEC_quick_push (varpool_node_ptr, control_vars, cvar);\n+\n+      if (var->alias)\n+\t{\n+\t  any_aliases = true;\n+\t  cvar->alias = true;\n+\t}\n+      else\n+\t{\n+\t  /* Make sure the COMMON block control variable gets initialized.\n+\t     Note that there's no point in doing this for aliases; we only\n+\t     need to do this once for the main variable.  */\n+          emutls_common_1 (var->decl, cdecl, &ctor_body);\n+\t}\n+\n+      /* Indicate that the value of the TLS variable may be found elsewhere,\n+\t preventing the variable from re-appearing in the GIMPLE.  We cheat\n+\t and use the control variable here (rather than a full call_expr),\n+\t which is special-cased inside the DWARF2 output routines.  */\n+      SET_DECL_VALUE_EXPR (var->decl, cdecl);\n+      DECL_HAS_VALUE_EXPR_P (var->decl) = 1;\n+    }\n+\n+  /* If there were any aliases, then frob the alias_pairs vector.  */\n+  if (any_aliases)\n+    {\n+      alias_pair *p;\n+      for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n+\tif (DECL_THREAD_LOCAL_P (p->decl))\n+\t  {\n+\t    p->decl = emutls_decl (p->decl);\n+\t    p->target = get_emutls_object_name (p->target);\n+\t  }\n+    }\n+\n+  /* Adjust all uses of TLS variables within the function bodies.  */\n+  for (func = cgraph_nodes; func; func = func->next)\n+    if (func->reachable && func->lowered)\n+      lower_emutls_function_body (func);\n+\n+  /* Generate the constructor for any COMMON control variables created.  */\n+  if (ctor_body)\n+    cgraph_build_static_cdtor ('I', ctor_body, DEFAULT_INIT_PRIORITY);\n+\n+  VEC_free (varpool_node_ptr, heap, control_vars);\n+  VEC_free (tree, heap, access_vars);\n+  tls_vars = NULL;\n+\n+  return TODO_dump_func | TODO_ggc_collect | TODO_verify_all;\n+}\n+\n+/* If the target supports TLS natively, we need do nothing here.  */\n+\n+static bool\n+gate_emutls (void)\n+{\n+  return !targetm.have_tls;\n+}\n+\n+struct simple_ipa_opt_pass pass_ipa_lower_emutls =\n+{\n+ {\n+  SIMPLE_IPA_PASS,\n+  \"emutls\",\t\t\t\t/* name */\n+  gate_emutls,\t\t\t\t/* gate */\n+  ipa_lower_emutls,\t\t\t/* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "33c898ee2403309fb351862a68fe15ddc42a8f65", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -446,6 +446,7 @@ extern struct gimple_opt_pass pass_warn_unused_result;\n extern struct gimple_opt_pass pass_split_functions;\n \n /* IPA Passes */\n+extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;\n extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;\n extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n "}, {"sha": "af8345a95becb6a51861e5c94f7b58c7b9bdb5d4", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -5257,7 +5257,6 @@ extern void set_user_assembler_name (tree, const char *);\n extern void process_pending_assemble_externals (void);\n extern void finish_aliases_1 (void);\n extern void finish_aliases_2 (void);\n-extern tree emutls_decl (tree);\n extern void remove_unreachable_alias_pairs (void);\n \n /* In stmt.c */"}, {"sha": "47423041bcde677d670e7bf01c4f9ca00474260e", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 424, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -186,317 +186,6 @@ static GTY(()) int anchor_labelno;\n /* A pool of constants that can be shared between functions.  */\n static GTY(()) struct rtx_constant_pool *shared_constant_pool;\n \n-/* TLS emulation.  */\n-\n-static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n-     htab_t emutls_htab;\n-static GTY (()) tree emutls_object_type;\n-/* Emulated TLS objects have the TLS model TLS_MODEL_EMULATED.  This\n-   macro can be used on them to distinguish the control variable from\n-   the initialization template.  */\n-#define DECL_EMUTLS_VAR_P(D)  (TREE_TYPE (D) == emutls_object_type)\n-\n-#if !defined (NO_DOT_IN_LABEL)\n-# define EMUTLS_SEPARATOR\t\".\"\n-#elif !defined (NO_DOLLAR_IN_LABEL)\n-# define EMUTLS_SEPARATOR\t\"$\"\n-#else\n-# define EMUTLS_SEPARATOR\t\"_\"\n-#endif\n-\n-/* Create an IDENTIFIER_NODE by prefixing PREFIX to the\n-   IDENTIFIER_NODE NAME's name.  */\n-\n-static tree\n-prefix_name (const char *prefix, tree name)\n-{\n-  unsigned plen = strlen (prefix);\n-  unsigned nlen = strlen (IDENTIFIER_POINTER (name));\n-  char *toname = (char *) alloca (plen + nlen + 1);\n-\n-  memcpy (toname, prefix, plen);\n-  memcpy (toname + plen, IDENTIFIER_POINTER (name), nlen + 1);\n-\n-  return get_identifier (toname);\n-}\n-\n-/* Create an identifier for the struct __emutls_object, given an identifier\n-   of the DECL_ASSEMBLY_NAME of the original object.  */\n-\n-static tree\n-get_emutls_object_name (tree name)\n-{\n-  const char *prefix = (targetm.emutls.var_prefix\n-\t\t\t? targetm.emutls.var_prefix\n-\t\t\t: \"__emutls_v\" EMUTLS_SEPARATOR);\n-  return prefix_name (prefix, name);\n-}\n-\n-tree\n-default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)\n-{\n-  tree word_type_node, field, next_field;\n-\n-  field = build_decl (UNKNOWN_LOCATION,\n-\t\t      FIELD_DECL, get_identifier (\"__templ\"), ptr_type_node);\n-  DECL_CONTEXT (field) = type;\n-  next_field = field;\n-\n-  field = build_decl (UNKNOWN_LOCATION,\n-\t\t      FIELD_DECL, get_identifier (\"__offset\"),\n-\t\t      ptr_type_node);\n-  DECL_CONTEXT (field) = type;\n-  DECL_CHAIN (field) = next_field;\n-  next_field = field;\n-\n-  word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n-  field = build_decl (UNKNOWN_LOCATION,\n-\t\t      FIELD_DECL, get_identifier (\"__align\"),\n-\t\t      word_type_node);\n-  DECL_CONTEXT (field) = type;\n-  DECL_CHAIN (field) = next_field;\n-  next_field = field;\n-\n-  field = build_decl (UNKNOWN_LOCATION,\n-\t\t      FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n-  DECL_CONTEXT (field) = type;\n-  DECL_CHAIN (field) = next_field;\n-\n-  return field;\n-}\n-\n-/* Create the structure for struct __emutls_object.  This should match the\n-   structure at the top of emutls.c, modulo the union there.  */\n-\n-static tree\n-get_emutls_object_type (void)\n-{\n-  tree type, type_name, field;\n-\n-  type = emutls_object_type;\n-  if (type)\n-    return type;\n-\n-  emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);\n-  type_name = NULL;\n-  field = targetm.emutls.var_fields (type, &type_name);\n-  if (!type_name)\n-    type_name = get_identifier (\"__emutls_object\");\n-  type_name = build_decl (UNKNOWN_LOCATION,\n-\t\t\t  TYPE_DECL, type_name, type);\n-  TYPE_NAME (type) = type_name;\n-  TYPE_FIELDS (type) = field;\n-  layout_type (type);\n-\n-  return type;\n-}\n-\n-/* Create a read-only variable like DECL, with the same DECL_INITIAL.\n-   This will be used for initializing the emulated tls data area.  */\n-\n-static tree\n-get_emutls_init_templ_addr (tree decl)\n-{\n-  tree name, to;\n-\n-  if (targetm.emutls.register_common && !DECL_INITIAL (decl)\n-      && !DECL_SECTION_NAME (decl))\n-    return null_pointer_node;\n-\n-  name = DECL_ASSEMBLER_NAME (decl);\n-  if (!targetm.emutls.tmpl_prefix || targetm.emutls.tmpl_prefix[0])\n-    {\n-      const char *prefix = (targetm.emutls.tmpl_prefix\n-\t\t\t    ? targetm.emutls.tmpl_prefix\n-\t\t\t    : \"__emutls_t\" EMUTLS_SEPARATOR);\n-      name = prefix_name (prefix, name);\n-    }\n-\n-  to = build_decl (DECL_SOURCE_LOCATION (decl),\n-\t\t   VAR_DECL, name, TREE_TYPE (decl));\n-  SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n-\n-  DECL_ARTIFICIAL (to) = 1;\n-  TREE_USED (to) = TREE_USED (decl);\n-  TREE_READONLY (to) = 1;\n-  DECL_IGNORED_P (to) = 1;\n-  DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n-  DECL_SECTION_NAME (to) = DECL_SECTION_NAME (decl);\n-  DECL_PRESERVE_P (to) = DECL_PRESERVE_P (decl);\n-\n-  DECL_WEAK (to) = DECL_WEAK (decl);\n-  if (DECL_ONE_ONLY (decl))\n-    {\n-      make_decl_one_only (to, DECL_ASSEMBLER_NAME (to));\n-      TREE_STATIC (to) = TREE_STATIC (decl);\n-      TREE_PUBLIC (to) = TREE_PUBLIC (decl);\n-      DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);\n-    }\n-  else\n-    TREE_STATIC (to) = 1;\n-\n-  DECL_VISIBILITY_SPECIFIED (to) = DECL_VISIBILITY_SPECIFIED (decl);\n-  DECL_INITIAL (to) = DECL_INITIAL (decl);\n-  DECL_INITIAL (decl) = NULL;\n-\n-  varpool_finalize_decl (to);\n-  return build_fold_addr_expr (to);\n-}\n-\n-/* When emulating tls, we use a control structure for use by the runtime.\n-   Create and return this structure.  */\n-\n-tree\n-emutls_decl (tree decl)\n-{\n-  tree name, to;\n-  struct tree_map *h, in;\n-  void **loc;\n-\n-  if (targetm.have_tls || decl == NULL || decl == error_mark_node\n-      || TREE_CODE (decl) != VAR_DECL || ! DECL_THREAD_LOCAL_P (decl))\n-    return decl;\n-\n-  /* Look up the object in the hash; return the control structure if\n-     it has already been created.  */\n-  if (! emutls_htab)\n-    emutls_htab = htab_create_ggc (512, tree_map_hash, tree_map_eq, 0);\n-\n-  name = DECL_ASSEMBLER_NAME (decl);\n-\n-  /* Note that we use the hash of the decl's name, rather than a hash\n-     of the decl's pointer.  In emutls_finish we iterate through the\n-     hash table, and we want this traversal to be predictable.  */\n-  in.hash = IDENTIFIER_HASH_VALUE (name);\n-  in.base.from = decl;\n-  loc = htab_find_slot_with_hash (emutls_htab, &in, in.hash, INSERT);\n-  h = (struct tree_map *) *loc;\n-  if (h != NULL)\n-    to = h->to;\n-  else\n-    {\n-      to = build_decl (DECL_SOURCE_LOCATION (decl),\n-\t\t       VAR_DECL, get_emutls_object_name (name),\n-\t\t       get_emutls_object_type ());\n-\n-      h = ggc_alloc_tree_map ();\n-      h->hash = in.hash;\n-      h->base.from = decl;\n-      h->to = to;\n-      *(struct tree_map **) loc = h;\n-\n-      DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;\n-      DECL_ARTIFICIAL (to) = 1;\n-      DECL_IGNORED_P (to) = 1;\n-      /* FIXME: work around PR44132.  */\n-      DECL_PRESERVE_P (to) = 1;\n-      TREE_READONLY (to) = 0;\n-      SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n-      if (DECL_ONE_ONLY (decl))\n-\tmake_decl_one_only (to, DECL_ASSEMBLER_NAME (to));\n-      DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n-      if (targetm.emutls.var_align_fixed)\n-\t/* If we're not allowed to change the proxy object's\n-\t   alignment, pretend it's been set by the user.  */\n-\tDECL_USER_ALIGN (to) = 1;\n-    }\n-\n-  /* Note that these fields may need to be updated from time to time from\n-     the original decl.  Consider:\n-\textern __thread int i;\n-\tint foo() { return i; }\n-\t__thread int i = 1;\n-     in which I goes from external to locally defined and initialized.  */\n-  DECL_DLLIMPORT_P (to) = DECL_DLLIMPORT_P (decl);\n-  DECL_ATTRIBUTES (to) = targetm.merge_decl_attributes (decl, to);\n-\n-  TREE_STATIC (to) = TREE_STATIC (decl);\n-  TREE_USED (to) = TREE_USED (decl);\n-  TREE_PUBLIC (to) = TREE_PUBLIC (decl);\n-  DECL_EXTERNAL (to) = DECL_EXTERNAL (decl);\n-  DECL_COMMON (to) = DECL_COMMON (decl);\n-  DECL_WEAK (to) = DECL_WEAK (decl);\n-  DECL_VISIBILITY (to) = DECL_VISIBILITY (decl);\n-  DECL_VISIBILITY_SPECIFIED (to) = DECL_VISIBILITY_SPECIFIED (decl);\n-  \n-  /* Fortran might pass this to us.  */\n-  DECL_RESTRICTED_P (to) = DECL_RESTRICTED_P (decl);\n-\n-  return to;\n-}\n-\n-static int\n-emutls_common_1 (void **loc, void *xstmts)\n-{\n-  struct tree_map *h = *(struct tree_map **) loc;\n-  tree x, *pstmts = (tree *) xstmts;\n-  tree word_type_node;\n-\n-  if (! DECL_COMMON (h->base.from)\n-      || (DECL_INITIAL (h->base.from)\n-\t  && DECL_INITIAL (h->base.from) != error_mark_node))\n-    return 1;\n-\n-  word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n-\n-  /* The idea was to call get_emutls_init_templ_addr here, but if we\n-     do this and there is an initializer, -fanchor_section loses,\n-     because it would be too late to ensure the template is\n-     output.  */\n-  x = built_in_decls[BUILT_IN_EMUTLS_REGISTER_COMMON];\n-  x = build_call_expr (x, 4,\n-\t\t       build_fold_addr_expr (h->to),\n-\t\t       fold_convert (word_type_node,\n-\t\t\t\t     DECL_SIZE_UNIT (h->base.from)),\n-\t\t       build_int_cst (word_type_node,\n-\t\t\t\t      DECL_ALIGN_UNIT (h->base.from)),\n-\t\t       null_pointer_node);\n-\n-  append_to_statement_list (x, pstmts);\n-  return 1;\n-}\n-\n-/* Callback to finalize one emutls control variable.  */\n-\n-static int\n-emutls_finalize_control_var (void **loc, \n-\t\t\t\tvoid *unused ATTRIBUTE_UNUSED)\n-{\n-  struct tree_map *h = *(struct tree_map **) loc;\n-  if (h != NULL) \n-    {\n-      struct varpool_node *node = varpool_node (h->to);\n-      /* Because varpool_finalize_decl () has side-effects,\n-         only apply to un-finalized vars.  */\n-      if (node && !node->finalized) \n-\tvarpool_finalize_decl (h->to);\n-    }\n-  return 1;\n-}\n-\n-/* Finalize emutls control vars and add a static constructor if\n-   required.  */\n-\n-void\n-emutls_finish (void)\n-{\n-  if (emutls_htab == NULL)\n-    return;\n-  htab_traverse_noresize (emutls_htab, \n-\t\t\t  emutls_finalize_control_var, NULL);\n-\n-  if (targetm.emutls.register_common)\n-    {\n-      tree body = NULL_TREE;\n-\n-      htab_traverse_noresize (emutls_htab, emutls_common_1, &body);\n-      if (body == NULL_TREE)\n-\treturn;\n-\n-      cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n-    }\n-}\n-\n /* Helper routines for maintaining section_htab.  */\n \n static int\n@@ -1210,11 +899,6 @@ get_variable_section (tree decl, bool prefer_noswitch_p)\n \t\t  && ADDR_SPACE_GENERIC_P (as));\n       if (DECL_THREAD_LOCAL_P (decl))\n \treturn tls_comm_section;\n-      /* This cannot be common bss for an emulated TLS object without\n-\t a register_common hook.  */\n-      else if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED\n-\t       && !targetm.emutls.register_common)\n-\t;\n       else if (TREE_PUBLIC (decl) && bss_initializer_p (decl))\n \treturn comm_section;\n     }\n@@ -2098,40 +1782,6 @@ assemble_variable_contents (tree decl, const char *name,\n     }\n }\n \n-/* Initialize emulated tls object TO, which refers to TLS variable\n-   DECL and is initialized by PROXY.  */\n-\n-tree\n-default_emutls_var_init (tree to, tree decl, tree proxy)\n-{\n-  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n-  constructor_elt *elt;\n-  tree type = TREE_TYPE (to);\n-  tree field = TYPE_FIELDS (type);\n-\n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n-  elt->index = field;\n-  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n-\n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = DECL_CHAIN (field);\n-  elt->index = field;\n-  elt->value = build_int_cst (TREE_TYPE (field),\n-\t\t\t      DECL_ALIGN_UNIT (decl));\n-\n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = DECL_CHAIN (field);\n-  elt->index = field;\n-  elt->value = null_pointer_node;\n-\n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n-  field = DECL_CHAIN (field);\n-  elt->index = field;\n-  elt->value = proxy;\n-\n-  return build_constructor (type, v);\n-}\n-\n /* Assemble everything that is needed for a variable or function declaration.\n    Not used for automatic variables, and not used for function definitions.\n    Should not be called for variables of incomplete structure type.\n@@ -2153,35 +1803,9 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   /* This function is supposed to handle VARIABLES.  Ensure we have one.  */\n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n \n-  if (! targetm.have_tls\n-      && TREE_CODE (decl) == VAR_DECL\n-      && DECL_THREAD_LOCAL_P (decl))\n-    {\n-      tree to = emutls_decl (decl);\n-\n-      /* If this variable is defined locally, then we need to initialize the\n-         control structure with size and alignment information.  We do this\n-\t at the last moment because tentative definitions can take a locally\n-\t defined but uninitialized variable and initialize it later, which\n-\t would result in incorrect contents.  */\n-      if (! DECL_EXTERNAL (to)\n-\t  && (! DECL_COMMON (to)\n-\t      || (DECL_INITIAL (decl)\n-\t\t  && DECL_INITIAL (decl) != error_mark_node)))\n-\t{\n-\t  DECL_INITIAL (to) = targetm.emutls.var_init\n-\t    (to, decl, get_emutls_init_templ_addr (decl));\n-\n-\t  /* Make sure the template is marked as needed early enough.\n-\t     Without this, if the variable is placed in a\n-\t     section-anchored block, the template will only be marked\n-\t     when it's too late.  */\n-\t  record_references_in_initializer (to, false);\n-\t}\n-\n-      decl = to;\n-    }\n-\n+  /* Emulated TLS had better not get this far.  */\n+  gcc_checking_assert (targetm.have_tls || !DECL_THREAD_LOCAL_P (decl));\n+              \n   last_assemble_variable_decl = 0;\n \n   /* Normally no need to say anything here for external references,\n@@ -5685,6 +5309,11 @@ find_decl_and_mark_needed (tree decl, tree target)\n static void\n do_assemble_alias (tree decl, tree target)\n {\n+  /* Emulated TLS had better not get this var.  */\n+  gcc_assert(!(!targetm.have_tls\n+\t       && TREE_CODE (decl) == VAR_DECL\n+\t       && DECL_THREAD_LOCAL_P (decl)));\n+\n   if (TREE_ASM_WRITTEN (decl))\n     return;\n \n@@ -5699,14 +5328,6 @@ do_assemble_alias (tree decl, tree target)\n     {\n       ultimate_transparent_alias_target (&target);\n \n-      if (!targetm.have_tls\n-\t  && TREE_CODE (decl) == VAR_DECL\n-\t  && DECL_THREAD_LOCAL_P (decl))\n-\t{\n-\t  decl = emutls_decl (decl);\n-\t  target = get_emutls_object_name (target);\n-\t}\n-\n       if (!TREE_SYMBOL_REFERENCED (target))\n \tweakref_targets = tree_cons (decl, target, weakref_targets);\n \n@@ -5725,14 +5346,6 @@ do_assemble_alias (tree decl, tree target)\n       return;\n     }\n \n-  if (!targetm.have_tls\n-      && TREE_CODE (decl) == VAR_DECL\n-      && DECL_THREAD_LOCAL_P (decl))\n-    {\n-      decl = emutls_decl (decl);\n-      target = get_emutls_object_name (target);\n-    }\n-\n #ifdef ASM_OUTPUT_DEF\n   /* Make name accessible from other files, if appropriate.  */\n \n@@ -6400,24 +6013,11 @@ categorize_decl_for_section (const_tree decl, int reloc)\n     ret = SECCAT_RODATA;\n \n   /* There are no read-only thread-local sections.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_TLS_MODEL (decl))\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n     {\n-      if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED)\n-\t{\n-\t  if (DECL_EMUTLS_VAR_P (decl))\n-\t    {\n-\t      if (targetm.emutls.var_section)\n-\t\tret = SECCAT_EMUTLS_VAR;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (targetm.emutls.tmpl_prefix)\n-\t\tret = SECCAT_EMUTLS_TMPL;\n-\t    }\n-\t}\n       /* Note that this would be *just* SECCAT_BSS, except that there's\n \t no concept of a read-only thread-local-data section.  */\n-      else if (ret == SECCAT_BSS\n+      if (ret == SECCAT_BSS\n \t       || (flag_zero_initialized_in_bss\n \t\t   && initializer_zerop (DECL_INITIAL (decl))))\n \tret = SECCAT_TBSS;\n@@ -6511,12 +6111,6 @@ default_elf_select_section (tree decl, int reloc,\n     case SECCAT_TBSS:\n       sname = \".tbss\";\n       break;\n-    case SECCAT_EMUTLS_VAR:\n-      sname = targetm.emutls.var_section;\n-      break;\n-    case SECCAT_EMUTLS_TMPL:\n-      sname = targetm.emutls.tmpl_section;\n-      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -6581,12 +6175,6 @@ default_unique_section (tree decl, int reloc)\n     case SECCAT_TBSS:\n       prefix = one_only ? \".tb\" : \".tbss\";\n       break;\n-    case SECCAT_EMUTLS_VAR:\n-      prefix = targetm.emutls.var_section;\n-      break;\n-    case SECCAT_EMUTLS_TMPL:\n-      prefix = targetm.emutls.tmpl_section;\n-      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -6697,8 +6285,7 @@ default_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n     flags |= SYMBOL_FLAG_FUNCTION;\n   if (targetm.binds_local_p (decl))\n     flags |= SYMBOL_FLAG_LOCAL;\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl)\n-      && DECL_TLS_MODEL (decl) != TLS_MODEL_EMULATED)\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n     flags |= DECL_TLS_MODEL (decl) << SYMBOL_FLAG_TLS_SHIFT;\n   else if (targetm.in_small_data_p (decl))\n     flags |= SYMBOL_FLAG_SMALL;"}, {"sha": "dcf3518db632a7038e2f6b2468a0f8d3e2a87648", "filename": "gcc/varpool.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b84c5966fddefd51475d4df0fb2f1a699ba23fe/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=8b84c5966fddefd51475d4df0fb2f1a699ba23fe", "patch": "@@ -346,17 +346,6 @@ decide_is_variable_needed (struct varpool_node *node, tree decl)\n       && !DECL_EXTERNAL (decl))\n     return true;\n \n-  /* When emulating tls, we actually see references to the control\n-     variable, rather than the user-level variable.  */\n-  if (!targetm.have_tls\n-      && TREE_CODE (decl) == VAR_DECL\n-      && DECL_THREAD_LOCAL_P (decl))\n-    {\n-      tree control = emutls_decl (decl);\n-      if (decide_is_variable_needed (varpool_node (control), control))\n-\treturn true;\n-    }\n-\n   /* When not reordering top level variables, we have to assume that\n      we are going to keep everything.  */\n   if (flag_toplevel_reorder)"}]}