{"sha": "4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkMWRjMTI3NWJiYTg5YWY5MmJmYzdkOTdjMjFiMzc2ZTRjMjljMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-05T02:48:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-08T20:12:25Z"}, "message": "c++: Fix defaulted <=> fallback to < and == [PR96299]\n\nI thought I had implemented P1186R3, but apparently I didn't read it closely\nenough to understand the point of the paper, namely that for a defaulted\noperator<=>, if a member type doesn't have a viable operator<=>, we will use\nits operator< and operator== if the defaulted operator has an specific\ncomparison category as its return type; the compiler can't guess if it\nshould be strong_ordering or something else, but the user can make that\nchoice explicit.\n\nThe libstdc++ test change was necessary because of the change in\ngenericize_spaceship from op0 > op1 to op1 < op0; this should be equivalent,\nbut isn't because of PR88173.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96299\n\t* cp-tree.h (build_new_op): Add overload that omits some parms.\n\t(genericize_spaceship): Add location_t parm.\n\t* constexpr.c (cxx_eval_binary_expression): Pass it.\n\t* cp-gimplify.c (genericize_spaceship): Pass it.\n\t* method.c (genericize_spaceship): Handle class-type arguments.\n\t(build_comparison_op): Fall back to op</== when appropriate.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96299\n\t* g++.dg/cpp2a/spaceship-synth-neg2.C: Move error.\n\t* g++.dg/cpp2a/spaceship-p1186.C: New test.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR c++/96299\n\t* testsuite/18_support/comparisons/algorithms/partial_order.cc:\n\tOne more line needs to use VERIFY instead of static_assert.", "tree": {"sha": "03acc5cf7dbc5e9e56aa34664cdd835c803cd181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03acc5cf7dbc5e9e56aa34664cdd835c803cd181"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a988a398d6daef3072cd2d07a21980911d8f93fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a988a398d6daef3072cd2d07a21980911d8f93fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a988a398d6daef3072cd2d07a21980911d8f93fc"}], "stats": {"total": 253, "additions": 222, "deletions": 31}, "files": [{"sha": "2ef6de83830f185b75c75fc369f562efba0c88d6", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -3159,7 +3159,7 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t  overflow_p);\n   else if (code == SPACESHIP_EXPR)\n     {\n-      r = genericize_spaceship (type, lhs, rhs);\n+      r = genericize_spaceship (loc, type, lhs, rhs);\n       return cxx_eval_constant_expression (ctx, r, lval, non_constant_p,\n \t\t\t\t\t   overflow_p);\n     }"}, {"sha": "4f62398dfb039622fb7e19608e032ea588987309", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -882,7 +882,7 @@ static tree genericize_spaceship (tree expr)\n   tree type = TREE_TYPE (expr);\n   tree op0 = TREE_OPERAND (expr, 0);\n   tree op1 = TREE_OPERAND (expr, 1);\n-  return genericize_spaceship (type, op0, op1);\n+  return genericize_spaceship (input_location, type, op0, op1);\n }\n \n /* If EXPR involves an anonymous VLA type, prepend a DECL_EXPR for that type"}, {"sha": "6270fadfe2bfe37308f39c4ca3ead37e5f6c5dd9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -6335,6 +6335,13 @@ extern tree build_new_op\t\t\t(const op_location_t &,\n \t\t\t\t\t\t enum tree_code,\n \t\t\t\t\t\t int, tree, tree, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n+/* Wrapper that leaves out the usually-null op3 and overload parms.  */\n+inline tree build_new_op (const op_location_t &loc, enum tree_code code,\n+\t\t\t  int flags, tree arg1, tree arg2,\n+\t\t\t  tsubst_flags_t complain)\n+{\n+  return build_new_op (loc, code, flags, arg1, arg2, NULL_TREE, NULL, complain);\n+}\n extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern bool aligned_allocation_fn_p\t\t(tree);\n@@ -7807,7 +7814,7 @@ extern tree merge_types\t\t\t\t(tree, tree);\n extern tree strip_array_domain\t\t\t(tree);\n extern tree check_return_expr\t\t\t(tree, bool *);\n extern tree spaceship_type\t\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n-extern tree genericize_spaceship\t\t(tree, tree, tree);\n+extern tree genericize_spaceship\t\t(location_t, tree, tree, tree);\n extern tree cp_build_binary_op                  (const op_location_t &,\n \t\t\t\t\t\t enum tree_code, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "da580a868b8e6cd479d36cfb91f31004c4f3c8c4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 91, "deletions": 24, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -1063,43 +1063,60 @@ spaceship_type (tree optype, tsubst_flags_t complain)\n   return lookup_comparison_category (tag, complain);\n }\n \n-/* Turn <=> with type TYPE and operands OP0 and OP1 into GENERIC.  */\n+/* Turn <=> with type TYPE and operands OP0 and OP1 into GENERIC.\n+   This is also used by build_comparison_op for fallback to op< and op==\n+   in a defaulted op<=>.  */\n \n tree\n-genericize_spaceship (tree type, tree op0, tree op1)\n+genericize_spaceship (location_t loc, tree type, tree op0, tree op1)\n {\n   /* ??? maybe optimize based on knowledge of representation? */\n   comp_cat_tag tag = cat_tag_for (type);\n+\n+  if (tag == cc_last && is_auto (type))\n+    {\n+      /* build_comparison_op is checking to see if we want to suggest changing\n+\t the op<=> return type from auto to a specific comparison category; any\n+\t category will do for now.  */\n+      tag = cc_strong_ordering;\n+      type = lookup_comparison_category (tag, tf_none);\n+      if (type == error_mark_node)\n+\treturn error_mark_node;\n+    }\n+\n   gcc_checking_assert (tag < cc_last);\n \n   tree r;\n-  op0 = save_expr (op0);\n-  op1 = save_expr (op1);\n+  if (SCALAR_TYPE_P (TREE_TYPE (op0)))\n+    {\n+      op0 = save_expr (op0);\n+      op1 = save_expr (op1);\n+    }\n \n   tree gt = lookup_comparison_result (tag, type, 1);\n \n+  int flags = LOOKUP_NORMAL;\n+  tsubst_flags_t complain = tf_none;\n+\n   if (tag == cc_partial_ordering)\n     {\n       /* op0 == op1 ? equivalent : op0 < op1 ? less :\n-\t op0 > op1 ? greater : unordered */\n+\t op1 < op0 ? greater : unordered */\n       tree uo = lookup_comparison_result (tag, type, 3);\n-      tree comp = fold_build2 (GT_EXPR, boolean_type_node, op0, op1);\n-      r = fold_build3 (COND_EXPR, type, comp, gt, uo);\n+      tree comp = build_new_op (loc, LT_EXPR, flags, op1, op0, complain);\n+      r = build_conditional_expr (loc, comp, gt, uo, complain);\n     }\n   else\n     /* op0 == op1 ? equal : op0 < op1 ? less : greater */\n     r = gt;\n \n   tree lt = lookup_comparison_result (tag, type, 2);\n-  tree comp = fold_build2 (LT_EXPR, boolean_type_node, op0, op1);\n-  r = fold_build3 (COND_EXPR, type, comp, lt, r);\n+  tree comp = build_new_op (loc, LT_EXPR, flags, op0, op1, complain);\n+  r = build_conditional_expr (loc, comp, lt, r, complain);\n \n   tree eq = lookup_comparison_result (tag, type, 0);\n-  comp = fold_build2 (EQ_EXPR, boolean_type_node, op0, op1);\n-  r = fold_build3 (COND_EXPR, type, comp, eq, r);\n-\n-  /* Wrap the whole thing in a TARGET_EXPR like build_conditional_expr_1.  */\n-  r = get_target_expr (r);\n+  comp = build_new_op (loc, EQ_EXPR, flags, op0, op1, complain);\n+  r = build_conditional_expr (loc, comp, eq, r, complain);\n \n   return r;\n }\n@@ -1323,7 +1340,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n   if (!info.defining && !(complain & tf_error) && !DECL_MAYBE_DELETED (fndecl))\n     return;\n \n-  int flags = LOOKUP_NORMAL | LOOKUP_NONVIRTUAL | LOOKUP_DEFAULTED;\n+  int flags = LOOKUP_NORMAL;\n   const ovl_op_info_t *op = IDENTIFIER_OVL_OP_INFO (DECL_NAME (fndecl));\n   tree_code code = op->tree_code;\n \n@@ -1364,6 +1381,10 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \n   if (code == EQ_EXPR || code == SPACESHIP_EXPR)\n     {\n+      comp_cat_tag retcat = cc_last;\n+      if (code == SPACESHIP_EXPR && !FNDECL_USED_AUTO (fndecl))\n+\tretcat = cat_tag_for (rettype);\n+\n       bool bad = false;\n       auto_vec<tree> comps;\n \n@@ -1375,13 +1396,15 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t{\n \t  tree expr_type = TREE_TYPE (field);\n \n+\t  location_t field_loc = DECL_SOURCE_LOCATION (field);\n+\n \t  /* A defaulted comparison operator function for class C is defined as\n \t     deleted if any non-static data member of C is of reference type or\n \t     C has variant members.  */\n \t  if (TREE_CODE (expr_type) == REFERENCE_TYPE)\n \t    {\n \t      if (complain & tf_error)\n-\t\tinform (DECL_SOURCE_LOCATION (field), \"cannot default compare \"\n+\t\tinform (field_loc, \"cannot default compare \"\n \t\t\t\"reference member %qD\", field);\n \t      bad = true;\n \t      continue;\n@@ -1390,7 +1413,7 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t\t   && next_initializable_field (TYPE_FIELDS (expr_type)))\n \t    {\n \t      if (complain & tf_error)\n-\t\tinform (DECL_SOURCE_LOCATION (field), \"cannot default compare \"\n+\t\tinform (field_loc, \"cannot default compare \"\n \t\t\t\"anonymous union member\");\n \t      bad = true;\n \t      continue;\n@@ -1400,25 +1423,69 @@ build_comparison_op (tree fndecl, tsubst_flags_t complain)\n \t\t\t\t NULL_TREE);\n \t  tree rhs_mem = build3 (COMPONENT_REF, expr_type, rhs, field,\n \t\t\t\t NULL_TREE);\n-\t  tree comp = build_new_op (info.loc, code, flags, lhs_mem, rhs_mem,\n-\t\t\t\t    NULL_TREE, NULL, complain);\n+\t  tree overload = NULL_TREE;\n+\t  tree comp = build_new_op (field_loc, code, flags, lhs_mem, rhs_mem,\n+\t\t\t\t    NULL_TREE, &overload,\n+\t\t\t\t    retcat != cc_last ? tf_none : complain);\n \t  if (comp == error_mark_node)\n \t    {\n-\t      bad = true;\n-\t      continue;\n+\t      if (overload == NULL_TREE && code == SPACESHIP_EXPR\n+\t\t  && (retcat != cc_last || complain))\n+\t\t{\n+\t\t  tree comptype = (retcat != cc_last ? rettype\n+\t\t\t\t   : DECL_SAVED_AUTO_RETURN_TYPE (fndecl));\n+\t\t  /* No viable <=>, try using op< and op==.  */\n+\t\t  tree lteq = genericize_spaceship (field_loc, comptype,\n+\t\t\t\t\t\t    lhs_mem, rhs_mem);\n+\t\t  if (lteq != error_mark_node)\n+\t\t    {\n+\t\t      /* We found usable < and ==.  */\n+\t\t      if (retcat != cc_last)\n+\t\t\t/* Return type is a comparison category, use them.  */\n+\t\t\tcomp = lteq;\n+\t\t      else if (complain & tf_error)\n+\t\t\t/* Return type is auto, suggest changing it.  */\n+\t\t\tinform (info.loc, \"changing the return type from %qs \"\n+\t\t\t\t\"to a comparison category type will allow the \"\n+\t\t\t\t\"comparison to use %qs and %qs\", \"auto\",\n+\t\t\t\t\"operator<\", \"operator==\");\n+\t\t    }\n+\t\t  else if (retcat != cc_last && complain != tf_none)\n+\t\t    /* No usable < and ==, give an error for op<=>.  */\n+\t\t    build_new_op (field_loc, code, flags, lhs_mem, rhs_mem,\n+\t\t\t\t  complain);\n+\t\t}\n+\t      if (comp == error_mark_node)\n+\t\t{\n+\t\t  bad = true;\n+\t\t  continue;\n+\t\t}\n \t    }\n-\t  if (code == SPACESHIP_EXPR\n-\t      && cat_tag_for (TREE_TYPE (comp)) == cc_last)\n+\t  if (code != SPACESHIP_EXPR)\n+\t    ;\n+\t  else if (FNDECL_USED_AUTO (fndecl)\n+\t\t   && cat_tag_for (TREE_TYPE (comp)) == cc_last)\n \t    {\n \t      /* The operator function is defined as deleted if ... Ri is not a\n \t\t comparison category type.  */\n \t      if (complain & tf_error)\n-\t\tinform (DECL_SOURCE_LOCATION (field),\n+\t\tinform (field_loc,\n \t\t\t\"three-way comparison of %qD has type %qT, not a \"\n \t\t\t\"comparison category type\", field, TREE_TYPE (comp));\n \t      bad = true;\n \t      continue;\n \t    }\n+\t  else if (!FNDECL_USED_AUTO (fndecl)\n+\t\t   && !can_convert (rettype, TREE_TYPE (comp), complain))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror_at (field_loc,\n+\t\t\t  \"three-way comparison of %qD has type %qT, which \"\n+\t\t\t  \"does not convert to %qT\",\n+\t\t\t  field, TREE_TYPE (comp), rettype);\n+\t      bad = true;\n+\t      continue;\n+\t    }\n \t  comps.safe_push (comp);\n \t}\n       if (code == SPACESHIP_EXPR && is_auto (rettype))"}, {"sha": "a979fcb65dfdd603d003806a4ace5ad4eabc1d5e", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-p1186.C", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-p1186.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-p1186.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-p1186.C?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -0,0 +1,117 @@\n+// PR c++/96299\n+// P1186R3\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+\n+struct H {\n+  bool operator==(H const &) const;\n+  bool operator<(H const &) const;\n+};\n+\n+// Can't deduce category from op< and op==.\n+struct A {\n+  int i;\n+  char c;\n+  H h;\t\t\t\t// { dg-error \"operator<=>\" }\n+  auto operator<=>(A const &) const = default;\n+};\n+\n+// OK, explicit return type tells us how to interpret op</==.\n+struct B {\n+  int i;\n+  char c;\n+  H h;\n+  std::strong_ordering operator<=>(B const &) const = default;\n+};\n+\n+struct C {\n+  bool operator<(C const &) const;\n+};\n+\n+// C's op< isn't enough, need op== as well.\n+struct D {\n+  C c;\t\t\t\t// { dg-error \"operator<=>\" }\n+  std::strong_ordering operator<=>(D const &) const = default;\n+};\n+\n+struct E {\n+  std::partial_ordering operator<=>(E const &) const;\n+};\n+\n+// Can't use a weak op<=> to build a strong op<=>.\n+struct F {\n+  E e;\t\t\t\t// { dg-error \"strong_ordering\" }\n+  H h;\n+  std::strong_ordering operator<=>(F const &) const = default;\n+};\n+\n+struct G {\n+  std::strong_ordering operator<=>(G const &) const;\n+};\n+\n+// OK, uses op<=> for g and op</op== for h.\n+struct I {\n+  G g;\n+  H h;\n+  std::partial_ordering operator<=>(I const &) const = default;\n+};\n+\n+template <class T>\n+struct J {\n+  T t;\t\t\t\t// { dg-error \"no match|ambiguous\" }\n+  auto operator<=>(J const &) const = default;\n+};\n+\n+template <class T>\n+struct K {\n+  T t;\t\t\t\t// { dg-error \"no match\" }\n+  std::partial_ordering operator<=>(K const &) const = default;\n+};\n+\n+template <class T>\n+struct M {\n+  T t;\t\t\t\t// { dg-error \"no match|strong_ordering\" }\n+  std::strong_ordering operator<=>(M const &) const = default;\n+};\n+\n+// Test that we don't fall back to </== if <=> is ambiguous.\n+struct N {\n+  bool operator==(N const &) const;\n+  bool operator<(N const &) const;\n+};\n+template <class T>\n+std::partial_ordering operator<=>(N const &, T&&);\n+template <class T>\n+std::partial_ordering operator<=>(T&&, N const &);\n+\n+void\n+foo (A &a1, A &a2, B &b1, B &b2, D& d1, D& d2, F& f1, F& f2, I& i1, I& i2)\n+{\n+  auto a = a1 < a2;\t\t// { dg-error \"deleted\" }\n+  auto b = b1 < b2;\n+  auto d = d1 < d2;\t\t// { dg-error \"deleted\" }\n+  auto f = f1 < f2;\t\t// { dg-error \"deleted\" }\n+  auto i = i1 < i2;\n+\n+  auto j1 = J<int>() < J<int>();\n+  auto j2 = J<H>() < J<H>();\t// { dg-error \"deleted\" }\n+  auto j3 = J<C>() < J<C>();\t// { dg-error \"deleted\" }\n+  auto j4 = J<E>() < J<E>();\n+  auto j5 = J<G>() < J<G>();\n+  auto j6 = J<N>() < J<N>();\t// { dg-error \"deleted\" }\n+\n+  auto k1 = K<int>() < K<int>();\n+  auto k2 = K<H>() < K<H>();\n+  auto k3 = K<C>() < K<C>();\t// { dg-error \"deleted\" }\n+  auto k4 = K<E>() < K<E>();\n+  auto k5 = K<G>() < K<G>();\n+  auto k6 = K<N>() < K<N>();\t// { dg-error \"deleted\" }\n+\n+  auto m1 = M<int>() < M<int>();\n+  auto m2 = M<H>() < M<H>();\n+  auto m3 = M<C>() < M<C>();\t// { dg-error \"deleted\" }\n+  auto m4 = M<E>() < M<E>();\t// { dg-error \"deleted\" }\n+  auto m5 = M<G>() < M<G>();\n+  auto m6 = M<N>() < M<N>();\t// { dg-error \"deleted\" }\n+}"}, {"sha": "c6acb7b5a80236bd6ed10c3e26a6fc74b53dd672", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth-neg2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth-neg2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth-neg2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth-neg2.C?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -14,9 +14,9 @@ bool operator<(const X<T>&, const X<T>&) { return true; }\n struct Y\n {\n   int a;\n-  X<int> c;\n+  X<int> c;\t\t\t// { dg-error \"no match\" }\n \n-  auto operator <=>(Y const&) const = default; // { dg-error \"no match\" }\n+  auto operator <=>(Y const&) const = default;\n };\n \n void f()"}, {"sha": "094ac70287458fbee4176e439aaadc41bce305e3", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/partial_order.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed1dc1275bba89af92bfc7d97c21b376e4c29c3/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc?ref=4ed1dc1275bba89af92bfc7d97c21b376e4c29c3", "patch": "@@ -70,7 +70,7 @@ test03()\n   constexpr double epsilon = std::numeric_limits<double>::epsilon();\n   static_assert( partial_order(denorm, smallest) == partial_ordering::less );\n   static_assert( partial_order(denorm, 0.0) == partial_ordering::greater );\n-  // FIXME: these should all use static_assert\n+  // FIXME: these should all use static_assert.  See PR88173.\n   VERIFY( partial_order(0.0, nan) == partial_ordering::unordered );\n   VERIFY( partial_order(nan, nan) == partial_ordering::unordered );\n   VERIFY( partial_order(nan, 0.0) == partial_ordering::unordered );\n@@ -81,7 +81,7 @@ test03()\n   VERIFY( partial_order(-inf, -nan) == partial_ordering::unordered );\n   static_assert( partial_order(max, inf) == partial_ordering::less );\n   static_assert( partial_order(inf, max) == partial_ordering::greater );\n-  static_assert( partial_order(inf, nan) == partial_ordering::unordered );\n+  VERIFY( partial_order(inf, nan) == partial_ordering::unordered );\n   static_assert( partial_order(1.0, 1.0+epsilon) == partial_ordering::less );\n }\n "}]}