{"sha": "a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlM2IzZDlmMGM2MWI3MjlhZDY0ZGI0NzlmM2RjNGM2NDEyMDNmZg==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2010-04-22T09:34:32Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2010-04-22T09:34:32Z"}, "message": "2010-04-22  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* c-tree.h (push_init_level, pop_init_level, set_init_index)\n\t(process_init_element): New argument of type struct obstack *.\n\n\t* c-typeck.c (push_init_level, pop_init_level, set_designator)\n\t(set_init_index, set_init_label, set_nonincremental_init)\n\t(set_nonincremental_init_from_string, find_init_member)\n\t(output_init_element, output_pending_init_elements)\n\t(process_init_element): New argument braced_init_obstack.  Pass it\n\tdown.\n\t(push_range_stack, add_pending_init): New argument\n\tbraced_init_obstack.  Use obstack allocation.\n\n\t* c-parser.c (c_parser_initelt, c_parser_initval): New argument\n\tbraced_init_obstack.  Pass it down.\n\t(c_parser_braced_init): New variables ret, braced_init_obstack.\n\tInitialize obstack, pass it down and finally free it.\n\nFrom-SVN: r158634", "tree": {"sha": "c91abf2b932d8d427f3728cfcbac2e5959e0b43c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c91abf2b932d8d427f3728cfcbac2e5959e0b43c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b58b39b0a7d1c79b0d57e51199864f9a3685bb4"}], "stats": {"total": 233, "additions": 147, "deletions": 86}, "files": [{"sha": "bdcd51dc829214c54a7ac38b457a8adaced25c41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "patch": "@@ -1,3 +1,22 @@\n+2010-04-22  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* c-tree.h (push_init_level, pop_init_level, set_init_index)\n+\t(process_init_element): New argument of type struct obstack *.\n+\n+\t* c-typeck.c (push_init_level, pop_init_level, set_designator)\n+\t(set_init_index, set_init_label, set_nonincremental_init)\n+\t(set_nonincremental_init_from_string, find_init_member)\n+\t(output_init_element, output_pending_init_elements)\n+\t(process_init_element): New argument braced_init_obstack.  Pass it\n+\tdown.\n+\t(push_range_stack, add_pending_init): New argument\n+\tbraced_init_obstack.  Use obstack allocation.\n+\n+\t* c-parser.c (c_parser_initelt, c_parser_initval): New argument\n+\tbraced_init_obstack.  Pass it down.\n+\t(c_parser_braced_init): New variables ret, braced_init_obstack.\n+\tInitialize obstack, pass it down and finally free it.\n+\n 2010-04-22  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR middle-end/29274"}, {"sha": "a8feb27b8836048f8dabb07739ee62af0c158a87", "filename": "gcc/c-parser.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "patch": "@@ -906,8 +906,9 @@ static tree c_parser_attributes (c_parser *);\n static struct c_type_name *c_parser_type_name (c_parser *);\n static struct c_expr c_parser_initializer (c_parser *);\n static struct c_expr c_parser_braced_init (c_parser *, tree, bool);\n-static void c_parser_initelt (c_parser *);\n-static void c_parser_initval (c_parser *, struct c_expr *);\n+static void c_parser_initelt (c_parser *, struct obstack *);\n+static void c_parser_initval (c_parser *, struct c_expr *,\n+\t\t\t      struct obstack *);\n static tree c_parser_compound_statement (c_parser *);\n static void c_parser_compound_statement_nostart (c_parser *);\n static void c_parser_label (c_parser *);\n@@ -3088,11 +3089,14 @@ c_parser_initializer (c_parser *parser)\n static struct c_expr\n c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n {\n+  struct c_expr ret;\n+  struct obstack braced_init_obstack;\n   location_t brace_loc = c_parser_peek_token (parser)->location;\n+  gcc_obstack_init (&braced_init_obstack);\n   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));\n   c_parser_consume_token (parser);\n   if (nested_p)\n-    push_init_level (0);\n+    push_init_level (0, &braced_init_obstack);\n   else\n     really_start_incremental_init (type);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -3105,7 +3109,7 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n \t comma.  */\n       while (true)\n \t{\n-\t  c_parser_initelt (parser);\n+\t  c_parser_initelt (parser, &braced_init_obstack);\n \t  if (parser->error)\n \t    break;\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n@@ -3118,22 +3122,24 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n     }\n   if (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))\n     {\n-      struct c_expr ret;\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n-      pop_init_level (0);\n+      pop_init_level (0, &braced_init_obstack);\n+      obstack_free (&braced_init_obstack, NULL);\n       return ret;\n     }\n   c_parser_consume_token (parser);\n-  return pop_init_level (0);\n+  ret = pop_init_level (0, &braced_init_obstack);\n+  obstack_free (&braced_init_obstack, NULL);\n+  return ret;\n }\n \n /* Parse a nested initializer, including designators.  */\n \n static void\n-c_parser_initelt (c_parser *parser)\n+c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)\n {\n   /* Parse any designator or designator list.  A single array\n      designator may have the subsequent \"=\" omitted in GNU C, but a\n@@ -3142,7 +3148,8 @@ c_parser_initelt (c_parser *parser)\n       && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n     {\n       /* Old-style structure member designator.  */\n-      set_init_label (c_parser_peek_token (parser)->value);\n+      set_init_label (c_parser_peek_token (parser)->value,\n+\t\t      braced_init_obstack);\n       /* Use the colon as the error location.  */\n       pedwarn (c_parser_peek_2nd_token (parser)->location, OPT_pedantic,\n \t       \"obsolete use of designated initializer with %<:%>\");\n@@ -3170,7 +3177,8 @@ c_parser_initelt (c_parser *parser)\n \t      c_parser_consume_token (parser);\n \t      if (c_parser_next_token_is (parser, CPP_NAME))\n \t\t{\n-\t\t  set_init_label (c_parser_peek_token (parser)->value);\n+\t\t  set_init_label (c_parser_peek_token (parser)->value,\n+\t\t\t\t  braced_init_obstack);\n \t\t  c_parser_consume_token (parser);\n \t\t}\n \t      else\n@@ -3181,7 +3189,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  init.original_type = NULL;\n \t\t  c_parser_error (parser, \"expected identifier\");\n \t\t  c_parser_skip_until_found (parser, CPP_COMMA, NULL);\n-\t\t  process_init_element (init, false);\n+\t\t  process_init_element (init, false, braced_init_obstack);\n \t\t  return;\n \t\t}\n \t    }\n@@ -3262,7 +3270,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  /* Now parse and process the remainder of the\n \t\t     initializer, starting with this message\n \t\t     expression as a primary-expression.  */\n-\t\t  c_parser_initval (parser, &mexpr);\n+\t\t  c_parser_initval (parser, &mexpr, braced_init_obstack);\n \t\t  return;\n \t\t}\n \t      c_parser_consume_token (parser);\n@@ -3281,7 +3289,7 @@ c_parser_initelt (c_parser *parser)\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \t\t{\n \t\t  c_parser_consume_token (parser);\n-\t\t  set_init_index (first, second);\n+\t\t  set_init_index (first, second, braced_init_obstack);\n \t\t  if (second)\n \t\t    pedwarn (ellipsis_loc, OPT_pedantic,\n \t\t\t     \"ISO C forbids specifying range of elements to initialize\");\n@@ -3313,13 +3321,13 @@ c_parser_initelt (c_parser *parser)\n \t\t  init.original_type = NULL;\n \t\t  c_parser_error (parser, \"expected %<=%>\");\n \t\t  c_parser_skip_until_found (parser, CPP_COMMA, NULL);\n-\t\t  process_init_element (init, false);\n+\t\t  process_init_element (init, false, braced_init_obstack);\n \t\t  return;\n \t\t}\n \t    }\n \t}\n     }\n-  c_parser_initval (parser, NULL);\n+  c_parser_initval (parser, NULL, braced_init_obstack);\n }\n \n /* Parse a nested initializer; as c_parser_initializer but parses\n@@ -3329,7 +3337,8 @@ c_parser_initelt (c_parser *parser)\n    initializer.  */\n \n static void\n-c_parser_initval (c_parser *parser, struct c_expr *after)\n+c_parser_initval (c_parser *parser, struct c_expr *after,\n+\t\t  struct obstack * braced_init_obstack)\n {\n   struct c_expr init;\n   gcc_assert (!after || c_dialect_objc ());\n@@ -3344,7 +3353,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n \t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n \tinit = default_function_array_read_conversion (loc, init);\n     }\n-  process_init_element (init, false);\n+  process_init_element (init, false, braced_init_obstack);\n }\n \n /* Parse a compound statement (possibly a function body) (C90 6.6.2,"}, {"sha": "681fe9b4ffe15c46c61aa323ed083880c841bb2c", "filename": "gcc/c-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "patch": "@@ -539,11 +539,11 @@ extern void maybe_warn_string_init (tree, struct c_expr);\n extern void start_init (tree, tree, int);\n extern void finish_init (void);\n extern void really_start_incremental_init (tree);\n-extern void push_init_level (int);\n-extern struct c_expr pop_init_level (int);\n-extern void set_init_index (tree, tree);\n-extern void set_init_label (tree);\n-extern void process_init_element (struct c_expr, bool);\n+extern void push_init_level (int, struct obstack *);\n+extern struct c_expr pop_init_level (int, struct obstack *);\n+extern void set_init_index (tree, tree, struct obstack *);\n+extern void set_init_label (tree, struct obstack *);\n+extern void process_init_element (struct c_expr, bool, struct obstack *);\n extern tree build_compound_literal (location_t, tree, tree, bool);\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n extern tree c_start_case (location_t, location_t, tree);"}, {"sha": "df02975f9dc7f3d6a90195d0aba7ee7c3238cabf", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 97, "deletions": 64, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e3b3d9f0c61b729ad64db479f3dc4c641203ff/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=a1e3b3d9f0c61b729ad64db479f3dc4c641203ff", "patch": "@@ -97,14 +97,15 @@ static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (int, const char *);\n static tree digest_init (location_t, tree, tree, tree, bool, bool, int);\n-static void output_init_element (tree, tree, bool, tree, tree, int, bool);\n-static void output_pending_init_elements (int);\n-static int set_designator (int);\n-static void push_range_stack (tree);\n-static void add_pending_init (tree, tree, tree, bool);\n-static void set_nonincremental_init (void);\n-static void set_nonincremental_init_from_string (tree);\n-static tree find_init_member (tree);\n+static void output_init_element (tree, tree, bool, tree, tree, int, bool,\n+\t\t\t\t struct obstack *);\n+static void output_pending_init_elements (int, struct obstack *);\n+static int set_designator (int, struct obstack *);\n+static void push_range_stack (tree, struct obstack *);\n+static void add_pending_init (tree, tree, tree, bool, struct obstack *);\n+static void set_nonincremental_init (struct obstack *);\n+static void set_nonincremental_init_from_string (tree, struct obstack *);\n+static tree find_init_member (tree, struct obstack *);\n static void readonly_error (tree, enum lvalue_use);\n static void readonly_warning (tree, enum lvalue_use);\n static int lvalue_or_else (const_tree, enum lvalue_use);\n@@ -6433,7 +6434,7 @@ really_start_incremental_init (tree type)\n    IMPLICIT is 1 (or 2 if the push is because of designator list).  */\n \n void\n-push_init_level (int implicit)\n+push_init_level (int implicit, struct obstack * braced_init_obstack)\n {\n   struct constructor_stack *p;\n   tree value = NULL_TREE;\n@@ -6451,12 +6452,14 @@ push_init_level (int implicit)\n \t  if ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t       || TREE_CODE (constructor_type) == UNION_TYPE)\n \t      && constructor_fields == 0)\n-\t    process_init_element (pop_init_level (1), true);\n+\t    process_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t\t  true, braced_init_obstack);\n \t  else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t\t   && constructor_max_index\n \t\t   && tree_int_cst_lt (constructor_max_index,\n \t\t\t\t       constructor_index))\n-\t    process_init_element (pop_init_level (1), true);\n+\t    process_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t\t  true, braced_init_obstack);\n \t  else\n \t    break;\n \t}\n@@ -6469,9 +6472,9 @@ push_init_level (int implicit)\n       if ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t   || TREE_CODE (constructor_type) == UNION_TYPE)\n \t  && constructor_fields)\n-\tvalue = find_init_member (constructor_fields);\n+\tvalue = find_init_member (constructor_fields, braced_init_obstack);\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n-\tvalue = find_init_member (constructor_index);\n+\tvalue = find_init_member (constructor_index, braced_init_obstack);\n     }\n \n   p = XNEW (struct constructor_stack);\n@@ -6557,7 +6560,7 @@ push_init_level (int implicit)\n       if (!VEC_empty (constructor_elt, constructor_elements)\n \t  && (TREE_CODE (constructor_type) == RECORD_TYPE\n \t      || TREE_CODE (constructor_type) == ARRAY_TYPE))\n-\tset_nonincremental_init ();\n+\tset_nonincremental_init (braced_init_obstack);\n     }\n \n   if (implicit == 1 && warn_missing_braces && !missing_braces_mentioned)\n@@ -6618,7 +6621,7 @@ push_init_level (int implicit)\n \t  /* We need to split the char/wchar array into individual\n \t     characters, so that we don't have to special case it\n \t     everywhere.  */\n-\t  set_nonincremental_init_from_string (value);\n+\t  set_nonincremental_init_from_string (value, braced_init_obstack);\n \t}\n     }\n   else\n@@ -6642,7 +6645,7 @@ push_init_level (int implicit)\n    Otherwise, return a CONSTRUCTOR expression as the value.  */\n \n struct c_expr\n-pop_init_level (int implicit)\n+pop_init_level (int implicit, struct obstack * braced_init_obstack)\n {\n   struct constructor_stack *p;\n   struct c_expr ret;\n@@ -6655,14 +6658,16 @@ pop_init_level (int implicit)\n       /* When we come to an explicit close brace,\n \t pop any inner levels that didn't have explicit braces.  */\n       while (constructor_stack->implicit)\n-\tprocess_init_element (pop_init_level (1), true);\n-\n+\t{\n+\t  process_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t\ttrue, braced_init_obstack);\n+\t}\n       gcc_assert (!constructor_range_stack);\n     }\n \n   /* Now output all pending elements.  */\n   constructor_incremental = 1;\n-  output_pending_init_elements (1);\n+  output_pending_init_elements (1, braced_init_obstack);\n \n   p = constructor_stack;\n \n@@ -6803,7 +6808,7 @@ pop_init_level (int implicit)\n    ARRAY argument is nonzero for array ranges.  Returns zero for success.  */\n \n static int\n-set_designator (int array)\n+set_designator (int array, struct obstack * braced_init_obstack)\n {\n   tree subtype;\n   enum tree_code subcode;\n@@ -6825,7 +6830,10 @@ set_designator (int array)\n       /* Designator list starts at the level of closest explicit\n \t braces.  */\n       while (constructor_stack->implicit)\n-\tprocess_init_element (pop_init_level (1), true);\n+\t{\n+\t  process_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t\ttrue, braced_init_obstack);\n+\t}\n       constructor_designated = 1;\n       return 0;\n     }\n@@ -6858,7 +6866,7 @@ set_designator (int array)\n     }\n \n   constructor_designated = 1;\n-  push_init_level (2);\n+  push_init_level (2, braced_init_obstack);\n   return 0;\n }\n \n@@ -6867,11 +6875,13 @@ set_designator (int array)\n    NULL_TREE if there is no range designator at this level.  */\n \n static void\n-push_range_stack (tree range_end)\n+push_range_stack (tree range_end, struct obstack * braced_init_obstack)\n {\n   struct constructor_range_stack *p;\n \n-  p = GGC_NEW (struct constructor_range_stack);\n+  p = (struct constructor_range_stack *)\n+    obstack_alloc (braced_init_obstack,\n+\t\t   sizeof (struct constructor_range_stack));\n   p->prev = constructor_range_stack;\n   p->next = 0;\n   p->fields = constructor_fields;\n@@ -6889,9 +6899,10 @@ push_range_stack (tree range_end)\n    of indices, running from FIRST through LAST.  */\n \n void\n-set_init_index (tree first, tree last)\n+set_init_index (tree first, tree last,\n+\t\tstruct obstack * braced_init_obstack)\n {\n-  if (set_designator (1))\n+  if (set_designator (1, braced_init_obstack))\n     return;\n \n   designator_erroneous = 1;\n@@ -6963,18 +6974,18 @@ set_init_index (tree first, tree last)\n       designator_depth++;\n       designator_erroneous = 0;\n       if (constructor_range_stack || last)\n-\tpush_range_stack (last);\n+\tpush_range_stack (last, braced_init_obstack);\n     }\n }\n \n /* Within a struct initializer, specify the next field to be initialized.  */\n \n void\n-set_init_label (tree fieldname)\n+set_init_label (tree fieldname, struct obstack * braced_init_obstack)\n {\n   tree tail;\n \n-  if (set_designator (0))\n+  if (set_designator (0, braced_init_obstack))\n     return;\n \n   designator_erroneous = 1;\n@@ -7001,7 +7012,7 @@ set_init_label (tree fieldname)\n       designator_depth++;\n       designator_erroneous = 0;\n       if (constructor_range_stack)\n-\tpush_range_stack (NULL_TREE);\n+\tpush_range_stack (NULL_TREE, braced_init_obstack);\n     }\n }\n \f\n@@ -7016,7 +7027,8 @@ set_init_label (tree fieldname)\n    existing initializer.  */\n \n static void\n-add_pending_init (tree purpose, tree value, tree origtype, bool implicit)\n+add_pending_init (tree purpose, tree value, tree origtype, bool implicit,\n+\t\t  struct obstack * braced_init_obstack)\n {\n   struct init_node *p, **q, *r;\n \n@@ -7075,7 +7087,8 @@ add_pending_init (tree purpose, tree value, tree origtype, bool implicit)\n \t}\n     }\n \n-  r = GGC_NEW (struct init_node);\n+  r = (struct init_node *) obstack_alloc (braced_init_obstack,\n+\t\t\t\t\t  sizeof (struct init_node));\n   r->purpose = purpose;\n   r->value = value;\n   r->origtype = origtype;\n@@ -7244,7 +7257,7 @@ add_pending_init (tree purpose, tree value, tree origtype, bool implicit)\n /* Build AVL tree from a sorted chain.  */\n \n static void\n-set_nonincremental_init (void)\n+set_nonincremental_init (struct obstack * braced_init_obstack)\n {\n   unsigned HOST_WIDE_INT ix;\n   tree index, value;\n@@ -7254,7 +7267,10 @@ set_nonincremental_init (void)\n     return;\n \n   FOR_EACH_CONSTRUCTOR_ELT (constructor_elements, ix, index, value)\n-    add_pending_init (index, value, NULL_TREE, false);\n+    {\n+      add_pending_init (index, value, NULL_TREE, false,\n+\t\t\tbraced_init_obstack);\n+    }\n   constructor_elements = 0;\n   if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n@@ -7281,7 +7297,8 @@ set_nonincremental_init (void)\n /* Build AVL tree from a string constant.  */\n \n static void\n-set_nonincremental_init_from_string (tree str)\n+set_nonincremental_init_from_string (tree str,\n+\t\t\t\t     struct obstack * braced_init_obstack)\n {\n   tree value, purpose, type;\n   HOST_WIDE_INT val[2];\n@@ -7344,7 +7361,8 @@ set_nonincremental_init_from_string (tree str)\n \t}\n \n       value = build_int_cst_wide (type, val[1], val[0]);\n-      add_pending_init (purpose, value, NULL_TREE, false);\n+      add_pending_init (purpose, value, NULL_TREE, false,\n+                        braced_init_obstack);\n     }\n \n   constructor_incremental = 0;\n@@ -7354,15 +7372,15 @@ set_nonincremental_init_from_string (tree str)\n    not initialized yet.  */\n \n static tree\n-find_init_member (tree field)\n+find_init_member (tree field, struct obstack * braced_init_obstack)\n {\n   struct init_node *p;\n \n   if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n       if (constructor_incremental\n \t  && tree_int_cst_lt (field, constructor_unfilled_index))\n-\tset_nonincremental_init ();\n+\tset_nonincremental_init (braced_init_obstack);\n \n       p = constructor_pending_elts;\n       while (p)\n@@ -7383,7 +7401,7 @@ find_init_member (tree field)\n \t  && (!constructor_unfilled_fields\n \t      || tree_int_cst_lt (bitpos,\n \t\t\t\t  bit_position (constructor_unfilled_fields))))\n-\tset_nonincremental_init ();\n+\tset_nonincremental_init (braced_init_obstack);\n \n       p = constructor_pending_elts;\n       while (p)\n@@ -7427,7 +7445,8 @@ find_init_member (tree field)\n \n static void\n output_init_element (tree value, tree origtype, bool strict_string, tree type,\n-\t\t     tree field, int pending, bool implicit)\n+\t\t     tree field, int pending, bool implicit,\n+\t\t     struct obstack * braced_init_obstack)\n {\n   tree semantic_type = NULL_TREE;\n   constructor_elt *celt;\n@@ -7544,9 +7563,10 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n     {\n       if (constructor_incremental\n \t  && tree_int_cst_lt (field, constructor_unfilled_index))\n-\tset_nonincremental_init ();\n+\tset_nonincremental_init (braced_init_obstack);\n \n-      add_pending_init (field, value, origtype, implicit);\n+      add_pending_init (field, value, origtype, implicit,\n+\t\t\tbraced_init_obstack);\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == RECORD_TYPE\n@@ -7559,7 +7579,7 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n       if (constructor_incremental)\n \t{\n \t  if (!constructor_unfilled_fields)\n-\t    set_nonincremental_init ();\n+\t    set_nonincremental_init (braced_init_obstack);\n \t  else\n \t    {\n \t      tree bitpos, unfillpos;\n@@ -7568,11 +7588,12 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \t      unfillpos = bit_position (constructor_unfilled_fields);\n \n \t      if (tree_int_cst_lt (bitpos, unfillpos))\n-\t\tset_nonincremental_init ();\n+\t\tset_nonincremental_init (braced_init_obstack);\n \t    }\n \t}\n \n-      add_pending_init (field, value, origtype, implicit);\n+      add_pending_init (field, value, origtype, implicit,\n+\t\t\tbraced_init_obstack);\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE\n@@ -7621,7 +7642,7 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \n   /* Now output any pending elements which have become next.  */\n   if (pending)\n-    output_pending_init_elements (0);\n+    output_pending_init_elements (0, braced_init_obstack);\n }\n \n /* Output any pending elements which have become next.\n@@ -7634,9 +7655,8 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \n    If ALL is 1, we output space as necessary so that\n    we can output all the pending elements.  */\n-\n static void\n-output_pending_init_elements (int all)\n+output_pending_init_elements (int all, struct obstack * braced_init_obstack)\n {\n   struct init_node *elt = constructor_pending_elts;\n   tree next;\n@@ -7657,7 +7677,8 @@ output_pending_init_elements (int all)\n \t\t\t\t  constructor_unfilled_index))\n \t    output_init_element (elt->value, elt->origtype, true,\n \t\t\t\t TREE_TYPE (constructor_type),\n-\t\t\t\t constructor_unfilled_index, 0, false);\n+\t\t\t\t constructor_unfilled_index, 0, false,\n+\t\t\t\t braced_init_obstack);\n \t  else if (tree_int_cst_lt (constructor_unfilled_index,\n \t\t\t\t    elt->purpose))\n \t    {\n@@ -7711,7 +7732,8 @@ output_pending_init_elements (int all)\n \t      constructor_unfilled_fields = elt->purpose;\n \t      output_init_element (elt->value, elt->origtype, true,\n \t\t\t\t   TREE_TYPE (elt->purpose),\n-\t\t\t\t   elt->purpose, 0, false);\n+\t\t\t\t   elt->purpose, 0, false,\n+\t\t\t\t   braced_init_obstack);\n \t    }\n \t  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))\n \t    {\n@@ -7782,7 +7804,8 @@ output_pending_init_elements (int all)\n    existing initializer.  */\n \n void\n-process_init_element (struct c_expr value, bool implicit)\n+process_init_element (struct c_expr value, bool implicit,\n+\t\t      struct obstack * braced_init_obstack)\n {\n   tree orig_value = value.value;\n   int string_flag = orig_value != 0 && TREE_CODE (orig_value) == STRING_CST;\n@@ -7823,13 +7846,15 @@ process_init_element (struct c_expr value, bool implicit)\n       if ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t   || TREE_CODE (constructor_type) == UNION_TYPE)\n \t  && constructor_fields == 0)\n-\tprocess_init_element (pop_init_level (1), true);\n+\tprocess_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t      true, braced_init_obstack);\n       else if ((TREE_CODE (constructor_type) == ARRAY_TYPE\n \t        || TREE_CODE (constructor_type) == VECTOR_TYPE)\n \t       && (constructor_max_index == 0\n \t\t   || tree_int_cst_lt (constructor_max_index,\n \t\t\t\t       constructor_index)))\n-\tprocess_init_element (pop_init_level (1), true);\n+\tprocess_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t      true, braced_init_obstack);\n       else\n \tbreak;\n     }\n@@ -7899,7 +7924,7 @@ process_init_element (struct c_expr value, bool implicit)\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n \t\t       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))\n \t    {\n-\t      push_init_level (1);\n+\t      push_init_level (1, braced_init_obstack);\n \t      continue;\n \t    }\n \n@@ -7908,7 +7933,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t      push_member_name (constructor_fields);\n \t      output_init_element (value.value, value.original_type,\n \t\t\t\t   strict_string, fieldtype,\n-\t\t\t\t   constructor_fields, 1, implicit);\n+\t\t\t\t   constructor_fields, 1, implicit,\n+\t\t\t\t   braced_init_obstack);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -7990,7 +8016,7 @@ process_init_element (struct c_expr value, bool implicit)\n \t\t   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n \t\t       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))\n \t    {\n-\t      push_init_level (1);\n+\t      push_init_level (1, braced_init_obstack);\n \t      continue;\n \t    }\n \n@@ -7999,7 +8025,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t      push_member_name (constructor_fields);\n \t      output_init_element (value.value, value.original_type,\n \t\t\t\t   strict_string, fieldtype,\n-\t\t\t\t   constructor_fields, 1, implicit);\n+\t\t\t\t   constructor_fields, 1, implicit,\n+\t\t\t\t   braced_init_obstack);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \t  else\n@@ -8031,7 +8058,7 @@ process_init_element (struct c_expr value, bool implicit)\n \t\t   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n \t\t       || eltcode == UNION_TYPE || eltcode == VECTOR_TYPE))\n \t    {\n-\t      push_init_level (1);\n+\t      push_init_level (1, braced_init_obstack);\n \t      continue;\n \t    }\n \n@@ -8050,7 +8077,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t      push_array_bounds (tree_low_cst (constructor_index, 1));\n \t      output_init_element (value.value, value.original_type,\n \t\t\t\t   strict_string, elttype,\n-\t\t\t\t   constructor_index, 1, implicit);\n+\t\t\t\t   constructor_index, 1, implicit,\n+\t\t\t\t   braced_init_obstack);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n \n@@ -8084,7 +8112,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t\telttype = TYPE_MAIN_VARIANT (constructor_type);\n \t      output_init_element (value.value, value.original_type,\n \t\t\t\t   strict_string, elttype,\n-\t\t\t\t   constructor_index, 1, implicit);\n+\t\t\t\t   constructor_index, 1, implicit,\n+\t\t\t\t   braced_init_obstack);\n \t    }\n \n \t  constructor_index\n@@ -8112,7 +8141,8 @@ process_init_element (struct c_expr value, bool implicit)\n \t  if (value.value)\n \t    output_init_element (value.value, value.original_type,\n \t\t\t\t strict_string, constructor_type,\n-\t\t\t\t NULL_TREE, 1, implicit);\n+\t\t\t\t NULL_TREE, 1, implicit,\n+\t\t\t\t braced_init_obstack);\n \t  constructor_fields = 0;\n \t}\n \n@@ -8128,14 +8158,17 @@ process_init_element (struct c_expr value, bool implicit)\n \t  while (constructor_stack != range_stack->stack)\n \t    {\n \t      gcc_assert (constructor_stack->implicit);\n-\t      process_init_element (pop_init_level (1), true);\n+\t      process_init_element (pop_init_level (1,\n+\t\t\t\t\t\t    braced_init_obstack),\n+\t\t\t\t    true, braced_init_obstack);\n \t    }\n \t  for (p = range_stack;\n \t       !p->range_end || tree_int_cst_equal (p->index, p->range_end);\n \t       p = p->prev)\n \t    {\n \t      gcc_assert (constructor_stack->implicit);\n-\t      process_init_element (pop_init_level (1), true);\n+\t      process_init_element (pop_init_level (1, braced_init_obstack),\n+\t\t\t\t    true, braced_init_obstack);\n \t    }\n \n \t  p->index = size_binop_loc (input_location,\n@@ -8155,7 +8188,7 @@ process_init_element (struct c_expr value, bool implicit)\n \t      p = p->next;\n \t      if (!p)\n \t\tbreak;\n-\t      push_init_level (2);\n+\t      push_init_level (2, braced_init_obstack);\n \t      p->stack = constructor_stack;\n \t      if (p->range_end && tree_int_cst_equal (p->index, p->range_end))\n \t\tp->index = p->range_start;"}]}