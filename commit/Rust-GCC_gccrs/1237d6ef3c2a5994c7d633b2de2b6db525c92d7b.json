{"sha": "1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIzN2Q2ZWYzYzJhNTk5NGM3ZDYzM2IyZGUyYjZkYjUyNWM5MmQ3Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:24:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:24:08Z"}, "message": "[multiple changes]\n\n2010-10-11  Javier Miranda  <miranda@adacore.com>\n\n\t* debug.adb: Update comment.\n\n2010-10-11  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb (GNATCmd): Set Opt.Unchecked_Shared_Lib_Imports to True\n\tunconditionally as for \"gnat make\" the projects are not processed in\n\tthe GNAT driver.\n\n2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.ads, sem_ch10.adb (Load_Needed_Body): Add parameter to\n\tsuppress semantic analysis of the body when inlining, prior to\n\tverifying that the body does not have a with_clause on a descendant\n\tunit.\n\t* inline.adb (Analyze_Inlined_Bodies): Do not inline a body if it has a\n\twith_clause on a descendant. \n\t(Scope_In_Main_Unit): Simplify.\n\nFrom-SVN: r165298", "tree": {"sha": "cadb7f8e64b74dd68b8d3be233527091a162548c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cadb7f8e64b74dd68b8d3be233527091a162548c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/comments", "author": null, "committer": null, "parents": [{"sha": "3cae7f1412ac273c2794babccfb130c010cf84db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cae7f1412ac273c2794babccfb130c010cf84db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cae7f1412ac273c2794babccfb130c010cf84db"}], "stats": {"total": 225, "additions": 158, "deletions": 67}, "files": [{"sha": "cede220e98221e12c837b9b31295630d69e54bac", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "patch": "@@ -1,3 +1,23 @@\n+2010-10-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb: Update comment.\n+\n+2010-10-11  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb (GNATCmd): Set Opt.Unchecked_Shared_Lib_Imports to True\n+\tunconditionally as for \"gnat make\" the projects are not processed in\n+\tthe GNAT driver.\n+\n+2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.ads, sem_ch10.adb (Load_Needed_Body): Add parameter to\n+\tsuppress semantic analysis of the body when inlining, prior to\n+\tverifying that the body does not have a with_clause on a descendant\n+\tunit.\n+\t* inline.adb (Analyze_Inlined_Bodies): Do not inline a body if it has a\n+\twith_clause on a descendant. \n+\t(Scope_In_Main_Unit): Simplify.\n+\n 2010-10-11  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch6.adb, freeze.adb: Minor reformatting."}, {"sha": "a34caef11ab0adec3f7c6ad6ed24c7731e94ee30", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "patch": "@@ -531,7 +531,8 @@ package body Debug is\n    --       compiler has a bug -- these are the files that need to be included\n    --       in a bug report.\n \n-   --  d.o  documentation missing ???\n+   --  d.o  Generate listing showing the IL instructions generated by the .NET\n+   --       compiler for each subprogram.\n \n    --  d.r  Forces the flag OK_To_Reorder_Components to be set in all record\n    --       base types that have no discriminants."}, {"sha": "372c38b5473cc33fd120600b1f2b8777f867c3ab", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "patch": "@@ -1577,12 +1577,14 @@ begin\n            Program_Name (Command_List (The_Command).Unixcmd.all, \"gnat\");\n       end if;\n \n-      --  For all tools other than gnatmake, allow shared library projects to\n-      --  import projects that are not shared library projects.\n-\n-      if The_Command /= Make then\n-         Opt.Unchecked_Shared_Lib_Imports := True;\n-      end if;\n+      --  For the tools where the GNAT driver processes the project files,\n+      --  allow shared library projects to import projects that are not shared\n+      --  library projects, to avoid adding a switch for these tools. For the\n+      --  builder (gnatmake), if a shared library project imports a project\n+      --  that is not a shared library project and the appropriate switch is\n+      --  not specified, the invocation of gnatmake will fail.\n+\n+      Opt.Unchecked_Shared_Lib_Imports := True;\n \n       --  Locate the executable for the command\n "}, {"sha": "f7e2b305ffd8833443641ec76a325e6315f288bf", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 108, "deletions": 51, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "patch": "@@ -138,8 +138,7 @@ package body Inline is\n    -----------------------\n \n    function Scope_In_Main_Unit (Scop : Entity_Id) return Boolean;\n-   --  Return True if Scop is in the main unit or its spec, or in a\n-   --  parent of the main unit if it is a child unit.\n+   --  Return True if Scop is in the main unit or its spec\n \n    procedure Add_Call (Called : Entity_Id; Caller : Entity_Id := Empty);\n    --  Make two entries in Inlined table, for an inlined subprogram being\n@@ -338,7 +337,6 @@ package body Inline is\n \n             elsif not Is_Inlined (Pack)\n               and then not Has_Completion (E)\n-              and then not Scope_In_Main_Unit (Pack)\n             then\n                Set_Is_Inlined (Pack);\n                Inlined_Bodies.Increment_Last;\n@@ -354,6 +352,7 @@ package body Inline is\n \n    procedure Add_Inlined_Subprogram (Index : Subp_Index) is\n       E    : constant Entity_Id := Inlined.Table (Index).Name;\n+      Pack : constant Entity_Id := Cunit_Entity (Get_Code_Unit (E));\n       Succ : Succ_Index;\n       Subp : Subp_Index;\n \n@@ -473,10 +472,12 @@ package body Inline is\n    --  Start of processing for Add_Inlined_Subprogram\n \n    begin\n-      --  Insert the current subprogram in the list of inlined subprograms,\n-      --  if it can actually be inlined by the back-end.\n+      --  Insert the current subprogram in the list of inlined subprograms, if\n+      --  it can actually be inlined by the back-end, and if its unit is known\n+      --  to be inlined, or is an instance whose body will be analyzed anyway.\n \n-      if not Scope_In_Main_Unit (E)\n+      if (Is_Inlined (Pack) or else Is_Generic_Instance (Pack))\n+        and then not Scope_In_Main_Unit (E)\n         and then Is_Inlined (E)\n         and then not Is_Nested (E)\n         and then not Has_Initialized_Type (E)\n@@ -625,6 +626,53 @@ package body Inline is\n       Pack      : Entity_Id;\n       S         : Succ_Index;\n \n+      function Is_Ancestor\n+        (U_Name : Entity_Id;\n+         Nam    : Node_Id) return Boolean;\n+      --  Determine whether the unit whose body is loaded is an ancestor of\n+      --  a unit mentioned in a with_clause of that body. The body is not\n+      --  analyzed yet, so the check is purely lexical: the name of the with\n+      --  clause is a selected component, and names of ancestors must match.\n+\n+      -----------------\n+      -- Is_Ancestor --\n+      -----------------\n+\n+      function Is_Ancestor\n+        (U_Name : Entity_Id;\n+         Nam    : Node_Id) return Boolean\n+      is\n+         Pref : Node_Id;\n+\n+      begin\n+         if Nkind (Nam) /= N_Selected_Component then\n+            return False;\n+\n+         else\n+            Pref := Prefix (Nam);\n+            if Nkind (Pref) = N_Identifier then\n+\n+               --  Par is an ancestor of Par.Child.\n+\n+               return Chars (Pref) = Chars (U_Name);\n+\n+            elsif Nkind (Pref) = N_Selected_Component\n+              and then Chars (Selector_Name (Pref)) = Chars (U_Name)\n+            then\n+               --  Par.Child is an ancestor of Par.Child.Grand.\n+\n+               return True;   --  should check that ancestor match\n+\n+            else\n+               --  A is an ancestor of A.B.C if it is an ancestor of A.B\n+\n+               return Is_Ancestor (U_Name, Pref);\n+            end if;\n+         end if;\n+      end Is_Ancestor;\n+\n+   --  Start of processing for  Analyze_Inlined_Bodies\n+\n    begin\n       Analyzing_Inlined_Bodies := False;\n \n@@ -650,8 +698,8 @@ package body Inline is\n                Comp_Unit := Parent (Comp_Unit);\n             end loop;\n \n-            --  Load the body, unless it the main unit, or is an instance\n-            --  whose body has already been analyzed.\n+            --  Load the body, unless it the main unit, or is an instance whose\n+            --  body has already been analyzed.\n \n             if Present (Comp_Unit)\n               and then Comp_Unit /= Cunit (Main_Unit)\n@@ -667,7 +715,8 @@ package body Inline is\n \n                begin\n                   if not Is_Loaded (Bname) then\n-                     Load_Needed_Body (Comp_Unit, OK);\n+                     Style_Check := False;\n+                     Load_Needed_Body (Comp_Unit, OK, Do_Analyze => False);\n \n                      if not OK then\n \n@@ -681,6 +730,42 @@ package body Inline is\n                         Error_Msg_File_1 :=\n                           Get_File_Name (Bname, Subunit => False);\n                         Error_Msg_N (\"\\but file{ was not found!?\", Comp_Unit);\n+\n+                     else\n+                        --  If the package to be inlined is an ancestor unit of\n+                        --  the main unit, and it has a semantic dependence on\n+                        --  it, the inlining cannot take place to prevent an\n+                        --  elaboration circularity. The desired body is not\n+                        --  analyzed yet, to prevent the completion of Taft\n+                        --  amendment types that would lead to elaboration\n+                        --  circularities in gigi.\n+\n+                        declare\n+                           U_Id      : constant Entity_Id :=\n+                                         Defining_Entity (Unit (Comp_Unit));\n+                           Body_Unit : constant Node_Id :=\n+                                         Library_Unit (Comp_Unit);\n+                           Item      : Node_Id;\n+\n+                        begin\n+                           Item := First (Context_Items (Body_Unit));\n+                           while Present (Item) loop\n+                              if Nkind (Item) = N_With_Clause\n+                                and then Is_Ancestor (U_Id, Name (Item))\n+                              then\n+                                 Set_Is_Inlined (U_Id, False);\n+                                 exit;\n+                              end if;\n+\n+                              Next (Item);\n+                           end loop;\n+\n+                           --  If no suspicious with_clauses, analyze the body.\n+\n+                           if Is_Inlined (U_Id) then\n+                              Semantics (Body_Unit);\n+                           end if;\n+                        end;\n                      end if;\n                   end if;\n                end;\n@@ -697,14 +782,14 @@ package body Inline is\n \n          Instantiate_Bodies;\n \n-         --  The list of inlined subprograms is an overestimate, because\n-         --  it includes inlined functions called from functions that are\n-         --  compiled as part of an inlined package, but are not themselves\n-         --  called. An accurate computation of just those subprograms that\n-         --  are needed requires that we perform a transitive closure over\n-         --  the call graph, starting from calls in the main program. Here\n-         --  we do one step of the inverse transitive closure, and reset\n-         --  the Is_Called flag on subprograms all of whose callers are not.\n+         --  The list of inlined subprograms is an overestimate, because it\n+         --  includes inlined functions called from functions that are compiled\n+         --  as part of an inlined package, but are not themselves called. An\n+         --  accurate computation of just those subprograms that are needed\n+         --  requires that we perform a transitive closure over the call graph,\n+         --  starting from calls in the main program. Here we do one step of\n+         --  the inverse transitive closure, and reset the Is_Called flag on\n+         --  subprograms all of whose callers are not.\n \n          for Index in Inlined.First .. Inlined.Last loop\n             S := Inlined.Table (Index).First_Succ;\n@@ -1124,42 +1209,14 @@ package body Inline is\n    ------------------------\n \n    function Scope_In_Main_Unit (Scop : Entity_Id) return Boolean is\n-      Comp : Node_Id;\n-      S    : Entity_Id;\n-      Ent  : Entity_Id := Cunit_Entity (Main_Unit);\n+      Comp : constant Node_Id := Cunit (Get_Code_Unit (Scop));\n \n    begin\n-      --  The scope may be within the main unit, or it may be an ancestor\n-      --  of the main unit, if the main unit is a child unit. In both cases\n-      --  it makes no sense to process the body before the main unit. In\n-      --  the second case, this may lead to circularities if a parent body\n-      --  depends on a child spec, and we are analyzing the child.\n-\n-      S := Scop;\n-      while Scope (S) /= Standard_Standard\n-        and then not Is_Child_Unit (S)\n-      loop\n-         S := Scope (S);\n-      end loop;\n-\n-      Comp := Parent (S);\n-      while Present (Comp)\n-        and then Nkind (Comp) /= N_Compilation_Unit\n-      loop\n-         Comp := Parent (Comp);\n-      end loop;\n-\n-      if Is_Child_Unit (Ent) then\n-         while Present (Ent)\n-           and then Is_Child_Unit (Ent)\n-         loop\n-            if Scope (Ent) = S then\n-               return True;\n-            end if;\n-\n-            Ent := Scope (Ent);\n-         end loop;\n-      end if;\n+      --  Check whether the scope of the subprogram to inline is within the\n+      --  main unit or within its spec. In either case there are no additional\n+      --  bodies to process. If the subprogram appears in a parent of the\n+      --  current unit, the check on whether inlining is possible is done in\n+      --  Analyze_Inlined_Bodies.\n \n       return\n         Comp = Cunit (Main_Unit)"}, {"sha": "7c8a2ea048cb42b1a959b98ac80dd3f478ebab12", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "patch": "@@ -5178,7 +5178,11 @@ package body Sem_Ch10 is\n    --  If the unit is not generic, but contains a generic unit, it is loaded on\n    --  demand, at the point of instantiation (see ch12).\n \n-   procedure Load_Needed_Body (N : Node_Id; OK : out Boolean) is\n+   procedure Load_Needed_Body\n+     (N          : Node_Id;\n+      OK         : out Boolean;\n+      Do_Analyze : Boolean := True)\n+   is\n       Body_Name : Unit_Name_Type;\n       Unum      : Unit_Number_Type;\n \n@@ -5211,7 +5215,9 @@ package body Sem_Ch10 is\n                Write_Eol;\n             end if;\n \n-            Semantics (Cunit (Unum));\n+            if Do_Analyze then\n+               Semantics (Cunit (Unum));\n+            end if;\n          end if;\n \n          OK := True;"}, {"sha": "6eb7fab5cd38800a34441169d56c6c659e547678", "filename": "gcc/ada/sem_ch10.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fsem_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b/gcc%2Fada%2Fsem_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.ads?ref=1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,11 +63,16 @@ package Sem_Ch10 is\n    --  rule imposes extra steps in order to install/remove the private_with\n    --  clauses of an enclosing unit.\n \n-   procedure Load_Needed_Body (N : Node_Id; OK : out Boolean);\n-   --  Load and analyze the body of a context unit that is generic, or\n-   --  that contains generic units or inlined units. The body becomes\n-   --  part of the semantic dependency set of the unit that needs it.\n-   --  The returned result in OK is True if the load is successful,\n-   --  and False if the requested file cannot be found.\n+   procedure Load_Needed_Body\n+     (N          : Node_Id;\n+      OK         : out Boolean;\n+      Do_Analyze : Boolean := True);\n+   --  Load and analyze the body of a context unit that is generic, or that\n+   --  contains generic units or inlined units. The body becomes part of the\n+   --  semantic dependency set of the unit that needs it. The returned result\n+   --  in OK is True if the load is successful, and False if the requested file\n+   --  cannot be found. If the flag Do_Analyze is false, the unit is loaded and\n+   --  parsed only. This allows a selective analysis in some inlining cases\n+   --  where a full analysis would lead so circularities in the back-end.\n \n end Sem_Ch10;"}]}