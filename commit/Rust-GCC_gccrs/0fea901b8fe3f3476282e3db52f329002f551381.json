{"sha": "0fea901b8fe3f3476282e3db52f329002f551381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZlYTkwMWI4ZmUzZjM0NzYyODJlM2RiNTJmMzI5MDAyZjU1MTM4MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:13:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:13:04Z"}, "message": "[multiple changes]\n\n2014-08-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch5.adb: Minor reformatting.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Late_Freeze_Subprogram): Following AI05-151,\n\ta function can return a limited view of a type declared\n\telsewhere. In that case the function cannot be frozen at the end\n\tof its enclosing package. If its first use is in a different unit,\n\tit cannot be frozen there, but if the call is legal the full view\n\tof the return type is available and the subprogram can now be\n\tfrozen. However the freeze node cannot be inserted at the point\n\tof call, but rather must go in the package holding the function,\n\tso that the backend can process it in the proper context.\n\nFrom-SVN: r213562", "tree": {"sha": "0cbbc100e132aa2a0f288573f50ae517520872b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cbbc100e132aa2a0f288573f50ae517520872b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fea901b8fe3f3476282e3db52f329002f551381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fea901b8fe3f3476282e3db52f329002f551381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fea901b8fe3f3476282e3db52f329002f551381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fea901b8fe3f3476282e3db52f329002f551381/comments", "author": null, "committer": null, "parents": [{"sha": "11261647740b1ae87c271c47c5849f62628f6a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11261647740b1ae87c271c47c5849f62628f6a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11261647740b1ae87c271c47c5849f62628f6a91"}], "stats": {"total": 114, "additions": 90, "deletions": 24}, "files": [{"sha": "5ca6f568e163cf2df74964d94c364228b0e32cc1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fea901b8fe3f3476282e3db52f329002f551381/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fea901b8fe3f3476282e3db52f329002f551381/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0fea901b8fe3f3476282e3db52f329002f551381", "patch": "@@ -1,3 +1,19 @@\n+2014-08-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch5.adb: Minor reformatting.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Late_Freeze_Subprogram): Following AI05-151,\n+\ta function can return a limited view of a type declared\n+\telsewhere. In that case the function cannot be frozen at the end\n+\tof its enclosing package. If its first use is in a different unit,\n+\tit cannot be frozen there, but if the call is legal the full view\n+\tof the return type is available and the subprogram can now be\n+\tfrozen. However the freeze node cannot be inserted at the point\n+\tof call, but rather must go in the package holding the function,\n+\tso that the backend can process it in the proper context.\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb, sem_ch5.adb, einfo.ads: Minor reformatting."}, {"sha": "677fb42259b4c7df11bf40dc861fe4ca02ed27e8", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fea901b8fe3f3476282e3db52f329002f551381/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fea901b8fe3f3476282e3db52f329002f551381/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0fea901b8fe3f3476282e3db52f329002f551381", "patch": "@@ -1815,13 +1815,18 @@ package body Freeze is\n    -------------------\n \n    function Freeze_Entity (E : Entity_Id; N : Node_Id) return List_Id is\n-      Loc    : constant Source_Ptr := Sloc (N);\n+      Loc           : constant Source_Ptr := Sloc (N);\n+      Comp          : Entity_Id;\n+      F_Node        : Node_Id;\n+      Indx          : Node_Id;\n+      Formal        : Entity_Id;\n+      Atype         : Entity_Id;\n+\n       Test_E : Entity_Id := E;\n-      Comp   : Entity_Id;\n-      F_Node : Node_Id;\n-      Indx   : Node_Id;\n-      Formal : Entity_Id;\n-      Atype  : Entity_Id;\n+      --  This could use a comment ???\n+\n+      Late_Freezing : Boolean := False;\n+      --  Used to detect attempt to freeze function declared in another unit\n \n       Result : List_Id := No_List;\n       --  List of freezing actions, left at No_List if none\n@@ -1861,6 +1866,16 @@ package body Freeze is\n       --  Determine whether an arbitrary entity is subject to Boolean aspect\n       --  Import and its value is specified as True.\n \n+      procedure Late_Freeze_Subprogram (E : Entity_Id);\n+      --  Following AI05-151, a function can return a limited view of a type\n+      --  declared elsewhere. In that case the function cannot be frozen at\n+      --  the end of its enclosing package. If its first use is in a different\n+      --  unit, it cannot be frozen there, but if the call is legal the full\n+      --  view of the return type is available and the subprogram can now be\n+      --  frozen. However the freeze node cannot be inserted at the point of\n+      --  call, but rather must go in the package holding the function, so that\n+      --  the backend can process it in the proper context.\n+\n       procedure Wrap_Imported_Subprogram (E : Entity_Id);\n       --  If E is an entity for an imported subprogram with pre/post-conditions\n       --  then this procedure will create a wrapper to ensure that proper run-\n@@ -1885,6 +1900,7 @@ package body Freeze is\n \n       function After_Last_Declaration return Boolean is\n          Spec : constant Node_Id := Parent (Current_Scope);\n+\n       begin\n          if Nkind (Spec) = N_Package_Specification then\n             if Present (Private_Declarations (Spec)) then\n@@ -1894,6 +1910,7 @@ package body Freeze is\n             else\n                return False;\n             end if;\n+\n          else\n             return False;\n          end if;\n@@ -2013,8 +2030,7 @@ package body Freeze is\n                      else\n                         Error_Msg_N\n                           (\"current instance must be an immutably limited \"\n-                           & \"type (RM-2012, 7.5 (8.1/3))\",\n-                           Prefix (N));\n+                           & \"type (RM-2012, 7.5 (8.1/3))\", Prefix (N));\n                      end if;\n \n                      return Abandon;\n@@ -2182,8 +2198,7 @@ package body Freeze is\n                      Error_Msg_Name_1 := CN;\n                      Error_Msg_Sloc := Sloc (Arr);\n                      Error_Msg_N\n-                       (\"pragma Pack affects convention % components #??\",\n-                        PP);\n+                       (\"pragma Pack affects convention % components #??\", PP);\n                      Error_Msg_Name_1 := CN;\n                      Error_Msg_N\n                        (\"\\array components may not have % compatible \"\n@@ -2260,6 +2275,7 @@ package body Freeze is\n                      Comp_Size_C : constant Node_Id :=\n                                      Get_Attribute_Definition_Clause\n                                        (Ent, Attribute_Component_Size);\n+\n                   begin\n                      --  Warn if we have pack and component size so that the\n                      --  pack is ignored.\n@@ -2305,11 +2321,11 @@ package body Freeze is\n \n                         if Present (Pack_Pragma) then\n                            Error_Msg_N\n-                             (\"??pragma Pack causes component size \"\n-                              & \"to be ^!\", Pack_Pragma);\n+                             (\"??pragma Pack causes component size to be ^!\",\n+                              Pack_Pragma);\n                            Error_Msg_N\n-                             (\"\\??use Component_Size to set \"\n-                              & \"desired value!\", Pack_Pragma);\n+                             (\"\\??use Component_Size to set desired value!\",\n+                              Pack_Pragma);\n                         end if;\n                      end if;\n \n@@ -2531,8 +2547,7 @@ package body Freeze is\n \n                      Ilen :=\n                        Make_Attribute_Reference (Loc,\n-                         Prefix         =>\n-                           New_Occurrence_Of (Ityp, Loc),\n+                         Prefix         => New_Occurrence_Of (Ityp, Loc),\n                          Attribute_Name => Name_Range_Length);\n                      Analyze_And_Resolve (Ilen);\n \n@@ -2562,10 +2577,8 @@ package body Freeze is\n \n             if Known_RM_Size (Arr) then\n                declare\n-                  SizC : constant Node_Id := Size_Clause (Arr);\n-\n+                  SizC    : constant Node_Id := Size_Clause (Arr);\n                   Discard : Boolean;\n-                  pragma Warnings (Off, Discard);\n \n                begin\n                   --  It is not clear if it is possible to have no size clause\n@@ -3060,6 +3073,7 @@ package body Freeze is\n \n                   if Will_Be_Frozen then\n                      Undelay_Type (Comp);\n+\n                   else\n                      if Present (Prev) then\n                         Set_Next_Entity (Prev, Next_Entity (Comp));\n@@ -3107,8 +3121,8 @@ package body Freeze is\n                         if Is_Entity_Name (Expression (Alloc)) then\n                            Freeze_And_Append\n                              (Entity (Expression (Alloc)), N, Result);\n-                        elsif\n-                          Nkind (Expression (Alloc)) = N_Subtype_Indication\n+\n+                        elsif Nkind (Expression (Alloc)) = N_Subtype_Indication\n                         then\n                            Freeze_And_Append\n                             (Entity (Subtype_Mark (Expression (Alloc))),\n@@ -3633,6 +3647,25 @@ package body Freeze is\n          return False;\n       end Has_Boolean_Aspect_Import;\n \n+      ----------------------------\n+      -- Late_Freeze_Subprogram --\n+      ----------------------------\n+\n+      procedure Late_Freeze_Subprogram (E : Entity_Id) is\n+         Spec  : constant Node_Id :=\n+                   Specification (Unit_Declaration_Node (Scope (E)));\n+         Decls : List_Id;\n+\n+      begin\n+         if Present (Private_Declarations (Spec)) then\n+            Decls := Private_Declarations (Spec);\n+         else\n+            Decls := Visible_Declarations (Spec);\n+         end if;\n+\n+         Append_List (Result, Decls);\n+      end Late_Freeze_Subprogram;\n+\n       ------------------------------\n       -- Wrap_Imported_Subprogram --\n       ------------------------------\n@@ -4165,6 +4198,16 @@ package body Freeze is\n \n                   if Ekind (E) = E_Function then\n \n+                     --  Check whether function is declared elsewhere.\n+\n+                     Late_Freezing :=\n+                       Get_Source_Unit (E) /= Get_Source_Unit (N)\n+                         and then Expander_Active\n+                         and then Ekind (Scope (E)) = E_Package\n+                         and then Nkind (Unit_Declaration_Node (Scope (E)))\n+                           = N_Package_Declaration\n+                         and then not In_Open_Scopes (Scope (E));\n+\n                      --  Freeze return type\n \n                      R_Type := Etype (E);\n@@ -4325,6 +4368,11 @@ package body Freeze is\n                Freeze_Subprogram (E);\n             end if;\n \n+            if Late_Freezing then\n+               Late_Freeze_Subprogram (E);\n+               return No_List;\n+            end if;\n+\n             --  If warning on suspicious contracts then check for the case of\n             --  a postcondition other than False for a No_Return subprogram.\n "}, {"sha": "b80efcec70495f9d1cf4789f78dfd2b3bc3e0876", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fea901b8fe3f3476282e3db52f329002f551381/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fea901b8fe3f3476282e3db52f329002f551381/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=0fea901b8fe3f3476282e3db52f329002f551381", "patch": "@@ -2204,17 +2204,19 @@ package body Sem_Ch5 is\n \n       procedure Check_Predicate_Use (T : Entity_Id) is\n       begin\n-\n          --  A predicated subtype is illegal in loops and related constructs\n-         --  if the predicate is not static, or else if it is a non-static\n-         --  subtype of a statically predicated subtype.\n+         --  if the predicate is not static, or if it is a non-static subtype\n+         --  of a statically predicated subtype.\n \n          if Is_Discrete_Type (T)\n            and then Has_Predicates (T)\n            and then (not Has_Static_Predicate (T)\n                       or else not Is_Static_Subtype (T)\n                       or else Has_Dynamic_Predicate_Aspect (T))\n          then\n+            --  Seems a confusing message for the case of a static predicate\n+            --  with a non-static subtype???\n+\n             Bad_Predicated_Subtype_Use\n               (\"cannot use subtype& with non-static predicate for loop \"\n                & \"iteration\", Discrete_Subtype_Definition (N),"}]}