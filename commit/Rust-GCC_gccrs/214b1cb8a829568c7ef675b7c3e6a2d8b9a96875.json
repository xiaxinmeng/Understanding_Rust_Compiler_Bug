{"sha": "214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "node_id": "C_kwDOANBUbNoAKDIxNGIxY2I4YTgyOTU2OGM3ZWY2NzViN2MzZTZhMmQ4YjlhOTY4NzU", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-05-19T19:07:07Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-07T08:36:33Z"}, "message": "ada: Deconstruct Safe_To_Capture_In_Parameter_Value\n\nRecently routine Safe_To_Capture_Value was adapted, so that various data\nproperties like validity/nullness/values are tracked also for\nin-parameters. Now a similar routine Safe_To_Capture_In_Parameter_Value,\nwhich was only used to track data nullness, is redundant, so this patch\ndeconstructs it.\n\nAlso the removed routine had at least few problems and limitations, for\nexample:\n\n1) it only worked for functions and procedures, but not for protected\nentries and task types (whose discriminants work very much like\nin-parameters)\n\n2) it only worked for subprogram bodies with no spec, because of this\ndubious check (here simplified):\n\n   if Nkind (Parent (Parent (Current_Scope))) /= N_Subprogram_Body then\n       return False;\n\n3) it only recognized references within short-circuit operators as\ncertainly evaluated if they were directly their left hand expression,\ne.g.:\n\n   X.all and then ...\n\nbut not when they were certainly evaluated as part of a bigger\nexpression on the left hand side, e.g.:\n\n   (X.all > 0) and then ...\n\n4) it categorizes parameters with 'Unrestricted_Access attribute as safe\nto capture, which is not necessarily wrong, but risky (because the\nobject becomes aliased).\n\nRoutine Safe_To_Capture_Value, which is kept by this patch, seems to\nbehave better in all those situations, though it has its own problems as\nwell and ideally should be further scrutinized.\n\ngcc/ada/\n\n\t* checks.adb (Safe_To_Capture_In_Parameter_Value): Remove.\n\t* sem_util.adb (Safe_To_Capture_Value): Stop search at the current\n\tbody.", "tree": {"sha": "2281e20fb9740e301666829d91a691a3392587e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2281e20fb9740e301666829d91a691a3392587e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb513a0d0f5e88b65abbab304692622f40641694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb513a0d0f5e88b65abbab304692622f40641694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb513a0d0f5e88b65abbab304692622f40641694"}], "stats": {"total": 125, "additions": 7, "deletions": 118}, "files": [{"sha": "96876672871520d13b16fec1a9f2b5b0e58c4b95", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 3, "deletions": 117, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "patch": "@@ -8408,115 +8408,10 @@ package body Checks is\n       Loc : constant Source_Ptr := Sloc (Parent (N));\n       Typ : constant Entity_Id  := Etype (N);\n \n-      function Safe_To_Capture_In_Parameter_Value return Boolean;\n-      --  Determines if it is safe to capture Known_Non_Null status for an\n-      --  the entity referenced by node N. The caller ensures that N is indeed\n-      --  an entity name. It is safe to capture the non-null status for an IN\n-      --  parameter when the reference occurs within a declaration that is sure\n-      --  to be executed as part of the declarative region.\n-\n       procedure Mark_Non_Null;\n       --  After installation of check, if the node in question is an entity\n       --  name, then mark this entity as non-null if possible.\n \n-      function Safe_To_Capture_In_Parameter_Value return Boolean is\n-         E     : constant Entity_Id := Entity (N);\n-         S     : constant Entity_Id := Current_Scope;\n-         S_Par : Node_Id;\n-\n-      begin\n-         if Ekind (E) /= E_In_Parameter then\n-            return False;\n-         end if;\n-\n-         --  Two initial context checks. We must be inside a subprogram body\n-         --  with declarations and reference must not appear in nested scopes.\n-\n-         if (Ekind (S) /= E_Function and then Ekind (S) /= E_Procedure)\n-           or else Scope (E) /= S\n-         then\n-            return False;\n-         end if;\n-\n-         S_Par := Parent (Parent (S));\n-\n-         if Nkind (S_Par) /= N_Subprogram_Body\n-           or else No (Declarations (S_Par))\n-         then\n-            return False;\n-         end if;\n-\n-         declare\n-            N_Decl : Node_Id;\n-            P      : Node_Id;\n-\n-         begin\n-            --  Retrieve the declaration node of N (if any). Note that N\n-            --  may be a part of a complex initialization expression.\n-\n-            P := Parent (N);\n-            N_Decl := Empty;\n-            while Present (P) loop\n-\n-               --  If we have a short circuit form, and we are within the right\n-               --  hand expression, we return false, since the right hand side\n-               --  is not guaranteed to be elaborated.\n-\n-               if Nkind (P) in N_Short_Circuit\n-                 and then N = Right_Opnd (P)\n-               then\n-                  return False;\n-               end if;\n-\n-               --  Similarly, if we are in an if expression and not part of the\n-               --  condition, then we return False, since neither the THEN or\n-               --  ELSE dependent expressions will always be elaborated.\n-\n-               if Nkind (P) = N_If_Expression\n-                 and then N /= First (Expressions (P))\n-               then\n-                  return False;\n-               end if;\n-\n-               --  If within a case expression, and not part of the expression,\n-               --  then return False, since a particular dependent expression\n-               --  may not always be elaborated\n-\n-               if Nkind (P) = N_Case_Expression\n-                 and then N /= Expression (P)\n-               then\n-                  return False;\n-               end if;\n-\n-               --  While traversing the parent chain, if node N belongs to a\n-               --  statement, then it may never appear in a declarative region.\n-\n-               if Nkind (P) in N_Statement_Other_Than_Procedure_Call\n-                 or else Nkind (P) = N_Procedure_Call_Statement\n-               then\n-                  return False;\n-               end if;\n-\n-               --  If we are at a declaration, record it and exit\n-\n-               if Nkind (P) in N_Declaration\n-                 and then Nkind (P) not in N_Subprogram_Specification\n-               then\n-                  N_Decl := P;\n-                  exit;\n-               end if;\n-\n-               P := Parent (P);\n-            end loop;\n-\n-            if No (N_Decl) then\n-               return False;\n-            end if;\n-\n-            return List_Containing (N_Decl) = Declarations (S_Par);\n-         end;\n-      end Safe_To_Capture_In_Parameter_Value;\n-\n       -------------------\n       -- Mark_Non_Null --\n       -------------------\n@@ -8532,19 +8427,10 @@ package body Checks is\n \n             Set_Is_Known_Null (Entity (N), False);\n \n-            --  We can mark the entity as known to be non-null if either it is\n-            --  safe to capture the value, or in the case of an IN parameter,\n-            --  which is a constant, if the check we just installed is in the\n-            --  declarative region of the subprogram body. In this latter case,\n-            --  a check is decisive for the rest of the body if the expression\n-            --  is sure to be elaborated, since we know we have to elaborate\n-            --  all declarations before executing the body.\n-\n-            --  Couldn't this always be part of Safe_To_Capture_Value ???\n+            --  We can mark the entity as known to be non-null if it is safe to\n+            --  capture the value.\n \n-            if Safe_To_Capture_Value (N, Entity (N))\n-              or else Safe_To_Capture_In_Parameter_Value\n-            then\n+            if Safe_To_Capture_Value (N, Entity (N)) then\n                Set_Is_Known_Non_Null (Entity (N));\n             end if;\n          end if;"}, {"sha": "c00490cf55ec4882a0270fefc35dec75ce818db1", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "patch": "@@ -27912,7 +27912,10 @@ package body Sem_Util is\n \n          P := Parent (N);\n          while Present (P) loop\n-            if         Nkind (P) = N_If_Statement\n+            if Is_Body (P) then\n+               return True;\n+\n+            elsif      Nkind (P) = N_If_Statement\n               or else  Nkind (P) = N_Case_Statement\n               or else (Nkind (P) in N_Short_Circuit\n                         and then Desc = Right_Opnd (P))"}]}