{"sha": "599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5YjA0YWE3ZDkyOGEzMDUwMjlkOGU4Y2Y1ZDZmNWM1YTY4M2RhOA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-05T16:49:26Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-06T15:17:08Z"}, "message": "This adds support for basic BlockExpressions\n\nWe keep temporary's for each block in order for the result to be\nreferenced. For example:\n\n  let x = { test() + 1 };\n\nThis can be resolved into:\n\n  {\n    let x:i32;\n\n    _tmp1:i32;\n    {\n      _tmp2:i32 = test();\n      _tmp1 = _tmp2 + 1;\n    }\n\n    x = _tmp1;\n  }\n\nFixes #189", "tree": {"sha": "d4d464c29ebab1df3ddaa8d9a39383a56e0f1dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4d464c29ebab1df3ddaa8d9a39383a56e0f1dce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4be77f7e0f6b35c019940200f94c7a7b30fff84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4be77f7e0f6b35c019940200f94c7a7b30fff84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4be77f7e0f6b35c019940200f94c7a7b30fff84"}], "stats": {"total": 353, "additions": 236, "deletions": 117}, "files": [{"sha": "ec7c13af95919ea5ef59d15f3ded141846000663", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -237,9 +237,13 @@ class HIRCompileBase : public HIR::HIRVisitor\n protected:\n   HIRCompileBase (Context *ctx) : ctx (ctx) {}\n \n+  Context *ctx;\n+\n   Context *get_context () { return ctx; }\n \n-  Context *ctx;\n+  void compile_function_body (Bfunction *fndecl,\n+\t\t\t      std::unique_ptr<HIR::BlockExpr> &function_body,\n+\t\t\t      bool has_return_type);\n };\n \n } // namespace Compile"}, {"sha": "879e32d0c24bcaedbf259fb585345c1aa4b4de71", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -28,82 +28,83 @@ namespace Compile {\n class CompileBlock : public HIRCompileBase\n {\n public:\n-  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx)\n+  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n   {\n-    CompileBlock compiler (ctx);\n+    CompileBlock compiler (ctx, result);\n     expr->accept_vis (compiler);\n     return compiler.translated;\n   }\n \n-  ~CompileBlock () {}\n-\n   void visit (HIR::BlockExpr &expr);\n \n private:\n-  CompileBlock (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+  CompileBlock (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n+  {}\n \n   Bblock *translated;\n+  Bvariable *result;\n };\n \n class CompileConditionalBlocks : public HIRCompileBase\n {\n public:\n-  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx)\n+  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx,\n+\t\t\t      Bvariable *result)\n   {\n-    CompileConditionalBlocks resolver (ctx);\n+    CompileConditionalBlocks resolver (ctx, result);\n     expr->accept_vis (resolver);\n     return resolver.translated;\n   }\n \n-  ~CompileConditionalBlocks () {}\n-\n   void visit (HIR::IfExpr &expr);\n \n   void visit (HIR::IfExprConseqElse &expr);\n \n   void visit (HIR::IfExprConseqIf &expr);\n \n private:\n-  CompileConditionalBlocks (Context *ctx)\n-    : HIRCompileBase (ctx), translated (nullptr)\n+  CompileConditionalBlocks (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n   Bstatement *translated;\n+  Bvariable *result;\n };\n \n class CompileExprWithBlock : public HIRCompileBase\n {\n public:\n-  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx)\n+  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx,\n+\t\t\t      Bvariable *result)\n   {\n-    CompileExprWithBlock resolver (ctx);\n+    CompileExprWithBlock resolver (ctx, result);\n     expr->accept_vis (resolver);\n     return resolver.translated;\n   }\n \n-  ~CompileExprWithBlock () {}\n-\n   void visit (HIR::IfExpr &expr)\n   {\n-    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n-    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n   }\n \n private:\n-  CompileExprWithBlock (Context *ctx)\n-    : HIRCompileBase (ctx), translated (nullptr)\n+  CompileExprWithBlock (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n   Bstatement *translated;\n+  Bvariable *result;\n };\n \n } // namespace Compile"}, {"sha": "194ee066a094f176b7263be195ad1dd110777f91", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -110,6 +110,11 @@ class Context\n     return scope_stack.back ();\n   }\n \n+  void add_statement_to_enclosing_scope (Bstatement *stmt)\n+  {\n+    statements.at (statements.size () - 2).push_back (stmt);\n+  }\n+\n   void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n \n   void insert_var_decl (HirId id, ::Bvariable *decl)"}, {"sha": "fad5ce0e476d6a7fdf9b1f16632a454fa8b056d1", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -409,27 +409,71 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::IfExpr &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n     ctx->add_statement (stmt);\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    // this can be a return expression\n+    TyTy::TyBase *if_type = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &if_type))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to lookup type of IfExprConseqElse\");\n+\treturn;\n+      }\n+\n+    fncontext fnctx = ctx->peek_fn ();\n+    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+    Btype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+    bool is_address_taken = false;\n+    Bstatement *ret_var_stmt = nullptr;\n+    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+      expr.get_locus (), &ret_var_stmt);\n+    ctx->add_statement (ret_var_stmt);\n+\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n     ctx->add_statement (stmt);\n+\n+    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n     ctx->add_statement (stmt);\n   }\n \n   void visit (HIR::BlockExpr &expr)\n   {\n-    auto code_block = CompileBlock::compile (&expr, ctx);\n+    TyTy::TyBase *block_tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &block_tyty))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+\treturn;\n+      }\n+\n+    fncontext fnctx = ctx->peek_fn ();\n+    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+    Btype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+    bool is_address_taken = false;\n+    Bstatement *ret_var_stmt = nullptr;\n+    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+      expr.get_locus (), &ret_var_stmt);\n+    ctx->add_statement (ret_var_stmt);\n+\n+    auto code_block = CompileBlock::compile (&expr, ctx, tmp);\n     auto block_stmt = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (block_stmt);\n+\n+    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n   }\n \n   void visit (HIR::StructExprStructFields &struct_expr)"}, {"sha": "8286a5c5eedd813c4c1d2373b9c3958b9aefb8a2", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -213,28 +213,8 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     ctx->push_fn (fndecl, return_address);\n \n-    // compile the block\n-    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n-      CompileStmt::Compile (s, ctx);\n-      return true;\n-    });\n-\n-    if (function_body->has_expr () && function_body->tail_expr_reachable ())\n-      {\n-\t// the previous passes will ensure this is a valid return\n-\t// dead code elimination should remove any bad trailing expressions\n-\tBexpression *compiled_expr\n-\t  = CompileExpr::Compile (function_body->expr.get (), ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\n-\tauto fncontext = ctx->peek_fn ();\n-\n-\tstd::vector<Bexpression *> retstmts;\n-\tretstmts.push_back (compiled_expr);\n-\tauto s = ctx->get_backend ()->return_statement (\n-\t  fncontext.fndecl, retstmts, function_body->expr->get_locus_slow ());\n-\tctx->add_statement (s);\n-      }\n+    compile_function_body (fndecl, function.function_body,\n+\t\t\t   function.has_function_return_type ());\n \n     ctx->pop_block ();\n     auto body = ctx->get_backend ()->block_statement (code_block);"}, {"sha": "b08c49e5f4b899b45ef1e82d655c3f90e27031a2", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -265,28 +265,8 @@ class CompileItem : public HIRCompileBase\n \n     ctx->push_fn (fndecl, return_address);\n \n-    // compile the block\n-    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n-      CompileStmt::Compile (s, ctx);\n-      return true;\n-    });\n-\n-    if (function_body->has_expr () && function_body->tail_expr_reachable ())\n-      {\n-\t// the previous passes will ensure this is a valid return\n-\t// dead code elimination should remove any bad trailing expressions\n-\tBexpression *compiled_expr\n-\t  = CompileExpr::Compile (function_body->expr.get (), ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\n-\tauto fncontext = ctx->peek_fn ();\n-\n-\tstd::vector<Bexpression *> retstmts;\n-\tretstmts.push_back (compiled_expr);\n-\tauto s = ctx->get_backend ()->return_statement (\n-\t  fncontext.fndecl, retstmts, function_body->expr->get_locus_slow ());\n-\tctx->add_statement (s);\n-      }\n+    compile_function_body (fndecl, function.function_body,\n+\t\t\t   function.has_function_return_type ());\n \n     ctx->pop_block ();\n     auto body = ctx->get_backend ()->block_statement (code_block);\n@@ -297,7 +277,6 @@ class CompileItem : public HIRCompileBase\n       }\n \n     ctx->pop_fn ();\n-\n     ctx->push_function (fndecl);\n   }\n "}, {"sha": "d021240e4280b092374ac269eea2ec2160bcd544", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -29,37 +29,24 @@ namespace Compile {\n class CompileStmt : public HIRCompileBase\n {\n public:\n-  static void Compile (HIR::Stmt *stmt, Context *ctx)\n+  static Bexpression *Compile (HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileStmt compiler (ctx);\n     stmt->accept_vis (compiler);\n     rust_assert (compiler.ok);\n+    return compiler.translated;\n   }\n \n-  virtual ~CompileStmt () {}\n-\n   void visit (HIR::ExprStmtWithBlock &stmt)\n   {\n     ok = true;\n-    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n-\n-    // these can be null\n-    if (translated == nullptr)\n-      return;\n-\n-    gcc_unreachable ();\n+    translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n   }\n \n   void visit (HIR::ExprStmtWithoutBlock &stmt)\n   {\n     ok = true;\n-    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n-\n-    // these can be null\n-    if (translated == nullptr)\n-      return;\n-\n-    gcc_unreachable ();\n+    translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n   }\n \n   void visit (HIR::LetStmt &stmt)\n@@ -99,9 +86,12 @@ class CompileStmt : public HIRCompileBase\n   }\n \n private:\n-  CompileStmt (Context *ctx) : HIRCompileBase (ctx), ok (false) {}\n+  CompileStmt (Context *ctx)\n+    : HIRCompileBase (ctx), ok (false), translated (nullptr)\n+  {}\n \n   bool ok;\n+  Bexpression *translated;\n };\n \n } // namespace Compile"}, {"sha": "f72cf4cf9f5004cd98552f5ecf7f56a2e077a43f", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 108, "deletions": 16, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -135,10 +135,30 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \t\t\t\t  start_location, end_location);\n   ctx->push_block (new_block);\n \n-  expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n-    CompileStmt::Compile (s, ctx);\n-    return true;\n-  });\n+  for (auto &s : expr.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr == nullptr)\n+\tcontinue;\n+\n+      if (result == nullptr)\n+\t{\n+\t  Bstatement *final_stmt\n+\t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n+\t\t\t\t\t\t\t compiled_expr);\n+\t  ctx->add_statement (final_stmt);\n+\t}\n+      else\n+\t{\n+\t  Bexpression *result_reference\n+\t    = ctx->get_backend ()->var_expression (result,\n+\t\t\t\t\t\t   s->get_locus_slow ());\n+\n+\t  Bstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\t    fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n+\t  ctx->add_statement (assignment);\n+\t}\n+    }\n \n   if (expr.has_expr () && expr.tail_expr_reachable ())\n     {\n@@ -147,14 +167,22 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       Bexpression *compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n       rust_assert (compiled_expr != nullptr);\n \n-      auto fncontext = ctx->peek_fn ();\n+      if (result == nullptr)\n+\t{\n+\t  Bstatement *final_stmt\n+\t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n+\t\t\t\t\t\t\t compiled_expr);\n+\t  ctx->add_statement (final_stmt);\n+\t}\n+      else\n+\t{\n+\t  Bexpression *result_reference = ctx->get_backend ()->var_expression (\n+\t    result, expr.get_final_expr ()->get_locus_slow ());\n \n-      std::vector<Bexpression *> retstmts;\n-      retstmts.push_back (compiled_expr);\n-      auto s\n-\t= ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n-\t\t\t\t\t\t expr.expr->get_locus_slow ());\n-      ctx->add_statement (s);\n+\t  Bstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\t    fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n+\t  ctx->add_statement (assignment);\n+\t}\n     }\n \n   ctx->pop_block ();\n@@ -168,7 +196,8 @@ CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n   Bfunction *fndecl = fnctx.fndecl;\n   Bexpression *condition_expr\n     = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+  Bblock *then_block\n+    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -182,8 +211,10 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n   Bfunction *fndecl = fnctx.fndecl;\n   Bexpression *condition_expr\n     = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n-  Bblock *else_block = CompileBlock::compile (expr.get_else_block (), ctx);\n+  Bblock *then_block\n+    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  Bblock *else_block\n+    = CompileBlock::compile (expr.get_else_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -197,7 +228,8 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n   Bfunction *fndecl = fnctx.fndecl;\n   Bexpression *condition_expr\n     = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+  Bblock *then_block\n+    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   // else block\n   std::vector<Bvariable *> locals;\n@@ -210,7 +242,8 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n   ctx->push_block (else_block);\n \n   Bstatement *else_stmt_decl\n-    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx);\n+    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n+\t\t\t\t\t result);\n   ctx->add_statement (else_stmt_decl);\n \n   ctx->pop_block ();\n@@ -244,5 +277,64 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n   translated = CompileExpr::Compile (&expr, ctx);\n }\n \n+// Shared methods in compilation\n+\n+void\n+HIRCompileBase::compile_function_body (\n+  Bfunction *fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n+  bool has_return_type)\n+{\n+  for (auto &s : function_body->get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (has_return_type)\n+\t    {\n+\t      std::vector<Bexpression *> retstmts;\n+\t      retstmts.push_back (compiled_expr);\n+\n+\t      auto ret\n+\t\t= ctx->get_backend ()->return_statement (fndecl, retstmts,\n+\t\t\t\t\t\t\t s->get_locus_slow ());\n+\t      ctx->add_statement (ret);\n+\t    }\n+\t  else\n+\t    {\n+\t      Bstatement *final_stmt\n+\t\t= ctx->get_backend ()->expression_statement (fndecl,\n+\t\t\t\t\t\t\t     compiled_expr);\n+\t      ctx->add_statement (final_stmt);\n+\t    }\n+\t}\n+    }\n+\n+  if (function_body->has_expr () && function_body->tail_expr_reachable ())\n+    {\n+      // the previous passes will ensure this is a valid return\n+      // dead code elimination should remove any bad trailing expressions\n+      Bexpression *compiled_expr\n+\t= CompileExpr::Compile (function_body->expr.get (), ctx);\n+      rust_assert (compiled_expr != nullptr);\n+\n+      if (has_return_type)\n+\t{\n+\t  std::vector<Bexpression *> retstmts;\n+\t  retstmts.push_back (compiled_expr);\n+\n+\t  auto ret = ctx->get_backend ()->return_statement (\n+\t    fndecl, retstmts,\n+\t    function_body->get_final_expr ()->get_locus_slow ());\n+\t  ctx->add_statement (ret);\n+\t}\n+      else\n+\t{\n+\t  Bstatement *final_stmt\n+\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n+\t  ctx->add_statement (final_stmt);\n+\t}\n+    }\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "8f0c206e960abeb2987b24c9a8bb691dd6afcfdf", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -2585,6 +2585,10 @@ class BlockExpr : public ExprWithBlock\n     return statements[statements.size () - 1]->get_locus_slow ();\n   }\n \n+  std::unique_ptr<ExprWithoutBlock> &get_final_expr () { return expr; }\n+\n+  std::vector<std::unique_ptr<Stmt> > &get_statements () { return statements; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "681d0238d8e4300302a79f740e04000377087cfd", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -127,19 +127,12 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     return true;\n   });\n \n-  // tail expression must be checked as part of the caller since\n-  // the result of this is very dependant on what we expect it to be\n-\n-  // now that the stmts have been resolved we must resolve the block of locals\n-  // and make sure the variables have been resolved\n-  // auto body_mappings = expr.get_mappings ();\n-  // Rib *rib = nullptr;\n-  // if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n-  //   {\n-  //     rust_fatal_error (expr.get_locus (), \"failed to lookup locals per\n-  //     block\"); return;\n-  //   }\n-  // TyTyResolver::Resolve (rib, mappings, resolver, context);\n+  if (expr.has_expr ())\n+    {\n+      delete block_tyty;\n+\n+      block_tyty = TypeCheckExpr::Resolve (expr.get_final_expr ().get (), true);\n+    }\n \n   infered = block_tyty->clone ();\n }"}, {"sha": "fe63252cf9b5ac9ca12b1b9ffac1b326f6626fdc", "filename": "gcc/testsuite/rust.test/compilable/block_expr1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599b04aa7d928a305029d8e8cf5d6f5c5a683da8/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr1.rs?ref=599b04aa7d928a305029d8e8cf5d6f5c5a683da8", "patch": "@@ -0,0 +1,27 @@\n+fn test3(x: i32) -> i32 {\n+    if x > 1 {\n+        5\n+    } else {\n+        0\n+    }\n+}\n+\n+fn test5(x: i32) -> i32 {\n+    if x > 1 {\n+        if x == 5 {\n+            7\n+        } else {\n+            9\n+        }\n+    } else {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let call3: i32 = { test3(3) + 2 };\n+    let call5 = {\n+        let a = test5(5);\n+        a + 1\n+    };\n+}"}]}