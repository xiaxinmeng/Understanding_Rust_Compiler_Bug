{"sha": "e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliODQxODEzYzA0YjdiOWVlOWQyYjMwZDhmZmY0OTRhYzRhYWNiZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-04-18T12:32:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-04-18T12:32:36Z"}, "message": "configure.in (powerpc64*-*-linux*): Remove.\n\n\t* configure.in (powerpc64*-*-linux*): Remove.\n\t* configure: Rebuilt.\nlibffi/\n\t* include/ffi.h.in (POWERPC64): Define if 64-bit.\n\t(enum ffi_abi): Add FFI_LINUX64 on POWERPC.\n\tMake it the default on POWERPC64.\n\t(FFI_TRAMPOLINE_SIZE): Define to 24 on POWERPC64.\n\t* configure.in: Change powerpc-*-linux* into powerpc*-*-linux*.\n\t* configure: Rebuilt.\n\t* src/powerpc/ffi.c (hidden): Define.\n\t(ffi_prep_args_SYSV): Renamed from\n\tffi_prep_args.  Cast pointers to unsigned long to shut up warnings.\n\t(NUM_GPR_ARG_REGISTERS64, NUM_FPR_ARG_REGISTERS64,\n\tASM_NEEDS_REGISTERS64): New.\n\t(ffi_prep_args64): New function.\n\t(ffi_prep_cif_machdep): Handle FFI_LINUX64 ABI.\n\t(ffi_call): Likewise.\n\t(ffi_prep_closure): Likewise.\n\t(flush_icache): Surround by #ifndef POWERPC64.\n\t(ffi_dblfl): New union type.\n\t(ffi_closure_helper_SYSV): Use it to avoid aliasing problems.\n\t(ffi_closure_helper_LINUX64): New function.\n\t* src/powerpc/ppc_closure.S: Surround whole file by #ifndef\n\t__powerpc64__.\n\t* src/powerpc/sysv.S: Likewise.\n\t(ffi_call_SYSV): Rename ffi_prep_args to ffi_prep_args_SYSV.\n\t* src/powerpc/linux64.S: New file.\n\t* src/powerpc/linux64_closure.S: New file.\n\t* Makefile.am (EXTRA_DIST): Add src/powerpc/linux64.S and\n\tsrc/powerpc/linux64_closure.S.\n\t(TARGET_SRC_POWERPC): Likewise.\n\n\t* src/ffitest.c (closure_test_fn, closure_test_fn1, closure_test_fn2,\n\tclosure_test_fn3): Fix result printing on big-endian 64-bit\n\tmachines.\n\t(main): Print tst2_arg instead of uninitialized tst2_result.\n\n\t* src/ffitest.c (main): Hide what closure pointer really points to\n\tfrom the compiler.\n\nFrom-SVN: r65781", "tree": {"sha": "6d11613a6465cc0f53789e34009ab2f57cfbaf75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d11613a6465cc0f53789e34009ab2f57cfbaf75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c594837086fc3e80adfa989de0a494391ff39a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c594837086fc3e80adfa989de0a494391ff39a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c594837086fc3e80adfa989de0a494391ff39a6"}], "stats": {"total": 1125, "additions": 997, "deletions": 128}, "files": [{"sha": "94dc6317f7204b48b346e7b45629e1f041b4bf3d", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -1,3 +1,8 @@\n+2003-04-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* configure.in (powerpc64*-*-linux*): Remove.\n+\t* configure: Rebuilt.\n+\n 2003-04-17  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* Makefile.tpl (GCC_STRAP_TARGETS):  New variable containing all the"}, {"sha": "045ad147f7303bb252e2e57cc2aa1b344d545e87", "filename": "configure", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -1267,11 +1267,6 @@ case \"${target}\" in\n   powerpc-*-eabi)\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n-  powerpc64*-*-linux*)\n-    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n-    # not yet ported.\n-    noconfigdirs=\"$noconfigdirs target-libffi\"\n-    ;;\n   rs6000-*-lynxos*)\n     noconfigdirs=\"$noconfigdirs target-newlib gprof ${libgcj}\"\n     ;;"}, {"sha": "f695982d796ae8dae9a73b6e366c7a698a1f02f7", "filename": "configure.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -607,11 +607,6 @@ case \"${target}\" in\n   powerpc-*-eabi)\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n-  powerpc64*-*-linux*)\n-    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n-    # not yet ported.\n-    noconfigdirs=\"$noconfigdirs target-libffi\"\n-    ;;\n   rs6000-*-lynxos*)\n     noconfigdirs=\"$noconfigdirs target-newlib gprof ${libgcj}\"\n     ;;"}, {"sha": "e07b07fead66ab673acf99978bd5759df750bb72", "filename": "libffi/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -1,3 +1,42 @@\n+2003-04-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* include/ffi.h.in (POWERPC64): Define if 64-bit.\n+\t(enum ffi_abi): Add FFI_LINUX64 on POWERPC.\n+\tMake it the default on POWERPC64.\n+\t(FFI_TRAMPOLINE_SIZE): Define to 24 on POWERPC64.\n+\t* configure.in: Change powerpc-*-linux* into powerpc*-*-linux*.\n+\t* configure: Rebuilt.\n+\t* src/powerpc/ffi.c (hidden): Define.\n+\t(ffi_prep_args_SYSV): Renamed from\n+\tffi_prep_args.  Cast pointers to unsigned long to shut up warnings.\n+\t(NUM_GPR_ARG_REGISTERS64, NUM_FPR_ARG_REGISTERS64,\n+\tASM_NEEDS_REGISTERS64): New.\n+\t(ffi_prep_args64): New function.\n+\t(ffi_prep_cif_machdep): Handle FFI_LINUX64 ABI.\n+\t(ffi_call): Likewise.\n+\t(ffi_prep_closure): Likewise.\n+\t(flush_icache): Surround by #ifndef POWERPC64.\n+\t(ffi_dblfl): New union type.\n+\t(ffi_closure_helper_SYSV): Use it to avoid aliasing problems.\n+\t(ffi_closure_helper_LINUX64): New function.\n+\t* src/powerpc/ppc_closure.S: Surround whole file by #ifndef\n+\t__powerpc64__.\n+\t* src/powerpc/sysv.S: Likewise.\n+\t(ffi_call_SYSV): Rename ffi_prep_args to ffi_prep_args_SYSV.\n+\t* src/powerpc/linux64.S: New file.\n+\t* src/powerpc/linux64_closure.S: New file.\n+\t* Makefile.am (EXTRA_DIST): Add src/powerpc/linux64.S and\n+\tsrc/powerpc/linux64_closure.S.\n+\t(TARGET_SRC_POWERPC): Likewise.\n+\n+\t* src/ffitest.c (closure_test_fn, closure_test_fn1, closure_test_fn2,\n+\tclosure_test_fn3): Fix result printing on big-endian 64-bit\n+\tmachines.\n+\t(main): Print tst2_arg instead of uninitialized tst2_result.\n+\n+\t* src/ffitest.c (main): Hide what closure pointer really points to\n+\tfrom the compiler.\n+\n 2003-04-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* configure.in (arm-*-netbsdelf*): Add configuration."}, {"sha": "82381b8f242a689c444619c06a6eea69c1b9d42b", "filename": "libffi/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -12,6 +12,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n \t\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n+\t\tsrc/powerpc/linux64.S src/powerpc/linux64_closure.S \\\n \t\tsrc/powerpc/ppc_closure.S src/powerpc/asm.h \\\n \t\tsrc/powerpc/ffi_darwin.c \\\n \t\tsrc/powerpc/darwin.S src/powerpc/aix.S \\\n@@ -94,7 +95,7 @@ TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n-TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n+TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c"}, {"sha": "08d8c73ada46c4a29cde71651e917a6c52446daf", "filename": "libffi/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -95,6 +95,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n \t\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n+\t\tsrc/powerpc/linux64.S src/powerpc/linux64_closure.S \\\n \t\tsrc/powerpc/ppc_closure.S src/powerpc/asm.h \\\n \t\tsrc/powerpc/ffi_darwin.c \\\n \t\tsrc/powerpc/darwin.S src/powerpc/aix.S \\\n@@ -173,7 +174,7 @@ TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n-TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n+TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c\n@@ -257,7 +258,8 @@ libffi_convenience_la_LIBADD =\n @POWERPC_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n @POWERPC_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @POWERPC_TRUE@src/java_raw_api.lo src/powerpc/ffi.lo \\\n-@POWERPC_TRUE@src/powerpc/sysv.lo src/powerpc/ppc_closure.lo\n+@POWERPC_TRUE@src/powerpc/sysv.lo src/powerpc/ppc_closure.lo \\\n+@POWERPC_TRUE@src/powerpc/linux64.lo src/powerpc/linux64_closure.lo\n @MIPS_LINUX_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n @MIPS_LINUX_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @MIPS_LINUX_TRUE@src/java_raw_api.lo src/mips/ffi.lo src/mips/o32.lo\n@@ -301,7 +303,8 @@ libffi_la_LIBADD =\n @POWERPC_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @POWERPC_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @POWERPC_TRUE@src/powerpc/ffi.lo src/powerpc/sysv.lo \\\n-@POWERPC_TRUE@src/powerpc/ppc_closure.lo\n+@POWERPC_TRUE@src/powerpc/ppc_closure.lo src/powerpc/linux64.lo \\\n+@POWERPC_TRUE@src/powerpc/linux64_closure.lo\n @MIPS_LINUX_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @MIPS_LINUX_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @MIPS_LINUX_TRUE@src/mips/ffi.lo src/mips/o32.lo"}, {"sha": "6197a44a8cdd78a8e7c89e7046b8730943f83de3", "filename": "libffi/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -2469,7 +2469,7 @@ ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;\n m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;\n mips64*-*);;\n mips*-*-linux*) TARGET=MIPS_LINUX; TARGETDIR=mips;;\n-powerpc-*-linux* | powerpc-*-sysv*) TARGET=POWERPC; TARGETDIR=powerpc;;\n+powerpc*-*-linux* | powerpc-*-sysv*) TARGET=POWERPC; TARGETDIR=powerpc;;\n powerpc-*-beos*) TARGET=POWERPC; TARGETDIR=powerpc;;\n powerpc-*-darwin*) TARGET=POWERPC_DARWIN; TARGETDIR=powerpc;;\n powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;"}, {"sha": "7bb01d68ca08162ffb11e37b47b1b90cfd0025cc", "filename": "libffi/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -64,7 +64,7 @@ ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;\n m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;\n mips64*-*);;\n mips*-*-linux*) TARGET=MIPS_LINUX; TARGETDIR=mips;;\n-powerpc-*-linux* | powerpc-*-sysv*) TARGET=POWERPC; TARGETDIR=powerpc;;\n+powerpc*-*-linux* | powerpc-*-sysv*) TARGET=POWERPC; TARGETDIR=powerpc;;\n powerpc-*-beos*) TARGET=POWERPC; TARGETDIR=powerpc;;\n powerpc-*-darwin*) TARGET=POWERPC_DARWIN; TARGETDIR=powerpc;;\n powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;"}, {"sha": "c51a809ea3f75c62450fae053f32087ad1394bdd", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -158,6 +158,12 @@ extern \"C\" {\n #define SIZEOF_ARG SIZEOF_VOID_P\n #endif\n \n+#ifdef POWERPC\n+#if defined (__powerpc64__)\n+#define POWERPC64\n+#endif\n+#endif\n+\n #ifdef SPARC\n #if defined(__arch64__) || defined(__sparcv9)\n #define SPARC64\n@@ -250,7 +256,12 @@ typedef enum ffi_abi {\n #ifdef POWERPC\n   FFI_SYSV,\n   FFI_GCC_SYSV,\n+  FFI_LINUX64,\n+# ifdef POWERPC64\n+  FFI_DEFAULT_ABI = FFI_LINUX64,\n+# else\n   FFI_DEFAULT_ABI = FFI_GCC_SYSV,\n+# endif\n #endif\n \n #ifdef POWERPC_AIX\n@@ -435,7 +446,11 @@ struct ffi_ia64_trampoline_struct {\n #elif defined(POWERPC)\n \n #define FFI_CLOSURES 1\n+#ifdef POWERPC64\n+#define FFI_TRAMPOLINE_SIZE 24\n+#else\n #define FFI_TRAMPOLINE_SIZE 40\n+#endif\n #define FFI_NATIVE_RAW_API 0\n \n #elif defined(POWERPC_DARWIN)"}, {"sha": "223b49c6dd81b25d1d782648fe4c4e2b9b1aac8b", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -309,7 +309,7 @@ closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)\n \t       (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n \t       (int)*(int *)args[12], (int)(*(int *)args[13]), \n \t       (int)(*(int *)args[14]),*(int *)args[15],\n-\t       (int)(long)userdata, *(int*)resp);\n+\t       (int)(long)userdata, (int)*(ffi_arg *)resp);\n }\n \n typedef int (*closure_test_type)(unsigned long long, int, unsigned long long, \n@@ -339,7 +339,7 @@ static void closure_test_fn1(ffi_cif* cif,void* resp,void** args,\n \t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n \t   (int)*(int *)args[12], (int)(*(int *)args[13]),\n \t   (int)(*(int *)args[14]), *(int *)args[15],\n-\t   (int)(long)userdata, *(int*)resp);\n+\t   (int)(long)userdata, (int)*(ffi_arg *)resp);\n }\n \n typedef int (*closure_test_type1)(float, float, float, float, signed short, \n@@ -368,7 +368,7 @@ static void closure_test_fn2(ffi_cif* cif,void* resp,void** args,\n \t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n \t   (int)*(int *)args[12], (int)(*(float *)args[13]), \n \t   (int)(*(int *)args[14]), *(int *)args[15], (int)(long)userdata, \n-\t   *(int*)resp);\n+\t   (int)*(ffi_arg *)resp);\n  }\n \n typedef int (*closure_test_type2)(double, double, double, double, signed short,\n@@ -397,7 +397,7 @@ static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,\n \t   (int)(*(float *)args[10]), (int)(*(float *)args[11]),\n \t   (int)*(int *)args[12], (int)(*(float *)args[13]), \n \t   (int)(*(float *)args[14]), *(int *)args[15], (int)(long)userdata,\n-\t   *(int*)resp);\n+\t   (int)*(ffi_arg *)resp);\n  }\n \n typedef int (*closure_test_type3)(float, float, float, float, float, float,\n@@ -430,6 +430,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   /* The closure must not be an automatic variable on\n      platforms (Solaris) that forbid stack execution by default. */\n   static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n #endif\n \n   ffi_type * cl_arg_types[17];\n@@ -841,8 +842,8 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n     ts2_arg.d1 = 5.55;\n     ts2_arg.d2 = 6.66;\n \n-    printf (\"%g\\n\", ts2_result->d1);\n-    printf (\"%g\\n\", ts2_result->d2);\n+    printf (\"%g\\n\", ts2_arg.d1);\n+    printf (\"%g\\n\", ts2_arg.d2);\n \n     ffi_call(&cif, FFI_FN(struct2), ts2_result, values);\n \n@@ -1161,6 +1162,13 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n #endif /* X86_WIN32 */\n \n # if FFI_CLOSURES\n+#  if __GNUC__ >= 2\n+   /* Hide before the compiler that pcl is &cl, since on\n+      some architectures it is not possible to call a data\n+      object using direct function call.  */\n+   asm (\"\" : \"=g\" (pcl) : \"0\" (pcl));\n+#  endif\n+\n   /* A simple closure test */\n     {\n       (void) puts(\"\\nEnter FFI_CLOSURES\\n\");\n@@ -1187,10 +1195,10 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n       CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,\n+      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn,\n \t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n       \n-      CHECK((*((closure_test_type)(&cl)))\n+      CHECK((*((closure_test_type)pcl))\n \t    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, \n \t     19, 21, 1) == 680);\n     }\n@@ -1219,10 +1227,10 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n       CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,\n+      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,\n \t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n       \n-      CHECK((*((closure_test_type1)(&cl)))\n+      CHECK((*((closure_test_type1)pcl))\n \t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n \t     19, 21, 1) == 255);\n     }\n@@ -1251,10 +1259,10 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n       CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn2,\n+      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn2,\n \t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n \n-      CHECK((*((closure_test_type2)(&cl)))\n+      CHECK((*((closure_test_type2)pcl))\n \t    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n \t     19.0, 21, 1) == 255);\n \n@@ -1284,10 +1292,10 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n       CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n \t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n \n-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn3,\n+      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn3,\n \t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n       \n-      CHECK((*((closure_test_type3)(&cl)))\n+      CHECK((*((closure_test_type3)pcl))\n \t    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n \t     19.19, 21.21, 1) == 135);\n     }"}, {"sha": "6f0e2a561affacf10d80aa09f41557d216159d73", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 502, "deletions": 95, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -31,7 +31,15 @@\n #include <stdlib.h>\n #include <stdio.h>\n \n+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 1)\n+# define hidden __attribute__ ((visibility (\"hidden\")))\n+#else\n+# define hidden\n+#endif\n+\n+\n extern void ffi_closure_SYSV(void);\n+extern void hidden ffi_closure_LINUX64(void);\n \n enum {\n   /* The assembly depends on these exact flags.  */\n@@ -52,7 +60,7 @@ enum {\n };\n enum { ASM_NEEDS_REGISTERS = 4 };\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n+/* ffi_prep_args_SYSV is called by the assembly routine once stack space\n    has been allocated for the function's arguments.\n \n    The stack layout we want looks like this:\n@@ -79,7 +87,7 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n    */\n \n /*@-exportheader@*/\n-void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n+void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n /*@=exportheader@*/\n {\n   const unsigned bytes = ecif->cif->bytes;\n@@ -124,7 +132,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n   /* Deal with return values that are actually pass-by-reference.  */\n   if (flags & FLAG_RETVAL_REFERENCE)\n   {\n-    *gpr_base++ = (unsigned)(char *)ecif->rvalue;\n+    *gpr_base++ = (unsigned long)(char *)ecif->rvalue;\n     intarg_count++;\n   }\n \n@@ -210,7 +218,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t  copy_space -= struct_copy_size;\n \t  memcpy(copy_space, (char *)*p_argv, (*ptr)->size);\n \t  \n-\t  gprvalue = (unsigned)copy_space;\n+\t  gprvalue = (unsigned long)copy_space;\n \n \t  FFI_ASSERT(copy_space > (char *)next_arg);\n \t  FFI_ASSERT(flags & FLAG_ARG_NEEDS_COPY);\n@@ -252,34 +260,229 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n   FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n }\n \n+/* About the LINUX64 ABI.  */\n+enum {\n+  NUM_GPR_ARG_REGISTERS64 = 8,\n+  NUM_FPR_ARG_REGISTERS64 = 13\n+};\n+enum { ASM_NEEDS_REGISTERS64 = 4 };\n+\n+/* ffi_prep_args64 is called by the assembly routine once stack space\n+   has been allocated for the function's arguments.\n+\n+   The stack layout we want looks like this:\n+\n+   |   Ret addr from ffi_call_LINUX64\t8bytes\t|\thigher addresses\n+   |--------------------------------------------|\n+   |   CR save area\t\t\t8bytes\t|\n+   |--------------------------------------------|\n+   |   Previous backchain pointer\t8\t| \tstack pointer here\n+   |--------------------------------------------|<+ <<<\ton entry to\n+   |   Saved r28-r31\t\t\t4*8\t| |\tffi_call_LINUX64\n+   |--------------------------------------------| |\n+   |   GPR registers r3-r10\t\t8*8\t| |\n+   |--------------------------------------------| |\n+   |   FPR registers f1-f13 (optional)\t13*8\t| |\n+   |--------------------------------------------| |\n+   |   Parameter save area\t\t        | |\n+   |--------------------------------------------| |\n+   |   TOC save area\t\t\t8\t| |\n+   |--------------------------------------------| |\tstack\t|\n+   |   Linker doubleword\t\t8\t| |\tgorws\t|\n+   |--------------------------------------------| |\tdown\tV\n+   |   Compiler doubleword\t\t8\t| |\n+   |--------------------------------------------| |\tlower addresses\n+   |   Space for callee's LR\t\t8\t| |\n+   |--------------------------------------------| |\n+   |   CR save area\t\t\t8\t| |\n+   |--------------------------------------------| |\tstack pointer here\n+   |   Current backchain pointer\t8\t|-/\tduring\n+   |--------------------------------------------|   <<<\tffi_call_LINUX64\n+\n+   */\n+\n+/*@-exportheader@*/\n+void hidden ffi_prep_args64(extended_cif *ecif, unsigned long *const stack)\n+/*@=exportheader@*/\n+{\n+  const unsigned long bytes = ecif->cif->bytes;\n+  const unsigned long flags = ecif->cif->flags;\n+\n+  /* 'stacktop' points at the previous backchain pointer.  */\n+  unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));\n+\n+  /* 'next_arg' points at the space for gpr3, and grows upwards as\n+     we use GPR registers, then continues at rest.  */\n+  unsigned long *const gpr_base = stacktop - ASM_NEEDS_REGISTERS64\n+\t\t\t\t  - NUM_GPR_ARG_REGISTERS64;\n+  unsigned long *const gpr_end = gpr_base + NUM_GPR_ARG_REGISTERS64;\n+  unsigned long *const rest = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n+  unsigned long *next_arg = gpr_base;\n+\n+  /* 'fpr_base' points at the space for fpr3, and grows upwards as\n+     we use FPR registers.  */\n+  double *fpr_base = (double *)gpr_base - NUM_FPR_ARG_REGISTERS64;\n+  int fparg_count = 0;\n+\n+  int i, words;\n+  ffi_type **ptr;\n+  double double_tmp;\n+  void **p_argv;\n+  unsigned long gprvalue;\n+\n+  /* Check that everything starts aligned properly.  */\n+  FFI_ASSERT(((unsigned long)(char *)stack & 0xF) == 0);\n+  FFI_ASSERT(((unsigned long)(char *)stacktop & 0xF) == 0);\n+  FFI_ASSERT((bytes & 0xF) == 0);\n+\n+  /* Deal with return values that are actually pass-by-reference.  */\n+  if (flags & FLAG_RETVAL_REFERENCE)\n+    *next_arg++ = (unsigned long)(char *)ecif->rvalue;\n+\n+  /* Now for the arguments.  */\n+  p_argv = ecif->avalue;\n+  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n+       i > 0;\n+       i--, ptr++, p_argv++)\n+    {\n+      switch ((*ptr)->type)\n+\t{\n+\tcase FFI_TYPE_FLOAT:\n+\t  double_tmp = *(float *)*p_argv;\n+\t  *(float *)next_arg = (float)double_tmp;\n+\t  if (++next_arg == gpr_end)\n+\t    next_arg = rest;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n+\t    *fpr_base++ = double_tmp;\n+\t  fparg_count++;\n+\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  double_tmp = *(double *)*p_argv;\n+\t  *(double *)next_arg = double_tmp;\n+\t  if (++next_arg == gpr_end)\n+\t    next_arg = rest;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n+\t    *fpr_base++ = double_tmp;\n+\t  fparg_count++;\n+\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+#endif\n+\t  words = ((*ptr)->size + 7) / 8;\n+\t  if (next_arg >= gpr_base && next_arg + words > gpr_end)\n+\t    {\n+\t      unsigned int first = (char *) gpr_end - (char *) next_arg;\n+\t      memcpy((char *) next_arg, (char *) *p_argv, first);\n+\t      memcpy((char *) rest, (char *) *p_argv + first,\n+\t\t     (*ptr)->size - first);\n+\t      next_arg = rest + words * 8 - first;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Structures with 1, 2 and 4 byte sizes are passed left-padded\n+\t\t if they are in the first 8 arguments.  */\n+\t      if (next_arg >= gpr_base\n+\t\t  && (*ptr)->size < 8\n+\t\t  && ((*ptr)->size & ~((*ptr)->size - 1)) == (*ptr)->size)\n+\t\tmemcpy((char *) next_arg + 8 - (*ptr)->size,\n+\t\t       (char *) *p_argv, (*ptr)->size);\n+\t      else\n+\t\tmemcpy((char *) next_arg, (char *) *p_argv, (*ptr)->size);\n+\t      next_arg += words;\n+\t      if (next_arg == gpr_end)\n+\t\tnext_arg = rest;\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT8:\n+\t  gprvalue = *(unsigned char *)*p_argv;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_SINT8:\n+\t  gprvalue = *(signed char *)*p_argv;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_UINT16:\n+\t  gprvalue = *(unsigned short *)*p_argv;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_SINT16:\n+\t  gprvalue = *(signed short *)*p_argv;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_UINT32:\n+\t  gprvalue = *(unsigned int *)*p_argv;\n+\t  goto putgpr;\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_SINT32:\n+\t  gprvalue = *(signed int *)*p_argv;\n+\t  goto putgpr;\n+\t\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  gprvalue = *(unsigned long *)*p_argv;\n+\tputgpr:\n+\t  *next_arg++ = gprvalue;\n+\t  if (next_arg == gpr_end)\n+\t    next_arg = rest;\n+\t  break;\n+\t}\n+    }\n+\n+  FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS\n+\t     || (next_arg >= gpr_base && next_arg <= gpr_base + 4));\n+}\n+\n+\n+\n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n-  /* All this is for the SYSV ABI.  */\n+  /* All this is for the SYSV and LINUX64 ABI.  */\n   int i;\n   ffi_type **ptr;\n   unsigned bytes;\n   int fparg_count = 0, intarg_count = 0;\n   unsigned flags = 0;\n   unsigned struct_copy_size = 0;\n-  \n-  /* All the machine-independent calculation of cif->bytes will be wrong.\n-     Redo the calculation for SYSV.  */\n \n-  /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */\n-  bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof(int);\n+  if (cif->abi != FFI_LINUX64)\n+    {    \n+      /* All the machine-independent calculation of cif->bytes will be wrong.\n+\t Redo the calculation for SYSV.  */\n \n-  /* Space for the GPR registers.  */\n-  bytes += NUM_GPR_ARG_REGISTERS * sizeof(int);\n+      /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */\n+      bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof(int);\n \n-  /* Return value handling.  The rules are as follows:\n+      /* Space for the GPR registers.  */\n+      bytes += NUM_GPR_ARG_REGISTERS * sizeof(int);\n+    }\n+  else\n+    {\n+      /* 64-bit ABI.  */\n+\n+      /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp\n+\t regs.  */\n+      bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof(long);\n+\n+      /* Space for the mandatory parm save area and general registers.  */\n+      bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof(long);\n+    }\n+\n+  /* Return value handling.  The rules for SYSV are as follows:\n      - 32-bit (or less) integer values are returned in gpr3;\n      - Structures of size <= 4 bytes also returned in gpr3;\n      - 64-bit integer values and structures between 5 and 8 bytes are returned\n        in gpr3 and gpr4;\n      - Single/double FP values are returned in fpr1;\n      - Larger structures and long double (if not equivalent to double) values\n-       are allocated space and a pointer is passed as the first argument.  */\n+       are allocated space and a pointer is passed as the first argument.\n+     For LINUX64:\n+     - integer values in gpr3;\n+     - Structures/Unions and long double by reference;\n+     - Single/double FP values in fpr1.  */\n   switch (cif->rtype->type)\n     {\n     case FFI_TYPE_DOUBLE:\n@@ -295,7 +498,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       break;\n \n     case FFI_TYPE_STRUCT:\n-      if (cif->abi != FFI_GCC_SYSV)\n+      if (cif->abi != FFI_GCC_SYSV && cif->abi != FFI_LINUX64)\n \tif (cif->rtype->size <= 4)\n \t  break;\n \telse if (cif->rtype->size <= 8)\n@@ -319,76 +522,116 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       break;\n     }\n \n-  /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the\n-     first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest\n-     goes on the stack.  Structures and long doubles (if not equivalent\n-     to double) are passed as a pointer to a copy of the structure.\n-     Stuff on the stack needs to keep proper alignment.  */\n-  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n-    {\n-      switch ((*ptr)->type)\n-\t{\n-\tcase FFI_TYPE_FLOAT:\n-\t  fparg_count++;\n-\t  /* floating singles are not 8-aligned on stack */\n-\t  break;\n+  if (cif->abi != FFI_LINUX64)\n+    /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the\n+       first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest\n+       goes on the stack.  Structures and long doubles (if not equivalent\n+       to double) are passed as a pointer to a copy of the structure.\n+       Stuff on the stack needs to keep proper alignment.  */\n+    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+      {\n+\tswitch ((*ptr)->type)\n+\t  {\n+\t  case FFI_TYPE_FLOAT:\n+\t    fparg_count++;\n+\t    /* floating singles are not 8-aligned on stack */\n+\t    break;\n \n-\tcase FFI_TYPE_DOUBLE:\n-\t  fparg_count++;\n-\t  /* If this FP arg is going on the stack, it must be\n-\t     8-byte-aligned.  */\n-\t  if (fparg_count > NUM_FPR_ARG_REGISTERS\n-\t      && intarg_count%2 != 0)\n-\t    intarg_count++;\n-\t  break;\n+\t  case FFI_TYPE_DOUBLE:\n+\t    fparg_count++;\n+\t    /* If this FP arg is going on the stack, it must be\n+\t       8-byte-aligned.  */\n+\t    if (fparg_count > NUM_FPR_ARG_REGISTERS\n+\t\t&& intarg_count%2 != 0)\n+\t      intarg_count++;\n+\t    break;\n \n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_SINT64:\n-\t  /* 'long long' arguments are passed as two words, but\n-\t     either both words must fit in registers or both go\n-\t     on the stack.  If they go on the stack, they must\n-\t     be 8-byte-aligned.  */\n-\t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n-\t      || intarg_count >= NUM_GPR_ARG_REGISTERS && intarg_count%2 != 0)\n+\t  case FFI_TYPE_UINT64:\n+\t  case FFI_TYPE_SINT64:\n+\t    /* 'long long' arguments are passed as two words, but\n+\t       either both words must fit in registers or both go\n+\t       on the stack.  If they go on the stack, they must\n+\t       be 8-byte-aligned.  */\n+\t    if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n+\t\t|| (intarg_count >= NUM_GPR_ARG_REGISTERS\n+\t\t    && intarg_count%2 != 0))\n+\t      intarg_count++;\n+\t    intarg_count += 2;\n+\t    break;\n+\n+\t  case FFI_TYPE_STRUCT:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t  case FFI_TYPE_LONGDOUBLE:\n+#endif\n+\t    /* We must allocate space for a copy of these to enforce\n+\t       pass-by-value.  Pad the space up to a multiple of 16\n+\t       bytes (the maximum alignment required for anything under\n+\t       the SYSV ABI).  */\n+\t    struct_copy_size += ((*ptr)->size + 15) & ~0xF;\n+\t    /* Fall through (allocate space for the pointer).  */\n+\n+\t  default:\n+\t    /* Everything else is passed as a 4-byte word in a GPR, either\n+\t       the object itself or a pointer to it.  */\n \t    intarg_count++;\n-\t  intarg_count += 2;\n-\t  break;\n+\t    break;\n+\t  }\n+      }\n+  else\n+    for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n+      {\n+\tswitch ((*ptr)->type)\n+\t  {\n+\t  case FFI_TYPE_FLOAT:\n+\t  case FFI_TYPE_DOUBLE:\n+\t    fparg_count++;\n+\t    intarg_count++;\n+\t    break;\n \n-\tcase FFI_TYPE_STRUCT:\n+\t  case FFI_TYPE_STRUCT:\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n+\t  case FFI_TYPE_LONGDOUBLE:\n #endif\n-\t  /* We must allocate space for a copy of these to enforce\n-\t     pass-by-value.  Pad the space up to a multiple of 16\n-\t     bytes (the maximum alignment required for anything under\n-\t     the SYSV ABI).  */\n-\t  struct_copy_size += ((*ptr)->size + 15) & ~0xF;\n-\t  /* Fall through (allocate space for the pointer).  */\n+\t    intarg_count += ((*ptr)->size + 7) & ~7;\n+\t    break;\n \n-\tdefault:\n-\t  /* Everything else is passed as a 4-byte word in a GPR, either\n-\t     the object itself or a pointer to it.  */\n-\t  intarg_count++;\n-\t  break;\n-\t}\n-    }\n+\t  default:\n+\t    /* Everything else is passed as a 8-byte word in a GPR, either\n+\t       the object itself or a pointer to it.  */\n+\t    intarg_count++;\n+\t    break;\n+\t  }\n+      }\n \n   if (fparg_count != 0)\n     flags |= FLAG_FP_ARGUMENTS;\n   if (intarg_count > 4)\n     flags |= FLAG_4_GPR_ARGUMENTS;\n   if (struct_copy_size != 0)\n     flags |= FLAG_ARG_NEEDS_COPY;\n-  \n-  /* Space for the FPR registers, if needed.  */\n-  if (fparg_count != 0)\n-    bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n \n-  /* Stack space.  */\n-  if (intarg_count > NUM_GPR_ARG_REGISTERS)\n-    bytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof(int);\n-  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-    bytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof(double);\n+  if (cif->abi != FFI_LINUX64)\n+    {\n+      /* Space for the FPR registers, if needed.  */\n+      if (fparg_count != 0)\n+\tbytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n+\n+      /* Stack space.  */\n+      if (intarg_count > NUM_GPR_ARG_REGISTERS)\n+\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof(int);\n+      if (fparg_count > NUM_FPR_ARG_REGISTERS)\n+\tbytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof(double);\n+    }\n+  else\n+    {\n+      /* Space for the FPR registers, if needed.  */\n+      if (fparg_count != 0)\n+\tbytes += NUM_FPR_ARG_REGISTERS64 * sizeof(double);\n+\n+      /* Stack space.  */\n+      if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n+\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof(long);\n+    }\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n   bytes = (bytes + 15) & ~0xF;\n@@ -408,6 +651,10 @@ extern void ffi_call_SYSV(/*@out@*/ extended_cif *,\n \t\t\t  unsigned, unsigned, \n \t\t\t  /*@out@*/ unsigned *, \n \t\t\t  void (*fn)());\n+extern void hidden ffi_call_LINUX64(/*@out@*/ extended_cif *, \n+\t\t\t\t    unsigned long, unsigned long,\n+\t\t\t\t    /*@out@*/ unsigned long *, \n+\t\t\t\t    void (*fn)());\n /*@=declundef@*/\n /*@=exportheader@*/\n \n@@ -437,28 +684,61 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   \n   switch (cif->abi) \n     {\n+#ifndef POWERPC64\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n       /*@-usedef@*/\n       ffi_call_SYSV(&ecif, -cif->bytes, \n \t\t    cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n+#else\n+    case FFI_LINUX64:\n+      /*@-usedef@*/\n+      ffi_call_LINUX64(&ecif, -(long) cif->bytes,\n+\t\t       cif->flags, ecif.rvalue, fn);\n+      /*@=usedef@*/\n+      break;\n+#endif\n     default:\n       FFI_ASSERT(0);\n       break;\n     }\n }\n \n \n+#ifndef POWERPC64\n static void flush_icache(char *, int);\n \n+#define MIN_CACHE_LINE_SIZE 8\n+\n+static void flush_icache(char * addr1, int size)\n+{\n+  int i;\n+  char * addr;\n+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE) {\n+     addr = addr1 + i;\n+     __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" : : \"r\"(addr) : \"memory\");\n+  }\n+  addr = addr1 + size - 1;\n+  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\" : : \"r\"(addr) : \"memory\");\n+}\n+#endif\n+\n ffi_status\n ffi_prep_closure (ffi_closure* closure,\n \t\t  ffi_cif* cif,\n \t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n \t\t  void *user_data)\n {\n+#ifdef POWERPC64\n+  void **tramp = (void **) &closure->tramp[0];\n+\n+  FFI_ASSERT (cif->abi == FFI_LINUX64);\n+  /* Copy function address and TOC from ffi_closure_LINUX64.  */\n+  memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n+  tramp[2] = (void *) closure;\n+#else\n   unsigned int *tramp;\n \n   FFI_ASSERT (cif->abi == FFI_GCC_SYSV);\n@@ -475,34 +755,25 @@ ffi_prep_closure (ffi_closure* closure,\n   *(void **) &tramp[2] = (void *)ffi_closure_SYSV; /* function */\n   *(void **) &tramp[3] = (void *)closure;          /* context */\n \n+  /* Flush the icache.  */\n+  flush_icache(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n+#endif\n+\n   closure->cif = cif;\n   closure->fun = fun;\n   closure->user_data = user_data;\n \n-  /* Flush the icache.  */\n-  flush_icache(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n-\n   return FFI_OK;\n }\n \n-\n-#define MIN_CACHE_LINE_SIZE 8\n-\n-static void flush_icache(char * addr1, int size)\n+typedef union\n {\n-  int i;\n-  char * addr;\n-  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE) {\n-     addr = addr1 + i;\n-     __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" : : \"r\"(addr) : \"memory\");\n-  }\n-  addr = addr1 + size - 1;\n-  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\" : : \"r\"(addr) : \"memory\");\n-}\n-\n+  float f;\n+  double d;\n+} ffi_dblfl;\n \n int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*, \n-                                     unsigned long*, unsigned long*);\n+\t\t\t     ffi_dblfl*, unsigned long*);\n \n /* Basically the trampoline invokes ffi_closure_SYSV, and on \n  * entry, r11 holds the address of the closure.\n@@ -514,7 +785,7 @@ int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*,\n \n int\n ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue, \n-            unsigned long * pgr, unsigned long * pfr, \n+            unsigned long * pgr, ffi_dblfl * pfr, \n             unsigned long * pst)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n@@ -540,7 +811,7 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n      returns the data directly to the caller.  */\n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n-      rvalue = *pgr;\n+      rvalue = (void *) *pgr;\n       ng++;\n       pgr++;\n     }\n@@ -631,11 +902,11 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n           /* there are 8 64bit floating point registers */\n \n           if (nf < 8) {\n-             temp = *(double*)pfr;\n-             *(float*)pfr = (float)temp;\n+             temp = pfr->d;\n+             pfr->f = (float)temp;\n              avalue[i] = pfr;\n              nf++;\n-             pfr+=2;\n+             pfr++;\n           } else {\n \t    /* FIXME? here we are really changing the values\n              * stored in the original calling routines outgoing\n@@ -655,7 +926,7 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n           if (nf < 8) {\n \t     avalue[i] = pfr;\n              nf++;\n-             pfr+=2;\n+             pfr++;\n           } else {\n \t     if (((long)pst) & 4) pst++;\n \t     avalue[i] = pst;\n@@ -674,12 +945,148 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n-  /* Tell ffi_closure_osf how to perform return type promotions.  */\n+  /* Tell ffi_closure_SYSV how to perform return type promotions.  */\n   return cif->rtype->type;\n \n }\n \n+int hidden ffi_closure_helper_LINUX64 (ffi_closure*, void*, unsigned long*,\n+\t\t\t\t       ffi_dblfl*);\n \n+int hidden\n+ffi_closure_helper_LINUX64 (ffi_closure* closure, void * rvalue, \n+            unsigned long * pst, ffi_dblfl * pfr)\n+{\n+  /* rvalue is the pointer to space for return value in closure assembly */\n+  /* pst is the pointer to parameter save area\n+     (r3-r10 are stored into its first 8 slots by ffi_closure_LINUX64) */\n+  /* pfr is the pointer to where f1-f13 are stored in ffi_closure_LINUX64 */\n+\n+  void **          avalue;\n+  ffi_type **      arg_types;\n+  long             i, avn;\n+  long             nf;   /* number of floating registers already used */\n+  long             ng;   /* number of general registers already used */\n+  ffi_cif *        cif; \n+  double           temp; \n \n+  cif = closure->cif;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n \n+  nf = 0;\n+  ng = 0;\n \n+  /* Copy the caller's structure return value address so that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = (void *) *pst;\n+      ng++;\n+      pst++;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+  \n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n+    {\n+      switch (arg_types[i]->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\t  avalue[i] = (char *) pst + 7;\n+\t  ng++;\n+\t  pst++;\n+\t  break;\n+           \n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\t  avalue[i] = (char *) pst + 6;\n+\t  ng++;\n+\t  pst++;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\t  avalue[i] = (char *) pst + 4;\n+\t  ng++;\n+\t  pst++;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = pst;\n+\t  ng++;\n+\t  pst++;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+#endif\n+\t  /* Structures with 1, 2 and 4 byte sizes are passed left-padded\n+\t     if they are in the first 8 arguments.  */\n+\t  if (ng < NUM_GPR_ARG_REGISTERS64\n+\t      && arg_types[i]->size < 8\n+\t      && ((arg_types[i]->size & ~(arg_types[i]->size - 1))\n+\t\t  == arg_types[i]->size))\n+\t    avalue[i] = (char *) pst + 8 - arg_types[i]->size;\n+\t  else\n+\t    avalue[i] = pst;\n+\t  ng += (arg_types[i]->size + 7) / 8;\n+\t  pst += (arg_types[i]->size + 7) / 8;\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  /* unfortunately float values are stored as doubles\n+           * in the ffi_closure_LINUX64 code (since we don't check\n+           * the type in that routine).\n+           */\n+\n+          /* there are 13 64bit floating point registers */\n+\n+          if (nf < NUM_FPR_ARG_REGISTERS64) {\n+             temp = pfr->d;\n+             pfr->f = (float)temp;\n+             avalue[i] = pfr;\n+             pfr++;\n+          } else {\n+\t     avalue[i] = pst;\n+          }\n+          nf++;\n+\t  ng++;\n+\t  pst++;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  /* On the outgoing stack all values are aligned to 8 */\n+          /* there are 13 64bit floating point registers */\n+\n+          if (nf < NUM_FPR_ARG_REGISTERS64) {\n+\t     avalue[i] = pfr;\n+             pfr++;\n+          } else {\n+\t     avalue[i] = pst;\n+          }\n+          nf++;\n+\t  ng++;\n+\t  pst++;\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      i++;\n+    }\n+\n+\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n+  return cif->rtype->type;\n+\n+}"}, {"sha": "9619c5392235331d35f45dff5bd549653aca546c", "filename": "libffi/src/powerpc/linux64.S", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -0,0 +1,185 @@\n+/* -----------------------------------------------------------------------\n+   sysv.h - Copyright (c) 2003 Jakub Jelinek <jakub@redhat.com>\n+   \n+   PowerPC64 Assembly glue.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\t\n+#include <ffi.h>\n+\n+#ifdef __powerpc64__\n+\t.hidden\tffi_call_LINUX64, .ffi_call_LINUX64\n+\t.globl\tffi_call_LINUX64, .ffi_call_LINUX64\n+\t.section\t\".opd\",\"aw\"\n+\t.align\t3\n+ffi_call_LINUX64:\n+\t.quad\t.ffi_call_LINUX64,.TOC.@tocbase,0\n+\t.size\tffi_call_LINUX64,24\n+\t.type\t.ffi_call_LINUX64,@function\n+\t.text\n+.ffi_call_LINUX64:\n+.LFB1:\n+\tmflr\t%r0\n+\tstd\t%r28, -32(%r1)\n+\tstd\t%r29, -24(%r1)\n+\tstd\t%r30, -16(%r1)\n+\tstd\t%r31, -8(%r1)\n+\tstd\t%r0, 16(%r1)\n+\n+\tmr\t%r28, %r1\t/* our AP.  */\n+\tstdux\t%r1, %r1, %r4\n+.LCFI0:\n+\tmr\t%r31, %r5\t/* flags, */\n+\tmr\t%r30, %r6\t/* rvalue, */\n+\tmr\t%r29, %r7\t/* function address.  */\n+\tstd\t%r2, 40(%r1)\n+\n+\t/* Call ffi_prep_args64.  */\n+\tmr\t%r4, %r1\n+\tbl\t.ffi_prep_args64\n+\n+\tld\t%r0, 0(%r29)\n+\tld\t%r2, 8(%r29)\n+\tld\t%r11, 16(%r29)\n+\n+\t/* Now do the call.  */\n+\t/* Set up cr1 with bits 4-7 of the flags.  */\n+\tmtcrf\t0x40, %r31\n+\n+\t/* Get the address to call into CTR.  */\n+\tmtctr\t%r0\n+\t/* Load all those argument registers.  */\n+\tld\t%r3, -32-(8*8)(%r28)\n+\tld\t%r4, -32-(7*8)(%r28)\n+\tld\t%r5, -32-(6*8)(%r28)\n+\tld\t%r6, -32-(5*8)(%r28)\n+\tbf-\t5, 1f\n+\tld\t%r7, -32-(4*4)(%r28)\n+\tld\t%r8, -32-(3*4)(%r28)\n+\tld\t%r9, -32-(2*4)(%r28)\n+\tld\t%r10, -32-(1*4)(%r28)\n+1:\n+\n+\t/* Load all the FP registers.  */\n+\tbf-\t6, 2f\n+\tlfd\t%f1, -32-(21*8)(%r28)\n+\tlfd\t%f2, -32-(20*8)(%r28)\n+\tlfd\t%f3, -32-(19*8)(%r28)\n+\tlfd\t%f4, -32-(18*8)(%r28)\n+\tlfd\t%f5, -32-(17*8)(%r28)\n+\tlfd\t%f6, -32-(16*8)(%r28)\n+\tlfd\t%f7, -32-(15*8)(%r28)\n+\tlfd\t%f8, -32-(14*8)(%r28)\n+\tlfd\t%f9, -32-(13*8)(%r28)\n+\tlfd\t%f10, -32-(12*8)(%r28)\n+\tlfd\t%f11, -32-(11*8)(%r28)\n+\tlfd\t%f12, -32-(10*8)(%r28)\n+\tlfd\t%f13, -32-(9*8)(%r28)\n+2:\n+\t/* FIXME: Shouldn't gcc use %r3-%r10 in this case\n+\t   and not the parm save area?  */\n+\tstd\t%r3, 48+(0*8)(%r1)\n+\tstd\t%r4, 48+(1*8)(%r1)\n+\tstd\t%r5, 48+(2*8)(%r1)\n+\tstd\t%r6, 48+(3*8)(%r1)\n+\tstd\t%r7, 48+(4*8)(%r1)\n+\tstd\t%r8, 48+(5*8)(%r1)\n+\tstd\t%r9, 48+(6*8)(%r1)\n+\tstd\t%r10, 48+(7*8)(%r1)\n+\t/* end of FIXME.  */\n+\n+\t/* Make the call.  */\n+\tbctrl\n+\n+\t/* Now, deal with the return value.  */\n+\tmtcrf\t0x01, %r31\n+\tbt-\t30, .Ldone_return_value\n+\tbt-\t29, .Lfp_return_value\n+\tstd\t%r3, 0(%r30)\n+\t/* Fall through...  */\n+\n+.Ldone_return_value:\n+\t/* Restore the registers we used and return.  */\n+\tld\t%r2, 40(%r1)\n+\tmr\t%r1, %r28\n+\tld\t%r0, 16(%r28)\n+\tld\t%r28, -32(%r1)\n+\tmtlr\t%r0\n+\tld\t%r29, -24(%r1)\n+\tld\t%r30, -16(%r1)\n+\tld\t%r31, -8(%r1)\n+\tblr\n+\n+.Lfp_return_value:\n+\tbf\t28, .Lfloat_return_value\n+\tstfd\t%f1, 0(%r30)\n+\tb\t.Ldone_return_value\n+.Lfloat_return_value:\n+\tstfs\t%f1, 0(%r30)\n+\tb\t.Ldone_return_value\n+.LFE1:\n+\t.long\t0\n+\t.byte\t0,12,0,1,128,4,0,0\n+\t.size\t.ffi_call_LINUX64,.-.ffi_call_LINUX64\n+\n+\t.section\t.eh_frame,\"aw\",@progbits\n+.Lframe1:\n+\t.4byte\t.LECIE1-.LSCIE1\t # Length of Common Information Entry\n+.LSCIE1:\n+\t.4byte\t0x0\t # CIE Identifier Tag\n+\t.byte\t0x1\t # CIE Version\n+\t.ascii \"zR\\0\"\t # CIE Augmentation\n+\t.uleb128 0x1\t # CIE Code Alignment Factor\n+\t.sleb128 -8\t # CIE Data Alignment Factor\n+\t.byte\t0x41\t # CIE RA Column\n+\t.uleb128 0x1\t # Augmentation size\n+\t.byte\t0x14\t # FDE Encoding (pcrel udata8)\n+\t.byte\t0xc\t # DW_CFA_def_cfa\n+\t.uleb128 0x1\n+\t.uleb128 0x0\n+\t.align 3\n+.LECIE1:\n+.LSFDE1:\n+\t.4byte\t.LEFDE1-.LASFDE1\t # FDE Length\n+.LASFDE1:\n+\t.4byte\t.LASFDE1-.Lframe1\t # FDE CIE offset\n+\t.8byte\t.LFB1-.\t # FDE initial location\n+\t.8byte\t.LFE1-.LFB1\t # FDE address range\n+\t.uleb128 0x0\t # Augmentation size\n+\t.byte\t0x2\t # DW_CFA_advance_loc1\n+\t.byte\t.LCFI0-.LFB1\n+\t.byte\t0xd\t # DW_CFA_def_cfa_register\n+\t.uleb128 0x1c\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x41\n+\t.sleb128 -2\n+\t.byte\t0x9f\t # DW_CFA_offset, column 0x1f\n+\t.uleb128 0x1\n+\t.byte\t0x9e\t # DW_CFA_offset, column 0x1e\n+\t.uleb128 0x2\n+\t.byte\t0x9d\t # DW_CFA_offset, column 0x1d\n+\t.uleb128 0x3\n+\t.byte\t0x9c\t # DW_CFA_offset, column 0x1c\n+\t.uleb128 0x4\n+\t.align 3\n+.LEFDE1:\n+#endif"}, {"sha": "d435e584fd538bbdd3d153384072757c39f52727", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -0,0 +1,210 @@\n+\t.file\t\"linux64_closure.S\"\n+\n+#ifdef __powerpc64__\n+        .hidden ffi_closure_LINUX64, .ffi_closure_LINUX64\n+        .globl  ffi_closure_LINUX64, .ffi_closure_LINUX64\n+        .section        \".opd\",\"aw\"\n+        .align  3\n+ffi_closure_LINUX64:\n+        .quad   .ffi_closure_LINUX64,.TOC.@tocbase,0\n+        .size   ffi_closure_LINUX64,24\n+        .type   .ffi_closure_LINUX64,@function\n+        .text\n+.ffi_closure_LINUX64:\n+.LFB1:\n+\t# save general regs into parm save area\n+\tstd\t%r3, 48(%r1)\n+\tstd\t%r4, 56(%r1)\n+\tstd\t%r5, 64(%r1)\n+\tstd\t%r6, 72(%r1)\n+\tmflr\t%r0\n+\n+\tstd\t%r7, 80(%r1)\n+\tstd\t%r8, 88(%r1)\n+\tstd\t%r9, 96(%r1)\n+\tstd\t%r10, 104(%r1)\n+\tstd\t%r0, 16(%r1)\n+\n+\t# mandatory 48 bytes special reg save area + 64 bytes parm save area\n+\t# + 8 bytes retval area + 13*8 bytes fpr save area\n+\tstdu\t%r1, -224(%r1)\n+.LCFI0:\n+\n+\t# next save fpr 1 to fpr 13\n+\tstfd  %f1, 120+(0*8)(%r1)\n+\tstfd  %f2, 120+(1*8)(%r1)\n+\tstfd  %f3, 120+(2*8)(%r1)\n+\tstfd  %f4, 120+(3*8)(%r1)\n+\tstfd  %f5, 120+(4*8)(%r1)\n+\tstfd  %f6, 120+(5*8)(%r1)\n+\tstfd  %f7, 120+(6*8)(%r1)\n+\tstfd  %f8, 120+(7*8)(%r1)\n+\tstfd  %f9, 120+(8*8)(%r1)\n+\tstfd  %f10, 120+(9*8)(%r1)\n+\tstfd  %f11, 120+(10*8)(%r1)\n+\tstfd  %f12, 120+(11*8)(%r1)\n+\tstfd  %f13, 120+(12*8)(%r1)\n+\n+\t# set up registers for the routine that actually does the work\n+\t# get the context pointer from the trampoline\n+\tmr %r3, %r11\n+\n+\t# now load up the pointer to the result storage\n+\taddi %r4, %r1, 112\n+\n+\t# now load up the pointer to the parameter save area\n+\t# in the previous frame\n+\taddi %r5, %r1, 224 + 48\n+\n+\t# now load up the pointer to the saved fpr registers */\n+\taddi %r6, %r1, 120\n+\n+\t# make the call\n+\tbl .ffi_closure_helper_LINUX64\n+\n+\t# now r3 contains the return type\n+\t# so use it to look up in a table\n+\t# so we know how to deal with each type\n+\n+\t# look up the proper starting point in table \n+\t# by using return type as offset\n+\taddi %r5, %r1, 112\t# get pointer to results area\n+\tbl .Lget_ret_type0_addr # get pointer to .Lret_type0 into LR\n+\tmflr %r4\t\t# move to r4\n+\tsldi %r3, %r3, 4\t# now multiply return type by 16\n+\tadd %r3, %r3, %r4\t# add contents of table to table address\n+\tmtctr %r3\n+\tbctr\t\t\t# jump to it\n+\n+# Each of the ret_typeX code fragments has to be exactly 16 bytes long\n+# (4 instructions). For cache effectiveness we align to a 16 byte boundary\n+# first.\n+\t.align 4\n+\n+\tnop\n+\tnop\n+\tnop\n+.Lget_ret_type0_addr:\n+\tblrl\n+\n+.Lret_type0:\n+# case FFI_TYPE_VOID\n+\tb .Lfinish\n+\tnop\n+\tnop\n+\tnop\n+# case FFI_TYPE_INT\n+\tlwa %r3, 4(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_FLOAT\n+\tlfs %f1, 4(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_DOUBLE\n+\tlfd %f1, 0(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_LONGDOUBLE\n+\tlfd %f1, 0(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_UINT8\n+\tlbz %r3, 7(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_SINT8\n+\tlbz %r3, 7(%r5)\n+\textsb %r3,%r3\n+\tb .Lfinish\n+\tnop\n+# case FFI_TYPE_UINT16\n+\tlhz %r3, 6(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_SINT16\n+\tlha %r3, 6(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_UINT32\n+\tlwz %r3, 4(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_SINT32\n+\tlwa %r3, 4(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_UINT64\n+\tld %r3, 0(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_SINT64\n+\tld %r3, 0(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# case FFI_TYPE_STRUCT\n+\tb .Lfinish\n+\tnop\n+\tnop\n+\tnop\n+# case FFI_TYPE_POINTER\n+\tld %r3, 0(%r5)\n+\tb .Lfinish\n+\tnop\n+\tnop\n+# esac\n+.Lfinish:\n+\tld %r0, 224+16(%r1)\n+\tmtlr %r0\n+\taddi %r1, %r1, 224\n+\tblr\n+.LFE1:\n+\t.long\t0\n+\t.byte\t0,12,0,1,128,0,0,0\n+\t.size\t.ffi_closure_LINUX64,.-.ffi_closure_LINUX64\n+\n+\t.section\t.eh_frame,\"aw\",@progbits\n+.Lframe1:\n+\t.4byte\t.LECIE1-.LSCIE1\t # Length of Common Information Entry\n+.LSCIE1:\n+\t.4byte\t0x0\t # CIE Identifier Tag\n+\t.byte\t0x1\t # CIE Version\n+\t.ascii \"zR\\0\"\t # CIE Augmentation\n+\t.uleb128 0x1\t # CIE Code Alignment Factor\n+\t.sleb128 -8\t # CIE Data Alignment Factor\n+\t.byte\t0x41\t # CIE RA Column\n+\t.uleb128 0x1\t # Augmentation size\n+\t.byte\t0x14\t # FDE Encoding (pcrel udata8)\n+\t.byte\t0xc\t # DW_CFA_def_cfa\n+\t.uleb128 0x1\n+\t.uleb128 0x0\n+\t.align 3\n+.LECIE1:\n+.LSFDE1:\n+\t.4byte\t.LEFDE1-.LASFDE1\t # FDE Length\n+.LASFDE1:\n+\t.4byte\t.LASFDE1-.Lframe1\t # FDE CIE offset\n+\t.8byte\t.LFB1-.\t # FDE initial location\n+\t.8byte\t.LFE1-.LFB1\t # FDE address range\n+\t.uleb128 0x0\t # Augmentation size\n+\t.byte\t0x2\t # DW_CFA_advance_loc1\n+\t.byte\t.LCFI0-.LFB1\n+\t.byte\t0xe\t # DW_CFA_def_cfa_offset\n+\t.uleb128 224\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x41\n+\t.sleb128 -2\n+\t.align 3\n+.LEFDE1:\n+#endif"}, {"sha": "4cfc8fda5ad9c6e08228b95f50c767b84cf338a8", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -3,6 +3,8 @@\n \n         .file   \"ppc_closure.S\"\n \n+#ifndef __powerpc64__\n+\n ENTRY(ffi_closure_SYSV)\n .LFB1:\n \tstwu %r1,-144(%r1)\n@@ -227,3 +229,5 @@ __FRAME_BEGIN__:\n \t.byte\t0x1\t # uleb128 0x1\n \t.align 2\n .LEFDE1:\n+\n+#endif"}, {"sha": "c1e0d18461c0e87ac22ccc3dcf0615e28c0bace4", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=e9b841813c04b7b9ee9d2b30d8fff494ac4aacbf", "patch": "@@ -29,7 +29,8 @@\n #include <ffi.h>\n #include <powerpc/asm.h>\n \n-\t.globl ffi_prep_args\n+#ifndef __powerpc64__\n+\t.globl ffi_prep_args_SYSV\n ENTRY(ffi_call_SYSV)\n .LFB1:\n \t/* Save the old stack pointer as AP.  */\n@@ -58,9 +59,9 @@ ENTRY(ffi_call_SYSV)\n \tmr\t%r28,%r8\t/* our AP. */\n .LCFI6:\n \n-\t/* Call ffi_prep_args.  */\n+\t/* Call ffi_prep_args_SYSV.  */\n \tmr\t%r4,%r1\n-\tbl\tJUMPTARGET(ffi_prep_args)\n+\tbl\tJUMPTARGET(ffi_prep_args_SYSV)\n \n \t/* Now do the call.  */\n \t/* Set up cr1 with bits 4-7 of the flags.  */\n@@ -171,3 +172,4 @@ __FRAME_BEGIN__:\n       .byte     0x1c     /*  uleb128 0x1c */\n       .align 2\n .LEFDE1:\n+#endif"}]}