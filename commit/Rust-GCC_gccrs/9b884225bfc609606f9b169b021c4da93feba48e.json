{"sha": "9b884225bfc609606f9b169b021c4da93feba48e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI4ODQyMjViZmM2MDk2MDZmOWIxNjliMDIxYzRkYTkzZmViYTQ4ZQ==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2019-06-13T03:34:28Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2019-06-13T03:34:28Z"}, "message": "re PR target/88838 ([SVE] Use 32-bit WHILELO in LP64 mode)\n\n\ngcc/ChangeLog:\n\n2019-06-13  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n\n\tPR target/88838\n\t* tree-vect-loop-manip.c (vect_set_loop_masks_directly): If the\n\tcompare_type is not with Pmode size, we will create an IV with\n\tPmode size with truncated use (i.e. converted to the correct type).\n\t* tree-vect-loop.c (vect_verify_full_masking): Find IV type.\n\t(vect_iv_limit_for_full_masking): New. Factored out of\n\tvect_set_loop_condition_masked.\n\t* tree-vectorizer.h (LOOP_VINFO_MASK_IV_TYPE): New.\n\t(vect_iv_limit_for_full_masking): Declare.\n\ngcc/testsuite/ChangeLog:\n\n2019-06-13  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n\n\tPR target/88838\n\t* gcc.target/aarch64/pr88838.c: New test.\n\t* gcc.target/aarch64/sve/while_1.c: Adjust.\n\nFrom-SVN: r272233", "tree": {"sha": "28c9e494f42ea0d6f529cb8033d031f8f2b46f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28c9e494f42ea0d6f529cb8033d031f8f2b46f04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b884225bfc609606f9b169b021c4da93feba48e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b884225bfc609606f9b169b021c4da93feba48e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b884225bfc609606f9b169b021c4da93feba48e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b884225bfc609606f9b169b021c4da93feba48e/comments", "author": null, "committer": null, "parents": [{"sha": "fa9863e7d34ecd011ae75083be2ae124e5831b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9863e7d34ecd011ae75083be2ae124e5831b64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9863e7d34ecd011ae75083be2ae124e5831b64"}], "stats": {"total": 182, "additions": 138, "deletions": 44}, "files": [{"sha": "079379e45dc3dab842ce98a5fa8623579611c9a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -1,3 +1,15 @@\n+2019-06-13  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n+\n+\tPR target/88838\n+\t* tree-vect-loop-manip.c (vect_set_loop_masks_directly): If the\n+\tcompare_type is not with Pmode size, we will create an IV with\n+\tPmode size with truncated use (i.e. converted to the correct type).\n+\t* tree-vect-loop.c (vect_verify_full_masking): Find IV type.\n+\t(vect_iv_limit_for_full_masking): New. Factored out of\n+\tvect_set_loop_condition_masked.\n+\t* tree-vectorizer.h (LOOP_VINFO_MASK_IV_TYPE): New.\n+\t(vect_iv_limit_for_full_masking): Declare.\n+\n 2019-06-13  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \n \tPR target/88834"}, {"sha": "7212c6be52577e3f916e5e9f0d8f3634d61798c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -1,3 +1,9 @@\n+2019-06-13  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n+\n+\tPR target/88838\n+\t* gcc.target/aarch64/pr88838.c: New test.\n+\t* gcc.target/aarch64/sve/while_1.c: Adjust.\n+\n 2019-06-13  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \n \tPR target/88834"}, {"sha": "d7db84758acc81545c2e63952c4f229e55abd9b1", "filename": "gcc/testsuite/gcc.target/aarch64/pr88838.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr88838.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr88838.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr88838.c?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-S -O3 -march=armv8.2-a+sve\" } */\n+\n+void\n+f (int *restrict x, int *restrict y, int *restrict z, int n)\n+{\n+    for (int i = 0; i < n; i += 1)\n+          x[i] = y[i] + z[i];\n+}\n+\n+/* { dg-final { scan-assembler-not \"sxtw\" } } */"}, {"sha": "05a486012210f1c3a9be8e254fe9f09938d03b34", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -26,14 +26,14 @@\n TEST_ALL (ADD_LOOP)\n \n /* { dg-final { scan-assembler-not {\\tuqdec} } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, xzr,} 2 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, x[0-9]+,} 2 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, xzr,} 2 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, x[0-9]+,} 2 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, xzr,} 3 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, wzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, w[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, wzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, w[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, wzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, w[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, wzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, w[0-9]+,} 3 } } */\n /* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]/z, \\[x0, x[0-9]+\\]\\n} 2 } } */\n /* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7], \\[x0, x[0-9]+\\]\\n} 2 } } */\n /* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x0, x[0-9]+, lsl 1\\]\\n} 2 } } */"}, {"sha": "a0a1bee9408e4f4483ecea6d4a17c4677c5042e5", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -415,6 +415,7 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n \t\t\t      bool might_wrap_p)\n {\n   tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n+  tree iv_type = LOOP_VINFO_MASK_IV_TYPE (loop_vinfo);\n   tree mask_type = rgm->mask_type;\n   unsigned int nscalars_per_iter = rgm->max_nscalars_per_iter;\n   poly_uint64 nscalars_per_mask = TYPE_VECTOR_SUBPARTS (mask_type);\n@@ -445,11 +446,16 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n   tree index_before_incr, index_after_incr;\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n-  tree zero_index = build_int_cst (compare_type, 0);\n   standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n-  create_iv (zero_index, nscalars_step, NULL_TREE, loop, &incr_gsi,\n+\n+  tree zero_index = build_int_cst (iv_type, 0);\n+  tree step = build_int_cst (iv_type,\n+\t\t\t     LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  /* Create IV of iv_type.  */\n+  create_iv (zero_index, step, NULL_TREE, loop, &incr_gsi,\n \t     insert_after, &index_before_incr, &index_after_incr);\n \n+  zero_index = build_int_cst (compare_type, 0);\n   tree test_index, test_limit, first_limit;\n   gimple_stmt_iterator *test_gsi;\n   if (might_wrap_p)\n@@ -529,6 +535,10 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n   tree next_mask = NULL_TREE;\n   tree mask;\n   unsigned int i;\n+  gimple_seq test_seq = NULL;\n+  test_index = gimple_convert (&test_seq, compare_type, test_index);\n+  gsi_insert_seq_before (test_gsi, test_seq, GSI_SAME_STMT);\n+\n   FOR_EACH_VEC_ELT_REVERSE (rgm->masks, i, mask)\n     {\n       /* Previous masks will cover BIAS scalars.  This mask covers the\n@@ -637,12 +647,12 @@ vect_set_loop_condition_masked (struct loop *loop, loop_vec_info loop_vinfo,\n \n   tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n   unsigned int compare_precision = TYPE_PRECISION (compare_type);\n-  unsigned HOST_WIDE_INT max_vf = vect_max_vf (loop_vinfo);\n   tree orig_niters = niters;\n \n   /* Type of the initial value of NITERS.  */\n   tree ni_actual_type = TREE_TYPE (niters);\n   unsigned int ni_actual_precision = TYPE_PRECISION (ni_actual_type);\n+  tree niters_skip = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n \n   /* Convert NITERS to the same size as the compare.  */\n   if (compare_precision > ni_actual_precision\n@@ -661,33 +671,7 @@ vect_set_loop_condition_masked (struct loop *loop, loop_vec_info loop_vinfo,\n   else\n     niters = gimple_convert (&preheader_seq, compare_type, niters);\n \n-  /* Convert skip_niters to the right type.  */\n-  tree niters_skip = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n-\n-  /* Now calculate the value that the induction variable must be able\n-     to hit in order to ensure that we end the loop with an all-false mask.\n-     This involves adding the maximum number of inactive trailing scalar\n-     iterations.  */\n-  widest_int iv_limit;\n-  bool known_max_iters = max_loop_iterations (loop, &iv_limit);\n-  if (known_max_iters)\n-    {\n-      if (niters_skip)\n-\t{\n-\t  /* Add the maximum number of skipped iterations to the\n-\t     maximum iteration count.  */\n-\t  if (TREE_CODE (niters_skip) == INTEGER_CST)\n-\t    iv_limit += wi::to_widest (niters_skip);\n-\t  else\n-\t    iv_limit += max_vf - 1;\n-\t}\n-      /* IV_LIMIT is the maximum number of latch iterations, which is also\n-\t the maximum in-range IV value.  Round this value down to the previous\n-\t vector alignment boundary and then add an extra full iteration.  */\n-      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-      iv_limit = (iv_limit & -(int) known_alignment (vf)) + max_vf;\n-    }\n-\n+  widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n   /* Get the vectorization factor in tree form.  */\n   tree vf = build_int_cst (compare_type,\n \t\t\t   LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n@@ -717,7 +701,7 @@ vect_set_loop_condition_masked (struct loop *loop, loop_vec_info loop_vinfo,\n \t/* See whether zero-based IV would ever generate all-false masks\n \t   before wrapping around.  */\n \tbool might_wrap_p\n-\t  = (!known_max_iters\n+\t  = (iv_limit == -1\n \t     || (wi::min_precision (iv_limit * rgm->max_nscalars_per_iter,\n \t\t\t\t    UNSIGNED)\n \t\t > compare_precision));"}, {"sha": "671ef2f7658e9c20b990306c943745c8a98ee218", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -1030,6 +1030,8 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned int min_ni_width;\n+  unsigned int max_nscalars_per_iter\n+    = vect_get_max_nscalars_per_iter (loop_vinfo);\n \n   /* Use a normal loop if there are no statements that need masking.\n      This only happens in rare degenerate cases: it means that the loop\n@@ -1048,14 +1050,22 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n     max_ni = wi::smin (max_ni, max_back_edges + 1);\n \n   /* Account for rgroup masks, in which each bit is replicated N times.  */\n-  max_ni *= vect_get_max_nscalars_per_iter (loop_vinfo);\n+  max_ni *= max_nscalars_per_iter;\n \n   /* Work out how many bits we need to represent the limit.  */\n   min_ni_width = wi::min_precision (max_ni, UNSIGNED);\n \n   /* Find a scalar mode for which WHILE_ULT is supported.  */\n   opt_scalar_int_mode cmp_mode_iter;\n   tree cmp_type = NULL_TREE;\n+  tree iv_type = NULL_TREE;\n+  widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n+  widest_int iv_precision = UINT_MAX;\n+\n+  if (iv_limit != -1)\n+    iv_precision = wi::min_precision (iv_limit * max_nscalars_per_iter,\n+\t\t\t\t      UNSIGNED);\n+\n   FOR_EACH_MODE_IN_CLASS (cmp_mode_iter, MODE_INT)\n     {\n       unsigned int cmp_bits = GET_MODE_BITSIZE (cmp_mode_iter.require ());\n@@ -1067,10 +1077,32 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n \t      && can_produce_all_loop_masks_p (loop_vinfo, this_type))\n \t    {\n \t      /* Although we could stop as soon as we find a valid mode,\n-\t\t it's often better to continue until we hit Pmode, since the\n-\t\t operands to the WHILE are more likely to be reusable in\n-\t\t address calculations.  */\n-\t      cmp_type = this_type;\n+\t\t there are at least two reasons why that's not always the\n+\t\t best choice:\n+\n+\t\t - An IV that's Pmode or wider is more likely to be reusable\n+\t\t in address calculations than an IV that's narrower than\n+\t\t Pmode.\n+\n+\t\t - Doing the comparison in IV_PRECISION or wider allows\n+\t\t a natural 0-based IV, whereas using a narrower comparison\n+\t\t type requires mitigations against wrap-around.\n+\n+\t\t Conversely, if the IV limit is variable, doing the comparison\n+\t\t in a wider type than the original type can introduce\n+\t\t unnecessary extensions, so picking the widest valid mode\n+\t\t is not always a good choice either.\n+\n+\t\t Here we prefer the first IV type that's Pmode or wider,\n+\t\t and the first comparison type that's IV_PRECISION or wider.\n+\t\t (The comparison type must be no wider than the IV type,\n+\t\t to avoid extensions in the vector loop.)\n+\n+\t\t ??? We might want to try continuing beyond Pmode for ILP32\n+\t\t targets if CMP_BITS < IV_PRECISION.  */\n+\t      iv_type = this_type;\n+\t      if (!cmp_type || iv_precision > TYPE_PRECISION (cmp_type))\n+\t\tcmp_type = this_type;\n \t      if (cmp_bits >= GET_MODE_BITSIZE (Pmode))\n \t\tbreak;\n \t    }\n@@ -1081,6 +1113,7 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n     return false;\n \n   LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo) = cmp_type;\n+  LOOP_VINFO_MASK_IV_TYPE (loop_vinfo) = iv_type;\n   return true;\n }\n \n@@ -9014,3 +9047,45 @@ optimize_mask_stores (struct loop *loop)\n       add_phi_arg (phi, gimple_vuse (last_store), e, UNKNOWN_LOCATION);\n     }\n }\n+\n+/* Decide whether it is possible to use a zero-based induction variable\n+   when vectorizing LOOP_VINFO with a fully-masked loop.  If it is,\n+   return the value that the induction variable must be able to hold\n+   in order to ensure that the loop ends with an all-false mask.\n+   Return -1 otherwise.  */\n+widest_int\n+vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo)\n+{\n+  tree niters_skip = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  unsigned HOST_WIDE_INT max_vf = vect_max_vf (loop_vinfo);\n+\n+  /* Calculate the value that the induction variable must be able\n+     to hit in order to ensure that we end the loop with an all-false mask.\n+     This involves adding the maximum number of inactive trailing scalar\n+     iterations.  */\n+  widest_int iv_limit = -1;\n+  if (max_loop_iterations (loop, &iv_limit))\n+    {\n+      if (niters_skip)\n+\t{\n+\t  /* Add the maximum number of skipped iterations to the\n+\t     maximum iteration count.  */\n+\t  if (TREE_CODE (niters_skip) == INTEGER_CST)\n+\t    iv_limit += wi::to_widest (niters_skip);\n+\t  else\n+\t    iv_limit += max_vf - 1;\n+\t}\n+      else if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+\t/* Make a conservatively-correct assumption.  */\n+\tiv_limit += max_vf - 1;\n+\n+      /* IV_LIMIT is the maximum number of latch iterations, which is also\n+\t the maximum in-range IV value.  Round this value down to the previous\n+\t vector alignment boundary and then add an extra full iteration.  */\n+      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      iv_limit = (iv_limit & -(int) known_alignment (vf)) + max_vf;\n+    }\n+  return iv_limit;\n+}\n+"}, {"sha": "eb0f21f84fb4d0dca777e6724e8795227c2633f5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b884225bfc609606f9b169b021c4da93feba48e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9b884225bfc609606f9b169b021c4da93feba48e", "patch": "@@ -435,6 +435,10 @@ typedef struct _loop_vec_info : public vec_info {\n      is false and vectorized loop otherwise.  */\n   tree simd_if_cond;\n \n+  /* Type of the IV to use in the WHILE_ULT call for fully-masked\n+     loops.  */\n+  tree iv_type;\n+\n   /* Unknown DRs according to which loop was peeled.  */\n   struct dr_vec_info *unaligned_dr;\n \n@@ -570,6 +574,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_MASKS(L)                (L)->masks\n #define LOOP_VINFO_MASK_SKIP_NITERS(L)     (L)->mask_skip_niters\n #define LOOP_VINFO_MASK_COMPARE_TYPE(L)    (L)->mask_compare_type\n+#define LOOP_VINFO_MASK_IV_TYPE(L)         (L)->iv_type\n #define LOOP_VINFO_PTR_MASK(L)             (L)->ptr_mask\n #define LOOP_VINFO_LOOP_NEST(L)            (L)->shared->loop_nest\n #define LOOP_VINFO_DATAREFS(L)             (L)->shared->datarefs\n@@ -1582,6 +1587,7 @@ extern tree vect_create_addr_base_for_vector_ref (stmt_vec_info, gimple_seq *,\n /* FORNOW: Used in tree-parloops.c.  */\n extern stmt_vec_info vect_force_simple_reduction (loop_vec_info, stmt_vec_info,\n \t\t\t\t\t\t  bool *, bool);\n+extern widest_int vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo);\n /* Used in gimple-loop-interchange.c.  */\n extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);"}]}