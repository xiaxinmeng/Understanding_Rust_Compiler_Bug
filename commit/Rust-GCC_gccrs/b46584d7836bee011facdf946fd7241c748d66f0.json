{"sha": "b46584d7836bee011facdf946fd7241c748d66f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2NTg0ZDc4MzZiZWUwMTFmYWNkZjk0NmZkNzI0MWM3NDhkNjZmMA==", "commit": {"author": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-08-21T13:26:11Z"}, "committer": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-08-21T13:26:11Z"}, "message": "driver: Fix several memory leaks [PR63854]\n\nThis patch fixes several memory leaks in the driver, all of which relate\nto the handling of static specs. We introduce functions\nset_static_spec_{shared,owned}() which are used to enforce proper memory\nmanagement when updating the strings in the static_specs table.\n\nThis is achieved by making use of the alloc_p field in the table\nentries. Similarly to set_spec(), each time we update an entry, we check\nwhether alloc_p is set, and free the old value if so. We then set\nalloc_p correctly based on whether we \"own\" this memory or whether we're\njust taking a pointer to a shared string which we shouldn't free.\n\nThe following table shows the number of leaks found by AddressSanitizer\nwhen running a minimal libgccjit program on AArch64. The test program\ndoes the whole libgccjit compilation cycle in a loop (including acquiring\nand releasing the context), and the table below shows the number of leaks\nfor different iterations of that loop.\n\n+--------------+-----+-----+------+---------------+\n| # of runs >  | 1   | 2   | 3    | Leaks per run |\n+--------------+-----+-----+------+---------------+\n| Before patch | 463 | 940 | 1417 | 477           |\n+--------------+-----+-----+------+---------------+\n| After patch  | 416 | 846 | 1276 | 430           |\n+--------------+-----+-----+------+---------------+\n\ngcc/ChangeLog:\n\n\tPR jit/63854\n\t* gcc.c (set_static_spec): New.\n\t(set_static_spec_owned): New.\n\t(set_static_spec_shared): New.\n\t(driver::maybe_putenv_COLLECT_LTO_WRAPPER): Use\n\tset_static_spec_owned() to take ownership of lto_wrapper_file\n\tsuch that it gets freed in driver::finalize.\n\t(driver::maybe_run_linker): Use set_static_spec_shared() to\n\tensure that we don't try and free() the static string \"ld\",\n\talso ensuring that any previously-allocated string in\n\tlinker_name_spec is freed. Likewise with argv0.\n\t(driver::finalize): Use set_static_spec_shared() when resetting\n\tspecs that previously had allocated strings; remove if(0)\n\taround call to free().", "tree": {"sha": "c413688a720f31abff580d02f4a0accd0276ff81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c413688a720f31abff580d02f4a0accd0276ff81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b46584d7836bee011facdf946fd7241c748d66f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46584d7836bee011facdf946fd7241c748d66f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46584d7836bee011facdf946fd7241c748d66f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46584d7836bee011facdf946fd7241c748d66f0/comments", "author": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7d55c6b81733335d81e35f7c0116bbdffccb682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d55c6b81733335d81e35f7c0116bbdffccb682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d55c6b81733335d81e35f7c0116bbdffccb682"}], "stats": {"total": 60, "additions": 52, "deletions": 8}, "files": [{"sha": "a38d684f34dbcdc79436cc9ccfa2bf24dfd04839", "filename": "gcc/gcc.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46584d7836bee011facdf946fd7241c748d66f0/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46584d7836bee011facdf946fd7241c748d66f0/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=b46584d7836bee011facdf946fd7241c748d66f0", "patch": "@@ -1908,6 +1908,51 @@ init_spec (void)\n \n   specs = sl;\n }\n+\n+/* Update the entry for SPEC in the static_specs table to point to VALUE,\n+   ensuring that we free the previous value if necessary.  Set alloc_p for the\n+   entry to ALLOC_P: this determines whether we take ownership of VALUE (i.e.\n+   whether we need to free it later on).  */\n+static void\n+set_static_spec (const char **spec, const char *value, bool alloc_p)\n+{\n+  struct spec_list *sl = NULL;\n+\n+  for (unsigned i = 0; i < ARRAY_SIZE (static_specs); i++)\n+    {\n+      if (static_specs[i].ptr_spec == spec)\n+\t{\n+\t  sl = static_specs + i;\n+\t  break;\n+\t}\n+    }\n+\n+  gcc_assert (sl);\n+\n+  if (sl->alloc_p)\n+    {\n+      const char *old = *spec;\n+      free (const_cast <char *> (old));\n+    }\n+\n+  *spec = value;\n+  sl->alloc_p = alloc_p;\n+}\n+\n+/* Update a static spec to a new string, taking ownership of that\n+   string's memory.  */\n+static void set_static_spec_owned (const char **spec, const char *val)\n+{\n+  return set_static_spec (spec, val, true);\n+}\n+\n+/* Update a static spec to point to a new value, but don't take\n+   ownership of (i.e. don't free) that string.  */\n+static void set_static_spec_shared (const char **spec, const char *val)\n+{\n+  return set_static_spec (spec, val, false);\n+}\n+\n \f\n /* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is\n    removed; If the spec starts with a + then SPEC is added to the end of the\n@@ -8344,7 +8389,7 @@ driver::maybe_putenv_COLLECT_LTO_WRAPPER () const\n   if (lto_wrapper_file)\n     {\n       lto_wrapper_file = convert_white_space (lto_wrapper_file);\n-      lto_wrapper_spec = lto_wrapper_file;\n+      set_static_spec_owned (&lto_wrapper_spec, lto_wrapper_file);\n       obstack_init (&collect_obstack);\n       obstack_grow (&collect_obstack, \"COLLECT_LTO_WRAPPER=\",\n \t\t    sizeof (\"COLLECT_LTO_WRAPPER=\") - 1);\n@@ -8851,7 +8896,7 @@ driver::maybe_run_linker (const char *argv0) const\n \t    {\n \t      char *s = find_a_file (&exec_prefixes, \"collect2\", X_OK, false);\n \t      if (s == NULL)\n-\t\tlinker_name_spec = \"ld\";\n+\t\tset_static_spec_shared (&linker_name_spec, \"ld\");\n \t    }\n \n #if HAVE_LTO_PLUGIN > 0\n@@ -8875,7 +8920,7 @@ driver::maybe_run_linker (const char *argv0) const\n \t      linker_plugin_file_spec = convert_white_space (temp_spec);\n \t    }\n #endif\n-\t  lto_gcc_spec = argv0;\n+\t  set_static_spec_shared (&lto_gcc_spec, argv0);\n \t}\n \n       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n@@ -10817,9 +10862,9 @@ driver::finalize ()\n   just_machine_suffix = 0;\n   gcc_exec_prefix = 0;\n   gcc_libexec_prefix = 0;\n-  md_exec_prefix = MD_EXEC_PREFIX;\n-  md_startfile_prefix = MD_STARTFILE_PREFIX;\n-  md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;\n+  set_static_spec_shared (&md_exec_prefix, MD_EXEC_PREFIX);\n+  set_static_spec_shared (&md_startfile_prefix, MD_STARTFILE_PREFIX);\n+  set_static_spec_shared (&md_startfile_prefix_1, MD_STARTFILE_PREFIX_1);\n   multilib_dir = 0;\n   multilib_os_dir = 0;\n   multiarch_dir = 0;\n@@ -10843,8 +10888,7 @@ driver::finalize ()\n       spec_list *sl = &static_specs[i];\n       if (sl->alloc_p)\n \t{\n-\t  if (0)\n-\t    free (const_cast <char *> (*(sl->ptr_spec)));\n+\t  free (const_cast <char *> (*(sl->ptr_spec)));\n \t  sl->alloc_p = false;\n \t}\n       *(sl->ptr_spec) = sl->default_ptr;"}]}