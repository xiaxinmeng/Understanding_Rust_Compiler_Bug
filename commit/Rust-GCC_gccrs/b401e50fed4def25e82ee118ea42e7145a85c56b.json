{"sha": "b401e50fed4def25e82ee118ea42e7145a85c56b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwMWU1MGZlZDRkZWYyNWU4MmVlMTE4ZWE0MmU3MTQ1YTg1YzU2Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-06-05T11:11:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-06-05T11:11:16Z"}, "message": "tree-cfgcleanup.c (cleanup_control_flow_pre): For edge removal pretend DOM info isn't available so we do not update it and...\n\n2018-06-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-cfgcleanup.c (cleanup_control_flow_pre): For edge\n\tremoval pretend DOM info isn't available so we do not update\n\tit and only remove edges, not dominated blocks.  Actually free\n\tDOM info in case we removed something.  Remove unreachable blocks.\n\t(mfb_keep_latches): Work with either DOM info or marked backedges.\n\t(cleanup_tree_cfg_noloop): Do not remove unreachable blocks\n\tfirst.  Mark backedges if DOM info isn't available.\n\t(Re-)compute DOM info after cleanup_control_flow_pre.\n\nFrom-SVN: r261195", "tree": {"sha": "f39003bf3d25157b33457ba2117c868b0d5f5455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f39003bf3d25157b33457ba2117c868b0d5f5455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b401e50fed4def25e82ee118ea42e7145a85c56b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b401e50fed4def25e82ee118ea42e7145a85c56b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b401e50fed4def25e82ee118ea42e7145a85c56b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b401e50fed4def25e82ee118ea42e7145a85c56b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62761a0f888a69870bd24371dd9e4c191de81f1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62761a0f888a69870bd24371dd9e4c191de81f1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62761a0f888a69870bd24371dd9e4c191de81f1d"}], "stats": {"total": 85, "additions": 64, "deletions": 21}, "files": [{"sha": "7f5f4e407d1ff7773a66e6071ec21e4f26e6977c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b401e50fed4def25e82ee118ea42e7145a85c56b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b401e50fed4def25e82ee118ea42e7145a85c56b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b401e50fed4def25e82ee118ea42e7145a85c56b", "patch": "@@ -1,3 +1,14 @@\n+2018-06-05  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-cfgcleanup.c (cleanup_control_flow_pre): For edge\n+\tremoval pretend DOM info isn't available so we do not update\n+\tit and only remove edges, not dominated blocks.  Actually free\n+\tDOM info in case we removed something.  Remove unreachable blocks.\n+\t(mfb_keep_latches): Work with either DOM info or marked backedges.\n+\t(cleanup_tree_cfg_noloop): Do not remove unreachable blocks\n+\tfirst.  Mark backedges if DOM info isn't available.\n+\t(Re-)compute DOM info after cleanup_control_flow_pre.\n+\n 2018-06-05  Richard Biener  <rguenther@suse.de>\n \n \t* tree-cfg.c (struct locus_discrim_map): Store line, not location."}, {"sha": "d5464fdc4e4abc18998ecb4d49d23054ab1ccf93", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b401e50fed4def25e82ee118ea42e7145a85c56b/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b401e50fed4def25e82ee118ea42e7145a85c56b/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=b401e50fed4def25e82ee118ea42e7145a85c56b", "patch": "@@ -684,8 +684,8 @@ want_merge_blocks_p (basic_block bb1, basic_block bb2)\n }\n \n \n-/* Tries to cleanup cfg in basic block BB.  Returns true if anything\n-   changes.  */\n+/* Tries to cleanup cfg in basic block BB by merging blocks.  Returns\n+   true if anything changes.  */\n \n static bool\n cleanup_tree_cfg_bb (basic_block bb)\n@@ -725,6 +725,12 @@ cleanup_control_flow_pre ()\n {\n   bool retval = false;\n \n+  /* We want remove_edge_and_dominated_blocks to only remove edges,\n+     not dominated blocks which it does when dom info isn't available.\n+     Pretend so.  */\n+  dom_state saved_state = dom_info_state (CDI_DOMINATORS);\n+  set_dom_info_availability (CDI_DOMINATORS, DOM_NONE);\n+\n   auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n   auto_sbitmap visited (last_basic_block_for_fn (cfun));\n   bitmap_clear (visited);\n@@ -741,6 +747,8 @@ cleanup_control_flow_pre ()\n \t  && ! bitmap_bit_p (visited, dest->index))\n \t{\n \t  bitmap_set_bit (visited, dest->index);\n+\t  /* We only possibly remove edges from DEST here, leaving\n+\t     possibly unreachable code in the IL.  */\n \t  retval |= cleanup_control_flow_bb (dest);\n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    stack.quick_push (ei_start (dest->succs));\n@@ -754,13 +762,35 @@ cleanup_control_flow_pre ()\n \t}\n     }\n \n+  set_dom_info_availability (CDI_DOMINATORS, saved_state);\n+\n+  /* We are deleting BBs in non-reverse dominator order, make sure\n+     insert_debug_temps_for_defs is prepared for that.  */\n+  if (retval)\n+    free_dominance_info (CDI_DOMINATORS);\n+\n+  /* Remove all now (and previously) unreachable blocks.  */\n+  for (int i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); ++i)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+      if (bb && !bitmap_bit_p (visited, bb->index))\n+\t{\n+\t  if (!retval)\n+\t    free_dominance_info (CDI_DOMINATORS);\n+\t  delete_basic_block (bb);\n+\t  retval = true;\n+\t}\n+    }\n+\n   return retval;\n }\n \n static bool\n mfb_keep_latches (edge e)\n {\n-  return ! dominated_by_p (CDI_DOMINATORS, e->src, e->dest);\n+  return !((dom_info_available_p (CDI_DOMINATORS)\n+\t    && dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n+\t   || (e->flags & EDGE_DFS_BACK));\n }\n \n /* Remove unreachable blocks and other miscellaneous clean up work.\n@@ -769,23 +799,8 @@ mfb_keep_latches (edge e)\n static bool\n cleanup_tree_cfg_noloop (void)\n {\n-  bool changed;\n-\n   timevar_push (TV_TREE_CLEANUP_CFG);\n \n-  /* If dominance information is available, there cannot be any unreachable\n-     blocks.  */\n-  if (!dom_info_available_p (CDI_DOMINATORS))\n-    {\n-      changed = delete_unreachable_blocks ();\n-      calculate_dominance_info (CDI_DOMINATORS);\n-    }\n-  else\n-    {\n-      checking_verify_dominators (CDI_DOMINATORS);\n-      changed = false;\n-    }\n-\n   /* Ensure that we have single entries into loop headers.  Otherwise\n      if one of the entries is becoming a latch due to CFG cleanup\n      (from formerly being part of an irreducible region) then we mess\n@@ -795,6 +810,10 @@ cleanup_tree_cfg_noloop (void)\n      we need to capture the dominance state before the pending transform.  */\n   if (current_loops)\n     {\n+      /* This needs backedges or dominators.  */\n+      if (!dom_info_available_p (CDI_DOMINATORS))\n+\tmark_dfs_back_edges ();\n+\n       loop_p loop;\n       unsigned i;\n       FOR_EACH_VEC_ELT (*get_loops (cfun), i, loop)\n@@ -816,7 +835,9 @@ cleanup_tree_cfg_noloop (void)\n \t\t    any_abnormal = true;\n \t\t    break;\n \t\t  }\n-\t\tif (dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t\tif ((dom_info_available_p (CDI_DOMINATORS)\n+\t\t     && dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t\t    || (e->flags & EDGE_DFS_BACK))\n \t\t  {\n \t\t    found_latch = true;\n \t\t    continue;\n@@ -850,12 +871,19 @@ cleanup_tree_cfg_noloop (void)\n   /* Start by iterating over all basic blocks in PRE order looking for\n      edge removal opportunities.  Do this first because incoming SSA form\n      may be invalid and we want to avoid performing SSA related tasks such\n-     as propgating out a PHI node during BB merging in that state.  */\n-  changed |= cleanup_control_flow_pre ();\n+     as propgating out a PHI node during BB merging in that state.  This\n+     also gets rid of unreachable blocks.  */\n+  bool changed = cleanup_control_flow_pre ();\n \n   /* After doing the above SSA form should be valid (or an update SSA\n      should be required).  */\n \n+  /* Compute dominator info which we need for the iterative process below.  */\n+  if (!dom_info_available_p (CDI_DOMINATORS))\n+    calculate_dominance_info (CDI_DOMINATORS);\n+  else\n+    checking_verify_dominators (CDI_DOMINATORS);\n+\n   /* During forwarder block cleanup, we may redirect edges out of\n      SWITCH_EXPRs, which can get expensive.  So we want to enable\n      recording of edge to CASE_LABEL_EXPR.  */\n@@ -884,6 +912,10 @@ cleanup_tree_cfg_noloop (void)\n       if (!bb)\n \tcontinue;\n \n+      /* BB merging done by cleanup_tree_cfg_bb can end up propagating\n+\t out single-argument PHIs which in turn can expose\n+\t cleanup_control_flow_bb opportunities so we have to repeat\n+\t that here.  */\n       changed |= cleanup_control_flow_bb (bb);\n       changed |= cleanup_tree_cfg_bb (bb);\n     }"}]}