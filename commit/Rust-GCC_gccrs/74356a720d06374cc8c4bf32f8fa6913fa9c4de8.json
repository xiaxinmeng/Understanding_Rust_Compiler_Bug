{"sha": "74356a720d06374cc8c4bf32f8fa6913fa9c4de8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQzNTZhNzIwZDA2Mzc0Y2M4YzRiZjMyZjhmYTY5MTNmYTljNGRlOA==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-02-01T00:22:38Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-02-01T00:22:38Z"}, "message": "(TARGET_SOFT_FLOAT): New macro.\n\n(TARGET_SWITCHES, CPP_SPEC, CONDITIONAL_REGISTER_USAGE, FUNCTION_VALUE,\nLIBCALL_VALUE, FUNCTION_VALUE_REGNO_P, FUNCTION_ARG_REGNO_P,\nFUNCTION_ARG, ASM_DECLARE_FUNCTION_NAME, GO_IF_LEGITIMATE_ADDRESS,\nRTX_COSTS): Use TARGET_SOFT_FLOAT.\n(REAL_ARITHMETIC): Define.\n(ASM_OUTPUT_DOUBLE): Rewrite.\n(ASM_OUTPUT_FLOAT): Rewrite.\n\nFrom-SVN: r8848", "tree": {"sha": "9b72fa0089364cecd0298fa421b77de5500ea2c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b72fa0089364cecd0298fa421b77de5500ea2c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74356a720d06374cc8c4bf32f8fa6913fa9c4de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74356a720d06374cc8c4bf32f8fa6913fa9c4de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74356a720d06374cc8c4bf32f8fa6913fa9c4de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74356a720d06374cc8c4bf32f8fa6913fa9c4de8/comments", "author": null, "committer": null, "parents": [{"sha": "21302ab094a6a3ce9bd628e959a32add07d83c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21302ab094a6a3ce9bd628e959a32add07d83c16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21302ab094a6a3ce9bd628e959a32add07d83c16"}], "stats": {"total": 87, "additions": 54, "deletions": 33}, "files": [{"sha": "5fe931980e2a3e448c4241b85e7fc8e05faee6b5", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 54, "deletions": 33, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74356a720d06374cc8c4bf32f8fa6913fa9c4de8/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74356a720d06374cc8c4bf32f8fa6913fa9c4de8/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=74356a720d06374cc8c4bf32f8fa6913fa9c4de8", "patch": "@@ -107,6 +107,10 @@ extern int target_flags;\n \n #define TARGET_GAS (target_flags & 128)\n \n+/* Emit code for processors which do not have an FPU.  */\n+\n+#define TARGET_SOFT_FLOAT (target_flags & 256)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -132,6 +136,8 @@ extern int target_flags;\n    {\"no-portable-runtime\", -(64+16)},\\\n    {\"gas\", 128},\t\t\\\n    {\"no-gas\", -128},\t\t\\\n+   {\"soft-float\", 256},\t\t\\\n+   {\"no-soft-float\", -256},\t\\\n    { \"\", TARGET_DEFAULT}}\n \n #ifndef TARGET_DEFAULT\n@@ -211,7 +217,7 @@ extern int target_flags;\n #define CPP_SPEC \"%{msnake:-D__hp9000s700 -D_PA_RISC1_1}\\\n  %{mpa-risc-1-1:-D__hp9000s700 -D_PA_RISC1_1}\"\n #else\n-#define CPP_SPEC \"%{!mpa-risc-1-0:%{!mnosnake:-D__hp9000s700 -D_PA_RISC1_1}}\"\n+#define CPP_SPEC \"%{!mpa-risc-1-0:%{!mnosnake:%{!msoft-float:-D__hp9000s700 -D_PA_RISC1_1}}}\"\n #endif\n \n /* Defines for a K&R CC */\n@@ -257,6 +263,10 @@ do {\t\t\t\t\t\t\t\t\\\n \f\n /* target machine storage layout */\n \n+/* Define for cross-compilation from a host with a different float format\n+   or endianess (e.g. VAX, x86).  */\n+#define REAL_ARITHMETIC\n+\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 1\n@@ -267,8 +277,6 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Define this if most significant word of a multiword number is lowest\n    numbered.  */\n-/* For the HP-PA we can decide arbitrarily\n-   since there are no machine instructions for them.  */\n #define WORDS_BIG_ENDIAN 1\n \n /* number of bits in an addressable storage unit */\n@@ -439,7 +447,8 @@ do {\t\t\t\t\t\t\t\t\\\n       for (i = 33; i < 88; i += 2) \t\t\\\n \tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n     }\t\t\t\t\t\t\\\n-  else if (TARGET_DISABLE_FPREGS)\t\t\\\n+  else if (TARGET_DISABLE_FPREGS\t\t\\\n+\t   || TARGET_SOFT_FLOAT)\t\t\\\n     {\t\t\t\t\t\t\\\n       for (i = 32; i < 88; i++) \t\t\\\n \tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n@@ -786,26 +795,29 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\t\\\n-\t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), ((! TARGET_SOFT_FLOAT\t\t     \\\n+\t\t\t\t       && (TYPE_MODE (VALTYPE) == SFmode ||  \\\n+\t\t\t\t\t   TYPE_MODE (VALTYPE) == DFmode)) ? \\\n \t\t\t\t      32 : 28))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE) \\\n-  gen_rtx (REG, MODE, ((MODE) == SFmode || (MODE) == DFmode ? 32 : 28))\n+#define LIBCALL_VALUE(MODE)\t\\\n+  gen_rtx (REG, MODE,\t\t\t\t\t\t\t\\\n+\t   (! TARGET_SOFT_FLOAT\t\t\t\t\t\t\\\n+\t    && ((MODE) == SFmode || (MODE) == DFmode) ? 32 : 28))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n \n #define FUNCTION_VALUE_REGNO_P(N) \\\n-  ((N) == 28 || (N) == 32)\n+  ((N) == 28 || (! TARGET_SOFT_FLOAT && (N) == 32))\n \n /* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(N) \\\n-  (((N) >= 23 && (N) <= 26) || ((N) >= 32 && (N) <= 39))\n+  (((N) >= 23 && (N) <= 26) || (! TARGET_SOFT_FLOAT && (N) >= 32 && (N) <= 39))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -914,17 +926,20 @@ struct hppa_args {int words, nargs_prototype; };\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t      \t\t\\\n   (4 >= ((CUM).words + FUNCTION_ARG_SIZE ((MODE), (TYPE)))\t\t\\\n    ? (!TARGET_PORTABLE_RUNTIME || (TYPE) == 0\t\t\t\t\\\n-      || !FLOAT_MODE_P (MODE) || (CUM).nargs_prototype > 0)\t\t\\\n+      || !FLOAT_MODE_P (MODE) || TARGET_SOFT_FLOAT\t\t\t\\\n+      || (CUM).nargs_prototype > 0)\t\t\t\t\t\\\n       ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n \t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n \t\t  ? (((!current_call_is_indirect \t\t\t\\\n \t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n-\t\t      && (MODE) == DFmode)\t\t\t\t\\\n+\t\t      && (MODE) == DFmode\t\t\t\t\\\n+\t\t      && ! TARGET_SOFT_FLOAT)\t\t\t\t\\\n \t\t     ? ((CUM).words ? 38 : 34)\t\t\t\t\\\n \t\t     : ((CUM).words ? 23 : 25))\t\t\t\t\\\n \t\t  : (((!current_call_is_indirect\t\t\t\\\n \t\t       || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n-\t\t      && (MODE) == SFmode)\t\t\t\t\\\n+\t\t      && (MODE) == SFmode\t\t\t\t\\\n+\t\t      && ! TARGET_SOFT_FLOAT)\t\t\t\t\\\n \t\t     ? (32 + 2 * (CUM).words)\t\t\t\t\\\n \t\t     : (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\t\\\n \t\t\t\t\t\t\t      (TYPE))))))\\\n@@ -1006,9 +1021,11 @@ extern enum cmp_type hppa_branch_type;\n \t     for (parm = DECL_ARGUMENTS (DECL), i = 0; parm && i < 4;\t\\\n \t\t  parm = TREE_CHAIN (parm))\t\t\t\t\\\n \t       {\t\t\t\t\t\t\t\\\n-\t\t if (TYPE_MODE (DECL_ARG_TYPE (parm)) == SFmode)\t\\\n+\t\t if (TYPE_MODE (DECL_ARG_TYPE (parm)) == SFmode\t\t\\\n+\t\t     && ! TARGET_SOFT_FLOAT)\t\t\t\t\\\n \t\t   fprintf (FILE, \",ARGW%d=FR\", i++);\t\t\t\\\n-\t\t else if (TYPE_MODE (DECL_ARG_TYPE (parm)) == DFmode)\t\\\n+\t\t else if (TYPE_MODE (DECL_ARG_TYPE (parm)) == DFmode\t\\\n+\t\t\t  && ! TARGET_SOFT_FLOAT)\t\t\t\\\n \t\t   {\t\t\t\t\t\t\t\\\n \t\t     if (i <= 2)\t\t\t\t\t\\\n \t\t       {\t\t\t\t\t\t\\\n@@ -1044,9 +1061,9 @@ extern enum cmp_type hppa_branch_type;\n \t\t for (; i < 4; i++)\t\t\t\t\t\\\n \t\t   fprintf (FILE, \",ARGW%d=GR\", i);\t\t\t\\\n \t       }\t\t\t\t\t\t\t\\\n-\t     if (TYPE_MODE (fntype) == DFmode)\t\t\t\t\\\n+\t     if (TYPE_MODE (fntype) == DFmode && ! TARGET_SOFT_FLOAT)\t\\\n \t       fprintf (FILE, \",RTNVAL=FR\");\t\t\t\t\\\n-\t     else if (TYPE_MODE (fntype) == SFmode)\t\t\t\\\n+\t     else if (TYPE_MODE (fntype) == SFmode && ! TARGET_SOFT_FLOAT) \\\n \t       fprintf (FILE, \",RTNVAL=FU\");\t\t\t\t\\\n \t     else if (fntype != void_type_node)\t\t\t\t\\\n \t       fprintf (FILE, \",RTNVAL=GR\");\t\t\t\t\\\n@@ -1373,24 +1390,28 @@ extern union tree_node *current_function_decl;\n \tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n       if (base != 0)\t\t\t\t\t\\\n \tif (GET_CODE (index) == CONST_INT\t\t\\\n-\t    && ((INT_14_BITS (index) && (MODE) != SFmode && (MODE) != DFmode) \\\n+\t    && ((INT_14_BITS (index)\t\t\t\\\n+\t\t && (TARGET_SOFT_FLOAT\t\t\t\\\n+\t\t     || ((MODE) != SFmode && (MODE) != DFmode))) \\\n \t\t|| INT_5_BITS (index)))\t\t\t\\\n \t  goto ADDR;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == LO_SUM\t\t\t\\\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n \t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n \t   && CONSTANT_P (XEXP (X, 1))\t\t\t\\\n-\t   && (MODE) != SFmode\t\t\t\t\\\n-\t   && (MODE) != DFmode)\t\t\t\t\\\n+\t   && (TARGET_SOFT_FLOAT\t\t\t\\\n+\t       || ((MODE) != SFmode\t\t\t\\\n+\t\t   && (MODE) != DFmode)))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == LO_SUM\t\t\t\\\n \t   && GET_CODE (XEXP (X, 0)) == SUBREG\t\t\\\n \t   && GET_CODE (SUBREG_REG (XEXP (X, 0))) == REG\\\n \t   && REG_OK_FOR_BASE_P (SUBREG_REG (XEXP (X, 0)))\\\n \t   && CONSTANT_P (XEXP (X, 1))\t\t\t\\\n-\t   && (MODE) != SFmode\t\t\t\t\\\n-\t   && (MODE) != DFmode)\t\t\t\t\\\n+\t   && (TARGET_SOFT_FLOAT\t\t\t\\\n+\t       || ((MODE) != SFmode\t\t\t\\\n+\t\t   && (MODE) != DFmode)))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == LABEL_REF\t\t\t\\\n \t   || (GET_CODE (X) == CONST_INT\t\t\\\n@@ -1636,8 +1657,9 @@ while (0)\n \n #define RTX_COSTS(X,CODE,OUTER_CODE) \\\n   case MULT:\t\t\t\t\t\t\t\\\n-    return TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\t\t\\\n-      ? COSTS_N_INSNS (8) : COSTS_N_INSNS (20); \t\t\\\n+    return (TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\t\t\\\n+\t    && ! TARGET_SOFT_FLOAT\t\t\t\t\\\n+\t    ? COSTS_N_INSNS (8) : COSTS_N_INSNS (20)); \t\t\\\n   case DIV:\t\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\t\\\n@@ -1892,19 +1914,18 @@ readonly_data ()\t\t\t\t\t\t\t\\\n /* This is how to output an assembler line defining a `double' constant.  */\n \n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  do { union { double d; int i[2];} __u;\t\\\n-    __u.d = (VALUE);\t\t\t\t\\\n-    fprintf (FILE, \"\\t; .double %.20e\\n\\t.word %d ; = 0x%x\\n\\t.word %d ; = 0x%x\\n\",\t\\\n-\t     __u.d, __u.i[0], __u.i[0], __u.i[1], __u.i[1]);\t\\\n-  } while (0)\n+  do { long l[2];\t\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+       fprintf (FILE, \"\\t.word 0x%lx\\n\\t.word 0x%lx\\n\", l[0], l[1]);\t\\\n+     } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n #define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  do { union { float f; int i;} __u;\t\t\\\n-    __u.f = (VALUE);\t\t\t\t\\\n-    fprintf (FILE, \"\\t; .float %.12e\\n\\t.word %d ; = 0x%x\\n\", __u.f, __u.i, __u.i); \\\n-  } while (0)\n+  do { long l;\t\t\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n+       fprintf (FILE, \"\\t.word 0x%lx\\n\", l);\t\t\t\t\\\n+     } while (0)\n \n /* This is how to output an assembler line defining an `int' constant.  */\n "}]}