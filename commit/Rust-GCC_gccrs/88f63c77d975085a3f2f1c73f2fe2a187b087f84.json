{"sha": "88f63c77d975085a3f2f1c73f2fe2a187b087f84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmNjNjNzdkOTc1MDg1YTNmMmYxYzczZjJmZTJhMTg3YjA4N2Y4NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-03T22:12:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-03T22:12:50Z"}, "message": "(clear_storage, expand_assignment, store_{expr,constructor}): Use ptr_mode instead of Pmode in some places.\n\n(clear_storage, expand_assignment, store_{expr,constructor}): Use ptr_mode\ninstead of Pmode in some places.\n(expand_expr, expand_builtin): Likewise.\n(push_block, store_expr): Convert size to Pmode.\n(expand_expr, case ADDR_EXPR): Convert from Pmode to ptr_mode.\n\nFrom-SVN: r9305", "tree": {"sha": "d5ebcc056de5c8998db606e54d333788a9dcb2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5ebcc056de5c8998db606e54d333788a9dcb2aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88f63c77d975085a3f2f1c73f2fe2a187b087f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f63c77d975085a3f2f1c73f2fe2a187b087f84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f63c77d975085a3f2f1c73f2fe2a187b087f84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f63c77d975085a3f2f1c73f2fe2a187b087f84/comments", "author": null, "committer": null, "parents": [{"sha": "ea534b63c64528eafee8d376cdaf142ea2c80765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea534b63c64528eafee8d376cdaf142ea2c80765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea534b63c64528eafee8d376cdaf142ea2c80765"}], "stats": {"total": 86, "additions": 52, "deletions": 34}, "files": [{"sha": "7e65189e75cb8f1e4035ec79b9a4a5ffbb011898", "filename": "gcc/expr.c", "status": "modified", "additions": 52, "deletions": 34, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f63c77d975085a3f2f1c73f2fe2a187b087f84/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f63c77d975085a3f2f1c73f2fe2a187b087f84/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=88f63c77d975085a3f2f1c73f2fe2a187b087f84", "patch": "@@ -1829,13 +1829,13 @@ clear_storage (object, size)\n #ifdef TARGET_MEM_FUNCTIONS\n       emit_library_call (memset_libfunc, 0,\n \t\t\t VOIDmode, 3,\n-\t\t\t XEXP (object, 0), Pmode, const0_rtx, Pmode,\n-\t\t\t GEN_INT (size), Pmode);\n+\t\t\t XEXP (object, 0), Pmode, const0_rtx, ptr_mode,\n+\t\t\t GEN_INT (size), ptr_mode);\n #else\n       emit_library_call (bzero_libfunc, 0,\n \t\t\t VOIDmode, 2,\n \t\t\t XEXP (object, 0), Pmode,\n-\t\t\t GEN_INT (size), Pmode);\n+\t\t\t GEN_INT (size), ptr_mode);\n #endif\n     }\n   else\n@@ -2018,6 +2018,8 @@ push_block (size, extra, below)\n      int extra, below;\n {\n   register rtx temp;\n+\n+  size = convert_modes (Pmode, ptr_mode, size, 1);\n   if (CONSTANT_P (size))\n     anti_adjust_stack (plus_constant (size, extra));\n   else if (GET_CODE (size) == REG && extra == 0)\n@@ -2494,8 +2496,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  if (GET_CODE (to_rtx) != MEM)\n \t    abort ();\n \t  to_rtx = change_address (to_rtx, VOIDmode,\n-\t\t\t\t   gen_rtx (PLUS, Pmode, XEXP (to_rtx, 0),\n-\t\t\t\t\t    force_reg (Pmode, offset_rtx)));\n+\t\t\t\t   gen_rtx (PLUS, ptr_mode, XEXP (to_rtx, 0),\n+\t\t\t\t\t    force_reg (ptr_mode, offset_rtx)));\n \t  /* If we have a variable offset, the known alignment\n \t     is only that of the innermost structure containing the field.\n \t     (Actually, we could sometimes do better by using the\n@@ -2867,24 +2869,25 @@ store_expr (exp, target, want_value)\n \t      emit_block_move (target, temp, copy_size_rtx,\n \t\t\t       TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n \n-\t      /* Figure out how much is left in TARGET\n-\t\t that we have to clear.  */\n+\t      /* Figure out how much is left in TARGET that we have to clear.\n+\t\t Do all calculations in ptr_mode.  */\n+\n+\t      addr = XEXP (target, 0);\n+\t      addr = convert_modes (ptr_mode, Pmode, addr, 1);\n+\n \t      if (GET_CODE (copy_size_rtx) == CONST_INT)\n \t\t{\n-\t\t  addr = plus_constant (XEXP (target, 0),\n-\t\t\t\t\tTREE_STRING_LENGTH (exp));\n+\t\t  addr = plus_constant (addr, TREE_STRING_LENGTH (exp));\n \t\t  size = plus_constant (size, - TREE_STRING_LENGTH (exp));\n \t\t}\n \t      else\n \t\t{\n-\t\t  enum machine_mode size_mode = Pmode;\n-\n-\t\t  addr = force_reg (Pmode, XEXP (target, 0));\n-\t\t  addr = expand_binop (size_mode, add_optab, addr,\n+\t\t  addr = force_reg (ptr_mode, addr);\n+\t\t  addr = expand_binop (ptr_mode, add_optab, addr,\n \t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n \t\t\t\t       OPTAB_LIB_WIDEN);\n \n-\t\t  size = expand_binop (size_mode, sub_optab, size,\n+\t\t  size = expand_binop (ptr_mode, sub_optab, size,\n \t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n \t\t\t\t       OPTAB_LIB_WIDEN);\n \n@@ -2898,10 +2901,10 @@ store_expr (exp, target, want_value)\n \t\t{\n #ifdef TARGET_MEM_FUNCTIONS\n \t\t  emit_library_call (memset_libfunc, 0, VOIDmode, 3, addr,\n-\t\t\t\t     Pmode, const0_rtx, Pmode, size, Pmode);\n+\t\t\t\t     Pmode, const0_rtx, Pmode, size, ptr_mode);\n #else\n \t\t  emit_library_call (bzero_libfunc, 0, VOIDmode, 2,\n-\t\t\t\t     addr, Pmode, size, Pmode);\n+\t\t\t\t     addr, Pmode, size, ptr_mode);\n #endif\n \t\t}\n \n@@ -3038,8 +3041,8 @@ store_constructor (exp, target)\n \n \t      to_rtx\n \t\t= change_address (to_rtx, VOIDmode,\n-\t\t\t\t  gen_rtx (PLUS, Pmode, XEXP (to_rtx, 0),\n-\t\t\t\t\t   force_reg (Pmode, offset_rtx)));\n+\t\t\t\t  gen_rtx (PLUS, ptr_mode, XEXP (to_rtx, 0),\n+\t\t\t\t\t   force_reg (ptr_mode, offset_rtx)));\n \t    }\n \n \t  store_field (to_rtx, bitsize, bitpos, mode, TREE_VALUE (elt),\n@@ -4509,9 +4512,7 @@ expand_expr (exp, target, tmode, modifier)\n \t   code, suitable for indexing, may be generated.  */\n \tif (TREE_CODE (exp1) == SAVE_EXPR\n \t    && SAVE_EXPR_RTL (exp1) == 0\n-\t    && TREE_CODE (exp2 = TREE_OPERAND (exp1, 0)) != ERROR_MARK\n-\t    && TYPE_MODE (TREE_TYPE (exp1)) == Pmode\n-\t    && TYPE_MODE (TREE_TYPE (exp2)) == Pmode)\n+\t    && TYPE_MODE (TREE_TYPE (exp1)) == ptr_mode)\n \t  {\n \t    temp = expand_expr (TREE_OPERAND (exp1, 0), NULL_RTX,\n \t\t\t\tVOIDmode, EXPAND_SUM);\n@@ -4754,8 +4755,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (op0) != MEM)\n \t      abort ();\n \t    op0 = change_address (op0, VOIDmode,\n-\t\t\t\t  gen_rtx (PLUS, Pmode, XEXP (op0, 0),\n-\t\t\t\t\t   force_reg (Pmode, offset_rtx)));\n+\t\t\t\t  gen_rtx (PLUS, ptr_mode, XEXP (op0, 0),\n+\t\t\t\t\t   force_reg (ptr_mode, offset_rtx)));\n \t  /* If we have a variable offset, the known alignment\n \t     is only that of the innermost structure containing the field.\n \t     (Actually, we could sometimes do better by using the\n@@ -5125,7 +5126,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  TREE_OPERAND (TREE_OPERAND (exp, 0), 0) = t;\n \t}\n \n-      /* If the result is to be Pmode and we are adding an integer to\n+      /* If the result is to be ptr_mode and we are adding an integer to\n \t something, we might be forming a constant.  So try to use\n \t plus_constant.  If it produces a sum and we can't accept it,\n \t use force_operand.  This allows P = &ARR[const] to generate\n@@ -5134,7 +5135,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t If this is an EXPAND_SUM call, always return the sum.  */\n       if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n-\t  || mode == Pmode)\n+\t  || mode == ptr_mode)\n \t{\n \t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n@@ -5176,7 +5177,7 @@ expand_expr (exp, target, tmode, modifier)\n \t And force_operand won't know whether to sign-extend or\n \t zero-extend.  */\n       if ((modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n-\t  || mode != Pmode)\n+\t  || mode != ptr_mode)\n \tgoto binop;\n \n       preexpand_calls (exp);\n@@ -5300,7 +5301,7 @@ expand_expr (exp, target, tmode, modifier)\n       /* Attempt to return something suitable for generating an\n \t indexed address, for machines that support that.  */\n \n-      if (modifier == EXPAND_SUM && mode == Pmode\n+      if (modifier == EXPAND_SUM && mode == ptr_mode\n \t  && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t{\n@@ -6259,7 +6260,16 @@ expand_expr (exp, target, tmode, modifier)\n \t    abort ();\n   \n \t  if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n-\t    return XEXP (op0, 0);\n+\t    {\n+\t      temp = XEXP (op0, 0);\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t      if (GET_MODE (temp) == Pmode && GET_MODE (temp) != mode\n+\t\t  && mode == ptr_mode)\n+\t\ttemp = convert_modes (ptr_mode, Pmode, temp,\n+\t\t\t\t      POINTERS_EXTEND_UNSIGNED);\n+#endif\n+\t      return temp;\n+\t    }\n \n \t  op0 = force_operand (XEXP (op0, 0), target);\n \t}\n@@ -6275,6 +6285,12 @@ expand_expr (exp, target, tmode, modifier)\n       if (temp != 0)\n \tupdate_temp_slot_address (temp, op0);\n \n+#ifdef POINTERS_EXTEND_UNSIGNED\n+      if (GET_MODE (op0) == Pmode && GET_MODE (op0) != mode\n+\t  && mode == ptr_mode)\n+\top0 = convert_modes (ptr_mode, Pmode, op0, POINTERS_EXTEND_UNSIGNED);\n+#endif\n+\n       return op0;\n \n     case ENTRY_VALUE_EXPR:\n@@ -7642,7 +7658,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    result = gen_reg_rtx (insn_mode);\n \n \t  src_rtx = memory_address (BLKmode,\n-\t\t\t\t    expand_expr (src, NULL_RTX, Pmode,\n+\t\t\t\t    expand_expr (src, NULL_RTX, ptr_mode,\n \t\t\t\t\t\t EXPAND_NORMAL));\n \t  if (! (*insn_operand_predicate[(int)icode][1]) (src_rtx, Pmode))\n \t    src_rtx = copy_to_mode_reg (Pmode, src_rtx);\n@@ -7726,14 +7742,14 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t      break;\n \t    }\n \n-\t  dest_rtx = expand_expr (dest, NULL_RTX, Pmode, EXPAND_NORMAL);\n+\t  dest_rtx = expand_expr (dest, NULL_RTX, ptr_mode, EXPAND_SUM);\n \t  dest_mem = gen_rtx (MEM, BLKmode,\n \t\t\t      memory_address (BLKmode, dest_rtx));\n \t  src_mem = gen_rtx (MEM, BLKmode,\n \t\t\t     memory_address (BLKmode,\n \t\t\t\t\t     expand_expr (src, NULL_RTX,\n-\t\t\t\t\t\t\t  Pmode,\n-\t\t\t\t\t\t\t  EXPAND_NORMAL)));\n+\t\t\t\t\t\t\t  ptr_mode,\n+\t\t\t\t\t\t\t  EXPAND_SUM)));\n \n \t  /* Copy word part most expediently.  */\n \t  emit_block_move (dest_mem, src_mem,\n@@ -7844,10 +7860,12 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \temit_insn (gen_cmpstrsi (result,\n \t\t\t\t gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t  expand_expr (arg1, NULL_RTX, Pmode,\n+\t\t\t\t\t  expand_expr (arg1, NULL_RTX,\n+\t\t\t\t\t\t       ptr_mode,\n \t\t\t\t\t\t       EXPAND_NORMAL)),\n \t\t\t\t gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t  expand_expr (arg2, NULL_RTX, Pmode,\n+\t\t\t\t\t  expand_expr (arg2, NULL_RTX,\n+\t\t\t\t\t\t       ptr_mode,\n \t\t\t\t\t\t       EXPAND_NORMAL)),\n \t\t\t\t expand_expr (len, NULL_RTX, VOIDmode, 0),\n \t\t\t\t GEN_INT (MIN (arg1_align, arg2_align))));"}]}