{"sha": "fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "node_id": "C_kwDOANBUbNoAKGZjODJiNjhjYzFlZTI3NzhmMmJmYzUzYzVkZTQ3ZTViMzZhYzhiN2M", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-26T06:44:02Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-26T06:44:02Z"}, "message": "backend: Add overflow checks to every arithmetic operation", "tree": {"sha": "95454db7a9799f2ad2c16205fbc305e7ff7a09c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95454db7a9799f2ad2c16205fbc305e7ff7a09c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff7d6bfed2e7bc08fba1cc456daf464e6176dd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7d6bfed2e7bc08fba1cc456daf464e6176dd46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7d6bfed2e7bc08fba1cc456daf464e6176dd46"}], "stats": {"total": 261, "additions": 223, "deletions": 38}, "files": [{"sha": "e13c08caae49e867c5289cc455420d4f35fbe317", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-compile-block.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-constexpr.h\"\n+#include \"rust-gcc.h\"\n \n #include \"fold-const.h\"\n #include \"realmpfr.h\"\n@@ -146,9 +147,26 @@ CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n       return;\n     }\n \n-  translated\n-    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t     expr.get_locus ());\n+  if (ctx->in_fn () && !ctx->const_context_p ())\n+    {\n+      auto receiver_tmp = NULL_TREE;\n+      auto receiver\n+\t= ctx->get_backend ()->temporary_variable (ctx->peek_fn ().fndecl,\n+\t\t\t\t\t\t   NULL_TREE, TREE_TYPE (lhs),\n+\t\t\t\t\t\t   lhs, true, expr.get_locus (),\n+\t\t\t\t\t\t   &receiver_tmp);\n+      auto check\n+\t= ctx->get_backend ()->arithmetic_or_logical_expression_checked (\n+\t  op, lhs, rhs, expr.get_locus (), receiver);\n+\n+      ctx->add_statement (check);\n+      translated = receiver->get_tree (expr.get_locus ());\n+    }\n+  else\n+    {\n+      translated = ctx->get_backend ()->arithmetic_or_logical_expression (\n+\top, lhs, rhs, expr.get_locus ());\n+    }\n }\n \n void\n@@ -176,13 +194,27 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n       return;\n     }\n \n-  auto operator_expr\n-    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t     expr.get_locus ());\n-  tree assignment\n-    = ctx->get_backend ()->assignment_statement (lhs, operator_expr,\n-\t\t\t\t\t\t expr.get_locus ());\n-  ctx->add_statement (assignment);\n+  if (ctx->in_fn () && !ctx->const_context_p ())\n+    {\n+      auto tmp = NULL_TREE;\n+      auto receiver\n+\t= ctx->get_backend ()->temporary_variable (ctx->peek_fn ().fndecl,\n+\t\t\t\t\t\t   NULL_TREE, TREE_TYPE (lhs),\n+\t\t\t\t\t\t   lhs, true, expr.get_locus (),\n+\t\t\t\t\t\t   &tmp);\n+      auto check\n+\t= ctx->get_backend ()->arithmetic_or_logical_expression_checked (\n+\t  op, lhs, rhs, expr.get_locus (), receiver);\n+      ctx->add_statement (check);\n+\n+      translated = ctx->get_backend ()->assignment_statement (\n+\tlhs, receiver->get_tree (expr.get_locus ()), expr.get_locus ());\n+    }\n+  else\n+    {\n+      translated = ctx->get_backend ()->arithmetic_or_logical_expression (\n+\top, lhs, rhs, expr.get_locus ());\n+    }\n }\n \n void\n@@ -2378,7 +2410,10 @@ CompileExpr::array_copied_expr (Location expr_locus,\n       return error_mark_node;\n     }\n \n+  ctx->push_const_context ();\n   tree capacity_expr = CompileExpr::Compile (elems.get_num_copies_expr (), ctx);\n+  ctx->pop_const_context ();\n+\n   if (!TREE_CONSTANT (capacity_expr))\n     {\n       rust_error_at (expr_locus, \"non const num copies %qT\", array_type);"}, {"sha": "96c4e7fcf6119286fa21f1e5ac31b2a26d6d6a27", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -160,6 +160,9 @@ CompileItem::visit (HIR::Function &function)\n     function.get_mappings ().get_nodeid (), &canonical_path);\n   rust_assert (ok);\n \n+  if (function.get_qualifiers ().is_const ())\n+    ctx->push_const_context ();\n+\n   tree fndecl\n     = compile_function (ctx, function.get_function_name (),\n \t\t\tfunction.get_self_param (),\n@@ -169,6 +172,9 @@ CompileItem::visit (HIR::Function &function)\n \t\t\tfunction.get_definition ().get (), canonical_path,\n \t\t\tfntype, function.has_function_return_type ());\n   reference = address_expression (fndecl, ref_locus);\n+\n+  if (function.get_qualifiers ().is_const ())\n+    ctx->pop_const_context ();\n }\n \n void"}, {"sha": "77d84748eb5a52b87e69d6b1389625234464d72d", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -370,7 +370,11 @@ TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n {\n   tree element_type\n     = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+\n+  ctx->push_const_context ();\n   tree capacity_expr = CompileExpr::Compile (&type.get_capacity_expr (), ctx);\n+  ctx->pop_const_context ();\n+\n   tree folded_capacity_expr = fold_expr (capacity_expr);\n \n   translated"}, {"sha": "cda264233b187aed0cd85ebb8f98b97434d25ee0", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -235,13 +235,24 @@ class Backend\n   // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n   virtual tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t\t\t tree left, tree right,\n-\t\t\t\t\t\t Location)\n+\t\t\t\t\t\t Location loc)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n+  // This function adds overflow checking and returns a list of statements to\n+  // add to the current function context. The `receiver` variable refers to the\n+  // variable which will contain the result of that operation.\n+  virtual tree\n+  arithmetic_or_logical_expression_checked (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t    tree left, tree right, Location loc,\n+\t\t\t\t\t    Bvariable *receiver)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ComparisonOperator.\n   virtual tree comparison_expression (ComparisonOperator op, tree left,\n-\t\t\t\t      tree right, Location)\n+\t\t\t\t      tree right, Location loc)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n@@ -416,8 +427,8 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable *temporary_variable (tree, tree, tree, tree init,\n-\t\t\t\t\t bool address_is_taken,\n+  virtual Bvariable *temporary_variable (tree fndecl, tree bind_tree, tree type,\n+\t\t\t\t\t tree init, bool address_is_taken,\n \t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n "}, {"sha": "e5dc6dacc76fa22a8b3a0b5527577eca7fc10882", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 126, "deletions": 14, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -53,6 +53,7 @@\n #include \"rust-gcc.h\"\n \n #include \"backend/rust-tree.h\"\n+#include \"backend/rust-builtins.h\"\n \n // Get the tree of a variable for use as an expression.  If this is a\n // zero-sized global, create an expression that refers to the decl but\n@@ -206,6 +207,10 @@ class Gcc_backend : public Backend\n   tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t\t tree left, tree right, Location);\n \n+  tree arithmetic_or_logical_expression_checked (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t tree left, tree right,\n+\t\t\t\t\t\t Location, Bvariable *receiver);\n+\n   tree comparison_expression (ComparisonOperator op, tree left, tree right,\n \t\t\t      Location);\n \n@@ -1380,25 +1385,26 @@ Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n   return new_tree;\n }\n \n-// Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n tree\n Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t       tree left_tree, tree right_tree,\n+\t\t\t\t\t       tree left, tree right,\n \t\t\t\t\t       Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+  if (left == error_mark_node || right == error_mark_node)\n     return error_mark_node;\n \n   /* We need to determine if we're doing floating point arithmetics of integer\n      arithmetics. */\n-  bool floating_point = is_floating_point (left_tree);\n+  bool floating_point = is_floating_point (left);\n+  auto ret = NULL_TREE;\n \n   /* For arithmetic or logical operators, the resulting type should be the same\n      as the lhs operand. */\n-  auto tree_type = TREE_TYPE (left_tree);\n+  auto tree_type = TREE_TYPE (left);\n   auto original_type = tree_type;\n+  auto loc = location.gcc_location ();\n   auto tree_code = operator_to_tree_code (op, floating_point);\n \n   /* For floating point operations we may need to extend the precision of type.\n@@ -1409,21 +1415,127 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n       extended_type = excess_precision_type (tree_type);\n       if (extended_type != NULL_TREE)\n \t{\n-\t  left_tree = convert (extended_type, left_tree);\n-\t  right_tree = convert (extended_type, right_tree);\n+\t  left = convert (extended_type, left);\n+\t  right = convert (extended_type, right);\n \t  tree_type = extended_type;\n \t}\n     }\n \n-  /* Construct a new tree and build an expression from it. */\n-  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n-\t\t\t\t   tree_type, left_tree, right_tree);\n-  TREE_CONSTANT (new_tree)\n-    = TREE_CONSTANT (left_tree) && TREE_CONSTANT (right_tree);\n+  ret = fold_build2_loc (loc, tree_code, tree_type, left, right);\n+  TREE_CONSTANT (ret) = TREE_CONSTANT (left) & TREE_CONSTANT (right);\n \n+  // TODO: How do we handle floating point?\n   if (floating_point && extended_type != NULL_TREE)\n-    new_tree = convert (original_type, new_tree);\n-  return new_tree;\n+    ret = convert (original_type, ret);\n+\n+  return ret;\n+}\n+\n+static bool\n+is_overflowing_expr (ArithmeticOrLogicalOperator op)\n+{\n+  switch (op)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+static std::pair<tree, tree>\n+fetch_overflow_builtins (ArithmeticOrLogicalOperator op)\n+{\n+  auto builtin_ctx = Rust::Compile::BuiltinsContext::get ();\n+\n+  auto builtin = NULL_TREE;\n+  auto abort = NULL_TREE;\n+\n+  switch (op)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      builtin_ctx.lookup_simple_builtin (\"add_overflow\", &builtin);\n+      break;\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      builtin_ctx.lookup_simple_builtin (\"sub_overflow\", &builtin);\n+      break;\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      builtin_ctx.lookup_simple_builtin (\"mul_overflow\", &builtin);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    };\n+\n+  builtin_ctx.lookup_simple_builtin (\"abort\", &abort);\n+\n+  rust_assert (abort);\n+  rust_assert (builtin);\n+\n+  // FIXME: ARTHUR: This is really ugly. The builtin context should take care of\n+  // that\n+  TREE_SIDE_EFFECTS (abort) = 1;\n+  TREE_READONLY (abort) = 0;\n+\n+  // FIXME: ARTHUR: Same here. Remove these!\n+  TREE_SIDE_EFFECTS (builtin) = 1;\n+  TREE_READONLY (builtin) = 0;\n+\n+  return {abort, builtin};\n+}\n+\n+// Return an expression for the arithmetic or logical operation LEFT OP RIGHT\n+// with overflow checking when possible\n+tree\n+Gcc_backend::arithmetic_or_logical_expression_checked (\n+  ArithmeticOrLogicalOperator op, tree left, tree right, Location location,\n+  Bvariable *receiver_var)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  if (left == error_mark_node || right == error_mark_node)\n+    return error_mark_node;\n+\n+  auto loc = location.gcc_location ();\n+\n+  // FIXME: Add `if (!debug_mode)`\n+  // No overflow checks for floating point operations or divisions. In that\n+  // case, simply assign the result of the operation to the receiver variable\n+  if (is_floating_point (left) || !is_overflowing_expr (op))\n+    return assignment_statement (\n+      receiver_var->get_tree (location),\n+      arithmetic_or_logical_expression (op, left, right, location), location);\n+\n+  auto receiver = receiver_var->get_tree (location);\n+  TREE_ADDRESSABLE (receiver) = 1;\n+  auto result_ref = build_fold_addr_expr_loc (loc, receiver);\n+\n+  auto builtins = fetch_overflow_builtins (op);\n+  auto abort = builtins.first;\n+  auto builtin = builtins.second;\n+\n+  auto abort_call = build_call_expr_loc (loc, abort, 0);\n+\n+  // FIXME: ARTHUR: Is that needed?\n+  TREE_SIDE_EFFECTS (abort_call) = 1;\n+  TREE_READONLY (abort_call) = 0;\n+\n+  auto builtin_call\n+    = build_call_expr_loc (loc, builtin, 3, left, right, result_ref);\n+  auto overflow_check\n+    = build2_loc (loc, EQ_EXPR, boolean_type_node, builtin_call,\n+\t\t  boolean_constant_expression (true));\n+\n+  auto if_block = build3_loc (loc, COND_EXPR, void_type_node, overflow_check,\n+\t\t\t      abort_call, NULL_TREE);\n+\n+  // FIXME: ARTHUR: Needed?\n+  TREE_SIDE_EFFECTS (if_block) = 1;\n+  TREE_READONLY (if_block) = 0;\n+\n+  return if_block;\n }\n \n // Return an expression for the comparison operation LEFT OP RIGHT."}, {"sha": "4e02906a1958235dcdd94f085d121c6759cbb081", "filename": "gcc/testsuite/rust/debug/win64-abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Ftestsuite%2Frust%2Fdebug%2Fwin64-abi.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Ftestsuite%2Frust%2Fdebug%2Fwin64-abi.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fdebug%2Fwin64-abi.rs?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -1,11 +1,11 @@\n // { dg-do compile { target { x86_64-*-* } } }\n // { dg-options \"-gdwarf-5 -dA -w -O1 -m64\" }\n-pub extern \"win64\" fn square(num: i32) -> i32 {\n-    num * num\n+pub extern \"win64\" fn id(num: i32) -> i32 {\n+    num\n }\n \n fn main() {\n     // MS ABI dictates that the first argument is ecx instead of edi from the sysv world\n-    // { dg-final { scan-assembler \"%ecx, %ecx\" } }\n-    square(1);\n+    // { dg-final { scan-assembler \"%ecx, %eax\" } }\n+    id(1);\n }"}, {"sha": "4fb6a29c8c1bf0a474ed3d3484a4be6b19dcdfc8", "filename": "gcc/testsuite/rust/execute/torture/macro-issue1426.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacro-issue1426.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacro-issue1426.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacro-issue1426.rs?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -1,5 +1,3 @@\n-// { dg-additional-options -fdump-tree-ccp1-raw }\n-\n macro_rules! stmt {\n     ($s:stmt) => {\n         $s\n@@ -22,11 +20,10 @@ pub fn test() -> i32 {\n         let e = 5,\n         let f = b + c + d + e\n     );\n+\n     f\n-    // { dg-final { scan-tree-dump-times {gimple_return <14>} 1 ccp1 { target __OPTIMIZE__ } } }\n }\n \n-fn main() {\n-    let _ = test();\n+fn main() -> i32 {\n+    test() - 14\n }\n-", "previous_filename": "gcc/testsuite/rust/compile/torture/macro-issue1426.rs"}, {"sha": "57a0824ce0aa27343fe3ba1da7fae118ea8532ce", "filename": "gcc/testsuite/rust/execute/torture/overflow1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foverflow1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foverflow1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foverflow1.rs?ref=fc82b68cc1ee2778f2bfc53c5de47e5b36ac8b7c", "patch": "@@ -0,0 +1,20 @@\n+// { dg-shouldfail \"i8 overflow\" }\n+// { dg-options \"-fdump-tree-original\" }\n+\n+fn five() -> i8 {\n+    5\n+}\n+\n+extern \"C\" {\n+    fn printf(fmt: *const i8, ...);\n+}\n+\n+fn main() {\n+    let a = 127i8;\n+    let b = five();\n+\n+    // { dg-final { scan-tree-dump ADD_OVERFLOW original } }\n+    let c = a + b;\n+\n+    unsafe { printf(\"%d\\n\\0\" as *const str as *const i8, c) }\n+}"}]}