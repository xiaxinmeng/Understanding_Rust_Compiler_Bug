{"sha": "0935784671e347118c6bf7629852ba50e9466a85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzNTc4NDY3MWUzNDcxMThjNmJmNzYyOTg1MmJhNTBlOTQ2NmE4NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-07-02T15:38:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-07-02T15:38:50Z"}, "message": "Implement WG21 N2672, Initializer List proposed wording\n\ngcc/cp/ChangeLog:\n2008-07-02  Jason Merrill  <jason@redhat.com>\n\nImplement WG21 N2672, Initializer List proposed wording\n* cp-tree.h (enum cp_tree_index): Add CPTI_INIT_LIST_TYPE.\n(struct lang_type_class): Add has_list_ctor bitfield.\n(TYPE_HAS_LIST_CTOR): New macro.\n(BRACE_ENCLOSED_INITIALIZER_P): Expect init_list_type_node.\n(CONSTRUCTOR_IS_DIRECT_INIT): New macro.\n(LOOKUP_NO_NARROWING): New macro.\n(LOOKUP_NO_COPY_CTOR_CONVERSION): New macro.\n* parser.c (cp_parse_braced_list): Split out from...\n(cp_parser_initializer_clause): ...here.\n(cp_parser_postfix_expression): Build up CONSTRUCTOR for compound \nliteral here.\n(cp_lexer_next_token_is_not_keyword): New fn.\n(cp_parser_parenthesized_expression_list): Handle { }.\n(cp_parser_new_expression, cp_parser_new_initializer): Likewise.\n(cp_parser_assignment_expression, cp_parser_condition): Likewise.\n(cp_parser_jump_statement, cp_parser_simple_declaration): Likewise.\n(cp_parser_mem_initializer, cp_parser_init_declarator): Likewise.\n(cp_parser_initializer, cp_parser_functional_cast): Likewise.\n(cp_parser_omp_for_loop, cp_parser_cache_group): Likewise.\n(cp_parser_save_member_function_body): Likewise.\n* call.c (conversion_kind): Add ck_list, ck_aggr.\n(struct conversion): Add check_narrowing bitfield, conversion list.\n(build_list_conv): New fn.\n(build_aggr_conv): New fn.\n(implicit_conversion): Call them.\n(standard_conversion): Set check_narrowing if appropriate.\n(add_function_candidate): Handle LOOKUP_NO_COPY_CTOR_CONVERSION.\n(build_user_type_conversion_1): When converting from an init list,\nwe allow additional conversions except when calling a copy ctor.\n(convert_like_real): Calling an explicit ctor for an init list is \nill-formed.  Handle ck_list and ck_addr.  Check narrowing.\n(build_new_method_call): If CONSTRUCTOR_IS_DIRECT_INIT is set and\nclass doesn't have a list ctor, break the {} into a TREE_LIST.\n(compare_ics): ck_list is better than other UDCs.\n(set_up_extended_ref_temp): Split out from initialize_reference.\n(is_std_init_list): New fn.\n(is_list_ctor): New fn.\n* decl.c (cxx_init_decl_processing): Create init_list_type_node.\n(reshape_init_array_1): Pass it to build_constructor.\n(reshape_init_class): Ditto.\n(initialize_artificial_var): Pass the appropriate type.\n(build_aggr_init_full_exprs): Split out from...\n(check_initializer): ...here.  Handle new semantics.\n(build_init_list_var_init): New subroutine of check_initializer.\n(grokdeclarator): Converting constructors can have more than one parm.\n(grok_special_member_properties): Set TYPE_HAS_LIST_CTOR.\n* init.c (expand_default_init): Only do digest_init for aggregates.\n* rtti.c (tinfo_base_init): Pass init_list_type_node to \nbuild_constructor_from_list.\n(generic_initializer, ptr_initializer): Ditto.\n(ptm_initializer, class_initializer): Ditto.\n(get_pseudo_ti_init): Ditto.\n* error.c (dump_type): Handle init_list_type_node.\n(maybe_warn_cpp0x): New fn.\n(maybe_varn_variadic_templates): Call it.\n* cvt.c (ocp_convert): Handle conversion from { }.\n* tree.c (build_array_of_n_type): New fn.\n* typeck2.c (store_init_value): Use init_list_type_node.\n(digest_init): Likewise.\n(check_narrowing): New fn.\n* semantics.c: (finish_compound_literal): Take CONSTRUCTOR instead \nof vector of constructor elts.  Handle non-aggregate types.  Make\nconstant literals static.\n* pt.c: (tsubst_copy_and_build): Adjust.\n(unify): Handle { }.\n* name-lookup.c (arg_assoc_type): Handle init_list_type_node.\n\ngcc/ChangeLog:\n2008-07-02  Jason Merrill  <jason@redhat.com>\n\n* tree.c (ctor_to_list): New fn.\n* tree.h: Declare it.\n(CONSTRUCTOR_ELT): New macro.\n(CONSTRUCTOR_NELTS): New macro.\n\nlibstdc++-v3/ChangeLog:\n2008-07-02  Jason Merrill  <jason@redhat.com>\n\n* libsupc++/initializer_list: New file.\n* include/bits/stl_map.h (insert(initializer_list)): New method.\n\nFrom-SVN: r137361", "tree": {"sha": "607689dbfbc953af02e19c2cf6b60aa4ddae34e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/607689dbfbc953af02e19c2cf6b60aa4ddae34e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0935784671e347118c6bf7629852ba50e9466a85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0935784671e347118c6bf7629852ba50e9466a85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0935784671e347118c6bf7629852ba50e9466a85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0935784671e347118c6bf7629852ba50e9466a85/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "906c5773db6775e8182c4ff74f5c835bca66ae4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906c5773db6775e8182c4ff74f5c835bca66ae4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/906c5773db6775e8182c4ff74f5c835bca66ae4e"}], "stats": {"total": 1486, "additions": 1212, "deletions": 274}, "files": [{"sha": "fad92a66f41e482cd8350eda7034b62fddc45df3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -1,3 +1,10 @@\n+2008-07-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.c (ctor_to_list): New fn.\n+\t* tree.h: Declare it.\n+\t(CONSTRUCTOR_ELT): New macro.\n+\t(CONSTRUCTOR_NELTS): New macro.\n+\n 2008-07-02  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (struct variable_info): Reorder"}, {"sha": "3bf8c97596df5aaa281563e0caa4fbf91280d5dc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -1,3 +1,73 @@\n+2008-07-02  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement WG21 N2672, Initializer List proposed wording\n+\t* cp-tree.h (enum cp_tree_index): Add CPTI_INIT_LIST_TYPE.\n+\t(struct lang_type_class): Add has_list_ctor bitfield.\n+\t(TYPE_HAS_LIST_CTOR): New macro.\n+\t(BRACE_ENCLOSED_INITIALIZER_P): Expect init_list_type_node.\n+\t(CONSTRUCTOR_IS_DIRECT_INIT): New macro.\n+\t(LOOKUP_NO_NARROWING): New macro.\n+\t(LOOKUP_NO_COPY_CTOR_CONVERSION): New macro.\n+\t* parser.c (cp_parse_braced_list): Split out from...\n+\t(cp_parser_initializer_clause): ...here.\n+\t(cp_parser_postfix_expression): Build up CONSTRUCTOR for compound \n+\tliteral here.\n+\t(cp_lexer_next_token_is_not_keyword): New fn.\n+\t(cp_parser_parenthesized_expression_list): Handle { }.\n+\t(cp_parser_new_expression, cp_parser_new_initializer): Likewise.\n+\t(cp_parser_assignment_expression, cp_parser_condition): Likewise.\n+\t(cp_parser_jump_statement, cp_parser_simple_declaration): Likewise.\n+\t(cp_parser_mem_initializer, cp_parser_init_declarator): Likewise.\n+\t(cp_parser_initializer, cp_parser_functional_cast): Likewise.\n+\t(cp_parser_omp_for_loop, cp_parser_cache_group): Likewise.\n+\t(cp_parser_save_member_function_body): Likewise.\n+\t* call.c (conversion_kind): Add ck_list, ck_aggr.\n+\t(struct conversion): Add check_narrowing bitfield, conversion list.\n+\t(build_list_conv): New fn.\n+\t(build_aggr_conv): New fn.\n+\t(implicit_conversion): Call them.\n+\t(standard_conversion): Set check_narrowing if appropriate.\n+\t(add_function_candidate): Handle LOOKUP_NO_COPY_CTOR_CONVERSION.\n+\t(build_user_type_conversion_1): When converting from an init list,\n+\twe allow additional conversions except when calling a copy ctor.\n+\t(convert_like_real): Calling an explicit ctor for an init list is \n+\till-formed.  Handle ck_list and ck_addr.  Check narrowing.\n+\t(build_new_method_call): If CONSTRUCTOR_IS_DIRECT_INIT is set and\n+\tclass doesn't have a list ctor, break the {} into a TREE_LIST.\n+\t(compare_ics): ck_list is better than other UDCs.\n+\t(set_up_extended_ref_temp): Split out from initialize_reference.\n+\t(is_std_init_list): New fn.\n+\t(is_list_ctor): New fn.\n+\t* decl.c (cxx_init_decl_processing): Create init_list_type_node.\n+\t(reshape_init_array_1): Pass it to build_constructor.\n+\t(reshape_init_class): Ditto.\n+\t(initialize_artificial_var): Pass the appropriate type.\n+\t(build_aggr_init_full_exprs): Split out from...\n+\t(check_initializer): ...here.  Handle new semantics.\n+\t(build_init_list_var_init): New subroutine of check_initializer.\n+\t(grokdeclarator): Converting constructors can have more than one parm.\n+\t(grok_special_member_properties): Set TYPE_HAS_LIST_CTOR.\n+\t* init.c (expand_default_init): Only do digest_init for aggregates.\n+\t* rtti.c (tinfo_base_init): Pass init_list_type_node to \n+\tbuild_constructor_from_list.\n+\t(generic_initializer, ptr_initializer): Ditto.\n+\t(ptm_initializer, class_initializer): Ditto.\n+\t(get_pseudo_ti_init): Ditto.\n+\t* error.c (dump_type): Handle init_list_type_node.\n+\t(maybe_warn_cpp0x): New fn.\n+\t(maybe_varn_variadic_templates): Call it.\n+\t* cvt.c (ocp_convert): Handle conversion from { }.\n+\t* tree.c (build_array_of_n_type): New fn.\n+\t* typeck2.c (store_init_value): Use init_list_type_node.\n+\t(digest_init): Likewise.\n+\t(check_narrowing): New fn.\n+\t* semantics.c: (finish_compound_literal): Take CONSTRUCTOR instead \n+\tof vector of constructor elts.  Handle non-aggregate types.  Make\n+\tconstant literals static.\n+\t* pt.c: (tsubst_copy_and_build): Adjust.\n+\t(unify): Handle { }.\n+\t* name-lookup.c (arg_assoc_type): Handle init_list_type_node.\n+\t\n 2008-07-01  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* typeck.c (comp_ptr_ttypes_real): Use vector_targets_convertible_p."}, {"sha": "d41465db638451ff19deee95e619622d4b5c22fc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 304, "deletions": 64, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -54,6 +54,8 @@ typedef enum conversion_kind {\n   ck_ref_bind,\n   ck_user,\n   ck_ambig,\n+  ck_list,\n+  ck_aggr,\n   ck_rvalue\n } conversion_kind;\n \n@@ -96,6 +98,7 @@ struct conversion {\n      being bound to an lvalue expression or an rvalue reference is\n      being bound to an rvalue expression. */\n   BOOL_BITFIELD rvaluedness_matches_p: 1;\n+  BOOL_BITFIELD check_narrowing: 1;\n   /* The type of the expression resulting from the conversion.  */\n   tree type;\n   union {\n@@ -107,6 +110,8 @@ struct conversion {\n     /* The expression at the beginning of the conversion chain.  This\n        variant is used only if KIND is ck_identity or ck_ambig.  */\n     tree expr;\n+    /* The array of conversions for an initializer_list.  */\n+    conversion **list;\n   } u;\n   /* The function candidate corresponding to this conversion\n      sequence.  This field is only used if KIND is ck_user.  */\n@@ -174,6 +179,7 @@ static conversion *implicit_conversion (tree, tree, tree, bool, int);\n static conversion *standard_conversion (tree, tree, tree, bool, int);\n static conversion *reference_binding (tree, tree, tree, bool, int);\n static conversion *build_conv (conversion_kind, tree, conversion *);\n+static conversion *build_list_conv (tree, tree, int);\n static bool is_subseq (conversion *, conversion *);\n static conversion *maybe_handle_ref_bind (conversion **);\n static void maybe_handle_implicit_object (conversion **);\n@@ -529,9 +535,8 @@ build_conv (conversion_kind code, tree type, conversion *from)\n   conversion *t;\n   conversion_rank rank = CONVERSION_RANK (from);\n \n-  /* We can't use buildl1 here because CODE could be USER_CONV, which\n-     takes two arguments.  In that case, the caller is responsible for\n-     filling in the second argument.  */\n+  /* Note that the caller is responsible for filling in t->cand for\n+     user-defined conversions.  */\n   t = alloc_conversion (code);\n   t->type = type;\n   t->u.next = from;\n@@ -561,6 +566,83 @@ build_conv (conversion_kind code, tree type, conversion *from)\n   return t;\n }\n \n+/* Represent a conversion from CTOR, a braced-init-list, to TYPE, a\n+   specialization of std::initializer_list<T>, if such a conversion is\n+   possible.  */\n+\n+static conversion *\n+build_list_conv (tree type, tree ctor, int flags)\n+{\n+  tree elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (type), 0);\n+  unsigned len = CONSTRUCTOR_NELTS (ctor);\n+  conversion **subconvs = alloc_conversions (len);\n+  conversion *t;\n+  unsigned i;\n+  tree val;\n+\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (ctor), i, val)\n+    {\n+      conversion *sub\n+\t= implicit_conversion (elttype, TREE_TYPE (val), val,\n+\t\t\t       false, flags);\n+      if (sub == NULL)\n+\treturn NULL;\n+\n+      subconvs[i] = sub;\n+    }\n+\n+  t = alloc_conversion (ck_list);\n+  t->type = type;\n+  t->u.list = subconvs;\n+  t->rank = cr_exact;\n+\n+  for (i = 0; i < len; ++i)\n+    {\n+      conversion *sub = subconvs[i];\n+      if (sub->rank > t->rank)\n+\tt->rank = sub->rank;\n+      if (sub->user_conv_p)\n+\tt->user_conv_p = true;\n+      if (sub->bad_p)\n+\tt->bad_p = true;\n+    }\n+\n+  return t;\n+}\n+\n+/* Represent a conversion from CTOR, a braced-init-list, to TYPE, an\n+   aggregate class, if such a conversion is possible.  */\n+\n+static conversion *\n+build_aggr_conv (tree type, tree ctor, int flags)\n+{\n+  unsigned HOST_WIDE_INT i = 0;\n+  conversion *c;\n+  tree field = TYPE_FIELDS (type);\n+\n+  for (; field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+      if (i < CONSTRUCTOR_NELTS (ctor))\n+\t{\n+\t  constructor_elt *ce = CONSTRUCTOR_ELT (ctor, i);\n+\t  if (!can_convert_arg (TREE_TYPE (field), TREE_TYPE (ce->value),\n+\t\t\t\tce->value, flags))\n+\t    return NULL;\n+\t}\n+      else if (build_value_init (TREE_TYPE (field)) == error_mark_node)\n+\treturn NULL;\n+    }\n+\n+  c = alloc_conversion (ck_aggr);\n+  c->type = type;\n+  c->rank = cr_exact;\n+  c->user_conv_p = true;\n+  c->u.next = NULL;\n+  return c;\n+}\n+\n /* Build a representation of the identity conversion from EXPR to\n    itself.  The TYPE should match the type of EXPR, if EXPR is non-NULL.  */\n \n@@ -865,6 +947,9 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   else\n     return NULL;\n \n+  if (flags & LOOKUP_NO_NARROWING)\n+    conv->check_narrowing = true;\n+\n   return conv;\n }\n \n@@ -1296,6 +1381,10 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   if (conv)\n     return conv;\n \n+  if (is_std_init_list (to) && expr\n+      && BRACE_ENCLOSED_INITIALIZER_P (expr))\n+    return build_list_conv (to, expr, flags);\n+\n   if (expr != NULL_TREE\n       && (MAYBE_CLASS_TYPE_P (from)\n \t  || MAYBE_CLASS_TYPE_P (to))\n@@ -1305,6 +1394,11 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       int convflags = ((flags & LOOKUP_NO_TEMP_BIND)\n \t\t       |LOOKUP_ONLYCONVERTING);\n \n+      if (CLASS_TYPE_P (to)\n+\t  && !CLASSTYPE_NON_AGGREGATE (complete_type (to))\n+\t  && BRACE_ENCLOSED_INITIALIZER_P (expr))\n+\treturn build_aggr_conv (to, expr, flags);\n+\n       cand = build_user_type_conversion_1 (to, expr, convflags);\n       if (cand)\n \tconv = cand->second_conv;\n@@ -1431,6 +1525,7 @@ add_function_candidate (struct z_candidate **candidates,\n       if (parmnode)\n \t{\n \t  tree parmtype = TREE_VALUE (parmnode);\n+\t  int lflags = flags;\n \n \t  /* The type of the implicit object parameter ('this') for\n \t     overload resolution is not always the same as for the\n@@ -1449,8 +1544,12 @@ add_function_candidate (struct z_candidate **candidates,\n \t      parmtype = build_pointer_type (parmtype);\n \t    }\n \n+\t  if ((flags & LOOKUP_NO_COPY_CTOR_CONVERSION)\n+\t      && ctype && i == 0 && DECL_COPY_CONSTRUCTOR_P (fn))\n+\t    lflags |= LOOKUP_NO_CONVERSION;\n+\n \t  t = implicit_conversion (parmtype, argtype, arg,\n-\t\t\t\t   /*c_cast_p=*/false, flags);\n+\t\t\t\t   /*c_cast_p=*/false, lflags);\n \t}\n       else\n \t{\n@@ -2607,7 +2706,18 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       ctors = BASELINK_FUNCTIONS (ctors);\n \n       t = build_int_cst (build_pointer_type (totype), 0);\n-      args = build_tree_list (NULL_TREE, expr);\n+      if (BRACE_ENCLOSED_INITIALIZER_P (expr)\n+\t  && !TYPE_HAS_LIST_CTOR (totype))\n+\t{\n+\t  args = ctor_to_list (expr);\n+\t  /* We still allow more conversions within an init-list.  */\n+\t  flags = ((flags & ~LOOKUP_NO_CONVERSION)\n+\t\t   /* But not for the copy ctor.  */\n+\t\t   |LOOKUP_NO_COPY_CTOR_CONVERSION\n+\t\t   |LOOKUP_NO_NARROWING);\n+\t}\n+      else\n+\targs = build_tree_list (NULL_TREE, expr);\n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n@@ -2617,7 +2727,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   for (; ctors; ctors = OVL_NEXT (ctors))\n     {\n       tree ctor = OVL_CURRENT (ctors);\n-      if (DECL_NONCONVERTING_P (ctor))\n+      if (DECL_NONCONVERTING_P (ctor)\n+\t  && !BRACE_ENCLOSED_INITIALIZER_P (expr))\n \tcontinue;\n \n       if (TREE_CODE (ctor) == TEMPLATE_DECL)\n@@ -4443,6 +4554,17 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \ttree convfn = cand->fn;\n \tunsigned i;\n \n+\t/* When converting from an init list we consider explicit\n+\t   constructors, but actually trying to call one is an error.  */\n+\tif (DECL_NONCONVERTING_P (convfn))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"converting to %qT from initializer list would use \"\n+\t\t     \"explicit constructor %qD\", totype, convfn);\n+\t    else\n+\t      return error_mark_node;\n+\t  }\n+\n \t/* Set user_conv_p on the argument conversions, so rvalue/base\n \t   handling knows not to allow any more UDCs.  */\n \tfor (i = 0; i < cand->num_convs; ++i)\n@@ -4478,6 +4600,44 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       return build_user_type_conversion\n \t(totype, convs->u.expr, LOOKUP_NORMAL);\n \n+    case ck_list:\n+      {\n+\t/* Conversion to std::initializer_list<T>.  */\n+\ttree elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (totype), 0);\n+\ttree new_ctor = build_constructor (init_list_type_node, NULL);\n+\tunsigned len = CONSTRUCTOR_NELTS (expr);\n+\ttree array, parms, val;\n+\tunsigned ix;\n+\n+\t/* Convert all the elements.  */\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), ix, val)\n+\t  {\n+\t    tree sub = convert_like_real (convs->u.list[ix], val, fn, argnum,\n+\t\t\t\t\t  1, false, false, complain);\n+\t    if (sub == error_mark_node)\n+\t      return sub;\n+\t    check_narrowing (TREE_TYPE (sub), val);\n+\t    CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_ctor), NULL_TREE, sub);\n+\t  }\n+\t/* Build up the array.  */\n+\telttype = cp_build_qualified_type\n+\t  (elttype, TYPE_QUALS (elttype) | TYPE_QUAL_CONST);\n+\tarray = build_array_of_n_type (elttype, len);\n+\tarray = finish_compound_literal (array, new_ctor);\n+\n+\tparms = build_tree_list (NULL_TREE, size_int (len));\n+\tparms = tree_cons (NULL_TREE, decay_conversion (array), parms);\n+\t/* Call the private constructor.  */\n+\tpush_deferring_access_checks (dk_no_check);\n+\tnew_ctor = build_special_member_call\n+\t  (NULL_TREE, complete_ctor_identifier, parms, totype, 0, complain);\n+\tpop_deferring_access_checks ();\n+\treturn build_cplus_new (totype, new_ctor);\n+      }\n+\n+    case ck_aggr:\n+      return get_target_expr (digest_init (totype, expr));\n+\n     default:\n       break;\n     };\n@@ -4625,6 +4785,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       break;\n     }\n \n+  if (convs->check_narrowing)\n+    check_narrowing (totype, expr);\n+\n   if (issue_conversion_warnings)\n     expr = convert_and_check (totype, expr);\n   else\n@@ -5626,6 +5789,18 @@ build_new_method_call (tree instance, tree fns, tree args,\n   if (DECL_DESTRUCTOR_P (fn))\n     name = complete_dtor_identifier;\n \n+  /* If CONSTRUCTOR_IS_DIRECT_INIT is set, this was a T{ } form\n+     initializer, not T({ }).  If the type doesn't have a list ctor,\n+     break apart the list into separate ctor args.  */\n+  if (DECL_CONSTRUCTOR_P (fn) && args\n+      && BRACE_ENCLOSED_INITIALIZER_P (TREE_VALUE (args))\n+      && CONSTRUCTOR_IS_DIRECT_INIT (TREE_VALUE (args))\n+      && !TYPE_HAS_LIST_CTOR (basetype))\n+    {\n+      gcc_assert (TREE_CHAIN (args) == NULL_TREE);\n+      args = ctor_to_list (TREE_VALUE (args));\n+    }\n+\n   class_type = (conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE);\n   mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n \n@@ -5977,13 +6152,26 @@ compare_ics (conversion *ics1, conversion *ics2)\n       conversion *t1;\n       conversion *t2;\n \n-      for (t1 = ics1; t1->kind != ck_user; t1 = t1->u.next)\n-\tif (t1->kind == ck_ambig)\n+      for (t1 = ics1; t1->kind != ck_user && t1->kind != ck_list; t1 = t1->u.next)\n+\tif (t1->kind == ck_ambig || t1->kind == ck_aggr)\n \t  return 0;\n-      for (t2 = ics2; t2->kind != ck_user; t2 = t2->u.next)\n-\tif (t2->kind == ck_ambig)\n+      for (t2 = ics2; t2->kind != ck_user && t2->kind != ck_list; t2 = t2->u.next)\n+\tif (t2->kind == ck_ambig || t2->kind == ck_aggr)\n \t  return 0;\n \n+      /* Conversion to std::initializer_list is better than other\n+\t user-defined conversions.  */\n+      if (t1->kind == ck_list\n+\t  || t2->kind == ck_list)\n+\t{\n+\t  if (t2->kind != ck_list)\n+\t    return 1;\n+\t  else if (t1->kind != ck_list)\n+\t    return -1;\n+\t  else\n+\t    return 0;\n+\t}\n+\n       if (t1->cand->fn != t2->cand->fn)\n \treturn 0;\n \n@@ -6815,6 +7003,76 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n   return var;\n }\n \n+/* EXPR is the initializer for a variable DECL of reference or\n+   std::initializer_list type.  Create, push and return a new VAR_DECL\n+   for the initializer so that it will live as long as DECL.  Any\n+   cleanup for the new variable is returned through CLEANUP, and the\n+   code to initialize the new variable is returned through INITP.  */\n+\n+tree\n+set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n+{\n+  tree init;\n+  tree type;\n+  tree var;\n+\n+  /* Create the temporary variable.  */\n+  type = TREE_TYPE (expr);\n+  var = make_temporary_var_for_ref_to_temp (decl, type);\n+  layout_decl (var, 0);\n+  /* If the rvalue is the result of a function call it will be\n+     a TARGET_EXPR.  If it is some other construct (such as a\n+     member access expression where the underlying object is\n+     itself the result of a function call), turn it into a\n+     TARGET_EXPR here.  It is important that EXPR be a\n+     TARGET_EXPR below since otherwise the INIT_EXPR will\n+     attempt to make a bitwise copy of EXPR to initialize\n+     VAR.  */\n+  if (TREE_CODE (expr) != TARGET_EXPR)\n+    expr = get_target_expr (expr);\n+  /* Create the INIT_EXPR that will initialize the temporary\n+     variable.  */\n+  init = build2 (INIT_EXPR, type, var, expr);\n+  if (at_function_scope_p ())\n+    {\n+      add_decl_expr (var);\n+\n+      if (TREE_STATIC (var))\n+\tinit = add_stmt_to_compound (init, register_dtor_fn (var));\n+      else\n+\t*cleanup = cxx_maybe_build_cleanup (var);\n+\n+      /* We must be careful to destroy the temporary only\n+\t after its initialization has taken place.  If the\n+\t initialization throws an exception, then the\n+\t destructor should not be run.  We cannot simply\n+\t transform INIT into something like:\n+\n+\t (INIT, ({ CLEANUP_STMT; }))\n+\n+\t because emit_local_var always treats the\n+\t initializer as a full-expression.  Thus, the\n+\t destructor would run too early; it would run at the\n+\t end of initializing the reference variable, rather\n+\t than at the end of the block enclosing the\n+\t reference variable.\n+\n+\t The solution is to pass back a cleanup expression\n+\t which the caller is responsible for attaching to\n+\t the statement tree.  */\n+    }\n+  else\n+    {\n+      rest_of_decl_compilation (var, /*toplev=*/1, at_eof);\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+\tstatic_aggregates = tree_cons (NULL_TREE, var,\n+\t\t\t\t       static_aggregates);\n+    }\n+\n+  *initp = init;\n+  return var;\n+}\n+\n /* Convert EXPR to the indicated reference TYPE, in a way suitable for\n    initializing a variable of that TYPE.  If DECL is non-NULL, it is\n    the VAR_DECL being initialized with the EXPR.  (In that case, the\n@@ -6919,60 +7177,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t  if (!real_lvalue_p (expr))\n \t    {\n \t      tree init;\n-\t      tree type;\n-\n-\t      /* Create the temporary variable.  */\n-\t      type = TREE_TYPE (expr);\n-\t      var = make_temporary_var_for_ref_to_temp (decl, type);\n-\t      layout_decl (var, 0);\n-\t      /* If the rvalue is the result of a function call it will be\n-\t\t a TARGET_EXPR.  If it is some other construct (such as a\n-\t\t member access expression where the underlying object is\n-\t\t itself the result of a function call), turn it into a\n-\t\t TARGET_EXPR here.  It is important that EXPR be a\n-\t\t TARGET_EXPR below since otherwise the INIT_EXPR will\n-\t\t attempt to make a bitwise copy of EXPR to initialize\n-\t\t VAR.  */\n-\t      if (TREE_CODE (expr) != TARGET_EXPR)\n-\t\texpr = get_target_expr (expr);\n-\t      /* Create the INIT_EXPR that will initialize the temporary\n-\t\t variable.  */\n-\t      init = build2 (INIT_EXPR, type, var, expr);\n-\t      if (at_function_scope_p ())\n-\t\t{\n-\t\t  add_decl_expr (var);\n-\n-\t\t  if (TREE_STATIC (var))\n-\t\t    init = add_stmt_to_compound (init, register_dtor_fn (var));\n-\t\t  else\n-\t\t    *cleanup = cxx_maybe_build_cleanup (var);\n-\n-\t\t  /* We must be careful to destroy the temporary only\n-\t\t     after its initialization has taken place.  If the\n-\t\t     initialization throws an exception, then the\n-\t\t     destructor should not be run.  We cannot simply\n-\t\t     transform INIT into something like:\n-\n-\t\t\t (INIT, ({ CLEANUP_STMT; }))\n-\n-\t\t     because emit_local_var always treats the\n-\t\t     initializer as a full-expression.  Thus, the\n-\t\t     destructor would run too early; it would run at the\n-\t\t     end of initializing the reference variable, rather\n-\t\t     than at the end of the block enclosing the\n-\t\t     reference variable.\n-\n-\t\t     The solution is to pass back a cleanup expression\n-\t\t     which the caller is responsible for attaching to\n-\t\t     the statement tree.  */\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rest_of_decl_compilation (var, /*toplev=*/1, at_eof);\n-\t\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t\t    static_aggregates = tree_cons (NULL_TREE, var,\n-\t\t\t\t\t\t   static_aggregates);\n-\t\t}\n+\t      var = set_up_extended_ref_temp (decl, expr, cleanup, &init);\n \t      /* Use its address to initialize the reference variable.  */\n \t      expr = build_address (var);\n \t      if (base_conv_type)\n@@ -7003,4 +7208,39 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n   return expr;\n }\n \n+/* Returns true iff TYPE is some variant of std::initializer_list.  */\n+\n+bool\n+is_std_init_list (tree type)\n+{\n+  return (CLASS_TYPE_P (type)\n+\t  && CP_TYPE_CONTEXT (type) == std_node\n+\t  && strcmp (TYPE_NAME_STRING (type), \"initializer_list\") == 0);\n+}\n+\n+/* Returns true iff DECL is a list constructor: i.e. a constructor which\n+   will accept an argument list of a single std::initializer_list<T>.  */\n+\n+bool\n+is_list_ctor (tree decl)\n+{\n+  tree args = FUNCTION_FIRST_USER_PARMTYPE (decl);\n+  tree arg;\n+\n+  if (!args || args == void_list_node)\n+    return false;\n+\n+  arg = non_reference (TREE_VALUE (args));\n+  if (!is_std_init_list (arg))\n+    return false;\n+\n+  args = TREE_CHAIN (args);\n+\n+  if (args && args != void_list_node && !TREE_PURPOSE (args))\n+    /* There are more non-defaulted parms.  */\n+    return false;\n+\n+  return true;\n+}\n+\n #include \"gt-cp-call.h\""}, {"sha": "ed6ae0e810a6163198d89e4f0ee29d4aa24be5ce", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -59,6 +59,7 @@ struct diagnostic_info;\n       TEMPLATE_PARM_PARAMETER_PACK (in TEMPLATE_PARM_INDEX)\n       TYPE_REF_IS_RVALUE (in REFERENCE_TYPE)\n       ATTR_IS_DEPENDENT (in the TREE_LIST for an attribute)\n+      CONSTRUCTOR_IS_DIRECT_INIT (in CONSTRUCTOR)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -572,6 +573,7 @@ enum cp_tree_index\n \n     CPTI_CLASS_TYPE,\n     CPTI_UNKNOWN_TYPE,\n+    CPTI_INIT_LIST_TYPE,\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n@@ -637,6 +639,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n #define class_type_node\t\t\tcp_global_trees[CPTI_CLASS_TYPE]\n #define unknown_type_node\t\tcp_global_trees[CPTI_UNKNOWN_TYPE]\n+#define init_list_type_node\t\tcp_global_trees[CPTI_INIT_LIST_TYPE]\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n@@ -1126,6 +1129,7 @@ struct lang_type_class GTY(())\n   unsigned has_complex_assign_ref : 1;\n   unsigned non_aggregate : 1;\n   unsigned has_complex_dflt : 1;\n+  unsigned has_list_ctor : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1134,7 +1138,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 11;\n+  unsigned dummy : 10;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -1248,6 +1252,10 @@ struct lang_type GTY(())\n #define TYPE_HAS_CONST_INIT_REF(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->has_const_init_ref)\n \n+/* Nonzero if this class has an X(initializer_list<T>) constructor.  */\n+#define TYPE_HAS_LIST_CTOR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_list_ctor)\n+\n /* Nonzero if this class defines an overloaded operator new.  (An\n    operator new [] doesn't count.)  */\n #define TYPE_HAS_NEW_OPERATOR(NODE) \\\n@@ -2713,7 +2721,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* True if NODE is a brace-enclosed initializer.  */\n #define BRACE_ENCLOSED_INITIALIZER_P(NODE) \\\n-  (TREE_CODE (NODE) == CONSTRUCTOR && !TREE_TYPE (NODE))\n+  (TREE_CODE (NODE) == CONSTRUCTOR && TREE_TYPE (NODE) == init_list_type_node)\n \n /* True if NODE is a compound-literal, i.e., a brace-enclosed\n    initializer cast to a particular type.  */\n@@ -2725,6 +2733,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \t\t\t\t\t\t CONSTRUCTOR_ELTS (NODE)) \\\n \t\t\t\t   && !TREE_HAS_CONSTRUCTOR (NODE))\n \n+/* True if NODE is a init-list used as a direct-initializer, i.e.\n+   B b{1,2}, not B b({1,2}) or B b = {1,2}.  */\n+#define CONSTRUCTOR_IS_DIRECT_INIT(NODE) (TREE_LANG_FLAG_0 (CONSTRUCTOR_CHECK (NODE)))\n+\n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\\n@@ -3688,6 +3700,11 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define LOOKUP_HIDDEN (LOOKUP_PREFER_NAMESPACES << 1)\n /* Prefer that the lvalue be treated as an rvalue.  */\n #define LOOKUP_PREFER_RVALUE (LOOKUP_HIDDEN << 1)\n+/* We're inside an init-list, so narrowing conversions are ill-formed.  */\n+#define LOOKUP_NO_NARROWING (LOOKUP_PREFER_RVALUE << 1)\n+/* Avoid user-defined conversions for the first parameter of a copy\n+   constructor.  */\n+#define LOOKUP_NO_COPY_CTOR_CONVERSION (LOOKUP_NO_NARROWING << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -4084,6 +4101,7 @@ extern tree cxx_type_promotes_to\t\t(tree);\n extern tree type_passed_as\t\t\t(tree);\n extern tree convert_for_arg_passing\t\t(tree, tree);\n extern bool is_properly_derived_from\t\t(tree, tree);\n+extern tree set_up_extended_ref_temp\t\t(tree, tree, tree *, tree *);\n extern tree initialize_reference\t\t(tree, tree, tree, tree *);\n extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n extern tree strip_top_quals\t\t\t(tree);\n@@ -4092,6 +4110,8 @@ extern tree perform_direct_initialization_if_possible (tree, tree, bool,\n                                                        tsubst_flags_t);\n extern tree in_charge_arg_for_name\t\t(tree);\n extern tree build_cxx_call\t\t\t(tree, int, tree *);\n+extern bool is_std_init_list\t\t\t(tree);\n+extern bool is_list_ctor\t\t\t(tree);\n #ifdef ENABLE_CHECKING\n extern void validate_conversion_obstack\t\t(void);\n #endif /* ENABLE_CHECKING */\n@@ -4311,6 +4331,7 @@ extern const char *language_to_string\t\t(enum languages);\n extern const char *class_key_or_enum_as_string\t(tree);\n extern void print_instantiation_context\t\t(void);\n extern void maybe_warn_variadic_templates       (void);\n+extern void maybe_warn_cpp0x\t\t\t(const char *);\n \n /* in except.c */\n extern void init_exception_processing\t\t(void);\n@@ -4622,7 +4643,7 @@ extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr\t\t(enum tree_code, tree);\n-extern tree finish_compound_literal\t\t(tree, VEC(constructor_elt,gc) *);\n+extern tree finish_compound_literal\t\t(tree, tree);\n extern tree finish_fname\t\t\t(tree);\n extern void finish_translation_unit\t\t(void);\n extern tree finish_template_type_parm\t\t(tree, tree);\n@@ -4707,6 +4728,7 @@ extern tree build_min_non_dep_call_list\t\t(tree, tree, tree);\n extern tree build_cplus_new\t\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree build_cplus_array_type\t\t(tree, tree);\n+extern tree build_array_of_n_type\t\t(tree, int);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern tree build_qualified_name\t\t(tree, tree, tree, bool);\n@@ -4861,6 +4883,7 @@ extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n \n extern tree store_init_value\t\t\t(tree, tree);\n+extern void check_narrowing\t\t\t(tree, tree);\n extern tree digest_init\t\t\t\t(tree, tree);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree);\n@@ -4882,6 +4905,7 @@ extern tree mangle_thunk\t\t\t(tree, int, tree, tree);\n extern tree mangle_conv_op_name_for_type\t(tree);\n extern tree mangle_guard_variable\t\t(tree);\n extern tree mangle_ref_init_variable\t\t(tree);\n+extern tree mangle_compound_literal\t\t(void);\n \n /* in dump.c */\n extern bool cp_dump_tree\t\t\t(void *, tree);"}, {"sha": "70ef00a4fce6db9c9092848a473dee0c946797d7", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -725,8 +725,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (abstract_virtuals_error (NULL_TREE, type))\n \treturn error_mark_node;\n \n-      if ((flags & LOOKUP_ONLYCONVERTING)\n-\t  && ! (MAYBE_CLASS_TYPE_P (dtype) && DERIVED_FROM_P (type, dtype)))\n+      if (BRACE_ENCLOSED_INITIALIZER_P (ctor))\n+\tctor = perform_implicit_conversion (type, ctor, tf_warning_or_error);\n+      else if ((flags & LOOKUP_ONLYCONVERTING)\n+\t       && ! (CLASS_TYPE_P (dtype) && DERIVED_FROM_P (type, dtype)))\n \t/* For copy-initialization, first we create a temp of the proper type\n \t   with a user-defined conversion sequence, then we direct-initialize\n \t   the target with the temp (see [dcl.init]).  */"}, {"sha": "a5a5574d7b4d29061462fde72dd41cb814f99133", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 98, "deletions": 75, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -3344,6 +3344,9 @@ cxx_init_decl_processing (void)\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n+  init_list_type_node = make_node (UNKNOWN_TYPE);\n+  record_unknown_type (init_list_type_node, \"init list\");\n+\n   {\n     /* Make sure we get a unique function type, so we can give\n        its pointer type a name.  (This wins for gdb.) */\n@@ -4295,6 +4298,39 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n   return NULL_TREE;\n }\n \n+/* Subroutine of check_initializer.  We're initializing a DECL of\n+   std::initializer_list<T> TYPE from a braced-init-list INIT, and need to\n+   extend the lifetime of the underlying array to match that of the decl,\n+   just like for reference initialization.  CLEANUP is as for\n+   grok_reference_init.  */\n+\n+static tree\n+build_init_list_var_init (tree decl, tree type, tree init, tree *cleanup)\n+{\n+  tree aggr_init, array, arrtype;\n+  init = perform_implicit_conversion (type, init, tf_warning_or_error);\n+  aggr_init = TARGET_EXPR_INITIAL (init);\n+  init = build2 (INIT_EXPR, type, decl, init);\n+\n+  array = AGGR_INIT_EXPR_ARG (aggr_init, 1);\n+  arrtype = TREE_TYPE (array);\n+  STRIP_NOPS (array);\n+  gcc_assert (TREE_CODE (array) == ADDR_EXPR);\n+  array = TREE_OPERAND (array, 0);\n+  /* If the array is constant, finish_compound_literal already made it a\n+     static variable and we don't need to do anything here.  */\n+  if (decl && TREE_CODE (array) == TARGET_EXPR)\n+    {\n+      tree subinit;\n+      tree var = set_up_extended_ref_temp (decl, array, cleanup, &subinit);\n+      var = build_address (var);\n+      var = convert (arrtype, var);\n+      AGGR_INIT_EXPR_ARG (aggr_init, 1) = var;\n+      init = build2 (COMPOUND_EXPR, TREE_TYPE (init), subinit, init);\n+    }\n+  return init;\n+}\n+\n /* Designated initializers in arrays are not supported in GNU C++.\n    The parser cannot detect this error since it does not know whether\n    a given brace-enclosed initializer is for a class type or for an\n@@ -4573,7 +4609,7 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d)\n   unsigned HOST_WIDE_INT index;\n \n   /* The initializer for an array is always a CONSTRUCTOR.  */\n-  new_init = build_constructor (NULL_TREE, NULL);\n+  new_init = build_constructor (init_list_type_node, NULL);\n \n   if (sized_array_p)\n     {\n@@ -4668,7 +4704,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n   gcc_assert (CLASS_TYPE_P (type));\n \n   /* The initializer for a class is always a CONSTRUCTOR.  */\n-  new_init = build_constructor (NULL_TREE, NULL);\n+  new_init = build_constructor (init_list_type_node, NULL);\n   field = next_initializable_field (TYPE_FIELDS (type));\n \n   if (!field)\n@@ -4926,6 +4962,26 @@ check_array_initializer (tree decl, tree type, tree init)\n   return false;\n }\n \n+/* Subroutine of check_initializer; args are passed down from that function.\n+   Set stmts_are_full_exprs_p to 1 across a call to build_aggr_init.  */\n+\n+static tree\n+build_aggr_init_full_exprs (tree decl, tree init, int flags)\n+     \n+{\n+  int saved_stmts_are_full_exprs_p = 0;\n+  if (building_stmt_tree ())\n+    {\n+      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n+      current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n+    }\n+  init = build_aggr_init (decl, init, flags, tf_warning_or_error);\n+  if (building_stmt_tree ())\n+    current_stmt_tree ()->stmts_are_full_exprs_p =\n+      saved_stmts_are_full_exprs_p;\n+  return init;\n+}\n+\n /* Verify INIT (the initializer for DECL), and record the\n    initialization in DECL_INITIAL, if appropriate.  CLEANUP is as for\n    grok_reference_init.\n@@ -4967,23 +5023,19 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n       int init_len = VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init));\n       if (SCALAR_TYPE_P (type))\n \t{\n-\t  if (init_len != 1)\n+\t  if (init_len == 0)\n+\t    {\n+\t      maybe_warn_cpp0x (\"extended initializer lists\");\n+\t      init = build_zero_init (type, NULL_TREE, false);\n+\t    }\n+\t  else if (init_len != 1)\n \t    {\n \t      error (\"scalar object %qD requires one element in initializer\",\n \t\t     decl);\n \t      TREE_TYPE (decl) = error_mark_node;\n \t      return NULL_TREE;\n \t    }\n \t}\n-      else if ((cxx_dialect == cxx98) && !CP_AGGREGATE_TYPE_P (type))\n-\t{\n-\t  /* A non-aggregate that is not a scalar cannot be initialized\n-\t     via an initializer-list in C++98.  */\n-\t  error (\"braces around initializer for non-aggregate type %qT\",\n-\t\t type);\n-\t  TREE_TYPE (decl) = error_mark_node;\n-\t  return NULL_TREE;\n-\t}\n     }\n \n   if (TREE_CODE (decl) == CONST_DECL)\n@@ -5001,17 +5053,26 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     {\n       /* Do not reshape constructors of vectors (they don't need to be\n \t reshaped.  */\n-      if (TREE_CODE (init) == CONSTRUCTOR\n-\t  && !COMPOUND_LITERAL_P (init)\n-\t  && !TREE_TYPE (init))  /* ptrmemfunc */\n+      if (BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n-\t  init = reshape_init (type, init);\n-\n-\t  if ((*targetm.vector_opaque_p) (type))\n+\t  if (is_std_init_list (type))\n+\t    return build_init_list_var_init (decl, type, init, cleanup);\n+\t  else if (TYPE_NON_AGGREGATE_CLASS (type))\n+\t    {\n+\t      /* Don't reshape if the class has constructors.  */\n+\t      if (cxx_dialect == cxx98)\n+\t\terror (\"in C++98 %qD must be initialized by constructor, \"\n+\t\t       \"not by %<{...}%>\",\n+\t\t       decl);\n+\t      init = build_tree_list (NULL_TREE, init);\n+\t    }\n+\t  else if ((*targetm.vector_opaque_p) (type))\n \t    {\n \t      error (\"opaque vector types cannot be initialized\");\n \t      init = error_mark_node;\n \t    }\n+\t  else\n+\t    init = reshape_init (type, init);\t    \n \t}\n \n       /* If DECL has an array type without a specific bound, deduce the\n@@ -5021,60 +5082,26 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n       if (type == error_mark_node)\n \treturn NULL_TREE;\n \n-      if (TREE_CODE (type) == ARRAY_TYPE && TYPE_NEEDS_CONSTRUCTING (type))\n-\tgoto initialize_aggr;\n-      else if (CLASS_TYPE_P (type))\n+      if (TYPE_NEEDS_CONSTRUCTING (type)\n+\t  || (CLASS_TYPE_P (type)\n+\t      && !BRACE_ENCLOSED_INITIALIZER_P (init)))\n+\treturn build_aggr_init_full_exprs (decl, init, flags);\n+      else if (TREE_CODE (init) != TREE_VEC)\n \t{\n-\t  if (TREE_CODE (init) == CONSTRUCTOR)\n-\t    {\n-\t      if (TYPE_NON_AGGREGATE_CLASS (type))\n-\t\t{\n-\t\t  error (\"%qD must be initialized by constructor, \"\n-\t\t\t \"not by %<{...}%>\",\n-\t\t\t decl);\n-\t\t  init = error_mark_node;\n-\t\t}\n-\t      else\n-\t\tgoto dont_use_constructor;\n-\t    }\n-\t  else\n-\t    {\n-\t      int saved_stmts_are_full_exprs_p;\n-\n-\t    initialize_aggr:\n-\t      saved_stmts_are_full_exprs_p = 0;\n-\t      if (building_stmt_tree ())\n-\t\t{\n-\t\t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n-\t\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-\t\t}\n-\t      init = build_aggr_init (decl, init, flags, tf_warning_or_error);\n-\t      if (building_stmt_tree ())\n-\t\tcurrent_stmt_tree ()->stmts_are_full_exprs_p =\n-\t\t  saved_stmts_are_full_exprs_p;\n-\t      return init;\n-\t    }\n-\t}\n-      else\n-\t{\n-\tdont_use_constructor:\n-\t  if (TREE_CODE (init) != TREE_VEC)\n-\t    {\n-\t      init_code = store_init_value (decl, init);\n-\t      if (pedantic && TREE_CODE (type) == ARRAY_TYPE\n-\t\t  && DECL_INITIAL (decl)\n-\t\t  && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n-\t\t  && PAREN_STRING_LITERAL_P (DECL_INITIAL (decl)))\n-\t\twarning (0, \"array %qD initialized by parenthesized string literal %qE\",\n-\t\t\t decl, DECL_INITIAL (decl));\n-\t      init = NULL;\n-\t    }\n+\t  init_code = store_init_value (decl, init);\n+\t  if (pedantic && TREE_CODE (type) == ARRAY_TYPE\n+\t      && DECL_INITIAL (decl)\n+\t      && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n+\t      && PAREN_STRING_LITERAL_P (DECL_INITIAL (decl)))\n+\t    warning (0, \"array %qD initialized by parenthesized string literal %qE\",\n+\t\t     decl, DECL_INITIAL (decl));\n+\t  init = NULL;\n \t}\n     }\n   else if (DECL_EXTERNAL (decl))\n     ;\n   else if (TYPE_P (type) && TYPE_NEEDS_CONSTRUCTING (type))\n-    goto initialize_aggr;\n+    return build_aggr_init_full_exprs (decl, init, flags);\n   else if (MAYBE_CLASS_TYPE_P (type))\n     {\n       tree core_type = strip_array_types (type);\n@@ -5311,7 +5338,7 @@ initialize_artificial_var (tree decl, tree init)\n {\n   gcc_assert (DECL_ARTIFICIAL (decl));\n   if (TREE_CODE (init) == TREE_LIST)\n-    init = build_constructor_from_list (NULL_TREE, init);\n+    init = build_constructor_from_list (TREE_TYPE (decl), init);\n   gcc_assert (TREE_CODE (init) == CONSTRUCTOR);\n   DECL_INITIAL (decl) = init;\n   DECL_INITIALIZED_P (decl) = 1;\n@@ -8921,17 +8948,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t      DECL_NONCONVERTING_P (decl) = 1;\n \t    else if (DECL_CONSTRUCTOR_P (decl))\n \t      {\n-\t\t/* The constructor can be called with exactly one\n-\t\t   parameter if there is at least one parameter, and\n-\t\t   any subsequent parameters have default arguments.\n+\t\t/* A constructor with no parms is not a conversion.\n \t\t   Ignore any compiler-added parms.  */\n \t\ttree arg_types = FUNCTION_FIRST_USER_PARMTYPE (decl);\n \n-\t\tif (arg_types == void_list_node\n-\t\t    || (arg_types\n-\t\t\t&& TREE_CHAIN (arg_types)\n-\t\t\t&& TREE_CHAIN (arg_types) != void_list_node\n-\t\t\t&& !TREE_PURPOSE (TREE_CHAIN (arg_types))))\n+\t\tif (arg_types == void_list_node)\n \t\t  DECL_NONCONVERTING_P (decl) = 1;\n \t      }\n \t  }\n@@ -9646,6 +9667,8 @@ grok_special_member_properties (tree decl)\n \t}\n       else if (sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (decl)))\n \tTYPE_HAS_DEFAULT_CONSTRUCTOR (class_type) = 1;\n+      else if (is_list_ctor (decl))\n+\tTYPE_HAS_LIST_CTOR (class_type) = 1;\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n     {"}, {"sha": "80aa6e962d2344ee2ef0bb138b14e40bdb273648", "filename": "gcc/cp/error.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -284,7 +284,10 @@ dump_type (tree t, int flags)\n   switch (TREE_CODE (t))\n     {\n     case UNKNOWN_TYPE:\n-      pp_identifier (cxx_pp, \"<unresolved overloaded function type>\");\n+      if (t == init_list_type_node)\n+\tpp_identifier (cxx_pp, \"<brace-enclosed initializer list>\");\n+      else\n+\tpp_identifier (cxx_pp, \"<unresolved overloaded function type>\");\n       break;\n \n     case TREE_LIST:\n@@ -2674,13 +2677,20 @@ cp_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,\n   report_diagnostic (&diagnostic);\n }\n \n-/* Warn about the use of variadic templates when appropriate.  */\n+/* Warn about the use of C++0x features when appropriate.  */\n void\n-maybe_warn_variadic_templates (void)\n+maybe_warn_cpp0x (const char* str)\n {\n   if ((cxx_dialect == cxx98) && !in_system_header)\n     /* We really want to suppress this warning in system headers,\n        because libstdc++ uses variadic templates even when we aren't\n        in C++0x mode. */\n-    pedwarn (\"ISO C++ does not include variadic templates\");\n+    pedwarn (\"%s only available with -std=c++0x\", str);\n+}\n+\n+/* Warn about the use of variadic templates when appropriate.  */\n+void\n+maybe_warn_variadic_templates (void)\n+{\n+  maybe_warn_cpp0x (\"variadic templates\");\n }"}, {"sha": "3e9e612f2b49cd6cdc0ba081b37cd52e410d6f79", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -1334,10 +1334,10 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t   to run a new constructor; and catching an exception, where we\n \t   have already built up the constructor call so we could wrap it\n \t   in an exception region.  */;\n-      else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+      else if (BRACE_ENCLOSED_INITIALIZER_P (init)\n+\t       && CP_AGGREGATE_TYPE_P (type))\n \t{\n \t  /* A brace-enclosed initializer for an aggregate.  */\n-\t  gcc_assert (CP_AGGREGATE_TYPE_P (type));\n \t  init = digest_init (type, init);\n \t}\n       else"}, {"sha": "e42f60afba79229771016af932f029bfbf140c78", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -4639,7 +4639,8 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n     case TYPENAME_TYPE:\n       return false;\n     case LANG_TYPE:\n-      gcc_assert (type == unknown_type_node);\n+      gcc_assert (type == unknown_type_node\n+\t\t  || type == init_list_type_node);\n       return false;\n     case TYPE_PACK_EXPANSION:\n       return arg_assoc_type (k, PACK_EXPANSION_PATTERN (type));"}, {"sha": "2323c6721665886ac4430ea8e18c9a4b9d1d9776", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 221, "deletions": 86, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -529,6 +529,14 @@ cp_lexer_next_token_is_keyword (cp_lexer* lexer, enum rid keyword)\n   return cp_lexer_peek_token (lexer)->keyword == keyword;\n }\n \n+/* Return true if the next token is not the indicated KEYWORD.  */\n+\n+static inline bool\n+cp_lexer_next_token_is_not_keyword (cp_lexer* lexer, enum rid keyword)\n+{\n+  return cp_lexer_peek_token (lexer)->keyword != keyword;\n+}\n+\n /* Return true if the next token is a keyword for a decl-specifier.  */\n \n static bool\n@@ -1743,6 +1751,8 @@ static tree cp_parser_initializer\n   (cp_parser *, bool *, bool *);\n static tree cp_parser_initializer_clause\n   (cp_parser *, bool *);\n+static tree cp_parser_braced_list\n+  (cp_parser*, bool*);\n static VEC(constructor_elt,gc) *cp_parser_initializer_list\n   (cp_parser *, bool *);\n \n@@ -1965,7 +1975,7 @@ static bool cp_parser_optional_template_keyword\n   (cp_parser *);\n static void cp_parser_pre_parsed_nested_name_specifier\n   (cp_parser *);\n-static void cp_parser_cache_group\n+static bool cp_parser_cache_group\n   (cp_parser *, enum cpp_ttype, unsigned);\n static void cp_parser_parse_tentatively\n   (cp_parser *);\n@@ -4534,7 +4544,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t  }\n \t\t/* Form the representation of the compound-literal.  */\n \t\tpostfix_expression\n-\t\t  = finish_compound_literal (type, initializer_list);\n+\t\t  = (finish_compound_literal\n+\t\t     (type, build_constructor (init_list_type_node,\n+\t\t\t\t\t       initializer_list)));\n \t\tbreak;\n \t      }\n \t  }\n@@ -5070,10 +5082,19 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t  }\n \telse\n \t  {\n+\t    bool expr_non_constant_p;\n+\n \t    /* Parse the next assignment-expression.  */\n-\t    if (non_constant_p)\n+\t    if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t      {\n+\t\t/* A braced-init-list.  */\n+\t\tmaybe_warn_cpp0x (\"extended initializer lists\");\n+\t\texpr = cp_parser_braced_list (parser, &expr_non_constant_p);\n+\t\tif (non_constant_p && expr_non_constant_p)\n+\t\t  *non_constant_p = true;\n+\t      }\n+\t    else if (non_constant_p)\n \t      {\n-\t\tbool expr_non_constant_p;\n \t\texpr = (cp_parser_constant_expression\n \t\t\t(parser, /*allow_non_constant_p=*/true,\n \t\t\t &expr_non_constant_p));\n@@ -5535,8 +5556,9 @@ cp_parser_new_expression (cp_parser* parser)\n   else\n     type = cp_parser_new_type_id (parser, &nelts);\n \n-  /* If the next token is a `(', then we have a new-initializer.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+  /* If the next token is a `(' or '{', then we have a new-initializer.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN)\n+      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     initializer = cp_parser_new_initializer (parser);\n   else\n     initializer = NULL_TREE;\n@@ -5748,6 +5770,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \n    new-initializer:\n      ( expression-list [opt] )\n+     braced-init-list\n \n    Returns a representation of the expression-list.  If there is no\n    expression-list, VOID_ZERO_NODE is returned.  */\n@@ -5757,9 +5780,18 @@ cp_parser_new_initializer (cp_parser* parser)\n {\n   tree expression_list;\n \n-  expression_list = (cp_parser_parenthesized_expression_list\n-\t\t     (parser, false, /*cast_p=*/false, /*allow_expansion_p=*/true,\n-\t\t      /*non_constant_p=*/NULL));\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    {\n+      bool expr_non_constant_p;\n+      maybe_warn_cpp0x (\"extended initializer lists\");\n+      expression_list = cp_parser_braced_list (parser, &expr_non_constant_p);\n+      CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;\n+      expression_list = build_tree_list (NULL_TREE, expression_list);\n+    }\n+  else\n+    expression_list = (cp_parser_parenthesized_expression_list\n+\t\t       (parser, false, /*cast_p=*/false, /*allow_expansion_p=*/true,\n+\t\t\t/*non_constant_p=*/NULL));\n   if (!expression_list)\n     expression_list = void_zero_node;\n \n@@ -6208,10 +6240,14 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p)\n \t    = cp_parser_assignment_operator_opt (parser);\n \t  if (assignment_operator != ERROR_MARK)\n \t    {\n-\t      tree rhs;\n+\t      bool non_constant_p;\n \n \t      /* Parse the right-hand side of the assignment.  */\n-\t      rhs = cp_parser_assignment_expression (parser, cast_p);\n+\t      tree rhs = cp_parser_initializer_clause (parser, &non_constant_p);\n+\n+\t      if (BRACE_ENCLOSED_INITIALIZER_P (rhs))\n+\t\tmaybe_warn_cpp0x (\"extended initializer lists\");\n+\n \t      /* An assignment may not appear in a\n \t\t constant-expression.  */\n \t      if (cp_parser_non_integral_constant_expression (parser,\n@@ -7124,7 +7160,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \n    condition:\n      expression\n-     type-specifier-seq declarator = assignment-expression\n+     type-specifier-seq declarator = initializer-clause\n+     type-specifier-seq declarator braced-init-list\n \n    GNU Extension:\n \n@@ -7170,39 +7207,55 @@ cp_parser_condition (cp_parser* parser)\n       attributes = cp_parser_attributes_opt (parser);\n       /* Parse the asm-specification.  */\n       asm_specification = cp_parser_asm_specification_opt (parser);\n-      /* If the next token is not an `=', then we might still be\n+      /* If the next token is not an `=' or '{', then we might still be\n \t looking at an expression.  For example:\n \n \t   if (A(a).x)\n \n \t looks like a decl-specifier-seq and a declarator -- but then\n \t there is no `=', so this is an expression.  */\n-      cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n-      /* If we did see an `=', then we are looking at a declaration\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ)\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n+\tcp_parser_simulate_error (parser);\n+\t\n+      /* If we did see an `=' or '{', then we are looking at a declaration\n \t for sure.  */\n       if (cp_parser_parse_definitely (parser))\n \t{\n \t  tree pushed_scope;\n \t  bool non_constant_p;\n+\t  bool flags = LOOKUP_ONLYCONVERTING;\n \n \t  /* Create the declaration.  */\n \t  decl = start_decl (declarator, &type_specifiers,\n \t\t\t     /*initialized_p=*/true,\n \t\t\t     attributes, /*prefix_attributes=*/NULL_TREE,\n \t\t\t     &pushed_scope);\n-\t  /* Parse the assignment-expression.  */\n-\t  initializer\n-\t    = cp_parser_constant_expression (parser,\n-\t\t\t\t\t     /*allow_non_constant_p=*/true,\n-\t\t\t\t\t     &non_constant_p);\n+\n+\t  /* Parse the initializer.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t    {\n+\t      initializer = cp_parser_braced_list (parser, &non_constant_p);\n+\t      CONSTRUCTOR_IS_DIRECT_INIT (initializer) = 1;\n+\t      flags = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Consume the `='.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      initializer = cp_parser_initializer_clause (parser, &non_constant_p);\n+\t    }\n+\t  if (BRACE_ENCLOSED_INITIALIZER_P (initializer))\n+\t    maybe_warn_cpp0x (\"extended initializer lists\");\n+\n \t  if (!non_constant_p)\n \t    initializer = fold_non_dependent_expr (initializer);\n \n \t  /* Process the initializer.  */\n \t  cp_finish_decl (decl,\n \t\t\t  initializer, !non_constant_p,\n \t\t\t  asm_specification,\n-\t\t\t  LOOKUP_ONLYCONVERTING);\n+\t\t\t  flags);\n \n \t  if (pushed_scope)\n \t    pop_scope (pushed_scope);\n@@ -7426,6 +7479,7 @@ cp_parser_for_init_statement (cp_parser* parser)\n      break ;\n      continue ;\n      return expression [opt] ;\n+     return braced-init-list ;\n      goto identifier ;\n \n    GNU extension:\n@@ -7496,12 +7550,18 @@ cp_parser_jump_statement (cp_parser* parser)\n     case RID_RETURN:\n       {\n \ttree expr;\n+\tbool expr_non_constant_p;\n \n-\t/* If the next token is a `;', then there is no\n-\t   expression.  */\n-\tif (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\tif (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t  {\n+\t    maybe_warn_cpp0x (\"extended initializer lists\");\n+\t    expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n+\t  }\n+\telse if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \t  expr = cp_parser_expression (parser, /*cast_p=*/false);\n \telse\n+\t  /* If the next token is a `;', then there is no\n+\t     expression.  */\n \t  expr = NULL_TREE;\n \t/* Build the return-statement.  */\n \tstatement = finish_return_stmt (expr);\n@@ -7964,7 +8024,8 @@ cp_parser_simple_declaration (cp_parser* parser,\n      is not a parenthesis, then we must be looking at a declaration.\n      (After \"int (\" we might be looking at a functional cast.)  */\n   if (decl_specifiers.any_specifiers_p\n-      && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n+      && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN)\n+      && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n     cp_parser_commit_to_tentative_parse (parser);\n \n   /* Keep going until we hit the `;' at the end of the simple\n@@ -8907,6 +8968,7 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n \n    mem-initializer:\n      mem-initializer-id ( expression-list [opt] )\n+     mem-initializer-id braced-init-list\n \n    GNU extension:\n \n@@ -8937,11 +8999,20 @@ cp_parser_mem_initializer (cp_parser* parser)\n   if (member && !DECL_P (member))\n     in_base_initializer = 1;\n \n-  expression_list\n-    = cp_parser_parenthesized_expression_list (parser, false,\n-\t\t\t\t\t       /*cast_p=*/false,\n-                                               /*allow_expansion_p=*/true,\n-\t\t\t\t\t       /*non_constant_p=*/NULL);\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    {\n+      bool expr_non_constant_p;\n+      maybe_warn_cpp0x (\"extended initializer lists\");\n+      expression_list = cp_parser_braced_list (parser, &expr_non_constant_p);\n+      CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;\n+      expression_list = build_tree_list (NULL_TREE, expression_list);\n+    }\n+  else\n+    expression_list\n+      = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t\t /*cast_p=*/false,\n+\t\t\t\t\t\t /*allow_expansion_p=*/true,\n+\t\t\t\t\t\t /*non_constant_p=*/NULL);\n   if (expression_list == error_mark_node)\n     return error_mark_node;\n   if (!expression_list)\n@@ -12197,7 +12268,7 @@ cp_parser_init_declarator (cp_parser* parser,\n      initialized with \"= ..\", CPP_OPEN_PAREN if initialized with\n      \"(...)\".  */\n   enum cpp_ttype initialization_kind;\n-  bool is_parenthesized_init = false;\n+  bool is_direct_init = false;\n   bool is_non_constant_init;\n   int ctor_dtor_or_conv_p;\n   bool friend_p;\n@@ -12263,7 +12334,8 @@ cp_parser_init_declarator (cp_parser* parser,\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Check to see if the token indicates the start of a\n      function-definition.  */\n-  if (cp_parser_token_starts_function_definition_p (token))\n+  if (function_declarator_p (declarator)\n+      && cp_parser_token_starts_function_definition_p (token))\n     {\n       if (!function_definition_allowed_p)\n \t{\n@@ -12314,9 +12386,10 @@ cp_parser_init_declarator (cp_parser* parser,\n       return error_mark_node;\n     }\n \n-  /* An `=' or an `(' indicates an initializer.  */\n+  /* An `=' or an `(', or an '{' in C++0x, indicates an initializer.  */\n   if (token->type == CPP_EQ\n-      || token->type == CPP_OPEN_PAREN)\n+      || token->type == CPP_OPEN_PAREN\n+      || token->type == CPP_OPEN_BRACE)\n     {\n       is_initialized = true;\n       initialization_kind = token->type;\n@@ -12399,7 +12472,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Parse the initializer.  */\n   initializer = NULL_TREE;\n-  is_parenthesized_init = false;\n+  is_direct_init = false;\n   is_non_constant_init = true;\n   if (is_initialized)\n     {\n@@ -12422,15 +12495,16 @@ cp_parser_init_declarator (cp_parser* parser,\n \t}\n       else\n \tinitializer = cp_parser_initializer (parser,\n-\t\t\t\t\t     &is_parenthesized_init,\n+\t\t\t\t\t     &is_direct_init,\n \t\t\t\t\t     &is_non_constant_init);\n     }\n \n   /* The old parser allows attributes to appear after a parenthesized\n      initializer.  Mark Mitchell proposed removing this functionality\n      on the GCC mailing lists on 2002-08-13.  This parser accepts the\n      attributes -- but ignores them.  */\n-  if (cp_parser_allow_gnu_extensions_p (parser) && is_parenthesized_init)\n+  if (cp_parser_allow_gnu_extensions_p (parser)\n+      && initialization_kind == CPP_OPEN_PAREN)\n     if (cp_parser_attributes_opt (parser))\n       warning (OPT_Wattributes,\n \t       \"attributes after parenthesized initializer ignored\");\n@@ -12463,8 +12537,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t a direct-initialization, which means that an\n \t\t\t `explicit' constructor is OK.  Otherwise, an\n \t\t\t `explicit' constructor cannot be used.  */\n-\t\t      ((is_parenthesized_init || !is_initialized)\n-\t\t     ? 0 : LOOKUP_ONLYCONVERTING));\n+\t\t      ((is_direct_init || !is_initialized)\n+\t\t       ? 0 : LOOKUP_ONLYCONVERTING));\n     }\n   else if ((cxx_dialect != cxx98) && friend_p\n \t   && decl && TREE_CODE (decl) == FUNCTION_DECL)\n@@ -13983,14 +14057,14 @@ cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser)\n    Returns an expression representing the initializer.  If no\n    initializer is present, NULL_TREE is returned.\n \n-   *IS_PARENTHESIZED_INIT is set to TRUE if the `( expression-list )'\n-   production is used, and zero otherwise.  *IS_PARENTHESIZED_INIT is\n-   set to FALSE if there is no initializer present.  If there is an\n+   *IS_DIRECT_INIT is set to FALSE if the `= initializer-clause'\n+   production is used, and TRUE otherwise.  *IS_DIRECT_INIT is\n+   set to TRUE if there is no initializer present.  If there is an\n    initializer, and it is not a constant-expression, *NON_CONSTANT_P\n    is set to true; otherwise it is set to false.  */\n \n static tree\n-cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n+cp_parser_initializer (cp_parser* parser, bool* is_direct_init,\n \t\t       bool* non_constant_p)\n {\n   cp_token *token;\n@@ -14001,7 +14075,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n \n   /* Let our caller know whether or not this initializer was\n      parenthesized.  */\n-  *is_parenthesized_init = (token->type == CPP_OPEN_PAREN);\n+  *is_direct_init = (token->type != CPP_EQ);\n   /* Assume that the initializer is constant.  */\n   *non_constant_p = false;\n \n@@ -14017,6 +14091,12 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n \t\t\t\t\t\t    /*cast_p=*/false,\n                                                     /*allow_expansion_p=*/true,\n \t\t\t\t\t\t    non_constant_p);\n+  else if (token->type == CPP_OPEN_BRACE)\n+    {\n+      maybe_warn_cpp0x (\"extended initializer lists\");\n+      init = cp_parser_braced_list (parser, non_constant_p);\n+      CONSTRUCTOR_IS_DIRECT_INIT (init) = 1;\n+    }\n   else\n     {\n       /* Anything else is an error.  */\n@@ -14031,20 +14111,14 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n \n    initializer-clause:\n      assignment-expression\n-     { initializer-list , [opt] }\n-     { }\n+     braced-init-list\n \n    Returns an expression representing the initializer.\n \n    If the `assignment-expression' production is used the value\n    returned is simply a representation for the expression.\n \n-   Otherwise, a CONSTRUCTOR is returned.  The CONSTRUCTOR_ELTS will be\n-   the elements of the initializer-list (or NULL, if the last\n-   production is used).  The TREE_TYPE for the CONSTRUCTOR will be\n-   NULL_TREE.  There is no way to detect whether or not the optional\n-   trailing `,' was provided.  NON_CONSTANT_P is as for\n-   cp_parser_initializer.  */\n+   Otherwise, calls cp_parser_braced_list.  */\n \n static tree\n cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n@@ -14066,25 +14140,46 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n \tinitializer = fold_non_dependent_expr (initializer);\n     }\n   else\n+    initializer = cp_parser_braced_list (parser, non_constant_p);\n+\n+  return initializer;\n+}\n+\n+/* Parse a brace-enclosed initializer list.\n+\n+   braced-init-list:\n+     { initializer-list , [opt] }\n+     { }\n+\n+   Returns a CONSTRUCTOR.  The CONSTRUCTOR_ELTS will be\n+   the elements of the initializer-list (or NULL, if the last\n+   production is used).  The TREE_TYPE for the CONSTRUCTOR will be\n+   NULL_TREE.  There is no way to detect whether or not the optional\n+   trailing `,' was provided.  NON_CONSTANT_P is as for\n+   cp_parser_initializer.  */     \n+\n+static tree\n+cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n+{\n+  tree initializer;\n+\n+  /* Consume the `{' token.  */\n+  cp_lexer_consume_token (parser->lexer);\n+  /* Create a CONSTRUCTOR to represent the braced-initializer.  */\n+  initializer = make_node (CONSTRUCTOR);\n+  /* If it's not a `}', then there is a non-trivial initializer.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))\n     {\n-      /* Consume the `{' token.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      /* Create a CONSTRUCTOR to represent the braced-initializer.  */\n-      initializer = make_node (CONSTRUCTOR);\n-      /* If it's not a `}', then there is a non-trivial initializer.  */\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))\n-\t{\n-\t  /* Parse the initializer list.  */\n-\t  CONSTRUCTOR_ELTS (initializer)\n-\t    = cp_parser_initializer_list (parser, non_constant_p);\n-\t  /* A trailing `,' token is allowed.  */\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t}\n-      /* Now, there should be a trailing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+      /* Parse the initializer list.  */\n+      CONSTRUCTOR_ELTS (initializer)\n+\t= cp_parser_initializer_list (parser, non_constant_p);\n+      /* A trailing `,' token is allowed.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n     }\n-\n+  /* Now, there should be a trailing `}'.  */\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+  TREE_TYPE (initializer) = init_list_type_node;\n   return initializer;\n }\n \n@@ -17297,11 +17392,22 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n   tree expression_list;\n   tree cast;\n+  bool nonconst_p;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    {\n+      maybe_warn_cpp0x (\"extended initializer lists\");\n+      expression_list = cp_parser_braced_list (parser, &nonconst_p);\n+      CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;\n+      if (TREE_CODE (type) == TYPE_DECL)\n+\ttype = TREE_TYPE (type);\n+      return finish_compound_literal (type, expression_list);\n+    }\n \n   expression_list\n     = cp_parser_parenthesized_expression_list (parser, false,\n \t\t\t\t\t       /*cast_p=*/true,\n-                                               /*allow_expansion_p=*/true,\n+\t\t\t\t\t       /*allow_expansion_p=*/true,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n \n   cast = build_functional_cast (type, expression_list,\n@@ -17352,6 +17458,22 @@ cp_parser_save_member_function_body (cp_parser* parser,\n   /* Save away the tokens that make up the body of the\n      function.  */\n   first = parser->lexer->next_token;\n+  /* We can have braced-init-list mem-initializers before the fn body.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      while (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE)\n+\t     && cp_lexer_next_token_is_not_keyword (parser->lexer, RID_TRY))\n+\t{\n+\t  /* cache_group will stop after an un-nested { } pair, too.  */\n+\t  if (cp_parser_cache_group (parser, CPP_CLOSE_PAREN, /*depth=*/0))\n+\t    break;\n+\n+\t  /* variadic mem-inits have ... after the ')'.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t}\n+    }\n   cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);\n   /* Handle function try blocks.  */\n   while (cp_lexer_next_token_is_keyword (parser->lexer, RID_CATCH))\n@@ -18210,41 +18332,54 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n   parser->object_scope = NULL_TREE;\n }\n \n-/* Consume tokens up through a non-nested END token.  */\n+/* Consume tokens up through a non-nested END token.  Returns TRUE if we\n+   encounter the end of a block before what we were looking for.  */\n \n-static void\n+static bool\n cp_parser_cache_group (cp_parser *parser,\n \t\t       enum cpp_ttype end,\n \t\t       unsigned depth)\n {\n   while (true)\n     {\n-      cp_token *token;\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-      /* Abort a parenthesized expression if we encounter a brace.  */\n+      /* Abort a parenthesized expression if we encounter a semicolon.  */\n       if ((end == CPP_CLOSE_PAREN || depth == 0)\n-\t  && cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\treturn;\n+\t  && token->type == CPP_SEMICOLON)\n+\treturn true;\n       /* If we've reached the end of the file, stop.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_EOF)\n+      if (token->type == CPP_EOF\n \t  || (end != CPP_PRAGMA_EOL\n-\t      && cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA_EOL)))\n-\treturn;\n-      /* Consume the next token.  */\n-      token = cp_lexer_consume_token (parser->lexer);\n+\t      && token->type == CPP_PRAGMA_EOL))\n+\treturn true;\n+      if (token->type == CPP_CLOSE_BRACE && depth == 0)\n+\t/* We've hit the end of an enclosing block, so there's been some\n+\t   kind of syntax error.  */\n+\treturn true;\n+\n+      /* Consume the token.  */\n+      cp_lexer_consume_token (parser->lexer);\n       /* See if it starts a new group.  */\n       if (token->type == CPP_OPEN_BRACE)\n \t{\n \t  cp_parser_cache_group (parser, CPP_CLOSE_BRACE, depth + 1);\n+\t  /* In theory this should probably check end == '}', but\n+\t     cp_parser_save_member_function_body needs it to exit\n+\t     after either '}' or ')' when called with ')'.  */\n \t  if (depth == 0)\n-\t    return;\n+\t    return false;\n \t}\n       else if (token->type == CPP_OPEN_PAREN)\n-\tcp_parser_cache_group (parser, CPP_CLOSE_PAREN, depth + 1);\n+\t{\n+\t  cp_parser_cache_group (parser, CPP_CLOSE_PAREN, depth + 1);\n+\t  if (depth == 0 && end == CPP_CLOSE_PAREN)\n+\t    return false;\n+\t}\n       else if (token->type == CPP_PRAGMA)\n \tcp_parser_cache_group (parser, CPP_PRAGMA_EOL, depth + 1);\n       else if (token->type == end)\n-\treturn;\n+\treturn false;\n     }\n }\n \n@@ -20503,10 +20638,10 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t  if (CLASS_TYPE_P (TREE_TYPE (decl))\n \t\t      || type_dependent_expression_p (decl))\n \t\t    {\n-\t\t      bool is_parenthesized_init, is_non_constant_init;\n+\t\t      bool is_direct_init, is_non_constant_init;\n \n \t\t      init = cp_parser_initializer (parser,\n-\t\t\t\t\t\t    &is_parenthesized_init,\n+\t\t\t\t\t\t    &is_direct_init,\n \t\t\t\t\t\t    &is_non_constant_init);\n \n \t\t      cp_finish_decl (decl, init, !is_non_constant_init,"}, {"sha": "cce706f0705d3f1ce3fb0aa6db44a93ac2a5bf83", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -11507,6 +11507,7 @@ tsubst_copy_and_build (tree t,\n \tbool process_index_p;\n         int newlen;\n         bool need_copy_p = false;\n+\ttree r;\n \n \tif (type == error_mark_node)\n \t  return error_mark_node;\n@@ -11571,10 +11572,12 @@ tsubst_copy_and_build (tree t,\n               }\n           }\n \n+\tr = build_constructor (init_list_type_node, n);\n+\n \tif (TREE_HAS_CONSTRUCTOR (t))\n-\t  return finish_compound_literal (type, n);\n+\t  return finish_compound_literal (type, r);\n \n-\treturn build_constructor (NULL_TREE, n);\n+\treturn r;\n       }\n \n     case TYPEID_EXPR:\n@@ -12271,6 +12274,8 @@ type_unification_real (tree tparms,\n \t  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg,\n \t\t\t\t\t\t\t  arg_expr);\n \n+\tif (arg == init_list_type_node && arg_expr)\n+\t  arg = arg_expr;\n \tif (unify (tparms, targs, parm, arg, arg_strict))\n \t  return 1;\n       }\n@@ -13037,7 +13042,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n   if (arg == error_mark_node)\n     return 1;\n-  if (arg == unknown_type_node)\n+  if (arg == unknown_type_node\n+      || arg == init_list_type_node)\n     /* We can't deduce anything from this, but we might get all the\n        template args from other function args.  */\n     return 0;\n@@ -13049,6 +13055,31 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n   if (arg == parm && !uses_template_parms (parm))\n     return 0;\n \n+  /* Handle init lists early, so the rest of the function can assume\n+     we're dealing with a type. */\n+  if (BRACE_ENCLOSED_INITIALIZER_P (arg))\n+    {\n+      tree elt, elttype;\n+      unsigned i;\n+\n+      if (!is_std_init_list (parm))\n+\t/* We can only deduce from an initializer list argument if the\n+\t   parameter is std::initializer_list; otherwise this is a\n+\t   non-deduced context. */\n+\treturn 0;\n+\n+      elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (parm), 0);\n+\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (arg), i, elt)\n+\t{\n+\t  if (!BRACE_ENCLOSED_INITIALIZER_P (elt))\n+\t    elt = TREE_TYPE (elt);\n+\t  if (unify (tparms, targs, elttype, elt, UNIFY_ALLOW_NONE))\n+\t    return 1;\n+\t}\n+      return 0;\n+    }\n+\n   /* Immediately reject some pairs that won't unify because of\n      cv-qualification mismatches.  */\n   if (TREE_CODE (arg) == TREE_CODE (parm)"}, {"sha": "8a36f0b77b7d55c548799fa4c8b5a87ff32ab913", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -900,7 +900,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \n   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);\n \n-  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n+  init = build_constructor_from_list (init_list_type_node, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_STATIC (init) = 1;\n   init = tree_cons (NULL_TREE, init, NULL_TREE);\n@@ -917,7 +917,7 @@ generic_initializer (tinfo_s *ti, tree target)\n {\n   tree init = tinfo_base_init (ti, target);\n \n-  init = build_constructor_from_list (NULL_TREE, init);\n+  init = build_constructor_from_list (init_list_type_node, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_STATIC (init) = 1;\n   return init;\n@@ -942,7 +942,7 @@ ptr_initializer (tinfo_s *ti, tree target)\n \t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n \t\t    init);\n \n-  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n+  init = build_constructor_from_list (init_list_type_node, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_STATIC (init) = 1;\n   return init;\n@@ -974,7 +974,7 @@ ptm_initializer (tinfo_s *ti, tree target)\n \t\t    get_tinfo_ptr (klass),\n \t\t    init);\n \n-  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n+  init = build_constructor_from_list (init_list_type_node, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_STATIC (init) = 1;\n   return init;\n@@ -990,7 +990,7 @@ class_initializer (tinfo_s *ti, tree target, tree trail)\n   tree init = tinfo_base_init (ti, target);\n \n   TREE_CHAIN (init) = trail;\n-  init = build_constructor_from_list (NULL_TREE, init);\n+  init = build_constructor_from_list (init_list_type_node, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_STATIC (init) = 1;\n   return init;\n@@ -1102,10 +1102,10 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t\t\t\t  build_int_cst (offset_type, flags));\n \t    base_init = tree_cons (NULL_TREE, offset, base_init);\n \t    base_init = tree_cons (NULL_TREE, tinfo, base_init);\n-\t    base_init = build_constructor_from_list (NULL_TREE, base_init);\n+\t    base_init = build_constructor_from_list (init_list_type_node, base_init);\n \t    base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n \t  }\n-\tbase_inits = build_constructor_from_list (NULL_TREE, base_inits);\n+\tbase_inits = build_constructor_from_list (init_list_type_node, base_inits);\n \tbase_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n \t/* Prepend the number of bases.  */\n \tbase_inits = tree_cons (NULL_TREE,"}, {"sha": "fa65e9b28048a99a606cdc4f182723bef4b31d80", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -2099,21 +2099,17 @@ finish_unary_op_expr (enum tree_code code, tree expr)\n }\n \n /* Finish a compound-literal expression.  TYPE is the type to which\n-   the INITIALIZER_LIST is being cast.  */\n+   the CONSTRUCTOR in COMPOUND_LITERAL is being cast.  */\n \n tree\n-finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n+finish_compound_literal (tree type, tree compound_literal)\n {\n-  tree compound_literal;\n-\n   if (!TYPE_OBJ_P (type))\n     {\n       error (\"compound literal of non-object type %qT\", type);\n       return error_mark_node;\n     }\n \n-  /* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */\n-  compound_literal = build_constructor (NULL_TREE, initializer_list);\n   if (processing_template_decl)\n     {\n       TREE_TYPE (compound_literal) = type;\n@@ -2123,14 +2119,38 @@ finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n     }\n \n   type = complete_type (type);\n+\n+  if (TYPE_NON_AGGREGATE_CLASS (type))\n+    {\n+      /* Trying to deal with a CONSTRUCTOR instead of a TREE_LIST\n+\t everywhere that deals with function arguments would be a pain, so\n+\t just wrap it in a TREE_LIST.  The parser set a flag so we know\n+\t that it came from T{} rather than T({}).  */\n+      CONSTRUCTOR_IS_DIRECT_INIT (compound_literal) = 1;\n+      compound_literal = build_tree_list (NULL_TREE, compound_literal);\n+      return build_functional_cast (type, compound_literal, tf_error);\n+    }\n+\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && check_array_initializer (NULL_TREE, type, compound_literal))\n     return error_mark_node;\n   compound_literal = reshape_init (type, compound_literal);\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     cp_complete_array_type (&type, compound_literal, false);\n   compound_literal = digest_init (type, compound_literal);\n-  return get_target_expr (compound_literal);\n+  if ((!at_function_scope_p () || cp_type_readonly (type))\n+      && initializer_constant_valid_p (compound_literal, type))\n+    {\n+      tree decl = create_temporary_var (type);\n+      DECL_INITIAL (decl) = compound_literal;\n+      TREE_STATIC (decl) = 1;\n+      decl = pushdecl_top_level (decl);\n+      DECL_NAME (decl) = make_anon_name ();\n+      SET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));\n+      return decl;\n+    }\n+  else\n+    return get_target_expr (compound_literal);\n }\n \n /* Return the declaration for the function-name variable indicated by"}, {"sha": "b7c0a8d33b819b9863a565cb43f1e2086c8a2d13", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -616,6 +616,14 @@ build_cplus_array_type (tree elt_type, tree index_type)\n   return t;\n }\n \n+/* Return an ARRAY_TYPE with element type ELT and length N.  */\n+\n+tree\n+build_array_of_n_type (tree elt, int n)\n+{\n+  return build_cplus_array_type (elt, build_index_type (size_int (n - 1)));\n+}\n+\n /* Return a reference type node referring to TO_TYPE.  If RVAL is\n    true, return an rvalue reference type, otherwise return an lvalue\n    reference type.  If a type node exists, reuse it, otherwise create"}, {"sha": "4cf8021964f591ab995e6d5027c54e6da54e8174", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"diagnostic.h\"\n+#include \"real.h\"\n \n static tree\n process_init_constructor (tree type, tree init);\n@@ -592,7 +593,7 @@ store_init_value (tree decl, tree init)\n \t{\n \t  error (\"constructor syntax used, but no constructor declared \"\n \t\t \"for type %qT\", type);\n-\t  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n+\t  init = build_constructor_from_list (init_list_type_node, nreverse (init));\n \t}\n     }\n   else if (TREE_CODE (init) == TREE_LIST\n@@ -631,15 +632,70 @@ store_init_value (tree decl, tree init)\n }\n \n \f\n+/* Give errors about narrowing conversions within { }.  */\n+\n+void\n+check_narrowing (tree type, tree init)\n+{\n+  tree ftype = TREE_TYPE (init);\n+  bool ok = true;\n+  REAL_VALUE_TYPE d;\n+\n+  if (DECL_P (init))\n+    init = decl_constant_value (init);\n+\n+  if (TREE_CODE (type) == INTEGER_TYPE\n+      && TREE_CODE (ftype) == REAL_TYPE)\n+    ok = false;\n+  else if (INTEGRAL_OR_ENUMERATION_TYPE_P (ftype)\n+\t   && CP_INTEGRAL_TYPE_P (type))\n+    {\n+      if (TYPE_PRECISION (type) < TYPE_PRECISION (ftype)\n+\t  && (TREE_CODE (init) != INTEGER_CST\n+\t      || !int_fits_type_p (init, type)))\n+\tok = false;\n+    }\n+  else if (TREE_CODE (ftype) == REAL_TYPE\n+\t   && TREE_CODE (type) == REAL_TYPE)\n+    {\n+      if (TYPE_PRECISION (type) < TYPE_PRECISION (ftype))\n+\t{\n+\t  ok = false;\n+\t  if (TREE_CODE (init) == REAL_CST)\n+\t    {\n+\t      d = TREE_REAL_CST (init);\n+\t      if (exact_real_truncate (TYPE_MODE (type), &d))\n+\t\tok = true;\n+\t    }\n+\t}\n+    }\n+  else if (INTEGRAL_OR_ENUMERATION_TYPE_P (ftype)\n+\t   && TREE_CODE (type) == REAL_TYPE)\n+    {\n+      ok = false;\n+      if (TREE_CODE (init) == INTEGER_CST)\n+\t{\n+\t  d = real_value_from_int_cst (0, init);\n+\t  if (exact_real_truncate (TYPE_MODE (type), &d))\n+\t    ok = true;\n+\t}\n+    }\n+\n+  if (!ok)\n+    error (\"narrowing conversion of %qE to %qT inside { }\", init, type);\n+}\n+\n /* Process the initializer INIT for a variable of type TYPE, emitting\n    diagnostics for invalid initializers and converting the initializer as\n    appropriate.\n \n    For aggregate types, it assumes that reshape_init has already run, thus the\n-   initializer will have the right shape (brace elision has been undone).  */\n+   initializer will have the right shape (brace elision has been undone).\n \n-tree\n-digest_init (tree type, tree init)\n+   NESTED is true iff we are being called for an element of a CONSTRUCTOR.  */\n+\n+static tree\n+digest_init_r (tree type, tree init, bool nested)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -706,6 +762,8 @@ digest_init (tree type, tree init)\n     {\n       tree *exp;\n \n+      if (cxx_dialect != cxx98 && nested)\n+\tcheck_narrowing (type, init);\n       init = convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n \t\t\t\t\t \"initialization\", NULL_TREE, 0,\n                                          tf_warning_or_error);\n@@ -731,7 +789,7 @@ digest_init (tree type, tree init)\n \t      || TREE_CODE (type) == COMPLEX_TYPE);\n \n   if (BRACE_ENCLOSED_INITIALIZER_P (init))\n-      return process_init_constructor (type, init);\n+    return process_init_constructor (type, init);\n   else\n     {\n       if (COMPOUND_LITERAL_P (init) && TREE_CODE (type) == ARRAY_TYPE)\n@@ -757,6 +815,11 @@ digest_init (tree type, tree init)\n     }\n }\n \n+tree\n+digest_init (tree type, tree init)\n+{\n+  return digest_init_r (type, init, false);\n+}\n \f\n /* Set of flags used within process_init_constructor to describe the\n    initializers.  */\n@@ -828,7 +891,7 @@ process_init_constructor_array (tree type, tree init)\n       else\n \tce->index = size_int (i);\n       gcc_assert (ce->value);\n-      ce->value = digest_init (TREE_TYPE (type), ce->value);\n+      ce->value = digest_init_r (TREE_TYPE (type), ce->value, true);\n \n       if (ce->value != error_mark_node)\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n@@ -854,7 +917,7 @@ process_init_constructor_array (tree type, tree init)\n               next = build_functional_cast (TREE_TYPE (type), NULL_TREE,\n                                             tf_warning_or_error);\n \t    else\n-\t\tnext = build_constructor (NULL_TREE, NULL);\n+\t      next = build_constructor (init_list_type_node, NULL);\n \t    next = digest_init (TREE_TYPE (type), next);\n \t  }\n \telse if (!zero_init_p (TREE_TYPE (type)))\n@@ -929,7 +992,7 @@ process_init_constructor_record (tree type, tree init)\n \t    }\n \n \t  gcc_assert (ce->value);\n-\t  next = digest_init (TREE_TYPE (field), ce->value);\n+\t  next = digest_init_r (TREE_TYPE (field), ce->value, true);\n \t  ++idx;\n \t}\n       else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n@@ -942,9 +1005,9 @@ process_init_constructor_record (tree type, tree init)\n \t    next = build_functional_cast (TREE_TYPE (field), NULL_TREE,\n                                           tf_warning_or_error);\n \t  else\n-\t    next = build_constructor (NULL_TREE, NULL);\n+\t    next = build_constructor (init_list_type_node, NULL);\n \n-\t  next = digest_init (TREE_TYPE (field), next);\n+\t  next = digest_init_r (TREE_TYPE (field), next, true);\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  warning (OPT_Wmissing_field_initializers,\n@@ -1037,7 +1100,7 @@ process_init_constructor_union (tree type, tree init)\n     }\n \n   if (ce->value && ce->value != error_mark_node)\n-    ce->value = digest_init (TREE_TYPE (ce->index), ce->value);\n+    ce->value = digest_init_r (TREE_TYPE (ce->index), ce->value, true);\n \n   return picflag_from_initializer (ce->value);\n }"}, {"sha": "b7583da782977410fd35839f4caa843246240aa8", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist1.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist1.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,69 @@\n+// Basic uses of initializer lists\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+extern \"C\" void abort();\n+\n+using namespace std;\n+\n+struct A { int i,j; A(int _i,int _j): i(_i), j(_j) {} };\n+struct B { A a; B(A _a): a(_a) {} };\n+struct C { B b; C(B _b): b(_b) {} };\n+\n+struct D\n+{\n+  int ia[3];\n+  D (initializer_list<int> l)\n+  {\n+    const int *p = l.begin();\n+    for (int i = 0; i < 3; ++i)\n+      ia[i] = *p++;\n+  }\n+};\n+\n+void f(C c)\n+{\n+  if (c.b.a.i != 1) abort();\n+  if (c.b.a.j != 2) abort();\n+}\n+void f(int);\n+\n+void g(D d)\n+{\n+  if (d.ia[0] != 1 || d.ia[1] != 2 || d.ia[2] != 3)\n+    abort();\n+}\n+\n+struct E\n+{\n+  int i, j, k;\n+};\n+\n+void h(E e)\n+{\n+  if (e.i != 1 || e.j != 2 || e.k != 3)\n+    abort();\n+}\n+\n+void i(initializer_list<int> l)\n+{\n+  const int *p = l.begin();\n+  if (*p++ != 1) abort();\n+  if (*p++ != 2) abort();\n+  if (*p++ != 3) abort();\n+  if (p != l.end()) abort();\n+}\n+\n+int main()\n+{\n+  g({1,2,3});\n+\n+  h({1,2,3});\n+\n+  f({{{1,2}}});\n+  f({{A{1,2}}});\n+\n+  i({1,2,3});\n+}"}, {"sha": "2fe4770560d44595cc207056015bf7fdd4751ff6", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist2.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,32 @@\n+// Test that conversion to std::initializer_list takes priority over other\n+// user-defined conversions.\n+\n+// { dg-do link }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+struct string\n+{\n+  string (const char *) {}\n+  template <class Iter> string (Iter, Iter);\n+};\n+  \n+template <class T, class U>\n+struct pair\n+{\n+  pair (T t, U u) {}\n+};\n+\n+template<class T, class U>\n+struct map\n+{\n+  void insert (pair<T,U>);\n+  void insert (std::initializer_list<pair<T,U> >) {}\n+};\n+\n+int main()\n+{\n+  map<string,string> m;\n+  m.insert({ {\"this\",\"that\"}, {\"me\",\"you\"} });\n+}"}, {"sha": "412deb51129a8c8326b76198ad14891672c4c5de", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist3.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+template <class T> void f(std::initializer_list<T>);\n+\n+void g()\n+{\n+  f({1,2,3});\n+}\n+"}, {"sha": "d1ffab8546c0bcc8132d364de16861ae60b3fd1a", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist4.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist4.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,32 @@\n+// Test for initializer-list 'explicit' rule\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A\n+{\n+  explicit A(int,int);\n+  operator bool();\n+};\n+\n+A f(A)\n+{\n+  A{1,2};\n+  A a1{1,2};\n+  new A{1,2};\n+  if (A a5{1,2});\n+\n+  A({1,2});\t\t\t// { dg-error \"explicit\" }\n+  A a2({1,2});\t\t\t// { dg-error \"explicit\" }\n+  A a3 = {1,2};\t\t\t// { dg-error \"explicit\" }\n+  new A({1,2});\t\t\t// { dg-error \"explicit\" }\n+  f({1,2});\t\t\t// { dg-error \"explicit\" }\n+  a1 = {1,2};\t\t\t// { dg-error \"explicit\" }\n+  if (A a4 = {1,2});\t\t// { dg-error \"explicit\" }\n+  return {1,2};\t\t\t// { dg-error \"explicit\" }\n+}\n+\n+struct B\n+{\n+  A a;\n+  B(): a{1,2} {}\n+  B(const B&): a({1,2}) {}\t// { dg-error \"explicit\" }\n+};"}, {"sha": "0d02fd42d7f9fb951d57c68397b91997b771f5a8", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist5.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist5.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,21 @@\n+// Test for narrowing diagnostics\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+struct A { int i; int j; };\n+A a2 { 1.2 }; // { dg-error \"narrowing\" }\n+A a1 { 1, 2 }; // aggregate initialization \n+struct B {\n+  B(std::initializer_list<int>);\n+};\n+B b1 { 1, 2 }; // creates initializer_list<int> and calls constructor\n+B b2 { 1, 2.0 }; // { dg-error \"narrowing\" }\n+struct C {\n+  C(int i, double j);\n+};\n+C c1 = { 1, 2.2 }; // calls constructor with arguments (1, 2.2) \n+C c2 = { 1.1, 2 }; // { dg-error \"narrowing\" }\n+\n+int j { 1 }; // initialize to 1\n+int k {}; // initialize to 0"}, {"sha": "523570315ebb8ff134aeebe1dab764bfd770bcb2", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist6.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist6.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,30 @@\n+// Test for initlist lifetime\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run }\n+\n+#include <initializer_list>\n+\n+int c;\n+\n+struct A\n+{\n+  A(int,int) { ++c; }\n+  ~A() { --c; }\n+};\n+\n+void f (std::initializer_list<A> l) { }\n+\n+int main()\n+{\n+  f({ {1,2}, {3,4} });\n+  if (c != 0)\n+    return 1;\n+\n+  {\n+    std::initializer_list<A> l { {1,2}, {3,4} };\n+    if (c != 2)\n+      return 2;\n+  }\n+  if (c != 0)\n+    return 3;\n+}"}, {"sha": "d56d67f7556663608685eee0a6a6f4deabda7264", "filename": "gcc/testsuite/g++.dg/inherit/error4.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Ferror4.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -2,9 +2,9 @@\n \n struct A { virtual ~A(); };\n \n-struct B : A A {};            // { dg-error \"'A'|function definition|extra\" }\n+struct B : A A {};\t\t// { dg-error \"\" }\n \n-A foo(const B &b)\n+A foo(const B &b)\t\t// { dg-error \"\" }\n {\n-  return b;                   // { dg-error \"conversion\" }\n+  return b;\n }"}, {"sha": "619a20f3c70654c075c445c4ff791b4feeccf0f8", "filename": "gcc/testsuite/g++.dg/init/brace2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace2.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -5,4 +5,4 @@ const char * y = { \"hello\" };\n int a = 2;\n int b = { 2,3 }; // { dg-error \"requires one element in initializer\" }\n int c = { { 2 } } ; // { dg-error \"braces around scalar initializer\" }\n-int d = {}; // { dg-error \"requires one element in initializer\" }\n+int d = {}; // { dg-error \"initializer\" }"}, {"sha": "066d1ba65ff0168a524421b7e7605c14cfef8ab4", "filename": "gcc/testsuite/g++.dg/init/brace6.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace6.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -6,7 +6,7 @@ struct A {\n };\n \n struct B {\n-   B(const B&);\n+   B(const B&);\t\t\t// { dg-error \"candidate\" }\n    int b;\n };\n \n@@ -18,8 +18,8 @@ int main()\n {\n    int i = { 1 };\n    int j = { 1, 2 }; /* { dg-error \"requires one element\" } */\n-   A a = { 6 }; /* { dg-error \"initializer for non\" } */\n-   B b = { 6 }; /* { dg-error \"initializer for non\" } */\n+   A a = { 6 }; /* { dg-error \"initialize\" } */\n+   B b = { 6 }; /* { dg-error \"initialize\" } */\n    C c = { 6 }; /* { dg-error \"too many initializers\" } */\n    D d = { 6 };\n }"}, {"sha": "1397e87d256df886c2fa9bf178d62500d6dd1092", "filename": "gcc/testsuite/g++.dg/parse/crash36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -2,7 +2,7 @@\n // { dg-do compile }\n // { dg-options \"-std=c++98\" }\n \n-template <typename... T> struct A\t// { dg-error \"does not include variadic templates\" }\n+template <typename... T> struct A\t// { dg-error \"variadic templates\" }\n {\n   static T &t;\t\t\t\t// { dg-error \"not expanded with|T\" }\n   static const int i = sizeof (++t);\t// { dg-error \"was not declared in this scope\" }"}, {"sha": "e597d926f40d2032b2cc4b1c6adc4a95e38b3d77", "filename": "gcc/testsuite/g++.dg/parse/ctor3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor3.C?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -4,5 +4,5 @@ struct A {};\n \n struct B : A\n {\n-  B() : A {} // { dg-error \"expected\" }\n+  B() : A {}\t\t\t// { dg-error \"initializer|expected\" }\n };"}, {"sha": "a8f66dbb895898ed23e0905b3f3664738b8e838a", "filename": "gcc/tree.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -1827,6 +1827,26 @@ tree_cons_stat (tree purpose, tree value, tree chain MEM_STAT_DECL)\n   return node;\n }\n \n+/* Return the elements of a CONSTRUCTOR as a TREE_LIST.  */\n+\n+tree\n+ctor_to_list (tree ctor)\n+{\n+  tree list = NULL_TREE;\n+  tree *p = &list;\n+  unsigned ix;\n+  constructor_elt *ce;\n+\n+  for (ix = 0;\n+       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (ctor), ix, ce);\n+       ++ix)\n+    {\n+      *p = build_tree_list (ce->index, ce->value);\n+      p = &TREE_CHAIN (*p);\n+    }\n+\n+  return list;\n+}\n \f\n /* Return the size nominally occupied by an object of type TYPE\n    when it resides in memory.  The value is measured in units of bytes,"}, {"sha": "e6b9f9cf65e5789468ba6e5e3dc82feb2dc75925", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -1586,6 +1586,9 @@ struct tree_vec GTY(())\n \n /* In a CONSTRUCTOR node.  */\n #define CONSTRUCTOR_ELTS(NODE) (CONSTRUCTOR_CHECK (NODE)->constructor.elts)\n+#define CONSTRUCTOR_ELT(NODE,IDX) \\\n+  (VEC_index (constructor_elt, CONSTRUCTOR_ELTS (NODE), IDX))\n+#define CONSTRUCTOR_NELTS(NODE) (VEC_length (constructor_elt, CONSTRUCTOR_ELTS (NODE)))\n \n /* Iterate through the vector V of CONSTRUCTOR_ELT elements, yielding the\n    value of each element (stored within VAL). IX must be a scratch variable\n@@ -4475,6 +4478,10 @@ extern int fields_length (const_tree);\n \n extern bool initializer_zerop (const_tree);\n \n+/* Given a CONSTRUCTOR CTOR, return the elements as a TREE_LIST.  */\n+\n+extern tree ctor_to_list (tree);\n+\n /* Examine CTOR to discover:\n    * how many scalar fields are set to nonzero values,\n      and place it in *P_NZ_ELTS;"}, {"sha": "4c3689e34213aa6dac900a8e622483841c0e4013", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -1,3 +1,8 @@\n+2008-07-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* libsupc++/initializer_list: New file.\n+\t* include/bits/stl_map.h (insert(initializer_list)): New method.\n+\n 2008-06-30  Alfred E. Heggestad  <aeh@db.org>\n \n \t* include/backward/backward_warning.h: Fix typo."}, {"sha": "cf0c16bc42d14c823f500804f780af1ca27d0149", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -64,6 +64,7 @@\n \n #include <bits/functexcept.h>\n #include <bits/concept_check.h>\n+#include <initializer_list>\n \n _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n@@ -468,6 +469,18 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       insert(const value_type& __x)\n       { return _M_t._M_insert_unique(__x); }\n \n+      /**\n+       *  @brief Attempts to insert a list of std::pairs into the %map.\n+       *  @param  list  A std::initializer_list<value_type> of pairs to be\n+       *                inserted.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       *\n+       */\n+      void\n+      insert(std::initializer_list<value_type> list)\n+      { insert (list.begin(), list.end()); }\n+\n       /**\n        *  @brief Attempts to insert a std::pair into the %map.\n        *  @param  position  An iterator that serves as a hint as to where the"}, {"sha": "1a3cba3dd0206a8fa79692847a536400cfdf2c7f", "filename": "libstdc++-v3/libsupc++/initializer_list", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0935784671e347118c6bf7629852ba50e9466a85/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finitializer_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0935784671e347118c6bf7629852ba50e9466a85/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finitializer_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Finitializer_list?ref=0935784671e347118c6bf7629852ba50e9466a85", "patch": "@@ -0,0 +1,64 @@\n+// std::initializer_list support -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+// \n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+// \n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef __CXX_INITIALIZER_LIST\n+#define __CXX_INITIALIZER_LIST\n+\n+#pragma GCC visibility push(default)\n+\n+#include <cstddef>\n+\n+namespace std\n+{\n+  template<class E>\n+  class initializer_list\n+  {\n+    const E* _array;\n+    size_t _len;\n+\n+    // The compiler can call a private constructor.\n+    initializer_list(const E* _a, size_t _l)\n+      : _array(_a), _len(_l) { }\n+\n+  public:\n+    initializer_list()\n+      : _array(NULL), _len(0) {}\n+    \n+    size_t size() const\t\t// number of elements\n+    { return _len; }\n+    const E* begin() const\t// first element\n+    { return _array; }\n+    const E* end() const\t// one past the last element\n+    { return begin() + size(); }\n+  };\n+}\n+\n+#pragma GCC visibility pop\n+#endif // __CXX_INITIALIZER_LIST"}]}