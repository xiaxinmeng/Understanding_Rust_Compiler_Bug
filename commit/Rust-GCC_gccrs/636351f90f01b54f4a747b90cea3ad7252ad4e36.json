{"sha": "636351f90f01b54f4a747b90cea3ad7252ad4e36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2MzUxZjkwZjAxYjU0ZjRhNzQ3YjkwY2VhM2FkNzI1MmFkNGUzNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-08-28T16:23:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-08-28T16:23:12Z"}, "message": "[PATCH][lto/66752] Fix missed FSM jump thread\n\n\tPR lto/66752\n\t* tree-ssa-threadedge.c (simplify_conrol_stmt_condition): If we are\n\tunable to find X NE 0 in the tables, return X as the simplified\n\tcondition.\n\t(fsm_find_control_statement_thread_paths): If nodes in NEXT_PATH are\n\tin VISISTED_BBS, then return failure.  Else add nodes from NEXT_PATH\n\tto VISISTED_BBS.\n\t* tree-ssa-threadupdate.c (duplicate_thread_path): Fix up edge flags\n\tafter removing the control flow statement and unnecessary edges.\n\n\tPR lto/66752\n\t* gcc.dg/tree-ssa/pr66752-2.c: New test.\n\t* gcc.dg/torture/pr66752-1.c: New test\n\t* g++.dg/torture/pr66752-2.C: New test.\n\nFrom-SVN: r227307", "tree": {"sha": "bbd17aebd5d2754461d0c78d62a94cd88fb1a65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbd17aebd5d2754461d0c78d62a94cd88fb1a65b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636351f90f01b54f4a747b90cea3ad7252ad4e36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636351f90f01b54f4a747b90cea3ad7252ad4e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636351f90f01b54f4a747b90cea3ad7252ad4e36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636351f90f01b54f4a747b90cea3ad7252ad4e36/comments", "author": null, "committer": null, "parents": [{"sha": "ba60d5c3d56f2561188e02eb2e33314714781c2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba60d5c3d56f2561188e02eb2e33314714781c2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba60d5c3d56f2561188e02eb2e33314714781c2f"}], "stats": {"total": 184, "additions": 184, "deletions": 0}, "files": [{"sha": "de7f36775ee843b83aa1eee65ab40f4ef8dc2faf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -1,3 +1,15 @@\n+2015-08-28  Jeff Law  <law@redhat.com>\n+\n+\tPR lto/66752\n+\t* tree-ssa-threadedge.c (simplify_conrol_stmt_condition): If we are\n+\tunable to find X NE 0 in the tables, return X as the simplified\n+\tcondition.\n+\t(fsm_find_control_statement_thread_paths): If nodes in NEXT_PATH are\n+\tin VISISTED_BBS, then return failure.  Else add nodes from NEXT_PATH\n+\tto VISISTED_BBS.\n+\t* tree-ssa-threadupdate.c (duplicate_thread_path): Fix up edge flags\n+\tafter removing the control flow statement and unnecessary edges.\n+\n 2015-08-28  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tRevert:"}, {"sha": "8d4c3f6bf14db142f14b087270e68150a59aa877", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -1,3 +1,10 @@\n+2015-08-28  Jeff Law  <law@redhat.com>\n+\n+\tPR lto/66752\n+\t* gcc.dg/tree-ssa/pr66752-2.c: New test.\n+\t* gcc.dg/torture/pr66752-1.c: New test\n+\t* g++.dg/torture/pr66752-2.C: New test.\n+\n 2015-08-28  Alan Lawrence  <alan.lawrence@arm.com>\n \tRevert:\n \t2015-08-27  Alan Lawrence  <alan.lawrence@arm.com>"}, {"sha": "96d3fe9db4bb9c23e56936d30e2ae7819b713495", "filename": "gcc/testsuite/g++.dg/torture/pr66752-2.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr66752-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr66752-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr66752-2.C?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+extern \"C\"\n+{\n+  typedef struct _IO_FILE FILE;\n+  extern int fprintf (FILE * __restrict __stream,\n+\t\t      const char *__restrict __format, ...);\n+}\n+typedef union tree_node *tree;\n+class ipa_polymorphic_call_context\n+{\n+};\n+class ipcp_value_base\n+{\n+};\n+template < typename valtype > class ipcp_value:public ipcp_value_base\n+{\n+public:valtype value;\n+  ipcp_value *next;\n+};\n+\n+template < typename valtype > class ipcp_lattice\n+{\n+public:ipcp_value < valtype > *values;\n+  void print (FILE * f, bool dump_sources, bool dump_benefits);\n+};\n+\n+class ipcp_param_lattices\n+{\n+public:ipcp_lattice < tree > itself;\n+  ipcp_lattice < ipa_polymorphic_call_context > ctxlat;\n+};\n+template < typename valtype > void ipcp_lattice < valtype >::print (FILE * f,\n+\t\t\t\t\t\t\t\t    bool\n+\t\t\t\t\t\t\t\t    dump_sources,\n+\t\t\t\t\t\t\t\t    bool\n+\t\t\t\t\t\t\t\t    dump_benefits)\n+{\n+  ipcp_value < valtype > *val;\n+  bool prev = false;\n+  for (val = values; val; val = val->next)\n+    {\n+      if (dump_benefits && prev)\n+\tfprintf (f, \"               \");\n+      else if (!dump_benefits && prev)\n+\tfprintf (f, \", \");\n+      else\n+\tprev = true;\n+      if (dump_sources)\n+\tfprintf (f, \"]\");\n+      if (dump_benefits)\n+\tfprintf (f, \"shit\");\n+    }\n+}\n+\n+void\n+print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n+{\n+  struct ipcp_param_lattices *plats;\n+  plats->ctxlat.print (f, dump_sources, dump_benefits);\n+}"}, {"sha": "a7425554ba9d7877f922c1c474680bdb7d3da3ca", "filename": "gcc/testsuite/gcc.dg/torture/pr66752-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr66752-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr66752-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr66752-1.c?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+typedef unsigned int size_t;\n+struct fde_vector\n+{\n+  size_t count;\n+  const struct dwarf_fde *array[];\n+};\n+struct object;\n+typedef struct dwarf_fde fde;\n+typedef int (*fde_compare_t) (struct object *, const fde *, const fde *);\n+void\n+fde_merge (struct object *ob, fde_compare_t fde_compare,\n+\t   struct fde_vector *v1, struct fde_vector *v2)\n+{\n+  size_t i1, i2;\n+  const fde *fde2;\n+  do\n+    {\n+      i2--;\n+      while (i1 > 0 && fde_compare (ob, v1->array[i1 - 1], fde2) > 0)\n+\t{\n+\t  i1--;\n+\t}\n+    }\n+  while (i2 > 0);\n+}"}, {"sha": "f15b598616600ed2b9147b4e82a930e731be83f3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66752-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom1-details -fdump-tree-optimized\" } */\n+\n+extern int status, pt;\n+extern int count;\n+void\n+foo (int N, int c, int b, int *a)\n+{\n+  int i, flag;\n+  i = b -1;\n+  flag = 1;\n+  if (status && i < N && a[i] == b) {\n+    N--;\n+    flag = 0;\n+   if (pt)\n+     count++;\n+  }\n+  else    \n+    for (i = -1, flag = 1; ++i < N && flag;)\n+      if (a[i] == b)\n+        {\n+          --N;\n+          flag = 0;\n+          if (i < N)\n+            a[i] = a[N];\n+           else\n+            a[i] = 0;\n+          if (pt)\n+            count++;\n+        }\n+ if(status && flag)\n+   pt--;\n+}\n+\n+/* There are 3 FSM jump threading opportunities.  */\n+/* { dg-final { scan-tree-dump-times \"FSM\" 3 \"dom1\"} } */\n+\n+/* There should be no assignments or references to FLAG.  */\n+/* { dg-final { scan-tree-dump-not \"flag\" \"optimized\"} } */"}, {"sha": "451dc2e1c2e3d962f04a3f94650b944b6c4ea4ff", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -553,6 +553,24 @@ simplify_control_stmt_condition (edge e,\n           || !is_gimple_min_invariant (cached_lhs))\n         cached_lhs = (*simplify) (dummy_cond, stmt);\n \n+      /* If we were just testing that an integral type was != 0, and that\n+\t failed, just return the first operand.  This gives the FSM code a\n+\t chance to optimize the path.  */\n+      if (cached_lhs == NULL\n+\t  && cond_code == NE_EXPR)\n+\t{\n+\t  /* Recover the original operands.  They may have been simplified\n+\t     using context sensitive equivalences.  Those context sensitive\n+\t     equivalences may not be valid on paths found by the FSM optimizer.  */\n+\t  tree op0 = gimple_cond_lhs (stmt);\n+\t  tree op1 = gimple_cond_rhs (stmt);\n+\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t      && TREE_CODE (op0) == SSA_NAME\n+\t      && integer_zerop (op1))\n+\t    return op0;\n+\t}\n+\n       return cached_lhs;\n     }\n \n@@ -974,6 +992,21 @@ fsm_find_control_statement_thread_paths (tree expr,\n \t  return;\n \t}\n \n+      /* Make sure we haven't already visited any of the nodes in\n+\t NEXT_PATH.  Don't add them here to avoid pollution.  */\n+      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+\t{\n+\t  if (visited_bbs->contains ((*next_path)[i]))\n+\t    {\n+\t      vec_free (next_path);\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Now add the nodes to VISISTED_BBS.  */\n+      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+\tvisited_bbs->add ((*next_path)[i]);\n+\n       /* Append all the nodes from NEXT_PATH to PATH.  */\n       vec_safe_splice (path, next_path);\n       next_path_length = next_path->length ();"}, {"sha": "f4d3fdcdde50af136940fe43dc5eea4ae93c6e2c", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636351f90f01b54f4a747b90cea3ad7252ad4e36/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=636351f90f01b54f4a747b90cea3ad7252ad4e36", "patch": "@@ -2493,6 +2493,12 @@ duplicate_thread_path (edge entry, edge exit,\n \n   /* Remove the last branch in the jump thread path.  */\n   remove_ctrl_stmt_and_useless_edges (region_copy[n_region - 1], exit->dest);\n+\n+  /* And fixup the flags on the single remaining edge.  */\n+  edge fix_e = find_edge (region_copy[n_region - 1], exit->dest);\n+  fix_e->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n+  fix_e->flags |= EDGE_FALLTHRU;\n+\n   edge e = make_edge (region_copy[n_region - 1], exit->dest, EDGE_FALLTHRU);\n \n   if (e) {"}]}