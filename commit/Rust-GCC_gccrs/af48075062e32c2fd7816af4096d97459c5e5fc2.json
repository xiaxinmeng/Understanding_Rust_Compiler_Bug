{"sha": "af48075062e32c2fd7816af4096d97459c5e5fc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY0ODA3NTA2MmUzMmMyZmQ3ODE2YWY0MDk2ZDk3NDU5YzVlNWZjMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-27T19:12:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-27T19:12:31Z"}, "message": "mn10300: Fixes to PARALLEL handling within mn10300_adjust_sched_cost\n\n2014-08-27  David Malcolm  <dmalcolm@redhat.com>\n\n\t* gcc/config/mn10300/mn10300.c (is_load_insn): Rename to...\n\t(set_is_load_p): ...this, updating to work on a SET pattern rather\n\tthan an insn.\n\t(is_store_insn): Rename to...\n\t(set_is_store_p): ...this, updating to work on a SET pattern\n\trather than an insn.\n\t(mn10300_adjust_sched_cost): Move call to get_attr_timings from\n\ttop of function to where it is needed.  Rewrite the bogus\n\tcondition that checks for \"insn\" and \"dep\" being PARALLEL to\n\tinstead use single_set, introducing locals \"insn_set\" and\n\t\"dep_set\".  Given that we only ever returned \"cost\" for a non-pair\n\tof SETs, bail out early if we don't have a pair of SET.\n\tRewrite all uses of PATTERN (dep) and PATTERN (insn) to instead\n\tuse the new locals \"insn_set\" and \"dep_set\", and update calls to\n\tis_load_insn and is_store_insn to be calls to set_is_load_p and\n\tset_is_store_p.\n\nFrom-SVN: r214582", "tree": {"sha": "73d72c6b54e482f586523348a4e18ce5047d64b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73d72c6b54e482f586523348a4e18ce5047d64b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af48075062e32c2fd7816af4096d97459c5e5fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af48075062e32c2fd7816af4096d97459c5e5fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af48075062e32c2fd7816af4096d97459c5e5fc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af48075062e32c2fd7816af4096d97459c5e5fc2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cd4f356e901730e10be2c5f2515e77638d74644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cd4f356e901730e10be2c5f2515e77638d74644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cd4f356e901730e10be2c5f2515e77638d74644"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "2689e2db19c6d086c02ce41b1c40b6fe819ca531", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48075062e32c2fd7816af4096d97459c5e5fc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48075062e32c2fd7816af4096d97459c5e5fc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af48075062e32c2fd7816af4096d97459c5e5fc2", "patch": "@@ -1,3 +1,22 @@\n+2014-08-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc/config/mn10300/mn10300.c (is_load_insn): Rename to...\n+\t(set_is_load_p): ...this, updating to work on a SET pattern rather\n+\tthan an insn.\n+\t(is_store_insn): Rename to...\n+\t(set_is_store_p): ...this, updating to work on a SET pattern\n+\trather than an insn.\n+\t(mn10300_adjust_sched_cost): Move call to get_attr_timings from\n+\ttop of function to where it is needed.  Rewrite the bogus\n+\tcondition that checks for \"insn\" and \"dep\" being PARALLEL to\n+\tinstead use single_set, introducing locals \"insn_set\" and\n+\t\"dep_set\".  Given that we only ever returned \"cost\" for a non-pair\n+\tof SETs, bail out early if we don't have a pair of SET.\n+\tRewrite all uses of PATTERN (dep) and PATTERN (insn) to instead\n+\tuse the new locals \"insn_set\" and \"dep_set\", and update calls to\n+\tis_load_insn and is_store_insn to be calls to set_is_load_p and\n+\tset_is_store_p.\n+\n 2014-08-27  Guozhi Wei  <carrot@google.com>\n \n \tPR target/62262"}, {"sha": "ca79f6d16ac5dd52c7efb4c12205f6c8d9d85789", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48075062e32c2fd7816af4096d97459c5e5fc2/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48075062e32c2fd7816af4096d97459c5e5fc2/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=af48075062e32c2fd7816af4096d97459c5e5fc2", "patch": "@@ -2742,21 +2742,15 @@ mn10300_select_cc_mode (enum rtx_code code, rtx x, rtx y ATTRIBUTE_UNUSED)\n }\n \n static inline bool\n-is_load_insn (rtx insn)\n+set_is_load_p (rtx set)\n {\n-  if (GET_CODE (PATTERN (insn)) != SET)\n-    return false;\n-\n-  return MEM_P (SET_SRC (PATTERN (insn)));\n+  return MEM_P (SET_SRC (set));\n }\n \n static inline bool\n-is_store_insn (rtx insn)\n+set_is_store_p (rtx set)\n {\n-  if (GET_CODE (PATTERN (insn)) != SET)\n-    return false;\n-\n-  return MEM_P (SET_DEST (PATTERN (insn)));\n+  return MEM_P (SET_DEST (set));\n }\n \n /* Update scheduling costs for situations that cannot be\n@@ -2768,33 +2762,36 @@ is_store_insn (rtx insn)\n static int\n mn10300_adjust_sched_cost (rtx insn, rtx link, rtx dep, int cost)\n {\n-  int timings = get_attr_timings (insn);\n+  rtx insn_set;\n+  rtx dep_set;\n+  int timings;\n \n   if (!TARGET_AM33)\n     return 1;\n \n-  if (GET_CODE (insn) == PARALLEL)\n-    insn = XVECEXP (insn, 0, 0);\n+  /* We are only interested in pairs of SET. */\n+  insn_set = single_set (insn);\n+  if (!insn_set)\n+    return cost;\n \n-  if (GET_CODE (dep) == PARALLEL)\n-    dep = XVECEXP (dep, 0, 0);\n+  dep_set = single_set (dep);\n+  if (!dep_set)\n+    return cost;\n \n   /* For the AM34 a load instruction that follows a\n      store instruction incurs an extra cycle of delay.  */\n   if (mn10300_tune_cpu == PROCESSOR_AM34\n-      && is_load_insn (dep)\n-      && is_store_insn (insn))\n+      && set_is_load_p (dep_set)\n+      && set_is_store_p (insn_set))\n     cost += 1;\n \n   /* For the AM34 a non-store, non-branch FPU insn that follows\n      another FPU insn incurs a one cycle throughput increase.  */\n   else if (mn10300_tune_cpu == PROCESSOR_AM34\n-      && ! is_store_insn (insn)\n+      && ! set_is_store_p (insn_set)\n       && ! JUMP_P (insn)\n-      && GET_CODE (PATTERN (dep)) == SET\n-      && GET_CODE (PATTERN (insn)) == SET\n-      && GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (dep)))) == MODE_FLOAT\n-      && GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (insn)))) == MODE_FLOAT)\n+      && GET_MODE_CLASS (GET_MODE (SET_SRC (dep_set))) == MODE_FLOAT\n+      && GET_MODE_CLASS (GET_MODE (SET_SRC (insn_set))) == MODE_FLOAT)\n     cost += 1;\n \n   /*  Resolve the conflict described in section 1-7-4 of\n@@ -2816,23 +2813,21 @@ mn10300_adjust_sched_cost (rtx insn, rtx link, rtx dep, int cost)\n     return cost;\n \n   /* Check that the instruction about to scheduled is an FPU instruction.  */\n-  if (GET_CODE (PATTERN (dep)) != SET)\n-    return cost;\n-\n-  if (GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (dep)))) != MODE_FLOAT)\n+  if (GET_MODE_CLASS (GET_MODE (SET_SRC (dep_set))) != MODE_FLOAT)\n     return cost;\n \n   /* Now check to see if the previous instruction is a load or store.  */\n-  if (! is_load_insn (insn) && ! is_store_insn (insn))\n+  if (! set_is_load_p (insn_set) && ! set_is_store_p (insn_set))\n     return cost;\n \n   /* XXX: Verify: The text of 1-7-4 implies that the restriction\n      only applies when an INTEGER load/store precedes an FPU\n      instruction, but is this true ?  For now we assume that it is.  */\n-  if (GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (insn)))) != MODE_INT)\n+  if (GET_MODE_CLASS (GET_MODE (SET_SRC (insn_set))) != MODE_INT)\n     return cost;\n \n   /* Extract the latency value from the timings attribute.  */\n+  timings = get_attr_timings (insn);\n   return timings < 100 ? (timings % 10) : (timings % 100);\n }\n "}]}