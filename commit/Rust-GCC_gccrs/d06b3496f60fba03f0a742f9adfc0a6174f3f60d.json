{"sha": "d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA2YjM0OTZmNjBmYmEwM2YwYTc0MmY5YWRmYzBhNjE3NGYzZjYwZA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-04-07T22:07:44Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-04-07T22:07:44Z"}, "message": "PR fortran/25829 28655\n\n2008-04-07  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/25829 28655\n\t* io.c (io_tag): Add new tags for decimal, encoding, asynchronous,\n\tround, sign, and id. (match_open_element): Match new tags.\n\t(gfc_resolve_open): Resolve new tags. (gfc_match_open): Enable encoding\n\tfor DEFAULT only. Update error messages. (match_dt_element): Fix match\n\ttag for asynchronous. Update error messages. (gfc_free_inquire): Free\n\tnew expressions. (match_inquire_element): Match new tags.\n\t(gfc_match_inquire): Add constraint for ID and PENDING.\n\t(gfc_resolve_inquire): Resolve new tags.\n\t* trans-io.c (gfc_trans_inquire): Clean up whitespace and fix setting of\n\tmask for ID parameter.\n\t* ioparm.def: Fix order of parameters for pending, round, and sign.\n\tNOTE: These must line up with the definitions in libgfortran/io/io.h. or\n\tthings don't work.\n\nFrom-SVN: r133989", "tree": {"sha": "d0c78839eaa0e8d575e625941f9f193f1bc826a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0c78839eaa0e8d575e625941f9f193f1bc826a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/comments", "author": null, "committer": null, "parents": [{"sha": "931149a6b763268df6377a2951927b2db4e4e350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/931149a6b763268df6377a2951927b2db4e4e350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/931149a6b763268df6377a2951927b2db4e4e350"}], "stats": {"total": 139, "additions": 95, "deletions": 44}, "files": [{"sha": "7833747bec710a210e41ac3eeb08647ae46e7dfb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "patch": "@@ -1,3 +1,20 @@\n+2008-04-07  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/25829 28655\n+\t* io.c (io_tag): Add new tags for decimal, encoding, asynchronous,\n+\tround, sign, and id. (match_open_element): Match new tags.\n+\t(gfc_resolve_open): Resolve new tags. (gfc_match_open): Enable encoding\n+\tfor DEFAULT only. Update error messages. (match_dt_element): Fix match\n+\ttag for asynchronous. Update error messages. (gfc_free_inquire): Free\n+\tnew expressions. (match_inquire_element): Match new tags.\n+\t(gfc_match_inquire): Add constraint for ID and PENDING.\n+\t(gfc_resolve_inquire): Resolve new tags.\n+\t* trans-io.c (gfc_trans_inquire): Clean up whitespace and fix setting of\n+\tmask for ID parameter.\n+\t* ioparm.def: Fix order of parameters for pending, round, and sign.\n+\tNOTE: These must line up with the definitions in libgfortran/io/io.h. or\n+\tthings don't work.\n+\n 2008-04-06  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/35780"}, {"sha": "11907a72a89d55d7323e0f00ede09df5b75d17e3", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 68, "deletions": 35, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "patch": "@@ -50,6 +50,7 @@ static const io_tag\n \ttag_e_pad\t= {\"PAD\", \" pad =\", \" %e\", BT_CHARACTER},\n \ttag_e_decimal\t= {\"DECIMAL\", \" decimal =\", \" %e\", BT_CHARACTER},\n \ttag_e_encoding\t= {\"ENCODING\", \" encoding =\", \" %e\", BT_CHARACTER},\n+\ttag_e_async\t= {\"ASYNCHRONOUS\", \" asynchronous =\", \" %e\", BT_CHARACTER},\n \ttag_e_round\t= {\"ROUND\", \" round =\", \" %e\", BT_CHARACTER},\n \ttag_e_sign\t= {\"SIGN\", \" sign =\", \" %e\", BT_CHARACTER},\n \ttag_unit\t= {\"UNIT\", \" unit =\", \" %e\", BT_INTEGER},\n@@ -81,14 +82,19 @@ static const io_tag\n \ttag_readwrite\t= {\"READWRITE\", \" readwrite =\", \" %v\", BT_CHARACTER},\n \ttag_s_delim\t= {\"DELIM\", \" delim =\", \" %v\", BT_CHARACTER},\n \ttag_s_pad\t= {\"PAD\", \" pad =\", \" %v\", BT_CHARACTER},\n+\ttag_s_decimal\t= {\"DECIMAL\", \" decimal =\", \" %v\", BT_CHARACTER},\n+\ttag_s_encoding\t= {\"ENCODING\", \" encoding =\", \" %v\", BT_CHARACTER},\n+\ttag_s_async\t= {\"ASYNCHRONOUS\", \" asynchronous =\", \" %v\", BT_CHARACTER},\n+\ttag_s_round\t= {\"ROUND\", \" round =\", \" %v\", BT_CHARACTER},\n+\ttag_s_sign\t= {\"SIGN\", \" sign =\", \" %v\", BT_CHARACTER},\n \ttag_iolength\t= {\"IOLENGTH\", \" iolength =\", \" %v\", BT_INTEGER},\n \ttag_convert     = {\"CONVERT\", \" convert =\", \" %e\", BT_CHARACTER},\n \ttag_strm_out    = {\"POS\", \" pos =\", \" %v\", BT_INTEGER},\n \ttag_err\t\t= {\"ERR\", \" err =\", \" %l\", BT_UNKNOWN},\n \ttag_end\t\t= {\"END\", \" end =\", \" %l\", BT_UNKNOWN},\n \ttag_eor\t\t= {\"EOR\", \" eor =\", \" %l\", BT_UNKNOWN},\n-\ttag_async\t= {\"ASYNCHRONOUS\", \" asynchronous =\", \" %e\", BT_CHARACTER},\n-\ttag_id\t\t= {\"ID\", \" id =\", \" %v\", BT_INTEGER};\n+\ttag_id\t\t= {\"ID\", \" id =\", \" %v\", BT_INTEGER},\n+\ttag_pending\t= {\"PENDING\", \" pending =\", \" %v\", BT_LOGICAL};\n \n static gfc_dt *current_dt;\n \n@@ -1277,7 +1283,7 @@ match_open_element (gfc_open *open)\n {\n   match m;\n \n-  m = match_etag (&tag_async, &open->asynchronous);\n+  m = match_etag (&tag_e_async, &open->asynchronous);\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_unit, &open->unit);\n@@ -1394,6 +1400,7 @@ gfc_resolve_open (gfc_open *open)\n   RESOLVE_TAG (&tag_e_pad, open->pad);\n   RESOLVE_TAG (&tag_e_decimal, open->decimal);\n   RESOLVE_TAG (&tag_e_encoding, open->encoding);\n+  RESOLVE_TAG (&tag_e_async, open->asynchronous);\n   RESOLVE_TAG (&tag_e_round, open->round);\n   RESOLVE_TAG (&tag_e_sign, open->sign);\n   RESOLVE_TAG (&tag_convert, open->convert);\n@@ -1652,16 +1659,14 @@ gfc_match_open (void)\n   /* Checks on the ENCODING specifier.  */\n   if (open->encoding)\n     {\n-      /* When implemented, change the following to use gfc_notify_std F2003.\n       if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ENCODING= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n-\tgoto cleanup; */\n-      gfc_error (\"F2003 Feature: ENCODING=specifier at %C not implemented\");\n-      goto cleanup;\n+\tgoto cleanup;\n     \n       if (open->encoding->expr_type == EXPR_CONSTANT)\n \t{\n-\t  static const char * encoding[] = { \"UTF-8\", \"DEFAULT\", NULL };\n+\t  /* TODO: Implement UTF-8 here.  */\n+\t  static const char * encoding[] = { \"DEFAULT\", NULL };\n \n \t  if (!compare_to_allowed_values (\"ENCODING\", encoding, NULL, NULL,\n \t\t\t\t\t  open->encoding->value.character.string,\n@@ -1707,7 +1712,7 @@ gfc_match_open (void)\n   if (open->round)\n     {\n       /* When implemented, change the following to use gfc_notify_std F2003.  */\n-      gfc_error (\"F2003 Feature: ROUND=specifier at %C not implemented\");\n+      gfc_error (\"F2003 Feature: ROUND= specifier at %C not implemented\");\n       goto cleanup;\n \n       if (open->round->expr_type == EXPR_CONSTANT)\n@@ -1772,8 +1777,8 @@ gfc_match_open (void)\n \t\t\t\t      \"OPEN\", warn))\n \tgoto cleanup;\n \n-      /* F2003, 9.4.5: If the STATUS=specifier has the value NEW or REPLACE,\n-\t the FILE=specifier shall appear.  */\n+      /* F2003, 9.4.5: If the STATUS= specifier has the value NEW or REPLACE,\n+\t the FILE= specifier shall appear.  */\n       if (open->file == NULL\n \t  && (strncasecmp (open->status->value.character.string, \"replace\", 7)\n \t      == 0\n@@ -1785,8 +1790,8 @@ gfc_match_open (void)\n \t\t\t open->status->value.character.string);\n \t}\n \n-      /* F2003, 9.4.5: If the STATUS=specifier has the value SCRATCH,\n-\t the FILE=specifier shall not appear.  */\n+      /* F2003, 9.4.5: If the STATUS= specifier has the value SCRATCH,\n+\t the FILE= specifier shall not appear.  */\n       if (strncasecmp (open->status->value.character.string, \"scratch\", 7)\n \t  == 0 && open->file)\n \t{\n@@ -2324,7 +2329,7 @@ match_dt_element (io_kind k, gfc_dt *dt)\n       return MATCH_YES;\n     }\n \n-  m = match_etag (&tag_async, &dt->asynchronous);\n+  m = match_etag (&tag_e_async, &dt->asynchronous);\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_e_blank, &dt->blank);\n@@ -2869,13 +2874,13 @@ if (condition) \\\n       io_constraint (dt->eor, \"EOR tag not allowed with output at %L\",\n \t\t     &dt->eor_where);\n \n-      io_constraint (dt->blank, \"BLANK=specifier not allowed with output at %L\",\n+      io_constraint (dt->blank, \"BLANK= specifier not allowed with output at %L\",\n \t\t     &dt->blank->where);\n \n-      io_constraint (dt->pad, \"PAD=specifier not allowed with output at %L\",\n+      io_constraint (dt->pad, \"PAD= specifier not allowed with output at %L\",\n \t\t     &dt->pad->where);\n \n-      io_constraint (dt->size, \"SIZE=specifier not allowed with output at %L\",\n+      io_constraint (dt->size, \"SIZE= specifier not allowed with output at %L\",\n \t\t     &dt->size->where);\n     }\n   else\n@@ -2912,7 +2917,7 @@ if (condition) \\\n       io_constraint (!dt->asynchronous\n \t\t     || strcmp (dt->asynchronous->value.character.string,\n \t\t\t\t \"yes\"),\n-\t\t     \"ID=specifier at %L must be with ASYNCHRONOUS='yes' \"\n+\t\t     \"ID= specifier at %L must be with ASYNCHRONOUS='yes' \"\n \t\t     \"specifier\", &dt->id->where);\n     }\n \n@@ -2932,7 +2937,7 @@ if (condition) \\\n \t    return MATCH_ERROR;\n \n \t  io_constraint (unformatted,\n-\t\t\t \"the DECIMAL=specifier at %L must be with an \"\n+\t\t\t \"the DECIMAL= specifier at %L must be with an \"\n \t\t\t \"explicit format expression\", &dt->decimal->where);\n \t}\n     }\n@@ -2953,7 +2958,7 @@ if (condition) \\\n \t    return MATCH_ERROR;\n \n \t  io_constraint (unformatted,\n-\t\t\t \"the BLANK=specifier at %L must be with an \"\n+\t\t\t \"the BLANK= specifier at %L must be with an \"\n \t\t\t \"explicit format expression\", &dt->blank->where);\n \t}\n     }\n@@ -2974,7 +2979,7 @@ if (condition) \\\n \t    return MATCH_ERROR;\n \n \t  io_constraint (unformatted,\n-\t\t\t \"the PAD=specifier at %L must be with an \"\n+\t\t\t \"the PAD= specifier at %L must be with an \"\n \t\t\t \"explicit format expression\", &dt->pad->where);\n \t}\n     }\n@@ -2985,7 +2990,7 @@ if (condition) \\\n       if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ROUND= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;  */\n-      gfc_error (\"F2003 Feature: ROUND=specifier at %C not implemented\");\n+      gfc_error (\"F2003 Feature: ROUND= specifier at %C not implemented\");\n       return MATCH_ERROR;\n \n       if (dt->round->expr_type == EXPR_CONSTANT)\n@@ -3018,11 +3023,11 @@ if (condition) \\\n \t    return MATCH_ERROR;\n \n \t  io_constraint (unformatted,\n-\t\t\t \"SIGN=specifier at %L must be with an \"\n+\t\t\t \"SIGN= specifier at %L must be with an \"\n \t\t\t \"explicit format expression\", &dt->sign->where);\n \n \t  io_constraint (k == M_READ,\n-\t\t\t \"SIGN=specifier at %L not allowed in a \"\n+\t\t\t \"SIGN= specifier at %L not allowed in a \"\n \t\t\t \"READ statement\", &dt->sign->where);\n \t}\n     }\n@@ -3043,17 +3048,17 @@ if (condition) \\\n \t    return MATCH_ERROR;\n \n \t  io_constraint (k == M_READ,\n-\t\t\t \"DELIM=specifier at %L not allowed in a \"\n+\t\t\t \"DELIM= specifier at %L not allowed in a \"\n \t\t\t \"READ statement\", &dt->delim->where);\n       \n \t  io_constraint (dt->format_label != &format_asterisk\n \t\t\t && dt->namelist == NULL,\n-\t\t\t \"DELIM=specifier at %L must have FMT=*\",\n+\t\t\t \"DELIM= specifier at %L must have FMT=*\",\n \t\t\t &dt->delim->where);\n \n \t  io_constraint (unformatted && dt->namelist == NULL,\n-\t\t\t \"DELIM=specifier at %L must be with FMT=* or \"\n-\t\t\t \"NML=specifier \", &dt->delim->where);\n+\t\t\t \"DELIM= specifier at %L must be with FMT=* or \"\n+\t\t\t \"NML= specifier \", &dt->delim->where);\n \t}\n     }\n   \n@@ -3073,22 +3078,22 @@ if (condition) \\\n \t\t     \"and format label at %L\", spec_end);\n \n       io_constraint (dt->rec,\n-\t\t     \"NAMELIST IO is not allowed with a REC=specifier \"\n+\t\t     \"NAMELIST IO is not allowed with a REC= specifier \"\n \t\t     \"at %L.\", &dt->rec->where);\n \n       io_constraint (dt->advance,\n-\t\t     \"NAMELIST IO is not allowed with a ADVANCE=specifier \"\n+\t\t     \"NAMELIST IO is not allowed with a ADVANCE= specifier \"\n \t\t     \"at %L.\", &dt->advance->where);\n     }\n \n   if (dt->rec)\n     {\n       io_constraint (dt->end,\n \t\t     \"An END tag is not allowed with a \"\n-\t\t     \"REC=specifier at %L.\", &dt->end_where);\n+\t\t     \"REC= specifier at %L.\", &dt->end_where);\n \n       io_constraint (dt->format_label == &format_asterisk,\n-\t\t     \"FMT=* is not allowed with a REC=specifier \"\n+\t\t     \"FMT=* is not allowed with a REC= specifier \"\n \t\t     \"at %L.\", spec_end);\n     }\n \n@@ -3099,10 +3104,10 @@ if (condition) \\\n \n       io_constraint (dt->format_label == &format_asterisk,\n \t\t     \"List directed format(*) is not allowed with a \"\n-\t\t     \"ADVANCE=specifier at %L.\", &expr->where);\n+\t\t     \"ADVANCE= specifier at %L.\", &expr->where);\n \n       io_constraint (unformatted,\n-\t\t     \"the ADVANCE=specifier at %L must appear with an \"\n+\t\t     \"the ADVANCE= specifier at %L must appear with an \"\n \t\t     \"explicit format expression\", &expr->where);\n \n       if (expr->expr_type == EXPR_CONSTANT && expr->ts.type == BT_CHARACTER)\n@@ -3118,7 +3123,7 @@ if (condition) \\\n \t}\n \n       io_constraint (not_no && not_yes,\n-\t\t     \"ADVANCE=specifier at %L must have value = \"\n+\t\t     \"ADVANCE= specifier at %L must have value = \"\n \t\t     \"YES or NO.\", &expr->where);\n \n       io_constraint (dt->size && not_no && k == M_READ,\n@@ -3418,10 +3423,16 @@ gfc_free_inquire (gfc_inquire *inquire)\n   gfc_free_expr (inquire->write);\n   gfc_free_expr (inquire->readwrite);\n   gfc_free_expr (inquire->delim);\n+  gfc_free_expr (inquire->encoding);\n   gfc_free_expr (inquire->pad);\n   gfc_free_expr (inquire->iolength);\n   gfc_free_expr (inquire->convert);\n   gfc_free_expr (inquire->strm_pos);\n+  gfc_free_expr (inquire->asynchronous);\n+  gfc_free_expr (inquire->pending);\n+  gfc_free_expr (inquire->id);\n+  gfc_free_expr (inquire->sign);\n+  gfc_free_expr (inquire->round);\n   gfc_free (inquire);\n }\n \n@@ -3459,11 +3470,19 @@ match_inquire_element (gfc_inquire *inquire)\n   RETM m = match_vtag (&tag_read, &inquire->read);\n   RETM m = match_vtag (&tag_write, &inquire->write);\n   RETM m = match_vtag (&tag_readwrite, &inquire->readwrite);\n+  RETM m = match_vtag (&tag_s_async, &inquire->asynchronous);\n   RETM m = match_vtag (&tag_s_delim, &inquire->delim);\n+  RETM m = match_vtag (&tag_s_decimal, &inquire->decimal);\n+  RETM m = match_vtag (&tag_s_blank, &inquire->blank);\n+  RETM m = match_vtag (&tag_s_encoding, &inquire->encoding);\n+  RETM m = match_vtag (&tag_s_round, &inquire->round);\n+  RETM m = match_vtag (&tag_s_sign, &inquire->sign);\n   RETM m = match_vtag (&tag_s_pad, &inquire->pad);\n   RETM m = match_vtag (&tag_iolength, &inquire->iolength);\n   RETM m = match_vtag (&tag_convert, &inquire->convert);\n   RETM m = match_out_tag (&tag_strm_out, &inquire->strm_pos);\n+  RETM m = match_vtag (&tag_pending, &inquire->pending);\n+  RETM m = match_vtag (&tag_id, &inquire->id);\n   RETM return MATCH_NO;\n }\n \n@@ -3571,6 +3590,13 @@ gfc_match_inquire (void)\n       gfc_error (\"INQUIRE statement not allowed in PURE procedure at %C\");\n       goto cleanup;\n     }\n+  \n+  if (inquire->id != NULL && inquire->pending == NULL)\n+    {\n+      gfc_error (\"INQUIRE statement at %L requires a PENDING= specifier with \"\n+\t\t \"the ID= specifier\", &loc);\n+      goto cleanup;\n+    }\n \n   new_st.op = EXEC_INQUIRE;\n   new_st.ext.inquire = inquire;\n@@ -3615,9 +3641,16 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n   RESOLVE_TAG (&tag_readwrite, inquire->readwrite);\n   RESOLVE_TAG (&tag_s_delim, inquire->delim);\n   RESOLVE_TAG (&tag_s_pad, inquire->pad);\n+  RESOLVE_TAG (&tag_s_encoding, inquire->encoding);\n+  RESOLVE_TAG (&tag_s_round, inquire->round);\n   RESOLVE_TAG (&tag_iolength, inquire->iolength);\n   RESOLVE_TAG (&tag_convert, inquire->convert);\n   RESOLVE_TAG (&tag_strm_out, inquire->strm_pos);\n+  RESOLVE_TAG (&tag_s_async, inquire->asynchronous);\n+  RESOLVE_TAG (&tag_s_sign, inquire->sign);\n+  RESOLVE_TAG (&tag_s_round, inquire->round);\n+  RESOLVE_TAG (&tag_pending, inquire->pending);\n+  RESOLVE_TAG (&tag_id, inquire->id);\n \n   if (gfc_reference_st_label (inquire->err, ST_LABEL_TARGET) == FAILURE)\n     return FAILURE;"}, {"sha": "deb1b98389c837f692b0eda31d2dd67df50908e4", "filename": "gcc/fortran/ioparm.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "patch": "@@ -63,9 +63,9 @@ IOPARM (inquire, flags2,\t1 << 31, int4)\n IOPARM (inquire, asynchronous,\t1 << 0,  char1)\n IOPARM (inquire, decimal,\t1 << 1,  char2)\n IOPARM (inquire, encoding,\t1 << 2,  char1)\n-IOPARM (inquire, round,\t\t1 << 3,  char2)\n-IOPARM (inquire, sign,\t\t1 << 4,  char1)\n-IOPARM (inquire, pending,\t1 << 5,  pint4)\n+IOPARM (inquire, pending,\t1 << 3,  pint4)\n+IOPARM (inquire, round,\t        1 << 4,  char1)\n+IOPARM (inquire, sign,\t\t1 << 5,  char2)\n IOPARM (inquire, size,\t\t1 << 6,  pint4)\n IOPARM (inquire, id,\t\t1 << 7,  pint4)\n IOPARM (wait,    common,\t0,\t common)"}, {"sha": "6316a42691894c4f2cc5eac80c07be8f8f82d7b2", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d06b3496f60fba03f0a742f9adfc0a6174f3f60d/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d06b3496f60fba03f0a742f9adfc0a6174f3f60d", "patch": "@@ -1238,6 +1238,10 @@ gfc_trans_inquire (gfc_code * code)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_blank,\n \t\t\tp->blank);\n \n+  if (p->delim)\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_delim,\n+\t\t\tp->delim);\n+\n   if (p->position)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_position,\n \t\t\tp->position);\n@@ -1258,14 +1262,10 @@ gfc_trans_inquire (gfc_code * code)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_readwrite,\n \t\t\tp->readwrite);\n \n-  if (p->delim)\n-    mask |= set_string (&block, &post_block, var, IOPARM_inquire_delim,\n-\t\t\tp->delim);\n-\n   if (p->pad)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_pad,\n \t\t\tp->pad);\n-\n+  \n   if (p->convert)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_convert,\n \t\t\tp->convert);\n@@ -1304,7 +1304,8 @@ gfc_trans_inquire (gfc_code * code)\n \t\t\t\tp->size);\n \n   if (p->id)\n-    mask2 |= set_parameter_value (&block, var, IOPARM_inquire_id, p->id);\n+    mask2 |= set_parameter_ref (&block, &post_block,var, IOPARM_inquire_id,\n+\t\t\t\tp->id);\n \n   set_parameter_const (&block, var, IOPARM_inquire_flags2, mask2);\n "}]}