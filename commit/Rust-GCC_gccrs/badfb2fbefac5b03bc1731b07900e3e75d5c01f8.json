{"sha": "badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkZmIyZmJlZmFjNWIwM2JjMTczMWIwNzkwMGUzZTc1ZDVjMDFmOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-10-06T10:27:57Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-10-06T10:27:57Z"}, "message": "Update template instantiation documentation\n\n\t* doc/extend.texi (Template Instantiation): Reorder options and\n\tde-emphasize -frepo.\n\t* doc/invoke.texi (C++ Dialect Options): Use -fstrict-enums in\n\texample instead of -frepo.\n\nFrom-SVN: r228518", "tree": {"sha": "5dfae549ff6a764c04ea675f23f89e7494cb752a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dfae549ff6a764c04ea675f23f89e7494cb752a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ea7618de28a52f5a8db9850f162614c8a0c4b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ea7618de28a52f5a8db9850f162614c8a0c4b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ea7618de28a52f5a8db9850f162614c8a0c4b5"}], "stats": {"total": 108, "additions": 67, "deletions": 41}, "files": [{"sha": "6afa691026093f8002c4fa59cc9cbf6ef069a13f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "patch": "@@ -1,3 +1,10 @@\n+2015-10-06  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/extend.texi (Template Instantiation): Reorder options and\n+\tde-emphasize -frepo.\n+\t* doc/invoke.texi (C++ Dialect Options): Use -fstrict-enums in\n+\texample instead of -frepo.\n+\n 2015-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR c/65345"}, {"sha": "2db7bb239c25ecc1eea03f96acc43f3040dd03a6", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "patch": "@@ -19574,8 +19574,8 @@ If any calls are not inlined, you will get linker errors.\n @section Where's the Template?\n @cindex template instantiation\n \n-C++ templates are the first language feature to require more\n-intelligence from the environment than one usually finds on a UNIX\n+C++ templates were the first language feature to require more\n+intelligence from the environment than was traditionally found on a UNIX\n system.  Somehow the compiler and linker have to make sure that each\n template instance occurs exactly once in the executable if it is needed,\n and not at all otherwise.  There are two basic approaches to this\n@@ -19588,7 +19588,7 @@ equivalent of common blocks to their linker; the compiler emits template\n instances in each translation unit that uses them, and the linker\n collapses them together.  The advantage of this model is that the linker\n only has to consider the object files themselves; there is no external\n-complexity to worry about.  This disadvantage is that compilation time\n+complexity to worry about.  The disadvantage is that compilation time\n is increased because the template code is being compiled repeatedly.\n Code written for this model tends to include definitions of all\n templates in the header file, since they must be seen to be\n@@ -19614,14 +19614,59 @@ of non-inline member templates into a separate file, which should be\n compiled separately.\n @end table\n \n-When used with GNU ld version 2.8 or later on an ELF system such as\n-GNU/Linux or Solaris 2, or on Microsoft Windows, G++ supports the\n-Borland model.  On other systems, G++ implements neither automatic\n-model.\n+G++ implements the Borland model on targets where the linker supports it,\n+including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows.\n+Otherwise G++ implements neither automatic model.\n \n You have the following options for dealing with template instantiations:\n \n @enumerate\n+@item\n+Do nothing.  Code written for the Borland model works fine, but\n+each translation unit contains instances of each of the templates it\n+uses.  The duplicate instances will be discarded by the linker, but in\n+a large program, this can lead to an unacceptable amount of code\n+duplication in object files or shared libraries.\n+\n+Duplicate instances of a template can be avoided by defining an explicit\n+instantiation in one object file, and preventing the compiler from doing\n+implicit instantiations in any other object files by using an explicit\n+instantiation declaration, using the @code{extern template} syntax:\n+\n+@smallexample\n+extern template int max (int, int);\n+@end smallexample\n+\n+This syntax is defined in the C++ 2011 standard, but has been supported by\n+G++ and other compilers since well before 2011.\n+\n+Explicit instantiations can be used for the largest or most frequently\n+duplicated instances, without having to know exactly which other instances\n+are used in the rest of the program.  You can scatter the explicit\n+instantiations throughout your program, perhaps putting them in the\n+translation units where the instances are used or the translation units\n+that define the templates themselves; you can put all of the explicit\n+instantiations you need into one big file; or you can create small files\n+like\n+\n+@smallexample\n+#include \"Foo.h\"\n+#include \"Foo.cc\"\n+\n+template class Foo<int>;\n+template ostream& operator <<\n+                (ostream&, const Foo<int>&);\n+@end smallexample\n+\n+@noindent\n+for each of the instances you need, and create a template instantiation\n+library from those.\n+\n+This is the simplest option, but also offers flexibility and\n+fine-grained control when necessary. It is also the most portable\n+alternative and programs using this approach will work with most modern\n+compilers.\n+\n @item\n @opindex frepo\n Compile your template-using code with @option{-frepo}.  The compiler\n@@ -19633,8 +19678,8 @@ those instantiations and rebuild any affected object files.  The\n link-time overhead is negligible after the first pass, as the compiler\n continues to place the instantiations in the same files.\n \n-This is your best option for application code written for the Borland\n-model, as it just works.  Code written for the Cfront model \n+This can be a suitable option for application code written for the Borland\n+model, as it usually just works.  Code written for the Cfront model \n needs to be modified so that the template definitions are available at\n one or more points of instantiation; usually this is as simple as adding\n @code{#include <tmethods.cc>} to the end of each template header.\n@@ -19653,25 +19698,8 @@ Compile your code with @option{-fno-implicit-templates} to disable the\n implicit generation of template instances, and explicitly instantiate\n all the ones you use.  This approach requires more knowledge of exactly\n which instances you need than do the others, but it's less\n-mysterious and allows greater control.  You can scatter the explicit\n-instantiations throughout your program, perhaps putting them in the\n-translation units where the instances are used or the translation units\n-that define the templates themselves; you can put all of the explicit\n-instantiations you need into one big file; or you can create small files\n-like\n-\n-@smallexample\n-#include \"Foo.h\"\n-#include \"Foo.cc\"\n-\n-template class Foo<int>;\n-template ostream& operator <<\n-                (ostream&, const Foo<int>&);\n-@end smallexample\n-\n-@noindent\n-for each of the instances you need, and create a template instantiation\n-library from those.\n+mysterious and allows greater control if you want to ensure that only\n+the intended instances are used.\n \n If you are using Cfront-model code, you can probably get away with not\n using @option{-fno-implicit-templates} when compiling files that don't\n@@ -19682,27 +19710,18 @@ compile it without @option{-fno-implicit-templates} so you get all of the\n instances required by your explicit instantiations (but not by any\n other files) without having to specify them as well.\n \n-The ISO C++ 2011 standard allows forward declaration of explicit\n-instantiations (with @code{extern}). G++ supports explicit instantiation\n-declarations in C++98 mode and has extended the template instantiation\n+In addition to forward declaration of explicit instantiations\n+(with @code{extern}), G++ has extended the template instantiation\n syntax to support instantiation of the compiler support data for a\n template class (i.e.@: the vtable) without instantiating any of its\n members (with @code{inline}), and instantiation of only the static data\n members of a template class, without the support data or member\n functions (with @code{static}):\n \n @smallexample\n-extern template int max (int, int);\n inline template class Foo<int>;\n static template class Foo<int>;\n @end smallexample\n-\n-@item\n-Do nothing.  Pretend G++ does implement automatic instantiation\n-management.  Code written for the Borland model works fine, but\n-each translation unit contains instances of each of the templates it\n-uses.  In a large program, this can lead to an unacceptable amount of code\n-duplication.\n @end enumerate\n \n @node Bound member functions"}, {"sha": "8819c024a37e7a98eb8c683239dce1d0fb168351", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badfb2fbefac5b03bc1731b07900e3e75d5c01f8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=badfb2fbefac5b03bc1731b07900e3e75d5c01f8", "patch": "@@ -2085,11 +2085,11 @@ regardless of what language your program is in.  For example, you\n might compile a file @file{firstClass.C} like this:\n \n @smallexample\n-g++ -g -frepo -O -c firstClass.C\n+g++ -g -fstrict-enums -O -c firstClass.C\n @end smallexample\n \n @noindent\n-In this example, only @option{-frepo} is an option meant\n+In this example, only @option{-fstrict-enums} is an option meant\n only for C++ programs; you can use the other options with any\n language supported by GCC@.\n "}]}