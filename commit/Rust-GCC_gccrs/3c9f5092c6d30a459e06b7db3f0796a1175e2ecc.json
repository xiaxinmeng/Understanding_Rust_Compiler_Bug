{"sha": "3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5ZjUwOTJjNmQzMGE0NTllMDZiN2RiM2YwNzk2YTExNzVlMmVjYw==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-09-19T13:45:40Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-09-19T13:45:40Z"}, "message": "libcaf.h: Add caf_reference_type.\n\nlibgfortran/ChangeLog:\n\n2016-09-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* caf/libcaf.h: Add caf_reference_type.\n\t* caf/mpi.c: Adapted signature of caf_register().\n\t* caf/single.c (struct caf_single_token): Added to keep the pointer\n\tto the memory registered and array descriptor.\n\t(caf_internal_error): Added convenience interface.\n\t(_gfortran_caf_register): Adapted to work with caf_single_token and\n\treturn memory in the array descriptor.\n\t(_gfortran_caf_deregister): Same.\n\t(assign_char1_from_char4): Fixed style.\n\t(convert_type): Fixed incorrect conversion.\n\t(_gfortran_caf_get): Adapted to work with caf_single_token.\n\t(_gfortran_caf_send): Same.\n\t(_gfortran_caf_sendget): Same.\n\t(copy_data): Added to stop repeating it in all _by_ref functions.\n\t(get_for_ref): Recursive getting of coarray data using a chain of\n\treferences.\n\t(_gfortran_caf_get_by_ref): Driver for computing the memory needed for\n\tthe get and checking properties of the operation.\n\t(send_by_ref): Same as get_for_ref but for sending data.\n\t(_gfortran_caf_send_by_ref): Same like caf_get_by_ref but for sending.\n\t(_gfortran_caf_sendget_by_ref): Uses get_by_ref and send_by_ref to\n\timplement sendget for reference chains.\n\t(_gfortran_caf_atomic_define): Adapted to work with caf_single_token.\n\t(_gfortran_caf_atomic_ref): Likewise.\n\t(_gfortran_caf_atomic_cas): Likewise.\n\t(_gfortran_caf_atomic_op): Likewise.\n\t(_gfortran_caf_event_post): Likewise.\n\t(_gfortran_caf_event_wait): Likewise.\n\t(_gfortran_caf_event_query): Likewise.\n\t(_gfortran_caf_lock): Likewise.\n\t(_gfortran_caf_unlock): Likewise.\n\n\ngcc/testsuite/ChangeLog:\n\n2016-09-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray/alloc_comp_4.f90: New test.\n\t* gfortran.dg/coarray_38.f90:\n\t* gfortran.dg/coarray_alloc_comp_1.f08: New test.\n\t* gfortran.dg/coarray_alloc_comp_2.f08: New test.\n\t* gfortran.dg/coarray_allocate_7.f08: New test.\n\t* gfortran.dg/coarray_allocate_8.f08: New test.\n\t* gfortran.dg/coarray_allocate_9.f08: New test.\n\t* gfortran.dg/coarray_lib_alloc_1.f90: Adapted scan-tree-dumps to expect\n\tnew caf_register.\n\t* gfortran.dg/coarray_lib_alloc_2.f90: Same.\n\t* gfortran.dg/coarray_lib_alloc_3.f90: Same.\n\t* gfortran.dg/coarray_lib_comm_1.f90: Adapted scan-tree-dumps to expect\n\tget_by_refs.\n\t* gfortran.dg/coarray_lib_token_3.f90: Same as for coarray_lib_alloc2.\n\t* gfortran.dg/coarray_lock_7.f90: Same.\n\t* gfortran.dg/coarray_poly_5.f90: Same.\n\t* gfortran.dg/coarray_poly_6.f90: Same.\n\t* gfortran.dg/coarray_poly_7.f90: Same.\n\t* gfortran.dg/coarray_poly_8.f90: Same.\n\t* gfortran.dg/coindexed_1.f90: Changed errors expected.\n\ngcc/fortran/ChangeLog:\n\n2016-09-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* expr.c (gfc_check_assign): Added flag to control whether datatype\n\tconversion is allowed.\n\t* gfortran.h: Added caf-token-tree to gfc_component.  Changed\n\tprototypes mostly to add whether datatype conversion is allowed.\n\t* gfortran.texi: Added documentation for the caf_reference_t and the\n\tcaf_*_by_ref function.\n\t* primary.c (caf_variable_attr): Similar to gfc_variable_attr but\n\tfocused on the needs of coarrays.\n\t(gfc_caf_attr): Same.\n\t* resolve.c (resolve_ordinary_assign): Set the conversion allowed\n\tflag when not in a coarray.\n\t* trans-array.c (gfc_array_init_size): Moved setting of array\n\tdescriptor's datatype before the alloc, because caf_register needs it.\n\t(gfc_array_allocate): Changed notion of whether an array is a coarray.\n\t(gfc_array_deallocate): Same.\n\t(gfc_alloc_allocatable_for_assignment): Added setting of coarray's\n\tarray descriptor datatype before the register.  And using deregister/\n\tregister to mimmick a realloc for coarrays.\n\t* trans-decl.c (gfc_build_builtin_function_decls): Corrected signatures\n\tof old caf-functions and added signature definitions of the _by_ref\n\tones.\n\t(generate_coarray_sym_init): Adapted to new caf_register signature.\n\t* trans-expr.c (gfc_conv_scalar_to_descriptor): Make sure a constant\n\tis translated to an lvalue expression before use in an array\n\tdescriptor.\n\t(gfc_get_ultimate_alloc_ptr_comps_caf_token): New function.  Get the\n\tlast allocatable component's coarray token.\n\t(gfc_get_tree_for_caf_expr): For top-level object get the coarray\n\ttoken and check for unsupported features.\n\t(gfc_get_caf_token_offset): Getting the offset might procude new\n\tstatements, which now are stored in the pre and post of the current se.\n\t(gfc_caf_get_image_index): For this image return a call to\n\tcaf_this_image.\n\t(expr_may_alias_variables): Check that the result is set for testing\n\tits properties.\n\t(alloc_scalar_allocatable_for_assignment): Added auto allocation of\n\tcoarray components.\n\t(gfc_trans_assignment_1): Rewrite an assign to a coarray object to\n\tbe a sendget.\n\t* trans-intrinsic.c (conv_caf_vector_subscript_elem): Corrected\n\twrong comment.\n\t(compute_component_offset): Compute the correct offset a structure\n\tmember.\n\t(conv_expr_ref_to_caf_ref): Convert to a chain of refs into\n\tcaf_references.\n\t(gfc_conv_intrinsic_caf_get): Call caf_get_by_ref instead of caf_get.\n\t(conv_caf_send): Call caf_*_by_ref for coarrays that need\n\treallocation.\n\t(gfc_conv_intrinsic_function): Adapted to new signuature of the caf\n\tdrivers.\n\t(conv_intrinsic_atomic_op): Add pre and post statements correctly.\n\t(conv_intrinsic_atomic_ref): Same.\n\t(conv_intrinsic_atomic_cas): Same.\n\t(conv_intrinsic_event_query): Same.\n\t* trans-stmt.c (gfc_trans_lock_unlock): Same.\n\t(gfc_trans_event_post_wait): Same.\n\t(gfc_trans_allocate): Support allocation of allocatable coarrays.\n\t(gfc_trans_deallocate): And there deallocation.\n\t* trans-types.c (gfc_typenode_for_spec): Added flag to control whether\n\ta component is part of coarray.  When so, then add space to store a\n\tcoarray token.\n\t(gfc_build_array_type): Same.\n\t(gfc_get_array_descriptor_base): Same.\n\t(gfc_get_array_type_bounds): Same.\n\t(gfc_sym_type): Same.\n\t(gfc_get_derived_type): Same.\n\t(gfc_get_caf_reference_type): Declare the caf_reference_type.\n\t* trans-types.h: Prototype changes only.\n\t* trans.c (gfc_allocate_using_lib): Use the updated caf_register\n\tsignature.\n\t(gfc_allocate_allocatable): Same.\n\t(gfc_deallocate_with_status): Same.\n\t* trans.h: Defined the runtime types for caf_reference_t and the enums.\n\nFrom-SVN: r240231", "tree": {"sha": "9a8705f914f9ecf3d0ee2ae64c50f68a5472a893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a8705f914f9ecf3d0ee2ae64c50f68a5472a893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/comments", "author": null, "committer": null, "parents": [{"sha": "e79e6763c68224a1b0d272d32697702faee7e427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79e6763c68224a1b0d272d32697702faee7e427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79e6763c68224a1b0d272d32697702faee7e427"}], "stats": {"total": 4366, "additions": 4048, "deletions": 318}, "files": [{"sha": "a84e15eed90077f207607cb25c4ae7f05c17ab19", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -1,3 +1,80 @@\n+2016-09-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/71952\n+\t* expr.c (gfc_check_assign): Added flag to control whether datatype\n+\tconversion is allowed.\n+\t* gfortran.h: Added caf-token-tree to gfc_component.  Changed\n+\tprototypes mostly to add whether datatype conversion is allowed.\n+\t* gfortran.texi: Added documentation for the caf_reference_t and the\n+\tcaf_*_by_ref function.\n+\t* primary.c (caf_variable_attr): Similar to gfc_variable_attr but\n+\tfocused on the needs of coarrays.\n+\t(gfc_caf_attr): Same.\n+\t* resolve.c (resolve_ordinary_assign): Set the conversion allowed\n+\tflag when not in a coarray.\n+\t* trans-array.c (gfc_array_init_size): Moved setting of array\n+\tdescriptor's datatype before the alloc, because caf_register needs it.\n+\t(gfc_array_allocate): Changed notion of whether an array is a coarray.\n+\t(gfc_array_deallocate): Same.\n+\t(gfc_alloc_allocatable_for_assignment): Added setting of coarray's\n+\tarray descriptor datatype before the register.  And using deregister/\n+\tregister to mimmick a realloc for coarrays.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Corrected signatures\n+\tof old caf-functions and added signature definitions of the _by_ref\n+\tones.\n+\t(generate_coarray_sym_init): Adapted to new caf_register signature.\n+\t* trans-expr.c (gfc_conv_scalar_to_descriptor): Make sure a constant\n+\tis translated to an lvalue expression before use in an array\n+\tdescriptor.\n+\t(gfc_get_ultimate_alloc_ptr_comps_caf_token): New function.  Get the\n+\tlast allocatable component's coarray token.\n+\t(gfc_get_tree_for_caf_expr): For top-level object get the coarray\n+\ttoken and check for unsupported features.\n+\t(gfc_get_caf_token_offset): Getting the offset might procude new\n+\tstatements, which now are stored in the pre and post of the current se.\n+\t(gfc_caf_get_image_index): For this image return a call to\n+\tcaf_this_image.\n+\t(expr_may_alias_variables): Check that the result is set for testing\n+\tits properties.\n+\t(alloc_scalar_allocatable_for_assignment): Added auto allocation of\n+\tcoarray components.\n+\t(gfc_trans_assignment_1): Rewrite an assign to a coarray object to\n+\tbe a sendget.\n+\t* trans-intrinsic.c (conv_caf_vector_subscript_elem): Corrected\n+\twrong comment.\n+\t(compute_component_offset): Compute the correct offset a structure\n+\tmember.\n+\t(conv_expr_ref_to_caf_ref): Convert to a chain of refs into\n+\tcaf_references.\n+\t(gfc_conv_intrinsic_caf_get): Call caf_get_by_ref instead of caf_get.\n+\t(conv_caf_send): Call caf_*_by_ref for coarrays that need\n+\treallocation.\n+\t(gfc_conv_intrinsic_function): Adapted to new signuature of the caf\n+\tdrivers.\n+\t(conv_intrinsic_atomic_op): Add pre and post statements correctly.\n+\t(conv_intrinsic_atomic_ref): Same.\n+\t(conv_intrinsic_atomic_cas): Same.\n+\t(conv_intrinsic_event_query): Same.\n+\t* trans-stmt.c (gfc_trans_lock_unlock): Same.\n+\t(gfc_trans_event_post_wait): Same.\n+\t(gfc_trans_allocate): Support allocation of allocatable coarrays.\n+\t(gfc_trans_deallocate): And there deallocation.\n+\t* trans-types.c (gfc_typenode_for_spec): Added flag to control whether\n+\ta component is part of coarray.  When so, then add space to store a\n+\tcoarray token.\n+\t(gfc_build_array_type): Same.\n+\t(gfc_get_array_descriptor_base): Same.\n+\t(gfc_get_array_type_bounds): Same.\n+\t(gfc_sym_type): Same.\n+\t(gfc_get_derived_type): Same.\n+\t(gfc_get_caf_reference_type): Declare the caf_reference_type.\n+\t* trans-types.h: Prototype changes only.\n+\t* trans.c (gfc_allocate_using_lib): Use the updated caf_register\n+\tsignature.\n+\t(gfc_allocate_allocatable): Same.\n+\t(gfc_deallocate_with_status): Same.\n+\t* trans.h: Defined the runtime types for caf_reference_t and the enums.\n+\n 2016-09-19  Fritz Reese  <fritzoreese@gmail.com>\n \n \tPR fortran/77584"}, {"sha": "b3acf1d5d73814cc85f2c0b032b463e13b67bd49", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -3128,10 +3128,14 @@ gfc_check_conformance (gfc_expr *op1, gfc_expr *op2, const char *optype_msgid, .\n \n \n /* Given an assignable expression and an arbitrary expression, make\n-   sure that the assignment can take place.  */\n+   sure that the assignment can take place.  Only add a call to the intrinsic\n+   conversion routines, when allow_convert is set.  When this assign is a\n+   coarray call, then the convert is done by the coarray routine implictly and\n+   adding the intrinsic conversion would do harm in most cases.  */\n \n bool\n-gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n+gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,\n+\t\t  bool allow_convert)\n {\n   gfc_symbol *sym;\n   gfc_ref *ref;\n@@ -3309,12 +3313,15 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n      kind values can be converted into one another.  */\n   if (lvalue->ts.type == BT_CHARACTER && rvalue->ts.type == BT_CHARACTER)\n     {\n-      if (lvalue->ts.kind != rvalue->ts.kind)\n+      if (lvalue->ts.kind != rvalue->ts.kind && allow_convert)\n \tgfc_convert_chartype (rvalue, &lvalue->ts);\n \n       return true;\n     }\n \n+  if (!allow_convert)\n+    return true;\n+\n   return gfc_convert_type (rvalue, &lvalue->ts, 1);\n }\n "}, {"sha": "c3fb6ed5975cfb5d2f663c304a370deffb834b23", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -1043,6 +1043,8 @@ typedef struct gfc_component\n \n   /* Needed for procedure pointer components.  */\n   struct gfc_typebound_proc *tb;\n+  /* When allocatable/pointer and in a coarray the associated token.  */\n+  tree caf_token;\n }\n gfc_component;\n \n@@ -2768,7 +2770,7 @@ int gfc_validate_kind (bt, int, bool);\n int gfc_get_int_kind_from_width_isofortranenv (int size);\n int gfc_get_real_kind_from_width_isofortranenv (int size);\n tree gfc_get_union_type (gfc_symbol *);\n-tree gfc_get_derived_type (gfc_symbol * derived);\n+tree gfc_get_derived_type (gfc_symbol * derived, bool in_coarray = false);\n extern int gfc_index_integer_kind;\n extern int gfc_default_integer_kind;\n extern int gfc_max_integer_kind;\n@@ -3047,7 +3049,7 @@ int gfc_numeric_ts (gfc_typespec *);\n int gfc_kind_max (gfc_expr *, gfc_expr *);\n \n bool gfc_check_conformance (gfc_expr *, gfc_expr *, const char *, ...) ATTRIBUTE_PRINTF_3;\n-bool gfc_check_assign (gfc_expr *, gfc_expr *, int);\n+bool gfc_check_assign (gfc_expr *, gfc_expr *, int, bool c = true);\n bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n bool gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);\n \n@@ -3212,6 +3214,7 @@ const char *gfc_dt_upper_string (const char *);\n /* primary.c */\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);\n symbol_attribute gfc_expr_attr (gfc_expr *);\n+symbol_attribute gfc_caf_attr (gfc_expr *, bool in_allocate = false);\n match gfc_match_rvalue (gfc_expr **);\n match gfc_match_varspec (gfc_expr*, int, bool, bool);\n int gfc_check_digit (char, int);"}, {"sha": "85c1986a71b4f6cab9c135b0a1ceacb3b70568e0", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 316, "deletions": 16, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -3571,6 +3571,7 @@ of such a type\n @menu\n * caf_token_t::\n * caf_register_t::\n+* caf_reference_t::\n @end menu\n \n @node caf_token_t\n@@ -3597,6 +3598,114 @@ typedef enum caf_register_t {\n caf_register_t;\n @end verbatim\n \n+@node caf_reference_t\n+@subsection @code{caf_reference_t}\n+\n+The structure used for implementing arbitrary reference chains.\n+A @code{CAF_REFERENCE_T} allows to specify a component reference or any kind\n+of array reference of any rank supported by gfortran.  For array references all\n+kinds as known by the compiler/Fortran standard are supported indicated by\n+a @code{MODE}.\n+\n+@verbatim\n+typedef enum caf_ref_type_t {\n+  /* Reference a component of a derived type, either regular one or an\n+     allocatable or pointer type.  For regular ones idx in caf_reference_t is\n+     set to -1.  */\n+  CAF_REF_COMPONENT,\n+  /* Reference an allocatable array.  */\n+  CAF_REF_ARRAY,\n+  /* Reference a non-allocatable/non-pointer array.  I.e., the coarray object\n+     has no array descriptor associated and the addressing is done\n+     completely using the ref.  */\n+  CAF_REF_STATIC_ARRAY\n+} caf_ref_type_t;\n+@end verbatim\n+\n+@verbatim\n+typedef enum caf_array_ref_t {\n+  /* No array ref.  This terminates the array ref.  */\n+  CAF_ARR_REF_NONE = 0,\n+  /* Reference array elements given by a vector.  Only for this mode\n+     caf_reference_t.u.a.dim[i].v is valid.  */\n+  CAF_ARR_REF_VECTOR,\n+  /* A full array ref (:).  */\n+  CAF_ARR_REF_FULL,\n+  /* Reference a range on elements given by start, end and stride.  */\n+  CAF_ARR_REF_RANGE,\n+  /* Only a single item is referenced given in the start member.  */\n+  CAF_ARR_REF_SINGLE,\n+  /* An array ref of the kind (i:), where i is an arbitrary valid index in the\n+     array.  The index i is given in the start member.  */\n+  CAF_ARR_REF_OPEN_END,\n+  /* An array ref of the kind (:i), where the lower bound of the array ref\n+     is given by the remote side.  The index i is given in the end member.  */\n+  CAF_ARR_REF_OPEN_START\n+} caf_array_ref_t;\n+@end verbatim\n+\n+@verbatim\n+/* References to remote components of a derived type.  */\n+typedef struct caf_reference_t {\n+  /* A pointer to the next ref or NULL.  */\n+  struct caf_reference_t *next;\n+  /* The type of the reference.  */\n+  /* caf_ref_type_t, replaced by int to allow specification in fortran FE.  */\n+  int type;\n+  /* The size of an item referenced in bytes.  I.e. in an array ref this is\n+     the factor to advance the array pointer with to get to the next item.\n+     For component refs this gives just the size of the element referenced.  */\n+  size_t item_size;\n+  union {\n+    struct {\n+      /* The offset (in bytes) of the component in the derived type.\n+         Unused for allocatable or pointer components.  */\n+      ptrdiff_t offset;\n+      /* The offset (in bytes) to the caf_token associated with this\n+         component.  NULL, when not allocatable/pointer ref.  */\n+      ptrdiff_t caf_token_offset;\n+    } c;\n+    struct {\n+      /* The mode of the array ref.  See CAF_ARR_REF_*.  */\n+      /* caf_array_ref_t, replaced by unsigend char to allow specification in\n+         fortran FE.  */\n+     unsigned char mode[GFC_MAX_DIMENSIONS];\n+      /* The type of a static array.  Unset for array's with descriptors.  */\n+      int static_array_type;\n+      /* Subscript refs (s) or vector refs (v).  */\n+      union {\n+        struct {\n+          /* The start and end boundary of the ref and the stride.  */\n+          index_type start, end, stride;\n+        } s;\n+        struct {\n+          /* nvec entries of kind giving the elements to reference.  */\n+          void *vector;\n+          /* The number of entries in vector.  */\n+          size_t nvec;\n+          /* The integer kind used for the elements in vector.  */\n+          int kind;\n+        } v;\n+      } dim[GFC_MAX_DIMENSIONS];\n+    } a;\n+  } u;\n+} caf_reference_t;\n+@end verbatim\n+\n+The references make up a single linked list of reference operations.  The\n+@code{NEXT} member links to the next reference or NULL to indicate the end of\n+the chain.  Component and array refs can be arbitrarly mixed as long as they\n+comply to the Fortran standard.\n+\n+@emph{NOTES}\n+The member @code{STATIC_ARRAY_TYPE} is used only when the @code{TYPE} is\n+@code{CAF_REF_STATIC_ARRAY}.  The member gives the type of the data referenced.\n+Because no array descriptor is available for a descriptor-less array and\n+type conversion still needs to take place the type is transported here.\n+\n+At the moment @code{CAF_ARR_REF_VECTOR} is not implemented in the front end for\n+descriptor-less arrays.  The library caf_single has untested support for it.\n+\n \n @node Function ABI Documentation\n @section Function ABI Documentation\n@@ -3611,6 +3720,9 @@ caf_register_t;\n * _gfortran_caf_send:: Sending data from a local image to a remote image\n * _gfortran_caf_get:: Getting data from a remote image\n * _gfortran_caf_sendget:: Sending data between remote images\n+* _gfortran_caf_send_by_ref:: Sending data from a local image to a remote image using enhanced references\n+* _gfortran_caf_get_by_ref:: Getting data from a remote image using enhanced references\n+* _gfortran_caf_sendget_by_ref:: Sending data between remote images using enhanced references\n * _gfortran_caf_lock:: Locking a lock variable\n * _gfortran_caf_unlock:: Unlocking a lock variable\n * _gfortran_caf_event_post:: Post an event\n@@ -3742,19 +3854,24 @@ the the compiler passes @code{distance=0} and @code{failed=-1} to the function.\n \n @node _gfortran_caf_register\n @subsection @code{_gfortran_caf_register} --- Registering coarrays\n-@cindex Coarray, _gfortran_caf_deregister\n+@cindex Coarray, _gfortran_caf_register\n \n @table @asis\n @item @emph{Description}:\n-Allocates memory for a coarray and creates a token to identify the coarray. The\n-function is called for both coarrays with @code{SAVE} attribute and using an\n-explicit @code{ALLOCATE} statement. If an error occurs and @var{STAT} is a\n+Registers memory for a coarray and creates a token to identify the coarray.  The\n+routine is called for both coarrays with @code{SAVE} attribute and using an\n+explicit @code{ALLOCATE} statement.  If an error occurs and @var{STAT} is a\n @code{NULL} pointer, the function shall abort with printing an error message\n and starting the error termination.  If no error occurs and @var{STAT} is\n-present, it shall be set to zero. Otherwise, it shall be set to a positive\n+present, it shall be set to zero.  Otherwise, it shall be set to a positive\n value and, if not-@code{NULL}, @var{ERRMSG} shall be set to a string describing\n-the failure. The function shall return a pointer to the requested memory\n-for the local image as a call to @code{malloc} would do.\n+the failure.  The routine shall register the memory provided in the\n+@code{DATA}-component of the array descriptor @var{DESC}, when that component\n+is non-@code{NULL}, else it shall allocate sufficient memory and provide a\n+pointer to it in the @code{DATA}-component of @var{DESC}.  The array descriptor\n+has rank zero, when a scalar object is to be registered and the array\n+descriptor may be invalid after the call to @code{_gfortran_caf_register}.\n+When an array is to be allocated the descriptor persists.\n \n For @code{CAF_REGTYPE_COARRAY_STATIC} and @code{CAF_REGTYPE_COARRAY_ALLOC},\n the passed size is the byte size requested.  For @code{CAF_REGTYPE_LOCK_STATIC},\n@@ -3763,15 +3880,16 @@ size or one for a scalar.\n \n \n @item @emph{Syntax}:\n-@code{void *caf_register (size_t size, caf_register_t type, caf_token_t *token,\n-int *stat, char *errmsg, int errmsg_len)}\n+@code{void caf_register (size_t size, caf_register_t type, caf_token_t *token,\n+gfc_descriptor_t *desc, int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{size} @tab For normal coarrays, the byte size of the coarray to be\n allocated; for lock types and event types, the number of elements.\n @item @var{type} @tab one of the caf_register_t types.\n @item @var{token} @tab intent(out) An opaque pointer identifying the coarray.\n+@item @var{desc} @tab intent(inout) The (pseudo) array descriptor.\n @item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n may be NULL\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n@@ -3787,20 +3905,19 @@ GCC does such that also nonallocatable coarrays the memory is allocated and no\n static memory is used.  The token permits to identify the coarray; to the\n processor, the token is a nonaliasing pointer. The library can, for instance,\n store the base address of the coarray in the token, some handle or a more\n-complicated struct.\n+complicated struct.  The library may also store the array descriptor\n+@var{DESC} when its rank is non-zero.\n \n-For normal coarrays, the returned pointer is used for accesses on the local\n-image. For lock types, the value shall only used for checking the allocation\n+For lock types, the value shall only used for checking the allocation\n status. Note that for critical blocks, the locking is only required on one\n-image; in the locking statement, the processor shall always pass always an\n+image; in the locking statement, the processor shall always pass an\n image index of one for critical-block lock variables\n (@code{CAF_REGTYPE_CRITICAL}). For lock types and critical-block variables,\n the initial value shall be unlocked (or, respecitively, not in critical\n section) such as the value false; for event types, the initial state should\n be no event, e.g. zero.\n @end table\n \n-\n @node _gfortran_caf_deregister\n @subsection @code{_gfortran_caf_deregister} --- Deregistering coarrays\n @cindex Coarray, _gfortran_caf_deregister\n@@ -3809,14 +3926,17 @@ be no event, e.g. zero.\n @item @emph{Description}:\n Called to free the memory of a coarray; the processor calls this function for\n automatic and explicit deallocation.  In case of an error, this function shall\n-fail with an error message, unless the @var{STAT} variable is not null.\n+fail with an error message, unless the @var{STAT} variable is not null.  The\n+library is only expected to free memory it allocated itself during a call to\n+@code{_gfortran_caf_register}.\n \n @item @emph{Syntax}:\n-@code{void caf_deregister (const caf_token_t *token, int *stat, char *errmsg,\n+@code{void caf_deregister (caf_token_t *token, int *stat, char *errmsg,\n int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n+@item @var{token} @tab the token to free.\n @item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set\n to an error message; may be NULL\n@@ -3997,6 +4117,186 @@ the library has to handle numeric-type conversion and for strings, padding and\n different character kinds.\n @end table\n \n+@node _gfortran_caf_send_by_ref\n+@subsection @code{_gfortran_caf_send_by_ref} --- Sending data from a local image to a remote image with enhanced referencing options\n+@cindex Coarray, _gfortran_caf_send_by_ref\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to send a scalar, an array section or whole array from a local to a\n+remote image identified by the image_index.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_send_by_ref (caf_token_t token, int image_index,\n+gfc_descriptor_t *src, caf_reference_t *refs, int dst_kind, int src_kind,\n+bool may_require_tmp, bool dst_reallocatable, int *stat)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{src} @tab intent(in) Array descriptor of the local array to be\n+transferred to the remote image\n+@item @var{refs} @tab intent(in) the references on the remote array to store\n+the data given by src.  Guaranteed to have at least one entry.\n+@item @var{dst_kind} @tab Kind of the destination argument\n+@item @var{src_kind} @tab Kind of the source argument\n+@item @var{may_require_tmp} @tab The variable is false it is known at compile\n+time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n+or partially) such that walking @var{src} and @var{dest} in element wise\n+element order (honoring the stride value) will not lead to wrong results.\n+Otherwise, the value is true.\n+@item @var{dst_reallocatable} @tab set when the destination is of allocatable\n+or pointer type and the refs will allow reallocation, i.e., the ref is a full\n+array or component ref.\n+@item @var{stat} @tab intent(out) when non-@code{NULL} give the result of the\n+operation, i.e., zero on success and non-zero on error.  When @code{NULL} and\n+error occurs, then an error message is printed and the program is terminated.\n+@end multitable\n+\n+@item @emph{NOTES}\n+It is permitted to have image_id equal the current image; the memory of the\n+send-to and the send-from might (partially) overlap in that case.  The\n+implementation has to take care that it handles this case, e.g. using\n+@code{memmove} which handles (partially) overlapping memory.  If\n+@var{may_require_tmp} is true, the library might additionally create a\n+temporary variable, unless additional checks show that this is not required\n+(e.g. because walking backward is possible or because both arrays are\n+contiguous and @code{memmove} takes care of overlap issues).\n+\n+Note that the assignment of a scalar to an array is permitted.  In addition,\n+the library has to handle numeric-type conversion and for strings, padding\n+and different character kinds.\n+\n+Because of the more complicated references possible some operations may be\n+unsupported by certain libraries.  The library is expected to issue a precise\n+error message why the operation is not permitted.\n+@end table\n+\n+\n+@node _gfortran_caf_get_by_ref\n+@subsection @code{_gfortran_caf_get_by_ref} --- Getting data from a remote image using enhanced references\n+@cindex Coarray, _gfortran_caf_get_by_ref\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to get a scalar, an array section or whole array from a a remote image\n+identified by the image_index.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_get_by_ref (caf_token_t token, int image_index,\n+caf_reference_t *refs, gfc_descriptor_t *dst, int dst_kind, int src_kind,\n+bool may_require_tmp, bool dst_reallocatable, int *stat)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{refs} @tab intent(in) the references to apply to the remote structure\n+to get the data.\n+@item @var{dst} @tab intent(in) Array descriptor of the local array to store\n+the data transferred from the remote image.  May be reallocated where needed\n+and when @var{DST_REALLOCATABLE} allows it.\n+@item @var{dst_kind} @tab Kind of the destination argument\n+@item @var{src_kind} @tab Kind of the source argument\n+@item @var{may_require_tmp} @tab The variable is false it is known at compile\n+time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n+or partially) such that walking @var{src} and @var{dest} in element wise\n+element order (honoring the stride value) will not lead to wrong results.\n+Otherwise, the value is true.\n+@item @var{dst_reallocatable} @tab set when @var{DST} is of allocatable\n+or pointer type and its refs allow reallocation, i.e., the full array or a\n+component is referenced.\n+@item @var{stat} @tab intent(out) when non-@code{NULL} give the result of the\n+operation, i.e., zero on success and non-zero on error.  When @code{NULL} and\n+error occurs, then an error message is printed and the program is terminated.\n+@end multitable\n+\n+@item @emph{NOTES}\n+It is permitted to have image_id equal the current image; the memory of the\n+send-to and the send-from might (partially) overlap in that case.  The\n+implementation has to take care that it handles this case, e.g. using\n+@code{memmove} which handles (partially) overlapping memory.  If\n+@var{may_require_tmp} is true, the library might additionally create a\n+temporary variable, unless additional checks show that this is not required\n+(e.g. because walking backward is possible or because both arrays are\n+contiguous and @code{memmove} takes care of overlap issues).\n+\n+Note that the library has to handle numeric-type conversion and for strings,\n+padding and different character kinds.\n+\n+Because of the more complicated references possible some operations may be\n+unsupported by certain libraries.  The library is expected to issue a precise\n+error message why the operation is not permitted.\n+@end table\n+\n+\n+@node _gfortran_caf_sendget_by_ref\n+@subsection @code{_gfortran_caf_sendget_by_ref} --- Sending data between remote images using enhanced references on both sides\n+@cindex Coarray, _gfortran_caf_sendget_by_ref\n+\n+@table @asis\n+@item @emph{Description}:\n+Called to send a scalar, an array section or whole array from a remote image\n+identified by the src_image_index to a remote image identified by the\n+dst_image_index.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_sendget_by_ref (caf_token_t dst_token,\n+int dst_image_index, caf_reference_t *dst_refs,\n+caf_token_t src_token, int src_image_index, caf_reference_t *src_refs,\n+int dst_kind, int src_kind, bool may_require_tmp, int *dst_stat, int *src_stat)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{dst_token} @tab intent(in)  An opaque pointer identifying the\n+destination coarray.\n+@item @var{dst_image_index} @tab The ID of the destination remote image; must\n+be a positive number.\n+@item @var{dst_refs} @tab intent(in) the references on the remote array to store\n+the data given by src.  Guaranteed to have at least one entry.\n+@item @var{src_token} @tab An opaque pointer identifying the source coarray.\n+@item @var{src_image_index} @tab The ID of the source remote image; must be a\n+positive number.\n+@item @var{src_refs} @tab intent(in) the references to apply to the remote\n+structure to get the data.\n+@item @var{dst_kind} @tab Kind of the destination argument\n+@item @var{src_kind} @tab Kind of the source argument\n+@item @var{may_require_tmp} @tab The variable is false it is known at compile\n+time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n+or partially) such that walking @var{src} and @var{dest} in element wise\n+element order (honoring the stride value) will not lead to wrong results.\n+Otherwise, the value is true.\n+@item @var{dst_stat} @tab intent(out) when non-@code{NULL} give the result of\n+the send-operation, i.e., zero on success and non-zero on error.  When\n+@code{NULL} and an error occurs, then an error message is printed and the\n+program is terminated.\n+@item @var{src_stat} @tab intent(out) when non-@code{NULL} give the result of\n+the get-operation, i.e., zero on success and non-zero on error.  When\n+@code{NULL} and an error occurs, then an error message is printed and the\n+program is terminated.\n+@end multitable\n+\n+@item @emph{NOTES}\n+It is permitted to have image_ids equal; the memory of the send-to and the\n+send-from might (partially) overlap in that case.  The implementation has to\n+take care that it handles this case, e.g. using @code{memmove} which handles\n+(partially) overlapping memory.  If @var{may_require_tmp} is true, the library\n+might additionally create a temporary variable, unless additional checks show\n+that this is not required (e.g. because walking backward is possible or because\n+both arrays are contiguous and @code{memmove} takes care of overlap issues).\n+\n+Note that the assignment of a scalar to an array is permitted.  In addition,\n+the library has to handle numeric-type conversion and for strings, padding and\n+different character kinds.\n+\n+Because of the more complicated references possible some operations may be\n+unsupported by certain libraries.  The library is expected to issue a precise\n+error message why the operation is not permitted.\n+@end table\n+\n \n @node _gfortran_caf_lock\n @subsection @code{_gfortran_caf_lock} --- Locking a lock variable"}, {"sha": "c5e9778b1f2dc0cc3b9f6735d63e5634d9b880be", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -2376,6 +2376,163 @@ gfc_expr_attr (gfc_expr *e)\n }\n \n \n+/* Given an expression, figure out what the ultimate expression\n+   attribute is.  This routine is similar to gfc_variable_attr with\n+   parts of gfc_expr_attr, but focuses more on the needs of\n+   coarrays.  For coarrays a codimension attribute is kind of\n+   \"infectious\" being propagated once set and never cleared.  */\n+\n+static symbol_attribute\n+caf_variable_attr (gfc_expr *expr, bool in_allocate)\n+{\n+  int dimension, codimension, pointer, allocatable, target, coarray_comp,\n+      alloc_comp;\n+  symbol_attribute attr;\n+  gfc_ref *ref;\n+  gfc_symbol *sym;\n+  gfc_component *comp;\n+\n+  if (expr->expr_type != EXPR_VARIABLE && expr->expr_type != EXPR_FUNCTION)\n+    gfc_internal_error (\"gfc_caf_attr(): Expression isn't a variable\");\n+\n+  sym = expr->symtree->n.sym;\n+  gfc_clear_attr (&attr);\n+\n+  if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n+    {\n+      dimension = CLASS_DATA (sym)->attr.dimension;\n+      codimension = CLASS_DATA (sym)->attr.codimension;\n+      pointer = CLASS_DATA (sym)->attr.class_pointer;\n+      allocatable = CLASS_DATA (sym)->attr.allocatable;\n+      coarray_comp = CLASS_DATA (sym)->attr.coarray_comp;\n+      alloc_comp = CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp;\n+    }\n+  else\n+    {\n+      dimension = sym->attr.dimension;\n+      codimension = sym->attr.codimension;\n+      pointer = sym->attr.pointer;\n+      allocatable = sym->attr.allocatable;\n+      coarray_comp = sym->attr.coarray_comp;\n+      alloc_comp = sym->ts.type == BT_DERIVED\n+\t  ? sym->ts.u.derived->attr.alloc_comp : 0;\n+    }\n+\n+  target = attr.target;\n+  if (pointer || attr.proc_pointer)\n+    target = 1;\n+\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    switch (ref->type)\n+      {\n+      case REF_ARRAY:\n+\n+\tswitch (ref->u.ar.type)\n+\t  {\n+\t  case AR_FULL:\n+\t  case AR_SECTION:\n+\t    dimension = 1;\n+\t    break;\n+\n+\t  case AR_ELEMENT:\n+\t    /* Handle coarrays.  */\n+\t    if (ref->u.ar.dimen > 0 && !in_allocate)\n+\t      allocatable = pointer = 0;\n+\t    break;\n+\n+\t  case AR_UNKNOWN:\n+\t    /* If any of start, end or stride is not integer, there will\n+\t       already have been an error issued.  */\n+\t    int errors;\n+\t    gfc_get_errors (NULL, &errors);\n+\t    if (errors == 0)\n+\t      gfc_internal_error (\"gfc_caf_attr(): Bad array reference\");\n+\t  }\n+\n+\tbreak;\n+\n+      case REF_COMPONENT:\n+\tcomp = ref->u.c.component;\n+\n+\tif (comp->ts.type == BT_CLASS)\n+\t  {\n+\t    codimension |= CLASS_DATA (comp)->attr.codimension;\n+\t    pointer = CLASS_DATA (comp)->attr.class_pointer;\n+\t    allocatable = CLASS_DATA (comp)->attr.allocatable;\n+\t    coarray_comp |= CLASS_DATA (comp)->attr.coarray_comp;\n+\t  }\n+\telse\n+\t  {\n+\t    codimension |= comp->attr.codimension;\n+\t    pointer = comp->attr.pointer;\n+\t    allocatable = comp->attr.allocatable;\n+\t    coarray_comp |= comp->attr.coarray_comp;\n+\t  }\n+\n+\tif (pointer || attr.proc_pointer)\n+\t  target = 1;\n+\n+\tbreak;\n+\n+      case REF_SUBSTRING:\n+\tallocatable = pointer = 0;\n+\tbreak;\n+      }\n+\n+  attr.dimension = dimension;\n+  attr.codimension = codimension;\n+  attr.pointer = pointer;\n+  attr.allocatable = allocatable;\n+  attr.target = target;\n+  attr.save = sym->attr.save;\n+  attr.coarray_comp = coarray_comp;\n+  attr.alloc_comp = alloc_comp;\n+\n+  return attr;\n+}\n+\n+\n+symbol_attribute\n+gfc_caf_attr (gfc_expr *e, bool in_allocate)\n+{\n+  symbol_attribute attr;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      attr = caf_variable_attr (e, in_allocate);\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      gfc_clear_attr (&attr);\n+\n+      if (e->value.function.esym && e->value.function.esym->result)\n+\t{\n+\t  gfc_symbol *sym = e->value.function.esym->result;\n+\t  attr = sym->attr;\n+\t  if (sym->ts.type == BT_CLASS)\n+\t    {\n+\t      attr.dimension = CLASS_DATA (sym)->attr.dimension;\n+\t      attr.pointer = CLASS_DATA (sym)->attr.class_pointer;\n+\t      attr.allocatable = CLASS_DATA (sym)->attr.allocatable;\n+\t      attr.alloc_comp = CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp;\n+\t    }\n+\t}\n+      else if (e->symtree)\n+\tattr = caf_variable_attr (e, in_allocate);\n+      else\n+\tgfc_clear_attr (&attr);\n+      break;\n+\n+    default:\n+      gfc_clear_attr (&attr);\n+      break;\n+    }\n+\n+  return attr;\n+}\n+\n+\n /* Match a structure constructor.  The initial symbol has already been\n    seen.  */\n "}, {"sha": "11b6a14824b81ce6b6b3303922ebbc18ce449433", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -9839,27 +9839,29 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n       return false;\n     }\n \n-  gfc_check_assign (lhs, rhs, 1);\n-\n   /* Assign the 'data' of a class object to a derived type.  */\n   if (lhs->ts.type == BT_DERIVED\n       && rhs->ts.type == BT_CLASS)\n     gfc_add_data_component (rhs);\n \n-  /* Insert a GFC_ISYM_CAF_SEND intrinsic, when the LHS is a coindexed variable.\n-     Additionally, insert this code when the RHS is a CAF as we then use the\n-     GFC_ISYM_CAF_SEND intrinsic just to avoid a temporary; but do not do so if\n-     the LHS is (re)allocatable or has a vector subscript.  If the LHS is a\n-     noncoindexed array and the RHS is a coindexed scalar, use the normal code\n-     path.  */\n-  if (flag_coarray == GFC_FCOARRAY_LIB\n+  bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB\n       && (lhs_coindexed\n \t  || (code->expr2->expr_type == EXPR_FUNCTION\n \t      && code->expr2->value.function.isym\n \t      && code->expr2->value.function.isym->id == GFC_ISYM_CAF_GET\n \t      && (code->expr1->rank == 0 || code->expr2->rank != 0)\n \t      && !gfc_expr_attr (rhs).allocatable\n-              && !gfc_has_vector_subscript (rhs))))\n+\t      && !gfc_has_vector_subscript (rhs)));\n+\n+  gfc_check_assign (lhs, rhs, 1, !caf_convert_to_send);\n+\n+  /* Insert a GFC_ISYM_CAF_SEND intrinsic, when the LHS is a coindexed variable.\n+     Additionally, insert this code when the RHS is a CAF as we then use the\n+     GFC_ISYM_CAF_SEND intrinsic just to avoid a temporary; but do not do so if\n+     the LHS is (re)allocatable or has a vector subscript.  If the LHS is a\n+     noncoindexed array and the RHS is a coindexed scalar, use the normal code\n+     path.  */\n+  if (caf_convert_to_send)\n     {\n       if (code->expr2->expr_type == EXPR_FUNCTION\n \t  && code->expr2->value.function.isym"}, {"sha": "bb33a231f4acf2a63464e0123e57621cf95cbbdf", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 104, "deletions": 23, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -5083,19 +5083,19 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   stride = gfc_index_one_node;\n   offset = gfc_index_zero_node;\n \n-  /* Set the dtype.  */\n+  /* Set the dtype before the alloc, because registration of coarrays needs\n+     it initialized.  */\n   if (expr->ts.type == BT_CHARACTER && expr->ts.deferred\n       && TREE_CODE (expr->ts.u.cl->backend_decl) == VAR_DECL)\n     {\n       type = gfc_typenode_for_spec (&expr->ts);\n       tmp = gfc_conv_descriptor_dtype (descriptor);\n-      gfc_add_modify (descriptor_block, tmp,\n-\t\t      gfc_get_dtype_rank_type (rank, type));\n+      gfc_add_modify (pblock, tmp, gfc_get_dtype_rank_type (rank, type));\n     }\n   else\n     {\n       tmp = gfc_conv_descriptor_dtype (descriptor);\n-      gfc_add_modify (descriptor_block, tmp, gfc_get_dtype (type));\n+      gfc_add_modify (pblock, tmp, gfc_get_dtype (type));\n     }\n \n   or_expr = boolean_false_node;\n@@ -5404,7 +5404,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   stmtblock_t elseblock;\n   gfc_expr **lower;\n   gfc_expr **upper;\n-  gfc_ref *ref, *prev_ref = NULL;\n+  gfc_ref *ref, *prev_ref = NULL, *coref;\n+  gfc_se caf_se;\n   bool allocatable, coarray, dimension, alloc_w_e3_arr_spec = false;\n \n   ref = expr->ref;\n@@ -5418,16 +5419,25 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (!prev_ref)\n     {\n       allocatable = expr->symtree->n.sym->attr.allocatable;\n-      coarray = expr->symtree->n.sym->attr.codimension;\n       dimension = expr->symtree->n.sym->attr.dimension;\n     }\n   else\n     {\n       allocatable = prev_ref->u.c.component->attr.allocatable;\n-      coarray = prev_ref->u.c.component->attr.codimension;\n       dimension = prev_ref->u.c.component->attr.dimension;\n     }\n \n+  /* For allocatable/pointer arrays in derived types, one of the refs has to be\n+     a coarray.  In this case it does not matter whether we are on this_image\n+     or not.  */\n+  coarray = false;\n+  for (coref = expr->ref; coref; coref = coref->next)\n+    if (coref->type == REF_ARRAY && coref->u.ar.codimen > 0)\n+      {\n+\tcoarray = true;\n+\tbreak;\n+      }\n+\n   if (!dimension)\n     gcc_assert (coarray);\n \n@@ -5482,6 +5492,9 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   overflow = integer_zero_node;\n \n   gfc_init_block (&set_descriptor_block);\n+  /* Take the corank only from the actual ref and not from the coref.  The\n+     later will mislead the generation of the array dimensions for allocatable/\n+     pointer components in derived types.  */\n   size = gfc_array_init_size (se->expr, alloc_w_e3_arr_spec ? expr->rank\n \t\t\t\t\t\t\t   : ref->u.ar.as->rank,\n \t\t\t      coarray ? ref->u.ar.as->corank : 0,\n@@ -5517,6 +5530,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t}\n     }\n \n+  gfc_init_se (&caf_se, NULL);\n   gfc_start_block (&elseblock);\n \n   /* Allocate memory to store the data.  */\n@@ -5527,16 +5541,22 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   STRIP_NOPS (pointer);\n \n   if (coarray && flag_coarray == GFC_FCOARRAY_LIB)\n-    token = gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t gfc_conv_descriptor_token (se->expr));\n+    {\n+      tmp = gfc_get_tree_for_caf_expr (expr);\n+      gfc_get_caf_token_offset (&caf_se, &token, NULL, tmp, NULL_TREE, expr);\n+      gfc_add_block_to_block (&elseblock, &caf_se.pre);\n+      token = gfc_build_addr_expr (NULL_TREE, token);\n+    }\n \n   /* The allocatable variant takes the old pointer as first argument.  */\n   if (allocatable)\n     gfc_allocate_allocatable (&elseblock, pointer, size, token,\n-\t\t\t      status, errmsg, errlen, label_finish, expr);\n+\t\t\t      status, errmsg, errlen, label_finish, expr,\n+\t\t\t      coref != NULL ? coref->u.ar.as->corank : 0);\n   else\n     gfc_allocate_using_malloc (&elseblock, pointer, size, status);\n \n+  gfc_add_block_to_block (&elseblock, &caf_se.post);\n   if (dimension)\n     {\n       cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n@@ -5592,7 +5612,7 @@ gfc_array_deallocate (tree descriptor, tree pstat, tree errmsg, tree errlen,\n   tree var;\n   tree tmp;\n   stmtblock_t block;\n-  bool coarray = gfc_is_coarray (expr);\n+  bool coarray = gfc_caf_attr (expr).codimension;\n \n   gfc_start_block (&block);\n \n@@ -8659,6 +8679,10 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   int n;\n   int dim;\n   gfc_array_spec * as;\n+  bool coarray = (flag_coarray == GFC_FCOARRAY_LIB\n+\t\t  && gfc_caf_attr (expr1, true).codimension);\n+  tree token;\n+  gfc_se caf_se;\n \n   /* x = f(...) with x allocatable.  In this case, expr1 is the rhs.\n      Find the lhs expression in the loop chain and set expr1 and\n@@ -8973,11 +8997,30 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_modify (&fblock, tmp,\n \t\t      gfc_get_dtype_rank_type (expr1->rank,type));\n     }\n+  else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    {\n+      gfc_add_modify (&fblock, gfc_conv_descriptor_dtype (desc),\n+\t\t      gfc_get_dtype (TREE_TYPE (desc)));\n+    }\n \n   /* Realloc expression.  Note that the scalarizer uses desc.data\n      in the array reference - (*desc.data)[<element>].  */\n   gfc_init_block (&realloc_block);\n+  gfc_init_se (&caf_se, NULL);\n \n+  if (coarray)\n+    {\n+      token = gfc_get_ultimate_alloc_ptr_comps_caf_token (&caf_se, expr1);\n+      if (token == NULL_TREE)\n+\t{\n+\t  tmp = gfc_get_tree_for_caf_expr (expr1);\n+\t  gfc_get_caf_token_offset (&caf_se, &token, NULL, tmp, NULL_TREE,\n+\t\t\t\t    expr1);\n+\t  token = gfc_build_addr_expr (NULL_TREE, token);\n+\t}\n+\n+      gfc_add_block_to_block (&realloc_block, &caf_se.pre);\n+    }\n   if ((expr1->ts.type == BT_DERIVED)\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n     {\n@@ -8986,12 +9029,32 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_expr_to_block (&realloc_block, tmp);\n     }\n \n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     builtin_decl_explicit (BUILT_IN_REALLOC), 2,\n-\t\t\t     fold_convert (pvoid_type_node, array1),\n-\t\t\t     size2);\n-  gfc_conv_descriptor_data_set (&realloc_block,\n-\t\t\t\tdesc, tmp);\n+  if (!coarray)\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_REALLOC), 2,\n+\t\t\t\t fold_convert (pvoid_type_node, array1),\n+\t\t\t\t size2);\n+      gfc_conv_descriptor_data_set (&realloc_block,\n+\t\t\t\t    desc, tmp);\n+    }\n+  else\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_caf_deregister,\n+\t\t\t\t 4, token, null_pointer_node,\n+\t\t\t\t null_pointer_node, integer_zero_node);\n+      gfc_add_expr_to_block (&realloc_block, tmp);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_caf_register,\n+\t\t\t\t 7, size2,\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\tGFC_CAF_COARRAY_ALLOC),\n+\t\t\t\t token, gfc_build_addr_expr (NULL_TREE, desc),\n+\t\t\t\t null_pointer_node, null_pointer_node,\n+\t\t\t\t integer_zero_node);\n+      gfc_add_expr_to_block (&realloc_block, tmp);\n+    }\n \n   if ((expr1->ts.type == BT_DERIVED)\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n@@ -9001,6 +9064,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_expr_to_block (&realloc_block, tmp);\n     }\n \n+  gfc_add_block_to_block (&realloc_block, &caf_se.post);\n   realloc_expr = gfc_finish_block (&realloc_block);\n \n   /* Only reallocate if sizes are different.  */\n@@ -9011,16 +9075,33 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \n   /* Malloc expression.  */\n   gfc_init_block (&alloc_block);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     builtin_decl_explicit (BUILT_IN_MALLOC),\n-\t\t\t     1, size2);\n-  gfc_conv_descriptor_data_set (&alloc_block,\n-\t\t\t\tdesc, tmp);\n+  if (!coarray)\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_MALLOC),\n+\t\t\t\t 1, size2);\n+      gfc_conv_descriptor_data_set (&alloc_block,\n+\t\t\t\t    desc, tmp);\n+    }\n+  else\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_caf_register,\n+\t\t\t\t 7, size2,\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t\tGFC_CAF_COARRAY_ALLOC),\n+\t\t\t\t token, gfc_build_addr_expr (NULL_TREE, desc),\n+\t\t\t\t null_pointer_node, null_pointer_node,\n+\t\t\t\t integer_zero_node);\n+      gfc_add_expr_to_block (&alloc_block, tmp);\n+    }\n+\n \n   /* We already set the dtype in the case of deferred character\n      length arrays.  */\n   if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n-        && expr1->ts.type == BT_CHARACTER && expr1->ts.deferred))\n+\t&& ((expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n+\t    || coarray)))\n     {\n       tmp = gfc_conv_descriptor_dtype (desc);\n       gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));"}, {"sha": "1bab5d5134a603ab56d25b88c410ce1442e8716a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -135,6 +135,9 @@ tree gfor_fndecl_caf_deregister;\n tree gfor_fndecl_caf_get;\n tree gfor_fndecl_caf_send;\n tree gfor_fndecl_caf_sendget;\n+tree gfor_fndecl_caf_get_by_ref;\n+tree gfor_fndecl_caf_send_by_ref;\n+tree gfor_fndecl_caf_sendget_by_ref;\n tree gfor_fndecl_caf_sync_all;\n tree gfor_fndecl_caf_sync_memory;\n tree gfor_fndecl_caf_sync_images;\n@@ -3560,12 +3563,12 @@ gfc_build_builtin_function_decls (void)\n \t2, integer_type_node, integer_type_node);\n \n       gfor_fndecl_caf_register = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_register\")), \"...WWW\", pvoid_type_node, 6,\n-\tsize_type_node, integer_type_node, ppvoid_type_node, pint_type,\n-\tpchar_type_node, integer_type_node);\n+\tget_identifier (PREFIX(\"caf_register\")), \"RRWWWWR\", void_type_node, 7,\n+\tsize_type_node, integer_type_node, ppvoid_type_node, pvoid_type_node,\n+\tpint_type, pchar_type_node, integer_type_node);\n \n       gfor_fndecl_caf_deregister = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_deregister\")), \".WWW\", void_type_node, 4,\n+\tget_identifier (PREFIX(\"caf_deregister\")), \"WWWR\", void_type_node, 4,\n \tppvoid_type_node, pint_type, pchar_type_node, integer_type_node);\n \n       gfor_fndecl_caf_get = gfc_build_library_function_decl_with_spec (\n@@ -3581,11 +3584,31 @@ gfc_build_builtin_function_decls (void)\n \tboolean_type_node, pint_type);\n \n       gfor_fndecl_caf_sendget = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_sendget\")), \".R.RRRR.RRR\", void_type_node,\n-\t13, pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n-\tpvoid_type_node, pvoid_type_node, size_type_node, integer_type_node,\n-\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node,\n-\tboolean_type_node);\n+\tget_identifier (PREFIX(\"caf_sendget\")), \".R.RRRR.RRRRRR\",\n+\tvoid_type_node,\t14, pvoid_type_node, size_type_node, integer_type_node,\n+\tpvoid_type_node, pvoid_type_node, pvoid_type_node, size_type_node,\n+\tinteger_type_node, pvoid_type_node, pvoid_type_node, integer_type_node,\n+\tinteger_type_node, boolean_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_get_by_ref = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_get_by_ref\")), \".RWRRRRRW\", void_type_node,\n+\t9, pvoid_type_node, integer_type_node, pvoid_type_node, pvoid_type_node,\n+\tinteger_type_node, integer_type_node, boolean_type_node,\n+\tboolean_type_node, pint_type);\n+\n+      gfor_fndecl_caf_send_by_ref = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_send_by_ref\")), \".RRRRRRRW\", void_type_node,\n+\t9, pvoid_type_node, integer_type_node, pvoid_type_node, pvoid_type_node,\n+\tinteger_type_node, integer_type_node, boolean_type_node,\n+\tboolean_type_node, pint_type);\n+\n+      gfor_fndecl_caf_sendget_by_ref\n+\t  = gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_sendget_by_ref\")), \".RR.RRRRRWW\",\n+\t    void_type_node, 11, pvoid_type_node, integer_type_node,\n+\t    pvoid_type_node, pvoid_type_node, integer_type_node,\n+\t    pvoid_type_node, integer_type_node, integer_type_node,\n+\t    boolean_type_node, pint_type, pint_type);\n \n       gfor_fndecl_caf_sync_all = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_sync_all\")), \".WW\", void_type_node,\n@@ -5002,9 +5025,11 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n static void\n generate_coarray_sym_init (gfc_symbol *sym)\n {\n-  tree tmp, size, decl, token;\n+  tree tmp, size, decl, token, desc;\n   bool is_lock_type, is_event_type;\n   int reg_type;\n+  gfc_se se;\n+  symbol_attribute attr;\n \n   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension\n       || sym->attr.use_assoc || !sym->attr.referenced\n@@ -5055,12 +5080,20 @@ generate_coarray_sym_init (gfc_symbol *sym)\n     reg_type = GFC_CAF_EVENT_STATIC;\n   else\n     reg_type = GFC_CAF_COARRAY_STATIC;\n-  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_register, 6, size,\n+\n+  gfc_init_se (&se, NULL);\n+  desc = gfc_conv_scalar_to_descriptor (&se, decl, attr);\n+  gfc_add_block_to_block (&caf_init_block, &se.pre);\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_register, 7, size,\n \t\t\t     build_int_cst (integer_type_node, reg_type),\n-\t\t\t     token, null_pointer_node, /* token, stat.  */\n+\t\t\t     token, gfc_build_addr_expr (pvoid_type_node, desc),\n+\t\t\t     null_pointer_node, /* stat.  */\n \t\t\t     null_pointer_node, /* errgmsg, errmsg_len.  */\n \t\t\t     build_int_cst (integer_type_node, 0));\n-  gfc_add_modify (&caf_init_block, decl, fold_convert (TREE_TYPE (decl), tmp));\n+  gfc_add_expr_to_block (&caf_init_block, tmp);\n+  gfc_add_modify (&caf_init_block, decl, fold_convert (TREE_TYPE (decl),\n+\t\t\t\t\t  gfc_conv_descriptor_data_get (desc)));\n \n   /* Handle \"static\" initializer.  */\n   if (sym->value)"}, {"sha": "9fcd6a169beceeb7046e2da593b83fbba8fc1d0e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 198, "deletions": 69, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -72,6 +72,13 @@ gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n   desc = gfc_create_var (type, \"desc\");\n   DECL_ARTIFICIAL (desc) = 1;\n \n+  if (CONSTANT_CLASS_P (scalar))\n+    {\n+      tree tmp;\n+      tmp = gfc_create_var (TREE_TYPE (scalar), \"scalar\");\n+      gfc_add_modify (&se->pre, tmp, scalar);\n+      scalar = tmp;\n+    }\n   if (!POINTER_TYPE_P (TREE_TYPE (scalar)))\n     scalar = gfc_build_addr_expr (NULL_TREE, scalar);\n   gfc_add_modify (&se->pre, gfc_conv_descriptor_dtype (desc),\n@@ -88,6 +95,56 @@ gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n }\n \n \n+/* Get the coarray token from the ultimate array or component ref.\n+   Returns a NULL_TREE, when the ref object is not allocatable or pointer.  */\n+\n+tree\n+gfc_get_ultimate_alloc_ptr_comps_caf_token (gfc_se *outerse, gfc_expr *expr)\n+{\n+  gfc_symbol *sym = expr->symtree->n.sym;\n+  bool is_coarray = sym->attr.codimension;\n+  gfc_expr *caf_expr = gfc_copy_expr (expr);\n+  gfc_ref *ref = caf_expr->ref, *last_caf_ref = NULL;\n+\n+  while (ref)\n+    {\n+      if (ref->type == REF_COMPONENT\n+\t  && (ref->u.c.component->attr.allocatable\n+\t      || ref->u.c.component->attr.pointer)\n+\t  && (is_coarray || ref->u.c.component->attr.codimension))\n+\t  last_caf_ref = ref;\n+      ref = ref->next;\n+    }\n+\n+  if (last_caf_ref == NULL)\n+    return NULL_TREE;\n+\n+  tree comp = last_caf_ref->u.c.component->caf_token, caf;\n+  gfc_se se;\n+  bool comp_ref = !last_caf_ref->u.c.component->attr.dimension;\n+  if (comp == NULL_TREE && comp_ref)\n+    return NULL_TREE;\n+  gfc_init_se (&se, outerse);\n+  gfc_free_ref_list (last_caf_ref->next);\n+  last_caf_ref->next = NULL;\n+  caf_expr->rank = comp_ref ? 0 : last_caf_ref->u.c.component->as->rank;\n+  se.want_pointer = comp_ref;\n+  gfc_conv_expr (&se, caf_expr);\n+  gfc_add_block_to_block (&outerse->pre, &se.pre);\n+\n+  if (TREE_CODE (se.expr) == COMPONENT_REF && comp_ref)\n+    se.expr = TREE_OPERAND (se.expr, 0);\n+  gfc_free_expr (caf_expr);\n+\n+  if (comp_ref)\n+    caf = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   TREE_TYPE (comp), se.expr, comp, NULL_TREE);\n+  else\n+    caf = gfc_conv_descriptor_token (se.expr);\n+  return gfc_build_addr_expr (NULL_TREE, caf);\n+}\n+\n+\n /* This is the seed for an eventual trans-class.c\n \n    The following parameters should not be used directly since they might\n@@ -1827,69 +1884,51 @@ gfc_get_tree_for_caf_expr (gfc_expr *expr)\n {\n   tree caf_decl;\n   bool found = false;\n-  gfc_ref *ref, *comp_ref = NULL;\n+  gfc_ref *ref;\n \n   gcc_assert (expr && expr->expr_type == EXPR_VARIABLE);\n \n   /* Not-implemented diagnostic.  */\n+  if (expr->symtree->n.sym->ts.type == BT_CLASS\n+      && UNLIMITED_POLY (expr->symtree->n.sym)\n+      && CLASS_DATA (expr->symtree->n.sym)->attr.codimension)\n+    gfc_error (\"Sorry, coindexed access to an unlimited polymorphic object at \"\n+\t       \"%L is not supported\", &expr->where);\n+\n   for (ref = expr->ref; ref; ref = ref->next)\n     if (ref->type == REF_COMPONENT)\n       {\n-        comp_ref = ref;\n-\tif ((ref->u.c.component->ts.type == BT_CLASS\n-\t     && !CLASS_DATA (ref->u.c.component)->attr.codimension\n-\t     && (CLASS_DATA (ref->u.c.component)->attr.pointer\n-\t\t || CLASS_DATA (ref->u.c.component)->attr.allocatable))\n-\t    || (ref->u.c.component->ts.type != BT_CLASS\n-\t\t&& !ref->u.c.component->attr.codimension\n-\t\t&& (ref->u.c.component->attr.pointer\n-\t\t    || ref->u.c.component->attr.allocatable)))\n-\t  gfc_error (\"Sorry, coindexed access to a pointer or allocatable \"\n-\t\t     \"component of the coindexed coarray at %L is not yet \"\n-\t\t     \"supported\", &expr->where);\n+\tif (ref->u.c.component->ts.type == BT_CLASS\n+\t    && UNLIMITED_POLY (ref->u.c.component)\n+\t    && CLASS_DATA (ref->u.c.component)->attr.codimension)\n+\t  gfc_error (\"Sorry, coindexed access to an unlimited polymorphic \"\n+\t\t     \"component at %L is not supported\", &expr->where);\n       }\n-  if ((!comp_ref\n-       && ((expr->symtree->n.sym->ts.type == BT_CLASS\n-\t    && CLASS_DATA (expr->symtree->n.sym)->attr.alloc_comp)\n-\t   || (expr->symtree->n.sym->ts.type == BT_DERIVED\n-\t       && expr->symtree->n.sym->ts.u.derived->attr.alloc_comp)))\n-      || (comp_ref\n-\t  && ((comp_ref->u.c.component->ts.type == BT_CLASS\n-\t       && CLASS_DATA (comp_ref->u.c.component)->attr.alloc_comp)\n-\t      || (comp_ref->u.c.component->ts.type == BT_DERIVED\n-\t\t  && comp_ref->u.c.component->ts.u.derived->attr.alloc_comp))))\n-    gfc_error (\"Sorry, coindexed coarray at %L with allocatable component is \"\n-\t       \"not yet supported\", &expr->where);\n-\n-  if (expr->rank)\n-    {\n-      /* Without the new array descriptor, access like \"caf[i]%a(:)%b\" is in\n-\t general not possible as the required stride multiplier might be not\n-\t a multiple of c_sizeof(b). In case of noncoindexed access, the\n-\t scalarizer often takes care of it - for coarrays, it always fails.  */\n-      for (ref = expr->ref; ref; ref = ref->next)\n-        if (ref->type == REF_COMPONENT\n-\t    && ((ref->u.c.component->ts.type == BT_CLASS\n-\t\t && CLASS_DATA (ref->u.c.component)->attr.codimension)\n-\t        || (ref->u.c.component->ts.type != BT_CLASS\n-\t\t    && ref->u.c.component->attr.codimension)))\n-\t  break;\n-      if (ref == NULL)\n-\tref = expr->ref;\n-      for ( ; ref; ref = ref->next)\n-\tif (ref->type == REF_ARRAY && ref->u.ar.dimen)\n-\t  break;\n-      for ( ; ref; ref = ref->next)\n-\tif (ref->type == REF_COMPONENT)\n-\t  gfc_error (\"Sorry, coindexed access at %L to a scalar component \"\n-\t\t     \"with an array partref is not yet supported\",\n-\t\t     &expr->where);\n-    }\n \n   caf_decl = expr->symtree->n.sym->backend_decl;\n   gcc_assert (caf_decl);\n   if (expr->symtree->n.sym->ts.type == BT_CLASS)\n-    caf_decl = gfc_class_data_get (caf_decl);\n+    {\n+      if (expr->ref && expr->ref->type == REF_ARRAY)\n+\t{\n+\t  caf_decl = gfc_class_data_get (caf_decl);\n+\t  if (CLASS_DATA (expr->symtree->n.sym)->attr.codimension)\n+\t    return caf_decl;\n+\t}\n+      for (ref = expr->ref; ref; ref = ref->next)\n+\t{\n+\t  if (ref->type == REF_COMPONENT\n+\t      && strcmp (ref->u.c.component->name, \"_data\") != 0)\n+\t    {\n+\t      caf_decl = gfc_class_data_get (caf_decl);\n+\t      if (CLASS_DATA (expr->symtree->n.sym)->attr.codimension)\n+\t\treturn caf_decl;\n+\t      break;\n+\t    }\n+\t  else if (ref->type == REF_ARRAY && ref->u.ar.dimen)\n+\t    break;\n+\t}\n+    }\n   if (expr->symtree->n.sym->attr.codimension)\n     return caf_decl;\n \n@@ -1907,7 +1946,14 @@ gfc_get_tree_for_caf_expr (gfc_expr *expr)\n \t\t\t\t    TREE_TYPE (comp->backend_decl), caf_decl,\n \t\t\t\t    comp->backend_decl, NULL_TREE);\n \tif (comp->ts.type == BT_CLASS)\n-\t  caf_decl = gfc_class_data_get (caf_decl);\n+\t  {\n+\t    caf_decl = gfc_class_data_get (caf_decl);\n+\t    if (CLASS_DATA (comp)->attr.codimension)\n+\t      {\n+\t\tfound = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n \tif (comp->attr.codimension)\n \t  {\n \t    found = true;\n@@ -1922,8 +1968,8 @@ gfc_get_tree_for_caf_expr (gfc_expr *expr)\n /* Obtain the Coarray token - and optionally also the offset.  */\n \n void\n-gfc_get_caf_token_offset (tree *token, tree *offset, tree caf_decl, tree se_expr,\n-\t\t\t  gfc_expr *expr)\n+gfc_get_caf_token_offset (gfc_se *se, tree *token, tree *offset, tree caf_decl,\n+\t\t\t  tree se_expr, gfc_expr *expr)\n {\n   tree tmp;\n \n@@ -1978,7 +2024,47 @@ gfc_get_caf_token_offset (tree *token, tree *offset, tree caf_decl, tree se_expr\n   *offset = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n \t\t\t     *offset, fold_convert (gfc_array_index_type, tmp));\n \n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n+  if (expr->symtree->n.sym->ts.type == BT_DERIVED\n+      && expr->symtree->n.sym->attr.codimension\n+      && expr->symtree->n.sym->ts.u.derived->attr.alloc_comp)\n+    {\n+      gfc_expr *base_expr = gfc_copy_expr (expr);\n+      gfc_ref *ref = base_expr->ref;\n+      gfc_se base_se;\n+\n+      // Iterate through the refs until the last one.\n+      while (ref->next)\n+\t  ref = ref->next;\n+\n+      if (ref->type == REF_ARRAY\n+\t  && ref->u.ar.type != AR_FULL)\n+\t{\n+\t  const int ranksum = ref->u.ar.dimen + ref->u.ar.codimen;\n+\t  int i;\n+\t  for (i = 0; i < ranksum; ++i)\n+\t    {\n+\t      ref->u.ar.start[i] = NULL;\n+\t      ref->u.ar.end[i] = NULL;\n+\t    }\n+\t  ref->u.ar.type = AR_FULL;\n+\t}\n+      gfc_init_se (&base_se, NULL);\n+      if (gfc_caf_attr (base_expr).dimension)\n+\t{\n+\t  gfc_conv_expr_descriptor (&base_se, base_expr);\n+\t  tmp = gfc_conv_descriptor_data_get (base_se.expr);\n+\t}\n+      else\n+\t{\n+\t  gfc_conv_expr (&base_se, base_expr);\n+\t  tmp = base_se.expr;\n+\t}\n+\n+      gfc_free_expr (base_expr);\n+      gfc_add_block_to_block (&se->pre, &base_se.pre);\n+      gfc_add_block_to_block (&se->post, &base_se.post);\n+    }\n+  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n     tmp = gfc_conv_descriptor_data_get (caf_decl);\n   else\n    {\n@@ -2009,6 +2095,12 @@ gfc_caf_get_image_index (stmtblock_t *block, gfc_expr *e, tree desc)\n       break;\n   gcc_assert (ref != NULL);\n \n+  if (ref->u.ar.dimen_type[ref->u.ar.dimen] == DIMEN_THIS_IMAGE)\n+    {\n+      return build_call_expr_loc (input_location, gfor_fndecl_caf_this_image, 1,\n+\t\t\t\t  integer_zero_node);\n+    }\n+\n   img_idx = integer_zero_node;\n   extent = integer_one_node;\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n@@ -4647,10 +4739,11 @@ expr_may_alias_variables (gfc_expr *e, bool array_may_alias)\n     {\n       gfc_symbol *proc_ifc = gfc_get_proc_ifc_for_expr (e);\n \n-      if ((proc_ifc->result->ts.type == BT_CLASS\n-\t   && proc_ifc->result->ts.u.derived->attr.is_class\n-\t   && CLASS_DATA (proc_ifc->result)->attr.class_pointer)\n-\t  || proc_ifc->result->attr.pointer)\n+      if (proc_ifc->result != NULL\n+\t  && ((proc_ifc->result->ts.type == BT_CLASS\n+\t       && proc_ifc->result->ts.u.derived->attr.is_class\n+\t       && CLASS_DATA (proc_ifc->result)->attr.class_pointer)\n+\t      || proc_ifc->result->attr.pointer))\n \treturn true;\n       else\n \treturn false;\n@@ -9064,7 +9157,25 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   size_in_bytes = fold_build2_loc (input_location, MAX_EXPR, size_type_node,\n \t\t\t\t   size_in_bytes, size_one_node);\n \n-  if (expr1->ts.type == BT_DERIVED && expr1->ts.u.derived->attr.alloc_comp)\n+  if (gfc_caf_attr (expr1).codimension && flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree caf_decl, token;\n+      gfc_se caf_se;\n+      symbol_attribute attr;\n+\n+      gfc_clear_attr (&attr);\n+      gfc_init_se (&caf_se, NULL);\n+\n+      caf_decl = gfc_get_tree_for_caf_expr (expr1);\n+      gfc_get_caf_token_offset (&caf_se, &token, NULL, caf_decl, NULL_TREE,\n+\t\t\t\tNULL);\n+      gfc_add_block_to_block (block, &caf_se.pre);\n+      gfc_allocate_allocatable (block, lse.expr, size_in_bytes,\n+\t\t\t\tgfc_build_addr_expr (NULL_TREE, token),\n+\t\t\t\tNULL_TREE, NULL_TREE, NULL_TREE, jump_label1,\n+\t\t\t\texpr1, 1);\n+    }\n+  else if (expr1->ts.type == BT_DERIVED && expr1->ts.u.derived->attr.alloc_comp)\n     {\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_CALLOC),\n@@ -9242,6 +9353,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   tree string_length;\n   int n;\n   bool maybe_workshare = false;\n+  symbol_attribute lhs_caf_attr, rhs_caf_attr;\n \n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n@@ -9262,6 +9374,9 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  || gfc_is_alloc_class_scalar_function (expr2)))\n     expr2->must_finalize = 1;\n \n+  lhs_caf_attr = gfc_caf_attr (expr1);\n+  rhs_caf_attr = gfc_caf_attr (expr2);\n+\n   if (lss != gfc_ss_terminator)\n     {\n       /* The assignment needs scalarization.  */\n@@ -9440,10 +9555,26 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \tgfc_add_block_to_block (&loop.post, &rse.post);\n     }\n \n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n-\t\t\t\t gfc_expr_is_variable (expr2) || scalar_to_array\n-\t\t\t\t || expr2->expr_type == EXPR_ARRAY,\n-\t\t\t\t !(l_is_temp || init_flag) && dealloc);\n+  if (flag_coarray == GFC_FCOARRAY_LIB\n+      && lhs_caf_attr.codimension && rhs_caf_attr.codimension\n+      && lhs_caf_attr.alloc_comp && rhs_caf_attr.alloc_comp)\n+    {\n+      gfc_code code;\n+      gfc_actual_arglist a1, a2;\n+      a1.expr = expr1;\n+      a1.next = &a2;\n+      a2.expr = expr2;\n+      a2.next = NULL;\n+      code.ext.actual = &a1;\n+      code.resolved_isym = gfc_intrinsic_subroutine_by_id (GFC_ISYM_CAF_SEND);\n+      tmp = gfc_conv_intrinsic_subroutine (&code);\n+    }\n+  else\n+    tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n+\t\t\t\t   gfc_expr_is_variable (expr2)\n+\t\t\t\t   || scalar_to_array\n+\t\t\t\t   || expr2->expr_type == EXPR_ARRAY,\n+\t\t\t\t   !(l_is_temp || init_flag) && dealloc);\n   gfc_add_expr_to_block (&body, tmp);\n \n   if (lss == gfc_ss_terminator)\n@@ -9490,11 +9621,9 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \n       /* F2003: Allocate or reallocate lhs of allocatable array.  */\n       if (flag_realloc_lhs\n-\t    && gfc_is_reallocatable_lhs (expr1)\n-\t    && !gfc_expr_attr (expr1).codimension\n-\t    && !gfc_is_coindexed (expr1)\n-\t    && expr2->rank\n-\t    && !is_runtime_conformable (expr1, expr2))\n+\t  && gfc_is_reallocatable_lhs (expr1)\n+\t  && expr2->rank\n+\t  && !is_runtime_conformable (expr1, expr2))\n \t{\n \t  realloc_lhs_warning (expr1->ts.type, true, &expr1->where);\n \t  ompws_flags &= ~OMPWS_SCALARIZER_WS;"}, {"sha": "d6453c50ccc541cefb61934433d66bd355eee5f5", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 743, "deletions": 46, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -982,7 +982,7 @@ conv_caf_vector_subscript_elem (stmtblock_t *block, int i, tree desc,\n \n   if (vector != NULL_TREE)\n     {\n-      /* Set dim.lower/upper/stride.  */\n+      /* Set vector and kind.  */\n       field = gfc_advance_chain (TYPE_FIELDS (type), 0);\n       tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t desc, field, NULL_TREE);\n@@ -994,7 +994,7 @@ conv_caf_vector_subscript_elem (stmtblock_t *block, int i, tree desc,\n     }\n   else\n     {\n-      /* Set vector and kind.  */\n+      /* Set dim.lower/upper/stride.  */\n       field = gfc_advance_chain (TYPE_FIELDS (type), 0);\n       tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t     desc, field, NULL_TREE);\n@@ -1094,16 +1094,481 @@ conv_caf_vector_subscript (stmtblock_t *block, tree desc, gfc_array_ref *ar)\n }\n \n \n+static tree\n+compute_component_offset (tree field, tree type)\n+{\n+  tree tmp;\n+  if (DECL_FIELD_BIT_OFFSET (field) != NULL_TREE\n+      && !integer_zerop (DECL_FIELD_BIT_OFFSET (field)))\n+    {\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, type,\n+\t\t\t DECL_FIELD_BIT_OFFSET (field),\n+\t\t\t bitsize_unit_node);\n+      return fold_build2 (PLUS_EXPR, type, DECL_FIELD_OFFSET (field), tmp);\n+    }\n+  else\n+    return DECL_FIELD_OFFSET (field);\n+}\n+\n+\n+static tree\n+conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n+{\n+  gfc_ref *ref = expr->ref;\n+  tree caf_ref = NULL_TREE, prev_caf_ref = NULL_TREE, reference_type, tmp, tmp2,\n+      field, last_type, inner_struct, mode, mode_rhs, dim_array, dim, dim_type,\n+      start, end, stride, vector, nvec;\n+  gfc_se se;\n+  bool ref_static_array = false;\n+  tree last_component_ref_tree = NULL_TREE;\n+  int i, last_type_n;\n+\n+  if (expr->symtree)\n+    {\n+      last_component_ref_tree = expr->symtree->n.sym->backend_decl;\n+      ref_static_array = !expr->symtree->n.sym->attr.allocatable;\n+    }\n+\n+  /* Prevent uninit-warning.  */\n+  reference_type = NULL_TREE;\n+  last_type = gfc_typenode_for_spec (&expr->symtree->n.sym->ts);\n+  last_type_n = expr->symtree->n.sym->ts.type;\n+  while (ref)\n+    {\n+      if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0\n+\t  && ref->u.ar.dimen == 0)\n+\t{\n+\t  /* Skip pure coindexes.  */\n+\t  ref = ref->next;\n+\t  continue;\n+\t}\n+      tmp = gfc_create_var (gfc_get_caf_reference_type (), \"caf_ref\");\n+      reference_type = TREE_TYPE (tmp);\n+\n+      if (caf_ref == NULL_TREE)\n+\tcaf_ref = tmp;\n+\n+      /* Construct the chain of refs.  */\n+      if (prev_caf_ref != NULL_TREE)\n+\t{\n+\t  field = gfc_advance_chain (TYPE_FIELDS (reference_type), 0);\n+\t  tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t  TREE_TYPE (field), prev_caf_ref, field,\n+\t\t\t\t  NULL_TREE);\n+\t  gfc_add_modify (block, tmp2, gfc_build_addr_expr (TREE_TYPE (field),\n+\t\t\t\t\t\t\t    tmp));\n+\t}\n+      prev_caf_ref = tmp;\n+\n+      switch (ref->type)\n+\t{\n+\tcase REF_COMPONENT:\n+\t  last_type = gfc_typenode_for_spec (&ref->u.c.component->ts);\n+\t  last_type_n = ref->u.c.component->ts.type;\n+\t  /* Set the type of the ref.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (reference_type), 1);\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), prev_caf_ref, field,\n+\t\t\t\t NULL_TREE);\n+\t  gfc_add_modify (block, tmp, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t     GFC_CAF_REF_COMPONENT));\n+\n+\t  /* Ref the c in union u.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (reference_type), 3);\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), prev_caf_ref, field,\n+\t\t\t\t NULL_TREE);\n+\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (field)), 0);\n+\t  inner_struct = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t       TREE_TYPE (field), tmp, field,\n+\t\t\t\t       NULL_TREE);\n+\n+\t  /* Set the offset.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (inner_struct)), 0);\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), inner_struct, field,\n+\t\t\t\t NULL_TREE);\n+\t  /* Computing the offset is somewhat harder.  The bit_offset has to be\n+\t     taken into account.  When the bit_offset in the field_decl is non-\n+\t     null, divide it by the bitsize_unit and add it to the regular\n+\t     offset.  */\n+\t  tmp2 = compute_component_offset (ref->u.c.component->backend_decl,\n+\t\t\t\t\t   TREE_TYPE (tmp));\n+\t  gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (tmp), tmp2));\n+\n+\t  /* Set caf_token_offset.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (inner_struct)), 1);\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), inner_struct, field,\n+\t\t\t\t NULL_TREE);\n+\t  if (ref->u.c.component->attr.allocatable\n+\t      && ref->u.c.component->attr.dimension)\n+\t    {\n+\t      tree arr_desc_token_offset;\n+\t      /* Get the token from the descriptor.  */\n+\t      arr_desc_token_offset = gfc_advance_chain (\n+\t\t    TYPE_FIELDS (TREE_TYPE (ref->u.c.component->backend_decl)),\n+\t\t    4 /* CAF_TOKEN_FIELD  */);\n+\t      arr_desc_token_offset\n+\t\t  = compute_component_offset (arr_desc_token_offset,\n+\t\t\t\t\t      TREE_TYPE (tmp));\n+\t      tmp2 = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t      TREE_TYPE (tmp2), tmp2,\n+\t\t\t\t      arr_desc_token_offset);\n+\t    }\n+\t  else if (ref->u.c.component->caf_token)\n+\t    tmp2 = compute_component_offset (ref->u.c.component->caf_token,\n+\t\t\t\t\t     TREE_TYPE (tmp));\n+\t  else\n+\t    tmp2 = integer_zero_node;\n+\t  gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (tmp), tmp2));\n+\n+\t  /* Remember whether this ref was to a non-allocatable/non-pointer\n+\t     component so the next array ref can be tailored correctly.  */\n+\t  ref_static_array = !ref->u.c.component->attr.allocatable;\n+\t  last_component_ref_tree = ref_static_array\n+\t      ? ref->u.c.component->backend_decl : NULL_TREE;\n+\t  break;\n+\tcase REF_ARRAY:\n+\t  if (ref_static_array && ref->u.ar.as->type == AS_DEFERRED)\n+\t    ref_static_array = false;\n+\t  /* Set the type of the ref.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (reference_type), 1);\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), prev_caf_ref, field,\n+\t\t\t\t NULL_TREE);\n+\t  gfc_add_modify (block, tmp, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t     ref_static_array\n+\t\t\t\t\t\t     ? GFC_CAF_REF_STATIC_ARRAY\n+\t\t\t\t\t\t     : GFC_CAF_REF_ARRAY));\n+\n+\t  /* Ref the a in union u.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (reference_type), 3);\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), prev_caf_ref, field,\n+\t\t\t\t NULL_TREE);\n+\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (field)), 1);\n+\t  inner_struct = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t       TREE_TYPE (field), tmp, field,\n+\t\t\t\t       NULL_TREE);\n+\n+\t  /* Set the static_array_type in a for static arrays.  */\n+\t  if (ref_static_array)\n+\t    {\n+\t      field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (inner_struct)),\n+\t\t\t\t\t 1);\n+\t      tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t     TREE_TYPE (field), inner_struct, field,\n+\t\t\t\t     NULL_TREE);\n+\t      gfc_add_modify (block, tmp, build_int_cst (TREE_TYPE (tmp),\n+\t\t\t\t\t\t\t last_type_n));\n+\t    }\n+\t  /* Ref the mode in the inner_struct.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (inner_struct)), 0);\n+\t  mode = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t  TREE_TYPE (field), inner_struct, field,\n+\t\t\t\t  NULL_TREE);\n+\t  /* Ref the dim in the inner_struct.  */\n+\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (inner_struct)), 2);\n+\t  dim_array = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t       TREE_TYPE (field), inner_struct, field,\n+\t\t\t\t       NULL_TREE);\n+\t  for (i = 0; i < ref->u.ar.dimen; ++i)\n+\t    {\n+\t      /* Ref dim i.  */\n+\t      dim = gfc_build_array_ref (dim_array, gfc_rank_cst[i], NULL_TREE);\n+\t      dim_type = TREE_TYPE (dim);\n+\t      mode_rhs = start = end = stride = NULL_TREE;\n+\t      switch (ref->u.ar.dimen_type[i])\n+\t\t{\n+\t\tcase DIMEN_RANGE:\n+\t\t  if (ref->u.ar.end[i])\n+\t\t    {\n+\t\t      gfc_init_se (&se, NULL);\n+\t\t      gfc_conv_expr (&se, ref->u.ar.end[i]);\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      if (ref_static_array)\n+\t\t\t{\n+\t\t\t  /* Make the index zero-based, when reffing a static\n+\t\t\t     array.  */\n+\t\t\t  end = se.expr;\n+\t\t\t  gfc_init_se (&se, NULL);\n+\t\t\t  gfc_conv_expr (&se, ref->u.ar.as->lower[i]);\n+\t\t\t  gfc_add_block_to_block (block, &se.pre);\n+\t\t\t  se.expr = fold_build2 (MINUS_EXPR,\n+\t\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t\t end, fold_convert (\n+\t\t\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t\t\t   se.expr));\n+\t\t\t}\n+\t\t      end = gfc_evaluate_now (fold_convert (\n+\t\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\t\tse.expr),\n+\t\t\t\t\t      block);\n+\t\t    }\n+\t\t  else if (ref_static_array)\n+\t\t    end = fold_build2 (MINUS_EXPR,\n+\t\t\t\t       gfc_array_index_type,\n+\t\t\t\t       gfc_conv_array_ubound (\n+\t\t\t\t\t last_component_ref_tree, i),\n+\t\t\t\t       gfc_conv_array_lbound (\n+\t\t\t\t\t last_component_ref_tree, i));\n+\t\t  else\n+\t\t    {\n+\t\t      end = NULL_TREE;\n+\t\t      mode_rhs = build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t\tGFC_CAF_ARR_REF_OPEN_END);\n+\t\t    }\n+\t\t  if (ref->u.ar.stride[i])\n+\t\t    {\n+\t\t      gfc_init_se (&se, NULL);\n+\t\t      gfc_conv_expr (&se, ref->u.ar.stride[i]);\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      stride = gfc_evaluate_now (fold_convert (\n+\t\t\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t\t\t   se.expr),\n+\t\t\t\t\t\t block);\n+\t\t      if (ref_static_array)\n+\t\t\t{\n+\t\t\t  /* Make the index zero-based, when reffing a static\n+\t\t\t     array.  */\n+\t\t\t  stride = fold_build2 (MULT_EXPR,\n+\t\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\t\tgfc_conv_array_stride (\n+\t\t\t\t\t\t  last_component_ref_tree,\n+\t\t\t\t\t\t  i),\n+\t\t\t\t\t\tstride);\n+\t\t\t  gcc_assert (end != NULL_TREE);\n+\t\t\t  /* Multiply with the product of array's stride and\n+\t\t\t     the step of the ref to a virtual upper bound.\n+\t\t\t     We can not compute the actual upper bound here or\n+\t\t\t     the caflib would compute the extend\n+\t\t\t     incorrectly.  */\n+\t\t\t  end = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t\t     end, gfc_conv_array_stride (\n+\t\t\t\t\t       last_component_ref_tree,\n+\t\t\t\t\t       i));\n+\t\t\t  end = gfc_evaluate_now (end, block);\n+\t\t\t  stride = gfc_evaluate_now (stride, block);\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (ref_static_array)\n+\t\t    {\n+\t\t      stride = gfc_conv_array_stride (last_component_ref_tree,\n+\t\t\t\t\t\t      i);\n+\t\t      end = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t\t end, stride);\n+\t\t      end = gfc_evaluate_now (end, block);\n+\t\t    }\n+\t\t  else\n+\t\t    /* Always set a ref stride of one to make caflib's\n+\t\t       handling easier.  */\n+\t\t    stride = gfc_index_one_node;\n+\n+\t\t  /* Intentionally fall through.  */\n+\t\tcase DIMEN_ELEMENT:\n+\t\t  if (ref->u.ar.start[i])\n+\t\t    {\n+\t\t      gfc_init_se (&se, NULL);\n+\t\t      gfc_conv_expr (&se, ref->u.ar.start[i]);\n+\t\t      gfc_add_block_to_block (block, &se.pre);\n+\t\t      if (ref_static_array)\n+\t\t\t{\n+\t\t\t  /* Make the index zero-based, when reffing a static\n+\t\t\t     array.  */\n+\t\t\t  start = fold_convert (gfc_array_index_type, se.expr);\n+\t\t\t  gfc_init_se (&se, NULL);\n+\t\t\t  gfc_conv_expr (&se, ref->u.ar.as->lower[i]);\n+\t\t\t  gfc_add_block_to_block (block, &se.pre);\n+\t\t\t  se.expr = fold_build2 (MINUS_EXPR,\n+\t\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t\t start, fold_convert (\n+\t\t\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t\t\t   se.expr));\n+\t\t\t  /* Multiply with the stride.  */\n+\t\t\t  se.expr = fold_build2 (MULT_EXPR,\n+\t\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t\t se.expr,\n+\t\t\t\t\t\t gfc_conv_array_stride (\n+\t\t\t\t\t\t   last_component_ref_tree,\n+\t\t\t\t\t\t   i));\n+\t\t\t}\n+\t\t      start = gfc_evaluate_now (fold_convert (\n+\t\t\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t\t\t  se.expr),\n+\t\t\t\t\t\tblock);\n+\t\t      if (mode_rhs == NULL_TREE)\n+\t\t\tmode_rhs = build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t\t  ref->u.ar.dimen_type[i]\n+\t\t\t\t\t\t  == DIMEN_ELEMENT\n+\t\t\t\t\t\t  ? GFC_CAF_ARR_REF_SINGLE\n+\t\t\t\t\t\t  : GFC_CAF_ARR_REF_RANGE);\n+\t\t    }\n+\t\t  else if (ref_static_array)\n+\t\t    {\n+\t\t      start = integer_zero_node;\n+\t\t      mode_rhs = build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t\tref->u.ar.start[i] == NULL\n+\t\t\t\t\t\t? GFC_CAF_ARR_REF_FULL\n+\t\t\t\t\t\t: GFC_CAF_ARR_REF_RANGE);\n+\t\t    }\n+\t\t  else if (end == NULL_TREE)\n+\t\t    mode_rhs = build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t      GFC_CAF_ARR_REF_FULL);\n+\t\t  else\n+\t\t    mode_rhs = build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t      GFC_CAF_ARR_REF_OPEN_START);\n+\n+\t\t  /* Ref the s in dim.  */\n+\t\t  field = gfc_advance_chain (TYPE_FIELDS (dim_type), 0);\n+\t\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t TREE_TYPE (field), dim, field,\n+\t\t\t\t\t NULL_TREE);\n+\n+\t\t  /* Set start in s.  */\n+\t\t  if (start != NULL_TREE)\n+\t\t    {\n+\t\t      field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)),\n+\t\t\t\t\t\t 0);\n+\t\t      tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t      TREE_TYPE (field), tmp, field,\n+\t\t\t\t\t      NULL_TREE);\n+\t\t      gfc_add_modify (block, tmp2,\n+\t\t\t\t      fold_convert (TREE_TYPE (tmp2), start));\n+\t\t    }\n+\n+\t\t  /* Set end in s.  */\n+\t\t  if (end != NULL_TREE)\n+\t\t    {\n+\t\t      field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)),\n+\t\t\t\t\t\t 1);\n+\t\t      tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t      TREE_TYPE (field), tmp, field,\n+\t\t\t\t\t      NULL_TREE);\n+\t\t      gfc_add_modify (block, tmp2,\n+\t\t\t\t      fold_convert (TREE_TYPE (tmp2), end));\n+\t\t    }\n+\n+\t\t  /* Set end in s.  */\n+\t\t  if (stride != NULL_TREE)\n+\t\t    {\n+\t\t      field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)),\n+\t\t\t\t\t\t 2);\n+\t\t      tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t      TREE_TYPE (field), tmp, field,\n+\t\t\t\t\t      NULL_TREE);\n+\t\t      gfc_add_modify (block, tmp2,\n+\t\t\t\t      fold_convert (TREE_TYPE (tmp2), stride));\n+\t\t    }\n+\t\t  break;\n+\t\tcase DIMEN_VECTOR:\n+\t\t  /* TODO: In case of static array.  */\n+\t\t  gcc_assert (!ref_static_array);\n+\t\t  mode_rhs = build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t    GFC_CAF_ARR_REF_VECTOR);\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  se.descriptor_only = 1;\n+\t\t  gfc_conv_expr_descriptor (&se, ref->u.ar.start[i]);\n+\t\t  gfc_add_block_to_block (block, &se.pre);\n+\t\t  vector = se.expr;\n+\t\t  tmp = gfc_conv_descriptor_lbound_get (vector,\n+\t\t\t\t\t\t\tgfc_rank_cst[0]);\n+\t\t  tmp2 = gfc_conv_descriptor_ubound_get (vector,\n+\t\t\t\t\t\t\t gfc_rank_cst[0]);\n+\t\t  nvec = gfc_conv_array_extent_dim (tmp, tmp2, NULL);\n+\t\t  tmp = gfc_conv_descriptor_stride_get (vector,\n+\t\t\t\t\t\t\tgfc_rank_cst[0]);\n+\t\t  nvec = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t\t\t  TREE_TYPE (nvec), nvec, tmp);\n+\t\t  vector = gfc_conv_descriptor_data_get (vector);\n+\n+\t\t  /* Ref the v in dim.  */\n+\t\t  field = gfc_advance_chain (TYPE_FIELDS (dim_type), 1);\n+\t\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t TREE_TYPE (field), dim, field,\n+\t\t\t\t\t NULL_TREE);\n+\n+\t\t  /* Set vector in v.  */\n+\t\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)), 0);\n+\t\t  tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t  TREE_TYPE (field), tmp, field,\n+\t\t\t\t\t  NULL_TREE);\n+\t\t  gfc_add_modify (block, tmp2, fold_convert (TREE_TYPE (tmp2),\n+\t\t\t\t\t\t\t     vector));\n+\n+\t\t  /* Set nvec in v.  */\n+\t\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)), 1);\n+\t\t  tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t  TREE_TYPE (field), tmp, field,\n+\t\t\t\t\t  NULL_TREE);\n+\t\t  gfc_add_modify (block, tmp2, fold_convert (TREE_TYPE (tmp2),\n+\t\t\t\t\t\t\t     nvec));\n+\n+\t\t  /* Set kind in v.  */\n+\t\t  field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)), 2);\n+\t\t  tmp2 = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t  TREE_TYPE (field), tmp, field,\n+\t\t\t\t\t  NULL_TREE);\n+\t\t  gfc_add_modify (block, tmp2, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t  ref->u.ar.start[i]->ts.kind));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      /* Set the mode for dim i.  */\n+\t      tmp = gfc_build_array_ref (mode, gfc_rank_cst[i], NULL_TREE);\n+\t      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t\tmode_rhs));\n+\t    }\n+\n+\t  /* Set the mode for dim i+1 to GFC_ARR_REF_NONE.  */\n+\t  if (i < GFC_MAX_DIMENSIONS)\n+\t    {\n+\t      tmp = gfc_build_array_ref (mode, gfc_rank_cst[i], NULL_TREE);\n+\t      gfc_add_modify (block, tmp,\n+\t\t\t      build_int_cst (unsigned_char_type_node,\n+\t\t\t\t\t     GFC_CAF_ARR_REF_NONE));\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* Set the size of the current type.  */\n+      field = gfc_advance_chain (TYPE_FIELDS (reference_type), 2);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     prev_caf_ref, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field),\n+\t\t\t\t\t\tTYPE_SIZE_UNIT (last_type)));\n+\n+      ref = ref->next;\n+    }\n+\n+  if (prev_caf_ref != NULL_TREE)\n+    {\n+      field = gfc_advance_chain (TYPE_FIELDS (reference_type), 0);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     prev_caf_ref, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field),\n+\t\t\t\t\t\t  null_pointer_node));\n+    }\n+  return caf_ref != NULL_TREE ? gfc_build_addr_expr (NULL_TREE, caf_ref)\n+\t\t\t      : NULL_TREE;\n+}\n+\n /* Get data from a remote coarray.  */\n \n static void\n gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n-\t\t\t    tree may_require_tmp)\n+\t\t\t    tree may_require_tmp, bool may_realloc,\n+\t\t\t    symbol_attribute *caf_attr)\n {\n   gfc_expr *array_expr, *tmp_stat;\n   gfc_se argse;\n   tree caf_decl, token, offset, image_index, tmp;\n   tree res_var, dst_var, type, kind, vec, stat;\n+  tree caf_reference;\n+  symbol_attribute caf_attr_store;\n \n   gcc_assert (flag_coarray == GFC_FCOARRAY_LIB);\n \n@@ -1118,6 +1583,12 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n   array_expr = (lhs == NULL_TREE) ? expr->value.function.actual->expr : expr;\n   type = gfc_typenode_for_spec (&array_expr->ts);\n \n+  if (caf_attr == NULL)\n+    {\n+      caf_attr_store = gfc_caf_attr (array_expr);\n+      caf_attr = &caf_attr_store;\n+    }\n+\n   res_var = lhs;\n   dst_var = lhs;\n \n@@ -1136,6 +1607,108 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n   else\n     stat = null_pointer_node;\n \n+  /* Always use the new get_by_ref ().  When no allocatable components are\n+     present and the lhs does not reallocation then the \"old\" get () might\n+     suffice.  */\n+  if (true) //caf_attr->alloc_comp && !may_realloc)\n+    {\n+      /* Get using caf_get_by_ref.  */\n+      caf_reference = conv_expr_ref_to_caf_ref (&se->pre, array_expr);\n+\n+      if (caf_reference != NULL_TREE)\n+\t{\n+\t  if (lhs == NULL_TREE)\n+\t    {\n+\t      if (array_expr->ts.type == BT_CHARACTER)\n+\t\tgfc_init_se (&argse, NULL);\n+\t      if (array_expr->rank == 0)\n+\t\t{\n+\t\t  symbol_attribute attr;\n+\t\t  gfc_clear_attr (&attr);\n+\t\t  if (array_expr->ts.type == BT_CHARACTER)\n+\t\t    {\n+\t\t      res_var = gfc_conv_string_tmp (se,\n+\t\t\t\t\t\t     build_pointer_type (type),\n+\t\t\t\t\t     array_expr->ts.u.cl->backend_decl);\n+\t\t      argse.string_length = array_expr->ts.u.cl->backend_decl;\n+\t\t    }\n+\t\t  else\n+\t\t    res_var = gfc_create_var (type, \"caf_res\");\n+\t\t  dst_var = gfc_conv_scalar_to_descriptor (se, res_var, attr);\n+\t\t  dst_var = gfc_build_addr_expr (NULL_TREE, dst_var);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Create temporary.  */\n+\t\t  if (array_expr->ts.type == BT_CHARACTER)\n+\t\t    gfc_conv_expr_descriptor (&argse, array_expr);\n+\t\t  may_realloc = gfc_trans_create_temp_array (&se->pre,\n+\t\t\t\t\t\t\t     &se->post,\n+\t\t\t\t\t\t\t     se->ss, type,\n+\t\t\t\t\t\t\t     NULL_TREE, false,\n+\t\t\t\t\t\t\t     false, false,\n+\t\t\t\t\t\t\t     &array_expr->where)\n+\t\t      == NULL_TREE;\n+\t\t  res_var = se->ss->info->data.array.descriptor;\n+\t\t  dst_var = gfc_build_addr_expr (NULL_TREE, res_var);\n+\t\t  if (may_realloc)\n+\t\t    {\n+\t\t      tmp = gfc_conv_descriptor_data_get (res_var);\n+\t\t      tmp = gfc_deallocate_with_status (tmp, NULL_TREE,\n+\t\t\t\t\t\t\tNULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t\tNULL_TREE, true,\n+\t\t\t\t\t\t\tNULL, false);\n+\t\t      gfc_add_expr_to_block (&se->post, tmp);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  kind = build_int_cst (integer_type_node, expr->ts.kind);\n+\t  if (lhs_kind == NULL_TREE)\n+\t    lhs_kind = kind;\n+\n+\t  caf_decl = gfc_get_tree_for_caf_expr (array_expr);\n+\t  if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+\t    caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+\t  image_index = gfc_caf_get_image_index (&se->pre, array_expr,\n+\t\t\t\t\t\t caf_decl);\n+\t  gfc_get_caf_token_offset (se, &token, NULL, caf_decl, NULL,\n+\t\t\t\t    array_expr);\n+\n+\t  /* No overlap possible as we have generated a temporary.  */\n+\t  if (lhs == NULL_TREE)\n+\t    may_require_tmp = boolean_false_node;\n+\n+\t  /* It guarantees memory consistency within the same segment.  */\n+\t  tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\");\n+\t  tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\t    gfc_build_string_const (1, \"\"), NULL_TREE,\n+\t\t\t    NULL_TREE, tree_cons (NULL_TREE, tmp, NULL_TREE),\n+\t\t\t    NULL_TREE);\n+\t  ASM_VOLATILE_P (tmp) = 1;\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+\t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get_by_ref,\n+\t\t\t\t     9, token, image_index, dst_var,\n+\t\t\t\t     caf_reference, lhs_kind, kind,\n+\t\t\t\t     may_require_tmp,\n+\t\t\t\t     may_realloc ? boolean_true_node :\n+\t\t\t\t\t\t   boolean_false_node,\n+\t\t\t\t     stat);\n+\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+\t  if (se->ss)\n+\t    gfc_advance_se_ss_chain (se);\n+\n+\t  se->expr = res_var;\n+\t  if (array_expr->ts.type == BT_CHARACTER)\n+\t    se->string_length = argse.string_length;\n+\n+\t  return;\n+\t}\n+    }\n+\n   gfc_init_se (&argse, NULL);\n   if (array_expr->rank == 0)\n     {\n@@ -1176,9 +1749,9 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \t}\n       gfc_conv_expr_descriptor (&argse, array_expr);\n       /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n-         has the wrong type if component references are done.  */\n+\t has the wrong type if component references are done.  */\n       gfc_add_modify (&argse.pre, gfc_conv_descriptor_dtype (argse.expr),\n-                      gfc_get_dtype_rank_type (has_vector ? ar2.dimen\n+\t\t      gfc_get_dtype_rank_type (has_vector ? ar2.dimen\n \t\t\t\t\t\t\t  : array_expr->rank,\n \t\t\t\t\t       type));\n       if (has_vector)\n@@ -1193,10 +1766,10 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \t  for (int n = 0; n < se->ss->loop->dimen; n++)\n \t    if (se->loop->to[n] == NULL_TREE)\n \t      {\n-\t\tse->loop->from[n] =\n-\t\t\tgfc_conv_descriptor_lbound_get (argse.expr, gfc_rank_cst[n]);\n-\t\tse->loop->to[n] =\n-\t\t\tgfc_conv_descriptor_ubound_get (argse.expr, gfc_rank_cst[n]);\n+\t\tse->loop->from[n] = gfc_conv_descriptor_lbound_get (argse.expr,\n+\t\t\t\t\t\t\t       gfc_rank_cst[n]);\n+\t\tse->loop->to[n] = gfc_conv_descriptor_ubound_get (argse.expr,\n+\t\t\t\t\t\t\t       gfc_rank_cst[n]);\n \t      }\n \t  gfc_trans_create_temp_array (&argse.pre, &argse.post, se->ss, type,\n \t\t\t\t       NULL_TREE, false, true, false,\n@@ -1218,14 +1791,15 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n   if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n     caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n   image_index = gfc_caf_get_image_index (&se->pre, array_expr, caf_decl);\n-  gfc_get_caf_token_offset (&token, &offset, caf_decl, argse.expr, array_expr);\n+  gfc_get_caf_token_offset (se, &token, &offset, caf_decl, argse.expr,\n+\t\t\t    array_expr);\n \n   /* No overlap possible as we have generated a temporary.  */\n   if (lhs == NULL_TREE)\n     may_require_tmp = boolean_false_node;\n \n-  /* It guarantees memory consistency within the same segment */\n-  tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\"),\n+  /* It guarantees memory consistency within the same segment.  */\n+  tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\");\n   tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n \t\t    gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n \t\t    tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n@@ -1235,6 +1809,7 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 10,\n \t\t\t     token, offset, image_index, argse.expr, vec,\n \t\t\t     dst_var, kind, lhs_kind, may_require_tmp, stat);\n+\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   if (se->ss)\n@@ -1246,17 +1821,18 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n }\n \n \n-/* Send data to a remove coarray.  */\n+/* Send data to a remote coarray.  */\n \n static tree\n conv_caf_send (gfc_code *code) {\n   gfc_expr *lhs_expr, *rhs_expr, *tmp_stat;\n   gfc_se lhs_se, rhs_se;\n   stmtblock_t block;\n   tree caf_decl, token, offset, image_index, tmp, lhs_kind, rhs_kind;\n-  tree may_require_tmp, stat;\n+  tree may_require_tmp, src_stat, dst_stat;\n   tree lhs_type = NULL_TREE;\n   tree vec = null_pointer_node, rhs_vec = null_pointer_node;\n+  symbol_attribute lhs_caf_attr, rhs_caf_attr;\n \n   gcc_assert (flag_coarray == GFC_FCOARRAY_LIB);\n \n@@ -1266,7 +1842,9 @@ conv_caf_send (gfc_code *code) {\n \t\t    ? boolean_false_node : boolean_true_node;\n   gfc_init_block (&block);\n \n-  stat = null_pointer_node;\n+  lhs_caf_attr = gfc_caf_attr (lhs_expr);\n+  rhs_caf_attr = gfc_caf_attr (rhs_expr);\n+  src_stat = dst_stat = null_pointer_node;\n \n   /* LHS.  */\n   gfc_init_se (&lhs_se, NULL);\n@@ -1279,6 +1857,21 @@ conv_caf_send (gfc_code *code) {\n       lhs_se.expr = gfc_conv_scalar_to_descriptor (&lhs_se, lhs_se.expr, attr);\n       lhs_se.expr = gfc_build_addr_expr (NULL_TREE, lhs_se.expr);\n     }\n+  else if (lhs_caf_attr.alloc_comp && lhs_caf_attr.codimension)\n+    {\n+      lhs_se.want_pointer = 1;\n+      gfc_conv_expr_descriptor (&lhs_se, lhs_expr);\n+      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n+\t has the wrong type if component references are done.  */\n+      lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);\n+      tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);\n+      gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),\n+\t\t      gfc_get_dtype_rank_type (\n+\t\t\tgfc_has_vector_subscript (lhs_expr)\n+\t\t\t? gfc_find_array_ref (lhs_expr)->dimen\n+\t\t\t: lhs_expr->rank,\n+\t\t      lhs_type));\n+    }\n   else\n     {\n       /* If has_vector, pass descriptor for whole array and the\n@@ -1313,29 +1906,62 @@ conv_caf_send (gfc_code *code) {\n     }\n \n   lhs_kind = build_int_cst (integer_type_node, lhs_expr->ts.kind);\n-  gfc_add_block_to_block (&block, &lhs_se.pre);\n \n   /* Special case: RHS is a coarray but LHS is not; this code path avoids a\n      temporary and a loop.  */\n-  if (!gfc_is_coindexed (lhs_expr))\n+  if (!gfc_is_coindexed (lhs_expr) && !lhs_caf_attr.codimension)\n     {\n+      bool lhs_may_realloc = lhs_expr->rank > 0 && lhs_caf_attr.allocatable;\n       gcc_assert (gfc_is_coindexed (rhs_expr));\n       gfc_init_se (&rhs_se, NULL);\n+      if (lhs_expr->rank == 0 && gfc_expr_attr (lhs_expr).allocatable)\n+\t{\n+\t  gfc_se scal_se;\n+\t  gfc_init_se (&scal_se, NULL);\n+\t  scal_se.want_pointer = 1;\n+\t  gfc_conv_expr (&scal_se, lhs_expr);\n+\t  /* Ensure scalar on lhs is allocated.  */\n+\t  gfc_add_block_to_block (&block, &scal_se.pre);\n+\n+\t  gfc_allocate_using_malloc (&scal_se.pre, scal_se.expr,\n+\t\t\t\t    TYPE_SIZE_UNIT (\n+\t\t\t\t       gfc_typenode_for_spec (&lhs_expr->ts)),\n+\t\t\t\t    NULL_TREE);\n+\t  tmp = fold_build2 (EQ_EXPR, boolean_type_node, scal_se.expr,\n+\t\t\t     null_pointer_node);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t tmp, gfc_finish_block (&scal_se.pre),\n+\t\t\t\t build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      else\n+\tlhs_may_realloc = lhs_may_realloc\n+\t    && gfc_full_array_ref_p (lhs_expr->ref, NULL);\n+      gfc_add_block_to_block (&block, &lhs_se.pre);\n       gfc_conv_intrinsic_caf_get (&rhs_se, rhs_expr, lhs_se.expr, lhs_kind,\n-\t\t\t\t  may_require_tmp);\n+\t\t\t\t  may_require_tmp, lhs_may_realloc,\n+\t\t\t\t  &lhs_caf_attr);\n       gfc_add_block_to_block (&block, &rhs_se.pre);\n       gfc_add_block_to_block (&block, &rhs_se.post);\n       gfc_add_block_to_block (&block, &lhs_se.post);\n       return gfc_finish_block (&block);\n     }\n \n-  /* Obtain token, offset and image index for the LHS.  */\n+  gfc_add_block_to_block (&block, &lhs_se.pre);\n \n+  /* Obtain token, offset and image index for the LHS.  */\n   caf_decl = gfc_get_tree_for_caf_expr (lhs_expr);\n   if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n     caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n   image_index = gfc_caf_get_image_index (&block, lhs_expr, caf_decl);\n-  gfc_get_caf_token_offset (&token, &offset, caf_decl, lhs_se.expr, lhs_expr);\n+  tmp = lhs_se.expr;\n+  if (lhs_caf_attr.alloc_comp)\n+    gfc_get_caf_token_offset (&lhs_se, &token, NULL, caf_decl, NULL_TREE,\n+\t\t\t      NULL);\n+  else\n+    gfc_get_caf_token_offset (&lhs_se, &token, &offset, caf_decl, tmp,\n+\t\t\t      lhs_expr);\n+  lhs_se.expr = tmp;\n \n   /* RHS.  */\n   gfc_init_se (&rhs_se, NULL);\n@@ -1347,11 +1973,25 @@ conv_caf_send (gfc_code *code) {\n       symbol_attribute attr;\n       gfc_clear_attr (&attr);\n       gfc_conv_expr (&rhs_se, rhs_expr);\n-      if (!gfc_is_coindexed (rhs_expr) && rhs_expr->ts.type != BT_CHARACTER)\n-\t rhs_se.expr = fold_convert (lhs_type , rhs_se.expr);\n       rhs_se.expr = gfc_conv_scalar_to_descriptor (&rhs_se, rhs_se.expr, attr);\n       rhs_se.expr = gfc_build_addr_expr (NULL_TREE, rhs_se.expr);\n     }\n+  else if (rhs_caf_attr.alloc_comp && rhs_caf_attr.codimension)\n+    {\n+      tree tmp2;\n+      rhs_se.want_pointer = 1;\n+      gfc_conv_expr_descriptor (&rhs_se, rhs_expr);\n+      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n+\t has the wrong type if component references are done.  */\n+      tmp2 = gfc_typenode_for_spec (&rhs_expr->ts);\n+      tmp = build_fold_indirect_ref_loc (input_location, rhs_se.expr);\n+      gfc_add_modify (&rhs_se.pre, gfc_conv_descriptor_dtype (tmp),\n+\t\t      gfc_get_dtype_rank_type (\n+\t\t\tgfc_has_vector_subscript (rhs_expr)\n+\t\t\t? gfc_find_array_ref (rhs_expr)->dimen\n+\t\t\t: rhs_expr->rank,\n+\t\t      tmp2));\n+    }\n   else\n     {\n       /* If has_vector, pass descriptor for whole array and the\n@@ -1397,24 +2037,37 @@ conv_caf_send (gfc_code *code) {\n       gfc_se stat_se;\n       gfc_init_se (&stat_se, NULL);\n       gfc_conv_expr_reference (&stat_se, tmp_stat);\n-      stat = stat_se.expr;\n+      dst_stat = stat_se.expr;\n       gfc_add_block_to_block (&block, &stat_se.pre);\n       gfc_add_block_to_block (&block, &stat_se.post);\n     }\n-  else\n-    stat = null_pointer_node;\n \n-  if (!gfc_is_coindexed (rhs_expr))\n-    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 10, token,\n-\t\t\t       offset, image_index, lhs_se.expr, vec,\n-\t\t\t       rhs_se.expr, lhs_kind, rhs_kind, may_require_tmp,\n-\t\t\t       stat);\n+  if (!gfc_is_coindexed (rhs_expr) && !rhs_caf_attr.codimension)\n+    {\n+      if (lhs_caf_attr.alloc_comp)\n+\t{\n+\t  tree reference, dst_realloc;\n+\t  reference = conv_expr_ref_to_caf_ref (&block, lhs_expr);\n+\t  dst_realloc = lhs_caf_attr.allocatable ? boolean_true_node\n+\t\t\t\t\t     : boolean_false_node;\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t     gfor_fndecl_caf_send_by_ref,\n+\t\t\t\t     9, token, image_index, rhs_se.expr,\n+\t\t\t\t     reference, lhs_kind, rhs_kind,\n+\t\t\t\t     may_require_tmp, dst_realloc, src_stat);\n+\t  }\n+      else\n+\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 10,\n+\t\t\t\t   token, offset, image_index, lhs_se.expr, vec,\n+\t\t\t\t   rhs_se.expr, lhs_kind, rhs_kind,\n+\t\t\t\t   may_require_tmp, src_stat);\n+    }\n   else\n     {\n       tree rhs_token, rhs_offset, rhs_image_index;\n \n-      /* It guarantees memory consistency within the same segment */\n-      tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\"),\n+      /* It guarantees memory consistency within the same segment.  */\n+      tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\");\n       tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n \t\t\t  gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n \t\t\t  tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n@@ -1425,20 +2078,50 @@ conv_caf_send (gfc_code *code) {\n       if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n       rhs_image_index = gfc_caf_get_image_index (&block, rhs_expr, caf_decl);\n-      gfc_get_caf_token_offset (&rhs_token, &rhs_offset, caf_decl, rhs_se.expr,\n-\t\t\t\trhs_expr);\n-      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sendget, 13,\n-\t\t\t\t token, offset, image_index, lhs_se.expr, vec,\n-\t\t\t\t rhs_token, rhs_offset, rhs_image_index,\n-\t\t\t\t rhs_se.expr, rhs_vec, lhs_kind, rhs_kind,\n-\t\t\t\t may_require_tmp);\n+      tmp = rhs_se.expr;\n+      if (rhs_caf_attr.alloc_comp)\n+\t{\n+\t  tmp_stat = gfc_find_stat_co (lhs_expr);\n+\n+\t  if (tmp_stat)\n+\t    {\n+\t      gfc_se stat_se;\n+\t      gfc_init_se (&stat_se, NULL);\n+\t      gfc_conv_expr_reference (&stat_se, tmp_stat);\n+\t      src_stat = stat_se.expr;\n+\t      gfc_add_block_to_block (&block, &stat_se.pre);\n+\t      gfc_add_block_to_block (&block, &stat_se.post);\n+\t    }\n+\n+\t  gfc_get_caf_token_offset (&rhs_se, &rhs_token, NULL, caf_decl,\n+\t\t\t\t    NULL_TREE, NULL);\n+\t  tree lhs_reference, rhs_reference;\n+\t  lhs_reference = conv_expr_ref_to_caf_ref (&block, lhs_expr);\n+\t  rhs_reference = conv_expr_ref_to_caf_ref (&block, rhs_expr);\n+\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t     gfor_fndecl_caf_sendget_by_ref, 11,\n+\t\t\t\t     token, image_index, lhs_reference,\n+\t\t\t\t     rhs_token, rhs_image_index, rhs_reference,\n+\t\t\t\t     lhs_kind, rhs_kind, may_require_tmp,\n+\t\t\t\t     dst_stat, src_stat);\n+\t}\n+      else\n+\t{\n+\t  gfc_get_caf_token_offset (&rhs_se, &rhs_token, &rhs_offset, caf_decl,\n+\t\t\t\t    tmp, rhs_expr);\n+\t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sendget,\n+\t\t\t\t     14, token, offset, image_index,\n+\t\t\t\t     lhs_se.expr, vec, rhs_token, rhs_offset,\n+\t\t\t\t     rhs_image_index, tmp, rhs_vec, lhs_kind,\n+\t\t\t\t     rhs_kind, may_require_tmp, src_stat);\n+\t}\n     }\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &lhs_se.post);\n   gfc_add_block_to_block (&block, &rhs_se.post);\n \n-  /* It guarantees memory consistency within the same segment */\n-  tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\"),\n+  /* It guarantees memory consistency within the same segment.  */\n+  tmp = gfc_build_string_const (strlen (\"memory\") + 1, \"memory\");\n   tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n \t\t    gfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n \t\t    tree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n@@ -7962,7 +8645,8 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_CAF_GET:\n-      gfc_conv_intrinsic_caf_get (se, expr, NULL_TREE, NULL_TREE, NULL_TREE);\n+      gfc_conv_intrinsic_caf_get (se, expr, NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t  false, NULL);\n       break;\n \n     case GFC_ISYM_CMPLX:\n@@ -9033,8 +9717,11 @@ conv_intrinsic_atomic_op (gfc_code *code)\n           value = gfc_build_addr_expr (NULL_TREE, tmp);\n \t}\n \n-      gfc_get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_get_caf_token_offset (&argse, &token, &offset, caf_decl, atom,\n+\t\t\t\tatom_expr);\n \n+      gfc_add_block_to_block (&block, &argse.pre);\n       if (code->resolved_isym->id == GFC_ISYM_ATOMIC_DEF)\n \ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_def, 7,\n \t\t\t\t   token, offset, image_index, value, stat,\n@@ -9052,6 +9739,7 @@ conv_intrinsic_atomic_op (gfc_code *code)\n \t\t\t\t\t\t  (int) atom_expr->ts.kind));\n \n       gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&block, &argse.post);\n       gfc_add_block_to_block (&block, &post_block);\n       return gfc_finish_block (&block);\n     }\n@@ -9179,7 +9867,10 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n       else\n \timage_index = integer_zero_node;\n \n-      gfc_get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_get_caf_token_offset (&argse, &token, &offset, caf_decl, atom,\n+\t\t\t\tatom_expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n \n       /* Different type, need type conversion.  */\n       if (!POINTER_TYPE_P (TREE_TYPE (value)))\n@@ -9199,6 +9890,7 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n       if (vardecl != NULL_TREE)\n \tgfc_add_modify (&block, orig_value,\n \t\t\tfold_convert (TREE_TYPE (orig_value), vardecl));\n+      gfc_add_block_to_block (&block, &argse.post);\n       gfc_add_block_to_block (&block, &post_block);\n       return gfc_finish_block (&block);\n     }\n@@ -9312,7 +10004,10 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n           comp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t}\n \n-      gfc_get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_get_caf_token_offset (&argse, &token, &offset, caf_decl, atom,\n+\t\t\t\tatom_expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n \n       tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_cas, 9,\n \t\t\t\t token, offset, image_index, old, comp, new_val,\n@@ -9321,6 +10016,7 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n \t\t\t\t build_int_cst (integer_type_node,\n \t\t\t\t\t\t(int) atom_expr->ts.kind));\n       gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_block_to_block (&block, &argse.post);\n       gfc_add_block_to_block (&block, &post_block);\n       return gfc_finish_block (&block);\n     }\n@@ -9407,7 +10103,8 @@ conv_intrinsic_event_query (gfc_code *code)\n \n       image_index = integer_zero_node;\n \n-      gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, event_expr);\n+      gfc_get_caf_token_offset (&se, &token, NULL, caf_decl, NULL_TREE,\n+\t\t\t\tevent_expr);\n \n       /* For arrays, obtain the array index.  */\n       if (gfc_expr_attr (event_expr).dimension)"}, {"sha": "9fdacc10e39f13a3725a44534a10c685cc775d25", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -725,7 +725,8 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)\n \t  return NULL_TREE;\n \t}\n \n-      gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, code->expr1);\n+      gfc_get_caf_token_offset (&se, &token, NULL, caf_decl, NULL_TREE,\n+\t\t\t\tcode->expr1);\n \n       if (gfc_is_coindexed (code->expr1))\n \timage_index = gfc_caf_get_image_index (&se.pre, code->expr1, caf_decl);\n@@ -921,7 +922,10 @@ gfc_trans_event_post_wait (gfc_code *code, gfc_exec_op op)\n       return NULL_TREE;\n     }\n \n-  gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, code->expr1);\n+  gfc_init_se (&argse, NULL);\n+  gfc_get_caf_token_offset (&argse, &token, NULL, caf_decl, NULL_TREE,\n+\t\t\t    code->expr1);\n+  gfc_add_block_to_block (&se.pre, &argse.pre);\n \n   if (gfc_is_coindexed (code->expr1))\n     image_index = gfc_caf_get_image_index (&se.pre, code->expr1, caf_decl);\n@@ -5876,11 +5880,30 @@ gfc_trans_allocate (gfc_code * code)\n \t    /* Handle size computation of the type declared to alloc.  */\n \t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n \n+\t  if (gfc_caf_attr (expr).codimension\n+\t      && flag_coarray == GFC_FCOARRAY_LIB)\n+\t    {\n+\t      /* Scalar allocatable components in coarray'ed derived types make\n+\t\t it here and are treated now.  */\n+\t      tree caf_decl, token;\n+\t      gfc_se caf_se;\n+\n+\t      gfc_init_se (&caf_se, NULL);\n+\n+\t      caf_decl = gfc_get_tree_for_caf_expr (expr);\n+\t      gfc_get_caf_token_offset (&caf_se, &token, NULL, caf_decl,\n+\t\t\t\t\tNULL_TREE, NULL);\n+\t      gfc_add_block_to_block (&se.pre, &caf_se.pre);\n+\t      gfc_allocate_allocatable (&se.pre, se.expr, memsz,\n+\t\t\t\t\tgfc_build_addr_expr (NULL_TREE, token),\n+\t\t\t\t\tNULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t\tlabel_finish, expr, 1);\n+\t    }\n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n-\t  if (gfc_expr_attr (expr).allocatable)\n-\t    gfc_allocate_allocatable (&se.pre, se.expr, memsz, NULL_TREE,\n-\t\t\t\t      stat, errmsg, errlen, label_finish,\n-\t\t\t\t      expr);\n+\t  else if (gfc_expr_attr (expr).allocatable)\n+\t    gfc_allocate_allocatable (&se.pre, se.expr, memsz,\n+\t\t\t\t      NULL_TREE, stat, errmsg, errlen,\n+\t\t\t\t      label_finish, expr, 0);\n \t  else\n \t    gfc_allocate_using_malloc (&se.pre, se.expr, memsz, stat);\n \n@@ -6147,10 +6170,12 @@ gfc_trans_allocate (gfc_code * code)\n \t      /* Switch off automatic reallocation since we have just\n \t\t done the ALLOCATE.  */\n \t      int realloc_lhs = flag_realloc_lhs;\n+\t      gfc_expr *init_expr = gfc_expr_to_initialize (expr);\n \t      flag_realloc_lhs = 0;\n-\t      tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n-\t\t\t\t\t  e3rhs, false, false);\n+\t      tmp = gfc_trans_assignment (init_expr, e3rhs, false, false);\n \t      flag_realloc_lhs = realloc_lhs;\n+\t      /* Free the expression allocated for init_expr.  */\n+\t      gfc_free_expr (init_expr);\n \t    }\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n@@ -6298,7 +6323,7 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (expr->rank || gfc_is_coarray (expr))\n+      if (expr->rank || gfc_caf_attr (expr).codimension)\n \t{\n \t  gfc_ref *ref;\n "}, {"sha": "27a6bab7a0505dfb09f67f56a77d3abfda2bce4a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 150, "deletions": 15, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -1054,7 +1054,7 @@ gfc_get_character_type (int kind, gfc_charlen * cl)\n /* Convert a basic type.  This will be an array for character types.  */\n \n tree\n-gfc_typenode_for_spec (gfc_typespec * spec)\n+gfc_typenode_for_spec (gfc_typespec * spec, bool in_coarray)\n {\n   tree basetype;\n \n@@ -1107,7 +1107,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n \n     case BT_DERIVED:\n     case BT_CLASS:\n-      basetype = gfc_get_derived_type (spec->u.derived);\n+      basetype = gfc_get_derived_type (spec->u.derived, in_coarray);\n \n       if (spec->type == BT_CLASS)\n \tGFC_CLASS_TYPE_P (basetype) = 1;\n@@ -1311,7 +1311,7 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n static tree\n gfc_build_array_type (tree type, gfc_array_spec * as,\n \t\t      enum gfc_array_kind akind, bool restricted,\n-\t\t      bool contiguous)\n+\t\t      bool contiguous, bool in_coarray)\n {\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n@@ -1361,7 +1361,7 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n   return gfc_get_array_type_bounds (type, as->rank == -1\n \t\t\t\t\t  ? GFC_MAX_DIMENSIONS : as->rank,\n \t\t\t\t    corank, lbound,\n-\t\t\t\t    ubound, 0, akind, restricted);\n+\t\t\t\t    ubound, 0, akind, restricted, in_coarray);\n }\n \f\n /* Returns the struct descriptor_dimension type.  */\n@@ -1724,7 +1724,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n \n static tree\n gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n-\t\t\t       enum gfc_array_kind akind)\n+\t\t\t       enum gfc_array_kind akind, bool in_coarray)\n {\n   tree fat_type, decl, arraytype, *chain = NULL;\n   char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n@@ -1786,7 +1786,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n       TREE_NO_WARNING (decl) = 1;\n     }\n \n-  if (flag_coarray == GFC_FCOARRAY_LIB && codimen\n+  if (flag_coarray == GFC_FCOARRAY_LIB && (codimen || in_coarray)\n       && akind == GFC_ARRAY_ALLOCATABLE)\n     {\n       decl = gfc_add_field_to_struct_1 (fat_type,\n@@ -1814,18 +1814,21 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n tree\n gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n \t\t\t   tree * ubound, int packed,\n-\t\t\t   enum gfc_array_kind akind, bool restricted)\n+\t\t\t   enum gfc_array_kind akind, bool restricted,\n+\t\t\t   bool in_coarray)\n {\n   char name[8 + 2*GFC_RANK_DIGITS + 1 + GFC_MAX_SYMBOL_LEN];\n   tree fat_type, base_type, arraytype, lower, upper, stride, tmp, rtype;\n   const char *type_name;\n   int n;\n \n-  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted, akind);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted, akind,\n+\t\t\t\t\t     in_coarray);\n   fat_type = build_distinct_type_copy (base_type);\n   /* Make sure that nontarget and target array type have the same canonical\n      type (and same stub decl for debug info).  */\n-  base_type = gfc_get_array_descriptor_base (dimen, codimen, false, akind);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, false, akind,\n+\t\t\t\t\t     in_coarray);\n   TYPE_CANONICAL (fat_type) = base_type;\n   TYPE_STUB_DECL (fat_type) = TYPE_STUB_DECL (base_type);\n \n@@ -2161,7 +2164,7 @@ gfc_sym_type (gfc_symbol * sym)\n \t\t\t\t   || !sym->ts.u.cl->backend_decl))))\n     type = gfc_character1_type_node;\n   else\n-    type = gfc_typenode_for_spec (&sym->ts);\n+    type = gfc_typenode_for_spec (&sym->ts, sym->attr.codimension);\n \n   if (sym->attr.dummy && !sym->attr.function && !sym->attr.value)\n     byref = 1;\n@@ -2199,7 +2202,7 @@ gfc_sym_type (gfc_symbol * sym)\n \t  else if (sym->attr.allocatable)\n \t    akind = GFC_ARRAY_ALLOCATABLE;\n \t  type = gfc_build_array_type (type, sym->as, akind, restricted,\n-\t\t\t\t       sym->attr.contiguous);\n+\t\t\t\t       sym->attr.contiguous, false);\n \t}\n     }\n   else\n@@ -2417,7 +2420,7 @@ gfc_get_union_type (gfc_symbol *un)\n    in a parent namespace, this is used.  */\n \n tree\n-gfc_get_derived_type (gfc_symbol * derived)\n+gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n {\n   tree typenode = NULL, field = NULL, field_type = NULL;\n   tree canonical = NULL_TREE;\n@@ -2561,7 +2564,8 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n       if ((!c->attr.pointer && !c->attr.proc_pointer)\n \t  || c->ts.u.derived->backend_decl == NULL)\n-\tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived);\n+\tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived,\n+\t\t\t\t\t\t\t      in_coarray);\n \n       if (c->ts.u.derived->attr.is_iso_c)\n         {\n@@ -2618,7 +2622,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t    c->ts.u.cl->backend_decl\n \t\t\t= build_int_cst (gfc_charlen_type_node, 0);\n \n-\t  field_type = gfc_typenode_for_spec (&c->ts);\n+\t  field_type = gfc_typenode_for_spec (&c->ts, in_coarray);\n \t}\n \n       /* This returns an array descriptor type.  Initialization may be\n@@ -2638,7 +2642,8 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t      field_type = gfc_build_array_type (field_type, c->as, akind,\n \t\t\t\t\t\t !c->attr.target\n \t\t\t\t\t\t && !c->attr.pointer,\n-\t\t\t\t\t\t c->attr.contiguous);\n+\t\t\t\t\t\t c->attr.contiguous,\n+\t\t\t\t\t\t in_coarray);\n \t    }\n \t  else\n \t    field_type = gfc_get_nodesc_array_type (field_type, c->as,\n@@ -2683,6 +2688,19 @@ gfc_get_derived_type (gfc_symbol * derived)\n       gcc_assert (field);\n       if (!c->backend_decl)\n \tc->backend_decl = field;\n+\n+      /* Do not add a caf_token field for classes' data components.  */\n+      if (in_coarray && !c->attr.dimension && !c->attr.codimension\n+\t  && c->attr.allocatable && c->caf_token == NULL_TREE\n+\t  && strcmp (\"_data\", c->name) != 0)\n+\t{\n+\t  char caf_name[GFC_MAX_SYMBOL_LEN];\n+\t  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, \"_caf_%s\", c->name);\n+\t  c->caf_token = gfc_add_field_to_struct (typenode,\n+\t\t\t\t\t\t  get_identifier (caf_name),\n+\t\t\t\t\t\t  pvoid_type_node, &chain);\n+\t  TREE_NO_WARNING (c->caf_token) = 1;\n+\t}\n     }\n \n   /* Now lay out the derived type, including the fields.  */\n@@ -3324,4 +3342,121 @@ gfc_get_caf_vector_type (int dim)\n   return vector_types[dim-1];\n }\n \n+\n+tree\n+gfc_get_caf_reference_type ()\n+{\n+  static tree reference_type = NULL_TREE;\n+  tree c_struct_type, s_struct_type, v_struct_type, union_type, dim_union_type,\n+      a_struct_type, u_union_type, tmp, *chain;\n+\n+  if (reference_type != NULL_TREE)\n+    return reference_type;\n+\n+  chain = 0;\n+  c_struct_type = make_node (RECORD_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (c_struct_type,\n+\t\t\t\t   get_identifier (\"offset\"),\n+\t\t\t\t   gfc_array_index_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (c_struct_type,\n+\t\t\t\t   get_identifier (\"caf_token_offset\"),\n+\t\t\t\t   gfc_array_index_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (c_struct_type);\n+\n+  chain = 0;\n+  s_struct_type = make_node (RECORD_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (s_struct_type,\n+\t\t\t\t   get_identifier (\"start\"),\n+\t\t\t\t   gfc_array_index_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (s_struct_type,\n+\t\t\t\t   get_identifier (\"end\"),\n+\t\t\t\t   gfc_array_index_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (s_struct_type,\n+\t\t\t\t   get_identifier (\"stride\"),\n+\t\t\t\t   gfc_array_index_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (s_struct_type);\n+\n+  chain = 0;\n+  v_struct_type = make_node (RECORD_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (v_struct_type,\n+\t\t\t\t   get_identifier (\"vector\"),\n+\t\t\t\t   pvoid_type_node, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (v_struct_type,\n+\t\t\t\t   get_identifier (\"nvec\"),\n+\t\t\t\t   size_type_node, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (v_struct_type,\n+\t\t\t\t   get_identifier (\"kind\"),\n+\t\t\t\t   integer_type_node, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (v_struct_type);\n+\n+  chain = 0;\n+  union_type = make_node (UNION_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (union_type, get_identifier (\"s\"),\n+\t\t\t\t   s_struct_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (union_type, get_identifier (\"v\"),\n+\t\t\t\t   v_struct_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (union_type);\n+\n+  tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n+\t\t\t  gfc_rank_cst[GFC_MAX_DIMENSIONS - 1]);\n+  dim_union_type = build_array_type (union_type, tmp);\n+\n+  chain = 0;\n+  a_struct_type = make_node (RECORD_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (a_struct_type, get_identifier (\"mode\"),\n+\t\tbuild_array_type (unsigned_char_type_node,\n+\t\t\t\t  build_range_type (gfc_array_index_type,\n+\t\t\t\t\t\t    gfc_index_zero_node,\n+\t\t\t\t\t gfc_rank_cst[GFC_MAX_DIMENSIONS - 1])),\n+\t\t&chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (a_struct_type,\n+\t\t\t\t   get_identifier (\"static_array_type\"),\n+\t\t\t\t   integer_type_node, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (a_struct_type, get_identifier (\"dim\"),\n+\t\t\t\t   dim_union_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (a_struct_type);\n+\n+  chain = 0;\n+  u_union_type = make_node (UNION_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (u_union_type, get_identifier (\"c\"),\n+\t\t\t\t   c_struct_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (u_union_type, get_identifier (\"a\"),\n+\t\t\t\t   a_struct_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (u_union_type);\n+\n+  chain = 0;\n+  reference_type = make_node (RECORD_TYPE);\n+  tmp = gfc_add_field_to_struct_1 (reference_type, get_identifier (\"next\"),\n+\t\t\t\t   build_pointer_type (reference_type), &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (reference_type, get_identifier (\"type\"),\n+\t\t\t\t   integer_type_node, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (reference_type, get_identifier (\"item_size\"),\n+\t\t\t\t   size_type_node, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  tmp = gfc_add_field_to_struct_1 (reference_type, get_identifier (\"u\"),\n+\t\t\t\t   u_union_type, &chain);\n+  TREE_NO_WARNING (tmp) = 1;\n+  gfc_finish_type (reference_type);\n+  TYPE_NAME (reference_type) = get_identifier (\"caf_reference_t\");\n+\n+  return reference_type;\n+}\n+\n #include \"gt-fortran-trans-types.h\""}, {"sha": "e8e92bf27775f134fa9c948a24324c0271974fb4", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -70,7 +70,7 @@ tree gfc_get_character_type_len (int, tree);\n tree gfc_get_character_type_len_for_eltype (tree, tree);\n \n tree gfc_sym_type (gfc_symbol *);\n-tree gfc_typenode_for_spec (gfc_typespec *);\n+tree gfc_typenode_for_spec (gfc_typespec *, bool in_coarray = false);\n int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);\n \n tree gfc_get_function_type (gfc_symbol *);\n@@ -81,7 +81,8 @@ tree gfc_build_uint_type (int);\n \n tree gfc_get_element_type (tree);\n tree gfc_get_array_type_bounds (tree, int, int, tree *, tree *, int,\n-\t\t\t\tenum gfc_array_kind, bool);\n+\t\t\t\tenum gfc_array_kind, bool,\n+\t\t\t\tbool in_coarray = false);\n tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed, bool);\n \n /* Add a field of given name and type to a UNION_TYPE or RECORD_TYPE.  */\n@@ -102,5 +103,6 @@ tree gfc_get_dtype (tree);\n \n tree gfc_get_ppc_type (gfc_component *);\n tree gfc_get_caf_vector_type (int dim);\n+tree gfc_get_caf_reference_type ();\n \n #endif"}, {"sha": "9210e0f71e5dae7f76c9fcc3d70d95697cc6cdc0", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -734,19 +734,17 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n \n   size = fold_convert (size_type_node, size);\n   tmp = build_call_expr_loc (input_location,\n-\t     gfor_fndecl_caf_register, 6,\n+\t     gfor_fndecl_caf_register, 7,\n \t     fold_build2_loc (input_location,\n \t\t\t      MAX_EXPR, size_type_node, size,\n \t\t\t      build_int_cst (size_type_node, 1)),\n \t     build_int_cst (integer_type_node,\n \t\t\t    lock_var ? GFC_CAF_LOCK_ALLOC\n                             : event_var ? GFC_CAF_EVENT_ALLOC\n \t\t\t\t\t: GFC_CAF_COARRAY_ALLOC),\n-\t     token, pstat, errmsg, errlen);\n+\t     token, gfc_build_addr_expr (pvoid_type_node, pointer),\n+\t     pstat, errmsg, errlen);\n \n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t TREE_TYPE (pointer), pointer,\n-\t\t\t fold_convert ( TREE_TYPE (pointer), tmp));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* It guarantees memory consistency within the same segment */\n@@ -782,13 +780,15 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n     expr must be set to the original expression being allocated for its locus\n     and variable name in case a runtime error has to be printed.  */\n void\n-gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n-\t\t\t  tree status, tree errmsg, tree errlen, tree label_finish,\n-\t\t\t  gfc_expr* expr)\n+gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size,\n+\t\t\t  tree token, tree status, tree errmsg, tree errlen,\n+\t\t\t  tree label_finish, gfc_expr* expr, int corank)\n {\n   stmtblock_t alloc_block;\n   tree tmp, null_mem, alloc, error;\n   tree type = TREE_TYPE (mem);\n+  symbol_attribute caf_attr;\n+  bool need_assign = false;\n \n   size = fold_convert (size_type_node, size);\n   null_mem = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n@@ -800,8 +800,11 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n      gfc_allocate_using_lib.  */\n   gfc_start_block (&alloc_block);\n \n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    caf_attr = gfc_caf_attr (expr, true);\n+\n   if (flag_coarray == GFC_FCOARRAY_LIB\n-      && gfc_expr_attr (expr).codimension)\n+      && (corank > 0 || caf_attr.codimension))\n     {\n       tree cond;\n       bool lock_var = expr->ts.type == BT_DERIVED\n@@ -814,6 +817,33 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \t\t\t == INTMOD_ISO_FORTRAN_ENV\n \t\t       && expr->ts.u.derived->intmod_sym_id\n \t\t         == ISOFORTRAN_EVENT_TYPE;\n+      gfc_se se;\n+      gfc_init_se (&se, NULL);\n+\n+      tree sub_caf_tree = gfc_get_ultimate_alloc_ptr_comps_caf_token (&se,\n+\t\t\t\t\t\t\t\t      expr);\n+      if (sub_caf_tree == NULL_TREE)\n+\tsub_caf_tree = token;\n+\n+      /* When mem is an array ref, then strip the .data-ref.  */\n+      if (TREE_CODE (mem) == COMPONENT_REF\n+\t  && !(GFC_ARRAY_TYPE_P (TREE_TYPE (mem))))\n+\ttmp = TREE_OPERAND (mem, 0);\n+      else\n+\ttmp = mem;\n+\n+      if (!(GFC_ARRAY_TYPE_P (TREE_TYPE (tmp))\n+\t    && TYPE_LANG_SPECIFIC (TREE_TYPE (tmp))->corank == 0)\n+\t  && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t{\n+\t  symbol_attribute attr;\n+\n+\t  gfc_clear_attr (&attr);\n+\t  tmp = gfc_conv_scalar_to_descriptor (&se, mem, attr);\n+\t  need_assign = true;\n+\t}\n+      gfc_add_block_to_block (&alloc_block, &se.pre);\n+\n       /* In the front end, we represent the lock variable as pointer. However,\n \t the FE only passes the pointer around and leaves the actual\n \t representation to the library. Hence, we have to convert back to the\n@@ -822,9 +852,11 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \tsize = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n \t\t\t\tsize, TYPE_SIZE_UNIT (ptr_type_node));\n \n-      gfc_allocate_using_lib (&alloc_block, mem, size, token, status,\n-\t\t\t      errmsg, errlen, lock_var, event_var);\n-\n+      gfc_allocate_using_lib (&alloc_block, tmp, size, sub_caf_tree,\n+\t\t\t      status, errmsg, errlen, lock_var, event_var);\n+      if (need_assign)\n+\tgfc_add_modify (&alloc_block, mem, fold_convert (TREE_TYPE (mem),\n+\t\t\t\t\t   gfc_conv_descriptor_data_get (tmp)));\n       if (status != NULL_TREE)\n \t{\n \t  TREE_USED (label_finish) = 1;\n@@ -1362,8 +1394,8 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \n       token = gfc_build_addr_expr  (NULL_TREE, token);\n       tmp = build_call_expr_loc (input_location,\n-\t     gfor_fndecl_caf_deregister, 4,\n-\t     token, pstat, errmsg, errlen);\n+\t\t\t\t gfor_fndecl_caf_deregister, 4,\n+\t\t\t\t token, pstat, errmsg, errlen);\n       gfc_add_expr_to_block (&non_null, tmp);\n \n       /* It guarantees memory consistency within the same segment */"}, {"sha": "4d3d207dc32ec40b5d9acf8ade891ed63f6606f8", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -119,6 +119,27 @@ enum gfc_coarray_type\n };\n \n \n+/* Specify the type of ref handed to the caf communication functions.\n+   Please keep in sync with libgfortran/caf/libcaf.h.  */\n+enum gfc_caf_ref_type_t {\n+  GFC_CAF_REF_COMPONENT,\n+  GFC_CAF_REF_ARRAY,\n+  GFC_CAF_REF_STATIC_ARRAY\n+};\n+\n+\n+/* Give the reference type of an array ref.\n+   Please keep in sync with libgfortran/caf/libcaf.h.  */\n+enum gfc_caf_array_ref_t {\n+  GFC_CAF_ARR_REF_NONE = 0,\n+  GFC_CAF_ARR_REF_VECTOR,\n+  GFC_CAF_ARR_REF_FULL,\n+  GFC_CAF_ARR_REF_RANGE,\n+  GFC_CAF_ARR_REF_SINGLE,\n+  GFC_CAF_ARR_REF_OPEN_END,\n+  GFC_CAF_ARR_REF_OPEN_START\n+};\n+\n /* The array-specific scalarization information.  The array members of\n    this struct are indexed by actual array index, and thus can be sparse.  */\n \n@@ -441,14 +462,14 @@ void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_reference (gfc_se * se, gfc_expr *);\n void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);\n \n-tree gfc_conv_scalar_to_descriptor (gfc_se *, tree, symbol_attribute);\n-\n \n /* trans-expr.c */\n+tree gfc_conv_scalar_to_descriptor (gfc_se *, tree, symbol_attribute);\n+tree gfc_get_ultimate_alloc_ptr_comps_caf_token (gfc_se *, gfc_expr *);\n void gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr);\n tree gfc_string_to_single_character (tree len, tree str, int kind);\n tree gfc_get_tree_for_caf_expr (gfc_expr *);\n-void gfc_get_caf_token_offset (tree *, tree *, tree, tree, gfc_expr *);\n+void gfc_get_caf_token_offset (gfc_se*, tree *, tree *, tree, tree, gfc_expr *);\n tree gfc_caf_get_image_index (stmtblock_t *, gfc_expr *, tree);\n \n /* Find the decl containing the auxiliary variables for assigned variables.  */\n@@ -661,7 +682,7 @@ tree gfc_build_memcpy_call (tree, tree, tree);\n \n /* Allocate memory for allocatable variables, with optional status variable.  */\n void gfc_allocate_allocatable (stmtblock_t*, tree, tree, tree, tree,\n-\t\t\t       tree, tree, tree, gfc_expr*);\n+\t\t\t       tree, tree, tree, gfc_expr*, int);\n \n /* Allocate memory, with optional status variable.  */\n void gfc_allocate_using_malloc (stmtblock_t *, tree, tree, tree);\n@@ -760,6 +781,9 @@ extern GTY(()) tree gfor_fndecl_caf_deregister;\n extern GTY(()) tree gfor_fndecl_caf_get;\n extern GTY(()) tree gfor_fndecl_caf_send;\n extern GTY(()) tree gfor_fndecl_caf_sendget;\n+extern GTY(()) tree gfor_fndecl_caf_get_by_ref;\n+extern GTY(()) tree gfor_fndecl_caf_send_by_ref;\n+extern GTY(()) tree gfor_fndecl_caf_sendget_by_ref;\n extern GTY(()) tree gfor_fndecl_caf_sync_all;\n extern GTY(()) tree gfor_fndecl_caf_sync_memory;\n extern GTY(()) tree gfor_fndecl_caf_sync_images;"}, {"sha": "70d7c56535f1b97dac6889b1426c22c822d0a7e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -1,3 +1,26 @@\n+2016-09-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray/alloc_comp_4.f90: New test.\n+\t* gfortran.dg/coarray_38.f90:\n+\t* gfortran.dg/coarray_alloc_comp_1.f08: New test.\n+\t* gfortran.dg/coarray_alloc_comp_2.f08: New test.\n+\t* gfortran.dg/coarray_allocate_7.f08: New test.\n+\t* gfortran.dg/coarray_allocate_8.f08: New test.\n+\t* gfortran.dg/coarray_allocate_9.f08: New test.\n+\t* gfortran.dg/coarray_lib_alloc_1.f90: Adapted scan-tree-dumps to expect\n+\tnew caf_register.\n+\t* gfortran.dg/coarray_lib_alloc_2.f90: Same.\n+\t* gfortran.dg/coarray_lib_alloc_3.f90: Same.\n+\t* gfortran.dg/coarray_lib_comm_1.f90: Adapted scan-tree-dumps to expect\n+\tget_by_refs.\n+\t* gfortran.dg/coarray_lib_token_3.f90: Same as for coarray_lib_alloc2.\n+\t* gfortran.dg/coarray_lock_7.f90: Same.\n+\t* gfortran.dg/coarray_poly_5.f90: Same.\n+\t* gfortran.dg/coarray_poly_6.f90: Same.\n+\t* gfortran.dg/coarray_poly_7.f90: Same.\n+\t* gfortran.dg/coarray_poly_8.f90: Same.\n+\t* gfortran.dg/coindexed_1.f90: Changed errors expected.\n+\n 2016-09-19  Fritz Reese  <fritzoreese@gmail.com>\n \n \tPR fortran/77584"}, {"sha": "0bae25c39231f0b56a154a76b8c8593d09f241ea", "filename": "gcc/testsuite/gfortran.dg/coarray/alloc_comp_4.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Falloc_comp_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Falloc_comp_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Falloc_comp_4.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+\n+! Contributed by Damian Rouson\n+\n+program main\n+\n+  implicit none\n+\n+  type mytype\n+    integer, allocatable :: indices(:)\n+  end type\n+\n+  type(mytype), save :: object[*]\n+  integer :: me\n+\n+  me=this_image()\n+  allocate(object%indices(me))\n+  object%indices = 42\n+\n+  if ( any( object[me]%indices(:) /= 42 ) ) call abort()\n+end program"}, {"sha": "31155c53f01162ac29631bd3b1225852fae0c57c", "filename": "gcc/testsuite/gfortran.dg/coarray_38.f90", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_38.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_38.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_38.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -15,11 +15,11 @@ subroutine one\n type(t), save :: caf[*],x\n type(t2) :: y\n \n-x = caf[4]     ! { dg-error \"Sorry, coindexed coarray at \\\\(1\\\\) with allocatable component is not yet supported\" }\n-x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x = caf[4] ! OK, now\n+x%a = caf[4]%a ! OK, now\n x%b = caf[4]%b ! OK\n-x = y%caf2[5]  ! { dg-error \"Sorry, coindexed coarray at \\\\(1\\\\) with allocatable component is not yet supported\" }\n-x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x = y%caf2[5]  ! OK, now\n+x%a = y%caf2[4]%a ! OK, now\n x%b = y%caf2[4]%b ! OK\n end subroutine one\n \n@@ -36,10 +36,10 @@ subroutine two\n type(t2) :: y\n \n x = caf[4]     ! OK\n-x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%a = caf[4]%a ! OK, now\n x%b = caf[4]%b ! OK\n x = y%caf2[5]  ! OK\n-x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%a = y%caf2[4]%a !  OK, now\n x%b = y%caf2[4]%b ! OK\n end subroutine two\n \n@@ -56,10 +56,10 @@ subroutine three\n type(t2) :: y\n \n x(1) = caf(2)[4]%b ! OK\n-x(:) = caf(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+x(:) = caf(:)[4]%b ! OK now\n \n x(1) = y%caf2(2)[4]%b ! OK\n-x(:) = y%caf2(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+x(:) = y%caf2(:)[4]%b ! OK now\n end subroutine three\n \n subroutine four\n@@ -76,10 +76,10 @@ subroutine four\n type(t2) :: y\n \n !x = caf[4]    ! Unsupported - and ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n-x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%a = caf[4]%a ! OK, now\n x%b = caf[4]%b ! OK\n !x = y%caf2[5] ! Unsupported - and ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n-x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%a = y%caf2[4]%a ! Ok, now\n x%b = y%caf2[4]%b ! OK\n end subroutine four\n \n@@ -97,10 +97,10 @@ subroutine five\n type(t2) :: y\n \n !x = caf[4]     ! OK - but ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n-x%a = caf[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%a = caf[4]%a ! OK, now\n x%b = caf[4]%b ! OK\n !x = y%caf2[5]  ! OK - but ICEs in resolve_ordinary_assign, cf. PR fortran/65397\n-x%a = y%caf2[4]%a ! { dg-error \"Sorry, coindexed access to a pointer or allocatable component of the coindexed coarray at \\\\(1\\\\) is not yet supported\" }\n+x%a = y%caf2[4]%a ! OK, now\n x%b = y%caf2[4]%b ! OK\n end subroutine five\n \n@@ -117,8 +117,16 @@ subroutine six\n type(t2) :: y\n \n x(1) = caf(2)[4]%b ! OK\n-x(:) = caf(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+x(:) = caf(:)[4]%b ! OK now\n \n x(1) = y%caf2(2)[4]%b ! OK\n-x(:) = y%caf2(:)[4]%b ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+x(:) = y%caf2(:)[4]%b ! OK now\n end subroutine six\n+\n+call one()\n+call two()\n+call three()\n+call four()\n+call five()\n+call six()\n+end"}, {"sha": "78da297d8a4f400a0e3928011a21a860dd4a3887", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_1.f08", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_1.f08?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -0,0 +1,92 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+\n+! Contributed by Damian Rouson\n+! Check the new _caf_get_by_ref()-routine.\n+\n+program main\n+\n+implicit none\n+\n+type :: mytype\n+  integer :: i\n+  integer, allocatable :: indices(:)\n+  real, dimension(2,5,3) :: volume\n+  integer, allocatable :: scalar\n+  integer :: j\n+  integer, allocatable :: matrix(:,:)\n+  real, allocatable :: dynvol(:,:,:)\n+end type\n+\n+type arrtype\n+  type(mytype), allocatable :: vec(:)\n+  type(mytype), allocatable :: mat(:,:)\n+end type arrtype\n+\n+type(mytype), save :: object[*]\n+type(arrtype), save :: bar[*]\n+integer :: i,j,me,neighbor\n+integer :: idx(5)\n+real, allocatable :: volume(:,:,:), vol2(:,:,:)\n+real :: vol_static(2,5,3)\n+\n+idx = (/ 1,2,1,7,5 /)\n+\n+me=this_image()\n+object%indices=[(i,i=1,5)]\n+allocate(object%scalar, object%matrix(10,7))\n+object%i = 37\n+object%scalar = 42\n+vol_static = reshape([(i, i=1, 2*5*3)], [2, 5, 3])\n+object%volume = vol_static\n+object%matrix = reshape([(i, i=1, 70)], [10, 7])\n+object%dynvol = vol_static\n+sync all\n+neighbor = merge(1,neighbor,me==num_images())\n+if (object[neighbor]%scalar /= 42) call abort()\n+if (object[neighbor]%indices(4) /= 4) call abort()\n+if (object[neighbor]%matrix(3,6) /= 53) call abort()\n+if (any( object[neighbor]%indices(:) /= [1,2,3,4,5] )) call abort()\n+if (any( object[neighbor]%matrix(:,:) /= reshape([(i, i=1, 70)], [10, 7]))) call abort()\n+if (any( object[neighbor]%matrix(3,:) /= [(i * 10 + 3, i=0, 6)])) call abort()\n+if (any( object[neighbor]%matrix(:,2) /= [(i + 10, i=1, 10)])) call abort()\n+if (any( object[neighbor]%matrix(idx,2) /= [11, 12, 11, 17, 15])) call abort()\n+if (any( object[neighbor]%matrix(3,idx) /= [3, 13, 3, 63, 43])) call abort()\n+if (any( object[neighbor]%matrix(2:8:4, 5:1:-1) /= reshape([42, 46, 32, 36, 22, 26, 12, 16, 2, 6], [2,5]))) call abort()\n+if (any( object[neighbor]%matrix(:8:4, 2::2) /= reshape([11, 15, 31, 35, 51, 55], [2,3]))) call abort()\n+if (any( object[neighbor]%volume /= vol_static)) call abort()\n+if (any( object[neighbor]%dynvol /= vol_static)) call abort()\n+if (any( object[neighbor]%volume(:, 2:4, :) /= vol_static(:, 2:4, :))) call abort()\n+if (any( object[neighbor]%dynvol(:, 2:4, :) /= vol_static(:, 2:4, :))) call abort()\n+\n+vol2 = vol_static(:, ::2, :)\n+if (any( object[neighbor]%volume(:, ::2, :) /= vol2)) call abort()\n+if (any( object[neighbor]%dynvol(:, ::2, :) /= vol2)) call abort()\n+\n+allocate(bar%vec(-2:2))\n+\n+bar%vec(1)%volume = vol_static\n+if (any(bar[neighbor]%vec(1)%volume /= vol_static)) call abort()\n+\n+i = 15\n+bar%vec(1)%scalar = i\n+if (.not. allocated(bar%vec(1)%scalar)) call abort()\n+if (bar[neighbor]%vec(1)%scalar /= 15) call abort()\n+\n+bar%vec(0)%scalar = 27\n+if (.not. allocated(bar%vec(0)%scalar)) call abort()\n+if (bar[neighbor]%vec(0)%scalar /= 27) call abort()\n+\n+bar%vec(1)%indices = [ 3, 4, 15 ]\n+allocate(bar%vec(2)%indices(5))\n+bar%vec(2)%indices = 89\n+\n+if (.not. allocated(bar%vec(1)%indices)) call abort()\n+if (allocated(bar%vec(-2)%indices)) call abort()\n+if (allocated(bar%vec(-1)%indices)) call abort()\n+if (allocated(bar%vec( 0)%indices)) call abort()\n+if (.not. allocated(bar%vec( 2)%indices)) call abort()\n+if (any(bar[me]%vec(2)%indices /= 89)) call abort()\n+\n+if (any (bar[neighbor]%vec(1)%indices /= [ 3,4,15])) call abort()\n+end program"}, {"sha": "cd9d8f2ef3b014b6da9f839b28c58ad240174e9e", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_7.f08", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_7.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_7.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_7.f08?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single -fdump-tree-original\" }\n+\n+! Contributed by Damian Rouson\n+! Checking whether (de-)registering of coarrays works.\n+\n+program main\n+\n+  implicit none\n+\n+  type mytype\n+    integer, allocatable :: indices(:)\n+  end type\n+\n+  type(mytype), save :: object[*]\n+  integer :: i,me\n+\n+  me=this_image() ! me is always 1 here\n+  object%indices=[(i,i=1,me)]\n+  if ( size(object%indices) /= 1 ) call abort()\n+  ! therefore no array is present here and no array test needed.\n+  if ( object%indices(1) /= 1 ) call abort()\n+end program\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(D.\\[0-9\\]{4}, 1, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices, 0B, 0B, 0\\\\);\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister \\\\(&\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+"}, {"sha": "4710049636065f325b996d0ae41a2069734e600d", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_8.f08", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_8.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_8.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_8.f08?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single -fdump-tree-original\" }\n+\n+program alloc_comp\n+  implicit none\n+\n+  type coords\n+    real,allocatable :: x(:)\n+    real,allocatable :: y(:)\n+    real,allocatable :: z(:)\n+  end type\n+\n+  integer :: me,np,n,i\n+  type(coords) :: coo[*]\n+\n+  ! with caf_single num_images is always == 1\n+  me = this_image(); np = num_images()\n+  n = 100\n+\n+  allocate(coo%x(n),coo%y(n),coo%z(n))\n+\n+  coo%y = me\n+\n+  do i=1, n\n+        coo%y(i) = coo%y(i) + i\n+  end do\n+\n+  sync all\n+\n+  ! Check the caf_get()-offset is computed correctly.\n+  if(me == 1 .and. coo[np]%y(10) /= 11 ) call abort()\n+\n+  ! Check the whole array is correct.\n+  if (me == 1 .and. any( coo[np]%y /= [(i, i=2, 101)] ) ) call abort()\n+\n+  deallocate(coo%x)\n+\n+end program"}, {"sha": "880f2b387fe7d7654c1371f6b849ba36076d61c7", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_9.f08", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_9.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_9.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_9.f08?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+\n+! Contributed by Damian Rouson\n+\n+program main\n+  implicit none\n+\n+  type particles\n+    real x(2)\n+  end type\n+\n+  type vector\n+    type(particles), allocatable :: v(:)\n+  end type\n+\n+  type(vector) :: outbox[*]\n+  type(particles), allocatable :: object(:)[:]\n+\n+  allocate(outbox%v(1), source=particles(this_image()))\n+\n+  if (any( outbox[1]%v(1)%x(1:2) /= [ 1.0, 1.0] )) call abort()\n+  if (any( outbox[1]%v(1)%x(:) /= [ 1.0, 1.0] )) call abort()\n+  if (any( outbox[1]%v(1)%x /= [ 1.0, 1.0] )) call abort()\n+\n+  allocate(object(1)[*], source=particles(this_image()))\n+\n+  if (any( object(1)[1]%x(1:2) /= [ 1.0, 1.0] )) call abort()\n+  if (any( object(1)[1]%x(:) /= [ 1.0, 1.0] )) call abort()\n+  if (any( object(1)[1]%x /= [ 1.0, 1.0] )) call abort()\n+end program"}, {"sha": "31e4cf50c1335f240185e78671f6420058b75920", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -13,8 +13,8 @@ subroutine test()\n  deallocate(xx,yy,stat=stat, errmsg=errmsg)\n  end\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .4, 1, &xx.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .8, 1, &yy.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(4, 1, &xx.token, \\\\(void \\\\*\\\\) &xx, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(8, 1, &yy.token, \\\\(void \\\\*\\\\) &yy, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, 0B, 0B, 0.;\" 1 \"original\" } }"}, {"sha": "a83963c20cc58355451f1e79313fe85a209da7d3", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -15,8 +15,8 @@ subroutine test()\n  deallocate(xx,yy,stat=stat, errmsg=errmsg)\n  end\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .1, 1, &xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .1, 1, &yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &xx._data.token, \\\\(void \\\\*\\\\) &xx._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &yy._data.token, \\\\(void \\\\*\\\\) &yy._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;\" 1 \"original\" } }"}, {"sha": "33cda92f3e444ebf3fba22411f1986e96bddbfd0", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_3.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -16,8 +16,8 @@ subroutine test\n  deallocate(xx,yy,stat=stat, errmsg=errmsg)\n  end\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .1, 1, &xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .1, 1, &yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &xx._data.token, \\\\(void \\\\*\\\\) &xx._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &yy._data.token, \\\\(void \\\\*\\\\) &yy._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;\" 1 \"original\" } }"}, {"sha": "7ab5ab4477fa0d089b777e2f90cf0cc4c51a6df3", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -38,8 +38,9 @@\n if (any (A-B /= 0)) call abort\n end\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.1, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) b, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 0\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, _gfortran_caf_this_image \\\\\\(0\\\\\\), &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, _gfortran_caf_this_image \\\\\\(0\\\\\\), &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get_by_ref \\\\\\(caf_token.0, 1, &p, &caf_ref.\\[0-9\\]+, 4, 4, 1, 0, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get_by_ref \\\\\\(caf_token.1, 1, &p, &caf_ref.\\[0-9\\]+, 4, 4, 0, 0, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n+"}, {"sha": "bedb0919d00625cb95167340c2e6b91bb77abe96", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_token_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_3.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -8,5 +8,5 @@\n allocate(CAF_SCALAR[*])\n end\n \n-! { dg-final { scan-tree-dump-times \"caf.data = \\\\(void . restrict\\\\) _gfortran_caf_register \\\\(4, 1, &caf.token, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"caf_scalar.data = \\\\(void . restrict\\\\) _gfortran_caf_register \\\\(4, 1, &caf_scalar.token, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(4, 1, &caf.token, \\\\(void \\\\*\\\\) &caf, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(4, 1, &caf_scalar.token, \\\\(void \\\\*\\\\) &caf_scalar, 0B, 0B, 0\\\\);\" 1 \"original\" } }"}, {"sha": "10c390f1860724317cf26834b681c6cf2aa80b15", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_7.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_7.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -27,20 +27,20 @@\n unlock(four(2)[7])\n end\n \n-! { dg-final { scan-tree-dump-times \"one = \\\\(void \\\\* \\\\* restrict\\\\) _gfortran_caf_register \\\\(1, 2, \\\\(void \\\\* \\\\*\\\\) &caf_token.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"two = \\\\(void \\\\*\\\\\\[25\\\\\\] \\\\* restrict\\\\) _gfortran_caf_register \\\\(25, 2, \\\\(void \\\\* \\\\*\\\\) &caf_token.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"three.data = \\\\(void \\\\* restrict\\\\) _gfortran_caf_register \\\\(1, 3, &three.token, &stat.., 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"four.data = \\\\(void \\\\* restrict\\\\) _gfortran_caf_register \\\\(7, 3, &four.token, &stat.., 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 2, \\\\(void \\\\* \\\\*\\\\) &caf_token.., \\\\(void \\\\*\\\\) &desc.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(25, 2, \\\\(void \\\\* \\\\*\\\\) &caf_token.., \\\\(void \\\\*\\\\) &desc.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 3, &three.token, \\\\(void \\\\*\\\\) &three, &stat.., 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(7, 3, &four.token, \\\\(void \\\\*\\\\) &four, &stat.., 0B, 0\\\\);\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(caf_token.., 0, 0, 0B, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(caf_token.., 0, 0, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(caf_token.., \\\\(3 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ \\\\(integer\\\\(kind=4\\\\)\\\\) MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, 0B, &ii, 0B, 0\\\\);|_gfortran_caf_lock \\\\(caf_token.1, \\\\(3 - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, 0B, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(caf_token.., \\\\(2 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ \\\\(integer\\\\(kind=4\\\\)\\\\) MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, &ii, 0B, 0\\\\);|_gfortran_caf_unlock \\\\(caf_token.., \\\\(2 - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(three.token, 0, 5 - \\\\(integer\\\\(kind=4\\\\)\\\\) three.dim\\\\\\[0\\\\\\].lbound, &acquired.8, 0B, 0B, 0\\\\);|_gfortran_caf_lock \\\\(three.token, 0, 5 - three.dim\\\\\\[0\\\\\\].lbound, &acquired.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(three.token, 0, 5 - \\\\(integer\\\\(kind=4\\\\)\\\\) three.dim\\\\\\[0\\\\\\].lbound, &acquired.\\[0-9\\]+, 0B, 0B, 0\\\\);|_gfortran_caf_lock \\\\(three.token, 0, 5 - three.dim\\\\\\[0\\\\\\].lbound, &acquired.\\[0-9\\]+, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(three.token, 0, 8 - \\\\(integer\\\\(kind=4\\\\)\\\\) three.dim\\\\\\[0\\\\\\].lbound, &ii, 0B, 0\\\\);|_gfortran_caf_unlock \\\\(three.token, 0, 8 - three.dim\\\\\\[0\\\\\\].lbound, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(four.token, 1 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[0\\\\\\].lbound, 7 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[1\\\\\\].lbound, &acquired.., &ii, 0B, 0\\\\);|_gfortran_caf_lock \\\\(four.token, 1 - four.dim\\\\\\[0\\\\\\].lbound, 7 - four.dim\\\\\\[1\\\\\\].lbound, &acquired.., &ii, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(four.token, 1 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[0\\\\\\].lbound, 7 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[1\\\\\\].lbound, &acquired.\\[0-9\\]+, &ii, 0B, 0\\\\);|_gfortran_caf_lock \\\\(four.token, 1 - four.dim\\\\\\[0\\\\\\].lbound, 7 - four.dim\\\\\\[1\\\\\\].lbound, &acquired.\\[0-9\\]+, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(four.token, 2 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[0\\\\\\].lbound, 8 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[1\\\\\\].lbound, 0B, 0B, 0\\\\);|_gfortran_caf_unlock \\\\(four.token, 2 - four.dim\\\\\\[0\\\\\\].lbound, 8 - four.dim\\\\\\[1\\\\\\].lbound, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n "}, {"sha": "8e6142f935dfa930fe1fe1edf618006cbd57c4b1", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_5.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -10,4 +10,4 @@ subroutine test(x)\n allocate(x%x[*])\n end subroutine test\n \n-! { dg-final { scan-tree-dump-times \"x->_data->x.data = _gfortran_caf_register \\\\(4, 1, &x->_data->x.token, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(4, 1, &x->_data->x.token, \\\\(void \\\\*\\\\) &x->_data->x, 0B, 0B, 0\\\\);\" 1 \"original\" } }"}, {"sha": "53b80e442d33c55e360fc69f2f741b7360011e7d", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_6.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -18,4 +18,4 @@ end subroutine foo\n ! { dg-final { scan-tree-dump-times \"foo \\\\(struct __class_MAIN___T_0_1t & restrict x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"bar \\\\(struct __class_MAIN___T_0_1t \\\\* x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"bar \\\\(0B, 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"foo \\\\(&class.., y._data._data.token, \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) class..._data.data - \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) y._data._data.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo \\\\(&class.., y._data.token, \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) class..._data.data - \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) y._data.data\\\\);\" 1 \"original\" } }"}, {"sha": "44f98e16e09a2246e1e444e8bee3beb0858760ac", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_7.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_7.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -18,4 +18,4 @@ end subroutine foo\n ! { dg-final { scan-tree-dump-times \"foo \\\\(struct __class_MAIN___T_1_1t & restrict x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"bar \\\\(struct __class_MAIN___T_1_1t \\\\* x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"bar \\\\(0B, 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"foo \\\\(&class.., y._data._data.token, \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) class..._data.data - \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) y._data._data.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo \\\\(&class.., y._data.token, \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) class..._data.data - \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) y._data.data\\\\);\" 1 \"original\" } }"}, {"sha": "cac305f03ec636dab471a5dd983aa5656f91b72a", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_8.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -18,4 +18,4 @@ end subroutine foo\n ! { dg-final { scan-tree-dump-times \"foo \\\\(struct __class_MAIN___T_1_1t & restrict x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"bar \\\\(struct __class_MAIN___T_1_1t \\\\* x, void \\\\* restrict caf_token.., integer\\\\(kind=\\[48\\]\\\\) caf_offset..\\\\)\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"bar \\\\(0B, 0B, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"foo \\\\(&class.., y._data._data.token, \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) class..._data.data - \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) y._data._data.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"foo \\\\(&class.., y._data.token, \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) class..._data.data - \\\\(integer\\\\(kind=\\[48\\]\\\\)\\\\) y._data.data\\\\);\" 1 \"original\" } }"}, {"sha": "b25f2f83d235f9836f97f7164c411e97b9cf150f", "filename": "gcc/testsuite/gfortran.dg/coindexed_1.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoindexed_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoindexed_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoindexed_1.f90?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -14,7 +14,7 @@ program pmup\n   integer :: ii\n \n   !! --- ONE --- \n-  allocate(real :: a(3)[*])\n+  allocate(real :: a(3)[*]) ! { dg-error \"Sorry, coindexed access to an unlimited polymorphic object at\" }\n   IF (this_image() == num_images()) THEN\n     SELECT TYPE (a)\n       TYPE IS (real)\n@@ -43,11 +43,11 @@ program pmup\n \n   !! --- TWO --- \n   deallocate(a)\n-  allocate(t :: a(3)[*])\n+  allocate(t :: a(3)[*]) ! { dg-error \"Sorry, coindexed access to an unlimited polymorphic object at\" }\n   IF (this_image() == num_images()) THEN\n     SELECT TYPE (a)\n-      TYPE IS (t)     ! FIXME: When implemented, turn into \"do-do run\"\n-      a(:)[1]%a = 4.0 ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+      TYPE IS (t)\n+      a(:)[1]%a = 4.0\n     END SELECT\n   END IF\n   SYNC ALL\n@@ -57,8 +57,8 @@ program pmup\n    TYPE IS (real)\n       ii = a(1)[1]\n       call abort()\n-    TYPE IS (t)                       ! FIXME: When implemented, turn into \"do-do run\"\n-      IF (ALL(A(:)[1]%a == 4.0)) THEN ! { dg-error \"Sorry, coindexed access at \\\\(1\\\\) to a scalar component with an array partref is not yet supported\" }\n+    TYPE IS (t)\n+      IF (ALL(A(:)[1]%a == 4.0)) THEN\n         !WRITE(*,*) 'OK'\n       ELSE\n         WRITE(*,*) 'FAIL'"}, {"sha": "cb125459c87ea91e37e5beff82f18ed7b9f69efa", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -1,3 +1,37 @@\n+2016-09-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* caf/libcaf.h: Add caf_reference_type.\n+\t* caf/mpi.c: Adapted signature of caf_register().\n+\t* caf/single.c (struct caf_single_token): Added to keep the pointer\n+\tto the memory registered and array descriptor.\n+\t(caf_internal_error): Added convenience interface.\n+\t(_gfortran_caf_register): Adapted to work with caf_single_token and\n+\treturn memory in the array descriptor.\n+\t(_gfortran_caf_deregister): Same.\n+\t(assign_char1_from_char4): Fixed style.\n+\t(convert_type): Fixed incorrect conversion.\n+\t(_gfortran_caf_get): Adapted to work with caf_single_token.\n+\t(_gfortran_caf_send): Same.\n+\t(_gfortran_caf_sendget): Same.\n+\t(copy_data): Added to stop repeating it in all _by_ref functions.\n+\t(get_for_ref): Recursive getting of coarray data using a chain of\n+\treferences.\n+\t(_gfortran_caf_get_by_ref): Driver for computing the memory needed for\n+\tthe get and checking properties of the operation.\n+\t(send_by_ref): Same as get_for_ref but for sending data.\n+\t(_gfortran_caf_send_by_ref): Same like caf_get_by_ref but for sending.\n+\t(_gfortran_caf_sendget_by_ref): Uses get_by_ref and send_by_ref to\n+\timplement sendget for reference chains.\n+\t(_gfortran_caf_atomic_define): Adapted to work with caf_single_token.\n+\t(_gfortran_caf_atomic_ref): Likewise.\n+\t(_gfortran_caf_atomic_cas): Likewise.\n+\t(_gfortran_caf_atomic_op): Likewise.\n+\t(_gfortran_caf_event_post): Likewise.\n+\t(_gfortran_caf_event_wait): Likewise.\n+\t(_gfortran_caf_event_query): Likewise.\n+\t(_gfortran_caf_lock): Likewise.\n+\t(_gfortran_caf_unlock): Likewise.\n+\n 2016-09-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77507"}, {"sha": "aad0f62179507750cdbf63469bace6ed2a84583d", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -90,15 +90,90 @@ typedef struct caf_vector_t {\n }\n caf_vector_t;\n \n+typedef enum caf_ref_type_t {\n+  /* Reference a component of a derived type, either regular one or an\n+     allocatable or pointer type.  For regular ones idx in caf_reference_t is\n+     set to -1.  */\n+  CAF_REF_COMPONENT,\n+  /* Reference an allocatable array.  */\n+  CAF_REF_ARRAY,\n+  /* Reference a non-allocatable/non-pointer array.  */\n+  CAF_REF_STATIC_ARRAY\n+} caf_ref_type_t;\n+\n+typedef enum caf_array_ref_t {\n+  /* No array ref.  This terminates the array ref.  */\n+  CAF_ARR_REF_NONE = 0,\n+  /* Reference array elements given by a vector.  Only for this mode\n+     caf_reference_t.u.a.dim[i].v is valid.  */\n+  CAF_ARR_REF_VECTOR,\n+  /* A full array ref (:).  */\n+  CAF_ARR_REF_FULL,\n+  /* Reference a range on elements given by start, end and stride.  */\n+  CAF_ARR_REF_RANGE,\n+  /* Only a single item is referenced given in the start member.  */\n+  CAF_ARR_REF_SINGLE,\n+  /* An array ref of the kind (i:), where i is an arbitrary valid index in the\n+     array.  The index i is given in the start member.  */\n+  CAF_ARR_REF_OPEN_END,\n+  /* An array ref of the kind (:i), where the lower bound of the array ref\n+     is given by the remote side.  The index i is given in the end member.  */\n+  CAF_ARR_REF_OPEN_START\n+} caf_array_ref_t;\n+\n+/* References to remote components of a derived type.  */\n+typedef struct caf_reference_t {\n+  /* A pointer to the next ref or NULL.  */\n+  struct caf_reference_t *next;\n+  /* The type of the reference.  */\n+  /* caf_ref_type_t, replaced by int to allow specification in fortran FE.  */\n+  int type;\n+  /* The size of an item referenced in bytes.  I.e. in an array ref this is\n+     the factor to advance the array pointer with to get to the next item.\n+     For component refs this gives just the size of the element referenced.  */\n+  size_t item_size;\n+  union {\n+    struct {\n+      /* The offset (in bytes) of the component in the derived type.  */\n+      ptrdiff_t offset;\n+      /* The offset (in bytes) to the caf_token associated with this\n+\t component.  NULL, when not allocatable/pointer ref.  */\n+      ptrdiff_t caf_token_offset;\n+    } c;\n+    struct {\n+      /* The mode of the array ref.  See CAF_ARR_REF_*.  */\n+      /* caf_array_ref_t, replaced by unsigend char to allow specification in\n+\t fortran FE.  */\n+      unsigned char mode[GFC_MAX_DIMENSIONS];\n+      /* The type of a static array.  Unset for array's with descriptors.  */\n+      int static_array_type;\n+      /* Subscript refs (s) or vector refs (v).  */\n+      union {\n+\tstruct {\n+\t  /* The start and end boundary of the ref and the stride.  */\n+\t  index_type start, end, stride;\n+\t} s;\n+\tstruct {\n+\t  /* nvec entries of kind giving the elements to reference.  */\n+\t  void *vector;\n+\t  /* The number of entries in vector.  */\n+\t  size_t nvec;\n+\t  /* The integer kind used for the elements in vector.  */\n+\t  int kind;\n+\t} v;\n+      } dim[GFC_MAX_DIMENSIONS];\n+    } a;\n+  } u;\n+} caf_reference_t;\n \n void _gfortran_caf_init (int *, char ***);\n void _gfortran_caf_finalize (void);\n \n int _gfortran_caf_this_image (int);\n int _gfortran_caf_num_images (int, int);\n \n-void *_gfortran_caf_register (size_t, caf_register_t, caf_token_t *, int *,\n-\t\t\t      char *, int);\n+void _gfortran_caf_register (size_t, caf_register_t, caf_token_t *,\n+\t\t\t     gfc_descriptor_t *, int *, char *, int);\n void _gfortran_caf_deregister (caf_token_t *, int *, char *, int);\n \n void _gfortran_caf_sync_all (int *, char *, int);\n@@ -130,6 +205,18 @@ void _gfortran_caf_sendget (caf_token_t, size_t, int, gfc_descriptor_t *,\n \t\t\t    caf_vector_t *, caf_token_t, size_t, int,\n \t\t\t    gfc_descriptor_t *, caf_vector_t *, int, int, bool);\n \n+void _gfortran_caf_get_by_ref (caf_token_t token, int image_idx,\n+\tgfc_descriptor_t *dst, caf_reference_t *refs, int dst_kind,\n+\tint src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat);\n+void _gfortran_caf_send_by_ref (caf_token_t token, int image_index,\n+\tgfc_descriptor_t *src, caf_reference_t *refs, int dst_kind,\n+\tint src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat);\n+void _gfortran_caf_sendget_by_ref (\n+\tcaf_token_t dst_token, int dst_image_index, caf_reference_t *dst_refs,\n+\tcaf_token_t src_token, int src_image_index, caf_reference_t *src_refs,\n+\tint dst_kind, int src_kind, bool may_require_tmp, int *dst_stat,\n+\tint *src_stat);\n+\n void _gfortran_caf_atomic_define (caf_token_t, size_t, int, void *, int *,\n \t\t\t\t  int, int);\n void _gfortran_caf_atomic_ref (caf_token_t, size_t, int, void *, int *,"}, {"sha": "1e9a477c233cac64e408553bc8327e2ba95b3aea", "filename": "libgfortran/caf/mpi.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2Fcaf%2Fmpi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2Fcaf%2Fmpi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fmpi.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -131,7 +131,8 @@ _gfortran_caf_num_images (int distance __attribute__ ((unused)),\n \n void *\n _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n-\t\t\tint *stat, char *errmsg, int errmsg_len)\n+\t\t\tint *stat, char *errmsg, int errmsg_len,\n+\t\t\tint num_alloc_comps __attribute__ ((unused)))\n {\n   void *local;\n   int err;"}, {"sha": "c47244602904dad0fdf612ff14c709a2f7b2a0af", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 1709, "deletions": 46, "changes": 1755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f5092c6d30a459e06b7db3f0796a1175e2ecc/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=3c9f5092c6d30a459e06b7db3f0796a1175e2ecc", "patch": "@@ -33,8 +33,21 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Define GFC_CAF_CHECK to enable run-time checking.  */\n /* #define GFC_CAF_CHECK  1  */\n \n-typedef void* single_token_t;\n-#define TOKEN(X) ((single_token_t) (X))\n+struct caf_single_token\n+{\n+  /* The pointer to the memory registered.  For arrays this is the data member\n+     in the descriptor.  For components it's the pure data pointer.  */\n+  void *memptr;\n+  /* The descriptor when this token is associated to an allocatable array.  */\n+  gfc_descriptor_t *desc;\n+  /* Set when the caf lib has allocated the memory in memptr and is responsible\n+     for freeing it on deregister.  */\n+  bool owning_memory;\n+};\n+typedef struct caf_single_token *caf_single_token_t;\n+\n+#define TOKEN(X) ((caf_single_token_t) (X))\n+#define MEMTOK(X) ((caf_single_token_t) (X))->memptr\n \n /* Single-image implementation of the CAF library.\n    Note: For performance reasons -fcoarry=single should be used\n@@ -43,7 +56,6 @@ typedef void* single_token_t;\n /* Global variables.  */\n caf_static_t *caf_static_list = NULL;\n \n-\n /* Keep in sync with mpi.c.  */\n static void\n caf_runtime_error (const char *message, ...)\n@@ -59,6 +71,30 @@ caf_runtime_error (const char *message, ...)\n   exit (EXIT_FAILURE);\n }\n \n+/* Error handling is similar everytime.  */\n+static void\n+caf_internal_error (const char *msg, int *stat, char *errmsg,\n+\t\t    int errmsg_len, ...)\n+{\n+  va_list args;\n+  va_start (args, errmsg_len);\n+  if (stat)\n+    {\n+      *stat = 1;\n+      if (errmsg_len > 0)\n+\t{\n+\t  size_t len = snprintf (errmsg, errmsg_len, msg, args);\n+\t  if ((size_t)errmsg_len > len)\n+\t    memset (&errmsg[len], ' ', errmsg_len - len);\n+\t}\n+      return;\n+    }\n+  else\n+    caf_runtime_error (msg, args);\n+  va_end (args);\n+}\n+\n+\n void\n _gfortran_caf_init (int *argc __attribute__ ((unused)),\n \t\t    char ***argv __attribute__ ((unused)))\n@@ -94,41 +130,34 @@ _gfortran_caf_num_images (int distance __attribute__ ((unused)),\n }\n \n \n-void *\n+void\n _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n-\t\t\tint *stat, char *errmsg, int errmsg_len)\n+\t\t\tgfc_descriptor_t *data, int *stat, char *errmsg,\n+\t\t\tint errmsg_len)\n {\n+  const char alloc_fail_msg[] = \"Failed to allocate coarray\";\n   void *local;\n+  caf_single_token_t single_token;\n \n   if (type == CAF_REGTYPE_LOCK_STATIC || type == CAF_REGTYPE_LOCK_ALLOC\n       || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC\n       || type == CAF_REGTYPE_EVENT_ALLOC)\n     local = calloc (size, sizeof (bool));\n   else\n     local = malloc (size);\n-  *token = malloc (sizeof (single_token_t));\n+  *token = malloc (sizeof (struct caf_single_token));\n \n-  if (unlikely (local == NULL || token == NULL))\n+  if (unlikely (local == NULL || *token == NULL))\n     {\n-      const char msg[] = \"Failed to allocate coarray\";\n-      if (stat)\n-\t{\n-\t  *stat = 1;\n-\t  if (errmsg_len > 0)\n-\t    {\n-\t      int len = ((int) sizeof (msg) > errmsg_len) ? errmsg_len\n-\t\t\t\t\t\t\t  : (int) sizeof (msg);\n-\t      memcpy (errmsg, msg, len);\n-\t      if (errmsg_len > len)\n-\t\tmemset (&errmsg[len], ' ', errmsg_len-len);\n-\t    }\n-\t  return NULL;\n-\t}\n-      else\n-\t  caf_runtime_error (msg);\n+      caf_internal_error (alloc_fail_msg, stat, errmsg, errmsg_len);\n+      return;\n     }\n \n-  *token = local;\n+  single_token = TOKEN (*token);\n+  single_token->memptr = local;\n+  single_token->owning_memory = true;\n+  single_token->desc = GFC_DESCRIPTOR_RANK (data) > 0 ? data : NULL;\n+\n \n   if (stat)\n     *stat = 0;\n@@ -142,7 +171,7 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n       tmp->token = *token;\n       caf_static_list = tmp;\n     }\n-  return local;\n+  GFC_DESCRIPTOR_DATA (data) = local;\n }\n \n \n@@ -151,7 +180,12 @@ _gfortran_caf_deregister (caf_token_t *token, int *stat,\n \t\t\t  char *errmsg __attribute__ ((unused)),\n \t\t\t  int errmsg_len __attribute__ ((unused)))\n {\n-  free (TOKEN(*token));\n+  caf_single_token_t single_token = TOKEN (*token);\n+\n+  if (single_token->owning_memory && single_token->memptr)\n+    free (single_token->memptr);\n+\n+  free (TOKEN (*token));\n \n   if (stat)\n     *stat = 0;\n@@ -322,7 +356,7 @@ assign_char1_from_char4 (size_t dst_size, size_t src_size, unsigned char *dst,\n   for (i = 0; i < n; ++i)\n     dst[i] = src[i] > UINT8_MAX ? (unsigned char) '?' : (unsigned char) src[i];\n   if (dst_size > n)\n-    memset(&dst[n], ' ', dst_size - n);\n+    memset (&dst[n], ' ', dst_size - n);\n }\n \n \n@@ -465,7 +499,7 @@ convert_type (void *dst, int dst_type, int dst_kind, void *src, int src_type,\n \t}\n       else\n \tgoto error;\n-      break;\n+      return;\n     case BT_REAL:\n       if (src_type == BT_INTEGER)\n \t{\n@@ -518,7 +552,7 @@ convert_type (void *dst, int dst_type, int dst_kind, void *src, int src_type,\n \t  else\n \t    goto error;\n \t}\n-      break;\n+      return;\n     case BT_COMPLEX:\n       if (src_type == BT_INTEGER)\n \t{\n@@ -573,7 +607,7 @@ convert_type (void *dst, int dst_type, int dst_kind, void *src, int src_type,\n \t}\n       else\n \tgoto error;\n-      break;\n+      return;\n     default:\n       goto error;\n     }\n@@ -608,7 +642,7 @@ _gfortran_caf_get (caf_token_t token, size_t offset,\n \n   if (rank == 0)\n     {\n-      void *sr = (void *) ((char *) TOKEN (token) + offset);\n+      void *sr = (void *) ((char *) MEMTOK (token) + offset);\n       if (GFC_DESCRIPTOR_TYPE (dest) == GFC_DESCRIPTOR_TYPE (src)\n \t  && dst_kind == src_kind)\n \t{\n@@ -669,7 +703,7 @@ _gfortran_caf_get (caf_token_t token, size_t offset,\n \t      stride = src->dim[j]._stride;\n \t    }\n \t  array_offset_sr += (i / extent) * src->dim[rank-1]._stride;\n-\t  void *sr = (void *)((char *) TOKEN (token) + offset\n+\t  void *sr = (void *)((char *) MEMTOK (token) + offset\n \t\t\t  + array_offset_sr*GFC_DESCRIPTOR_SIZE (src));\n           memcpy ((void *) ((char *) tmp + array_offset_dst), sr, src_size);\n           array_offset_dst += src_size;\n@@ -754,7 +788,7 @@ _gfortran_caf_get (caf_token_t token, size_t offset,\n \t  stride = src->dim[j]._stride;\n \t}\n       array_offset_sr += (i / extent) * src->dim[rank-1]._stride;\n-      void *sr = (void *)((char *) TOKEN (token) + offset\n+      void *sr = (void *)((char *) MEMTOK (token) + offset\n \t\t\t  + array_offset_sr*GFC_DESCRIPTOR_SIZE (src));\n \n       if (GFC_DESCRIPTOR_TYPE (dest) == GFC_DESCRIPTOR_TYPE (src)\n@@ -801,7 +835,7 @@ _gfortran_caf_send (caf_token_t token, size_t offset,\n \n   if (rank == 0)\n     {\n-      void *dst = (void *) ((char *) TOKEN (token) + offset);\n+      void *dst = (void *) ((char *) MEMTOK (token) + offset);\n       if (GFC_DESCRIPTOR_TYPE (dest) == GFC_DESCRIPTOR_TYPE (src)\n \t  && dst_kind == src_kind)\n \t{\n@@ -893,7 +927,7 @@ _gfortran_caf_send (caf_token_t token, size_t offset,\n           stride = dest->dim[j]._stride;\n \t    }\n \t  array_offset_dst += (i / extent) * dest->dim[rank-1]._stride;\n-\t  void *dst = (void *)((char *) TOKEN (token) + offset\n+\t  void *dst = (void *)((char *) MEMTOK (token) + offset\n \t\t      + array_offset_dst*GFC_DESCRIPTOR_SIZE (dest));\n           void *sr = tmp + array_offset_sr;\n \t  if (GFC_DESCRIPTOR_TYPE (dest) == GFC_DESCRIPTOR_TYPE (src)\n@@ -941,7 +975,7 @@ _gfortran_caf_send (caf_token_t token, size_t offset,\n           stride = dest->dim[j]._stride;\n \t}\n       array_offset_dst += (i / extent) * dest->dim[rank-1]._stride;\n-      void *dst = (void *)((char *) TOKEN (token) + offset\n+      void *dst = (void *)((char *) MEMTOK (token) + offset\n \t\t\t   + array_offset_dst*GFC_DESCRIPTOR_SIZE (dest));\n       void *sr;\n       if (GFC_DESCRIPTOR_RANK (src) != 0)\n@@ -1004,13 +1038,1639 @@ _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n   /* For a single image, src->base_addr should be the same as src_token + offset\n      but to play save, we do it properly.  */\n   void *src_base = GFC_DESCRIPTOR_DATA (src);\n-  GFC_DESCRIPTOR_DATA (src) = (void *) ((char *) TOKEN (src_token) + src_offset);\n+  GFC_DESCRIPTOR_DATA (src) = (void *) ((char *) MEMTOK (src_token)\n+\t\t\t\t\t+ src_offset);\n   _gfortran_caf_send (dst_token, dst_offset, dst_image_index, dest, dst_vector,\n \t\t      src, dst_kind, src_kind, may_require_tmp, NULL);\n   GFC_DESCRIPTOR_DATA (src) = src_base;\n }\n \n \n+/* Emitted when a theorectically unreachable part is reached.  */\n+const char unreachable[] = \"Fatal error: unreachable alternative found.\\n\";\n+\n+\n+static void\n+copy_data (void *ds, void *sr, int dst_type, int src_type,\n+\t   int dst_kind, int src_kind, size_t dst_size, size_t src_size,\n+\t   size_t num, int *stat)\n+{\n+  size_t k;\n+  if (dst_type == src_type && dst_kind == src_kind)\n+    {\n+      memmove (ds, sr, (dst_size > src_size ? src_size : dst_size) * num);\n+      if ((dst_type == BT_CHARACTER || src_type == BT_CHARACTER)\n+\t  && dst_size > src_size)\n+\t{\n+\t  if (dst_kind == 1)\n+\t    memset ((void*)(char*) ds + src_size, ' ', dst_size-src_size);\n+\t  else /* dst_kind == 4.  */\n+\t    for (k = src_size/4; k < dst_size/4; k++)\n+\t      ((int32_t*) ds)[k] = (int32_t) ' ';\n+\t}\n+    }\n+  else if (dst_type == BT_CHARACTER && dst_kind == 1)\n+    assign_char1_from_char4 (dst_size, src_size, ds, sr);\n+  else if (dst_type == BT_CHARACTER)\n+    assign_char4_from_char1 (dst_size, src_size, ds, sr);\n+  else\n+    for (k = 0; k < num; ++k)\n+      {\n+\tconvert_type (ds, dst_type, dst_kind, sr, src_type, src_kind, stat);\n+\tds += dst_size;\n+\tsr += src_size;\n+      }\n+}\n+\n+\n+#define COMPUTE_NUM_ITEMS(num, stride, lb, ub) \\\n+  do { \\\n+    index_type abs_stride = (stride) > 0 ? (stride) : -(stride); \\\n+    num = (stride) > 0 ? (ub) + 1 - (lb) : (lb) + 1 - (ub); \\\n+    if (num <= 0 || abs_stride < 1) return; \\\n+    num = (abs_stride > 1) ? (1 + (num - 1) / abs_stride) : num; \\\n+  } while (0)\n+\n+\n+static void\n+get_for_ref (caf_reference_t *ref, size_t *i, size_t *dst_index,\n+\t     caf_single_token_t single_token, gfc_descriptor_t *dst,\n+\t     gfc_descriptor_t *src, void *ds, void *sr,\n+\t     int dst_kind, int src_kind, size_t dst_dim, size_t src_dim,\n+\t     size_t num, int *stat)\n+{\n+  ptrdiff_t extent_src = 1, array_offset_src = 0, stride_src;\n+  size_t next_dst_dim;\n+\n+  if (unlikely (ref == NULL))\n+    /* May be we should issue an error here, because this case should not\n+       occur.  */\n+    return;\n+\n+  if (ref->next == NULL)\n+    {\n+      size_t dst_size = GFC_DESCRIPTOR_SIZE (dst);\n+      ptrdiff_t array_offset_dst = 0;;\n+      size_t dst_rank = GFC_DESCRIPTOR_RANK (dst);\n+      int src_type = -1;\n+\n+      switch (ref->type)\n+\t{\n+\tcase CAF_REF_COMPONENT:\n+\t  /* Because the token is always registered after the component, its\n+\t     offset is always greater zeor.  */\n+\t  if (ref->u.c.caf_token_offset > 0)\n+\t    copy_data (ds, *(void **)(sr + ref->u.c.offset),\n+\t\t       GFC_DESCRIPTOR_TYPE (dst), GFC_DESCRIPTOR_TYPE (dst),\n+\t\t       dst_kind, src_kind, dst_size, ref->item_size, 1, stat);\n+\t  else\n+\t    copy_data (ds, sr + ref->u.c.offset,\n+\t\t       GFC_DESCRIPTOR_TYPE (dst), GFC_DESCRIPTOR_TYPE (src),\n+\t\t       dst_kind, src_kind, dst_size, ref->item_size, 1, stat);\n+\t  ++(*i);\n+\t  return;\n+\tcase CAF_REF_STATIC_ARRAY:\n+\t  src_type = ref->u.a.static_array_type;\n+\t  /* Intentionally fall through.  */\n+\tcase CAF_REF_ARRAY:\n+\t  if (ref->u.a.mode[src_dim] == CAF_ARR_REF_NONE)\n+\t    {\n+\t      for (size_t d = 0; d < dst_rank; ++d)\n+\t\tarray_offset_dst += dst_index[d];\n+\t      copy_data (ds + array_offset_dst * dst_size, sr,\n+\t\t\t GFC_DESCRIPTOR_TYPE (dst),\n+\t\t\t src_type == -1 ? GFC_DESCRIPTOR_TYPE (src) : src_type,\n+\t\t\t dst_kind, src_kind, dst_size, ref->item_size, num,\n+\t\t\t stat);\n+\t      *i += num;\n+\t      return;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  caf_runtime_error (unreachable);\n+\t}\n+    }\n+\n+  switch (ref->type)\n+    {\n+    case CAF_REF_COMPONENT:\n+      if (ref->u.c.caf_token_offset > 0)\n+\tget_for_ref (ref->next, i, dst_index,\n+\t\t    *(caf_single_token_t*)(sr + ref->u.c.caf_token_offset), dst,\n+\t\t (*(caf_single_token_t*)(sr + ref->u.c.caf_token_offset))->desc,\n+\t\t     ds, sr + ref->u.c.offset, dst_kind, src_kind, dst_dim, 0,\n+\t\t     1, stat);\n+      else\n+\tget_for_ref (ref->next, i, dst_index, single_token, dst,\n+\t\t     (gfc_descriptor_t *)(sr + ref->u.c.offset), ds,\n+\t\t     sr + ref->u.c.offset, dst_kind, src_kind, dst_dim, 0, 1,\n+\t\t     stat);\n+      return;\n+    case CAF_REF_ARRAY:\n+      if (ref->u.a.mode[src_dim] == CAF_ARR_REF_NONE)\n+\t{\n+\t  get_for_ref (ref->next, i, dst_index, single_token, dst,\n+\t\t       src, ds, sr, dst_kind, src_kind,\n+\t\t       dst_dim, 0, 1, stat);\n+\t  return;\n+\t}\n+      /* Only when on the left most index switch the data pointer to\n+\t the array's data pointer.  */\n+      if (src_dim == 0)\n+\tsr = GFC_DESCRIPTOR_DATA (src);\n+      switch (ref->u.a.mode[src_dim])\n+\t{\n+\tcase CAF_ARR_REF_VECTOR:\n+\t  extent_src = GFC_DIMENSION_EXTENT (src->dim[src_dim]);\n+\t  array_offset_src = 0;\n+\t  dst_index[dst_dim] = 0;\n+\t  for (size_t idx = 0; idx < ref->u.a.dim[src_dim].v.nvec;\n+\t       ++idx)\n+\t    {\n+#define KINDCASE(kind, type) case kind: \\\n+\t      array_offset_src = (((index_type) \\\n+\t\t  ((type *)ref->u.a.dim[src_dim].v.vector)[idx]) \\\n+\t\t  - GFC_DIMENSION_LBOUND (src->dim[src_dim])) \\\n+\t\t  * GFC_DIMENSION_STRIDE (src->dim[src_dim]); \\\n+\t      break\n+\n+\t      switch (ref->u.a.dim[src_dim].v.kind)\n+\t\t{\n+\t\tKINDCASE (1, GFC_INTEGER_1);\n+\t\tKINDCASE (2, GFC_INTEGER_2);\n+\t\tKINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\tKINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\tKINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\tdefault:\n+\t\t  caf_runtime_error (unreachable);\n+\t\t  return;\n+\t\t}\n+#undef KINDCASE\n+\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_FULL:\n+\t  COMPUTE_NUM_ITEMS (extent_src,\n+\t\t\t     ref->u.a.dim[src_dim].s.stride,\n+\t\t\t     GFC_DIMENSION_LBOUND (src->dim[src_dim]),\n+\t\t\t     GFC_DIMENSION_UBOUND (src->dim[src_dim]));\n+\t  stride_src = src->dim[src_dim]._stride\n+\t      * ref->u.a.dim[src_dim].s.stride;\n+\t  array_offset_src = 0;\n+\t  dst_index[dst_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_src;\n+\t       ++idx, array_offset_src += stride_src)\n+\t    {\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_RANGE:\n+\t  COMPUTE_NUM_ITEMS (extent_src,\n+\t\t\t     ref->u.a.dim[src_dim].s.stride,\n+\t\t\t     ref->u.a.dim[src_dim].s.start,\n+\t\t\t     ref->u.a.dim[src_dim].s.end);\n+\t  array_offset_src = (ref->u.a.dim[src_dim].s.start\n+\t\t\t      - GFC_DIMENSION_LBOUND (src->dim[src_dim]))\n+\t      * GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t  stride_src = GFC_DIMENSION_STRIDE (src->dim[src_dim])\n+\t      * ref->u.a.dim[src_dim].s.stride;\n+\t  dst_index[dst_dim] = 0;\n+\t  /* Increase the dst_dim only, when the src_extent is greater one\n+\t     or src and dst extent are both one.  Don't increase when the scalar\n+\t     source is not present in the dst.  */\n+\t  next_dst_dim = extent_src > 1\n+\t      || (GFC_DIMENSION_EXTENT (dst->dim[dst_dim]) == 1\n+\t\t  && extent_src == 1) ? (dst_dim + 1) : dst_dim;\n+\t  for (index_type idx = 0; idx < extent_src; ++idx)\n+\t    {\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, next_dst_dim, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t      array_offset_src += stride_src;\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_SINGLE:\n+\t  array_offset_src = (ref->u.a.dim[src_dim].s.start\n+\t\t\t      - src->dim[src_dim].lower_bound)\n+\t      * GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t  dst_index[dst_dim] = 0;\n+\t  get_for_ref (ref, i, dst_index, single_token, dst, src, ds,\n+\t\t       sr + array_offset_src * ref->item_size,\n+\t\t       dst_kind, src_kind, dst_dim, src_dim + 1, 1,\n+\t\t       stat);\n+\t  return;\n+\tcase CAF_ARR_REF_OPEN_END:\n+\t  COMPUTE_NUM_ITEMS (extent_src,\n+\t\t\t     ref->u.a.dim[src_dim].s.stride,\n+\t\t\t     ref->u.a.dim[src_dim].s.start,\n+\t\t\t     GFC_DIMENSION_UBOUND (src->dim[src_dim]));\n+\t  stride_src = GFC_DIMENSION_STRIDE (src->dim[src_dim])\n+\t      * ref->u.a.dim[src_dim].s.stride;\n+\t  array_offset_src = (ref->u.a.dim[src_dim].s.start\n+\t\t\t      - GFC_DIMENSION_LBOUND (src->dim[src_dim]))\n+\t      * GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t  dst_index[dst_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_src; ++idx)\n+\t    {\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t      array_offset_src += stride_src;\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_OPEN_START:\n+\t  COMPUTE_NUM_ITEMS (extent_src,\n+\t\t\t     ref->u.a.dim[src_dim].s.stride,\n+\t\t\t     GFC_DIMENSION_LBOUND (src->dim[src_dim]),\n+\t\t\t     ref->u.a.dim[src_dim].s.end);\n+\t  stride_src = GFC_DIMENSION_STRIDE (src->dim[src_dim])\n+\t      * ref->u.a.dim[src_dim].s.stride;\n+\t  array_offset_src = 0;\n+\t  dst_index[dst_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_src; ++idx)\n+\t    {\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, src,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t      array_offset_src += stride_src;\n+\t    }\n+\t  return;\n+\tdefault:\n+\t  caf_runtime_error (unreachable);\n+\t}\n+      return;\n+    case CAF_REF_STATIC_ARRAY:\n+      if (ref->u.a.mode[src_dim] == CAF_ARR_REF_NONE)\n+\t{\n+\t  get_for_ref (ref->next, i, dst_index, single_token, dst,\n+\t\t       NULL, ds, sr, dst_kind, src_kind,\n+\t\t       dst_dim, 0, 1, stat);\n+\t  return;\n+\t}\n+      switch (ref->u.a.mode[src_dim])\n+\t{\n+\tcase CAF_ARR_REF_VECTOR:\n+\t  array_offset_src = 0;\n+\t  dst_index[dst_dim] = 0;\n+\t  for (size_t idx = 0; idx < ref->u.a.dim[src_dim].v.nvec;\n+\t       ++idx)\n+\t    {\n+#define KINDCASE(kind, type) case kind: \\\n+\t     array_offset_src = ((type *)ref->u.a.dim[src_dim].v.vector)[idx]; \\\n+\t      break\n+\n+\t      switch (ref->u.a.dim[src_dim].v.kind)\n+\t\t{\n+\t\tKINDCASE (1, GFC_INTEGER_1);\n+\t\tKINDCASE (2, GFC_INTEGER_2);\n+\t\tKINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\tKINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\tKINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\tdefault:\n+\t\t  caf_runtime_error (unreachable);\n+\t\t  return;\n+\t\t}\n+#undef KINDCASE\n+\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, NULL,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_FULL:\n+\t  dst_index[dst_dim] = 0;\n+\t  for (array_offset_src = 0 ;\n+\t       array_offset_src <= ref->u.a.dim[src_dim].s.end;\n+\t       array_offset_src += ref->u.a.dim[src_dim].s.stride)\n+\t    {\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, NULL,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_RANGE:\n+\t  COMPUTE_NUM_ITEMS (extent_src,\n+\t\t\t     ref->u.a.dim[src_dim].s.stride,\n+\t\t\t     ref->u.a.dim[src_dim].s.start,\n+\t\t\t     ref->u.a.dim[src_dim].s.end);\n+\t  array_offset_src = ref->u.a.dim[src_dim].s.start;\n+\t  dst_index[dst_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_src; ++idx)\n+\t    {\n+\t      get_for_ref (ref, i, dst_index, single_token, dst, NULL,\n+\t\t\t   ds, sr + array_offset_src * ref->item_size,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, stat);\n+\t      dst_index[dst_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t      array_offset_src += ref->u.a.dim[src_dim].s.stride;\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_SINGLE:\n+\t  array_offset_src = ref->u.a.dim[src_dim].s.start;\n+\t  get_for_ref (ref, i, dst_index, single_token, dst, NULL, ds,\n+\t\t       sr + array_offset_src * ref->item_size,\n+\t\t       dst_kind, src_kind, dst_dim, src_dim + 1, 1,\n+\t\t       stat);\n+\t  return;\n+\t/* The OPEN_* are mapped to a RANGE and therefore can not occur.  */\n+\tcase CAF_ARR_REF_OPEN_END:\n+\tcase CAF_ARR_REF_OPEN_START:\n+\tdefault:\n+\t  caf_runtime_error (unreachable);\n+\t}\n+      return;\n+    default:\n+      caf_runtime_error (unreachable);\n+    }\n+}\n+\n+\n+void\n+_gfortran_caf_get_by_ref (caf_token_t token,\n+\t\t\t  int image_index __attribute__ ((unused)),\n+\t\t\t  gfc_descriptor_t *dst, caf_reference_t *refs,\n+\t\t\t  int dst_kind, int src_kind,\n+\t\t\t  bool may_require_tmp __attribute__ ((unused)),\n+\t\t\t  bool dst_reallocatable, int *stat)\n+{\n+  const char vecrefunknownkind[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t   \"unknown kind in vector-ref.\\n\";\n+  const char unknownreftype[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t\"unknown reference type.\\n\";\n+  const char unknownarrreftype[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t   \"unknown array reference type.\\n\";\n+  const char rankoutofrange[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t\"rank out of range.\\n\";\n+  const char extentoutofrange[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t  \"extent out of range.\\n\";\n+  const char cannotallocdst[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t\"can not allocate memory.\\n\";\n+  const char nonallocextentmismatch[] = \"libcaf_single::caf_get_by_ref(): \"\n+      \"extent of non-allocatable arrays mismatch (%lu != %lu).\\n\";\n+  const char doublearrayref[] = \"libcaf_single::caf_get_by_ref(): \"\n+      \"two or more array part references are not supported.\\n\";\n+  size_t size, i;\n+  size_t dst_index[GFC_MAX_DIMENSIONS];\n+  int dst_rank = GFC_DESCRIPTOR_RANK (dst);\n+  int dst_cur_dim = 0;\n+  size_t src_size;\n+  caf_single_token_t single_token = TOKEN (token);\n+  void *memptr = single_token->memptr;\n+  gfc_descriptor_t *src = single_token->desc;\n+  caf_reference_t *riter = refs;\n+  long delta;\n+  /* Reallocation of dst.data is needed (e.g., array to small).  */\n+  bool realloc_needed;\n+  /* Reallocation of dst.data is required, because data is not alloced at\n+     all.  */\n+  bool realloc_required;\n+  bool extent_mismatch = false;\n+  /* Set when the first non-scalar array reference is encountered.  */\n+  bool in_array_ref = false;\n+  bool array_extent_fixed = false;\n+  realloc_needed = realloc_required = GFC_DESCRIPTOR_DATA (dst) == NULL;\n+\n+  assert (!realloc_needed || (realloc_needed && dst_reallocatable));\n+\n+  if (stat)\n+    *stat = 0;\n+\n+  /* Compute the size of the result.  In the beginning size just counts the\n+     number of elements.  */\n+  size = 1;\n+  while (riter)\n+    {\n+      switch (riter->type)\n+\t{\n+\tcase CAF_REF_COMPONENT:\n+\t  if (riter->u.c.caf_token_offset)\n+\t    {\n+\t      single_token = *(caf_single_token_t*)\n+\t\t\t\t\t (memptr + riter->u.c.caf_token_offset);\n+\t      memptr = single_token->memptr;\n+\t      src = single_token->desc;\n+\t    }\n+\t  else\n+\t    {\n+\t      memptr += riter->u.c.offset;\n+\t      src = (gfc_descriptor_t *)memptr;\n+\t    }\n+\t  break;\n+\tcase CAF_REF_ARRAY:\n+\t  for (i = 0; riter->u.a.mode[i] != CAF_ARR_REF_NONE; ++i)\n+\t    {\n+\t      switch (riter->u.a.mode[i])\n+\t\t{\n+\t\tcase CAF_ARR_REF_VECTOR:\n+\t\t  delta = riter->u.a.dim[i].v.nvec;\n+#define KINDCASE(kind, type) case kind: \\\n+\t\t    memptr += (((index_type) \\\n+\t\t\t((type *)riter->u.a.dim[i].v.vector)[0]) \\\n+\t\t\t- GFC_DIMENSION_LBOUND (src->dim[i])) \\\n+\t\t\t* GFC_DIMENSION_STRIDE (src->dim[i]) \\\n+\t\t\t* riter->item_size; \\\n+\t\t    break\n+\n+\t\t  switch (riter->u.a.dim[i].v.kind)\n+\t\t    {\n+\t\t    KINDCASE (1, GFC_INTEGER_1);\n+\t\t    KINDCASE (2, GFC_INTEGER_2);\n+\t\t    KINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\t    KINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\t    KINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\t    default:\n+\t\t      caf_internal_error (vecrefunknownkind, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+#undef KINDCASE\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_FULL:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     GFC_DIMENSION_LBOUND (src->dim[i]),\n+\t\t\t\t     GFC_DIMENSION_UBOUND (src->dim[i]));\n+\t\t  /* The memptr stays unchanged when ref'ing the first element\n+\t\t     in a dimension.  */\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_RANGE:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     riter->u.a.dim[i].s.start,\n+\t\t\t\t     riter->u.a.dim[i].s.end);\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - GFC_DIMENSION_LBOUND (src->dim[i]))\n+\t\t      * GFC_DIMENSION_STRIDE (src->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_SINGLE:\n+\t\t  delta = 1;\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - GFC_DIMENSION_LBOUND (src->dim[i]))\n+\t\t      * GFC_DIMENSION_STRIDE (src->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_OPEN_END:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     riter->u.a.dim[i].s.start,\n+\t\t\t\t     GFC_DIMENSION_UBOUND (src->dim[i]));\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - GFC_DIMENSION_LBOUND (src->dim[i]))\n+\t\t      * GFC_DIMENSION_STRIDE (src->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_OPEN_START:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     GFC_DIMENSION_LBOUND (src->dim[i]),\n+\t\t\t\t     riter->u.a.dim[i].s.end);\n+\t\t  /* The memptr stays unchanged when ref'ing the first element\n+\t\t     in a dimension.  */\n+\t\t  break;\n+\t\tdefault:\n+\t\t  caf_internal_error (unknownarrreftype, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+\t      if (delta <= 0)\n+\t\treturn;\n+\t      /* Check the various properties of the destination array.\n+\t\t Is an array expected and present?  */\n+\t      if (delta > 1 && dst_rank == 0)\n+\t\t{\n+\t\t  /* No, an array is required, but not provided.  */\n+\t\t  caf_internal_error (extentoutofrange, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+\t      /* When dst is an array.  */\n+\t      if (dst_rank > 0)\n+\t\t{\n+\t\t  /* Check that dst_cur_dim is valid for dst.  Can be\n+\t\t     superceeded only by scalar data.  */\n+\t\t  if (dst_cur_dim >= dst_rank && delta != 1)\n+\t\t    {\n+\t\t      caf_internal_error (rankoutofrange, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+\t\t  /* Do further checks, when the source is not scalar.  */\n+\t\t  else if (delta != 1)\n+\t\t    {\n+\t\t      /* Check that the extent is not scalar and we are not in\n+\t\t\t an array ref for the dst side.  */\n+\t\t      if (!in_array_ref)\n+\t\t\t{\n+\t\t\t  /* Check that this is the non-scalar extent.  */\n+\t\t\t  if (!array_extent_fixed)\n+\t\t\t    {\n+\t\t\t      /* In an array extent now.  */\n+\t\t\t      in_array_ref = true;\n+\t\t\t      /* Check that we haven't skipped any scalar\n+\t\t\t\t dimensions yet and that the dst is\n+\t\t\t\t compatible.  */\n+\t\t\t      if (i > 0\n+\t\t\t\t  && dst_rank == GFC_DESCRIPTOR_RANK (src))\n+\t\t\t\t{\n+\t\t\t\t  if (dst_reallocatable)\n+\t\t\t\t    {\n+\t\t\t\t      /* Dst is reallocatable, which means that\n+\t\t\t\t\t the bounds are not set.  Set them.  */\n+\t\t\t\t      for (dst_cur_dim= 0; dst_cur_dim < (int)i;\n+\t\t\t\t\t   ++dst_cur_dim)\n+\t\t\t\t       GFC_DIMENSION_SET (dst->dim[dst_cur_dim],\n+\t\t\t\t\t\t\t  1, 1, 1);\n+\t\t\t\t    }\n+\t\t\t\t  else\n+\t\t\t\t    dst_cur_dim = i;\n+\t\t\t\t}\n+\t\t\t      /* Else press thumbs, that there are enough\n+\t\t\t\t dimensional refs to come.  Checked below.  */\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      caf_internal_error (doublearrayref, stat, NULL,\n+\t\t\t\t\t\t  0);\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      /* When the realloc is required, then no extent may have\n+\t\t\t been set.  */\n+\t\t      extent_mismatch = realloc_required\n+\t\t\t  || GFC_DESCRIPTOR_EXTENT (dst, dst_cur_dim) != delta;\n+\t\t      /* When it already known, that a realloc is needed or\n+\t\t\t the extent does not match the needed one.  */\n+\t\t      if (realloc_required || realloc_needed\n+\t\t\t  || extent_mismatch)\n+\t\t\t{\n+\t\t\t  /* Check whether dst is reallocatable.  */\n+\t\t\t  if (unlikely (!dst_reallocatable))\n+\t\t\t    {\n+\t\t\t      caf_internal_error (nonallocextentmismatch, stat,\n+\t\t\t\t\t\t  NULL, 0, delta,\n+\t\t\t\t\t\t  GFC_DESCRIPTOR_EXTENT (dst,\n+\t\t\t\t\t\t\t\t  dst_cur_dim));\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t  /* Only report an error, when the extent needs to be\n+\t\t\t     modified, which is not allowed.  */\n+\t\t\t  else if (!dst_reallocatable && extent_mismatch)\n+\t\t\t    {\n+\t\t\t      caf_internal_error (extentoutofrange, stat, NULL,\n+\t\t\t\t\t\t  0);\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t  realloc_needed = true;\n+\t\t\t}\n+\t\t      /* Only change the extent when it does not match.  This is\n+\t\t\t to prevent resetting given array bounds.  */\n+\t\t      if (extent_mismatch)\n+\t\t\tGFC_DIMENSION_SET (dst->dim[dst_cur_dim], 1, delta,\n+\t\t\t\t\t   size);\n+\t\t    }\n+\n+\t\t  /* Only increase the dim counter, when in an array ref.  */\n+\t\t  if (in_array_ref && dst_cur_dim < dst_rank)\n+\t\t    ++dst_cur_dim;\n+\t\t}\n+\t      size *= (index_type)delta;\n+\t    }\n+\t  if (in_array_ref)\n+\t    {\n+\t      array_extent_fixed = true;\n+\t      in_array_ref = false;\n+\t      /* Check, if we got less dimensional refs than the rank of dst\n+\t\t expects.  */\n+\t      assert (dst_cur_dim == GFC_DESCRIPTOR_RANK (dst));\n+\t    }\n+\t  break;\n+\tcase CAF_REF_STATIC_ARRAY:\n+\t  for (i = 0; riter->u.a.mode[i] != CAF_ARR_REF_NONE; ++i)\n+\t    {\n+\t      switch (riter->u.a.mode[i])\n+\t\t{\n+\t\tcase CAF_ARR_REF_VECTOR:\n+\t\t  delta = riter->u.a.dim[i].v.nvec;\n+#define KINDCASE(kind, type) case kind: \\\n+\t\t    memptr += ((type *)riter->u.a.dim[i].v.vector)[0] \\\n+\t\t\t* riter->item_size; \\\n+\t\t    break\n+\n+\t\t  switch (riter->u.a.dim[i].v.kind)\n+\t\t    {\n+\t\t    KINDCASE (1, GFC_INTEGER_1);\n+\t\t    KINDCASE (2, GFC_INTEGER_2);\n+\t\t    KINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\t    KINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\t    KINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\t    default:\n+\t\t      caf_internal_error (vecrefunknownkind, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+#undef KINDCASE\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_FULL:\n+\t\t  delta = riter->u.a.dim[i].s.end / riter->u.a.dim[i].s.stride\n+\t\t      + 1;\n+\t\t  /* The memptr stays unchanged when ref'ing the first element\n+\t\t     in a dimension.  */\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_RANGE:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     riter->u.a.dim[i].s.start,\n+\t\t\t\t     riter->u.a.dim[i].s.end);\n+\t\t  memptr += riter->u.a.dim[i].s.start\n+\t\t      * riter->u.a.dim[i].s.stride\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_SINGLE:\n+\t\t  delta = 1;\n+\t\t  memptr += riter->u.a.dim[i].s.start\n+\t\t      * riter->u.a.dim[i].s.stride\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_OPEN_END:\n+\t\t  /* This and OPEN_START are mapped to a RANGE and therefore\n+\t\t     can not occur here.  */\n+\t\tcase CAF_ARR_REF_OPEN_START:\n+\t\tdefault:\n+\t\t  caf_internal_error (unknownarrreftype, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+\t      if (delta <= 0)\n+\t\treturn;\n+\t      /* Check the various properties of the destination array.\n+\t\t Is an array expected and present?  */\n+\t      if (delta > 1 && dst_rank == 0)\n+\t\t{\n+\t\t  /* No, an array is required, but not provided.  */\n+\t\t  caf_internal_error (extentoutofrange, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+\t      /* When dst is an array.  */\n+\t      if (dst_rank > 0)\n+\t\t{\n+\t\t  /* Check that dst_cur_dim is valid for dst.  Can be\n+\t\t     superceeded only by scalar data.  */\n+\t\t  if (dst_cur_dim >= dst_rank && delta != 1)\n+\t\t    {\n+\t\t      caf_internal_error (rankoutofrange, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+\t\t  /* Do further checks, when the source is not scalar.  */\n+\t\t  else if (delta != 1)\n+\t\t    {\n+\t\t      /* Check that the extent is not scalar and we are not in\n+\t\t\t an array ref for the dst side.  */\n+\t\t      if (!in_array_ref)\n+\t\t\t{\n+\t\t\t  /* Check that this is the non-scalar extent.  */\n+\t\t\t  if (!array_extent_fixed)\n+\t\t\t    {\n+\t\t\t      /* In an array extent now.  */\n+\t\t\t      in_array_ref = true;\n+\t\t\t      /* The dst is not reallocatable, so nothing more\n+\t\t\t\t to do, then correct the dim counter.  */\n+\t\t\t      dst_cur_dim = i;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      caf_internal_error (doublearrayref, stat, NULL,\n+\t\t\t\t\t\t  0);\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      /* When the realloc is required, then no extent may have\n+\t\t\t been set.  */\n+\t\t      extent_mismatch = realloc_required\n+\t\t\t  || GFC_DESCRIPTOR_EXTENT (dst, dst_cur_dim) != delta;\n+\t\t      /* When it is already known, that a realloc is needed or\n+\t\t\t the extent does not match the needed one.  */\n+\t\t      if (realloc_required || realloc_needed\n+\t\t\t  || extent_mismatch)\n+\t\t\t{\n+\t\t\t  /* Check whether dst is reallocatable.  */\n+\t\t\t  if (unlikely (!dst_reallocatable))\n+\t\t\t    {\n+\t\t\t      caf_internal_error (nonallocextentmismatch, stat,\n+\t\t\t\t\t\t  NULL, 0, delta,\n+\t\t\t\t\t\t  GFC_DESCRIPTOR_EXTENT (dst,\n+\t\t\t\t\t\t\t\t  dst_cur_dim));\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t  /* Only report an error, when the extent needs to be\n+\t\t\t     modified, which is not allowed.  */\n+\t\t\t  else if (!dst_reallocatable && extent_mismatch)\n+\t\t\t    {\n+\t\t\t      caf_internal_error (extentoutofrange, stat, NULL,\n+\t\t\t\t\t\t  0);\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t  realloc_needed = true;\n+\t\t\t}\n+\t\t      /* Only change the extent when it does not match.  This is\n+\t\t\t to prevent resetting given array bounds.  */\n+\t\t      if (extent_mismatch)\n+\t\t\tGFC_DIMENSION_SET (dst->dim[dst_cur_dim], 1, delta,\n+\t\t\t\t\t   size);\n+\t\t    }\n+\t\t  /* Only increase the dim counter, when in an array ref.  */\n+\t\t  if (in_array_ref && dst_cur_dim < dst_rank)\n+\t\t    ++dst_cur_dim;\n+\t\t}\n+\t      size *= (index_type)delta;\n+\t    }\n+\t  if (in_array_ref)\n+\t    {\n+\t      array_extent_fixed = true;\n+\t      in_array_ref = false;\n+\t      /* Check, if we got less dimensional refs than the rank of dst\n+\t\t expects.  */\n+\t      assert (dst_cur_dim == GFC_DESCRIPTOR_RANK (dst));\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  caf_internal_error (unknownreftype, stat, NULL, 0);\n+\t  return;\n+\t}\n+      src_size = riter->item_size;\n+      riter = riter->next;\n+    }\n+  if (size == 0 || src_size == 0)\n+    return;\n+  /* Postcondition:\n+     - size contains the number of elements to store in the destination array,\n+     - src_size gives the size in bytes of each item in the destination array.\n+  */\n+\n+  if (realloc_needed)\n+    {\n+      if (!array_extent_fixed)\n+\t{\n+\t  assert (size == 1);\n+\t  /* This can happen only, when the result is scalar.  */\n+\t  for (dst_cur_dim = 0; dst_cur_dim < dst_rank; ++dst_cur_dim)\n+\t    GFC_DIMENSION_SET (dst->dim[dst_cur_dim], 1, 1, 1);\n+\t}\n+\n+      GFC_DESCRIPTOR_DATA (dst) = malloc (size * GFC_DESCRIPTOR_SIZE (dst));\n+      if (unlikely (GFC_DESCRIPTOR_DATA (dst) == NULL))\n+\t{\n+\t  caf_internal_error (cannotallocdst, stat, NULL, 0);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Reset the token.  */\n+  single_token = TOKEN (token);\n+  memptr = single_token->memptr;\n+  src = single_token->desc;\n+  memset(dst_index, 0, sizeof (dst_index));\n+  i = 0;\n+  get_for_ref (refs, &i, dst_index, single_token, dst, src,\n+\t       GFC_DESCRIPTOR_DATA (dst), memptr, dst_kind, src_kind, 0, 0,\n+\t       1, stat);\n+}\n+\n+\n+static void\n+send_by_ref (caf_reference_t *ref, size_t *i, size_t *src_index,\n+\t     caf_single_token_t single_token, gfc_descriptor_t *dst,\n+\t     gfc_descriptor_t *src, void *ds, void *sr,\n+\t     int dst_kind, int src_kind, size_t dst_dim, size_t src_dim,\n+\t     size_t num, size_t size, int *stat)\n+{\n+  const char vecrefunknownkind[] = \"libcaf_single::caf_send_by_ref(): \"\n+      \"unknown kind in vector-ref.\\n\";\n+  ptrdiff_t extent_dst = 1, array_offset_dst = 0, stride_dst;\n+  const size_t src_rank = GFC_DESCRIPTOR_RANK (src);\n+\n+  if (unlikely (ref == NULL))\n+    /* May be we should issue an error here, because this case should not\n+       occur.  */\n+    return;\n+\n+  if (ref->next == NULL)\n+    {\n+      size_t src_size = GFC_DESCRIPTOR_SIZE (src);\n+      ptrdiff_t array_offset_src = 0;;\n+      int dst_type = -1;\n+\n+      switch (ref->type)\n+\t{\n+\tcase CAF_REF_COMPONENT:\n+\t  if (ref->u.c.caf_token_offset > 0)\n+\t    {\n+\t      if (*(void**)(ds + ref->u.c.offset) == NULL)\n+\t\t{\n+\t\t  /* Create a scalar temporary array descriptor.  */\n+\t\t  gfc_descriptor_t static_dst;\n+\t\t  GFC_DESCRIPTOR_DATA (&static_dst) = NULL;\n+\t\t  GFC_DESCRIPTOR_DTYPE (&static_dst)\n+\t\t      = GFC_DESCRIPTOR_DTYPE (src);\n+\t\t  /* The component may be allocated now, because it is a\n+\t\t     scalar.  */\n+\t\t  single_token = *(caf_single_token_t*)\n+\t\t\t\t\t       (ds + ref->u.c.caf_token_offset);\n+\t\t  _gfortran_caf_register (ref->item_size,\n+\t\t\t\t\t  CAF_REGTYPE_COARRAY_ALLOC,\n+\t\t\t\t\t  (caf_token_t *)&single_token,\n+\t\t\t\t\t  &static_dst, stat, NULL, 0);\n+\t\t  /* In case of an error in allocation return.  When stat is\n+\t\t     NULL, then register_component() terminates on error.  */\n+\t\t  if (stat != NULL && *stat)\n+\t\t    return;\n+\t\t  /* Publish the allocated memory.  */\n+\t\t  *((void **)(ds + ref->u.c.offset))\n+\t\t      = GFC_DESCRIPTOR_DATA (&static_dst);\n+\t\t  ds = GFC_DESCRIPTOR_DATA (&static_dst);\n+\t\t  /* Set the type from the src.  */\n+\t\t  dst_type = GFC_DESCRIPTOR_TYPE (src);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  ds = GFC_DESCRIPTOR_DATA (dst);\n+\t\t  dst_type = GFC_DESCRIPTOR_TYPE (dst);\n+\t\t}\n+\t      copy_data (ds, sr, dst_type, GFC_DESCRIPTOR_TYPE (src),\n+\t\t  dst_kind, src_kind, ref->item_size, src_size, 1, stat);\n+\t    }\n+\t  else\n+\t    copy_data (ds + ref->u.c.offset, sr,\n+\t\t       dst != NULL ? GFC_DESCRIPTOR_TYPE (dst)\n+\t\t\t\t   : GFC_DESCRIPTOR_TYPE (src),\n+\t\t       GFC_DESCRIPTOR_TYPE (src),\n+\t\t       dst_kind, src_kind, ref->item_size, src_size, 1, stat);\n+\t  ++(*i);\n+\t  return;\n+\tcase CAF_REF_STATIC_ARRAY:\n+\t  dst_type = ref->u.a.static_array_type;\n+\t  /* Intentionally fall through.  */\n+\tcase CAF_REF_ARRAY:\n+\t  if (ref->u.a.mode[dst_dim] == CAF_ARR_REF_NONE)\n+\t    {\n+\t      if (src_rank > 0)\n+\t\t{\n+\t\t  for (size_t d = 0; d < src_rank; ++d)\n+\t\t    array_offset_src += src_index[d];\n+\t\t  copy_data (ds, sr + array_offset_src * ref->item_size,\n+\t\t\t     dst_type == -1 ? GFC_DESCRIPTOR_TYPE (dst)\n+\t\t\t\t\t    : dst_type,\n+\t\t\t     GFC_DESCRIPTOR_TYPE (src), dst_kind, src_kind,\n+\t\t\t     ref->item_size, src_size, num, stat);\n+\t\t}\n+\t      else\n+\t\tcopy_data (ds, sr,\n+\t\t\t   dst_type == -1 ? GFC_DESCRIPTOR_TYPE (dst)\n+\t\t\t\t\t  : dst_type,\n+\t\t\t   GFC_DESCRIPTOR_TYPE (src), dst_kind, src_kind,\n+\t\t\t   ref->item_size, src_size, num, stat);\n+\t      *i += num;\n+\t      return;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  caf_runtime_error (unreachable);\n+\t}\n+    }\n+\n+  switch (ref->type)\n+    {\n+    case CAF_REF_COMPONENT:\n+      if (ref->u.c.caf_token_offset > 0)\n+\t{\n+\t  if (*(void**)(ds + ref->u.c.offset) == NULL)\n+\t    {\n+\t      /* This component refs an unallocated array.  Non-arrays are\n+\t\t caught in the if (!ref->next) above.  */\n+\t      dst = (gfc_descriptor_t *)(ds + ref->u.c.offset);\n+\t      /* Assume that the rank and the dimensions fit for copying src\n+\t\t to dst.  */\n+\t      GFC_DESCRIPTOR_DTYPE (dst) = GFC_DESCRIPTOR_DTYPE (src);\n+\t      dst->offset = 0;\n+\t      stride_dst = 1;\n+\t      for (size_t d = 0; d < src_rank; ++d)\n+\t\t{\n+\t\t  extent_dst = GFC_DIMENSION_EXTENT (src->dim[d]);\n+\t\t  GFC_DIMENSION_LBOUND (dst->dim[d]) = 0;\n+\t\t  GFC_DIMENSION_UBOUND (dst->dim[d]) = extent_dst - 1;\n+\t\t  GFC_DIMENSION_STRIDE (dst->dim[d]) = stride_dst;\n+\t\t  stride_dst *= extent_dst;\n+\t\t}\n+\t      /* Null the data-pointer to make register_component allocate\n+\t\t its own memory.  */\n+\t      GFC_DESCRIPTOR_DATA (dst) = NULL;\n+\n+\t      /* The size of the array is given by size.  */\n+\t      _gfortran_caf_register (size * ref->item_size,\n+\t\t\t\t      CAF_REGTYPE_COARRAY_ALLOC,\n+\t\t\t\t      (void **)&single_token,\n+\t\t\t\t      dst, stat, NULL, 0);\n+\t      /* In case of an error in allocation return.  When stat is\n+\t\t NULL, then register_component() terminates on error.  */\n+\t      if (stat != NULL && *stat)\n+\t\treturn;\n+\t      /* The memptr, descriptor and the token are set below.  */\n+\t      *(caf_single_token_t *)(ds + ref->u.c.caf_token_offset)\n+\t\t  = single_token;\n+\t    }\n+\t  single_token = *(caf_single_token_t*)(ds + ref->u.c.caf_token_offset);\n+\t  send_by_ref (ref->next, i, src_index, single_token,\n+\t\t       single_token->desc, src, ds + ref->u.c.offset, sr,\n+\t\t       dst_kind, src_kind, 0, src_dim, 1, size, stat);\n+\t}\n+      else\n+\tsend_by_ref (ref->next, i, src_index, single_token,\n+\t\t     (gfc_descriptor_t *)(ds + ref->u.c.offset), src,\n+\t\t     ds + ref->u.c.offset, sr, dst_kind, src_kind, 0, src_dim,\n+\t\t     1, size, stat);\n+      return;\n+    case CAF_REF_ARRAY:\n+      if (ref->u.a.mode[dst_dim] == CAF_ARR_REF_NONE)\n+\t{\n+\t  send_by_ref (ref->next, i, src_index, single_token,\n+\t\t       (gfc_descriptor_t *)ds, src, ds, sr, dst_kind, src_kind,\n+\t\t       0, src_dim, 1, size, stat);\n+\t  return;\n+\t}\n+      /* Only when on the left most index switch the data pointer to\n+\t     the array's data pointer.  And only for non-static arrays.  */\n+      if (dst_dim == 0 && ref->type != CAF_REF_STATIC_ARRAY)\n+\tds = GFC_DESCRIPTOR_DATA (dst);\n+      switch (ref->u.a.mode[dst_dim])\n+\t{\n+\tcase CAF_ARR_REF_VECTOR:\n+\t  array_offset_dst = 0;\n+\t  src_index[src_dim] = 0;\n+\t  for (size_t idx = 0; idx < ref->u.a.dim[dst_dim].v.nvec;\n+\t       ++idx)\n+\t    {\n+#define KINDCASE(kind, type) case kind: \\\n+\t      array_offset_dst = (((index_type) \\\n+\t\t  ((type *)ref->u.a.dim[dst_dim].v.vector)[idx]) \\\n+\t\t  - GFC_DIMENSION_LBOUND (dst->dim[dst_dim])) \\\n+\t\t  * GFC_DIMENSION_STRIDE (dst->dim[dst_dim]); \\\n+\t      break\n+\n+\t      switch (ref->u.a.dim[dst_dim].v.kind)\n+\t\t{\n+\t\tKINDCASE (1, GFC_INTEGER_1);\n+\t\tKINDCASE (2, GFC_INTEGER_2);\n+\t\tKINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\tKINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\tKINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\tdefault:\n+\t\t  caf_internal_error (vecrefunknownkind, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+#undef KINDCASE\n+\n+\t      send_by_ref (ref, i, src_index, single_token, dst, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_FULL:\n+\t  COMPUTE_NUM_ITEMS (extent_dst,\n+\t\t\t     ref->u.a.dim[dst_dim].s.stride,\n+\t\t\t     GFC_DIMENSION_LBOUND (dst->dim[dst_dim]),\n+\t\t\t     GFC_DIMENSION_UBOUND (dst->dim[dst_dim]));\n+\t  array_offset_dst = 0;\n+\t  stride_dst = GFC_DIMENSION_STRIDE (dst->dim[dst_dim])\n+\t      * ref->u.a.dim[dst_dim].s.stride;\n+\t  src_index[src_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_dst;\n+\t       ++idx, array_offset_dst += stride_dst)\n+\t    {\n+\t      send_by_ref (ref, i, src_index, single_token, dst, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_RANGE:\n+\t  COMPUTE_NUM_ITEMS (extent_dst,\n+\t\t\t     ref->u.a.dim[dst_dim].s.stride,\n+\t\t\t     ref->u.a.dim[dst_dim].s.start,\n+\t\t\t     ref->u.a.dim[dst_dim].s.end);\n+\t  array_offset_dst = ref->u.a.dim[dst_dim].s.start\n+\t      - GFC_DIMENSION_LBOUND (dst->dim[dst_dim]);\n+\t  stride_dst = GFC_DIMENSION_STRIDE (dst->dim[dst_dim])\n+\t      * ref->u.a.dim[dst_dim].s.stride;\n+\t  src_index[src_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_dst; ++idx)\n+\t    {\n+\t      send_by_ref (ref, i, src_index, single_token, dst, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t      array_offset_dst += stride_dst;\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_SINGLE:\n+\t  array_offset_dst = (ref->u.a.dim[dst_dim].s.start\n+\t\t\t       - GFC_DIMENSION_LBOUND (dst->dim[dst_dim]))\n+\t\t\t     * GFC_DIMENSION_STRIDE (dst->dim[dst_dim]);\n+\t  send_by_ref (ref, i, src_index, single_token, dst, src, ds\n+\t\t       + array_offset_dst * ref->item_size, sr,\n+\t\t       dst_kind, src_kind, dst_dim + 1, src_dim, 1,\n+\t\t       size, stat);\n+\t  return;\n+\tcase CAF_ARR_REF_OPEN_END:\n+\t  COMPUTE_NUM_ITEMS (extent_dst,\n+\t\t\t     ref->u.a.dim[dst_dim].s.stride,\n+\t\t\t     ref->u.a.dim[dst_dim].s.start,\n+\t\t\t     GFC_DIMENSION_UBOUND (dst->dim[dst_dim]));\n+\t  array_offset_dst = ref->u.a.dim[dst_dim].s.start\n+\t      - GFC_DIMENSION_LBOUND (dst->dim[dst_dim]);\n+\t  stride_dst = GFC_DIMENSION_STRIDE (dst->dim[dst_dim])\n+\t      * ref->u.a.dim[dst_dim].s.stride;\n+\t  src_index[src_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_dst; ++idx)\n+\t    {\n+\t      send_by_ref (ref, i, src_index, single_token, dst, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t      array_offset_dst += stride_dst;\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_OPEN_START:\n+\t  COMPUTE_NUM_ITEMS (extent_dst,\n+\t\t\t     ref->u.a.dim[dst_dim].s.stride,\n+\t\t\t     GFC_DIMENSION_LBOUND (dst->dim[dst_dim]),\n+\t\t\t     ref->u.a.dim[dst_dim].s.end);\n+\t  array_offset_dst = 0;\n+\t  stride_dst = GFC_DIMENSION_STRIDE (dst->dim[dst_dim])\n+\t      * ref->u.a.dim[dst_dim].s.stride;\n+\t  src_index[src_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_dst; ++idx)\n+\t    {\n+\t      send_by_ref (ref, i, src_index, single_token, dst, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t      array_offset_dst += stride_dst;\n+\t    }\n+\t  return;\n+\tdefault:\n+\t  caf_runtime_error (unreachable);\n+\t}\n+      return;\n+    case CAF_REF_STATIC_ARRAY:\n+      if (ref->u.a.mode[dst_dim] == CAF_ARR_REF_NONE)\n+\t{\n+\t  send_by_ref (ref->next, i, src_index, single_token, NULL,\n+\t\t       src, ds, sr, dst_kind, src_kind,\n+\t\t       0, src_dim, 1, size, stat);\n+\t  return;\n+\t}\n+      switch (ref->u.a.mode[dst_dim])\n+\t{\n+\tcase CAF_ARR_REF_VECTOR:\n+\t  array_offset_dst = 0;\n+\t  src_index[src_dim] = 0;\n+\t  for (size_t idx = 0; idx < ref->u.a.dim[dst_dim].v.nvec;\n+\t       ++idx)\n+\t    {\n+#define KINDCASE(kind, type) case kind: \\\n+\t     array_offset_dst = ((type *)ref->u.a.dim[dst_dim].v.vector)[idx]; \\\n+\t      break\n+\n+\t      switch (ref->u.a.dim[dst_dim].v.kind)\n+\t\t{\n+\t\tKINDCASE (1, GFC_INTEGER_1);\n+\t\tKINDCASE (2, GFC_INTEGER_2);\n+\t\tKINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\tKINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\tKINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\tdefault:\n+\t\t  caf_runtime_error (unreachable);\n+\t\t  return;\n+\t\t}\n+#undef KINDCASE\n+\n+\t      send_by_ref (ref, i, src_index, single_token, NULL, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      src_index[src_dim]\n+\t\t  += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_FULL:\n+\t  src_index[src_dim] = 0;\n+\t  for (array_offset_dst = 0 ;\n+\t       array_offset_dst <= ref->u.a.dim[dst_dim].s.end;\n+\t       array_offset_dst += ref->u.a.dim[dst_dim].s.stride)\n+\t    {\n+\t      send_by_ref (ref, i, src_index, single_token, NULL, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_RANGE:\n+\t  COMPUTE_NUM_ITEMS (extent_dst,\n+\t\t\t     ref->u.a.dim[dst_dim].s.stride,\n+\t\t\t     ref->u.a.dim[dst_dim].s.start,\n+\t\t\t     ref->u.a.dim[dst_dim].s.end);\n+\t  array_offset_dst = ref->u.a.dim[dst_dim].s.start;\n+\t  src_index[src_dim] = 0;\n+\t  for (index_type idx = 0; idx < extent_dst; ++idx)\n+\t    {\n+\t      send_by_ref (ref, i, src_index, single_token, NULL, src,\n+\t\t\t   ds + array_offset_dst * ref->item_size, sr,\n+\t\t\t   dst_kind, src_kind, dst_dim + 1, src_dim + 1,\n+\t\t\t   1, size, stat);\n+\t      if (src_rank > 0)\n+\t\tsrc_index[src_dim]\n+\t\t    += GFC_DIMENSION_STRIDE (src->dim[src_dim]);\n+\t      array_offset_dst += ref->u.a.dim[dst_dim].s.stride;\n+\t    }\n+\t  return;\n+\tcase CAF_ARR_REF_SINGLE:\n+\t  array_offset_dst = ref->u.a.dim[dst_dim].s.start;\n+\t  send_by_ref (ref, i, src_index, single_token, NULL, src,\n+\t\t       ds + array_offset_dst * ref->item_size, sr,\n+\t\t       dst_kind, src_kind, dst_dim + 1, src_dim, 1,\n+\t\t       size, stat);\n+\t  return;\n+\t/* The OPEN_* are mapped to a RANGE and therefore can not occur.  */\n+\tcase CAF_ARR_REF_OPEN_END:\n+\tcase CAF_ARR_REF_OPEN_START:\n+\tdefault:\n+\t  caf_runtime_error (unreachable);\n+\t}\n+      return;\n+    default:\n+      caf_runtime_error (unreachable);\n+    }\n+}\n+\n+\n+void\n+_gfortran_caf_send_by_ref (caf_token_t token,\n+\t\t\t   int image_index __attribute__ ((unused)),\n+\t\t\t   gfc_descriptor_t *src, caf_reference_t *refs,\n+\t\t\t   int dst_kind, int src_kind,\n+\t\t\t   bool may_require_tmp __attribute__ ((unused)),\n+\t\t\t   bool dst_reallocatable, int *stat)\n+{\n+  const char vecrefunknownkind[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t   \"unknown kind in vector-ref.\\n\";\n+  const char unknownreftype[] = \"libcaf_single::caf_send_by_ref(): \"\n+\t\t\t\t\"unknown reference type.\\n\";\n+  const char unknownarrreftype[] = \"libcaf_single::caf_send_by_ref(): \"\n+\t\t\t\t   \"unknown array reference type.\\n\";\n+  const char rankoutofrange[] = \"libcaf_single::caf_send_by_ref(): \"\n+\t\t\t\t\"rank out of range.\\n\";\n+  const char realloconinnerref[] = \"libcaf_single::caf_send_by_ref(): \"\n+      \"reallocation of array followed by component ref not allowed.\\n\";\n+  const char cannotallocdst[] = \"libcaf_single::caf_send_by_ref(): \"\n+\t\t\t\t\"can not allocate memory.\\n\";\n+  const char nonallocextentmismatch[] = \"libcaf_single::caf_send_by_ref(): \"\n+      \"extent of non-allocatable array mismatch.\\n\";\n+  const char innercompref[] = \"libcaf_single::caf_send_by_ref(): \"\n+      \"inner unallocated component detected.\\n\";\n+  size_t size, i;\n+  size_t dst_index[GFC_MAX_DIMENSIONS];\n+  int src_rank = GFC_DESCRIPTOR_RANK (src);\n+  int src_cur_dim = 0;\n+  size_t src_size;\n+  caf_single_token_t single_token = TOKEN (token);\n+  void *memptr = single_token->memptr;\n+  gfc_descriptor_t *dst = single_token->desc;\n+  caf_reference_t *riter = refs;\n+  long delta;\n+  bool extent_mismatch;\n+  /* Note that the component is not allocated yet.  */\n+  index_type new_component_idx = -1;\n+\n+  if (stat)\n+    *stat = 0;\n+\n+  /* Compute the size of the result.  In the beginning size just counts the\n+     number of elements.  */\n+  size = 1;\n+  while (riter)\n+    {\n+      switch (riter->type)\n+\t{\n+\tcase CAF_REF_COMPONENT:\n+\t  if (unlikely (new_component_idx != -1))\n+\t    {\n+\t      /* Allocating a component in the middle of a component ref is not\n+\t\t support.  We don't know the type to allocate.  */\n+\t      caf_internal_error (innercompref, stat, NULL, 0);\n+\t      return;\n+\t    }\n+\t  if (riter->u.c.caf_token_offset > 0)\n+\t    {\n+\t      /* Check whether the allocatable component is zero, then no\n+\t\t token is present, too.  The token's pointer is not cleared\n+\t\t when the structure is initialized.  */\n+\t      if (*(void**)(memptr + riter->u.c.offset) == NULL)\n+\t\t{\n+\t\t  /* This component is not yet allocated.  Check that it is\n+\t\t     allocatable here.  */\n+\t\t  if (!dst_reallocatable)\n+\t\t    {\n+\t\t      caf_internal_error (cannotallocdst, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+\t\t  single_token = NULL;\n+\t\t  memptr = NULL;\n+\t\t  dst = NULL;\n+\t\t  break;\n+\t\t}\n+\t      single_token = *(caf_single_token_t*)\n+\t\t\t\t\t (memptr + riter->u.c.caf_token_offset);\n+\t      memptr += riter->u.c.offset;\n+\t      dst = single_token->desc;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Regular component.  */\n+\t      memptr += riter->u.c.offset;\n+\t      dst = (gfc_descriptor_t *)memptr;\n+\t    }\n+\t  break;\n+\tcase CAF_REF_ARRAY:\n+\t  if (dst != NULL)\n+\t    memptr = GFC_DESCRIPTOR_DATA (dst);\n+\t  else\n+\t    dst = src;\n+\t  /* When the dst array needs to be allocated, then look at the\n+\t     extent of the source array in the dimension dst_cur_dim.  */\n+\t  for (i = 0; riter->u.a.mode[i] != CAF_ARR_REF_NONE; ++i)\n+\t    {\n+\t      switch (riter->u.a.mode[i])\n+\t\t{\n+\t\tcase CAF_ARR_REF_VECTOR:\n+\t\t  delta = riter->u.a.dim[i].v.nvec;\n+#define KINDCASE(kind, type) case kind: \\\n+\t\t    memptr += (((index_type) \\\n+\t\t\t((type *)riter->u.a.dim[i].v.vector)[0]) \\\n+\t\t\t- GFC_DIMENSION_LBOUND (dst->dim[i])) \\\n+\t\t\t* GFC_DIMENSION_STRIDE (dst->dim[i]) \\\n+\t\t\t* riter->item_size; \\\n+\t\t    break\n+\n+\t\t  switch (riter->u.a.dim[i].v.kind)\n+\t\t    {\n+\t\t    KINDCASE (1, GFC_INTEGER_1);\n+\t\t    KINDCASE (2, GFC_INTEGER_2);\n+\t\t    KINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\t    KINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\t    KINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\t    default:\n+\t\t      caf_internal_error (vecrefunknownkind, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+#undef KINDCASE\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_FULL:\n+\t\t  if (dst)\n+\t\t    COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t       riter->u.a.dim[i].s.stride,\n+\t\t\t\t       GFC_DIMENSION_LBOUND (dst->dim[i]),\n+\t\t\t\t       GFC_DIMENSION_UBOUND (dst->dim[i]));\n+\t\t  else\n+\t\t    COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t       riter->u.a.dim[i].s.stride,\n+\t\t\t\t   GFC_DIMENSION_LBOUND (src->dim[src_cur_dim]),\n+\t\t\t\t  GFC_DIMENSION_UBOUND (src->dim[src_cur_dim]));\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_RANGE:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     riter->u.a.dim[i].s.start,\n+\t\t\t\t     riter->u.a.dim[i].s.end);\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - dst->dim[i].lower_bound)\n+\t\t      * GFC_DIMENSION_STRIDE (dst->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_SINGLE:\n+\t\t  delta = 1;\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - dst->dim[i].lower_bound)\n+\t\t      * GFC_DIMENSION_STRIDE (dst->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_OPEN_END:\n+\t\t  if (dst)\n+\t\t    COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t       riter->u.a.dim[i].s.stride,\n+\t\t\t\t       riter->u.a.dim[i].s.start,\n+\t\t\t\t       GFC_DIMENSION_UBOUND (dst->dim[i]));\n+\t\t  else\n+\t\t    COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t       riter->u.a.dim[i].s.stride,\n+\t\t\t\t       riter->u.a.dim[i].s.start,\n+\t\t\t\t  GFC_DIMENSION_UBOUND (src->dim[src_cur_dim]));\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - dst->dim[i].lower_bound)\n+\t\t      * GFC_DIMENSION_STRIDE (dst->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_OPEN_START:\n+\t\t  if (dst)\n+\t\t    COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t       riter->u.a.dim[i].s.stride,\n+\t\t\t\t       GFC_DIMENSION_LBOUND (dst->dim[i]),\n+\t\t\t\t       riter->u.a.dim[i].s.end);\n+\t\t  else\n+\t\t    COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t       riter->u.a.dim[i].s.stride,\n+\t\t\t\t   GFC_DIMENSION_LBOUND (src->dim[src_cur_dim]),\n+\t\t\t\t       riter->u.a.dim[i].s.end);\n+\t\t  /* The memptr stays unchanged when ref'ing the first element\n+\t\t     in a dimension.  */\n+\t\t  break;\n+\t\tdefault:\n+\t\t  caf_internal_error (unknownarrreftype, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+\n+\t      if (delta <= 0)\n+\t\treturn;\n+\t      /* Check the various properties of the source array.\n+\t\t When src is an array.  */\n+\t      if (delta > 1 && src_rank > 0)\n+\t\t{\n+\t\t  /* Check that src_cur_dim is valid for src.  Can be\n+\t\t     superceeded only by scalar data.  */\n+\t\t  if (src_cur_dim >= src_rank)\n+\t\t    {\n+\t\t      caf_internal_error (rankoutofrange, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+\t\t  /* Do further checks, when the source is not scalar.  */\n+\t\t  else\n+\t\t    {\n+\t\t      /* When the realloc is required, then no extent may have\n+\t\t\t been set.  */\n+\t\t      extent_mismatch = memptr == NULL\n+\t\t\t  || (dst\n+\t\t\t      && GFC_DESCRIPTOR_EXTENT (dst, src_cur_dim)\n+\t\t\t      != delta);\n+\t\t      /* When it already known, that a realloc is needed or\n+\t\t\t the extent does not match the needed one.  */\n+\t\t      if (extent_mismatch)\n+\t\t\t{\n+\t\t\t  /* Check whether dst is reallocatable.  */\n+\t\t\t  if (unlikely (!dst_reallocatable))\n+\t\t\t    {\n+\t\t\t      caf_internal_error (nonallocextentmismatch, stat,\n+\t\t\t\t\t\t  NULL, 0, delta,\n+\t\t\t\t\t\t  GFC_DESCRIPTOR_EXTENT (dst,\n+\t\t\t\t\t\t\t\t  src_cur_dim));\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t  /* Report error on allocatable but missing inner\n+\t\t\t     ref.  */\n+\t\t\t  else if (riter->next != NULL)\n+\t\t\t    {\n+\t\t\t      caf_internal_error (realloconinnerref, stat, NULL,\n+\t\t\t\t\t\t  0);\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      /* Only change the extent when it does not match.  This is\n+\t\t\t to prevent resetting given array bounds.  */\n+\t\t      if (extent_mismatch)\n+\t\t\tGFC_DIMENSION_SET (dst->dim[src_cur_dim], 1, delta,\n+\t\t\t\t\t   size);\n+\t\t    }\n+\t\t  /* Increase the dim-counter of the src only when the extent\n+\t\t     matches.  */\n+\t\t  if (src_cur_dim < src_rank\n+\t\t      && GFC_DESCRIPTOR_EXTENT (src, src_cur_dim) == delta)\n+\t\t    ++src_cur_dim;\n+\t\t}\n+\t      size *= (index_type)delta;\n+\t    }\n+\t  break;\n+\tcase CAF_REF_STATIC_ARRAY:\n+\t  for (i = 0; riter->u.a.mode[i] != CAF_ARR_REF_NONE; ++i)\n+\t    {\n+\t      switch (riter->u.a.mode[i])\n+\t\t{\n+\t\tcase CAF_ARR_REF_VECTOR:\n+\t\t  delta = riter->u.a.dim[i].v.nvec;\n+#define KINDCASE(kind, type) case kind: \\\n+\t\t    memptr += ((type *)riter->u.a.dim[i].v.vector)[0] \\\n+\t\t\t* riter->item_size; \\\n+\t\t    break\n+\n+\t\t  switch (riter->u.a.dim[i].v.kind)\n+\t\t    {\n+\t\t    KINDCASE (1, GFC_INTEGER_1);\n+\t\t    KINDCASE (2, GFC_INTEGER_2);\n+\t\t    KINDCASE (4, GFC_INTEGER_4);\n+#ifdef HAVE_GFC_INTEGER_8\n+\t\t    KINDCASE (8, GFC_INTEGER_8);\n+#endif\n+#ifdef HAVE_GFC_INTEGER_16\n+\t\t    KINDCASE (16, GFC_INTEGER_16);\n+#endif\n+\t\t    default:\n+\t\t      caf_internal_error (vecrefunknownkind, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+#undef KINDCASE\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_FULL:\n+\t\t  delta = riter->u.a.dim[i].s.end / riter->u.a.dim[i].s.stride\n+\t\t      + 1;\n+\t\t  /* The memptr stays unchanged when ref'ing the first element\n+\t\t     in a dimension.  */\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_RANGE:\n+\t\t  COMPUTE_NUM_ITEMS (delta,\n+\t\t\t\t     riter->u.a.dim[i].s.stride,\n+\t\t\t\t     riter->u.a.dim[i].s.start,\n+\t\t\t\t     riter->u.a.dim[i].s.end);\n+\t\t  memptr += riter->u.a.dim[i].s.start\n+\t\t      * riter->u.a.dim[i].s.stride\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_SINGLE:\n+\t\t  delta = 1;\n+\t\t  memptr += riter->u.a.dim[i].s.start\n+\t\t      * riter->u.a.dim[i].s.stride\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_OPEN_END:\n+\t\t  /* This and OPEN_START are mapped to a RANGE and therefore\n+\t\t     can not occur here.  */\n+\t\tcase CAF_ARR_REF_OPEN_START:\n+\t\tdefault:\n+\t\t  caf_internal_error (unknownarrreftype, stat, NULL, 0);\n+\t\t  return;\n+\t\t}\n+\t      if (delta <= 0)\n+\t\treturn;\n+\t      /* Check the various properties of the source array.\n+\t\t Only when the source array is not scalar examine its\n+\t\t properties.  */\n+\t      if (delta > 1 && src_rank > 0)\n+\t\t{\n+\t\t  /* Check that src_cur_dim is valid for src.  Can be\n+\t\t     superceeded only by scalar data.  */\n+\t\t  if (src_cur_dim >= src_rank)\n+\t\t    {\n+\t\t      caf_internal_error (rankoutofrange, stat, NULL, 0);\n+\t\t      return;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* We will not be able to realloc the dst, because that's\n+\t\t\t a fixed size array.  */\n+\t\t      extent_mismatch = GFC_DESCRIPTOR_EXTENT (src, src_cur_dim)\n+\t\t\t      != delta;\n+\t\t      /* When the extent does not match the needed one we can\n+\t\t\t only stop here.  */\n+\t\t      if (extent_mismatch)\n+\t\t\t{\n+\t\t\t  caf_internal_error (nonallocextentmismatch, stat,\n+\t\t\t\t\t      NULL, 0, delta,\n+\t\t\t\t\t      GFC_DESCRIPTOR_EXTENT (src,\n+\t\t\t\t\t\t\t\t  src_cur_dim));\n+\t\t\t  return;\n+\t\t\t}\n+\t\t    }\n+\t\t  ++src_cur_dim;\n+\t\t}\n+\t      size *= (index_type)delta;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  caf_internal_error (unknownreftype, stat, NULL, 0);\n+\t  return;\n+\t}\n+      src_size = riter->item_size;\n+      riter = riter->next;\n+    }\n+  if (size == 0 || src_size == 0)\n+    return;\n+  /* Postcondition:\n+     - size contains the number of elements to store in the destination array,\n+     - src_size gives the size in bytes of each item in the destination array.\n+  */\n+\n+  /* Reset the token.  */\n+  single_token = TOKEN (token);\n+  memptr = single_token->memptr;\n+  dst = single_token->desc;\n+  memset (dst_index, 0, sizeof (dst_index));\n+  i = 0;\n+  send_by_ref (refs, &i, dst_index, single_token, dst, src,\n+\t       memptr, GFC_DESCRIPTOR_DATA (src), dst_kind, src_kind, 0, 0,\n+\t       1, size, stat);\n+  assert (i == size);\n+}\n+\n+\n+void\n+_gfortran_caf_sendget_by_ref (caf_token_t dst_token, int dst_image_index,\n+\t\t\t      caf_reference_t *dst_refs, caf_token_t src_token,\n+\t\t\t      int src_image_index,\n+\t\t\t      caf_reference_t *src_refs, int dst_kind,\n+\t\t\t      int src_kind, bool may_require_tmp, int *dst_stat,\n+\t\t\t      int *src_stat)\n+{\n+  gfc_array_void temp;\n+\n+  _gfortran_caf_get_by_ref (src_token, src_image_index, &temp, src_refs,\n+\t\t\t    dst_kind, src_kind, may_require_tmp, true,\n+\t\t\t    src_stat);\n+\n+  if (src_stat && *src_stat != 0)\n+    return;\n+\n+  _gfortran_caf_send_by_ref (dst_token, dst_image_index, &temp, dst_refs,\n+\t\t\t     dst_kind, src_kind, may_require_tmp, true,\n+\t\t\t     dst_stat);\n+  if (GFC_DESCRIPTOR_DATA (&temp))\n+    free (GFC_DESCRIPTOR_DATA (&temp));\n+}\n+\n+\n void\n _gfortran_caf_atomic_define (caf_token_t token, size_t offset,\n \t\t\t     int image_index __attribute__ ((unused)),\n@@ -1019,7 +2679,7 @@ _gfortran_caf_atomic_define (caf_token_t token, size_t offset,\n {\n   assert(kind == 4);\n \n-  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+  uint32_t *atom = (uint32_t *) ((char *) MEMTOK (token) + offset);\n \n   __atomic_store (atom, (uint32_t *) value, __ATOMIC_RELAXED);\n \n@@ -1035,7 +2695,7 @@ _gfortran_caf_atomic_ref (caf_token_t token, size_t offset,\n {\n   assert(kind == 4);\n \n-  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+  uint32_t *atom = (uint32_t *) ((char *) MEMTOK (token) + offset);\n \n   __atomic_load (atom, (uint32_t *) value, __ATOMIC_RELAXED);\n \n@@ -1052,7 +2712,7 @@ _gfortran_caf_atomic_cas (caf_token_t token, size_t offset,\n {\n   assert(kind == 4);\n \n-  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+  uint32_t *atom = (uint32_t *) ((char *) MEMTOK (token) + offset);\n \n   *(uint32_t *) old = *(uint32_t *) compare;\n   (void) __atomic_compare_exchange_n (atom, (uint32_t *) old,\n@@ -1072,7 +2732,7 @@ _gfortran_caf_atomic_op (int op, caf_token_t token, size_t offset,\n   assert(kind == 4);\n \n   uint32_t res;\n-  uint32_t *atom = (uint32_t *) ((char *) TOKEN (token) + offset);\n+  uint32_t *atom = (uint32_t *) ((char *) MEMTOK (token) + offset);\n \n   switch (op)\n     {\n@@ -1106,7 +2766,8 @@ _gfortran_caf_event_post (caf_token_t token, size_t index,\n \t\t\t  int errmsg_len __attribute__ ((unused)))\n {\n   uint32_t value = 1;\n-  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));\n+  uint32_t *event = (uint32_t *) ((char *) MEMTOK (token) + index\n+\t\t\t\t  * sizeof (uint32_t));\n   __atomic_fetch_add (event, (uint32_t) value, __ATOMIC_RELAXED);\n   \n   if(stat)\n@@ -1119,7 +2780,8 @@ _gfortran_caf_event_wait (caf_token_t token, size_t index,\n \t\t\t  char *errmsg __attribute__ ((unused)), \n \t\t\t  int errmsg_len __attribute__ ((unused)))\n {\n-  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));\n+  uint32_t *event = (uint32_t *) ((char *) MEMTOK (token) + index\n+\t\t\t\t  * sizeof (uint32_t));\n   uint32_t value = (uint32_t)-until_count;\n    __atomic_fetch_add (event, (uint32_t) value, __ATOMIC_RELAXED);\n   \n@@ -1132,7 +2794,8 @@ _gfortran_caf_event_query (caf_token_t token, size_t index,\n \t\t\t   int image_index __attribute__ ((unused)), \n \t\t\t   int *count, int *stat)\n {\n-  uint32_t *event = (uint32_t *) ((char *) TOKEN (token) + index*sizeof(uint32_t));\n+  uint32_t *event = (uint32_t *) ((char *) MEMTOK (token) + index\n+\t\t\t\t  * sizeof (uint32_t));\n   __atomic_load (event, (uint32_t *) count, __ATOMIC_RELAXED);\n   \n   if(stat)\n@@ -1145,7 +2808,7 @@ _gfortran_caf_lock (caf_token_t token, size_t index,\n \t\t    int *aquired_lock, int *stat, char *errmsg, int errmsg_len)\n {\n   const char *msg = \"Already locked\";\n-  bool *lock = &((bool *) TOKEN (token))[index];\n+  bool *lock = &((bool *) MEMTOK (token))[index];\n \n   if (!*lock)\n     {\n@@ -1189,7 +2852,7 @@ _gfortran_caf_unlock (caf_token_t token, size_t index,\n \t\t      int *stat, char *errmsg, int errmsg_len)\n {\n   const char *msg = \"Variable is not locked\";\n-  bool *lock = &((bool *) TOKEN (token))[index];\n+  bool *lock = &((bool *) MEMTOK (token))[index];\n \n   if (*lock)\n     {"}]}