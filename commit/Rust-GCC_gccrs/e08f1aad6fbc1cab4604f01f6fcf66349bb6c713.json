{"sha": "e08f1aad6fbc1cab4604f01f6fcf66349bb6c713", "node_id": "C_kwDOANBUbNoAKGUwOGYxYWFkNmZiYzFjYWI0NjA0ZjAxZjZmY2Y2NjM0OWJiNmM3MTM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-04-02T21:26:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:28Z"}, "message": "[Ada] Small housekeeping work continued\n\nNo functional changes.\n\ngcc/ada/\n\n\t* gcc-interface/trans.cc: Fix formatting issues in comments.\n\t(Subprogram_Body_to_gnu): Tidy up.\n\t(Exception_Handler_to_gnu_gcc): Rename into...\n\t(Exception_Handler_to_gnu): ...this.\n\t(gnat_to_gnu) <N_Exception_Handler>: Adjust to above renaming.", "tree": {"sha": "da83ea31d0c60667fea5542b784988631a819bc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da83ea31d0c60667fea5542b784988631a819bc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e08f1aad6fbc1cab4604f01f6fcf66349bb6c713", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08f1aad6fbc1cab4604f01f6fcf66349bb6c713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08f1aad6fbc1cab4604f01f6fcf66349bb6c713", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08f1aad6fbc1cab4604f01f6fcf66349bb6c713/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e279bd9dc5d9c6bc1863a4f68524383707b67b6"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "57a9dee0accf8075a3d1315d126ddcd4a79abc11", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08f1aad6fbc1cab4604f01f6fcf66349bb6c713/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08f1aad6fbc1cab4604f01f6fcf66349bb6c713/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=e08f1aad6fbc1cab4604f01f6fcf66349bb6c713", "patch": "@@ -1149,9 +1149,9 @@ Gigi_Types_Compatible (Entity_Id type, Entity_Id def_type)\n   return false;\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Identifier,\n-   to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer\n-   to where we should place the result type.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Identifier, to a GCC\n+   tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to where we should\n+   place the result type.  */\n \n static tree\n Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n@@ -1353,8 +1353,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   return gnu_result;\n }\n \n-/* Subroutine of gnat_to_gnu to process gnat_node, an N_Pragma.  Return\n-   any statements we generate.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Pragma, to a GCC\n+   tree, which is returned.  */\n \n static tree\n Pragma_to_gnu (Node_Id gnat_node)\n@@ -1700,9 +1700,9 @@ get_type_length (tree type, tree result_type)\n   return length;\n }\n \n-/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Attribute node,\n-   to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to\n-   where we should place the result type.  ATTRIBUTE is the attribute ID.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Attribute node, to a\n+   GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to where we\n+   should place the result type.  ATTRIBUTE is the attribute ID.  */\n \n static tree\n Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n@@ -2613,8 +2613,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n   return gnu_result;\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Case_Statement,\n-   to a GCC tree, which is returned.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Case_Statement, to a\n+   GCC tree, which is returned.  */\n \n static tree\n Case_Statement_to_gnu (Node_Id gnat_node)\n@@ -2951,8 +2951,8 @@ independent_iterations_p (tree stmt_list)\n   return true;\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n-   to a GCC tree, which is returned.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Loop_Statement, to a\n+   GCC tree, which is returned.  */\n \n static tree\n Loop_Statement_to_gnu (Node_Id gnat_node)\n@@ -3836,22 +3836,19 @@ build_return_expr (tree ret_obj, tree ret_val)\n   return build1 (RETURN_EXPR, void_type_node, result_expr);\n }\n \n-/* Subroutine of gnat_to_gnu to process gnat_node, an N_Subprogram_Body.  We\n-   don't return anything.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Subprogram_Body.  */\n \n static void\n Subprogram_Body_to_gnu (Node_Id gnat_node)\n {\n-  /* Defining identifier of a parameter to the subprogram.  */\n-  Entity_Id gnat_param;\n   /* The defining identifier for the subprogram body. Note that if a\n      specification has appeared before for this body, then the identifier\n-     occurring in that specification will also be a defining identifier and all\n-     the calls to this subprogram will point to that specification.  */\n+     occurring in that specification will also be a defining identifier\n+     and calls to this subprogram will point to that specification.  */\n   Entity_Id gnat_subprog\n     = (Present (Corresponding_Spec (gnat_node))\n        ? Corresponding_Spec (gnat_node) : Defining_Entity (gnat_node));\n-  /* The FUNCTION_DECL node corresponding to the subprogram spec.   */\n+  /* The FUNCTION_DECL node corresponding to the defining identifier.  */\n   tree gnu_subprog;\n   /* Its RESULT_DECL node.  */\n   tree gnu_result_decl;\n@@ -3860,11 +3857,9 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* The TYPE_CI_CO_LIST of its FUNCTION_TYPE node, if any.  */\n   tree gnu_cico_list;\n   /* The entry in the CI_CO_LIST that represents a function return, if any.  */\n-  tree gnu_return_var_elmt = NULL_TREE;\n-  tree gnu_result;\n+  tree gnu_return_var_elmt;\n+  /* Its source location.  */\n   location_t locus;\n-  struct language_function *gnu_subprog_language;\n-  vec<parm_attr, va_gc> *cache;\n \n   /* If this is a generic subprogram or it has been eliminated, ignore it.  */\n   if (Is_Generic_Subprogram (gnat_subprog) || Is_Eliminated (gnat_subprog))\n@@ -3886,9 +3881,11 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n   if (gnu_cico_list && TREE_VALUE (gnu_cico_list) == void_type_node)\n     gnu_return_var_elmt = gnu_cico_list;\n+  else\n+    gnu_return_var_elmt = NULL_TREE;\n \n   /* If the function returns by invisible reference, make it explicit in the\n-     function body.  See gnat_to_gnu_entity, E_Subprogram_Type case.  */\n+     function body.  See gnat_to_gnu_subprog_type for more details.  */\n   if (TREE_ADDRESSABLE (gnu_subprog_type))\n     {\n       TREE_TYPE (gnu_result_decl)\n@@ -3910,8 +3907,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* Initialize the information structure for the function.  */\n   allocate_struct_function (gnu_subprog, false);\n-  gnu_subprog_language = ggc_cleared_alloc<language_function> ();\n-  DECL_STRUCT_FUNCTION (gnu_subprog)->language = gnu_subprog_language;\n+  language_function *gnu_subprog_lang = ggc_cleared_alloc<language_function> ();\n+  DECL_STRUCT_FUNCTION (gnu_subprog)->language = gnu_subprog_lang;\n   DECL_STRUCT_FUNCTION (gnu_subprog)->function_start_locus = locus;\n   set_cfun (NULL);\n \n@@ -3923,7 +3920,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      block.  */\n   if (gnu_cico_list)\n     {\n-      tree gnu_return_var = NULL_TREE;\n+      tree gnu_return_var;\n \n       vec_safe_push (gnu_return_label_stack,\n \t\t     create_artificial_label (input_location));\n@@ -3946,6 +3943,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t\t\t       true, false, NULL, gnat_subprog);\n \t  TREE_VALUE (gnu_return_var_elmt) = gnu_return_var;\n \t}\n+      else\n+\tgnu_return_var = NULL_TREE;\n \n       vec_safe_push (gnu_return_var_stack, gnu_return_var);\n \n@@ -3954,7 +3953,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t put it into TYPE_CI_CO_LIST, which must contain an empty entry too.\n \t We can match up the entries because TYPE_CI_CO_LIST is in the order\n \t of the parameters.  */\n-      for (gnat_param = First_Formal_With_Extras (gnat_subprog);\n+      for (Entity_Id gnat_param = First_Formal_With_Extras (gnat_subprog);\n \t   Present (gnat_param);\n \t   gnat_param = Next_Formal_With_Extras (gnat_param))\n \tif (!present_gnu_tree (gnat_param))\n@@ -3985,13 +3984,15 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   start_stmt_group ();\n   gnat_pushlevel ();\n \n+  /* First translate the declarations of the subprogram.  */\n   process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n \n-  /* Generate the code of the subprogram itself.  A return statement will be\n-     present and any Out parameters will be handled there.  */\n+  /* Then generate the code of the subprogram itself.  A return statement will\n+     be present and any Out parameters will be handled there.  */\n   add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n+\n   gnat_poplevel ();\n-  gnu_result = end_stmt_group ();\n+  tree gnu_result = end_stmt_group ();\n \n   /* Attempt setting the end_locus of our GCC body tree, typically a BIND_EXPR,\n      then the end_locus of our GCC subprogram declaration tree.  */\n@@ -4001,7 +4002,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* If we populated the parameter attributes cache, we need to make sure that\n      the cached expressions are evaluated on all the possible paths leading to\n      their uses.  So we force their evaluation on entry of the function.  */\n-  cache = gnu_subprog_language->parm_attr_cache;\n+  vec<parm_attr, va_gc> *cache = gnu_subprog_lang->parm_attr_cache;\n   if (cache)\n     {\n       struct parm_attr_d *pa;\n@@ -4022,7 +4023,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       add_stmt (gnu_result);\n       gnu_result = end_stmt_group ();\n \n-      gnu_subprog_language->parm_attr_cache = NULL;\n+      gnu_subprog_lang->parm_attr_cache = NULL;\n     }\n \n   /* If we are dealing with a return from an Ada procedure with parameters\n@@ -4116,7 +4117,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* Finally annotate the parameters and disconnect the trees for parameters\n      that we have turned into variables since they are now unusable.  */\n-  for (gnat_param = First_Formal_With_Extras (gnat_subprog);\n+  for (Entity_Id gnat_param = First_Formal_With_Extras (gnat_subprog);\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n     {\n@@ -4136,14 +4137,14 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* If the function returns an aggregate type and we have candidates for\n      a Named Return Value, finalize the optimization.  */\n-  if (optimize && !optimize_debug && gnu_subprog_language->named_ret_val)\n+  if (optimize && !optimize_debug && gnu_subprog_lang->named_ret_val)\n     {\n       finalize_nrv (gnu_subprog,\n-\t\t    gnu_subprog_language->named_ret_val,\n-\t\t    gnu_subprog_language->other_ret_val,\n-\t\t    gnu_subprog_language->gnat_ret);\n-      gnu_subprog_language->named_ret_val = NULL;\n-      gnu_subprog_language->other_ret_val = NULL;\n+\t\t    gnu_subprog_lang->named_ret_val,\n+\t\t    gnu_subprog_lang->other_ret_val,\n+\t\t    gnu_subprog_lang->gnat_ret);\n+      gnu_subprog_lang->named_ret_val = NULL;\n+      gnu_subprog_lang->other_ret_val = NULL;\n     }\n \n   /* If this is an inlined external function that has been marked uninlinable,\n@@ -4463,7 +4464,7 @@ elaborate_profile (Entity_Id first_formal, Entity_Id result_type)\n     (void) gnat_to_gnu_type (result_type);\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Function_Call\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n    If GNU_TARGET is non-null, this must be a function call on the RHS of a\n@@ -5343,7 +5344,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   return gnu_result;\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an\n    N_Handled_Sequence_Of_Statements, to a GCC tree, which is returned.  */\n \n static tree\n@@ -5487,12 +5488,11 @@ stmt_list_cannot_alter_control_flow_p (List_Id gnat_list)\n   return true;\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Exception_Handler,\n-   to a GCC tree, which is returned.  This is the variant for GCC exception\n-   schemes.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Exception_Handler,\n+   to a GCC tree, which is returned.  */\n \n static tree\n-Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n+Exception_Handler_to_gnu (Node_Id gnat_node)\n {\n   tree gnu_etypes_list = NULL_TREE;\n \n@@ -5664,7 +5664,7 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n     build2 (CATCH_EXPR, void_type_node, gnu_etypes_list, end_stmt_group ());\n }\n \n-/* Subroutine of gnat_to_gnu to generate code for an N_Compilation unit.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Compilation_Unit.  */\n \n static void\n Compilation_Unit_to_gnu (Node_Id gnat_node)\n@@ -5845,8 +5845,8 @@ Range_to_gnu (Node_Id gnat_range, tree *gnu_low, tree *gnu_high)\n }\n \n /* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Raise_xxx_Error,\n-   to a GCC tree and return it.  GNU_RESULT_TYPE_P is a pointer to where\n-   we should place the result type.  */\n+   to a GCC tree,  which is returned.  GNU_RESULT_TYPE_P is a pointer to\n+   where we should place the result type.  */\n \n static tree\n Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n@@ -7671,7 +7671,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Exception_Handler:\n-      gnu_result = Exception_Handler_to_gnu_gcc (gnat_node);\n+      gnu_result = Exception_Handler_to_gnu (gnat_node);\n       break;\n \n     case N_Raise_Statement:"}]}