{"sha": "ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ3YjlkNmVjZmQxNjUxZDdjM2ZjZDk2ZjJiMTA1YmIyYmEwMzQ5YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T09:53:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T09:53:42Z"}, "message": "[multiple changes]\n\n2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_prag.adb (Expand_Pragma_Loop_Assertion): Update the comment\n\ton intended expansion.\tReimplement the logic which expands the\n\ttermination variants.\n\t(Process_Increase_Decrease): Update the parameter profile and the\n\tcomment related to it. Accommodate the new aggregate-like appearance of\n\tthe termination variants.\n\t* sem_prag.adb (Analyze_Pragma): Update the syntax of pragma\n\tLoop_Assertion. Reimplement the semantic analysis of the pragma\n\tto accommodate the new aggregate-like variant.\n\t(Check_Variant): New routine.\n\t* snames.ads-tmpl: Change names Name_Decreases and Name_Increases\n\tto Name_Decreasing and Name_Increasing respectively. Add name\n\tVariant.\n\n2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_eval.adb: Static evaluation of case expressions.\n\nFrom-SVN: r193216", "tree": {"sha": "bb3ceb85196a7926fdbdfd8a855becd8738f530f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb3ceb85196a7926fdbdfd8a855becd8738f530f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/comments", "author": null, "committer": null, "parents": [{"sha": "2fe2920e2dcfed7940e33b7b426a5035189ac04e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe2920e2dcfed7940e33b7b426a5035189ac04e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe2920e2dcfed7940e33b7b426a5035189ac04e"}], "stats": {"total": 356, "additions": 256, "deletions": 100}, "files": [{"sha": "632b6030c20e87f7c65fbf86d719c84607a7982e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "patch": "@@ -1,3 +1,23 @@\n+2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_prag.adb (Expand_Pragma_Loop_Assertion): Update the comment\n+\ton intended expansion.\tReimplement the logic which expands the\n+\ttermination variants.\n+\t(Process_Increase_Decrease): Update the parameter profile and the\n+\tcomment related to it. Accommodate the new aggregate-like appearance of\n+\tthe termination variants.\n+\t* sem_prag.adb (Analyze_Pragma): Update the syntax of pragma\n+\tLoop_Assertion. Reimplement the semantic analysis of the pragma\n+\tto accommodate the new aggregate-like variant.\n+\t(Check_Variant): New routine.\n+\t* snames.ads-tmpl: Change names Name_Decreases and Name_Increases\n+\tto Name_Decreasing and Name_Increasing respectively. Add name\n+\tVariant.\n+\n+2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_eval.adb: Static evaluation of case expressions.\n+\n 2012-11-06  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_prag.adb, impunit.adb, exp_ch9.adb, par-ch4.adb,"}, {"sha": "5ce909747684fe9b17696d4ad8cf2301af3b291d", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 97, "deletions": 54, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "patch": "@@ -807,8 +807,8 @@ package body Exp_Prag is\n    --        <preceding source statements>\n    --        pragma Loop_Assertion\n    --           (Invariant => Invar_Expr,\n-   --            Increases => Incr_Expr,\n-   --            Decreases => Decr_Expr);\n+   --            Variant   => (Increasing => Incr_Expr,\n+   --                          Decreasing => Decr_Expr));\n    --        <succeeding source statements>\n    --     end loop;\n \n@@ -855,15 +855,20 @@ package body Exp_Prag is\n       Loop_Stmt   : Node_Id;\n       Old_Assign  : List_Id   := No_List;\n \n-      procedure Process_Increase_Decrease (Arg : Node_Id; Is_Last : Boolean);\n-      --  Process a single increases/decreases expression. Flag Is_Last should\n-      --  be set when the expression is the last argument to be processed.\n+      procedure Process_Increase_Decrease\n+        (Variant : Node_Id;\n+         Is_Last : Boolean);\n+      --  Process a single increasing / decreasing termination variant. Flag\n+      --  Is_Last should be set when processing the last variant.\n \n       -------------------------------\n       -- Process_Increase_Decrease --\n       -------------------------------\n \n-      procedure Process_Increase_Decrease (Arg : Node_Id; Is_Last : Boolean) is\n+      procedure Process_Increase_Decrease\n+        (Variant : Node_Id;\n+         Is_Last : Boolean)\n+      is\n          function Make_Op\n            (Loc      : Source_Ptr;\n             Curr_Val : Node_Id;\n@@ -880,26 +885,21 @@ package body Exp_Prag is\n             Curr_Val : Node_Id;\n             Old_Val  : Node_Id) return Node_Id\n          is\n+            Modif : constant Node_Id := First (Choices (Variant));\n          begin\n-            if Chars (Arg) = Name_Increases then\n-               return\n-                 Make_Op_Gt (Loc,\n-                   Left_Opnd  => Curr_Val,\n-                   Right_Opnd => Old_Val);\n-\n-            else pragma Assert (Chars (Arg) = Name_Decreases);\n-               return\n-                 Make_Op_Lt (Loc,\n-                   Left_Opnd  => Curr_Val,\n-                   Right_Opnd => Old_Val);\n+            if Chars (Modif) = Name_Increasing then\n+               return Make_Op_Gt (Loc, Curr_Val, Old_Val);\n+\n+            else pragma Assert (Chars (Modif) = Name_Decreasing);\n+               return Make_Op_Lt (Loc, Curr_Val, Old_Val);\n             end if;\n          end Make_Op;\n \n          --  Local variables\n \n-         Expr     : constant Node_Id := Expression (Arg);\n+         Expr     : constant Node_Id := Expression (Variant);\n+         Loc      : constant Source_Ptr := Sloc (Expr);\n          Loop_Loc : constant Source_Ptr := Sloc (Loop_Stmt);\n-         Cond     : Node_Id;\n          Curr_Id  : Entity_Id;\n          Old_Id   : Entity_Id;\n          Prag     : Node_Id;\n@@ -909,7 +909,8 @@ package body Exp_Prag is\n       begin\n          --  All temporaries generated in this routine must be inserted before\n          --  the related loop statement. Ensure that the proper scope is on the\n-         --  stack when analyzing the temporaries.\n+         --  stack when analyzing the temporaries. Note that we also use the\n+         --  Sloc of the related loop.\n \n          Push_Scope (Scope (Loop_Scop));\n \n@@ -930,6 +931,21 @@ package body Exp_Prag is\n                   New_Reference_To (Standard_Boolean, Loop_Loc),\n                 Expression          =>\n                   New_Reference_To (Standard_False, Loop_Loc)));\n+\n+            --  Prevent an unwanted optimization where the Current_Value of\n+            --  the flag eliminates the if statement which stores the variant\n+            --  values coming from the previous iteration.\n+\n+            --     Flag : Boolean := False;\n+            --     loop\n+            --        if Flag then         --  condition rewritten to False\n+            --           Old_N := Curr_N;  --  and if statement eliminated\n+            --        end if;\n+            --        . . .\n+            --        Flag := True;\n+            --     end loop;\n+\n+            Set_Current_Value (Flag_Id, Empty);\n          end if;\n \n          --  Step 2: Create the temporaries which store the old and current\n@@ -1008,16 +1024,22 @@ package body Exp_Prag is\n          --    if Curr /= Old then\n          --       <Prag>;\n \n-         Cond :=\n-           Make_Op_Ne (Loc,\n-             Left_Opnd  => New_Reference_To (Curr_Id, Loc),\n-             Right_Opnd => New_Reference_To (Old_Id, Loc));\n-\n          if No (If_Stmt) then\n-            If_Stmt :=\n-              Make_If_Statement (Loc,\n-                Condition       => Cond,\n-                Then_Statements => New_List (Prag));\n+\n+            --  When there is just one termination variant, do not compare the\n+            --  old and current value for equality, just check the pragma.\n+\n+            if Is_Last then\n+               If_Stmt := Prag;\n+            else\n+               If_Stmt :=\n+                 Make_If_Statement (Loc,\n+                   Condition       =>\n+                     Make_Op_Ne (Loc,\n+                       Left_Opnd  => New_Reference_To (Curr_Id, Loc),\n+                       Right_Opnd => New_Reference_To (Old_Id, Loc)),\n+                   Then_Statements => New_List (Prag));\n+            end if;\n \n          --  Generate:\n          --    else\n@@ -1038,46 +1060,60 @@ package body Exp_Prag is\n \n             Append_To (Elsif_Parts (If_Stmt),\n               Make_Elsif_Part (Loc,\n-                Condition       => Cond,\n+                Condition       =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd  => New_Reference_To (Curr_Id, Loc),\n+                    Right_Opnd => New_Reference_To (Old_Id, Loc)),\n                 Then_Statements => New_List (Prag)));\n          end if;\n       end Process_Increase_Decrease;\n \n       --  Local variables\n \n-      Args     : constant List_Id := Pragma_Argument_Associations (N);\n-      Last_Arg : constant Node_Id := Last (Args);\n-      Arg      : Node_Id;\n-      Invar    : Node_Id := Empty;\n+      Arg   : Node_Id;\n+      Invar : Node_Id := Empty;\n \n    --  Start of processing for Expand_Pragma_Loop_Assertion\n \n    begin\n       --  Locate the enclosing loop for which this assertion applies\n \n-      Loop_Scop := Current_Scope;\n-      while Present (Loop_Scop)\n-        and then Loop_Scop /= Standard_Standard\n-        and then Ekind (Loop_Scop) /= E_Loop\n-      loop\n-         Loop_Scop := Scope (Loop_Scop);\n-      end loop;\n-\n       Loop_Stmt := N;\n       while Present (Loop_Stmt)\n         and then Nkind (Loop_Stmt) /= N_Loop_Statement\n       loop\n          Loop_Stmt := Parent (Loop_Stmt);\n       end loop;\n \n+      Loop_Scop := Entity (Identifier (Loop_Stmt));\n+\n       --  Process all pragma arguments\n \n-      Arg := First (Args);\n+      Arg := First (Pragma_Argument_Associations (N));\n       while Present (Arg) loop\n-         if Chars (Arg) = Name_Increases\n-           or else Chars (Arg) = Name_Decreases\n-         then\n-            Process_Increase_Decrease (Arg, Is_Last => Arg = Last_Arg);\n+\n+         --  Termination variants appear as components in an aggregate\n+\n+         if Chars (Arg) = Name_Variant then\n+            declare\n+               Variants : constant Node_Id := Expression (Arg);\n+               Last_Var : constant Node_Id :=\n+                            Last (Component_Associations (Variants));\n+               Variant  : Node_Id;\n+\n+            begin\n+               Variant := First (Component_Associations (Variants));\n+               while Present (Variant) loop\n+                  Process_Increase_Decrease\n+                    (Variant => Variant,\n+                     Is_Last => Variant = Last_Var);\n+\n+                  Next (Variant);\n+               end loop;\n+            end;\n+\n+         --  Invariant\n+\n          else\n             Invar := Expression (Arg);\n          end if;\n@@ -1088,13 +1124,19 @@ package body Exp_Prag is\n       --  Verify the invariant expression, generate:\n       --    pragma Assert (<Invar>);\n \n+      --  Use the Sloc of the invariant for better error reporting\n+\n       if Present (Invar) then\n-         Insert_Action (N,\n-           Make_Pragma (Loc,\n-             Chars                        => Name_Assert,\n-             Pragma_Argument_Associations => New_List (\n-               Make_Pragma_Argument_Association (Loc,\n-                 Expression => Relocate_Node (Invar)))));\n+         declare\n+            Invar_Loc : constant Source_Ptr := Sloc (Invar);\n+         begin\n+            Insert_Action (N,\n+              Make_Pragma (Invar_Loc,\n+                Chars                        => Name_Assert,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Invar_Loc,\n+                    Expression => Relocate_Node (Invar)))));\n+         end;\n       end if;\n \n       --  Construct the segment which stores the old values of all expressions.\n@@ -1135,7 +1177,8 @@ package body Exp_Prag is\n                  Expression => New_Reference_To (Standard_True, Loc)))));\n       end if;\n \n-      --  Need a comment on this final rewrite ???\n+      --  The original pragma has been transformed into a complex sequence of\n+      --  statements and does not need to remain in the tree.\n \n       Rewrite (N, Make_Null_Statement (Loc));\n       Analyze (N);"}, {"sha": "42174631ba87c419cb7472fdaf8e73049447ee67", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "patch": "@@ -1759,21 +1759,63 @@ package body Sem_Eval is\n    -- Eval_Case_Expression --\n    --------------------------\n \n-   --  Right now we do not attempt folding of any case expressions, and the\n-   --  language does not require it, so the only required processing is to\n-   --  do the check for all expressions appearing in the case expression.\n+   --  A conditional expression is static if all its conditions and dependent\n+   --  expressions are static.\n \n    procedure Eval_Case_Expression (N : Node_Id) is\n-      Alt : Node_Id;\n+      Alt       : Node_Id;\n+      Choice    : Node_Id;\n+      Is_Static : Boolean;\n+      Result    : Node_Id;\n+      Val       : Uint;\n \n    begin\n-      Check_Non_Static_Context (Expression (N));\n+      Result := Empty;\n+      Is_Static := True;\n+\n+      if Is_Static_Expression (Expression (N)) then\n+         Val := Expr_Value (Expression (N));\n+\n+      else\n+         Check_Non_Static_Context (Expression (N));\n+         Is_Static := False;\n+      end if;\n \n       Alt := First (Alternatives (N));\n-      while Present (Alt) loop\n-         Check_Non_Static_Context (Expression (Alt));\n+\n+      Search : while Present (Alt) loop\n+         if not Is_Static\n+           or else not Is_Static_Expression (Expression (Alt))\n+         then\n+            Check_Non_Static_Context (Expression (Alt));\n+            Is_Static := False;\n+\n+         else\n+            Choice := First (Discrete_Choices (Alt));\n+            while Present (Choice) loop\n+               if Nkind (Choice) = N_Others_Choice then\n+                  Result := Expression (Alt);\n+                  exit Search;\n+\n+               elsif Expr_Value (Choice) = Val then\n+                  Result := Expression (Alt);\n+                  exit Search;\n+\n+               else\n+                  Next (Choice);\n+               end if;\n+            end loop;\n+         end if;\n+\n          Next (Alt);\n-      end loop;\n+      end loop Search;\n+\n+      if Is_Static then\n+         Rewrite (N, Relocate_Node (Result));\n+\n+      else\n+         Set_Is_Static_Expression (N, False);\n+      end if;\n    end Eval_Case_Expression;\n \n    ------------------------"}, {"sha": "325ca0c3bc3e3532386c19e7776c070923c0783c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 86, "deletions": 36, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "patch": "@@ -11288,18 +11288,71 @@ package body Sem_Prag is\n          -- Loop_Assertion --\n          --------------------\n \n-         --  pragma Loop_Assertion (\n-         --     [[Invariant   =>] boolean_EXPRESSION],\n-         --      {CHANGE_MODE =>  discrete_EXPRESSION} );\n+         --  pragma Loop_Assertion\n+         --    (   [Invariant =>] boolean_Expression\n+         --      | [Invariant =>] boolean_Expression ,\n+         --         Variant => TERMINATION_VARIANTS\n+         --      |  Variant => TERMINATION_VARIANTS );\n          --\n-         --  CHANGE_MODE ::= Increases | Decreases\n+         --  TERMINATION_VARIANTS ::=\n+         --    ( TERMINATION_VARIANT {, TERMINATION_VARIANT} )\n+         --\n+         --  TERMINATION_VARIANT ::= CHANGE_MODIFIER => discrete_EXPRESSION\n+         --\n+         --  CHANGE_MODIFIER ::= Increasing | Decreasing\n \n          when Pragma_Loop_Assertion => Loop_Assertion : declare\n-            Arg  : Node_Id;\n-            Expr : Node_Id;\n-            Seen : Boolean := False;\n+            procedure Check_Variant (Arg : Node_Id);\n+            --  Verify the legality of a variant\n+\n+            -------------------\n+            -- Check_Variant --\n+            -------------------\n+\n+            procedure Check_Variant (Arg : Node_Id) is\n+               Expr : constant Node_Id := Expression (Arg);\n+\n+            begin\n+               --  Variants appear in aggregate form\n+\n+               if Nkind (Expr) = N_Aggregate then\n+                  declare\n+                     Comp  : Node_Id;\n+                     Extra : Node_Id;\n+                     Modif : Node_Id;\n+\n+                  begin\n+                     Comp := First (Component_Associations (Expr));\n+                     while Present (Comp) loop\n+                        Modif := First (Choices (Comp));\n+                        Extra := Next (Modif);\n+\n+                        Check_Arg_Is_One_Of\n+                          (Modif, Name_Decreasing, Name_Increasing);\n+\n+                        if Present (Extra) then\n+                           Error_Pragma_Arg\n+                             (\"only one modifier allowed in argument\", Expr);\n+                        end if;\n+\n+                        Preanalyze_And_Resolve\n+                          (Expression (Comp), Any_Discrete);\n+\n+                        Next (Comp);\n+                     end loop;\n+                  end;\n+               else\n+                  Error_Pragma_Arg\n+                    (\"expression on variant must be an aggregate\", Expr);\n+               end if;\n+            end Check_Variant;\n+\n+            --  Local variables\n+\n             Stmt : Node_Id;\n \n+         --  Start of processing for Loop_Assertion\n+\n          begin\n             GNAT_Pragma;\n             S14_Pragma;\n@@ -11324,46 +11377,43 @@ package body Sem_Prag is\n             end if;\n \n             Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments  (2);\n \n-            --  Process the arguments\n+            --  Process the first argument\n \n-            Arg := Arg1;\n-            while Present (Arg) loop\n-               Expr := Expression (Arg);\n+            if Chars (Arg1) = Name_Variant then\n+               Check_Variant (Arg1);\n \n-               --  All expressions are preanalyzed because they will be\n-               --  relocated during expansion and analyzed in their new\n-               --  context.\n+            elsif Chars (Arg1) = No_Name\n+              or else Chars (Arg1) = Name_Invariant\n+            then\n+               Preanalyze_And_Resolve (Expression (Arg1), Any_Boolean);\n \n-               if Chars (Arg) = Name_Invariant\n-                 or else\n-                   (Arg_Count = 1\n-                      and then Chars (Arg) /= Name_Increases\n-                      and then Chars (Arg) /= Name_Decreases)\n-               then\n-                  --  Only one invariant is allowed in the pragma\n+            else\n+               Error_Pragma_Arg (\"argument not allowed in pragma %\", Arg1);\n+            end if;\n \n-                  if Seen then\n-                     Error_Pragma_Arg\n-                       (\"only one invariant allowed in pragma %\", Arg);\n+            --  Process the second argument\n+\n+            if Present (Arg2) then\n+               if Chars (Arg2) = Name_Variant then\n+                  if Chars (Arg1) = Name_Variant then\n+                     Error_Pragma (\"only one variant allowed in pragma %\");\n                   else\n-                     Seen := True;\n-                     Preanalyze_And_Resolve (Expr, Any_Boolean);\n+                     Check_Variant (Arg2);\n                   end if;\n \n-               elsif Chars (Arg) = Name_Increases\n-                 or else Chars (Arg) = Name_Decreases\n-               then\n-                  Preanalyze_And_Resolve (Expr, Any_Discrete);\n-\n-               --  Illegal argument\n+               elsif Chars (Arg2) = Name_Invariant then\n+                  if Chars (Arg1) = Name_Variant then\n+                     Error_Pragma_Arg (\"invariant must precede variant\", Arg2);\n+                  else\n+                     Error_Pragma (\"only one invariant allowed in pragma %\");\n+                  end if;\n \n                else\n-                  Error_Pragma_Arg (\"argument not allowed in pragma %\", Arg);\n+                  Error_Pragma_Arg (\"argument not allowed in pragma %\", Arg2);\n                end if;\n-\n-               Next (Arg);\n-            end loop;\n+            end if;\n          end Loop_Assertion;\n \n          -----------------------"}, {"sha": "be0b7ff7e37005cdcde4ddcf5f76750ed1066b13", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=ed7b9d6ecfd1651d7c3fcd96f2b105bb2ba0349a", "patch": "@@ -671,7 +671,7 @@ package Snames is\n    Name_Component_Size_4               : constant Name_Id := N + $;\n    Name_Copy                           : constant Name_Id := N + $;\n    Name_D_Float                        : constant Name_Id := N + $;\n-   Name_Decreases                      : constant Name_Id := N + $;\n+   Name_Decreasing                     : constant Name_Id := N + $;\n    Name_Descriptor                     : constant Name_Id := N + $;\n    Name_Disable                        : constant Name_Id := N + $;\n    Name_Dot_Replacement                : constant Name_Id := N + $;\n@@ -691,7 +691,7 @@ package Snames is\n    Name_GPL                            : constant Name_Id := N + $;\n    Name_IEEE_Float                     : constant Name_Id := N + $;\n    Name_Ignore                         : constant Name_Id := N + $;\n-   Name_Increases                      : constant Name_Id := N + $;\n+   Name_Increasing                     : constant Name_Id := N + $;\n    Name_Info                           : constant Name_Id := N + $;\n    Name_Internal                       : constant Name_Id := N + $;\n    Name_Link_Name                      : constant Name_Id := N + $;\n@@ -753,6 +753,7 @@ package Snames is\n    Name_Unrestricted                   : constant Name_Id := N + $;\n    Name_Uppercase                      : constant Name_Id := N + $;\n    Name_User                           : constant Name_Id := N + $;\n+   Name_Variant                        : constant Name_Id := N + $;\n    Name_VAX_Float                      : constant Name_Id := N + $;\n    Name_VMS                            : constant Name_Id := N + $;\n    Name_Vtable_Ptr                     : constant Name_Id := N + $;"}]}