{"sha": "d67fb775b386216c2a09ed47b130182d3ebb7807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY3ZmI3NzViMzg2MjE2YzJhMDllZDQ3YjEzMDE4MmQzZWJiNzgwNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-11-13T14:18:04Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-11-13T14:18:04Z"}, "message": "cse.c (CHEAP_REGNO): Redefine using REGNO_PTR_FRAME_P and HARD_REGISTER_NUM_P.\n\n\t* cse.c (CHEAP_REGNO): Redefine using REGNO_PTR_FRAME_P and\n\tHARD_REGISTER_NUM_P.\n\n\t* cselib.c (new_cselib_val): Make comment correct and more detailed.\n\t* flow.c (mark_set_1): Likewise.\n\n\t* except.c (duplicate_eh_region_1, duplicate_eh_region_2,\n\tduplicate_eh_regions): Remove.\n\t* except.h (duplicate_eh_regions): Remove prototype.\n\t* integrate.c (get_label_from_map, copy_rtx_and_substitute,\n\tglobal_const_equiv_varray): Remove.\n\t* integrate.h (get_label_from_map, copy_rtx_and_substitute,\n\tglobal_const_equiv_varray, set_label_in_map): Remove prototypes,\n\textern declaration, and #define.\n\t(MAYBE_EXTEND_CONST_EQUIV_VARRAY, SET_CONST_EQUIV_DATA): Remove.\n\t(struct inline_remap): Remove.\n\t* varray.c (struct element): Remove entry for const_equiv_data.\n\t* varray.h (struct const_equiv_data): Remove.\n\t(enum varray_data_enum) <VARRAY_DATA_CONST_EQUIV>: Remove.\n\t(union varray_data_tag) <const_equiv>: Remove.\n\t(VARRAY_CONST_EQUIV_INIT, VARRAY_CONST_EQUIV,\n\tVARRAY_PUSH_CONST_EQUIV, VARRAY_TOP_CONST_EQUIV): Remove.\n\n\t* regstack.c (record_label_references): Remove unused function.\n\n\t* rtl.def (VALUE): Update comment.\n\t(LABEL_REF): Remove unused operand 2.\n\t* rtl.h (struct rtx_def): Update for removed accessor macros.\n\t(XCADVFLAGS, INSN_DEAD_CODE_P, LINE_NUMBER, CONTAINING_INSN,\n\tREG_LOOP_TEST_P): Remove.\n\t(ADDR_DIFF_VEC_FLAGS, CSELIB_VAL_PTR, LABEL_NEXTREF): Add comments.\n\t* web.c (entry_register): Don't copy REG_LOOP_TEST_P.\n\t* doc/rtl.texi (INSN_DEAD_CODE_P, REG_LOOP_TEST_P): Remove.\n\nFrom-SVN: r90580", "tree": {"sha": "a572ebf2a3de1b04d3af878e1ae572f9db1c8d50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a572ebf2a3de1b04d3af878e1ae572f9db1c8d50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d67fb775b386216c2a09ed47b130182d3ebb7807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d67fb775b386216c2a09ed47b130182d3ebb7807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d67fb775b386216c2a09ed47b130182d3ebb7807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d67fb775b386216c2a09ed47b130182d3ebb7807/comments", "author": null, "committer": null, "parents": [{"sha": "1136d30e655fb95c9776184c89147c1b0029cd14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1136d30e655fb95c9776184c89147c1b0029cd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1136d30e655fb95c9776184c89147c1b0029cd14"}], "stats": {"total": 896, "additions": 58, "deletions": 838}, "files": [{"sha": "8c5c3294f3fffd0c10d042b1593c58cf27d27be1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -1,3 +1,39 @@\n+2004-11-13  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cse.c (CHEAP_REGNO): Redefine using REGNO_PTR_FRAME_P and\n+\tHARD_REGISTER_NUM_P.\n+\n+\t* cselib.c (new_cselib_val): Make comment correct and more detailed.\n+\t* flow.c (mark_set_1): Likewise.\n+\n+\t* except.c (duplicate_eh_region_1, duplicate_eh_region_2,\n+\tduplicate_eh_regions): Remove.\n+\t* except.h (duplicate_eh_regions): Remove prototype.\n+\t* integrate.c (get_label_from_map, copy_rtx_and_substitute,\n+\tglobal_const_equiv_varray): Remove.\n+\t* integrate.h (get_label_from_map, copy_rtx_and_substitute,\n+\tglobal_const_equiv_varray, set_label_in_map): Remove prototypes,\n+\textern declaration, and #define.\n+\t(MAYBE_EXTEND_CONST_EQUIV_VARRAY, SET_CONST_EQUIV_DATA): Remove.\n+\t(struct inline_remap): Remove.\n+\t* varray.c (struct element): Remove entry for const_equiv_data.\n+\t* varray.h (struct const_equiv_data): Remove.\n+\t(enum varray_data_enum) <VARRAY_DATA_CONST_EQUIV>: Remove.\n+\t(union varray_data_tag) <const_equiv>: Remove.\n+\t(VARRAY_CONST_EQUIV_INIT, VARRAY_CONST_EQUIV,\n+\tVARRAY_PUSH_CONST_EQUIV, VARRAY_TOP_CONST_EQUIV): Remove.\n+\n+\t* regstack.c (record_label_references): Remove unused function.\n+\n+\t* rtl.def (VALUE): Update comment.\n+\t(LABEL_REF): Remove unused operand 2.\n+\t* rtl.h (struct rtx_def): Update for removed accessor macros.\n+\t(XCADVFLAGS, INSN_DEAD_CODE_P, LINE_NUMBER, CONTAINING_INSN,\n+\tREG_LOOP_TEST_P): Remove.\n+\t(ADDR_DIFF_VEC_FLAGS, CSELIB_VAL_PTR, LABEL_NEXTREF): Add comments.\n+\t* web.c (entry_register): Don't copy REG_LOOP_TEST_P.\n+\t* doc/rtl.texi (INSN_DEAD_CODE_P, REG_LOOP_TEST_P): Remove.\n+\n 2004-11-13  James A. Morrison  <phython@gcc.gnu.org>\n             Eric Botcazou  <ebotcazou@libertysurf.fr>\n "}, {"sha": "2797e437d3ac85fcee07c37121c194a8cb203a66", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -504,11 +504,9 @@ struct table_elt\n    of 0.  Next come pseudos with a cost of one and other hard registers with\n    a cost of 2.  Aside from these special cases, call `rtx_cost'.  */\n \n-#define CHEAP_REGNO(N) \\\n-  ((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM\t\\\n-   || (N) == STACK_POINTER_REGNUM || (N) == ARG_POINTER_REGNUM\t\t\\\n-   || ((N) >= FIRST_VIRTUAL_REGISTER && (N) <= LAST_VIRTUAL_REGISTER)\t\\\n-   || ((N) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n+#define CHEAP_REGNO(N)\t\t\t\t\t\t\t\\\n+  (REGNO_PTR_FRAME_P(N)\t\t\t\t\t\t\t\\\n+   || (HARD_REGISTER_NUM_P (N)\t\t\t\t\t\t\\\n        && FIXED_REGNO_P (N) && REGNO_REG_CLASS (N) != NO_REGS))\n \n #define COST(X) (REG_P (X) ? 0 : notreg_cost (X, SET))"}, {"sha": "df22800114d60ce8f12eb1ba40f10001be436983", "filename": "gcc/cselib.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -704,8 +704,11 @@ new_cselib_val (unsigned int value, enum machine_mode mode)\n   gcc_assert (value);\n \n   e->value = value;\n-  /* We use custom method to allocate this RTL construct because it accounts\n-     about 8% of overall memory usage.  */\n+  /* We use an alloc pool to allocate this RTL construct because it\n+     accounts for about 8% of the overall memory usage.  We know\n+     precisely when we can have VALUE RTXen (when cselib is active)\n+     so we don't need to put them in garbave collected memory.\n+     ??? Why should a VALUE be an RTX in the first place?  */\n   e->u.val_rtx = pool_alloc (value_pool);\n   memset (e->u.val_rtx, 0, RTX_HDR_SIZE);\n   PUT_CODE (e->u.val_rtx, VALUE);"}, {"sha": "869570b11c225eb42367159c560b29f58e203d04", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -537,14 +537,6 @@ that the branch is an annulling one.  See the discussion under\n @code{sequence} below.  Stored in the @code{unchanging} field and\n printed as @samp{/u}.\n \n-@findex INSN_DEAD_CODE_P\n-@cindex @code{insn} and @samp{/s}\n-@cindex @code{in_struct}, in @code{insn}\n-@item INSN_DEAD_CODE_P (@var{x})\n-In an @code{insn} during the dead-code elimination pass, nonzero if the\n-insn is dead.\n-Stored in the @code{in_struct} field and printed as @samp{/s}.\n-\n @findex INSN_DELETED_P\n @cindex @code{insn} and @samp{/v}\n @cindex @code{call_insn} and @samp{/v}\n@@ -660,14 +652,6 @@ value is going to be returned.  (This happens only in a hard\n register.)  Stored in the @code{integrated} field and printed as\n @samp{/i}.\n \n-@findex REG_LOOP_TEST_P\n-@cindex @code{reg} and @samp{/s}\n-@cindex @code{in_struct}, in @code{reg}\n-@item REG_LOOP_TEST_P (@var{x})\n-In @code{reg} expressions, nonzero if this register's entire life is\n-contained in the exit test code for some loop.  Stored in the\n-@code{in_struct} field and printed as @samp{/s}.\n-\n @findex REG_POINTER\n @cindex @code{reg} and @samp{/f}\n @cindex @code{frame_related}, in @code{reg}"}, {"sha": "71fc01153a6285c20d99fbd25b11c5a5e5f27104", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -265,9 +265,6 @@ static void remove_fixup_regions (void);\n static void remove_unreachable_regions (rtx);\n static void convert_from_eh_region_ranges_1 (rtx *, int *, int);\n \n-static struct eh_region *duplicate_eh_region_1 (struct eh_region *,\n-\t\t\t\t\t\tstruct inline_remap *);\n-static void duplicate_eh_region_2 (struct eh_region *, struct eh_region **);\n static int ttypes_filter_eq (const void *, const void *);\n static hashval_t ttypes_filter_hash (const void *);\n static int ehspec_filter_eq (const void *, const void *);\n@@ -1064,150 +1061,6 @@ current_function_has_exception_handlers (void)\n \n   return false;\n }\n-\f\n-static struct eh_region *\n-duplicate_eh_region_1 (struct eh_region *o, struct inline_remap *map)\n-{\n-  struct eh_region *n = ggc_alloc_cleared (sizeof (struct eh_region));\n-\n-  n->region_number = o->region_number + cfun->eh->last_region_number;\n-  n->type = o->type;\n-\n-  switch (n->type)\n-    {\n-    case ERT_CLEANUP:\n-    case ERT_MUST_NOT_THROW:\n-      break;\n-\n-    case ERT_TRY:\n-      if (o->u.try.continue_label)\n-\tn->u.try.continue_label\n-\t  = get_label_from_map (map,\n-\t\t\t\tCODE_LABEL_NUMBER (o->u.try.continue_label));\n-      break;\n-\n-    case ERT_CATCH:\n-      n->u.catch.type_list = o->u.catch.type_list;\n-      break;\n-\n-    case ERT_ALLOWED_EXCEPTIONS:\n-      n->u.allowed.type_list = o->u.allowed.type_list;\n-      break;\n-\n-    case ERT_THROW:\n-      n->u.throw.type = o->u.throw.type;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (o->label)\n-    n->label = get_label_from_map (map, CODE_LABEL_NUMBER (o->label));\n-  if (o->resume)\n-    {\n-      n->resume = map->insn_map[INSN_UID (o->resume)];\n-      gcc_assert (n->resume);\n-    }\n-\n-  return n;\n-}\n-\n-static void\n-duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array)\n-{\n-  struct eh_region *n = n_array[o->region_number];\n-\n-  switch (n->type)\n-    {\n-    case ERT_TRY:\n-      n->u.try.catch = n_array[o->u.try.catch->region_number];\n-      n->u.try.last_catch = n_array[o->u.try.last_catch->region_number];\n-      break;\n-\n-    case ERT_CATCH:\n-      if (o->u.catch.next_catch)\n-\tn->u.catch.next_catch = n_array[o->u.catch.next_catch->region_number];\n-      if (o->u.catch.prev_catch)\n-\tn->u.catch.prev_catch = n_array[o->u.catch.prev_catch->region_number];\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  if (o->outer)\n-    n->outer = n_array[o->outer->region_number];\n-  if (o->inner)\n-    n->inner = n_array[o->inner->region_number];\n-  if (o->next_peer)\n-    n->next_peer = n_array[o->next_peer->region_number];\n-}\n-\n-int\n-duplicate_eh_regions (struct function *ifun, struct inline_remap *map)\n-{\n-  int ifun_last_region_number = ifun->eh->last_region_number;\n-  struct eh_region **n_array, *root, *cur;\n-  int i;\n-\n-  if (ifun_last_region_number == 0)\n-    return 0;\n-\n-  n_array = xcalloc (ifun_last_region_number + 1, sizeof (*n_array));\n-\n-  for (i = 1; i <= ifun_last_region_number; ++i)\n-    {\n-      cur = ifun->eh->region_array[i];\n-      if (!cur || cur->region_number != i)\n-\tcontinue;\n-      n_array[i] = duplicate_eh_region_1 (cur, map);\n-    }\n-  for (i = 1; i <= ifun_last_region_number; ++i)\n-    {\n-      cur = ifun->eh->region_array[i];\n-      if (!cur || cur->region_number != i)\n-\tcontinue;\n-      duplicate_eh_region_2 (cur, n_array);\n-    }\n-\n-  root = n_array[ifun->eh->region_tree->region_number];\n-  cur = cfun->eh->cur_region;\n-  if (cur)\n-    {\n-      struct eh_region *p = cur->inner;\n-      if (p)\n-\t{\n-\t  while (p->next_peer)\n-\t    p = p->next_peer;\n-\t  p->next_peer = root;\n-\t}\n-      else\n-\tcur->inner = root;\n-\n-      for (i = 1; i <= ifun_last_region_number; ++i)\n-\tif (n_array[i] && n_array[i]->outer == NULL)\n-\t  n_array[i]->outer = cur;\n-    }\n-  else\n-    {\n-      struct eh_region *p = cfun->eh->region_tree;\n-      if (p)\n-\t{\n-\t  while (p->next_peer)\n-\t    p = p->next_peer;\n-\t  p->next_peer = root;\n-\t}\n-      else\n-\tcfun->eh->region_tree = root;\n-    }\n-\n-  free (n_array);\n-\n-  i = cfun->eh->last_region_number;\n-  cfun->eh->last_region_number = i + ifun_last_region_number;\n-  return i;\n-}\n-\n \f\n static int\n t2r_eq (const void *pentry, const void *pdata)"}, {"sha": "d79182f6463b535f14833da3d4d200dddb3d9a76", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -23,8 +23,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n struct function;\n \n-struct inline_remap;\n-\n /* Per-function EH data.  Used only in except.c, but GC and others\n    manipulate pointers to the opaque type.  */\n struct eh_status;\n@@ -83,7 +81,6 @@ extern void expand_eh_return (void);\n extern rtx expand_builtin_extend_pointer (tree);\n extern rtx get_exception_pointer (struct function *);\n extern rtx get_exception_filter (struct function *);\n-extern int duplicate_eh_regions (struct function *, struct inline_remap *);\n extern int check_handled (tree, tree);\n \n extern void sjlj_emit_function_exit_after (rtx);"}, {"sha": "1053d8306761e82cab4a25ad6667e345e1ae7f58", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -2634,7 +2634,7 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \tinvalidate_mems_from_set (pbi, reg);\n \n       /* If the memory reference had embedded side effects (autoincrement\n-\t address modes.  Then we may need to kill some entries on the\n+\t address modes) then we may need to kill some entries on the\n \t memory set list.  */\n       if (insn && MEM_P (reg))\n \tfor_each_rtx (&PATTERN (insn), invalidate_mems_from_autoinc, pbi);"}, {"sha": "e4a9ddd9d71972b6909ef7a89646d712bb741f91", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 420, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -64,21 +64,6 @@ typedef struct initial_value_struct GTY(()) {\n static void set_block_origin_self (tree);\n static void set_block_abstract_flags (tree, int);\n \f\n-/* Returns the Ith entry in the label_map contained in MAP.  If the\n-   Ith entry has not yet been set, return a fresh label.  This function\n-   performs a lazy initialization of label_map, thereby avoiding huge memory\n-   explosions when the label_map gets very large.  */\n-\n-rtx\n-get_label_from_map (struct inline_remap *map, int i)\n-{\n-  rtx x = map->label_map[i];\n-\n-  if (x == NULL_RTX)\n-    x = map->label_map[i] = gen_label_rtx ();\n-\n-  return x;\n-}\n \n /* Return false if the function FNDECL cannot be inlined on account of its\n    attributes, true otherwise.  */\n@@ -174,412 +159,7 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n \n   return copy;\n }\n-\f\n-/* Unfortunately, we need a global copy of const_equiv map for communication\n-   with a function called from note_stores.  Be *very* careful that this\n-   is used properly in the presence of recursion.  */\n-\n-varray_type global_const_equiv_varray;\n-\n-/* Create a new copy of an rtx. Recursively copies the operands of the rtx,\n-   except for those few rtx codes that are sharable.\n-\n-   We always return an rtx that is similar to that incoming rtx, with the\n-   exception of possibly changing a REG to a SUBREG or vice versa.  No\n-   rtl is ever emitted.\n-\n-   If FOR_LHS is nonzero, if means we are processing something that will\n-   be the LHS of a SET.\n-\n-   Handle constants that need to be placed in the constant pool by\n-   calling `force_const_mem'.  */\n-\n-rtx\n-copy_rtx_and_substitute (rtx orig, struct inline_remap *map, int for_lhs)\n-{\n-  rtx copy, temp;\n-  int i, j;\n-  RTX_CODE code;\n-  enum machine_mode mode;\n-  const char *format_ptr;\n-  int regno;\n-\n-  if (orig == 0)\n-    return 0;\n-\n-  code = GET_CODE (orig);\n-  mode = GET_MODE (orig);\n-\n-  switch (code)\n-    {\n-    case REG:\n-      /* If the stack pointer register shows up, it must be part of\n-\t stack-adjustments (*not* because we eliminated the frame pointer!).\n-\t Small hard registers are returned as-is.  Pseudo-registers\n-\t go through their `reg_map'.  */\n-      regno = REGNO (orig);\n-      if (regno <= LAST_VIRTUAL_REGISTER)\n-\t{\n-\t  /* Some hard registers are also mapped,\n-\t     but others are not translated.  */\n-\t  if (map->reg_map[regno] != 0)\n-\t    return map->reg_map[regno];\n-\n-\t  /* If this is the virtual frame pointer, make space in current\n-\t     function's stack frame for the stack frame of the inline function.\n-\n-\t     Copy the address of this area into a pseudo.  Map\n-\t     virtual_stack_vars_rtx to this pseudo and set up a constant\n-\t     equivalence for it to be the address.  This will substitute the\n-\t     address into insns where it can be substituted and use the new\n-\t     pseudo where it can't.  */\n-\t  else if (regno == VIRTUAL_STACK_VARS_REGNUM)\n-\t    {\n-\t      rtx loc, seq;\n-\t      int size\n-\t\t= get_func_frame_size (DECL_STRUCT_FUNCTION (map->fndecl));\n-#ifdef FRAME_GROWS_DOWNWARD\n-\t      int alignment\n-\t\t= (DECL_STRUCT_FUNCTION (map->fndecl)->stack_alignment_needed\n-\t\t   / BITS_PER_UNIT);\n-\n-\t      /* In this case, virtual_stack_vars_rtx points to one byte\n-\t\t higher than the top of the frame area.  So make sure we\n-\t\t allocate a big enough chunk to keep the frame pointer\n-\t\t aligned like a real one.  */\n-\t      if (alignment)\n-\t\tsize = CEIL_ROUND (size, alignment);\n-#endif\n-\t      start_sequence ();\n-\t      loc = assign_stack_temp (BLKmode, size, 1);\n-\t      loc = XEXP (loc, 0);\n-#ifdef FRAME_GROWS_DOWNWARD\n-\t      /* In this case, virtual_stack_vars_rtx points to one byte\n-\t\t higher than the top of the frame area.  So compute the offset\n-\t\t to one byte higher than our substitute frame.  */\n-\t      loc = plus_constant (loc, size);\n-#endif\n-\t      map->reg_map[regno] = temp\n-\t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n-\n-#ifdef STACK_BOUNDARY\n-\t      mark_reg_pointer (map->reg_map[regno], STACK_BOUNDARY);\n-#endif\n-\n-\t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n-\n-\t      seq = get_insns ();\n-\t      end_sequence ();\n-\t      emit_insn_after (seq, map->insns_at_start);\n-\t      return temp;\n-\t    }\n-\t  else if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n-\t    {\n-\t      /* Do the same for a block to contain any arguments referenced\n-\t\t in memory.  */\n-\t      rtx loc, seq;\n-\t      int size = DECL_STRUCT_FUNCTION (map->fndecl)->args_size;\n-\n-\t      start_sequence ();\n-\t      loc = assign_stack_temp (BLKmode, size, 1);\n-\t      loc = XEXP (loc, 0);\n-\t      /* When arguments grow downward, the virtual incoming\n-\t\t args pointer points to the top of the argument block,\n-\t\t so the remapped location better do the same.  */\n-#ifdef ARGS_GROW_DOWNWARD\n-\t      loc = plus_constant (loc, size);\n-#endif\n-\t      map->reg_map[regno] = temp\n-\t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n-\n-#ifdef STACK_BOUNDARY\n-\t      mark_reg_pointer (map->reg_map[regno], STACK_BOUNDARY);\n-#endif\n-\n-\t      SET_CONST_EQUIV_DATA (map, temp, loc, CONST_AGE_PARM);\n-\n-\t      seq = get_insns ();\n-\t      end_sequence ();\n-\t      emit_insn_after (seq, map->insns_at_start);\n-\t      return temp;\n-\t    }\n-\t  else\n-\t    return orig;\n-\n-\t  abort ();\n-\t}\n-      if (map->reg_map[regno] == NULL)\n-\t{\n-\t  map->reg_map[regno] = gen_reg_rtx (mode);\n-\t  REG_USERVAR_P (map->reg_map[regno]) = REG_USERVAR_P (orig);\n-\t  REG_LOOP_TEST_P (map->reg_map[regno]) = REG_LOOP_TEST_P (orig);\n-\t  /* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */\n-\n-\t  if (REG_POINTER (map->x_regno_reg_rtx[regno]))\n-\t    mark_reg_pointer (map->reg_map[regno],\n-\t\t\t      map->regno_pointer_align[regno]);\n-\t}\n-      return map->reg_map[regno];\n-\n-    case SUBREG:\n-      copy = copy_rtx_and_substitute (SUBREG_REG (orig), map, for_lhs);\n-      return simplify_gen_subreg (GET_MODE (orig), copy,\n-\t\t\t\t  GET_MODE (SUBREG_REG (orig)),\n-\t\t\t\t  SUBREG_BYTE (orig));\n-\n-    case USE:\n-    case CLOBBER:\n-      /* USE and CLOBBER are ordinary, but we convert (use (subreg foo))\n-\t to (use foo) if the original insn didn't have a subreg.\n-\t Removing the subreg distorts the VAX movmemhi pattern\n-\t by changing the mode of an operand.  */\n-      copy = copy_rtx_and_substitute (XEXP (orig, 0), map, code == CLOBBER);\n-      if (GET_CODE (copy) == SUBREG && GET_CODE (XEXP (orig, 0)) != SUBREG)\n-\tcopy = SUBREG_REG (copy);\n-      return gen_rtx_fmt_e (code, VOIDmode, copy);\n-\n-    /* We need to handle \"deleted\" labels that appear in the DECL_RTL\n-       of a LABEL_DECL.  */\n-    case NOTE:\n-      if (NOTE_LINE_NUMBER (orig) != NOTE_INSN_DELETED_LABEL)\n-\tbreak;\n-\n-      /* Fall through.  */\n-    case CODE_LABEL:\n-      LABEL_PRESERVE_P (get_label_from_map (map, CODE_LABEL_NUMBER (orig)))\n-\t= LABEL_PRESERVE_P (orig);\n-      return get_label_from_map (map, CODE_LABEL_NUMBER (orig));\n-\n-    case LABEL_REF:\n-      copy\n-\t= gen_rtx_LABEL_REF\n-\t  (mode,\n-\t   LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n-\t   : get_label_from_map (map, CODE_LABEL_NUMBER (XEXP (orig, 0))));\n-\n-      LABEL_OUTSIDE_LOOP_P (copy) = LABEL_OUTSIDE_LOOP_P (orig);\n-\n-      /* The fact that this label was previously nonlocal does not mean\n-\t it still is, so we must check if it is within the range of\n-\t this function's labels.  */\n-      LABEL_REF_NONLOCAL_P (copy)\n-\t= (LABEL_REF_NONLOCAL_P (orig)\n-\t   && ! (CODE_LABEL_NUMBER (XEXP (copy, 0)) >= get_first_label_num ()\n-\t\t && CODE_LABEL_NUMBER (XEXP (copy, 0)) < max_label_num ()));\n-\n-      return copy;\n-\n-    case PC:\n-    case CC0:\n-    case CONST_INT:\n-    case CONST_VECTOR:\n-      return orig;\n-\n-    case SYMBOL_REF:\n-      /* Symbols which represent the address of a label stored in the constant\n-\t pool must be modified to point to a constant pool entry for the\n-\t remapped label.  Otherwise, symbols are returned unchanged.  */\n-      if (CONSTANT_POOL_ADDRESS_P (orig))\n-\t{\n-\t  struct function *f = cfun;\n-\t  rtx constant = get_pool_constant_for_function (f, orig);\n-\t  if (GET_CODE (constant) == LABEL_REF)\n-\t    return XEXP (force_const_mem\n-\t\t\t (GET_MODE (orig),\n-\t\t\t  copy_rtx_and_substitute (constant, map, for_lhs)),\n-\t\t\t 0);\n-\t}\n-      return orig;\n-\n-    case CONST_DOUBLE:\n-      /* We have to make a new copy of this CONST_DOUBLE because don't want\n-\t to use the old value of CONST_DOUBLE_MEM.  Also, this may be a\n-\t duplicate of a CONST_DOUBLE we have already seen.  */\n-      if (GET_MODE_CLASS (GET_MODE (orig)) == MODE_FLOAT)\n-\t{\n-\t  REAL_VALUE_TYPE d;\n-\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (d, orig);\n-\t  return CONST_DOUBLE_FROM_REAL_VALUE (d, GET_MODE (orig));\n-\t}\n-      else\n-\treturn immed_double_const (CONST_DOUBLE_LOW (orig),\n-\t\t\t\t   CONST_DOUBLE_HIGH (orig), VOIDmode);\n-\n-    case CONST:\n-      break;\n-\n-    case ASM_OPERANDS:\n-      /* If a single asm insn contains multiple output operands then\n-\t it contains multiple ASM_OPERANDS rtx's that share the input\n-\t and constraint vecs.  We must make sure that the copied insn\n-\t continues to share it.  */\n-      if (map->orig_asm_operands_vector == ASM_OPERANDS_INPUT_VEC (orig))\n-\t{\n-\t  copy = rtx_alloc (ASM_OPERANDS);\n-\t  RTX_FLAG (copy, volatil) = RTX_FLAG (orig, volatil);\n-\t  PUT_MODE (copy, GET_MODE (orig));\n-\t  ASM_OPERANDS_TEMPLATE (copy) = ASM_OPERANDS_TEMPLATE (orig);\n-\t  ASM_OPERANDS_OUTPUT_CONSTRAINT (copy)\n-\t    = ASM_OPERANDS_OUTPUT_CONSTRAINT (orig);\n-\t  ASM_OPERANDS_OUTPUT_IDX (copy) = ASM_OPERANDS_OUTPUT_IDX (orig);\n-\t  ASM_OPERANDS_INPUT_VEC (copy) = map->copy_asm_operands_vector;\n-\t  ASM_OPERANDS_INPUT_CONSTRAINT_VEC (copy)\n-\t    = map->copy_asm_constraints_vector;\n-#ifdef USE_MAPPED_LOCATION\n-\t  ASM_OPERANDS_SOURCE_LOCATION (copy)\n-\t    = ASM_OPERANDS_SOURCE_LOCATION (orig);\n-#else\n-\t  ASM_OPERANDS_SOURCE_FILE (copy) = ASM_OPERANDS_SOURCE_FILE (orig);\n-\t  ASM_OPERANDS_SOURCE_LINE (copy) = ASM_OPERANDS_SOURCE_LINE (orig);\n-#endif\n-\t  return copy;\n-\t}\n-      break;\n-\n-    case CALL:\n-      /* This is given special treatment because the first\n-\t operand of a CALL is a (MEM ...) which may get\n-\t forced into a register for cse.  This is undesirable\n-\t if function-address cse isn't wanted or if we won't do cse.  */\n-#ifndef NO_FUNCTION_CSE\n-      if (! (optimize && ! flag_no_function_cse))\n-#endif\n-\t{\n-\t  rtx copy\n-\t    = gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n-\t\t\t   copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0),\n-\t\t\t\t\t\t    map, 0));\n-\n-\t  MEM_COPY_ATTRIBUTES (copy, XEXP (orig, 0));\n-\n-\t  return\n-\t    gen_rtx_CALL (GET_MODE (orig), copy,\n-\t\t\t  copy_rtx_and_substitute (XEXP (orig, 1), map, 0));\n-\t}\n-      break;\n-\n-#if 0\n-    /* Must be ifdefed out for loop unrolling to work.  */\n-    /* ??? Is this for the old or the new unroller?  */\n-    case RETURN:\n-      abort ();\n-#endif\n \n-    case SET:\n-      /* If this is setting fp or ap, it means that we have a nonlocal goto.\n-\t Adjust the setting by the offset of the area we made.\n-\t If the nonlocal goto is into the current function,\n-\t this will result in unnecessarily bad code, but should work.  */\n-      if (SET_DEST (orig) == virtual_stack_vars_rtx\n-\t  || SET_DEST (orig) == virtual_incoming_args_rtx)\n-\t{\n-\t  /* In case a translation hasn't occurred already, make one now.  */\n-\t  rtx equiv_reg;\n-\t  rtx equiv_loc;\n-\t  HOST_WIDE_INT loc_offset;\n-\n-\t  copy_rtx_and_substitute (SET_DEST (orig), map, for_lhs);\n-\t  equiv_reg = map->reg_map[REGNO (SET_DEST (orig))];\n-\t  equiv_loc = VARRAY_CONST_EQUIV (map->const_equiv_varray,\n-\t\t\t\t\t  REGNO (equiv_reg)).rtx;\n-\t  loc_offset\n-\t    = REG_P (equiv_loc) ? 0 : INTVAL (XEXP (equiv_loc, 1));\n-\n-\t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n-\t\t\t      force_operand\n-\t\t\t      (plus_constant\n-\t\t\t       (copy_rtx_and_substitute (SET_SRC (orig),\n-\t\t\t\t\t\t\t map, 0),\n-\t\t\t\t- loc_offset),\n-\t\t\t       NULL_RTX));\n-\t}\n-      else\n-\treturn gen_rtx_SET (VOIDmode,\n-\t\t\t    copy_rtx_and_substitute (SET_DEST (orig), map, 1),\n-\t\t\t    copy_rtx_and_substitute (SET_SRC (orig), map, 0));\n-      break;\n-\n-    case MEM:\n-      copy = gen_rtx_MEM (mode, copy_rtx_and_substitute (XEXP (orig, 0),\n-\t\t\t\t\t\t\t map, 0));\n-      MEM_COPY_ATTRIBUTES (copy, orig);\n-      return copy;\n-\n-    default:\n-      break;\n-    }\n-\n-  copy = rtx_alloc (code);\n-  PUT_MODE (copy, mode);\n-  RTX_FLAG (copy, in_struct) = RTX_FLAG (orig, in_struct);\n-  RTX_FLAG (copy, volatil) = RTX_FLAG (orig, volatil);\n-  RTX_FLAG (copy, unchanging) = RTX_FLAG (orig, unchanging);\n-\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n-\n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n-    {\n-      switch (*format_ptr++)\n-\t{\n-\tcase '0':\n-\t  X0ANY (copy, i) = X0ANY (orig, i);\n-\t  break;\n-\n-\tcase 'e':\n-\t  XEXP (copy, i)\n-\t    = copy_rtx_and_substitute (XEXP (orig, i), map, for_lhs);\n-\t  break;\n-\n-\tcase 'u':\n-\t  /* Change any references to old-insns to point to the\n-\t     corresponding copied insns.  */\n-\t  XEXP (copy, i) = map->insn_map[INSN_UID (XEXP (orig, i))];\n-\t  break;\n-\n-\tcase 'E':\n-\t  XVEC (copy, i) = XVEC (orig, i);\n-\t  if (XVEC (orig, i) != NULL && XVECLEN (orig, i) != 0)\n-\t    {\n-\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n-\t      for (j = 0; j < XVECLEN (copy, i); j++)\n-\t\tXVECEXP (copy, i, j)\n-\t\t  = copy_rtx_and_substitute (XVECEXP (orig, i, j),\n-\t\t\t\t\t     map, for_lhs);\n-\t    }\n-\t  break;\n-\n-\tcase 'w':\n-\t  XWINT (copy, i) = XWINT (orig, i);\n-\t  break;\n-\n-\tcase 'i':\n-\t  XINT (copy, i) = XINT (orig, i);\n-\t  break;\n-\n-\tcase 's':\n-\t  XSTR (copy, i) = XSTR (orig, i);\n-\t  break;\n-\n-\tcase 't':\n-\t  XTREE (copy, i) = XTREE (orig, i);\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-\n-  if (code == ASM_OPERANDS && map->orig_asm_operands_vector == 0)\n-    {\n-      map->orig_asm_operands_vector = ASM_OPERANDS_INPUT_VEC (orig);\n-      map->copy_asm_operands_vector = ASM_OPERANDS_INPUT_VEC (copy);\n-      map->copy_asm_constraints_vector\n-\t= ASM_OPERANDS_INPUT_CONSTRAINT_VEC (copy);\n-    }\n-\n-  return copy;\n-}\n \f\n /* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so"}, {"sha": "2d6cffcbe435cdaf20a8ef606587aaa5daa14a0f", "filename": "gcc/integrate.h", "status": "modified", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -21,100 +21,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"varray.h\"\n \n-/* This structure is used to remap objects in the function being inlined to\n-   those belonging to the calling function.  It is passed by\n-   expand_inline_function to its children.\n-\n-   This structure is also used when unrolling loops and otherwise\n-   replicating code, although not all fields are needed in this case;\n-   only those fields needed by copy_rtx_and_substitute() and its children\n-   are used.\n-\n-   This structure is used instead of static variables because\n-   expand_inline_function may be called recursively via expand_expr.  */\n-\n-struct inline_remap\n-{\n-  /* Definition of function be inlined.  */\n-  tree fndecl;\n-  /* Place to put insns needed at start of function.  */\n-  rtx insns_at_start;\n-  /* Mapping from old registers to new registers.\n-     It is allocated and deallocated in `expand_inline_function' */\n-  rtx *reg_map;\n-  /* Mapping from old code-labels to new code-labels.\n-     The first element of this map is label_map[min_labelno].  */\n-  rtx *label_map;\n-  /* Mapping from old insn uid's to copied insns.  The first element\n-   of this map is insn_map[min_insnno]; the last element is\n-   insn_map[max_insnno].  We keep the bounds here for when the map\n-   only covers a partial range of insns (such as loop unrolling or\n-   code replication).  */\n-  rtx *insn_map;\n-  int min_insnno, max_insnno;\n-\n-  /* Map pseudo reg number in calling function to equivalent constant.  We\n-     cannot in general substitute constants into parameter pseudo registers,\n-     since some machine descriptions (many RISCs) won't always handle\n-     the resulting insns.  So if an incoming parameter has a constant\n-     equivalent, we record it here, and if the resulting insn is\n-     recognizable, we go with it.\n-\n-     We also use this mechanism to convert references to incoming arguments\n-     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n-     incoming argument and virtual stacked variables registers with new\n-     pseudos that contain pointers into the replacement area allocated for\n-     this inline instance.  These pseudos are then marked as being equivalent\n-     to the appropriate address and substituted if valid.  */\n-  varray_type const_equiv_varray;\n-  /* This is incremented for each new basic block.\n-     It is used to store in the age field to record the domain of validity\n-     of each entry in const_equiv_varray.\n-     A value of -1 indicates an entry for a reg which is a parm.\n-     All other values are \"positive\".  */\n-#define CONST_AGE_PARM (-1)\n-  unsigned int const_age;\n-\n-  /* When an insn is being copied by copy_rtx_and_substitute,\n-     this is nonzero if we have copied an ASM_OPERANDS.\n-     In that case, it is the original input-operand vector.  */\n-  rtvec orig_asm_operands_vector;\n-  /* When an insn is being copied by copy_rtx_and_substitute,\n-     this is nonzero if we have copied an ASM_OPERANDS.\n-     In that case, it is the copied input-operand vector.  */\n-  rtvec copy_asm_operands_vector;\n-  /* Likewise, this is the copied constraints vector.  */\n-  rtvec copy_asm_constraints_vector;\n-\n-  /* Indications for regs being pointers and their alignment.  */\n-  unsigned char *regno_pointer_align;\n-  rtx *x_regno_reg_rtx;\n-\n-  /* The next few fields are used for subst_constants to record the SETs\n-     that it saw.  */\n-  int num_sets;\n-  struct equiv_table\n-    {\n-      rtx dest;\n-      rtx equiv;\n-    }  equiv_sets[MAX_RECOG_OPERANDS];\n-  /* Record the last thing assigned to pc.  This is used for folded\n-     conditional branch insns.  */\n-  rtx last_pc_value;\n-#ifdef HAVE_cc0\n-  /* Record the last thing assigned to cc0.  */\n-  rtx last_cc0_value;\n-#endif\n-  /* Note mode of COMPARE if the mode would be otherwise lost (comparing of\n-     two VOIDmode constants.  */\n-  rtx compare_src;\n-  enum machine_mode compare_mode;\n-};\n-\n-/* Return a copy of an rtx (as needed), substituting pseudo-register,\n-   labels, and frame-pointer offsets as necessary.  */\n-extern rtx copy_rtx_and_substitute (rtx, struct inline_remap *, int);\n-\n /* Return a pseudo that corresponds to the value in the specified hard\n    reg as of the start of the function (for inlined functions, the\n    value at the start of the parent function).  */\n@@ -142,35 +48,3 @@ extern tree copy_decl_for_inlining (tree, tree, tree);\n    true otherwise.  */\n extern bool function_attribute_inlinable_p (tree);\n \n-/* Return the label indicated.  */\n-extern rtx get_label_from_map (struct inline_remap *, int);\n-\n-/* Set the label indicated.  */\n-#define set_label_in_map(MAP, I, X) ((MAP)->label_map[I] = (X))\n-\n-/* Unfortunately, we need a global copy of const_equiv varray for\n-   communication with a function called from note_stores.  Be *very*\n-   careful that this is used properly in the presence of recursion.  */\n-\n-extern varray_type global_const_equiv_varray;\n-\n-#define MAYBE_EXTEND_CONST_EQUIV_VARRAY(MAP,MAX)\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if ((size_t)(MAX) >= VARRAY_SIZE ((MAP)->const_equiv_varray))\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        int is_global = (global_const_equiv_varray\t\t\t\\\n-\t\t\t == (MAP)->const_equiv_varray);\t\t\t\\\n-        VARRAY_GROW ((MAP)->const_equiv_varray, (MAX)+1);\t\t\\\n-\tif (is_global)\t\t\t\t\t\t\t\\\n-\t   global_const_equiv_varray = (MAP)->const_equiv_varray;\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\n-\n-#define SET_CONST_EQUIV_DATA(MAP,REG,RTX,AGE)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    struct const_equiv_data *p;\t\t\t\t\t\t\\\n-    MAYBE_EXTEND_CONST_EQUIV_VARRAY ((MAP), REGNO (REG));\t\t\\\n-    p = &VARRAY_CONST_EQUIV ((MAP)->const_equiv_varray, REGNO (REG));\t\\\n-    p->rtx = (RTX);\t\t\t\t\t\t\t\\\n-    p->age = (AGE);\t\t\t\t\t\t\t\\\n-  }"}, {"sha": "d5983bbaf1870055a82bb2bc2b5ea852089b9c0a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -265,7 +265,6 @@ static int convert_regs_2 (FILE *, basic_block);\n static int convert_regs (FILE *);\n static void print_stack (FILE *, stack);\n static rtx next_flags_user (rtx);\n-static void record_label_references (rtx, rtx);\n static bool compensate_edge (edge, FILE *);\n \f\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n@@ -491,58 +490,7 @@ reg_to_stack (FILE *file)\n   free_aux_for_blocks ();\n   return true;\n }\n-\f\n-/* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the\n-   label's chain of references, and note which insn contains each\n-   reference.  */\n-\n-static void\n-record_label_references (rtx insn, rtx pat)\n-{\n-  enum rtx_code code = GET_CODE (pat);\n-  int i;\n-  const char *fmt;\n-\n-  if (code == LABEL_REF)\n-    {\n-      rtx label = XEXP (pat, 0);\n-      rtx ref;\n-\n-      gcc_assert (LABEL_P (label));\n-\n-      /* If this is an undefined label, LABEL_REFS (label) contains\n-         garbage.  */\n-      if (INSN_UID (label) == 0)\n-\treturn;\n-\n-      /* Don't make a duplicate in the code_label's chain.  */\n \n-      for (ref = LABEL_REFS (label);\n-\t   ref && ref != label;\n-\t   ref = LABEL_NEXTREF (ref))\n-\tif (CONTAINING_INSN (ref) == insn)\n-\t  return;\n-\n-      CONTAINING_INSN (pat) = insn;\n-      LABEL_NEXTREF (pat) = LABEL_REFS (label);\n-      LABEL_REFS (label) = pat;\n-\n-      return;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\trecord_label_references (insn, XEXP (pat, i));\n-      if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = 0; j < XVECLEN (pat, i); j++)\n-\t    record_label_references (insn, XVECEXP (pat, i, j));\n-\t}\n-    }\n-}\n \f\n /* Return a pointer to the REG expression within PAT.  If PAT is not a\n    REG, possible enclosed by a conversion rtx, return the inner part of"}, {"sha": "c20f61bdd4b9e3c4c5e8aa9266ce852dc5779cb0", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -331,7 +331,9 @@ DEF_RTL_EXPR(CONST, \"const\", \"e\", RTX_CONST_OBJ)\n    by a SET whose first operand is (PC).  */\n DEF_RTL_EXPR(PC, \"pc\", \"\", RTX_OBJ)\n \n-/* Used in the cselib routines to describe a value.  */\n+/* Used in the cselib routines to describe a value.  Objects of this\n+   kind are only allocated in cselib.c, in an alloc pool instead of\n+   in GC memory.  The only operand of a VALUE is a cselib_val_struct.  */\n DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n \n /* A register.  The \"operand\" is the register number, accessed with\n@@ -387,9 +389,8 @@ DEF_RTL_EXPR(MEM, \"mem\", \"e0\", RTX_OBJ)\n \n /* Reference to an assembler label in the code for this function.\n    The operand is a CODE_LABEL found in the insn chain.\n-   The unprinted fields 1 and 2 are used in flow.c for the\n-   LABEL_NEXTREF and CONTAINING_INSN.  */\n-DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", RTX_CONST_OBJ)\n+   The unprinted field 1 is used in flow.c for the LABEL_NEXTREF.  */\n+DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u0\", RTX_CONST_OBJ)\n \n /* Reference to a named label: \n    Operand 0: label name"}, {"sha": "2ff874bd7a3e4ebfd27a4dc05997065bed088707", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -220,16 +220,11 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      promoted mode.\n      1 in a CODE_LABEL if the label is used for nonlocal gotos\n      and must not be deleted even if its count is zero.\n-     1 in a LABEL_REF if this is a reference to a label outside the\n-     current loop.\n      1 in an INSN, JUMP_INSN or CALL_INSN if this insn must be scheduled\n      together with the preceding insn.  Valid only within sched.\n      1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n      from the target of a branch.  Valid from reorg until end of compilation;\n-     cleared before used.\n-     1 in an INSN, JUMP_INSN or CALL_INSN or related rtx if this insn is\n-     dead code.  Valid only during dead-code elimination phase; cleared\n-     before use.  */\n+     cleared before used.  */\n   unsigned int in_struct : 1;\n   /* At the end of RTL generation, 1 if this rtx is used.  This is used for\n      copying shared structure.  See `unshare_all_rtl'.\n@@ -642,7 +637,6 @@ do {\t\t\t\t\\\n #define XCBITMAP(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_bit)\n #define XCTREE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rt_tree)\n #define XCBBDEF(RTX, N, C)    (RTL_CHECKC1 (RTX, N, C).rt_bb)\n-#define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1 (RTX, N, C).rt_addr_diff_vec_flags)\n #define XCCSELIB(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_cselib)\n \n #define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n@@ -698,28 +692,26 @@ do {\t\t\t\t\\\n #define INSN_ANNULLED_BRANCH_P(RTX)\t\t\t\t\t\\\n   (RTL_FLAG_CHECK3(\"INSN_ANNULLED_BRANCH_P\", (RTX), JUMP_INSN, CALL_INSN, INSN)->unchanging)\n \n-/* 1 if RTX is an insn that is dead code.  Valid only for dead-code\n-   elimination phase.  */\n-#define INSN_DEAD_CODE_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"INSN_DEAD_CODE_P\", (RTX), INSN, CALL_INSN, JUMP_INSN)->in_struct)\n-\n /* 1 if RTX is an insn in a delay slot and is from the target of the branch.\n    If the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n    executed if the branch is taken.  For annulled branches with this bit\n    clear, the insn should be executed only if the branch is not taken.  */\n #define INSN_FROM_TARGET_P(RTX)\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK3(\"INSN_FROM_TARGET_P\", (RTX), INSN, JUMP_INSN, CALL_INSN)->in_struct)\n \n+/* In an ADDR_DIFF_VEC, the flags for RTX for use by branch shortening.\n+   See the comments for ADDR_DIFF_VEC in rtl.def.  */\n #define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n \n+/* In a VALUE, the value cselib has assigned to RTX.\n+   This is a \"struct cselib_val_struct\", see cselib.h.  */\n #define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n \n /* Holds a list of notes on what this insn does to various REGs.\n    It is a chain of EXPR_LIST rtx's, where the second operand is the\n    chain pointer and the first operand is the REG being described.\n    The mode field of the EXPR_LIST contains not a real machine mode\n    but a value from enum reg_note.  */\n-\n #define REG_NOTES(INSN)\tXEXP(INSN, 8)\n \n enum reg_note\n@@ -757,8 +749,6 @@ extern const char * const reg_note_name[];\n    Label numbers are unique in a compilation.  */\n #define CODE_LABEL_NUMBER(INSN)\tXINT (INSN, 6)\n \n-#define LINE_NUMBER NOTE\n-\n /* In a NOTE that is a line number, this is a string for the file name that the\n    line is in.  We use the same field to record block numbers temporarily in\n    NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes.  (We avoid lots of casts\n@@ -908,15 +898,11 @@ enum label_kind\n \f\n /* This is the field in the LABEL_REF through which the circular chain\n    of references to a particular label is linked.\n-   This chain is set up in flow.c.  */\n-\n+   FIXME: This chain is used in loop.c and in the SH backend.\n+\t  Since loop.c is about to go away, it could be a win to replace\n+\t  the uses of this in the SH backend with something else.  */\n #define LABEL_NEXTREF(REF) XCEXP (REF, 1, LABEL_REF)\n \n-/* Once basic blocks are found in flow.c,\n-   Each LABEL_REF points to its containing instruction with this field.  */\n-\n-#define CONTAINING_INSN(RTX) XCEXP (RTX, 2, LABEL_REF)\n-\n /* For a REG rtx, REGNO extracts the register number.  ORIGINAL_REGNO holds\n    the number the register originally had; for a pseudo register turned into\n    a hard reg this will hold the old pseudo register number.  */\n@@ -948,7 +934,6 @@ enum label_kind\n #define HARD_REGISTER_NUM_P(REG_NO) ((REG_NO) < FIRST_PSEUDO_REGISTER)\n \n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n-\n #define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)\n \n /* For a CONST_DOUBLE:\n@@ -1162,10 +1147,6 @@ do {\t\t\t\t\t\t\\\n #define LABEL_PRESERVE_P(RTX)\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK2(\"LABEL_PRESERVE_P\", (RTX), CODE_LABEL, NOTE)->in_struct)\n \n-/* 1 if RTX is a reg that is used only in an exit test of a loop.  */\n-#define REG_LOOP_TEST_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"REG_LOOP_TEST_P\", (RTX), REG)->in_struct)\n-\n /* During sched, 1 if RTX is an insn that must be scheduled together\n    with the preceding insn.  */\n #define SCHED_GROUP_P(RTX)\t\t\t\t\t\t\\"}, {"sha": "e80827a5ce6c2c24878cbe77d549e139af80325a", "filename": "gcc/varray.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -113,7 +113,6 @@ static const struct {\n   { sizeof (union tree_node *), 1 },\n   { sizeof (struct bitmap_head_def *), 1 },\n   { sizeof (struct reg_info_def *), 0 },\n-  { sizeof (struct const_equiv_data), 0 },\n   { sizeof (struct basic_block_def *), 1 },\n   { sizeof (struct elt_list *), 1 },\n   { sizeof (struct edge_def *), 1 },"}, {"sha": "c896fe23a33420174c66c3612e54c4799f55000a", "filename": "gcc/varray.h", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -33,30 +33,6 @@\n #include \"tm.h\"\n #endif\n \n-/* Auxiliary structure used inside the varray structure, used for\n-   function integration data.  */\n-\n-struct const_equiv_data GTY(()) {\n-  /* Map pseudo reg number in calling function to equivalent constant.  We\n-     cannot in general substitute constants into parameter pseudo registers,\n-     since some machine descriptions (many RISCs) won't always handle\n-     the resulting insns.  So if an incoming parameter has a constant\n-     equivalent, we record it here, and if the resulting insn is\n-     recognizable, we go with it.\n-\n-     We also use this mechanism to convert references to incoming arguments\n-     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n-     incoming argument and virtual stacked variables registers with new\n-     pseudos that contain pointers into the replacement area allocated for\n-     this inline instance.  These pseudos are then marked as being equivalent\n-     to the appropriate address and substituted if valid.  */\n-  rtx rtx;\n-\n-  /* Record the valid age for each entry.  The entry is invalid if its\n-     age is less than const_age.  */\n-  unsigned age;\n-};\n-\n /* Enum indicating what the varray contains.\n    If this is changed, `element' in varray.c needs to be updated.  */\n \n@@ -79,7 +55,6 @@ enum varray_data_enum {\n   VARRAY_DATA_TREE,\n   VARRAY_DATA_BITMAP,\n   VARRAY_DATA_REG,\n-  VARRAY_DATA_CONST_EQUIV,\n   VARRAY_DATA_BB,\n   VARRAY_DATA_TE,\n   VARRAY_DATA_EDGE,\n@@ -125,8 +100,6 @@ typedef union varray_data_tag GTY (()) {\n \t\t\t\ttag (\"VARRAY_DATA_BITMAP\")))\tbitmap[1];\n   struct reg_info_def\t *GTY ((length (\"%0.num_elements\"), skip,\n \t\t\t\ttag (\"VARRAY_DATA_REG\")))\treg[1];\n-  struct const_equiv_data GTY ((length (\"%0.num_elements\"),\n-\t\t\ttag (\"VARRAY_DATA_CONST_EQUIV\")))\tconst_equiv[1];\n   struct basic_block_def *GTY ((length (\"%0.num_elements\"), skip,\n \t\t\t\ttag (\"VARRAY_DATA_BB\")))\tbb[1];\n   struct elt_list\t *GTY ((length (\"%0.num_elements\"),\n@@ -207,9 +180,6 @@ extern varray_type varray_init (size_t, enum varray_data_enum, const char *);\n #define VARRAY_REG_INIT(va, num, name) \\\n   va = varray_init (num, VARRAY_DATA_REG, name)\n \n-#define VARRAY_CONST_EQUIV_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_CONST_EQUIV, name)\n-\n #define VARRAY_BB_INIT(va, num, name) \\\n   va = varray_init (num, VARRAY_DATA_BB, name)\n \n@@ -298,7 +268,6 @@ extern void varray_underflow (varray_type, const char *, int, const char *)\n #define VARRAY_TREE(VA, N)\t\tVARRAY_CHECK (VA, N, tree)\n #define VARRAY_BITMAP(VA, N)\t\tVARRAY_CHECK (VA, N, bitmap)\n #define VARRAY_REG(VA, N)\t\tVARRAY_CHECK (VA, N, reg)\n-#define VARRAY_CONST_EQUIV(VA, N)\tVARRAY_CHECK (VA, N, const_equiv)\n #define VARRAY_BB(VA, N)\t\tVARRAY_CHECK (VA, N, bb)\n #define VARRAY_ELT_LIST(VA, N)\t\tVARRAY_CHECK (VA, N, te)\n #define VARRAY_EDGE(VA, N)\t\tVARRAY_CHECK (VA, N, e)\n@@ -323,7 +292,6 @@ extern void varray_underflow (varray_type, const char *, int, const char *)\n #define VARRAY_PUSH_TREE(VA, X)\t\tVARRAY_PUSH (VA, tree, X)\n #define VARRAY_PUSH_BITMAP(VA, X)\tVARRAY_PUSH (VA, bitmap, X)\n #define VARRAY_PUSH_REG(VA, X)\t\tVARRAY_PUSH (VA, reg, X)\n-#define VARRAY_PUSH_CONST_EQUIV(VA, X)\tVARRAY_PUSH (VA, const_equiv, X)\n #define VARRAY_PUSH_BB(VA, X)\t\tVARRAY_PUSH (VA, bb, X)\n #define VARRAY_PUSH_EDGE(VA, X)\t\tVARRAY_PUSH (VA, e, X)\n #define VARRAY_PUSH_TREE_PTR(VA, X)\tVARRAY_PUSH (VA, tp, X)\n@@ -349,7 +317,6 @@ extern void varray_underflow (varray_type, const char *, int, const char *)\n #define VARRAY_TOP_TREE(VA)\t\tVARRAY_TOP (VA, tree)\n #define VARRAY_TOP_BITMAP(VA)\t        VARRAY_TOP (VA, bitmap)\n #define VARRAY_TOP_REG(VA)\t\tVARRAY_TOP (VA, reg)\n-#define VARRAY_TOP_CONST_EQUIV(VA)\tVARRAY_TOP (VA, const_equiv)\n #define VARRAY_TOP_BB(VA)\t\tVARRAY_TOP (VA, bb)\n #define VARRAY_TOP_EDGE(VA)\t\tVARRAY_TOP (VA, e)\n #define VARRAY_TOP_TREE_PTR(VA)\t\tVARRAY_TOP (VA, tp)"}, {"sha": "97ac74f3287974598ceaba5b468ee07fd9a67d9a", "filename": "gcc/web.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d67fb775b386216c2a09ed47b130182d3ebb7807/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=d67fb775b386216c2a09ed47b130182d3ebb7807", "patch": "@@ -201,7 +201,6 @@ entry_register (struct web_entry *entry, struct ref *ref, char *used)\n       newreg = gen_reg_rtx (GET_MODE (reg));\n       REG_USERVAR_P (newreg) = REG_USERVAR_P (reg);\n       REG_POINTER (newreg) = REG_POINTER (reg);\n-      REG_LOOP_TEST_P (newreg) = REG_LOOP_TEST_P (reg);\n       REG_ATTRS (newreg) = REG_ATTRS (reg);\n       if (dump_file)\n \tfprintf (dump_file, \"Web oldreg=%i newreg=%i\\n\", REGNO (reg),"}]}