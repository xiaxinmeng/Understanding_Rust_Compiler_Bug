{"sha": "613497aa6e28ca009d8498002424019d2a8a9ca5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzNDk3YWE2ZTI4Y2EwMDlkODQ5ODAwMjQyNDAxOWQyYThhOWNhNQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-01T00:21:16Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-07-01T00:21:16Z"}, "message": "c++: Extend the PR96204 fix to variable templates too\n\nr12-1829 corrected the access scope during partial specialization\nmatching of class templates, but overlooked the variable template case.\nThis patch moves the access scope adjustment to within\nmost_specialized_partial_spec so that all callers can benefit.\n\nThis patch also adjusts a couple of these callers to avoid always\npassing the most general template of a variable template specialization,\nsince that'd cause us to push the wrong access scope for e.g. the second\ntestcase below (we'd push A<T> instead of A<int>/A<char>).  We ought to\nbe passing the partially instantiated template instead.\n\n\tPR c++/96204\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (finish_template_variable): Pass the partially\n\tinstantiated template and its args to instantiate_template.\n\t(instantiate_class_template_1): No need to call\n\tpush_nested_class and pop_nested_class around the call to\n\tmost_specialized_partial_spec.\n\t(instantiate_template_1): Pass the partially instantiated\n\ttemplate to lookup_template_variable.\n\t(most_specialized_partial_spec):  Use push_access_scope_guard\n\tto set the access scope appropriately.  Use\n\tdeferring_access_check_sentinel to force access to get checked\n\timmediately.\n\t(instantiate_decl): Just pass the VAR_DECL to\n\tmost_specialized_partial_spec.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/access41.C: New test.\n\t* g++.dg/template/access41a.C: New test.", "tree": {"sha": "3fef3700df8725b851222f694696d1b784f0e292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fef3700df8725b851222f694696d1b784f0e292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/613497aa6e28ca009d8498002424019d2a8a9ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613497aa6e28ca009d8498002424019d2a8a9ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613497aa6e28ca009d8498002424019d2a8a9ca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613497aa6e28ca009d8498002424019d2a8a9ca5/comments", "author": null, "committer": null, "parents": [{"sha": "25b6bfea5f14da53116f2d3efe2446de89b9bc03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b6bfea5f14da53116f2d3efe2446de89b9bc03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25b6bfea5f14da53116f2d3efe2446de89b9bc03"}], "stats": {"total": 74, "additions": 63, "deletions": 11}, "files": [{"sha": "dda6c9e940d436b07f11dbb58337d82cfdf6e6a0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613497aa6e28ca009d8498002424019d2a8a9ca5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613497aa6e28ca009d8498002424019d2a8a9ca5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=613497aa6e28ca009d8498002424019d2a8a9ca5", "patch": "@@ -10268,10 +10268,6 @@ finish_template_variable (tree var, tsubst_flags_t complain)\n   tree templ = TREE_OPERAND (var, 0);\n   tree arglist = TREE_OPERAND (var, 1);\n \n-  tree tmpl_args = DECL_TI_ARGS (DECL_TEMPLATE_RESULT (templ));\n-  arglist = add_outermost_template_args (tmpl_args, arglist);\n-\n-  templ = most_general_template (templ);\n   tree parms = DECL_TEMPLATE_PARMS (templ);\n   arglist = coerce_innermost_template_parms (parms, arglist, templ, complain,\n \t\t\t\t\t     /*req_all*/true,\n@@ -11774,11 +11770,8 @@ instantiate_class_template_1 (tree type)\n   deferring_access_check_sentinel acs (dk_no_deferred);\n \n   /* Determine what specialization of the original template to\n-     instantiate; do this relative to the scope of the class for\n-     sake of access checking.  */\n-  push_nested_class (type);\n+     instantiate.  */\n   t = most_specialized_partial_spec (type, tf_warning_or_error);\n-  pop_nested_class ();\n   if (t == error_mark_node)\n     return error_mark_node;\n   else if (t)\n@@ -21134,7 +21127,7 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n       /* We need to determine if we're using a partial or explicit\n \t specialization now, because the type of the variable could be\n \t different.  */\n-      tree tid = lookup_template_variable (gen_tmpl, targ_ptr);\n+      tree tid = lookup_template_variable (tmpl, targ_ptr);\n       tree elt = most_specialized_partial_spec (tid, complain);\n       if (elt == error_mark_node)\n \tpattern = error_mark_node;\n@@ -24987,26 +24980,33 @@ most_specialized_partial_spec (tree target, tsubst_flags_t complain)\n   tree outer_args = NULL_TREE;\n   tree tmpl, args;\n \n+  tree decl;\n   if (TYPE_P (target))\n     {\n       tree tinfo = CLASSTYPE_TEMPLATE_INFO (target);\n       tmpl = TI_TEMPLATE (tinfo);\n       args = TI_ARGS (tinfo);\n+      decl = TYPE_NAME (target);\n     }\n   else if (TREE_CODE (target) == TEMPLATE_ID_EXPR)\n     {\n       tmpl = TREE_OPERAND (target, 0);\n       args = TREE_OPERAND (target, 1);\n+      decl = DECL_TEMPLATE_RESULT (tmpl);\n     }\n   else if (VAR_P (target))\n     {\n       tree tinfo = DECL_TEMPLATE_INFO (target);\n       tmpl = TI_TEMPLATE (tinfo);\n       args = TI_ARGS (tinfo);\n+      decl = target;\n     }\n   else\n     gcc_unreachable ();\n \n+  push_access_scope_guard pas (decl);\n+  deferring_access_check_sentinel acs (dk_no_deferred);\n+\n   tree main_tmpl = most_general_template (tmpl);\n \n   /* For determining which partial specialization to use, only the\n@@ -26011,8 +26011,7 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n   if (variable_template_specialization_p (d))\n     {\n       /* Look up an explicit specialization, if any.  */\n-      tree tid = lookup_template_variable (gen_tmpl, gen_args);\n-      tree elt = most_specialized_partial_spec (tid, tf_warning_or_error);\n+      tree elt = most_specialized_partial_spec (d, tf_warning_or_error);\n       if (elt && elt != error_mark_node)\n \t{\n \t  td = TREE_VALUE (elt);"}, {"sha": "1ab9a1ab243b8a3156dba0f645bb14414660b9c6", "filename": "gcc/testsuite/g++.dg/template/access41.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613497aa6e28ca009d8498002424019d2a8a9ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613497aa6e28ca009d8498002424019d2a8a9ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess41.C?ref=613497aa6e28ca009d8498002424019d2a8a9ca5", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/96204\n+// { dg-do compile { target c++14 } }\n+// A variant of access40.C where has_type_member is a variable template instead\n+// of a class template.\n+\n+template<class, class = void>\n+constexpr bool has_type_member = false;\n+\n+template<class T>\n+constexpr bool has_type_member<T, typename T::type> = true;\n+\n+struct Parent;\n+\n+struct Child {\n+private:\n+  friend struct Parent;\n+  typedef void type;\n+};\n+\n+struct Parent {\n+  // The partial specialization does not match despite Child::type\n+  // being accessible from the current scope.\n+  static_assert(!has_type_member<Child>, \"\");\n+};"}, {"sha": "e108049048de2ab0e7e872f7939d40c1123a30a1", "filename": "gcc/testsuite/g++.dg/template/access41a.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613497aa6e28ca009d8498002424019d2a8a9ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess41a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613497aa6e28ca009d8498002424019d2a8a9ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess41a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess41a.C?ref=613497aa6e28ca009d8498002424019d2a8a9ca5", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/96204\n+// { dg-do compile { target c++14 } }\n+// A variant of access40a.C where has_type_member is a variable template instead\n+// of a class template.\n+\n+template<class T>\n+struct A {\n+  template<class, class = void>\n+  static constexpr bool has_type_member = false;\n+};\n+\n+template<class T>\n+template<class U>\n+constexpr int A<T>::has_type_member<U, typename U::type> = true;\n+\n+struct Child {\n+private:\n+  friend struct A<int>;\n+  typedef void type;\n+};\n+\n+// The partial specialization matches because A<int> is a friend of Child.\n+static_assert(A<int>::has_type_member<Child>, \"\");\n+using type1 = const int;\n+using type1 = decltype(A<int>::has_type_member<Child>);\n+\n+static_assert(!A<char>::has_type_member<Child>, \"\");\n+using type2 = const bool;\n+using type2 = decltype(A<char>::has_type_member<Child>);"}]}