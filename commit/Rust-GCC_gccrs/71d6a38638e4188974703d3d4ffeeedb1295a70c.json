{"sha": "71d6a38638e4188974703d3d4ffeeedb1295a70c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkNmEzODYzOGU0MTg4OTc0NzAzZDNkNGZmZWVlZGIxMjk1YTcwYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-15T13:12:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-15T13:12:25Z"}, "message": "Make dse.c use offset/width instead of start/end\n\nstore_info and read_info_type in dse.c represented the ranges as\nstart/end, but a lot of the internal code used offset/width instead.\nUsing offset/width throughout fits better with the poly_int.h\nrange-checking functions.\n\n2017-12-15  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* dse.c (store_info, read_info_type): Replace begin and end with\n\toffset and width.\n\t(print_range): New function.\n\t(set_all_positions_unneeded, any_positions_needed_p)\n\t(check_mem_read_rtx, scan_stores, scan_reads, dse_step5): Update\n\taccordingly.\n\t(record_store): Likewise.  Optimize the case in which all positions\n\tare unneeded.\n\t(get_stored_val): Replace read_begin and read_end with read_offset\n\tand read_width.\n\t(replace_read): Update call accordingly.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255692", "tree": {"sha": "6d48e167eab27ea9e460decae8ed9dd5cff36f56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d48e167eab27ea9e460decae8ed9dd5cff36f56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d6a38638e4188974703d3d4ffeeedb1295a70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d6a38638e4188974703d3d4ffeeedb1295a70c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d6a38638e4188974703d3d4ffeeedb1295a70c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d6a38638e4188974703d3d4ffeeedb1295a70c/comments", "author": null, "committer": null, "parents": [{"sha": "1eeeda473c577152f6a1a9846b4c0df376622b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eeeda473c577152f6a1a9846b4c0df376622b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eeeda473c577152f6a1a9846b4c0df376622b95"}], "stats": {"total": 210, "additions": 132, "deletions": 78}, "files": [{"sha": "e83d5beaa1a03671056e909440a8e2728ff0bbce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6a38638e4188974703d3d4ffeeedb1295a70c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6a38638e4188974703d3d4ffeeedb1295a70c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71d6a38638e4188974703d3d4ffeeedb1295a70c", "patch": "@@ -1,3 +1,19 @@\n+2017-12-15  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* dse.c (store_info, read_info_type): Replace begin and end with\n+\toffset and width.\n+\t(print_range): New function.\n+\t(set_all_positions_unneeded, any_positions_needed_p)\n+\t(check_mem_read_rtx, scan_stores, scan_reads, dse_step5): Update\n+\taccordingly.\n+\t(record_store): Likewise.  Optimize the case in which all positions\n+\tare unneeded.\n+\t(get_stored_val): Replace read_begin and read_end with read_offset\n+\tand read_width.\n+\t(replace_read): Update call accordingly.\n+\n 2017-12-15  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gimple-loop-interchange.cc (STMT_COST_RATIO): New macro."}, {"sha": "fbc6b25ac1ecc1678894c2267980c3cdeaf39266", "filename": "gcc/dse.c", "status": "modified", "additions": 116, "deletions": 78, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d6a38638e4188974703d3d4ffeeedb1295a70c/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d6a38638e4188974703d3d4ffeeedb1295a70c/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=71d6a38638e4188974703d3d4ffeeedb1295a70c", "patch": "@@ -243,9 +243,12 @@ struct store_info\n   /* Canonized MEM address for use by canon_true_dependence.  */\n   rtx mem_addr;\n \n-  /* The offset of the first and byte before the last byte associated\n-     with the operation.  */\n-  HOST_WIDE_INT begin, end;\n+  /* The offset of the first byte associated with the operation.  */\n+  HOST_WIDE_INT offset;\n+\n+  /* The number of bytes covered by the operation.  This is always exact\n+     and known (rather than -1).  */\n+  HOST_WIDE_INT width;\n \n   union\n     {\n@@ -261,7 +264,7 @@ struct store_info\n \t  bitmap bmap;\n \n \t  /* Number of set bits (i.e. unneeded bytes) in BITMAP.  If it is\n-\t     equal to END - BEGIN, the whole store is unused.  */\n+\t     equal to WIDTH, the whole store is unused.  */\n \t  int count;\n \t} large;\n     } positions_needed;\n@@ -304,10 +307,11 @@ struct read_info_type\n   /* The id of the mem group of the base address.  */\n   int group_id;\n \n-  /* The offset of the first and byte after the last byte associated\n-     with the operation.  If begin == end == 0, the read did not have\n-     a constant offset.  */\n-  int begin, end;\n+  /* The offset of the first byte associated with the operation.  */\n+  HOST_WIDE_INT offset;\n+\n+  /* The number of bytes covered by the operation, or -1 if not known.  */\n+  HOST_WIDE_INT width;\n \n   /* The mem being read.  */\n   rtx mem;\n@@ -586,6 +590,18 @@ static bitmap kill_on_calls;\n \n /* The number of bits used in the global bitmaps.  */\n static unsigned int current_position;\n+\n+/* Print offset range [OFFSET, OFFSET + WIDTH) to FILE.  */\n+\n+static void\n+print_range (FILE *file, poly_int64 offset, poly_int64 width)\n+{\n+  fprintf (file, \"[\");\n+  print_dec (offset, file, SIGNED);\n+  fprintf (file, \"..\");\n+  print_dec (offset + width, file, SIGNED);\n+  fprintf (file, \")\");\n+}\n \f\n /*----------------------------------------------------------------------------\n    Zeroth step.\n@@ -1212,10 +1228,9 @@ set_all_positions_unneeded (store_info *s_info)\n {\n   if (__builtin_expect (s_info->is_large, false))\n     {\n-      int pos, end = s_info->end - s_info->begin;\n-      for (pos = 0; pos < end; pos++)\n-\tbitmap_set_bit (s_info->positions_needed.large.bmap, pos);\n-      s_info->positions_needed.large.count = end;\n+      bitmap_set_range (s_info->positions_needed.large.bmap,\n+\t\t\t0, s_info->width);\n+      s_info->positions_needed.large.count = s_info->width;\n     }\n   else\n     s_info->positions_needed.small_bitmask = HOST_WIDE_INT_0U;\n@@ -1227,8 +1242,7 @@ static inline bool\n any_positions_needed_p (store_info *s_info)\n {\n   if (__builtin_expect (s_info->is_large, false))\n-    return (s_info->positions_needed.large.count\n-\t    < s_info->end - s_info->begin);\n+    return s_info->positions_needed.large.count < s_info->width;\n   else\n     return (s_info->positions_needed.small_bitmask != HOST_WIDE_INT_0U);\n }\n@@ -1361,8 +1375,12 @@ record_store (rtx body, bb_info_t bb_info)\n       set_usage_bits (group, offset, width, expr);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \" processing const base store gid=%d[%d..%d)\\n\",\n-\t\t group_id, (int)offset, (int)(offset+width));\n+\t{\n+\t  fprintf (dump_file, \" processing const base store gid=%d\",\n+\t\t   group_id);\n+\t  print_range (dump_file, offset, width);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n   else\n     {\n@@ -1374,8 +1392,11 @@ record_store (rtx body, bb_info_t bb_info)\n       group_id = -1;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \" processing cselib store [%d..%d)\\n\",\n-\t\t (int)offset, (int)(offset+width));\n+\t{\n+\t  fprintf (dump_file, \" processing cselib store \");\n+\t  print_range (dump_file, offset, width);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n \n   const_rhs = rhs = NULL_RTX;\n@@ -1441,18 +1462,21 @@ record_store (rtx body, bb_info_t bb_info)\n \t{\n \t  HOST_WIDE_INT i;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"    trying store in insn=%d gid=%d[%d..%d)\\n\",\n-\t\t     INSN_UID (ptr->insn), s_info->group_id,\n-\t\t     (int)s_info->begin, (int)s_info->end);\n+\t    {\n+\t      fprintf (dump_file, \"    trying store in insn=%d gid=%d\",\n+\t\t       INSN_UID (ptr->insn), s_info->group_id);\n+\t      print_range (dump_file, s_info->offset, s_info->width);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \n \t  /* Even if PTR won't be eliminated as unneeded, if both\n \t     PTR and this insn store the same constant value, we might\n \t     eliminate this insn instead.  */\n \t  if (s_info->const_rhs\n \t      && const_rhs\n-\t      && offset >= s_info->begin\n-\t      && offset + width <= s_info->end\n-\t      && all_positions_needed_p (s_info, offset - s_info->begin,\n+\t      && known_subrange_p (offset, width,\n+\t\t\t\t   s_info->offset, s_info->width)\n+\t      && all_positions_needed_p (s_info, offset - s_info->offset,\n \t\t\t\t\t width))\n \t    {\n \t      if (GET_MODE (mem) == BLKmode)\n@@ -1468,8 +1492,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t{\n \t\t  rtx val;\n \t\t  start_sequence ();\n-\t\t  val = get_stored_val (s_info, GET_MODE (mem),\n-\t\t\t\t\toffset, offset + width,\n+\t\t  val = get_stored_val (s_info, GET_MODE (mem), offset, width,\n \t\t\t\t\tBLOCK_FOR_INSN (insn_info->insn),\n \t\t\t\t\ttrue);\n \t\t  if (get_insns () != NULL)\n@@ -1480,10 +1503,18 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t}\n \t    }\n \n-\t  for (i = MAX (offset, s_info->begin);\n-\t       i < offset + width && i < s_info->end;\n-\t       i++)\n-\t    set_position_unneeded (s_info, i - s_info->begin);\n+\t  if (known_subrange_p (s_info->offset, s_info->width, offset, width))\n+\t    /* The new store touches every byte that S_INFO does.  */\n+\t    set_all_positions_unneeded (s_info);\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT begin_unneeded = offset - s_info->offset;\n+\t      HOST_WIDE_INT end_unneeded = begin_unneeded + width;\n+\t      begin_unneeded = MAX (begin_unneeded, 0);\n+\t      end_unneeded = MIN (end_unneeded, s_info->width);\n+\t      for (i = begin_unneeded; i < end_unneeded; ++i)\n+\t\tset_position_unneeded (s_info, i);\n+\t    }\n \t}\n       else if (s_info->rhs)\n \t/* Need to see if it is possible for this store to overwrite\n@@ -1541,8 +1572,8 @@ record_store (rtx body, bb_info_t bb_info)\n       store_info->positions_needed.small_bitmask = lowpart_bitmask (width);\n     }\n   store_info->group_id = group_id;\n-  store_info->begin = offset;\n-  store_info->end = offset + width;\n+  store_info->offset = offset;\n+  store_info->width = width;\n   store_info->is_set = GET_CODE (body) == SET;\n   store_info->rhs = rhs;\n   store_info->const_rhs = const_rhs;\n@@ -1704,39 +1735,38 @@ look_for_hardregs (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n }\n \n /* Helper function for replace_read and record_store.\n-   Attempt to return a value stored in STORE_INFO, from READ_BEGIN\n-   to one before READ_END bytes read in READ_MODE.  Return NULL\n+   Attempt to return a value of mode READ_MODE stored in STORE_INFO,\n+   consisting of READ_WIDTH bytes starting from READ_OFFSET.  Return NULL\n    if not successful.  If REQUIRE_CST is true, return always constant.  */\n \n static rtx\n get_stored_val (store_info *store_info, machine_mode read_mode,\n-\t\tHOST_WIDE_INT read_begin, HOST_WIDE_INT read_end,\n+\t\tHOST_WIDE_INT read_offset, HOST_WIDE_INT read_width,\n \t\tbasic_block bb, bool require_cst)\n {\n   machine_mode store_mode = GET_MODE (store_info->mem);\n-  int shift;\n-  int access_size; /* In bytes.  */\n+  HOST_WIDE_INT gap;\n   rtx read_reg;\n \n   /* To get here the read is within the boundaries of the write so\n      shift will never be negative.  Start out with the shift being in\n      bytes.  */\n   if (store_mode == BLKmode)\n-    shift = 0;\n+    gap = 0;\n   else if (BYTES_BIG_ENDIAN)\n-    shift = store_info->end - read_end;\n+    gap = ((store_info->offset + store_info->width)\n+\t   - (read_offset + read_width));\n   else\n-    shift = read_begin - store_info->begin;\n-\n-  access_size = shift + GET_MODE_SIZE (read_mode);\n-\n-  /* From now on it is bits.  */\n-  shift *= BITS_PER_UNIT;\n+    gap = read_offset - store_info->offset;\n \n-  if (shift)\n-    read_reg = find_shift_sequence (access_size, store_info, read_mode, shift,\n-    \t\t\t\t    optimize_bb_for_speed_p (bb),\n-\t\t\t\t    require_cst);\n+  if (gap != 0)\n+    {\n+      HOST_WIDE_INT shift = gap * BITS_PER_UNIT;\n+      HOST_WIDE_INT access_size = GET_MODE_SIZE (read_mode) + gap;\n+      read_reg = find_shift_sequence (access_size, store_info, read_mode,\n+\t\t\t\t      shift, optimize_bb_for_speed_p (bb),\n+\t\t\t\t      require_cst);\n+    }\n   else if (store_mode == BLKmode)\n     {\n       /* The store is a memset (addr, const_val, const_size).  */\n@@ -1839,7 +1869,7 @@ replace_read (store_info *store_info, insn_info_t store_insn,\n   start_sequence ();\n   bb = BLOCK_FOR_INSN (read_insn->insn);\n   read_reg = get_stored_val (store_info,\n-\t\t\t     read_mode, read_info->begin, read_info->end,\n+\t\t\t     read_mode, read_info->offset, read_info->width,\n \t\t\t     bb, false);\n   if (read_reg == NULL_RTX)\n     {\n@@ -2000,8 +2030,8 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n   read_info = read_info_type_pool.allocate ();\n   read_info->group_id = group_id;\n   read_info->mem = mem;\n-  read_info->begin = offset;\n-  read_info->end = offset + width;\n+  read_info->offset = offset;\n+  read_info->width = width;\n   read_info->next = insn_info->read_rec;\n   insn_info->read_rec = read_info;\n   if (group_id < 0)\n@@ -2027,8 +2057,11 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n \t    fprintf (dump_file, \" processing const load gid=%d[BLK]\\n\",\n \t\t     group_id);\n \t  else\n-\t    fprintf (dump_file, \" processing const load gid=%d[%d..%d)\\n\",\n-\t\t     group_id, (int)offset, (int)(offset+width));\n+\t    {\n+\t      fprintf (dump_file, \" processing const load gid=%d\", group_id);\n+\t      print_range (dump_file, offset, width);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \t}\n \n       while (i_ptr)\n@@ -2066,19 +2099,20 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n \t      else\n \t\t{\n \t\t  if (store_info->rhs\n-\t\t      && offset >= store_info->begin\n-\t\t      && offset + width <= store_info->end\n+\t\t      && known_subrange_p (offset, width, store_info->offset,\n+\t\t\t\t\t   store_info->width)\n \t\t      && all_positions_needed_p (store_info,\n-\t\t\t\t\t\t offset - store_info->begin,\n+\t\t\t\t\t\t offset - store_info->offset,\n \t\t\t\t\t\t width)\n \t\t      && replace_read (store_info, i_ptr, read_info,\n \t\t\t\t       insn_info, loc, bb_info->regs_live))\n \t\t    return;\n \n \t\t  /* The bases are the same, just see if the offsets\n-\t\t     overlap.  */\n-\t\t  if ((offset < store_info->end)\n-\t\t      && (offset + width > store_info->begin))\n+\t\t     could overlap.  */\n+\t\t  if (ranges_maybe_overlap_p (offset, width,\n+\t\t\t\t\t      store_info->offset,\n+\t\t\t\t\t      store_info->width))\n \t\t    remove = true;\n \t\t}\n \t    }\n@@ -2133,11 +2167,10 @@ check_mem_read_rtx (rtx *loc, bb_info_t bb_info)\n \t  if (store_info->rhs\n \t      && store_info->group_id == -1\n \t      && store_info->cse_base == base\n-\t      && width != -1\n-\t      && offset >= store_info->begin\n-\t      && offset + width <= store_info->end\n+\t      && known_subrange_p (offset, width, store_info->offset,\n+\t\t\t\t   store_info->width)\n \t      && all_positions_needed_p (store_info,\n-\t\t\t\t\t offset - store_info->begin, width)\n+\t\t\t\t\t offset - store_info->offset, width)\n \t      && replace_read (store_info, i_ptr,  read_info, insn_info, loc,\n \t\t\t       bb_info->regs_live))\n \t    return;\n@@ -2789,16 +2822,19 @@ scan_stores (store_info *store_info, bitmap gen, bitmap kill)\n       group_info *group_info\n \t= rtx_group_vec[store_info->group_id];\n       if (group_info->process_globally)\n-\tfor (i = store_info->begin; i < store_info->end; i++)\n-\t  {\n-\t    int index = get_bitmap_index (group_info, i);\n-\t    if (index != 0)\n-\t      {\n-\t\tbitmap_set_bit (gen, index);\n-\t\tif (kill)\n-\t\t  bitmap_clear_bit (kill, index);\n-\t      }\n-\t  }\n+\t{\n+\t  HOST_WIDE_INT end = store_info->offset + store_info->width;\n+\t  for (i = store_info->offset; i < end; i++)\n+\t    {\n+\t      int index = get_bitmap_index (group_info, i);\n+\t      if (index != 0)\n+\t\t{\n+\t\t  bitmap_set_bit (gen, index);\n+\t\t  if (kill)\n+\t\t    bitmap_clear_bit (kill, index);\n+\t\t}\n+\t    }\n+\t}\n       store_info = store_info->next;\n     }\n }\n@@ -2848,9 +2884,9 @@ scan_reads (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t    {\n \t      if (i == read_info->group_id)\n \t\t{\n-\t\t  if (read_info->begin > read_info->end)\n+\t\t  if (!known_size_p (read_info->width))\n \t\t    {\n-\t\t      /* Begin > end for block mode reads.  */\n+\t\t      /* Handle block mode reads.  */\n \t\t      if (kill)\n \t\t\tbitmap_ior_into (kill, group->group_kill);\n \t\t      bitmap_and_compl_into (gen, group->group_kill);\n@@ -2860,7 +2896,8 @@ scan_reads (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t\t      /* The groups are the same, just process the\n \t\t\t offsets.  */\n \t\t      HOST_WIDE_INT j;\n-\t\t      for (j = read_info->begin; j < read_info->end; j++)\n+\t\t      HOST_WIDE_INT end = read_info->offset + read_info->width;\n+\t\t      for (j = read_info->offset; j < end; j++)\n \t\t\t{\n \t\t\t  int index = get_bitmap_index (group, j);\n \t\t\t  if (index != 0)\n@@ -3279,7 +3316,8 @@ dse_step5 (void)\n \t      HOST_WIDE_INT i;\n \t      group_info *group_info = rtx_group_vec[store_info->group_id];\n \n-\t      for (i = store_info->begin; i < store_info->end; i++)\n+\t      HOST_WIDE_INT end = store_info->offset + store_info->width;\n+\t      for (i = store_info->offset; i < end; i++)\n \t\t{\n \t\t  int index = get_bitmap_index (group_info, i);\n "}]}