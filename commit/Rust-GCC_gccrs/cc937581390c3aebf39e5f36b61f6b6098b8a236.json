{"sha": "cc937581390c3aebf39e5f36b61f6b6098b8a236", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5Mzc1ODEzOTBjM2FlYmYzOWU1ZjM2YjYxZjZiNjA5OGI4YTIzNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@stanford.edu", "date": "2001-03-07T01:32:01Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-03-07T01:32:01Z"}, "message": "c-parse.in (yylexname): New function, split out of _yylex.\n\n\n\t* c-parse.in (yylexname): New function, split out of _yylex.\n\t(objc_rid_sans_at): New table.\n\t(init_reswords): Initialize it.\n\t(_yylex): Give labels clearer names.  Handle CPP_ATSIGN by\n\tretrieving the next token and checking it for significance as\n\tan ObjC keyword or string constant.\n\n\t* cpplex.c (_cpp_lex_token): Just return CPP_ATSIGN for '@'.\n\t* cpplib.h (TTYPE_TABLE): Add CPP_ATSIGN, drop CPP_OSTRING.\n\n\t* c-lex.c, c-parse.in, cppmacro.c, cpplex.c, cp/spew.c: Remove\n\treferences to CPP_OSTRING.\n\nFrom-SVN: r40279", "tree": {"sha": "6fd6ae80f761d7e077d853c2bbffc740946a5e0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fd6ae80f761d7e077d853c2bbffc740946a5e0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc937581390c3aebf39e5f36b61f6b6098b8a236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc937581390c3aebf39e5f36b61f6b6098b8a236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc937581390c3aebf39e5f36b61f6b6098b8a236", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc937581390c3aebf39e5f36b61f6b6098b8a236/comments", "author": null, "committer": null, "parents": [{"sha": "8b44d68f7b41308b3ea5b66642352c6fc8946093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b44d68f7b41308b3ea5b66642352c6fc8946093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b44d68f7b41308b3ea5b66642352c6fc8946093"}], "stats": {"total": 229, "additions": 123, "deletions": 106}, "files": [{"sha": "bacb88dbf39886f7c54bafa7ff5d36ccc025d913", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -1,3 +1,18 @@\n+2001-03-06  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* c-parse.in (yylexname): New function, split out of _yylex.\n+\t(objc_rid_sans_at): New table.\n+\t(init_reswords): Initialize it.\n+\t(_yylex): Give labels clearer names.  Handle CPP_ATSIGN by\n+\tretrieving the next token and checking it for significance as\n+\tan ObjC keyword or string constant.\n+\n+\t* cpplex.c (_cpp_lex_token): Just return CPP_ATSIGN for '@'.\n+\t* cpplib.h (TTYPE_TABLE): Add CPP_ATSIGN, drop CPP_OSTRING.\n+\n+\t* c-lex.c, c-parse.in, cppmacro.c, cpplex.c: Remove references\n+\tto CPP_OSTRING.\n+\n 2001-03-06  Stephen L Moshier  <moshier@mediaone.net>\n \n \t* config/m68k/m68k.c (const_uint32_operand): Accept any"}, {"sha": "f68ae35a219adfa8f354df929fbd0103d0c5f1e0", "filename": "gcc/c-lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -1014,7 +1014,6 @@ c_lex (value)\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-    case CPP_OSTRING:\n       *value = lex_string ((const char *)tok.val.str.text,\n \t\t\t   tok.val.str.len, tok.type == CPP_WSTRING);\n       break;"}, {"sha": "d187ab4e16a61f8ed14ddbd3df07eed0db5ee9c5", "filename": "gcc/c-parse.in", "status": "modified", "additions": 99, "deletions": 65, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -263,6 +263,7 @@ end ifobjc\n \n static void yyprint\t  PARAMS ((FILE *, int, YYSTYPE));\n static void yyerror\t  PARAMS ((const char *));\n+static int yylexname\t  PARAMS ((void));\n static inline int _yylex  PARAMS ((void));\n static int  yylex\t  PARAMS ((void));\n static void init_reswords PARAMS ((void));\n@@ -3114,6 +3115,13 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_AT_IMPLEMENTATION */\tIMPLEMENTATION\n };\n \n+ifobjc\n+/* Lookup table for ObjC keywords beginning with '@'.  Crude but\n+   hopefully effective.  */\n+#define N_at_reswords ((int) RID_AT_IMPLEMENTATION - (int)RID_AT_ENCODE + 1)\n+static tree objc_rid_sans_at[N_at_reswords];\n+end ifobjc\n+\n static void\n init_reswords ()\n {\n@@ -3139,6 +3147,16 @@ init_reswords ()\n       C_RID_CODE (id) = reswords[i].rid;\n       C_IS_RESERVED_WORD (id) = 1;\n       ridpointers [(int) reswords[i].rid] = id;\n+\n+ifobjc\n+      /* Enter ObjC @-prefixed keywords into the \"sans\" table\n+\t _without_ their leading at-sign.  Again, all these\n+\t identifiers are reachable by the get_identifer table, so it's\n+\t not necessary to make objc_rid_sans_at a GC root.  */\n+      if (reswords[i].word[0] == '@')\n+\tobjc_rid_sans_at[(int) reswords[i].rid - (int) RID_AT_ENCODE]\n+\t  = get_identifier (reswords[i].word + 1);\n+end ifobjc\n     }\n ifobjc\n   save_and_forget_protocol_qualifiers ();\n@@ -3188,8 +3206,7 @@ yyerror (msgid)\n \terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n     }\n   else if (last_token == CPP_STRING\n-\t   || last_token == CPP_WSTRING\n-\t   || last_token == CPP_OSTRING)\n+\t   || last_token == CPP_WSTRING)\n     error (\"%s before string constant\", string);\n   else if (last_token == CPP_NUMBER\n \t   || last_token == CPP_INT\n@@ -3201,12 +3218,65 @@ yyerror (msgid)\n     error (\"%s before '%s' token\", string, NAME(last_token));\n }\n \n+static int\n+yylexname ()\n+{\n+  tree decl;\n+\n+  if (C_IS_RESERVED_WORD (yylval.ttype))\n+    {\n+      enum rid rid_code = C_RID_CODE (yylval.ttype);\n+      /* Return the canonical spelling for this keyword.  */\n+      yylval.ttype = ridpointers[(int) rid_code];\n+      return rid_to_yy[(int) rid_code];\n+    }\n+\n+  decl = lookup_name (yylval.ttype);\n+  if (decl)\n+    {\n+      if (TREE_CODE (decl) == TYPE_DECL)\n+\treturn TYPENAME;\n+      /* A user-invisible read-only initialized variable\n+\t should be replaced by its value.\n+\t We handle only strings since that's the only case used in C.  */\n+      else if (TREE_CODE (decl) == VAR_DECL\n+\t       && DECL_IGNORED_P (decl)\n+\t       && TREE_READONLY (decl)\n+\t       && DECL_INITIAL (decl) != 0\n+\t       && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST)\n+\t{\n+\t  tree stringval = DECL_INITIAL (decl);\n+\n+\t  /* Copy the string value so that we won't clobber anything\n+\t     if we put something in the TREE_CHAIN of this one.  */\n+\t  yylval.ttype = build_string (TREE_STRING_LENGTH (stringval),\n+\t\t\t\t       TREE_STRING_POINTER (stringval));\n+\t  return STRING;\n+\t}\n+    }\n+  else if (doing_objc_thang)\n+    {\n+      tree objc_interface_decl = is_class_name (yylval.ttype);\n+\n+      if (objc_interface_decl)\n+\t{\n+\t  yylval.ttype = objc_interface_decl;\n+\t  return CLASSNAME;\n+\t}\n+    }\n+\n+  return IDENTIFIER;\n+}\n+\n+\n static inline int\n _yylex ()\n {\n- retry:\n+ get_next:\n   last_token = c_lex (&yylval.ttype);\n-\n+ifobjc\n+ reconsider:\n+end ifobjc\n   switch (last_token)\n     {\n     case CPP_EQ:\t\t\t\t\treturn '=';\n@@ -3263,63 +3333,10 @@ _yylex ()\n     case CPP_EOF:\n       if (cpp_pop_buffer (parse_in) == 0)\n \treturn 0;\n-      goto retry;\n+      goto get_next;\n \n     case CPP_NAME:\n-      if (C_IS_RESERVED_WORD (yylval.ttype))\n-\t{\n-\t  enum rid rid_code = C_RID_CODE (yylval.ttype);\n-\t  /* Return the canonical spelling for this keyword.  */\n-\t  yylval.ttype = ridpointers[(int) rid_code];\n-\t  return rid_to_yy[(int) rid_code];\n-\t}\n-\n-      if (IDENTIFIER_POINTER (yylval.ttype)[0] == '@')\n-\t{\n-\t  error (\"invalid identifier `%s'\", IDENTIFIER_POINTER (yylval.ttype));\n-\t  return IDENTIFIER;\n-\t}\n-\n-      {\n-\ttree decl;\n-\n-\tdecl = lookup_name (yylval.ttype);\n-\n-\tif (decl)\n-\t  {\n-\t    if (TREE_CODE (decl) == TYPE_DECL)\n-\t      return TYPENAME;\n-\t    /* A user-invisible read-only initialized variable\n-\t       should be replaced by its value.\n-\t       We handle only strings since that's the only case used in C.  */\n-\t    else if (TREE_CODE (decl) == VAR_DECL\n-\t\t     && DECL_IGNORED_P (decl)\n-\t\t     && TREE_READONLY (decl)\n-\t\t     && DECL_INITIAL (decl) != 0\n-\t\t     && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST)\n-\t      {\n-\t\ttree stringval = DECL_INITIAL (decl);\n-\n-\t\t/* Copy the string value so that we won't clobber anything\n-\t\t   if we put something in the TREE_CHAIN of this one.  */\n-\t\tyylval.ttype = build_string (TREE_STRING_LENGTH (stringval),\n-\t\t\t\t\t     TREE_STRING_POINTER (stringval));\n-\t\treturn STRING;\n-\t      }\n-\t  }\n-\telse if (doing_objc_thang)\n-\t  {\n-\t    tree objc_interface_decl = is_class_name (yylval.ttype);\n-\n-\t    if (objc_interface_decl)\n-\t      {\n-\t\tyylval.ttype = objc_interface_decl;\n-\t\treturn CLASSNAME;\n-\t      }\n-\t  }\n-\n-\treturn IDENTIFIER;\n-      }\n+      return yylexname ();\n \n     case CPP_INT:\n     case CPP_FLOAT:\n@@ -3332,9 +3349,27 @@ _yylex ()\n     case CPP_WSTRING:\n       return STRING;\n       \n-    case CPP_OSTRING:\n-      return OBJC_STRING;\n-\n+      /* This token is Objective-C specific.  It gives the next\n+\t token special significance.  */\n+    case CPP_ATSIGN:\n+ifobjc\n+      last_token = c_lex (&yylval.ttype);\n+      if (last_token == CPP_STRING)\n+\treturn OBJC_STRING;\n+      else if (last_token == CPP_NAME)\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < N_at_reswords; i++)\n+\t    if (objc_rid_sans_at[i] == yylval.ttype)\n+\t      {\n+\t\tint rid_code = i + (int) RID_AT_ENCODE;\n+\t\tyylval.ttype = ridpointers[rid_code];\n+\t\treturn rid_to_yy[rid_code];\n+\t      }\n+\t}\n+      error (\"syntax error at '@' token\");\n+      goto reconsider;\n+end ifobjc\n       /* These tokens are C++ specific (and will not be generated\n          in C mode, but let's be cautious).  */\n     case CPP_SCOPE:\n@@ -3347,13 +3382,12 @@ _yylex ()\n       /* These tokens should not survive translation phase 4.  */\n     case CPP_HASH:\n     case CPP_PASTE:\n-      error (\"syntax error before '%s' token\", NAME(last_token));\n-      goto retry;\n+      error (\"syntax error at '%s' token\", NAME(last_token));\n+      goto get_next;\n \n     default:\n       abort ();\n     }\n-\n   /* NOTREACHED */\n }\n "}, {"sha": "92d117b175c2095dca59edb2e95ef80bc303c001", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -1,3 +1,7 @@\n+2001-03-06  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* spew.c: Remove references to CPP_OSTRING.\n+\n 2001-03-06  Andrew Haley  <aph@redhat.com>\n \n \t* typeck.c (convert_arguments): Check that we have an fndecl."}, {"sha": "a02db1b97bcb0c0d7c5afbed73b44b3fcc47bbcf", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -351,9 +351,6 @@ read_token (t)\n       t->yychar = STRING;\n       break;\n \n-      /* This token should not be generated in C++ mode.  */\n-    case CPP_OSTRING:\n-\n       /* These tokens should not survive translation phase 4.  */\n     case CPP_HASH:\n     case CPP_PASTE:\n@@ -1499,8 +1496,7 @@ yyerror (msgid)\n \terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n     }\n   else if (last_token == CPP_STRING\n-\t   || last_token == CPP_WSTRING\n-\t   || last_token == CPP_OSTRING)\n+\t   || last_token == CPP_WSTRING)\n     error (\"%s before string constant\", string);\n   else if (last_token == CPP_NUMBER\n \t   || last_token == CPP_INT"}, {"sha": "d1b90764a438fb371716340908a8325002043770", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -1241,29 +1241,8 @@ _cpp_lex_token (pfile, result)\n     case '}': result->type = CPP_CLOSE_BRACE; break;\n     case ';': result->type = CPP_SEMICOLON; break;\n \n-    case '@':\n-      if (CPP_OPTION (pfile, objc))\n-\t{\n-\t  /* In Objective C, '@' may begin keywords or strings, like\n-\t     @keyword or @\"string\".  It would be nice to call\n-\t     get_effective_char here and test the result.  However, we\n-\t     would then need to pass 2 characters to parse_identifier,\n-\t     making it ugly and slowing down its main loop.  Instead,\n-\t     we assume we have an identifier, and recover if not.  */\n-\t  result->type = CPP_NAME;\n-\t  result->val.node = parse_identifier (pfile, c);\n-\t  if (result->val.node->length != 1)\n-\t    break;\n-\n-\t  /* OK, so it wasn't an identifier.  Maybe a string?  */\n-\t  if (buffer->read_ahead == '\"')\n-\t    {\n-\t      c = '\"';\n-\t      ACCEPT_CHAR (CPP_OSTRING);\n-\t      goto make_string;\n-\t    }\n-\t}\n-      goto random_char;\n+      /* @ is a punctuator in Objective C.  */\n+    case '@': result->type = CPP_ATSIGN; break;\n \n     random_char:\n     default:\n@@ -1341,7 +1320,6 @@ cpp_spell_token (pfile, token, buffer)\n \t  {\n \t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n \t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n-\t  case CPP_OSTRING:\tleft = '\"';  right = '\"';  tag = '@';  break;\n \t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n     \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n \t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n@@ -1432,7 +1410,6 @@ cpp_output_token (token, fp)\n \t  {\n \t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n \t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n-\t  case CPP_OSTRING:\tleft = '\"';  right = '\"';  tag = '@';  break;\n \t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n     \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n \t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n@@ -1580,13 +1557,6 @@ cpp_can_paste (pfile, token1, token2, digraph)\n \treturn CPP_NUMBER;\n       break;\n \n-    case CPP_OTHER:\n-      if (CPP_OPTION (pfile, objc) && token1->val.c == '@')\n-\t{\n-\t  if (b == CPP_NAME)\treturn CPP_NAME;\n-\t  if (b == CPP_STRING)\treturn CPP_OSTRING;\n-\t}\n-\n     default:\n       break;\n     }"}, {"sha": "b9b706bd75efda551b934f64a8ead3e5d359cfc6", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -119,6 +119,7 @@ struct file_name_map_list;\n   OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n   OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n   OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n+  OP(CPP_ATSIGN,\t\"@\")  /* used in Objective C */ \\\n \\\n   TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n   TK(CPP_INT,\t\tSPELL_STRING)\t/* 23 */\t\t\t\\\n@@ -131,7 +132,6 @@ struct file_name_map_list;\n \\\n   TK(CPP_STRING,\tSPELL_STRING)\t/* \"string\" */\t\t\t\\\n   TK(CPP_WSTRING,\tSPELL_STRING)\t/* L\"string\" */\t\t\t\\\n-  TK(CPP_OSTRING,\tSPELL_STRING)\t/* @\"string\" - Objective C */\t\\\n   TK(CPP_HEADER_NAME,\tSPELL_STRING)\t/* <stdio.h> in #include */\t\\\n \\\n   TK(CPP_COMMENT,\tSPELL_STRING)\t/* Only if output comments.  */ \\"}, {"sha": "7d20f1c0464c76f6ed4d20488100be666dba4bfa", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc937581390c3aebf39e5f36b61f6b6098b8a236/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=cc937581390c3aebf39e5f36b61f6b6098b8a236", "patch": "@@ -291,8 +291,7 @@ stringify_arg (pfile, arg)\n       unsigned int len = cpp_token_len (token);\n \n       escape_it = (token->type == CPP_STRING || token->type == CPP_WSTRING\n-\t\t   || token->type == CPP_CHAR || token->type == CPP_WCHAR\n-\t\t   || token->type == CPP_OSTRING);\n+\t\t   || token->type == CPP_CHAR || token->type == CPP_WCHAR);\n \n       if (escape_it)\n \t/* Worst case is each char is octal.  */"}]}