{"sha": "4fbe09f9dea90b631ddd4ead35a2d98714bdfc93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiZTA5ZjlkZWE5MGI2MzFkZGQ0ZWFkMzVhMmQ5ODcxNGJkZmM5Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-11-23T13:40:32Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-11-23T13:40:32Z"}, "message": "predicates.md (pcrel_address, [...]): Remove redundant conditionals.\n\n\t* config/m68k/predicates.md (pcrel_address, extend_operator,\n\tpost_inc_operand, pre_dec_operand): Remove redundant\n\tconditionals.\n\t(const_uint32_operand, const_sint32_operand): Use gcc_assert\n\tinstead of abort.\n\t(valid_dbcc_comparison_p): Rewrite in the lisp style.\n\nFrom-SVN: r107419", "tree": {"sha": "f3f637abca242624397080dd1a6f45954d9713ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3f637abca242624397080dd1a6f45954d9713ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93/comments", "author": null, "committer": null, "parents": [{"sha": "f8d15f14743782e2ce1bd20ec64f6b294803360e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d15f14743782e2ce1bd20ec64f6b294803360e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d15f14743782e2ce1bd20ec64f6b294803360e"}], "stats": {"total": 53, "additions": 19, "deletions": 34}, "files": [{"sha": "7a754dcd661dbd0e7669355732dc045c9dfad6bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fbe09f9dea90b631ddd4ead35a2d98714bdfc93", "patch": "@@ -1,3 +1,12 @@\n+2005-11-23  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/m68k/predicates.md (pcrel_address, extend_operator,\n+\tpost_inc_operand, pre_dec_operand): Remove redundant\n+\tconditionals.\n+\t(const_uint32_operand, const_sint32_operand): Use gcc_assert\n+\tinstead of abort.\n+\t(valid_dbcc_comparison_p): Rewrite in the lisp style.\n+\n 2005-11-23  Ben Elliston  <bje@au.ibm.com>\n \n \t* dwarf2.h (enum dwarf_type): Add DW_ATE_decimal_float."}, {"sha": "ca97e0b75b007bc5de6053a0ce6223d324228e86", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbe09f9dea90b631ddd4ead35a2d98714bdfc93/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=4fbe09f9dea90b631ddd4ead35a2d98714bdfc93", "patch": "@@ -76,11 +76,7 @@\n ;; \"general_src_operand\".\n \n (define_predicate \"pcrel_address\"\n-  (match_code \"symbol_ref,label_ref,const\")\n-{\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF\n-\t  || GET_CODE (op) == CONST);\n-})\n+  (match_code \"symbol_ref,label_ref,const\"))\n \n ;; Accept integer operands in the range 0..0xffffffff.  We have to\n ;; check the range carefully since this predicate is used in DImode\n@@ -92,8 +88,7 @@\n {\n   /* It doesn't make sense to ask this question with a mode that is\n      not larger than 32 bits.  */\n-  if (GET_MODE_BITSIZE (mode) <= 32)\n-    abort ();\n+  gcc_assert (GET_MODE_BITSIZE (mode) > 32);\n \n #if HOST_BITS_PER_WIDE_INT > 32\n   /* All allowed constants will fit a CONST_INT.  */\n@@ -114,8 +109,7 @@\n {\n   /* It doesn't make sense to ask this question with a mode that is\n      not larger than 32 bits.  */\n-  if (GET_MODE_BITSIZE (mode) <= 32)\n-    abort ();\n+  gcc_assert (GET_MODE_BITSIZE (mode) > 32);\n \n   /* All allowed constants will fit a CONST_INT.  */\n   return (GET_CODE (op) == CONST_INT\n@@ -128,27 +122,13 @@\n ;; some comparisons when CC_NO_OVERFLOW is set.\n \n (define_predicate \"valid_dbcc_comparison_p\"\n-  (match_code \"eq,ne,gtu,ltu,geu,leu,gt,lt,ge,le\")\n-{\n-  return valid_dbcc_comparison_p_2 (op, mode);\n-})\n+  (and (match_code \"eq,ne,gtu,ltu,geu,leu,gt,lt,ge,le\")\n+       (match_test \"valid_dbcc_comparison_p_2 (op, mode)\")))\n \n ;; Check for sign_extend or zero_extend.  Used for bit-count operands.\n \n (define_predicate \"extend_operator\"\n-  (match_code \"sign_extend,zero_extend\")\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-  switch (GET_CODE (op))\n-    {\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-})\n+  (match_code \"sign_extend,zero_extend\"))\n \n ;; Returns true if OP is either a symbol reference or a sum of a\n ;; symbol reference and a constant.\n@@ -182,15 +162,11 @@\n ;; TODO: Add a comment here.\n \n (define_predicate \"post_inc_operand\"\n-  (match_code \"mem\")\n-{\n-  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC;\n-})\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == POST_INC\")))\n \n ;; TODO: Add a comment here.\n \n (define_predicate \"pre_dec_operand\"\n-  (match_code \"mem\")\n-{\n-  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == PRE_DEC;\n-})\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == PRE_DEC\")))"}]}