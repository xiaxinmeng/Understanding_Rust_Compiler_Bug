{"sha": "14499ba4f389c742028eb835fcb418c0f9e6dae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ0OTliYTRmMzg5Yzc0MjAyOGViODM1ZmNiNDE4YzBmOWU2ZGFlMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-17T22:00:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-17T22:00:10Z"}, "message": "(__objc_block_return): Remove function.\n\n(__objc_word_return, __objc_double_return): Remove functions.\n(__objc_get_forward_imp): New function.\n(__objc_init_dispatch_tables): Install zero instead of\n__objc_init_install_dtable.\n(__objc_init_install_dtable): No longer call the method but\nallow objc_msg_lookup return it for normal execution.\n(obj_msg_lookup): Differentiate between when a method isn't\nimplemented and when the dispatch table needs to be installed.\nReturn the IMP when the dispatch table is installed versus\nhaving __objc_init_install_dtable call it.\n(get_imp): Install dispatch table if needed and return IMP\nfrom the newly installed dispatch table.\n(__objc_responds_to): Install dispatch table if needed before\nchecking if method is implemented.\n\nFrom-SVN: r13723", "tree": {"sha": "b7073900929340924d79f8af1e81f75d27558312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7073900929340924d79f8af1e81f75d27558312"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14499ba4f389c742028eb835fcb418c0f9e6dae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14499ba4f389c742028eb835fcb418c0f9e6dae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14499ba4f389c742028eb835fcb418c0f9e6dae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14499ba4f389c742028eb835fcb418c0f9e6dae0/comments", "author": null, "committer": null, "parents": [{"sha": "0fd17968072d1cc7d6b3b4a8a5616faa8c984c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd17968072d1cc7d6b3b4a8a5616faa8c984c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fd17968072d1cc7d6b3b4a8a5616faa8c984c26"}], "stats": {"total": 187, "additions": 85, "deletions": 102}, "files": [{"sha": "5c44dee0cdd97bbea3a3d5985971594cea13126f", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 85, "deletions": 102, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14499ba4f389c742028eb835fcb418c0f9e6dae0/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14499ba4f389c742028eb835fcb418c0f9e6dae0/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=14499ba4f389c742028eb835fcb418c0f9e6dae0", "patch": "@@ -33,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #define gen_rtx(args...) 1\n #define rtx int\n \n-#if STRUCT_VALUE == 0\n+#if !defined(STRUCT_VALUE) || STRUCT_VALUE == 0\n #define INVISIBLE_STRUCT_RETURN 1\n #else\n #define INVISIBLE_STRUCT_RETURN 0\n@@ -69,52 +69,79 @@ static Method_t search_for_method_in_hierarchy (Class class, SEL sel);\n static Method_t search_for_method_in_list(MethodList_t list, SEL op);\n id nil_method(id, SEL, ...);\n \n+/* Given a selector, return the proper forwarding implementation. */\n+__inline__\n+IMP\n+__objc_get_forward_imp (SEL sel)\n+{\n+  const char *t = sel->sel_types;\n+\n+  if (t && (*t == '[' || *t == '(' || *t == '{'))\n+    return (IMP)__objc_block_forward;\n+  else if (t && (*t == 'f' || *t == 'd'))\n+    return (IMP)__objc_double_forward;\n+  else\n+    return (IMP)__objc_word_forward;\n+}\n+\n /* Given a class and selector, return the selector's implementation.  */\n __inline__\n IMP\n get_imp (Class class, SEL sel)\n {\n   IMP impl;\n   void* res = sarray_get (class->dtable, (size_t) sel->sel_id);\n-  if(res == __objc_init_install_dtable)\n-    {\n-      objc_mutex_lock(__objc_runtime_mutex);\n-      __objc_install_dispatch_table_for_class (class);\n-      objc_mutex_unlock(__objc_runtime_mutex);\n-      res = sarray_get (class->dtable, (size_t) sel->sel_id);\n-    }\n   if (res == 0)\n     {\n-      const char *t = sel->sel_types;\n-      if (t && (*t == '[' || *t == '(' || *t == '{'))\n-\tres = (IMP)__objc_block_forward;\n-      else if (t && (*t == 'f' || *t == 'd'))\n-\tres = (IMP)__objc_double_forward;\n+      /* Not a valid method */\n+      if(class->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  /* The dispatch table needs to be installed. */\n+\t  objc_mutex_lock(__objc_runtime_mutex);\n+\t  __objc_install_dispatch_table_for_class (class);\n+\t  objc_mutex_unlock(__objc_runtime_mutex);\n+\t  /* Call ourselves with the installed dispatch table\n+\t     and get the real method */\n+\t  res = get_imp(class, sel);\n+\t}\n       else\n-\tres = (IMP)__objc_word_forward;\n+\t{\n+\t  /* The dispatch table has been installed so the\n+\t     method just doesn't exist for the class.\n+\t     Return the forwarding implementation. */\n+\t  res = __objc_get_forward_imp(sel);\n+\t}\n     }\n   return res;\n }\n \n-__inline__ BOOL\n+/* Query if an object can respond to a selector, returns YES if the\n+object implements the selector otherwise NO.  Does not check if the\n+method can be forwarded. */\n+__inline__\n+BOOL\n __objc_responds_to (id object, SEL sel)\n {\n-  void* res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);\n-  if(res == __objc_init_install_dtable)\n+  void* res;\n+\n+  /* Install dispatch table if need be */\n+  if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n     {\n       objc_mutex_lock(__objc_runtime_mutex);\n       __objc_install_dispatch_table_for_class (object->class_pointer);\n       objc_mutex_unlock(__objc_runtime_mutex);\n-      res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);\n     }\n+\n+  /* Get the method from the dispatch table */\n+  res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);\n   return (res != 0);\n }\n \n /* This is the lookup function.  All entries in the table are either a \n-   valid method *or* one of `__objc_missing_method' which calls\n-   forward:: etc, or `__objc_init_install_dtable' which installs the\n-   real dtable */\n-__inline__ IMP\n+   valid method *or* zero.  If zero then either the dispatch table\n+   needs to be installed or it doesn't exist and forwarding is attempted. */\n+__inline__\n+IMP\n objc_msg_lookup(id receiver, SEL op)\n {\n   IMP result;\n@@ -123,13 +150,23 @@ objc_msg_lookup(id receiver, SEL op)\n       result = sarray_get(receiver->class_pointer->dtable, (sidx)op->sel_id);\n       if (result == 0)\n \t{\n-\t  const char *t = op->sel_types;\n-\t  if (t && (*t == '[' || *t == '(' || *t == '{'))\n-\t    result = (IMP)__objc_block_forward;\n-\t  else if (t && (*t == 'f' || *t == 'd'))\n-\t    result = (IMP)__objc_double_forward;\n+\t  /* Not a valid method */\n+\t  if(receiver->class_pointer->dtable == __objc_uninstalled_dtable)\n+\t    {\n+\t      /* The dispatch table needs to be installed.\n+\t\t This happens on the very first method call to the class. */\n+\t      __objc_init_install_dtable(receiver, op);\n+\n+\t      /* Get real method for this in newly installed dtable */\n+\t      result = get_imp(receiver->class_pointer, op);\n+\t    }\n \t  else\n-\t    result = (IMP)__objc_word_forward;\n+\t    {\n+\t      /* The dispatch table has been installed so the\n+\t\t method just doesn't exist for the class.\n+\t\t Attempt to forward the method. */\n+\t      result = __objc_get_forward_imp(op);\n+\t    }\n \t}\n       return result;\n     }\n@@ -160,68 +197,23 @@ objc_msg_sendv(id object, SEL op, arglist_t arg_frame)\n \t\t\t method_get_sizeof_arguments (m));\n }\n \n-void __objc_init_dispatch_tables()\n+void\n+__objc_init_dispatch_tables()\n {\n   __objc_uninstalled_dtable\n-    = sarray_new(200, __objc_init_install_dtable);\n+    = sarray_new(200, 0);\n }\n \n-/* Various return functions that are used based upon the\n-   return type for the selector.\n-   __objc_block_return for structures.\n-   __objc_double_return for floats/doubles.\n-   __objc_word_return for pointers or types that fit in registers.\n-   */\n-#if INVISIBLE_STRUCT_RETURN\n-static __big\n-#else\n-static id\n-#endif\n-__objc_block_return(IMP imp, void * args)\n-{\n-  void * result = __builtin_apply((apply_t)imp, args, 96);\n-  if (result)\n-    __builtin_return (result);\n-  else\n-    return;\n-}\n-\n-static id\n-__objc_word_return(IMP imp, void * args)\n-{\n-  void * result = __builtin_apply((apply_t)imp, args, 96);\n-  if (result)\n-    __builtin_return (result);\n-  else\n-    return;\n-}\n- \n-static double\n-__objc_double_return(IMP imp, void * args)\n-{\n-  void * result = __builtin_apply((apply_t)imp, args, 96);\n-  if (result)\n-    __builtin_return (result);\n-  else\n-    return;\n-}\n-\n-/* This one is a bit hairy.  This function is installed in the \n-   premature dispatch table, and thus called once for each class,\n-   namely when the very first message is send to it.  */\n-\n-static void __objc_init_install_dtable(id receiver, SEL op)\n+/* This function is called by objc_msg_lookup when the\n+   dispatch table needs to be installed; thus it is called once\n+   for each class, namely when the very first message is sent to it. */\n+static void\n+__objc_init_install_dtable(id receiver, SEL op)\n {\n-  __label__ already_initialized;\n-  IMP imp;\n-  void* args;\n-  void* result;\n-  const char *t;\n-\n   /* This may happen, if the programmer has taken the address of a \n      method before the dtable was initialized... too bad for him! */\n   if(receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n-    goto already_initialized;\n+    return;\n \n   objc_mutex_lock(__objc_runtime_mutex);\n \n@@ -252,33 +244,20 @@ static void __objc_init_install_dtable(id receiver, SEL op)\n \tCLS_SETINITIALIZED((Class)receiver);\n     }\n   objc_mutex_unlock(__objc_runtime_mutex);\n-\n-already_initialized:\n-  \n-  /* Get real method for this in newly installed dtable */\n-  imp = get_imp(receiver->class_pointer, op);\n-\n-  /* Perform the appropriate return based upon the method return type */\n-  args = __builtin_apply_args();\n-  t = op->sel_types;\n-  if (t && (*t == '[' || *t == '(' || *t == '{'))\n-    ((id(*)())__objc_block_return)(imp, args);\n-  else if (t && (*t == 'f' || *t == 'd'))\n-    ((id(*)())__objc_double_return)(imp, args);\n-  else\n-    __objc_word_return(imp, args);\n }\n \n /* Install dummy table for class which causes the first message to\n    that class (or instances hereof) to be initialized properly */\n-void __objc_install_premature_dtable(Class class)\n+void\n+__objc_install_premature_dtable(Class class)\n {\n   assert(__objc_uninstalled_dtable);\n   class->dtable = __objc_uninstalled_dtable;\n }   \n \n /* Send +initialize to class if not already done */\n-static void __objc_send_initialize(Class class)\n+static void\n+__objc_send_initialize(Class class)\n {\n   /* This *must* be a class object */\n   assert(CLS_ISCLASS(class));\n@@ -382,7 +361,8 @@ __objc_install_dispatch_table_for_class (Class class)\n   __objc_install_methods_in_dtable (class, class->methods);\n }\n \n-void __objc_update_dispatch_table_for_class (Class class)\n+void\n+__objc_update_dispatch_table_for_class (Class class)\n {\n   Class next;\n   struct sarray *arr;\n@@ -616,7 +596,8 @@ __objc_forward (id object, SEL sel, arglist_t args)\n   }\n }\n \n-void __objc_print_dtable_stats()\n+void\n+__objc_print_dtable_stats()\n {\n   int total = 0;\n \n@@ -646,7 +627,9 @@ void __objc_print_dtable_stats()\n   objc_mutex_unlock(__objc_runtime_mutex);\n }\n \n-/* Returns the dispatch table */\n+/* Returns the uninstalled dispatch table indicator.\n+ If a class' dispatch table points to __objc_uninstalled_dtable\n+ then that means it needs its dispatch table to be installed. */\n __inline__\n struct sarray* \n objc_get_uninstalled_dtable()"}]}