{"sha": "4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY1YjljODAzYWM0ZWRjNjM5ZDhiZjRhODI3YmE0MGU0ZGFiNGRiMA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-06-26T13:34:59Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-06-26T13:34:59Z"}, "message": "Introduce dump_location_t\n\ngcc/ChangeLog:\n\t* cfgloop.c (get_loop_location): Convert return type from\n\tlocation_t to dump_user_location_t, replacing INSN_LOCATION lookups\n\tby implicit construction from rtx_insn *, and using\n\tdump_user_location_t::from_function_decl for the fallback case.\n\t* cfgloop.h (get_loop_location): Convert return type from\n\tlocation_t to dump_user_location_t.\n\t* cgraphunit.c (walk_polymorphic_call_targets): Update call to\n\tdump_printf_loc to pass in a dump_location_t rather than a\n\tlocation_t, via the gimple stmt.\n\t* coverage.c (get_coverage_counts): Update calls to\n\tdump_printf_loc to pass in dump_location_t rather than a\n\tlocation_t.\n\t* doc/optinfo.texi (Dump types): Convert example of\n\tdump_printf_loc from taking \"locus\" to taking \"insn\".  Update\n\tdescription of the \"_loc\" calls to cover dump_location_t.\n\t* dumpfile.c: Include \"backend.h\", \"gimple.h\", \"rtl.h\", and\n\t\"selftest.h\".\n\t(dump_user_location_t::dump_user_location_t): New constructors,\n\tfrom gimple *stmt and rtx_insn *.\n\t(dump_user_location_t::from_function_decl): New function.\n\t(dump_loc): Make static.\n\t(dump_gimple_stmt_loc): Convert param \"loc\" from location_t to\n\tconst dump_location_t &.\n\t(dump_generic_expr_loc): Delete.\n\t(dump_printf_loc): Convert param \"loc\" from location_t to\n\tconst dump_location_t &.\n\t(selftest::test_impl_location): New function.\n\t(selftest::dumpfile_c_tests): New function.\n\t* dumpfile.h: Include \"profile-count.h\".\n\t(class dump_user_location_t): New class.\n\t(struct dump_impl_location_t): New struct.\n\t(class dump_location_t): New class.\n\t(dump_printf_loc): Convert 2nd param from source_location to\n\tconst dump_location_t &.\n\t(dump_generic_expr_loc): Delete.\n\t(dump_gimple_stmt_loc): Convert 2nd param from source_location to\n\tconst dump_location_t &.\n\t* gimple-fold.c (fold_gimple_assign): Update call to\n\tdump_printf_loc to pass in a dump_location_t rather than a\n\tlocation_t, via the gimple stmt.\n\t(gimple_fold_call): Likewise.\n\t* gimple-loop-interchange.cc\n\t(loop_cand::analyze_iloop_reduction_var): Update for change to\n\tcheck_reduction_path.\n\t(tree_loop_interchange::interchange): Update for change to\n\tfind_loop_location.\n\t* graphite-isl-ast-to-gimple.c (scop_to_isl_ast): Update for\n\tchange in return-type of find_loop_location.\n\t(graphite_regenerate_ast_isl): Likewise.\n\t* graphite-optimize-isl.c (optimize_isl): Likewise.\n\t* graphite.c (graphite_transform_loops): Likewise.\n\t* ipa-devirt.c (ipa_devirt): Update call to dump_printf_loc to\n\tpass in a dump_location_t rather than a location_t, via the\n\tgimple stmt.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n\t* ipa.c (walk_polymorphic_call_targets): Likewise.\n\t* loop-unroll.c (report_unroll): Convert \"locus\" param from\n\tlocation_t to dump_location_t.\n\t(decide_unrolling): Update for change to get_loop_location's\n\treturn type.\n\t* omp-grid.c (struct grid_prop): Convert field \"target_loc\" from\n\tlocation_t to dump_user_location_t.\n\t(grid_find_single_omp_among_assignments_1): Updates calls to\n\tdump_printf_loc to pass in a dump_location_t rather than a\n\tlocation_t, via the gimple stmt.\n\t(grid_parallel_clauses_gridifiable): Convert \"tloc\" from\n\tlocation_t to dump_location_t.  Updates calls to dump_printf_loc\n\tto pass in a dump_location_t rather than a location_t, via the\n\tgimple stmt.\n\t(grid_inner_loop_gridifiable_p): Likewise.\n\t(grid_dist_follows_simple_pattern): Likewise.\n\t(grid_gfor_follows_tiling_pattern): Likewise.\n\t(grid_target_follows_gridifiable_pattern): Likewise.\n\t(grid_attempt_target_gridification): Convert initialization\n\tof local \"grid\" from memset to zero-initialization; FIXME: does\n\tthis require C++11?  Update call to dump_printf_loc to pass in a\n\toptinfo_location rather than a location_t, via the gimple stmt.\n\t* profile.c (read_profile_edge_counts): Updates call to\n\tdump_printf_loc to pass in a dump_location_t rather than a\n\tlocation_t\n\t(compute_branch_probabilities): Likewise.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tdumpfile_c_tests.\n\t* selftest.h (dumpfile_c_tests): New decl.\n\t* tree-loop-distribution.c (pass_loop_distribution::execute):\n\tUpdate for change in return type of find_loop_location.\n\t* tree-parloops.c (parallelize_loops): Likewise.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Convert\n\t\"locus\" from location_t to dump_user_location_t.\n\t(canonicalize_loop_induction_variables): Likewise.\n\t* tree-ssa-loop-ivopts.c (tree_ssa_iv_optimize_loop): Update\n\tfor change in return type of find_loop_location.\n\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Update call\n\tto dump_printf_loc to pass in a dump_location_t rather than a\n\tlocation_t, via the stmt.\n\t* tree-ssa-sccvn.c (eliminate_dom_walker::before_dom_children):\n\tLikewise.\n\t* tree-vect-loop-manip.c (find_loop_location): Convert return\n\ttype from source_location to dump_user_location_t.\n\t(vect_do_peeling): Update for above change.\n\t(vect_loop_versioning): Update for change in type of\n\tvect_location.\n\t* tree-vect-loop.c (check_reduction_path): Convert \"loc\" param\n\tfrom location_t to dump_user_location_t.\n\t(vect_estimate_min_profitable_iters): Update for change in type\n\tof vect_location.\n\t* tree-vect-slp.c (vect_print_slp_tree): Convert param \"loc\" from\n\tlocation_t to dump_location_t.\n\t(vect_slp_bb): Update for change in type of vect_location.\n\t* tree-vectorizer.c (vect_location): Convert from source_location\n\tto dump_user_location_t.\n\t(try_vectorize_loop_1): Update for change in vect_location's type.\n\t(vectorize_loops): Likewise.\n\t(increase_alignment): Likewise.\n\t* tree-vectorizer.h (vect_location): Convert from source_location\n\tto dump_user_location_t.\n\t(find_loop_location): Convert return type from source_location to\n\tdump_user_location_t.\n\t(check_reduction_path): Convert 1st param from location_t to\n\tdump_user_location_t.\n\t* value-prof.c (check_counter): Update call to dump_printf_loc to\n\tpass in a dump_user_location_t rather than a location_t; update\n\tcall to error_at for change in type of \"locus\".\n\t(check_ic_target): Update call to dump_printf_loc to\n\tpass in a dump_user_location_t rather than a location_t, via the\n\tcall_stmt.\n\nFrom-SVN: r262149", "tree": {"sha": "da6d4a4811016c1d51edbe927f601eb11d9c3835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da6d4a4811016c1d51edbe927f601eb11d9c3835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3da2f26ca45060ddd8514010090353a2adec334a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da2f26ca45060ddd8514010090353a2adec334a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3da2f26ca45060ddd8514010090353a2adec334a"}], "stats": {"total": 668, "additions": 515, "deletions": 153}, "files": [{"sha": "749a10ff727f1d497c5ca29c9c5051dfebce04ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -1,3 +1,132 @@\n+2018-06-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cfgloop.c (get_loop_location): Convert return type from\n+\tlocation_t to dump_user_location_t, replacing INSN_LOCATION lookups\n+\tby implicit construction from rtx_insn *, and using\n+\tdump_user_location_t::from_function_decl for the fallback case.\n+\t* cfgloop.h (get_loop_location): Convert return type from\n+\tlocation_t to dump_user_location_t.\n+\t* cgraphunit.c (walk_polymorphic_call_targets): Update call to\n+\tdump_printf_loc to pass in a dump_location_t rather than a\n+\tlocation_t, via the gimple stmt.\n+\t* coverage.c (get_coverage_counts): Update calls to\n+\tdump_printf_loc to pass in dump_location_t rather than a\n+\tlocation_t.\n+\t* doc/optinfo.texi (Dump types): Convert example of\n+\tdump_printf_loc from taking \"locus\" to taking \"insn\".  Update\n+\tdescription of the \"_loc\" calls to cover dump_location_t.\n+\t* dumpfile.c: Include \"backend.h\", \"gimple.h\", \"rtl.h\", and\n+\t\"selftest.h\".\n+\t(dump_user_location_t::dump_user_location_t): New constructors,\n+\tfrom gimple *stmt and rtx_insn *.\n+\t(dump_user_location_t::from_function_decl): New function.\n+\t(dump_loc): Make static.\n+\t(dump_gimple_stmt_loc): Convert param \"loc\" from location_t to\n+\tconst dump_location_t &.\n+\t(dump_generic_expr_loc): Delete.\n+\t(dump_printf_loc): Convert param \"loc\" from location_t to\n+\tconst dump_location_t &.\n+\t(selftest::test_impl_location): New function.\n+\t(selftest::dumpfile_c_tests): New function.\n+\t* dumpfile.h: Include \"profile-count.h\".\n+\t(class dump_user_location_t): New class.\n+\t(struct dump_impl_location_t): New struct.\n+\t(class dump_location_t): New class.\n+\t(dump_printf_loc): Convert 2nd param from source_location to\n+\tconst dump_location_t &.\n+\t(dump_generic_expr_loc): Delete.\n+\t(dump_gimple_stmt_loc): Convert 2nd param from source_location to\n+\tconst dump_location_t &.\n+\t* gimple-fold.c (fold_gimple_assign): Update call to\n+\tdump_printf_loc to pass in a dump_location_t rather than a\n+\tlocation_t, via the gimple stmt.\n+\t(gimple_fold_call): Likewise.\n+\t* gimple-loop-interchange.cc\n+\t(loop_cand::analyze_iloop_reduction_var): Update for change to\n+\tcheck_reduction_path.\n+\t(tree_loop_interchange::interchange): Update for change to\n+\tfind_loop_location.\n+\t* graphite-isl-ast-to-gimple.c (scop_to_isl_ast): Update for\n+\tchange in return-type of find_loop_location.\n+\t(graphite_regenerate_ast_isl): Likewise.\n+\t* graphite-optimize-isl.c (optimize_isl): Likewise.\n+\t* graphite.c (graphite_transform_loops): Likewise.\n+\t* ipa-devirt.c (ipa_devirt): Update call to dump_printf_loc to\n+\tpass in a dump_location_t rather than a location_t, via the\n+\tgimple stmt.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Likewise.\n+\t* ipa.c (walk_polymorphic_call_targets): Likewise.\n+\t* loop-unroll.c (report_unroll): Convert \"locus\" param from\n+\tlocation_t to dump_location_t.\n+\t(decide_unrolling): Update for change to get_loop_location's\n+\treturn type.\n+\t* omp-grid.c (struct grid_prop): Convert field \"target_loc\" from\n+\tlocation_t to dump_user_location_t.\n+\t(grid_find_single_omp_among_assignments_1): Updates calls to\n+\tdump_printf_loc to pass in a dump_location_t rather than a\n+\tlocation_t, via the gimple stmt.\n+\t(grid_parallel_clauses_gridifiable): Convert \"tloc\" from\n+\tlocation_t to dump_location_t.  Updates calls to dump_printf_loc\n+\tto pass in a dump_location_t rather than a location_t, via the\n+\tgimple stmt.\n+\t(grid_inner_loop_gridifiable_p): Likewise.\n+\t(grid_dist_follows_simple_pattern): Likewise.\n+\t(grid_gfor_follows_tiling_pattern): Likewise.\n+\t(grid_target_follows_gridifiable_pattern): Likewise.\n+\t(grid_attempt_target_gridification): Convert initialization\n+\tof local \"grid\" from memset to zero-initialization; FIXME: does\n+\tthis require C++11?  Update call to dump_printf_loc to pass in a\n+\toptinfo_location rather than a location_t, via the gimple stmt.\n+\t* profile.c (read_profile_edge_counts): Updates call to\n+\tdump_printf_loc to pass in a dump_location_t rather than a\n+\tlocation_t\n+\t(compute_branch_probabilities): Likewise.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tdumpfile_c_tests.\n+\t* selftest.h (dumpfile_c_tests): New decl.\n+\t* tree-loop-distribution.c (pass_loop_distribution::execute):\n+\tUpdate for change in return type of find_loop_location.\n+\t* tree-parloops.c (parallelize_loops): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Convert\n+\t\"locus\" from location_t to dump_user_location_t.\n+\t(canonicalize_loop_induction_variables): Likewise.\n+\t* tree-ssa-loop-ivopts.c (tree_ssa_iv_optimize_loop): Update\n+\tfor change in return type of find_loop_location.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Update call\n+\tto dump_printf_loc to pass in a dump_location_t rather than a\n+\tlocation_t, via the stmt.\n+\t* tree-ssa-sccvn.c (eliminate_dom_walker::before_dom_children):\n+\tLikewise.\n+\t* tree-vect-loop-manip.c (find_loop_location): Convert return\n+\ttype from source_location to dump_user_location_t.\n+\t(vect_do_peeling): Update for above change.\n+\t(vect_loop_versioning): Update for change in type of\n+\tvect_location.\n+\t* tree-vect-loop.c (check_reduction_path): Convert \"loc\" param\n+\tfrom location_t to dump_user_location_t.\n+\t(vect_estimate_min_profitable_iters): Update for change in type\n+\tof vect_location.\n+\t* tree-vect-slp.c (vect_print_slp_tree): Convert param \"loc\" from\n+\tlocation_t to dump_location_t.\n+\t(vect_slp_bb): Update for change in type of vect_location.\n+\t* tree-vectorizer.c (vect_location): Convert from source_location\n+\tto dump_user_location_t.\n+\t(try_vectorize_loop_1): Update for change in vect_location's type.\n+\t(vectorize_loops): Likewise.\n+\t(increase_alignment): Likewise.\n+\t* tree-vectorizer.h (vect_location): Convert from source_location\n+\tto dump_user_location_t.\n+\t(find_loop_location): Convert return type from source_location to\n+\tdump_user_location_t.\n+\t(check_reduction_path): Convert 1st param from location_t to\n+\tdump_user_location_t.\n+\t* value-prof.c (check_counter): Update call to dump_printf_loc to\n+\tpass in a dump_user_location_t rather than a location_t; update\n+\tcall to error_at for change in type of \"locus\".\n+\t(check_ic_target): Update call to dump_printf_loc to\n+\tpass in a dump_user_location_t rather than a location_t, via the\n+\tcall_stmt.\n+\n 2018-06-26  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n \n         * config/s390/s390.h (enum processor_flags): Do not use"}, {"sha": "e27cd39259c549884a65682561afcc7a2366b384", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -1800,7 +1800,7 @@ loop_exits_from_bb_p (struct loop *loop, basic_block bb)\n \n /* Return location corresponding to the loop control condition if possible.  */\n \n-location_t\n+dump_user_location_t\n get_loop_location (struct loop *loop)\n {\n   rtx_insn *insn = NULL;\n@@ -1819,7 +1819,7 @@ get_loop_location (struct loop *loop)\n       FOR_BB_INSNS_REVERSE (desc->in_edge->src, insn)\n         {\n           if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n-            return INSN_LOCATION (insn);\n+            return insn;\n         }\n     }\n   /* If loop has a single exit, then the loop control branch\n@@ -1829,24 +1829,24 @@ get_loop_location (struct loop *loop)\n       FOR_BB_INSNS_REVERSE (exit->src, insn)\n         {\n           if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n-            return INSN_LOCATION (insn);\n+            return insn;\n         }\n     }\n   /* Next check the latch, to see if it is non-empty.  */\n   FOR_BB_INSNS_REVERSE (loop->latch, insn)\n     {\n       if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n-        return INSN_LOCATION (insn);\n+        return insn;\n     }\n   /* Finally, if none of the above identifies the loop control branch,\n      return the first location in the loop header.  */\n   FOR_BB_INSNS (loop->header, insn)\n     {\n       if (INSN_P (insn) && INSN_HAS_LOCATION (insn))\n-        return INSN_LOCATION (insn);\n+        return insn;\n     }\n   /* If all else fails, simply return the current function location.  */\n-  return DECL_SOURCE_LOCATION (current_function_decl);\n+  return dump_user_location_t::from_function_decl (current_function_decl);\n }\n \n /* Records that every statement in LOOP is executed I_BOUND times."}, {"sha": "80a31c416ca3a584b01f27ada8cfc1a7e5edfad9", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -357,7 +357,7 @@ extern bool loop_exit_edge_p (const struct loop *, const_edge);\n extern bool loop_exits_to_bb_p (struct loop *, basic_block);\n extern bool loop_exits_from_bb_p (struct loop *, basic_block);\n extern void mark_loop_exit_edges (void);\n-extern location_t get_loop_location (struct loop *loop);\n+extern dump_user_location_t get_loop_location (struct loop *loop);\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);"}, {"sha": "7cfb8a0f55929ed18bae105fbcfce70fe1de5106", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -928,8 +928,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t    }\n           if (dump_enabled_p ())\n             {\n-\t      location_t locus = gimple_location_safe (edge->call_stmt);\n-\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, edge->call_stmt,\n \t\t\t       \"devirtualizing call in %s to %s\\n\",\n \t\t\t       edge->caller->name (), target->name ());\n \t    }"}, {"sha": "350cc4559c5caea387269b66cea8655995851eae", "filename": "gcc/coverage.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -342,12 +342,16 @@ get_coverage_counts (unsigned counter, unsigned expected,\n       static int warned = 0;\n \n       if (!warned++ && dump_enabled_p ())\n-\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n-                         (flag_guess_branch_prob\n-                          ? \"file %s not found, execution counts estimated\\n\"\n-                          : \"file %s not found, execution counts assumed to \"\n-                            \"be zero\\n\"),\n-                         da_file_name);\n+\t{\n+\t  dump_user_location_t loc\n+\t    = dump_user_location_t::from_location_t (input_location);\n+\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t\t   (flag_guess_branch_prob\n+\t\t\t    ? \"file %s not found, execution counts estimated\\n\"\n+\t\t\t    : \"file %s not found, execution counts assumed to \"\n+\t\t\t    \"be zero\\n\"),\n+\t\t\t   da_file_name);\n+\t}\n       return NULL;\n     }\n   if (PARAM_VALUE (PARAM_PROFILE_FUNC_INTERNAL_ID))\n@@ -378,15 +382,17 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \t\t    \"its profile data (counter %qs)\", id, ctr_names[counter]);\n       if (warning_printed && dump_enabled_p ())\n \t{\n-          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n+\t  dump_user_location_t loc\n+\t    = dump_user_location_t::from_location_t (input_location);\n+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n                            \"use -Wno-error=coverage-mismatch to tolerate \"\n                            \"the mismatch but performance may drop if the \"\n                            \"function is hot\\n\");\n \t  \n \t  if (!seen_error ()\n \t      && !warned++)\n \t    {\n-\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n                                \"coverage mismatch ignored\\n\");\n \t      dump_printf (MSG_OPTIMIZED_LOCATIONS,\n                            flag_guess_branch_prob"}, {"sha": "6202802fec1c61eff2515aa2330901668399fcb1", "filename": "gcc/doc/optinfo.texi", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fdoc%2Foptinfo.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fdoc%2Foptinfo.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptinfo.texi?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -168,7 +168,7 @@ when any of the following flags is enabled\n \n @example\n int report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_RTL | TDF_DETAILS;\n-dump_printf_loc (report_flags, locus,\n+dump_printf_loc (report_flags, insn,\n                  \"loop turned into non-loop; it never loops.\\n\");\n @end example\n \n@@ -181,7 +181,19 @@ Output gimple statement.\n \n Note that the above methods also have variants prefixed with\n @code{_loc}, such as @code{dump_printf_loc}, which are similar except\n-they also output the source location information.\n+they also output the source location information.  The @code{_loc} variants\n+take a @code{const dump_location_t &}.  This class can be constructed from\n+a @code{gimple *} or from a @code{rtx_insn *}, and so callers can pass\n+a @code{gimple *} or a @code{rtx_insn *} as the @code{_loc} argument.\n+The @code{dump_location_t} constructor will extract the source location\n+from the statement or instruction, along with the profile count, and\n+the location in GCC's own source code (or the plugin) from which the dump\n+call was emitted.  Only the source location is currently used.\n+There is also a @code{dump_user_location_t} class, capturing the\n+source location and profile count, but not the dump emission location,\n+so that locations in the user's code can be passed around.  This\n+can also be constructed from a @code{gimple *} and from a @code{rtx_insn *},\n+and it too can be passed as the @code{_loc} argument.\n \n @end ftable\n "}, {"sha": "d4e1477cfb96686cbf00bb34d78b993e3af131d7", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 105, "deletions": 28, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -29,6 +29,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"profile-count.h\"\n #include \"tree-cfg.h\"\n #include \"langhooks.h\"\n+#include \"backend.h\" /* for gimple.h.  */\n+#include \"gimple.h\" /* for dump_user_location_t ctor.  */\n+#include \"rtl.h\" /* for dump_user_location_t ctor.  */\n+#include \"selftest.h\"\n \n /* If non-NULL, return one past-the-end of the matching SUBPART of\n    the WHOLE string.  */\n@@ -358,9 +362,51 @@ dump_open_alternate_stream (struct dump_file_info *dfi)\n   return stream;\n }\n \n+/* Construct a dump_user_location_t from STMT (using its location and\n+   hotness).  */\n+\n+dump_user_location_t::dump_user_location_t (gimple *stmt)\n+: m_count (), m_loc (UNKNOWN_LOCATION)\n+{\n+  if (stmt)\n+    {\n+      if (stmt->bb)\n+\tm_count = stmt->bb->count;\n+      m_loc = gimple_location (stmt);\n+    }\n+}\n+\n+/* Construct a dump_user_location_t from an RTL instruction (using its\n+   location and hotness).  */\n+\n+dump_user_location_t::dump_user_location_t (rtx_insn *insn)\n+: m_count (), m_loc (UNKNOWN_LOCATION)\n+{\n+  if (insn)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN (insn);\n+      if (bb)\n+\tm_count = bb->count;\n+      m_loc = INSN_LOCATION (insn);\n+    }\n+}\n+\n+/* Construct from a function declaration.  This one requires spelling out\n+   to avoid accidentally constructing from other kinds of tree.  */\n+\n+dump_user_location_t\n+dump_user_location_t::from_function_decl (tree fndecl)\n+{\n+  gcc_assert (fndecl);\n+\n+  // FIXME: profile count for function?\n+  return dump_user_location_t (profile_count (),\n+\t\t\t       DECL_SOURCE_LOCATION (fndecl));\n+}\n+\n /* Print source location on DFILE if enabled.  */\n \n-void\n+static void\n dump_loc (dump_flags_t dump_kind, FILE *dfile, source_location loc)\n {\n   if (dump_kind)\n@@ -393,18 +439,19 @@ dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n /* Similar to dump_gimple_stmt, except additionally print source location.  */\n \n void\n-dump_gimple_stmt_loc (dump_flags_t dump_kind, source_location loc,\n+dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n \t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n {\n+  location_t srcloc = loc.get_location_t ();\n   if (dump_file && (dump_kind & pflags))\n     {\n-      dump_loc (dump_kind, dump_file, loc);\n+      dump_loc (dump_kind, dump_file, srcloc);\n       print_gimple_stmt (dump_file, gs, spc, dump_flags | extra_dump_flags);\n     }\n \n   if (alt_dump_file && (dump_kind & alt_flags))\n     {\n-      dump_loc (dump_kind, alt_dump_file, loc);\n+      dump_loc (dump_kind, alt_dump_file, srcloc);\n       print_gimple_stmt (alt_dump_file, gs, spc, dump_flags | extra_dump_flags);\n     }\n }\n@@ -423,27 +470,6 @@ dump_generic_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n       print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n }\n \n-\n-/* Similar to dump_generic_expr, except additionally print the source\n-   location.  */\n-\n-void\n-dump_generic_expr_loc (dump_flags_t dump_kind, source_location loc,\n-\t\t       dump_flags_t extra_dump_flags, tree t)\n-{\n-  if (dump_file && (dump_kind & pflags))\n-    {\n-      dump_loc (dump_kind, dump_file, loc);\n-      print_generic_expr (dump_file, t, dump_flags | extra_dump_flags);\n-    }\n-\n-  if (alt_dump_file && (dump_kind & alt_flags))\n-    {\n-      dump_loc (dump_kind, alt_dump_file, loc);\n-      print_generic_expr (alt_dump_file, t, dump_flags | extra_dump_flags);\n-    }\n-}\n-\n /* Output a formatted message using FORMAT on appropriate dump streams.  */\n \n void\n@@ -469,13 +495,14 @@ dump_printf (dump_flags_t dump_kind, const char *format, ...)\n /* Similar to dump_printf, except source location is also printed.  */\n \n void\n-dump_printf_loc (dump_flags_t dump_kind, source_location loc,\n+dump_printf_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n \t\t const char *format, ...)\n {\n+  location_t srcloc = loc.get_location_t ();\n   if (dump_file && (dump_kind & pflags))\n     {\n       va_list ap;\n-      dump_loc (dump_kind, dump_file, loc);\n+      dump_loc (dump_kind, dump_file, srcloc);\n       va_start (ap, format);\n       vfprintf (dump_file, format, ap);\n       va_end (ap);\n@@ -484,7 +511,7 @@ dump_printf_loc (dump_flags_t dump_kind, source_location loc,\n   if (alt_dump_file && (dump_kind & alt_flags))\n     {\n       va_list ap;\n-      dump_loc (dump_kind, alt_dump_file, loc);\n+      dump_loc (dump_kind, alt_dump_file, srcloc);\n       va_start (ap, format);\n       vfprintf (alt_dump_file, format, ap);\n       va_end (ap);\n@@ -1059,3 +1086,53 @@ enable_rtl_dump_file (void)\n \t\t\t    NULL);\n   return num_enabled > 0;\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that the dump_location_t constructors capture the source location\n+   at which they were called (provided that the build compiler is sufficiently\n+   recent).  */\n+\n+static void\n+test_impl_location ()\n+{\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n+  /* Default ctor.  */\n+  {\n+    dump_location_t loc;\n+    const int expected_line = __LINE__ - 1;\n+    ASSERT_STR_CONTAINS (loc.get_impl_location ().m_file, \"dumpfile.c\");\n+    ASSERT_EQ (loc.get_impl_location ().m_line, expected_line);\n+  }\n+\n+  /* Constructing from a gimple.  */\n+  {\n+    dump_location_t loc ((gimple *)NULL);\n+    const int expected_line = __LINE__ - 1;\n+    ASSERT_STR_CONTAINS (loc.get_impl_location ().m_file, \"dumpfile.c\");\n+    ASSERT_EQ (loc.get_impl_location ().m_line, expected_line);\n+  }\n+\n+  /* Constructing from an rtx_insn.  */\n+  {\n+    dump_location_t loc ((rtx_insn *)NULL);\n+    const int expected_line = __LINE__ - 1;\n+    ASSERT_STR_CONTAINS (loc.get_impl_location ().m_file, \"dumpfile.c\");\n+    ASSERT_EQ (loc.get_impl_location ().m_line, expected_line);\n+  }\n+#endif\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+dumpfile_c_tests ()\n+{\n+  test_impl_location ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "90d8930c02d5bce9e0ead332796f76ee0786dd00", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 151, "deletions": 5, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_DUMPFILE_H\n #define GCC_DUMPFILE_H 1\n \n+#include \"profile-count.h\"\n \n /* Different tree dump places.  When you add new tree dump places,\n    extend the DUMP_FILES array in dumpfile.c.  */\n@@ -268,20 +269,165 @@ struct dump_file_info\n   bool graph_dump_initialized;\n };\n \n+/* A class for describing where in the user's source that a dump message\n+   relates to, with various constructors for convenience.\n+   In particular, this lets us associate dump messages\n+   with hotness information (e.g. from PGO), allowing them to\n+   be prioritized by code hotness.  */\n+\n+class dump_user_location_t\n+{\n+ public:\n+  /* Default constructor, analogous to UNKNOWN_LOCATION.  */\n+  dump_user_location_t () : m_count (), m_loc (UNKNOWN_LOCATION) {}\n+\n+  /* Construct from a gimple statement (using its location and hotness).  */\n+  dump_user_location_t (gimple *stmt);\n+\n+  /* Construct from an RTL instruction (using its location and hotness).  */\n+  dump_user_location_t (rtx_insn *insn);\n+\n+  /* Construct from a location_t.  This one is deprecated (since it doesn't\n+     capture hotness information); it thus needs to be spelled out.  */\n+  static dump_user_location_t\n+  from_location_t (location_t loc)\n+  {\n+    return dump_user_location_t (profile_count (), loc);\n+  }\n+\n+  /* Construct from a function declaration.  This one requires spelling out\n+     to avoid accidentally constructing from other kinds of tree.  */\n+  static dump_user_location_t\n+  from_function_decl (tree fndecl);\n+\n+  profile_count get_count () const { return m_count; }\n+  location_t get_location_t () const { return m_loc; }\n+\n+ private:\n+  /* Private ctor from count and location, for use by from_location_t.  */\n+  dump_user_location_t (profile_count count, location_t loc)\n+    : m_count (count), m_loc (loc)\n+  {}\n+\n+  profile_count m_count;\n+  location_t m_loc;\n+};\n+\n+/* A class for identifying where in the compiler's own source\n+   (or a plugin) that a dump message is being emitted from.  */\n+\n+struct dump_impl_location_t\n+{\n+  dump_impl_location_t (\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n+\t\t\tconst char *file = __builtin_FILE (),\n+\t\t\tint line = __builtin_LINE (),\n+\t\t\tconst char *function = __builtin_FUNCTION ()\n+#else\n+\t\t\tconst char *file = __FILE__,\n+\t\t\tint line = __LINE__,\n+\t\t\tconst char *function = NULL\n+#endif\n+  )\n+  : m_file (file), m_line (line), m_function (function)\n+  {}\n+\n+  const char *m_file;\n+  int m_line;\n+  const char *m_function;\n+};\n+\n+/* A bundle of information for describing the location of a dump message:\n+   (a) the source location and hotness within the user's code, together with\n+   (b) the source location within the compiler/plugin.\n+\n+   The constructors use default parameters so that (b) gets sets up\n+   automatically.\n+\n+   The upshot is that you can pass in e.g. a gimple * to dump_printf_loc,\n+   and the dump call will automatically record where in GCC's source\n+   code the dump was emitted from.  */\n+\n+class dump_location_t\n+{\n+ public:\n+  /* Default constructor, analogous to UNKNOWN_LOCATION.  */\n+  dump_location_t (const dump_impl_location_t &impl_location\n+\t\t     = dump_impl_location_t ())\n+  : m_user_location (dump_user_location_t ()),\n+    m_impl_location (impl_location)\n+  {\n+  }\n+\n+  /* Construct from a gimple statement (using its location and hotness).  */\n+  dump_location_t (gimple *stmt,\n+\t\t   const dump_impl_location_t &impl_location\n+\t\t     = dump_impl_location_t ())\n+  : m_user_location (dump_user_location_t (stmt)),\n+    m_impl_location (impl_location)\n+  {\n+  }\n+\n+  /* Construct from an RTL instruction (using its location and hotness).  */\n+  dump_location_t (rtx_insn *insn,\n+\t\t   const dump_impl_location_t &impl_location\n+\t\t   = dump_impl_location_t ())\n+  : m_user_location (dump_user_location_t (insn)),\n+    m_impl_location (impl_location)\n+  {\n+  }\n+\n+  /* Construct from a dump_user_location_t.  */\n+  dump_location_t (const dump_user_location_t &user_location,\n+\t\t   const dump_impl_location_t &impl_location\n+\t\t     = dump_impl_location_t ())\n+  : m_user_location (user_location),\n+    m_impl_location (impl_location)\n+  {\n+  }\n+\n+  /* Construct from a location_t.  This one is deprecated (since it doesn't\n+     capture hotness information), and thus requires spelling out.  */\n+  static dump_location_t\n+  from_location_t (location_t loc,\n+\t\t   const dump_impl_location_t &impl_location\n+\t\t     = dump_impl_location_t ())\n+  {\n+    return dump_location_t (dump_user_location_t::from_location_t (loc),\n+\t\t\t    impl_location);\n+  }\n+\n+  const dump_user_location_t &\n+  get_user_location () const { return m_user_location; }\n+\n+  const dump_impl_location_t &\n+  get_impl_location () const { return m_impl_location; }\n+\n+  location_t get_location_t () const\n+  {\n+    return m_user_location.get_location_t ();\n+  }\n+\n+  profile_count get_count () const { return m_user_location.get_count (); }\n+\n+ private:\n+  dump_user_location_t m_user_location;\n+  dump_impl_location_t m_impl_location;\n+};\n+\n /* In dumpfile.c */\n extern FILE *dump_begin (int, dump_flags_t *);\n extern void dump_end (int, FILE *);\n extern int opt_info_switch_p (const char *);\n extern const char *dump_flag_name (int);\n extern void dump_printf (dump_flags_t, const char *, ...) ATTRIBUTE_PRINTF_2;\n-extern void dump_printf_loc (dump_flags_t, source_location,\n-                             const char *, ...) ATTRIBUTE_PRINTF_3;\n+extern void dump_printf_loc (dump_flags_t, const dump_location_t &,\n+\t\t\t     const char *, ...) ATTRIBUTE_PRINTF_3;\n extern void dump_function (int phase, tree fn);\n extern void dump_basic_block (dump_flags_t, basic_block, int);\n-extern void dump_generic_expr_loc (dump_flags_t, source_location, dump_flags_t, tree);\n extern void dump_generic_expr (dump_flags_t, dump_flags_t, tree);\n-extern void dump_gimple_stmt_loc (dump_flags_t, source_location, dump_flags_t,\n-\t\t\t\t  gimple *, int);\n+extern void dump_gimple_stmt_loc (dump_flags_t, const dump_location_t &,\n+\t\t\t\t  dump_flags_t, gimple *, int);\n extern void dump_gimple_stmt (dump_flags_t, dump_flags_t, gimple *, int);\n extern void print_combine_total_stats (void);\n extern bool enable_rtl_dump_file (void);"}, {"sha": "a31f5071863c227a64de2c561110dcade1ad1708", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -347,8 +347,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t\t  {\n \t\t    if (dump_enabled_p ())\n \t\t      {\n-\t\t\tlocation_t loc = gimple_location_safe (stmt);\n-\t\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n \t\t\t\t\t \"resolving virtual function address \"\n \t\t\t\t\t \"reference to function %s\\n\",\n \t\t\t\t\t targets.length () == 1\n@@ -4063,8 +4062,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t      tree lhs = gimple_call_lhs (stmt);\n \t      if (dump_enabled_p ())\n \t\t{\n-\t\t  location_t loc = gimple_location_safe (stmt);\n-\t\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n \t\t\t\t   \"folding virtual function call to %s\\n\",\n \t\t \t\t   targets.length () == 1\n \t\t  \t\t   ? targets[0]->name ()"}, {"sha": "08aeb8eba9df232c549d07d5b289abad902498ca", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -523,7 +523,7 @@ loop_cand::analyze_iloop_reduction_var (tree var)\n \n   /* Handle and verify a series of stmts feeding the reduction op.  */\n   if (single_use != next_def\n-      && !check_reduction_path (UNKNOWN_LOCATION, m_loop, phi, next,\n+      && !check_reduction_path (dump_user_location_t (), m_loop, phi, next,\n \t\t\t\tgimple_assign_rhs_code (single_use)))\n     return false;\n \n@@ -1578,7 +1578,7 @@ bool\n tree_loop_interchange::interchange (vec<data_reference_p> datarefs,\n \t\t\t\t    vec<ddr_p> ddrs)\n {\n-  location_t loc = find_loop_location (m_loop_nest[0]);\n+  dump_user_location_t loc = find_loop_location (m_loop_nest[0]);\n   bool changed_p = false;\n   /* In each iteration we try to interchange I-th loop with (I+1)-th loop.\n      The overall effect is to push inner loop to outermost level in whole"}, {"sha": "9e78465ea9cdacdcbc930003768ada3cf542e855", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -1409,7 +1409,7 @@ scop_to_isl_ast (scop_p scop)\n   isl_ctx_set_max_operations (scop->isl_context, old_max_operations);\n   if (isl_ctx_last_error (scop->isl_context) != isl_error_none)\n     {\n-      location_t loc = find_loop_location\n+      dump_user_location_t loc = find_loop_location\n \t(scop->scop_info->region.entry->dest->loop_father);\n       if (isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n@@ -1518,7 +1518,7 @@ graphite_regenerate_ast_isl (scop_p scop)\n \n   if (t.codegen_error_p ())\n     {\n-      location_t loc = find_loop_location\n+      dump_user_location_t loc = find_loop_location\n \t(scop->scop_info->region.entry->dest->loop_father);\n       dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n \t\t       \"loop nest not optimized, code generation error\\n\");"}, {"sha": "35e9ac00ec295751eb8487a51cd2d2d2147e9cf4", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -160,7 +160,7 @@ optimize_isl (scop_p scop)\n   if (!scop->transformed_schedule\n       || isl_ctx_last_error (scop->isl_context) != isl_error_none)\n     {\n-      location_t loc = find_loop_location\n+      dump_user_location_t loc = find_loop_location\n \t(scop->scop_info->region.entry->dest->loop_father);\n       if (isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n@@ -182,7 +182,7 @@ optimize_isl (scop_p scop)\n \n   if (same_schedule)\n     {\n-      location_t loc = find_loop_location\n+      dump_user_location_t loc = find_loop_location\n \t(scop->scop_info->region.entry->dest->loop_father);\n       dump_printf_loc (MSG_NOTE, loc,\n \t\t       \"loop nest not optimized, optimized schedule is \""}, {"sha": "ddf16a827d061ad7cf091af82d1b2dbfed5c90e3", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -412,7 +412,7 @@ graphite_transform_loops (void)\n \tchanged = true;\n \tif (graphite_regenerate_ast_isl (scop))\n \t  {\n-\t    location_t loc = find_loop_location\n+\t    dump_user_location_t loc = find_loop_location\n \t      (scops[i]->scop_info->region.entry->dest->loop_father);\n \t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n \t\t\t     \"loop nest optimized\\n\");"}, {"sha": "e99d8ccd14c423521cf3178d0100a348ef0be8c3", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -3755,8 +3755,7 @@ ipa_devirt (void)\n \t      {\n \t\tif (dump_enabled_p ())\n                   {\n-                    location_t locus = gimple_location_safe (e->call_stmt);\n-                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, e->call_stmt,\n \t\t\t\t     \"speculatively devirtualizing call \"\n \t\t\t\t     \"in %s to %s\\n\",\n \t\t\t\t     n->dump_name (),"}, {"sha": "8b19fe3f39190529f1d18224878326bcc6cbba21", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -2842,8 +2842,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n-\t\t  location_t loc = gimple_location_safe (ie->call_stmt);\n-\t\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, ie->call_stmt,\n \t\t\t\t   \"discovered direct call non-invariant %s\\n\",\n \t\t\t\t   ie->caller->dump_name ());\n \t\t}\n@@ -2853,8 +2852,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \n           if (dump_enabled_p ())\n \t    {\n-\t      location_t loc = gimple_location_safe (ie->call_stmt);\n-\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, ie->call_stmt,\n \t\t\t       \"discovered direct call to non-function in %s, \"\n \t\t\t       \"making it __builtin_unreachable\\n\",\n \t\t\t       ie->caller->dump_name ());\n@@ -2942,9 +2940,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n      }\n   if (dump_enabled_p ())\n     {\n-      location_t loc = gimple_location_safe (ie->call_stmt);\n-\n-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, ie->call_stmt,\n \t\t       \"converting indirect call in %s to direct call to %s\\n\",\n \t\t       ie->caller->name (), callee->name ());\n     }"}, {"sha": "3b6b5e5c8d4c63bc5a32be142022a9ac8bf8faca", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -225,13 +225,8 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t       (builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n \n \t  if (dump_enabled_p ())\n-            {\n-\t      location_t locus;\n-\t      if (edge->call_stmt)\n-\t\tlocus = gimple_location (edge->call_stmt);\n-\t      else\n-\t\tlocus = UNKNOWN_LOCATION;\n-\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n+\t    {\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, edge->call_stmt,\n \t\t\t       \"devirtualizing call in %s to %s\\n\",\n \t\t\t       edge->caller->dump_name (),\n \t\t\t       target->dump_name ());"}, {"sha": "48bbda0dd77bc15f5fb640cad04d2f28662a5e5f", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -189,7 +189,7 @@ static rtx get_expansion (struct var_to_expand *);\n    appropriate given the dump or -fopt-info settings.  */\n \n static void\n-report_unroll (struct loop *loop, location_t locus)\n+report_unroll (struct loop *loop, dump_location_t locus)\n {\n   dump_flags_t report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS;\n \n@@ -220,7 +220,7 @@ decide_unrolling (int flags)\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       loop->lpt_decision.decision = LPT_NONE;\n-      location_t locus = get_loop_location (loop);\n+      dump_user_location_t locus = get_loop_location (loop);\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, locus,"}, {"sha": "6edc92fd51980396482220d959324f25d73c396a", "filename": "gcc/omp-grid.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fomp-grid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fomp-grid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-grid.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -91,7 +91,7 @@ struct grid_prop\n   bool tiling;\n   /* Location of the target construct for optimization information\n      messages.  */\n-  location_t target_loc;\n+  dump_user_location_t target_loc;\n   /* The collapse clause of the involved loops.  Collapse value of all of them\n      must be the same for gridification to take place.  */\n   size_t collapse;\n@@ -177,10 +177,10 @@ grid_find_single_omp_among_assignments_1 (gimple_seq seq, grid_prop *grid,\n \t\t\t\t   GRID_MISSED_MSG_PREFIX \"%s construct \"\n \t\t\t\t   \"contains multiple OpenMP constructs\\n\",\n \t\t\t\t   name);\n-\t\t  dump_printf_loc (MSG_NOTE, gimple_location (*ret),\n+\t\t  dump_printf_loc (MSG_NOTE, *ret,\n \t\t\t\t   \"The first OpenMP construct within \"\n \t\t\t\t   \"a parallel\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t  dump_printf_loc (MSG_NOTE, stmt,\n \t\t\t\t   \"The second OpenMP construct within \"\n \t\t\t\t   \"a parallel\\n\");\n \t\t}\n@@ -195,7 +195,7 @@ grid_find_single_omp_among_assignments_1 (gimple_seq seq, grid_prop *grid,\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t       GRID_MISSED_MSG_PREFIX \"%s construct contains \"\n \t\t\t       \"a complex statement\\n\", name);\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t      dump_printf_loc (MSG_NOTE, stmt,\n \t\t\t       \"This statement cannot be analyzed for \"\n \t\t\t       \"gridification\\n\");\n \t    }\n@@ -286,7 +286,7 @@ grid_find_ungridifiable_statement (gimple_stmt_iterator *gsi,\n    loop that is evaluated for possible gridification.  */\n \n static bool\n-grid_parallel_clauses_gridifiable (gomp_parallel *par, location_t tloc)\n+grid_parallel_clauses_gridifiable (gomp_parallel *par, dump_user_location_t tloc)\n {\n   tree clauses = gimple_omp_parallel_clauses (par);\n   while (clauses)\n@@ -300,7 +300,7 @@ grid_parallel_clauses_gridifiable (gomp_parallel *par, location_t tloc)\n \t\t\t       GRID_MISSED_MSG_PREFIX \"because there is \"\n \t\t\t       \"a num_threads clause of the parallel \"\n \t\t\t       \"construct\\n\");\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (par),\n+\t      dump_printf_loc (MSG_NOTE, par,\n \t\t\t       \"Parallel construct has a num_threads clause\\n\");\n \t    }\n \t  return false;\n@@ -311,7 +311,7 @@ grid_parallel_clauses_gridifiable (gomp_parallel *par, location_t tloc)\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n \t\t\t       GRID_MISSED_MSG_PREFIX \"a reduction clause \"\n \t\t\t       \"is present\\n \");\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (par),\n+\t      dump_printf_loc (MSG_NOTE, par,\n \t\t\t       \"Parallel construct has a reduction clause\\n\");\n \t    }\n \t  return false;\n@@ -341,7 +341,7 @@ grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n \t\t\t   GRID_MISSED_MSG_PREFIX \"the inner loop \"\n \t\t\t   \"loop bounds computation contains a complex \"\n \t\t\t   \"statement\\n\");\n-\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t  dump_printf_loc (MSG_NOTE, gfor,\n \t\t\t   \"Loop construct cannot be analyzed for \"\n \t\t\t   \"gridification\\n\");\n \t}\n@@ -361,7 +361,7 @@ grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t\t   GRID_MISSED_MSG_PREFIX \"the inner loop \"\n \t\t\t\t   \"has a non-automatic schedule clause\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t  dump_printf_loc (MSG_NOTE, gfor,\n \t\t\t\t   \"Loop construct has a non automatic \"\n \t\t\t\t   \"schedule clause\\n\");\n \t\t}\n@@ -375,7 +375,7 @@ grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t       GRID_MISSED_MSG_PREFIX \"a reduction \"\n \t\t\t       \"clause is present\\n \");\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t      dump_printf_loc (MSG_NOTE, gfor,\n \t\t\t       \"Loop construct has a reduction schedule \"\n \t\t\t       \"clause\\n\");\n \t    }\n@@ -404,7 +404,7 @@ grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n \t\t\t     GRID_MISSED_MSG_PREFIX \"the inner loop contains \"\n \t\t\t     \"statement %s which cannot be transformed\\n\",\n \t\t\t     gimple_code_name[(int) gimple_code (bad)]);\n-\t  dump_printf_loc (MSG_NOTE, gimple_location (bad),\n+\t  dump_printf_loc (MSG_NOTE, bad,\n \t\t\t   \"This statement cannot be analyzed for \"\n \t\t\t   \"gridification\\n\");\n \t}\n@@ -422,7 +422,7 @@ grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n static bool\n grid_dist_follows_simple_pattern (gomp_for *dist, grid_prop *grid)\n {\n-  location_t tloc = grid->target_loc;\n+  dump_user_location_t tloc = grid->target_loc;\n   gimple *stmt = grid_find_single_omp_among_assignments (gimple_omp_body (dist),\n \t\t\t\t\t\t\t grid, \"distribute\");\n   gomp_parallel *par;\n@@ -468,7 +468,7 @@ grid_gfor_follows_tiling_pattern (gomp_for *gfor, grid_prop *grid)\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t   GRID_MISSED_MSG_PREFIX \"an inner loop is not \"\n \t\t\t   \"a simple for loop\\n\");\n-\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t  dump_printf_loc (MSG_NOTE, gfor,\n \t\t\t   \"This statement is not a simple for loop\\n\");\n \t}\n       return false;\n@@ -484,7 +484,7 @@ grid_gfor_follows_tiling_pattern (gomp_for *gfor, grid_prop *grid)\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t   GRID_MISSED_MSG_PREFIX \"an inner loop does not \"\n \t\t\t   \"have use the same collapse clause\\n\");\n-\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t  dump_printf_loc (MSG_NOTE, gfor,\n \t\t\t   \"Loop construct uses a different collapse clause\\n\");\n \t}\n       return false;\n@@ -524,7 +524,7 @@ grid_gfor_follows_tiling_pattern (gomp_for *gfor, grid_prop *grid)\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute and \"\n \t\t\t       \"an internal loop do not agree on tile size\\n\");\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t      dump_printf_loc (MSG_NOTE, gfor,\n \t\t\t       \"Loop construct does not seem to loop over \"\n \t\t\t       \"a tile size\\n\");\n \t    }\n@@ -636,7 +636,7 @@ grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t\t   GRID_MISSED_MSG_PREFIX \"the distribute \"\n \t\t\t\t   \"construct contains a try..catch region\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, gimple_location (try_stmt),\n+\t\t  dump_printf_loc (MSG_NOTE, try_stmt,\n \t\t\t\t   \"This statement cannot be analyzed for \"\n \t\t\t\t   \"tiled gridification\\n\");\n \t\t}\n@@ -661,7 +661,7 @@ grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute \"\n \t\t\t       \"construct contains a call\\n\");\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t      dump_printf_loc (MSG_NOTE, stmt,\n \t\t\t       \"This statement cannot be analyzed for \"\n \t\t\t       \"tiled gridification\\n\");\n \t    }\n@@ -677,7 +677,7 @@ grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n \t\t\t\t   GRID_MISSED_MSG_PREFIX \"a parallel \"\n \t\t\t\t   \"construct contains another parallel \"\n \t\t\t\t   \"construct\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t  dump_printf_loc (MSG_NOTE, stmt,\n \t\t\t\t   \"This parallel construct is nested in \"\n \t\t\t\t   \"another one\\n\");\n \t\t}\n@@ -698,7 +698,7 @@ grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n \t\t\t\t   GRID_MISSED_MSG_PREFIX \"a loop \"\n \t\t\t\t   \"construct is not nested within a parallel \"\n \t\t\t\t   \"construct\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t  dump_printf_loc (MSG_NOTE, stmt,\n \t\t\t\t   \"This loop construct is not nested in \"\n \t\t\t\t   \"a parallel construct\\n\");\n \t\t}\n@@ -714,7 +714,7 @@ grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n \t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute \"\n \t\t\t       \"construct contains a complex statement\\n\");\n-\t      dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t      dump_printf_loc (MSG_NOTE, stmt,\n \t\t\t       \"This statement cannot be analyzed for \"\n \t\t\t       \"tiled gridification\\n\");\n \t    }\n@@ -734,7 +734,7 @@ grid_target_follows_gridifiable_pattern (gomp_target *target, grid_prop *grid)\n   if (gimple_omp_target_kind (target) != GF_OMP_TARGET_KIND_REGION)\n     return false;\n \n-  location_t tloc = gimple_location (target);\n+  dump_user_location_t tloc = target;\n   grid->target_loc = tloc;\n   gimple *stmt\n     = grid_find_single_omp_among_assignments (gimple_omp_body (target),\n@@ -1257,14 +1257,13 @@ grid_attempt_target_gridification (gomp_target *target,\n \t\t\t\t   gbind *tgt_bind)\n {\n   /* removed group_size */\n-  grid_prop grid;\n-  memset (&grid, 0, sizeof (grid));\n+  grid_prop grid = {};\n   if (!target || !grid_target_follows_gridifiable_pattern (target, &grid))\n     return;\n \n   location_t loc = gimple_location (target);\n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, target,\n \t\t     \"Target construct will be turned into a gridified HSA \"\n \t\t     \"kernel\\n\");\n "}, {"sha": "0cd0270b4fb43b0f941fa8243b180eb8d14c8d08", "filename": "gcc/profile.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -447,9 +447,14 @@ read_profile_edge_counts (gcov_type *exec_counts)\n \t\t      {\n \t\t\tstatic bool informed = 0;\n \t\t\tif (dump_enabled_p () && !informed)\n-\t\t          dump_printf_loc (MSG_NOTE, input_location,\n-                                           \"corrupted profile info: edge count\"\n-                                           \" exceeds maximal count\\n\");\n+\t\t\t  {\n+\t\t\t    dump_location_t loc\n+\t\t\t      = dump_location_t::from_location_t\n+\t\t\t        (input_location);\n+\t\t\t    dump_printf_loc (MSG_NOTE, loc,\n+\t\t\t\t\t     \"corrupted profile info: edge count\"\n+\t\t\t\t\t     \" exceeds maximal count\\n\");\n+\t\t\t  }\n \t\t\tinformed = 1;\n \t\t      }\n \t\t    else\n@@ -672,7 +677,8 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n          if (dump_enabled_p () && informed == 0)\n            {\n              informed = 1;\n-             dump_printf_loc (MSG_NOTE, input_location,\n+             dump_printf_loc (MSG_NOTE,\n+\t\t\t      dump_location_t::from_location_t (input_location),\n                               \"correcting inconsistent profile data\\n\");\n            }\n          correct_negative_edge_counts ();"}, {"sha": "a9aacc02f1a030dd066b5613722bcc0234b34eb2", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -59,6 +59,7 @@ selftest::run_tests ()\n   /* Low-level data structures.  */\n   bitmap_c_tests ();\n   sbitmap_c_tests ();\n+  dumpfile_c_tests ();\n   et_forest_c_tests ();\n   hash_map_tests_c_tests ();\n   hash_set_tests_c_tests ();"}, {"sha": "a5507cc7693d6334b989f575ed3cd4c8a85b143c", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -188,6 +188,7 @@ extern void attribute_c_tests ();\n extern void bitmap_c_tests ();\n extern void diagnostic_c_tests ();\n extern void diagnostic_show_locus_c_tests ();\n+extern void dumpfile_c_tests ();\n extern void edit_context_c_tests ();\n extern void et_forest_c_tests ();\n extern void fibonacci_heap_c_tests ();"}, {"sha": "120661447f00586d767ff6cdb4898087fd47f3dd", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -3117,7 +3117,7 @@ pass_loop_distribution::execute (function *fun)\n \t    break;\n \n \t  const char *str = loop->inner ? \" nest\" : \"\";\n-\t  location_t loc = find_loop_location (loop);\n+\t  dump_user_location_t loc = find_loop_location (loop);\n \t  if (!cd)\n \t    {\n \t      calculate_dominance_info (CDI_DOMINATORS);"}, {"sha": "e79a9544d21f01d9d2c79e5f0823fd378058d624", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -3286,7 +3286,6 @@ parallelize_loops (bool oacc_kernels_p)\n   struct tree_niter_desc niter_desc;\n   struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n-  source_location loop_loc;\n \n   /* Do not parallelize loops in the functions created by parallelization.  */\n   if (!oacc_kernels_p\n@@ -3411,7 +3410,7 @@ parallelize_loops (bool oacc_kernels_p)\n       changed = true;\n       skip_loop = loop->inner;\n \n-      loop_loc = find_loop_location (loop);\n+      dump_user_location_t loop_loc = find_loop_location (loop);\n       if (loop->inner)\n \tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loop_loc,\n \t\t\t \"parallelizing outer loop %d\\n\", loop->num);"}, {"sha": "5f741c3b4988c8fc12b3ecc64d8118b3ba3412b7", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -691,7 +691,7 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t\t    edge exit, tree niter, bool may_be_zero,\n \t\t\t    enum unroll_level ul,\n \t\t\t    HOST_WIDE_INT maxiter,\n-\t\t\t    location_t locus, bool allow_peel)\n+\t\t\t    dump_user_location_t locus, bool allow_peel)\n {\n   unsigned HOST_WIDE_INT n_unroll = 0;\n   bool n_unroll_found = false;\n@@ -1162,7 +1162,7 @@ canonicalize_loop_induction_variables (struct loop *loop,\n   tree niter;\n   HOST_WIDE_INT maxiter;\n   bool modified = false;\n-  location_t locus = UNKNOWN_LOCATION;\n+  dump_user_location_t locus;\n   struct tree_niter_desc niter_desc;\n   bool may_be_zero = false;\n \n@@ -1177,7 +1177,7 @@ canonicalize_loop_induction_variables (struct loop *loop,\n \t= niter_desc.may_be_zero && !integer_zerop (niter_desc.may_be_zero);\n     }\n   if (TREE_CODE (niter) == INTEGER_CST)\n-    locus = gimple_location (last_stmt (exit->src));\n+    locus = last_stmt (exit->src);\n   else\n     {\n       /* For non-constant niter fold may_be_zero into niter again.  */\n@@ -1204,7 +1204,7 @@ canonicalize_loop_induction_variables (struct loop *loop,\n \tniter = find_loop_niter_by_eval (loop, &exit);\n \n       if (exit)\n-        locus = gimple_location (last_stmt (exit->src));\n+        locus = last_stmt (exit->src);\n \n       if (TREE_CODE (niter) != INTEGER_CST)\n \texit = NULL;"}, {"sha": "6b445bd2214ae424fadf424f3555786224d6c9fa", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -7535,7 +7535,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n \n   gcc_assert (!data->niters);\n   data->current_loop = loop;\n-  data->loop_loc = find_loop_location (loop);\n+  data->loop_loc = find_loop_location (loop).get_location_t ();\n   data->speed = optimize_loop_for_speed_p (loop);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "03588a012bdd9362458a061cc9c90304cc376f9c", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -2627,7 +2627,7 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n     return true;\n \n   if (warn)\n-    dump_printf_loc (MSG_MISSED_OPTIMIZATION, gimple_location_safe (stmt),\n+    dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,\n \t\t     \"missed loop optimization: niters analysis ends up \"\n \t\t     \"with assumptions.\\n\");\n "}, {"sha": "e5eddf902b84ac864e239c6846af71e12d4b7cab", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -5866,8 +5866,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t    fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n \t\t  if (dump_enabled_p ())\n \t\t    {\n-\t\t      location_t loc = gimple_location (stmt);\n-\t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,\n \t\t\t\t       \"converting indirect call to \"\n \t\t\t\t       \"function %s\\n\",\n \t\t\t\t       lang_hooks.decl_printable_name (fn, 2));"}, {"sha": "ea648f27c25878e1edea32638fea4e91a436a5c0", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -1301,38 +1301,38 @@ create_lcssa_for_virtual_phi (struct loop *loop)\n    location is calculated.\n    Return the loop location if succeed and NULL if not.  */\n \n-source_location\n+dump_user_location_t\n find_loop_location (struct loop *loop)\n {\n   gimple *stmt = NULL;\n   basic_block bb;\n   gimple_stmt_iterator si;\n \n   if (!loop)\n-    return UNKNOWN_LOCATION;\n+    return dump_user_location_t ();\n \n   stmt = get_loop_exit_condition (loop);\n \n   if (stmt\n       && LOCATION_LOCUS (gimple_location (stmt)) > BUILTINS_LOCATION)\n-    return gimple_location (stmt);\n+    return stmt;\n \n   /* If we got here the loop is probably not \"well formed\",\n      try to estimate the loop location */\n \n   if (!loop->header)\n-    return UNKNOWN_LOCATION;\n+    return dump_user_location_t ();\n \n   bb = loop->header;\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       stmt = gsi_stmt (si);\n       if (LOCATION_LOCUS (gimple_location (stmt)) > BUILTINS_LOCATION)\n-        return gimple_location (stmt);\n+        return stmt;\n     }\n \n-  return UNKNOWN_LOCATION;\n+  return dump_user_location_t ();\n }\n \n /* Return true if PHI defines an IV of the loop to be vectorized.  */\n@@ -2498,7 +2498,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t}\n     }\n \n-  source_location loop_loc = find_loop_location (loop);\n+  dump_user_location_t loop_loc = find_loop_location (loop);\n   struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n   if (prolog_peeling)\n     {\n@@ -3072,7 +3072,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       loop_constraint_set (loop, LOOP_C_INFINITE);\n     }\n \n-  if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n+  if (LOCATION_LOCUS (vect_location.get_location_t ()) != UNKNOWN_LOCATION\n       && dump_enabled_p ())\n     {\n       if (version_alias)"}, {"sha": "ab76be0bdac2de0f4ceacc853faa0246528d35f1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -2731,8 +2731,8 @@ needs_fold_left_reduction_p (tree type, tree_code code,\n    reduction operation CODE has a handled computation expression.  */\n \n bool\n-check_reduction_path (location_t loc, loop_p loop, gphi *phi, tree loop_arg,\n-\t\t      enum tree_code code)\n+check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n+\t\t      tree loop_arg, enum tree_code code)\n {\n   auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n   auto_bitmap visited;\n@@ -3750,8 +3750,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   else\n     {\n       if (LOOP_VINFO_LOOP (loop_vinfo)->force_vectorize)\n-\twarning_at (vect_location, OPT_Wopenmp_simd, \"vectorization \"\n-\t\t    \"did not happen for a simd loop\");\n+\twarning_at (vect_location.get_location_t (), OPT_Wopenmp_simd,\n+\t\t    \"vectorization did not happen for a simd loop\");\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "31b58dbb090caff51631c1ca668ee87051822326", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -1510,7 +1510,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n /* Dump a slp tree NODE using flags specified in DUMP_KIND.  */\n \n static void\n-vect_print_slp_tree (dump_flags_t dump_kind, location_t loc, slp_tree node)\n+vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n+\t\t     slp_tree node)\n {\n   int i;\n   gimple *stmt;\n@@ -3003,7 +3004,7 @@ vect_slp_bb (basic_block bb)\n \t  insns++;\n \n \t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n-\t    vect_location = gimple_location (stmt);\n+\t    vect_location = stmt;\n \n \t  if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs))\n \t    break;"}, {"sha": "971221c381c2c447cf65ba6cbf7e575e4b5b10b1", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -81,8 +81,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n \n \n-/* Loop or bb location.  */\n-source_location vect_location;\n+/* Loop or bb location, with hotness information.  */\n+dump_user_location_t vect_location;\n \n /* Vector mapping GIMPLE stmt to stmt_vec_info. */\n vec<stmt_vec_info> *stmt_vec_info_vec;\n@@ -696,11 +696,11 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n   unsigned ret = 0;\n   vec_info_shared shared;\n   vect_location = find_loop_location (loop);\n-  if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n+  if (LOCATION_LOCUS (vect_location.get_location_t ()) != UNKNOWN_LOCATION\n       && dump_enabled_p ())\n     dump_printf (MSG_NOTE, \"\\nAnalyzing loop at %s:%d\\n\",\n-\t\t LOCATION_FILE (vect_location),\n-\t\t LOCATION_LINE (vect_location));\n+\t\t LOCATION_FILE (vect_location.get_location_t ()),\n+\t\t LOCATION_LINE (vect_location.get_location_t ()));\n \n   loop_vec_info loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo, &shared);\n   loop->aux = loop_vinfo;\n@@ -917,7 +917,7 @@ vectorize_loops (void)\n       ret |= try_vectorize_loop (simduid_to_vf_htab, &num_vectorized_loops,\n \t\t\t\t loop);\n \n-  vect_location = UNKNOWN_LOCATION;\n+  vect_location = dump_user_location_t ();\n \n   statistics_counter_event (cfun, \"Vectorized loops\", num_vectorized_loops);\n   if (dump_enabled_p ()\n@@ -1249,7 +1249,7 @@ increase_alignment (void)\n {\n   varpool_node *vnode;\n \n-  vect_location = UNKNOWN_LOCATION;\n+  vect_location = dump_user_location_t ();\n   type_align_map = new hash_map<tree, unsigned>;\n \n   /* Increase the alignment of all global arrays for vectorization.  */"}, {"sha": "94a0f381b001e294786713eb55940044ca6d71da", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -1437,8 +1437,8 @@ vect_get_scalar_dr_size (struct data_reference *dr)\n   return tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n }\n \n-/* Source location */\n-extern source_location vect_location;\n+/* Source location + hotness information. */\n+extern dump_user_location_t vect_location;\n \n /* If dumping is enabled, emit a MSG_NOTE at vect_location about\n    entering MSG within the vectorizer.  MSG should be a string literal. */\n@@ -1466,7 +1466,7 @@ extern void vect_loop_versioning (loop_vec_info, unsigned int, bool,\n extern struct loop *vect_do_peeling (loop_vec_info, tree, tree,\n \t\t\t\t     tree *, tree *, tree *, int, bool, bool);\n extern void vect_prepare_for_masked_peels (loop_vec_info);\n-extern source_location find_loop_location (struct loop *);\n+extern dump_user_location_t find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n@@ -1582,7 +1582,7 @@ extern tree vect_create_addr_base_for_vector_ref (gimple *, gimple_seq *,\n extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *,\n \t\t\t\t\t    bool *, bool);\n /* Used in gimple-loop-interchange.c.  */\n-extern bool check_reduction_path (location_t, loop_p, gphi *, tree,\n+extern bool check_reduction_path (dump_user_location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info,"}, {"sha": "77d4849d5b1047a39390fdb93e06ee184fc7423e", "filename": "gcc/value-prof.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=4f5b9c803ac4edc639d8bf4a827ba40e4dab4db0", "patch": "@@ -585,10 +585,11 @@ check_counter (gimple *stmt, const char * name,\n   gcov_type bb_count = bb_count_d.ipa ().to_gcov_type ();\n   if (*all != bb_count || *count > *all)\n     {\n-      location_t locus;\n-      locus = (stmt != NULL)\n-              ? gimple_location (stmt)\n-              : DECL_SOURCE_LOCATION (current_function_decl);\n+      dump_user_location_t locus;\n+      locus = ((stmt != NULL)\n+\t       ? dump_user_location_t (stmt)\n+\t       : dump_user_location_t::from_function_decl\n+\t\t   (current_function_decl));\n       if (flag_profile_correction)\n         {\n           if (dump_enabled_p ())\n@@ -603,7 +604,7 @@ check_counter (gimple *stmt, const char * name,\n \t}\n       else\n \t{\n-\t  error_at (locus, \"corrupted value profile: %s \"\n+\t  error_at (locus.get_location_t (), \"corrupted value profile: %s \"\n \t\t    \"profile counter (%d out of %d) inconsistent with \"\n \t\t    \"basic-block count (%d)\",\n \t\t    name,\n@@ -1271,13 +1272,11 @@ find_func_by_profile_id (int profile_id)\n bool\n check_ic_target (gcall *call_stmt, struct cgraph_node *target)\n {\n-   location_t locus;\n    if (gimple_check_call_matching_types (call_stmt, target->decl, true))\n      return true;\n \n-   locus =  gimple_location (call_stmt);\n    if (dump_enabled_p ())\n-     dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,\n+     dump_printf_loc (MSG_MISSED_OPTIMIZATION, call_stmt,\n                       \"Skipping target %s with mismatching types for icall\\n\",\n                       target->name ());\n    return false;"}]}