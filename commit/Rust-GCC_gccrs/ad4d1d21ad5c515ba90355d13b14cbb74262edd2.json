{"sha": "ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ0ZDFkMjFhZDVjNTE1YmE5MDM1NWQxM2IxNGNiYjc0MjYyZWRkMg==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2019-09-04T22:43:29Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-09-04T22:43:29Z"}, "message": "PR libstdc++/41861 Add full steady_clock support to condition_variable\n\nThe pthread_cond_clockwait function is available in glibc since the 2.30\nrelease. If this function is available in the C library it can be used\nto fix PR libstdc++/41861 by supporting std::chrono::steady_clock\nproperly with std::condition_variable.\n\nThis means that code using std::condition_variable::wait_for or\nstd::condition_variable::wait_until with std::chrono::steady_clock is no\nlonger subject to timing out early or potentially waiting for much\nlonger if the system clock is warped at an inopportune moment.\n\nIf pthread_cond_clockwait is available then std::chrono::steady_clock is\ndeemed to be the \"best\" clock available which means that it is used for\nthe relative wait_for calls and absolute wait_until calls using\nuser-defined clocks. Calls explicitly using std::chrono::system_clock\ncontinue to use CLOCK_REALTIME via __gthread_cond_timedwait.\n\nIf pthread_cond_clockwait is not available then\nstd::chrono::system_clock is deemed to be the \"best\" clock available\nwhich means that the previous suboptimal behaviour remains.\n\n2019-09-04  Mike Crowe  <mac@mcrowe.com>\n\n\tPR libstdc++/41861\n\t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT): Check for new\n\tpthread_cond_clockwait function.\n\t* configure.ac: Use GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.\n\t* include/std/condition_variable: (condition_variable): Rename\n\t__steady_clock_t typedef and add system_clock. Change __clock_t to be\n\ta typedef for the preferred clock to convert arbitrary other clocks to.\n\t[_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT] (wait_until): Add a steady_clock\n\toverload.\n\t(wait_until): Change __clock_t overload to use system_clock.\n\t[_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT] (__wait_until_impl): Add\n\tsteady_clock overload that calls pthread_cond_clockwait.\n\t(__wait_until_impl): Change __clock_t overload to use system_clock.\n\t(condition_variable_any) [_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT]: Use\n\tsteady_clock for __clock_t if pthread_cond_clockwait is available.\n\nFrom-SVN: r275390", "tree": {"sha": "37c354f2ea9e5d08fcd05367233f4cb01e5ddba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37c354f2ea9e5d08fcd05367233f4cb01e5ddba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76e0dd66c87720a8a82a6d5f44ba4d8f63a51b1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e0dd66c87720a8a82a6d5f44ba4d8f63a51b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76e0dd66c87720a8a82a6d5f44ba4d8f63a51b1d"}], "stats": {"total": 202, "additions": 191, "deletions": 11}, "files": [{"sha": "987bcb0938af6c70dd275083bdd1a9029e0aad17", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "patch": "@@ -1,3 +1,23 @@\n+2019-09-04  Mike Crowe  <mac@mcrowe.com>\n+\n+\tPR libstdc++/41861\n+\t* acinclude.m4 (GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT): Check for new\n+\tpthread_cond_clockwait function.\n+\t* configure.ac: Use GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* include/std/condition_variable: (condition_variable): Rename\n+\t__steady_clock_t typedef and add system_clock. Change __clock_t to be\n+\ta typedef for the preferred clock to convert arbitrary other clocks to.\n+\t[_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT] (wait_until): Add a steady_clock\n+\toverload.\n+\t(wait_until): Change __clock_t overload to use system_clock.\n+\t[_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT] (__wait_until_impl): Add\n+\tsteady_clock overload that calls pthread_cond_clockwait.\n+\t(__wait_until_impl): Change __clock_t overload to use system_clock.\n+\t(condition_variable_any) [_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT]: Use\n+\tsteady_clock for __clock_t if pthread_cond_clockwait is available.\n+\n 2019-09-04  Mike Crowe  <mac@mcrowe.com>\n \n \t* testsuite/30_threads/condition_variable/members/2.cc (test01):"}, {"sha": "bc9095f47998ed186bfe5b12918b205fd890d306", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "patch": "@@ -4193,6 +4193,37 @@ AC_DEFUN([GLIBCXX_CHECK_PTHREADS_NUM_PROCESSORS_NP], [\n   AC_LANG_RESTORE\n ])\n \n+dnl\n+dnl Check whether pthread_cond_clockwait is available in <pthread.h> for std::condition_variable to use,\n+dnl and define _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT.\n+dnl\n+AC_DEFUN([GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT], [\n+\n+  AC_LANG_SAVE\n+  AC_LANG_CPLUSPLUS\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS -lpthread\"\n+\n+  AC_MSG_CHECKING([for pthread_cond_clockwait])\n+  AC_CACHE_VAL(glibcxx_cv_PTHREAD_COND_CLOCKWAIT, [\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [#include <pthread.h>],\n+      [pthread_mutex_t mutex; pthread_cond_t cond; struct timespec ts; int n = pthread_cond_clockwait(&cond, &mutex, 0, &ts);],\n+      [glibcxx_cv_PTHREAD_COND_CLOCKWAIT=yes],\n+      [glibcxx_cv_PTHREAD_COND_CLOCKWAIT=no])\n+  ])\n+  if test $glibcxx_cv_PTHREAD_COND_CLOCKWAIT = yes; then\n+    AC_DEFINE(_GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT, 1, [Define if pthread_cond_clockwait is available in <pthread.h>.])\n+  fi\n+  AC_MSG_RESULT($glibcxx_cv_PTHREAD_COND_CLOCKWAIT)\n+\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  LIBS=\"$ac_save_LIBS\"\n+  AC_LANG_RESTORE\n+])\n+\n dnl\n dnl Check whether sysctl is available in <pthread.h>, and define _GLIBCXX_USE_SYSCTL_HW_NCPU.\n dnl"}, {"sha": "3d13402f9234fcdd23df82126947c236ffab5468", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "patch": "@@ -991,6 +991,9 @@\n /* Define if pthreads_num_processors_np is available in <pthread.h>. */\n #undef _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP\n \n+/* Define if pthread_cond_clockwait is available in <pthread.h>. */\n+#undef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+\n /* Define if POSIX read/write locks are available in <gthr.h>. */\n #undef _GLIBCXX_USE_PTHREAD_RWLOCK_T\n "}, {"sha": "f2f5098df91459c97928c39c9270dbb358f11155", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "patch": "@@ -21581,6 +21581,89 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n \n+# For pthread_cond_clockwait\n+\n+\n+\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS -lpthread\"\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for pthread_cond_clockwait\" >&5\n+$as_echo_n \"checking for pthread_cond_clockwait... \" >&6; }\n+  if ${glibcxx_cv_PTHREAD_COND_CLOCKWAIT+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+\n+    if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+int\n+main ()\n+{\n+pthread_mutex_t mutex; pthread_cond_t cond; struct timespec ts; int n = pthread_cond_clockwait(&cond, &mutex, 0, &ts);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_PTHREAD_COND_CLOCKWAIT=yes\n+else\n+  glibcxx_cv_PTHREAD_COND_CLOCKWAIT=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error $? \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <pthread.h>\n+int\n+main ()\n+{\n+pthread_mutex_t mutex; pthread_cond_t cond; struct timespec ts; int n = pthread_cond_clockwait(&cond, &mutex, 0, &ts);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_PTHREAD_COND_CLOCKWAIT=yes\n+else\n+  glibcxx_cv_PTHREAD_COND_CLOCKWAIT=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+\n+  if test $glibcxx_cv_PTHREAD_COND_CLOCKWAIT = yes; then\n+\n+$as_echo \"#define _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_PTHREAD_COND_CLOCKWAIT\" >&5\n+$as_echo \"$glibcxx_cv_PTHREAD_COND_CLOCKWAIT\" >&6; }\n+\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  LIBS=\"$ac_save_LIBS\"\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+\n+\n \n   ac_fn_c_check_header_mongrel \"$LINENO\" \"locale.h\" \"ac_cv_header_locale_h\" \"$ac_includes_default\"\n if test \"x$ac_cv_header_locale_h\" = xyes; then :"}, {"sha": "ad4ae0c3b7d323413c122ee343963852a32fee6d", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "patch": "@@ -220,6 +220,9 @@ GLIBCXX_ENABLE_LIBSTDCXX_TIME\n # Check for tmpnam which is obsolescent in POSIX.1-2008\n GLIBCXX_CHECK_TMPNAM\n \n+# For pthread_cond_clockwait\n+GLIBCXX_CHECK_PTHREAD_COND_CLOCKWAIT\n+\n AC_LC_MESSAGES\n \n # For hardware_concurrency"}, {"sha": "cc96661e94cf8d41f850bb5d4e1713c31413a478", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4d1d21ad5c515ba90355d13b14cbb74262edd2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=ad4d1d21ad5c515ba90355d13b14cbb74262edd2", "patch": "@@ -65,8 +65,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// condition_variable\n   class condition_variable\n   {\n-    typedef chrono::system_clock\t__clock_t;\n-    typedef chrono::steady_clock\t__steady_clock_t;\n+    using steady_clock = chrono::steady_clock;\n+    using system_clock = chrono::system_clock;\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+    using __clock_t = steady_clock;\n+#else\n+    using __clock_t = system_clock;\n+#endif\n     typedef __gthread_cond_t\t\t__native_type;\n \n #ifdef __GTHREAD_COND_INIT\n@@ -101,18 +106,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  wait(__lock);\n       }\n \n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+    template<typename _Duration>\n+      cv_status\n+      wait_until(unique_lock<mutex>& __lock,\n+\t\t const chrono::time_point<steady_clock, _Duration>& __atime)\n+      { return __wait_until_impl(__lock, __atime); }\n+#endif\n+\n     template<typename _Duration>\n       cv_status\n       wait_until(unique_lock<mutex>& __lock,\n-\t\t const chrono::time_point<__clock_t, _Duration>& __atime)\n+\t\t const chrono::time_point<system_clock, _Duration>& __atime)\n       { return __wait_until_impl(__lock, __atime); }\n \n     template<typename _Clock, typename _Duration>\n       cv_status\n       wait_until(unique_lock<mutex>& __lock,\n \t\t const chrono::time_point<_Clock, _Duration>& __atime)\n       {\n-\t// DR 887 - Sync unknown clock to known clock.\n \tconst typename _Clock::time_point __c_entry = _Clock::now();\n \tconst __clock_t::time_point __s_entry = __clock_t::now();\n \tconst auto __delta = __atime - __c_entry;\n@@ -145,11 +157,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait_for(unique_lock<mutex>& __lock,\n \t       const chrono::duration<_Rep, _Period>& __rtime)\n       {\n-\tusing __dur = typename __steady_clock_t::duration;\n+\tusing __dur = typename steady_clock::duration;\n \tauto __reltime = chrono::duration_cast<__dur>(__rtime);\n \tif (__reltime < __rtime)\n \t  ++__reltime;\n-\treturn wait_until(__lock, __steady_clock_t::now() + __reltime);\n+\treturn wait_until(__lock, steady_clock::now() + __reltime);\n       }\n \n     template<typename _Rep, typename _Period, typename _Predicate>\n@@ -158,11 +170,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       const chrono::duration<_Rep, _Period>& __rtime,\n \t       _Predicate __p)\n       {\n-\tusing __dur = typename __steady_clock_t::duration;\n+\tusing __dur = typename steady_clock::duration;\n \tauto __reltime = chrono::duration_cast<__dur>(__rtime);\n \tif (__reltime < __rtime)\n \t  ++__reltime;\n-\treturn wait_until(__lock, __steady_clock_t::now() + __reltime,\n+\treturn wait_until(__lock, steady_clock::now() + __reltime,\n \t\t\t  std::move(__p));\n       }\n \n@@ -171,10 +183,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return &_M_cond; }\n \n   private:\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+    template<typename _Dur>\n+      cv_status\n+      __wait_until_impl(unique_lock<mutex>& __lock,\n+\t\t\tconst chrono::time_point<steady_clock, _Dur>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tpthread_cond_clockwait(&_M_cond, __lock.mutex()->native_handle(),\n+\t\t\t\t\t CLOCK_MONOTONIC,\n+\t\t\t\t\t &__ts);\n+\n+\treturn (steady_clock::now() < __atime\n+\t\t? cv_status::no_timeout : cv_status::timeout);\n+      }\n+#endif\n+\n     template<typename _Dur>\n       cv_status\n       __wait_until_impl(unique_lock<mutex>& __lock,\n-\t\t\tconst chrono::time_point<__clock_t, _Dur>& __atime)\n+\t\t\tconst chrono::time_point<system_clock, _Dur>& __atime)\n       {\n \tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n \tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n@@ -188,7 +224,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__gthread_cond_timedwait(&_M_cond, __lock.mutex()->native_handle(),\n \t\t\t\t &__ts);\n \n-\treturn (__clock_t::now() < __atime\n+\treturn (system_clock::now() < __atime\n \t\t? cv_status::no_timeout : cv_status::timeout);\n       }\n   };\n@@ -208,7 +244,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Like above, but mutex is not required to have try_lock.\n   class condition_variable_any\n   {\n-    typedef chrono::system_clock\t__clock_t;\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+    using __clock_t = chrono::steady_clock;\n+#else\n+    using __clock_t = chrono::system_clock;\n+#endif\n     condition_variable\t\t\t_M_cond;\n     shared_ptr<mutex>\t\t\t_M_mutex;\n "}]}