{"sha": "617be7ba436bcbf9d7b883968c6b3c011206b56c", "node_id": "C_kwDOANBUbNoAKDYxN2JlN2JhNDM2YmNiZjlkN2I4ODM5NjhjNmIzYzAxMTIwNmI1NmM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-01-25T09:50:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-01-25T09:50:27Z"}, "message": "store-merging: Disable string_concatenate mode if start or end aren't byte aligned [PR108498]\n\nThe first of the following testcases is miscompiled on powerpc64-linux -O2\n-m64 at least, the latter at least on x86_64-linux -m32/-m64.\nSince GCC 11 store-merging has a separate string_concatenation mode which\nturns stores into setting a MEM_REF from a STRING_CST.\nThis mode is triggered if at least one of the to be merged stores\nis a STRING_CST store and either the first store (to earliest address)\nis that STRING_CST store or the first store is 8-bit INTEGER_CST store\nand then there are some rules when to turn that mode off or not merge\nfurther stores into it.\n\nThe problem with these 2 testcases is that the actual implementation\nrelies on start/width of the store to be at byte boundaries, as it\nsimply creates a char array, MEM_REF can be only on byte boundaries\nand the char array too, plus obviously STRING_CST as well.\nBut as can be easily seen in the second testcase, nothing verifies this,\nwhile the first store has to be a STRING_CST (which will be aligned)\nor 8-bit INTEGER_CST, that 8-bit INTEGER_CST store could be a bitfield\nstore, nothing verifies any stores in between whether they actually are\n8-bit and aligned, the only major requirement is that all the stores\nare consecutive.\n\nFor GCC 14 I think we should reconsider this, simply treat STRING_CST\nstores during the merging like INTEGER_CST stores and deal with it only\nduring split_group where we can create multiple parts, this part\nwould be a normal store, this part would be STRING_CST store, this part\nanother normal store etc.  But that is quite a lot of work, the following\npatch just disables the string_concatenate mode if boundaries aren't byte\naligned in the spot where we disable it if it is too short too.\nIf that happens, we'll just try to do the merging using normal 1/2/4/8 etc.\nbyte stores as usually with RMW masking for any bits that shouldn't be\ntouched or punt if we end up with too many stores compared to the original.\n\nNote, an original STRING_CST store will count as one store in that case,\nsomething we might want to reconsider later too (but, after all, CONSTRUCTOR\nstores (aka zeroing) already have the same problem, they can be large and\nexpensive and we still count them as one store).\n\n2023-01-25  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/108498\n\t* gimple-ssa-store-merging.cc (class store_operand_info):\n\tEnd coment with full stop rather than comma.\n\t(split_group): Likewise.\n\t(merged_store_group::apply_stores): Clear string_concatenation if\n\tstart or end aren't on a byte boundary.\n\n\t* gcc.c-torture/execute/pr108498-1.c: New test.\n\t* gcc.c-torture/execute/pr108498-2.c: New test.", "tree": {"sha": "2f60cd3af47c5db5e4276585d1f6c7f29b4cd6c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f60cd3af47c5db5e4276585d1f6c7f29b4cd6c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/617be7ba436bcbf9d7b883968c6b3c011206b56c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617be7ba436bcbf9d7b883968c6b3c011206b56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617be7ba436bcbf9d7b883968c6b3c011206b56c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617be7ba436bcbf9d7b883968c6b3c011206b56c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b851ee9fdf0f3023635f0cb1f7c607b2d6801053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b851ee9fdf0f3023635f0cb1f7c607b2d6801053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b851ee9fdf0f3023635f0cb1f7c607b2d6801053"}], "stats": {"total": 181, "additions": 179, "deletions": 2}, "files": [{"sha": "df7afd2fd78a4502a3606d2de6d8c12bce14e6dc", "filename": "gcc/gimple-ssa-store-merging.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617be7ba436bcbf9d7b883968c6b3c011206b56c/gcc%2Fgimple-ssa-store-merging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617be7ba436bcbf9d7b883968c6b3c011206b56c/gcc%2Fgimple-ssa-store-merging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.cc?ref=617be7ba436bcbf9d7b883968c6b3c011206b56c", "patch": "@@ -1614,7 +1614,7 @@ namespace {\n    then VAL represents the constant and all the other fields are zero, or\n    a memory load, then VAL represents the reference, BASE_ADDR is non-NULL\n    and the other fields also reflect the memory load, or an SSA name, then\n-   VAL represents the SSA name and all the other fields are zero,  */\n+   VAL represents the SSA name and all the other fields are zero.  */\n \n class store_operand_info\n {\n@@ -2309,6 +2309,10 @@ merged_store_group::apply_stores ()\n   if (buf_size <= MOVE_MAX)\n     string_concatenation = false;\n \n+  /* String concatenation only works for byte aligned start and end.  */\n+  if (start % BITS_PER_UNIT != 0 || width % BITS_PER_UNIT != 0)\n+    string_concatenation = false;\n+\n   /* Create a power-of-2-sized buffer for native_encode_expr.  */\n   if (!string_concatenation)\n     buf_size = 1 << ceil_log2 (buf_size);\n@@ -3631,7 +3635,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \n   /* For bswap framework using sets of stores, all the checking has been done\n      earlier in try_coalesce_bswap and the result always needs to be emitted\n-     as a single store.  Likewise for string concatenation,  */\n+     as a single store.  Likewise for string concatenation.  */\n   if (group->stores[0]->rhs_code == LROTATE_EXPR\n       || group->stores[0]->rhs_code == NOP_EXPR\n       || group->string_concatenation)"}, {"sha": "217c1e4ecd2e6cb29c79b12cf67adddaf4f2330a", "filename": "gcc/testsuite/gcc.c-torture/execute/pr108498-1.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617be7ba436bcbf9d7b883968c6b3c011206b56c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108498-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617be7ba436bcbf9d7b883968c6b3c011206b56c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108498-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108498-1.c?ref=617be7ba436bcbf9d7b883968c6b3c011206b56c", "patch": "@@ -0,0 +1,82 @@\n+/* PR tree-optimization/108498 */\n+\n+struct A\n+{\n+  signed char a1;\n+  int a2;\n+};\n+\n+struct B\n+{\n+  struct A b1;\n+  unsigned char b2:1, b3:1, b4:2, b5:1, b6:1, b7[4];\n+};\n+\n+struct C\n+{\n+  unsigned char c1;\n+  char c2;\n+  signed char c3;\n+  unsigned char c4, c5[4], c6:1, c7:1, c8:1, c9:3, c10:1;\n+  struct A c11;\n+  struct B c12[3];\n+};\n+\n+static inline struct C\n+foo (unsigned char a, unsigned b, int c, struct A d,\n+     unsigned e, struct B f, struct B g, struct B h)\n+{\n+  struct C x\n+    = { .c1 = b, .c2 = 0, .c3 = c, .c6 = a, .c4 = e, .c7 = 0,\n+        .c8 = 0, .c9 = 7, .c10 = 0, .c5 = {0, 1, 2, 3}, .c11 = d,\n+        .c12 = {f, g, h} };\n+  return x;\n+}\n+\n+static inline struct A\n+bar (int a, int b)\n+{\n+  struct A x = { .a1 = a, .a2 = b };\n+  return x;\n+}\n+\n+static inline struct B\n+baz (struct A b1)\n+{\n+  struct B x = { .b1 = b1, .b6 = 0, .b5 = 0, .b7 = {0, 1, 2, 3}, .b2 = 0 };\n+  return x;\n+}\n+\n+struct C\n+qux (void)\n+{\n+  const struct B a = baz (bar (0, 0));\n+  struct C b;\n+  struct B c[2];\n+  struct A d = { 0, 1 };\n+  c[0].b1.a1 = 0;\n+  c[0].b1.a2 = 2;\n+  c[1].b1.a1 = 4;\n+  c[1].b1.a2 = 8;\n+  return foo (0, 2, -1, d, 3, c[0], c[1], a);\n+}\n+\n+__attribute__((noipa)) void\n+corge (struct C *x)\n+{\n+  char buf[1024];\n+  __builtin_memset (buf, 0xaa, sizeof (buf));\n+  asm volatile (\"\" : : \"r\" (buf));\n+  __builtin_memset (x, 0x55, sizeof (struct C));\n+  asm volatile (\"\" : : \"r\" (x));\n+}\n+\n+int\n+main ()\n+{\n+  struct C x;\n+  corge (&x);\n+  x = qux ();\n+  if (x.c6 || x.c9 != 7)\n+    __builtin_abort ();\n+}"}, {"sha": "ad930488c33c48d5b2de39c2a562f2be7a97de0b", "filename": "gcc/testsuite/gcc.c-torture/execute/pr108498-2.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617be7ba436bcbf9d7b883968c6b3c011206b56c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108498-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617be7ba436bcbf9d7b883968c6b3c011206b56c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108498-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr108498-2.c?ref=617be7ba436bcbf9d7b883968c6b3c011206b56c", "patch": "@@ -0,0 +1,91 @@\n+/* PR tree-optimization/108498 */\n+\n+struct U { char c[16]; };\n+struct V { char c[16]; };\n+struct S { unsigned int a : 3, b : 8, c : 21; struct U d; unsigned int e; struct V f; unsigned int g : 5, h : 27; };\n+struct T { unsigned int a : 16, b : 8, c : 8; struct U d; unsigned int e; struct V f; unsigned int g : 5, h : 27; };\n+\n+__attribute__((noipa)) void\n+foo (struct S *p)\n+{\n+  p->b = 231;\n+  p->c = 42;\n+  p->d = (struct U) { \"abcdefghijklmno\" };\n+  p->e = 0xdeadbeef;\n+  p->f = (struct V) { \"ABCDEFGHIJKLMNO\" };\n+}\n+\n+__attribute__((noipa)) void\n+bar (struct S *p)\n+{\n+  p->b = 231;\n+  p->c = 42;\n+  p->d = (struct U) { \"abcdefghijklmno\" };\n+  p->e = 0xdeadbeef;\n+  p->f = (struct V) { \"ABCDEFGHIJKLMNO\" };\n+  p->g = 12;\n+}\n+\n+__attribute__((noipa)) void\n+baz (struct T *p)\n+{\n+  p->c = 42;\n+  p->d = (struct U) { \"abcdefghijklmno\" };\n+  p->e = 0xdeadbeef;\n+  p->f = (struct V) { \"ABCDEFGHIJKLMNO\" };\n+  p->g = 12;\n+}\n+\n+int\n+main ()\n+{\n+  if (__CHAR_BIT__ != 8 || __SIZEOF_INT__ != 4)\n+    return 0;\n+  struct S s = {};\n+  struct T t = {};\n+  foo (&s);\n+  if (s.a != 0 || s.b != 231 || s.c != 42\n+      || __builtin_memcmp (&s.d.c, \"abcdefghijklmno\", 16) || s.e != 0xdeadbeef\n+      || __builtin_memcmp (&s.f.c, \"ABCDEFGHIJKLMNO\", 16) || s.g != 0 || s.h != 0)\n+    __builtin_abort ();\n+  __builtin_memset (&s, 0, sizeof (s));\n+  s.a = 7;\n+  s.g = 31;\n+  s.h = (1U << 27) - 1;\n+  foo (&s);\n+  if (s.a != 7 || s.b != 231 || s.c != 42\n+      || __builtin_memcmp (&s.d.c, \"abcdefghijklmno\", 16) || s.e != 0xdeadbeef\n+      || __builtin_memcmp (&s.f.c, \"ABCDEFGHIJKLMNO\", 16) || s.g != 31 || s.h != (1U << 27) - 1)\n+    __builtin_abort ();\n+  __builtin_memset (&s, 0, sizeof (s));\n+  bar (&s);\n+  if (s.a != 0 || s.b != 231 || s.c != 42\n+      || __builtin_memcmp (&s.d.c, \"abcdefghijklmno\", 16) || s.e != 0xdeadbeef\n+      || __builtin_memcmp (&s.f.c, \"ABCDEFGHIJKLMNO\", 16) || s.g != 12 || s.h != 0)\n+    __builtin_abort ();\n+  __builtin_memset (&s, 0, sizeof (s));\n+  s.a = 7;\n+  s.g = 31;\n+  s.h = (1U << 27) - 1;\n+  bar (&s);\n+  if (s.a != 7 || s.b != 231 || s.c != 42\n+      || __builtin_memcmp (&s.d.c, \"abcdefghijklmno\", 16) || s.e != 0xdeadbeef\n+      || __builtin_memcmp (&s.f.c, \"ABCDEFGHIJKLMNO\", 16) || s.g != 12 || s.h != (1U << 27) - 1)\n+    __builtin_abort ();\n+  baz (&t);\n+  if (t.a != 0 || t.b != 0 || t.c != 42\n+      || __builtin_memcmp (&t.d.c, \"abcdefghijklmno\", 16) || t.e != 0xdeadbeef\n+      || __builtin_memcmp (&t.f.c, \"ABCDEFGHIJKLMNO\", 16) || t.g != 12 || t.h != 0)\n+    __builtin_abort ();\n+  __builtin_memset (&s, 0, sizeof (s));\n+  t.a = 7;\n+  t.b = 255;\n+  t.g = 31;\n+  t.h = (1U << 27) - 1;\n+  baz (&t);\n+  if (t.a != 7 || t.b != 255 || t.c != 42\n+      || __builtin_memcmp (&t.d.c, \"abcdefghijklmno\", 16) || t.e != 0xdeadbeef\n+      || __builtin_memcmp (&t.f.c, \"ABCDEFGHIJKLMNO\", 16) || t.g != 12 || t.h != (1U << 27) - 1)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}