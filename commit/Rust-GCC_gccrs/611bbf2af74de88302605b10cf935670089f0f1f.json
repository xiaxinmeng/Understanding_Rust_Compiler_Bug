{"sha": "611bbf2af74de88302605b10cf935670089f0f1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExYmJmMmFmNzRkZTg4MzAyNjA1YjEwY2Y5MzU2NzAwODlmMGYxZg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-06T09:46:58Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-06T09:46:58Z"}, "message": "Don't use CLASS_LIKELY_SPILLED in local-alloc\n\nFrom-SVN: r36197", "tree": {"sha": "4a4d83ca960f72aad7788486bf93b9692d85c584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a4d83ca960f72aad7788486bf93b9692d85c584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/611bbf2af74de88302605b10cf935670089f0f1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611bbf2af74de88302605b10cf935670089f0f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611bbf2af74de88302605b10cf935670089f0f1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611bbf2af74de88302605b10cf935670089f0f1f/comments", "author": null, "committer": null, "parents": [{"sha": "299d838af8eff49c7c1f04db2aad57f14e305515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299d838af8eff49c7c1f04db2aad57f14e305515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299d838af8eff49c7c1f04db2aad57f14e305515"}], "stats": {"total": 29, "additions": 7, "deletions": 22}, "files": [{"sha": "cad52842849612b4becb200a1a62a7fb98067aa7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611bbf2af74de88302605b10cf935670089f0f1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611bbf2af74de88302605b10cf935670089f0f1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=611bbf2af74de88302605b10cf935670089f0f1f", "patch": "@@ -1,5 +1,9 @@\n 2000-09-06  Bernd Schmidt  <bernds@redhat.co.uk>\n-\t\n+\n+\t* local-alloc.c (local_alloc): Ignore CLASS_LIKELY_SPILLED.\n+\t(update_equiv_regs): Likewise, except for the mn10200 kludge.\n+\t(combine_regs): Likewise.\n+\n \t* Makefile.in (cse.o): Depend on $(BASIC_BLOCK_H).\n \t* cse.c: Include \"basic-block.h\".\n \t(struct table_elt): New field REGCOST."}, {"sha": "666faca1705e86a6ad235e07e5f68936b8693725", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611bbf2af74de88302605b10cf935670089f0f1f/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611bbf2af74de88302605b10cf935670089f0f1f/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=611bbf2af74de88302605b10cf935670089f0f1f", "patch": "@@ -349,19 +349,14 @@ local_alloc ()\n \n   /* Determine which pseudo-registers can be allocated by local-alloc.\n      In general, these are the registers used only in a single block and\n-     which only die once.  However, if a register's preferred class has only\n-     a few entries, don't allocate this register here unless it is preferred\n-     or nothing since retry_global_alloc won't be able to move it to\n-     GENERAL_REGS if a reload register of this class is needed.\n+     which only die once.\n \n      We need not be concerned with which block actually uses the register\n      since we will never see it outside that block.  */\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n-      if (REG_BASIC_BLOCK (i) >= 0 && REG_N_DEATHS (i) == 1\n-\t  && (reg_alternate_class (i) == NO_REGS\n-\t      || ! CLASS_LIKELY_SPILLED_P (reg_preferred_class (i))))\n+      if (REG_BASIC_BLOCK (i) >= 0 && REG_N_DEATHS (i) == 1)\n \treg_qty[i] = -2;\n       else\n \treg_qty[i] = -1;\n@@ -789,15 +784,6 @@ update_equiv_regs ()\n \t  note_stores (set, no_equiv, NULL);\n \t  continue;\n \t}\n-      /* Don't handle the equivalence if the source is in a register\n-\t class that's likely to be spilled.  */\n-      if (GET_CODE (src) == REG\n-\t  && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t  && CLASS_LIKELY_SPILLED_P (reg_preferred_class (REGNO (src))))\n-\t{\n-\t  no_equiv (dest, set, NULL);\n-\t  continue;\n-\t}\n \n       note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n@@ -1653,11 +1639,6 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       || ureg == sreg\n       /* Don't try to connect two different hardware registers.  */\n       || (ureg < FIRST_PSEUDO_REGISTER && sreg < FIRST_PSEUDO_REGISTER)\n-      /* Don't use a hard reg that might be spilled.  */\n-      || (ureg < FIRST_PSEUDO_REGISTER\n-\t  && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (ureg)))\n-      || (sreg < FIRST_PSEUDO_REGISTER\n-\t  && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (sreg)))\n       /* Don't connect two different machine modes if they have different\n \t implications as to which registers may be used.  */\n       || !MODES_TIEABLE_P (GET_MODE (usedreg), GET_MODE (setreg)))"}]}