{"sha": "ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U5NGQzNTQ3ZjgxY2MzZGQxMDVmNGEzMzc3ZTcyY2RiZDJiYmQyYw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-07-29T17:09:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-29T17:09:26Z"}, "message": "re PR tree-optimization/36945 (PRE/SCCVN do not handle aggregate function arguments correctly)\n\n2008-07-29  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/36945\n\t* tree-ssa-sccvn.h (copy_reference_ops_from_ref): Declare.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Export.\n\tRecord invariant addresses un-decomposed.\n\t(copy_reference_ops_from_call): Record reference call\n\targuments properly.  Simplify.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): New\n\thelper split out from ...\n\t(create_component_ref_by_pieces): ... here.  Simplify.\n\tPrepare for recursive invocation for call arguments.\n\t(create_expression_by_pieces): Adjust call to\n\tcreate_component_ref_by_pieces.\n\t(compute_avail): Process operand 2 of reference ops.\n\n\t* gcc.dg/tree-ssa/ssa-pre-18.c: New testcase.\n\nFrom-SVN: r138257", "tree": {"sha": "d2185d79e36deb34f5ad3885547df3a1a15064b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2185d79e36deb34f5ad3885547df3a1a15064b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f3a057aa9e5b4f6fbdbee87e8224ca9ea5a6d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3a057aa9e5b4f6fbdbee87e8224ca9ea5a6d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3a057aa9e5b4f6fbdbee87e8224ca9ea5a6d83"}], "stats": {"total": 236, "additions": 127, "deletions": 109}, "files": [{"sha": "9d0388dd5aa9fefafd2d02b55e4f746174240b94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "patch": "@@ -1,3 +1,19 @@\n+2008-07-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36945\n+\t* tree-ssa-sccvn.h (copy_reference_ops_from_ref): Declare.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Export.\n+\tRecord invariant addresses un-decomposed.\n+\t(copy_reference_ops_from_call): Record reference call\n+\targuments properly.  Simplify.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): New\n+\thelper split out from ...\n+\t(create_component_ref_by_pieces): ... here.  Simplify.\n+\tPrepare for recursive invocation for call arguments.\n+\t(create_expression_by_pieces): Adjust call to\n+\tcreate_component_ref_by_pieces.\n+\t(compute_avail): Process operand 2 of reference ops.\n+\n 2008-07-29  Richard Guenther  <rguenther@suse.de>\n \n \t* gimplify.c (gimplify_expr): Clear TREE_SIDE_EFFECTS for"}, {"sha": "79568ddab39709b7e11815dd8d8af1e7d33c7ab0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "patch": "@@ -1,3 +1,8 @@\n+2008-07-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/36945\n+\t* gcc.dg/tree-ssa/ssa-pre-18.c: New testcase.\n+\n 2008-07-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/36852"}, {"sha": "5e92934f052bda61d8ffeab9a6d46b80ccc845df", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-18.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-18.c?ref=ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-details\" } */\n+\n+struct Bar { int a; int b; };\n+struct Foo { int x; struct Bar y; };\n+\n+int __attribute__((const)) foo (struct Bar);\n+\n+int bar (int b)\n+{\n+  struct Foo f;\n+  int c;\n+  while (b--)\n+    {\n+      c = foo(f.y);\n+    }\n+  return c;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Replaced foo \\\\(f.y\\\\)\" \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "c98a18a772c9e57685bb5bea31bf797bb7a27420", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 69, "deletions": 82, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "patch": "@@ -2421,64 +2421,56 @@ static VEC(gimple,heap) *inserted_exprs;\n    to see which expressions need to be put into GC'able memory  */\n static VEC(gimple, heap) *need_creation;\n \n-/* For COMPONENT_REF's and ARRAY_REF's, we can't have any intermediates for the\n-   COMPONENT_REF or INDIRECT_REF or ARRAY_REF portion, because we'd end up with\n-   trying to rename aggregates into ssa form directly, which is a no\n-   no.\n-\n-   Thus, this routine doesn't create temporaries, it just builds a\n-   single access expression for the array, calling\n-   find_or_generate_expression to build the innermost pieces.\n+/* The actual worker for create_component_ref_by_pieces.  */\n \n-   This function is a subroutine of create_expression_by_pieces, and\n-   should not be called on it's own unless you really know what you\n-   are doing.\n-*/\n static tree\n-create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n-\t\t\t\tunsigned int operand,\n-\t\t\t\tgimple_seq *stmts,\n-\t\t\t\tgimple domstmt,\n-\t\t\t\tbool in_call)\n+create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n+\t\t\t\t  unsigned int *operand, gimple_seq *stmts,\n+\t\t\t\t  gimple domstmt)\n {\n   vn_reference_op_t currop = VEC_index (vn_reference_op_s, ref->operands,\n-\t\t\t\t\toperand);\n+\t\t\t\t\t*operand);\n   tree genop;\n+  ++*operand;\n   switch (currop->opcode)\n     {\n     case CALL_EXPR:\n       {\n \ttree folded;\n-\tunsigned int i;\n-\tvn_reference_op_t declop = VEC_index (vn_reference_op_s,\n-\t\t\t\t\t      ref->operands, 1);\n-\tunsigned int nargs = VEC_length (vn_reference_op_s, ref->operands) - 2;\n-\ttree *args = XNEWVEC (tree, nargs);\n-\n-\tfor (i = 0; i < nargs; i++)\n+\tunsigned int nargs = 0;\n+\ttree *args = XNEWVEC (tree, VEC_length (vn_reference_op_s,\n+\t\t\t\t\t\tref->operands) - 1);\n+\twhile (*operand < VEC_length (vn_reference_op_s, ref->operands))\n \t  {\n-\t    args[i] = create_component_ref_by_pieces (block, ref,\n-\t\t\t\t\t\t      operand + 2 + i, stmts,\n-\t\t\t\t\t\t      domstmt, true);\n+\t    args[nargs] = create_component_ref_by_pieces_1 (block, ref,\n+\t\t\t\t\t\t\t    operand, stmts,\n+\t\t\t\t\t\t\t    domstmt);\n+\t    nargs++;\n \t  }\n \tfolded = build_call_array (currop->type,\n-\t\t\t\t   TREE_CODE (declop->op0) == FUNCTION_DECL\n-\t\t\t\t   ? build_fold_addr_expr (declop->op0)\n-\t\t\t\t   : declop->op0,\n+\t\t\t\t   TREE_CODE (currop->op0) == FUNCTION_DECL\n+\t\t\t\t   ? build_fold_addr_expr (currop->op0)\n+\t\t\t\t   : currop->op0,\n \t\t\t\t   nargs, args);\n \tfree (args);\n \treturn folded;\n       }\n       break;\n+    case ADDR_EXPR:\n+      if (currop->op0)\n+\t{\n+\t  gcc_assert (is_gimple_min_invariant (currop->op0));\n+\t  return currop->op0;\n+\t}\n+      /* Fallthrough.  */\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case VIEW_CONVERT_EXPR:\n       {\n \ttree folded;\n-\ttree genop0 = create_component_ref_by_pieces (block, ref,\n-\t\t\t\t\t\t      operand + 1,\n-\t\t\t\t\t\t      stmts, domstmt,\n-\t\t\t\t\t\t      in_call);\n+\ttree genop0 = create_component_ref_by_pieces_1 (block, ref,\n+\t\t\t\t\t\t\toperand,\n+\t\t\t\t\t\t\tstmts, domstmt);\n \tif (!genop0)\n \t  return NULL_TREE;\n \tfolded = fold_build1 (currop->opcode, currop->type,\n@@ -2490,45 +2482,25 @@ create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n     case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n       {\n-\t/* Inside a CALL_EXPR op0 is the actual indirect_ref.  */\n-\tif (in_call)\n-\t  {\n-\t    tree folded;\n-\t    tree op0 = TREE_OPERAND (currop->op0, 0);\n-\t    pre_expr op0expr = get_or_alloc_expr_for (op0);\n-\t    tree genop0 = find_or_generate_expression (block, op0expr, stmts,\n-\t\t\t\t\t\t       domstmt);\n-\t    if (!genop0)\n-\t      return NULL_TREE;\n-\t    folded = fold_build1 (currop->opcode, currop->type,\n-\t\t\t\t  genop0);\n-\t    return folded;\n-\t  }\n-\telse\n-\t  {\n-\n-\t    tree folded;\n-\t    tree genop1 = create_component_ref_by_pieces (block, ref,\n-\t\t\t\t\t\t\t  operand + 1,\n-\t\t\t\t\t\t\t  stmts, domstmt,\n-\t\t\t\t\t\t\t  in_call);\n-\t    if (!genop1)\n-\t      return NULL_TREE;\n-\t    genop1 = fold_convert (build_pointer_type (currop->type),\n-\t\t\t\t   genop1);\n+\ttree folded;\n+\ttree genop1 = create_component_ref_by_pieces_1 (block, ref,\n+\t\t\t\t\t\t\toperand,\n+\t\t\t\t\t\t\tstmts, domstmt);\n+\tif (!genop1)\n+\t  return NULL_TREE;\n+\tgenop1 = fold_convert (build_pointer_type (currop->type),\n+\t\t\t       genop1);\n \n-\t    folded = fold_build1 (currop->opcode, currop->type,\n-\t\t\t\t  genop1);\n-\t    return folded;\n-\t  }\n+\tfolded = fold_build1 (currop->opcode, currop->type,\n+\t\t\t      genop1);\n+\treturn folded;\n       }\n       break;\n     case BIT_FIELD_REF:\n       {\n \ttree folded;\n-\ttree genop0 = create_component_ref_by_pieces (block, ref, operand + 1,\n-\t\t\t\t\t\t      stmts, domstmt,\n-\t\t\t\t\t\t      in_call);\n+\ttree genop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n+\t\t\t\t\t\t\tstmts, domstmt);\n \tpre_expr op1expr = get_or_alloc_expr_for (currop->op0);\n \tpre_expr op2expr = get_or_alloc_expr_for (currop->op1);\n \ttree genop1;\n@@ -2553,17 +2525,14 @@ create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n     case ARRAY_RANGE_REF:\n     case ARRAY_REF:\n       {\n-\tvn_reference_op_t op0expr;\n \ttree genop0;\n \ttree genop1 = currop->op0;\n \tpre_expr op1expr;\n \ttree genop2 = currop->op1;\n \tpre_expr op2expr;\n \ttree genop3;\n-\top0expr = VEC_index (vn_reference_op_s, ref->operands, operand + 1);\n-\tgenop0 = create_component_ref_by_pieces (block, ref, operand + 1,\n-\t\t\t\t\t\t stmts, domstmt,\n-\t\t\t\t\t\t in_call);\n+\tgenop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n+\t\t\t\t\t\t   stmts, domstmt);\n \tif (!genop0)\n \t  return NULL_TREE;\n \top1expr = get_or_alloc_expr_for (genop1);\n@@ -2589,8 +2558,8 @@ create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n \ttree op1;\n \ttree genop2 = currop->op1;\n \tpre_expr op2expr;\n-\top0 = create_component_ref_by_pieces (block, ref, operand + 1,\n-\t\t\t\t\t      stmts, domstmt, in_call);\n+\top0 = create_component_ref_by_pieces_1 (block, ref, operand,\n+\t\t\t\t\t\tstmts, domstmt);\n \tif (!op0)\n \t  return NULL_TREE;\n \t/* op1 should be a FIELD_DECL, which are represented by\n@@ -2626,18 +2595,33 @@ create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n     case CONST_DECL:\n     case RESULT_DECL:\n     case FUNCTION_DECL:\n-      /* For ADDR_EXPR in a CALL_EXPR, op0 is actually the entire\n-\t ADDR_EXPR, not just it's operand.  */\n-    case ADDR_EXPR:\n-      if (currop->opcode == ADDR_EXPR)\n-\tgcc_assert (currop->op0 != NULL);\n       return currop->op0;\n \n     default:\n       gcc_unreachable ();\n     }\n }\n \n+/* For COMPONENT_REF's and ARRAY_REF's, we can't have any intermediates for the\n+   COMPONENT_REF or INDIRECT_REF or ARRAY_REF portion, because we'd end up with\n+   trying to rename aggregates into ssa form directly, which is a no no.\n+\n+   Thus, this routine doesn't create temporaries, it just builds a\n+   single access expression for the array, calling\n+   find_or_generate_expression to build the innermost pieces.\n+\n+   This function is a subroutine of create_expression_by_pieces, and\n+   should not be called on it's own unless you really know what you\n+   are doing.  */\n+\n+static tree\n+create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n+\t\t\t\tgimple_seq *stmts, gimple domstmt)\n+{\n+  unsigned int op = 0;\n+  return create_component_ref_by_pieces_1 (block, ref, &op, stmts, domstmt);\n+}\n+\n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n    complex.\n@@ -2743,8 +2727,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n     case REFERENCE:\n       {\n \tvn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n-\tfolded = create_component_ref_by_pieces (block, ref, 0, stmts,\n-\t\t\t\t\t\t domstmt, false);\n+\tfolded = create_component_ref_by_pieces (block, ref, stmts, domstmt);\n       }\n       break;\n     case NARY:\n@@ -3616,6 +3599,8 @@ compute_avail (void)\n \t\t      add_to_exp_gen (block, vro->op0);\n \t\t    if (vro->op1 && TREE_CODE (vro->op1) == SSA_NAME)\n \t\t      add_to_exp_gen (block, vro->op1);\n+\t\t    if (vro->op2 && TREE_CODE (vro->op2) == SSA_NAME)\n+\t\t      add_to_exp_gen (block, vro->op2);\n \t\t  }\n \t\tresult = (pre_expr) pool_alloc (pre_expr_pool);\n \t\tresult->kind = REFERENCE;\n@@ -3688,6 +3673,8 @@ compute_avail (void)\n \t\t\t    add_to_exp_gen (block, vro->op0);\n \t\t\t  if (vro->op1 && TREE_CODE (vro->op1) == SSA_NAME)\n \t\t\t    add_to_exp_gen (block, vro->op1);\n+\t\t\t  if (vro->op2 && TREE_CODE (vro->op2) == SSA_NAME)\n+\t\t\t    add_to_exp_gen (block, vro->op2);\n \t\t\t}\n \t\t      result = (pre_expr) pool_alloc (pre_expr_pool);\n \t\t      result->kind = REFERENCE;"}, {"sha": "f6492bdafd830bbf3e27060185e927f54ffa0473", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "patch": "@@ -557,7 +557,7 @@ shared_vuses_from_stmt (gimple stmt)\n /* Copy the operations present in load/store REF into RESULT, a vector of\n    vn_reference_op_s's.  */\n \n-static void\n+void\n copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n {\n   if (TREE_CODE (ref) == TARGET_MEM_REF)\n@@ -646,6 +646,13 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \tcase SSA_NAME:\n \t  temp.op0 = ref;\n \t  break;\n+\tcase ADDR_EXPR:\n+\t  if (is_gimple_min_invariant (ref))\n+\t    {\n+\t      temp.op0 = ref;\n+\t      break;\n+\t    }\n+\t  /* Fallthrough.  */\n \t  /* These are only interesting for their operands, their\n \t     existence, and their type.  They will never be the last\n \t     ref in the chain of references (IE they require an\n@@ -654,15 +661,15 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \tcase IMAGPART_EXPR:\n \tcase REALPART_EXPR:\n \tcase VIEW_CONVERT_EXPR:\n-\tcase ADDR_EXPR:\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n-\n \t}\n       VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n \n-      if (REFERENCE_CLASS_P (ref) || TREE_CODE (ref) == ADDR_EXPR)\n+      if (REFERENCE_CLASS_P (ref)\n+\t  || (TREE_CODE (ref) == ADDR_EXPR\n+\t      && !is_gimple_min_invariant (ref)))\n \tref = TREE_OPERAND (ref, 0);\n       else\n \tref = NULL_TREE;\n@@ -677,41 +684,22 @@ copy_reference_ops_from_call (gimple call,\n \t\t\t      VEC(vn_reference_op_s, heap) **result)\n {\n   vn_reference_op_s temp;\n-  tree callfn;\n   unsigned i;\n \n   /* Copy the call_expr opcode, type, function being called, and\n      arguments.  */\n   memset (&temp, 0, sizeof (temp));\n   temp.type = gimple_call_return_type (call);\n   temp.opcode = CALL_EXPR;\n+  temp.op0 = gimple_call_fn (call);\n   VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n \n-  /* FIXME tuples\n-     We make no attempt to simplify the called function because\n-     the typical &FUNCTION_DECL form is also used in function pointer\n-     cases that become constant.  If we simplify the original to\n-     FUNCTION_DECL but not the function pointer case (which can\n-     happen because we have no fold functions that operate on\n-     vn_reference_t), we will claim they are not equivalent.\n-\n-     An example of this behavior can be see if CALL_EXPR_FN below is\n-     replaced with get_callee_fndecl and gcc.dg/tree-ssa/ssa-pre-13.c\n-     is compiled.  */\n-  callfn = gimple_call_fn (call);\n-  temp.type = TREE_TYPE (callfn);\n-  temp.opcode = TREE_CODE (callfn);\n-  temp.op0 = callfn;\n-  VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n-\n+  /* Copy the call arguments.  As they can be references as well,\n+     just chain them together.  */\n   for (i = 0; i < gimple_call_num_args (call); ++i)\n     {\n       tree callarg = gimple_call_arg (call, i);\n-      memset (&temp, 0, sizeof (temp));\n-      temp.type = TREE_TYPE (callarg);\n-      temp.opcode = TREE_CODE (callarg);\n-      temp.op0 = callarg;\n-      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+      copy_reference_ops_from_ref (callarg, result);\n     }\n   return;\n }"}, {"sha": "d648cd9bb94b7a516b3541707b7aa3349fc0e8ea", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=ce94d3547f81cc3dd105f4a3377e72cdbd2bbd2c", "patch": "@@ -174,6 +174,7 @@ vn_nary_op_t vn_nary_op_insert_stmt (gimple, tree);\n vn_nary_op_t vn_nary_op_insert_pieces (unsigned int, enum tree_code,\n \t\t\t\t       tree, tree, tree, tree,\n \t\t\t\t       tree, tree, unsigned int);\n+void copy_reference_ops_from_ref (tree, VEC(vn_reference_op_s, heap) **);\n void copy_reference_ops_from_call (gimple, VEC(vn_reference_op_s, heap) **);\n tree vn_reference_lookup_pieces (VEC (tree, gc) *,\n \t\t\t\t VEC (vn_reference_op_s, heap) *,"}]}