{"sha": "16ad69a19dbd022a4a50118af9f71fad695adeaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhZDY5YTE5ZGJkMDIyYTRhNTAxMThhZjlmNzFmYWQ2OTVhZGVhYQ==", "commit": {"author": {"name": "Jack Reeves", "email": "jackw_reeves@hotmail.com", "date": "2002-07-03T22:25:06Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-07-03T22:25:06Z"}, "message": "re PR libstdc++/3946 (auto_ptr_ref constructor allows dangerous conversion)\n\n2002-07-03  Jack Reeves  <jackw_reeves@hotmail.com>\n            Kenny Simpson  <theonetruekenny@yahoo.com>\n            Phil Edwards  <pme@gcc.gnu.org>\n\n\tPR libstdc++/3946\n\t* testsuite/20_util/auto_ptr.cc (test08):  New test.\n\t* include/std/std_memory.h (auto_ref_ptr):  Make constructor explicit.\n\t(auto_ptr::operator auto_ptr_ref):  Fix typo.\n\tGeneral reformatting and doxygenating of the whole file.\n\nCo-Authored-By: Kenny Simpson <theonetruekenny@yahoo.com>\nCo-Authored-By: Phil Edwards <pme@gcc.gnu.org>\n\nFrom-SVN: r55223", "tree": {"sha": "4b4d1c65ed92465eddeca39b31b0fb0d749d3f6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b4d1c65ed92465eddeca39b31b0fb0d749d3f6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16ad69a19dbd022a4a50118af9f71fad695adeaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ad69a19dbd022a4a50118af9f71fad695adeaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ad69a19dbd022a4a50118af9f71fad695adeaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ad69a19dbd022a4a50118af9f71fad695adeaa/comments", "author": null, "committer": null, "parents": [{"sha": "6f0361e32e24a9482337b4829863128b35c99d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0361e32e24a9482337b4829863128b35c99d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0361e32e24a9482337b4829863128b35c99d0b"}], "stats": {"total": 401, "additions": 297, "deletions": 104}, "files": [{"sha": "adbf06b173db3f63d00ce5cc487c68297fbb886b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad69a19dbd022a4a50118af9f71fad695adeaa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad69a19dbd022a4a50118af9f71fad695adeaa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=16ad69a19dbd022a4a50118af9f71fad695adeaa", "patch": "@@ -1,3 +1,13 @@\n+2002-07-03  Jack Reeves  <jackw_reeves@hotmail.com>\n+            Kenny Simpson  <theonetruekenny@yahoo.com>\n+            Phil Edwards  <pme@gcc.gnu.org>\n+\n+\tPR libstdc++/3946\n+\t* testsuite/20_util/auto_ptr.cc (test08):  New test.\n+\t* include/std/std_memory.h (auto_ref_ptr):  Make constructor explicit.\n+\t(auto_ptr::operator auto_ptr_ref):  Fix typo.\n+\tGeneral reformatting and doxygenating of the whole file.\n+\n 2002-07-03  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/7097"}, {"sha": "5850eb2a0075420b0d5cc3a21ae6fc63ce04b58c", "filename": "libstdc++-v3/include/std/std_memory.h", "status": "modified", "additions": 270, "deletions": 103, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad69a19dbd022a4a50118af9f71fad695adeaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad69a19dbd022a4a50118af9f71fad695adeaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h?ref=16ad69a19dbd022a4a50118af9f71fad695adeaa", "patch": "@@ -58,147 +58,314 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_raw_storage_iter.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n+/**\n+ *  @if maint\n+ *  This is a helper function.  The unused second parameter exists to\n+ *  permit the real get_temporary_buffer to use template parameter deduction.\n+ *\n+ *  XXX This should perhaps use the pool.\n+ *  @endif\n+*/\n+template <typename _Tp>\n+pair<_Tp*, ptrdiff_t>\n+__get_temporary_buffer(ptrdiff_t __len, _Tp*)\n+{\n+  if (__len > ptrdiff_t(INT_MAX / sizeof(_Tp)))\n+    __len = INT_MAX / sizeof(_Tp);\n \n-  /**\n-   *  @if maint\n-   *  This is a helper function.  The unused second parameter exists to\n-   *  permit the real get_temporary_buffer to use template parameter deduction.\n-   *  @endif\n-  */\n-  template <class _Tp>\n-  pair<_Tp*, ptrdiff_t> \n-  __get_temporary_buffer(ptrdiff_t __len, _Tp*)\n-  {\n-    if (__len > ptrdiff_t(INT_MAX / sizeof(_Tp)))\n-      __len = INT_MAX / sizeof(_Tp);\n-\n-    while (__len > 0) {\n-      _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));\n-      if (__tmp != 0)\n-\treturn pair<_Tp*, ptrdiff_t>(__tmp, __len);\n-      __len /= 2;\n-    }\n-\n-    return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);\n+  while (__len > 0) {\n+    _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));\n+    if (__tmp != 0)\n+      return pair<_Tp*, ptrdiff_t>(__tmp, __len);\n+    __len /= 2;\n   }\n \n-  /**\n-   *  @brief This is a mostly-useless wrapper around malloc().\n-   *  @param  len  The number of objects of type Tp.\n-   *  @return   See full description.\n-   *\n-   *  Reinventing the wheel, but this time with prettier spokes!\n-   *\n-   *  This function tries to obtain storage for @c len adjacent Tp objects.\n-   *  The objects themselves are not constructed, of course.  A pair<> is\n-   *  returned containing \"the buffer s address and capacity (in the units of\n-   *  sizeof(Tp)), or a pair of 0 values if no storage can be obtained.\"\n-   *  Note that the capacity obtained may be less than that requested if the\n-   *  memory is unavailable; you should compare len with the .second return\n-   *  value.\n-  */\n-  template <class _Tp>\n-  inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {\n+  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);\n+}\n+\n+/**\n+ *  @brief This is a mostly-useless wrapper around malloc().\n+ *  @param  len  The number of objects of type Tp.\n+ *  @return   See full description.\n+ *\n+ *  Reinventing the wheel, but this time with prettier spokes!\n+ *\n+ *  This function tries to obtain storage for @c len adjacent Tp objects.\n+ *  The objects themselves are not constructed, of course.  A pair<> is\n+ *  returned containing \"the buffer s address and capacity (in the units of\n+ *  sizeof(Tp)), or a pair of 0 values if no storage can be obtained.\"\n+ *  Note that the capacity obtained may be less than that requested if the\n+ *  memory is unavailable; you should compare len with the .second return\n+ *  value.\n+*/\n+template<typename _Tp>\n+  inline pair<_Tp*,ptrdiff_t>\n+  get_temporary_buffer(ptrdiff_t __len)\n+  {\n     return __get_temporary_buffer(__len, (_Tp*) 0);\n   }\n \n-  /**\n-   *  @brief The companion to get_temporary_buffer().\n-   *  @param  p  A buffer previously allocated by get_temporary_buffer.\n-   *  @return   None.\n-   *\n-   *  Frees the memory pointed to by p.\n-   */\n-  template <class _Tp>\n-  void return_temporary_buffer(_Tp* __p) {\n+/**\n+ *  @brief The companion to get_temporary_buffer().\n+ *  @param  p  A buffer previously allocated by get_temporary_buffer.\n+ *  @return   None.\n+ *\n+ *  Frees the memory pointed to by p.\n+ */\n+template<typename _Tp>\n+  void\n+  return_temporary_buffer(_Tp* __p)\n+  {\n     std::free(__p);\n   }\n \n \n-template <class _Tp1>\n+/**\n+ *  A wrapper class to provide auto_ptr with reference semantics.  For\n+ *  example, an auto_ptr can be assigned (or constructed from) the result of\n+ *  a function which returns an auto_ptr by value.\n+ *\n+ *  All the auto_ptr_ref stuff should happen behind the scenes.\n+*/\n+template<typename _Tp1>\n   struct auto_ptr_ref\n {\n    _Tp1* _M_ptr;\n-   auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}\n+\n+   explicit\n+   auto_ptr_ref(_Tp1* __p)\n+   : _M_ptr(__p) {}\n };\n \n+\n /**\n- *  A simple smart pointer providing strict ownership semantics.  (More later.)\n+ *  @brief  A simple smart pointer providing strict ownership semantics.\n+ *\n+ *  The Standard says:\n+ *  <pre>\n+ *  An @c auto_ptr owns the object it holds a pointer to.  Copying an\n+ *  @c auto_ptr copies the pointer and transfers ownership to the destination.\n+ *  If more than one @c auto_ptr owns the same object at the same time the\n+ *  behavior of the program is undefined.\n+ *\n+ *  The uses of @c auto_ptr include providing temporary exception-safety for\n+ *  dynamically allocated memory, passing ownership of dynamically allocated\n+ *  memory to a function, and returning dynamically allocated memory from a\n+ *  function.  @c auto_ptr does not meet the CopyConstructible and Assignable\n+ *  requirements for Standard Library <a href=\"tables.html#65\">container</a>\n+ *  elements and thus instantiating a Standard Library container with an\n+ *  @c auto_ptr results in undefined behavior.\n+ *  </pre>\n+ *  Quoted from [20.4.5]/3.\n+ *\n+ *  Good examples of what can and cannot be done with auto_ptr can be found\n+ *  in the libstdc++ testsuite.\n+ *\n+ *  @if maint\n+ *  _GLIBCPP_RESOLVE_LIB_DEFECTS\n+ *  127.  auto_ptr<> conversion issues\n+ *  These resolutions have all been incorporated.\n+ *  @endif\n */\n-template <class _Tp>\n+template<typename _Tp>\n   class auto_ptr\n {\n private:\n   _Tp* _M_ptr;\n \n public:\n+  /// The pointed-to type.\n   typedef _Tp element_type;\n \n-  explicit auto_ptr(_Tp* __p = 0) throw() : _M_ptr(__p) {}\n-  auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) {}\n+  /**\n+   *  @brief  An %auto_ptr is usually constructed from a raw pointer.\n+   *  @param  p  A pointer (defaults to NULL).\n+   *\n+   *  This object now @e owns the object pointed to by @a p.\n+  */\n+  explicit\n+  auto_ptr(element_type* __p = 0) throw()\n+  : _M_ptr(__p) { }\n \n-  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) throw()\n-    : _M_ptr(__a.release()) {}\n+  /**\n+   *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n+   *  @param  a  Another %auto_ptr of the same type.\n+   *\n+   *  This object now @e owns the object previously owned by @a a, which has\n+   *  given up ownsership.\n+  */\n+  auto_ptr(auto_ptr& __a) throw()\n+  : _M_ptr(__a.release()) { }\n \n-  auto_ptr& operator=(auto_ptr& __a) throw() {\n-    reset(__a.release());\n-    return *this;\n-  }\n+  /**\n+   *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n+   *  @param  a  Another %auto_ptr of a different but related type.\n+   *\n+   *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n+   *\n+   *  This object now @e owns the object previously owned by @a a, which has\n+   *  given up ownsership.\n+  */\n+  template<typename _Tp1>\n+    auto_ptr(auto_ptr<_Tp1>& __a) throw()\n+    : _M_ptr(__a.release()) { }\n \n-  template <class _Tp1>\n-  auto_ptr& operator=(auto_ptr<_Tp1>& __a) throw() {\n-    reset(__a.release());\n-    return *this;\n-  }\n-  \n-  // Note: The C++ standard says there is supposed to be an empty throw\n-  // specification here, but omitting it is standard conforming.  Its \n-  // presence can be detected only if _Tp::~_Tp() throws, but (17.4.3.6/2)\n-  // this is prohibited.\n+  /**\n+   *  @brief  %auto_ptr assignment operator.\n+   *  @param  a  Another %auto_ptr of the same type.\n+   *\n+   *  This object now @e owns the object previously owned by @a a, which has\n+   *  given up ownsership.  The object that this one @e used to own and\n+   *  track has been deleted.\n+  */\n+  auto_ptr&\n+  operator=(auto_ptr& __a) throw()\n+    {\n+      reset(__a.release());\n+      return *this;\n+    }\n+\n+  /**\n+   *  @brief  %auto_ptr assignment operator.\n+   *  @param  a  Another %auto_ptr of a different but related type.\n+   *\n+   *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n+   *\n+   *  This object now @e owns the object previously owned by @a a, which has\n+   *  given up ownsership.  The object that this one @e used to own and\n+   *  track has been deleted.\n+  */\n+  template <typename _Tp1>\n+    auto_ptr&\n+    operator=(auto_ptr<_Tp1>& __a) throw()\n+    {\n+      reset(__a.release());\n+      return *this;\n+    }\n+\n+  /**\n+   *  When the %auto_ptr goes out of scope, the object it owns is deleted.\n+   *  If it no longer owns anything (i.e., @c get() is @c NULL), then this\n+   *  has no effect.\n+   *\n+   *  @if maint\n+   *  The C++ standard says there is supposed to be an empty throw\n+   *  specification here, but omitting it is standard conforming.  Its\n+   *  presence can be detected only if _Tp::~_Tp() throws, but this is\n+   *  prohibited.  [17.4.3.6]/2\n+   *  @end maint\n+  */\n   ~auto_ptr() { delete _M_ptr; }\n- \n-  _Tp& operator*() const throw() {\n-    return *_M_ptr;\n-  }\n-  _Tp* operator->() const throw() {\n-    return _M_ptr;\n-  }\n-  _Tp* get() const throw() {\n-    return _M_ptr;\n-  }\n-  _Tp* release() throw() {\n-    _Tp* __tmp = _M_ptr;\n-    _M_ptr = 0;\n-    return __tmp;\n-  }\n-  void reset(_Tp* __p = 0) throw() {\n-    if (__p != _M_ptr) {\n-      delete _M_ptr;\n-      _M_ptr = __p;\n-    }    \n-  }\n \n-public:\n-  auto_ptr(auto_ptr_ref<_Tp> __ref) throw()\n+  /**\n+   *  @brief  Smart pointer dereferencing.\n+   *\n+   *  If this %auto_ptr no longer owns anything, then this operation will\n+   *  crash.  (For a smart pointer, \"no longer owns anything\" is the same as\n+   *  being a null pointer, and you know what happens when you dereference\n+   *  one of those...)\n+  */\n+  element_type&\n+  operator*() const throw() { return *_M_ptr; }\n+\n+  /**\n+   *  @brief  Smart pointer dereferencing.\n+   *\n+   *  This returns the pointer itself, which the language then will\n+   *  automatically cause to be dereferenced.\n+  */\n+  element_type*\n+  operator->() const throw() { return _M_ptr; }\n+\n+  /**\n+   *  @brief  Bypassing the smart pointer.\n+   *  @return  The raw pointer being managed.\n+   *\n+   *  You can get a copy of the pointer that this object owns, for\n+   *  situations such as passing to a function which only accepts a raw\n+   *  pointer.\n+   *\n+   *  @note  This %auto_ptr still owns the memory.\n+  */\n+  element_type*\n+  get() const throw() { return _M_ptr; }\n+\n+  /**\n+   *  @brief  Bypassing the smart pointer.\n+   *  @return  The raw pointer being managed.\n+   *\n+   *  You can get a copy of the pointer that this object owns, for\n+   *  situations such as passing to a function which only accepts a raw\n+   *  pointer.\n+   *\n+   *  @note  This %auto_ptr no longer owns the memory.  When this object\n+   *  goes out of scope, nothing will happen.\n+  */\n+  element_type*\n+  release() throw()\n+    {\n+      element_type* __tmp = _M_ptr;\n+      _M_ptr = 0;\n+      return __tmp;\n+    }\n+\n+  /**\n+   *  @brief  Forcibly deletes the managed object.\n+   *  @param  p  A pointer (defaults to NULL).\n+   *\n+   *  This object now @e owns the object pointed to by @a p.  The previous\n+   *  object has been deleted.\n+  */\n+  void\n+  reset(element_type* __p = 0) throw()\n+    {\n+      if (__p != _M_ptr)\n+        {\n+          delete _M_ptr;\n+          _M_ptr = __p;\n+        }\n+    }\n+\n+  /** @{\n+   *  @brief  Automatic conversions\n+   *\n+   *  These operations convert an %auto_ptr into and from an auto_ptr_ref\n+   *  automatically as needed.  This allows constructs such as\n+   *  @code\n+   *    auto_ptr<Derived>  func_returning_auto_ptr(.....);\n+   *    ...\n+   *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);\n+   *  @endcode\n+  */\n+  auto_ptr(auto_ptr_ref<element_type> __ref) throw()\n     : _M_ptr(__ref._M_ptr) {}\n \n-  auto_ptr& operator=(auto_ptr_ref<_Tp> __ref) throw() {\n-    if (__ref._M_ptr != this->get()) {\n-      delete _M_ptr;\n-      _M_ptr = __ref._M_ptr;\n+  auto_ptr&\n+  operator=(auto_ptr_ref<element_type> __ref) throw()\n+    {\n+      if (__ref._M_ptr != this->get())\n+        {\n+          delete _M_ptr;\n+          _M_ptr = __ref._M_ptr;\n+        }\n+      return *this;\n     }\n-    return *this;\n-  }\n \n-  template <class _Tp1> operator auto_ptr_ref<_Tp1>() throw() \n-    { return auto_ptr_ref<_Tp>(this->release()); }\n-  template <class _Tp1> operator auto_ptr<_Tp1>() throw()\n-    { return auto_ptr<_Tp1>(this->release()); }\n+  template<typename _Tp1>\n+    operator auto_ptr_ref<_Tp1>() throw()\n+      { return auto_ptr_ref<_Tp1>(this->release()); }\n+\n+  template<typename _Tp1>\n+    operator auto_ptr<_Tp1>() throw()\n+      { return auto_ptr<_Tp1>(this->release()); }\n+  /** @}  */\n };\n \n } // namespace std\n \n #endif /* _CPP_MEMORY */\n-"}, {"sha": "cf0d37bfb784ee15acdf0398a5f8f1165e4ddf07", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr.cc", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad69a19dbd022a4a50118af9f71fad695adeaa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad69a19dbd022a4a50118af9f71fad695adeaa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc?ref=16ad69a19dbd022a4a50118af9f71fad695adeaa", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2000 Free Software Foundation\n+// Copyright (C) 2000, 2002 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -276,6 +276,21 @@ test07()\n   return 0;\n }\n \n+\n+// http://gcc.gnu.org/ml/libstdc++/2002-07/msg00024.html\n+struct Base{};\n+struct Derived : public Base {};\n+std::auto_ptr<Derived> conversiontest08()\n+  { return std::auto_ptr<Derived>(new Derived); }\n+\n+void\n+test08()\n+{\n+  std::auto_ptr<Base> ptr;\n+  ptr = conversiontest08();\n+}\n+\n+\n int \n main()\n {\n@@ -286,6 +301,7 @@ main()\n   test05();\n   test06();\n   test07();\n+  test08();\n \n   return 0;\n }"}]}