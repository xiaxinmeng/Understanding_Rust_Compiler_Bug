{"sha": "5012919d0bd344ac1888e8e531072f0ccbe24d2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAxMjkxOWQwYmQzNDRhYzE4ODhlOGU1MzEwNzJmMGNjYmUyNGQyYw==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2016-11-16T17:17:00Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2016-11-16T17:17:00Z"}, "message": "nvptx backend prerequisites for OpenMP offloading\n\ngcc/\n\t* config/nvptx/mkoffload.c (main): Check that either OpenACC or OpenMP\n\tis selected.  Pass -mgomp to offload compiler in OpenMP case.\n\t* config/nvptx/nvptx-protos.h (nvptx_shuffle_kind): Move enum\n\tdeclaration from nvptx.c.\n\t(nvptx_gen_shuffle): Declare.\n\t(nvptx_output_set_softstack): Declare.\n\t* config/nvptx/nvptx.c (nvptx_shuffle_kind): Move to nvptx-protos.h.\n\t(need_softstack_decl): New variable.\n\t(need_unisimt_decl): New variable.\n\t(diagnose_openacc_conflict): New.  Use it...\n\t(nvptx_option_override): ...here.  Handle TARGET_GOMP.\n\t(nvptx_encode_section_info): Handle \"shared\" attribute.\n\t(write_as_kernel): Restrict to OpenACC target regions.\n\t(init_softstack_frame): New.\n\t(nvptx_init_unisimt_predicate): New.\n\t(write_omp_entry): New.  Use it...\n\t(nvptx_declare_function_name): ...here to emit OpenMP target region\n\tentrypoints.  Handle TARGET_SOFT_STACK.  Call\n\tnvptx_init_unisimt_predicate.\n\t(nvptx_output_set_softstack): New.\n\t(nvptx_get_drap_rtx): Return %argp as the DRAP if needed.\n\t(nvptx_gen_shuffle): Export.\n\t(nvptx_output_call_insn): Handle COND_EXEC patterns.  Emit instruction\n\tpredicate.\n\t(nvptx_print_operand): Fix handling of instruction predicates.\n\t(nvptx_get_unisimt_master): New helper function.\n\t(nvptx_get_unisimt_predicate): Ditto.\n\t(nvptx_call_insn_is_syscall_p): Ditto.\n\t(nvptx_unisimt_handle_set): Ditto.\n\t(nvptx_reorg_uniform_simt): New.  Transform code for -muniform-simt.\n\t(nvptx_reorg): Call nvptx_reorg_uniform_simt.\n\t(nvptx_handle_shared_attribute): New.  Use it...\n\t(nvptx_attribute_table): ... here (new entry).\n\t(nvptx_record_offload_symbol): Handle NULL attributes.\n\t(nvptx_file_end): Handle need_softstack_decl and need_unisimt_decl.\n\t(nvptx_simt_vf): New.\n\t(TARGET_SIMT_VF): Define.\n\t* config/nvptx/nvptx.h (TARGET_CPU_CPP_BUILTINS): Define\n\t__nvptx_softstack or __nvptx_unisimt__ when -msoft-stack, or resp.\n\t-muniform-simt option is active.\n\t(STACK_SIZE_MODE): Define.\n\t(FIXED_REGISTERS): Adjust.\n\t(SOFTSTACK_SLOT_REGNUM): New.\n\t(SOFTSTACK_PREV_REGNUM): New.\n\t(REGISTER_NAMES): Adjust.\n\t(struct machine_function): New fields.\n\t* config/nvptx/nvptx.md (UNSPEC_SET_SOFTSTACK): New.\n\t(UNSPEC_VOTE_BALLOT): Ditto.\n\t(UNSPEC_LANEID): Ditto.\n\t(UNSPECV_NOUNROLL): Ditto.\n\t(atomic): New attribute.\n\t(predicable): New attribute.  Generate predicated forms via\n\tdefine_cond_exec.\n\t(br_true): Mark as not predicable.\n\t(br_false): Ditto.\n\t(br_true_uni): Ditto.\n\t(br_false_uni): Ditto.\n\t(return): Ditto.\n\t(trap_if_true): Ditto.\n\t(trap_if_false): Ditto.\n\t(nvptx_fork): Ditto.\n\t(nvptx_forked): Ditto.\n\t(nvptx_joining): Ditto.\n\t(nvptx_join): Ditto.\n\t(nvptx_barsync): Ditto.\n\t(epilogue): Emit stack restore if TARGET_SOFT_STACK.\n\t(allocate_stack): Implement for TARGET_SOFT_STACK.  Remove unused code.\n\t(allocate_stack_<mode>): Remove unused pattern.\n\t(set_softstack_insn): New pattern.\n\t(restore_stack_block): Handle for TARGET_SOFT_STACK.\n\t(nvptx_vote_ballot): New pattern.\n\t(omp_simt_lane): Ditto.\n\t(omp_simt_last_lane): Ditto.\n\t(omp_simt_ordered): Ditto.\n\t(omp_simt_vote_any): Ditto.\n\t(omp_simt_xchg_bfly): Ditto.\n\t(omp_simt_xchg_idx): Ditto.\n\t(nvptx_nounroll): Ditto.\n\t(atomic_compare_and_swap<mode>_1): Mark with atomic attribute.\n\t(atomic_exchange<mode>): Ditto.\n\t(atomic_fetch_add<mode>): Ditto.\n\t(atomic_fetch_addsf): Ditto.\n\t(atomic_fetch_<logic><mode>): Ditto.\n\t* config/nvptx/nvptx.opt: (msoft-stack): New option.\n\t(muniform-simt): Ditto.\n\t(mgomp): Ditto.\n\t* config/nvptx/t-nvptx (MULTILIB_OPTIONS): New.\n\t* doc/extend.texi (Nvidia PTX Variable Attributes): New section.\n\t* doc/invoke.texi (msoft-stack): Document.\n\t(muniform-simt): Document\n\t(mgomp): Document.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in: (TARGET_SIMT_VF): New hook.\n\t* target.def: Define it.\n\t* target-insns.def (omp_simt_lane): New.\n\t(omp_simt_last_lane): New.\n\t(omp_simt_ordered): New.\n\t(omp_simt_vote_any): New.\n\t(omp_simt_xchg_bfly): New.\n\t(omp_simt_xchg_idx): New.\n\nlibgcc/\n\t* config/nvptx/crt0.c (__main): Setup __nvptx_stacks and __nvptx_uni.\n\t* config/nvptx/mgomp.c: New file.\n\t* config/nvptx/t-nvptx: Add mgomp.c\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_alloca): Use a\n\tcompile test.\n\t* gcc.target/nvptx/softstack.c: New test.\n\t* gcc.target/nvptx/decl-shared.c: New test.\n\t* gcc.target/nvptx/decl-shared-init.c: New test.\n\nFrom-SVN: r242503", "tree": {"sha": "9db609d99ee4957a92a3ad468eb36d855e6c1bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9db609d99ee4957a92a3ad468eb36d855e6c1bc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5012919d0bd344ac1888e8e531072f0ccbe24d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5012919d0bd344ac1888e8e531072f0ccbe24d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5012919d0bd344ac1888e8e531072f0ccbe24d2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5012919d0bd344ac1888e8e531072f0ccbe24d2c/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2fe2aba3cd7c2daf16c545bc7fa34481157bfcaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe2aba3cd7c2daf16c545bc7fa34481157bfcaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe2aba3cd7c2daf16c545bc7fa34481157bfcaf"}], "stats": {"total": 938, "additions": 870, "deletions": 68}, "files": [{"sha": "be573a3124b919ef8732a8c68b2545e8e5037ba0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -1,3 +1,106 @@\n+2016-11-16  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* config/nvptx/mkoffload.c (main): Check that either OpenACC or OpenMP\n+\tis selected.  Pass -mgomp to offload compiler in OpenMP case.\n+\t* config/nvptx/nvptx-protos.h (nvptx_shuffle_kind): Move enum\n+\tdeclaration from nvptx.c.\n+\t(nvptx_gen_shuffle): Declare.\n+\t(nvptx_output_set_softstack): Declare.\n+\t* config/nvptx/nvptx.c (nvptx_shuffle_kind): Move to nvptx-protos.h.\n+\t(need_softstack_decl): New variable.\n+\t(need_unisimt_decl): New variable.\n+\t(diagnose_openacc_conflict): New.  Use it...\n+\t(nvptx_option_override): ...here.  Handle TARGET_GOMP.\n+\t(nvptx_encode_section_info): Handle \"shared\" attribute.\n+\t(write_as_kernel): Restrict to OpenACC target regions.\n+\t(init_softstack_frame): New.\n+\t(nvptx_init_unisimt_predicate): New.\n+\t(write_omp_entry): New.  Use it...\n+\t(nvptx_declare_function_name): ...here to emit OpenMP target region\n+\tentrypoints.  Handle TARGET_SOFT_STACK.  Call\n+\tnvptx_init_unisimt_predicate.\n+\t(nvptx_output_set_softstack): New.\n+\t(nvptx_get_drap_rtx): Return %argp as the DRAP if needed.\n+\t(nvptx_gen_shuffle): Export.\n+\t(nvptx_output_call_insn): Handle COND_EXEC patterns.  Emit instruction\n+\tpredicate.\n+\t(nvptx_print_operand): Fix handling of instruction predicates.\n+\t(nvptx_get_unisimt_master): New helper function.\n+\t(nvptx_get_unisimt_predicate): Ditto.\n+\t(nvptx_call_insn_is_syscall_p): Ditto.\n+\t(nvptx_unisimt_handle_set): Ditto.\n+\t(nvptx_reorg_uniform_simt): New.  Transform code for -muniform-simt.\n+\t(nvptx_reorg): Call nvptx_reorg_uniform_simt.\n+\t(nvptx_handle_shared_attribute): New.  Use it...\n+\t(nvptx_attribute_table): ... here (new entry).\n+\t(nvptx_record_offload_symbol): Handle NULL attributes.\n+\t(nvptx_file_end): Handle need_softstack_decl and need_unisimt_decl.\n+\t(nvptx_simt_vf): New.\n+\t(TARGET_SIMT_VF): Define.\n+\t* config/nvptx/nvptx.h (TARGET_CPU_CPP_BUILTINS): Define\n+\t__nvptx_softstack or __nvptx_unisimt__ when -msoft-stack, or resp.\n+\t-muniform-simt option is active.\n+\t(STACK_SIZE_MODE): Define.\n+\t(FIXED_REGISTERS): Adjust.\n+\t(SOFTSTACK_SLOT_REGNUM): New.\n+\t(SOFTSTACK_PREV_REGNUM): New.\n+\t(REGISTER_NAMES): Adjust.\n+\t(struct machine_function): New fields.\n+\t* config/nvptx/nvptx.md (UNSPEC_SET_SOFTSTACK): New.\n+\t(UNSPEC_VOTE_BALLOT): Ditto.\n+\t(UNSPEC_LANEID): Ditto.\n+\t(UNSPECV_NOUNROLL): Ditto.\n+\t(atomic): New attribute.\n+\t(predicable): New attribute.  Generate predicated forms via\n+\tdefine_cond_exec.\n+\t(br_true): Mark as not predicable.\n+\t(br_false): Ditto.\n+\t(br_true_uni): Ditto.\n+\t(br_false_uni): Ditto.\n+\t(return): Ditto.\n+\t(trap_if_true): Ditto.\n+\t(trap_if_false): Ditto.\n+\t(nvptx_fork): Ditto.\n+\t(nvptx_forked): Ditto.\n+\t(nvptx_joining): Ditto.\n+\t(nvptx_join): Ditto.\n+\t(nvptx_barsync): Ditto.\n+\t(epilogue): Emit stack restore if TARGET_SOFT_STACK.\n+\t(allocate_stack): Implement for TARGET_SOFT_STACK.  Remove unused code.\n+\t(allocate_stack_<mode>): Remove unused pattern.\n+\t(set_softstack_insn): New pattern.\n+\t(restore_stack_block): Handle for TARGET_SOFT_STACK.\n+\t(nvptx_vote_ballot): New pattern.\n+\t(omp_simt_lane): Ditto.\n+\t(omp_simt_last_lane): Ditto.\n+\t(omp_simt_ordered): Ditto.\n+\t(omp_simt_vote_any): Ditto.\n+\t(omp_simt_xchg_bfly): Ditto.\n+\t(omp_simt_xchg_idx): Ditto.\n+\t(nvptx_nounroll): Ditto.\n+\t(atomic_compare_and_swap<mode>_1): Mark with atomic attribute.\n+\t(atomic_exchange<mode>): Ditto.\n+\t(atomic_fetch_add<mode>): Ditto.\n+\t(atomic_fetch_addsf): Ditto.\n+\t(atomic_fetch_<logic><mode>): Ditto.\n+\t* config/nvptx/nvptx.opt: (msoft-stack): New option.\n+\t(muniform-simt): Ditto.\n+\t(mgomp): Ditto.\n+\t* config/nvptx/t-nvptx (MULTILIB_OPTIONS): New.\n+\t* doc/extend.texi (Nvidia PTX Variable Attributes): New section.\n+\t* doc/invoke.texi (msoft-stack): Document.\n+\t(muniform-simt): Document\n+\t(mgomp): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in: (TARGET_SIMT_VF): New hook.\n+\t* target.def: Define it.\n+\t* target-insns.def (omp_simt_lane): New.\n+\t(omp_simt_last_lane): New.\n+\t(omp_simt_ordered): New.\n+\t(omp_simt_vote_any): New.\n+\t(omp_simt_xchg_bfly): New.\n+\t(omp_simt_xchg_idx): New.\n+\n 2016-11-16  Maciej W. Rozycki  <macro@imgtec.com>\n \n \t* config/mips/mips-protos.h (mips_set_text_contents_type): New"}, {"sha": "d876c7bc162eab64b63e7807f1b6d9ff336b6b63", "filename": "gcc/config/nvptx/mkoffload.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -460,6 +460,7 @@ main (int argc, char **argv)\n \n   /* Scan the argument vector.  */\n   bool fopenmp = false;\n+  bool fopenacc = false;\n   for (int i = 1; i < argc; i++)\n     {\n #define STR \"-foffload-abi=\"\n@@ -476,11 +477,15 @@ main (int argc, char **argv)\n #undef STR\n       else if (strcmp (argv[i], \"-fopenmp\") == 0)\n \tfopenmp = true;\n+      else if (strcmp (argv[i], \"-fopenacc\") == 0)\n+\tfopenacc = true;\n       else if (strcmp (argv[i], \"-save-temps\") == 0)\n \tsave_temps = true;\n       else if (strcmp (argv[i], \"-v\") == 0)\n \tverbose = true;\n     }\n+  if (!(fopenacc ^ fopenmp))\n+    fatal_error (input_location, \"either -fopenacc or -fopenmp must be set\");\n \n   struct obstack argv_obstack;\n   obstack_init (&argv_obstack);\n@@ -501,6 +506,8 @@ main (int argc, char **argv)\n     default:\n       gcc_unreachable ();\n     }\n+  if (fopenmp)\n+    obstack_ptr_grow (&argv_obstack, \"-mgomp\");\n \n   for (int ix = 1; ix != argc; ix++)\n     {"}, {"sha": "331ec0af6bfb9d15ec9f155c693a78629282c309", "filename": "gcc/config/nvptx/nvptx-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -21,6 +21,16 @@\n #ifndef GCC_NVPTX_PROTOS_H\n #define GCC_NVPTX_PROTOS_H\n \n+/* The kind of shuffe instruction.  */\n+enum nvptx_shuffle_kind\n+{\n+  SHUFFLE_UP,\n+  SHUFFLE_DOWN,\n+  SHUFFLE_BFLY,\n+  SHUFFLE_IDX,\n+  SHUFFLE_MAX\n+};\n+\n extern void nvptx_declare_function_name (FILE *, const char *, const_tree decl);\n extern void nvptx_declare_object_name (FILE *file, const char *name,\n \t\t\t\t       const_tree decl);\n@@ -36,10 +46,12 @@ extern void nvptx_register_pragmas (void);\n extern void nvptx_expand_oacc_fork (unsigned);\n extern void nvptx_expand_oacc_join (unsigned);\n extern void nvptx_expand_call (rtx, rtx);\n+extern rtx nvptx_gen_shuffle (rtx, rtx, rtx, nvptx_shuffle_kind);\n extern rtx nvptx_expand_compare (rtx);\n extern const char *nvptx_ptx_type_from_mode (machine_mode, bool);\n extern const char *nvptx_output_mov_insn (rtx, rtx);\n extern const char *nvptx_output_call_insn (rtx_insn *, rtx, rtx);\n extern const char *nvptx_output_return (void);\n+extern const char *nvptx_output_set_softstack (unsigned);\n #endif\n #endif"}, {"sha": "405a91b2604c8fe1271f29940a7cf7e3b1652a2a", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 382, "deletions": 36, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -72,16 +72,6 @@\n /* This file should be included last.  */\n #include \"target-def.h\"\n \n-/* The kind of shuffe instruction.  */\n-enum nvptx_shuffle_kind\n-{\n-  SHUFFLE_UP,\n-  SHUFFLE_DOWN,\n-  SHUFFLE_BFLY,\n-  SHUFFLE_IDX,\n-  SHUFFLE_MAX\n-};\n-\n /* The various PTX memory areas an object might reside in.  */\n enum nvptx_data_area\n {\n@@ -141,6 +131,12 @@ static GTY(()) rtx worker_red_sym;\n /* Global lock variable, needed for 128bit worker & gang reductions.  */\n static GTY(()) tree global_lock_var;\n \n+/* True if any function references __nvptx_stacks.  */\n+static bool need_softstack_decl;\n+\n+/* True if any function references __nvptx_uni.  */\n+static bool need_unisimt_decl;\n+\n /* Allocate a new, cleared machine_function structure.  */\n \n static struct machine_function *\n@@ -151,6 +147,16 @@ nvptx_init_machine_status (void)\n   return p;\n }\n \n+/* Issue a diagnostic when option OPTNAME is enabled (as indicated by OPTVAL)\n+   and -fopenacc is also enabled.  */\n+\n+static void\n+diagnose_openacc_conflict (bool optval, const char *optname)\n+{\n+  if (flag_openacc && optval)\n+    error (\"option %s is not supported together with -fopenacc\", optname);\n+}\n+\n /* Implement TARGET_OPTION_OVERRIDE.  */\n \n static void\n@@ -188,6 +194,13 @@ nvptx_option_override (void)\n   worker_red_sym = gen_rtx_SYMBOL_REF (Pmode, \"__worker_red\");\n   SET_SYMBOL_DATA_AREA (worker_red_sym, DATA_AREA_SHARED);\n   worker_red_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n+\n+  diagnose_openacc_conflict (TARGET_GOMP, \"-mgomp\");\n+  diagnose_openacc_conflict (TARGET_SOFT_STACK, \"-msoft-stack\");\n+  diagnose_openacc_conflict (TARGET_UNIFORM_SIMT, \"-muniform-simt\");\n+\n+  if (TARGET_GOMP)\n+    target_flags |= MASK_SOFT_STACK | MASK_UNIFORM_SIMT;\n }\n \n /* Return a ptx type for MODE.  If PROMOTE, then use .u32 for QImode to\n@@ -238,9 +251,17 @@ nvptx_encode_section_info (tree decl, rtx rtl, int first)\n       if (TREE_CONSTANT (decl))\n \tarea = DATA_AREA_CONST;\n       else if (TREE_CODE (decl) == VAR_DECL)\n-\t/* TODO: This would be a good place to check for a .shared or\n-\t   other section name.  */\n-\tarea = TREE_READONLY (decl) ? DATA_AREA_CONST : DATA_AREA_GLOBAL;\n+\t{\n+\t  if (lookup_attribute (\"shared\", DECL_ATTRIBUTES (decl)))\n+\t    {\n+\t      area = DATA_AREA_SHARED;\n+\t      if (DECL_INITIAL (decl))\n+\t\terror (\"static initialization of variable %q+D in %<.shared%>\"\n+\t\t       \" memory is not supported\", decl);\n+\t    }\n+\t  else\n+\t    area = TREE_READONLY (decl) ? DATA_AREA_CONST : DATA_AREA_GLOBAL;\n+\t}\n \n       SET_SYMBOL_DATA_AREA (XEXP (rtl, 0), area);\n     }\n@@ -718,7 +739,10 @@ static bool\n write_as_kernel (tree attrs)\n {\n   return (lookup_attribute (\"kernel\", attrs) != NULL_TREE\n-\t  || lookup_attribute (\"omp target entrypoint\", attrs) != NULL_TREE);\n+\t  || (lookup_attribute (\"omp target entrypoint\", attrs) != NULL_TREE\n+\t      && lookup_attribute (\"oacc function\", attrs) != NULL_TREE));\n+  /* For OpenMP target regions, the corresponding kernel entry is emitted from\n+     write_omp_entry as a separate function.  */\n }\n \n /* Emit a linker marker for a function decl or defn.  */\n@@ -973,6 +997,67 @@ init_frame (FILE  *file, int regno, unsigned align, unsigned size)\n \t   POINTER_SIZE, reg_names[regno], reg_names[regno]);\n }\n \n+/* Emit soft stack frame setup sequence.  */\n+\n+static void\n+init_softstack_frame (FILE *file, unsigned alignment, HOST_WIDE_INT size)\n+{\n+  /* Maintain 64-bit stack alignment.  */\n+  unsigned keep_align = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+  size = ROUND_UP (size, keep_align);\n+  int bits = POINTER_SIZE;\n+  const char *reg_stack = reg_names[STACK_POINTER_REGNUM];\n+  const char *reg_frame = reg_names[FRAME_POINTER_REGNUM];\n+  const char *reg_sspslot = reg_names[SOFTSTACK_SLOT_REGNUM];\n+  const char *reg_sspprev = reg_names[SOFTSTACK_PREV_REGNUM];\n+  fprintf (file, \"\\t.reg.u%d %s;\\n\", bits, reg_stack);\n+  fprintf (file, \"\\t.reg.u%d %s;\\n\", bits, reg_frame);\n+  fprintf (file, \"\\t.reg.u%d %s;\\n\", bits, reg_sspslot);\n+  fprintf (file, \"\\t.reg.u%d %s;\\n\", bits, reg_sspprev);\n+  fprintf (file, \"\\t{\\n\");\n+  fprintf (file, \"\\t\\t.reg.u32 %%fstmp0;\\n\");\n+  fprintf (file, \"\\t\\t.reg.u%d %%fstmp1;\\n\", bits);\n+  fprintf (file, \"\\t\\t.reg.u%d %%fstmp2;\\n\", bits);\n+  fprintf (file, \"\\t\\tmov.u32 %%fstmp0, %%tid.y;\\n\");\n+  fprintf (file, \"\\t\\tmul%s.u32 %%fstmp1, %%fstmp0, %d;\\n\",\n+\t   bits == 64 ? \".wide\" : \".lo\", bits / 8);\n+  fprintf (file, \"\\t\\tmov.u%d %%fstmp2, __nvptx_stacks;\\n\", bits);\n+\n+  /* Initialize %sspslot = &__nvptx_stacks[tid.y].  */\n+  fprintf (file, \"\\t\\tadd.u%d %s, %%fstmp2, %%fstmp1;\\n\", bits, reg_sspslot);\n+\n+  /* Initialize %sspprev = __nvptx_stacks[tid.y].  */\n+  fprintf (file, \"\\t\\tld.shared.u%d %s, [%s];\\n\",\n+\t   bits, reg_sspprev, reg_sspslot);\n+\n+  /* Initialize %frame = %sspprev - size.  */\n+  fprintf (file, \"\\t\\tsub.u%d %s, %s, \" HOST_WIDE_INT_PRINT_DEC \";\\n\",\n+\t   bits, reg_frame, reg_sspprev, size);\n+\n+  /* Apply alignment, if larger than 64.  */\n+  if (alignment > keep_align)\n+    fprintf (file, \"\\t\\tand.b%d %s, %s, %d;\\n\",\n+\t     bits, reg_frame, reg_frame, -alignment);\n+\n+  size = crtl->outgoing_args_size;\n+  gcc_assert (size % keep_align == 0);\n+\n+  /* Initialize %stack.  */\n+  fprintf (file, \"\\t\\tsub.u%d %s, %s, \" HOST_WIDE_INT_PRINT_DEC \";\\n\",\n+\t   bits, reg_stack, reg_frame, size);\n+\n+  /* Usually 'crtl->is_leaf' is computed during register allocator\n+     initialization, which is not done on NVPTX.  Compute it now.  */\n+  gcc_assert (!crtl->is_leaf);\n+  crtl->is_leaf = leaf_function_p ();\n+  if (!crtl->is_leaf)\n+    fprintf (file, \"\\t\\tst.shared.u%d [%s], %s;\\n\",\n+\t     bits, reg_sspslot, reg_stack);\n+  fprintf (file, \"\\t}\\n\");\n+  cfun->machine->has_softstack = true;\n+  need_softstack_decl = true;\n+}\n+\n /* Emit code to initialize the REGNO predicate register to indicate\n    whether we are not lane zero on the NAME axis.  */\n \n@@ -986,6 +1071,97 @@ nvptx_init_axis_predicate (FILE *file, int regno, const char *name)\n   fprintf (file, \"\\t}\\n\");\n }\n \n+/* Emit code to initialize predicate and master lane index registers for\n+   -muniform-simt code generation variant.  */\n+\n+static void\n+nvptx_init_unisimt_predicate (FILE *file)\n+{\n+  int bits = POINTER_SIZE;\n+  int master = REGNO (cfun->machine->unisimt_master);\n+  int pred = REGNO (cfun->machine->unisimt_predicate);\n+  fprintf (file, \"\\t{\\n\");\n+  fprintf (file, \"\\t\\t.reg.u32 %%ustmp0;\\n\");\n+  fprintf (file, \"\\t\\t.reg.u%d %%ustmp1;\\n\", bits);\n+  fprintf (file, \"\\t\\t.reg.u%d %%ustmp2;\\n\", bits);\n+  fprintf (file, \"\\t\\tmov.u32 %%ustmp0, %%tid.y;\\n\");\n+  fprintf (file, \"\\t\\tmul%s.u32 %%ustmp1, %%ustmp0, 4;\\n\",\n+\t   bits == 64 ? \".wide\" : \".lo\");\n+  fprintf (file, \"\\t\\tmov.u%d %%ustmp2, __nvptx_uni;\\n\", bits);\n+  fprintf (file, \"\\t\\tadd.u%d %%ustmp2, %%ustmp2, %%ustmp1;\\n\", bits);\n+  fprintf (file, \"\\t\\tld.shared.u32 %%r%d, [%%ustmp2];\\n\", master);\n+  fprintf (file, \"\\t\\tmov.u32 %%ustmp0, %%tid.x;\\n\");\n+  /* Compute 'master lane index' as 'tid.x & __nvptx_uni[tid.y]'.  */\n+  fprintf (file, \"\\t\\tand.b32 %%r%d, %%r%d, %%ustmp0;\\n\", master, master);\n+  /* Compute predicate as 'tid.x == master'.  */\n+  fprintf (file, \"\\t\\tsetp.eq.u32 %%r%d, %%r%d, %%ustmp0;\\n\", pred, master);\n+  fprintf (file, \"\\t}\\n\");\n+  need_unisimt_decl = true;\n+}\n+\n+/* Emit kernel NAME for function ORIG outlined for an OpenMP 'target' region:\n+\n+   extern void gomp_nvptx_main (void (*fn)(void*), void *fnarg);\n+   void __attribute__((kernel)) NAME (void *arg, char *stack, size_t stacksize)\n+   {\n+     __nvptx_stacks[tid.y] = stack + stacksize * (ctaid.x * ntid.y + tid.y + 1);\n+     __nvptx_uni[tid.y] = 0;\n+     gomp_nvptx_main (ORIG, arg);\n+   }\n+   ORIG itself should not be emitted as a PTX .entry function.  */\n+\n+static void\n+write_omp_entry (FILE *file, const char *name, const char *orig)\n+{\n+  static bool gomp_nvptx_main_declared;\n+  if (!gomp_nvptx_main_declared)\n+    {\n+      gomp_nvptx_main_declared = true;\n+      write_fn_marker (func_decls, false, true, \"gomp_nvptx_main\");\n+      func_decls << \".extern .func gomp_nvptx_main (.param.u\" << POINTER_SIZE\n+        << \" %in_ar1, .param.u\" << POINTER_SIZE << \" %in_ar2);\\n\";\n+    }\n+#define ENTRY_TEMPLATE(PS, PS_BYTES, MAD_PS_32) \"\\\n+ (.param.u\" PS \" %arg, .param.u\" PS \" %stack, .param.u\" PS \" %sz)\\n\\\n+{\\n\\\n+\t.reg.u32 %r<3>;\\n\\\n+\t.reg.u\" PS \" %R<4>;\\n\\\n+\tmov.u32 %r0, %tid.y;\\n\\\n+\tmov.u32 %r1, %ntid.y;\\n\\\n+\tmov.u32 %r2, %ctaid.x;\\n\\\n+\tcvt.u\" PS \".u32 %R1, %r0;\\n\\\n+\t\" MAD_PS_32 \" %R1, %r1, %r2, %R1;\\n\\\n+\tmov.u\" PS \" %R0, __nvptx_stacks;\\n\\\n+\t\" MAD_PS_32 \" %R0, %r0, \" PS_BYTES \", %R0;\\n\\\n+\tld.param.u\" PS \" %R2, [%stack];\\n\\\n+\tld.param.u\" PS \" %R3, [%sz];\\n\\\n+\tadd.u\" PS \" %R2, %R2, %R3;\\n\\\n+\tmad.lo.u\" PS \" %R2, %R1, %R3, %R2;\\n\\\n+\tst.shared.u\" PS \" [%R0], %R2;\\n\\\n+\tmov.u\" PS \" %R0, __nvptx_uni;\\n\\\n+\t\" MAD_PS_32 \" %R0, %r0, 4, %R0;\\n\\\n+\tmov.u32 %r0, 0;\\n\\\n+\tst.shared.u32 [%R0], %r0;\\n\\\n+\tmov.u\" PS \" %R0, \\0;\\n\\\n+\tld.param.u\" PS \" %R1, [%arg];\\n\\\n+\t{\\n\\\n+\t\t.param.u\" PS \" %P<2>;\\n\\\n+\t\tst.param.u\" PS \" [%P0], %R0;\\n\\\n+\t\tst.param.u\" PS \" [%P1], %R1;\\n\\\n+\t\tcall.uni gomp_nvptx_main, (%P0, %P1);\\n\\\n+\t}\\n\\\n+\tret.uni;\\n\\\n+}\\n\"\n+  static const char entry64[] = ENTRY_TEMPLATE (\"64\", \"8\", \"mad.wide.u32\");\n+  static const char entry32[] = ENTRY_TEMPLATE (\"32\", \"4\", \"mad.lo.u32  \");\n+#undef ENTRY_TEMPLATE\n+  const char *entry_1 = TARGET_ABI64 ? entry64 : entry32;\n+  /* Position ENTRY_2 after the embedded nul using strlen of the prefix.  */\n+  const char *entry_2 = entry_1 + strlen (entry64) + 1;\n+  fprintf (file, \".visible .entry %s%s%s%s\", name, entry_1, orig, entry_2);\n+  need_softstack_decl = need_unisimt_decl = true;\n+}\n+\n /* Implement ASM_DECLARE_FUNCTION_NAME.  Writes the start of a ptx\n    function, including local var decls and copies from the arguments to\n    local regs.  */\n@@ -997,6 +1173,14 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   tree result_type = TREE_TYPE (fntype);\n   int argno = 0;\n \n+  if (lookup_attribute (\"omp target entrypoint\", DECL_ATTRIBUTES (decl))\n+      && !lookup_attribute (\"oacc function\", DECL_ATTRIBUTES (decl)))\n+    {\n+      char *buf = (char *) alloca (strlen (name) + sizeof (\"$impl\"));\n+      sprintf (buf, \"%s$impl\", name);\n+      write_omp_entry (file, name, buf);\n+      name = buf;\n+    }\n   /* We construct the initial part of the function into a string\n      stream, in order to share the prototype writing code.  */\n   std::stringstream s;\n@@ -1034,19 +1218,24 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \n   fprintf (file, \"%s\", s.str().c_str());\n \n-  /* Declare a local var for outgoing varargs.  */\n-  if (cfun->machine->has_varadic)\n-    init_frame (file, STACK_POINTER_REGNUM,\n-\t\tUNITS_PER_WORD, crtl->outgoing_args_size);\n-\n-  /* Declare a local variable for the frame.  Force its size to be\n-     DImode-compatible.  */\n   HOST_WIDE_INT sz = get_frame_size ();\n-  if (sz || cfun->machine->has_chain)\n-    init_frame (file, FRAME_POINTER_REGNUM,\n-\t\tcrtl->stack_alignment_needed / BITS_PER_UNIT,\n-\t\t(sz + GET_MODE_SIZE (DImode) - 1)\n-\t\t& ~(HOST_WIDE_INT)(GET_MODE_SIZE (DImode) - 1));\n+  bool need_frameptr = sz || cfun->machine->has_chain;\n+  int alignment = crtl->stack_alignment_needed / BITS_PER_UNIT;\n+  if (!TARGET_SOFT_STACK)\n+    {\n+      /* Declare a local var for outgoing varargs.  */\n+      if (cfun->machine->has_varadic)\n+\tinit_frame (file, STACK_POINTER_REGNUM,\n+\t\t    UNITS_PER_WORD, crtl->outgoing_args_size);\n+\n+      /* Declare a local variable for the frame.  Force its size to be\n+\t DImode-compatible.  */\n+      if (need_frameptr)\n+\tinit_frame (file, FRAME_POINTER_REGNUM, alignment,\n+\t\t    ROUND_UP (sz, GET_MODE_SIZE (DImode)));\n+    }\n+  else if (need_frameptr || cfun->machine->has_varadic || cfun->calls_alloca)\n+    init_softstack_frame (file, alignment, sz);\n \n   /* Declare the pseudos we have as ptx registers.  */\n   int maxregs = max_reg_num ();\n@@ -1072,8 +1261,25 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   if (cfun->machine->axis_predicate[1])\n     nvptx_init_axis_predicate (file,\n \t\t\t       REGNO (cfun->machine->axis_predicate[1]), \"x\");\n+  if (cfun->machine->unisimt_predicate)\n+    nvptx_init_unisimt_predicate (file);\n }\n \n+/* Output instruction that sets soft stack pointer in shared memory to the\n+   value in register given by SRC_REGNO.  */\n+\n+const char *\n+nvptx_output_set_softstack (unsigned src_regno)\n+{\n+  if (cfun->machine->has_softstack && !crtl->is_leaf)\n+    {\n+      fprintf (asm_out_file, \"\\tst.shared.u%d\\t[%s], \",\n+\t       POINTER_SIZE, reg_names[SOFTSTACK_SLOT_REGNUM]);\n+      output_reg (asm_out_file, src_regno, VOIDmode);\n+      fprintf (asm_out_file, \";\\n\");\n+    }\n+  return \"\";\n+}\n /* Output a return instruction.  Also copy the return value to its outgoing\n    location.  */\n \n@@ -1113,6 +1319,8 @@ nvptx_function_ok_for_sibcall (tree, tree)\n static rtx\n nvptx_get_drap_rtx (void)\n {\n+  if (TARGET_SOFT_STACK && stack_realign_drap)\n+    return arg_pointer_rtx;\n   return NULL_RTX;\n }\n \n@@ -1311,7 +1519,7 @@ nvptx_gen_pack (rtx dst, rtx src0, rtx src1)\n /* Generate an instruction or sequence to broadcast register REG\n    across the vectors of a single warp.  */\n \n-static rtx\n+rtx\n nvptx_gen_shuffle (rtx dst, rtx src, rtx idx, nvptx_shuffle_kind kind)\n {\n   rtx res;\n@@ -1833,6 +2041,8 @@ nvptx_output_mov_insn (rtx dst, rtx src)\n   return \"%.\\tcvt%t0%t1\\t%0, %1;\";\n }\n \n+static void nvptx_print_operand (FILE *, rtx, int);\n+\n /* Output INSN, which is a call to CALLEE with result RESULT.  For ptx, this\n    involves writing .param declarations and in/out copies into them.  For\n    indirect calls, also write the .callprototype.  */\n@@ -1844,6 +2054,8 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n   static int labelno;\n   bool needs_tgt = register_operand (callee, Pmode);\n   rtx pat = PATTERN (insn);\n+  if (GET_CODE (pat) == COND_EXEC)\n+    pat = COND_EXEC_CODE (pat);\n   int arg_end = XVECLEN (pat, 0);\n   tree decl = NULL_TREE;\n \n@@ -1888,6 +2100,8 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n       fprintf (asm_out_file, \";\\n\");\n     }\n \n+  /* The '.' stands for the call's predicate, if any.  */\n+  nvptx_print_operand (asm_out_file, NULL_RTX, '.');\n   fprintf (asm_out_file, \"\\t\\tcall \");\n   if (result != NULL_RTX)\n     fprintf (asm_out_file, \"(%s_in), \", reg_names[NVPTX_RETURN_REGNUM]);\n@@ -1951,8 +2165,6 @@ nvptx_print_operand_punct_valid_p (unsigned char c)\n   return c == '.' || c== '#';\n }\n \n-static void nvptx_print_operand (FILE *, rtx, int);\n-\n /* Subroutine of nvptx_print_operand; used to print a memory reference X to FILE.  */\n \n static void\n@@ -2013,12 +2225,10 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n       x = current_insn_predicate;\n       if (x)\n \t{\n-\t  unsigned int regno = REGNO (XEXP (x, 0));\n-\t  fputs (\"[\", file);\n+\t  fputs (\"@\", file);\n \t  if (GET_CODE (x) == EQ)\n \t    fputs (\"!\", file);\n-\t  fputs (reg_names [regno], file);\n-\t  fputs (\"]\", file);\n+\t  output_reg (file, REGNO (XEXP (x, 0)), VOIDmode);\n \t}\n       return;\n     }\n@@ -2313,6 +2523,89 @@ nvptx_reorg_subreg (void)\n     }\n }\n \n+/* Return a SImode \"master lane index\" register for uniform-simt, allocating on\n+   first use.  */\n+\n+static rtx\n+nvptx_get_unisimt_master ()\n+{\n+  rtx &master = cfun->machine->unisimt_master;\n+  return master ? master : master = gen_reg_rtx (SImode);\n+}\n+\n+/* Return a BImode \"predicate\" register for uniform-simt, similar to above.  */\n+\n+static rtx\n+nvptx_get_unisimt_predicate ()\n+{\n+  rtx &pred = cfun->machine->unisimt_predicate;\n+  return pred ? pred : pred = gen_reg_rtx (BImode);\n+}\n+\n+/* Return true if given call insn references one of the functions provided by\n+   the CUDA runtime: malloc, free, vprintf.  */\n+\n+static bool\n+nvptx_call_insn_is_syscall_p (rtx_insn *insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  gcc_checking_assert (GET_CODE (pat) == PARALLEL);\n+  pat = XVECEXP (pat, 0, 0);\n+  if (GET_CODE (pat) == SET)\n+    pat = SET_SRC (pat);\n+  gcc_checking_assert (GET_CODE (pat) == CALL\n+\t\t       && GET_CODE (XEXP (pat, 0)) == MEM);\n+  rtx addr = XEXP (XEXP (pat, 0), 0);\n+  if (GET_CODE (addr) != SYMBOL_REF)\n+    return false;\n+  const char *name = XSTR (addr, 0);\n+  /* Ordinary malloc/free are redirected to __nvptx_{malloc,free), so only the\n+     references with forced assembler name refer to PTX syscalls.  For vprintf,\n+     accept both normal and forced-assembler-name references.  */\n+  return (!strcmp (name, \"vprintf\") || !strcmp (name, \"*vprintf\")\n+\t  || !strcmp (name, \"*malloc\")\n+\t  || !strcmp (name, \"*free\"));\n+}\n+\n+/* If SET subexpression of INSN sets a register, emit a shuffle instruction to\n+   propagate its value from lane MASTER to current lane.  */\n+\n+static void\n+nvptx_unisimt_handle_set (rtx set, rtx_insn *insn, rtx master)\n+{\n+  rtx reg;\n+  if (GET_CODE (set) == SET && REG_P (reg = SET_DEST (set)))\n+    emit_insn_after (nvptx_gen_shuffle (reg, reg, master, SHUFFLE_IDX), insn);\n+}\n+\n+/* Adjust code for uniform-simt code generation variant by making atomics and\n+   \"syscalls\" conditionally executed, and inserting shuffle-based propagation\n+   for registers being set.  */\n+\n+static void\n+nvptx_reorg_uniform_simt ()\n+{\n+  rtx_insn *insn, *next;\n+\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (!(CALL_P (insn) && nvptx_call_insn_is_syscall_p (insn))\n+\t  && !(NONJUMP_INSN_P (insn)\n+\t       && GET_CODE (PATTERN (insn)) == PARALLEL\n+\t       && get_attr_atomic (insn)))\n+\tcontinue;\n+      rtx pat = PATTERN (insn);\n+      rtx master = nvptx_get_unisimt_master ();\n+      for (int i = 0; i < XVECLEN (pat, 0); i++)\n+\tnvptx_unisimt_handle_set (XVECEXP (pat, 0, i), insn, master);\n+      rtx pred = nvptx_get_unisimt_predicate ();\n+      pred = gen_rtx_NE (BImode, pred, const0_rtx);\n+      pat = gen_rtx_COND_EXEC (VOIDmode, pred, pat);\n+      validate_change (insn, &PATTERN (insn), pat, false);\n+    }\n+}\n+\n /* Loop structure of the function.  The entire function is described as\n    a NULL loop.  */\n \n@@ -3829,6 +4122,9 @@ nvptx_reorg (void)\n   /* Replace subregs.  */\n   nvptx_reorg_subreg ();\n \n+  if (TARGET_UNIFORM_SIMT)\n+    nvptx_reorg_uniform_simt ();\n+\n   regstat_free_n_sets_and_refs ();\n \n   df_finish_pass (true);\n@@ -3857,12 +4153,36 @@ nvptx_handle_kernel_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   return NULL_TREE;\n }\n \n+/* Handle a \"shared\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+nvptx_handle_shared_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    {\n+      error (\"%qE attribute only applies to variables\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (!(TREE_PUBLIC (decl) || TREE_STATIC (decl)))\n+    {\n+      error (\"%qE attribute not allowed with auto storage class\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Table of valid machine attributes.  */\n static const struct attribute_spec nvptx_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n   { \"kernel\", 0, 0, true, false,  false, nvptx_handle_kernel_attribute, false },\n+  { \"shared\", 0, 0, true, false,  false, nvptx_handle_shared_attribute, false },\n   { NULL, 0, 0, false, false, false, NULL, false }\n };\n \f\n@@ -3924,13 +4244,13 @@ nvptx_record_offload_symbol (tree decl)\n     case FUNCTION_DECL:\n       {\n \ttree attr = get_oacc_fn_attrib (decl);\n-\ttree dims = TREE_VALUE (attr);\n-\tunsigned ix;\n+\t/* OpenMP offloading does not set this attribute.  */\n+\ttree dims = attr ? TREE_VALUE (attr) : NULL_TREE;\n \n \tfprintf (asm_out_file, \"//:FUNC_MAP \\\"%s\\\"\",\n \t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n \n-\tfor (ix = 0; ix != GOMP_DIM_MAX; ix++, dims = TREE_CHAIN (dims))\n+\tfor (; dims; dims = TREE_CHAIN (dims))\n \t  {\n \t    int size = TREE_INT_CST_LOW (TREE_VALUE (dims));\n \n@@ -3991,6 +4311,21 @@ nvptx_file_end (void)\n   if (worker_red_size)\n     write_worker_buffer (asm_out_file, worker_red_sym,\n \t\t\t worker_red_align, worker_red_size);\n+\n+  if (need_softstack_decl)\n+    {\n+      write_var_marker (asm_out_file, false, true, \"__nvptx_stacks\");\n+      /* 32 is the maximum number of warps in a block.  Even though it's an\n+         external declaration, emit the array size explicitly; otherwise, it\n+         may fail at PTX JIT time if the definition is later in link order.  */\n+      fprintf (asm_out_file, \".extern .shared .u%d __nvptx_stacks[32];\\n\",\n+\t       POINTER_SIZE);\n+    }\n+  if (need_unisimt_decl)\n+    {\n+      write_var_marker (asm_out_file, false, true, \"__nvptx_uni\");\n+      fprintf (asm_out_file, \".extern .shared .u32 __nvptx_uni[32];\\n\");\n+    }\n }\n \n /* Expander for the shuffle builtins.  */\n@@ -4176,6 +4511,14 @@ nvptx_expand_builtin (tree exp, rtx target, rtx ARG_UNUSED (subtarget),\n #define PTX_WORKER_LENGTH 32\n #define PTX_GANG_DEFAULT  0 /* Defer to runtime.  */\n \n+/* Implement TARGET_SIMT_VF target hook: number of threads in a warp.  */\n+\n+static int\n+nvptx_simt_vf ()\n+{\n+  return PTX_VECTOR_LENGTH;\n+}\n+\n /* Validate compute dimensions of an OpenACC offload or routine, fill\n    in non-unity defaults.  FN_LEVEL indicates the level at which a\n    routine might spawn a loop.  It is negative for non-routines.  If\n@@ -4944,6 +5287,9 @@ nvptx_goacc_reduction (gcall *call)\n #undef  TARGET_BUILTIN_DECL\n #define TARGET_BUILTIN_DECL nvptx_builtin_decl\n \n+#undef TARGET_SIMT_VF\n+#define TARGET_SIMT_VF nvptx_simt_vf\n+\n #undef TARGET_GOACC_VALIDATE_DIMS\n #define TARGET_GOACC_VALIDATE_DIMS nvptx_goacc_validate_dims\n "}, {"sha": "1702178eeb97dbb06c25072c20b6616e33c98fdd", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -31,6 +31,10 @@\n       builtin_assert (\"machine=nvptx\");\t\t\\\n       builtin_assert (\"cpu=nvptx\");\t\t\\\n       builtin_define (\"__nvptx__\");\t\t\\\n+      if (TARGET_SOFT_STACK)\t\t\t\\\n+        builtin_define (\"__nvptx_softstack__\");\t\\\n+      if (TARGET_UNIFORM_SIMT)\t\t\t\\\n+        builtin_define (\"__nvptx_unisimt__\");\t\\\n     } while (0)\n \n /* Avoid the default in ../../gcc.c, which adds \"-pthread\", which is not\n@@ -79,13 +83,14 @@\n \n #define POINTER_SIZE (TARGET_ABI64 ? 64 : 32)\n #define Pmode (TARGET_ABI64 ? DImode : SImode)\n+#define STACK_SIZE_MODE Pmode\n \n /* Registers.  Since ptx is a virtual target, we just define a few\n    hard registers for special purposes and leave pseudos unallocated.\n    We have to have some available hard registers, to keep gcc setup\n    happy.  */\n #define FIRST_PSEUDO_REGISTER 16\n-#define FIXED_REGISTERS\t    { 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n+#define FIXED_REGISTERS\t    { 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n #define CALL_USED_REGISTERS { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n \n #define HARD_REGNO_NREGS(REG, MODE)\t\t\\\n@@ -133,10 +138,17 @@ enum reg_class             {  NO_REGS,    ALL_REGS,\tLIM_REG_CLASSES };\n #define FRAME_POINTER_REGNUM 2\n #define ARG_POINTER_REGNUM 3\n #define STATIC_CHAIN_REGNUM 4\n+/* This register points to the shared memory location with the current warp's\n+   soft stack pointer (__nvptx_stacks[tid.y]).  */\n+#define SOFTSTACK_SLOT_REGNUM 5\n+/* This register is used to save the previous value of the soft stack pointer\n+   in the prologue and restore it when returning.  */\n+#define SOFTSTACK_PREV_REGNUM 6\n \n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    \"%value\", \"%stack\", \"%frame\", \"%args\", \"%chain\", \"%hr5\", \"%hr6\", \"%hr7\", \\\n+    \"%value\", \"%stack\", \"%frame\", \"%args\",                              \\\n+    \"%chain\", \"%sspslot\", \"%sspprev\", \"%hr7\",                           \\\n     \"%hr8\", \"%hr9\", \"%hr10\", \"%hr11\", \"%hr12\", \"%hr13\", \"%hr14\", \"%hr15\" \\\n   }\n \n@@ -200,10 +212,13 @@ struct GTY(()) machine_function\n   bool is_varadic;  /* This call is varadic  */\n   bool has_varadic;  /* Current function has a varadic call.  */\n   bool has_chain; /* Current function has outgoing static chain.  */\n+  bool has_softstack; /* Current function has a soft stack frame.  */\n   int num_args;\t/* Number of args of current call.  */\n   int return_mode; /* Return mode of current fn.\n \t\t      (machine_mode not defined yet.) */\n   rtx axis_predicate[2]; /* Neutering predicates.  */\n+  rtx unisimt_master; /* 'Master lane index' for -muniform-simt.  */\n+  rtx unisimt_predicate; /* Predicate for -muniform-simt.  */\n };\n #endif\n \f"}, {"sha": "91d11290860dacf36a7a92bbf5ce1e9eaf6b83a6", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 163, "deletions": 28, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -36,10 +36,16 @@\n \n    UNSPEC_ALLOCA\n \n+   UNSPEC_SET_SOFTSTACK\n+\n    UNSPEC_DIM_SIZE\n \n    UNSPEC_BIT_CONV\n \n+   UNSPEC_VOTE_BALLOT\n+\n+   UNSPEC_LANEID\n+\n    UNSPEC_SHUFFLE\n    UNSPEC_BR_UNIFIED\n ])\n@@ -55,11 +61,16 @@\n    UNSPECV_FORKED\n    UNSPECV_JOINING\n    UNSPECV_JOIN\n+\n+   UNSPECV_NOUNROLL\n ])\n \n (define_attr \"subregs_ok\" \"false,true\"\n   (const_string \"false\"))\n \n+(define_attr \"atomic\" \"false,true\"\n+  (const_string \"false\"))\n+\n ;; The nvptx operand predicates, in general, don't permit subregs and\n ;; only literal constants, which differ from the generic ones, which\n ;; permit subregs and symbolc constants (as appropriate)\n@@ -124,6 +135,17 @@\n   return true;\n })\n \n+(define_attr \"predicable\" \"false,true\"\n+  (const_string \"true\"))\n+\n+(define_cond_exec\n+  [(match_operator 0 \"predicate_operator\"\n+      [(match_operand:BI 1 \"nvptx_register_operand\" \"\")\n+       (match_operand:BI 2 \"const0_operand\" \"\")])]\n+  \"\"\n+  \"\"\n+  )\n+\n (define_constraint \"P0\"\n   \"An integer with the value 0.\"\n   (and (match_code \"const_int\")\n@@ -509,7 +531,8 @@\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"%j0\\\\tbra\\\\t%l1;\")\n+  \"%j0\\\\tbra\\\\t%l1;\"\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_insn \"br_false\"\n   [(set (pc)\n@@ -518,7 +541,8 @@\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"%J0\\\\tbra\\\\t%l1;\")\n+  \"%J0\\\\tbra\\\\t%l1;\"\n+  [(set_attr \"predicable\" \"false\")])\n \n ;; unified conditional branch\n (define_insn \"br_true_uni\"\n@@ -527,15 +551,17 @@\n \t\t       UNSPEC_BR_UNIFIED) (const_int 0))\n         (label_ref (match_operand 1 \"\" \"\")) (pc)))]\n   \"\"\n-  \"%j0\\\\tbra.uni\\\\t%l1;\")\n+  \"%j0\\\\tbra.uni\\\\t%l1;\"\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_insn \"br_false_uni\"\n   [(set (pc) (if_then_else\n \t(eq (unspec:BI [(match_operand:BI 0 \"nvptx_register_operand\" \"R\")]\n \t\t       UNSPEC_BR_UNIFIED) (const_int 0))\n         (label_ref (match_operand 1 \"\" \"\")) (pc)))]\n   \"\"\n-  \"%J0\\\\tbra.uni\\\\t%l1;\")\n+  \"%J0\\\\tbra.uni\\\\t%l1;\"\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_expand \"cbranch<mode>4\"\n   [(set (pc)\n@@ -938,12 +964,16 @@\n   \"\"\n {\n   return nvptx_output_return ();\n-})\n+}\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_expand \"epilogue\"\n   [(clobber (const_int 0))]\n   \"\"\n {\n+  if (TARGET_SOFT_STACK)\n+    emit_insn (gen_set_softstack_insn (gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t    SOFTSTACK_PREV_REGNUM)));\n   emit_jump_insn (gen_return ());\n   DONE;\n })\n@@ -972,31 +1002,40 @@\n    (match_operand 1 \"nvptx_register_operand\")]\n   \"\"\n {\n+  if (TARGET_SOFT_STACK)\n+    {\n+      emit_move_insn (stack_pointer_rtx,\n+\t\t      gen_rtx_MINUS (Pmode, stack_pointer_rtx, operands[1]));\n+      emit_insn (gen_set_softstack_insn (stack_pointer_rtx));\n+      emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n+      DONE;\n+    }\n   /* The ptx documentation specifies an alloca intrinsic (for 32 bit\n      only)  but notes it is not implemented.  The assembler emits a\n      confused error message.  Issue a blunt one now instead.  */\n   sorry (\"target cannot support alloca.\");\n   emit_insn (gen_nop ());\n   DONE;\n-  if (TARGET_ABI64)\n-    emit_insn (gen_allocate_stack_di (operands[0], operands[1]));\n-  else\n-    emit_insn (gen_allocate_stack_si (operands[0], operands[1]));\n-  DONE;\n })\n \n-(define_insn \"allocate_stack_<mode>\"\n-  [(set (match_operand:P 0 \"nvptx_register_operand\" \"=R\")\n-        (unspec:P [(match_operand:P 1 \"nvptx_register_operand\" \"R\")]\n-                   UNSPEC_ALLOCA))]\n-  \"\"\n-  \"%.\\\\tcall (%0), %%alloca, (%1);\")\n+(define_insn \"set_softstack_insn\"\n+  [(unspec [(match_operand 0 \"nvptx_register_operand\" \"R\")]\n+\t   UNSPEC_SET_SOFTSTACK)]\n+  \"TARGET_SOFT_STACK\"\n+{\n+  return nvptx_output_set_softstack (REGNO (operands[0]));\n+})\n \n (define_expand \"restore_stack_block\"\n   [(match_operand 0 \"register_operand\" \"\")\n    (match_operand 1 \"register_operand\" \"\")]\n   \"\"\n {\n+  if (TARGET_SOFT_STACK)\n+    {\n+      emit_move_insn (operands[0], operands[1]);\n+      emit_insn (gen_set_softstack_insn (operands[0]));\n+    }\n   DONE;\n })\n \n@@ -1018,14 +1057,16 @@\n \t\t(const_int 0))\n \t    (const_int 0))]\n   \"\"\n-  \"%j0 trap;\")\n+  \"%j0 trap;\"\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_insn \"trap_if_false\"\n   [(trap_if (eq (match_operand:BI 0 \"nvptx_register_operand\" \"R\")\n \t\t(const_int 0))\n \t    (const_int 0))]\n   \"\"\n-  \"%J0 trap;\")\n+  \"%J0 trap;\"\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_expand \"ctrap<mode>4\"\n   [(trap_if (match_operator 0 \"nvptx_comparison_operator\"\n@@ -1074,28 +1115,28 @@\n \t\t       UNSPECV_FORK)]\n   \"\"\n   \"// fork %0;\"\n-)\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_insn \"nvptx_forked\"\n   [(unspec_volatile:SI [(match_operand:SI 0 \"const_int_operand\" \"\")]\n \t\t       UNSPECV_FORKED)]\n   \"\"\n   \"// forked %0;\"\n-)\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_insn \"nvptx_joining\"\n   [(unspec_volatile:SI [(match_operand:SI 0 \"const_int_operand\" \"\")]\n \t\t       UNSPECV_JOINING)]\n   \"\"\n   \"// joining %0;\"\n-)\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_insn \"nvptx_join\"\n   [(unspec_volatile:SI [(match_operand:SI 0 \"const_int_operand\" \"\")]\n \t\t       UNSPECV_JOIN)]\n   \"\"\n   \"// join %0;\"\n-)\n+  [(set_attr \"predicable\" \"false\")])\n \n (define_expand \"oacc_fork\"\n   [(set (match_operand:SI 0 \"nvptx_nonmemory_operand\" \"\")\n@@ -1134,6 +1175,88 @@\n   \"\"\n   \"%.\\\\tshfl%S3.b32\\\\t%0, %1, %2, 31;\")\n \n+(define_insn \"nvptx_vote_ballot\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec:SI [(match_operand:BI 1 \"nvptx_register_operand\" \"R\")]\n+\t\t   UNSPEC_VOTE_BALLOT))]\n+  \"\"\n+  \"%.\\\\tvote.ballot.b32\\\\t%0, %1;\")\n+\n+;; Patterns for OpenMP SIMD-via-SIMT lowering\n+\n+;; Implement IFN_GOMP_SIMT_LANE: set operand 0 to lane index\n+(define_insn \"omp_simt_lane\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_LANEID))]\n+  \"\"\n+  \"%.\\\\tmov.u32\\\\t%0, %%laneid;\")\n+\n+;; Implement IFN_GOMP_SIMT_ORDERED: copy operand 1 to operand 0 and\n+;; place a compiler barrier to disallow unrolling/peeling the containing loop\n+(define_expand \"omp_simt_ordered\"\n+  [(match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+   (match_operand:SI 1 \"nvptx_register_operand\" \"R\")]\n+  \"\"\n+{\n+  emit_move_insn (operands[0], operands[1]);\n+  emit_insn (gen_nvptx_nounroll ());\n+  DONE;\n+})\n+\n+;; Implement IFN_GOMP_SIMT_XCHG_BFLY: perform a \"butterfly\" exchange\n+;; across lanes\n+(define_expand \"omp_simt_xchg_bfly\"\n+  [(match_operand 0 \"nvptx_register_operand\" \"=R\")\n+   (match_operand 1 \"nvptx_register_operand\" \"R\")\n+   (match_operand:SI 2 \"nvptx_nonmemory_operand\" \"Ri\")]\n+  \"\"\n+{\n+  emit_insn (nvptx_gen_shuffle (operands[0], operands[1], operands[2],\n+\t\t\t\tSHUFFLE_BFLY));\n+  DONE;\n+})\n+\n+;; Implement IFN_GOMP_SIMT_XCHG_IDX: broadcast value in operand 1\n+;; from lane given by index in operand 2 to operand 0 in all lanes\n+(define_expand \"omp_simt_xchg_idx\"\n+  [(match_operand 0 \"nvptx_register_operand\" \"=R\")\n+   (match_operand 1 \"nvptx_register_operand\" \"R\")\n+   (match_operand:SI 2 \"nvptx_nonmemory_operand\" \"Ri\")]\n+  \"\"\n+{\n+  emit_insn (nvptx_gen_shuffle (operands[0], operands[1], operands[2],\n+\t\t\t\tSHUFFLE_IDX));\n+  DONE;\n+})\n+\n+;; Implement IFN_GOMP_SIMT_VOTE_ANY:\n+;; set operand 0 to zero iff all lanes supply zero in operand 1\n+(define_expand \"omp_simt_vote_any\"\n+  [(match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+   (match_operand:SI 1 \"nvptx_register_operand\" \"R\")]\n+  \"\"\n+{\n+  rtx pred = gen_reg_rtx (BImode);\n+  emit_move_insn (pred, gen_rtx_NE (BImode, operands[1], const0_rtx));\n+  emit_insn (gen_nvptx_vote_ballot (operands[0], pred));\n+  DONE;\n+})\n+\n+;; Implement IFN_GOMP_SIMT_LAST_LANE:\n+;; set operand 0 to the lowest lane index that passed non-zero in operand 1\n+(define_expand \"omp_simt_last_lane\"\n+  [(match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+   (match_operand:SI 1 \"nvptx_register_operand\" \"R\")]\n+  \"\"\n+{\n+  rtx pred = gen_reg_rtx (BImode);\n+  rtx tmp = gen_reg_rtx (SImode);\n+  emit_move_insn (pred, gen_rtx_NE (BImode, operands[1], const0_rtx));\n+  emit_insn (gen_nvptx_vote_ballot (tmp, pred));\n+  emit_insn (gen_ctzsi2 (operands[0], tmp));\n+  DONE;\n+})\n+\n ;; extract parts of a 64 bit object into 2 32-bit ints\n (define_insn \"unpack<mode>si2\"\n   [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n@@ -1186,7 +1309,8 @@\n    (set (match_dup 1)\n \t(unspec_volatile:SDIM [(const_int 0)] UNSPECV_CAS))]\n   \"\"\n-  \"%.\\\\tatom%A1.cas.b%T0\\\\t%0, %1, %2, %3;\")\n+  \"%.\\\\tatom%A1.cas.b%T0\\\\t%0, %1, %2, %3;\"\n+  [(set_attr \"atomic\" \"true\")])\n \n (define_insn \"atomic_exchange<mode>\"\n   [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\t;; output\n@@ -1197,7 +1321,8 @@\n    (set (match_dup 1)\n \t(match_operand:SDIM 2 \"nvptx_nonmemory_operand\" \"Ri\"))]\t;; input\n   \"\"\n-  \"%.\\\\tatom%A1.exch.b%T0\\\\t%0, %1, %2;\")\n+  \"%.\\\\tatom%A1.exch.b%T0\\\\t%0, %1, %2;\"\n+  [(set_attr \"atomic\" \"true\")])\n \n (define_insn \"atomic_fetch_add<mode>\"\n   [(set (match_operand:SDIM 1 \"memory_operand\" \"+m\")\n@@ -1209,7 +1334,8 @@\n    (set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n \t(match_dup 1))]\n   \"\"\n-  \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\")\n+  \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\"\n+  [(set_attr \"atomic\" \"true\")])\n \n (define_insn \"atomic_fetch_addsf\"\n   [(set (match_operand:SF 1 \"memory_operand\" \"+m\")\n@@ -1221,7 +1347,8 @@\n    (set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n \t(match_dup 1))]\n   \"\"\n-  \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\")\n+  \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\"\n+  [(set_attr \"atomic\" \"true\")])\n \n (define_code_iterator any_logic [and ior xor])\n (define_code_attr logic [(and \"and\") (ior \"or\") (xor \"xor\")])\n@@ -1237,10 +1364,18 @@\n    (set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\n \t(match_dup 1))]\n   \"0\"\n-  \"%.\\\\tatom%A1.b%T0.<logic>\\\\t%0, %1, %2;\")\n+  \"%.\\\\tatom%A1.b%T0.<logic>\\\\t%0, %1, %2;\"\n+  [(set_attr \"atomic\" \"true\")])\n \n (define_insn \"nvptx_barsync\"\n   [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"\")]\n \t\t    UNSPECV_BARSYNC)]\n   \"\"\n-  \"\\\\tbar.sync\\\\t%0;\")\n+  \"\\\\tbar.sync\\\\t%0;\"\n+  [(set_attr \"predicable\" \"false\")])\n+\n+(define_insn \"nvptx_nounroll\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_NOUNROLL)]\n+  \"\"\n+  \"\\\\t.pragma \\\\\\\"nounroll\\\\\\\";\"\n+  [(set_attr \"predicable\" \"false\")])"}, {"sha": "cb6194da9dcea0c47247133988be555401b85cb1", "filename": "gcc/config/nvptx/nvptx.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -32,3 +32,15 @@ Link in code for a __main kernel.\n moptimize\n Target Report Var(nvptx_optimize) Init(-1)\n Optimize partition neutering.\n+\n+msoft-stack\n+Target Report Mask(SOFT_STACK)\n+Use custom stacks instead of local memory for automatic storage.\n+\n+muniform-simt\n+Target Report Mask(UNIFORM_SIMT)\n+Generate code that can keep local state uniform across all lanes.\n+\n+mgomp\n+Target Report Mask(GOMP)\n+Generate code for OpenMP offloading: enables -msoft-stack and -muniform-simt."}, {"sha": "6c1010ddd661588802370acaf9102ab1dfe94585", "filename": "gcc/config/nvptx/t-nvptx", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -8,3 +8,5 @@ ALL_HOST_OBJS += mkoffload.o\n mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n \t  mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)\n+\n+MULTILIB_OPTIONS = mgomp"}, {"sha": "4dcc7f6b55556393e844530ec9cbbf1f6ba984d2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -5576,6 +5576,7 @@ attributes.\n * MeP Variable Attributes::\n * Microsoft Windows Variable Attributes::\n * MSP430 Variable Attributes::\n+* Nvidia PTX Variable Attributes::\n * PowerPC Variable Attributes::\n * RL78 Variable Attributes::\n * SPU Variable Attributes::\n@@ -6257,6 +6258,20 @@ same name (@pxref{MSP430 Function Attributes}).\n These attributes can be applied to both functions and variables.\n @end table\n \n+@node Nvidia PTX Variable Attributes\n+@subsection Nvidia PTX Variable Attributes\n+\n+These variable attributes are supported by the Nvidia PTX back end:\n+\n+@table @code\n+@item shared\n+@cindex @code{shared} attribute, Nvidia PTX\n+Use this attribute to place a variable in the @code{.shared} memory space.\n+This memory space is private to each cooperative thread array; only threads\n+within one thread block refer to the same instance of the variable.\n+The runtime does not initialize variables in this memory space.\n+@end table\n+\n @node PowerPC Variable Attributes\n @subsection PowerPC Variable Attributes\n "}, {"sha": "620225c37cf8001e956addc494785f52697fa478", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -20570,6 +20570,37 @@ offloading execution.\n Apply partitioned execution optimizations.  This is the default when any\n level of optimization is selected.\n \n+@item -msoft-stack\n+@opindex msoft-stack\n+Generate code that does not use @code{.local} memory\n+directly for stack storage. Instead, a per-warp stack pointer is\n+maintained explicitly. This enables variable-length stack allocation (with\n+variable-length arrays or @code{alloca}), and when global memory is used for\n+underlying storage, makes it possible to access automatic variables from other\n+threads, or with atomic instructions. This code generation variant is used\n+for OpenMP offloading, but the option is exposed on its own for the purpose\n+of testing the compiler; to generate code suitable for linking into programs\n+using OpenMP offloading, use option @option{-mgomp}.\n+\n+@item -muniform-simt\n+@opindex muniform-simt\n+Switch to code generation variant that allows to execute all threads in each\n+warp, while maintaining memory state and side effects as if only one thread\n+in each warp was active outside of OpenMP SIMD regions.  All atomic operations\n+and calls to runtime (malloc, free, vprintf) are conditionally executed (iff\n+current lane index equals the master lane index), and the register being\n+assigned is copied via a shuffle instruction from the master lane.  Outside of\n+SIMD regions lane 0 is the master; inside, each thread sees itself as the\n+master.  Shared memory array @code{int __nvptx_uni[]} stores all-zeros or\n+all-ones bitmasks for each warp, indicating current mode (0 outside of SIMD\n+regions).  Each thread can bitwise-and the bitmask at position @code{tid.y}\n+with current lane index to compute the master lane index.\n+\n+@item -mgomp\n+@opindex mgomp\n+Generate code for use in OpenMP offloading: enables @option{-msoft-stack} and\n+@option{-muniform-simt} options, and selects corresponding multilib variant.\n+\n @end table\n \n @node PDP-11 Options"}, {"sha": "84bba07de270019b1cea4ba2a60ceb870a1a6c92", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -5862,6 +5862,10 @@ usable.  In that case, the smaller the number is, the more desirable it is\n to use it.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_SIMT_VF (void)\n+Return number of threads in SIMT thread group on the target.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_GOACC_VALIDATE_DIMS (tree @var{decl}, int *@var{dims}, int @var{fn_level})\n This hook should check the launch dimensions provided for an OpenACC\n compute region, or routine.  Defaulted values are represented as -1"}, {"sha": "9afd5daa65bc107a68a147201caf60c3ce903780", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -4295,6 +4295,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_SIMD_CLONE_USABLE\n \n+@hook TARGET_SIMT_VF\n+\n @hook TARGET_GOACC_VALIDATE_DIMS\n \n @hook TARGET_GOACC_DIM_LIMIT"}, {"sha": "e011a5a7f26c0d0f700afa38c7600d5a8b498d15", "filename": "gcc/target-insns.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -68,6 +68,12 @@ DEF_TARGET_INSN (oacc_dim_pos, (rtx x0, rtx x1))\n DEF_TARGET_INSN (oacc_dim_size, (rtx x0, rtx x1))\n DEF_TARGET_INSN (oacc_fork, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (oacc_join, (rtx x0, rtx x1, rtx x2))\n+DEF_TARGET_INSN (omp_simt_lane, (rtx x0))\n+DEF_TARGET_INSN (omp_simt_last_lane, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (omp_simt_ordered, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (omp_simt_vote_any, (rtx x0, rtx x1))\n+DEF_TARGET_INSN (omp_simt_xchg_bfly, (rtx x0, rtx x1, rtx x2))\n+DEF_TARGET_INSN (omp_simt_xchg_idx, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (prefetch, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (probe_stack, (rtx x0))\n DEF_TARGET_INSN (probe_stack_address, (rtx x0))"}, {"sha": "c24b4cf5ee2f267432481ea9d426cc1678324d45", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -1648,6 +1648,18 @@ int, (struct cgraph_node *), NULL)\n \n HOOK_VECTOR_END (simd_clone)\n \n+/* Functions relating to OpenMP SIMT vectorization transform.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_SIMT_\"\n+HOOK_VECTOR (TARGET_SIMT, simt)\n+\n+DEFHOOK\n+(vf,\n+\"Return number of threads in SIMT thread group on the target.\",\n+int, (void), NULL)\n+\n+HOOK_VECTOR_END (simt)\n+\n /* Functions relating to openacc.  */\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_GOACC_\""}, {"sha": "4496de29f35afa509d34818d12a84ebc27df247a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -1,3 +1,11 @@\n+2016-11-16  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* lib/target-supports.exp (check_effective_target_alloca): Use a\n+\tcompile test.\n+\t* gcc.target/nvptx/softstack.c: New test.\n+\t* gcc.target/nvptx/decl-shared.c: New test.\n+\t* gcc.target/nvptx/decl-shared-init.c: New test.\n+\n 2016-11-16  Maciej W. Rozycki  <macro@imgtec.com>\n \n \t* gcc.target/mips/data-sym-jump.c: New test case."}, {"sha": "6a99b1c338a1f4e81f3f0ef5f77b860554034dd2", "filename": "gcc/testsuite/gcc.target/nvptx/decl-shared-init.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fdecl-shared-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fdecl-shared-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fdecl-shared-init.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -0,0 +1 @@\n+int var __attribute__((shared)) = 0; /* { dg-error \"static initialization .* not supported\" } */"}, {"sha": "367075cebe29f01861d8ed4ace03a025900170ef", "filename": "gcc/testsuite/gcc.target/nvptx/decl-shared.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fdecl-shared.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fdecl-shared.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fdecl-shared.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -0,0 +1,14 @@\n+static int v_internal __attribute__((shared,used));\n+int v_common __attribute__((shared));\n+int v_extdef __attribute__((shared,nocommon));\n+extern int v_extdecl __attribute__((shared));\n+\n+int use()\n+{\n+  return v_extdecl;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[\\r\\n\\]\\[\\t \\]*.shared \\[^,\\r\\n\\]*v_internal\" } } */\n+/* { dg-final { scan-assembler \"\\[\\r\\n\\]\\[\\t \\]*.weak .shared \\[^,\\r\\n\\]*v_common\" } } */\n+/* { dg-final { scan-assembler \"\\[\\r\\n\\]\\[\\t \\]*.visible .shared \\[^,\\r\\n\\]*v_extdef\" } } */\n+/* { dg-final { scan-assembler \"\\[\\r\\n\\]\\[\\t \\]*.extern .shared \\[^,\\r\\n\\]*v_extdecl\" } } */"}, {"sha": "73e60f282a744ff146c6bc008897648bc4c3cb29", "filename": "gcc/testsuite/gcc.target/nvptx/softstack.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fsoftstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fsoftstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fsoftstack.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-O2 -msoft-stack\" } */\n+/* { dg-do run } */\n+\n+static __attribute__((noinline,noclone)) int f(int *p)\n+{\n+  return __sync_lock_test_and_set(p, 1);\n+}\n+\n+static __attribute__((noinline,noclone)) int g(int n)\n+{\n+  /* Check that variable-length stack allocation works.  */\n+  int v[n];\n+  v[0] = 0;\n+  /* Check that atomic operations can be applied to auto data.  */\n+  return f(v) == 0 && v[0] == 1;\n+}\n+\n+int main()\n+{\n+  if (!g(1))\n+    __builtin_abort();\n+  return 0;\n+}"}, {"sha": "ec99708f633b02d743cb229127a3d7f3c6cadbcd", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -763,7 +763,10 @@ proc check_effective_target_untyped_assembly {} {\n \n proc check_effective_target_alloca {} {\n     if { [istarget nvptx-*-*] } {\n-\treturn 0\n+\treturn [check_no_compiler_messages alloca assembly {\n+\t    void f (void*);\n+\t    void g (int n) { f (__builtin_alloca (n)); }\n+\t}]\n     }\n     return 1\n }"}, {"sha": "4daa0aa3409dd95694a01d98da49eb40103701dd", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -1,3 +1,9 @@\n+2016-11-16  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* config/nvptx/crt0.c (__main): Setup __nvptx_stacks and __nvptx_uni.\n+\t* config/nvptx/mgomp.c: New file.\n+\t* config/nvptx/t-nvptx: Add mgomp.c\n+\n 2016-11-16  Waldemar Brodkorb  <wbx@openadk.org>\n \n \tPR libgcc/68468"}, {"sha": "5a7dbf6f22f36b257034a95ff56c44aced0aef6d", "filename": "libgcc/config/nvptx/crt0.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2Fconfig%2Fnvptx%2Fcrt0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2Fconfig%2Fnvptx%2Fcrt0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Fcrt0.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -24,6 +24,14 @@ int *__exitval_ptr;\n extern void __attribute__((noreturn)) exit (int status);\n extern int main (int, void **);\n \n+/* Always setup soft stacks to allow testing with -msoft-stack but without\n+   -mgomp.  32 is the maximum number of warps in a CTA: the definition here\n+   must match the external declaration emitted by the compiler.  */\n+void *__nvptx_stacks[32] __attribute__((shared,nocommon));\n+\n+/* Likewise for -muniform-simt.  */\n+unsigned __nvptx_uni[32] __attribute__((shared,nocommon));\n+\n void __attribute__((kernel))\n __main (int *rval_ptr, int argc, void **argv)\n {\n@@ -33,5 +41,9 @@ __main (int *rval_ptr, int argc, void **argv)\n   if (rval_ptr)\n     *rval_ptr = 255;\n \n+  static char stack[131072] __attribute__((aligned(8)));\n+  __nvptx_stacks[0] = stack + sizeof stack;\n+  __nvptx_uni[0] = 0;\n+\n   exit (main (argc, argv));\n }"}, {"sha": "d8ca581831467e355a2eaa4e22aa0ed2e91e3427", "filename": "libgcc/config/nvptx/mgomp.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2Fconfig%2Fnvptx%2Fmgomp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2Fconfig%2Fnvptx%2Fmgomp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Fmgomp.c?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -0,0 +1,32 @@\n+/* Define shared memory arrays for -msoft-stack and -muniform-simt.\n+\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* OpenACC offloading does not use these symbols; thus, they are exposed\n+   only for the -mgomp multilib.  The same definitions are also provided\n+   in crt0.c for the case of non-offloading compilation.  32 is the maximum\n+   number of warps in a CTA.  */\n+\n+#if defined(__nvptx_softstack__) && defined(__nvptx_unisimt__)\n+void *__nvptx_stacks[32] __attribute__((shared,nocommon));\n+unsigned __nvptx_uni[32] __attribute__((shared,nocommon));\n+#endif"}, {"sha": "c4d20c94cbbaa596f4e8f94fa0201f544df89de1", "filename": "libgcc/config/nvptx/t-nvptx", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5012919d0bd344ac1888e8e531072f0ccbe24d2c/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=5012919d0bd344ac1888e8e531072f0ccbe24d2c", "patch": "@@ -1,4 +1,5 @@\n-LIB2ADD=$(srcdir)/config/nvptx/reduction.c\n+LIB2ADD=$(srcdir)/config/nvptx/reduction.c \\\n+\t$(srcdir)/config/nvptx/mgomp.c\n \n LIB2ADDEH=\n LIB2FUNCS_EXCLUDE=__main"}]}