{"sha": "550b31876707cbf91d22ca6c37d032302d2048d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwYjMxODc2NzA3Y2JmOTFkMjJjYTZjMzdkMDMyMzAyZDIwNDhkOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-05-18T01:04:12Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-05-18T01:04:12Z"}, "message": "re PR middle-end/30251 (Evaluate bessel functions at compile-time)\n\n\tPR middle-end/30251\n\t* builtins.c (do_mpfr_bessel_n): New.\n\t(fold_builtin_1): Handle BUILT_IN_J0 and BUILT_IN_J1.\n\t(fold_builtin_2): Handle BUILT_IN_JN.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-4.c: New test.\n\nFrom-SVN: r124818", "tree": {"sha": "f419ab9cf75fbb5c9a0e430d63b7fa1186c1199f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f419ab9cf75fbb5c9a0e430d63b7fa1186c1199f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550b31876707cbf91d22ca6c37d032302d2048d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550b31876707cbf91d22ca6c37d032302d2048d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550b31876707cbf91d22ca6c37d032302d2048d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550b31876707cbf91d22ca6c37d032302d2048d9/comments", "author": null, "committer": null, "parents": [{"sha": "f012476607904e252a6ae09a8eba00d9915d5874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f012476607904e252a6ae09a8eba00d9915d5874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f012476607904e252a6ae09a8eba00d9915d5874"}], "stats": {"total": 201, "additions": 201, "deletions": 0}, "files": [{"sha": "6e3c321b2957361d04462a8cf23b5b8f2f1b04ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=550b31876707cbf91d22ca6c37d032302d2048d9", "patch": "@@ -1,3 +1,10 @@\n+2007-05-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/30251\n+\t* builtins.c (do_mpfr_bessel_n): New.\n+\t(fold_builtin_1): Handle BUILT_IN_J0 and BUILT_IN_J1.\n+\t(fold_builtin_2): Handle BUILT_IN_JN.\n+\n 2007-05-17  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/31965"}, {"sha": "221b5a34b3e8ec8fd02c1d2a42daca113791bece", "filename": "gcc/builtins.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=550b31876707cbf91d22ca6c37d032302d2048d9", "patch": "@@ -231,6 +231,11 @@ static tree do_mpfr_arg2 (tree, tree, tree,\n static tree do_mpfr_arg3 (tree, tree, tree, tree,\n \t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n static tree do_mpfr_sincos (tree, tree, tree);\n+#if MPFR_VERSION >= MPFR_VERSION_NUM(2,3,0)\n+static tree do_mpfr_bessel_n (tree, tree, tree,\n+\t\t\t      int (*)(mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n+\t\t\t      const REAL_VALUE_TYPE *, bool);\n+#endif\n \n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n@@ -9766,6 +9771,20 @@ fold_builtin_1 (tree fndecl, tree arg0, bool ignore)\n \t\t\t     &dconstm1, NULL, false);\n     break;\n \n+#if MPFR_VERSION >= MPFR_VERSION_NUM(2,3,0)\n+    CASE_FLT_FN (BUILT_IN_J0):\n+      if (validate_arg (arg0, REAL_TYPE))\n+\treturn do_mpfr_arg1 (arg0, type, mpfr_j0,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+\n+    CASE_FLT_FN (BUILT_IN_J1):\n+      if (validate_arg (arg0, REAL_TYPE))\n+\treturn do_mpfr_arg1 (arg0, type, mpfr_j1,\n+\t\t\t     NULL, NULL, 0);\n+    break;\n+#endif\n+\n     CASE_FLT_FN (BUILT_IN_NAN):\n     case BUILT_IN_NAND32:\n     case BUILT_IN_NAND64:\n@@ -9876,6 +9895,13 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n \n   switch (fcode)\n     {\n+#if MPFR_VERSION >= MPFR_VERSION_NUM(2,3,0)\n+    CASE_FLT_FN (BUILT_IN_JN):\n+      if (validate_arg (arg0, INTEGER_TYPE)\n+\t  && validate_arg (arg1, REAL_TYPE))\n+\treturn do_mpfr_bessel_n (arg0, arg1, type, mpfr_jn, NULL, 0);\n+    break;\n+#endif\n \n     CASE_FLT_FN (BUILT_IN_ATAN2):\n       if (validate_arg (arg0, REAL_TYPE)\n@@ -12505,3 +12531,50 @@ do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n     }\n   return result;\n }\n+\n+#if MPFR_VERSION >= MPFR_VERSION_NUM(2,3,0)\n+/* If argument ARG1 is an INTEGER_CST and ARG2 is a REAL_CST, call the\n+   two-argument mpfr order N Bessel function FUNC on them and return\n+   the resulting value as a tree with type TYPE.  The mpfr precision\n+   is set to the precision of TYPE.  We assume that function FUNC\n+   returns zero if the result could be calculated exactly within the\n+   requested precision.  */\n+static tree\n+do_mpfr_bessel_n (tree arg1, tree arg2, tree type,\n+\t\t  int (*func)(mpfr_ptr, long, mpfr_srcptr, mp_rnd_t),\n+\t\t  const REAL_VALUE_TYPE *min, bool inclusive)\n+{\n+  tree result = NULL_TREE;\n+\n+  STRIP_NOPS (arg1);\n+  STRIP_NOPS (arg2);\n+\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n+      && host_integerp (arg1, 0)\n+      && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2))\n+    {\n+      const HOST_WIDE_INT n = tree_low_cst(arg1, 0);\n+      const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg2);\n+\n+      if (n == (long)n\n+\t  && !real_isnan (ra) && !real_isinf (ra)\n+\t  && (!min || real_compare (inclusive ? GE_EXPR: GT_EXPR , ra, min)))\n+        {\n+\t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n+\t  int inexact;\n+\t  mpfr_t m;\n+\n+\t  mpfr_init2 (m, prec);\n+\t  mpfr_from_real (m, ra, GMP_RNDN);\n+\t  mpfr_clear_flags ();\n+\t  inexact = func (m, n, m, GMP_RNDN);\n+\t  result = do_mpfr_ckconv (m, type, inexact);\n+\t  mpfr_clear (m);\n+\t}\n+    }\n+  \n+  return result;\n+}\n+#endif"}, {"sha": "c2be7405667387a94a0c2fa42997aa197d77b8c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=550b31876707cbf91d22ca6c37d032302d2048d9", "patch": "@@ -1,3 +1,7 @@\n+2007-05-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-4.c: New test.\n+\n 2007-05-17  Janis Johnson  <janis187@us.ibm.com>\n \t    Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n "}, {"sha": "294dd93eeb25151b41394e8d122ec173da65a224", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-4.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550b31876707cbf91d22ca6c37d032302d2048d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-4.c?ref=550b31876707cbf91d22ca6c37d032302d2048d9", "patch": "@@ -0,0 +1,117 @@\n+/* Copyright (C) 2007  Free Software Foundation.\n+\n+   Verify that built-in math function constant folding of constant\n+   arguments is correctly performed by the compiler.  This testcase is\n+   for functionality that was available as of mpfr-2.3.0.\n+\n+   Origin: Kaveh R. Ghazi,  April 23, 2007.  */\n+\n+/* { dg-do link } */\n+/* Expect failures at least until mpfr-2.3.0 is released. */\n+/* { dg-xfail-if \"mpfr-2.3.0\" { *-*-* } } */\n+\n+/* All references to link_error should go away at compile-time.  */\n+extern void link_error(int);\n+\n+/* Return TRUE if the sign of X != sign of Y.  This is important when\n+   comparing signed zeros.  */\n+#define CKSGN_F(X,Y) \\\n+  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+#define CKSGN(X,Y) \\\n+  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+#define CKSGN_L(X,Y) \\\n+  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+\n+/* Test that FUNC(ARG) == (RES).  */\n+#define TESTIT(FUNC,ARG,RES) do { \\\n+  if (__builtin_##FUNC##f(ARG##F) != RES##F \\\n+      || CKSGN_F(__builtin_##FUNC##f(ARG##F),RES##F)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG) != RES \\\n+      || CKSGN(__builtin_##FUNC(ARG),RES)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG##L) != RES##L \\\n+      || CKSGN_L(__builtin_##FUNC##l(ARG##L),RES##L)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Range test, check that (LOW) < FUNC(ARG) < (HI).  */\n+#define TESTIT_R(FUNC,ARG,LOW,HI) do { \\\n+  if (__builtin_##FUNC##f(ARG) <= (LOW) || __builtin_##FUNC##f(ARG) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG) <= (LOW) || __builtin_##FUNC(ARG) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG) <= (LOW) || __builtin_##FUNC##l(ARG) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that FUNC(ARG1, ARG2) == (RES).  */\n+#define TESTIT2(FUNC,ARG1,ARG2,RES) do { \\\n+  if (__builtin_##FUNC##f(ARG1, ARG2##F) != RES##F \\\n+      || CKSGN_F(__builtin_##FUNC##f(ARG1,ARG2##F),RES##F)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG1, ARG2) != RES \\\n+      || CKSGN(__builtin_##FUNC(ARG1,ARG2),RES)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG1, ARG2##L) != RES##L \\\n+      || CKSGN_L(__builtin_##FUNC##l(ARG1,ARG2##L),RES##L)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Range test, check that (LOW) < FUNC(ARG1,ARG2) < (HI).  */\n+#define TESTIT2_R(FUNC,ARG1,ARG2,LOW,HI) do { \\\n+  if (__builtin_##FUNC##f(ARG1, ARG2##F) <= (LOW) \\\n+      || __builtin_##FUNC##f(ARG1, ARG2##F) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC(ARG1, ARG2) <= (LOW) \\\n+      || __builtin_##FUNC(ARG1, ARG2) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_##FUNC##l(ARG1, ARG2##L) <= (LOW) \\\n+      || __builtin_##FUNC##l(ARG1, ARG2##L) >= (HI)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+int main (void)\n+{\n+  TESTIT (j0, 0.0, 1.0); /* j0(0) == 1 */\n+  TESTIT (j0, -0.0, 1.0); /* j0(-0) == 1 */\n+  TESTIT_R (j0, 1.0, 0.765, 0.766); /* j0(1) == 0.7651... */\n+  TESTIT_R (j0, -1.0, 0.765, 0.766); /* j0(-1) == 0.7651... */\n+\n+  TESTIT (j1, 0.0, 0.0); /* j1(0) == 0 */\n+  TESTIT (j1, -0.0, -0.0); /* j1(-0) == -0 */\n+  TESTIT_R (j1, 1.0, 0.44, 0.45); /* j1(1) == 0.440... */\n+  TESTIT_R (j1, -1.0, -0.45, -0.44); /* j1(-1) == -0.440... */\n+\n+  TESTIT2 (jn, 5, 0.0, 0.0); /* jn(5,0) == 0 */\n+  TESTIT2 (jn, 5, -0.0, -0.0); /* jn(5,-0) == -0 */\n+  TESTIT2 (jn, 6, 0.0, 0.0); /* jn(6,0) == 0 */\n+  TESTIT2 (jn, 6, -0.0, 0.0); /* jn(6,-0) == 0 */\n+\n+  TESTIT2 (jn, -5, 0.0, -0.0); /* jn(-5,0) == -0 */\n+  TESTIT2 (jn, -5, -0.0, 0.0); /* jn(-5,-0) == 0 */\n+  TESTIT2 (jn, -6, 0.0, 0.0); /* jn(-6,0) == 0 */\n+  TESTIT2 (jn, -6, -0.0, 0.0); /* jn(-6,-0) == 0 */\n+\n+  TESTIT2_R (jn, 2, 1.0, 0.11, 0.12); /* jn(2,1) == 0.114... */\n+  TESTIT2_R (jn, 2, -1.0, 0.11, 0.12); /* jn(2,-1) == 0.114... */\n+  TESTIT2_R (jn, 3, 5.0, 0.36, 0.37); /* jn(3,5) == 0.364... */\n+  TESTIT2_R (jn, 3, -5.0, -0.37, -0.36); /* jn(3,-5) == -0.364... */\n+\n+  TESTIT2_R (jn, -2, 1.0, 0.11, 0.12); /* jn(-2,1) == 0.114... */\n+  TESTIT2_R (jn, -2, -1.0, 0.11, 0.12); /* jn(-2,-1) == 0.114... */\n+  TESTIT2_R (jn, -3, 5.0, -0.37, -0.36); /* jn(-3,5) == -0.364... */\n+  TESTIT2_R (jn, -3, -5.0, 0.36, 0.37); /* jn(-3,-5) == 0.364... */\n+\n+  TESTIT2_R (jn, 4, 3.5, 0.20, 0.21); /* jn(4,3.5) == 0.204... */\n+  TESTIT2_R (jn, 4, -3.5, 0.20, 0.21); /* jn(4,-3.5) == 0.204... */\n+  TESTIT2_R (jn, 5, 4.6, 0.20, 0.21); /* jn(5,4.6) == 0.207... */\n+  TESTIT2_R (jn, 5, -4.6, -0.21, -0.20); /* jn(5,-4.6) == -0.207... */\n+\n+  TESTIT2_R (jn, -4, 3.5, 0.20, 0.21); /* jn(-4,3.5) == 0.204... */\n+  TESTIT2_R (jn, -4, -3.5, 0.20, 0.21); /* jn(-4,-3.5) == 0.204... */\n+  TESTIT2_R (jn, -5, 4.6, -0.21, -0.20); /* jn(-5,4.6) == -0.207... */\n+  TESTIT2_R (jn, -5, -4.6, 0.20, 0.21); /* jn(-5,-4.6) == 0.207... */\n+\n+  return 0;\n+}"}]}