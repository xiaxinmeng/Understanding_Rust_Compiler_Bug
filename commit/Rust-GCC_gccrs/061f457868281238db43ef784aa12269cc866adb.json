{"sha": "061f457868281238db43ef784aa12269cc866adb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxZjQ1Nzg2ODI4MTIzOGRiNDNlZjc4NGFhMTIyNjljYzg2NmFkYg==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2019-03-21T23:48:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-03-21T23:48:49Z"}, "message": "Integrate C++17 parallel algorithms\n\nThis is the Intel implementation of the C++17 parallel\nalgorithms, which has been donated to both GCC and LLVM. The upstream\nproject is at -\n\n\thttps://reviews.llvm.org/source/pstl/\n\nThe new files in the include/pstl sub-directory are covered by the\nLICENSE.txt in that sub-directory, as are the tests in\ntestsuite/**/pstl/*\n\n\t* include/Makefile.am (std_header): Add ${std_srcdir}/execution.\n\t(pstl_srcdir, pstl_builddir, pstl_headers): New variables.\n\t(allstamped): Add stamp-pstl.\n\t(install-headers): Add ptsl_builddir.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/c++config: Add pstl configuration.\n\t* include/pstl/LICENSE.txt: New file.\n\t* include/pstl/algorithm_fwd.h: New file.\n\t* include/pstl/algorithm_impl.h: New file.\n\t* include/pstl/execution_defs.h: New file.\n\t* include/pstl/execution_impl.h: New file.\n\t* include/pstl/glue_algorithm_defs.h: New file.\n\t* include/pstl/glue_algorithm_impl.h: New file.\n\t* include/pstl/glue_execution_defs.h: New file.\n\t* include/pstl/glue_memory_defs.h: New file.\n\t* include/pstl/glue_memory_impl.h: New file.\n\t* include/pstl/glue_numeric_defs.h: New file.\n\t* include/pstl/glue_numeric_impl.h: New file.\n\t* include/pstl/memory_impl.h: New file.\n\t* include/pstl/numeric_fwd.h: New file.\n\t* include/pstl/numeric_impl.h: New file.\n\t* include/pstl/parallel_backend.h: New file.\n\t* include/pstl/parallel_backend_tbb.h: New file.\n\t* include/pstl/parallel_backend_utils.h: New file.\n\t* include/pstl/parallel_impl.h: New file.\n\t* include/pstl/pstl_config.h: New file.\n\t* include/pstl/unseq_backend_simd.h: New file.\n\t* include/pstl/utils.h: New file.\n\t* include/std/algorithm: Include parallel algorithm implementations.\n\t* include/std/execution: New file.\n\t* include/std/memory: Include parallel algorithm implementations.\n\t* include/std/numeric: Include parallel algorithm implementations.\n\t* include/std/version: Add parallel algorithms feature test macro.\n\t* testsuite/util/pstl/pstl_test_config.h: New file.\n\t* testsuite/util/pstl/test_utils.h: New file.\n\t* testsuite/20_util/specialized_algorithms/pstl/uninitialized_construct.cc: New file.\n\t* testsuite/20_util/specialized_algorithms/pstl/uninitialized_copy_move.cc: New file.\n\t* testsuite/20_util/specialized_algorithms/pstl/uninitialized_fill_destroy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_merge/inplace_merge.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_merge/merge.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/copy_if.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/copy_move.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/fill.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/generate.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/is_partitioned.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/partition.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/partition_copy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/remove.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/remove_copy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/replace.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/replace_copy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/rotate.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/rotate_copy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/swap_ranges.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/transform_binary.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/transform_unary.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/unique.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_modifying_operations/unique_copy_equal.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/adjacent_find.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/all_of.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/any_of.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/count.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/equal.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find_first_of.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find_if.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/for_each.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/mismatch.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/none_of.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/nth_element.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/reverse.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/reverse_copy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/includes.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/is_heap.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/is_sorted.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/lexicographical_compare.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/minmax_element.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/partial_sort.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/partial_sort_copy.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/set.cc: New file.\n\t* testsuite/25_algorithms/pstl/alg_sorting/sort.cc: New file.\n\t* testsuite/26_numerics/pstl/numeric_ops/adjacent_difference.cc: New file.\n\t* testsuite/26_numerics/pstl/numeric_ops/reduce.cc: New file.\n\t* testsuite/26_numerics/pstl/numeric_ops/scan.cc: New file.\n\t* testsuite/26_numerics/pstl/numeric_ops/transform_reduce.cc: New file.\n\t* testsuite/26_numerics/pstl/numeric_ops/transform_scan.cc: New file.\n\t* testsuite/testsuite/20_util/specialized_algorithms/pstl/uninitialized_construct.cc: New file.\n\t* testsuite/testsuite/20_util/specialized_algorithms/pstl/uninitialized_copy_move.cc: New file.\n\t* testsuite/testsuite/20_util/specialized_algorithms/pstl/uninitialized_fill_destroy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_merge/inplace_merge.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_merge/merge.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/copy_if.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/copy_move.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/fill.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/generate.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/is_partitioned.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/partition.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/partition_copy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/remove.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/remove_copy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/replace.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/replace_copy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/rotate.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/rotate_copy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/swap_ranges.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/transform_binary.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/transform_unary.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/unique.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/unique_copy_equal.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/adjacent_find.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/all_of.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/any_of.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/count.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/equal.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find_first_of.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find_if.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/for_each.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/mismatch.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/none_of.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/nth_element.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/reverse.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/reverse_copy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/includes.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/is_heap.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/is_sorted.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/lexicographical_compare.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/minmax_element.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/partial_sort.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/partial_sort_copy.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/set.cc: New file.\n\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/sort.cc: New file.\n\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/adjacent_difference.cc: New file.\n\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/reduce.cc: New file.\n\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/scan.cc: New file.\n\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/transform_reduce.cc: New file.\n\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/transform_scan.cc: New file.\n\nFrom-SVN: r269863", "tree": {"sha": "8afdd97120052ef490689fc5e641cd27d7cc9f2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8afdd97120052ef490689fc5e641cd27d7cc9f2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/061f457868281238db43ef784aa12269cc866adb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/061f457868281238db43ef784aa12269cc866adb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/061f457868281238db43ef784aa12269cc866adb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/061f457868281238db43ef784aa12269cc866adb/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774856e3fbc2b1b6ab67470a7d6fc7cb7b4be546"}], "stats": {"total": 20321, "additions": 20317, "deletions": 4}, "files": [{"sha": "c8672263a6f7ab0d273ed5bba6868a56fc0e31a6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -1,3 +1,147 @@\n+2019-03-21  Thomas Rodgers  <trodgers@redhat.com>\n+\t\n+\t* include/Makefile.am (std_header): Add ${std_srcdir}/execution.\n+\t(pstl_srcdir, pstl_builddir, pstl_headers): New variables.\n+\t(allstamped): Add stamp-pstl.\n+\t(install-headers): Add ptsl_builddir.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/c++config: Add pstl configuration.\n+\t* include/pstl/LICENSE.txt: New file.\n+\t* include/pstl/algorithm_fwd.h: New file.\n+\t* include/pstl/algorithm_impl.h: New file.\n+\t* include/pstl/execution_defs.h: New file.\n+\t* include/pstl/execution_impl.h: New file.\n+\t* include/pstl/glue_algorithm_defs.h: New file.\n+\t* include/pstl/glue_algorithm_impl.h: New file.\n+\t* include/pstl/glue_execution_defs.h: New file.\n+\t* include/pstl/glue_memory_defs.h: New file.\n+\t* include/pstl/glue_memory_impl.h: New file.\n+\t* include/pstl/glue_numeric_defs.h: New file.\n+\t* include/pstl/glue_numeric_impl.h: New file.\n+\t* include/pstl/memory_impl.h: New file.\n+\t* include/pstl/numeric_fwd.h: New file.\n+\t* include/pstl/numeric_impl.h: New file.\n+\t* include/pstl/parallel_backend.h: New file.\n+\t* include/pstl/parallel_backend_tbb.h: New file.\n+\t* include/pstl/parallel_backend_utils.h: New file.\n+\t* include/pstl/parallel_impl.h: New file.\n+\t* include/pstl/pstl_config.h: New file.\n+\t* include/pstl/unseq_backend_simd.h: New file.\n+\t* include/pstl/utils.h: New file.\n+\t* include/std/algorithm: Include parallel algorithm implementations.\n+\t* include/std/execution: New file.\n+\t* include/std/memory: Include parallel algorithm implementations.\n+\t* include/std/numeric: Include parallel algorithm implementations.\n+\t* include/std/version: Add parallel algorithms feature test macro.\n+\t* testsuite/util/pstl/pstl_test_config.h: New file.\n+\t* testsuite/util/pstl/test_utils.h: New file.\n+\t* testsuite/20_util/specialized_algorithms/pstl/uninitialized_construct.cc: New file.\n+\t* testsuite/20_util/specialized_algorithms/pstl/uninitialized_copy_move.cc: New file.\n+\t* testsuite/20_util/specialized_algorithms/pstl/uninitialized_fill_destroy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_merge/inplace_merge.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_merge/merge.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/copy_if.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/copy_move.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/fill.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/generate.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/is_partitioned.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/partition.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/partition_copy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/remove.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/remove_copy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/replace.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/replace_copy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/rotate.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/rotate_copy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/swap_ranges.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/transform_binary.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/transform_unary.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/unique.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_modifying_operations/unique_copy_equal.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/adjacent_find.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/all_of.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/any_of.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/count.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/equal.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find_first_of.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/find_if.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/for_each.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/mismatch.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/none_of.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/nth_element.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/reverse.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/reverse_copy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/includes.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/is_heap.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/is_sorted.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/lexicographical_compare.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/minmax_element.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/partial_sort.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/partial_sort_copy.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/set.cc: New file.\n+\t* testsuite/25_algorithms/pstl/alg_sorting/sort.cc: New file.\n+\t* testsuite/26_numerics/pstl/numeric_ops/adjacent_difference.cc: New file.\n+\t* testsuite/26_numerics/pstl/numeric_ops/reduce.cc: New file.\n+\t* testsuite/26_numerics/pstl/numeric_ops/scan.cc: New file.\n+\t* testsuite/26_numerics/pstl/numeric_ops/transform_reduce.cc: New file.\n+\t* testsuite/26_numerics/pstl/numeric_ops/transform_scan.cc: New file.\n+\t* testsuite/testsuite/20_util/specialized_algorithms/pstl/uninitialized_construct.cc: New file.\n+\t* testsuite/testsuite/20_util/specialized_algorithms/pstl/uninitialized_copy_move.cc: New file.\n+\t* testsuite/testsuite/20_util/specialized_algorithms/pstl/uninitialized_fill_destroy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_merge/inplace_merge.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_merge/merge.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/copy_if.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/copy_move.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/fill.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/generate.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/is_partitioned.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/partition.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/partition_copy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/remove.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/remove_copy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/replace.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/replace_copy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/rotate.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/rotate_copy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/swap_ranges.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/transform_binary.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/transform_unary.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/unique.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_modifying_operations/unique_copy_equal.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/adjacent_find.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/all_of.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/any_of.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/count.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/equal.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find_first_of.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/find_if.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/for_each.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/mismatch.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/none_of.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/nth_element.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/reverse.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/reverse_copy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/includes.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/is_heap.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/is_sorted.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/lexicographical_compare.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/minmax_element.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/partial_sort.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/partial_sort_copy.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/set.cc: New file.\n+\t* testsuite/testsuite/25_algorithms/pstl/alg_sorting/sort.cc: New file.\n+\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/adjacent_difference.cc: New file.\n+\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/reduce.cc: New file.\n+\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/scan.cc: New file.\n+\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/transform_reduce.cc: New file.\n+\t* testsuite/testsuite/26_numerics/pstl/numeric_ops/transform_scan.cc: New file.\n+\n 2019-03-21  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/c_compatibility/math.h [!__STDCPP_WANT_MATH_SPEC_FUNCS__]"}, {"sha": "1deacb80ca248d89e494a79fefb5b3a5ea043d11", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -38,6 +38,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n+\t${std_srcdir}/execution \\\n \t${std_srcdir}/filesystem \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n@@ -225,6 +226,32 @@ bits_sup_headers = \\\n \t${bits_sup_srcdir}/hash_bytes.h \\\n \t${bits_sup_srcdir}/nested_exception.h\n \n+# C++17 Parallel Algorithm Includes.\n+pstl_srcdir = ${glibcxx_srcdir}/include/pstl\n+pstl_builddir = ./pstl\n+pstl_headers = \\\n+\t${pstl_srcdir}/algorithm_fwd.h \\\n+\t${pstl_srcdir}/algorithm_impl.h \\\n+\t${pstl_srcdir}/execution_defs.h \\\n+\t${pstl_srcdir}/execution_impl.h \\\n+\t${pstl_srcdir}/glue_algorithm_defs.h \\\n+\t${pstl_srcdir}/glue_algorithm_impl.h \\\n+\t${pstl_srcdir}/glue_execution_defs.h \\\n+\t${pstl_srcdir}/glue_memory_defs.h \\\n+\t${pstl_srcdir}/glue_memory_impl.h \\\n+\t${pstl_srcdir}/glue_numeric_defs.h \\\n+\t${pstl_srcdir}/glue_numeric_impl.h \\\n+\t${pstl_srcdir}/memory_impl.h \\\n+\t${pstl_srcdir}/numeric_fwd.h \\\n+\t${pstl_srcdir}/numeric_impl.h \\\n+\t${pstl_srcdir}/parallel_backend.h \\\n+\t${pstl_srcdir}/parallel_backend_tbb.h \\\n+\t${pstl_srcdir}/parallel_backend_utils.h \\\n+\t${pstl_srcdir}/parallel_impl.h \\\n+\t${pstl_srcdir}/pstl_config.h \\\n+\t${pstl_srcdir}/unseq_backend_simd.h \\\n+\t${pstl_srcdir}/utils.h\n+\n backward_srcdir = ${glibcxx_srcdir}/include/backward\n backward_builddir = ./backward\n backward_headers = \\\n@@ -1014,7 +1041,7 @@ endif\n # List of all timestamp files.  By keeping only one copy of this list, both\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n-\tstamp-std stamp-bits stamp-bits-sup stamp-c_base stamp-c_compatibility \\\n+\tstamp-std stamp-bits stamp-bits-sup stamp-pstl stamp-c_base stamp-c_compatibility \\\n \tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr2 stamp-decimal \\\n \tstamp-experimental stamp-experimental-bits stamp-debug stamp-parallel \\\n \tstamp-profile stamp-profile-impl stamp-host\n@@ -1047,6 +1074,11 @@ stamp-bits-sup: stamp-bits ${bits_sup_headers}\n \t@-cd ${bits_builddir} && $(LN_S) ${bits_sup_headers} . 2>/dev/null\n \t@$(STAMP) stamp-bits-sup\n \n+stamp-pstl: ${pstl_headers}\n+\t@-mkdir -p ${pstl_builddir}\n+\t@-cd ${pstl_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-pstl\n+\n stamp-c_base: ${c_base_headers}\n \t@-mkdir -p ${c_base_builddir}\n \t@-cd ${c_base_builddir} && $(LN_S) $? . 2>/dev/null\n@@ -1480,7 +1512,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${host_installdir}/../ext\n \tfor file in ${ext_host_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${host_installdir}/../ext; done\n-\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${pstl_builddir}\n+\tfor file in ${pstl_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${pstl_builddir}; done\n # By adding these files here, automake will remove them for 'make clean'\n CLEANFILES = ${pch_output} ${pch_output_anchors} stamp-host\n "}, {"sha": "bc475c6dd90f1b18307eaa7b84195d61717ea416", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -382,6 +382,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n+\t${std_srcdir}/execution \\\n \t${std_srcdir}/filesystem \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n@@ -569,6 +570,33 @@ bits_sup_headers = \\\n \t${bits_sup_srcdir}/hash_bytes.h \\\n \t${bits_sup_srcdir}/nested_exception.h\n \n+\n+# C++17 Parallel Algorithm Includes.\n+pstl_srcdir = ${glibcxx_srcdir}/include/pstl\n+pstl_builddir = ./pstl\n+pstl_headers = \\\n+\t${pstl_srcdir}/algorithm_fwd.h \\\n+\t${pstl_srcdir}/algorithm_impl.h \\\n+\t${pstl_srcdir}/execution_defs.h \\\n+\t${pstl_srcdir}/execution_impl.h \\\n+\t${pstl_srcdir}/glue_algorithm_defs.h \\\n+\t${pstl_srcdir}/glue_algorithm_impl.h \\\n+\t${pstl_srcdir}/glue_execution_defs.h \\\n+\t${pstl_srcdir}/glue_memory_defs.h \\\n+\t${pstl_srcdir}/glue_memory_impl.h \\\n+\t${pstl_srcdir}/glue_numeric_defs.h \\\n+\t${pstl_srcdir}/glue_numeric_impl.h \\\n+\t${pstl_srcdir}/memory_impl.h \\\n+\t${pstl_srcdir}/numeric_fwd.h \\\n+\t${pstl_srcdir}/numeric_impl.h \\\n+\t${pstl_srcdir}/parallel_backend.h \\\n+\t${pstl_srcdir}/parallel_backend_tbb.h \\\n+\t${pstl_srcdir}/parallel_backend_utils.h \\\n+\t${pstl_srcdir}/parallel_impl.h \\\n+\t${pstl_srcdir}/pstl_config.h \\\n+\t${pstl_srcdir}/unseq_backend_simd.h \\\n+\t${pstl_srcdir}/utils.h\n+\n backward_srcdir = ${glibcxx_srcdir}/include/backward\n backward_builddir = ./backward\n backward_headers = \\\n@@ -1346,7 +1374,7 @@ PCHFLAGS = -x c++-header -nostdinc++ $(CXXFLAGS) $(VTV_PCH_CXXFLAGS)\n # List of all timestamp files.  By keeping only one copy of this list, both\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n-\tstamp-std stamp-bits stamp-bits-sup stamp-c_base stamp-c_compatibility \\\n+\tstamp-std stamp-bits stamp-bits-sup stamp-pstl stamp-c_base stamp-c_compatibility \\\n \tstamp-backward stamp-ext stamp-pb stamp-tr1 stamp-tr2 stamp-decimal \\\n \tstamp-experimental stamp-experimental-bits stamp-debug stamp-parallel \\\n \tstamp-profile stamp-profile-impl stamp-host\n@@ -1362,7 +1390,6 @@ allcreated = \\\n \n # Host includes for threads\n uppercase = [ABCDEFGHIJKLMNOPQRSTUVWXYZ_]\n-\n # By adding these files here, automake will remove them for 'make clean'\n CLEANFILES = ${pch_output} ${pch_output_anchors} stamp-host\n all: all-am\n@@ -1550,6 +1577,11 @@ stamp-bits-sup: stamp-bits ${bits_sup_headers}\n \t@-cd ${bits_builddir} && $(LN_S) ${bits_sup_headers} . 2>/dev/null\n \t@$(STAMP) stamp-bits-sup\n \n+stamp-pstl: ${pstl_headers}\n+\t@-mkdir -p ${pstl_builddir}\n+\t@-cd ${pstl_builddir} && $(LN_S) $? . 2>/dev/null\n+\t@$(STAMP) stamp-pstl\n+\n stamp-c_base: ${c_base_headers}\n \t@-mkdir -p ${c_base_builddir}\n \t@-cd ${c_base_builddir} && $(LN_S) $? . 2>/dev/null\n@@ -1956,6 +1988,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${host_installdir}/../ext\n \tfor file in ${ext_host_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${host_installdir}/../ext; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${pstl_builddir}\n+\tfor file in ${pstl_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${pstl_builddir}; done\n \n # To remove directories.\n clean-local:"}, {"sha": "66420a9a3f25dec59cceaac977ea60dcb554d063", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -665,4 +665,103 @@ namespace std\n # endif\n #endif // GCC\n \n+// PSTL configuration\n+\n+#if __cplusplus >= 201703L\n+// Preserved here so we have some idea which version of upstream we've pulled in\n+// #define PSTL_VERSION 104\n+// #define PSTL_VERSION_MAJOR (PSTL_VERSION/100)\n+// #define PSTL_VERSION_MINOR (PSTL_VERSION - PSTL_VERSION_MAJOR * 100)\n+\n+// For now this defaults to being based on the presence of Thread Building Blocks\n+# ifndef _GLIBCXX_USE_TBB_PAR_BACKEND\n+#  define _GLIBCXX_USE_TBB_PAR_BACKEND __has_include(<tbb/tbb.h>)\n+# endif\n+// This section will need some rework when a new (default) backend type is added\n+# if _GLIBCXX_USE_TBB_PAR_BACKEND\n+#  define __PSTL_USE_PAR_POLICIES 1\n+# endif\n+\n+# if __PSTL_USE_PAR_POLICIES\n+#  if !defined(__PSTL_PAR_BACKEND_TBB)\n+#   define __PSTL_PAR_BACKEND_TBB 1\n+#  endif\n+# else\n+#  undef __PSTL_PAR_BACKEND_TBB\n+# endif\n+\n+# define __PSTL_PRAGMA(x) _Pragma (#x)\n+\n+# define __PSTL_STRING_AUX(x) #x\n+# define __PSTL_STRING(x) __PSTL_STRING_AUX(x)\n+# define __PSTL_STRING_CONCAT(x, y) x#y\n+\n+# define __PSTL_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + \\\n+\t\t\t     __GNUC_PATCHLEVEL__)\n+\n+// Enable SIMD for compilers that support OpenMP 4.0\n+# if (__PSTL_GCC_VERSION >= 40900)\n+#  define __PSTL_PRAGMA_SIMD __PSTL_PRAGMA(omp simd)\n+#define __PSTL_PRAGMA_DECLARE_SIMD __PSTL_PRAGMA(omp declare simd)\n+#  define __PSTL_PRAGMA_SIMD_REDUCTION(PRM) __PSTL_PRAGMA(omp simd reduction(PRM))\n+# else //no simd\n+#  define __PSTL_PRAGMA_SIMD\n+#  define __PSTL_PRAGMA_SIMD_REDUCTION(PRM)\n+# endif //Enable SIMD\n+\n+#define __PSTL_PRAGMA_SIMD_SCAN(PRM)\n+#define __PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM)\n+#define __PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM)\n+\n+#define __PSTL_PRAGMA_FORCEINLINE\n+\n+// Should be defined to 1 for environments with a vendor implementation\n+// of C++17 execution policies\n+// #define __PSTL_CPP17_EXECUTION_POLICIES_PRESENT (_MSC_VER >= 1912)\n+// TODO define libstdc++ policies\n+\n+# define __PSTL_CPP14_2RANGE_MISMATCH_EQUAL_PRESENT \\\n+  (__cplusplus >= 201300L || __cpp_lib_robust_nonmodifying_seq_ops == 201304)\n+# define __PSTL_CPP14_MAKE_REVERSE_ITERATOR_PRESENT \\\n+  (__cplusplus >= 201402L || __cpp_lib_make_reverse_iterator == 201402)\n+# define __PSTL_CPP14_INTEGER_SEQUENCE_PRESENT (__cplusplus >= 201402L)\n+# define __PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT (__cplusplus >= 201402L)\n+\n+# if __PSTL_MONOTONIC_PRESENT\n+#  define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(PRM) \\\n+  __PSTL_PRAGMA(omp ordered simd monotonic(PRM))\n+#  define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(PRM1, PRM2) \\\n+  __PSTL_PRAGMA(omp ordered simd monotonic(PRM1, PRM2))\n+# else\n+#  define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(PRM)\n+#  define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(PRM1, PRM2)\n+# endif\n+\n+// Declaration of reduction functor, where\n+// NAME - the name of the functor\n+// OP - type of the callable object with the reduction operation\n+// omp_in - refers to the local partial result\n+// omp_out - refers to the final value of the combiner operator\n+// omp_priv - refers to the private copy of the initial value\n+// omp_orig - refers to the original variable to be reduced\n+#define __PSTL_PRAGMA_DECLARE_REDUCTION(NAME, OP)                                                                      \\\n+    __PSTL_PRAGMA(omp declare reduction(NAME : OP : omp_out(omp_in)) initializer(omp_priv = omp_orig))\n+\n+# define __PSTL_PRAGMA_VECTOR_UNALIGNED\n+# define __PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED\n+# define __PSTL_PRAGMA_LOCATION\n+\n+# define __PSTL_PRAGMA_MESSAGE_IMPL(x) \\\n+  __PSTL_PRAGMA(message(__PSTL_STRING_CONCAT(__PSTL_PRAGMA_LOCATION, x)))\n+# define __PSTL_PRAGMA_MESSAGE_POLICIES(x) __PSTL_PRAGMA_MESSAGE_IMPL(x)\n+\n+//Too many warnings in output, switched off\n+# define __PSTL_PRAGMA_MESSAGE(x)\n+\n+# if defined(__GLIBCXX__)\n+#  define __PSTL_CPP11_STD_ROTATE_BROKEN \\\n+  (__PSTL_GCC_VERSION < 50100) //GCC 5.1 release\n+# endif\n+\n+#endif\n // End of prewritten config; the settings discovered at configure time follow."}, {"sha": "9eda544c8a810a6b93f55aa4cf436324abec9372", "filename": "libstdc++-v3/include/pstl/LICENSE.txt", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2FLICENSE.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2FLICENSE.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2FLICENSE.txt?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,307 @@\n+==============================================================================\n+The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:\n+==============================================================================\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+    1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+    2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+    3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+    4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+    5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+    6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+    7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+    8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+    9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+    END OF TERMS AND CONDITIONS\n+\n+    APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+    Copyright [yyyy] [name of copyright owner]\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+\n+---- LLVM Exceptions to the Apache 2.0 License ----\n+\n+As an exception, if, as a result of your compiling your source code, portions\n+of this Software are embedded into an Object form of such source code, you\n+may redistribute such embedded portions in such Object form without complying\n+with the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n+\n+In addition, if you combine or link compiled forms of this Software with\n+software that is licensed under the GPLv2 (\"Combined Software\") and if a\n+court of competent jurisdiction determines that the patent provision (Section\n+3), the indemnity provision (Section 9) or other Section of the License\n+conflicts with the conditions of the GPLv2, you may retroactively and\n+prospectively choose to deem waived or otherwise exclude such Section(s) of\n+the License, but only in their entirety and only with respect to the Combined\n+Software.\n+\n+==============================================================================\n+Software from third parties included in the LLVM Project:\n+==============================================================================\n+The LLVM Project contains third party software which is under different license\n+terms. All such code will be identified clearly using at least one of two\n+mechanisms:\n+1) It will be in a separate directory tree with its own `LICENSE.txt` or\n+   `LICENSE` file at the top containing the specific license and restrictions\n+   which apply to that software, or\n+2) It will contain specific license and restriction terms at the top of every\n+   file.\n+\n+==============================================================================\n+Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):\n+==============================================================================\n+\n+The software contained in this directory tree is dual licensed under both the\n+University of Illinois \"BSD-Like\" license and the MIT license.  As a user of\n+this code you may choose to use it under either license.  As a contributor,\n+you agree to allow your code to be used under both.\n+\n+Full text of the relevant licenses is included below.\n+\n+==============================================================================\n+\n+University of Illinois/NCSA\n+Open Source License\n+\n+Copyright (c) 2017-2019 by the contributors listed in CREDITS.TXT\n+\n+All rights reserved.\n+\n+Developed by:\n+    Threading Runtimes Team\n+    Intel Corporation\n+    http://www.intel.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of\n+this software and associated documentation files (the \"Software\"), to deal with\n+the Software without restriction, including without limitation the rights to\n+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n+of the Software, and to permit persons to whom the Software is furnished to do\n+so, subject to the following conditions:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimers.\n+\n+    * Redistributions in binary form must reproduce the above copyright notice,\n+      this list of conditions and the following disclaimers in the\n+      documentation and/or other materials provided with the distribution.\n+\n+    * Neither the names of Intel Corporation Threading Runtimes Team nor the \n+      names of its contributors may be used to endorse or promote products \n+      derived from this Software without specific prior written permission.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE\n+SOFTWARE.\n+\n+==============================================================================\n+\n+Copyright (c) 2017-2019 by the contributors listed in CREDITS.TXT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."}, {"sha": "209c680734251e9a420fc26a977694db51deeb43", "filename": "libstdc++-v3/include/pstl/algorithm_fwd.h", "status": "added", "additions": 1336, "deletions": 0, "changes": 1336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_fwd.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,1336 @@\n+// -*- C++ -*-\n+//===-- algorithm_fwd.h --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_algorithm_fwd_H\n+#define __PSTL_algorithm_fwd_H\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+//------------------------------------------------------------------------\n+// any_of\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Pred>\n+bool\n+__brick_any_of(const _ForwardIterator, const _ForwardIterator, _Pred,\n+               /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _Pred>\n+bool\n+__brick_any_of(const _ForwardIterator, const _ForwardIterator, _Pred,\n+               /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Pred, class _IsVector>\n+bool\n+__pattern_any_of(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Pred, _IsVector,\n+                 /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Pred, class _IsVector>\n+bool\n+__pattern_any_of(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Pred, _IsVector,\n+                 /*parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// walk1 (pseudo)\n+//\n+// walk1 evaluates f(x) for each dereferenced value x drawn from [first,last)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Function>\n+void __brick_walk1(_ForwardIterator, _ForwardIterator, _Function,\n+                   /*vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _Function>\n+void __brick_walk1(_RandomAccessIterator, _RandomAccessIterator, _Function,\n+                   /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Function, class _IsVector>\n+void\n+__pattern_walk1(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Function, _IsVector,\n+                /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Function, class _IsVector>\n+void\n+__pattern_walk1(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Function, _IsVector,\n+                /*parallel=*/std::true_type);\n+#endif\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Brick>\n+void\n+__pattern_walk_brick(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Brick,\n+                     /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Brick>\n+void\n+__pattern_walk_brick(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Brick,\n+                     /*parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// walk1_n\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Size, class _Function>\n+_ForwardIterator __brick_walk1_n(_ForwardIterator, _Size, _Function,\n+                                 /*_IsVectorTag=*/std::false_type);\n+\n+template <class _RandomAccessIterator, class _DifferenceType, class _Function>\n+_RandomAccessIterator __brick_walk1_n(_RandomAccessIterator, _DifferenceType, _Function,\n+                                      /*vectorTag=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Function, class _IsVector>\n+_ForwardIterator\n+__pattern_walk1_n(_ExecutionPolicy&&, _ForwardIterator, _Size, _Function, _IsVector,\n+                  /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size, class _Function, class _IsVector>\n+_RandomAccessIterator\n+__pattern_walk1_n(_ExecutionPolicy&&, _RandomAccessIterator, _Size, _Function, _IsVector,\n+                  /*is_parallel=*/std::true_type);\n+#endif\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Brick>\n+_ForwardIterator\n+__pattern_walk_brick_n(_ExecutionPolicy&&, _ForwardIterator, _Size, _Brick,\n+                       /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size, class _Brick>\n+_RandomAccessIterator\n+__pattern_walk_brick_n(_ExecutionPolicy&&, _RandomAccessIterator, _Size, _Brick,\n+                       /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// walk2 (pseudo)\n+//\n+// walk2 evaluates f(x,y) for deferenced values (x,y) drawn from [first1,last1) and [first2,...)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Function>\n+_ForwardIterator2 __brick_walk2(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Function,\n+                                /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Function>\n+_ForwardIterator2 __brick_walk2(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Function,\n+                                /*vector=*/std::true_type) noexcept;\n+\n+template <class _ForwardIterator1, class _Size, class _ForwardIterator2, class _Function>\n+_ForwardIterator2 __brick_walk2_n(_ForwardIterator1, _Size, _ForwardIterator2, _Function,\n+                                  /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _Size, class _ForwardIterator2, class _Function>\n+_ForwardIterator2 __brick_walk2_n(_ForwardIterator1, _Size, _ForwardIterator2, _Function,\n+                                  /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Function, class _IsVector>\n+_ForwardIterator2\n+__pattern_walk2(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Function, _IsVector,\n+                /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Function, class _IsVector>\n+_ForwardIterator2\n+__pattern_walk2(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Function, _IsVector,\n+                /*parallel=*/std::true_type);\n+#endif\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2, class _Function,\n+          class _IsVector>\n+_ForwardIterator2\n+__pattern_walk2_n(_ExecutionPolicy&&, _ForwardIterator1, _Size, _ForwardIterator2, _Function, _IsVector,\n+                  /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size, class _RandomAccessIterator2,\n+          class _Function, class _IsVector>\n+_RandomAccessIterator2\n+__pattern_walk2_n(_ExecutionPolicy&&, _RandomAccessIterator1, _Size, _RandomAccessIterator2, _Function, _IsVector,\n+                  /*parallel=*/std::true_type);\n+#endif\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Brick>\n+_ForwardIterator2\n+__pattern_walk2_brick(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Brick,\n+                      /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2, class _Brick>\n+_RandomAccessIterator2\n+__pattern_walk2_brick(_ExecutionPolicy&&, _RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                      _Brick,\n+                      /*parallel=*/std::true_type);\n+#endif\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2, class _Brick>\n+_ForwardIterator2\n+__pattern_walk2_brick_n(_ExecutionPolicy&&, _ForwardIterator1, _Size, _ForwardIterator2, _Brick,\n+                        /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size, class _RandomAccessIterator2, class _Brick>\n+_RandomAccessIterator2\n+__pattern_walk2_brick_n(_ExecutionPolicy&&, _RandomAccessIterator1, _Size, _RandomAccessIterator2, _Brick,\n+                        /*parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// walk3 (pseudo)\n+//\n+// walk3 evaluates f(x,y,z) for (x,y,z) drawn from [first1,last1), [first2,...), [first3,...)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator3, class _Function>\n+_ForwardIterator3 __brick_walk3(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator3, _Function,\n+                                /*vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator1, class _RandomAccessIterator2, class _RandomAccessIterator3, class _Function>\n+_RandomAccessIterator3 __brick_walk3(_RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                                     _RandomAccessIterator3, _Function,\n+                                     /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator3,\n+          class _Function, class _IsVector>\n+_ForwardIterator3\n+__pattern_walk3(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator3,\n+                _Function, _IsVector,\n+                /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2,\n+          class _RandomAccessIterator3, class _Function, class _IsVector>\n+_RandomAccessIterator3\n+__pattern_walk3(_ExecutionPolicy&&, _RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                _RandomAccessIterator3, _Function, _IsVector, /*parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// equal\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+bool __brick_equal(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _BinaryPredicate,\n+                   /* IsVector = */ std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator1, class _RandomAccessIterator2, class _BinaryPredicate>\n+bool __brick_equal(_RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2, _BinaryPredicate,\n+                   /* is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+bool\n+__pattern_equal(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _BinaryPredicate,\n+                _IsVector,\n+                /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+bool\n+__pattern_equal(_ExecutionPolicy&&, _RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                _BinaryPredicate, _IsVector,\n+                /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// find_if\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Predicate>\n+_ForwardIterator __brick_find_if(_ForwardIterator, _ForwardIterator, _Predicate,\n+                                 /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _Predicate>\n+_RandomAccessIterator __brick_find_if(_RandomAccessIterator, _RandomAccessIterator, _Predicate,\n+                                      /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate, class _IsVector>\n+_ForwardIterator\n+__pattern_find_if(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Predicate, _IsVector,\n+                  /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate, class _IsVector>\n+_ForwardIterator\n+__pattern_find_if(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Predicate, _IsVector,\n+                  /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// find_end\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1 __brick_find_end(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                   _BinaryPredicate,\n+                                   /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1 __brick_find_end(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                   _BinaryPredicate,\n+                                   /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+_ForwardIterator1\n+__pattern_find_end(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                   _BinaryPredicate, _IsVector,\n+                   /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+_ForwardIterator1\n+__pattern_find_end(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                   _BinaryPredicate, _IsVector,\n+                   /*is_parallel=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// find_first_of\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1 __brick_find_first_of(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                        _BinaryPredicate,\n+                                        /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1 __brick_find_first_of(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                        _BinaryPredicate,\n+                                        /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+_ForwardIterator1\n+__pattern_find_first_of(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                        _BinaryPredicate, _IsVector, /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+_ForwardIterator1\n+__pattern_find_first_of(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                        _BinaryPredicate, _IsVector, /*is_parallel=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// search\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1 __brick_search(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                 _BinaryPredicate,\n+                                 /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1 __brick_search(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                 _BinaryPredicate,\n+                                 /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+_ForwardIterator1\n+__pattern_search(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                 _BinaryPredicate, _IsVector,\n+                 /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate,\n+          class _IsVector>\n+_ForwardIterator1\n+__pattern_search(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                 _BinaryPredicate, _IsVector,\n+                 /*is_parallel=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// search_n\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\n+_ForwardIterator\n+__brick_search_n(_ForwardIterator, _ForwardIterator, _Size, const _Tp&, _BinaryPredicate,\n+                 /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\n+_ForwardIterator\n+__brick_search_n(_ForwardIterator, _ForwardIterator, _Size, const _Tp&, _BinaryPredicate,\n+                 /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate,\n+          class IsVector>\n+_ForwardIterator\n+__pattern_search_n(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Size, const _Tp&, _BinaryPredicate,\n+                   IsVector,\n+                   /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size, class _Tp, class _BinaryPredicate,\n+          class IsVector>\n+_RandomAccessIterator\n+__pattern_search_n(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Size, const _Tp&,\n+                   _BinaryPredicate, IsVector,\n+                   /*is_parallel=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// copy_n\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Size, class _OutputIterator>\n+_OutputIterator __brick_copy_n(_ForwardIterator, _Size, _OutputIterator,\n+                               /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _Size, class _OutputIterator>\n+_OutputIterator __brick_copy_n(_ForwardIterator, _Size, _OutputIterator,\n+                               /*vector=*/std::true_type) noexcept;\n+\n+//------------------------------------------------------------------------\n+// copy\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator __brick_copy(_ForwardIterator, _ForwardIterator, _OutputIterator,\n+                             /*vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _OutputIterator>\n+_OutputIterator __brick_copy(_RandomAccessIterator, _RandomAccessIterator, _OutputIterator,\n+                             /*vector=*/std::true_type) noexcept;\n+\n+//------------------------------------------------------------------------\n+// move\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator __brick_move(_ForwardIterator, _ForwardIterator, _OutputIterator,\n+                             /*vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _OutputIterator>\n+_OutputIterator __brick_move(_RandomAccessIterator, _RandomAccessIterator, _OutputIterator,\n+                             /*vector=*/std::true_type) noexcept;\n+\n+//------------------------------------------------------------------------\n+// swap_ranges\n+//------------------------------------------------------------------------\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator\n+__brick_swap_ranges(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                    /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator\n+__brick_swap_ranges(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                    /*vector=*/std::true_type) noexcept;\n+\n+//------------------------------------------------------------------------\n+// copy_if\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryPredicate>\n+_OutputIterator __brick_copy_if(_ForwardIterator, _ForwardIterator, _OutputIterator, _UnaryPredicate,\n+                                /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryPredicate>\n+_OutputIterator __brick_copy_if(_ForwardIterator, _ForwardIterator, _OutputIterator, _UnaryPredicate,\n+                                /*vector=*/std::true_type) noexcept;\n+\n+template <class _DifferenceType, class _ForwardIterator, class _UnaryPredicate>\n+std::pair<_DifferenceType, _DifferenceType>\n+__brick_calc_mask_1(_ForwardIterator, _ForwardIterator, bool* __restrict, _UnaryPredicate,\n+                    /*vector=*/std::false_type) noexcept;\n+template <class _DifferenceType, class _RandomAccessIterator, class _UnaryPredicate>\n+std::pair<_DifferenceType, _DifferenceType>\n+__brick_calc_mask_1(_RandomAccessIterator, _RandomAccessIterator, bool* __restrict, _UnaryPredicate,\n+                    /*vector=*/std::true_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+void\n+__brick_copy_by_mask(_ForwardIterator, _ForwardIterator, _OutputIterator, bool*,\n+                     /*vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+void\n+__brick_copy_by_mask(_ForwardIterator, _ForwardIterator, _OutputIterator, bool* __restrict,\n+                     /*vector=*/std::true_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator1, class _OutputIterator2>\n+void\n+__brick_partition_by_mask(_ForwardIterator, _ForwardIterator, _OutputIterator1, _OutputIterator2, bool*,\n+                          /*vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _OutputIterator1, class _OutputIterator2>\n+void\n+__brick_partition_by_mask(_RandomAccessIterator, _RandomAccessIterator, _OutputIterator1, _OutputIterator2, bool*,\n+                          /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _UnaryPredicate, class _IsVector>\n+_OutputIterator\n+__pattern_copy_if(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _OutputIterator, _UnaryPredicate, _IsVector,\n+                  /*parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator, class _UnaryPredicate,\n+          class _IsVector>\n+_OutputIterator\n+__pattern_copy_if(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _OutputIterator, _UnaryPredicate,\n+                  _IsVector, /*parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// count\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Predicate>\n+typename std::iterator_traits<_ForwardIterator>::difference_type\n+    __brick_count(_ForwardIterator, _ForwardIterator, _Predicate,\n+                  /* is_vector = */ std::true_type) noexcept;\n+\n+template <class _ForwardIterator, class _Predicate>\n+typename std::iterator_traits<_ForwardIterator>::difference_type\n+    __brick_count(_ForwardIterator, _ForwardIterator, _Predicate,\n+                  /* is_vector = */ std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate, class _IsVector>\n+typename std::iterator_traits<_ForwardIterator>::difference_type\n+__pattern_count(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Predicate,\n+                /* is_parallel */ std::false_type, _IsVector) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate, class _IsVector>\n+typename std::iterator_traits<_ForwardIterator>::difference_type\n+__pattern_count(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Predicate,\n+                /* is_parallel */ std::true_type, _IsVector);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// unique\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _BinaryPredicate>\n+_ForwardIterator __brick_unique(_ForwardIterator, _ForwardIterator, _BinaryPredicate,\n+                                /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _BinaryPredicate>\n+_ForwardIterator __brick_unique(_ForwardIterator, _ForwardIterator, _BinaryPredicate,\n+                                /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_unique(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _BinaryPredicate, _IsVector,\n+                 /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_unique(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _BinaryPredicate, _IsVector,\n+                 /*is_parallel=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// unique_copy\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class OutputIterator, class _BinaryPredicate>\n+OutputIterator __brick_unique_copy(_ForwardIterator, _ForwardIterator, OutputIterator, _BinaryPredicate,\n+                                   /*vector=*/std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _OutputIterator, class _BinaryPredicate>\n+_OutputIterator __brick_unique_copy(_RandomAccessIterator, _RandomAccessIterator, _OutputIterator, _BinaryPredicate,\n+                                    /*vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class OutputIterator, class _BinaryPredicate, class _IsVector>\n+OutputIterator __pattern_unique_copy(_ForwardIterator, _ForwardIterator, OutputIterator, _BinaryPredicate, _IsVector,\n+                                     /*parallel=*/std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _DifferenceType, class _RandomAccessIterator, class _BinaryPredicate>\n+_DifferenceType\n+__brick_calc_mask_2(_RandomAccessIterator, _RandomAccessIterator, bool* __restrict, _BinaryPredicate,\n+                    /*vector=*/std::false_type) noexcept;\n+\n+template <class _DifferenceType, class _RandomAccessIterator, class _BinaryPredicate>\n+_DifferenceType\n+__brick_calc_mask_2(_RandomAccessIterator, _RandomAccessIterator, bool* __restrict, _BinaryPredicate,\n+                    /*vector=*/std::true_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator, class _BinaryPredicate,\n+          class _IsVector>\n+_OutputIterator\n+__pattern_unique_copy(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _OutputIterator,\n+                      _BinaryPredicate, _IsVector, /*parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// reverse\n+//------------------------------------------------------------------------\n+\n+template <class _BidirectionalIterator>\n+void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator,\n+                     /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _BidirectionalIterator>\n+void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator,\n+                     /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _BidirectionalIterator>\n+void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator,\n+                     /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _BidirectionalIterator>\n+void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator,\n+                     /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _IsVector>\n+void\n+__pattern_reverse(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _IsVector,\n+                  /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _IsVector>\n+void\n+__pattern_reverse(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _IsVector,\n+                  /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// reverse_copy\n+//------------------------------------------------------------------------\n+\n+template <class _BidirectionalIterator, class _OutputIterator>\n+_OutputIterator __brick_reverse_copy(_BidirectionalIterator, _BidirectionalIterator, _OutputIterator,\n+                                     /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _BidirectionalIterator, class _OutputIterator>\n+_OutputIterator __brick_reverse_copy(_BidirectionalIterator, _BidirectionalIterator, _OutputIterator,\n+                                     /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _OutputIterator, class _IsVector>\n+_OutputIterator\n+__pattern_reverse_copy(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _OutputIterator, _IsVector,\n+                       /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _OutputIterator, class _IsVector>\n+_OutputIterator\n+__pattern_reverse_copy(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _OutputIterator, _IsVector,\n+                       /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// rotate\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator>\n+_ForwardIterator __brick_rotate(_ForwardIterator, _ForwardIterator, _ForwardIterator,\n+                                /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator>\n+_ForwardIterator __brick_rotate(_ForwardIterator, _ForwardIterator, _ForwardIterator,\n+                                /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _IsVector>\n+_ForwardIterator\n+__pattern_rotate(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _ForwardIterator, _IsVector,\n+                 /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _IsVector>\n+_ForwardIterator\n+__pattern_rotate(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _ForwardIterator, _IsVector,\n+                 /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// rotate_copy\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator __brick_rotate_copy(_ForwardIterator, _ForwardIterator, _ForwardIterator, _OutputIterator,\n+                                    /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator __brick_rotate_copy(_ForwardIterator, _ForwardIterator, _ForwardIterator, _OutputIterator,\n+                                    /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _IsVector>\n+_OutputIterator\n+__pattern_rotate_copy(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _ForwardIterator, _OutputIterator,\n+                      _IsVector,\n+                      /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _IsVector>\n+_OutputIterator\n+__pattern_rotate_copy(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _ForwardIterator, _OutputIterator,\n+                      _IsVector,\n+                      /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// is_partitioned\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _UnaryPredicate>\n+bool __brick_is_partitioned(_ForwardIterator, _ForwardIterator, _UnaryPredicate,\n+                            /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _UnaryPredicate>\n+bool __brick_is_partitioned(_ForwardIterator, _ForwardIterator, _UnaryPredicate,\n+                            /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _IsVector>\n+bool\n+__pattern_is_partitioned(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _UnaryPredicate, _IsVector,\n+                         /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _IsVector>\n+bool\n+__pattern_is_partitioned(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _UnaryPredicate, _IsVector,\n+                         /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// partition\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _UnaryPredicate>\n+_ForwardIterator __brick_partition(_ForwardIterator, _ForwardIterator, _UnaryPredicate,\n+                                   /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _UnaryPredicate>\n+_ForwardIterator __brick_partition(_ForwardIterator, _ForwardIterator, _UnaryPredicate,\n+                                   /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_partition(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _UnaryPredicate, _IsVector,\n+                    /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_partition(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _UnaryPredicate, _IsVector,\n+                    /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// stable_partition\n+//------------------------------------------------------------------------\n+\n+template <class _BidirectionalIterator, class _UnaryPredicate>\n+_BidirectionalIterator __brick_stable_partition(_BidirectionalIterator, _BidirectionalIterator, _UnaryPredicate,\n+                                                /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _BidirectionalIterator, class _UnaryPredicate>\n+_BidirectionalIterator __brick_stable_partition(_BidirectionalIterator, _BidirectionalIterator, _UnaryPredicate,\n+                                                /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate, class _IsVector>\n+_BidirectionalIterator\n+__pattern_stable_partition(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _UnaryPredicate,\n+                           _IsVector,\n+                           /*is_parallelization=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate, class _IsVector>\n+_BidirectionalIterator\n+__pattern_stable_partition(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _UnaryPredicate,\n+                           _IsVector,\n+                           /*is_parallelization=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// partition_copy\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator1, class _OutputIterator2, class _UnaryPredicate>\n+std::pair<_OutputIterator1, _OutputIterator2>\n+    __brick_partition_copy(_ForwardIterator, _ForwardIterator, _OutputIterator1, _OutputIterator2, _UnaryPredicate,\n+                           /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator1, class _OutputIterator2, class _UnaryPredicate>\n+std::pair<_OutputIterator1, _OutputIterator2>\n+    __brick_partition_copy(_ForwardIterator, _ForwardIterator, _OutputIterator1, _OutputIterator2, _UnaryPredicate,\n+                           /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator1, class _OutputIterator2,\n+          class _UnaryPredicate, class _IsVector>\n+std::pair<_OutputIterator1, _OutputIterator2>\n+__pattern_partition_copy(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _OutputIterator1, _OutputIterator2,\n+                         _UnaryPredicate, _IsVector,\n+                         /*is_parallelization=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator1, class _OutputIterator2,\n+          class _UnaryPredicate, class _IsVector>\n+std::pair<_OutputIterator1, _OutputIterator2>\n+__pattern_partition_copy(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _OutputIterator1,\n+                         _OutputIterator2, _UnaryPredicate, _IsVector,\n+                         /*is_parallelization=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// sort\n+//------------------------------------------------------------------------\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector,\n+          class _IsMoveConstructible>\n+void\n+__pattern_sort(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare, _IsVector /*is_vector*/,\n+               /*is_parallel=*/std::false_type, _IsMoveConstructible) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_sort(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare, _IsVector /*is_vector*/,\n+               /*is_parallel=*/std::true_type,\n+               /*is_move_constructible=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// stable_sort\n+//------------------------------------------------------------------------\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_stable_sort(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare,\n+                      _IsVector /*is_vector*/,\n+                      /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_stable_sort(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare,\n+                      _IsVector /*is_vector*/,\n+                      /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// partial_sort\n+//------------------------------------------------------------------------\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_partial_sort(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator,\n+                       _Compare, _IsVector,\n+                       /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_partial_sort(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator,\n+                       _Compare, _IsVector,\n+                       /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// partial_sort_copy\n+//------------------------------------------------------------------------\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator, class _Compare, class _IsVector>\n+_RandomAccessIterator\n+__pattern_partial_sort_copy(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _RandomAccessIterator,\n+                            _RandomAccessIterator, _Compare, _IsVector,\n+                            /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator, class _Compare, class _IsVector>\n+_RandomAccessIterator\n+__pattern_partial_sort_copy(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _RandomAccessIterator,\n+                            _RandomAccessIterator, _Compare, _IsVector,\n+                            /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// adjacent_find\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _BinaryPredicate>\n+_ForwardIterator\n+__brick_adjacent_find(_ForwardIterator, _ForwardIterator, _BinaryPredicate,\n+                      /* IsVector = */ std::true_type, bool) noexcept;\n+\n+template <class _ForwardIterator, class _BinaryPredicate>\n+_ForwardIterator\n+__brick_adjacent_find(_ForwardIterator, _ForwardIterator, _BinaryPredicate,\n+                      /* IsVector = */ std::false_type, bool) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_adjacent_find(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _BinaryPredicate,\n+                        /* is_parallel */ std::false_type, _IsVector, bool) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _BinaryPredicate, class _IsVector>\n+_RandomAccessIterator\n+__pattern_adjacent_find(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _BinaryPredicate,\n+                        /* is_parallel */ std::true_type, _IsVector, bool);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// nth_element\n+//------------------------------------------------------------------------\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_nth_element(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator, _Compare,\n+                      _IsVector,\n+                      /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+void\n+__pattern_nth_element(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator, _Compare,\n+                      _IsVector,\n+                      /*is_parallel=*/std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// fill, fill_n\n+//------------------------------------------------------------------------\n+template <class _ForwardIterator, class _Tp>\n+void\n+__brick_fill(_ForwardIterator, _ForwardIterator, const _Tp&,\n+             /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ForwardIterator, class _Tp>\n+void\n+__brick_fill(_ForwardIterator, _ForwardIterator, const _Tp&,\n+             /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _IsVector>\n+void\n+__pattern_fill(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, const _Tp&,\n+               /*is_parallel=*/std::false_type, _IsVector) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _IsVector>\n+_ForwardIterator\n+__pattern_fill(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, const _Tp&,\n+               /*is_parallel=*/std::true_type, _IsVector);\n+#endif\n+\n+template <class _OutputIterator, class _Size, class _Tp>\n+_OutputIterator\n+__brick_fill_n(_OutputIterator, _Size, const _Tp&,\n+               /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _OutputIterator, class _Size, class _Tp>\n+_OutputIterator\n+__brick_fill_n(_OutputIterator, _Size, const _Tp&,\n+               /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp, class _IsVector>\n+_OutputIterator\n+__pattern_fill_n(_ExecutionPolicy&&, _OutputIterator, _Size, const _Tp&,\n+                 /*is_parallel=*/std::false_type, _IsVector) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp, class _IsVector>\n+_OutputIterator\n+__pattern_fill_n(_ExecutionPolicy&&, _OutputIterator, _Size, const _Tp&,\n+                 /*is_parallel=*/std::true_type, _IsVector);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// generate, generate_n\n+//------------------------------------------------------------------------\n+\n+template <class _RandomAccessIterator, class _Generator>\n+void __brick_generate(_RandomAccessIterator, _RandomAccessIterator, _Generator,\n+                      /* is_vector = */ std::true_type) noexcept;\n+\n+template <class _ForwardIterator, class _Generator>\n+void __brick_generate(_ForwardIterator, _ForwardIterator, _Generator,\n+                      /* is_vector = */ std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Generator, class _IsVector>\n+void\n+__pattern_generate(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Generator,\n+                   /*is_parallel=*/std::false_type, _IsVector) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Generator, class _IsVector>\n+_ForwardIterator\n+__pattern_generate(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Generator,\n+                   /*is_parallel=*/std::true_type, _IsVector);\n+#endif\n+\n+template <class OutputIterator, class Size, class _Generator>\n+OutputIterator __brick_generate_n(OutputIterator, Size, _Generator,\n+                                  /* is_vector = */ std::true_type) noexcept;\n+\n+template <class OutputIterator, class Size, class _Generator>\n+OutputIterator __brick_generate_n(OutputIterator, Size, _Generator,\n+                                  /* is_vector = */ std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class OutputIterator, class Size, class _Generator, class _IsVector>\n+OutputIterator\n+__pattern_generate_n(_ExecutionPolicy&&, OutputIterator, Size, _Generator,\n+                     /*is_parallel=*/std::false_type, _IsVector) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class OutputIterator, class Size, class _Generator, class _IsVector>\n+OutputIterator\n+__pattern_generate_n(_ExecutionPolicy&&, OutputIterator, Size, _Generator,\n+                     /*is_parallel=*/std::true_type, _IsVector);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// remove\n+//------------------------------------------------------------------------\n+template <class _ForwardIterator, class _UnaryPredicate>\n+_ForwardIterator __brick_remove_if(_ForwardIterator, _ForwardIterator, _UnaryPredicate,\n+                                   /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _UnaryPredicate>\n+_RandomAccessIterator __brick_remove_if(_RandomAccessIterator, _RandomAccessIterator, _UnaryPredicate,\n+                                        /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_remove_if(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _UnaryPredicate, _IsVector,\n+                    /*is_parallel*/ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _IsVector>\n+_ForwardIterator\n+__pattern_remove_if(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _UnaryPredicate, _IsVector,\n+                    /*is_parallel*/ std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// merge\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_merge(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                              _OutputIterator, _Compare,\n+                              /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_merge(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                              _OutputIterator, _Compare,\n+                              /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_merge(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                _OutputIterator, _Compare, _IsVector, /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_merge(_ExecutionPolicy&&, _RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                _RandomAccessIterator2, _OutputIterator, _Compare, _IsVector,\n+                /* is_parallel = */ std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// inplace_merge\n+//------------------------------------------------------------------------\n+\n+template <class _BidirectionalIterator, class _Compare>\n+void __brick_inplace_merge(_BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator, _Compare,\n+                           /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _BidirectionalIterator, class _Compare>\n+void __brick_inplace_merge(_BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator, _Compare,\n+                           /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare, class _IsVector>\n+void\n+__pattern_inplace_merge(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator,\n+                        _Compare, _IsVector,\n+                        /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare, class _IsVector>\n+void\n+__pattern_inplace_merge(_ExecutionPolicy&&, _BidirectionalIterator, _BidirectionalIterator, _BidirectionalIterator,\n+                        _Compare, _IsVector,\n+                        /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// includes\n+//------------------------------------------------------------------------\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare, class _IsVector>\n+bool\n+__pattern_includes(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                   _Compare, _IsVector,\n+                   /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare, class _IsVector>\n+bool\n+__pattern_includes(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                   _Compare, _IsVector,\n+                   /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// set_union\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_union(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                  _OutputIterator, _Compare,\n+                                  /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_union(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                  _OutputIterator, _Compare,\n+                                  /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_union(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                    _OutputIterator, _Compare, _IsVector, /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_union(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                    _OutputIterator, _Compare, _IsVector, /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// set_intersection\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_intersection(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                         _OutputIterator, _Compare,\n+                                         /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_intersection(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                         _OutputIterator, _Compare,\n+                                         /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_intersection(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                           _ForwardIterator2, _OutputIterator, _Compare, _IsVector,\n+                           /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_intersection(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                           _ForwardIterator2, _OutputIterator, _Compare, _IsVector, /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// set_difference\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_difference(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                       _OutputIterator, _Compare,\n+                                       /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_difference(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                       _OutputIterator, _Compare,\n+                                       /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_difference(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                         _OutputIterator, _Compare, _IsVector, /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_difference(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                         _OutputIterator, _Compare, _IsVector, /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// set_symmetric_difference\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_symmetric_difference(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator2, _OutputIterator, _Compare,\n+                                                 /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator, class _Compare>\n+_OutputIterator __brick_set_symmetric_difference(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator2, _OutputIterator, _Compare,\n+                                                 /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_symmetric_difference(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                                   _ForwardIterator2, _OutputIterator, _Compare, _IsVector,\n+                                   /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _OutputIterator,\n+          class _Compare, class _IsVector>\n+_OutputIterator\n+__pattern_set_symmetric_difference(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                                   _ForwardIterator2, _OutputIterator, _Compare, _IsVector,\n+                                   /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// is_heap_until\n+//------------------------------------------------------------------------\n+\n+template <class _RandomAccessIterator, class _Compare>\n+_RandomAccessIterator __brick_is_heap_until(_RandomAccessIterator, _RandomAccessIterator, _Compare,\n+                                            /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _RandomAccessIterator, class _Compare>\n+_RandomAccessIterator __brick_is_heap_until(_RandomAccessIterator, _RandomAccessIterator, _Compare,\n+                                            /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+_RandomAccessIterator\n+__pattern_is_heap_until(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare, _IsVector,\n+                        /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare, class _IsVector>\n+_RandomAccessIterator\n+__pattern_is_heap_until(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare, _IsVector,\n+                        /* is_parallel = */ std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// min_element\n+//------------------------------------------------------------------------\n+\n+template <typename _ForwardIterator, typename _Compare>\n+_ForwardIterator __brick_min_element(_ForwardIterator, _ForwardIterator, _Compare,\n+                                     /* __is_vector = */ std::false_type) noexcept;\n+\n+template <typename _ForwardIterator, typename _Compare>\n+_ForwardIterator __brick_min_element(_ForwardIterator, _ForwardIterator, _Compare,\n+                                     /* __is_vector = */ std::true_type) noexcept;\n+\n+template <typename _ExecutionPolicy, typename _ForwardIterator, typename _Compare, typename _IsVector>\n+_ForwardIterator\n+__pattern_min_element(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Compare, _IsVector,\n+                      /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <typename _ExecutionPolicy, typename _RandomAccessIterator, typename _Compare, typename _IsVector>\n+_RandomAccessIterator\n+__pattern_min_element(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _Compare, _IsVector,\n+                      /* is_parallel = */ std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// minmax_element\n+//------------------------------------------------------------------------\n+\n+template <typename _ForwardIterator, typename _Compare>\n+std::pair<_ForwardIterator, _ForwardIterator> __brick_minmax_element(_ForwardIterator, _ForwardIterator, _Compare,\n+                                                                     /* __is_vector = */ std::false_type) noexcept;\n+\n+template <typename _ForwardIterator, typename _Compare>\n+std::pair<_ForwardIterator, _ForwardIterator> __brick_minmax_element(_ForwardIterator, _ForwardIterator, _Compare,\n+                                                                     /* __is_vector = */ std::true_type) noexcept;\n+\n+template <typename _ExecutionPolicy, typename _ForwardIterator, typename _Compare, typename _IsVector>\n+std::pair<_ForwardIterator, _ForwardIterator>\n+__pattern_minmax_element(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Compare, _IsVector,\n+                         /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <typename _ExecutionPolicy, typename _ForwardIterator, typename _Compare, typename _IsVector>\n+std::pair<_ForwardIterator, _ForwardIterator>\n+__pattern_minmax_element(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Compare, _IsVector,\n+                         /* is_parallel = */ std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// mismatch\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n+std::pair<_ForwardIterator1, _ForwardIterator2> __brick_mismatch(_ForwardIterator1, _ForwardIterator1,\n+                                                                 _ForwardIterator2, _ForwardIterator2, _Predicate,\n+                                                                 /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n+std::pair<_ForwardIterator1, _ForwardIterator2> __brick_mismatch(_ForwardIterator1, _ForwardIterator1,\n+                                                                 _ForwardIterator2, _ForwardIterator2, _Predicate,\n+                                                                 /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate, class _IsVector>\n+std::pair<_ForwardIterator1, _ForwardIterator2>\n+__pattern_mismatch(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                   _Predicate, _IsVector,\n+                   /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2, class _Predicate,\n+          class _IsVector>\n+std::pair<_RandomAccessIterator1, _RandomAccessIterator2>\n+__pattern_mismatch(_ExecutionPolicy&&, _RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                   _RandomAccessIterator2, _Predicate, _IsVector, /* is_parallel = */ std::true_type) noexcept;\n+#endif\n+\n+//------------------------------------------------------------------------\n+// lexicographical_compare\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Compare>\n+bool __brick_lexicographical_compare(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                     _Compare,\n+                                     /* __is_vector = */ std::false_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Compare>\n+bool __brick_lexicographical_compare(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,\n+                                     _Compare,\n+                                     /* __is_vector = */ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare, class _IsVector>\n+bool\n+__pattern_lexicographical_compare(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                                  _ForwardIterator2, _Compare, _IsVector, /* is_parallel = */ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare, class _IsVector>\n+bool\n+__pattern_lexicographical_compare(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2,\n+                                  _ForwardIterator2, _Compare, _IsVector, /* is_parallel = */ std::true_type) noexcept;\n+#endif\n+\n+} // namespace __internal\n+} // namespace __pstl\n+#endif /* __PSTL_algorithm_fwd_H */"}, {"sha": "9d8242873ab7dfd304c48dedfe148ad8261dfb1d", "filename": "libstdc++-v3/include/pstl/algorithm_impl.h", "status": "added", "additions": 3661, "deletions": 0, "changes": 3661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Falgorithm_impl.h?ref=061f457868281238db43ef784aa12269cc866adb"}, {"sha": "be8a4a321d3db96cc284c42cf8ae0ac53aae28fa", "filename": "libstdc++-v3/include/pstl/execution_defs.h", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_defs.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,162 @@\n+// -*- C++ -*-\n+//===-- execution_defs.h --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_execution_policy_defs_H\n+#define __PSTL_execution_policy_defs_H\n+\n+#include <type_traits>\n+\n+namespace __pstl\n+{\n+namespace execution\n+{\n+inline namespace v1\n+{\n+\n+// 2.4, Sequential execution policy\n+class sequenced_policy\n+{\n+  public:\n+    // For internal use only\n+    static constexpr std::false_type\n+    __allow_unsequenced()\n+    {\n+        return std::false_type{};\n+    }\n+    static constexpr std::false_type\n+    __allow_vector()\n+    {\n+        return std::false_type{};\n+    }\n+    static constexpr std::false_type\n+    __allow_parallel()\n+    {\n+        return std::false_type{};\n+    }\n+};\n+\n+#if __PSTL_USE_PAR_POLICIES\n+// 2.5, Parallel execution policy\n+class parallel_policy\n+{\n+  public:\n+    // For internal use only\n+    static constexpr std::false_type\n+    __allow_unsequenced()\n+    {\n+        return std::false_type{};\n+    }\n+    static constexpr std::false_type\n+    __allow_vector()\n+    {\n+        return std::false_type{};\n+    }\n+    static constexpr std::true_type\n+    __allow_parallel()\n+    {\n+        return std::true_type{};\n+    }\n+};\n+\n+// 2.6, Parallel+Vector execution policy\n+class parallel_unsequenced_policy\n+{\n+  public:\n+    // For internal use only\n+    static constexpr std::true_type\n+    __allow_unsequenced()\n+    {\n+        return std::true_type{};\n+    }\n+    static constexpr std::true_type\n+    __allow_vector()\n+    {\n+        return std::true_type{};\n+    }\n+    static constexpr std::true_type\n+    __allow_parallel()\n+    {\n+        return std::true_type{};\n+    }\n+};\n+#endif\n+\n+class unsequenced_policy\n+{\n+  public:\n+    // For internal use only\n+    static constexpr std::true_type\n+    __allow_unsequenced()\n+    {\n+        return std::true_type{};\n+    }\n+    static constexpr std::true_type\n+    __allow_vector()\n+    {\n+        return std::true_type{};\n+    }\n+    static constexpr std::false_type\n+    __allow_parallel()\n+    {\n+        return std::false_type{};\n+    }\n+};\n+\n+// 2.8, Execution policy objects\n+constexpr sequenced_policy seq{};\n+#if __PSTL_USE_PAR_POLICIES\n+constexpr parallel_policy par{};\n+constexpr parallel_unsequenced_policy par_unseq{};\n+#endif\n+constexpr unsequenced_policy unseq{};\n+\n+// 2.3, Execution policy type trait\n+template <class T>\n+struct is_execution_policy : std::false_type\n+{\n+};\n+\n+template <>\n+struct is_execution_policy<sequenced_policy> : std::true_type\n+{\n+};\n+#if __PSTL_USE_PAR_POLICIES\n+template <>\n+struct is_execution_policy<parallel_policy> : std::true_type\n+{\n+};\n+template <>\n+struct is_execution_policy<parallel_unsequenced_policy> : std::true_type\n+{\n+};\n+#endif\n+template <>\n+struct is_execution_policy<unsequenced_policy> : std::true_type\n+{\n+};\n+\n+#if __PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT\n+template <class T>\n+constexpr bool is_execution_policy_v = is_execution_policy<T>::value;\n+#endif\n+\n+} // namespace v1\n+} // namespace execution\n+\n+namespace __internal\n+{\n+template <class ExecPolicy, class T>\n+using __enable_if_execution_policy =\n+    typename std::enable_if<__pstl::execution::is_execution_policy<typename std::decay<ExecPolicy>::type>::value,\n+                            T>::type;\n+} // namespace __internal\n+\n+} // namespace __pstl\n+\n+#endif /* __PSTL_execution_policy_defs_H */"}, {"sha": "f33e6fc849bc46023e9e1383b26b7f2962e36cf3", "filename": "libstdc++-v3/include/pstl/execution_impl.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fexecution_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,155 @@\n+// -*- C++ -*-\n+//===-- execution_impl.h --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_execution_impl_H\n+#define __PSTL_execution_impl_H\n+\n+#include <iterator>\n+#include <type_traits>\n+\n+#include \"execution_defs.h\"\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+using namespace __pstl::execution;\n+\n+/* predicate */\n+\n+template <typename _Tp>\n+std::false_type __lazy_and(_Tp, std::false_type)\n+{\n+    return std::false_type{};\n+};\n+\n+template <typename _Tp>\n+inline _Tp\n+__lazy_and(_Tp __a, std::true_type)\n+{\n+    return __a;\n+}\n+\n+template <typename _Tp>\n+std::true_type __lazy_or(_Tp, std::true_type)\n+{\n+    return std::true_type{};\n+};\n+\n+template <typename _Tp>\n+inline _Tp\n+__lazy_or(_Tp __a, std::false_type)\n+{\n+    return __a;\n+}\n+\n+/* iterator */\n+template <typename _IteratorType, typename... _OtherIteratorTypes>\n+struct __is_random_access_iterator\n+{\n+    static constexpr bool value =\n+        __is_random_access_iterator<_IteratorType>::value && __is_random_access_iterator<_OtherIteratorTypes...>::value;\n+    typedef std::integral_constant<bool, value> type;\n+};\n+\n+template <typename _IteratorType>\n+struct __is_random_access_iterator<_IteratorType>\n+    : std::is_same<typename std::iterator_traits<_IteratorType>::iterator_category, std::random_access_iterator_tag>\n+{\n+};\n+\n+/* policy */\n+template <typename Policy>\n+struct __policy_traits\n+{\n+};\n+\n+template <>\n+struct __policy_traits<sequenced_policy>\n+{\n+    typedef std::false_type allow_parallel;\n+    typedef std::false_type allow_unsequenced;\n+    typedef std::false_type allow_vector;\n+};\n+\n+template <>\n+struct __policy_traits<unsequenced_policy>\n+{\n+    typedef std::false_type allow_parallel;\n+    typedef std::true_type allow_unsequenced;\n+    typedef std::true_type allow_vector;\n+};\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <>\n+struct __policy_traits<parallel_policy>\n+{\n+    typedef std::true_type allow_parallel;\n+    typedef std::false_type allow_unsequenced;\n+    typedef std::false_type allow_vector;\n+};\n+\n+template <>\n+struct __policy_traits<parallel_unsequenced_policy>\n+{\n+    typedef std::true_type allow_parallel;\n+    typedef std::true_type allow_unsequenced;\n+    typedef std::true_type allow_vector;\n+};\n+#endif\n+\n+template <typename _ExecutionPolicy>\n+using __collector_t = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__collector_type;\n+\n+template <typename _ExecutionPolicy>\n+using __allow_vector = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_vector;\n+\n+template <typename _ExecutionPolicy>\n+using __allow_unsequenced = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_unsequenced;\n+\n+template <typename _ExecutionPolicy>\n+using __allow_parallel = typename __policy_traits<typename std::decay<_ExecutionPolicy>::type>::__allow_parallel;\n+\n+template <typename _ExecutionPolicy, typename... _IteratorTypes>\n+auto\n+__is_vectorization_preferred(_ExecutionPolicy&& __exec)\n+    -> decltype(__lazy_and(__exec.__allow_vector(), typename __is_random_access_iterator<_IteratorTypes...>::type()))\n+{\n+    return __lazy_and(__exec.__allow_vector(), typename __is_random_access_iterator<_IteratorTypes...>::type());\n+}\n+\n+template <typename _ExecutionPolicy, typename... _IteratorTypes>\n+auto\n+__is_parallelization_preferred(_ExecutionPolicy&& __exec)\n+    -> decltype(__lazy_and(__exec.__allow_parallel(), typename __is_random_access_iterator<_IteratorTypes...>::type()))\n+{\n+    return __lazy_and(__exec.__allow_parallel(), typename __is_random_access_iterator<_IteratorTypes...>::type());\n+}\n+\n+template <typename policy, typename... _IteratorTypes>\n+struct __prefer_unsequenced_tag\n+{\n+    static constexpr bool value =\n+        __allow_unsequenced<policy>::value && __is_random_access_iterator<_IteratorTypes...>::value;\n+    typedef std::integral_constant<bool, value> type;\n+};\n+\n+template <typename policy, typename... _IteratorTypes>\n+struct __prefer_parallel_tag\n+{\n+    static constexpr bool value =\n+        __allow_parallel<policy>::value && __is_random_access_iterator<_IteratorTypes...>::value;\n+    typedef std::integral_constant<bool, value> type;\n+};\n+\n+} // namespace __internal\n+} // namespace __pstl\n+\n+#endif /* __PSTL_execution_impl_H */"}, {"sha": "c622ed3a762e923633226d642c9cd6d55c316495", "filename": "libstdc++-v3/include/pstl/glue_algorithm_defs.h", "status": "added", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_defs.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,551 @@\n+// -*- C++ -*-\n+//===-- glue_algorithm_defs.h ---------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_algorithm_defs_H\n+#define __PSTL_glue_algorithm_defs_H\n+\n+#include <functional>\n+\n+#include \"execution_defs.h\"\n+\n+namespace std\n+{\n+\n+// [alg.any_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+any_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n+\n+// [alg.all_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+all_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n+\n+// [alg.none_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+none_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n+\n+// [alg.foreach]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Function>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Function __f);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Function>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+for_each_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, _Function __f);\n+\n+// [alg.find]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+find_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+find_if_not(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n+\n+// [alg.find.end]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+         _ForwardIterator2 __s_last, _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+         _ForwardIterator2 __s_last);\n+\n+// [alg.find_first_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last);\n+\n+// [alg.adjacent_find]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred);\n+\n+// [alg.count]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n+                                                 typename iterator_traits<_ForwardIterator>::difference_type>\n+count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n+                                                 typename iterator_traits<_ForwardIterator>::difference_type>\n+count_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n+\n+// [alg.search]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+       _ForwardIterator2 __s_last, _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+       _ForwardIterator2 __s_last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,\n+         const _Tp& __value, _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,\n+         const _Tp& __value);\n+\n+// [alg.copy]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+copy_n(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Size __n, _ForwardIterator2 __result);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 result,\n+        _Predicate __pred);\n+\n+// [alg.swap]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+            _ForwardIterator2 __first2);\n+\n+// [alg.transform]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+          _UnaryOperation __op);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+          _ForwardIterator __result, _BinaryOperation __op);\n+\n+// [alg.replace]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+replace_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,\n+           const _Tp& __new_value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+replace(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value,\n+        const _Tp& __new_value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryPredicate, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+replace_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                _ForwardIterator2 __result, _UnaryPredicate __pred, const _Tp& __new_value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+replace_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+             const _Tp& __old_value, const _Tp& __new_value);\n+\n+// [alg.fill]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, const _Tp& __value);\n+\n+// [alg.generate]\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+generate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Generator __g);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Generator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+generate_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size count, _Generator __g);\n+\n+// [alg.remove]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+remove_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _Predicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+remove_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+            const _Tp& __value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+remove_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+remove(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n+\n+// [alg.unique]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+            _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result);\n+\n+// [alg.reverse]\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last);\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,\n+             _ForwardIterator __d_first);\n+\n+// [alg.rotate]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+rotate_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __middle, _ForwardIterator1 __last,\n+            _ForwardIterator2 __result);\n+\n+// [alg.partitions]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _BidirectionalIterator>\n+stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,\n+                 _UnaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardIterator1, class _ForwardIterator2,\n+          class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+partition_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n+               _ForwardIterator1 __out_true, _ForwardIterator2 __out_false, _UnaryPredicate __pred);\n+\n+// [alg.sort]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);\n+\n+// [stable.sort]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);\n+\n+// [mismatch]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2, _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _BinaryPredicate __pred);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);\n+\n+// [alg.equal]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _BinaryPredicate __p);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2, _BinaryPredicate __p);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2);\n+\n+// [alg.move]\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+move(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __d_first);\n+\n+// [partial.sort]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,\n+             _RandomAccessIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,\n+             _RandomAccessIterator __last);\n+\n+// [partial.sort.copy]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n+                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n+                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last);\n+\n+// [is.sorted]\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+// [alg.nth.element]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,\n+            _RandomAccessIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,\n+            _RandomAccessIterator __last);\n+\n+// [alg.merge]\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2, _ForwardIterator __d_first);\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,\n+              _BidirectionalIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,\n+              _BidirectionalIterator __last);\n+\n+// [includes]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2);\n+\n+// [set.union]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+          _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+          _ForwardIterator2 __last2, _ForwardIterator __result);\n+\n+// [set.intersection]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);\n+\n+// [set.difference]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);\n+\n+// [set.symmetric.difference]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator result,\n+                         _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);\n+\n+// [is.heap]\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);\n+\n+// [alg.min.max]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>\n+minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>\n+minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+// [alg.lex.comparison]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                        _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                        _ForwardIterator2 __first2, _ForwardIterator2 __last2);\n+\n+} // namespace std\n+#endif /* __PSTL_glue_algorithm_defs_H */"}, {"sha": "88ce93fca41687f7b7f0f3b5da0c5a286207c8c2", "filename": "libstdc++-v3/include/pstl/glue_algorithm_impl.h", "status": "added", "additions": 1182, "deletions": 0, "changes": 1182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_algorithm_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,1182 @@\n+// -*- C++ -*-\n+//===-- glue_algorithm_impl.h ---------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_algorithm_impl_H\n+#define __PSTL_glue_algorithm_impl_H\n+\n+#include <functional>\n+\n+#include \"execution_defs.h\"\n+#include \"utils.h\"\n+#include \"algorithm_fwd.h\"\n+#include \"numeric_fwd.h\" /* count and count_if use __pattern_transform_reduce */\n+\n+namespace std\n+{\n+\n+// [alg.any_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+any_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_any_of(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+// [alg.all_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Pred>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+all_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Pred __pred)\n+{\n+    return !std::any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                        __pstl::__internal::__not_pred<_Pred>(__pred));\n+}\n+\n+// [alg.none_of]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+none_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n+{\n+    return !std::any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred);\n+}\n+\n+// [alg.foreach]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Function>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Function __f)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last, __f,\n+                                __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+                                __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Function>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+for_each_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, _Function __f)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_walk1_n(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __n, __f,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+// [alg.find]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+find_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_find_if(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+find_if_not(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n+{\n+    return std::find_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                        __pstl::__internal::__not_pred<_Predicate>(__pred));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n+{\n+    return std::find_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                        __pstl::__internal::__equal_value<_Tp>(__value));\n+}\n+\n+// [alg.find.end]\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+         _ForwardIterator2 __s_last, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_find_end(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+         _ForwardIterator2 __s_last)\n+{\n+    return std::find_end(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last,\n+                         __pstl::__internal::__pstl_equal());\n+}\n+\n+// [alg.find_first_of]\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_find_first_of(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last)\n+{\n+    return std::find_first_of(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last,\n+                              __pstl::__internal::__pstl_equal());\n+}\n+\n+// [alg.adjacent_find]\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    using namespace __pstl;\n+    return __internal::__pattern_adjacent_find(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, std::equal_to<_ValueType>(),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec), /*first_semantic*/ false);\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_adjacent_find(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec), /*first_semantic*/ false);\n+}\n+\n+// [alg.count]\n+\n+// Implementation note: count and count_if call the pattern directly instead of calling std::transform_reduce\n+// so that we do not have to include <numeric>.\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n+                                                 typename iterator_traits<_ForwardIterator>::difference_type>\n+count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    using namespace __pstl;\n+    return __internal::__pattern_count(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+        [&__value](const _ValueType& __x) { return __value == __x; },\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n+                                                 typename iterator_traits<_ForwardIterator>::difference_type>\n+count_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_count(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+// [alg.search]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+       _ForwardIterator2 __s_last, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_search(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>\n+search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+       _ForwardIterator2 __s_last)\n+{\n+    return std::search(std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first, __s_last,\n+                       __pstl::__internal::__pstl_equal());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,\n+         const _Tp& __value, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_search_n(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __count, __value, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,\n+         const _Tp& __value)\n+{\n+    return std::search_n(std::forward<_ExecutionPolicy>(__exec), __first, __last, __count, __value,\n+                         std::equal_to<typename iterator_traits<_ForwardIterator>::value_type>());\n+}\n+\n+// [alg.copy]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result)\n+{\n+    using namespace __pstl;\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);\n+\n+    return __internal::__pattern_walk2_brick(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+        [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _ForwardIterator2 __res) {\n+            return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n+        },\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+copy_n(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Size __n, _ForwardIterator2 __result)\n+{\n+    using namespace __pstl;\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);\n+\n+    return __internal::__pattern_walk2_brick_n(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+        [__is_vector](_ForwardIterator1 __begin, _Size __sz, _ForwardIterator2 __res) {\n+            return __internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n+        },\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+        _Predicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_copy_if(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+// [alg.swap]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+            _ForwardIterator2 __first2)\n+{\n+    using namespace __pstl;\n+    typedef typename iterator_traits<_ForwardIterator1>::reference _ReferenceType1;\n+    typedef typename iterator_traits<_ForwardIterator2>::reference _ReferenceType2;\n+    return __internal::__pattern_walk2(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n+        [](_ReferenceType1 __x, _ReferenceType2 __y) {\n+            using std::swap;\n+            swap(__x, __y);\n+        },\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+// [alg.transform]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+          _UnaryOperation __op)\n+{\n+    typedef typename iterator_traits<_ForwardIterator1>::reference _InputType;\n+    typedef typename iterator_traits<_ForwardIterator2>::reference _OutputType;\n+    using namespace __pstl;\n+    return __internal::__pattern_walk2(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+        [__op](_InputType __x, _OutputType __y) mutable { __y = __op(__x); },\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+          _ForwardIterator __result, _BinaryOperation __op)\n+{\n+    typedef typename iterator_traits<_ForwardIterator1>::reference _Input1Type;\n+    typedef typename iterator_traits<_ForwardIterator2>::reference _Input2Type;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _OutputType;\n+    using namespace __pstl;\n+    return __internal::__pattern_walk3(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __result,\n+        [__op](_Input1Type x, _Input2Type y, _OutputType z) mutable { z = __op(x, y); },\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                   _ForwardIterator>(__exec));\n+}\n+\n+// [alg.replace]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+replace_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,\n+           const _Tp& __new_value)\n+{\n+    using namespace __pstl;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ElementType;\n+    __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                [&__pred, &__new_value](_ElementType __elem) {\n+                                    if (__pred(__elem))\n+                                    {\n+                                        __elem = __new_value;\n+                                    }\n+                                },\n+                                __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+                                __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+replace(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value,\n+        const _Tp& __new_value)\n+{\n+    std::replace_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                    __pstl::__internal::__equal_value<_Tp>(__old_value), __new_value);\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryPredicate, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+replace_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                _ForwardIterator2 __result, _UnaryPredicate __pred, const _Tp& __new_value)\n+{\n+    typedef typename iterator_traits<_ForwardIterator1>::reference _InputType;\n+    typedef typename iterator_traits<_ForwardIterator2>::reference _OutputType;\n+    using namespace __pstl;\n+    return __internal::__pattern_walk2(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+        [__pred, &__new_value](_InputType __x, _OutputType __y) mutable { __y = __pred(__x) ? __new_value : __x; },\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+replace_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+             const _Tp& __old_value, const _Tp& __new_value)\n+{\n+    return std::replace_copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                                __pstl::__internal::__equal_value<_Tp>(__old_value), __new_value);\n+}\n+\n+// [alg.fill]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_fill(std::forward<_ExecutionPolicy>(__exec), __first, __last, __value,\n+                               __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+                               __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, const _Tp& __value)\n+{\n+    if (__count <= 0)\n+        return __first;\n+\n+    using namespace __pstl;\n+    return __internal::__pattern_fill_n(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __count, __value,\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+// [alg.generate]\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+generate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Generator __g)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_generate(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __g,\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Generator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+generate_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, _Generator __g)\n+{\n+    if (__count <= 0)\n+        return __first;\n+\n+    using namespace __pstl;\n+    return __internal::__pattern_generate_n(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __count, __g,\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+// [alg.remove]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+remove_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _Predicate __pred)\n+{\n+    return std::copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                        __pstl::__internal::__not_pred<_Predicate>(__pred));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+remove_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+            const _Tp& __value)\n+{\n+    return std::copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                        __pstl::__internal::__not_equal_value<_Tp>(__value));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+remove_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_remove_if(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+remove(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n+{\n+    return std::remove_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                          __pstl::__internal::__equal_value<_Tp>(__value));\n+}\n+\n+// [alg.unique]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_unique(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    return std::unique(std::forward<_ExecutionPolicy>(__exec), __first, __last, __pstl::__internal::__pstl_equal());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,\n+            _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_unique_copy(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result)\n+{\n+    return std::unique_copy(__exec, __first, __last, __result, __pstl::__internal::__pstl_equal());\n+}\n+\n+// [alg.reverse]\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_reverse(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,\n+             _ForwardIterator __d_first)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_reverse_copy(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(__exec));\n+}\n+\n+// [alg.rotate]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_rotate(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+rotate_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __middle, _ForwardIterator1 __last,\n+            _ForwardIterator2 __result)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_rotate_copy(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __result,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+// [alg.partitions]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_is_partitioned(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_partition(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _BidirectionalIterator>\n+stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,\n+                 _UnaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_stable_partition(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardIterator1, class _ForwardIterator2,\n+          class _UnaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+partition_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n+               _ForwardIterator1 __out_true, _ForwardIterator2 __out_false, _UnaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_partition_copy(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __out_true, __out_false, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator, _ForwardIterator1,\n+                                                 _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator, _ForwardIterator1,\n+                                                   _ForwardIterator2>(__exec));\n+}\n+\n+// [alg.sort]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n+{\n+    typedef typename iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    using namespace __pstl;\n+    return __internal::__pattern_sort(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        typename std::is_move_constructible<_InputType>::type());\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    std::sort(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+}\n+\n+// [stable.sort]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_stable_sort(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    std::stable_sort(__exec, __first, __last, std::less<_InputType>());\n+}\n+\n+// [mismatch]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2, _BinaryPredicate __pred)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_mismatch(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __pred,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _BinaryPredicate __pred)\n+{\n+    return std::mismatch(__exec, __first1, __last1, __first2, std::next(__first2, std::distance(__first1, __last1)),\n+                         __pred);\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2)\n+{\n+    return std::mismatch(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n+                         __pstl::__internal::__pstl_equal());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>\n+mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n+{\n+    //TODO: to get rid of \"distance\"\n+    return std::mismatch(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n+                         std::next(__first2, std::distance(__first1, __last1)));\n+}\n+\n+// [alg.equal]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _BinaryPredicate __p)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_equal(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __p,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n+{\n+    return std::equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n+                      __pstl::__internal::__pstl_equal());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2, _BinaryPredicate __p)\n+{\n+    //TODO: to get rid of \"distance\"\n+    if (std::distance(__first1, __last1) == std::distance(__first2, __last2))\n+        return std::equal(__first1, __last1, __first2, __p);\n+    else\n+        return false;\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2)\n+{\n+    return equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,\n+                 __pstl::__internal::__pstl_equal());\n+}\n+\n+// [alg.move]\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+move(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __d_first)\n+{\n+    using namespace __pstl;\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);\n+\n+    return __internal::__pattern_walk2_brick(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,\n+        [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end, _ForwardIterator2 __res) {\n+            return __internal::__brick_move(__begin, __end, __res, __is_vector);\n+        },\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+// [partial.sort]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,\n+             _RandomAccessIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_partial_sort(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,\n+             _RandomAccessIterator __last)\n+{\n+    typedef typename iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    std::partial_sort(__exec, __first, __middle, __last, std::less<_InputType>());\n+}\n+\n+// [partial.sort.copy]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n+                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_partial_sort_copy(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __d_last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,\n+                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last)\n+{\n+    return std::partial_sort_copy(std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __d_last,\n+                                  __pstl::__internal::__pstl_less());\n+}\n+\n+// [is.sorted]\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    const _ForwardIterator __res = __internal::__pattern_adjacent_find(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __pstl::__internal::__reorder_pred<_Compare>(__comp),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec), /*first_semantic*/ false);\n+    return __res == __last ? __last : std::next(__res);\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator>::value_type _InputType;\n+    return is_sorted_until(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_adjacent_find(\n+               std::forward<_ExecutionPolicy>(__exec), __first, __last, __internal::__reorder_pred<_Compare>(__comp),\n+               __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+               __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+               /*or_semantic*/ true) == __last;\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator>::value_type _InputType;\n+    return std::is_sorted(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+}\n+\n+// [alg.merge]\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_merge(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __d_first, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                   _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+      _ForwardIterator2 __last2, _ForwardIterator __d_first)\n+{\n+    return std::merge(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __d_first,\n+                      __pstl::__internal::__pstl_less());\n+}\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,\n+              _BidirectionalIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_inplace_merge(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _BidirectionalIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _BidirectionalIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,\n+              _BidirectionalIterator __last)\n+{\n+    typedef typename std::iterator_traits<_BidirectionalIterator>::value_type _InputType;\n+    std::inplace_merge(__exec, __first, __middle, __last, std::less<_InputType>());\n+}\n+\n+// [includes]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_includes(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+         _ForwardIterator2 __last2)\n+{\n+    return std::includes(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n+                         __pstl::__internal::__pstl_less());\n+}\n+\n+// [set.union]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+          _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_set_union(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                   _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,\n+          _ForwardIterator2 __last2, _ForwardIterator __result)\n+{\n+    return std::set_union(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+                          __pstl::__internal::__pstl_less());\n+}\n+\n+// [set.intersection]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_set_intersection(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                   _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result)\n+{\n+    return std::set_intersection(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+                                 __pstl::__internal::__pstl_less());\n+}\n+\n+// [set.difference]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_set_difference(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                   _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result)\n+{\n+    return std::set_difference(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result,\n+                               __pstl::__internal::__pstl_less());\n+}\n+\n+// [set.symmetric.difference]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,\n+          class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result,\n+                         _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_set_symmetric_difference(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __result, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                 _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,\n+                                                   _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result)\n+{\n+    return std::set_symmetric_difference(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n+                                         __result, __pstl::__internal::__pstl_less());\n+}\n+\n+// [is.heap]\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_is_heap_until(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>\n+is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    return std::is_heap_until(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n+{\n+    return std::is_heap_until(std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp) == __last;\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    return std::is_heap(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+}\n+\n+// [alg.min.max]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_min_element(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator>::value_type _InputType;\n+    return std::min_element(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_InputType>());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n+{\n+    return min_element(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                       __pstl::__internal::__reorder_pred<_Compare>(__comp));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator>::value_type _InputType;\n+    return std::min_element(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                            __pstl::__internal::__reorder_pred<std::less<_InputType>>(std::less<_InputType>()));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>\n+minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_minmax_element(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>\n+minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    return std::minmax_element(std::forward<_ExecutionPolicy>(__exec), __first, __last, std::less<_ValueType>());\n+}\n+\n+// [alg.nth.element]\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,\n+            _RandomAccessIterator __last, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    __internal::__pattern_nth_element(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __nth, __last, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _RandomAccessIterator>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _RandomAccessIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,\n+            _RandomAccessIterator __last)\n+{\n+    typedef typename iterator_traits<_RandomAccessIterator>::value_type _InputType;\n+    std::nth_element(std::forward<_ExecutionPolicy>(__exec), __first, __nth, __last, std::less<_InputType>());\n+}\n+\n+// [alg.lex.comparison]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                        _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_lexicographical_compare(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2, __comp,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>\n+lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                        _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n+{\n+    return std::lexicographical_compare(std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __last2,\n+                                        __pstl::__internal::__pstl_less());\n+}\n+\n+} // namespace std\n+\n+#endif /* __PSTL_glue_algorithm_impl_H */"}, {"sha": "dacd038cea5701f47de3c917d00e55e37c60c352", "filename": "libstdc++-v3/include/pstl/glue_execution_defs.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_execution_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_execution_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_execution_defs.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,56 @@\n+// -*- C++ -*-\n+//===-- glue_execution_defs.h ---------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_execution_defs_H\n+#define __PSTL_glue_execution_defs_H\n+\n+#include <type_traits>\n+\n+#include \"execution_defs.h\"\n+\n+namespace std\n+{\n+// Type trait\n+using __pstl::execution::is_execution_policy;\n+#if __PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT\n+#if __INTEL_COMPILER\n+template <class T>\n+constexpr bool is_execution_policy_v = is_execution_policy<T>::value;\n+#else\n+using __pstl::execution::is_execution_policy_v;\n+#endif\n+#endif\n+\n+namespace execution\n+{\n+// Standard C++ policy classes\n+using __pstl::execution::sequenced_policy;\n+#if __PSTL_USE_PAR_POLICIES\n+using __pstl::execution::parallel_policy;\n+using __pstl::execution::parallel_unsequenced_policy;\n+#endif\n+// Standard predefined policy instances\n+using __pstl::execution::seq;\n+#if __PSTL_USE_PAR_POLICIES\n+using __pstl::execution::par;\n+using __pstl::execution::par_unseq;\n+#endif\n+// Implementation-defined names\n+// Unsequenced policy is not yet standard, but for consistency\n+// we include it into namespace std::execution as well\n+using __pstl::execution::unseq;\n+using __pstl::execution::unsequenced_policy;\n+} // namespace execution\n+} // namespace std\n+\n+#include \"algorithm_impl.h\"\n+#include \"numeric_impl.h\"\n+#include \"parallel_backend.h\"\n+\n+#endif /* __PSTL_glue_execution_defs_H */"}, {"sha": "79e4ed71f7dcfd49d4929b8e19b676e84d95be11", "filename": "libstdc++-v3/include/pstl/glue_memory_defs.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_defs.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,79 @@\n+// -*- C++ -*-\n+//===-- glue_memory_defs.h ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_memory_defs_H\n+#define __PSTL_glue_memory_defs_H\n+\n+#include \"execution_defs.h\"\n+\n+namespace std\n+{\n+\n+// [uninitialized.copy]\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result);\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result);\n+\n+// [uninitialized.move]\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result);\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_move_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result);\n+\n+// [uninitialized.fill]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+uninitialized_fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, const _Tp& __value);\n+\n+// [specialized.destroy]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+destroy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+destroy_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);\n+\n+// [uninitialized.construct.default]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+uninitialized_default_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_default_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);\n+\n+// [uninitialized.construct.value]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+uninitialized_value_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_value_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);\n+\n+} //  namespace std\n+#endif /* __PSTL_glue_memory_defs_H */"}, {"sha": "4cde9bac51c5680e395a31f825a9d38fdbc79062", "filename": "libstdc++-v3/include/pstl/glue_memory_impl.h", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_memory_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,358 @@\n+// -*- C++ -*-\n+//===-- glue_memory_impl.h ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_memory_impl_H\n+#define __PSTL_glue_memory_impl_H\n+\n+#include \"utils.h\"\n+#include \"algorithm_fwd.h\"\n+\n+namespace std\n+{\n+\n+// [uninitialized.copy]\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result)\n+{\n+    typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n+    typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel =\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n+        [&]() {\n+            return __internal::__pattern_walk2_brick(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                [__is_vector](_InputIterator __begin, _InputIterator __end, _ForwardIterator __res) {\n+                    return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n+                },\n+                __is_parallel);\n+        },\n+        [&]() {\n+            return __internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                                               [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                   ::new (std::addressof(__val2)) _ValueType2(__val1);\n+                                               },\n+                                               __is_vector, __is_parallel);\n+        });\n+}\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result)\n+{\n+    typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n+    typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel =\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n+        [&]() {\n+            return __internal::__pattern_walk2_brick_n(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+                [__is_vector](_InputIterator __begin, _Size __sz, _ForwardIterator __res) {\n+                    return __internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n+                },\n+                __is_parallel);\n+        },\n+        [&]() {\n+            return __internal::__pattern_walk2_n(std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+                                                 [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                     ::new (std::addressof(__val2)) _ValueType2(__val1);\n+                                                 },\n+                                                 __is_vector, __is_parallel);\n+        });\n+}\n+\n+// [uninitialized.move]\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result)\n+{\n+    typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n+    typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel =\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n+        [&]() {\n+            return __internal::__pattern_walk2_brick(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                [__is_vector](_InputIterator __begin, _InputIterator __end, _ForwardIterator __res) {\n+                    return __internal::__brick_copy(__begin, __end, __res, __is_vector);\n+                },\n+                __is_parallel);\n+        },\n+        [&]() {\n+            return __internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                                               [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                   ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));\n+                                               },\n+                                               __is_vector, __is_parallel);\n+        });\n+}\n+\n+template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_move_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result)\n+{\n+    typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;\n+    typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel =\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+    const auto __is_vector =\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::integral_constant < bool, std::is_trivial<_ValueType1>::value&& std::is_trivial<_ValueType2>::value > (),\n+        [&]() {\n+            return __internal::__pattern_walk2_brick_n(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+                [__is_vector](_InputIterator __begin, _Size __sz, _ForwardIterator __res) {\n+                    return __internal::__brick_copy_n(__begin, __sz, __res, __is_vector);\n+                },\n+                __is_parallel);\n+        },\n+        [&]() {\n+            return __internal::__pattern_walk2_n(std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,\n+                                                 [](_ReferenceType1 __val1, _ReferenceType2 __val2) {\n+                                                     ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));\n+                                                 },\n+                                                 __is_vector, __is_parallel);\n+        });\n+}\n+\n+// [uninitialized.fill]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+uninitialized_fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    __internal::__invoke_if_else(std::is_arithmetic<_ValueType>(),\n+                                 [&]() {\n+                                     __internal::__pattern_walk_brick(\n+                                         std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                         [&__value, &__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n+                                             __internal::__brick_fill(__begin, __end, _ValueType(__value), __is_vector);\n+                                         },\n+                                         __is_parallel);\n+                                 },\n+                                 [&]() {\n+                                     __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first,\n+                                                                 __last,\n+                                                                 [&__value](_ReferenceType __val) {\n+                                                                     ::new (std::addressof(__val)) _ValueType(__value);\n+                                                                 },\n+                                                                 __is_vector, __is_parallel);\n+                                 });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, const _Tp& __value)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::is_arithmetic<_ValueType>(),\n+        [&]() {\n+            return __internal::__pattern_walk_brick_n(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                [&__value, &__is_vector](_ForwardIterator __begin, _Size __count) {\n+                    return __internal::__brick_fill_n(__begin, __count, _ValueType(__value), __is_vector);\n+                },\n+                __is_parallel);\n+        },\n+        [&]() {\n+            return __internal::__pattern_walk1_n(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                [&__value](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(__value); }, __is_vector,\n+                __is_parallel);\n+        });\n+}\n+\n+// [specialized.destroy]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+destroy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    __internal::__invoke_if_not(std::is_trivially_destructible<_ValueType>(), [&]() {\n+        __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                    [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector, __is_parallel);\n+    });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+destroy_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::is_trivially_destructible<_ValueType>(), [&]() { return std::next(__first, __n); },\n+        [&]() {\n+            return __internal::__pattern_walk1_n(std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                                                 [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector,\n+                                                 __is_parallel);\n+        });\n+}\n+\n+// [uninitialized.construct.default]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+uninitialized_default_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    __internal::__invoke_if_not(std::is_trivial<_ValueType>(), [&]() {\n+        __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                    [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; }, __is_vector,\n+                                    __is_parallel);\n+    });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_default_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(std::is_trivial<_ValueType>(), [&]() { return std::next(__first, __n); },\n+                                        [&]() {\n+                                            return __internal::__pattern_walk1_n(\n+                                                std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                                                [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; },\n+                                                __is_vector, __is_parallel);\n+                                        });\n+}\n+\n+// [uninitialized.construct.value]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>\n+uninitialized_value_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    __internal::__invoke_if_else(\n+        std::is_trivial<_ValueType>(),\n+        [&]() {\n+            __internal::__pattern_walk_brick(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                             [__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {\n+                                                 __internal::__brick_fill(__begin, __end, _ValueType(), __is_vector);\n+                                             },\n+                                             __is_parallel);\n+        },\n+        [&]() {\n+            __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                        [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(); },\n+                                        __is_vector, __is_parallel);\n+        });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Size>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>\n+uninitialized_value_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;\n+    using namespace __pstl;\n+\n+    const auto __is_parallel = __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+    const auto __is_vector = __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec);\n+\n+    return __internal::__invoke_if_else(\n+        std::is_trivial<_ValueType>(),\n+        [&]() {\n+            return __internal::__pattern_walk_brick_n(std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                                                      [__is_vector](_ForwardIterator __begin, _Size __count) {\n+                                                          return __internal::__brick_fill_n(__begin, __count,\n+                                                                                            _ValueType(), __is_vector);\n+                                                      },\n+                                                      __is_parallel);\n+        },\n+        [&]() {\n+            return __internal::__pattern_walk1_n(\n+                std::forward<_ExecutionPolicy>(__exec), __first, __n,\n+                [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType(); }, __is_vector, __is_parallel);\n+        });\n+}\n+\n+} // namespace std\n+\n+#endif /* __PSTL_glue_memory_imple_H */"}, {"sha": "55187f1f6ea2c86e7675bf243b82d2555f96af87", "filename": "libstdc++-v3/include/pstl/glue_numeric_defs.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_defs.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,116 @@\n+// -*- C++ -*-\n+//===-- glue_numeric_defs.h -----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_numeric_defs_H\n+#define __PSTL_glue_numeric_defs_H\n+\n+#include \"execution_defs.h\"\n+\n+namespace std\n+{\n+// [reduce]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n+       _BinaryOperation __binary_op);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n+                                                 typename iterator_traits<_ForwardIterator>::value_type>\n+reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _Tp __init);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1,\n+          class _BinaryOperation2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1,\n+                 _BinaryOperation2 __binary_op2);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n+                 _BinaryOperation __binary_op, _UnaryOperation __unary_op);\n+\n+// [exclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _Tp __init);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>\n+_ForwardIterator2\n+exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op);\n+\n+// [inclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _BinaryOperation __binary_op);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _BinaryOperation __binary_op, _Tp __init);\n+\n+// [transform.exclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation,\n+          class _UnaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform_exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                         _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op,\n+                         _UnaryOperation __unary_op);\n+\n+// [transform.inclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation,\n+          class _UnaryOperation, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform_inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                         _ForwardIterator2 __result, _BinaryOperation __binary_op, _UnaryOperation __unary_op,\n+                         _Tp __init);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation,\n+          class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform_inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                         _ForwardIterator2 __result, _BinaryOperation __binary_op, _UnaryOperation __unary_op);\n+\n+// [adjacent.difference]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                    _ForwardIterator2 __d_first, _BinaryOperation op);\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                    _ForwardIterator2 __d_first);\n+\n+} // namespace std\n+#endif /* __PSTL_glue_numeric_defs_H */"}, {"sha": "bde0b03f3fb1dcdb30bcb139b4728901b620ba5b", "filename": "libstdc++-v3/include/pstl/glue_numeric_impl.h", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fglue_numeric_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,224 @@\n+// -*- C++ -*-\n+//===-- glue_numeric_impl.h -----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_glue_numeric_impl_H\n+#define __PSTL_glue_numeric_impl_H\n+\n+#include <functional>\n+\n+#include \"utils.h\"\n+#include \"numeric_fwd.h\"\n+\n+namespace std\n+{\n+\n+// [reduce]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n+       _BinaryOperation __binary_op)\n+{\n+    return transform_reduce(std::forward<_ExecutionPolicy>(__exec), __first, __last, __init, __binary_op,\n+                            __pstl::__internal::__no_op());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init)\n+{\n+    return transform_reduce(std::forward<_ExecutionPolicy>(__exec), __first, __last, __init, std::plus<_Tp>(),\n+                            __pstl::__internal::__no_op());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\n+                                                 typename iterator_traits<_ForwardIterator>::value_type>\n+reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last)\n+{\n+    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    return transform_reduce(std::forward<_ExecutionPolicy>(__exec), __first, __last, _ValueType{},\n+                            std::plus<_ValueType>(), __pstl::__internal::__no_op());\n+}\n+\n+// [transform.reduce]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _Tp __init)\n+{\n+    typedef typename iterator_traits<_ForwardIterator1>::value_type _InputType;\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_reduce(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __init, std::plus<_InputType>(),\n+        std::multiplies<_InputType>(),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1,\n+          class _BinaryOperation2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                 _ForwardIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_reduce(\n+        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __init, __binary_op1, __binary_op2,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>\n+transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n+                 _BinaryOperation __binary_op, _UnaryOperation __unary_op)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_reduce(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __init, __binary_op, __unary_op,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator>(__exec));\n+}\n+\n+// [exclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _Tp __init)\n+{\n+    return transform_exclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __init,\n+                                    std::plus<_Tp>(), __pstl::__internal::__no_op());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>\n+_ForwardIterator2\n+exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op)\n+{\n+    return transform_exclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __init,\n+                                    __binary_op, __pstl::__internal::__no_op());\n+}\n+\n+// [inclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result)\n+{\n+    typedef typename iterator_traits<_ForwardIterator1>::value_type _InputType;\n+    return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,\n+                                    std::plus<_InputType>(), __pstl::__internal::__no_op());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _BinaryOperation __binary_op)\n+{\n+    return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __binary_op,\n+                                    __pstl::__internal::__no_op());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+               _ForwardIterator2 __result, _BinaryOperation __binary_op, _Tp __init)\n+{\n+    return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __binary_op,\n+                                    __pstl::__internal::__no_op(), __init);\n+}\n+\n+// [transform.exclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation,\n+          class _UnaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform_exclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                         _ForwardIterator2 __result, _Tp __init, _BinaryOperation __binary_op,\n+                         _UnaryOperation __unary_op)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_scan(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __unary_op, __init, __binary_op,\n+        /*inclusive=*/std::false_type(),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+// [transform.inclusive.scan]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation,\n+          class _UnaryOperation, class _Tp>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform_inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                         _ForwardIterator2 __result, _BinaryOperation __binary_op, _UnaryOperation __unary_op,\n+                         _Tp __init)\n+{\n+    using namespace __pstl;\n+    return __internal::__pattern_transform_scan(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __unary_op, __init, __binary_op,\n+        /*inclusive=*/std::true_type(),\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation,\n+          class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+transform_inclusive_scan(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                         _ForwardIterator2 __result, _BinaryOperation __binary_op, _UnaryOperation __unary_op)\n+{\n+    if (__first != __last)\n+    {\n+        auto __tmp = __unary_op(*__first);\n+        *__result = __tmp;\n+        return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec), ++__first, __last, ++__result,\n+                                        __binary_op, __unary_op, __tmp);\n+    }\n+    else\n+    {\n+        return __result;\n+    }\n+}\n+\n+// [adjacent.difference]\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                    _ForwardIterator2 __d_first, _BinaryOperation __op)\n+{\n+\n+    if (__first == __last)\n+        return __d_first;\n+\n+    using namespace __pstl;\n+    return __internal::__pattern_adjacent_difference(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __op,\n+        __internal::__is_vectorization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),\n+        __internal::__is_parallelization_preferred<_ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>\n+__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>\n+adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                    _ForwardIterator2 __d_first)\n+{\n+    typedef typename iterator_traits<_ForwardIterator1>::value_type _ValueType;\n+    return adjacent_difference(std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,\n+                               std::minus<_ValueType>());\n+}\n+\n+} // namespace std\n+\n+#endif /* __PSTL_glue_numeric_impl_H_ */"}, {"sha": "0fadbc618d1d63e4dc6f1a3507e084c456d86028", "filename": "libstdc++-v3/include/pstl/memory_impl.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fmemory_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fmemory_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fmemory_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,56 @@\n+// -*- C++ -*-\n+//===-- memory_impl.h -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_memory_impl_H\n+#define __PSTL_memory_impl_H\n+\n+#include <iterator>\n+\n+#include \"unseq_backend_simd.h\"\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+//------------------------------------------------------------------------\n+// uninitialized_move\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator\n+__brick_uninitialized_move(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                           /*vector=*/std::false_type) noexcept\n+{\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _ValueType2;\n+    for (; __first != __last; ++__first, ++__result)\n+    {\n+        ::new (std::addressof(*__result)) _ValueType2(std::move(*__first));\n+    }\n+    return __result;\n+}\n+\n+template <class _ForwardIterator, class _OutputIterator>\n+_OutputIterator\n+__brick_uninitialized_move(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                           /*vector=*/std::true_type) noexcept\n+{\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type __ValueType2;\n+    typedef typename std::iterator_traits<_ForwardIterator>::reference _ReferenceType1;\n+    typedef typename std::iterator_traits<_OutputIterator>::reference _ReferenceType2;\n+\n+    return __unseq_backend::__simd_walk_2(\n+        __first, __last - __first, __result,\n+        [](_ReferenceType1 __x, _ReferenceType2 __y) { ::new (std::addressof(__y)) __ValueType2(std::move(__x)); });\n+}\n+\n+} // namespace __internal\n+} // namespace __pstl\n+\n+#endif /* __PSTL_memory_impl_H */"}, {"sha": "56667968938e4184e61d6b0109680fcfb11989cf", "filename": "libstdc++-v3/include/pstl/numeric_fwd.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_fwd.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,146 @@\n+// -*- C++ -*-\n+//===-- numeric_fwd.h --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_numeric_fwd_H\n+#define __PSTL_numeric_fwd_H\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+//------------------------------------------------------------------------\n+// transform_reduce (version with two binary functions, according to draft N4659)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>\n+_Tp __brick_transform_reduce(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Tp, _BinaryOperation1,\n+                             _BinaryOperation2,\n+                             /*__is_vector=*/std::true_type) noexcept;\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>\n+_Tp __brick_transform_reduce(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Tp, _BinaryOperation1,\n+                             _BinaryOperation2,\n+                             /*__is_vector=*/std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1,\n+          class _BinaryOperation2, class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&&, _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _Tp,\n+                           _BinaryOperation1, _BinaryOperation2, _IsVector,\n+                           /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2, class _Tp,\n+          class _BinaryOperation1, class _BinaryOperation2, class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&&, _RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2,\n+                           _Tp, _BinaryOperation1, _BinaryOperation2, _IsVector __is_vector,\n+                           /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// transform_reduce (version with unary and binary functions)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Tp, class _UnaryOperation, class _BinaryOperation>\n+_Tp __brick_transform_reduce(_ForwardIterator, _ForwardIterator, _Tp, _BinaryOperation, _UnaryOperation,\n+                             /*is_vector=*/std::true_type) noexcept;\n+\n+template <class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>\n+_Tp __brick_transform_reduce(_ForwardIterator, _ForwardIterator, _Tp, _BinaryOperation, _UnaryOperation,\n+                             /*is_vector=*/std::false_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation,\n+          class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Tp, _BinaryOperation,\n+                           _UnaryOperation, _IsVector,\n+                           /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation,\n+          class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _Tp, _BinaryOperation,\n+                           _UnaryOperation, _IsVector,\n+                           /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// transform_exclusive_scan\n+//\n+// walk3 evaluates f(x,y,z) for (x,y,z) drawn from [first1,last1), [first2,...), [first3,...)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp, class _BinaryOperation>\n+std::pair<_OutputIterator, _Tp> __brick_transform_scan(_ForwardIterator, _ForwardIterator, _OutputIterator,\n+                                                       _UnaryOperation, _Tp, _BinaryOperation,\n+                                                       /*Inclusive*/ std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp, class _BinaryOperation>\n+std::pair<_OutputIterator, _Tp> __brick_transform_scan(_ForwardIterator, _ForwardIterator, _OutputIterator,\n+                                                       _UnaryOperation, _Tp, _BinaryOperation,\n+                                                       /*Inclusive*/ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation, class _Inclusive, class _IsVector>\n+_OutputIterator\n+__pattern_transform_scan(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _OutputIterator, _UnaryOperation, _Tp,\n+                         _BinaryOperation, _Inclusive, _IsVector,\n+                         /*is_parallel=*/std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation, class _Inclusive, class _IsVector>\n+typename std::enable_if<!std::is_floating_point<_Tp>::value, _OutputIterator>::type\n+__pattern_transform_scan(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _OutputIterator,\n+                         _UnaryOperation, _Tp, _BinaryOperation, _Inclusive, _IsVector, /*is_parallel=*/std::true_type);\n+#endif\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation, class _Inclusive, class _IsVector>\n+typename std::enable_if<std::is_floating_point<_Tp>::value, _OutputIterator>::type\n+__pattern_transform_scan(_ExecutionPolicy&&, _RandomAccessIterator, _RandomAccessIterator, _OutputIterator,\n+                         _UnaryOperation, _Tp, _BinaryOperation, _Inclusive, _IsVector, /*is_parallel=*/std::true_type);\n+#endif\n+\n+//------------------------------------------------------------------------\n+// adjacent_difference\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator, class _BinaryOperation>\n+_OutputIterator __brick_adjacent_difference(_ForwardIterator, _ForwardIterator, _OutputIterator, _BinaryOperation,\n+                                            /*is_vector*/ std::false_type) noexcept;\n+\n+template <class _ForwardIterator, class _OutputIterator, class _BinaryOperation>\n+_OutputIterator __brick_adjacent_difference(_ForwardIterator, _ForwardIterator, _OutputIterator, _BinaryOperation,\n+                                            /*is_vector*/ std::true_type) noexcept;\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _BinaryOperation,\n+          class _IsVector>\n+_OutputIterator\n+__pattern_adjacent_difference(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _OutputIterator, _BinaryOperation,\n+                              _IsVector, /*is_parallel*/ std::false_type) noexcept;\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _BinaryOperation,\n+          class _IsVector>\n+_OutputIterator\n+__pattern_adjacent_difference(_ExecutionPolicy&&, _ForwardIterator, _ForwardIterator, _OutputIterator, _BinaryOperation,\n+                              _IsVector, /*is_parallel*/ std::true_type);\n+#endif\n+\n+} // namespace __internal\n+} // namespace __pstl\n+#endif /* __PSTL_numeric_fwd_H */"}, {"sha": "803e2d8bf6148b1b42837076b4550322b5db5452", "filename": "libstdc++-v3/include/pstl/numeric_impl.h", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fnumeric_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,368 @@\n+// -*- C++ -*-\n+//===-- numeric_impl.h ----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_numeric_impl_H\n+#define __PSTL_numeric_impl_H\n+\n+#include <iterator>\n+#include <type_traits>\n+#include <numeric>\n+\n+#include \"execution_impl.h\"\n+#include \"unseq_backend_simd.h\"\n+#include \"algorithm_fwd.h\"\n+\n+#if __PSTL_USE_PAR_POLICIES\n+#include \"parallel_backend.h\"\n+#endif\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+//------------------------------------------------------------------------\n+// transform_reduce (version with two binary functions, according to draft N4659)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>\n+_Tp\n+__brick_transform_reduce(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _Tp __init,\n+                         _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2,\n+                         /*is_vector=*/std::false_type) noexcept\n+{\n+    return std::inner_product(__first1, __last1, __first2, __init, __binary_op1, __binary_op2);\n+}\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>\n+_Tp\n+__brick_transform_reduce(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _Tp __init,\n+                         _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2,\n+                         /*is_vector=*/std::true_type) noexcept\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator1>::difference_type _DifferenceType;\n+    return __unseq_backend::__simd_transform_reduce(\n+        __last1 - __first1, __init, __binary_op1,\n+        [=, &__binary_op2](_DifferenceType __i) { return __binary_op2(__first1[__i], __first2[__i]); });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp, class _BinaryOperation1,\n+          class _BinaryOperation2, class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&&, _ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+                           _ForwardIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1,\n+                           _BinaryOperation2 __binary_op2, _IsVector __is_vector,\n+                           /*is_parallel=*/std::false_type) noexcept\n+{\n+    return __brick_transform_reduce(__first1, __last1, __first2, __init, __binary_op1, __binary_op2, __is_vector);\n+}\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator1, class _RandomAccessIterator2, class _Tp,\n+          class _BinaryOperation1, class _BinaryOperation2, class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&& __exec, _RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n+                           _RandomAccessIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1,\n+                           _BinaryOperation2 __binary_op2, _IsVector __is_vector, /*is_parallel=*/std::true_type)\n+{\n+    return __except_handler([&]() {\n+        return __par_backend::__parallel_transform_reduce(\n+            std::forward<_ExecutionPolicy>(__exec), __first1, __last1,\n+            [__first1, __first2, __binary_op2](_RandomAccessIterator1 __i) mutable {\n+                return __binary_op2(*__i, *(__first2 + (__i - __first1)));\n+            },\n+            __init,\n+            __binary_op1, // Combine\n+            [__first1, __first2, __binary_op1, __binary_op2,\n+             __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j, _Tp __init) -> _Tp {\n+                return __brick_transform_reduce(__i, __j, __first2 + (__i - __first1), __init, __binary_op1,\n+                                                __binary_op2, __is_vector);\n+            });\n+    });\n+}\n+#endif\n+\n+//------------------------------------------------------------------------\n+// transform_reduce (version with unary and binary functions)\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation>\n+_Tp\n+__brick_transform_reduce(_ForwardIterator __first, _ForwardIterator __last, _Tp __init, _BinaryOperation __binary_op,\n+                         _UnaryOperation __unary_op, /*is_vector=*/std::false_type) noexcept\n+{\n+    for (; __first != __last; ++__first)\n+    {\n+        __init = __binary_op(__init, __unary_op(*__first));\n+    }\n+    return __init;\n+}\n+\n+template <class _ForwardIterator, class _Tp, class _UnaryOperation, class _BinaryOperation>\n+_Tp\n+__brick_transform_reduce(_ForwardIterator __first, _ForwardIterator __last, _Tp __init, _BinaryOperation __binary_op,\n+                         _UnaryOperation __unary_op, /*is_vector=*/std::true_type) noexcept\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator>::difference_type _DifferenceType;\n+    return __unseq_backend::__simd_transform_reduce(\n+        __last - __first, __init, __binary_op,\n+        [=, &__unary_op](_DifferenceType __i) { return __unary_op(__first[__i]); });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation,\n+          class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n+                           _BinaryOperation __binary_op, _UnaryOperation __unary_op, _IsVector __is_vector,\n+                           /*is_parallel=*/std::false_type) noexcept\n+{\n+    return __brick_transform_reduce(__first, __last, __init, __binary_op, __unary_op, __is_vector);\n+}\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator, class _Tp, class _BinaryOperation, class _UnaryOperation,\n+          class _IsVector>\n+_Tp\n+__pattern_transform_reduce(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Tp __init,\n+                           _BinaryOperation __binary_op, _UnaryOperation __unary_op, _IsVector __is_vector,\n+                           /*is_parallel=*/std::true_type)\n+{\n+    return __except_handler([&]() {\n+        return __par_backend::__parallel_transform_reduce(\n+            std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+            [__unary_op](_ForwardIterator __i) mutable { return __unary_op(*__i); }, __init, __binary_op,\n+            [__unary_op, __binary_op, __is_vector](_ForwardIterator __i, _ForwardIterator __j, _Tp __init) {\n+                return __brick_transform_reduce(__i, __j, __init, __binary_op, __unary_op, __is_vector);\n+            });\n+    });\n+}\n+#endif\n+\n+//------------------------------------------------------------------------\n+// transform_exclusive_scan\n+//\n+// walk3 evaluates f(x,y,z) for (x,y,z) drawn from [first1,last1), [first2,...), [first3,...)\n+//------------------------------------------------------------------------\n+\n+// Exclusive form\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp, class _BinaryOperation>\n+std::pair<_OutputIterator, _Tp>\n+__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                       _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op,\n+                       /*Inclusive*/ std::false_type, /*is_vector=*/std::false_type) noexcept\n+{\n+    for (; __first != __last; ++__first, ++__result)\n+    {\n+        *__result = __init;\n+        __PSTL_PRAGMA_FORCEINLINE\n+        __init = __binary_op(__init, __unary_op(*__first));\n+    }\n+    return std::make_pair(__result, __init);\n+}\n+\n+// Inclusive form\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp, class _BinaryOperation>\n+std::pair<_OutputIterator, _Tp>\n+__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                       _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op,\n+                       /*Inclusive*/ std::true_type, /*is_vector=*/std::false_type) noexcept\n+{\n+    for (; __first != __last; ++__first, ++__result)\n+    {\n+        __PSTL_PRAGMA_FORCEINLINE\n+        __init = __binary_op(__init, __unary_op(*__first));\n+        *__result = __init;\n+    }\n+    return std::make_pair(__result, __init);\n+}\n+\n+// type is arithmetic and binary operation is a user defined operation.\n+template <typename _Tp, typename _BinaryOperation>\n+using is_arithmetic_udop = std::integral_constant<bool, std::is_arithmetic<_Tp>::value &&\n+                                                            !std::is_same<_BinaryOperation, std::plus<_Tp>>::value>;\n+\n+// [restriction] - T shall be DefaultConstructible.\n+// [violation] - default ctor of T shall set the identity value for binary_op.\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp, class _BinaryOperation,\n+          class _Inclusive>\n+typename std::enable_if<!is_arithmetic_udop<_Tp, _BinaryOperation>::value, std::pair<_OutputIterator, _Tp>>::type\n+__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                       _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op, _Inclusive,\n+                       /*is_vector=*/std::true_type) noexcept\n+{\n+#if (__PSTL_UDS_PRESENT)\n+    return __unseq_backend::__simd_scan(__first, __last - __first, __result, __unary_op, __init, __binary_op,\n+                                        _Inclusive());\n+#else\n+    // We need to call serial brick here to call function for inclusive and exclusive scan that depends on _Inclusive() value\n+    return __brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(),\n+                                  /*is_vector=*/std::false_type());\n+#endif\n+}\n+\n+template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp, class _BinaryOperation,\n+          class _Inclusive>\n+typename std::enable_if<is_arithmetic_udop<_Tp, _BinaryOperation>::value, std::pair<_OutputIterator, _Tp>>::type\n+__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result,\n+                       _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op, _Inclusive,\n+                       /*is_vector=*/std::true_type) noexcept\n+{\n+    return __brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(),\n+                                  /*is_vector=*/std::false_type());\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation, class _Inclusive, class _IsVector>\n+_OutputIterator\n+__pattern_transform_scan(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last,\n+                         _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op,\n+                         _Inclusive, _IsVector __is_vector, /*is_parallel=*/std::false_type) noexcept\n+{\n+    return __brick_transform_scan(__first, __last, __result, __unary_op, __init, __binary_op, _Inclusive(), __is_vector)\n+        .first;\n+}\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation, class _Inclusive, class _IsVector>\n+typename std::enable_if<!std::is_floating_point<_Tp>::value, _OutputIterator>::type\n+__pattern_transform_scan(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last,\n+                         _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op,\n+                         _Inclusive, _IsVector __is_vector, /*is_parallel=*/std::true_type)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type _DifferenceType;\n+\n+    return __except_handler([&]() {\n+        __par_backend::__parallel_transform_scan(\n+            std::forward<_ExecutionPolicy>(__exec), __last - __first,\n+            [__first, __unary_op](_DifferenceType __i) mutable { return __unary_op(__first[__i]); }, __init,\n+            __binary_op,\n+            [__first, __unary_op, __binary_op](_DifferenceType __i, _DifferenceType __j, _Tp __init) {\n+                // Execute serial __brick_transform_reduce, due to the explicit SIMD vectorization (reduction) requires a commutative operation for the guarantee of correct scan.\n+                return __brick_transform_reduce(__first + __i, __first + __j, __init, __binary_op, __unary_op,\n+                                                /*__is_vector*/ std::false_type());\n+            },\n+            [__first, __unary_op, __binary_op, __result, __is_vector](_DifferenceType __i, _DifferenceType __j,\n+                                                                      _Tp __init) {\n+                return __brick_transform_scan(__first + __i, __first + __j, __result + __i, __unary_op, __init,\n+                                              __binary_op, _Inclusive(), __is_vector)\n+                    .second;\n+            });\n+        return __result + (__last - __first);\n+    });\n+}\n+#endif\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _RandomAccessIterator, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation, class _Inclusive, class _IsVector>\n+typename std::enable_if<std::is_floating_point<_Tp>::value, _OutputIterator>::type\n+__pattern_transform_scan(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last,\n+                         _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init, _BinaryOperation __binary_op,\n+                         _Inclusive, _IsVector __is_vector, /*is_parallel=*/std::true_type)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type _DifferenceType;\n+    _DifferenceType __n = __last - __first;\n+\n+    if (__n <= 0)\n+    {\n+        return __result;\n+    }\n+    return __except_handler([&]() {\n+        __par_backend::parallel_strict_scan(\n+            std::forward<_ExecutionPolicy>(__exec), __n, __init,\n+            [__first, __unary_op, __binary_op, __result, __is_vector](_DifferenceType __i, _DifferenceType __len) {\n+                return __brick_transform_scan(__first + __i, __first + (__i + __len), __result + __i, __unary_op, _Tp{},\n+                                              __binary_op, _Inclusive(), __is_vector)\n+                    .second;\n+            },\n+            __binary_op,\n+            [__result, &__binary_op](_DifferenceType __i, _DifferenceType __len, _Tp __initial) {\n+                return *(std::transform(__result + __i, __result + __i + __len, __result + __i,\n+                                        [&__initial, &__binary_op](const _Tp& __x) {\n+                                            __PSTL_PRAGMA_FORCEINLINE\n+                                            return __binary_op(__initial, __x);\n+                                        }) -\n+                         1);\n+            },\n+            [](_Tp __res) {});\n+        return __result + (__last - __first);\n+    });\n+}\n+#endif\n+\n+//------------------------------------------------------------------------\n+// adjacent_difference\n+//------------------------------------------------------------------------\n+\n+template <class _ForwardIterator, class _OutputIterator, class _BinaryOperation>\n+_OutputIterator\n+__brick_adjacent_difference(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __d_first,\n+                            _BinaryOperation __op, /*is_vector*/ std::false_type) noexcept\n+{\n+    return std::adjacent_difference(__first, __last, __d_first, __op);\n+}\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class BinaryOperation>\n+_ForwardIterator2\n+__brick_adjacent_difference(_ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __d_first,\n+                            BinaryOperation __op, /*is_vector=*/std::true_type) noexcept\n+{\n+    assert(__first != __last);\n+\n+    typedef typename std::iterator_traits<_ForwardIterator1>::reference _ReferenceType1;\n+    typedef typename std::iterator_traits<_ForwardIterator2>::reference _ReferenceType2;\n+\n+    auto __n = __last - __first;\n+    *__d_first = *__first;\n+    return __unseq_backend::__simd_walk_3(\n+        __first + 1, __n - 1, __first, __d_first + 1,\n+        [&__op](_ReferenceType1 __x, _ReferenceType1 __y, _ReferenceType2 __z) { __z = __op(__x, __y); });\n+}\n+\n+template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator, class _BinaryOperation,\n+          class _IsVector>\n+_OutputIterator\n+__pattern_adjacent_difference(_ExecutionPolicy&&, _ForwardIterator __first, _ForwardIterator __last,\n+                              _OutputIterator __d_first, _BinaryOperation __op, _IsVector __is_vector,\n+                              /*is_parallel*/ std::false_type) noexcept\n+{\n+    return __brick_adjacent_difference(__first, __last, __d_first, __op, __is_vector);\n+}\n+\n+#if __PSTL_USE_PAR_POLICIES\n+template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryOperation,\n+          class _IsVector>\n+_ForwardIterator2\n+__pattern_adjacent_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,\n+                              _ForwardIterator2 __d_first, _BinaryOperation __op, _IsVector __is_vector,\n+                              /*is_parallel=*/std::true_type)\n+{\n+    assert(__first != __last);\n+    typedef typename std::iterator_traits<_ForwardIterator1>::reference _ReferenceType1;\n+    typedef typename std::iterator_traits<_ForwardIterator2>::reference _ReferenceType2;\n+\n+    *__d_first = *__first;\n+    __par_backend::__parallel_for(\n+        std::forward<_ExecutionPolicy>(__exec), __first, __last - 1,\n+        [&__op, __is_vector, __d_first, __first](_ForwardIterator1 __b, _ForwardIterator1 __e) {\n+            _ForwardIterator2 __d_b = __d_first + (__b - __first);\n+            __brick_walk3(\n+                __b, __e, __b + 1, __d_b + 1,\n+                [&__op](_ReferenceType1 __x, _ReferenceType1 __y, _ReferenceType2 __z) { __z = __op(__y, __x); },\n+                __is_vector);\n+        });\n+    return __d_first + (__last - __first);\n+}\n+#endif\n+\n+} // namespace __internal\n+} // namespace __pstl\n+\n+#endif /* __PSTL_numeric_impl_H */"}, {"sha": "820e2b7f89b95dd0f86399028889a36a14cca888", "filename": "libstdc++-v3/include/pstl/parallel_backend.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,19 @@\n+// -*- C++ -*-\n+//===-- parallel_backend.h ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_parallel_backend_H\n+#define __PSTL_parallel_backend_H\n+\n+#if __PSTL_PAR_BACKEND_TBB\n+#include \"parallel_backend_tbb.h\"\n+#else\n+__PSTL_PRAGMA_MESSAGE(\"Parallel backend was not specified\");\n+#endif\n+\n+#endif /* __PSTL_parallel_backend_H */"}, {"sha": "114bf6397101c0cbf9004eadc28d3b0609298a5e", "filename": "libstdc++-v3/include/pstl/parallel_backend_tbb.h", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_tbb.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,653 @@\n+// -*- C++ -*-\n+//===-- parallel_backend_tbb.h --------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_parallel_backend_tbb_H\n+#define __PSTL_parallel_backend_tbb_H\n+\n+#include <cassert>\n+#include <algorithm>\n+#include <type_traits>\n+\n+#include \"parallel_backend_utils.h\"\n+\n+// Bring in minimal required subset of Intel TBB\n+#include <tbb/blocked_range.h>\n+#include <tbb/parallel_for.h>\n+#include <tbb/parallel_reduce.h>\n+#include <tbb/parallel_scan.h>\n+#include <tbb/parallel_invoke.h>\n+#include <tbb/task_arena.h>\n+#include <tbb/tbb_allocator.h>\n+\n+#if TBB_INTERFACE_VERSION < 10000\n+#error Intel(R) Threading Building Blocks 2018 is required; older versions are not supported.\n+#endif\n+\n+namespace __pstl\n+{\n+namespace __par_backend\n+{\n+\n+//! Raw memory buffer with automatic freeing and no exceptions.\n+/** Some of our algorithms need to start with raw memory buffer,\n+not an initialize array, because initialization/destruction\n+would make the span be at least O(N). */\n+// tbb::allocator can improve performance in some cases.\n+template <typename _Tp>\n+class __buffer\n+{\n+    tbb::tbb_allocator<_Tp> _M_allocator;\n+    _Tp* _M_ptr;\n+    const std::size_t _M_buf_size;\n+    __buffer(const __buffer&) = delete;\n+    void\n+    operator=(const __buffer&) = delete;\n+\n+  public:\n+    //! Try to obtain buffer of given size to store objects of _Tp type\n+    __buffer(std::size_t n) : _M_allocator(), _M_ptr(_M_allocator.allocate(n)), _M_buf_size(n) {}\n+    //! True if buffer was successfully obtained, zero otherwise.\n+    operator bool() const { return _M_ptr != NULL; }\n+    //! Return pointer to buffer, or  NULL if buffer could not be obtained.\n+    _Tp*\n+    get() const\n+    {\n+        return _M_ptr;\n+    }\n+    //! Destroy buffer\n+    ~__buffer() { _M_allocator.deallocate(_M_ptr, _M_buf_size); }\n+};\n+\n+// Wrapper for tbb::task\n+inline void\n+__cancel_execution()\n+{\n+    tbb::task::self().group()->cancel_group_execution();\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_for\n+//------------------------------------------------------------------------\n+\n+template <class _Index, class _RealBody>\n+class __parallel_for_body\n+{\n+  public:\n+    __parallel_for_body(const _RealBody& __body) : _M_body(__body) {}\n+    __parallel_for_body(const __parallel_for_body& __body) : _M_body(__body._M_body) {}\n+    void\n+    operator()(const tbb::blocked_range<_Index>& __range) const\n+    {\n+        _M_body(__range.begin(), __range.end());\n+    }\n+\n+  private:\n+    _RealBody _M_body;\n+};\n+\n+//! Evaluation of brick f[i,j) for each subrange [i,j) of [first,last)\n+// wrapper over tbb::parallel_for\n+template <class _ExecutionPolicy, class _Index, class _Fp>\n+void\n+__parallel_for(_ExecutionPolicy&&, _Index __first, _Index __last, _Fp __f)\n+{\n+    tbb::this_task_arena::isolate([=]() {\n+        tbb::parallel_for(tbb::blocked_range<_Index>(__first, __last), __parallel_for_body<_Index, _Fp>(__f));\n+    });\n+}\n+\n+//! Evaluation of brick f[i,j) for each subrange [i,j) of [first,last)\n+// wrapper over tbb::parallel_reduce\n+template <class _ExecutionPolicy, class _Value, class _Index, typename _RealBody, typename _Reduction>\n+_Value\n+__parallel_reduce(_ExecutionPolicy&&, _Index __first, _Index __last, const _Value& __identity,\n+                  const _RealBody& __real_body, const _Reduction& __reduction)\n+{\n+    return tbb::this_task_arena::isolate([__first, __last, &__identity, &__real_body, &__reduction]() -> _Value {\n+        return tbb::parallel_reduce(\n+            tbb::blocked_range<_Index>(__first, __last), __identity,\n+            [__real_body](const tbb::blocked_range<_Index>& __r, const _Value& __value) -> _Value {\n+                return __real_body(__r.begin(), __r.end(), __value);\n+            },\n+            __reduction);\n+    });\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_transform_reduce\n+//\n+// Notation:\n+//      r(i,j,init) returns reduction of init with reduction over [i,j)\n+//      u(i) returns f(i,i+1,identity) for a hypothetical left identity element of r\n+//      c(x,y) combines values x and y that were the result of r or u\n+//------------------------------------------------------------------------\n+\n+template <class _Index, class _Up, class _Tp, class _Cp, class _Rp>\n+struct __par_trans_red_body\n+{\n+    alignas(_Tp) char _M_sum_storage[sizeof(_Tp)]; // Holds generalized non-commutative sum when has_sum==true\n+    _Rp _M_brick_reduce;                           // Most likely to have non-empty layout\n+    _Up _M_u;\n+    _Cp _M_combine;\n+    bool _M_has_sum; // Put last to minimize size of class\n+    _Tp&\n+    sum()\n+    {\n+        __TBB_ASSERT(_M_has_sum, \"sum expected\");\n+        return *(_Tp*)_M_sum_storage;\n+    }\n+    __par_trans_red_body(_Up __u, _Tp __init, _Cp __c, _Rp __r)\n+        : _M_brick_reduce(__r), _M_u(__u), _M_combine(__c), _M_has_sum(true)\n+    {\n+        new (_M_sum_storage) _Tp(__init);\n+    }\n+\n+    __par_trans_red_body(__par_trans_red_body& __left, tbb::split)\n+        : _M_brick_reduce(__left._M_brick_reduce), _M_u(__left._M_u), _M_combine(__left._M_combine), _M_has_sum(false)\n+    {\n+    }\n+\n+    ~__par_trans_red_body()\n+    {\n+        // 17.6.5.12 tells us to not worry about catching exceptions from destructors.\n+        if (_M_has_sum)\n+            sum().~_Tp();\n+    }\n+\n+    void\n+    join(__par_trans_red_body& __rhs)\n+    {\n+        sum() = _M_combine(sum(), __rhs.sum());\n+    }\n+\n+    void\n+    operator()(const tbb::blocked_range<_Index>& __range)\n+    {\n+        _Index __i = __range.begin();\n+        _Index __j = __range.end();\n+        if (!_M_has_sum)\n+        {\n+            __TBB_ASSERT(__range.size() > 1, \"there should be at least 2 elements\");\n+            new (&_M_sum_storage)\n+                _Tp(_M_combine(_M_u(__i), _M_u(__i + 1))); // The condition i+1 < j is provided by the grain size of 3\n+            _M_has_sum = true;\n+            std::advance(__i, 2);\n+            if (__i == __j)\n+                return;\n+        }\n+        sum() = _M_brick_reduce(__i, __j, sum());\n+    }\n+};\n+\n+template <class _ExecutionPolicy, class _Index, class _Up, class _Tp, class _Cp, class _Rp>\n+_Tp\n+__parallel_transform_reduce(_ExecutionPolicy&&, _Index __first, _Index __last, _Up __u, _Tp __init, _Cp __combine,\n+                            _Rp __brick_reduce)\n+{\n+    __par_trans_red_body<_Index, _Up, _Tp, _Cp, _Rp> __body(__u, __init, __combine, __brick_reduce);\n+    // The grain size of 3 is used in order to provide mininum 2 elements for each body\n+    tbb::this_task_arena::isolate(\n+        [__first, __last, &__body]() { tbb::parallel_reduce(tbb::blocked_range<_Index>(__first, __last, 3), __body); });\n+    return __body.sum();\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_scan\n+//------------------------------------------------------------------------\n+\n+template <class _Index, class _Up, class _Tp, class _Cp, class _Rp, class _Sp>\n+class __trans_scan_body\n+{\n+    alignas(_Tp) char _M_sum_storage[sizeof(_Tp)]; // Holds generalized non-commutative sum when has_sum==true\n+    _Rp _M_brick_reduce;                           // Most likely to have non-empty layout\n+    _Up _M_u;\n+    _Cp _M_combine;\n+    _Sp _M_scan;\n+    bool _M_has_sum; // Put last to minimize size of class\n+  public:\n+    __trans_scan_body(_Up __u, _Tp __init, _Cp __combine, _Rp __reduce, _Sp __scan)\n+        : _M_brick_reduce(__reduce), _M_u(__u), _M_combine(__combine), _M_scan(__scan), _M_has_sum(true)\n+    {\n+        new (_M_sum_storage) _Tp(__init);\n+    }\n+\n+    __trans_scan_body(__trans_scan_body& __b, tbb::split)\n+        : _M_brick_reduce(__b._M_brick_reduce), _M_u(__b._M_u), _M_combine(__b._M_combine), _M_scan(__b._M_scan),\n+          _M_has_sum(false)\n+    {\n+    }\n+\n+    ~__trans_scan_body()\n+    {\n+        // 17.6.5.12 tells us to not worry about catching exceptions from destructors.\n+        if (_M_has_sum)\n+            sum().~_Tp();\n+    }\n+\n+    _Tp&\n+    sum() const\n+    {\n+        __TBB_ASSERT(_M_has_sum, \"sum expected\");\n+        return *(_Tp*)_M_sum_storage;\n+    }\n+\n+    void\n+    operator()(const tbb::blocked_range<_Index>& __range, tbb::pre_scan_tag)\n+    {\n+        _Index __i = __range.begin();\n+        _Index __j = __range.end();\n+        if (!_M_has_sum)\n+        {\n+            new (&_M_sum_storage) _Tp(_M_u(__i));\n+            _M_has_sum = true;\n+            ++__i;\n+            if (__i == __j)\n+                return;\n+        }\n+        sum() = _M_brick_reduce(__i, __j, sum());\n+    }\n+\n+    void\n+    operator()(const tbb::blocked_range<_Index>& __range, tbb::final_scan_tag)\n+    {\n+        sum() = _M_scan(__range.begin(), __range.end(), sum());\n+    }\n+\n+    void\n+    reverse_join(__trans_scan_body& __a)\n+    {\n+        if (_M_has_sum)\n+        {\n+            sum() = _M_combine(__a.sum(), sum());\n+        }\n+        else\n+        {\n+            new (&_M_sum_storage) _Tp(__a.sum());\n+            _M_has_sum = true;\n+        }\n+    }\n+\n+    void\n+    assign(__trans_scan_body& __b)\n+    {\n+        sum() = __b.sum();\n+    }\n+};\n+\n+template <typename _Index>\n+_Index\n+__split(_Index __m)\n+{\n+    _Index __k = 1;\n+    while (2 * __k < __m)\n+        __k *= 2;\n+    return __k;\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_strict_scan\n+//------------------------------------------------------------------------\n+\n+template <typename _Index, typename _Tp, typename _Rp, typename _Cp>\n+void\n+__upsweep(_Index __i, _Index __m, _Index __tilesize, _Tp* __r, _Index __lastsize, _Rp __reduce, _Cp __combine)\n+{\n+    if (__m == 1)\n+        __r[0] = __reduce(__i * __tilesize, __lastsize);\n+    else\n+    {\n+        _Index __k = __split(__m);\n+        tbb::parallel_invoke(\n+            [=] { __upsweep(__i, __k, __tilesize, __r, __tilesize, __reduce, __combine); },\n+            [=] { __upsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize, __reduce, __combine); });\n+        if (__m == 2 * __k)\n+            __r[__m - 1] = __combine(__r[__k - 1], __r[__m - 1]);\n+    }\n+}\n+\n+template <typename _Index, typename _Tp, typename _Cp, typename _Sp>\n+void\n+__downsweep(_Index __i, _Index __m, _Index __tilesize, _Tp* __r, _Index __lastsize, _Tp __initial, _Cp __combine,\n+            _Sp __scan)\n+{\n+    if (__m == 1)\n+        __scan(__i * __tilesize, __lastsize, __initial);\n+    else\n+    {\n+        const _Index __k = __split(__m);\n+        tbb::parallel_invoke([=] { __downsweep(__i, __k, __tilesize, __r, __tilesize, __initial, __combine, __scan); },\n+                             // Assumes that __combine never throws.\n+                             //TODO: Consider adding a requirement for user functors to be constant.\n+                             [=, &__combine] {\n+                                 __downsweep(__i + __k, __m - __k, __tilesize, __r + __k, __lastsize,\n+                                             __combine(__initial, __r[__k - 1]), __combine, __scan);\n+                             });\n+    }\n+}\n+\n+// Adapted from Intel(R) Cilk(TM) version from cilkpub.\n+// Let i:len denote a counted interval of length n starting at i.  s denotes a generalized-sum value.\n+// Expected actions of the functors are:\n+//     reduce(i,len) -> s  -- return reduction value of i:len.\n+//     combine(s1,s2) -> s -- return merged sum\n+//     apex(s) -- do any processing necessary between reduce and scan.\n+//     scan(i,len,initial) -- perform scan over i:len starting with initial.\n+// The initial range 0:n is partitioned into consecutive subranges.\n+// reduce and scan are each called exactly once per subrange.\n+// Thus callers can rely upon side effects in reduce.\n+// combine must not throw an exception.\n+// apex is called exactly once, after all calls to reduce and before all calls to scan.\n+// For example, it's useful for allocating a __buffer used by scan but whose size is the sum of all reduction values.\n+// T must have a trivial constructor and destructor.\n+template <class _ExecutionPolicy, typename _Index, typename _Tp, typename _Rp, typename _Cp, typename _Sp, typename _Ap>\n+void\n+parallel_strict_scan(_ExecutionPolicy&&, _Index __n, _Tp __initial, _Rp __reduce, _Cp __combine, _Sp __scan, _Ap __apex)\n+{\n+    tbb::this_task_arena::isolate([=, &__combine]() {\n+        if (__n > 1)\n+        {\n+            _Index __p = tbb::this_task_arena::max_concurrency();\n+            const _Index __slack = 4;\n+            _Index __tilesize = (__n - 1) / (__slack * __p) + 1;\n+            _Index __m = (__n - 1) / __tilesize;\n+            __buffer<_Tp> __buf(__m + 1);\n+            _Tp* __r = __buf.get();\n+            __upsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __reduce, __combine);\n+            // When __apex is a no-op and __combine has no side effects, a good optimizer\n+            // should be able to eliminate all code between here and __apex.\n+            // Alternatively, provide a default value for __apex that can be\n+            // recognized by metaprogramming that conditionlly executes the following.\n+            size_t __k = __m + 1;\n+            _Tp __t = __r[__k - 1];\n+            while ((__k &= __k - 1))\n+                __t = __combine(__r[__k - 1], __t);\n+            __apex(__combine(__initial, __t));\n+            __downsweep(_Index(0), _Index(__m + 1), __tilesize, __r, __n - __m * __tilesize, __initial, __combine,\n+                        __scan);\n+            return;\n+        }\n+        // Fewer than 2 elements in sequence, or out of memory.  Handle has single block.\n+        _Tp __sum = __initial;\n+        if (__n)\n+            __sum = __combine(__sum, __reduce(_Index(0), __n));\n+        __apex(__sum);\n+        if (__n)\n+            __scan(_Index(0), __n, __initial);\n+    });\n+}\n+\n+template <class _ExecutionPolicy, class _Index, class _Up, class _Tp, class _Cp, class _Rp, class _Sp>\n+_Tp\n+__parallel_transform_scan(_ExecutionPolicy&&, _Index __n, _Up __u, _Tp __init, _Cp __combine, _Rp __brick_reduce,\n+                          _Sp __scan)\n+{\n+    __trans_scan_body<_Index, _Up, _Tp, _Cp, _Rp, _Sp> __body(__u, __init, __combine, __brick_reduce, __scan);\n+    auto __range = tbb::blocked_range<_Index>(0, __n);\n+    tbb::this_task_arena::isolate([__range, &__body]() { tbb::parallel_scan(__range, __body); });\n+    return __body.sum();\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_stable_sort\n+//------------------------------------------------------------------------\n+\n+//------------------------------------------------------------------------\n+// stable_sort utilities\n+//\n+// These are used by parallel implementations but do not depend on them.\n+//------------------------------------------------------------------------\n+\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _RandomAccessIterator3,\n+          typename _Compare, typename _Cleanup, typename _LeafMerge>\n+class __merge_task : public tbb::task\n+{\n+    /*override*/ tbb::task*\n+    execute();\n+    _RandomAccessIterator1 _M_xs, _M_xe;\n+    _RandomAccessIterator2 _M_ys, _M_ye;\n+    _RandomAccessIterator3 _M_zs;\n+    _Compare _M_comp;\n+    _Cleanup _M_cleanup;\n+    _LeafMerge _M_leaf_merge;\n+\n+  public:\n+    __merge_task(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __ys,\n+                 _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp, _Cleanup __cleanup,\n+                 _LeafMerge __leaf_merge)\n+        : _M_xs(__xs), _M_xe(__xe), _M_ys(__ys), _M_ye(__ye), _M_zs(__zs), _M_comp(__comp), _M_cleanup(__cleanup),\n+          _M_leaf_merge(__leaf_merge)\n+    {\n+    }\n+};\n+\n+#define __PSTL_MERGE_CUT_OFF 2000\n+\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _RandomAccessIterator3,\n+          typename __M_Compare, typename _Cleanup, typename _LeafMerge>\n+tbb::task*\n+__merge_task<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3, __M_Compare, _Cleanup,\n+             _LeafMerge>::execute()\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _DifferenceType1;\n+    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _DifferenceType2;\n+    typedef typename std::common_type<_DifferenceType1, _DifferenceType2>::type _SizeType;\n+    const _SizeType __n = (_M_xe - _M_xs) + (_M_ye - _M_ys);\n+    const _SizeType __merge_cut_off = __PSTL_MERGE_CUT_OFF;\n+    if (__n <= __merge_cut_off)\n+    {\n+        _M_leaf_merge(_M_xs, _M_xe, _M_ys, _M_ye, _M_zs, _M_comp);\n+\n+        //we clean the buffer one time on last step of the sort\n+        _M_cleanup(_M_xs, _M_xe);\n+        _M_cleanup(_M_ys, _M_ye);\n+        return nullptr;\n+    }\n+    else\n+    {\n+        _RandomAccessIterator1 __xm;\n+        _RandomAccessIterator2 __ym;\n+        if (_M_xe - _M_xs < _M_ye - _M_ys)\n+        {\n+            __ym = _M_ys + (_M_ye - _M_ys) / 2;\n+            __xm = std::upper_bound(_M_xs, _M_xe, *__ym, _M_comp);\n+        }\n+        else\n+        {\n+            __xm = _M_xs + (_M_xe - _M_xs) / 2;\n+            __ym = std::lower_bound(_M_ys, _M_ye, *__xm, _M_comp);\n+        }\n+        const _RandomAccessIterator3 __zm = _M_zs + ((__xm - _M_xs) + (__ym - _M_ys));\n+        tbb::task* __right = new (tbb::task::allocate_additional_child_of(*parent()))\n+            __merge_task(__xm, _M_xe, __ym, _M_ye, __zm, _M_comp, _M_cleanup, _M_leaf_merge);\n+        tbb::task::spawn(*__right);\n+        tbb::task::recycle_as_continuation();\n+        _M_xe = __xm;\n+        _M_ye = __ym;\n+    }\n+    return this;\n+}\n+\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Compare, typename _LeafSort>\n+class __stable_sort_task : public tbb::task\n+{\n+  public:\n+    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _DifferenceType1;\n+    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _DifferenceType2;\n+    typedef typename std::common_type<_DifferenceType1, _DifferenceType2>::type _SizeType;\n+\n+  private:\n+    /*override*/ tbb::task*\n+    execute();\n+    _RandomAccessIterator1 _M_xs, _M_xe;\n+    _RandomAccessIterator2 _M_zs;\n+    _Compare _M_comp;\n+    _LeafSort _M_leaf_sort;\n+    int32_t _M_inplace;\n+    _SizeType _M_nsort;\n+\n+  public:\n+    __stable_sort_task(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __zs,\n+                       int32_t __inplace, _Compare __comp, _LeafSort __leaf_sort, _SizeType __n)\n+        : _M_xs(__xs), _M_xe(__xe), _M_zs(__zs), _M_comp(__comp), _M_leaf_sort(__leaf_sort), _M_inplace(__inplace),\n+          _M_nsort(__n)\n+    {\n+    }\n+};\n+\n+//! Binary operator that does nothing\n+struct __binary_no_op\n+{\n+    template <typename _T>\n+    void operator()(_T, _T)\n+    {\n+    }\n+};\n+\n+#define __PSTL_STABLE_SORT_CUT_OFF 500\n+\n+template <typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Compare, typename _LeafSort>\n+tbb::task*\n+__stable_sort_task<_RandomAccessIterator1, _RandomAccessIterator2, _Compare, _LeafSort>::execute()\n+{\n+    const _SizeType __n = _M_xe - _M_xs;\n+    const _SizeType __nmerge = _M_nsort > 0 ? _M_nsort : __n;\n+    const _SizeType __sort_cut_off = __PSTL_STABLE_SORT_CUT_OFF;\n+    if (__n <= __sort_cut_off)\n+    {\n+        _M_leaf_sort(_M_xs, _M_xe, _M_comp);\n+        if (_M_inplace != 2)\n+            __init_buf(_M_xs, _M_xe, _M_zs, _M_inplace == 0);\n+        return NULL;\n+    }\n+    else\n+    {\n+        const _RandomAccessIterator1 __xm = _M_xs + __n / 2;\n+        const _RandomAccessIterator2 __zm = _M_zs + (__xm - _M_xs);\n+        const _RandomAccessIterator2 __ze = _M_zs + __n;\n+        task* __m;\n+        auto __move_values = [](_RandomAccessIterator2 __x, _RandomAccessIterator1 __z) { *__z = std::move(*__x); };\n+        auto __move_sequences = [](_RandomAccessIterator2 __first1, _RandomAccessIterator2 __last1,\n+                                   _RandomAccessIterator1 __first2) { return std::move(__first1, __last1, __first2); };\n+        if (_M_inplace == 2)\n+            __m = new (allocate_continuation())\n+                __merge_task<_RandomAccessIterator2, _RandomAccessIterator2, _RandomAccessIterator1, _Compare,\n+                             __serial_destroy,\n+                             __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n+                    _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __serial_destroy(),\n+                    __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n+                                                                                             __move_sequences));\n+        else if (_M_inplace)\n+            __m = new (allocate_continuation())\n+                __merge_task<_RandomAccessIterator2, _RandomAccessIterator2, _RandomAccessIterator1, _Compare,\n+                             __binary_no_op, __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n+                    _M_zs, __zm, __zm, __ze, _M_xs, _M_comp, __binary_no_op(),\n+                    __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n+                                                                                             __move_sequences));\n+        else\n+        {\n+            auto __move_values = [](_RandomAccessIterator1 __x, _RandomAccessIterator2 __z) { *__z = std::move(*__x); };\n+            auto __move_sequences = [](_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n+                                       _RandomAccessIterator2 __first2) {\n+                return std::move(__first1, __last1, __first2);\n+            };\n+            __m = new (allocate_continuation())\n+                __merge_task<_RandomAccessIterator1, _RandomAccessIterator1, _RandomAccessIterator2, _Compare,\n+                             __binary_no_op, __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>>(\n+                    _M_xs, __xm, __xm, _M_xe, _M_zs, _M_comp, __binary_no_op(),\n+                    __serial_move_merge<decltype(__move_values), decltype(__move_sequences)>(__nmerge, __move_values,\n+                                                                                             __move_sequences));\n+        }\n+        __m->set_ref_count(2);\n+        task* __right = new (__m->allocate_child())\n+            __stable_sort_task(__xm, _M_xe, __zm, !_M_inplace, _M_comp, _M_leaf_sort, __nmerge);\n+        spawn(*__right);\n+        recycle_as_child_of(*__m);\n+        _M_xe = __xm;\n+        _M_inplace = !_M_inplace;\n+    }\n+    return this;\n+}\n+\n+template <class _ExecutionPolicy, typename _RandomAccessIterator, typename _Compare, typename _LeafSort>\n+void\n+__parallel_stable_sort(_ExecutionPolicy&&, _RandomAccessIterator __xs, _RandomAccessIterator __xe, _Compare __comp,\n+                       _LeafSort __leaf_sort, std::size_t __nsort = 0)\n+{\n+    tbb::this_task_arena::isolate([=, &__nsort]() {\n+        //sorting based on task tree and parallel merge\n+        typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n+        typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type _DifferenceType;\n+        const _DifferenceType __n = __xe - __xs;\n+        if (__nsort == 0)\n+            __nsort = __n;\n+\n+        const _DifferenceType __sort_cut_off = __PSTL_STABLE_SORT_CUT_OFF;\n+        if (__n > __sort_cut_off)\n+        {\n+            assert(__nsort > 0 && __nsort <= __n);\n+            __buffer<_ValueType> __buf(__n);\n+            using tbb::task;\n+            task::spawn_root_and_wait(*new (task::allocate_root())\n+                                          __stable_sort_task<_RandomAccessIterator, _ValueType*, _Compare, _LeafSort>(\n+                                              __xs, __xe, (_ValueType*)__buf.get(), 2, __comp, __leaf_sort, __nsort));\n+            return;\n+        }\n+        //serial sort\n+        __leaf_sort(__xs, __xe, __comp);\n+    });\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_merge\n+//------------------------------------------------------------------------\n+\n+template <class _ExecutionPolicy, typename _RandomAccessIterator1, typename _RandomAccessIterator2,\n+          typename _RandomAccessIterator3, typename _Compare, typename _LeafMerge>\n+void\n+__parallel_merge(_ExecutionPolicy&&, _RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe,\n+                 _RandomAccessIterator2 __ys, _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp,\n+                 _LeafMerge __leaf_merge)\n+{\n+    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _DifferenceType1;\n+    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _DifferenceType2;\n+    typedef typename std::common_type<_DifferenceType1, _DifferenceType2>::type _SizeType;\n+    const _SizeType __n = (__xe - __xs) + (__ye - __ys);\n+    const _SizeType __merge_cut_off = __PSTL_MERGE_CUT_OFF;\n+    if (__n <= __merge_cut_off)\n+    {\n+        // Fall back on serial merge\n+        __leaf_merge(__xs, __xe, __ys, __ye, __zs, __comp);\n+    }\n+    else\n+    {\n+        tbb::this_task_arena::isolate([=]() {\n+            typedef __merge_task<_RandomAccessIterator1, _RandomAccessIterator2, _RandomAccessIterator3, _Compare,\n+                                 __binary_no_op, _LeafMerge>\n+                _TaskType;\n+            tbb::task::spawn_root_and_wait(*new (tbb::task::allocate_root()) _TaskType(\n+                __xs, __xe, __ys, __ye, __zs, __comp, __binary_no_op(), __leaf_merge));\n+        });\n+    }\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_invoke\n+//------------------------------------------------------------------------\n+template <class _ExecutionPolicy, typename _F1, typename _F2>\n+void\n+__parallel_invoke(_ExecutionPolicy&&, _F1&& __f1, _F2&& __f2)\n+{\n+    //TODO: a version of tbb::this_task_arena::isolate with variadic arguments pack should be added in the future\n+    tbb::this_task_arena::isolate([&]() { tbb::parallel_invoke(std::forward<_F1>(__f1), std::forward<_F2>(__f2)); });\n+}\n+\n+} // namespace __par_backend\n+} // namespace __pstl\n+\n+#endif /* __PSTL_parallel_backend_tbb_H */"}, {"sha": "4fc63c0387327221088b9a873042f0088e472d8d", "filename": "libstdc++-v3/include/pstl/parallel_backend_utils.h", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_backend_utils.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,195 @@\n+// -*- C++ -*-\n+//===-- parallel_backend_utils.h ------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_parallel_backend_utils_H\n+#define __PSTL_parallel_backend_utils_H\n+\n+#include <iterator>\n+#include <utility>\n+#include \"utils.h\"\n+\n+namespace __pstl\n+{\n+namespace __par_backend\n+{\n+\n+//! Destroy sequence [xs,xe)\n+struct __serial_destroy\n+{\n+    template <typename _RandomAccessIterator>\n+    void\n+    operator()(_RandomAccessIterator __zs, _RandomAccessIterator __ze)\n+    {\n+        typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n+        while (__zs != __ze)\n+        {\n+            --__ze;\n+            (*__ze).~_ValueType();\n+        }\n+    }\n+};\n+\n+//! Merge sequences [__xs,__xe) and [__ys,__ye) to output sequence [__zs,(__xe-__xs)+(__ye-__ys)), using std::move\n+template <class _MoveValues, class _MoveSequences>\n+struct __serial_move_merge\n+{\n+    const std::size_t _M_nmerge;\n+    _MoveValues _M_move_values;\n+    _MoveSequences _M_move_sequences;\n+\n+    explicit __serial_move_merge(std::size_t __nmerge, _MoveValues __move_values, _MoveSequences __move_sequences)\n+        : _M_nmerge(__nmerge), _M_move_values(__move_values), _M_move_sequences(__move_sequences)\n+    {\n+    }\n+    template <class _RandomAccessIterator1, class _RandomAccessIterator2, class _RandomAccessIterator3, class _Compare>\n+    void\n+    operator()(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _RandomAccessIterator2 __ys,\n+               _RandomAccessIterator2 __ye, _RandomAccessIterator3 __zs, _Compare __comp)\n+    {\n+        auto __n = _M_nmerge;\n+        assert(__n > 0);\n+        if (__xs != __xe)\n+        {\n+            if (__ys != __ye)\n+            {\n+                for (;;)\n+                {\n+                    if (__comp(*__ys, *__xs))\n+                    {\n+                        _M_move_values(__ys, __zs);\n+                        ++__zs, --__n;\n+                        if (++__ys == __ye)\n+                        {\n+                            break;\n+                        }\n+                        else if (__n == 0)\n+                        {\n+                            __zs = _M_move_sequences(__ys, __ye, __zs);\n+                            break;\n+                        }\n+                        else\n+                        {\n+                        }\n+                    }\n+                    else\n+                    {\n+                        _M_move_values(__xs, __zs);\n+                        ++__zs, --__n;\n+                        if (++__xs == __xe)\n+                        {\n+                            _M_move_sequences(__ys, __ye, __zs);\n+                            return;\n+                        }\n+                        else if (__n == 0)\n+                        {\n+                            __zs = _M_move_sequences(__xs, __xe, __zs);\n+                            _M_move_sequences(__ys, __ye, __zs);\n+                            return;\n+                        }\n+                        else\n+                        {\n+                        }\n+                    }\n+                }\n+            }\n+            __ys = __xs;\n+            __ye = __xe;\n+        }\n+        _M_move_sequences(__ys, __ye, __zs);\n+    }\n+};\n+\n+template <typename _RandomAccessIterator1, typename _OutputIterator>\n+void\n+__init_buf(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe, _OutputIterator __zs, bool __bMove)\n+{\n+    const _OutputIterator __ze = __zs + (__xe - __xs);\n+    typedef typename std::iterator_traits<_OutputIterator>::value_type _ValueType;\n+    if (__bMove)\n+    {\n+        // Initialize the temporary buffer and move keys to it.\n+        for (; __zs != __ze; ++__xs, ++__zs)\n+            new (&*__zs) _ValueType(std::move(*__xs));\n+    }\n+    else\n+    {\n+        // Initialize the temporary buffer\n+        for (; __zs != __ze; ++__zs)\n+            new (&*__zs) _ValueType;\n+    }\n+}\n+\n+// TODO is this actually used anywhere?\n+template <typename _Buf>\n+class __stack\n+{\n+    typedef typename std::iterator_traits<decltype(_Buf(0).get())>::value_type _ValueType;\n+    typedef typename std::iterator_traits<_ValueType*>::difference_type _DifferenceType;\n+\n+    _Buf _M_buf;\n+    _ValueType* _M_ptr;\n+    _DifferenceType _M_maxsize;\n+\n+    __stack(const __stack&) = delete;\n+    void\n+    operator=(const __stack&) = delete;\n+\n+  public:\n+    __stack(_DifferenceType __max_size) : _M_buf(__max_size), _M_maxsize(__max_size) { _M_ptr = _M_buf.get(); }\n+\n+    ~__stack()\n+    {\n+        assert(size() <= _M_maxsize);\n+        while (!empty())\n+            pop();\n+    }\n+\n+    const _Buf&\n+    buffer() const\n+    {\n+        return _M_buf;\n+    }\n+    size_t\n+    size() const\n+    {\n+        assert(_M_ptr - _M_buf.get() <= _M_maxsize);\n+        assert(_M_ptr - _M_buf.get() >= 0);\n+        return _M_ptr - _M_buf.get();\n+    }\n+    bool\n+    empty() const\n+    {\n+        assert(_M_ptr >= _M_buf.get());\n+        return _M_ptr == _M_buf.get();\n+    }\n+    void\n+    push(const _ValueType& __v)\n+    {\n+        assert(size() < _M_maxsize);\n+        new (_M_ptr) _ValueType(__v);\n+        ++_M_ptr;\n+    }\n+    const _ValueType&\n+    top() const\n+    {\n+        return *(_M_ptr - 1);\n+    }\n+    void\n+    pop()\n+    {\n+        assert(_M_ptr > _M_buf.get());\n+        --_M_ptr;\n+        (*_M_ptr).~_ValueType();\n+    }\n+};\n+\n+} // namespace __par_backend\n+} // namespace __pstl\n+\n+#endif /* __PSTL_parallel_backend_utils_H */"}, {"sha": "2498003098a3313a1ed71b10e778476051dcf92a", "filename": "libstdc++-v3/include/pstl/parallel_impl.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fparallel_impl.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,81 @@\n+// -*- C++ -*-\n+//===-- parallel_impl.h ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_parallel_impl_H\n+#define __PSTL_parallel_impl_H\n+\n+#include <atomic>\n+// This header defines the minimum set of parallel routines required to support Parallel STL,\n+// implemented on top of Intel(R) Threading Building Blocks (Intel(R) TBB) library\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+//------------------------------------------------------------------------\n+// parallel_find\n+//-----------------------------------------------------------------------\n+/** Return extremum value returned by brick f[i,j) for subranges [i,j) of [first,last)\n+Each f[i,j) must return a value in [i,j). */\n+template <class _ExecutionPolicy, class _Index, class _Brick, class _Compare>\n+_Index\n+__parallel_find(_ExecutionPolicy&& __exec, _Index __first, _Index __last, _Brick __f, _Compare __comp, bool __b_first)\n+{\n+    typedef typename std::iterator_traits<_Index>::difference_type _DifferenceType;\n+    const _DifferenceType __n = __last - __first;\n+    _DifferenceType __initial_dist = __b_first ? __n : -1;\n+    std::atomic<_DifferenceType> __extremum(__initial_dist);\n+    // TODO: find out what is better here: parallel_for or parallel_reduce\n+    __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                  [__comp, __f, __first, &__extremum](_Index __i, _Index __j) {\n+                                      // See \"Reducing Contention Through Priority Updates\", PPoPP '13, for discussion of\n+                                      // why using a shared variable scales fairly well in this situation.\n+                                      if (__comp(__i - __first, __extremum))\n+                                      {\n+                                          _Index __res = __f(__i, __j);\n+                                          // If not '__last' returned then we found what we want so put this to extremum\n+                                          if (__res != __j)\n+                                          {\n+                                              const _DifferenceType __k = __res - __first;\n+                                              for (_DifferenceType __old = __extremum; __comp(__k, __old);\n+                                                   __old = __extremum)\n+                                              {\n+                                                  __extremum.compare_exchange_weak(__old, __k);\n+                                              }\n+                                          }\n+                                      }\n+                                  });\n+    return __extremum != __initial_dist ? __first + __extremum : __last;\n+}\n+\n+//------------------------------------------------------------------------\n+// parallel_or\n+//------------------------------------------------------------------------\n+//! Return true if brick f[i,j) returns true for some subrange [i,j) of [first,last)\n+template <class _ExecutionPolicy, class _Index, class _Brick>\n+bool\n+__parallel_or(_ExecutionPolicy&& __exec, _Index __first, _Index __last, _Brick __f)\n+{\n+    std::atomic<bool> __found(false);\n+    __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec), __first, __last,\n+                                  [__f, &__found](_Index __i, _Index __j) {\n+                                      if (!__found.load(std::memory_order_relaxed) && __f(__i, __j))\n+                                      {\n+                                          __found.store(true, std::memory_order_relaxed);\n+                                          __par_backend::__cancel_execution();\n+                                      }\n+                                  });\n+    return __found;\n+}\n+\n+} // namespace __internal\n+} // namespace __pstl\n+\n+#endif /* __PSTL_parallel_impl_H */"}, {"sha": "d799028c592b331c61bf37a1e3b9c487c59912c1", "filename": "libstdc++-v3/include/pstl/pstl_config.h", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fpstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fpstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Fpstl_config.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,174 @@\n+// -*- C++ -*-\n+//===-- pstl_config.h -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_config_H\n+#define __PSTL_config_H\n+\n+#define PSTL_VERSION 203\n+#define PSTL_VERSION_MAJOR (PSTL_VERSION / 100)\n+#define PSTL_VERSION_MINOR (PSTL_VERSION - PSTL_VERSION_MAJOR * 100)\n+\n+// Check the user-defined macro for parallel policies\n+#if defined(PSTL_USE_PARALLEL_POLICIES)\n+#undef __PSTL_USE_PAR_POLICIES\n+#define __PSTL_USE_PAR_POLICIES PSTL_USE_PARALLEL_POLICIES\n+// Check the internal macro for parallel policies\n+#elif !defined(__PSTL_USE_PAR_POLICIES)\n+#define __PSTL_USE_PAR_POLICIES 1\n+#endif\n+\n+#if __PSTL_USE_PAR_POLICIES\n+#if !defined(__PSTL_PAR_BACKEND_TBB)\n+#define __PSTL_PAR_BACKEND_TBB 1\n+#endif\n+#else\n+#undef __PSTL_PAR_BACKEND_TBB\n+#endif\n+\n+// Check the user-defined macro for warnings\n+#if defined(PSTL_USAGE_WARNINGS)\n+#undef __PSTL_USAGE_WARNINGS\n+#define __PSTL_USAGE_WARNINGS PSTL_USAGE_WARNINGS\n+// Check the internal macro for warnings\n+#elif !defined(__PSTL_USAGE_WARNINGS)\n+#define __PSTL_USAGE_WARNINGS 0\n+#endif\n+\n+// Portability \"#pragma\" definition\n+#ifdef _MSC_VER\n+#define __PSTL_PRAGMA(x) __pragma(x)\n+#else\n+#define __PSTL_PRAGMA(x) _Pragma(#x)\n+#endif\n+\n+#define __PSTL_STRING_AUX(x) #x\n+#define __PSTL_STRING(x) __PSTL_STRING_AUX(x)\n+#define __PSTL_STRING_CONCAT(x, y) x #y\n+\n+// note that when ICC or Clang is in use, __PSTL_GCC_VERSION might not fully match\n+// the actual GCC version on the system.\n+#define __PSTL_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n+\n+#if __clang__\n+// according to clang documentation, version can be vendor specific\n+#define __PSTL_CLANG_VERSION (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__)\n+#endif\n+\n+// Enable SIMD for compilers that support OpenMP 4.0\n+#if (_OPENMP >= 201307) || (__INTEL_COMPILER >= 1600) || (!defined(__INTEL_COMPILER) && __PSTL_GCC_VERSION >= 40900)\n+#define __PSTL_PRAGMA_SIMD __PSTL_PRAGMA(omp simd)\n+#define __PSTL_PRAGMA_DECLARE_SIMD __PSTL_PRAGMA(omp declare simd)\n+#define __PSTL_PRAGMA_SIMD_REDUCTION(PRM) __PSTL_PRAGMA(omp simd reduction(PRM))\n+#elif !defined(_MSC_VER) //#pragma simd\n+#define __PSTL_PRAGMA_SIMD __PSTL_PRAGMA(simd)\n+#define __PSTL_PRAGMA_DECLARE_SIMD\n+#define __PSTL_PRAGMA_SIMD_REDUCTION(PRM) __PSTL_PRAGMA(simd reduction(PRM))\n+#else //no simd\n+#define __PSTL_PRAGMA_SIMD\n+#define __PSTL_PRAGMA_DECLARE_SIMD\n+#define __PSTL_PRAGMA_SIMD_REDUCTION(PRM)\n+#endif //Enable SIMD\n+\n+#if (__INTEL_COMPILER)\n+#define __PSTL_PRAGMA_FORCEINLINE __PSTL_PRAGMA(forceinline)\n+#else\n+#define __PSTL_PRAGMA_FORCEINLINE\n+#endif\n+\n+#if (__INTEL_COMPILER >= 1900)\n+#define __PSTL_PRAGMA_SIMD_SCAN(PRM) __PSTL_PRAGMA(omp simd reduction(inscan, PRM))\n+#define __PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM) __PSTL_PRAGMA(omp scan inclusive(PRM))\n+#define __PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM) __PSTL_PRAGMA(omp scan exclusive(PRM))\n+#else\n+#define __PSTL_PRAGMA_SIMD_SCAN(PRM)\n+#define __PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM)\n+#define __PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM)\n+#endif\n+\n+// Should be defined to 1 for environments with a vendor implementation of C++17 execution policies\n+#define __PSTL_CPP17_EXECUTION_POLICIES_PRESENT (_MSC_VER >= 1912)\n+\n+#define __PSTL_CPP14_2RANGE_MISMATCH_EQUAL_PRESENT                                                                     \\\n+    (_MSC_VER >= 1900 || __cplusplus >= 201300L || __cpp_lib_robust_nonmodifying_seq_ops == 201304)\n+#define __PSTL_CPP14_MAKE_REVERSE_ITERATOR_PRESENT                                                                     \\\n+    (_MSC_VER >= 1900 || __cplusplus >= 201402L || __cpp_lib_make_reverse_iterator == 201402)\n+#define __PSTL_CPP14_INTEGER_SEQUENCE_PRESENT (_MSC_VER >= 1900 || __cplusplus >= 201402L)\n+#define __PSTL_CPP14_VARIABLE_TEMPLATES_PRESENT                                                                        \\\n+    (!__INTEL_COMPILER || __INTEL_COMPILER >= 1700) && (_MSC_FULL_VER >= 190023918 || __cplusplus >= 201402L)\n+\n+#define __PSTL_EARLYEXIT_PRESENT (__INTEL_COMPILER >= 1800)\n+#define __PSTL_MONOTONIC_PRESENT (__INTEL_COMPILER >= 1800)\n+\n+#if (__INTEL_COMPILER >= 1900 || !defined(__INTEL_COMPILER) && __PSTL_GCC_VERSION >= 40900 || _OPENMP >= 201307)\n+#define __PSTL_UDR_PRESENT 1\n+#else\n+#define __PSTL_UDR_PRESENT 0\n+#endif\n+\n+#define __PSTL_UDS_PRESENT (__INTEL_COMPILER >= 1900 && __INTEL_COMPILER_BUILD_DATE >= 20180626)\n+\n+#if __PSTL_EARLYEXIT_PRESENT\n+#define __PSTL_PRAGMA_SIMD_EARLYEXIT __PSTL_PRAGMA(omp simd early_exit)\n+#else\n+#define __PSTL_PRAGMA_SIMD_EARLYEXIT\n+#endif\n+\n+#if __PSTL_MONOTONIC_PRESENT\n+#define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(PRM) __PSTL_PRAGMA(omp ordered simd monotonic(PRM))\n+#define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(PRM1, PRM2) __PSTL_PRAGMA(omp ordered simd monotonic(PRM1, PRM2))\n+#else\n+#define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(PRM)\n+#define __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(PRM1, PRM2)\n+#endif\n+\n+// Declaration of reduction functor, where\n+// NAME - the name of the functor\n+// OP - type of the callable object with the reduction operation\n+// omp_in - refers to the local partial result\n+// omp_out - refers to the final value of the combiner operator\n+// omp_priv - refers to the private copy of the initial value\n+// omp_orig - refers to the original variable to be reduced\n+#define __PSTL_PRAGMA_DECLARE_REDUCTION(NAME, OP)                                                                      \\\n+    __PSTL_PRAGMA(omp declare reduction(NAME : OP : omp_out(omp_in)) initializer(omp_priv = omp_orig))\n+\n+#if (__INTEL_COMPILER >= 1600)\n+#define __PSTL_PRAGMA_VECTOR_UNALIGNED __PSTL_PRAGMA(vector unaligned)\n+#else\n+#define __PSTL_PRAGMA_VECTOR_UNALIGNED\n+#endif\n+\n+// Check the user-defined macro to use non-temporal stores\n+#if defined(PSTL_USE_NONTEMPORAL_STORES) && (__INTEL_COMPILER >= 1600)\n+#define __PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED __PSTL_PRAGMA(vector nontemporal)\n+#else\n+#define __PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED\n+#endif\n+\n+#if _MSC_VER || __INTEL_COMPILER //the preprocessors don't type a message location\n+#define __PSTL_PRAGMA_LOCATION __FILE__ \":\" __PSTL_STRING(__LINE__) \": [Parallel STL message]: \"\n+#else\n+#define __PSTL_PRAGMA_LOCATION \" [Parallel STL message]: \"\n+#endif\n+\n+#define __PSTL_PRAGMA_MESSAGE_IMPL(x) __PSTL_PRAGMA(message(__PSTL_STRING_CONCAT(__PSTL_PRAGMA_LOCATION, x)))\n+\n+#if __PSTL_USAGE_WARNINGS\n+#define __PSTL_PRAGMA_MESSAGE(x) __PSTL_PRAGMA_MESSAGE_IMPL(x)\n+#define __PSTL_PRAGMA_MESSAGE_POLICIES(x) __PSTL_PRAGMA_MESSAGE_IMPL(x)\n+#else\n+#define __PSTL_PRAGMA_MESSAGE(x)\n+#define __PSTL_PRAGMA_MESSAGE_POLICIES(x)\n+#endif\n+\n+// broken macros\n+#define __PSTL_CPP11_STD_ROTATE_BROKEN ((__GLIBCXX__ && __GLIBCXX__ < 20150716) || (_MSC_VER && _MSC_VER < 1800))\n+\n+#define __PSTL_ICC_18_OMP_SIMD_BROKEN (__INTEL_COMPILER == 1800)\n+\n+#endif /* __PSTL_config_H */"}, {"sha": "b48b07b271c8c839df7ee1c19e06c739d38eeffb", "filename": "libstdc++-v3/include/pstl/unseq_backend_simd.h", "status": "added", "additions": 855, "deletions": 0, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Funseq_backend_simd.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,855 @@\n+// -*- C++ -*-\n+//===-- unseq_backend_simd.h ----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_unseq_backend_simd_H\n+#define __PSTL_unseq_backend_simd_H\n+\n+#include <type_traits>\n+\n+#include \"utils.h\"\n+\n+// This header defines the minimum set of vector routines required\n+// to support parallel STL.\n+namespace __pstl\n+{\n+namespace __unseq_backend\n+{\n+\n+// Expect vector width up to 64 (or 512 bit)\n+const std::size_t __lane_size = 64;\n+\n+template <class _Iterator, class _DifferenceType, class _Function>\n+_Iterator\n+__simd_walk_1(_Iterator __first, _DifferenceType __n, _Function __f) noexcept\n+{\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        __f(__first[__i]);\n+\n+    return __first + __n;\n+}\n+\n+template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Function>\n+_Iterator2\n+__simd_walk_2(_Iterator1 __first1, _DifferenceType __n, _Iterator2 __first2, _Function __f) noexcept\n+{\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        __f(__first1[__i], __first2[__i]);\n+    return __first2 + __n;\n+}\n+\n+template <class _Iterator1, class _DifferenceType, class _Iterator2, class _Iterator3, class _Function>\n+_Iterator3\n+__simd_walk_3(_Iterator1 __first1, _DifferenceType __n, _Iterator2 __first2, _Iterator3 __first3,\n+              _Function __f) noexcept\n+{\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        __f(__first1[__i], __first2[__i], __first3[__i]);\n+    return __first3 + __n;\n+}\n+\n+// TODO: check whether __simd_first() can be used here\n+template <class _Index, class _DifferenceType, class _Pred>\n+bool\n+__simd_or(_Index __first, _DifferenceType __n, _Pred __pred) noexcept\n+{\n+#if __PSTL_EARLYEXIT_PRESENT\n+    _DifferenceType __i;\n+    __PSTL_PRAGMA_VECTOR_UNALIGNED\n+    __PSTL_PRAGMA_SIMD_EARLYEXIT\n+    for (__i = 0; __i < __n; ++__i)\n+        if (__pred(__first[__i]))\n+            break;\n+    return __i < __n;\n+#else\n+    _DifferenceType __block_size = 4 < __n ? 4 : __n;\n+    const _Index __last = __first + __n;\n+    while (__last != __first)\n+    {\n+        int32_t __flag = 1;\n+        __PSTL_PRAGMA_SIMD_REDUCTION(& : __flag)\n+        for (_DifferenceType __i = 0; __i < __block_size; ++__i)\n+            if (__pred(*(__first + __i)))\n+                __flag = 0;\n+        if (!__flag)\n+            return true;\n+\n+        __first += __block_size;\n+        if (__last - __first >= __block_size << 1)\n+        {\n+            // Double the block _Size.  Any unnecessary iterations can be amortized against work done so far.\n+            __block_size <<= 1;\n+        }\n+        else\n+        {\n+            __block_size = __last - __first;\n+        }\n+    }\n+    return false;\n+#endif\n+}\n+\n+template <class _Index, class _DifferenceType, class _Compare>\n+_Index\n+__simd_first(_Index __first, _DifferenceType __begin, _DifferenceType __end, _Compare __comp) noexcept\n+{\n+#if __PSTL_EARLYEXIT_PRESENT\n+    _DifferenceType __i = __begin;\n+    __PSTL_PRAGMA_VECTOR_UNALIGNED // Do not generate peel loop part\n+        __PSTL_PRAGMA_SIMD_EARLYEXIT for (; __i < __end; ++__i)\n+    {\n+        if (__comp(__first, __i))\n+        {\n+            break;\n+        }\n+    }\n+    return __first + __i;\n+#else\n+    // Experiments show good block sizes like this\n+    const _DifferenceType __block_size = 8;\n+    alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};\n+    while (__end - __begin >= __block_size)\n+    {\n+        _DifferenceType __found = 0;\n+        __PSTL_PRAGMA_VECTOR_UNALIGNED // Do not generate peel loop part\n+            __PSTL_PRAGMA_SIMD_REDUCTION(|\n+                                         : __found) for (_DifferenceType __i = __begin; __i < __begin + __block_size;\n+                                                         ++__i)\n+        {\n+            const _DifferenceType __t = __comp(__first, __i);\n+            __lane[__i - __begin] = __t;\n+            __found |= __t;\n+        }\n+        if (__found)\n+        {\n+            _DifferenceType __i;\n+            // This will vectorize\n+            for (__i = 0; __i < __block_size; ++__i)\n+            {\n+                if (__lane[__i])\n+                {\n+                    break;\n+                }\n+            }\n+            return __first + __begin + __i;\n+        }\n+        __begin += __block_size;\n+    }\n+\n+    //Keep remainder scalar\n+    while (__begin != __end)\n+    {\n+        if (__comp(__first, __begin))\n+        {\n+            return __first + __begin;\n+        }\n+        ++__begin;\n+    }\n+    return __first + __end;\n+#endif //__PSTL_EARLYEXIT_PRESENT\n+}\n+\n+template <class _Index1, class _DifferenceType, class _Index2, class _Pred>\n+std::pair<_Index1, _Index2>\n+__simd_first(_Index1 __first1, _DifferenceType __n, _Index2 __first2, _Pred __pred) noexcept\n+{\n+#if __PSTL_EARLYEXIT_PRESENT\n+    _DifferenceType __i = 0;\n+    __PSTL_PRAGMA_VECTOR_UNALIGNED\n+    __PSTL_PRAGMA_SIMD_EARLYEXIT\n+    for (; __i < __n; ++__i)\n+        if (__pred(__first1[__i], __first2[__i]))\n+            break;\n+    return std::make_pair(__first1 + __i, __first2 + __i);\n+#else\n+    const _Index1 __last1 = __first1 + __n;\n+    const _Index2 __last2 = __first2 + __n;\n+    // Experiments show good block sizes like this\n+    const _DifferenceType __block_size = 8;\n+    alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};\n+    while (__last1 - __first1 >= __block_size)\n+    {\n+        _DifferenceType __found = 0;\n+        _DifferenceType __i;\n+        __PSTL_PRAGMA_VECTOR_UNALIGNED // Do not generate peel loop part\n+            __PSTL_PRAGMA_SIMD_REDUCTION(|\n+                                         : __found) for (__i = 0; __i < __block_size; ++__i)\n+        {\n+            const _DifferenceType __t = __pred(__first1[__i], __first2[__i]);\n+            __lane[__i] = __t;\n+            __found |= __t;\n+        }\n+        if (__found)\n+        {\n+            _DifferenceType __i;\n+            // This will vectorize\n+            for (__i = 0; __i < __block_size; ++__i)\n+            {\n+                if (__lane[__i])\n+                    break;\n+            }\n+            return std::make_pair(__first1 + __i, __first2 + __i);\n+        }\n+        __first1 += __block_size;\n+        __first2 += __block_size;\n+    }\n+\n+    //Keep remainder scalar\n+    for (; __last1 != __first1; ++__first1, ++__first2)\n+        if (__pred(*(__first1), *(__first2)))\n+            return std::make_pair(__first1, __first2);\n+\n+    return std::make_pair(__last1, __last2);\n+#endif //__PSTL_EARLYEXIT_PRESENT\n+}\n+\n+template <class _Index, class _DifferenceType, class _Pred>\n+_DifferenceType\n+__simd_count(_Index __index, _DifferenceType __n, _Pred __pred) noexcept\n+{\n+    _DifferenceType __count = 0;\n+    __PSTL_PRAGMA_SIMD_REDUCTION(+ : __count)\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        if (__pred(*(__index + __i)))\n+            ++__count;\n+\n+    return __count;\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _OutputIterator, class _BinaryPredicate>\n+_OutputIterator\n+__simd_unique_copy(_InputIterator __first, _DifferenceType __n, _OutputIterator __result,\n+                   _BinaryPredicate __pred) noexcept\n+{\n+    if (__n == 0)\n+        return __result;\n+\n+    _DifferenceType __cnt = 1;\n+    __result[0] = __first[0];\n+\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 1; __i < __n; ++__i)\n+    {\n+        __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(__cnt : 1)\n+        if (!__pred(__first[__i], __first[__i - 1]))\n+        {\n+            __result[__cnt] = __first[__i];\n+            ++__cnt;\n+        }\n+    }\n+    return __result + __cnt;\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _OutputIterator, class _Assigner>\n+_OutputIterator\n+__simd_assign(_InputIterator __first, _DifferenceType __n, _OutputIterator __result, _Assigner __assigner) noexcept\n+{\n+    __PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        __assigner(__first + __i, __result + __i);\n+    return __result + __n;\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _OutputIterator, class _UnaryPredicate>\n+_OutputIterator\n+__simd_copy_if(_InputIterator __first, _DifferenceType __n, _OutputIterator __result, _UnaryPredicate __pred) noexcept\n+{\n+    _DifferenceType __cnt = 0;\n+\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+    {\n+        __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(__cnt : 1)\n+        if (__pred(__first[__i]))\n+        {\n+            __result[__cnt] = __first[__i];\n+            ++__cnt;\n+        }\n+    }\n+    return __result + __cnt;\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _BinaryPredicate>\n+_DifferenceType\n+__simd_calc_mask_2(_InputIterator __first, _DifferenceType __n, bool* __mask, _BinaryPredicate __pred) noexcept\n+{\n+    _DifferenceType __count = 0;\n+\n+    __PSTL_PRAGMA_SIMD_REDUCTION(+ : __count)\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+    {\n+        __mask[__i] = !__pred(__first[__i], __first[__i - 1]);\n+        __count += __mask[__i];\n+    }\n+    return __count;\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _UnaryPredicate>\n+_DifferenceType\n+__simd_calc_mask_1(_InputIterator __first, _DifferenceType __n, bool* __mask, _UnaryPredicate __pred) noexcept\n+{\n+    _DifferenceType __count = 0;\n+\n+    __PSTL_PRAGMA_SIMD_REDUCTION(+ : __count)\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+    {\n+        __mask[__i] = __pred(__first[__i]);\n+        __count += __mask[__i];\n+    }\n+    return __count;\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _OutputIterator, class _Assigner>\n+void\n+__simd_copy_by_mask(_InputIterator __first, _DifferenceType __n, _OutputIterator __result, bool* __mask,\n+                    _Assigner __assigner) noexcept\n+{\n+    _DifferenceType __cnt = 0;\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+    {\n+        if (__mask[__i])\n+        {\n+            __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(__cnt : 1)\n+            {\n+                __assigner(__first + __i, __result + __cnt);\n+                ++__cnt;\n+            }\n+        }\n+    }\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _OutputIterator1, class _OutputIterator2>\n+void\n+__simd_partition_by_mask(_InputIterator __first, _DifferenceType __n, _OutputIterator1 __out_true,\n+                         _OutputIterator2 __out_false, bool* __mask) noexcept\n+{\n+    _DifferenceType __cnt_true = 0, __cnt_false = 0;\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+    {\n+        __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(__cnt_true : 1, __cnt_false : 1)\n+        if (__mask[__i])\n+        {\n+            __out_true[__cnt_true] = __first[__i];\n+            ++__cnt_true;\n+        }\n+        else\n+        {\n+            __out_false[__cnt_false] = __first[__i];\n+            ++__cnt_false;\n+        }\n+    }\n+}\n+\n+template <class _Index, class _DifferenceType, class _Tp>\n+_Index\n+__simd_fill_n(_Index __first, _DifferenceType __n, const _Tp& __value) noexcept\n+{\n+    __PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        __first[__i] = __value;\n+    return __first + __n;\n+}\n+\n+template <class _Index, class _DifferenceType, class _Generator>\n+_Index\n+__simd_generate_n(_Index __first, _DifferenceType __size, _Generator __g) noexcept\n+{\n+    __PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __size; ++__i)\n+        __first[__i] = __g();\n+    return __first + __size;\n+}\n+\n+template <class _Index, class _BinaryPredicate>\n+_Index\n+__simd_adjacent_find(_Index __first, _Index __last, _BinaryPredicate __pred, bool __or_semantic) noexcept\n+{\n+    if (__last - __first < 2)\n+        return __last;\n+\n+    typedef typename std::iterator_traits<_Index>::difference_type _DifferenceType;\n+    _DifferenceType __i = 0;\n+\n+#if __PSTL_EARLYEXIT_PRESENT\n+    //Some compiler versions fail to compile the following loop when iterators are used. Indices are used instead\n+    const _DifferenceType __n = __last - __first - 1;\n+    __PSTL_PRAGMA_VECTOR_UNALIGNED\n+    __PSTL_PRAGMA_SIMD_EARLYEXIT\n+    for (; __i < __n; ++__i)\n+        if (__pred(__first[__i], __first[__i + 1]))\n+            break;\n+\n+    return __i < __n ? __first + __i : __last;\n+#else\n+    // Experiments show good block sizes like this\n+    //TODO: to consider tuning block_size for various data types\n+    const _DifferenceType __block_size = 8;\n+    alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};\n+    while (__last - __first >= __block_size)\n+    {\n+        _DifferenceType __found = 0;\n+        __PSTL_PRAGMA_VECTOR_UNALIGNED // Do not generate peel loop part\n+            __PSTL_PRAGMA_SIMD_REDUCTION(|\n+                                         : __found) for (__i = 0; __i < __block_size - 1; ++__i)\n+        {\n+            //TODO: to improve SIMD vectorization\n+            const _DifferenceType __t = __pred(*(__first + __i), *(__first + __i + 1));\n+            __lane[__i] = __t;\n+            __found |= __t;\n+        }\n+\n+        //Process a pair of elements on a boundary of a data block\n+        if (__first + __block_size < __last && __pred(*(__first + __i), *(__first + __i + 1)))\n+            __lane[__i] = __found = 1;\n+\n+        if (__found)\n+        {\n+            if (__or_semantic)\n+                return __first;\n+\n+            // This will vectorize\n+            for (__i = 0; __i < __block_size; ++__i)\n+                if (__lane[__i])\n+                    break;\n+            return __first + __i; //As far as found is true a __result (__lane[__i] is true) is guaranteed\n+        }\n+        __first += __block_size;\n+    }\n+    //Process the rest elements\n+    for (; __last - __first > 1; ++__first)\n+        if (__pred(*__first, *(__first + 1)))\n+            return __first;\n+\n+    return __last;\n+#endif\n+}\n+\n+// It was created to reduce the code inside std::enable_if\n+template <typename _Tp, typename _BinaryOperation>\n+using is_arithmetic_plus = std::integral_constant<bool, std::is_arithmetic<_Tp>::value &&\n+                                                            std::is_same<_BinaryOperation, std::plus<_Tp>>::value>;\n+\n+template <typename _DifferenceType, typename _Tp, typename _BinaryOperation, typename _UnaryOperation>\n+typename std::enable_if<is_arithmetic_plus<_Tp, _BinaryOperation>::value, _Tp>::type\n+__simd_transform_reduce(_DifferenceType __n, _Tp __init, _BinaryOperation, _UnaryOperation __f) noexcept\n+{\n+    __PSTL_PRAGMA_SIMD_REDUCTION(+ : __init)\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+        __init += __f(__i);\n+    return __init;\n+}\n+\n+template <typename _Size, typename _Tp, typename _BinaryOperation, typename _UnaryOperation>\n+typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value, _Tp>::type\n+__simd_transform_reduce(_Size __n, _Tp __init, _BinaryOperation __binary_op, _UnaryOperation __f) noexcept\n+{\n+    const std::size_t __block_size = __lane_size / sizeof(_Tp);\n+    if (__n > 2 * __block_size && __block_size > 1)\n+    {\n+        alignas(__lane_size) char __lane_[__lane_size];\n+        _Tp* __lane = reinterpret_cast<_Tp*>(__lane_);\n+\n+        // initializer\n+        __PSTL_PRAGMA_SIMD\n+        for (_Size __i = 0; __i < __block_size; ++__i)\n+        {\n+            ::new (__lane + __i) _Tp(__binary_op(__f(__i), __f(__block_size + __i)));\n+        }\n+        // main loop\n+        _Size __i = 2 * __block_size;\n+        const _Size last_iteration = __block_size * (__n / __block_size);\n+        for (; __i < last_iteration; __i += __block_size)\n+        {\n+            __PSTL_PRAGMA_SIMD\n+            for (_Size __j = 0; __j < __block_size; ++__j)\n+            {\n+                __lane[__j] = __binary_op(__lane[__j], __f(__i + __j));\n+            }\n+        }\n+        // remainder\n+        __PSTL_PRAGMA_SIMD\n+        for (_Size __j = 0; __j < __n - last_iteration; ++__j)\n+        {\n+            __lane[__j] = __binary_op(__lane[__j], __f(last_iteration + __j));\n+        }\n+        // combiner\n+        for (_Size __i = 0; __i < __block_size; ++__i)\n+        {\n+            __init = __binary_op(__init, __lane[__i]);\n+        }\n+        // destroyer\n+        __PSTL_PRAGMA_SIMD\n+        for (_Size __i = 0; __i < __block_size; ++__i)\n+        {\n+            __lane[__i].~_Tp();\n+        }\n+    }\n+    else\n+    {\n+        for (_Size __i = 0; __i < __n; ++__i)\n+        {\n+            __init = __binary_op(__init, __f(__i));\n+        }\n+    }\n+    return __init;\n+}\n+\n+// Exclusive scan for \"+\" and arithmetic types\n+template <class _InputIterator, class _Size, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation>\n+typename std::enable_if<is_arithmetic_plus<_Tp, _BinaryOperation>::value, std::pair<_OutputIterator, _Tp>>::type\n+__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init,\n+            _BinaryOperation, /*Inclusive*/ std::false_type)\n+{\n+    __PSTL_PRAGMA_SIMD_SCAN(+ : __init)\n+    for (_Size __i = 0; __i < __n; ++__i)\n+    {\n+        __result[__i] = __init;\n+        __PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(__init)\n+        __init += __unary_op(__first[__i]);\n+    }\n+    return std::make_pair(__result + __n, __init);\n+}\n+\n+// As soon as we cannot call __binary_op in \"combiner\" we create a wrapper over _Tp to encapsulate __binary_op\n+template <typename _Tp, typename _BinaryOp>\n+struct _Combiner\n+{\n+    _Tp __value;\n+    _BinaryOp* __bin_op; // Here is a pointer to function because of default ctor\n+\n+    _Combiner() : __value{}, __bin_op(nullptr) {}\n+    _Combiner(const _Tp& value, const _BinaryOp* bin_op) : __value(value), __bin_op(const_cast<_BinaryOp*>(bin_op)) {}\n+    _Combiner(const _Combiner& __obj) : __value{}, __bin_op(__obj.__bin_op) {}\n+\n+    void\n+    operator()(const _Combiner& __obj)\n+    {\n+        __value = (*__bin_op)(__value, __obj.__value);\n+    }\n+};\n+\n+// Exclusive scan for other binary operations and types\n+template <class _InputIterator, class _Size, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation>\n+typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value, std::pair<_OutputIterator, _Tp>>::type\n+__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init,\n+            _BinaryOperation __binary_op, /*Inclusive*/ std::false_type)\n+{\n+    typedef _Combiner<_Tp, _BinaryOperation> _CombinerType;\n+    _CombinerType __init_{__init, &__binary_op};\n+\n+    __PSTL_PRAGMA_DECLARE_REDUCTION(__bin_op, _CombinerType)\n+\n+    __PSTL_PRAGMA_SIMD_SCAN(__bin_op : __init_)\n+    for (_Size __i = 0; __i < __n; ++__i)\n+    {\n+        __result[__i] = __init_.__value;\n+        __PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(__init_)\n+        __PSTL_PRAGMA_FORCEINLINE\n+        __init_.__value = __binary_op(__init_.__value, __unary_op(__first[__i]));\n+    }\n+    return std::make_pair(__result + __n, __init_.__value);\n+}\n+\n+// Inclusive scan for \"+\" and arithmetic types\n+template <class _InputIterator, class _Size, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation>\n+typename std::enable_if<is_arithmetic_plus<_Tp, _BinaryOperation>::value, std::pair<_OutputIterator, _Tp>>::type\n+__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init,\n+            _BinaryOperation, /*Inclusive*/ std::true_type)\n+{\n+    __PSTL_PRAGMA_SIMD_SCAN(+ : __init)\n+    for (_Size __i = 0; __i < __n; ++__i)\n+    {\n+        __init += __unary_op(__first[__i]);\n+        __PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(__init)\n+        __result[__i] = __init;\n+    }\n+    return std::make_pair(__result + __n, __init);\n+}\n+\n+// Inclusive scan for other binary operations and types\n+template <class _InputIterator, class _Size, class _OutputIterator, class _UnaryOperation, class _Tp,\n+          class _BinaryOperation>\n+typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value, std::pair<_OutputIterator, _Tp>>::type\n+__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result, _UnaryOperation __unary_op, _Tp __init,\n+            _BinaryOperation __binary_op, std::true_type)\n+{\n+    typedef _Combiner<_Tp, _BinaryOperation> _CombinerType;\n+    _CombinerType __init_{__init, &__binary_op};\n+\n+    __PSTL_PRAGMA_DECLARE_REDUCTION(__bin_op, _CombinerType)\n+\n+    __PSTL_PRAGMA_SIMD_SCAN(__bin_op : __init_)\n+    for (_Size __i = 0; __i < __n; ++__i)\n+    {\n+        __PSTL_PRAGMA_FORCEINLINE\n+        __init_.__value = __binary_op(__init_.__value, __unary_op(__first[__i]));\n+        __PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(__init_)\n+        __result[__i] = __init_.__value;\n+    }\n+    return std::make_pair(__result + __n, __init_.__value);\n+}\n+\n+// [restriction] - std::iterator_traits<_ForwardIterator>::value_type should be DefaultConstructible.\n+// complexity [violation] - We will have at most (__n-1 + number_of_lanes) comparisons instead of at most __n-1.\n+template <typename _ForwardIterator, typename _Size, typename _Compare>\n+_ForwardIterator\n+__simd_min_element(_ForwardIterator __first, _Size __n, _Compare __comp) noexcept\n+{\n+    if (__n == 0)\n+    {\n+        return __first;\n+    }\n+\n+    typedef typename std::iterator_traits<_ForwardIterator>::value_type _ValueType;\n+    struct _ComplexType\n+    {\n+        _ValueType __min_val;\n+        _Size __min_ind;\n+        _Compare* __min_comp;\n+\n+        _ComplexType() : __min_val{}, __min_ind{}, __min_comp(nullptr) {}\n+        _ComplexType(const _ValueType& val, const _Compare* comp)\n+            : __min_val(val), __min_ind(0), __min_comp(const_cast<_Compare*>(comp))\n+        {\n+        }\n+        _ComplexType(const _ComplexType& __obj)\n+            : __min_val(__obj.__min_val), __min_ind(__obj.__min_ind), __min_comp(__obj.__min_comp)\n+        {\n+        }\n+\n+        __PSTL_PRAGMA_DECLARE_SIMD\n+        void\n+        operator()(const _ComplexType& __obj)\n+        {\n+            if (!(*__min_comp)(__min_val, __obj.__min_val) &&\n+                ((*__min_comp)(__obj.__min_val, __min_val) || __obj.__min_ind - __min_ind < 0))\n+            {\n+                __min_val = __obj.__min_val;\n+                __min_ind = __obj.__min_ind;\n+            }\n+        }\n+    };\n+\n+    _ComplexType __init{*__first, &__comp};\n+\n+    __PSTL_PRAGMA_DECLARE_REDUCTION(__min_func, _ComplexType)\n+\n+    __PSTL_PRAGMA_SIMD_REDUCTION(__min_func : __init)\n+    for (_Size __i = 1; __i < __n; ++__i)\n+    {\n+        const _ValueType __min_val = __init.__min_val;\n+        const _ValueType __current = __first[__i];\n+        if (__comp(__current, __min_val))\n+        {\n+            __init.__min_val = __current;\n+            __init.__min_ind = __i;\n+        }\n+    }\n+    return __first + __init.__min_ind;\n+}\n+\n+// [restriction] - std::iterator_traits<_ForwardIterator>::value_type should be DefaultConstructible.\n+// complexity [violation] - We will have at most (2*(__n-1) + 4*number_of_lanes) comparisons instead of at most [1.5*(__n-1)].\n+template <typename _ForwardIterator, typename _Size, typename _Compare>\n+std::pair<_ForwardIterator, _ForwardIterator>\n+__simd_minmax_element(_ForwardIterator __first, _Size __n, _Compare __comp) noexcept\n+{\n+    if (__n == 0)\n+    {\n+        return std::make_pair(__first, __first);\n+    }\n+    typedef typename std::iterator_traits<_ForwardIterator>::value_type _ValueType;\n+\n+    struct _ComplexType\n+    {\n+        _ValueType __min_val;\n+        _ValueType __max_val;\n+        _Size __min_ind;\n+        _Size __max_ind;\n+        _Compare* __minmax_comp;\n+\n+        _ComplexType() : __min_val{}, __max_val{}, __min_ind{}, __max_ind{}, __minmax_comp(nullptr) {}\n+        _ComplexType(const _ValueType& min_val, const _ValueType& max_val, const _Compare* comp)\n+            : __min_val(min_val), __max_val(max_val), __min_ind(0), __max_ind(0),\n+              __minmax_comp(const_cast<_Compare*>(comp))\n+        {\n+        }\n+        _ComplexType(const _ComplexType& __obj)\n+            : __min_val(__obj.__min_val), __max_val(__obj.__max_val), __min_ind(__obj.__min_ind),\n+              __max_ind(__obj.__max_ind), __minmax_comp(__obj.__minmax_comp)\n+        {\n+        }\n+\n+        void\n+        operator()(const _ComplexType& __obj)\n+        {\n+            // min\n+            if ((*__minmax_comp)(__obj.__min_val, __min_val))\n+            {\n+                __min_val = __obj.__min_val;\n+                __min_ind = __obj.__min_ind;\n+            }\n+            else if (!(*__minmax_comp)(__min_val, __obj.__min_val))\n+            {\n+                __min_val = __obj.__min_val;\n+                __min_ind = (__min_ind - __obj.__min_ind < 0) ? __min_ind : __obj.__min_ind;\n+            }\n+\n+            // max\n+            if ((*__minmax_comp)(__max_val, __obj.__max_val))\n+            {\n+                __max_val = __obj.__max_val;\n+                __max_ind = __obj.__max_ind;\n+            }\n+            else if (!(*__minmax_comp)(__obj.__max_val, __max_val))\n+            {\n+                __max_val = __obj.__max_val;\n+                __max_ind = (__max_ind - __obj.__max_ind < 0) ? __obj.__max_ind : __max_ind;\n+            }\n+        }\n+    };\n+\n+    _ComplexType __init{*__first, *__first, &__comp};\n+\n+    __PSTL_PRAGMA_DECLARE_REDUCTION(__min_func, _ComplexType);\n+\n+    __PSTL_PRAGMA_SIMD_REDUCTION(__min_func : __init)\n+    for (_Size __i = 1; __i < __n; ++__i)\n+    {\n+        auto __min_val = __init.__min_val;\n+        auto __max_val = __init.__max_val;\n+        auto __current = __first + __i;\n+        if (__comp(*__current, __min_val))\n+        {\n+            __init.__min_val = *__current;\n+            __init.__min_ind = __i;\n+        }\n+        else if (!__comp(*__current, __max_val))\n+        {\n+            __init.__max_val = *__current;\n+            __init.__max_ind = __i;\n+        }\n+    }\n+    return std::make_pair(__first + __init.__min_ind, __first + __init.__max_ind);\n+}\n+\n+template <class _InputIterator, class _DifferenceType, class _OutputIterator1, class _OutputIterator2,\n+          class _UnaryPredicate>\n+std::pair<_OutputIterator1, _OutputIterator2>\n+__simd_partition_copy(_InputIterator __first, _DifferenceType __n, _OutputIterator1 __out_true,\n+                      _OutputIterator2 __out_false, _UnaryPredicate __pred) noexcept\n+{\n+    _DifferenceType __cnt_true = 0, __cnt_false = 0;\n+\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 0; __i < __n; ++__i)\n+    {\n+        __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC_2ARGS(__cnt_true : 1, __cnt_false : 1)\n+        if (__pred(__first[__i]))\n+        {\n+            __out_true[__cnt_true] = __first[__i];\n+            ++__cnt_true;\n+        }\n+        else\n+        {\n+            __out_false[__cnt_false] = __first[__i];\n+            ++__cnt_false;\n+        }\n+    }\n+    return std::make_pair(__out_true + __cnt_true, __out_false + __cnt_false);\n+}\n+\n+template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n+_ForwardIterator1\n+__simd_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,\n+                     _ForwardIterator2 __s_last, _BinaryPredicate __pred) noexcept\n+{\n+    typedef typename std::iterator_traits<_ForwardIterator1>::difference_type _DifferencType;\n+\n+    const _DifferencType __n1 = __last - __first;\n+    const _DifferencType __n2 = __s_last - __s_first;\n+    if (__n1 == 0 || __n2 == 0)\n+    {\n+        return __last; // according to the standard\n+    }\n+\n+    // Common case\n+    // If first sequence larger than second then we'll run simd_first with parameters of first sequence.\n+    // Otherwise, vice versa.\n+    if (__n1 < __n2)\n+    {\n+        for (; __first != __last; ++__first)\n+        {\n+            if (__simd_or(__s_first, __n2,\n+                          __internal::__equal_value_by_pred<decltype(*__first), _BinaryPredicate>(*__first, __pred)))\n+            {\n+                return __first;\n+            }\n+        }\n+    }\n+    else\n+    {\n+        for (; __s_first != __s_last; ++__s_first)\n+        {\n+            const auto __result = __simd_first(__first, _DifferencType(0), __n1,\n+                                               [__s_first, &__pred](_ForwardIterator1 __it, _DifferencType __i) {\n+                                                   return __pred(__it[__i], *__s_first);\n+                                               });\n+            if (__result != __last)\n+            {\n+                return __result;\n+            }\n+        }\n+    }\n+    return __last;\n+}\n+\n+template <class _RandomAccessIterator, class _DifferenceType, class _UnaryPredicate>\n+_RandomAccessIterator\n+__simd_remove_if(_RandomAccessIterator __first, _DifferenceType __n, _UnaryPredicate __pred) noexcept\n+{\n+    // find first element we need to remove\n+    auto __current =\n+        __simd_first(__first, _DifferenceType(0), __n,\n+                     [&__pred](_RandomAccessIterator __it, _DifferenceType __i) { return __pred(__it[__i]); });\n+    __n -= __current - __first;\n+\n+    // if we have in sequence only one element that pred(__current[1]) != false we can exit the function\n+    if (__n < 2)\n+    {\n+        return __current;\n+    }\n+\n+    _DifferenceType __cnt = 0;\n+    __PSTL_PRAGMA_SIMD\n+    for (_DifferenceType __i = 1; __i < __n; ++__i)\n+    {\n+        __PSTL_PRAGMA_SIMD_ORDERED_MONOTONIC(__cnt : 1)\n+        if (!__pred(__current[__i]))\n+        {\n+            __current[__cnt] = std::move(__current[__i]);\n+            ++__cnt;\n+        }\n+    }\n+    return __current + __cnt;\n+}\n+} // namespace __unseq_backend\n+} // namespace __pstl\n+\n+#endif /* __PSTL_unseq_backend_simd_H */"}, {"sha": "00ccc62072aade389b4d061348f6599d4b207eaa", "filename": "libstdc++-v3/include/pstl/utils.h", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Futils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Futils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fpstl%2Futils.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,222 @@\n+// -*- C++ -*-\n+//===-- utils.h -----------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_utils_H\n+#define __PSTL_utils_H\n+\n+#include <new>\n+#include <iterator>\n+\n+namespace __pstl\n+{\n+namespace __internal\n+{\n+\n+template <typename _Fp>\n+typename std::result_of<_Fp()>::type\n+__except_handler(_Fp __f)\n+{\n+    try\n+    {\n+        return __f();\n+    }\n+    catch (const std::bad_alloc&)\n+    {\n+        throw; // re-throw bad_alloc according to the standard [algorithms.parallel.exceptions]\n+    }\n+    catch (...)\n+    {\n+        std::terminate(); // Good bye according to the standard [algorithms.parallel.exceptions]\n+    }\n+}\n+\n+template <typename _Fp>\n+void\n+__invoke_if(std::true_type, _Fp __f)\n+{\n+    __f();\n+}\n+\n+template <typename _Fp>\n+void\n+__invoke_if(std::false_type, _Fp __f)\n+{\n+}\n+\n+template <typename _Fp>\n+void\n+__invoke_if_not(std::false_type, _Fp __f)\n+{\n+    __f();\n+}\n+\n+template <typename _Fp>\n+void\n+__invoke_if_not(std::true_type, _Fp __f)\n+{\n+}\n+\n+template <typename _F1, typename _F2>\n+typename std::result_of<_F1()>::type\n+__invoke_if_else(std::true_type, _F1 __f1, _F2 __f2)\n+{\n+    return __f1();\n+}\n+\n+template <typename _F1, typename _F2>\n+typename std::result_of<_F2()>::type\n+__invoke_if_else(std::false_type, _F1 __f1, _F2 __f2)\n+{\n+    return __f2();\n+}\n+\n+//! Unary operator that returns reference to its argument.\n+struct __no_op\n+{\n+    template <typename _Tp>\n+    _Tp&&\n+    operator()(_Tp&& __a) const\n+    {\n+        return std::forward<_Tp>(__a);\n+    }\n+};\n+\n+//! Logical negation of a predicate\n+template <typename _Pred>\n+class __not_pred\n+{\n+    _Pred _M_pred;\n+\n+  public:\n+    explicit __not_pred(_Pred __pred) : _M_pred(__pred) {}\n+\n+    template <typename... _Args>\n+    bool\n+    operator()(_Args&&... __args)\n+    {\n+        return !_M_pred(std::forward<_Args>(__args)...);\n+    }\n+};\n+\n+template <typename _Pred>\n+class __reorder_pred\n+{\n+    _Pred _M_pred;\n+\n+  public:\n+    explicit __reorder_pred(_Pred __pred) : _M_pred(__pred) {}\n+\n+    template <typename _FTp, typename _STp>\n+    bool\n+    operator()(_FTp&& __a, _STp&& __b)\n+    {\n+        return _M_pred(std::forward<_STp>(__b), std::forward<_FTp>(__a));\n+    }\n+};\n+\n+//! \"==\" comparison.\n+/** Not called \"equal\" to avoid (possibly unfounded) concerns about accidental invocation via\n+    argument-dependent name lookup by code expecting to find the usual std::equal. */\n+class __pstl_equal\n+{\n+  public:\n+    explicit __pstl_equal() {}\n+\n+    template <typename _Xp, typename _Yp>\n+    bool\n+    operator()(_Xp&& __x, _Yp&& __y) const\n+    {\n+        return std::forward<_Xp>(__x) == std::forward<_Yp>(__y);\n+    }\n+};\n+\n+//! \"<\" comparison.\n+class __pstl_less\n+{\n+  public:\n+    explicit __pstl_less() {}\n+\n+    template <typename _Xp, typename _Yp>\n+    bool\n+    operator()(_Xp&& __x, _Yp&& __y) const\n+    {\n+        return std::forward<_Xp>(__x) < std::forward<_Yp>(__y);\n+    }\n+};\n+\n+//! Like a polymorphic lambda for pred(...,value)\n+template <typename _Tp, typename _Predicate>\n+class __equal_value_by_pred\n+{\n+    const _Tp& _M_value;\n+    _Predicate _M_pred;\n+\n+  public:\n+    __equal_value_by_pred(const _Tp& __value, _Predicate __pred) : _M_value(__value), _M_pred(__pred) {}\n+\n+    template <typename _Arg>\n+    bool\n+    operator()(_Arg&& __arg)\n+    {\n+        return _M_pred(std::forward<_Arg>(__arg), _M_value);\n+    }\n+};\n+\n+//! Like a polymorphic lambda for ==value\n+template <typename _Tp>\n+class __equal_value\n+{\n+    const _Tp& _M_value;\n+\n+  public:\n+    explicit __equal_value(const _Tp& __value) : _M_value(__value) {}\n+\n+    template <typename _Arg>\n+    bool\n+    operator()(_Arg&& __arg) const\n+    {\n+        return std::forward<_Arg>(__arg) == _M_value;\n+    }\n+};\n+\n+//! Logical negation of ==value\n+template <typename _Tp>\n+class __not_equal_value\n+{\n+    const _Tp& _M_value;\n+\n+  public:\n+    explicit __not_equal_value(const _Tp& __value) : _M_value(__value) {}\n+\n+    template <typename _Arg>\n+    bool\n+    operator()(_Arg&& __arg) const\n+    {\n+        return !(std::forward<_Arg>(__arg) == _M_value);\n+    }\n+};\n+\n+template <typename _ForwardIterator, typename _Compare>\n+_ForwardIterator\n+__cmp_iterators_by_values(_ForwardIterator __a, _ForwardIterator __b, _Compare __comp)\n+{\n+    if (__a < __b)\n+    { // we should return closer iterator\n+        return __comp(*__b, *__a) ? __b : __a;\n+    }\n+    else\n+    {\n+        return __comp(*__a, *__b) ? __a : __b;\n+    }\n+}\n+\n+} // namespace __internal\n+} // namespace __pstl\n+\n+#endif /* __PSTL_utils_H */"}, {"sha": "73c87d5fcba99a976e776d81f40b1e49396f7049", "filename": "libstdc++-v3/include/std/algorithm", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -61,6 +61,21 @@\n #include <bits/stl_algobase.h>\n #include <bits/stl_algo.h>\n \n+#if __cplusplus > 201402L\n+// Parallel STL algorithms\n+# if __PSTL_EXECUTION_POLICIES_DEFINED\n+// If <execution> has already been included, pull in implementations\n+#  include <pstl/glue_algorithm_impl.h>\n+#  else\n+// Otherwise just pull in forward declarations\n+#    include <pstl/glue_algorithm_defs.h>\n+#    define __PSTL_ALGORITHM_FORWARD_DECLARED 1\n+#  endif\n+\n+// Feature test macro for parallel algorithms\n+# define __cpp_lib_parallel_algorithm 201703L\n+#endif // C++17\n+\n #ifdef _GLIBCXX_PARALLEL\n # include <parallel/algorithm>\n #endif"}, {"sha": "2d821e5c624d193a5c268a69d28065a31c7dcc25", "filename": "libstdc++-v3/include/std/execution", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexecution", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexecution", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexecution?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,56 @@\n+// <execution> -*- C++ -*-\n+\n+// Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _GLIBCXX_EXECUTION\n+#define _GLIBCXX_EXECUTION 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201703L\n+# include <bits/c++config.h>\n+# include <pstl/glue_execution_defs.h>\n+\n+# define __PSTL_EXECUTION_POLICIES_DEFINED 1\n+\n+// Algorithm implementation\n+# if __PSTL_ALGORITHM_FORWARD_DECLARED\n+#  include <pstl/glue_algorithm_impl.h>\n+# endif\n+\n+// Numeric implementation\n+# if __PSTL_NUMERIC_FORWARD_DECLARED\n+#  include <pstl/glue_numeric_impl.h>\n+# endif\n+\n+// Memory implementation\n+# if __PSTL_NUMERIC_FORWARD_DECLARED\n+#  include <pstl/glue_memory_impl.h>\n+# endif\n+\n+// Feature test macro for parallel algorithms\n+# define __cpp_lib_parallel_algorithm 201603L\n+\n+#endif // C++17\n+\n+#endif /* _GLIBCXX_EXECUTION */"}, {"sha": "57ccf93de863cc94f551b09e59190de84bd539e1", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -363,4 +363,18 @@ _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n #endif // C++11\n \n+#if __cplusplus > 201402L\n+// Parallel STL algorithms\n+# if __PSTL_EXECUTION_POLICIES_DEFINED\n+// If <execution> has already been included, pull in implementations\n+#  include <pstl/glue_memory_impl.h>\n+# else\n+// Otherwise just pull in forward declarations\n+#  include <pstl/glue_memory_defs.h>\n+# endif\n+\n+// Feature test macro for parallel algorithms\n+# define __cpp_lib_parallel_algorithm 201703L\n+#endif // C++17\n+\n #endif /* _GLIBCXX_MEMORY */"}, {"sha": "ffd9eae9691dca57ff87cbd7d848c18d2cd971b4", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -205,5 +205,19 @@ _GLIBCXX_END_NAMESPACE_VERSION\n \n #endif // C++14\n \n+#if __cplusplus > 201402L\n+// Parallel STL algorithms\n+# if __PSTL_EXECUTION_POLICIES_DEFINED\n+// If <execution> has already been included, pull in implementations\n+#  include <pstl/glue_numeric_impl.h>\n+# else\n+// Otherwise just pull in forward declarations\n+#  include <pstl/glue_numeric_defs.h>\n+#  define __PSTL_NUMERIC_FORWARD_DECLARED 1\n+# endif\n+\n+// Feature test macro for parallel algorithms\n+# define __cpp_lib_parallel_algorithm 201703L\n+#endif // C++17\n \n #endif /* _GLIBCXX_NUMERIC */"}, {"sha": "9da3854aad3efb628fa54d9c0b5ed6098b462798", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -145,6 +145,7 @@\n #define __cpp_lib_unordered_map_try_emplace 201411\n #define __cpp_lib_variant 201606L\n #define __cpp_lib_void_t 201411\n+#define __cpp_lib_parallel_algorithm 201603L\n \n #if __cplusplus > 201703L\n // c++2a"}, {"sha": "9ce23697950648418273ae9aef9d8c274d828ccb", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/pstl/uninitialized_construct.cc", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_construct.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,130 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- uninitialized_construct.pass.cpp ----------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for uninitialized_default_construct, uninitialized_default_construct_n,\n+//           uninitialized_value_construct,   uninitialized_value_construct_n\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/memory\"\n+#else\n+#include <execution>\n+#include <memory>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// function of checking correctness for uninitialized.construct.value\n+template <typename T, typename Iterator>\n+bool\n+IsCheckValueCorrectness(Iterator begin, Iterator end)\n+{\n+    for (; begin != end; ++begin)\n+    {\n+        if (*begin != T())\n+        {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+struct test_uninit_construct\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator begin, Iterator end, size_t n, /*is_trivial<T>=*/std::false_type)\n+    {\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+        // it needs for cleaning memory that was filled by default constructors in unique_ptr<T[]> p(new T[n])\n+        // and for cleaning memory after last calling of uninitialized_value_construct_n.\n+        // It is important for non-trivial types\n+        std::destroy_n(exec, begin, n);\n+\n+        // reset counter of constructors\n+        T::SetCount(0);\n+        // run algorithm\n+        std::uninitialized_default_construct(exec, begin, end);\n+        // compare counter of constructors to length of container\n+        EXPECT_TRUE(T::Count() == n, \"wrong uninitialized_default_construct\");\n+        // destroy objects for testing new algorithms on same memory\n+        std::destroy(exec, begin, end);\n+\n+        std::uninitialized_default_construct_n(exec, begin, n);\n+        EXPECT_TRUE(T::Count() == n, \"wrong uninitialized_default_construct_n\");\n+        std::destroy_n(exec, begin, n);\n+\n+        std::uninitialized_value_construct(exec, begin, end);\n+        EXPECT_TRUE(T::Count() == n, \"wrong uninitialized_value_construct\");\n+        std::destroy(exec, begin, end);\n+\n+        std::uninitialized_value_construct_n(exec, begin, n);\n+        EXPECT_TRUE(T::Count() == n, \"wrong uninitialized_value_construct_n\");\n+    }\n+\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator begin, Iterator end, size_t n, /*is_trivial<T>=*/std::true_type)\n+    {\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+\n+        std::uninitialized_default_construct(exec, begin, end);\n+        std::destroy(exec, begin, end);\n+\n+        std::uninitialized_default_construct_n(exec, begin, n);\n+        std::destroy_n(exec, begin, n);\n+\n+        std::uninitialized_value_construct(exec, begin, end);\n+        // check correctness for uninitialized.construct.value\n+        EXPECT_TRUE(IsCheckValueCorrectness<T>(begin, end), \"wrong uninitialized_value_construct\");\n+        std::destroy(exec, begin, end);\n+\n+        std::uninitialized_value_construct_n(exec, begin, n);\n+        EXPECT_TRUE(IsCheckValueCorrectness<T>(begin, end), \"wrong uninitialized_value_construct_n\");\n+        std::destroy_n(exec, begin, n);\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_uninit_construct_by_type()\n+{\n+    std::size_t N = 100000;\n+    for (size_t n = 0; n <= N; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        std::unique_ptr<T[]> p(new T[n]);\n+        invoke_on_all_policies(test_uninit_construct(), p.get(), std::next(p.get(), n), n, std::is_trivial<T>());\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+\n+    // for user-defined types\n+#if !__PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN\n+    test_uninit_construct_by_type<Wrapper<int32_t>>();\n+    test_uninit_construct_by_type<Wrapper<std::vector<std::string>>>();\n+#endif\n+\n+    // for trivial types\n+    test_uninit_construct_by_type<int8_t>();\n+    test_uninit_construct_by_type<float64_t>();\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "52a5a0b0fb825f8ed0a2b792ef76d7f2007679bb", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/pstl/uninitialized_copy_move.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_copy_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_copy_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_copy_move.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,152 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- uninitialized_copy_move.pass.cpp ----------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for uninitialized_copy, uninitialized_copy_n, uninitialized_move, uninitialized_move_n\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/memory\"\n+#else\n+#include <execution>\n+#include <memory>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// function of checking correctness for uninitialized.construct.value\n+template <typename InputIterator, typename OutputIterator, typename Size>\n+bool\n+IsCheckValueCorrectness(InputIterator first1, OutputIterator first2, Size n)\n+{\n+    for (Size i = 0; i < n; ++i, ++first1, ++first2)\n+    {\n+        if (*first1 != *first2)\n+        {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+struct test_uninitialized_copy_move\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first, size_t n,\n+               /*is_trivial<T>=*/std::false_type)\n+    {\n+        typedef typename std::iterator_traits<InputIterator>::value_type T;\n+        // it needs for cleaning memory that was filled by default constructors in unique_ptr<T[]> p(new T[n])\n+        // and for cleaning memory after last calling of uninitialized_value_construct_n.\n+        // It is important for non-trivial types\n+        std::destroy_n(exec, out_first, n);\n+\n+        // reset counter of constructors\n+        T::SetCount(0);\n+        // run algorithm\n+        std::uninitialized_copy(exec, first, last, out_first);\n+        // compare counter of constructors to length of container\n+        EXPECT_TRUE(T::Count() == n, \"wrong uninitialized_copy\");\n+        // destroy objects for testing new algorithms on same memory\n+        std::destroy_n(exec, out_first, n);\n+\n+        std::uninitialized_copy_n(exec, first, n, out_first);\n+        EXPECT_TRUE(T::Count() == n, \"wrong uninitialized_copy_n\");\n+        std::destroy_n(exec, out_first, n);\n+\n+        // For move\n+        std::uninitialized_move(exec, first, last, out_first);\n+        // compare counter of constructors to length of container\n+        EXPECT_TRUE(T::MoveCount() == n, \"wrong uninitialized_move\");\n+        // destroy objects for testing new algorithms on same memory\n+        std::destroy_n(exec, out_first, n);\n+\n+        std::uninitialized_move_n(exec, first, n, out_first);\n+        EXPECT_TRUE(T::MoveCount() == n, \"wrong uninitialized_move_n\");\n+        std::destroy_n(exec, out_first, n);\n+    }\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN || __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN\n+    template <typename InputIterator, typename OutputIterator>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               size_t n, /*is_trivial<T>=*/std::true_type)\n+    {\n+    }\n+    template <typename InputIterator, typename OutputIterator>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, size_t n, /*is_trivial<T>=*/std::true_type)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first, size_t n,\n+               /*is_trivial<T>=*/std::true_type)\n+    {\n+        typedef typename std::iterator_traits<InputIterator>::value_type T;\n+\n+        std::uninitialized_copy(exec, first, last, out_first);\n+        EXPECT_TRUE(IsCheckValueCorrectness(first, out_first, n), \"wrong uninitialized_copy\");\n+        std::destroy_n(exec, out_first, n);\n+\n+        std::uninitialized_copy_n(exec, first, n, out_first);\n+        EXPECT_TRUE(IsCheckValueCorrectness(first, out_first, n), \"wrong uninitialized_copy_n\");\n+        std::destroy_n(exec, out_first, n);\n+\n+        std::uninitialized_move(exec, first, last, out_first);\n+        EXPECT_TRUE(IsCheckValueCorrectness(first, out_first, n), \"wrong uninitialized_move\");\n+        std::destroy_n(exec, out_first, n);\n+\n+        std::uninitialized_move_n(exec, first, n, out_first);\n+        EXPECT_TRUE(IsCheckValueCorrectness(first, out_first, n), \"wrong uninitialized_move_n\");\n+        std::destroy_n(exec, out_first, n);\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_uninitialized_copy_move_by_type()\n+{\n+    std::size_t N = 100000;\n+    for (size_t n = 0; n <= N; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, [=](size_t k) -> T { return T(k); });\n+        std::unique_ptr<T[]> p(new T[n]);\n+        invoke_on_all_policies(test_uninitialized_copy_move(), in.begin(), in.end(), p.get(), n, std::is_trivial<T>());\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+\n+    // for trivial types\n+    test_uninitialized_copy_move_by_type<int16_t>();\n+    test_uninitialized_copy_move_by_type<float64_t>();\n+\n+    // for user-defined types\n+#if !__PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN && !__PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN &&   \\\n+    !__PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN\n+    test_uninitialized_copy_move_by_type<Wrapper<int8_t>>();\n+#endif\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "31ea484897b97b4883f4fda87667e760a624493d", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/pstl/uninitialized_fill_destroy.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_fill_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_fill_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fpstl%2Funinitialized_fill_destroy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,102 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- uninitialized_fill_destroy.pass.cpp -------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/memory\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_uninitialized_fill_destroy\n+{\n+    template <typename Policy, typename Iterator, typename T>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, const T& in, std::size_t n, std::false_type)\n+    {\n+        using namespace std;\n+        {\n+            T::SetCount(0);\n+            uninitialized_fill(exec, first, last, in);\n+            size_t count = count_if(first, last, [&in](T& x) -> bool { return x == in; });\n+            EXPECT_TRUE(n == count, \"wrong work of uninitialized_fill\");\n+            destroy(exec, first, last);\n+            EXPECT_TRUE(T::Count() == 0, \"wrong work of destroy\");\n+        }\n+\n+        {\n+            auto res = uninitialized_fill_n(exec, first, n, in);\n+            EXPECT_TRUE(res == last, \"wrong result of uninitialized_fill_n\");\n+            size_t count = count_if(first, last, [&in](T& x) -> bool { return x == in; });\n+            EXPECT_TRUE(n == count, \"wrong work of uninitialized_fill_n\");\n+            destroy_n(exec, first, n);\n+            EXPECT_TRUE(T::Count() == 0, \"wrong work of destroy_n\");\n+        }\n+    }\n+    template <typename Policy, typename Iterator, typename T>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, const T& in, std::size_t n, std::true_type)\n+    {\n+        using namespace std;\n+        {\n+            destroy(exec, first, last);\n+            uninitialized_fill(exec, first, last, in);\n+            size_t count = count_if(first, last, [&in](T& x) -> bool { return x == in; });\n+            EXPECT_EQ(n, count, \"wrong work of uninitialized:_fill\");\n+        }\n+        {\n+            destroy_n(exec, first, n);\n+            auto res = uninitialized_fill_n(exec, first, n, in);\n+            size_t count = count_if(first, last, [&in](T& x) -> bool { return x == in; });\n+            EXPECT_EQ(n, count, \"wrong work of uninitialized_fill_n\");\n+            EXPECT_TRUE(res == last, \"wrong result of uninitialized_fill_n\");\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_uninitialized_fill_destroy_by_type()\n+{\n+    std::size_t N = 100000;\n+    for (size_t n = 0; n <= N; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        std::unique_ptr<T[]> p(new T[n]);\n+        invoke_on_all_policies(test_uninitialized_fill_destroy(), p.get(), std::next(p.get(), n), T(), n,\n+                               std::is_trivial<T>());\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    // for trivial types\n+    test_uninitialized_fill_destroy_by_type<int32_t>();\n+    test_uninitialized_fill_destroy_by_type<float64_t>();\n+\n+    // for user-defined types\n+    test_uninitialized_fill_destroy_by_type<Wrapper<std::string>>();\n+    test_uninitialized_fill_destroy_by_type<Wrapper<int8_t*>>();\n+    std::cout << done() << std::endl;\n+\n+    return 0;\n+}"}, {"sha": "ed4a3c367a643249b64f66e98d9d96f9ea067c00", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_merge/inplace_merge.cc", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_merge%2Finplace_merge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_merge%2Finplace_merge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_merge%2Finplace_merge.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,164 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- inplace_merge.pass.cpp --------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <algorithm>\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename BiDirIt1, typename Size, typename Generator1, typename Generator2, typename Compare>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, BiDirIt1 first1, BiDirIt1 last1, BiDirIt1 first2, BiDirIt1 last2,\n+               Size n, Size m, Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+    }\n+\n+    template <typename BiDirIt1, typename Size, typename Generator1, typename Generator2, typename Compare>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, BiDirIt1 first1, BiDirIt1 last1, BiDirIt1 first2,\n+               BiDirIt1 last2, Size n, Size m, Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+    }\n+#endif\n+\n+    // inplace_merge works with bidirectional iterators at least\n+    template <typename Policy, typename BiDirIt1, typename Size, typename Generator1, typename Generator2,\n+              typename Compare>\n+    typename std::enable_if<!is_same_iterator_category<BiDirIt1, std::forward_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, BiDirIt1 first1, BiDirIt1 last1, BiDirIt1 first2, BiDirIt1 last2, Size n, Size m,\n+               Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+\n+        using T = typename std::iterator_traits<BiDirIt1>::value_type;\n+        const BiDirIt1 mid1 = std::next(first1, m);\n+        fill_data(first1, mid1, generator1);\n+        fill_data(mid1, last1, generator2);\n+\n+        const BiDirIt1 mid2 = std::next(first2, m);\n+        fill_data(first2, mid2, generator1);\n+        fill_data(mid2, last2, generator2);\n+\n+        std::inplace_merge(first1, mid1, last1, comp);\n+        std::inplace_merge(exec, first2, mid2, last2, comp);\n+        EXPECT_EQ_N(first1, first2, n, \"wrong effect from inplace_merge with predicate\");\n+    }\n+\n+    template <typename Policy, typename BiDirIt1, typename Size, typename Generator1, typename Generator2,\n+              typename Compare>\n+    typename std::enable_if<is_same_iterator_category<BiDirIt1, std::forward_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, BiDirIt1 first1, BiDirIt1 last1, BiDirIt1 first2, BiDirIt1 last2, Size n, Size m,\n+               Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+    }\n+};\n+\n+template <typename T, typename Generator1, typename Generator2, typename Compare>\n+void\n+test_by_type(Generator1 generator1, Generator2 generator2, Compare comp)\n+{\n+    using namespace std;\n+    size_t max_size = 100000;\n+    Sequence<T> in1(max_size, [](size_t v) { return T(v); });\n+    Sequence<T> exp(max_size, [](size_t v) { return T(v); });\n+    size_t m;\n+\n+    for (size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        m = 0;\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n, exp.begin(), exp.begin() + n, n, m,\n+                               generator1, generator2, comp);\n+\n+        m = n / 3;\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n, exp.begin(), exp.begin() + n, n, m,\n+                               generator1, generator2, comp);\n+\n+        m = 2 * n / 3;\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n, exp.begin(), exp.begin() + n, n, m,\n+                               generator1, generator2, comp);\n+    }\n+}\n+\n+template <typename T>\n+struct LocalWrapper\n+{\n+    explicit LocalWrapper(int32_t k) : my_val(k) {}\n+    LocalWrapper(LocalWrapper&& input) { my_val = std::move(input.my_val); }\n+    LocalWrapper&\n+    operator=(LocalWrapper&& input)\n+    {\n+        my_val = std::move(input.my_val);\n+        return *this;\n+    }\n+    bool\n+    operator<(const LocalWrapper<T>& w) const\n+    {\n+        return my_val < w.my_val;\n+    }\n+    friend bool\n+    operator==(const LocalWrapper<T>& x, const LocalWrapper<T>& y)\n+    {\n+        return x.my_val == y.my_val;\n+    }\n+    friend std::ostream&\n+    operator<<(std::ostream& stream, const LocalWrapper<T>& input)\n+    {\n+        return stream << input.my_val;\n+    }\n+\n+  private:\n+    T my_val;\n+};\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        invoke_if(exec, [&]() { inplace_merge(exec, iter, iter, iter, non_const(std::less<T>())); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test_by_type<float64_t>([](int32_t i) { return -2 * i; }, [](int32_t i) { return -(2 * i + 1); },\n+                            [](const float64_t x, const float64_t y) { return x > y; });\n+\n+    test_by_type<int32_t>([](int32_t i) { return 10 * i; }, [](int32_t i) { return i + 1; }, std::less<int32_t>());\n+\n+    test_by_type<LocalWrapper<float32_t>>([](int32_t i) { return LocalWrapper<float32_t>(2 * i + 1); },\n+                                          [](int32_t i) { return LocalWrapper<float32_t>(2 * i); },\n+                                          std::less<LocalWrapper<float32_t>>());\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_bi<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "01f9a0290cb5e0b6e4d390d9437789379670d9d2", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_merge/merge.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_merge%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_merge%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_merge%2Fmerge.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,123 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- merge.pass.cpp ----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <algorithm>\n+#include <functional>\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_merge\n+{\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename OutputIterator,\n+              typename Compare>\n+    void\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               OutputIterator out_first, OutputIterator out_last, Compare comp)\n+    {\n+        using namespace std;\n+        {\n+            const auto res = merge(exec, first1, last1, first2, last2, out_first, comp);\n+            EXPECT_TRUE(res == out_last, \"wrong return result from merge with predicate\");\n+            EXPECT_TRUE(is_sorted(out_first, res, comp), \"wrong result from merge with predicate\");\n+            EXPECT_TRUE(includes(out_first, res, first1, last1, comp), \"first sequence is not a part of result\");\n+            EXPECT_TRUE(includes(out_first, res, first2, last2, comp), \"second sequence is not a part of result\");\n+        }\n+        {\n+            const auto res = merge(exec, first1, last1, first2, last2, out_first);\n+            EXPECT_TRUE(res == out_last, \"wrong return result from merge\");\n+            EXPECT_TRUE(is_sorted(out_first, res), \"wrong result from merge\");\n+        }\n+    }\n+\n+    // for reverse iterators\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename OutputIterator,\n+              typename Compare>\n+    void\n+    operator()(Policy&& exec, std::reverse_iterator<InputIterator1> first1, std::reverse_iterator<InputIterator1> last1,\n+               std::reverse_iterator<InputIterator2> first2, std::reverse_iterator<InputIterator2> last2,\n+               std::reverse_iterator<OutputIterator> out_first, std::reverse_iterator<OutputIterator> out_last,\n+               Compare comp)\n+    {\n+        using namespace std;\n+        typedef typename std::iterator_traits<std::reverse_iterator<InputIterator1>>::value_type T;\n+        const auto res = merge(exec, first1, last1, first2, last2, out_first, std::greater<T>());\n+\n+        EXPECT_TRUE(res == out_last, \"wrong return result from merge with predicate\");\n+        EXPECT_TRUE(is_sorted(out_first, res, std::greater<T>()), \"wrong result from merge with predicate\");\n+        EXPECT_TRUE(includes(out_first, res, first1, last1, std::greater<T>()),\n+                    \"first sequence is not a part of result\");\n+        EXPECT_TRUE(includes(out_first, res, first2, last2, std::greater<T>()),\n+                    \"second sequence is not a part of result\");\n+    }\n+};\n+\n+template <typename T, typename Generator1, typename Generator2>\n+void\n+test_merge_by_type(Generator1 generator1, Generator2 generator2)\n+{\n+    using namespace std;\n+    size_t max_size = 100000;\n+    Sequence<T> in1(max_size, generator1);\n+    Sequence<T> in2(max_size / 2, generator2);\n+    Sequence<T> out(in1.size() + in2.size());\n+    std::sort(in1.begin(), in1.end());\n+    std::sort(in2.begin(), in2.end());\n+\n+    for (size_t size = 0; size <= max_size; size = size <= 16 ? size + 1 : size_t(3.1415 * size))\n+    {\n+        invoke_on_all_policies(test_merge(), in1.cbegin(), in1.cbegin() + size, in2.data(), in2.data() + size / 2,\n+                               out.begin(), out.begin() + 1.5 * size, std::less<T>());\n+        invoke_on_all_policies(test_merge(), in1.data(), in1.data() + size, in2.cbegin(), in2.cbegin() + size / 2,\n+                               out.begin(), out.begin() + 3 * size / 2, std::less<T>());\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputIterator out_iter)\n+    {\n+        merge(exec, input_iter, input_iter, input_iter, input_iter, out_iter, non_const(std::less<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test_merge_by_type<int32_t>([](size_t v) { return (v % 2 == 0 ? v : -v) * 3; }, [](size_t v) { return v * 2; });\n+    test_merge_by_type<float64_t>([](size_t v) { return float64_t(v); }, [](size_t v) { return float64_t(v - 100); });\n+\n+#if !__PSTL_ICC_16_17_TEST_64_TIMEOUT\n+    test_merge_by_type<Wrapper<int16_t>>([](size_t v) { return Wrapper<int16_t>(v % 100); },\n+                                         [](size_t v) { return Wrapper<int16_t>(v % 10); });\n+#endif\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "b76fe1b666dcdf4773fa9975b69ae7d335c82c2b", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/copy_if.cc", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fcopy_if.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fcopy_if.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fcopy_if.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,154 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- copy_if.pass.cpp --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for copy_if and remove_copy_if\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct run_copy_if\n+{\n+#if __PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN // dummy specializations to skip testing in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(__pstl::execution::parallel_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size n,\n+               Predicate pred, T trash)\n+    {\n+    }\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(__pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, Size n, Predicate pred, T trash)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size n,\n+               Predicate pred, T trash)\n+    {\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+\n+        // Run copy_if\n+        auto i = copy_if(first, last, expected_first, pred);\n+        auto k = copy_if(exec, first, last, out_first, pred);\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong copy_if effect\");\n+        for (size_t j = 0; j < GuardSize; ++j)\n+        {\n+            ++k;\n+        }\n+        EXPECT_TRUE(out_last == k, \"wrong return value from copy_if\");\n+\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+        // Run remove_copy_if\n+        i = remove_copy_if(first, last, expected_first, [=](const T& x) { return !pred(x); });\n+        k = remove_copy_if(exec, first, last, out_first, [=](const T& x) { return !pred(x); });\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong remove_copy_if effect\");\n+        for (size_t j = 0; j < GuardSize; ++j)\n+        {\n+            ++k;\n+        }\n+        EXPECT_TRUE(out_last == k, \"wrong return value from remove_copy_if\");\n+    }\n+};\n+\n+template <typename T, typename Predicate, typename Convert>\n+void\n+test(T trash, Predicate pred, Convert convert, bool check_weakness = true)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        // count is number of output elements, plus a handful\n+        // more for sake of detecting buffer overruns.\n+        size_t count = GuardSize;\n+        Sequence<T> in(n, [&](size_t k) -> T {\n+            T val = convert(n ^ k);\n+            count += pred(val) ? 1 : 0;\n+            return val;\n+        });\n+\n+        Sequence<T> out(count, [=](size_t) { return trash; });\n+        Sequence<T> expected(count, [=](size_t) { return trash; });\n+        if (check_weakness)\n+        {\n+            auto expected_result = copy_if(in.cfbegin(), in.cfend(), expected.begin(), pred);\n+            size_t m = expected_result - expected.begin();\n+            EXPECT_TRUE(n / 4 <= m && m <= 3 * (n + 1) / 4, \"weak test for copy_if\");\n+        }\n+        invoke_on_all_policies(run_copy_if(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), count, pred, trash);\n+        invoke_on_all_policies(run_copy_if(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), count, pred, trash);\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        copy_if(exec, input_iter, input_iter, out_iter, non_const(is_even));\n+\n+        invoke_if(exec, [&]() { remove_copy_if(exec, input_iter, input_iter, out_iter, non_const(is_even)); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<float64_t>(-666.0, [](const float64_t& x) { return x * x <= 1024; },\n+                    [](size_t j) { return ((j + 1) % 7 & 2) != 0 ? float64_t(j % 32) : float64_t(j % 33 + 34); });\n+\n+    test<int32_t>(-666, [](const int32_t& x) { return x != 42; },\n+                  [](size_t j) { return ((j + 1) % 5 & 2) != 0 ? int32_t(j + 1) : 42; });\n+\n+#if !__PSTL_ICC_17_TEST_MAC_RELEASE_32_BROKEN\n+    test<Number>(Number(42, OddTag()), IsMultiple(3, OddTag()), [](int32_t j) { return Number(j, OddTag()); });\n+#endif\n+\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_RELEASE_BROKEN\n+    test<int32_t>(-666, [](const int32_t& x) { return true; }, [](size_t j) { return j; }, false);\n+#endif\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "ac265c09bf9a80f5def8e0070360fd6f82eb3e3e", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/copy_move.cc", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fcopy_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fcopy_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fcopy_move.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,208 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- copy_move.pass.cpp ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for copy, move and copy_n\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct run_copy\n+{\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size, typename T>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size size,\n+               Size n, T trash)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size, typename T>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, Size size, Size n, T trash)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size size,\n+               Size n, T trash)\n+    {\n+        // Cleaning\n+        std::fill_n(expected_first, size, trash);\n+        std::fill_n(out_first, size, trash);\n+\n+        // Run copy\n+        copy(first, last, expected_first);\n+        auto k = copy(exec, first, last, out_first);\n+        for (size_t j = 0; j < GuardSize; ++j)\n+            ++k;\n+        EXPECT_EQ_N(expected_first, out_first, size, \"wrong effect from copy\");\n+        EXPECT_TRUE(out_last == k, \"wrong return value from copy\");\n+\n+        // Cleaning\n+        std::fill_n(out_first, size, trash);\n+        // Run copy_n\n+        k = copy_n(exec, first, n, out_first);\n+        for (size_t j = 0; j < GuardSize; ++j)\n+            ++k;\n+        EXPECT_EQ_N(expected_first, out_first, size, \"wrong effect from copy_n\");\n+        EXPECT_TRUE(out_last == k, \"wrong return value from copy_n\");\n+    }\n+};\n+\n+template <typename T>\n+struct run_move\n+{\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size size,\n+               Size n, T trash)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, Size size, Size n, T trash)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size size,\n+               Size n, T trash)\n+    {\n+        // Cleaning\n+        std::fill_n(expected_first, size, trash);\n+        std::fill_n(out_first, size, trash);\n+\n+        // Run move\n+        move(first, last, expected_first);\n+        auto k = move(exec, first, last, out_first);\n+        for (size_t j = 0; j < GuardSize; ++j)\n+            ++k;\n+        EXPECT_EQ_N(expected_first, out_first, size, \"wrong effect from move\");\n+        EXPECT_TRUE(out_last == k, \"wrong return value from move\");\n+    }\n+};\n+\n+template <typename T>\n+struct run_move<Wrapper<T>>\n+{\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size size,\n+               Size n, Wrapper<T> trash)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, Size size, Size n, Wrapper<T> trash)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size size,\n+               Size n, Wrapper<T> trash)\n+    {\n+        // Cleaning\n+        std::fill_n(out_first, size, trash);\n+        Wrapper<T>::SetMoveCount(0);\n+\n+        // Run move\n+        auto k = move(exec, first, last, out_first);\n+        for (size_t j = 0; j < GuardSize; ++j)\n+            ++k;\n+        EXPECT_TRUE(Wrapper<T>::MoveCount() == size, \"wrong effect from move\");\n+        EXPECT_TRUE(out_last == k, \"wrong return value from move\");\n+    }\n+};\n+\n+template <typename T, typename Convert>\n+void\n+test(T trash, Convert convert)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        // count is number of output elements, plus a handful\n+        // more for sake of detecting buffer overruns.\n+        Sequence<T> in(n, [&](size_t k) -> T {\n+            T val = convert(n ^ k);\n+            return val;\n+        });\n+\n+        const size_t outN = n + GuardSize;\n+        Sequence<T> out(outN, [=](size_t) { return trash; });\n+        Sequence<T> expected(outN, [=](size_t) { return trash; });\n+        invoke_on_all_policies(run_copy(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), outN, n, trash);\n+        invoke_on_all_policies(run_copy(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), outN, n, trash);\n+        invoke_on_all_policies(run_move<T>(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), n, n, trash);\n+\n+        // For this test const iterator isn't suitable\n+        // because const rvalue-reference call copy assignment operator\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(-666, [](size_t j) { return int32_t(j); });\n+    test<Wrapper<float64_t>>(Wrapper<float64_t>(-666.0), [](int32_t j) { return Wrapper<float64_t>(j); });\n+\n+#if !__PSTL_ICC_16_17_TEST_64_TIMEOUT\n+    test<float64_t>(-666.0, [](size_t j) { return float64_t(j); });\n+    test<Number>(Number(42, OddTag()), [](int32_t j) { return Number(j, OddTag()); });\n+#endif\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "fd29a6136e246cf3394b4b62208a90b773293d80", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/fill.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ffill.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ffill.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ffill.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,108 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- fill.pass.cpp -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_fill\n+{\n+    template <typename It, typename T>\n+    bool\n+    check(It first, It last, const T& value)\n+    {\n+        for (; first != last; ++first)\n+            if (*first != value)\n+                return false;\n+        return true;\n+    }\n+\n+    template <typename Policy, typename Iterator, typename T>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, const T& value)\n+    {\n+        fill(first, last, T(value + 1)); // initialize memory with different value\n+\n+        fill(exec, first, last, value);\n+        EXPECT_TRUE(check(first, last, value), \"fill wrong result\");\n+    }\n+};\n+\n+struct test_fill_n\n+{\n+    template <typename It, typename Size, typename T>\n+    bool\n+    check(It first, Size n, const T& value)\n+    {\n+        for (Size i = 0; i < n; ++i, ++first)\n+            if (*first != value)\n+                return false;\n+        return true;\n+    }\n+\n+    template <typename Policy, typename Iterator, typename Size, typename T>\n+    void\n+    operator()(Policy&& exec, Iterator first, Size n, const T& value)\n+    {\n+        fill_n(first, n, T(value + 1)); // initialize memory with different value\n+\n+        const Iterator one_past_last = fill_n(exec, first, n, value);\n+        const Iterator expected_return = std::next(first, n);\n+\n+        EXPECT_TRUE(expected_return == one_past_last, \"fill_n should return Iterator to one past the element assigned\");\n+        EXPECT_TRUE(check(first, n, value), \"fill_n wrong result\");\n+\n+        //n == -1\n+        const Iterator res = fill_n(exec, first, -1, value);\n+        EXPECT_TRUE(res == first, \"fill_n wrong result for n == -1\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_fill_by_type(std::size_t n)\n+{\n+    Sequence<T> in(n, [](std::size_t v) -> T { return T(0); }); //fill with zeros\n+    T value = -1;\n+\n+    invoke_on_all_policies(test_fill(), in.begin(), in.end(), value);\n+    invoke_on_all_policies(test_fill_n(), in.begin(), n, value);\n+}\n+\n+int32_t\n+main()\n+{\n+\n+    const std::size_t N = 100000;\n+\n+    for (std::size_t n = 0; n < N; n = n < 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        test_fill_by_type<int32_t>(n);\n+        test_fill_by_type<float64_t>(n);\n+    }\n+\n+    std::cout << done() << std::endl;\n+\n+    return 0;\n+}"}, {"sha": "ebd922d75f1d67854abd3f0ab30413ed4a4bcfbb", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/generate.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fgenerate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fgenerate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fgenerate.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,111 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- generate.pass.cpp -------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <atomic>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct Generator_count\n+{\n+    const T def_val = T(-1);\n+    T\n+    operator()()\n+    {\n+        return def_val;\n+    }\n+    T\n+    default_value() const\n+    {\n+        return def_val;\n+    }\n+};\n+\n+struct test_generate\n+{\n+    template <typename Policy, typename Iterator, typename Size>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Size n)\n+    {\n+        using namespace std;\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+\n+        // Try random-access iterator\n+        {\n+            Generator_count<T> g;\n+            generate(exec, first, last, g);\n+            EXPECT_TRUE(std::count(first, last, g.default_value()) == n, \"generate wrong result for generate\");\n+            std::fill(first, last, T(0));\n+        }\n+\n+        {\n+            Generator_count<T> g;\n+            const auto m = n / 2;\n+            auto last = generate_n(exec, first, m, g);\n+            EXPECT_TRUE(std::count(first, last, g.default_value()) == m && last == std::next(first, m),\n+                        \"generate_n wrong result for generate_n\");\n+            std::fill(first, last, T(0));\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_generate_by_type()\n+{\n+    for (size_t n = 0; n <= 100000; n = n < 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, [](size_t v) -> T { return T(0); }); //fill by zero\n+\n+        invoke_on_all_policies(test_generate(), in.begin(), in.end(), in.size());\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto gen = []() { return T(0); };\n+\n+        generate(exec, iter, iter, non_const(gen));\n+        generate_n(exec, iter, 0, non_const(gen));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test_generate_by_type<int32_t>();\n+    test_generate_by_type<float64_t>();\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "1f7315cfa2d0e90b10f938b378977af49d25bb77", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/is_partitioned.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fis_partitioned.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fis_partitioned.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fis_partitioned.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,108 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- is_partitioned.pass.cpp -------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+    //dummy specialization by policy type, in case of broken configuration\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN || __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN\n+\n+    template <typename Iterator1, typename Predicate>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 begin1, Iterator1 end1, Predicate pred)\n+    {\n+    }\n+    template <typename Iterator1, typename Predicate>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 begin1, Iterator1 end1, Predicate pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 begin1, Iterator1 end1, Predicate pred)\n+    {\n+        const bool expected = std::is_partitioned(begin1, end1, pred);\n+        const bool actual = std::is_partitioned(exec, begin1, end1, pred);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from is_partitioned\");\n+    }\n+};\n+\n+template <typename T, typename Predicate>\n+void\n+test(Predicate pred)\n+{\n+\n+    const std::size_t max_n = 1000000;\n+    Sequence<T> in(max_n, [](std::size_t k) { return T(k); });\n+\n+    for (std::size_t n1 = 0; n1 <= max_n; n1 = n1 <= 16 ? n1 + 1 : std::size_t(3.1415 * n1))\n+    {\n+        invoke_on_all_policies(test_one_policy(), in.begin(), in.begin() + n1, pred);\n+        std::partition(in.begin(), in.begin() + n1, pred);\n+        invoke_on_all_policies(test_one_policy(), in.cbegin(), in.cbegin() + n1, pred);\n+    }\n+}\n+\n+template <typename T>\n+struct LocalWrapper\n+{\n+    explicit LocalWrapper(std::size_t k) : my_val(k) {}\n+\n+  private:\n+    T my_val;\n+};\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        invoke_if(exec, [&]() { is_partitioned(exec, iter, iter, non_const(is_even)); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<float64_t>([](const float64_t x) { return x < 0; });\n+    test<int32_t>([](const int32_t x) { return x > 1000; });\n+    test<uint16_t>([](const uint16_t x) { return x % 5 < 3; });\n+#if !__PSTL_ICC_18_TEST_EARLY_EXIT_MONOTONIC_RELEASE_BROKEN && !__PSTL_ICC_19_TEST_IS_PARTITIONED_RELEASE_BROKEN\n+    test<LocalWrapper<float64_t>>([](const LocalWrapper<float64_t>& x) { return true; });\n+#endif\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "607ba9b9c77c0b5bd80e1e26384b7383e5438712", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/partition.cc", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fpartition.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fpartition.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fpartition.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,187 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- partition.pass.cpp ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for stable_partition and partition\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+#include <iterator>\n+#include <type_traits>\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct DataType\n+{\n+    explicit DataType(int32_t k) : my_val(k) {}\n+    DataType(DataType&& input) { my_val = std::move(input.my_val); }\n+    DataType&\n+    operator=(DataType&& input)\n+    {\n+        my_val = std::move(input.my_val);\n+        return *this;\n+    }\n+    T\n+    get_val() const\n+    {\n+        return my_val;\n+    }\n+\n+    friend std::ostream&\n+    operator<<(std::ostream& stream, const DataType<T>& input)\n+    {\n+        return stream << input.my_val;\n+    }\n+\n+  private:\n+    T my_val;\n+};\n+\n+template <typename Iterator>\n+typename std::enable_if<std::is_trivial<typename std::iterator_traits<Iterator>::value_type>::value, bool>::type\n+is_equal(Iterator first, Iterator last, Iterator d_first)\n+{\n+    return std::equal(first, last, d_first);\n+}\n+\n+template <typename Iterator>\n+typename std::enable_if<!std::is_trivial<typename std::iterator_traits<Iterator>::value_type>::value, bool>::type\n+is_equal(Iterator first, Iterator last, Iterator d_first)\n+{\n+    return true;\n+}\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specializations to skip testing in case of broken configuration\n+    template <typename BiDirIt, typename Size, typename UnaryOp, typename Generator>\n+    void\n+    operator()(__pstl::execution::unsequenced_policy, BiDirIt first, BiDirIt last, BiDirIt exp_first, BiDirIt exp_last,\n+               Size n, UnaryOp unary_op, Generator generator)\n+    {\n+    }\n+\n+    template <typename BiDirIt, typename Size, typename UnaryOp, typename Generator>\n+    void\n+    operator()(__pstl::execution::parallel_unsequenced_policy, BiDirIt first, BiDirIt last, BiDirIt exp_first,\n+               BiDirIt exp_last, Size n, UnaryOp unary_op, Generator generator)\n+    {\n+    }\n+#elif __PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN //dummy specializations to skip testing in case of broken configuration\n+    template <typename BiDirIt, typename Size, typename UnaryOp, typename Generator>\n+    void\n+    operator()(__pstl::execution::parallel_policy, BiDirIt first, BiDirIt last, BiDirIt exp_first, BiDirIt exp_last,\n+               Size n, UnaryOp unary_op, Generator generator)\n+    {\n+    }\n+\n+    template <typename BiDirIt, typename Size, typename UnaryOp, typename Generator>\n+    void\n+    operator()(__pstl::execution::parallel_unsequenced_policy, BiDirIt first, BiDirIt last, BiDirIt exp_first,\n+               BiDirIt exp_last, Size n, UnaryOp unary_op, Generator generator)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename BiDirIt, typename Size, typename UnaryOp, typename Generator>\n+    typename std::enable_if<!is_same_iterator_category<BiDirIt, std::forward_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, BiDirIt first, BiDirIt last, BiDirIt exp_first, BiDirIt exp_last, Size n,\n+               UnaryOp unary_op, Generator generator)\n+    {\n+        // partition\n+        {\n+            fill_data(first, last, generator);\n+            BiDirIt actual_ret = std::partition(exec, first, last, unary_op);\n+            EXPECT_TRUE(std::all_of(first, actual_ret, unary_op) && !std::any_of(actual_ret, last, unary_op),\n+                        \"wrong effect from partition\");\n+        }\n+        // stable_partition\n+        {\n+            fill_data(exp_first, exp_last, generator);\n+            BiDirIt exp_ret = std::stable_partition(exp_first, exp_last, unary_op);\n+            fill_data(first, last, generator);\n+            BiDirIt actual_ret = std::stable_partition(exec, first, last, unary_op);\n+\n+            EXPECT_TRUE(std::distance(first, actual_ret) == std::distance(exp_first, exp_ret),\n+                        \"wrong result from stable_partition\");\n+            EXPECT_TRUE((is_equal<BiDirIt>(exp_first, exp_last, first)), \"wrong effect from stable_partition\");\n+        }\n+    }\n+    template <typename Policy, typename BiDirIt, typename Size, typename UnaryOp, typename Generator>\n+    typename std::enable_if<is_same_iterator_category<BiDirIt, std::forward_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, BiDirIt first, BiDirIt last, BiDirIt exp_first, BiDirIt exp_last, Size n,\n+               UnaryOp unary_op, Generator generator)\n+    {\n+    }\n+};\n+\n+template <typename T, typename Generator, typename UnaryPred>\n+void\n+test_by_type(Generator generator, UnaryPred pred)\n+{\n+\n+    using namespace std;\n+    size_t max_size = 100000;\n+    Sequence<T> in(max_size, [](size_t v) { return T(v); });\n+    Sequence<T> exp(max_size, [](size_t v) { return T(v); });\n+\n+    for (size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        invoke_on_all_policies(test_one_policy(), in.begin(), in.begin() + n, exp.begin(), exp.begin() + n, n, pred,\n+                               generator);\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        invoke_if(exec, [&]() {\n+            partition(exec, iter, iter, non_const(is_even));\n+            stable_partition(exec, iter, iter, non_const(is_even));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_RELEASE_BROKEN\n+    test_by_type<int32_t>([](int32_t i) { return i; }, [](int32_t) { return true; });\n+#endif\n+    test_by_type<float64_t>([](int32_t i) { return -i; }, [](const float64_t x) { return x < 0; });\n+    test_by_type<int64_t>([](int32_t i) { return i + 1; }, [](int64_t x) { return x % 3 == 0; });\n+    test_by_type<DataType<float32_t>>([](int32_t i) { return DataType<float32_t>(2 * i + 1); },\n+                                      [](const DataType<float32_t>& x) { return x.get_val() < 0; });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_bi<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "13ceaba8389e8c49a2f97dcda8994fc22482cd23", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/partition_copy.cc", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fpartition_copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fpartition_copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fpartition_copy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,124 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- partition_copy.pass.cpp -------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for stable_partition and partition_copy\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+#include <cstdlib>\n+#include <iterator>\n+\n+using namespace TestUtils;\n+\n+struct test_partition_copy\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2,\n+              typename UnaryOp>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator true_first,\n+               OutputIterator true_last, OutputIterator2 false_first, OutputIterator2 false_last, UnaryOp unary_op)\n+    {\n+\n+        auto actual_ret = std::partition_copy(exec, first, last, true_first, false_first, unary_op);\n+\n+        EXPECT_TRUE(std::distance(true_first, actual_ret.first) == std::count_if(first, last, unary_op),\n+                    \"partition_copy has wrong effect from true sequence\");\n+        EXPECT_TRUE(std::distance(false_first, actual_ret.second) ==\n+                        std::count_if(first, last, __pstl::__internal::__not_pred<UnaryOp>(unary_op)),\n+                    \"partition_copy has wrong effect from false sequence\");\n+    }\n+\n+    //dummy specialization by iterator type and policy type, in case of broken configuration\n+#if __PSTL_ICC_1800_TEST_MONOTONIC_RELEASE_64_BROKEN\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename UnaryOp>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, std::reverse_iterator<InputIterator> first,\n+               std::reverse_iterator<InputIterator> last, std::reverse_iterator<OutputIterator> true_first,\n+               std::reverse_iterator<OutputIterator> true_last, std::reverse_iterator<OutputIterator2> false_first,\n+               OutputIterator2 false_last, UnaryOp unary_op)\n+    {\n+    }\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename UnaryOp>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, std::reverse_iterator<InputIterator> first,\n+               std::reverse_iterator<InputIterator> last, std::reverse_iterator<OutputIterator> true_first,\n+               std::reverse_iterator<OutputIterator> true_last, std::reverse_iterator<OutputIterator2> false_first,\n+               OutputIterator2 false_last, UnaryOp unary_op)\n+    {\n+    }\n+#endif\n+};\n+\n+template <typename T, typename UnaryPred>\n+void\n+test(UnaryPred pred)\n+{\n+\n+    const std::size_t max_size = 100000;\n+    Sequence<T> in(max_size, [](std::size_t v) -> T { return T(v); });\n+    Sequence<T> actual_true(max_size);\n+    Sequence<T> actual_false(max_size);\n+    for (std::size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : std::size_t(3.1415 * n))\n+    {\n+\n+        // for non-const input iterators\n+        invoke_on_all_policies(test_partition_copy(), in.begin(), in.begin() + n, actual_true.begin(),\n+                               actual_true.begin() + n, actual_false.begin(), actual_false.begin() + n, pred);\n+\n+        // for const input iterators\n+        invoke_on_all_policies(test_partition_copy(), in.cbegin(), in.cbegin() + n, actual_true.begin(),\n+                               actual_true.begin() + n, actual_false.begin(), actual_false.begin() + n, pred);\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+\n+        partition_copy(exec, input_iter, input_iter, out_iter, out_iter, non_const(is_even));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>([](const int32_t value) { return value % 2; });\n+\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_RELEASE_BROKEN\n+    test<int32_t>([](const int32_t value) { return true; });\n+#endif\n+\n+    test<float64_t>([](const float64_t value) { return value > 2 << 6; });\n+    test<Wrapper<float64_t>>([](const Wrapper<float64_t>& value) -> bool { return value.get_my_field() != nullptr; });\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_bi<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "0ca54afef77143914cd0049056136186b4e06ab2", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/remove.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fremove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fremove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fremove.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,161 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- remove.pass.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Test for remove, remove_if\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct run_remove\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename Size, typename T>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator expected_first, OutputIterator expected_last, Size n,\n+               const T& value)\n+    {\n+    }\n+    template <typename InputIterator, typename OutputIterator, typename Size, typename T>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator expected_first,\n+               OutputIterator expected_last, Size n, const T& value)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename Size, typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator expected_first, OutputIterator expected_last, Size,\n+               const T& value)\n+    {\n+        // Cleaning\n+        std::copy(first, last, expected_first);\n+        std::copy(first, last, out_first);\n+\n+        // Run remove\n+        OutputIterator i = remove(expected_first, expected_last, value);\n+        OutputIterator k = remove(exec, out_first, out_last, value);\n+        EXPECT_TRUE(std::distance(expected_first, i) == std::distance(out_first, k), \"wrong return value from remove\");\n+        EXPECT_EQ_N(expected_first, out_first, std::distance(expected_first, i), \"wrong remove effect\");\n+    }\n+};\n+\n+struct run_remove_if\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename Size, typename Predicate>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator expected_first, OutputIterator expected_last, Size n,\n+               Predicate pred)\n+    {\n+    }\n+    template <typename InputIterator, typename OutputIterator, typename Size, typename Predicate>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator expected_first,\n+               OutputIterator expected_last, Size n, Predicate pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename Size, typename Predicate>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator expected_first, OutputIterator expected_last, Size,\n+               Predicate pred)\n+    {\n+        // Cleaning\n+        std::copy(first, last, expected_first);\n+        std::copy(first, last, out_first);\n+\n+        // Run remove_if\n+        OutputIterator i = remove_if(expected_first, expected_last, pred);\n+        OutputIterator k = remove_if(exec, out_first, out_last, pred);\n+        EXPECT_TRUE(std::distance(expected_first, i) == std::distance(out_first, k),\n+                    \"wrong return value from remove_if\");\n+        EXPECT_EQ_N(expected_first, out_first, std::distance(expected_first, i), \"wrong remove_if effect\");\n+    }\n+};\n+\n+template <typename T, typename Predicate, typename Convert>\n+void\n+test(T trash, const T& value, Predicate pred, Convert convert)\n+{\n+    const std::size_t max_size = 100000;\n+    Sequence<T> out(max_size, [trash](size_t) { return trash; });\n+    Sequence<T> expected(max_size, [trash](size_t) { return trash; });\n+\n+    for (size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> data(n, [&](size_t k) -> T { return convert(k); });\n+\n+        invoke_on_all_policies(run_remove(), data.begin(), data.end(), out.begin(), out.begin() + n, expected.begin(),\n+                               expected.begin() + n, n, value);\n+        invoke_on_all_policies(run_remove_if(), data.begin(), data.end(), out.begin(), out.begin() + n,\n+                               expected.begin(), expected.begin() + n, n, pred);\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+\n+        invoke_if(exec, [&]() { remove_if(exec, iter, iter, non_const(is_even)); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+#if !__PSTL_ICC_18_TEST_EARLY_EXIT_MONOTONIC_RELEASE_BROKEN\n+    test<int32_t>(666, 42, [](int32_t val) { return true; }, [](size_t j) { return j; });\n+#endif\n+\n+    test<int32_t>(666, 2001, [](const int32_t& val) { return val != 2001; },\n+                  [](size_t j) { return ((j + 1) % 5 & 2) != 0 ? 2001 : -1 - int32_t(j); });\n+    test<float64_t>(-666.0, 8.5, [](const float64_t& val) { return val != 8.5; },\n+                    [](size_t j) { return ((j + 1) % 7 & 2) != 0 ? 8.5 : float64_t(j % 32 + j); });\n+\n+#if !__PSTL_ICC_17_TEST_MAC_RELEASE_32_BROKEN\n+    test<Number>(Number(-666, OddTag()), Number(42, OddTag()), IsMultiple(3, OddTag()),\n+                 [](int32_t j) { return Number(j, OddTag()); });\n+#endif\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "c5883c66dbb925d33230f175158995feceba04d6", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/remove_copy.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fremove_copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fremove_copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fremove_copy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,98 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- remove_copy.pass.cpp ----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct run_remove_copy\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size n,\n+               const T& value, T trash)\n+    {\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+\n+        // Run copy_if\n+        auto i = remove_copy(first, last, expected_first, value);\n+        auto k = remove_copy(exec, first, last, out_first, value);\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong remove_copy effect\");\n+        for (size_t j = 0; j < GuardSize; ++j)\n+        {\n+            ++k;\n+        }\n+        EXPECT_TRUE(out_last == k, \"wrong return value from remove_copy\");\n+    }\n+};\n+\n+template <typename T, typename Convert>\n+void\n+test(T trash, const T& value, Convert convert, bool check_weakness = true)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        // count is number of output elements, plus a handful\n+        // more for sake of detecting buffer overruns.\n+        size_t count = GuardSize;\n+        Sequence<T> in(n, [&](size_t k) -> T {\n+            T x = convert(n ^ k);\n+            count += !(x == value) ? 1 : 0;\n+            return x;\n+        });\n+        using namespace std;\n+\n+        Sequence<T> out(count, [=](size_t) { return trash; });\n+        Sequence<T> expected(count, [=](size_t) { return trash; });\n+        if (check_weakness)\n+        {\n+            auto expected_result = remove_copy(in.cfbegin(), in.cfend(), expected.begin(), value);\n+            size_t m = expected_result - expected.begin();\n+            EXPECT_TRUE(n / 4 <= m && m <= 3 * (n + 1) / 4, \"weak test for remove_copy\");\n+        }\n+        invoke_on_all_policies(run_remove_copy(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), count, value, trash);\n+        invoke_on_all_policies(run_remove_copy(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), count, value, trash);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+\n+    test<float64_t>(-666.0, 8.5, [](size_t j) { return ((j + 1) % 7 & 2) != 0 ? 8.5 : float64_t(j % 32 + j); });\n+\n+    test<int32_t>(-666, 42, [](size_t j) { return ((j + 1) % 5 & 2) != 0 ? 42 : -1 - int32_t(j); });\n+\n+    test<Number>(Number(42, OddTag()), Number(2001, OddTag()),\n+                 [](int32_t j) { return ((j + 1) % 3 & 2) != 0 ? Number(2001, OddTag()) : Number(j, OddTag()); });\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "4d685913f97757f71e3cee6ebad7e3d11f90af04", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/replace.cc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Freplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Freplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Freplace.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,167 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- replace.pass.cpp --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// This class is needed to check the self-copying\n+struct copy_int\n+{\n+    int32_t value;\n+    int32_t copied_times = 0;\n+    explicit copy_int(int32_t val = 0) { value = val; }\n+\n+    copy_int&\n+    operator=(const copy_int& other)\n+    {\n+        if (&other == this)\n+            copied_times++;\n+        else\n+        {\n+            value = other.value;\n+            copied_times = other.copied_times;\n+        }\n+        return *this;\n+    }\n+\n+    bool\n+    operator==(const copy_int& other) const\n+    {\n+        return (value == other.value);\n+    }\n+};\n+\n+template <typename Iterator>\n+struct test_one_policy\n+{\n+    std::size_t len;\n+    Iterator data_b;\n+    Iterator data_e;\n+    test_one_policy(Iterator data_, std::size_t len_)\n+    {\n+        len = len_;\n+        data_b = data_;\n+        data_e = std::next(data_b, len);\n+    }\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2, typename T, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 expected_b, Iterator1 expected_e, Iterator2 actual_b,\n+               Iterator2 actual_e, Predicate pred, const T& value, const T& old_value)\n+    {\n+        using namespace std;\n+\n+        copy(data_b, data_e, expected_b);\n+        copy(data_b, data_e, actual_b);\n+\n+        replace(expected_b, expected_e, old_value, value);\n+        replace(exec, actual_b, actual_e, old_value, value);\n+\n+        EXPECT_TRUE((check<T, Iterator2>(actual_b, actual_e)), \"wrong result of self assignment check\");\n+        EXPECT_TRUE(equal(expected_b, expected_e, actual_b), \"wrong result of replace\");\n+\n+        copy(data_b, data_e, expected_b);\n+        copy(data_b, data_e, actual_b);\n+\n+        replace_if(expected_b, expected_e, pred, value);\n+        replace_if(exec, actual_b, actual_e, pred, value);\n+        EXPECT_TRUE(equal(expected_b, expected_e, actual_b), \"wrong result of replace_if\");\n+    }\n+\n+    template <typename T, typename Iterator1>\n+    bool\n+    check(Iterator1 b, Iterator1 e)\n+    {\n+        return true;\n+    }\n+\n+    template <typename T, typename Iterator1>\n+    typename std::enable_if<std::is_same<T, copy_int>::value, bool>::type_t\n+    check(Iterator1 b, Iterator1 e)\n+    {\n+        return std::all_of(b, e, [](const copy_int& elem) { return elem.copied_times == 0; });\n+    }\n+};\n+\n+template <typename T1, typename T2, typename Pred>\n+void\n+test(Pred pred)\n+{\n+    typedef typename Sequence<T2>::iterator iterator_type;\n+\n+    const std::size_t max_len = 100000;\n+\n+    const T1 value = T1(0);\n+    const T1 new_value = T1(666);\n+\n+    Sequence<T2> expected(max_len);\n+    Sequence<T2> actual(max_len);\n+\n+    Sequence<T2> data(max_len, [&value](std::size_t i) {\n+        if (i % 3 == 2)\n+        {\n+            return T1(i);\n+        }\n+        else\n+        {\n+            return value;\n+        }\n+    });\n+\n+    for (std::size_t len = 0; len < max_len; len = len <= 16 ? len + 1 : std::size_t(3.1415 * len))\n+    {\n+        test_one_policy<iterator_type> temp(data.begin(), len);\n+\n+        invoke_on_all_policies(temp, expected.begin(), expected.begin() + len, actual.begin(), actual.begin() + len,\n+                               pred, new_value, value);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        invoke_if(exec, [&]() { replace_if(exec, iter, iter, non_const(is_even), T(0)); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t, float32_t>(__pstl::__internal::__equal_value<int32_t>(666));\n+    test<uint16_t, uint8_t>([](const uint16_t& elem) { return elem % 3 < 2; });\n+    test<float64_t, int64_t>([](const float64_t& elem) { return elem * elem - 3.5 * elem > 10; });\n+    test<copy_int, copy_int>([](const copy_int& val) { return val.value / 5 > 2; });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "8ff476db8c3253c5e5435cda823fb839e7d3250b", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/replace_copy.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Freplace_copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Freplace_copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Freplace_copy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,112 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- replace_copy.pass.cpp ---------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for replace_copy and replace_copy_if\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_replace_copy\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size n,\n+               Predicate pred, const T& old_value, const T& new_value, T trash)\n+    {\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+        // Run replace_copy\n+        auto i = std::replace_copy(first, last, expected_first, old_value, new_value);\n+        auto k = std::replace_copy(exec, first, last, out_first, old_value, new_value);\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong replace_copy effect\");\n+        EXPECT_TRUE(out_last == k, \"wrong return value from replace_copy\");\n+\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+        // Run replace_copy_if\n+        i = replace_copy_if(first, last, expected_first, pred, new_value);\n+        k = replace_copy_if(exec, first, last, out_first, pred, new_value);\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong replace_copy_if effect\");\n+        EXPECT_TRUE(out_last == k, \"wrong return value from replace_copy_if\");\n+    }\n+};\n+\n+template <typename T, typename Convert, typename Predicate>\n+void\n+test(T trash, const T& old_value, const T& new_value, Predicate pred, Convert convert)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, [&](size_t k) -> T { return convert(n ^ k); });\n+        Sequence<T> out(n, [=](size_t) { return trash; });\n+        Sequence<T> expected(n, [=](size_t) { return trash; });\n+\n+        invoke_on_all_policies(test_replace_copy(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), out.size(), pred, old_value, new_value, trash);\n+        invoke_on_all_policies(test_replace_copy(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), out.size(), pred, old_value, new_value, trash);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+\n+        invoke_if(exec, [&]() { replace_copy_if(exec, input_iter, input_iter, out_iter, non_const(is_even), T(0)); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test<float64_t>(-666.0, 8.5, 0.33, [](const float64_t& x) { return x * x <= 1024; },\n+                    [](size_t j) { return ((j + 1) % 7 & 2) != 0 ? 8.5 : float64_t(j % 32 + j); });\n+\n+    test<int32_t>(-666, 42, 99, [](const int32_t& x) { return x != 42; },\n+                  [](size_t j) { return ((j + 1) % 5 & 2) != 0 ? 42 : -1 - int32_t(j); });\n+\n+#if !__PSTL_ICC_17_TEST_MAC_RELEASE_32_BROKEN\n+    test<Number>(Number(42, OddTag()), Number(2001, OddTag()), Number(2017, OddTag()), IsMultiple(3, OddTag()),\n+                 [](int32_t j) { return ((j + 1) % 3 & 2) != 0 ? Number(2001, OddTag()) : Number(j, OddTag()); });\n+#endif\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "88ec2c7a452f34a21c4417bb61f546a435d91fdd", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/rotate.cc", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Frotate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Frotate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Frotate.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,181 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- rotate.pass.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iterator>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct wrapper\n+{\n+    T t;\n+    int move_count;\n+    explicit wrapper(T t_) : t(t_), move_count(0) {}\n+    wrapper&\n+    operator=(const T& t_)\n+    {\n+        t = t_;\n+        return *this;\n+    }\n+\n+    wrapper(const wrapper<T>& a) : move_count(0) { t = a.t; }\n+\n+    wrapper<T>&\n+    operator=(wrapper<T>& a)\n+    {\n+        t = a.t;\n+        return *this;\n+    }\n+\n+    wrapper<T>&\n+    operator=(wrapper<T>&& a)\n+    {\n+        t = a.t;\n+        move_count += 1;\n+        return *this;\n+    }\n+};\n+\n+template <typename T>\n+struct compare\n+{\n+    bool\n+    operator()(const T& a, const T& b)\n+    {\n+        return a == b;\n+    }\n+};\n+\n+template <typename T>\n+struct compare<wrapper<T>>\n+{\n+    bool\n+    operator()(const wrapper<T>& a, const wrapper<T>& b)\n+    {\n+        return a.t == b.t;\n+    }\n+};\n+#include <typeinfo>\n+\n+struct test_one_policy\n+{\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specializations to skip testing in case of broken configuration\n+    template <typename Iterator, typename Size>\n+    void\n+    operator()(__pstl::execution::unsequenced_policy, Iterator data_b, Iterator data_e, Iterator actual_b,\n+               Iterator actual_e, Size shift)\n+    {\n+    }\n+    template <typename Iterator, typename Size>\n+    void\n+    operator()(__pstl::execution::parallel_unsequenced_policy, Iterator data_b, Iterator data_e, Iterator actual_b,\n+               Iterator actual_e, Size shift)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator, typename Size>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator data_b, Iterator data_e, Iterator actual_b, Iterator actual_e,\n+               Size shift)\n+    {\n+        using namespace std;\n+        using T = typename iterator_traits<Iterator>::value_type;\n+        Iterator actual_m = std::next(actual_b, shift);\n+\n+        copy(data_b, data_e, actual_b);\n+        Iterator actual_return = rotate(exec, actual_b, actual_m, actual_e);\n+\n+        EXPECT_TRUE(actual_return == std::next(actual_b, std::distance(actual_m, actual_e)), \"wrong result of rotate\");\n+        auto comparator = compare<T>();\n+        bool check = std::equal(actual_return, actual_e, data_b, comparator);\n+        check = check && std::equal(actual_b, actual_return, std::next(data_b, shift), comparator);\n+\n+        EXPECT_TRUE(check, \"wrong effect of rotate\");\n+        EXPECT_TRUE(check_move(exec, actual_b, actual_e, shift), \"wrong move test of rotate\");\n+    }\n+\n+    template <typename ExecutionPolicy, typename Iterator, typename Size>\n+    typename std::enable_if<\n+        is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value &&\n+            !std::is_same<ExecutionPolicy, __pstl::execution::sequenced_policy>::value &&\n+            std::is_same<typename std::iterator_traits<Iterator>::value_type, wrapper<float32_t>>::value,\n+        bool>::type\n+    check_move(ExecutionPolicy&& exec, Iterator b, Iterator e, Size shift)\n+    {\n+        bool result = all_of(b, e, [](wrapper<float32_t>& a) {\n+            bool temp = a.move_count > 0;\n+            a.move_count = 0;\n+            return temp;\n+        });\n+        return shift == 0 || result;\n+    }\n+\n+    template <typename ExecutionPolicy, typename Iterator, typename Size>\n+    typename std::enable_if<\n+        !(is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value &&\n+          !std::is_same<ExecutionPolicy, __pstl::execution::sequenced_policy>::value &&\n+          std::is_same<typename std::iterator_traits<Iterator>::value_type, wrapper<float32_t>>::value),\n+        bool>::type\n+    check_move(ExecutionPolicy&& exec, Iterator b, Iterator e, Size shift)\n+    {\n+        return true;\n+    }\n+};\n+\n+template <typename T>\n+void\n+test()\n+{\n+    const int32_t max_len = 100000;\n+\n+    Sequence<T> actual(max_len, [](std::size_t i) { return T(i); });\n+    Sequence<T> data(max_len, [](std::size_t i) { return T(i); });\n+\n+    for (int32_t len = 0; len < max_len; len = len <= 16 ? len + 1 : int32_t(3.1415 * len))\n+    {\n+        int32_t shifts[] = {0, 1, 2, len / 3, (2 * len) / 3, len - 1};\n+        for (auto shift : shifts)\n+        {\n+            if (shift >= 0 && shift < len)\n+            {\n+                invoke_on_all_policies(test_one_policy(), data.begin(), data.begin() + len, actual.begin(),\n+                                       actual.begin() + len, shift);\n+            }\n+        }\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>();\n+    test<wrapper<float64_t>>();\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "35165d0180a5190b8ce61ba021dce5021d39e270", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/rotate_copy.cc", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Frotate_copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Frotate_copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Frotate_copy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,154 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- rotate_copy.pass.cpp ----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iterator>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct wrapper;\n+\n+template <typename T>\n+bool\n+compare(const wrapper<T>& a, const wrapper<T>& b)\n+{\n+    return a.t == b.t;\n+}\n+\n+template <typename T>\n+bool\n+compare(const T& a, const T& b)\n+{\n+    return a == b;\n+}\n+\n+template <typename T>\n+struct wrapper\n+{\n+    explicit wrapper(T t_) : t(t_) {}\n+    wrapper&\n+    operator=(const T& t_)\n+    {\n+        t = t_;\n+        return *this;\n+    }\n+    friend bool\n+    compare<T>(const wrapper<T>& a, const wrapper<T>& b);\n+\n+  private:\n+    T t;\n+};\n+\n+template <typename T, typename It1, typename It2>\n+struct comparator\n+{\n+    using T1 = typename std::iterator_traits<It1>::value_type;\n+    using T2 = typename std::iterator_traits<It2>::value_type;\n+    bool\n+    operator()(T1 a, T2 b)\n+    {\n+        T temp = a;\n+        return compare(temp, b);\n+    }\n+};\n+\n+struct test_one_policy\n+{\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1, typename Iterator2>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b,\n+               Iterator2 actual_e, std::size_t shift)\n+    {\n+    }\n+    template <typename Iterator1, typename Iterator2>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b,\n+               Iterator2 actual_e, std::size_t shift)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b, Iterator2 actual_e,\n+               std::size_t shift)\n+    {\n+        using namespace std;\n+        using T = typename iterator_traits<Iterator2>::value_type;\n+        Iterator1 data_m = std::next(data_b, shift);\n+\n+        fill(actual_b, actual_e, T(-123));\n+        Iterator2 actual_return = rotate_copy(exec, data_b, data_m, data_e, actual_b);\n+\n+        EXPECT_TRUE(actual_return == actual_e, \"wrong result of rotate_copy\");\n+        auto comparer = comparator<T, Iterator1, Iterator2>();\n+        bool check = std::equal(data_m, data_e, actual_b, comparer);\n+        check = check && std::equal(data_b, data_m, std::next(actual_b, std::distance(data_m, data_e)), comparer);\n+\n+        EXPECT_TRUE(check, \"wrong effect of rotate_copy\");\n+    }\n+};\n+\n+template <typename T1, typename T2>\n+void\n+test()\n+{\n+\n+    const std::size_t max_len = 100000;\n+\n+    Sequence<T2> actual(max_len, [](std::size_t i) { return T1(i); });\n+\n+    Sequence<T1> data(max_len, [](std::size_t i) { return T1(i); });\n+\n+    for (std::size_t len = 0; len < max_len; len = len <= 16 ? len + 1 : std::size_t(3.1415 * len))\n+    {\n+        std::size_t shifts[] = {0, 1, 2, len / 3, (2 * len) / 3, len - 1};\n+        for (std::size_t shift : shifts)\n+        {\n+            if (shift > 0 && shift < len)\n+            {\n+                invoke_on_all_policies(test_one_policy(), data.begin(), data.begin() + len, actual.begin(),\n+                                       actual.begin() + len, shift);\n+                invoke_on_all_policies(test_one_policy(), data.cbegin(), data.cbegin() + len, actual.begin(),\n+                                       actual.begin() + len, shift);\n+            }\n+        }\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    test<int32_t, int8_t>();\n+    test<uint16_t, float32_t>();\n+    test<float64_t, int64_t>();\n+    test<wrapper<float64_t>, wrapper<float64_t>>();\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "3a19f36869c0e5d70b21a8410c598f686c75ee1c", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/swap_ranges.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fswap_ranges.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fswap_ranges.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Fswap_ranges.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,141 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- swap_ranges.pass.cpp ----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iterator>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct wrapper\n+{\n+    T t;\n+    std::size_t number_of_swaps = 0;\n+    wrapper() {}\n+    explicit wrapper(T t_) : t(t_) {}\n+    template <typename U>\n+    void\n+    operator=(const U& b)\n+    {\n+        t = b;\n+    }\n+    bool\n+    operator==(const wrapper<T>& a) const\n+    {\n+        return t == a.t;\n+    }\n+};\n+\n+template <typename T>\n+void\n+swap(wrapper<T>& a, wrapper<T>& b)\n+{\n+    std::swap(a.t, b.t);\n+    a.number_of_swaps++;\n+    b.number_of_swaps++;\n+}\n+\n+template <typename T>\n+struct check_swap\n+{\n+    bool\n+    operator()(T& a)\n+    {\n+        return true;\n+    }\n+};\n+\n+template <typename T>\n+struct check_swap<wrapper<T>>\n+{\n+    bool\n+    operator()(wrapper<T>& a)\n+    {\n+        bool temp = (a.number_of_swaps == 1);\n+        a.number_of_swaps = 0;\n+        return temp;\n+    }\n+};\n+\n+struct test_one_policy\n+{\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b, Iterator2 actual_e)\n+    {\n+        using namespace std;\n+        using T_ref = typename iterator_traits<Iterator1>::reference;\n+        using T = typename iterator_traits<Iterator1>::value_type;\n+\n+        iota(data_b, data_e, 0);\n+        iota(actual_b, actual_e, std::distance(data_b, data_e));\n+\n+        Iterator2 actual_return = swap_ranges(exec, data_b, data_e, actual_b);\n+        bool check_return = (actual_return == actual_e);\n+        EXPECT_TRUE(check_return, \"wrong result of swap_ranges\");\n+        if (check_return)\n+        {\n+            std::size_t i = 0;\n+            bool check = all_of(actual_b, actual_e, [&i](T_ref a) { return a == T(i++); }) &&\n+                         all_of(data_b, data_e, [&i](T_ref a) { return a == T(i++); });\n+\n+            EXPECT_TRUE(check, \"wrong effect of swap_ranges\");\n+\n+            if (check)\n+            {\n+                bool swap_check =\n+                    all_of(data_b, data_e, check_swap<T>()) && all_of(actual_b, actual_e, check_swap<T>());\n+                EXPECT_TRUE(swap_check, \"wrong effect of swap_ranges swap check\");\n+            }\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void\n+test()\n+{\n+    const std::size_t max_len = 100000;\n+\n+    Sequence<T> data(max_len);\n+    Sequence<T> actual(max_len);\n+\n+    for (std::size_t len = 0; len < max_len; len = len <= 16 ? len + 1 : std::size_t(3.1415 * len))\n+    {\n+        invoke_on_all_policies(test_one_policy(), data.begin(), data.begin() + len, actual.begin(),\n+                               actual.begin() + len);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    test<wrapper<uint16_t>>();\n+    test<wrapper<float64_t>>();\n+    test<int32_t>();\n+    test<float32_t>();\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "37b2d125330ad9ac0d6cc3a00954f7ddbd46d84c", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/transform_binary.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ftransform_binary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ftransform_binary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ftransform_binary.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,128 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- transform_binary.pass.cpp -----------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename In1, typename In2, typename Out>\n+class TheOperation\n+{\n+    Out val;\n+\n+  public:\n+    TheOperation(Out v) : val(v) {}\n+    Out\n+    operator()(const In1& x, const In2& y) const\n+    {\n+        return Out(val + x - y);\n+    }\n+};\n+\n+template <typename InputIterator1, typename InputIterator2, typename OutputIterator>\n+void\n+check_and_reset(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator out_first)\n+{\n+    typedef typename std::iterator_traits<OutputIterator>::value_type Out;\n+    typename std::iterator_traits<OutputIterator>::difference_type k = 0;\n+    for (; first1 != last1; ++first1, ++first2, ++out_first, ++k)\n+    {\n+        // check\n+        Out expected = Out(1.5) + *first1 - *first2;\n+        Out actual = *out_first;\n+        if (std::is_floating_point<Out>::value)\n+        {\n+            EXPECT_TRUE((expected > actual ? expected - actual : actual - expected) < 1e7,\n+                        \"wrong value in output sequence\");\n+        }\n+        else\n+        {\n+            EXPECT_EQ(expected, actual, \"wrong value in output sequence\");\n+        }\n+        // reset\n+        *out_first = k % 7 != 4 ? 7 * k - 5 : 0;\n+    }\n+}\n+\n+struct test_one_policy\n+{\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename OutputIterator,\n+              typename BinaryOp>\n+    void\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               OutputIterator out_first, OutputIterator out_last, BinaryOp op)\n+    {\n+        auto orrr = std::transform(exec, first1, last1, first2, out_first, op);\n+        check_and_reset(first1, last1, first2, out_first);\n+    }\n+};\n+\n+template <typename In1, typename In2, typename Out, typename Predicate>\n+void\n+test(Predicate pred)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<In1> in1(n, [](size_t k) { return k % 5 != 1 ? 3 * k - 7 : 0; });\n+        Sequence<In2> in2(n, [](size_t k) { return k % 7 != 2 ? 5 * k - 5 : 0; });\n+\n+        Sequence<Out> out(n, [](size_t k) { return -1; });\n+\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.end(), in2.begin(), in2.end(), out.begin(),\n+                               out.end(), pred);\n+        invoke_on_all_policies(test_one_policy(), in1.cbegin(), in1.cend(), in2.cbegin(), in2.cend(), out.begin(),\n+                               out.end(), pred);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            InputIterator input_iter2 = input_iter;\n+            transform(exec, input_iter, input_iter, input_iter2, out_iter, non_const(std::plus<T>()));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    //const operator()\n+    test<int32_t, int32_t, int32_t>(TheOperation<int32_t, int32_t, int32_t>(1));\n+    test<float32_t, float32_t, float32_t>(TheOperation<float32_t, float32_t, float32_t>(1.5));\n+    //non-const operator()\n+    test<int32_t, float32_t, float32_t>(non_const(TheOperation<int32_t, float32_t, float32_t>(1.5)));\n+    test<int64_t, float64_t, float32_t>(non_const(TheOperation<int64_t, float64_t, float32_t>(1.5)));\n+    //lambda\n+    test<int8_t, float64_t, int8_t>([](const int8_t& x, const float64_t& y) { return int8_t(int8_t(1.5) + x - y); });\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "2224c0a11f5400614f76099d9c878350e20fb45c", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/transform_unary.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ftransform_unary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ftransform_unary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Ftransform_unary.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,98 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- transform_unary.pass.cpp ------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename InputIterator, typename OutputIterator>\n+void\n+check_and_reset(InputIterator first, InputIterator last, OutputIterator out_first)\n+{\n+    typedef typename std::iterator_traits<OutputIterator>::value_type Out;\n+    typename std::iterator_traits<OutputIterator>::difference_type k = 0;\n+    for (; first != last; ++first, ++out_first, ++k)\n+    {\n+        // check\n+        Out expected = 1 - *first;\n+        Out actual = *out_first;\n+        EXPECT_EQ(expected, actual, \"wrong value in output sequence\");\n+        // reset\n+        *out_first = k % 7 != 4 ? 7 * k - 5 : 0;\n+    }\n+}\n+\n+struct test_one_policy\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename UnaryOp>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, UnaryOp op)\n+    {\n+        auto orr = std::transform(exec, first, last, out_first, op);\n+        EXPECT_TRUE(out_last == orr, \"transform returned wrong iterator\");\n+        check_and_reset(first, last, out_first);\n+    }\n+};\n+\n+template <typename Tin, typename Tout>\n+void\n+test()\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<Tin> in(n, [](int32_t k) { return k % 5 != 1 ? 3 * k - 7 : 0; });\n+\n+        Sequence<Tout> out(n);\n+\n+        const auto flip = Complement<Tin, Tout>(1);\n+        invoke_on_all_policies(test_one_policy(), in.begin(), in.end(), out.begin(), out.end(), flip);\n+        invoke_on_all_policies(test_one_policy(), in.cbegin(), in.cend(), out.begin(), out.end(), flip);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        invoke_if(exec, [&]() { transform(exec, input_iter, input_iter, out_iter, non_const(std::negate<T>())); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t, int32_t>();\n+    test<int32_t, float32_t>();\n+    test<uint16_t, float32_t>();\n+    test<float32_t, float64_t>();\n+    test<float64_t, float64_t>();\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "c87904876f565f32cb41e3edc4a645c8aa1a2f02", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/unique.cc", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Funique.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Funique.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Funique.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,164 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- unique.pass.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Test for unique\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct run_unique\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename ForwardIt, typename Generator>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, ForwardIt first1, ForwardIt last1, ForwardIt first2,\n+               ForwardIt last2, Generator generator)\n+    {\n+    }\n+\n+    template <typename ForwardIt, typename Generator>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, ForwardIt first1, ForwardIt last1, ForwardIt first2,\n+               ForwardIt last2, Generator generator)\n+    {\n+    }\n+\n+    template <typename ForwardIt, typename BinaryPred, typename Generator>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, ForwardIt first1, ForwardIt last1, ForwardIt first2,\n+               ForwardIt last2, BinaryPred pred, Generator generator)\n+    {\n+    }\n+\n+    template <typename ForwardIt, typename BinaryPred, typename Generator>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, ForwardIt first1, ForwardIt last1, ForwardIt first2,\n+               ForwardIt last2, BinaryPred pred, Generator generator)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename ForwardIt, typename Generator>\n+    void\n+    operator()(Policy&& exec, ForwardIt first1, ForwardIt last1, ForwardIt first2, ForwardIt last2, Generator generator)\n+    {\n+        using namespace std;\n+\n+        // Preparation\n+        fill_data(first1, last1, generator);\n+        fill_data(first2, last2, generator);\n+\n+        ForwardIt i = unique(first1, last1);\n+        ForwardIt k = unique(exec, first2, last2);\n+\n+        auto n = std::distance(first1, i);\n+        EXPECT_TRUE(std::distance(first2, k) == n, \"wrong return value from unique without predicate\");\n+        EXPECT_EQ_N(first1, first2, n, \"wrong effect from unique without predicate\");\n+    }\n+\n+    template <typename Policy, typename ForwardIt, typename BinaryPred, typename Generator>\n+    void\n+    operator()(Policy&& exec, ForwardIt first1, ForwardIt last1, ForwardIt first2, ForwardIt last2, BinaryPred pred,\n+               Generator generator)\n+    {\n+        using namespace std;\n+\n+        // Preparation\n+        fill_data(first1, last1, generator);\n+        fill_data(first2, last2, generator);\n+\n+        ForwardIt i = unique(first1, last1, pred);\n+        ForwardIt k = unique(exec, first2, last2, pred);\n+\n+        auto n = std::distance(first1, i);\n+        EXPECT_TRUE(std::distance(first2, k) == n, \"wrong return value from unique with predicate\");\n+        EXPECT_EQ_N(first1, first2, n, \"wrong effect from unique with predicate\");\n+    }\n+};\n+\n+template <typename T, typename Generator, typename Predicate>\n+void\n+test(Generator generator, Predicate pred)\n+{\n+    const std::size_t max_size = 1000000;\n+    Sequence<T> in(max_size, [](size_t v) { return T(v); });\n+    Sequence<T> exp(max_size, [](size_t v) { return T(v); });\n+\n+    for (size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        invoke_on_all_policies(run_unique(), exp.begin(), exp.begin() + n, in.begin(), in.begin() + n, generator);\n+        invoke_on_all_policies(run_unique(), exp.begin(), exp.begin() + n, in.begin(), in.begin() + n, pred, generator);\n+    }\n+}\n+\n+template <typename T>\n+struct LocalWrapper\n+{\n+    T my_val;\n+\n+    explicit LocalWrapper(T k) : my_val(k) {}\n+    LocalWrapper(LocalWrapper&& input) : my_val(std::move(input.my_val)) {}\n+    LocalWrapper&\n+    operator=(LocalWrapper&& input)\n+    {\n+        my_val = std::move(input.my_val);\n+        return *this;\n+    }\n+    friend bool\n+    operator==(const LocalWrapper<T>& x, const LocalWrapper<T>& y)\n+    {\n+        return x.my_val == y.my_val;\n+    }\n+};\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        invoke_if(exec, [&]() { unique(exec, iter, iter, non_const(std::equal_to<T>())); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+#if !__PSTL_ICC_16_17_18_TEST_UNIQUE_MASK_RELEASE_BROKEN\n+    test<int32_t>([](size_t j) { return j / 3; },\n+                  [](const int32_t& val1, const int32_t& val2) { return val1 * val1 == val2 * val2; });\n+    test<float64_t>([](size_t) { return float64_t(1); },\n+                    [](const float64_t& val1, const float64_t& val2) { return val1 != val2; });\n+#endif\n+    test<LocalWrapper<uint32_t>>([](size_t j) { return LocalWrapper<uint32_t>(j); },\n+                                 [](const LocalWrapper<uint32_t>& val1, const LocalWrapper<uint32_t>& val2) {\n+                                     return val1.my_val != val2.my_val;\n+                                 });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "1b66d264a59be2215675133f1b53fed83e3166a5", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_modifying_operations/unique_copy_equal.cc", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Funique_copy_equal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Funique_copy_equal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_modifying_operations%2Funique_copy_equal.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,142 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- unique_copy_equal.pass.cpp ----------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for unique_copy\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct run_unique_copy\n+{\n+#if __PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN // dummy specializations to skip testing in case of broken configuration\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(__pstl::execution::parallel_policy, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size n,\n+               Predicate pred, T trash)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(__pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last,\n+               OutputIterator out_first, OutputIterator out_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, Size n, Predicate pred, T trash)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Predicate, typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator2 expected_first, OutputIterator2 expected_last, Size n,\n+               Predicate pred, T trash)\n+    {\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+\n+        // Run unique_copy\n+        auto i = unique_copy(first, last, expected_first);\n+        auto k = unique_copy(exec, first, last, out_first);\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong unique_copy effect\");\n+        for (size_t j = 0; j < GuardSize; ++j)\n+        {\n+            ++k;\n+        }\n+        EXPECT_TRUE(out_last == k, \"wrong return value from unique_copy\");\n+\n+        // Cleaning\n+        std::fill_n(expected_first, n, trash);\n+        std::fill_n(out_first, n, trash);\n+        // Run unique_copy with predicate\n+        i = unique_copy(first, last, expected_first, pred);\n+        k = unique_copy(exec, first, last, out_first, pred);\n+        EXPECT_EQ_N(expected_first, out_first, n, \"wrong unique_copy with predicate effect\");\n+        for (size_t j = 0; j < GuardSize; ++j)\n+        {\n+            ++k;\n+        }\n+        EXPECT_TRUE(out_last == k, \"wrong return value from unique_copy with predicate\");\n+    }\n+};\n+\n+template <typename T, typename BinaryPredicate, typename Convert>\n+void\n+test(T trash, BinaryPredicate pred, Convert convert, bool check_weakness = true)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        // count is number of output elements, plus a handful\n+        // more for sake of detecting buffer overruns.\n+        Sequence<T> in(n, [&](size_t k) -> T { return convert(k ^ n); });\n+        using namespace std;\n+        size_t count = GuardSize;\n+        for (size_t k = 0; k < in.size(); ++k)\n+            count += k == 0 || !pred(in[k], in[k - 1]) ? 1 : 0;\n+        Sequence<T> out(count, [=](size_t) { return trash; });\n+        Sequence<T> expected(count, [=](size_t) { return trash; });\n+        if (check_weakness)\n+        {\n+            auto expected_result = unique_copy(in.begin(), in.end(), expected.begin(), pred);\n+            size_t m = expected_result - expected.begin();\n+            EXPECT_TRUE(n / (n < 10000 ? 4 : 6) <= m && m <= (3 * n + 1) / 4, \"weak test for unique_copy\");\n+        }\n+        invoke_on_all_policies(run_unique_copy(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), count, pred, trash);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        unique_copy(exec, input_iter, input_iter, out_iter, non_const(std::equal_to<T>()));\n+    }\n+};\n+\n+int32_t\n+main(int32_t argc, char* argv[])\n+{\n+    test<Number>(Number(42, OddTag()), std::equal_to<Number>(),\n+                 [](int32_t j) { return Number(3 * j / 13 ^ (j & 8), OddTag()); });\n+\n+    test<float32_t>(float32_t(42), std::equal_to<float32_t>(),\n+                    [](int32_t j) { return float32_t(5 * j / 23 ^ (j / 7)); });\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_RELEASE_BROKEN\n+    test<float32_t>(float32_t(42), [](float32_t x, float32_t y) { return false; },\n+                    [](int32_t j) { return float32_t(j); }, false);\n+#endif\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "1ec669086cc2274782dc3f99044e8ae47600d8dc", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/adjacent_find.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fadjacent_find.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fadjacent_find.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fadjacent_find.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,122 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- adjacent_find.pass.cpp --------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_adjacent_find\n+{\n+    template <typename Policy, typename Iterator, typename Pred>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Pred pred)\n+    {\n+        using namespace std;\n+\n+        auto k = std::adjacent_find(first, last, pred);\n+        auto i = adjacent_find(exec, first, last, pred);\n+        EXPECT_TRUE(i == k, \"wrong return value from adjacent_find with predicate\");\n+\n+        i = adjacent_find(exec, first, last);\n+        EXPECT_TRUE(i == k, \"wrong return value from adjacent_find without predicate\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_adjacent_find_by_type()\n+{\n+\n+    size_t counts[] = {2, 3, 500};\n+    for (int32_t c = 0; c < const_size(counts); ++c)\n+    {\n+\n+        for (int32_t e = 0; e < (counts[c] >= 64 ? 64 : (counts[c] == 2 ? 1 : 2)); ++e)\n+        {\n+            Sequence<T> in(counts[c], [](int32_t v) -> T { return T(v); }); //fill 0...n\n+            in[e] = in[e + 1] = -1;                                         //make an adjacent pair\n+\n+            auto i = std::adjacent_find(in.cbegin(), in.cend(), std::equal_to<T>());\n+            EXPECT_TRUE(i == in.cbegin() + e, \"std::adjacent_find returned wrong result\");\n+\n+            invoke_on_all_policies(test_adjacent_find(), in.begin(), in.end(), std::equal_to<T>());\n+            invoke_on_all_policies(test_adjacent_find(), in.cbegin(), in.cend(), std::equal_to<T>());\n+        }\n+    }\n+\n+    //special cases: size=0, size=1;\n+    for (int32_t expect = 0; expect < 1; ++expect)\n+    {\n+        Sequence<T> in(expect, [](int32_t v) -> T { return T(v); }); //fill 0...n\n+        auto i = std::adjacent_find(in.cbegin(), in.cend(), std::equal_to<T>());\n+        EXPECT_TRUE(i == in.cbegin() + expect, \"std::adjacent_find returned wrong result\");\n+\n+        invoke_on_all_policies(test_adjacent_find(), in.begin(), in.end(), std::equal_to<T>());\n+        invoke_on_all_policies(test_adjacent_find(), in.cbegin(), in.cend(), std::equal_to<T>());\n+    }\n+\n+    //special cases:\n+    Sequence<T> a1 = {5, 5, 5, 6, 7, 8, 9};\n+    invoke_on_all_policies(test_adjacent_find(), a1.begin(), a1.end(), std::equal_to<T>());\n+    invoke_on_all_policies(test_adjacent_find(), a1.begin() + 1, a1.end(), std::equal_to<T>());\n+\n+    invoke_on_all_policies(test_adjacent_find(), a1.cbegin(), a1.cend(), std::equal_to<T>());\n+    invoke_on_all_policies(test_adjacent_find(), a1.cbegin() + 1, a1.cend(), std::equal_to<T>());\n+\n+    Sequence<T> a2 = {5, 6, 7, 8, 9, 9};\n+    invoke_on_all_policies(test_adjacent_find(), a2.begin(), a2.end(), std::equal_to<T>());\n+    invoke_on_all_policies(test_adjacent_find(), a2.begin(), a2.end() - 1, std::equal_to<T>());\n+\n+    invoke_on_all_policies(test_adjacent_find(), a2.cbegin(), a2.cend(), std::equal_to<T>());\n+    invoke_on_all_policies(test_adjacent_find(), a2.cbegin(), a2.cend() - 1, std::equal_to<T>());\n+\n+    Sequence<T> a3 = {5, 6, 6, 6, 7, 9, 9, 9, 9};\n+    invoke_on_all_policies(test_adjacent_find(), a3.begin(), a3.end(), std::equal_to<T>());\n+\n+    invoke_on_all_policies(test_adjacent_find(), a3.cbegin(), a3.cend(), std::equal_to<T>());\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        adjacent_find(exec, iter, iter, non_const(std::equal_to<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test_adjacent_find_by_type<int32_t>();\n+    test_adjacent_find_by_type<float64_t>();\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_bi<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "0e2ac01f6a15ffcccdee899ee89958dac10c8b2a", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/all_of.cc", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fall_of.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fall_of.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fall_of.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,124 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- all_of.pass.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+/*\n+  TODO: consider implementing the following tests for a better code coverage\n+  - correctness\n+  - bad input argument (if applicable)\n+  - data corruption around/of input and output\n+  - correctly work with nested parallelism\n+  - check that algorithm does not require anything more than is described in its requirements section\n+*/\n+\n+using namespace TestUtils;\n+\n+struct test_all_of\n+{\n+    template <typename ExecutionPolicy, typename Iterator, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator begin, Iterator end, Predicate pred, bool expected)\n+    {\n+\n+        auto actualr = std::all_of(exec, begin, end, pred);\n+        EXPECT_EQ(expected, actualr, \"result for all_of\");\n+    }\n+};\n+\n+template <typename T>\n+struct Parity\n+{\n+    bool parity;\n+\n+  public:\n+    Parity(bool parity_) : parity(parity_) {}\n+    bool\n+    operator()(T value) const\n+    {\n+        return (size_t(value) ^ parity) % 2 == 0;\n+    }\n+};\n+\n+template <typename T>\n+void\n+test(size_t bits)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+\n+        // Sequence of odd values\n+        Sequence<T> in(n, [n, bits](size_t k) { return T(2 * HashBits(n, bits - 1) ^ 1); });\n+\n+        // Even value, or false when T is bool.\n+        T spike(2 * HashBits(n, bits - 1));\n+        Sequence<T> inCopy(in);\n+\n+        invoke_on_all_policies(test_all_of(), in.begin(), in.end(), Parity<T>(1), true);\n+        invoke_on_all_policies(test_all_of(), in.cbegin(), in.cend(), Parity<T>(1), true);\n+        EXPECT_EQ(in, inCopy, \"all_of modified input sequence\");\n+        if (n > 0)\n+        {\n+            // Sprinkle in a miss\n+            in[2 * n / 3] = spike;\n+            invoke_on_all_policies(test_all_of(), in.begin(), in.end(), Parity<T>(1), false);\n+            invoke_on_all_policies(test_all_of(), in.cbegin(), in.cend(), Parity<T>(1), false);\n+\n+            // Sprinkle in a few more misses\n+            in[n / 2] = spike;\n+            in[n / 3] = spike;\n+            invoke_on_all_policies(test_all_of(), in.begin(), in.end(), Parity<T>(1), false);\n+            invoke_on_all_policies(test_all_of(), in.cbegin(), in.cend(), Parity<T>(1), false);\n+        }\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        all_of(exec, iter, iter, non_const(is_even));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(8 * sizeof(int32_t));\n+    test<uint16_t>(8 * sizeof(uint16_t));\n+    test<float64_t>(53);\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN\n+    test<bool>(1);\n+#endif\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "87e0797e642a6de3814e8da1ba77faf8b502a5e6", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/any_of.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fany_of.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fany_of.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fany_of.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,110 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- any_of.pass.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+/*\n+  TODO: consider implementing the following tests for a better code coverage\n+  - correctness\n+  - bad input argument (if applicable)\n+  - data corruption around/of input and output\n+  - correctly work with nested parallelism\n+  - check that algorithm does not require anything more than is described in its requirements section\n+*/\n+\n+using namespace TestUtils;\n+\n+struct test_any_of\n+{\n+    template <typename ExecutionPolicy, typename Iterator, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator begin, Iterator end, Predicate pred, bool expected)\n+    {\n+\n+        auto actualr = std::any_of(exec, begin, end, pred);\n+        EXPECT_EQ(expected, actualr, \"result for any_of\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test(size_t bits)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+\n+        // Sequence of odd values\n+        Sequence<T> in(n, [n, bits](size_t k) { return T(2 * HashBits(n, bits - 1) ^ 1); });\n+\n+        // Even value, or false when T is bool.\n+        T spike(2 * HashBits(n, bits - 1));\n+        Sequence<T> inCopy(in);\n+\n+        invoke_on_all_policies(test_any_of(), in.begin(), in.end(), is_equal_to<T>(spike), false);\n+        invoke_on_all_policies(test_any_of(), in.cbegin(), in.cend(), is_equal_to<T>(spike), false);\n+        EXPECT_EQ(in, inCopy, \"any_of modified input sequence\");\n+        if (n > 0)\n+        {\n+            // Sprinkle in a hit\n+            in[2 * n / 3] = spike;\n+            invoke_on_all_policies(test_any_of(), in.begin(), in.end(), is_equal_to<T>(spike), true);\n+            invoke_on_all_policies(test_any_of(), in.cbegin(), in.cend(), is_equal_to<T>(spike), true);\n+\n+            // Sprinkle in a few more hits\n+            in[n / 2] = spike;\n+            in[n / 3] = spike;\n+            invoke_on_all_policies(test_any_of(), in.begin(), in.end(), is_equal_to<T>(spike), true);\n+            invoke_on_all_policies(test_any_of(), in.cbegin(), in.cend(), is_equal_to<T>(spike), true);\n+        }\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        any_of(exec, iter, iter, non_const(is_even));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(8 * sizeof(int32_t));\n+    test<uint16_t>(8 * sizeof(uint16_t));\n+    test<float64_t>(53);\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN\n+    test<bool>(1);\n+#endif\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "4f2c0ddc6ad7315522bef4a59f7e4f2ab8623f27", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/count.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fcount.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fcount.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fcount.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,115 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- count.pass.cpp ----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for count and count_if\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_count\n+{\n+    template <typename Policy, typename Iterator, typename T>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, T needle)\n+    {\n+        auto expected = std::count(first, last, needle);\n+        auto result = std::count(exec, first, last, needle);\n+        EXPECT_EQ(expected, result, \"wrong count result\");\n+    }\n+};\n+\n+struct test_count_if\n+{\n+    template <typename Policy, typename Iterator, typename Predicate>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Predicate pred)\n+    {\n+        auto expected = std::count_if(first, last, pred);\n+        auto result = std::count_if(exec, first, last, pred);\n+        EXPECT_EQ(expected, result, \"wrong count_if result\");\n+    }\n+};\n+\n+template <typename T>\n+class IsEqual\n+{\n+    T value;\n+\n+  public:\n+    IsEqual(T value_, OddTag) : value(value_) {}\n+    bool\n+    operator()(const T& x) const\n+    {\n+        return x == value;\n+    }\n+};\n+\n+template <typename In, typename T, typename Predicate, typename Convert>\n+void\n+test(T needle, Predicate pred, Convert convert)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<In> in(n, [=](size_t k) -> In {\n+            // Sprinkle \"42\" and \"50\" early, so that short sequences have non-zero count.\n+            return convert((n - k - 1) % 3 == 0 ? 42 : (n - k - 2) % 5 == 0 ? 50 : 3 * (int(k) % 1000 - 500));\n+        });\n+        invoke_on_all_policies(test_count(), in.begin(), in.end(), needle);\n+        invoke_on_all_policies(test_count_if(), in.begin(), in.end(), pred);\n+\n+        invoke_on_all_policies(test_count(), in.cbegin(), in.cend(), needle);\n+        invoke_on_all_policies(test_count_if(), in.cbegin(), in.cend(), pred);\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        count_if(exec, iter, iter, non_const(is_even));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(42, IsEqual<int32_t>(50, OddTag()), [](int32_t j) { return j; });\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_RELEASE_BROKEN\n+    test<int32_t>(42, [](const int32_t& x) { return true; }, [](int32_t j) { return j; });\n+#endif\n+    test<float64_t>(42, IsEqual<float64_t>(50, OddTag()), [](int32_t j) { return float64_t(j); });\n+    test<Number>(Number(42, OddTag()), IsEqual<Number>(Number(50, OddTag()), OddTag()),\n+                 [](int32_t j) { return Number(j, OddTag()); });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "2b51fc4cf76bdd378f470a3ad0d220c74027dbdd", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/equal.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fequal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fequal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fequal.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,175 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- equal.pass.cpp ----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+#define CPP14_ENABLED 0\n+\n+struct UserType\n+{\n+    float32_t f;\n+    float64_t d;\n+    int32_t i;\n+    size_t key;\n+\n+    bool\n+    operator()(UserType a, UserType b)\n+    {\n+        return a.key < b.key;\n+    }\n+    bool\n+    operator<(UserType a)\n+    {\n+        return a.key < key;\n+    }\n+    bool\n+    operator>=(UserType a)\n+    {\n+        return a.key <= key;\n+    }\n+    bool\n+    operator<=(UserType a)\n+    {\n+        return a.key >= key;\n+    }\n+    bool\n+    operator==(UserType a)\n+    {\n+        return a.key == key;\n+    }\n+    bool\n+    operator==(UserType a) const\n+    {\n+        return a.key == key;\n+    }\n+    bool\n+    operator!=(UserType a)\n+    {\n+        return a.key != key;\n+    }\n+    UserType operator!()\n+    {\n+        UserType tmp;\n+        tmp.key = !key;\n+        return tmp;\n+    }\n+    friend std::ostream&\n+    operator<<(std::ostream& stream, const UserType a)\n+    {\n+        stream << a.key;\n+        return stream;\n+    }\n+\n+    UserType() : key(-1), f(0.0f), d(0.0), i(0) {}\n+    UserType(size_t Number) : key(Number), f(0.0f), d(0.0), i(0) {}\n+    UserType&\n+    operator=(const UserType& other)\n+    {\n+        key = other.key;\n+        return *this;\n+    }\n+    UserType(const UserType& other) : key(other.key), f(other.f), d(other.d), i(other.i) {}\n+    UserType(UserType&& other) : key(other.key), f(other.f), d(other.d), i(other.i)\n+    {\n+        other.key = -1;\n+        other.f = 0.0f;\n+        other.d = 0.0;\n+        other.i = 0;\n+    }\n+};\n+\n+struct test_one_policy\n+{\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 first1, Iterator1 last1, Iterator2 first2, bool is_true_equal)\n+    {\n+        using namespace std;\n+\n+        auto expected = equal(first1, last1, first2);\n+        auto actual = equal(exec, first1, last1, first2);\n+        EXPECT_EQ(expected, actual, \"result for equal for random-access iterator, checking against std::equal()\");\n+\n+        // testing bool\n+        EXPECT_TRUE(is_true_equal == actual, \"result for equal for random-access iterator, bool\");\n+\n+//add C++14 equal symantics tests\n+//add more cases for inCopy size less than in\n+#if CPP14_ENABLED\n+        auto actualr14 = std::equal(in.cbegin(), in.cend(), inCopy.cbegin(), inCopy.cend());\n+        EXPECT_EQ(expected, actualr14, \"result for equal for random-access iterator\");\n+#endif\n+    }\n+};\n+\n+template <typename T>\n+void\n+test(size_t bits)\n+{\n+    for (size_t n = 1; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+\n+        // Sequence of odd values\n+        Sequence<T> in(n, [bits](size_t k) { return T(2 * HashBits(k, bits - 1) ^ 1); });\n+        Sequence<T> inCopy(in);\n+\n+        invoke_on_all_policies(test_one_policy(), in.begin(), in.end(), inCopy.begin(), true);\n+        invoke_on_all_policies(test_one_policy(), in.cbegin(), in.cend(), inCopy.cbegin(), true);\n+\n+        // testing bool !equal()\n+        inCopy[0] = !inCopy[0];\n+        invoke_on_all_policies(test_one_policy(), in.begin(), in.end(), inCopy.begin(), false);\n+        invoke_on_all_policies(test_one_policy(), in.cbegin(), in.cend(), inCopy.cbegin(), false);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename FirstIterator, typename SecondInterator>\n+    void\n+    operator()(Policy&& exec, FirstIterator first_iter, SecondInterator second_iter)\n+    {\n+        equal(exec, first_iter, first_iter, second_iter, second_iter, non_const(std::equal_to<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test<int32_t>(8 * sizeof(int32_t));\n+    test<uint16_t>(8 * sizeof(uint16_t));\n+    test<float64_t>(53);\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN\n+    test<bool>(1);\n+#endif\n+    test<UserType>(256);\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "29e3ca0e0c79850e88bc305eaa4a941862994763", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,103 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- find.pass.cpp -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for find\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_find\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator, typename Value>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, Iterator first, Iterator last, Value value)\n+    {\n+    }\n+    template <typename Iterator, typename Value>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator first, Iterator last, Value value)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename Iterator, typename Value>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Value value)\n+    {\n+        auto i = std::find(first, last, value);\n+        auto j = find(exec, first, last, value);\n+        EXPECT_TRUE(i == j, \"wrong return value from find\");\n+    }\n+};\n+\n+template <typename T, typename Value, typename Hit, typename Miss>\n+void\n+test(Value value, Hit hit, Miss miss)\n+{\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, [&](size_t k) -> T { return miss(n ^ k); });\n+        // Try different find positions, including not found.\n+        // By going backwards, we can add extra matches that are *not* supposed to be found.\n+        // The decreasing exponential gives us O(n) total work for the loop since each find takes O(m) time.\n+        for (size_t m = n; m > 0; m *= 0.6)\n+        {\n+            if (m < n)\n+                in[m] = hit(n ^ m);\n+            invoke_on_all_policies(test_find(), in.begin(), in.end(), value);\n+            invoke_on_all_policies(test_find(), in.cbegin(), in.cend(), value);\n+        }\n+    }\n+}\n+\n+// Type defined for sake of checking that std::find works with asymmetric ==.\n+class Weird\n+{\n+    Number value;\n+\n+  public:\n+    friend bool\n+    operator==(Number x, Weird y)\n+    {\n+        return x == y.value;\n+    }\n+    Weird(int32_t val, OddTag) : value(val, OddTag()) {}\n+};\n+\n+int32_t\n+main()\n+{\n+    // Note that the \"hit\" and \"miss\" functions here avoid overflow issues.\n+    test<Number>(Weird(42, OddTag()), [](int32_t j) { return Number(42, OddTag()); }, // hit\n+                 [](int32_t j) { return Number(j == 42 ? 0 : j, OddTag()); });        // miss\n+\n+    // Test with value that is equal to two different bit patterns (-0.0 and 0.0)\n+    test<float32_t>(-0.0, [](int32_t j) { return j & 1 ? 0.0 : -0.0; }, // hit\n+                    [](int32_t j) { return j == 0 ? ~j : j; });         // miss\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "42bfe0f1cfb399e50a5646bb62415dc6fe532edb", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_end.cc", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_end.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_end.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_end.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,130 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- find_end.pass.cpp -------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 b, Iterator1 e, Iterator2 bsub, Iterator2 esub,\n+               Predicate pred)\n+    {\n+    }\n+    template <typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 b, Iterator1 e, Iterator2 bsub, Iterator2 esub,\n+               Predicate pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 b, Iterator1 e, Iterator2 bsub, Iterator2 esub, Predicate pred)\n+    {\n+        using namespace std;\n+        // For find_end\n+        {\n+            auto expected = find_end(b, e, bsub, esub, pred);\n+            auto actual = find_end(exec, b, e, bsub, esub);\n+            EXPECT_TRUE(actual == expected, \"wrong return result from find_end\");\n+\n+            actual = find_end(exec, b, e, bsub, esub, pred);\n+            EXPECT_TRUE(actual == expected, \"wrong return result from find_end with a predicate\");\n+        }\n+\n+        // For search\n+        {\n+            auto expected = search(b, e, bsub, esub, pred);\n+            auto actual = search(exec, b, e, bsub, esub);\n+            EXPECT_TRUE(actual == expected, \"wrong return result from search\");\n+\n+            actual = search(exec, b, e, bsub, esub, pred);\n+            EXPECT_TRUE(actual == expected, \"wrong return result from search with a predicate\");\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void\n+test(const std::size_t bits)\n+{\n+\n+    const std::size_t max_n1 = 1000;\n+    const std::size_t max_n2 = (max_n1 * 10) / 8;\n+    Sequence<T> in(max_n1, [max_n1, bits](std::size_t k) { return T(2 * HashBits(max_n1, bits - 1) ^ 1); });\n+    Sequence<T> sub(max_n2, [max_n1, bits](std::size_t k) { return T(2 * HashBits(max_n1, bits - 1)); });\n+    for (std::size_t n1 = 0; n1 <= max_n1; n1 = n1 <= 16 ? n1 + 1 : size_t(3.1415 * n1))\n+    {\n+        std::size_t sub_n[] = {0, 1, 3, n1, (n1 * 10) / 8};\n+        std::size_t res[] = {0, 1, n1 / 2, n1};\n+        for (auto n2 : sub_n)\n+        {\n+            for (auto r : res)\n+            {\n+                std::size_t i = r, isub = 0;\n+                for (; i < n1 & isub < n2; ++i, ++isub)\n+                    in[i] = sub[isub];\n+                invoke_on_all_policies(test_one_policy(), in.begin(), in.begin() + n1, sub.begin(), sub.begin() + n2,\n+                                       std::equal_to<T>());\n+                invoke_on_all_policies(test_one_policy(), in.cbegin(), in.cbegin() + n1, sub.cbegin(),\n+                                       sub.cbegin() + n2, std::equal_to<T>());\n+            }\n+        }\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename FirstIterator, typename SecondInterator>\n+    void\n+    operator()(Policy&& exec, FirstIterator first_iter, SecondInterator second_iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            find_end(exec, first_iter, first_iter, second_iter, second_iter, non_const(std::equal_to<T>()));\n+            search(exec, first_iter, first_iter, second_iter, second_iter, non_const(std::equal_to<T>()));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(8 * sizeof(int32_t));\n+    test<uint16_t>(8 * sizeof(uint16_t));\n+    test<float64_t>(53);\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN\n+    test<bool>(1);\n+#endif\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "4d4a5390048a32523dbc64d70fa26db97bf25171", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_first_of.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_first_of.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_first_of.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_first_of.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,119 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- find_first_of.pass.cpp --------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 b, Iterator1 e, Iterator2 bsub, Iterator2 esub,\n+               Predicate pred)\n+    {\n+    }\n+    template <typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 b, Iterator1 e, Iterator2 bsub, Iterator2 esub,\n+               Predicate pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 b, Iterator1 e, Iterator2 bsub, Iterator2 esub, Predicate pred)\n+    {\n+        using namespace std;\n+        Iterator1 expected = find_first_of(b, e, bsub, esub, pred);\n+        Iterator1 actual = find_first_of(exec, b, e, bsub, esub, pred);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from find_first_of with a predicate\");\n+\n+        expected = find_first_of(b, e, bsub, esub);\n+        actual = find_first_of(exec, b, e, bsub, esub);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from find_first_of\");\n+    }\n+};\n+\n+template <typename T, typename Predicate>\n+void\n+test(Predicate pred)\n+{\n+\n+    const std::size_t max_n1 = 1000;\n+    const std::size_t max_n2 = (max_n1 * 10) / 8;\n+    Sequence<T> in1(max_n1, [](std::size_t k) { return T(1); });\n+    Sequence<T> in2(max_n2, [](std::size_t k) { return T(0); });\n+    for (std::size_t n1 = 0; n1 <= max_n1; n1 = n1 <= 16 ? n1 + 1 : size_t(3.1415 * n1))\n+    {\n+        std::size_t sub_n[] = {0, 1, n1 / 3, n1, (n1 * 10) / 8};\n+        for (const auto n2 : sub_n)\n+        {\n+            invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.data(), in2.data() + n2, pred);\n+\n+            in2[n2 / 2] = T(1);\n+            invoke_on_all_policies(test_one_policy(), in1.cbegin(), in1.cbegin() + n1, in2.data(), in2.data() + n2,\n+                                   pred);\n+\n+            if (n2 >= 3)\n+            {\n+                in2[2 * n2 / 3] = T(1);\n+                invoke_on_all_policies(test_one_policy(), in1.cbegin(), in1.cbegin() + n1, in2.begin(),\n+                                       in2.begin() + n2, pred);\n+                in2[2 * n2 / 3] = T(0);\n+            }\n+            in2[n2 / 2] = T(0);\n+        }\n+    }\n+    invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + max_n1 / 10, in1.data(),\n+                           in1.data() + max_n1 / 10, pred);\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename FirstIterator, typename SecondInterator>\n+    void\n+    operator()(Policy&& exec, FirstIterator first_iter, SecondInterator second_iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            find_first_of(exec, first_iter, first_iter, second_iter, second_iter, non_const(std::equal_to<T>()));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(std::equal_to<int32_t>());\n+    test<uint16_t>(std::not_equal_to<uint16_t>());\n+    test<float64_t>([](const float64_t x, const float64_t y) { return x * x == y * y; });\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "aa4b0bf25d35ee53f7ccd9c1347b85165f1e843b", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/find_if.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_if.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_if.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffind_if.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,116 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- find_if.pass.cpp --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for find_if and find_if_not\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_find_if\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator, typename Predicate, typename NotPredicate>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, Iterator first, Iterator last, Predicate pred,\n+               NotPredicate not_pred)\n+    {\n+    }\n+    template <typename Iterator, typename Predicate, typename NotPredicate>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator first, Iterator last, Predicate pred,\n+               NotPredicate not_pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename Iterator, typename Predicate, typename NotPredicate>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Predicate pred, NotPredicate not_pred)\n+    {\n+        auto i = std::find_if(first, last, pred);\n+        auto j = find_if(exec, first, last, pred);\n+        EXPECT_TRUE(i == j, \"wrong return value from find_if\");\n+        auto i_not = find_if_not(exec, first, last, not_pred);\n+        EXPECT_TRUE(i_not == i, \"wrong return value from find_if_not\");\n+    }\n+};\n+\n+template <typename T, typename Predicate, typename Hit, typename Miss>\n+void\n+test(Predicate pred, Hit hit, Miss miss)\n+{\n+    auto not_pred = [pred](T x) { return !pred(x); };\n+    // Try sequences of various lengths.\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, [&](size_t k) -> T { return miss(n ^ k); });\n+        // Try different find positions, including not found.\n+        // By going backwards, we can add extra matches that are *not* supposed to be found.\n+        // The decreasing exponential gives us O(n) total work for the loop since each find takes O(m) time.\n+        for (size_t m = n; m > 0; m *= 0.6)\n+        {\n+            if (m < n)\n+                in[m] = hit(n ^ m);\n+            invoke_on_all_policies(test_find_if(), in.begin(), in.end(), pred, not_pred);\n+            invoke_on_all_policies(test_find_if(), in.cbegin(), in.cend(), pred, not_pred);\n+        }\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+\n+        invoke_if(exec, [&]() {\n+            find_if(exec, iter, iter, non_const(is_even));\n+            find_if_not(exec, iter, iter, non_const(is_even));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+#if !__PSTL_ICC_17_TEST_MAC_RELEASE_32_BROKEN\n+    // Note that the \"hit\" and \"miss\" functions here avoid overflow issues.\n+    test<Number>(IsMultiple(5, OddTag()), [](int32_t j) { return Number(j - j % 5, OddTag()); }, // hit\n+                 [](int32_t j) { return Number(j % 5 == 0 ? j ^ 1 : j, OddTag()); });            // miss\n+#endif\n+\n+    // Try type for which algorithm can really be vectorized.\n+    test<float32_t>([](float32_t x) { return x >= 0; }, [](float32_t j) { return j * j; },\n+                    [](float32_t j) { return -1 - j * j; });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "dc9e146dcfb8c7996fd61e886c21cd009e96d081", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/for_each.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffor_each.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffor_each.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Ffor_each.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,109 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- for_each.pass.cpp -------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename Type>\n+struct Gen\n+{\n+    Type\n+    operator()(std::size_t k)\n+    {\n+        return Type(k % 5 != 1 ? 3 * k - 7 : 0);\n+    };\n+};\n+\n+template <typename T>\n+struct Flip\n+{\n+    int32_t val;\n+    Flip(int32_t y) : val(y) {}\n+    T\n+    operator()(T& x) const\n+    {\n+        return x = val - x;\n+    }\n+};\n+\n+struct test_one_policy\n+{\n+    template <typename Policy, typename Iterator, typename Size>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Iterator expected_first, Iterator expected_last, Size n)\n+    {\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+\n+        // Try for_each\n+        std::for_each(expected_first, expected_last, Flip<T>(1));\n+        for_each(exec, first, last, Flip<T>(1));\n+        EXPECT_EQ_N(expected_first, first, n, \"wrong effect from for_each\");\n+\n+        // Try for_each_n\n+        std::for_each_n(__pstl::execution::seq, expected_first, n, Flip<T>(1));\n+        for_each_n(exec, first, n, Flip<T>(1));\n+        EXPECT_EQ_N(expected_first, first, n, \"wrong effect from for_each_n\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test()\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> inout(n, Gen<T>());\n+        Sequence<T> expected(n, Gen<T>());\n+        invoke_on_all_policies(test_one_policy(), inout.begin(), inout.end(), expected.begin(), expected.end(),\n+                               inout.size());\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            auto f = [](typename std::iterator_traits<Iterator>::reference x) { x = x + 1; };\n+\n+            for_each(exec, iter, iter, non_const(f));\n+            for_each_n(exec, iter, 0, non_const(f));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>();\n+    test<uint16_t>();\n+    test<float64_t>();\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "50a6120dfb29932a7444589f2183a8a614db3b9c", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/mismatch.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fmismatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fmismatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fmismatch.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,143 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- mismatch.pass.cpp -------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#include \"pstl/numeric\"\n+#include \"pstl/memory\"\n+\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_mismatch\n+{\n+    template <typename Policy, typename Iterator1, typename Iterator2>\n+    void\n+    operator()(Policy&& exec, Iterator1 first1, Iterator1 last1, Iterator2 first2)\n+    {\n+        using namespace std;\n+        typedef typename iterator_traits<Iterator1>::value_type T;\n+        {\n+            const auto expected = std::mismatch(first1, last1, first2, std::equal_to<T>());\n+            const auto res3 = mismatch(exec, first1, last1, first2, std::equal_to<T>());\n+            EXPECT_TRUE(expected == res3, \"wrong return result from mismatch\");\n+            const auto res4 = mismatch(exec, first1, last1, first2);\n+            EXPECT_TRUE(expected == res4, \"wrong return result from mismatch\");\n+        }\n+    }\n+    template <typename Policy, typename Iterator1, typename Iterator2>\n+    void\n+    operator()(Policy&& exec, Iterator1 first1, Iterator1 last1, Iterator2 first2, Iterator2 last2)\n+    {\n+        using namespace std;\n+        typedef typename iterator_traits<Iterator1>::value_type T;\n+        {\n+            const auto expected = mismatch(__pstl::execution::seq, first1, last1, first2, last2, std::equal_to<T>());\n+            const auto res1 = mismatch(exec, first1, last1, first2, last2, std::equal_to<T>());\n+            EXPECT_TRUE(expected == res1, \"wrong return result from mismatch\");\n+            const auto res2 = mismatch(exec, first1, last1, first2, last2);\n+            EXPECT_TRUE(expected == res2, \"wrong return result from mismatch\");\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_mismatch_by_type()\n+{\n+    using namespace std;\n+    for (size_t size = 0; size <= 100000; size = size <= 16 ? size + 1 : size_t(3.1415 * size))\n+    {\n+        const T val = T(-1);\n+        Sequence<T> in(size, [](size_t v) -> T { return T(v % 100); });\n+        {\n+            Sequence<T> in2(in);\n+            invoke_on_all_policies(test_mismatch(), in.begin(), in.end(), in2.begin(), in2.end());\n+            invoke_on_all_policies(test_mismatch(), in.begin(), in.end(), in2.begin());\n+\n+            const size_t min_size = 3;\n+            if (size > min_size)\n+            {\n+                const size_t idx_for_1 = size / min_size;\n+                in[idx_for_1] = val, in[idx_for_1 + 1] = val, in[idx_for_1 + 2] = val;\n+                invoke_on_all_policies(test_mismatch(), in.begin(), in.end(), in2.begin(), in2.end());\n+                invoke_on_all_policies(test_mismatch(), in.begin(), in.end(), in2.begin());\n+            }\n+\n+            const size_t idx_for_2 = 500;\n+            if (size >= idx_for_2 - 1)\n+            {\n+                in2[size / idx_for_2] = val;\n+                invoke_on_all_policies(test_mismatch(), in.cbegin(), in.cend(), in2.cbegin(), in2.cend());\n+                invoke_on_all_policies(test_mismatch(), in.cbegin(), in.cend(), in2.cbegin());\n+            }\n+        }\n+        {\n+            Sequence<T> in2(100, [](size_t v) -> T { return T(v); });\n+            invoke_on_all_policies(test_mismatch(), in2.begin(), in2.end(), in.begin(), in.end());\n+            //  We can't call std::mismatch with semantic below when size of second sequence less than size of first sequence\n+            if (in2.size() <= in.size())\n+                invoke_on_all_policies(test_mismatch(), in2.begin(), in2.end(), in.begin());\n+\n+            const size_t idx = 97;\n+            in2[idx] = val;\n+            in2[idx + 1] = val;\n+            invoke_on_all_policies(test_mismatch(), in.cbegin(), in.cend(), in2.cbegin(), in2.cend());\n+            if (in.size() <= in2.size())\n+                invoke_on_all_policies(test_mismatch(), in.cbegin(), in.cend(), in2.cbegin());\n+        }\n+        {\n+            Sequence<T> in2({});\n+            invoke_on_all_policies(test_mismatch(), in2.begin(), in2.end(), in.begin(), in.end());\n+\n+            invoke_on_all_policies(test_mismatch(), in.cbegin(), in.cend(), in2.cbegin(), in2.cend());\n+            if (in.size() == 0)\n+                invoke_on_all_policies(test_mismatch(), in.cbegin(), in.cend(), in2.cbegin());\n+        }\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename FirstIterator, typename SecondInterator>\n+    void\n+    operator()(Policy&& exec, FirstIterator first_iter, SecondInterator second_iter)\n+    {\n+        mismatch(exec, first_iter, first_iter, second_iter, second_iter, non_const(std::less<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test_mismatch_by_type<int32_t>();\n+    test_mismatch_by_type<float64_t>();\n+    test_mismatch_by_type<Wrapper<int32_t>>();\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "a06ac3d05e7651ba7dd3eb9f9ac91588ac02d74e", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/none_of.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fnone_of.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fnone_of.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fnone_of.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,108 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- none_of.pass.cpp --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+/*\n+  TODO: consider implementing the following tests for a better code coverage\n+  - correctness\n+  - bad input argument (if applicable)\n+  - data corruption around/of input and output\n+  - correctly work with nested parallelism\n+  - check that algorithm does not require anything more than is described in its requirements section\n+*/\n+\n+using namespace TestUtils;\n+\n+struct test_none_of\n+{\n+    template <typename ExecutionPolicy, typename Iterator, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator begin, Iterator end, Predicate pred, bool expected)\n+    {\n+\n+        auto actualr = std::none_of(exec, begin, end, pred);\n+        EXPECT_EQ(expected, actualr, \"result for none_of\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test(size_t bits)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+\n+        // Sequence of odd values\n+        Sequence<T> in(n, [n, bits](size_t k) { return T(2 * HashBits(n, bits - 1) ^ 1); });\n+\n+        // Even value, or false when T is bool.\n+        T spike(2 * HashBits(n, bits - 1));\n+\n+        invoke_on_all_policies(test_none_of(), in.begin(), in.end(), is_equal_to<T>(spike), true);\n+        invoke_on_all_policies(test_none_of(), in.cbegin(), in.cend(), is_equal_to<T>(spike), true);\n+        if (n > 0)\n+        {\n+            // Sprinkle in a hit\n+            in[2 * n / 3] = spike;\n+            invoke_on_all_policies(test_none_of(), in.begin(), in.end(), is_equal_to<T>(spike), false);\n+            invoke_on_all_policies(test_none_of(), in.cbegin(), in.cend(), is_equal_to<T>(spike), false);\n+\n+            // Sprinkle in a few more hits\n+            in[n / 3] = spike;\n+            in[n / 2] = spike;\n+            invoke_on_all_policies(test_none_of(), in.begin(), in.end(), is_equal_to<T>(spike), false);\n+            invoke_on_all_policies(test_none_of(), in.cbegin(), in.cend(), is_equal_to<T>(spike), false);\n+        }\n+    }\n+}\n+\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        auto is_even = [&](float64_t v) {\n+            uint32_t i = (uint32_t)v;\n+            return i % 2 == 0;\n+        };\n+        none_of(exec, iter, iter, non_const(is_even));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>(8 * sizeof(int32_t));\n+    test<uint16_t>(8 * sizeof(uint16_t));\n+    test<float64_t>(53);\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN\n+    test<bool>(1);\n+#endif\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "4e25442ca9a7760f4ebebed4b5d360a8957e9e56", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/nth_element.cc", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fnth_element.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fnth_element.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fnth_element.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,185 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- nth_element.pass.cpp ----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <algorithm>\n+#include <iostream>\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// User defined type with minimal requirements\n+template <typename T>\n+struct DataType\n+{\n+    explicit DataType(int32_t k) : my_val(k) {}\n+    DataType(DataType&& input)\n+    {\n+        my_val = std::move(input.my_val);\n+        input.my_val = T(0);\n+    }\n+    DataType&\n+    operator=(DataType&& input)\n+    {\n+        my_val = std::move(input.my_val);\n+        input.my_val = T(0);\n+        return *this;\n+    }\n+    T\n+    get_val() const\n+    {\n+        return my_val;\n+    }\n+\n+    friend std::ostream&\n+    operator<<(std::ostream& stream, const DataType<T>& input)\n+    {\n+        return stream << input.my_val;\n+    }\n+\n+  private:\n+    T my_val;\n+};\n+\n+template <typename T>\n+bool\n+is_equal(const DataType<T>& x, const DataType<T>& y)\n+{\n+    return x.get_val() == y.get_val();\n+}\n+\n+template <typename T>\n+bool\n+is_equal(const T& x, const T& y)\n+{\n+    return x == y;\n+}\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1, typename Size, typename Generator1, typename Generator2, typename Compare>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 first1, Iterator1 last1, Iterator1 first2,\n+               Iterator1 last2, Size n, Size m, Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+    }\n+    template <typename Iterator1, typename Size, typename Generator1, typename Generator2, typename Compare>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 first1, Iterator1 last1, Iterator1 first2,\n+               Iterator1 last2, Size n, Size m, Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+    }\n+#endif\n+\n+    // nth_element works only with random access iterators\n+    template <typename Policy, typename Iterator1, typename Size, typename Generator1, typename Generator2,\n+              typename Compare>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, Iterator1 first1, Iterator1 last1, Iterator1 first2, Iterator1 last2, Size n, Size m,\n+               Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+\n+        using T = typename std::iterator_traits<Iterator1>::value_type;\n+        const Iterator1 mid1 = std::next(first1, m);\n+        const Iterator1 mid2 = std::next(first2, m);\n+\n+        fill_data(first1, mid1, generator1);\n+        fill_data(mid1, last1, generator2);\n+        fill_data(first2, mid2, generator1);\n+        fill_data(mid2, last2, generator2);\n+        std::nth_element(first1, mid1, last1, comp);\n+        std::nth_element(exec, first2, mid2, last2, comp);\n+        if (m > 0 && m < n)\n+        {\n+            EXPECT_TRUE(is_equal(*mid1, *mid2), \"wrong result from nth_element with predicate\");\n+        }\n+        EXPECT_TRUE(std::find_first_of(first2, mid2, mid2, last2, [comp](T& x, T& y) { return comp(y, x); }) == mid2,\n+                    \"wrong effect from nth_element with predicate\");\n+    }\n+\n+    template <typename Policy, typename Iterator1, typename Size, typename Generator1, typename Generator2,\n+              typename Compare>\n+    typename std::enable_if<!is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, Iterator1 first1, Iterator1 last1, Iterator1 first2, Iterator1 last2, Size n, Size m,\n+               Generator1 generator1, Generator2 generator2, Compare comp)\n+    {\n+    }\n+};\n+\n+template <typename T, typename Generator1, typename Generator2, typename Compare>\n+void\n+test_by_type(Generator1 generator1, Generator2 generator2, Compare comp)\n+{\n+    using namespace std;\n+    size_t max_size = 10000;\n+    Sequence<T> in1(max_size, [](size_t v) { return T(v); });\n+    Sequence<T> exp(max_size, [](size_t v) { return T(v); });\n+    size_t m;\n+\n+    for (size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        m = 0;\n+        invoke_on_all_policies(test_one_policy(), exp.begin(), exp.begin() + n, in1.begin(), in1.begin() + n, n, m,\n+                               generator1, generator2, comp);\n+        m = n / 7;\n+        invoke_on_all_policies(test_one_policy(), exp.begin(), exp.begin() + n, in1.begin(), in1.begin() + n, n, m,\n+                               generator1, generator2, comp);\n+        m = 3 * n / 5;\n+        invoke_on_all_policies(test_one_policy(), exp.begin(), exp.begin() + n, in1.begin(), in1.begin() + n, n, m,\n+                               generator1, generator2, comp);\n+    }\n+    invoke_on_all_policies(test_one_policy(), exp.begin(), exp.begin() + max_size, in1.begin(), in1.begin() + max_size,\n+                           max_size, max_size, generator1, generator2, comp);\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        invoke_if(exec, [&]() { nth_element(exec, iter, iter, iter, non_const(std::less<T>())); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test_by_type<int32_t>([](int32_t i) { return 10 * i; }, [](int32_t i) { return i + 1; }, std::less<int32_t>());\n+    test_by_type<int32_t>([](int32_t) { return 0; }, [](int32_t) { return 0; }, std::less<int32_t>());\n+\n+    test_by_type<float64_t>([](int32_t i) { return -2 * i; }, [](int32_t i) { return -(2 * i + 1); },\n+                            [](const float64_t x, const float64_t y) { return x > y; });\n+\n+    test_by_type<DataType<float32_t>>(\n+        [](int32_t i) { return DataType<float32_t>(2 * i + 1); }, [](int32_t i) { return DataType<float32_t>(2 * i); },\n+        [](const DataType<float32_t>& x, const DataType<float32_t>& y) { return x.get_val() < y.get_val(); });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "7348c9911c11e4a3895cb3e8a43f77ff48acc669", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/reverse.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Freverse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Freverse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Freverse.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,112 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- reverse.pass.cpp --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iterator>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_18_VC141_TEST_SIMD_LAMBDA_RELEASE_BROKEN || __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||     \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1, typename Iterator2>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b,\n+               Iterator2 actual_e)\n+    {\n+    }\n+    template <typename Iterator1, typename Iterator2>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b,\n+               Iterator2 actual_e)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2>\n+    typename std::enable_if<!is_same_iterator_category<Iterator1, std::forward_iterator_tag>::value>::type\n+    operator()(ExecutionPolicy&& exec, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b, Iterator2 actual_e)\n+    {\n+        using namespace std;\n+\n+        copy(data_b, data_e, actual_b);\n+\n+        reverse(exec, actual_b, actual_e);\n+\n+        bool check = equal(data_b, data_e, reverse_iterator<Iterator2>(actual_e));\n+\n+        EXPECT_TRUE(check, \"wrong result of reverse\");\n+    }\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::forward_iterator_tag>::value>::type\n+    operator()(ExecutionPolicy&& exec, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b, Iterator2 actual_e)\n+    {\n+    }\n+};\n+\n+template <typename T>\n+void\n+test()\n+{\n+    const std::size_t max_len = 100000;\n+\n+    Sequence<T> actual(max_len);\n+\n+    Sequence<T> data(max_len, [](std::size_t i) { return T(i); });\n+\n+    for (std::size_t len = 0; len < max_len; len = len <= 16 ? len + 1 : std::size_t(3.1415 * len))\n+    {\n+        invoke_on_all_policies(test_one_policy(), data.begin(), data.begin() + len, actual.begin(),\n+                               actual.begin() + len);\n+    }\n+}\n+\n+template <typename T>\n+struct wrapper\n+{\n+    T t;\n+    wrapper() {}\n+    explicit wrapper(T t_) : t(t_) {}\n+    bool\n+    operator==(const wrapper<T>& a) const\n+    {\n+        return t == a.t;\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>();\n+    test<uint16_t>();\n+    test<float64_t>();\n+#if !__PSTL_ICC_17_TEST_MAC_RELEASE_32_BROKEN\n+    test<wrapper<float64_t>>();\n+#endif\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "10b5f7544e36ee2698b56a55d38ccff138de5575", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/reverse_copy.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Freverse_copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Freverse_copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Freverse_copy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,141 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- reverse_copy.pass.cpp ---------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iterator>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct wrapper\n+{\n+    T t;\n+    wrapper() {}\n+    explicit wrapper(T t_) : t(t_) {}\n+    wrapper&\n+    operator=(const T& t_)\n+    {\n+        t = t_;\n+        return *this;\n+    }\n+    bool\n+    operator==(const wrapper& t_) const\n+    {\n+        return t == t_.t;\n+    }\n+};\n+\n+template <typename T1, typename T2>\n+bool\n+eq(const wrapper<T1>& a, const wrapper<T2>& b)\n+{\n+    return a.t == b.t;\n+}\n+\n+template <typename T1, typename T2>\n+bool\n+eq(const T1& a, const T2& b)\n+{\n+    return a == b;\n+}\n+\n+// we need to save state here, because we need to test with different types of iterators\n+// due to the caller invoke_on_all_policies does forcing modification passed iterator type to cover additional usage cases.\n+template <typename Iterator>\n+struct test_one_policy\n+{\n+    Iterator data_b;\n+    Iterator data_e;\n+    test_one_policy(Iterator b, Iterator e) : data_b(b), data_e(e) {}\n+\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 actual_b, Iterator1 actual_e)\n+    {\n+    }\n+    template <typename Iterator1>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 actual_b, Iterator1 actual_e)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 actual_b, Iterator1 actual_e)\n+    {\n+        using namespace std;\n+        using T = typename iterator_traits<Iterator1>::value_type;\n+        using DifferenceType = typename iterator_traits<Iterator1>::difference_type;\n+\n+        fill(actual_b, actual_e, T(-123));\n+        Iterator1 actual_return = reverse_copy(exec, data_b, data_e, actual_b);\n+\n+        EXPECT_TRUE(actual_return == actual_e, \"wrong result of reverse_copy\");\n+\n+        const auto n = std::distance(data_b, data_e);\n+        Sequence<T> res(n);\n+        std::copy(std::reverse_iterator<Iterator>(data_e), std::reverse_iterator<Iterator>(data_b), res.begin());\n+\n+        EXPECT_EQ_N(res.begin(), actual_b, n, \"wrong effect of reverse_copy\");\n+    }\n+};\n+\n+template <typename T1, typename T2>\n+void\n+test()\n+{\n+    typedef typename Sequence<T1>::iterator iterator_type;\n+    typedef typename Sequence<T1>::const_bidirectional_iterator cbi_iterator_type;\n+\n+    const std::size_t max_len = 100000;\n+\n+    Sequence<T2> actual(max_len);\n+\n+    Sequence<T1> data(max_len, [](std::size_t i) { return T1(i); });\n+\n+    for (std::size_t len = 0; len < max_len; len = len <= 16 ? len + 1 : std::size_t(3.1415 * len))\n+    {\n+        invoke_on_all_policies(test_one_policy<iterator_type>(data.begin(), data.begin() + len), actual.begin(),\n+                               actual.begin() + len);\n+        invoke_on_all_policies(test_one_policy<cbi_iterator_type>(data.cbibegin(), std::next(data.cbibegin(), len)),\n+                               actual.begin(), actual.begin() + len);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    // clang-3.8 fails to correctly auto vectorize the loop in some cases of different types of container's elements,\n+    // for example: int32_t and int8_t. This issue isn't detected for clang-3.9 and newer versions.\n+    test<int16_t, int8_t>();\n+    test<uint16_t, float32_t>();\n+    test<float64_t, int64_t>();\n+    test<wrapper<float64_t>, wrapper<float64_t>>();\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "b096833ce5a0d05bb1246f1bf29ccc247249074f", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_nonmodifying/search_n.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fsearch_n.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fsearch_n.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_nonmodifying%2Fsearch_n.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,116 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- search_n.pass.cpp -------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator, typename Size, typename T, typename Predicate>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, Iterator b, Iterator e, Size count, const T& value, Predicate pred)\n+    {\n+    }\n+    template <typename Iterator, typename Size, typename T, typename Predicate>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator b, Iterator e, Size count, const T& value,\n+               Predicate pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator, typename Size, typename T, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator b, Iterator e, Size count, const T& value, Predicate pred)\n+    {\n+        using namespace std;\n+        auto expected = search_n(b, e, count, value, pred);\n+        auto actual = search_n(exec, b, e, count, value);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from search_n\");\n+\n+        actual = search_n(exec, b, e, count, value, pred);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from search_n with a predicate\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test()\n+{\n+\n+    const std::size_t max_n1 = 100000;\n+    const T value = T(1);\n+    for (std::size_t n1 = 0; n1 <= max_n1; n1 = n1 <= 16 ? n1 + 1 : size_t(3.1415 * n1))\n+    {\n+        std::size_t sub_n[] = {0, 1, 3, n1, (n1 * 10) / 8};\n+        std::size_t res[] = {0, 1, n1 / 2, n1};\n+        for (auto n2 : sub_n)\n+        {\n+            // Some of standard libraries return \"first\" in this case. We return \"last\" according to the standard\n+            if (n2 == 0)\n+            {\n+                continue;\n+            }\n+            for (auto r : res)\n+            {\n+                Sequence<T> in(n1, [n1](std::size_t k) { return T(0); });\n+                std::size_t i = r, isub = 0;\n+                for (; i < n1 & isub < n2; ++i, ++isub)\n+                    in[i] = value;\n+\n+                invoke_on_all_policies(test_one_policy(), in.begin(), in.begin() + n1, n2, value, std::equal_to<T>());\n+                invoke_on_all_policies(test_one_policy(), in.cbegin(), in.cbegin() + n1, n2, value, std::equal_to<T>());\n+            }\n+        }\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        invoke_if(exec, [&]() { search_n(exec, iter, iter, 0, T(0), non_const(std::equal_to<T>())); });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<int32_t>();\n+    test<uint16_t>();\n+    test<float64_t>();\n+#if !__PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN\n+    test<bool>();\n+#endif\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "2e7dc8f82eaefa6139d2cf7bbaeb8bcc4a7a93fd", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/includes.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fincludes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fincludes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fincludes.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,115 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- includes.pass.cpp -------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include <cmath>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct Num\n+{\n+    T val;\n+    explicit Num(const T& v) : val(v) {}\n+\n+    //for \"includes\" checks\n+    template <typename T1>\n+    bool\n+    operator<(const Num<T1>& v1) const\n+    {\n+        return val < v1.val;\n+    }\n+\n+    //The types Type1 and Type2 must be such that an object of type InputIt can be dereferenced and then implicitly converted to both of them\n+    template <typename T1>\n+    operator Num<T1>() const\n+    {\n+        return Num<T1>((T1)val);\n+    }\n+};\n+\n+struct test_one_policy\n+{\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename Compare>\n+    typename std::enable_if<!TestUtils::isReverse<InputIterator1>::value, void>::type\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               Compare comp)\n+    {\n+\n+        auto expect_res = std::includes(first1, last1, first2, last2, comp);\n+        auto res = std::includes(exec, first1, last1, first2, last2, comp);\n+\n+        EXPECT_TRUE(expect_res == res, \"wrong result for includes\");\n+    }\n+\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename Compare>\n+    typename std::enable_if<TestUtils::isReverse<InputIterator1>::value, void>::type\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               Compare comp)\n+    {\n+    }\n+};\n+\n+template <typename T1, typename T2, typename Compare>\n+void\n+test_includes(Compare compare)\n+{\n+\n+    const std::size_t n_max = 1000000;\n+\n+    // The rand()%(2*n+1) encourages generation of some duplicates.\n+    std::srand(42);\n+\n+    for (std::size_t n = 0; n < n_max; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        for (std::size_t m = 0; m < n_max; m = m <= 16 ? m + 1 : size_t(2.71828 * m))\n+        {\n+            //prepare the input ranges\n+            Sequence<T1> in1(n, [](std::size_t k) { return rand() % (2 * k + 1); });\n+            Sequence<T2> in2(m, [](std::size_t k) { return rand() % (k + 1); });\n+\n+            std::sort(in1.begin(), in1.end(), compare);\n+            std::sort(in2.begin(), in2.end(), compare);\n+\n+            invoke_on_all_policies(test_one_policy(), in1.begin(), in1.end(), in2.cbegin(), in2.cend(), compare);\n+\n+            //test w/ non constant predicate\n+            if (n < 5 && m < 5)\n+                invoke_on_all_policies(test_one_policy(), in1.begin(), in1.end(), in2.cbegin(), in2.cend(),\n+                                       non_const(compare));\n+        }\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+\n+    test_includes<float64_t, float64_t>(__pstl::__internal::__pstl_less());\n+    test_includes<Num<int64_t>, Num<int32_t>>([](const Num<int64_t>& x, const Num<int32_t>& y) { return x < y; });\n+    std::cout << done() << std::endl;\n+\n+    return 0;\n+}"}, {"sha": "14d4118f73d66a95a278b2230f536157c552d065", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/is_heap.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fis_heap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fis_heap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fis_heap.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,152 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- is_heap.pass.cpp --------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for is_heap, is_heap_until\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+#include <iostream>\n+\n+using namespace TestUtils;\n+\n+struct WithCmpOp\n+{\n+    int32_t _first;\n+    int32_t _second;\n+    WithCmpOp() : _first(0), _second(0){};\n+    explicit WithCmpOp(int32_t x) : _first(x), _second(x){};\n+    bool\n+    operator<(const WithCmpOp& rhs) const\n+    {\n+        return this->_first < rhs._first;\n+    }\n+};\n+\n+struct test_is_heap\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator, typename Predicate>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::unsequenced_policy, Iterator first, Iterator last, Predicate pred)\n+    {\n+    }\n+    template <typename Iterator, typename Predicate>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator first, Iterator last, Predicate pred)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename Iterator, typename Predicate>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, Iterator first, Iterator last, Predicate pred)\n+    {\n+        using namespace std;\n+        // is_heap\n+        {\n+            bool expected = is_heap(first, last);\n+            bool actual = is_heap(exec, first, last);\n+            EXPECT_TRUE(expected == actual, \"wrong return value from is_heap\");\n+        }\n+        // is_heap with predicate\n+        {\n+            bool expected = is_heap(first, last, pred);\n+            bool actual = is_heap(exec, first, last, pred);\n+            EXPECT_TRUE(expected == actual, \"wrong return value from is_heap with predicate\");\n+        }\n+        // is_heap_until\n+        {\n+            Iterator expected = is_heap_until(first, last);\n+            Iterator actual = is_heap_until(exec, first, last);\n+            EXPECT_TRUE(expected == actual, \"wrong return value from is_heap_until\");\n+        }\n+        // is_heap_until with predicate\n+        {\n+            const Iterator expected = is_heap_until(first, last, pred);\n+            const auto y = std::distance(first, expected);\n+            const Iterator actual = is_heap_until(exec, first, last, pred);\n+            const auto x = std::distance(first, actual);\n+            EXPECT_TRUE(expected == actual, \"wrong return value from is_heap_until with predicate\");\n+        }\n+    }\n+\n+    // is_heap, is_heap_until works only with random access iterators\n+    template <typename Policy, typename Iterator, typename Predicate>\n+    typename std::enable_if<!is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, Iterator first, Iterator last, Predicate pred)\n+    {\n+    }\n+};\n+\n+template <typename T, typename Comp>\n+void\n+test_is_heap_by_type(Comp comp)\n+{\n+    using namespace std;\n+\n+    const size_t max_size = 100000;\n+    for (size_t n = 0; n <= max_size; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, [](size_t v) -> T { return T(v); });\n+\n+        invoke_on_all_policies(test_is_heap(), in.begin(), in.end(), comp);\n+\n+        std::make_heap(in.begin(), in.begin() + n / 4, comp);\n+        invoke_on_all_policies(test_is_heap(), in.cbegin(), in.cend(), comp);\n+\n+        std::make_heap(in.begin(), in.begin() + n / 3, comp);\n+        invoke_on_all_policies(test_is_heap(), in.begin(), in.end(), comp);\n+\n+        std::make_heap(in.begin(), in.end(), comp);\n+        invoke_on_all_policies(test_is_heap(), in.cbegin(), in.cend(), comp);\n+    }\n+\n+    Sequence<T> in(max_size / 10, [](size_t v) -> T { return T(1); });\n+    invoke_on_all_policies(test_is_heap(), in.begin(), in.end(), comp);\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            is_heap(exec, iter, iter, non_const(std::less<T>()));\n+            is_heap_until(exec, iter, iter, non_const(std::less<T>()));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test_is_heap_by_type<float32_t>(std::greater<float32_t>());\n+    test_is_heap_by_type<WithCmpOp>(std::less<WithCmpOp>());\n+    test_is_heap_by_type<uint64_t>([](uint64_t x, uint64_t y) { return x % 100 < y % 100; });\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "11fa230cd3fa772a7d2f0a3cdecd035c2e8c833c", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/is_sorted.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fis_sorted.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fis_sorted.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fis_sorted.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,108 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- is_sorted.pass.cpp ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_is_sorted\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, bool exam)\n+    {\n+        using namespace std;\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+\n+        //try random-access iterator\n+        bool res = is_sorted(exec, first, last);\n+        EXPECT_TRUE(exam == res, \"is_sorted wrong result for random-access iterator\");\n+        auto iexam = is_sorted_until(first, last);\n+        auto ires = is_sorted_until(exec, first, last);\n+        EXPECT_TRUE(iexam == ires, \"is_sorted_until wrong result for random-access iterator\");\n+\n+        //try random-access iterator with a predicate\n+        res = is_sorted(exec, first, last, std::less<T>());\n+        EXPECT_TRUE(exam == res, \"is_sorted wrong result for random-access iterator\");\n+        iexam = is_sorted_until(first, last, std::less<T>());\n+        ires = is_sorted_until(exec, first, last, std::less<T>());\n+        EXPECT_TRUE(iexam == ires, \"is_sorted_until wrong result for random-access iterator\");\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_is_sorted_by_type()\n+{\n+\n+    Sequence<T> in(99999, [](size_t v) -> T { return T(v); }); //fill 0..n\n+\n+    invoke_on_all_policies(test_is_sorted(), in.begin(), in.end(), std::is_sorted(in.begin(), in.end()));\n+    invoke_on_all_policies(test_is_sorted(), in.cbegin(), in.cend(), std::is_sorted(in.begin(), in.end()));\n+\n+    in[in.size() / 2] = -1;\n+    invoke_on_all_policies(test_is_sorted(), in.begin(), in.end(), std::is_sorted(in.begin(), in.end()));\n+    invoke_on_all_policies(test_is_sorted(), in.cbegin(), in.cend(), std::is_sorted(in.begin(), in.end()));\n+\n+    in[1] = -1;\n+    invoke_on_all_policies(test_is_sorted(), in.begin(), in.end(), std::is_sorted(in.begin(), in.end()));\n+    invoke_on_all_policies(test_is_sorted(), in.cbegin(), in.cend(), std::is_sorted(in.begin(), in.end()));\n+\n+    //an empty container\n+    Sequence<T> in0(0);\n+    invoke_on_all_policies(test_is_sorted(), in0.begin(), in0.end(), std::is_sorted(in0.begin(), in0.end()));\n+    invoke_on_all_policies(test_is_sorted(), in0.cbegin(), in0.cend(), std::is_sorted(in0.begin(), in0.end()));\n+\n+    //non-descending order\n+    Sequence<T> in1(9, [](size_t v) -> T { return T(0); });\n+    invoke_on_all_policies(test_is_sorted(), in1.begin(), in1.end(), std::is_sorted(in1.begin(), in1.end()));\n+    invoke_on_all_policies(test_is_sorted(), in1.cbegin(), in1.cend(), std::is_sorted(in1.begin(), in1.end()));\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        is_sorted(exec, iter, iter, std::less<T>());\n+        is_sorted_until(exec, iter, iter, std::less<T>());\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test_is_sorted_by_type<int32_t>();\n+    test_is_sorted_by_type<float64_t>();\n+\n+    test_is_sorted_by_type<Wrapper<int32_t>>();\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "7cc6a1c1bc003c89c50fc3d846256ce9104730e9", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/lexicographical_compare.cc", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Flexicographical_compare.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Flexicographical_compare.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Flexicographical_compare.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,183 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- lexicographical_compare.pass.cpp ----------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iostream>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_one_policy\n+{\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2, typename Predicate>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 begin1, Iterator1 end1, Iterator2 begin2, Iterator2 end2,\n+               Predicate pred)\n+    {\n+        const bool expected = std::lexicographical_compare(begin1, end1, begin2, end2, pred);\n+        const bool actual = std::lexicographical_compare(exec, begin1, end1, begin2, end2, pred);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from lexicographical compare with predicate\");\n+    }\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 begin1, Iterator1 end1, Iterator2 begin2, Iterator2 end2)\n+    {\n+        const bool expected = std::lexicographical_compare(begin1, end1, begin2, end2);\n+        const bool actual = std::lexicographical_compare(exec, begin1, end1, begin2, end2);\n+        EXPECT_TRUE(actual == expected, \"wrong return result from lexicographical compare without predicate\");\n+    }\n+};\n+\n+template <typename T1, typename T2, typename Predicate>\n+void\n+test(Predicate pred)\n+{\n+\n+    const std::size_t max_n = 1000000;\n+    Sequence<T1> in1(max_n, [](std::size_t k) { return T1(k); });\n+    Sequence<T2> in2(2 * max_n, [](std::size_t k) { return T2(k); });\n+\n+    std::size_t n2;\n+\n+    // Test case: Call algorithm's version without predicate.\n+    invoke_on_all_policies(test_one_policy(), in1.cbegin(), in1.cbegin() + max_n, in2.cbegin() + 3 * max_n / 10,\n+                           in2.cbegin() + 5 * max_n / 10);\n+\n+    // Test case: If one range is a prefix of another, the shorter range is lexicographically less than the other.\n+    std::size_t max_n2 = max_n / 10;\n+    invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + max_n, in2.cbegin(), in2.cbegin() + max_n2,\n+                           pred);\n+    invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + max_n, in2.begin() + max_n2,\n+                           in2.begin() + 3 * max_n2, pred);\n+\n+    // Test case: If one range is a prefix of another, the shorter range is lexicographically less than the other.\n+    max_n2 = 2 * max_n;\n+    invoke_on_all_policies(test_one_policy(), in1.cbegin(), in1.cbegin() + max_n, in2.begin(), in2.begin() + max_n2,\n+                           pred);\n+\n+    for (std::size_t n1 = 0; n1 <= max_n; n1 = n1 <= 16 ? n1 + 1 : std::size_t(3.1415 * n1))\n+    {\n+        // Test case: If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically equal.\n+        n2 = n1;\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.begin(), in2.begin() + n2, pred);\n+\n+        n2 = n1;\n+        // Test case: two ranges have different elements and are of the same length (second sequence less than first)\n+        std::size_t ind = n1 / 2;\n+        in2[ind] = T2(-1);\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.begin(), in2.begin() + n2, pred);\n+        in2[ind] = T2(ind);\n+\n+        // Test case: two ranges have different elements and are of the same length (first sequence less than second)\n+        ind = n1 / 5;\n+        in1[ind] = T1(-1);\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.cbegin(), in2.cbegin() + n2, pred);\n+        in1[ind] = T1(ind);\n+    }\n+}\n+\n+template <typename Predicate>\n+void\n+test_string(Predicate pred)\n+{\n+\n+    const std::size_t max_n = 1000000;\n+    std::string in1 = \"\";\n+    std::string in2 = \"\";\n+    for (std::size_t n1 = 0; n1 <= max_n; ++n1)\n+    {\n+        in1 += n1;\n+    }\n+\n+    for (std::size_t n1 = 0; n1 <= 2 * max_n; ++n1)\n+    {\n+        in2 += n1;\n+    }\n+\n+    std::size_t n2;\n+\n+    for (std::size_t n1 = 0; n1 < in1.size(); n1 = n1 <= 16 ? n1 + 1 : std::size_t(3.1415 * n1))\n+    {\n+        // Test case: If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically equal.\n+        n2 = n1;\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.begin(), in2.begin() + n2, pred);\n+\n+        n2 = n1;\n+        // Test case: two ranges have different elements and are of the same length (second sequence less than first)\n+        in2[n1 / 2] = 'a';\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.begin(), in2.begin() + n2, pred);\n+\n+        // Test case: two ranges have different elements and are of the same length (first sequence less than second)\n+        in1[n1 / 5] = 'a';\n+        invoke_on_all_policies(test_one_policy(), in1.begin(), in1.begin() + n1, in2.cbegin(), in2.cbegin() + n2, pred);\n+    }\n+    invoke_on_all_policies(test_one_policy(), in1.cbegin(), in1.cbegin() + max_n, in2.cbegin() + 3 * max_n / 10,\n+                           in2.cbegin() + 5 * max_n / 10);\n+}\n+\n+template <typename T>\n+struct LocalWrapper\n+{\n+    explicit LocalWrapper(std::size_t k) : my_val(k) {}\n+    bool\n+    operator<(const LocalWrapper<T>& w) const\n+    {\n+        return my_val < w.my_val;\n+    }\n+\n+  private:\n+    T my_val;\n+};\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename FirstIterator, typename SecondInterator>\n+    void\n+    operator()(Policy&& exec, FirstIterator first_iter, SecondInterator second_iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            lexicographical_compare(exec, first_iter, first_iter, second_iter, second_iter, non_const(std::less<T>()));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test<uint16_t, float64_t>(std::less<float64_t>());\n+    test<float32_t, int32_t>(std::greater<float32_t>());\n+#if !__PSTL_ICC_18_TEST_EARLY_EXIT_AVX_RELEASE_BROKEN\n+    test<float64_t, int32_t>([](const float64_t x, const int32_t y) { return x * x < y * y; });\n+#endif\n+    test<LocalWrapper<int32_t>, LocalWrapper<int32_t>>(\n+        [](const LocalWrapper<int32_t>& x, const LocalWrapper<int32_t>& y) { return x < y; });\n+    test_string([](const char x, const char y) { return x < y; });\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "e194a1da6fd3f0ec4141e2f37c10628300d79530", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/minmax_element.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fminmax_element.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fminmax_element.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fminmax_element.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,202 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- minmax_element.pass.cpp -------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+#include <set>\n+#include <cassert>\n+#include <cmath>\n+\n+using namespace TestUtils;\n+\n+struct check_minelement\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator begin, Iterator end)\n+    {\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+        const Iterator expect = std::min_element(begin, end);\n+        const Iterator result = std::min_element(exec, begin, end);\n+        const Iterator result_pred = std::min_element(exec, begin, end, std::less<T>());\n+        EXPECT_TRUE(expect == result, \"wrong return result from min_element\");\n+        EXPECT_TRUE(expect == result_pred, \"wrong return result from min_element\");\n+    }\n+};\n+\n+struct check_maxelement\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator begin, Iterator end)\n+    {\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+        const Iterator expect = std::max_element(begin, end);\n+        const Iterator result = std::max_element(exec, begin, end);\n+        const Iterator result_pred = std::max_element(exec, begin, end, std::less<T>());\n+        EXPECT_TRUE(expect == result, \"wrong return result from max_element\");\n+        EXPECT_TRUE(expect == result_pred, \"wrong return result from max_element\");\n+    }\n+};\n+\n+struct check_minmaxelement\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator begin, Iterator end)\n+    {\n+        typedef typename std::iterator_traits<Iterator>::value_type T;\n+        const std::pair<Iterator, Iterator> expect = std::minmax_element(begin, end);\n+        const std::pair<Iterator, Iterator> got = std::minmax_element(exec, begin, end);\n+        const std::pair<Iterator, Iterator> got_pred = std::minmax_element(exec, begin, end, std::less<T>());\n+        EXPECT_TRUE(expect.first == got.first, \"wrong return result from minmax_element (min part)\");\n+        EXPECT_TRUE(expect.second == got.second, \"wrong return result from minmax_element (max part)\");\n+        EXPECT_TRUE(expect == got_pred, \"wrong return result from minmax_element\");\n+    }\n+};\n+\n+template <typename T>\n+struct sequence_wrapper\n+{\n+    TestUtils::Sequence<T> seq;\n+    const T min_value;\n+    const T max_value;\n+    static const std::size_t bits = 30; // We assume that T can handle signed 2^bits+1 value\n+\n+    // TestUtils::HashBits returns value between 0 and (1<<bits)-1,\n+    // therefore we could threat 1<<bits as maximum and -(1<<bits) as a minimum\n+    sequence_wrapper(std::size_t n) : seq(n), min_value(-(1 << bits)), max_value(1 << bits) {}\n+\n+    void\n+    pattern_fill()\n+    {\n+        seq.fill([](std::size_t i) -> T { return T(TestUtils::HashBits(i, bits)); });\n+    }\n+\n+    // sets first one at position `at` and bunch of them farther\n+    void\n+    set_desired_value(std::size_t at, T value)\n+    {\n+        if (seq.size() == 0)\n+            return;\n+        seq[at] = value;\n+\n+        //Producing serveral red herrings\n+        for (std::size_t i = at + 1; i < seq.size(); i += 1 + TestUtils::HashBits(i, 5))\n+            seq[i] = value;\n+    }\n+};\n+\n+template <typename T>\n+void\n+test_by_type(std::size_t n)\n+{\n+    sequence_wrapper<T> wseq(n);\n+\n+    // to avoid overtesing we use std::set to leave only unique indexes\n+    std::set<std::size_t> targets{0};\n+    if (n > 1)\n+    {\n+        targets.insert(1);\n+        targets.insert(2.718282 * n / 3);\n+        targets.insert(n / 2);\n+        targets.insert(n / 7.389056);\n+        targets.insert(n - 1); // last\n+    }\n+\n+    for (std::set<std::size_t>::iterator it = targets.begin(); it != targets.end(); ++it)\n+    {\n+        wseq.pattern_fill();\n+        wseq.set_desired_value(*it, wseq.min_value);\n+        TestUtils::invoke_on_all_policies(check_minelement(), wseq.seq.cbegin(), wseq.seq.cend());\n+        TestUtils::invoke_on_all_policies(check_minelement(), wseq.seq.begin(), wseq.seq.end());\n+\n+        wseq.set_desired_value(*it, wseq.max_value);\n+        TestUtils::invoke_on_all_policies(check_maxelement(), wseq.seq.cbegin(), wseq.seq.cend());\n+        TestUtils::invoke_on_all_policies(check_maxelement(), wseq.seq.begin(), wseq.seq.end());\n+\n+        if (targets.size() > 1)\n+        {\n+            for (std::set<std::size_t>::reverse_iterator rit = targets.rbegin(); rit != targets.rend(); ++rit)\n+            {\n+                if (*rit == *it) // we requires at least 2 unique indexes in targets\n+                    break;\n+                wseq.pattern_fill();\n+                wseq.set_desired_value(*it, wseq.min_value);  // setting minimum element\n+                wseq.set_desired_value(*rit, wseq.max_value); // setting maximum element\n+                TestUtils::invoke_on_all_policies(check_minmaxelement(), wseq.seq.cbegin(), wseq.seq.cend());\n+                TestUtils::invoke_on_all_policies(check_minmaxelement(), wseq.seq.begin(), wseq.seq.end());\n+            }\n+        }\n+        else\n+        { // we must check this corner case; it can not be tested in loop above\n+            TestUtils::invoke_on_all_policies(check_minmaxelement(), wseq.seq.cbegin(), wseq.seq.cend());\n+            TestUtils::invoke_on_all_policies(check_minmaxelement(), wseq.seq.begin(), wseq.seq.end());\n+        }\n+    }\n+}\n+\n+// should provide minimal requirements only\n+struct OnlyLessCompare\n+{\n+    int32_t val;\n+    OnlyLessCompare() : val(0) {}\n+    OnlyLessCompare(int32_t val_) : val(val_) {}\n+    bool\n+    operator<(const OnlyLessCompare& other) const\n+    {\n+        return val < other.val;\n+    }\n+};\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        max_element(exec, iter, iter, non_const(std::less<T>()));\n+        min_element(exec, iter, iter, non_const(std::less<T>()));\n+        minmax_element(exec, iter, iter, non_const(std::less<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    using TestUtils::float64_t;\n+    const std::size_t N = 100000;\n+\n+    for (std::size_t n = 0; n < N; n = n < 16 ? n + 1 : size_t(3.14159 * n))\n+    {\n+        test_by_type<float64_t>(n);\n+        test_by_type<OnlyLessCompare>(n);\n+    }\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << TestUtils::done() << std::endl;\n+    return 0;\n+}"}, {"sha": "674f5a365b009cbfc844e6a55f3cd4840adbba00", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/partial_sort.cc", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fpartial_sort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fpartial_sort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fpartial_sort.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,160 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- partial_sort.pass.cpp ---------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+\n+#include <cmath>\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+static std::atomic<int32_t> count_val;\n+static std::atomic<int32_t> count_comp;\n+\n+template <typename T>\n+struct Num\n+{\n+    T val;\n+\n+    Num() { ++count_val; }\n+    Num(T v) : val(v) { ++count_val; }\n+    Num(const Num<T>& v) : val(v.val) { ++count_val; }\n+    Num(Num<T>&& v) : val(v.val) { ++count_val; }\n+    ~Num() { --count_val; }\n+    Num<T>&\n+    operator=(const Num<T>& v)\n+    {\n+        val = v.val;\n+        return *this;\n+    }\n+    operator T() const { return val; }\n+    bool\n+    operator<(const Num<T>& v) const\n+    {\n+        ++count_comp;\n+        return val < v.val;\n+    }\n+};\n+\n+struct test_brick_partial_sort\n+{\n+    template <typename Policy, typename InputIterator, typename Compare>\n+    typename std::enable_if<is_same_iterator_category<InputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, InputIterator exp_first, InputIterator exp_last,\n+               Compare compare)\n+    {\n+\n+        typedef typename std::iterator_traits<InputIterator>::value_type T;\n+\n+        // The rand()%(2*n+1) encourages generation of some duplicates.\n+        std::srand(42);\n+        const std::size_t n = last - first;\n+        for (std::size_t k = 0; k < n; ++k)\n+        {\n+            first[k] = T(rand() % (2 * n + 1));\n+        }\n+        std::copy(first, last, exp_first);\n+\n+        for (std::size_t p = 0; p < n; p = p <= 16 ? p + 1 : std::size_t(31.415 * p))\n+        {\n+            auto m1 = first + p;\n+            auto m2 = exp_first + p;\n+\n+            std::partial_sort(exp_first, m2, exp_last, compare);\n+            count_comp = 0;\n+            std::partial_sort(exec, first, m1, last, compare);\n+            EXPECT_EQ_N(exp_first, first, p, \"wrong effect from partial_sort\");\n+\n+            //checking upper bound number of comparisons; O(p*(last-first)log(middle-first)); where p - number of threads;\n+            if (m1 - first > 1)\n+            {\n+                auto complex = std::ceil(n * std::log(float32_t(m1 - first)));\n+#if __PSTL_USE_PAR_POLICIES\n+                auto p = tbb::this_task_arena::max_concurrency();\n+#else\n+                auto p = 1;\n+#endif\n+\n+#ifdef _DEBUG\n+                if (count_comp > complex * p)\n+                {\n+                    std::cout << \"complexity exceeded\" << std::endl;\n+                }\n+#endif\n+            }\n+        }\n+    }\n+\n+    template <typename Policy, typename InputIterator, typename Compare>\n+    typename std::enable_if<!is_same_iterator_category<InputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, InputIterator exp_first, InputIterator exp_last,\n+               Compare compare)\n+    {\n+    }\n+};\n+\n+template <typename T, typename Compare>\n+void\n+test_partial_sort(Compare compare)\n+{\n+\n+    const std::size_t n_max = 100000;\n+    Sequence<T> in(n_max);\n+    Sequence<T> exp(n_max);\n+    for (std::size_t n = 0; n < n_max; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        invoke_on_all_policies(test_brick_partial_sort(), in.begin(), in.begin() + n, exp.begin(), exp.begin() + n,\n+                               compare);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        partial_sort(exec, iter, iter, iter, non_const(std::less<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    count_val = 0;\n+\n+    test_partial_sort<Num<float32_t>>([](Num<float32_t> x, Num<float32_t> y) { return x < y; });\n+\n+    EXPECT_TRUE(count_val == 0, \"cleanup error\");\n+\n+    test_partial_sort<int32_t>(\n+        [](int32_t x, int32_t y) { return x > y; }); // Reversed so accidental use of < will be detected.\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "431c8594a42193b2c57c1f9aeb048ce0d3674e56", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/partial_sort_copy.cc", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fpartial_sort_copy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fpartial_sort_copy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fpartial_sort_copy.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,199 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- partial_sort_copy.pass.cpp ----------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Tests for partial_sort_copy\n+\n+#include <cmath>\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct Num\n+{\n+    T val;\n+\n+    Num() : val(0) {}\n+    Num(T v) : val(v) {}\n+    Num(const Num<T>& v) : val(v.val) {}\n+    Num(Num<T>&& v) : val(v.val) {}\n+    Num<T>&\n+    operator=(const Num<T>& v)\n+    {\n+        val = v.val;\n+        return *this;\n+    }\n+    operator T() const { return val; }\n+    bool\n+    operator<(const Num<T>& v) const\n+    {\n+        return val < v.val;\n+    }\n+};\n+\n+template <typename RandomAccessIterator>\n+struct test_one_policy\n+{\n+    RandomAccessIterator d_first;\n+    RandomAccessIterator d_last;\n+    RandomAccessIterator exp_first;\n+    RandomAccessIterator exp_last;\n+    // This ctor is needed because output shouldn't be transformed to any iterator type (only random access iterators are allowed)\n+    test_one_policy(RandomAccessIterator b1, RandomAccessIterator e1, RandomAccessIterator b2, RandomAccessIterator e2)\n+        : d_first(b1), d_last(e1), exp_first(b2), exp_last(e2)\n+    {\n+    }\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename InputIterator, typename Size, typename T, typename Compare>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, Size n1, Size n2,\n+               const T& trash, Compare compare)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename Size, typename T, typename Compare>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last, Size n1, Size n2,\n+               const T& trash, Compare compare)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename Size, typename T>\n+    void\n+    operator()(pstl::execution::unsequenced_policy, InputIterator first, InputIterator last, Size n1, Size n2,\n+               const T& trash)\n+    {\n+    }\n+\n+    template <typename InputIterator, typename Size, typename T>\n+    void\n+    operator()(pstl::execution::parallel_unsequenced_policy, InputIterator first, InputIterator last, Size n1, Size n2,\n+               const T& trash)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename InputIterator, typename Size, typename T, typename Compare>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, Size n1, Size n2, const T& trash,\n+               Compare compare)\n+    {\n+        prepare_data(first, last, n1, trash);\n+        RandomAccessIterator exp = std::partial_sort_copy(first, last, exp_first, exp_last, compare);\n+        RandomAccessIterator res = std::partial_sort_copy(exec, first, last, d_first, d_last, compare);\n+\n+        EXPECT_TRUE((exp - exp_first) == (res - d_first), \"wrong result from partial_sort_copy with predicate\");\n+        EXPECT_EQ_N(exp_first, d_first, n2, \"wrong effect from partial_sort_copy with predicate\");\n+    }\n+\n+    template <typename Policy, typename InputIterator, typename Size, typename T>\n+    void\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, Size n1, Size n2, const T& trash)\n+    {\n+        prepare_data(first, last, n1, trash);\n+        RandomAccessIterator exp = std::partial_sort_copy(first, last, exp_first, exp_last);\n+        RandomAccessIterator res = std::partial_sort_copy(exec, first, last, d_first, d_last);\n+\n+        EXPECT_TRUE((exp - exp_first) == (res - d_first), \"wrong result from partial_sort_copy without predicate\");\n+        EXPECT_EQ_N(exp_first, d_first, n2, \"wrong effect from partial_sort_copy without predicate\");\n+    }\n+\n+  private:\n+    template <typename InputIterator, typename Size, typename T>\n+    void\n+    prepare_data(InputIterator first, InputIterator last, Size n1, const T& trash)\n+    {\n+        // The rand()%(2*n+1) encourages generation of some duplicates.\n+        std::srand(42);\n+        std::generate(first, last, [n1]() { return T(rand() % (2 * n1 + 1)); });\n+\n+        std::fill(exp_first, exp_last, trash);\n+        std::fill(d_first, d_last, trash);\n+    }\n+};\n+\n+template <typename T, typename Compare>\n+void\n+test_partial_sort_copy(Compare compare)\n+{\n+\n+    typedef typename Sequence<T>::iterator iterator_type;\n+    const std::size_t n_max = 100000;\n+    Sequence<T> in(n_max);\n+    Sequence<T> out(2 * n_max);\n+    Sequence<T> exp(2 * n_max);\n+    std::size_t n1 = 0;\n+    std::size_t n2;\n+    T trash = T(-666);\n+    for (; n1 < n_max; n1 = n1 <= 16 ? n1 + 1 : size_t(3.1415 * n1))\n+    {\n+        // If both sequences are equal\n+        n2 = n1;\n+        invoke_on_all_policies(\n+            test_one_policy<iterator_type>(out.begin(), out.begin() + n2, exp.begin(), exp.begin() + n2), in.begin(),\n+            in.begin() + n1, n1, n2, trash, compare);\n+\n+        // If first sequence is greater than second\n+        n2 = n1 / 3;\n+        invoke_on_all_policies(\n+            test_one_policy<iterator_type>(out.begin(), out.begin() + n2, exp.begin(), exp.begin() + n2), in.begin(),\n+            in.begin() + n1, n1, n2, trash, compare);\n+\n+        // If first sequence is less than second\n+        n2 = 2 * n1;\n+        invoke_on_all_policies(\n+            test_one_policy<iterator_type>(out.begin(), out.begin() + n2, exp.begin(), exp.begin() + n2), in.begin(),\n+            in.begin() + n1, n1, n2, trash, compare);\n+    }\n+    // Test partial_sort_copy without predicate\n+    n1 = n_max;\n+    n2 = 2 * n1;\n+    invoke_on_all_policies(test_one_policy<iterator_type>(out.begin(), out.begin() + n2, exp.begin(), exp.begin() + n2),\n+                           in.begin(), in.begin() + n1, n1, n2, trash);\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        invoke_if(exec, [&]() {\n+            partial_sort_copy(exec, input_iter, input_iter, out_iter, out_iter, non_const(std::less<T>()));\n+        });\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    test_partial_sort_copy<Num<float32_t>>([](Num<float32_t> x, Num<float32_t> y) { return x < y; });\n+    test_partial_sort_copy<int32_t>([](int32_t x, int32_t y) { return x > y; });\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "4b9e7aa1d045509a74917147adcb9adaaec8b8a3", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/set.cc", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fset.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,171 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- set.pass.cpp ------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include <cmath>\n+#include <chrono>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct Num\n+{\n+    T val;\n+\n+    Num() : val{} {}\n+    Num(const T& v) : val(v) {}\n+\n+    //for \"includes\" checks\n+    template <typename T1>\n+    bool\n+    operator<(const Num<T1>& v1) const\n+    {\n+        return val < v1.val;\n+    }\n+\n+    //The types Type1 and Type2 must be such that an object of type InputIt can be dereferenced and then implicitly converted to both of them\n+    template <typename T1>\n+    operator Num<T1>() const\n+    {\n+        return Num<T1>((T1)val);\n+    }\n+\n+    friend bool\n+    operator==(const Num& v1, const Num& v2)\n+    {\n+        return v1.val == v2.val;\n+    }\n+};\n+\n+struct test_one_policy\n+{\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename Compare>\n+    typename std::enable_if<!TestUtils::isReverse<InputIterator1>::value, void>::type\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               Compare comp)\n+    {\n+        using T1 = typename std::iterator_traits<InputIterator1>::value_type;\n+\n+        auto n1 = std::distance(first1, last1);\n+        auto n2 = std::distance(first2, last2);\n+        auto n = n1 + n2;\n+        Sequence<T1> expect(n);\n+        Sequence<T1> out(n);\n+\n+        //1. set_union\n+        auto expect_res = std::set_union(first1, last1, first2, last2, expect.begin(), comp);\n+        auto res = std::set_union(exec, first1, last1, first2, last2, out.begin(), comp);\n+\n+        EXPECT_TRUE(expect_res - expect.begin() == res - out.begin(), \"wrong result for set_union\");\n+        EXPECT_EQ_N(expect.begin(), out.begin(), std::distance(out.begin(), res), \"wrong set_union effect\");\n+\n+        //2. set_intersection\n+        expect_res = std::set_intersection(first1, last1, first2, last2, expect.begin(), comp);\n+        res = std::set_intersection(exec, first1, last1, first2, last2, out.begin(), comp);\n+\n+        EXPECT_TRUE(expect_res - expect.begin() == res - out.begin(), \"wrong result for set_intersection\");\n+        EXPECT_EQ_N(expect.begin(), out.begin(), std::distance(out.begin(), res), \"wrong set_intersection effect\");\n+\n+        //3. set_difference\n+        expect_res = std::set_difference(first1, last1, first2, last2, expect.begin(), comp);\n+        res = std::set_difference(exec, first1, last1, first2, last2, out.begin(), comp);\n+\n+        EXPECT_TRUE(expect_res - expect.begin() == res - out.begin(), \"wrong result for set_difference\");\n+        EXPECT_EQ_N(expect.begin(), out.begin(), std::distance(out.begin(), res), \"wrong set_difference effect\");\n+\n+        //4. set_symmetric_difference\n+        expect_res = std::set_symmetric_difference(first1, last1, first2, last2, expect.begin(), comp);\n+        res = std::set_symmetric_difference(exec, first1, last1, first2, last2, out.begin(), comp);\n+\n+        EXPECT_TRUE(expect_res - expect.begin() == res - out.begin(), \"wrong result for set_symmetric_difference\");\n+        EXPECT_EQ_N(expect.begin(), out.begin(), std::distance(out.begin(), res),\n+                    \"wrong set_symmetric_difference effect\");\n+    }\n+\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename Compare>\n+    typename std::enable_if<TestUtils::isReverse<InputIterator1>::value, void>::type\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               Compare comp)\n+    {\n+    }\n+};\n+\n+template <typename T1, typename T2, typename Compare>\n+void\n+test_set(Compare compare)\n+{\n+\n+    const std::size_t n_max = 100000;\n+\n+    // The rand()%(2*n+1) encourages generation of some duplicates.\n+    std::srand(4200);\n+\n+    for (std::size_t n = 0; n < n_max; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        for (std::size_t m = 0; m < n_max; m = m <= 16 ? m + 1 : size_t(2.71828 * m))\n+        {\n+            //prepare the input ranges\n+            Sequence<T1> in1(n, [n](std::size_t k) { return rand() % (2 * k + 1); });\n+            Sequence<T2> in2(m, [m](std::size_t k) { return (m % 2) * rand() + rand() % (k + 1); });\n+\n+            std::sort(in1.begin(), in1.end(), compare);\n+            std::sort(in2.begin(), in2.end(), compare);\n+\n+            invoke_on_all_policies(test_one_policy(), in1.begin(), in1.end(), in2.cbegin(), in2.cend(), compare);\n+        }\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename InputIterator, typename OutputInterator>\n+    void\n+    operator()(Policy&& exec, InputIterator input_iter, OutputInterator out_iter)\n+    {\n+        set_difference(exec, input_iter, input_iter, input_iter, input_iter, out_iter, non_const(std::less<T>()));\n+\n+        set_intersection(exec, input_iter, input_iter, input_iter, input_iter, out_iter, non_const(std::less<T>()));\n+\n+        set_symmetric_difference(exec, input_iter, input_iter, input_iter, input_iter, out_iter,\n+                                 non_const(std::less<T>()));\n+\n+        set_union(exec, input_iter, input_iter, input_iter, input_iter, out_iter, non_const(std::less<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+\n+    test_set<float64_t, float64_t>(__pstl::__internal::__pstl_less());\n+    test_set<Num<int64_t>, Num<int32_t>>([](const Num<int64_t>& x, const Num<int32_t>& y) { return x < y; });\n+\n+    test_algo_basic_double<int32_t>(run_for_rnd_fw<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+\n+    return 0;\n+}"}, {"sha": "e0c55df404f82dc360cea77ce411511bc2b4e619", "filename": "libstdc++-v3/testsuite/25_algorithms/pstl/alg_sorting/sort.cc", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fsort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fsort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpstl%2Falg_sorting%2Fsort.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,255 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- sort.pass.cpp -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+#define _CRT_SECURE_NO_WARNINGS\n+\n+#include <atomic>\n+\n+static bool Stable;\n+\n+//! Number of extant keys\n+static std::atomic<int32_t> KeyCount;\n+\n+//! One more than highest index in array to be sorted.\n+static uint32_t LastIndex;\n+\n+//! Keeping Equal() static and a friend of ParanoidKey class (C++, paragraphs 3.5/7.1.1)\n+class ParanoidKey;\n+static bool\n+Equal(const ParanoidKey& x, const ParanoidKey& y);\n+\n+//! A key to be sorted, with lots of checking.\n+class ParanoidKey\n+{\n+    //! Value used by comparator\n+    int32_t value;\n+    //! Original position or special value (Empty or Dead)\n+    int32_t index;\n+    //! Special value used to mark object without a comparable value, e.g. after being moved from.\n+    static const int32_t Empty = -1;\n+    //! Special value used to mark destroyed objects.\n+    static const int32_t Dead = -2;\n+    // True if key object has comparable value\n+    bool\n+    isLive() const\n+    {\n+        return (uint32_t)(index) < LastIndex;\n+    }\n+    // True if key object has been constructed.\n+    bool\n+    isConstructed() const\n+    {\n+        return isLive() || index == Empty;\n+    }\n+\n+  public:\n+    ParanoidKey()\n+    {\n+        ++KeyCount;\n+        index = Empty;\n+        value = Empty;\n+    }\n+    ParanoidKey(const ParanoidKey& k) : value(k.value), index(k.index)\n+    {\n+        EXPECT_TRUE(k.isLive(), \"source for copy-constructor is dead\");\n+        ++KeyCount;\n+    }\n+    ~ParanoidKey()\n+    {\n+        EXPECT_TRUE(isConstructed(), \"double destruction\");\n+        index = Dead;\n+        --KeyCount;\n+    }\n+    ParanoidKey&\n+    operator=(const ParanoidKey& k)\n+    {\n+        EXPECT_TRUE(k.isLive(), \"source for copy-assignment is dead\");\n+        EXPECT_TRUE(isConstructed(), \"destination for copy-assignment is dead\");\n+        value = k.value;\n+        index = k.index;\n+        return *this;\n+    }\n+    ParanoidKey(int32_t index, int32_t value, OddTag) : index(index), value(value) {}\n+    ParanoidKey(ParanoidKey&& k) : value(k.value), index(k.index)\n+    {\n+        EXPECT_TRUE(k.isConstructed(), \"source for move-construction is dead\");\n+// std::stable_sort() fails in move semantics on paranoid test before VS2015\n+#if !defined(_MSC_VER) || _MSC_VER >= 1900\n+        k.index = Empty;\n+#endif\n+        ++KeyCount;\n+    }\n+    ParanoidKey&\n+    operator=(ParanoidKey&& k)\n+    {\n+        EXPECT_TRUE(k.isConstructed(), \"source for move-assignment is dead\");\n+        EXPECT_TRUE(isConstructed(), \"destination for move-assignment is dead\");\n+        value = k.value;\n+        index = k.index;\n+// std::stable_sort() fails in move semantics on paranoid test before VS2015\n+#if !defined(_MSC_VER) || _MSC_VER >= 1900\n+        k.index = Empty;\n+#endif\n+        return *this;\n+    }\n+    friend class KeyCompare;\n+    friend bool\n+    Equal(const ParanoidKey& x, const ParanoidKey& y);\n+};\n+\n+class KeyCompare\n+{\n+    enum statusType\n+    {\n+        //! Special value used to mark defined object.\n+        Live = 0xabcd,\n+        //! Special value used to mark destroyed objects.\n+        Dead = -1\n+    } status;\n+\n+  public:\n+    KeyCompare(OddTag) : status(Live) {}\n+    ~KeyCompare() { status = Dead; }\n+    bool\n+    operator()(const ParanoidKey& j, const ParanoidKey& k) const\n+    {\n+        EXPECT_TRUE(status == Live, \"key comparison object not defined\");\n+        EXPECT_TRUE(j.isLive(), \"first key to operator() is not live\");\n+        EXPECT_TRUE(k.isLive(), \"second key to operator() is not live\");\n+        return j.value < k.value;\n+    }\n+};\n+\n+// Equal is equality comparison used for checking result of sort against expected result.\n+static bool\n+Equal(const ParanoidKey& x, const ParanoidKey& y)\n+{\n+    return (x.value == y.value && !Stable) || (x.index == y.index);\n+}\n+\n+static bool\n+Equal(float32_t x, float32_t y)\n+{\n+    return x == y;\n+}\n+\n+static bool\n+Equal(int32_t x, int32_t y)\n+{\n+    return x == y;\n+}\n+\n+struct test_sort_with_compare\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Compare>\n+    typename std::enable_if<is_same_iterator_category<InputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, OutputIterator tmp_first, OutputIterator tmp_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, InputIterator first, InputIterator last, Size n, Compare compare)\n+    {\n+        using namespace std;\n+        copy_n(first, n, expected_first);\n+        copy_n(first, n, tmp_first);\n+        if (Stable)\n+            std::stable_sort(expected_first + 1, expected_last - 1, compare);\n+        else\n+            std::sort(expected_first + 1, expected_last - 1, compare);\n+        int32_t count0 = KeyCount;\n+        if (Stable)\n+            stable_sort(exec, tmp_first + 1, tmp_last - 1, compare);\n+        else\n+            sort(exec, tmp_first + 1, tmp_last - 1, compare);\n+\n+        for (size_t i = 0; i < n; ++i, ++expected_first, ++tmp_first)\n+        {\n+            // Check that expected[i] is equal to tmp[i]\n+            EXPECT_TRUE(Equal(*expected_first, *tmp_first), \"bad sort\");\n+        }\n+        int32_t count1 = KeyCount;\n+        EXPECT_EQ(count0, count1, \"key cleanup error\");\n+    }\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename OutputIterator2, typename Size,\n+              typename Compare>\n+    typename std::enable_if<!is_same_iterator_category<InputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, OutputIterator tmp_first, OutputIterator tmp_last, OutputIterator2 expected_first,\n+               OutputIterator2 expected_last, InputIterator first, InputIterator last, Size n, Compare compare)\n+    {\n+    }\n+};\n+\n+template <typename T, typename Compare, typename Convert>\n+void\n+test_sort(Compare compare, Convert convert)\n+{\n+    for (size_t n = 0; n < 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        LastIndex = n + 2;\n+        // The rand()%(2*n+1) encourages generation of some duplicates.\n+        // Sequence is padded with an extra element at front and back, to detect overwrite bugs.\n+        Sequence<T> in(n + 2, [=](size_t k) { return convert(k, rand() % (2 * n + 1)); });\n+        Sequence<T> expected(in);\n+        Sequence<T> tmp(in);\n+        invoke_on_all_policies(test_sort_with_compare(), tmp.begin(), tmp.end(), expected.begin(), expected.end(),\n+                               in.begin(), in.end(), in.size(), compare);\n+    }\n+}\n+\n+template <typename T>\n+struct test_non_const\n+{\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        sort(exec, iter, iter, non_const(std::less<T>()));\n+        stable_sort(exec, iter, iter, non_const(std::less<T>()));\n+    }\n+};\n+\n+int32_t\n+main()\n+{\n+    std::srand(42);\n+    for (int32_t kind = 0; kind < 2; ++kind)\n+    {\n+        Stable = kind != 0;\n+        test_sort<ParanoidKey>(KeyCompare(OddTag()),\n+                               [](size_t k, size_t val) { return ParanoidKey(k, val, OddTag()); });\n+        test_sort<float32_t>([](float32_t x, float32_t y) { return x < y; },\n+                             [](size_t, size_t val) { return float32_t(val); });\n+        test_sort<int32_t>(\n+            [](int32_t x, int32_t y) { return x > y; }, // Reversed so accidental use of < will be detected.\n+            [](size_t, size_t val) { return int32_t(val); });\n+    }\n+\n+    test_algo_basic_single<int32_t>(run_for_rnd<test_non_const<int32_t>>());\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "01a3fb623cd1910281f24e55476bf27ef35796f9", "filename": "libstdc++-v3/testsuite/26_numerics/pstl/numeric_ops/adjacent_difference.cc", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Fadjacent_difference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Fadjacent_difference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Fadjacent_difference.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,179 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- adjacent_difference.pass.cpp --------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include <iterator>\n+\n+#include \"pstl/execution\"\n+#include \"pstl/algorithm\"\n+#include \"pstl/numeric\"\n+#else\n+#include <execution>\n+#include <algorithm>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+template <typename T>\n+struct wrapper\n+{\n+    T t;\n+    explicit wrapper(T t_) : t(t_) {}\n+    template <typename T2>\n+    wrapper(const wrapper<T2>& a)\n+    {\n+        t = a.t;\n+    }\n+    template <typename T2>\n+    void\n+    operator=(const wrapper<T2>& a)\n+    {\n+        t = a.t;\n+    }\n+    wrapper<T>\n+    operator-(const wrapper<T>& a) const\n+    {\n+        return wrapper<T>(t - a.t);\n+    }\n+};\n+\n+template <typename T>\n+bool\n+compare(const T& a, const T& b)\n+{\n+    return a == b;\n+}\n+\n+template <typename T>\n+bool\n+compare(const wrapper<T>& a, const wrapper<T>& b)\n+{\n+    return a.t == b.t;\n+}\n+\n+template <typename Iterator1, typename Iterator2, typename T, typename Function>\n+typename std::enable_if<!std::is_floating_point<T>::value, bool>::type\n+compute_and_check(Iterator1 first, Iterator1 last, Iterator2 d_first, T, Function f)\n+{\n+    using T2 = typename std::iterator_traits<Iterator2>::value_type;\n+\n+    if (first == last)\n+        return true;\n+\n+    T2 temp(*first);\n+    if (!compare(temp, *d_first))\n+        return false;\n+    Iterator1 second = std::next(first);\n+\n+    ++d_first;\n+    for (; second != last; ++first, ++second, ++d_first)\n+    {\n+        T2 temp(f(*second, *first));\n+        if (!compare(temp, *d_first))\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+// we don't want to check equality here\n+// because we can't be sure it will be strictly equal for floating point types\n+template <typename Iterator1, typename Iterator2, typename T, typename Function>\n+typename std::enable_if<std::is_floating_point<T>::value, bool>::type\n+compute_and_check(Iterator1 first, Iterator1 last, Iterator2 d_first, T, Function)\n+{\n+    return true;\n+}\n+\n+struct test_one_policy\n+{\n+#if __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN ||                                                            \\\n+    __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN // dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator1, typename Iterator2, typename T, typename Function>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::unsequenced_policy, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b,\n+               Iterator2 actual_e, T trash, Function f)\n+    {\n+    }\n+    template <typename Iterator1, typename Iterator2, typename T, typename Function>\n+    typename std::enable_if<is_same_iterator_category<Iterator1, std::random_access_iterator_tag>::value, void>::type\n+    operator()(pstl::execution::parallel_unsequenced_policy, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b,\n+               Iterator2 actual_e, T trash, Function f)\n+    {\n+    }\n+#endif\n+\n+    template <typename ExecutionPolicy, typename Iterator1, typename Iterator2, typename T, typename Function>\n+    void\n+    operator()(ExecutionPolicy&& exec, Iterator1 data_b, Iterator1 data_e, Iterator2 actual_b, Iterator2 actual_e,\n+               T trash, Function f)\n+    {\n+        using namespace std;\n+        using T2 = typename std::iterator_traits<Iterator1>::value_type;\n+\n+        fill(actual_b, actual_e, trash);\n+\n+        Iterator2 actual_return = adjacent_difference(exec, data_b, data_e, actual_b);\n+        EXPECT_TRUE(compute_and_check(data_b, data_e, actual_b, T2(0), std::minus<T2>()),\n+                    \"wrong effect of adjacent_difference\");\n+        EXPECT_TRUE(actual_return == actual_e, \"wrong result of adjacent_difference\");\n+\n+        fill(actual_b, actual_e, trash);\n+\n+        actual_return = adjacent_difference(exec, data_b, data_e, actual_b, f);\n+        EXPECT_TRUE(compute_and_check(data_b, data_e, actual_b, T2(0), f),\n+                    \"wrong effect of adjacent_difference with functor\");\n+        EXPECT_TRUE(actual_return == actual_e, \"wrong result of adjacent_difference with functor\");\n+    }\n+};\n+\n+template <typename T1, typename T2, typename Pred>\n+void\n+test(Pred pred)\n+{\n+    typedef typename Sequence<T2>::iterator iterator_type;\n+\n+    const std::size_t max_len = 100000;\n+\n+    const T2 value = T2(77);\n+    const T1 trash = T1(31);\n+\n+    Sequence<T1> actual(max_len, [](std::size_t i) { return T1(i); });\n+\n+    Sequence<T2> data(max_len, [&value](std::size_t i) { return i % 3 == 2 ? T2(i * i) : value; });\n+\n+    for (std::size_t len = 0; len < max_len; len = len <= 16 ? len + 1 : std::size_t(3.1415 * len))\n+    {\n+        invoke_on_all_policies(test_one_policy(), data.begin(), data.begin() + len, actual.begin(),\n+                               actual.begin() + len, trash, pred);\n+        invoke_on_all_policies(test_one_policy(), data.cbegin(), data.cbegin() + len, actual.begin(),\n+                               actual.begin() + len, trash, pred);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    test<uint8_t, uint32_t>([](uint32_t a, uint32_t b) { return a - b; });\n+    test<int32_t, int64_t>([](int64_t a, int64_t b) { return a / (b + 1); });\n+    test<int64_t, float32_t>([](float32_t a, float32_t b) { return (a + b) / 2; });\n+    test<wrapper<int32_t>, wrapper<int64_t>>(\n+        [](const wrapper<int64_t>& a, const wrapper<int64_t>& b) { return a - b; });\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "9ecef9c17be78eaa124206bf13329eb35dd85fc0", "filename": "libstdc++-v3/testsuite/26_numerics/pstl/numeric_ops/reduce.cc", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Freduce.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Freduce.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Freduce.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,121 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- reduce.pass.cpp ---------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/numeric\"\n+#else\n+#include <execution>\n+#include <numeric>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+struct test_long_forms_for_one_policy\n+{\n+    template <typename Policy, typename Iterator, typename T, typename BinaryOp>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, T init, BinaryOp binary, T expected)\n+    {\n+        T result_r = std::reduce(exec, first, last, init, binary);\n+        EXPECT_EQ(expected, result_r, \"bad result from reduce(exec, first, last, init, binary_op)\");\n+    }\n+};\n+\n+template <typename T, typename BinaryOp, typename F>\n+void\n+test_long_form(T init, BinaryOp binary_op, F f)\n+{\n+    // Try sequences of various lengths\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        T expected(init);\n+        Sequence<T> in(n, [n, f](size_t k) { return f((int32_t(k ^ n) % 1000 - 500)); });\n+        for (size_t k = 0; k < n; ++k)\n+            expected = binary_op(expected, in[k]);\n+\n+        using namespace std;\n+\n+        T result = transform_reduce_serial(in.cfbegin(), in.cfend(), init, binary_op, [](const T& t) { return t; });\n+        EXPECT_EQ(expected, result, \"bad result from reduce(first, last, init, binary_op_op)\");\n+\n+        invoke_on_all_policies(test_long_forms_for_one_policy(), in.begin(), in.end(), init, binary_op, expected);\n+        invoke_on_all_policies(test_long_forms_for_one_policy(), in.cbegin(), in.cend(), init, binary_op, expected);\n+    }\n+}\n+\n+struct test_two_short_forms\n+{\n+\n+#if __PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN //dummy specialization by policy type, in case of broken configuration\n+    template <typename Iterator>\n+    void\n+    operator()(__pstl::execution::parallel_policy, Iterator first, Iterator last, Sum init, Sum expected)\n+    {\n+    }\n+    template <typename Iterator>\n+    void\n+    operator()(__pstl::execution::parallel_unsequenced_policy, Iterator first, Iterator last, Sum init, Sum expected)\n+    {\n+    }\n+#endif\n+\n+    template <typename Policy, typename Iterator>\n+    void\n+    operator()(Policy&& exec, Iterator first, Iterator last, Sum init, Sum expected)\n+    {\n+        using namespace std;\n+\n+        Sum r0 = init + reduce(exec, first, last);\n+        EXPECT_EQ(expected, r0, \"bad result from reduce(exec, first, last)\");\n+\n+        Sum r1 = reduce(exec, first, last, init);\n+        EXPECT_EQ(expected, r1, \"bad result from reduce(exec, first, last, init)\");\n+    }\n+};\n+\n+// Test forms of reduce(...) that omit the binary_op or init operands.\n+void\n+test_short_forms()\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sum init(42, OddTag());\n+        Sum expected(init);\n+        Sequence<Sum> in(n, [n](size_t k) { return Sum((int32_t(k ^ n) % 1000 - 500), OddTag()); });\n+        for (size_t k = 0; k < n; ++k)\n+            expected = expected + in[k];\n+        invoke_on_all_policies(test_two_short_forms(), in.begin(), in.end(), init, expected);\n+        invoke_on_all_policies(test_two_short_forms(), in.cbegin(), in.cend(), init, expected);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    // Test for popular types\n+    test_long_form(42, std::plus<int32_t>(), [](int32_t x) { return x; });\n+    test_long_form(42.0, std::plus<float64_t>(), [](float64_t x) { return x; });\n+\n+    // Test for strict types\n+    test_long_form<Number>(Number(42, OddTag()), Add(OddTag()), [](int32_t x) { return Number(x, OddTag()); });\n+\n+    // Short forms are just facade for long forms, so just test with a single type.\n+    test_short_forms();\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "28027dddfeb368e0108459306b22e7a586a19dae", "filename": "libstdc++-v3/testsuite/26_numerics/pstl/numeric_ops/scan.cc", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Fscan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Fscan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Fscan.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,207 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- scan.pass.cpp -----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/numeric\"\n+#else\n+#include <execution>\n+#include <numeric>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// We provide the no execution policy versions of the exclusive_scan and inclusive_scan due checking correctness result of the versions with execution policies.\n+//TODO: to add a macro for availability of ver implementations\n+template <class InputIterator, class OutputIterator, class T>\n+OutputIterator\n+exclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result, T init)\n+{\n+    for (; first != last; ++first, ++result)\n+    {\n+        *result = init;\n+        init = init + *first;\n+    }\n+    return result;\n+}\n+\n+template <class InputIterator, class OutputIterator, class T, class BinaryOperation>\n+OutputIterator\n+exclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result, T init, BinaryOperation binary_op)\n+{\n+    for (; first != last; ++first, ++result)\n+    {\n+        *result = init;\n+        init = binary_op(init, *first);\n+    }\n+    return result;\n+}\n+\n+// Note: N4582 is missing the \", class T\".  Issue was reported 2016-Apr-11 to cxxeditor@gmail.com\n+template <class InputIterator, class OutputIterator, class BinaryOperation, class T>\n+OutputIterator\n+inclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op, T init)\n+{\n+    for (; first != last; ++first, ++result)\n+    {\n+        init = binary_op(init, *first);\n+        *result = init;\n+    }\n+    return result;\n+}\n+\n+template <class InputIterator, class OutputIterator, class BinaryOperation>\n+OutputIterator\n+inclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)\n+{\n+    if (first != last)\n+    {\n+        auto tmp = *first;\n+        *result = tmp;\n+        return inclusive_scan_serial(++first, last, ++result, binary_op, tmp);\n+    }\n+    else\n+    {\n+        return result;\n+    }\n+}\n+\n+template <class InputIterator, class OutputIterator>\n+OutputIterator\n+inclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result)\n+{\n+    typedef typename std::iterator_traits<InputIterator>::value_type input_type;\n+    return inclusive_scan_serial(first, last, result, std::plus<input_type>());\n+}\n+\n+// Most of the framework required for testing inclusive and exclusive scan is identical,\n+// so the tests for both are in this file.  Which is being tested is controlled by the global\n+// flag inclusive, which is set to each alternative by main().\n+static bool inclusive;\n+\n+template <typename Iterator, typename Size, typename T>\n+void\n+check_and_reset(Iterator expected_first, Iterator out_first, Size n, T trash)\n+{\n+    EXPECT_EQ_N(expected_first, out_first, n,\n+                inclusive ? \"wrong result from inclusive_scan\" : \"wrong result from exclusive_scan\");\n+    std::fill_n(out_first, n, trash);\n+}\n+\n+struct test_scan_with_plus\n+{\n+    template <typename Policy, typename Iterator1, typename Iterator2, typename Iterator3, typename Size, typename T>\n+    void\n+    operator()(Policy&& exec, Iterator1 in_first, Iterator1 in_last, Iterator2 out_first, Iterator2 out_last,\n+               Iterator3 expected_first, Iterator3 expected_last, Size n, T init, T trash)\n+    {\n+        using namespace std;\n+\n+        auto orr1 = inclusive ? inclusive_scan_serial(in_first, in_last, expected_first)\n+                              : exclusive_scan_serial(in_first, in_last, expected_first, init);\n+        auto orr = inclusive ? inclusive_scan(exec, in_first, in_last, out_first)\n+                             : exclusive_scan(exec, in_first, in_last, out_first, init);\n+        EXPECT_TRUE(out_last == orr,\n+                    inclusive ? \"inclusive_scan returned wrong iterator\" : \"exclusive_scan returned wrong iterator\");\n+\n+        check_and_reset(expected_first, out_first, n, trash);\n+        fill(out_first, out_last, trash);\n+    }\n+};\n+\n+template <typename T, typename Convert>\n+void\n+test_with_plus(T init, T trash, Convert convert)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<T> in(n, convert);\n+        Sequence<T> expected(in);\n+        Sequence<T> out(n, [&](int32_t) { return trash; });\n+\n+        invoke_on_all_policies(test_scan_with_plus(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), in.size(), init, trash);\n+        invoke_on_all_policies(test_scan_with_plus(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), in.size(), init, trash);\n+    }\n+}\n+struct test_scan_with_binary_op\n+{\n+    template <typename Policy, typename Iterator1, typename Iterator2, typename Iterator3, typename Size, typename T,\n+              typename BinaryOp>\n+    typename std::enable_if<!TestUtils::isReverse<Iterator1>::value, void>::type\n+    operator()(Policy&& exec, Iterator1 in_first, Iterator1 in_last, Iterator2 out_first, Iterator2 out_last,\n+               Iterator3 expected_first, Iterator3 expected_last, Size n, T init, BinaryOp binary_op, T trash)\n+    {\n+        using namespace std;\n+\n+        auto orr1 = inclusive ? inclusive_scan_serial(in_first, in_last, expected_first, binary_op, init)\n+                              : exclusive_scan_serial(in_first, in_last, expected_first, init, binary_op);\n+        auto orr = inclusive ? inclusive_scan(exec, in_first, in_last, out_first, binary_op, init)\n+                             : exclusive_scan(exec, in_first, in_last, out_first, init, binary_op);\n+\n+        EXPECT_TRUE(out_last == orr, \"scan returned wrong iterator\");\n+        check_and_reset(expected_first, out_first, n, trash);\n+    }\n+\n+    template <typename Policy, typename Iterator1, typename Iterator2, typename Iterator3, typename Size, typename T,\n+              typename BinaryOp>\n+    typename std::enable_if<TestUtils::isReverse<Iterator1>::value, void>::type\n+    operator()(Policy&& exec, Iterator1 in_first, Iterator1 in_last, Iterator2 out_first, Iterator2 out_last,\n+               Iterator3 expected_first, Iterator3 expected_last, Size n, T init, BinaryOp binary_op, T trash)\n+    {\n+    }\n+};\n+\n+template <typename In, typename Out, typename BinaryOp>\n+void\n+test_matrix(Out init, BinaryOp binary_op, Out trash)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<In> in(n, [](size_t k) { return In(k, k + 1); });\n+\n+        Sequence<Out> out(n, [&](size_t) { return trash; });\n+        Sequence<Out> expected(n, [&](size_t) { return trash; });\n+\n+        invoke_on_all_policies(test_scan_with_binary_op(), in.begin(), in.end(), out.begin(), out.end(),\n+                               expected.begin(), expected.end(), in.size(), init, binary_op, trash);\n+        invoke_on_all_policies(test_scan_with_binary_op(), in.cbegin(), in.cend(), out.begin(), out.end(),\n+                               expected.begin(), expected.end(), in.size(), init, binary_op, trash);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    for (int32_t mode = 0; mode < 2; ++mode)\n+    {\n+        inclusive = mode != 0;\n+#if !__PSTL_ICC_19_TEST_SIMD_UDS_WINDOWS_RELEASE_BROKEN\n+        // Test with highly restricted type and associative but not commutative operation\n+        test_matrix<Matrix2x2<int32_t>, Matrix2x2<int32_t>>(Matrix2x2<int32_t>(), multiply_matrix<int32_t>,\n+                                                            Matrix2x2<int32_t>(-666, 666));\n+#endif\n+\n+        // Since the implict \"+\" forms of the scan delegate to the generic forms,\n+        // there's little point in using a highly restricted type, so just use double.\n+        test_with_plus<float64_t>(inclusive ? 0.0 : -1.0, -666.0,\n+                                  [](uint32_t k) { return float64_t((k % 991 + 1) ^ (k % 997 + 2)); });\n+    }\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "41c6457784b15e28725a112a0da53db8f3b55c37", "filename": "libstdc++-v3/testsuite/26_numerics/pstl/numeric_ops/transform_reduce.cc", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Ftransform_reduce.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Ftransform_reduce.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Ftransform_reduce.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,144 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- transform_reduce.pass.cpp -----------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/execution\"\n+#include \"pstl/numeric\"\n+#else\n+#include <execution>\n+#include <numeric>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// Equal for all types\n+template <typename T>\n+static bool\n+Equal(T x, T y)\n+{\n+    return x == y;\n+}\n+\n+// Functor for xor-operation for modeling binary operations in inner_product\n+class XOR\n+{\n+  public:\n+    template <typename T>\n+    T\n+    operator()(const T& left, const T& right) const\n+    {\n+        return left ^ right;\n+    }\n+};\n+\n+// Model of User-defined class\n+class MyClass\n+{\n+  public:\n+    int32_t my_field;\n+    MyClass() { my_field = 0; }\n+    MyClass(int32_t in) { my_field = in; }\n+    MyClass(const MyClass& in) { my_field = in.my_field; }\n+\n+    friend MyClass\n+    operator+(const MyClass& x, const MyClass& y)\n+    {\n+        return MyClass(x.my_field + y.my_field);\n+    }\n+    friend MyClass\n+    operator-(const MyClass& x)\n+    {\n+        return MyClass(-x.my_field);\n+    }\n+    friend MyClass operator*(const MyClass& x, const MyClass& y) { return MyClass(x.my_field * y.my_field); }\n+    bool\n+    operator==(const MyClass& in)\n+    {\n+        return my_field == in.my_field;\n+    }\n+};\n+\n+template <typename T>\n+void\n+CheckResults(const T& expected, const T& in)\n+{\n+    EXPECT_TRUE(Equal(expected, in), \"wrong result of transform_reduce\");\n+}\n+\n+// We need to check correctness only for \"int\" (for example) except cases\n+// if we have \"floating-point type\"-specialization\n+void\n+CheckResults(const float32_t& expected, const float32_t& in)\n+{\n+}\n+\n+// Test for different types and operations with different iterators\n+struct test_transform_reduce\n+{\n+    template <typename Policy, typename InputIterator1, typename InputIterator2, typename T, typename BinaryOperation1,\n+              typename BinaryOperation2, typename UnaryOp>\n+    void\n+    operator()(Policy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,\n+               T init, BinaryOperation1 opB1, BinaryOperation2 opB2, UnaryOp opU)\n+    {\n+\n+        auto expectedB = std::inner_product(first1, last1, first2, init, opB1, opB2);\n+        auto expectedU = transform_reduce_serial(first1, last1, init, opB1, opU);\n+        T resRA = std::transform_reduce(exec, first1, last1, first2, init, opB1, opB2);\n+        CheckResults(expectedB, resRA);\n+        resRA = std::transform_reduce(exec, first1, last1, init, opB1, opU);\n+        CheckResults(expectedU, resRA);\n+    }\n+};\n+\n+template <typename T, typename BinaryOperation1, typename BinaryOperation2, typename UnaryOp, typename Initializer>\n+void\n+test_by_type(T init, BinaryOperation1 opB1, BinaryOperation2 opB2, UnaryOp opU, Initializer initObj)\n+{\n+\n+    std::size_t maxSize = 100000;\n+    Sequence<T> in1(maxSize, initObj);\n+    Sequence<T> in2(maxSize, initObj);\n+\n+    for (std::size_t n = 0; n < maxSize; n = n < 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        invoke_on_all_policies(test_transform_reduce(), in1.begin(), in1.begin() + n, in2.begin(), in2.begin() + n,\n+                               init, opB1, opB2, opU);\n+        invoke_on_all_policies(test_transform_reduce(), in1.cbegin(), in1.cbegin() + n, in2.cbegin(), in2.cbegin() + n,\n+                               init, opB1, opB2, opU);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    test_by_type<int32_t>(42, std::plus<int32_t>(), std::multiplies<int32_t>(), std::negate<int32_t>(),\n+                          [](std::size_t a) -> int32_t { return int32_t(rand() % 1000); });\n+    test_by_type<int64_t>(0, [](const int64_t& a, const int64_t& b) -> int64_t { return a | b; }, XOR(),\n+                          [](const int64_t& x) -> int64_t { return x * 2; },\n+                          [](std::size_t a) -> int64_t { return int64_t(rand() % 1000); });\n+    test_by_type<float32_t>(1.0f, std::multiplies<float32_t>(),\n+                            [](const float32_t& a, const float32_t& b) -> float32_t { return a + b; },\n+                            [](const float32_t& x) -> float32_t { return x + 2; },\n+                            [](std::size_t a) -> float32_t { return rand() % 1000; });\n+    test_by_type<MyClass>(MyClass(), std::plus<MyClass>(), std::multiplies<MyClass>(), std::negate<MyClass>(),\n+                          [](std::size_t a) -> MyClass { return MyClass(rand() % 1000); });\n+\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "a3cedff35588792b945e9b9caf8d16558859d7dc", "filename": "libstdc++-v3/testsuite/26_numerics/pstl/numeric_ops/transform_scan.cc", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Ftransform_scan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Ftransform_scan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpstl%2Fnumeric_ops%2Ftransform_scan.cc?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,184 @@\n+// -*- C++ -*-\n+// { dg-options \"-std=gnu++17 -ltbb\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-effective-target tbb-backend }\n+\n+//===-- transform_scan.pass.cpp -------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"pstl/pstl_test_config.h\"\n+\n+#ifdef PSTL_STANDALONE_TESTS\n+#include \"pstl/execution\"\n+#include \"pstl/numeric\"\n+#else\n+#include <execution>\n+#include <numeric>\n+#endif // PSTL_STANDALONE_TESTS\n+\n+#include \"pstl/test_utils.h\"\n+\n+using namespace TestUtils;\n+\n+// Most of the framework required for testing inclusive and exclusive transform-scans is identical,\n+// so the tests for both are in this file.  Which is being tested is controlled by the global\n+// flag inclusive, which is set to each alternative by main().\n+static bool inclusive;\n+\n+template <typename Iterator, typename Size, typename T>\n+void\n+check_and_reset(Iterator expected_first, Iterator out_first, Size n, T trash)\n+{\n+    EXPECT_EQ_N(expected_first, out_first, n,\n+                inclusive ? \"wrong result from transform_inclusive_scan\"\n+                          : \"wrong result from transform_exclusive_scan\");\n+    std::fill_n(out_first, n, trash);\n+}\n+\n+struct test_transform_scan\n+{\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename Size, typename UnaryOp,\n+              typename T, typename BinaryOp>\n+    typename std::enable_if<!TestUtils::isReverse<InputIterator>::value, void>::type\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator expected_first, OutputIterator expected_last, Size n,\n+               UnaryOp unary_op, T init, BinaryOp binary_op, T trash)\n+    {\n+        using namespace std;\n+\n+        auto orr1 = inclusive ? transform_inclusive_scan(__pstl::execution::seq, first, last, expected_first, binary_op,\n+                                                         unary_op, init)\n+                              : transform_exclusive_scan(__pstl::execution::seq, first, last, expected_first, init,\n+                                                         binary_op, unary_op);\n+        auto orr2 = inclusive ? transform_inclusive_scan(exec, first, last, out_first, binary_op, unary_op, init)\n+                              : transform_exclusive_scan(exec, first, last, out_first, init, binary_op, unary_op);\n+        EXPECT_TRUE(out_last == orr2, \"transform...scan returned wrong iterator\");\n+        check_and_reset(expected_first, out_first, n, trash);\n+\n+        // Checks inclusive scan if init is not provided\n+        if (inclusive && n > 0)\n+        {\n+            orr1 = transform_inclusive_scan(__pstl::execution::seq, first, last, expected_first, binary_op, unary_op);\n+            orr2 = transform_inclusive_scan(exec, first, last, out_first, binary_op, unary_op);\n+            EXPECT_TRUE(out_last == orr2, \"transform...scan returned wrong iterator\");\n+            check_and_reset(expected_first, out_first, n, trash);\n+        }\n+    }\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator, typename Size, typename UnaryOp,\n+              typename T, typename BinaryOp>\n+    typename std::enable_if<TestUtils::isReverse<InputIterator>::value, void>::type\n+    operator()(Policy&& exec, InputIterator first, InputIterator last, OutputIterator out_first,\n+               OutputIterator out_last, OutputIterator expected_first, OutputIterator expected_last, Size n,\n+               UnaryOp unary_op, T init, BinaryOp binary_op, T trash)\n+    {\n+    }\n+};\n+\n+const uint32_t encryption_mask = 0x314;\n+\n+template <typename InputIterator, typename OutputIterator, typename UnaryOperation, typename T,\n+          typename BinaryOperation>\n+std::pair<OutputIterator, T>\n+transform_inclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation unary_op,\n+                                T init, BinaryOperation binary_op) noexcept\n+{\n+    for (; first != last; ++first, ++result)\n+    {\n+        init = binary_op(init, unary_op(*first));\n+        *result = init;\n+    }\n+    return std::make_pair(result, init);\n+}\n+\n+template <typename InputIterator, typename OutputIterator, typename UnaryOperation, typename T,\n+          typename BinaryOperation>\n+std::pair<OutputIterator, T>\n+transform_exclusive_scan_serial(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation unary_op,\n+                                T init, BinaryOperation binary_op) noexcept\n+{\n+    for (; first != last; ++first, ++result)\n+    {\n+        *result = init;\n+        init = binary_op(init, unary_op(*first));\n+    }\n+    return std::make_pair(result, init);\n+}\n+\n+template <typename In, typename Out, typename UnaryOp, typename BinaryOp>\n+void\n+test(UnaryOp unary_op, Out init, BinaryOp binary_op, Out trash)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<In> in(n, [](size_t k) { return In(k ^ encryption_mask); });\n+\n+        Out tmp = init;\n+        Sequence<Out> expected(n, [&](size_t k) -> Out {\n+            if (inclusive)\n+            {\n+                tmp = binary_op(tmp, unary_op(in[k]));\n+                return tmp;\n+            }\n+            else\n+            {\n+                Out val = tmp;\n+                tmp = binary_op(tmp, unary_op(in[k]));\n+                return val;\n+            }\n+        });\n+\n+        Sequence<Out> out(n, [&](size_t) { return trash; });\n+\n+        auto result =\n+            inclusive\n+                ? transform_inclusive_scan_serial(in.cbegin(), in.cend(), out.fbegin(), unary_op, init, binary_op)\n+                : transform_exclusive_scan_serial(in.cbegin(), in.cend(), out.fbegin(), unary_op, init, binary_op);\n+        check_and_reset(expected.begin(), out.begin(), out.size(), trash);\n+\n+        invoke_on_all_policies(test_transform_scan(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), in.size(), unary_op, init, binary_op, trash);\n+        invoke_on_all_policies(test_transform_scan(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), in.size(), unary_op, init, binary_op, trash);\n+    }\n+}\n+\n+template <typename In, typename Out, typename UnaryOp, typename BinaryOp>\n+void\n+test_matrix(UnaryOp unary_op, Out init, BinaryOp binary_op, Out trash)\n+{\n+    for (size_t n = 0; n <= 100000; n = n <= 16 ? n + 1 : size_t(3.1415 * n))\n+    {\n+        Sequence<In> in(n, [](size_t k) { return In(k, k + 1); });\n+\n+        Sequence<Out> out(n, [&](size_t) { return trash; });\n+        Sequence<Out> expected(n, [&](size_t) { return trash; });\n+\n+        invoke_on_all_policies(test_transform_scan(), in.begin(), in.end(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), in.size(), unary_op, init, binary_op, trash);\n+        invoke_on_all_policies(test_transform_scan(), in.cbegin(), in.cend(), out.begin(), out.end(), expected.begin(),\n+                               expected.end(), in.size(), unary_op, init, binary_op, trash);\n+    }\n+}\n+\n+int32_t\n+main()\n+{\n+    for (int32_t mode = 0; mode < 2; ++mode)\n+    {\n+        inclusive = mode != 0;\n+#if !__PSTL_ICC_19_TEST_SIMD_UDS_WINDOWS_RELEASE_BROKEN\n+        test_matrix<Matrix2x2<int32_t>, Matrix2x2<int32_t>>([](const Matrix2x2<int32_t> x) { return x; },\n+                                                            Matrix2x2<int32_t>(), multiply_matrix<int32_t>,\n+                                                            Matrix2x2<int32_t>(-666, 666));\n+#endif\n+        test<int32_t, uint32_t>([](int32_t x) { return x++; }, -123, [](int32_t x, int32_t y) { return x + y; }, 666);\n+    }\n+    std::cout << done() << std::endl;\n+    return 0;\n+}"}, {"sha": "5a12ac0242d1eeabdc3801bd0e60d9c9ac41e503", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -1605,6 +1605,29 @@ proc check_effective_target_random_device { } {\n     return 0\n }\n \n+# Return 1 if tbb parallel backend is available\n+proc check_effective_target_tbb-backend { } {\n+\t\tglobal cxxflags\n+\n+\t\t# Set up and preprocess a C++ test program that depends\n+\t\t# on tbb\n+\t\tset src tbb_backend[pid].cc\n+\n+\t\tset f [open $src \"w\"]\n+\t\tputs $f \"#include <tbb/tbb.h>\"\n+\t\tclose $f\n+\t\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n+\t\tfile delete $src\n+\n+\t\tif [string match \"\" $lines] {\n+\t\t\t\t# No error message, preprocessing succeeded.\n+\t\t\t\tverbose \"check_v3_tbb-backend: `1'\" 2\n+\t\t\t\treturn 1\n+\t\t}\n+\t\tverbose \"check_v3_tbb-backend: `0'\" 2\n+\t\treturn 0\n+}\n+\n set additional_prunes \"\"\n \n if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \\"}, {"sha": "10b872498c3d33a7db889fea52b292ba85210847", "filename": "libstdc++-v3/testsuite/util/pstl/pstl_test_config.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fpstl%2Fpstl_test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fpstl%2Fpstl_test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fpstl%2Fpstl_test_config.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,49 @@\n+// -*- C++ -*-\n+//===-- pstl_test_config.h ------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef __PSTL_TEST_config_H\n+#define __PSTL_TEST_config_H\n+\n+#if defined(_MSC_VER) && defined(_DEBUG)\n+#define _SCL_SECURE_NO_WARNINGS //to prevent the compilation warning. Microsoft STL implementation has specific checking of an iterator range in DEBUG mode for the containers from the standard library.\n+#endif\n+\n+#define __PSTL_ICC_16_17_TEST_REDUCTION_BOOL_TYPE_RELEASE_64_BROKEN                                                    \\\n+    (__x86_64 && !_DEBUG && __INTEL_COMPILER && __INTEL_COMPILER <= 1700 && !__APPLE__)\n+#define __PSTL_ICC_16_17_TEST_REDUCTION_RELEASE_BROKEN                                                                 \\\n+    (!_DEBUG && __INTEL_COMPILER &&                                                                                    \\\n+     (__INTEL_COMPILER < 1800 || (__INTEL_COMPILER == 1800 && __INTEL_COMPILER_UPDATE < 1)))\n+#define __PSTL_ICC_1800_TEST_MONOTONIC_RELEASE_64_BROKEN                                                               \\\n+    (__x86_64 && !_DEBUG && __INTEL_COMPILER && __INTEL_COMPILER == 1800 && __INTEL_COMPILER_UPDATE < 1)\n+#define __PSTL_ICC_17_TEST_MAC_RELEASE_32_BROKEN                                                                       \\\n+    (__i386__ && !_DEBUG && __INTEL_COMPILER >= 1700 && __INTEL_COMPILER < 1800 && __APPLE__)\n+#define __PSTL_ICC_18_VC141_TEST_SIMD_LAMBDA_RELEASE_BROKEN                                                            \\\n+    (!_DEBUG && __INTEL_COMPILER >= 1800 && __INTEL_COMPILER < 1900 && _MSC_VER == 1910)\n+#define __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN                                                           \\\n+    (_M_IX86 && _DEBUG && __INTEL_COMPILER >= 1700 && __INTEL_COMPILER < 1800 && _MSC_VER >= 1900)\n+#define __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN                                                            \\\n+    (_M_IX86 && _DEBUG && __INTEL_COMPILER >= 1600 && __INTEL_COMPILER < 1700 && _MSC_VER == 1900)\n+#define __PSTL_ICC_16_VC14_TEST_PAR_TBB_RT_RELEASE_64_BROKEN                                                           \\\n+    (__PSTL_USE_PAR_POLICIES && ((_M_X64 && _MSC_VER == 1900) || __x86_64) && !_DEBUG && __INTEL_COMPILER < 1700)\n+#define __PSTL_ICC_16_17_TEST_64_TIMEOUT (__x86_64 && __INTEL_COMPILER && __INTEL_COMPILER < 1800 && !__APPLE__)\n+#define __PSTL_ICC_18_TEST_EARLY_EXIT_MONOTONIC_RELEASE_BROKEN (!_DEBUG && __INTEL_COMPILER && __INTEL_COMPILER == 1800)\n+#define __PSTL_CLANG_TEST_BIG_OBJ_DEBUG_32_BROKEN                                                                      \\\n+    (__i386__ && PSTL_USE_DEBUG && __clang__ && __PSTL_CLANG_VERSION <= 90000)\n+#define __PSTL_ICC_16_17_18_TEST_UNIQUE_MASK_RELEASE_BROKEN                                                            \\\n+    (!_DEBUG && __INTEL_COMPILER &&                                                                                    \\\n+     (__INTEL_COMPILER < 1800 || (__INTEL_COMPILER == 1800 && __INTEL_COMPILER_UPDATE < 3)))\n+#define __PSTL_ICC_18_TEST_EARLY_EXIT_AVX_RELEASE_BROKEN                                                               \\\n+    (!_DEBUG && __INTEL_COMPILER == 1800 && __AVX__ && !__AVX2__ && !__AVX512__)\n+#define __PSTL_ICC_19_TEST_IS_PARTITIONED_RELEASE_BROKEN                                                               \\\n+    (!PSTL_USE_DEBUG && (__linux__ || __APPLE__) && __INTEL_COMPILER == 1900)\n+#define __PSTL_ICL_19_VC14_VC141_TEST_SCAN_RELEASE_BROKEN                                                              \\\n+    (__INTEL_COMPILER == 1900 && _MSC_VER >= 1900 && _MSC_VER <= 1910)\n+#define __PSTL_ICC_19_TEST_SIMD_UDS_WINDOWS_RELEASE_BROKEN (__INTEL_COMPILER == 1900 && _MSC_VER && !_DEBUG)\n+\n+#endif /* __PSTL_TEST_config_H */"}, {"sha": "65329285c2bed860dcafc1bde7827f20cdd75a9e", "filename": "libstdc++-v3/testsuite/util/pstl/test_utils.h", "status": "added", "additions": 1248, "deletions": 0, "changes": 1248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fpstl%2Ftest_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061f457868281238db43ef784aa12269cc866adb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fpstl%2Ftest_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fpstl%2Ftest_utils.h?ref=061f457868281238db43ef784aa12269cc866adb", "patch": "@@ -0,0 +1,1248 @@\n+// -*- C++ -*-\n+//===-- utils.h -----------------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// File contains common utilities that tests rely on\n+\n+// Do not #include <algorithm>, because if we do we will not detect accidental dependencies.\n+#include <sstream>\n+#include <iostream>\n+#include <cstring>\n+#include <iterator>\n+#include <vector>\n+#include <atomic>\n+#include <memory>\n+#include <cstdint>\n+\n+#include \"pstl_test_config.h\"\n+\n+namespace TestUtils\n+{\n+\n+typedef double float64_t;\n+typedef float float32_t;\n+\n+template <class T, std::size_t N>\n+constexpr size_t\n+const_size(const T (&array)[N]) noexcept\n+{\n+    return N;\n+}\n+\n+template <typename T>\n+class Sequence;\n+\n+// Handy macros for error reporting\n+#define EXPECT_TRUE(condition, message) TestUtils::expect<true>(condition, __FILE__, __LINE__, message)\n+#define EXPECT_FALSE(condition, message) TestUtils::expect<false>(condition, __FILE__, __LINE__, message)\n+\n+// Check that expected and actual are equal and have the same type.\n+#define EXPECT_EQ(expected, actual, message) TestUtils::expect_equal(expected, actual, __FILE__, __LINE__, message)\n+\n+// Check that sequences started with expected and actual and have had size n are equal and have the same type.\n+#define EXPECT_EQ_N(expected, actual, n, message)                                                                      \\\n+    TestUtils::expect_equal(expected, actual, n, __FILE__, __LINE__, message)\n+\n+// Issue error message from outstr, adding a newline.\n+// Real purpose of this routine is to have a place to hang a breakpoint.\n+static void\n+issue_error_message(std::stringstream& outstr)\n+{\n+    outstr << std::endl;\n+    std::cerr << outstr.str();\n+}\n+\n+template <bool B>\n+void\n+expect(bool condition, const char* file, int32_t line, const char* message)\n+{\n+    // Templating this function is somewhat silly, but avoids the need to declare it static\n+    // or have a separate translation unit.\n+    if (condition != B)\n+    {\n+        std::stringstream outstr;\n+        outstr << \"error at \" << file << \":\" << line << \" - \" << message;\n+        issue_error_message(outstr);\n+    }\n+}\n+\n+// Do not change signature to const T&.\n+// Function must be able to detect const differences between expected and actual.\n+template <typename T>\n+void\n+expect_equal(T& expected, T& actual, const char* file, int32_t line, const char* message)\n+{\n+    if (!(expected == actual))\n+    {\n+        std::stringstream outstr;\n+        outstr << \"error at \" << file << \":\" << line << \" - \" << message << \", expected \" << expected << \" got \"\n+               << actual;\n+        issue_error_message(outstr);\n+    }\n+}\n+\n+template <typename T>\n+void\n+expect_equal(Sequence<T>& expected, Sequence<T>& actual, const char* file, int32_t line, const char* message)\n+{\n+    size_t n = expected.size();\n+    size_t m = actual.size();\n+    if (n != m)\n+    {\n+        std::stringstream outstr;\n+        outstr << \"error at \" << file << \":\" << line << \" - \" << message << \", expected sequence of size \" << n\n+               << \" got sequence of size \" << m;\n+        issue_error_message(outstr);\n+        return;\n+    }\n+    size_t error_count = 0;\n+    for (size_t k = 0; k < n && error_count < 10; ++k)\n+    {\n+        if (!(expected[k] == actual[k]))\n+        {\n+            std::stringstream outstr;\n+            outstr << \"error at \" << file << \":\" << line << \" - \" << message << \", at index \" << k << \" expected \"\n+                   << expected[k] << \" got \" << actual[k];\n+            issue_error_message(outstr);\n+            ++error_count;\n+        }\n+    }\n+}\n+\n+template <typename Iterator1, typename Iterator2, typename Size>\n+void\n+expect_equal(Iterator1 expected_first, Iterator2 actual_first, Size n, const char* file, int32_t line,\n+             const char* message)\n+{\n+    size_t error_count = 0;\n+    for (size_t k = 0; k < n && error_count < 10; ++k, ++expected_first, ++actual_first)\n+    {\n+        if (!(*expected_first == *actual_first))\n+        {\n+            std::stringstream outstr;\n+            outstr << \"error at \" << file << \":\" << line << \" - \" << message << \", at index \" << k;\n+            issue_error_message(outstr);\n+            ++error_count;\n+        }\n+    }\n+}\n+\n+// ForwardIterator is like type Iterator, but restricted to be a forward iterator.\n+// Only the forward iterator signatures that are necessary for tests are present.\n+// Post-increment in particular is deliberatly omitted since our templates should avoid using it\n+// because of efficiency considerations.\n+template <typename Iterator, typename IteratorTag>\n+class ForwardIterator\n+{\n+  public:\n+    typedef IteratorTag iterator_category;\n+    typedef typename std::iterator_traits<Iterator>::value_type value_type;\n+    typedef typename std::iterator_traits<Iterator>::difference_type difference_type;\n+    typedef typename std::iterator_traits<Iterator>::pointer pointer;\n+    typedef typename std::iterator_traits<Iterator>::reference reference;\n+\n+  protected:\n+    Iterator my_iterator;\n+    typedef value_type element_type;\n+\n+  public:\n+    ForwardIterator() = default;\n+    explicit ForwardIterator(Iterator i) : my_iterator(i) {}\n+    reference operator*() const { return *my_iterator; }\n+    Iterator operator->() const { return my_iterator; }\n+    ForwardIterator\n+    operator++()\n+    {\n+        ++my_iterator;\n+        return *this;\n+    }\n+    ForwardIterator operator++(int32_t)\n+    {\n+        auto retval = *this;\n+        my_iterator++;\n+        return retval;\n+    }\n+    friend bool\n+    operator==(const ForwardIterator& i, const ForwardIterator& j)\n+    {\n+        return i.my_iterator == j.my_iterator;\n+    }\n+    friend bool\n+    operator!=(const ForwardIterator& i, const ForwardIterator& j)\n+    {\n+        return i.my_iterator != j.my_iterator;\n+    }\n+\n+    Iterator\n+    iterator() const\n+    {\n+        return my_iterator;\n+    }\n+};\n+\n+template <typename Iterator, typename IteratorTag>\n+class BidirectionalIterator : public ForwardIterator<Iterator, IteratorTag>\n+{\n+    typedef ForwardIterator<Iterator, IteratorTag> base_type;\n+\n+  public:\n+    BidirectionalIterator() = default;\n+    explicit BidirectionalIterator(Iterator i) : base_type(i) {}\n+    BidirectionalIterator(const base_type& i) : base_type(i.iterator()) {}\n+\n+    BidirectionalIterator\n+    operator++()\n+    {\n+        ++base_type::my_iterator;\n+        return *this;\n+    }\n+    BidirectionalIterator\n+    operator--()\n+    {\n+        --base_type::my_iterator;\n+        return *this;\n+    }\n+    BidirectionalIterator operator++(int32_t)\n+    {\n+        auto retval = *this;\n+        base_type::my_iterator++;\n+        return retval;\n+    }\n+    BidirectionalIterator operator--(int32_t)\n+    {\n+        auto retval = *this;\n+        base_type::my_iterator--;\n+        return retval;\n+    }\n+};\n+\n+template <typename Iterator, typename F>\n+void\n+fill_data(Iterator first, Iterator last, F f)\n+{\n+    typedef typename std::iterator_traits<Iterator>::value_type T;\n+    for (std::size_t i = 0; first != last; ++first, ++i)\n+    {\n+        *first = T(f(i));\n+    }\n+}\n+\n+// Sequence<T> is a container of a sequence of T with lots of kinds of iterators.\n+// Prefixes on begin/end mean:\n+//      c = \"const\"\n+//      f = \"forward\"\n+// No prefix indicates non-const random-access iterator.\n+template <typename T>\n+class Sequence\n+{\n+    std::vector<T> m_storage;\n+\n+  public:\n+    typedef typename std::vector<T>::iterator iterator;\n+    typedef typename std::vector<T>::const_iterator const_iterator;\n+    typedef ForwardIterator<iterator, std::forward_iterator_tag> forward_iterator;\n+    typedef ForwardIterator<const_iterator, std::forward_iterator_tag> const_forward_iterator;\n+\n+    typedef BidirectionalIterator<iterator, std::bidirectional_iterator_tag> bidirectional_iterator;\n+    typedef BidirectionalIterator<const_iterator, std::bidirectional_iterator_tag> const_bidirectional_iterator;\n+\n+    typedef T value_type;\n+    explicit Sequence(size_t size) : m_storage(size) {}\n+\n+    // Construct sequence [f(0), f(1), ... f(size-1)]\n+    // f can rely on its invocations being sequential from 0 to size-1.\n+    template <typename Func>\n+    Sequence(size_t size, Func f)\n+    {\n+        m_storage.reserve(size);\n+        // Use push_back because T might not have a default constructor\n+        for (size_t k = 0; k < size; ++k)\n+            m_storage.push_back(T(f(k)));\n+    }\n+    Sequence(const std::initializer_list<T>& data) : m_storage(data) {}\n+\n+    const_iterator\n+    begin() const\n+    {\n+        return m_storage.begin();\n+    }\n+    const_iterator\n+    end() const\n+    {\n+        return m_storage.end();\n+    }\n+    iterator\n+    begin()\n+    {\n+        return m_storage.begin();\n+    }\n+    iterator\n+    end()\n+    {\n+        return m_storage.end();\n+    }\n+    const_iterator\n+    cbegin() const\n+    {\n+        return m_storage.cbegin();\n+    }\n+    const_iterator\n+    cend() const\n+    {\n+        return m_storage.cend();\n+    }\n+    forward_iterator\n+    fbegin()\n+    {\n+        return forward_iterator(m_storage.begin());\n+    }\n+    forward_iterator\n+    fend()\n+    {\n+        return forward_iterator(m_storage.end());\n+    }\n+    const_forward_iterator\n+    cfbegin() const\n+    {\n+        return const_forward_iterator(m_storage.cbegin());\n+    }\n+    const_forward_iterator\n+    cfend() const\n+    {\n+        return const_forward_iterator(m_storage.cend());\n+    }\n+    const_forward_iterator\n+    fbegin() const\n+    {\n+        return const_forward_iterator(m_storage.cbegin());\n+    }\n+    const_forward_iterator\n+    fend() const\n+    {\n+        return const_forward_iterator(m_storage.cend());\n+    }\n+\n+    const_bidirectional_iterator\n+    cbibegin() const\n+    {\n+        return const_bidirectional_iterator(m_storage.cbegin());\n+    }\n+    const_bidirectional_iterator\n+    cbiend() const\n+    {\n+        return const_bidirectional_iterator(m_storage.cend());\n+    }\n+\n+    bidirectional_iterator\n+    bibegin()\n+    {\n+        return bidirectional_iterator(m_storage.begin());\n+    }\n+    bidirectional_iterator\n+    biend()\n+    {\n+        return bidirectional_iterator(m_storage.end());\n+    }\n+\n+    std::size_t\n+    size() const\n+    {\n+        return m_storage.size();\n+    }\n+    const T*\n+    data() const\n+    {\n+        return m_storage.data();\n+    }\n+    typename std::vector<T>::reference operator[](size_t j) { return m_storage[j]; }\n+    const T& operator[](size_t j) const { return m_storage[j]; }\n+\n+    // Fill with given value\n+    void\n+    fill(const T& value)\n+    {\n+        for (size_t i = 0; i < m_storage.size(); i++)\n+            m_storage[i] = value;\n+    }\n+\n+    void\n+    print() const;\n+\n+    template <typename Func>\n+    void\n+    fill(Func f)\n+    {\n+        fill_data(m_storage.begin(), m_storage.end(), f);\n+    }\n+};\n+\n+template <typename T>\n+void\n+Sequence<T>::print() const\n+{\n+    std::cout << \"size = \" << size() << \": { \";\n+    std::copy(begin(), end(), std::ostream_iterator<T>(std::cout, \" \"));\n+    std::cout << \" } \" << std::endl;\n+}\n+\n+// Predicates for algorithms\n+template <typename DataType>\n+struct is_equal_to\n+{\n+    is_equal_to(const DataType& expected) : m_expected(expected) {}\n+    bool\n+    operator()(const DataType& actual) const\n+    {\n+        return actual == m_expected;\n+    }\n+\n+  private:\n+    DataType m_expected;\n+};\n+\n+// Low-quality hash function, returns value between 0 and (1<<bits)-1\n+// Warning: low-order bits are quite predictable.\n+inline size_t\n+HashBits(size_t i, size_t bits)\n+{\n+    size_t mask = bits >= 8 * sizeof(size_t) ? ~size_t(0) : (size_t(1) << bits) - 1;\n+    return (424157 * i ^ 0x24aFa) & mask;\n+}\n+\n+// Stateful unary op\n+template <typename T, typename U>\n+class Complement\n+{\n+    int32_t val;\n+\n+  public:\n+    Complement(T v) : val(v) {}\n+    U\n+    operator()(const T& x) const\n+    {\n+        return U(val - x);\n+    }\n+};\n+\n+// Tag used to prevent accidental use of converting constructor, even if use is explicit.\n+struct OddTag\n+{\n+};\n+\n+class Sum;\n+\n+// Type with limited set of operations.  Not default-constructible.\n+// Only available operator is \"==\".\n+// Typically used as value type in tests.\n+class Number\n+{\n+    int32_t value;\n+    friend class Add;\n+    friend class Sum;\n+    friend class IsMultiple;\n+    friend class Congruent;\n+    friend Sum\n+    operator+(const Sum& x, const Sum& y);\n+\n+  public:\n+    Number(int32_t val, OddTag) : value(val) {}\n+    friend bool\n+    operator==(const Number& x, const Number& y)\n+    {\n+        return x.value == y.value;\n+    }\n+    friend std::ostream&\n+    operator<<(std::ostream& o, const Number& d)\n+    {\n+        return o << d.value;\n+    }\n+};\n+\n+// Stateful predicate for Number.  Not default-constructible.\n+class IsMultiple\n+{\n+    long modulus;\n+\n+  public:\n+    // True if x is multiple of modulus\n+    bool\n+    operator()(Number x) const\n+    {\n+        return x.value % modulus == 0;\n+    }\n+    IsMultiple(long modulus_, OddTag) : modulus(modulus_) {}\n+};\n+\n+// Stateful equivalence-class predicate for Number.  Not default-constructible.\n+class Congruent\n+{\n+    long modulus;\n+\n+  public:\n+    // True if x and y have same remainder for the given modulus.\n+    // Note: this is not quite the same as \"equivalent modulo modulus\" when x and y have different\n+    // sign, but nonetheless AreCongruent is still an equivalence relationship, which is all\n+    // we need for testing.\n+    bool\n+    operator()(Number x, Number y) const\n+    {\n+        return x.value % modulus == y.value % modulus;\n+    }\n+    Congruent(long modulus_, OddTag) : modulus(modulus_) {}\n+};\n+\n+// Stateful reduction operation for Number\n+class Add\n+{\n+    long bias;\n+\n+  public:\n+    explicit Add(OddTag) : bias(1) {}\n+    Number\n+    operator()(Number x, const Number& y)\n+    {\n+        return Number(x.value + y.value + (bias - 1), OddTag());\n+    }\n+};\n+\n+// Class similar to Number, but has default constructor and +.\n+class Sum : public Number\n+{\n+  public:\n+    Sum() : Number(0, OddTag()) {}\n+    Sum(long x, OddTag) : Number(x, OddTag()) {}\n+    friend Sum\n+    operator+(const Sum& x, const Sum& y)\n+    {\n+        return Sum(x.value + y.value, OddTag());\n+    }\n+};\n+\n+// Type with limited set of operations, which includes an associative but not commutative operation.\n+// Not default-constructible.\n+// Typically used as value type in tests involving \"GENERALIZED_NONCOMMUTATIVE_SUM\".\n+class MonoidElement\n+{\n+    size_t a, b;\n+\n+  public:\n+    MonoidElement(size_t a_, size_t b_, OddTag) : a(a_), b(b_) {}\n+    friend bool\n+    operator==(const MonoidElement& x, const MonoidElement& y)\n+    {\n+        return x.a == y.a && x.b == y.b;\n+    }\n+    friend std::ostream&\n+    operator<<(std::ostream& o, const MonoidElement& x)\n+    {\n+        return o << \"[\" << x.a << \"..\" << x.b << \")\";\n+    }\n+    friend class AssocOp;\n+};\n+\n+// Stateful associative op for MonoidElement\n+// It's not really a monoid since the operation is not allowed for any two elements.\n+// But it's good enough for testing.\n+class AssocOp\n+{\n+    unsigned c;\n+\n+  public:\n+    explicit AssocOp(OddTag) : c(5) {}\n+    MonoidElement\n+    operator()(const MonoidElement& x, const MonoidElement& y)\n+    {\n+        unsigned d = 5;\n+        EXPECT_EQ(d, c, \"state lost\");\n+        EXPECT_EQ(x.b, y.a, \"commuted?\");\n+\n+        return MonoidElement(x.a, y.b, OddTag());\n+    }\n+};\n+\n+// Multiplication of matrix is an associative but not commutative operation\n+// Typically used as value type in tests involving \"GENERALIZED_NONCOMMUTATIVE_SUM\".\n+template <typename T>\n+struct Matrix2x2\n+{\n+    T a[2][2];\n+    Matrix2x2() : a{{1, 0}, {0, 1}} {}\n+    Matrix2x2(T x, T y) : a{{0, x}, {x, y}} {}\n+#if !__PSTL_ICL_19_VC14_VC141_TEST_SCAN_RELEASE_BROKEN\n+    Matrix2x2(const Matrix2x2& m) : a{{m.a[0][0], m.a[0][1]}, {m.a[1][0], m.a[1][1]}} {}\n+    Matrix2x2&\n+    operator=(const Matrix2x2& m)\n+    {\n+        a[0][0] = m.a[0][0], a[0][1] = m.a[0][1], a[1][0] = m.a[1][0], a[1][1] = m.a[1][1];\n+        return *this;\n+    }\n+#endif\n+};\n+\n+template <typename T>\n+bool\n+operator==(const Matrix2x2<T>& left, const Matrix2x2<T>& right)\n+{\n+    return left.a[0][0] == right.a[0][0] && left.a[0][1] == right.a[0][1] && left.a[1][0] == right.a[1][0] &&\n+           left.a[1][1] == right.a[1][1];\n+}\n+\n+template <typename T>\n+Matrix2x2<T>\n+multiply_matrix(const Matrix2x2<T>& left, const Matrix2x2<T>& right)\n+{\n+    Matrix2x2<T> result;\n+    for (int32_t i = 0; i < 2; ++i)\n+    {\n+        for (int32_t j = 0; j < 2; ++j)\n+        {\n+            result.a[i][j] = left.a[i][0] * right.a[0][j] + left.a[i][1] * right.a[1][j];\n+        }\n+    }\n+    return result;\n+}\n+\n+// Check that Intel(R) Threading Building Blocks header files are not used when parallel policies are off\n+#if !__PSTL_USE_PAR_POLICIES\n+#if defined(TBB_INTERFACE_VERSION)\n+#error The parallel backend is used while it should not (__PSTL_USE_PAR_POLICIES==0)\n+#endif\n+#endif\n+\n+//============================================================================\n+// Adapters for creating different types of iterators.\n+//\n+// In this block we implemented some adapters for creating differnet types of iterators.\n+// It's needed for extending the unit testing of Parallel STL algorithms.\n+// We have adapters for iterators with different tags (forward_iterator_tag, bidirectional_iterator_tag), reverse iterators.\n+// The input iterator should be const or non-const, non-reverse random access iterator.\n+// Iterator creates in \"MakeIterator\":\n+// firstly, iterator is \"packed\" by \"IteratorTypeAdapter\" (creating forward or bidirectional iterator)\n+// then iterator is \"packed\" by \"ReverseAdapter\" (if it's possible)\n+// So, from input iterator we may create, for example, reverse bidirectional iterator.\n+// \"Main\" functor for testing iterators is named \"invoke_on_all_iterator_types\".\n+\n+// Base adapter\n+template <typename Iterator>\n+struct BaseAdapter\n+{\n+    typedef Iterator iterator_type;\n+    iterator_type\n+    operator()(Iterator it)\n+    {\n+        return it;\n+    }\n+};\n+\n+// Check if the iterator is reverse iterator\n+// Note: it works only for iterators that created by std::reverse_iterator\n+template <typename NotReverseIterator>\n+struct isReverse : std::false_type\n+{\n+};\n+\n+template <typename Iterator>\n+struct isReverse<std::reverse_iterator<Iterator>> : std::true_type\n+{\n+};\n+\n+// Reverse adapter\n+template <typename Iterator, typename IsReverse>\n+struct ReverseAdapter\n+{\n+    typedef std::reverse_iterator<Iterator> iterator_type;\n+    iterator_type\n+    operator()(Iterator it)\n+    {\n+#if __PSTL_CPP14_MAKE_REVERSE_ITERATOR_PRESENT\n+        return std::make_reverse_iterator(it);\n+#else\n+        return iterator_type(it);\n+#endif\n+    }\n+};\n+\n+// Non-reverse adapter\n+template <typename Iterator>\n+struct ReverseAdapter<Iterator, std::false_type> : BaseAdapter<Iterator>\n+{\n+};\n+\n+// Iterator adapter by type (by default std::random_access_iterator_tag)\n+template <typename Iterator, typename IteratorTag>\n+struct IteratorTypeAdapter : BaseAdapter<Iterator>\n+{\n+};\n+\n+// Iterator adapter for forward iterator\n+template <typename Iterator>\n+struct IteratorTypeAdapter<Iterator, std::forward_iterator_tag>\n+{\n+    typedef ForwardIterator<Iterator, std::forward_iterator_tag> iterator_type;\n+    iterator_type\n+    operator()(Iterator it)\n+    {\n+        return iterator_type(it);\n+    }\n+};\n+\n+// Iterator adapter for bidirectional iterator\n+template <typename Iterator>\n+struct IteratorTypeAdapter<Iterator, std::bidirectional_iterator_tag>\n+{\n+    typedef BidirectionalIterator<Iterator, std::bidirectional_iterator_tag> iterator_type;\n+    iterator_type\n+    operator()(Iterator it)\n+    {\n+        return iterator_type(it);\n+    }\n+};\n+\n+//For creating iterator with new type\n+template <typename InputIterator, typename IteratorTag, typename IsReverse>\n+struct MakeIterator\n+{\n+    typedef IteratorTypeAdapter<InputIterator, IteratorTag> IterByType;\n+    typedef ReverseAdapter<typename IterByType::iterator_type, IsReverse> ReverseIter;\n+\n+    typename ReverseIter::iterator_type\n+    operator()(InputIterator it)\n+    {\n+        return ReverseIter()(IterByType()(it));\n+    }\n+};\n+\n+// Useful constant variables\n+constexpr std::size_t GuardSize = 5;\n+constexpr std::ptrdiff_t sizeLimit = 1000;\n+\n+template <typename Iter, typename Void = void> // local iterator_traits for non-iterators\n+struct iterator_traits_\n+{\n+};\n+\n+template <typename Iter> // For iterators\n+struct iterator_traits_<Iter,\n+                        typename std::enable_if<!std::is_void<typename Iter::iterator_category>::value, void>::type>\n+{\n+    typedef typename Iter::iterator_category iterator_category;\n+};\n+\n+template <typename T> // For pointers\n+struct iterator_traits_<T*>\n+{\n+    typedef std::random_access_iterator_tag iterator_category;\n+};\n+\n+// is iterator Iter has tag Tag\n+template <typename Iter, typename Tag>\n+using is_same_iterator_category = std::is_same<typename iterator_traits_<Iter>::iterator_category, Tag>;\n+\n+// if we run with reverse or const iterators we shouldn't test the large range\n+template <typename IsReverse, typename IsConst>\n+struct invoke_if_\n+{\n+    template <typename Op, typename... Rest>\n+    void\n+    operator()(bool is_allow, Op op, Rest&&... rest)\n+    {\n+        if (is_allow)\n+            op(std::forward<Rest>(rest)...);\n+    }\n+};\n+template <>\n+struct invoke_if_<std::false_type, std::false_type>\n+{\n+    template <typename Op, typename... Rest>\n+    void\n+    operator()(bool is_allow, Op op, Rest&&... rest)\n+    {\n+        op(std::forward<Rest>(rest)...);\n+    }\n+};\n+\n+// Base non_const_wrapper struct. It is used to distinguish non_const testcases\n+// from a regular one. For non_const testcases only compilation is checked.\n+struct non_const_wrapper\n+{\n+};\n+\n+// Generic wrapper to specify iterator type to execute callable Op on.\n+// The condition can be either positive(Op is executed only with IteratorTag)\n+// or negative(Op is executed with every type of iterators except IteratorTag)\n+template <typename Op, typename IteratorTag, bool IsPositiveCondition = true>\n+struct non_const_wrapper_tagged : non_const_wrapper\n+{\n+    template <typename Policy, typename Iterator>\n+    typename std::enable_if<IsPositiveCondition == is_same_iterator_category<Iterator, IteratorTag>::value, void>::type\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+        Op()(exec, iter);\n+    }\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator>\n+    typename std::enable_if<IsPositiveCondition == is_same_iterator_category<OutputIterator, IteratorTag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, InputIterator input_iter, OutputIterator out_iter)\n+    {\n+        Op()(exec, input_iter, out_iter);\n+    }\n+\n+    template <typename Policy, typename Iterator>\n+    typename std::enable_if<IsPositiveCondition != is_same_iterator_category<Iterator, IteratorTag>::value, void>::type\n+    operator()(Policy&& exec, Iterator iter)\n+    {\n+    }\n+\n+    template <typename Policy, typename InputIterator, typename OutputIterator>\n+    typename std::enable_if<IsPositiveCondition != is_same_iterator_category<OutputIterator, IteratorTag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, InputIterator input_iter, OutputIterator out_iter)\n+    {\n+    }\n+};\n+\n+// These run_for_* structures specify with which types of iterators callable object Op\n+// should be executed.\n+template <typename Op>\n+struct run_for_rnd : non_const_wrapper_tagged<Op, std::random_access_iterator_tag>\n+{\n+};\n+\n+template <typename Op>\n+struct run_for_rnd_bi : non_const_wrapper_tagged<Op, std::forward_iterator_tag, false>\n+{\n+};\n+\n+template <typename Op>\n+struct run_for_rnd_fw : non_const_wrapper_tagged<Op, std::bidirectional_iterator_tag, false>\n+{\n+};\n+\n+// Invoker for different types of iterators.\n+template <typename IteratorTag, typename IsReverse>\n+struct iterator_invoker\n+{\n+    template <typename Iterator>\n+    using make_iterator = MakeIterator<Iterator, IteratorTag, IsReverse>;\n+    template <typename Iterator>\n+    using IsConst = typename std::is_const<\n+        typename std::remove_pointer<typename std::iterator_traits<Iterator>::pointer>::type>::type;\n+    template <typename Iterator>\n+    using invoke_if = invoke_if_<IsReverse, IsConst<Iterator>>;\n+\n+    // A single iterator version which is used for non_const testcases\n+    template <typename Policy, typename Op, typename Iterator>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value &&\n+                                std::is_base_of<non_const_wrapper, Op>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, Iterator iter)\n+    {\n+        op(std::forward<Policy>(exec), make_iterator<Iterator>()(iter));\n+    }\n+\n+    // A version with 2 iterators which is used for non_const testcases\n+    template <typename Policy, typename Op, typename InputIterator, typename OutputIterator>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value &&\n+                                std::is_base_of<non_const_wrapper, Op>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator input_iter, OutputIterator out_iter)\n+    {\n+        op(std::forward<Policy>(exec), make_iterator<InputIterator>()(input_iter),\n+           make_iterator<OutputIterator>()(out_iter));\n+    }\n+\n+    template <typename Policy, typename Op, typename Iterator, typename Size, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, Op op, Iterator begin, Size n, Rest&&... rest)\n+    {\n+        invoke_if<Iterator>()(n <= sizeLimit, op, exec, make_iterator<Iterator>()(begin), n,\n+                              std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename Iterator, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value &&\n+                                !std::is_base_of<non_const_wrapper, Op>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, Iterator inputBegin, Iterator inputEnd, Rest&&... rest)\n+    {\n+        invoke_if<Iterator>()(std::distance(inputBegin, inputEnd) <= sizeLimit, op, exec,\n+                              make_iterator<Iterator>()(inputBegin), make_iterator<Iterator>()(inputEnd),\n+                              std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename InputIterator, typename OutputIterator, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator inputBegin, InputIterator inputEnd, OutputIterator outputBegin,\n+               Rest&&... rest)\n+    {\n+        invoke_if<InputIterator>()(std::distance(inputBegin, inputEnd) <= sizeLimit, op, exec,\n+                                   make_iterator<InputIterator>()(inputBegin), make_iterator<InputIterator>()(inputEnd),\n+                                   make_iterator<OutputIterator>()(outputBegin), std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename InputIterator, typename OutputIterator, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator inputBegin, InputIterator inputEnd, OutputIterator outputBegin,\n+               OutputIterator outputEnd, Rest&&... rest)\n+    {\n+        invoke_if<InputIterator>()(std::distance(inputBegin, inputEnd) <= sizeLimit, op, exec,\n+                                   make_iterator<InputIterator>()(inputBegin), make_iterator<InputIterator>()(inputEnd),\n+                                   make_iterator<OutputIterator>()(outputBegin),\n+                                   make_iterator<OutputIterator>()(outputEnd), std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename InputIterator1, typename InputIterator2, typename OutputIterator,\n+              typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator1 inputBegin1, InputIterator1 inputEnd1, InputIterator2 inputBegin2,\n+               InputIterator2 inputEnd2, OutputIterator outputBegin, OutputIterator outputEnd, Rest&&... rest)\n+    {\n+        invoke_if<InputIterator1>()(\n+            std::distance(inputBegin1, inputEnd1) <= sizeLimit, op, exec, make_iterator<InputIterator1>()(inputBegin1),\n+            make_iterator<InputIterator1>()(inputEnd1), make_iterator<InputIterator2>()(inputBegin2),\n+            make_iterator<InputIterator2>()(inputEnd2), make_iterator<OutputIterator>()(outputBegin),\n+            make_iterator<OutputIterator>()(outputEnd), std::forward<Rest>(rest)...);\n+    }\n+};\n+\n+// Invoker for reverse iterators only\n+// Note: if we run with reverse iterators we shouldn't test the large range\n+template <typename IteratorTag>\n+struct iterator_invoker<IteratorTag, /* IsReverse = */ std::true_type>\n+{\n+\n+    template <typename Iterator>\n+    using make_iterator = MakeIterator<Iterator, IteratorTag, std::true_type>;\n+\n+    // A single iterator version which is used for non_const testcases\n+    template <typename Policy, typename Op, typename Iterator>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value &&\n+                                std::is_base_of<non_const_wrapper, Op>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, Iterator iter)\n+    {\n+        op(std::forward<Policy>(exec), make_iterator<Iterator>()(iter));\n+    }\n+\n+    // A version with 2 iterators which is used for non_const testcases\n+    template <typename Policy, typename Op, typename InputIterator, typename OutputIterator>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value &&\n+                                std::is_base_of<non_const_wrapper, Op>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator input_iter, OutputIterator out_iter)\n+    {\n+        op(std::forward<Policy>(exec), make_iterator<InputIterator>()(input_iter),\n+           make_iterator<OutputIterator>()(out_iter));\n+    }\n+\n+    template <typename Policy, typename Op, typename Iterator, typename Size, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value, void>::type\n+    operator()(Policy&& exec, Op op, Iterator begin, Size n, Rest&&... rest)\n+    {\n+        if (n <= sizeLimit)\n+            op(exec, make_iterator<Iterator>()(begin + n), n, std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename Iterator, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<Iterator, std::random_access_iterator_tag>::value &&\n+                                !std::is_base_of<non_const_wrapper, Op>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, Iterator inputBegin, Iterator inputEnd, Rest&&... rest)\n+    {\n+        if (std::distance(inputBegin, inputEnd) <= sizeLimit)\n+            op(exec, make_iterator<Iterator>()(inputEnd), make_iterator<Iterator>()(inputBegin),\n+               std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename InputIterator, typename OutputIterator, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator inputBegin, InputIterator inputEnd, OutputIterator outputBegin,\n+               Rest&&... rest)\n+    {\n+        if (std::distance(inputBegin, inputEnd) <= sizeLimit)\n+            op(exec, make_iterator<InputIterator>()(inputEnd), make_iterator<InputIterator>()(inputBegin),\n+               make_iterator<OutputIterator>()(outputBegin + (inputEnd - inputBegin)), std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename InputIterator, typename OutputIterator, typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator inputBegin, InputIterator inputEnd, OutputIterator outputBegin,\n+               OutputIterator outputEnd, Rest&&... rest)\n+    {\n+        if (std::distance(inputBegin, inputEnd) <= sizeLimit)\n+            op(exec, make_iterator<InputIterator>()(inputEnd), make_iterator<InputIterator>()(inputBegin),\n+               make_iterator<OutputIterator>()(outputEnd), make_iterator<OutputIterator>()(outputBegin),\n+               std::forward<Rest>(rest)...);\n+    }\n+\n+    template <typename Policy, typename Op, typename InputIterator1, typename InputIterator2, typename OutputIterator,\n+              typename... Rest>\n+    typename std::enable_if<is_same_iterator_category<OutputIterator, std::random_access_iterator_tag>::value,\n+                            void>::type\n+    operator()(Policy&& exec, Op op, InputIterator1 inputBegin1, InputIterator1 inputEnd1, InputIterator2 inputBegin2,\n+               InputIterator2 inputEnd2, OutputIterator outputBegin, OutputIterator outputEnd, Rest&&... rest)\n+    {\n+        if (std::distance(inputBegin1, inputEnd1) <= sizeLimit)\n+            op(exec, make_iterator<InputIterator1>()(inputEnd1), make_iterator<InputIterator1>()(inputBegin1),\n+               make_iterator<InputIterator2>()(inputEnd2), make_iterator<InputIterator2>()(inputBegin2),\n+               make_iterator<OutputIterator>()(outputEnd), make_iterator<OutputIterator>()(outputBegin),\n+               std::forward<Rest>(rest)...);\n+    }\n+};\n+\n+// We can't create reverse iterator from forward iterator\n+template <>\n+struct iterator_invoker<std::forward_iterator_tag, /*isReverse=*/std::true_type>\n+{\n+    template <typename... Rest>\n+    void\n+    operator()(Rest&&... rest)\n+    {\n+    }\n+};\n+\n+template <typename IsReverse>\n+struct reverse_invoker\n+{\n+    template <typename... Rest>\n+    void\n+    operator()(Rest&&... rest)\n+    {\n+        // Random-access iterator\n+        iterator_invoker<std::random_access_iterator_tag, IsReverse>()(std::forward<Rest>(rest)...);\n+\n+        // Forward iterator\n+        iterator_invoker<std::forward_iterator_tag, IsReverse>()(std::forward<Rest>(rest)...);\n+\n+        // Bidirectional iterator\n+        iterator_invoker<std::bidirectional_iterator_tag, IsReverse>()(std::forward<Rest>(rest)...);\n+    }\n+};\n+\n+struct invoke_on_all_iterator_types\n+{\n+    template <typename... Rest>\n+    void\n+    operator()(Rest&&... rest)\n+    {\n+        reverse_invoker</* IsReverse = */ std::false_type>()(std::forward<Rest>(rest)...);\n+        reverse_invoker</* IsReverse = */ std::true_type>()(std::forward<Rest>(rest)...);\n+    }\n+};\n+//============================================================================\n+\n+// Invoke op(policy,rest...) for each possible policy.\n+template <typename Op, typename... T>\n+void\n+invoke_on_all_policies(Op op, T&&... rest)\n+{\n+    using namespace __pstl::execution;\n+\n+    // Try static execution policies\n+    invoke_on_all_iterator_types()(seq, op, std::forward<T>(rest)...);\n+    invoke_on_all_iterator_types()(unseq, op, std::forward<T>(rest)...);\n+#if __PSTL_USE_PAR_POLICIES\n+    invoke_on_all_iterator_types()(par, op, std::forward<T>(rest)...);\n+    invoke_on_all_iterator_types()(par_unseq, op, std::forward<T>(rest)...);\n+#endif\n+}\n+\n+template <typename F>\n+struct NonConstAdapter\n+{\n+    F my_f;\n+    NonConstAdapter(const F& f) : my_f(f) {}\n+\n+    template <typename... Types>\n+    auto\n+    operator()(Types&&... args) -> decltype(std::declval<F>().\n+                                            operator()(std::forward<Types>(args)...))\n+    {\n+        return my_f(std::forward<Types>(args)...);\n+    }\n+};\n+\n+template <typename F>\n+NonConstAdapter<F>\n+non_const(const F& f)\n+{\n+    return NonConstAdapter<F>(f);\n+}\n+\n+// Wrapper for types. It's need for counting of constructing and destructing objects\n+template <typename T>\n+class Wrapper\n+{\n+  public:\n+    Wrapper()\n+    {\n+        my_field = std::shared_ptr<T>(new T());\n+        ++my_count;\n+    }\n+    Wrapper(const T& input)\n+    {\n+        my_field = std::shared_ptr<T>(new T(input));\n+        ++my_count;\n+    }\n+    Wrapper(const Wrapper& input)\n+    {\n+        my_field = input.my_field;\n+        ++my_count;\n+    }\n+    Wrapper(Wrapper&& input)\n+    {\n+        my_field = input.my_field;\n+        input.my_field = nullptr;\n+        ++move_count;\n+    }\n+    Wrapper&\n+    operator=(const Wrapper& input)\n+    {\n+        my_field = input.my_field;\n+        return *this;\n+    }\n+    Wrapper&\n+    operator=(Wrapper&& input)\n+    {\n+        my_field = input.my_field;\n+        input.my_field = nullptr;\n+        ++move_count;\n+        return *this;\n+    }\n+    bool\n+    operator==(const Wrapper& input) const\n+    {\n+        return my_field == input.my_field;\n+    }\n+    bool\n+    operator<(const Wrapper& input) const\n+    {\n+        return *my_field < *input.my_field;\n+    }\n+    bool\n+    operator>(const Wrapper& input) const\n+    {\n+        return *my_field > *input.my_field;\n+    }\n+    friend std::ostream&\n+    operator<<(std::ostream& stream, const Wrapper& input)\n+    {\n+        return stream << *(input.my_field);\n+    }\n+    ~Wrapper()\n+    {\n+        --my_count;\n+        if (move_count > 0)\n+        {\n+            --move_count;\n+        }\n+    }\n+    T*\n+    get_my_field() const\n+    {\n+        return my_field.get();\n+    };\n+    static size_t\n+    Count()\n+    {\n+        return my_count;\n+    }\n+    static size_t\n+    MoveCount()\n+    {\n+        return move_count;\n+    }\n+    static void\n+    SetCount(const size_t& n)\n+    {\n+        my_count = n;\n+    }\n+    static void\n+    SetMoveCount(const size_t& n)\n+    {\n+        move_count = n;\n+    }\n+\n+  private:\n+    static std::atomic<size_t> my_count;\n+    static std::atomic<size_t> move_count;\n+    std::shared_ptr<T> my_field;\n+};\n+\n+template <typename T>\n+std::atomic<size_t> Wrapper<T>::my_count = {0};\n+\n+template <typename T>\n+std::atomic<size_t> Wrapper<T>::move_count = {0};\n+\n+template <typename InputIterator, typename T, typename BinaryOperation, typename UnaryOperation>\n+T\n+transform_reduce_serial(InputIterator first, InputIterator last, T init, BinaryOperation binary_op,\n+                        UnaryOperation unary_op) noexcept\n+{\n+    for (; first != last; ++first)\n+    {\n+        init = binary_op(init, unary_op(*first));\n+    }\n+    return init;\n+}\n+\n+static const char*\n+done()\n+{\n+#if __PSTL_TEST_SUCCESSFUL_KEYWORD\n+    return \"done\";\n+#else\n+    return \"passed\";\n+#endif\n+}\n+\n+// test_algo_basic_* functions are used to execute\n+// f on a very basic sequence of elements of type T.\n+\n+// Should be used with unary predicate\n+template <typename T, typename F>\n+static void\n+test_algo_basic_single(F&& f)\n+{\n+    size_t N = 10;\n+    Sequence<T> in(N, [](size_t v) -> T { return T(v); });\n+\n+    invoke_on_all_policies(f, in.begin());\n+}\n+\n+// Should be used with binary predicate\n+template <typename T, typename F>\n+static void\n+test_algo_basic_double(F&& f)\n+{\n+    size_t N = 10;\n+    Sequence<T> in(N, [](size_t v) -> T { return T(v); });\n+    Sequence<T> out(N, [](size_t v) -> T { return T(v); });\n+\n+    invoke_on_all_policies(f, in.begin(), out.begin());\n+}\n+\n+template <typename Policy, typename F>\n+static void\n+invoke_if(Policy&& p, F f)\n+{\n+#if __PSTL_ICC_16_VC14_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN || __PSTL_ICC_17_VC141_TEST_SIMD_LAMBDA_DEBUG_32_BROKEN\n+    __pstl::__internal::invoke_if_not(__pstl::__internal::allow_unsequenced<Policy>(), f);\n+#else\n+    f();\n+#endif\n+}\n+\n+} /* namespace TestUtils */"}]}