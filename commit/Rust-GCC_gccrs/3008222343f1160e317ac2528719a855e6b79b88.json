{"sha": "3008222343f1160e317ac2528719a855e6b79b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAwODIyMjM0M2YxMTYwZTMxN2FjMjUyODcxOWE4NTVlNmI3OWI4OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-14T21:40:37Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-14T21:40:37Z"}, "message": "(expand_call): If PCC_STATIC_STRUCT_RETURN and TARGET\nis zero, copy result from static location.\n\nFrom-SVN: r4677", "tree": {"sha": "c56a92464797ff565d349dbc15ae9afc62346b99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c56a92464797ff565d349dbc15ae9afc62346b99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3008222343f1160e317ac2528719a855e6b79b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3008222343f1160e317ac2528719a855e6b79b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3008222343f1160e317ac2528719a855e6b79b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3008222343f1160e317ac2528719a855e6b79b88/comments", "author": null, "committer": null, "parents": [{"sha": "34f921d8b8d544df586cc45d0c3e72928bddeaaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f921d8b8d544df586cc45d0c3e72928bddeaaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f921d8b8d544df586cc45d0c3e72928bddeaaa"}], "stats": {"total": 22, "additions": 14, "deletions": 8}, "files": [{"sha": "03dbdfbc97d5824df439cc4dded14851e1b92ce5", "filename": "gcc/calls.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3008222343f1160e317ac2528719a855e6b79b88/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3008222343f1160e317ac2528719a855e6b79b88/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3008222343f1160e317ac2528719a855e6b79b88", "patch": "@@ -1838,15 +1838,21 @@ expand_call (exp, target, ignore)\n     {\n       if (target == 0)\n \t{\n-\t  target = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t    copy_to_reg (valreg));\n-\t  MEM_IN_STRUCT_P (target)\n-\t    = (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n-\t       || TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-\t       || TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE\n-\t       || TREE_CODE (TREE_TYPE (exp)) == QUAL_UNION_TYPE);\n+\t  /* We used leave the value in the location that it is\n+\t     returned in, but that causes problems if it is used more\n+\t     than once in one expression.  Rather than trying to track\n+\t     when a copy is required, we always copy when TARGET is\n+\t     not specified.  This calling sequence is only used on\n+\t     a few machines and TARGET is usually nonzero.  */\n+\t  if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n+\t    target = assign_stack_temp (BLKmode,\n+\t\t\t\t\tint_size_in_bytes (TREE_TYPE (exp)),\n+\t\t\t\t\t1);\n+\t  else\n+\t    target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n \t}\n-      else if (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n+\n+      if (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n \temit_move_insn (target, gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t\t\t copy_to_reg (valreg)));\n       else"}]}