{"sha": "2ce86d2eb54f42359291f388a833fa05b6f1bf19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlODZkMmViNTRmNDIzNTkyOTFmMzg4YTgzM2ZhMDViNmYxYmYxOQ==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-06-21T19:36:47Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-06-21T19:36:47Z"}, "message": "Implemented Cilk Plus Array Notation for C++\n\nImplemented Cilk Plus Array Notation for C++ \ngcc/c-family/ChangeLog\n2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-common.h (struct cilkplus_an_parts): New structure.\n        (struct cilkplus_an_loop_parts): Likewise.\n        (cilkplus_extract_an_triplets): New prototype.\n        (fix_sec_implicit_args): Likewise.\n        * array-notation-common.c (cilkplus_extract_an_triplets): New function.\n        (fix_sec_implicit_args): Likewise.\n\ngcc/cp/ChangeLog\n2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * call.c (convert_like_real): Added a check if array notation is present\n        in expression.  If so, then no conversion of arguments is necessary.\n        (build_over_call): Likewise.\n        * typeck.c (cp_build_function_call_vec): Likewise.\n        (convert_for_assignment): Likewise.\n        (cp_build_array_ref): Reject array notations with a rank greater than 1\n        as an array's index.\n        (cp_build_binary_op): If array notations are preent in op, then call\n        find_correct_array_notation_type.\n        (cp_build_addr_expr_1): Handle ARRAY_NOTATION_REF similar to ARRAY_REF.\n        * cp-array-notation.c: New file.\n        * cp-objcp-common.c (cp_common_init_ts): Marked ARRAY_NOTATION_REF tree\n        as typed.\n        * cp-tree.h (fix_array_notation_exprs): New prototype.\n        * semantics.c (finish_return_stmt): Reject array notations as\n        return value.\n        (cxx_eval_constant_expression): Added ARRAY_NOTATION_REF case.\n        (potential_constant_expression_1): Likewise.\n        * tree.c (lvalue_kind): Likewise.\n        * error.c (dump_decl): Likewise.\n        (dump_expr): Likewise.\n        * pt.c (ARRAY_NOTATION_REF): Likewise.\n        (type_unification_real): Do not unify any arguments if array notations\n        are found in arg.\n        (instantiate_decl): Added a check for array notaitons inside the\n        function body.  If so, then expand them.\n        * parser.c (cp_parser_array_notation): New function.\n        (cp_parser_postfix_open_square_expression): Added a check for colons\n        inside square braces.  If found, then handle the array access as an\n        array notation access.  Also, disable auto-correction from a single\n        colon to scope when Cilk Plus is enabled.\n        (cp_parser_compound_statement): Added a check for array notations\n        inside the statement.  If found, then expand them.\n        (cp_parser_ctor_initializer_opt_and_function_body): Likewise.\n        (cp_parser_function_definition_after_declarator): Likewise.\n        (cp_parser_selection_statement): Searched for array notations inside\n        condition.  If so, then emit an error.\n        (cp_parser_iteration_statement): Likewise.\n        (cp_parser_direct_declarator): Reject array notations inside a\n        variable or array declaration.\n        * Make-lang.in (CXX_AND_OBJCXX_OBJS): Added cp/cp-array-notation.o.\n\ngcc/testsuite/ChangeLog\n2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-c++-common/cilk-plus/AN/array_test1.c: Make this an execution test.\n        Also changed the returns from error as distinct values so that debugging\n        can get easier.\n        * c-c++-common/cilk-plus/AN/if_test_errors.c (main): Made certain\n        errors specific to C, if necessary.  Also added new error hooks for C++.\n        * c-c++-common/cilk-plus/AN/misc.c (main): Likewise.\n        * c-c++-common/cilk-plus/AN/parser_errors.c (main): Likewise.\n        * c-c++-common/cilk-plus/AN/parser_errors2.c (main): Likewise.\n        * c-c++-common/cilk-plus/AN/parser_errors3.c (main): Likewise.\n        * c-c++-common/cilk-plus/AN/pr57541.c (main): Likewise.\n        * c-c++-common/cilk-plus/AN/parser_errors4.c (main): In addition to the\n        same changes as parser_errors3.c, spaces were added between colons to\n        not confuse C++ compiler with 2 colons as scope.\n        * c-c++-common/cilk-plus/AN/vla.c: Make this test C specific.\n        * g++.dg/cilk-plus/AN/array_test1_tplt.cc: New test.\n        * g++.dg/cilk-plus/AN/array_test2_tplt.cc: Likewise.\n        * g++.dg/cilk-plus/AN/array_test_ND_tplt.cc: Likewise.\n        * g++.dg/cilk-plus/AN/braced_list.cc: Likewise.\n        * g++.dg/cilk-plus/AN/builtin_fn_custom_tplt.cc: Likewise.\n        * g++.dg/cilk-plus/AN/builtin_fn_mutating_tplt.cc: Likewise.\n        * g++.dg/cilk-plus/AN/fp_triplet_values_tplt.c: Likewise.\n        * g++.dg/cilk-plus/AN/preincr_test.cc: Likewise.\n        * g++.dg/cilk-plus/AN/postincr_test.cc: Likewise.\n        * g++.dg/cilk-plus/cilk-plus.exp: New script.\n        * gcc/testsuite/g++.dg/dg.exp: Included Cilk Plus C++ tests in the list.\n\nFrom-SVN: r200319", "tree": {"sha": "e7207dc359e56d6ee18d5ceeab12e6a330340857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7207dc359e56d6ee18d5ceeab12e6a330340857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ce86d2eb54f42359291f388a833fa05b6f1bf19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce86d2eb54f42359291f388a833fa05b6f1bf19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce86d2eb54f42359291f388a833fa05b6f1bf19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce86d2eb54f42359291f388a833fa05b6f1bf19/comments", "author": null, "committer": null, "parents": [{"sha": "fa1e55b0a0c843b58c6e628fb3c29afa36fcf778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1e55b0a0c843b58c6e628fb3c29afa36fcf778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1e55b0a0c843b58c6e628fb3c29afa36fcf778"}], "stats": {"total": 3267, "additions": 3182, "deletions": 85}, "files": [{"sha": "224e27be67959c763115b442bb84a13826ba62dc", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -1,3 +1,12 @@\n+2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-common.h (struct cilkplus_an_parts): New structure.\n+\t(struct cilkplus_an_loop_parts): Likewise.\n+\t(cilkplus_extract_an_triplets): New prototype.\n+\t(fix_sec_implicit_args): Likewise.\n+\t* array-notation-common.c (cilkplus_extract_an_triplets): New function.\n+\t(fix_sec_implicit_args): Likewise.\n+\t\n 2013-06-20  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* array-notation-common.c (find_inv_trees): Removed an unwanted"}, {"sha": "0e2a43132f5c95c10de2a8ed2754eb68c0929acc", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -560,3 +560,100 @@ find_correct_array_notation_type (tree op)\n     } \n   return return_type;\n }\n+\n+/* Extracts all the array notation triplet information from LIST and stores\n+   them in the following fields of the 2-D array NODE(size x rank):\n+   START, LENGTH and STRIDE, holding the starting index, length, and stride,\n+   respectively.  In addition, it also sets two bool fields, IS_VECTOR and\n+   COUNT_DOWN, in NODE indicating whether a certain value at a certain field\n+   is a vector and if the array is accessed from high to low.  */\n+\n+void\n+cilkplus_extract_an_triplets (vec<tree, va_gc> *list, size_t size, size_t rank,\n+\t\t\t      vec<vec<struct cilkplus_an_parts> > *node)\n+{\n+  vec<vec<tree> > array_exprs = vNULL;\n+  struct cilkplus_an_parts init = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t    false };\n+  node->safe_grow_cleared (size);\n+  array_exprs.safe_grow_cleared (size);\n+  for (size_t ii = 0; ii < size; ii++)\n+    for (size_t jj = 0; jj < rank; jj++)\n+      {\n+\t(*node)[ii].safe_push (init);\n+\tarray_exprs[ii].safe_push (NULL_TREE);\n+      }\n+\n+  for (size_t ii = 0; ii < size; ii++)\n+    {\n+      size_t jj = 0;\n+      tree ii_tree = (*list)[ii];\n+      while (ii_tree)\n+\tif (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n+\t  {\n+\t    array_exprs[ii][jj] = ii_tree;\n+\t    jj++;\n+\t    ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t  }\n+\telse if (TREE_CODE (ii_tree) == ARRAY_REF)\n+\t  ii_tree = TREE_OPERAND (ii_tree, 0);\n+\telse if (TREE_CODE (ii_tree) == VAR_DECL\n+\t\t || TREE_CODE (ii_tree) == CALL_EXPR\n+\t\t || TREE_CODE (ii_tree) == PARM_DECL)\n+\t  break;\n+\telse\n+\t  gcc_unreachable ();\t\n+    }\n+    for (size_t ii = 0; ii < size; ii++)\n+      if (TREE_CODE ((*list)[ii]) == ARRAY_NOTATION_REF)\n+\tfor (size_t jj = 0; jj < rank; jj++)\n+\t  if (TREE_CODE (array_exprs[ii][jj]) == ARRAY_NOTATION_REF)\n+\t    {\n+\t      tree ii_tree = array_exprs[ii][jj];\n+\t      (*node)[ii][jj].is_vector = true;\n+\t      (*node)[ii][jj].value = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t      (*node)[ii][jj].start = ARRAY_NOTATION_START (ii_tree);\n+\t      (*node)[ii][jj].length =\n+\t\tfold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t     ARRAY_NOTATION_LENGTH (ii_tree));\n+\t      (*node)[ii][jj].stride =\n+\t\tfold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t     ARRAY_NOTATION_STRIDE (ii_tree));\n+\t    }\n+}\n+\n+/* Replaces all the __sec_implicit_arg functions in LIST with the induction\n+   variable stored in VAR at the appropriate location pointed by the\n+   __sec_implicit_arg's first parameter.  Emits an error if the parameter is\n+   not between 0 and RANK.  */\n+\n+vec <tree, va_gc> *\n+fix_sec_implicit_args (location_t loc, vec <tree, va_gc> *list,\n+\t\t       vec<an_loop_parts> an_loop_info, size_t rank,\n+\t\t       tree orig_stmt)\n+{\n+  vec <tree, va_gc> *array_operand = NULL;\n+  for (size_t ii = 0; ii < vec_safe_length (list); ii++)\n+    if (TREE_CODE ((*list)[ii]) == CALL_EXPR\n+\t&& TREE_CODE (CALL_EXPR_FN ((*list)[ii])) == ADDR_EXPR\n+\t&& is_sec_implicit_index_fn (CALL_EXPR_FN ((*list)[ii])))\n+      {\n+\tint idx = extract_sec_implicit_index_arg (loc, (*list)[ii]);\n+\tif (idx < (int) rank && idx >= 0)\n+\t  vec_safe_push (array_operand, an_loop_info[idx].var);\n+\telse if (idx == -1)\n+\t  /* In this case, the returning function would have emitted an\n+\t     error thus it is not necessary to do so again.  */\n+\t  return NULL;\n+\telse\n+\t  {\n+\t    error_at (loc, \"__sec_implicit_index argument %d must be \"\n+\t\t      \"less than the rank of %qE\", idx, orig_stmt);\n+\t    return NULL;\n+\t  }\n+      }\n+    else\n+      /* Save the existing value into the array operand.  */\n+      vec_safe_push (array_operand, (*list)[ii]);\n+  return array_operand;\n+}"}, {"sha": "95d3ccfd8456135a49354d08c1dc4931d4d0a941", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -1160,6 +1160,29 @@ struct inv_list\n   vec<enum tree_code, va_gc> *additional_tcodes; \n };\n \n+/* This structure holds all the important components that can be extracted\n+   from an ARRAY_NOTATION_REF expression.  It is used to pass array notation\n+   information between the functions that are responsible for expansion.  */\n+typedef struct cilkplus_an_parts\n+{\n+  tree value;\n+  tree start;\n+  tree length;\n+  tree stride;\n+  bool is_vector;\n+} an_parts;\n+\n+/* This structure holds the components necessary to create the loop around\n+   the ARRAY_REF that is created using the ARRAY_NOTATION information.  */\n+\n+typedef struct cilkplus_an_loop_parts\n+{\n+  tree var;         /* Loop induction variable.  */\n+  tree incr;        /* Loop increment/decrement expression.  */\n+  tree cmp;         /* Loop condition.  */\n+  tree ind_init;    /* Initialization of the loop induction variable.  */\n+} an_loop_parts; \n+\n /* In array-notation-common.c.  */\n extern HOST_WIDE_INT extract_sec_implicit_index_arg (location_t, tree);\n extern bool is_sec_implicit_index_fn (tree);\n@@ -1179,4 +1202,8 @@ extern void replace_array_notations (tree *, bool, vec<tree, va_gc> *,\n extern tree find_inv_trees (tree *, int *, void *);\n extern tree replace_inv_trees (tree *, int *, void *);\n extern tree find_correct_array_notation_type (tree op);\n+extern void cilkplus_extract_an_triplets (vec<tree, va_gc> *, size_t, size_t,\n+\t\t\t\t\t  vec<vec<an_parts> > *);\n+extern vec <tree, va_gc> *fix_sec_implicit_args\n+  (location_t, vec <tree, va_gc> *, vec<an_loop_parts>, size_t, tree);\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "b4f36b017eb2dc96e629558c594a977942391ae6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -1,3 +1,47 @@\n+2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* call.c (convert_like_real): Added a check if array notation is present\n+\tin expression.  If so, then no conversion of arguments is necessary.\n+\t(build_over_call): Likewise.\n+\t* typeck.c (cp_build_function_call_vec): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t(cp_build_array_ref): Reject array notations with a rank greater than 1\n+\tas an array's index.\n+\t(cp_build_binary_op): If array notations are preent in op, then call\n+\tfind_correct_array_notation_type.\n+\t(cp_build_addr_expr_1): Handle ARRAY_NOTATION_REF similar to ARRAY_REF.\n+\t* cp-array-notation.c: New file.\n+\t* cp-objcp-common.c (cp_common_init_ts): Marked ARRAY_NOTATION_REF tree\n+\tas typed.\n+\t* cp-tree.h (fix_array_notation_exprs): New prototype.\n+\t* semantics.c (finish_return_stmt): Reject array notations as\n+\treturn value.\n+\t(cxx_eval_constant_expression): Added ARRAY_NOTATION_REF case.\n+\t(potential_constant_expression_1): Likewise.\n+\t* tree.c (lvalue_kind): Likewise.\n+\t* error.c (dump_decl): Likewise.\n+\t(dump_expr): Likewise.\n+\t* pt.c (ARRAY_NOTATION_REF): Likewise.\n+\t(type_unification_real): Do not unify any arguments if array notations\n+\tare found in arg.\n+\t(instantiate_decl): Added a check for array notaitons inside the\n+\tfunction body.  If so, then expand them.\n+\t* parser.c (cp_parser_array_notation): New function.\n+\t(cp_parser_postfix_open_square_expression): Added a check for colons\n+\tinside square braces.  If found, then handle the array access as an\n+\tarray notation access.  Also, disable auto-correction from a single\n+\tcolon to scope when Cilk Plus is enabled.\n+\t(cp_parser_compound_statement): Added a check for array notations\n+\tinside the statement.  If found, then expand them.\n+\t(cp_parser_ctor_initializer_opt_and_function_body): Likewise.\n+\t(cp_parser_function_definition_after_declarator): Likewise.\n+\t(cp_parser_selection_statement): Searched for array notations inside\n+\tcondition.  If so, then emit an error.\n+\t(cp_parser_iteration_statement): Likewise.\n+\t(cp_parser_direct_declarator): Reject array notations inside a\n+\tvariable or array declaration.\n+\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Added cp/cp-array-notation.o.\n+\n 2013-06-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/55149"}, {"sha": "6e80bcf8c101cc8463713e670948239ffe7d8e1f", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -80,7 +80,7 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \\\n  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n- cp/cp-gimplify.o $(CXX_C_OBJS)\n+ cp/cp-gimplify.o cp/cp-array-notation.o $(CXX_C_OBJS)\n \n # Language-specific object files for C++.\n CXX_OBJS = cp/cp-lang.o c-family/stub-objc.o $(CXX_AND_OBJCXX_OBJS)\n@@ -266,6 +266,9 @@ CXX_PRETTY_PRINT_H = cp/cxx-pretty-print.h $(C_PRETTY_PRINT_H)\n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   $(C_PRAGMA_H) input.h cp/operators.def $(TM_P_H) \\\n   c-family/c-objc.h\n+cp/cp-array-notation.o: cp/cp-array-notation.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h $(TREE_H) $(CXX_TREE_H) $(DIAGNOSTIC_H) tree-iterator.h vec.h \\\n+  $(GIMPLE_H) c-family/array-notation-common.o $(C_COMMON_H) \n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) debug.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-cp.h gt-cp-cp-lang.h \\\n   cp/cp-objcp-common.h $(EXPR_H) $(TARGET_H) $(CXX_PARSER_H)"}, {"sha": "0c729e86626107de847b1fb3fd1b8ce96ce98632", "filename": "gcc/cp/call.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -5858,9 +5858,15 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    break;\n \t}\n \n-      if (permerror (loc, \"invalid conversion from %qT to %qT\",\n-\t\t     TREE_TYPE (expr), totype)\n-\t  && fn)\n+      if (flag_enable_cilkplus\n+\t  && (contains_array_notation_expr (expr)\n+\t      || contains_array_notation_expr (fn)))\n+\t/* If we are using array notations, we fix them up at a later stage\n+\t   and we will do these checks then.  */\n+\t;\n+      else if (permerror (loc, \"invalid conversion from %qT to %qT\",\n+\t\t\t  TREE_TYPE (expr), totype)\n+\t       && fn)\n \tinform (DECL_SOURCE_LOCATION (fn),\n \t\t\"initializing argument %P of %qD\", argnum, fn);\n \n@@ -6890,12 +6896,20 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    }\n \t}\n \n-      val = convert_like_with_context (conv, arg, fn, i-is_method,\n-\t                               conversion_warning\n-\t\t\t\t       ? complain\n-\t\t\t\t       : complain & (~tf_warning));\n+      /* If the function call is builtin array notation function then no need\n+\t to do any type conversion.  */\n+      if (flag_enable_cilkplus\n+\t  && is_cilkplus_reduce_builtin (fn) != BUILT_IN_NONE)\n+\tval = arg;\n+      else\n+\t{\n+\t  val = convert_like_with_context (conv, arg, fn, i - is_method,\n+\t\t\t\t\t   conversion_warning\n+\t\t\t\t\t   ? complain\n+\t\t\t\t\t   : complain & (~tf_warning));\n \n-      val = convert_for_arg_passing (type, val, complain);\n+\t  val = convert_for_arg_passing (type, val, complain);\n+\t}\n       if (val == error_mark_node)\n         return error_mark_node;\n       else"}, {"sha": "92272b332d19bef8454446e8a89735571b6ca446", "filename": "gcc/cp/cp-array-notation.c", "status": "added", "additions": 1547, "deletions": 0, "changes": 1547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,1547 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   It contains routines to handle Array Notation expression\n+   handling routines in the C++ Compiler.\n+   Copyright (C) 2013  Free Software Foundation, Inc.\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n+                  Intel Corporation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The Array Notation Transformation Technique:\n+\n+   An array notation expression has 4 major components:\n+   1. The array name\n+   2. Start Index\n+   3. Number of elements we need to acess (we call it length)\n+   4. Stride\n+\n+   So, if we have something like A[0:5:2], we are accessing A[0], A[2], A[4],\n+   A[6] and A[8]. The user is responsible to make sure the access length does\n+   not step outside the array's size.\n+   \n+   In this section, I highlight the overall method on how array notations are\n+   broken up into C/C++ code.  Almost all the functions follows this step:\n+\n+   Let's say the user has used the array notation in a statement like this:\n+\n+   A[St1:Ln:Str1] = B[St2:Ln:Str2] + <NON ARRAY_NOT STMT>\n+\n+   where St{1,2} = Starting index, Ln = Number of elements we need to access,\n+   and Str{1,2} = the stride.\n+   Note: The length of both the array notation expressions must be the same.\n+   \n+   The above expression is broken into the following:\n+\n+   for (Tmp_Var = 0; Tmp_Var < Ln; Tmp_Var++)\n+     A[St1 + Tmp_Var * Str1] = B[St1 + Tmp_Var * Str2] + <NON_ARRAY_NOT_STMT>;\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-iterator.h\"\n+#include \"vec.h\"\n+#include \"gimple.h\"\n+\n+/* Creates a FOR_STMT with INIT, COND, INCR and BODY as the initializer,\n+   condition, increment expression and the loop-body, respectively.  */\n+\n+static void\n+create_an_loop (tree init, tree cond, tree incr, tree body)\n+{\n+  tree for_stmt;\n+\n+  finish_expr_stmt (init);\n+  for_stmt = begin_for_stmt (NULL_TREE, NULL_TREE);\n+  finish_for_init_stmt (for_stmt);\n+  finish_for_cond (cond, for_stmt);\n+  finish_for_expr (incr, for_stmt);\n+  finish_expr_stmt (body);\n+  finish_for_stmt (for_stmt);\n+}\n+\n+/* Returns true if there is a length mismatch among exprssions that are at the\n+   same dimension and one the same side of the equal sign.  The Array notation\n+   lengths (LIST->LENGTH) is passed in as a 2D vector of trees.  */\n+\n+static bool\n+cp_length_mismatch_in_expr_p (location_t loc, vec<vec<an_parts> >list)\n+{\n+  size_t ii, jj;\n+  tree length = NULL_TREE;\n+  HOST_WIDE_INT l_length, l_node;\n+  \n+  size_t x = list.length ();\n+  size_t y = list[0].length ();\n+  \n+  for (jj = 0; jj < y; jj++)\n+    {\n+      length = NULL_TREE;\n+      for (ii = 0; ii < x; ii++)\n+\t{\n+\t  if (!length)\n+\t    length = list[ii][jj].length;\n+\t  else if (TREE_CODE (length) == INTEGER_CST)\n+\t    {\n+\t      /* If length is a INTEGER, and list[ii][jj] is an integer then\n+\t\t check if they are equal.  If they are not equal then return\n+\t\t true.  */\n+\t      if (TREE_CODE (list[ii][jj].length) == INTEGER_CST)\n+\t\t{\n+\t\t  l_node = int_cst_value (list[ii][jj].length);\n+\t\t  l_length = int_cst_value (length);\n+\t\t  if (absu_hwi (l_length) != absu_hwi (l_node))\n+\t\t    {\n+\t\t      error_at (loc, \"length mismatch in expression\");\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* We set the length node as the current node just in case it turns\n+\t       out to be an integer.  */\n+\t    length = list[ii][jj].length;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* If *VALUE is not a constant integer, then this function replaces it with\n+   a variable to make it loop invariant for array notations.  */\n+\n+static inline void\n+make_triplet_val_inv (location_t loc, tree *value, tsubst_flags_t cry)\n+{\n+  tree var;\n+  if (TREE_CODE (*value) != INTEGER_CST\n+      && TREE_CODE (*value) != PARM_DECL\n+      && TREE_CODE (*value) != VAR_DECL)\n+    {\n+      var = build_decl (loc, VAR_DECL, NULL_TREE, integer_type_node);\n+      finish_expr_stmt (build_x_modify_expr (loc, var, NOP_EXPR, *value, cry));\n+      *value = var;\n+    }\n+}\n+\n+/* Returns a vector of size RANK that contains an ARRAY_REF.  This vector is\n+   created using array notation-triplet information stored in AN_INFO. The\n+   induction var is taken from AN_LOOP_INFO.\n+\n+   For example: For an array notation A[5:10:2], the vector start will be\n+   of size 1 holding '5', stride of same size as start but holding the value of\n+   as 2, and is_vector as true.   Let's assume VAR is 'x'\n+   This function returns a vector of size 1 with the following data:\n+   A[5 + (x * 2)] .\n+*/\n+\n+static vec<tree, va_gc> *\n+create_array_refs (location_t loc, vec<vec<an_parts> > an_info,\n+\t\t   vec<an_loop_parts> an_loop_info, size_t size,  size_t rank)\n+{\n+  tree ind_mult, ind_incr;\n+  vec<tree, va_gc> *array_operand = NULL;\n+  for (size_t ii = 0; ii < size; ii++)\n+    if (an_info[ii][0].is_vector)\n+      {\n+\ttree array_opr = an_info[ii][rank - 1].value;\n+\tfor (int s_jj = rank -1; s_jj >= 0; s_jj--)\n+\t  {\n+\t    tree str = NULL_TREE, v = NULL_TREE, st = NULL_TREE;\n+\t    tree start = an_info[ii][s_jj].start;\n+\t    tree stride = an_info[ii][s_jj].stride;\n+\t    tree var = an_loop_info[s_jj].var;\n+\n+\t    /* If stride and start are of same type and the induction var\n+\t       is not, convert induction variable to stride's type.  */\n+\t    if (TREE_TYPE (start) == TREE_TYPE (stride)\n+\t\t&& TREE_TYPE (stride) != TREE_TYPE (var))\n+\t      {\n+\t\tst = start;\n+\t\tstr = stride;\n+\t\tv = build_c_cast (loc, TREE_TYPE (str), var);\n+\t      }\n+\t    else if (TREE_TYPE (start) != TREE_TYPE (stride))\n+\t      {\n+\t\t/* If we reach here, then the stride and start are of\n+\t\t   different types, and so it doesn't really matter what\n+\t\t   the induction variable type is, convert everything to \n+\t\t   integer.  The reason why we pick an integer\n+\t\t   instead of something like size_t is because the stride\n+\t\t   and length can be + or -.  */\n+\t\tst = build_c_cast (loc, integer_type_node, start);\n+\t\tstr = build_c_cast (loc, integer_type_node, stride);\n+\t\tv = build_c_cast (loc, integer_type_node, var);\n+\t      }\n+\t    else\n+\t      {\n+\t\tst = start;\n+\t\tstr = stride;\n+\t\tv = var;\n+\t      }\n+\n+\t    ind_mult = build2 (MULT_EXPR, TREE_TYPE (v), v, str);\n+\t    ind_incr = build2 (PLUS_EXPR, TREE_TYPE (v), st, ind_mult);\n+\t    /* Array [ start_index + (induction_var * stride)]  */\n+\t    array_opr = grok_array_decl\t(loc, array_opr, ind_incr, false);\n+\t  }\n+\tvec_safe_push (array_operand, array_opr);\n+      }\n+    else\n+      vec_safe_push (array_operand, integer_one_node);\n+  return array_operand;\n+}\n+\n+/* Populates the INCR and CMP fields in *NODE with the increment\n+   (of type POSTINCREMENT) and comparison (of TYPE LT_EXPR) expressions, using \n+   data from AN_INFO.  */\n+\n+void\n+create_cmp_incr (location_t loc, vec <an_loop_parts> *node, size_t rank, \n+\t\t vec<vec<an_parts> > an_info, tsubst_flags_t complain)\n+{\n+  for (size_t ii = 0; ii < rank; ii++)\n+    {\n+      (*node)[ii].incr = build_x_unary_op (loc, POSTINCREMENT_EXPR, \n+\t\t\t\t\t   (*node)[ii].var, complain);\n+      (*node)[ii].cmp = build_x_binary_op (loc, LT_EXPR, (*node)[ii].var,\n+\t\t\t\t\t   TREE_CODE ((*node)[ii].var),\n+\t\t\t\t\t   an_info[0][ii].length,\n+\t\t\t\t\t   TREE_CODE (an_info[0][ii].length),\n+\t\t\t\t\t   NULL, complain);\n+    }\n+}\n+\n+/* Replaces all the scalar expressions in *NODE.  Returns a STATEMENT LIST that\n+   holds the NODE along with the variables that hold the results of the\n+   invariant expressions.  */\n+\n+static tree\n+replace_invariant_exprs (tree *node)\n+{\n+  size_t ix = 0;\n+  tree node_list = NULL_TREE;\n+  tree t = NULL_TREE, new_var = NULL_TREE, new_node; \n+  struct inv_list data;\n+\n+  data.list_values = NULL;\n+  data.replacement = NULL;\n+  data.additional_tcodes = NULL;\n+  cp_walk_tree (node, find_inv_trees, (void *) &data, NULL);\n+\n+  if (vec_safe_length (data.list_values))\n+    {\n+      node_list = push_stmt_list ();\n+      for (ix = 0; vec_safe_iterate (data.list_values, ix, &t); ix++)\n+\t{\n+\t  if (processing_template_decl || !TREE_TYPE (t))\n+\t    new_var = build_min_nt_loc (EXPR_LOCATION (t), VAR_DECL, NULL_TREE,\n+\t\t\t\t       \tNULL_TREE);\n+\t  else\n+\t    new_var = build_decl (EXPR_LOCATION (t), VAR_DECL, NULL_TREE,\n+\t\t\t\t  TREE_TYPE (t));\n+\t  gcc_assert (new_var != NULL_TREE && new_var != error_mark_node);\n+\t  new_node = build_x_modify_expr (EXPR_LOCATION (t), new_var, NOP_EXPR,\n+\t\t\t\t\t  t, tf_warning_or_error);\n+\t  finish_expr_stmt (new_node);\n+\t  vec_safe_push (data.replacement, new_var);\n+\t}\n+      cp_walk_tree (node, replace_inv_trees, (void *) &data, NULL);\n+      node_list = pop_stmt_list (node_list);\n+    }\n+  return node_list;\n+}\n+\n+/* Replace array notation's built-in function passed in AN_BUILTIN_FN with\n+   the appropriate loop and computation (all stored in variable LOOP of type\n+   tree node).  The output of the function function is always a scalar and that\n+   result is returned in *NEW_VAR.  *NEW_VAR is NULL_TREE if the function is\n+   __sec_reduce_mutating.  */\n+\n+static tree\n+expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n+{\n+  tree new_var_type = NULL_TREE, func_parm, new_yes_expr, new_no_expr;\n+  tree array_ind_value = NULL_TREE, new_no_ind, new_yes_ind, new_no_list;\n+  tree new_yes_list, new_cond_expr, new_expr = NULL_TREE; \n+  tree new_var_init = NULL_TREE, new_exp_init = NULL_TREE;\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  size_t list_size = 0, rank = 0, ii = 0;\n+  tree  body, an_init, loop_with_init = alloc_stmt_list ();\n+  tree array_op0, comp_node = NULL_TREE;\n+  tree call_fn = NULL_TREE, identity_value = NULL_TREE;\n+  tree init = NULL_TREE, cond_init = NULL_TREE;\n+  enum tree_code code = NOP_EXPR;\n+  location_t location = UNKNOWN_LOCATION;\n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL; \n+  enum built_in_function an_type =\n+    is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n+  vec <tree, va_gc> *func_args;\n+  \n+  if (an_type == BUILT_IN_NONE)\n+    return NULL_TREE;\n+\n+  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE\n+      && an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    func_parm = CALL_EXPR_ARG (an_builtin_fn, 0);\n+  else\n+    {\n+      call_fn = CALL_EXPR_ARG (an_builtin_fn, 2);\n+\n+      /* We need to do this because we are \"faking\" the builtin function types,\n+\t so the compiler does a bunch of typecasts and this will get rid of\n+\t all that!  */\n+      STRIP_NOPS (call_fn);\n+      if (TREE_CODE (call_fn) != OVERLOAD\n+\t  && TREE_CODE (call_fn) != FUNCTION_DECL)\n+\tcall_fn = TREE_OPERAND (call_fn, 0);\n+      identity_value = CALL_EXPR_ARG (an_builtin_fn, 0);\n+      func_parm = CALL_EXPR_ARG (an_builtin_fn, 1);\n+      STRIP_NOPS (identity_value);\n+    }\n+  STRIP_NOPS (func_parm);\n+  \n+  location = EXPR_LOCATION (an_builtin_fn);\n+  \n+  /* Note about using find_rank (): If find_rank returns false, then it must\n+     have already reported an error, thus we just return an error_mark_node\n+     without any doing any error emission.  */  \n+  if (!find_rank (location, an_builtin_fn, an_builtin_fn, true, &rank))\n+      return error_mark_node;\n+  if (rank == 0)\n+    return an_builtin_fn;\n+  else if (rank > 1 \n+\t   && (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+\t       || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND))\n+    { \n+      error_at (location, \"__sec_reduce_min_ind or __sec_reduce_max_ind cannot \"\n+\t\t\"have arrays with dimension greater than 1\");\n+      return error_mark_node;\n+    }\n+  \n+  extract_array_notation_exprs (func_parm, true, &array_list);\n+  list_size = vec_safe_length (array_list);\n+  switch (an_type)\n+    {\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      new_var_type = TREE_TYPE ((*array_list)[0]);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+      new_var_type = integer_type_node;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+      new_var_type = size_type_node;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+      if (call_fn && identity_value)\n+\tnew_var_type = TREE_TYPE ((*array_list)[0]);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+      new_var_type = NULL_TREE;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+    \n+  if (new_var_type && TREE_CODE (new_var_type) == ARRAY_TYPE)\n+    new_var_type = TREE_TYPE (new_var_type);\n+  an_loop_info.safe_grow_cleared (rank);\n+\n+  an_init = push_stmt_list ();\n+\n+  /* Assign the array notation components to variable so that they can satisfy\n+     the exec-once rule.  */\n+  for (ii = 0; ii < list_size; ii++)\n+    if (TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n+      {\n+\ttree anode = (*array_list)[ii];\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (anode),\n+\t\t\t      tf_warning_or_error);\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (anode),\n+\t\t\t      tf_warning_or_error);\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (anode),\n+\t\t\t      tf_warning_or_error);\n+      }\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  TREE_TYPE (an_info[0][ii].start));\n+      an_loop_info[ii].ind_init = build_x_modify_expr\n+\t(location, an_loop_info[ii].var, NOP_EXPR, \n+\t build_zero_cst (TREE_TYPE (an_loop_info[ii].var)),\n+\t tf_warning_or_error);\n+    }\n+  \n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t      list_size, rank);\n+  replace_array_notations (&func_parm, true, array_list, array_operand);\n+  \n+  if (!TREE_TYPE (func_parm))      \n+    TREE_TYPE (func_parm) = TREE_TYPE ((*array_list)[0]);\n+  \n+  create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n+  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    {\n+      if (processing_template_decl)\n+\t*new_var = build_decl (location, VAR_DECL, NULL_TREE, new_var_type);\n+      else\n+\t*new_var = create_tmp_var (new_var_type, NULL);\n+    }\n+  else\n+    /* We do not require a new variable for mutating.  The \"identity value\"\n+       itself is the variable.  */\n+    *new_var = NULL_TREE;\n+  \n+  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n+    {\n+      array_ind_value = create_tmp_var (TREE_TYPE (func_parm), NULL);\n+      gcc_assert (array_ind_value && (array_ind_value != error_mark_node));\n+      DECL_INITIAL (array_ind_value) = NULL_TREE;\n+      pushdecl (array_ind_value);\n+    }\n+\n+  array_op0 = (*array_operand)[0];\n+  switch (an_type)\n+    {\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+      code = PLUS_EXPR;\n+      init = build_zero_cst (new_var_type);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n+      code = MULT_EXPR;\n+      init = build_one_cst (new_var_type);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+      code = (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO) ? EQ_EXPR\n+\t: NE_EXPR;\n+      init = build_zero_cst (new_var_type);\n+      cond_init = build_one_cst (new_var_type);\n+      comp_node = build_zero_cst (TREE_TYPE (func_parm));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+      code = (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO) ? NE_EXPR\n+\t: EQ_EXPR;\n+      init = build_one_cst (new_var_type);\n+      cond_init = build_zero_cst (new_var_type);\n+      comp_node = build_zero_cst (TREE_TYPE (func_parm));\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+      code = MAX_EXPR;\n+      init = TYPE_MIN_VALUE (new_var_type) ? TYPE_MIN_VALUE (new_var_type)\n+\t: func_parm;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      code = MIN_EXPR;\n+      init = TYPE_MAX_VALUE (new_var_type) ? TYPE_MAX_VALUE (new_var_type)\n+\t: func_parm;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+      code = an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND ? LE_EXPR\n+\t: GE_EXPR;\n+      init = an_loop_info[0].var;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+      init = identity_value;\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+      init = NULL_TREE;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (init)\n+    new_var_init = build_x_modify_expr (location, *new_var, NOP_EXPR, init,\n+\t\t\t\t\ttf_warning_or_error);\n+  switch (an_type)\n+    {\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:      \n+      new_expr = build_x_modify_expr (location, *new_var, code, func_parm,\n+\t\t\t\t      tf_warning_or_error);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n+      /* In all these cases, assume the false case is true and as soon as\n+\t we find a true case,  set the true flag on and latch it in.  */\n+      new_yes_expr = build_x_modify_expr (location, *new_var, NOP_EXPR,\n+\t\t\t\t\t  cond_init, tf_warning_or_error);\n+      new_no_expr = build_x_modify_expr (location, *new_var, NOP_EXPR,\n+\t\t\t\t\t *new_var, tf_warning_or_error);\n+      new_cond_expr = build_x_binary_op\n+\t(location, code, func_parm, TREE_CODE (func_parm), comp_node,\n+\t TREE_CODE (comp_node), NULL, tf_warning_or_error);\n+      new_expr = build_x_conditional_expr (location, new_cond_expr,\n+\t\t\t\t\t   new_yes_expr, new_no_expr,\n+\t\t\t\t\t   tf_warning_or_error);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n+      new_cond_expr = build_x_binary_op\n+\t(location, code, *new_var, TREE_CODE (*new_var), func_parm,\n+\t TREE_CODE (func_parm), NULL, tf_warning_or_error);\n+      new_expr = build_x_modify_expr (location, *new_var, NOP_EXPR, func_parm,\n+\t\t\t\t      tf_warning_or_error);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n+      new_exp_init = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n+\t\t\t\t\t  func_parm, tf_warning_or_error);\n+      new_yes_expr = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n+\t\t\t\t\t  func_parm, tf_warning_or_error);\n+      new_no_expr = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n+\t\t\t\t\t array_ind_value, tf_warning_or_error);\n+      if (list_size > 1)\n+\tnew_yes_ind = build_x_modify_expr (location, *new_var, NOP_EXPR,\n+\t\t\t\t\t   an_loop_info[0].var,\n+\t\t\t\t\t   tf_warning_or_error);\n+      else\n+\tnew_yes_ind = build_x_modify_expr (location, *new_var, NOP_EXPR,\n+\t\t\t\t\t   TREE_OPERAND (array_op0, 1),\n+\t\t\t\t\t   tf_warning_or_error);\n+      new_no_ind = build_x_modify_expr (location, *new_var, NOP_EXPR, *new_var,\n+\t\t\t\t\ttf_warning_or_error);\n+      new_yes_list = alloc_stmt_list ();\n+      append_to_statement_list (new_yes_ind, &new_yes_list);\n+      append_to_statement_list (new_yes_expr, &new_yes_list);\n+\n+      new_no_list = alloc_stmt_list ();\n+      append_to_statement_list (new_no_ind, &new_no_list);\n+      append_to_statement_list (new_no_expr, &new_no_list);\n+\n+      new_cond_expr = build_x_binary_op (location, code, array_ind_value,\n+\t\t\t\t\t TREE_CODE (array_ind_value), func_parm,\n+\t\t\t\t\t TREE_CODE (func_parm), NULL,\n+\t\t\t\t\t tf_warning_or_error);\n+      new_expr = build_x_conditional_expr (location, new_cond_expr,\n+\t\t\t\t\t   new_yes_list, new_no_list,\n+\t\t\t\t\t   tf_warning_or_error);\n+      break;\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n+    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n+      func_args = make_tree_vector ();\n+      if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE)\n+\tvec_safe_push (func_args, *new_var);\n+      else\n+\tvec_safe_push (func_args, identity_value);\n+      vec_safe_push (func_args, func_parm);\n+\n+      new_expr = finish_call_expr (call_fn, &func_args, false, true,\n+\t\t\t\t   tf_warning_or_error);\n+      if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE)\n+\tnew_expr = build_x_modify_expr (location, *new_var, NOP_EXPR, new_expr,\n+\t\t\t\t\ttf_warning_or_error);\n+      release_tree_vector (func_args);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n+  /* The reason we are putting initial variable twice is because the\n+     new exp init below depends on this value being initialized.  */\n+  for (ii = 0; ii < rank; ii++)\n+    finish_expr_stmt (an_loop_info[ii].ind_init);\n+ \n+  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    finish_expr_stmt (new_var_init);\n+\n+  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n+    finish_expr_stmt (new_exp_init);\n+\n+  an_init = pop_stmt_list (an_init);\n+  append_to_statement_list_force (an_init, &loop_with_init);\n+  body = new_expr;\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      create_an_loop (an_loop_info[ii].ind_init, an_loop_info[ii].cmp,\n+\t\t      an_loop_info[ii].incr, body);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+\n+  an_info.release ();\n+  an_loop_info.release ();\n+\n+  return loop_with_init;\n+}\n+\n+/* Returns a loop with ARRAY_REF inside it with an appropriate modify expr.\n+   The LHS and/or RHS will be array notation expressions that have a\n+   MODIFYCODE.  The location of the variable is specified by LOCATION. */\n+\n+static tree\n+expand_an_in_modify_expr (location_t location, tree lhs,\n+\t\t\t  enum tree_code modifycode, tree rhs,\n+\t\t\t  tsubst_flags_t complain)\n+{\n+  tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n+  tree array_expr = NULL_TREE;\n+  tree body = NULL_TREE;\n+  vec<tree> cond_expr = vNULL;\n+  vec<tree, va_gc> *lhs_array_operand = NULL, *rhs_array_operand = NULL;\n+  size_t lhs_rank = 0, rhs_rank = 0, ii = 0;\n+  vec<tree, va_gc> *rhs_list = NULL, *lhs_list = NULL;\n+  size_t rhs_list_size = 0, lhs_list_size = 0;\n+  tree new_modify_expr, new_var = NULL_TREE, builtin_loop, scalar_mods;\n+  bool found_builtin_fn = false;\n+  tree an_init, loop_with_init = alloc_stmt_list ();\n+  vec<vec<an_parts> > lhs_an_info = vNULL, rhs_an_info = vNULL;\n+  vec<an_loop_parts> lhs_an_loop_info = vNULL, rhs_an_loop_info = vNULL;\n+\n+  if (!find_rank (location, rhs, rhs, false, &rhs_rank))\n+    return error_mark_node;\n+  extract_array_notation_exprs (rhs, false, &rhs_list);\n+  rhs_list_size = vec_safe_length (rhs_list);\n+  an_init = push_stmt_list ();\n+  if (rhs_rank)\n+    {\n+      scalar_mods = replace_invariant_exprs (&rhs);\n+      if (scalar_mods)\n+\tfinish_expr_stmt (scalar_mods);\n+    }\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    {\n+      tree rhs_node = (*rhs_list)[ii];\n+      if (TREE_CODE (rhs_node) == CALL_EXPR)\n+\t{\n+\t  builtin_loop = expand_sec_reduce_builtin (rhs_node, &new_var);\n+\t  if (builtin_loop == error_mark_node)\n+\t    return error_mark_node;\n+\t  else if (builtin_loop)\n+\t    {\n+\t      finish_expr_stmt (builtin_loop);\n+\t      found_builtin_fn = true;\n+\t      if (new_var)\n+\t\t{\n+\t\t  vec <tree, va_gc> *rhs_sub_list = NULL, *new_var_list = NULL;\n+\t\t  vec_safe_push (rhs_sub_list, rhs_node);\n+\t\t  vec_safe_push (new_var_list, new_var);\n+\t\t  replace_array_notations (&rhs, false, rhs_sub_list,\n+\t\t\t\t\t   new_var_list);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  lhs_rank = 0;\n+  rhs_rank = 0;\n+  if (!find_rank (location, lhs, lhs, true, &lhs_rank)\n+      || !find_rank (location, rhs, rhs, true, &rhs_rank))\n+    {\n+      pop_stmt_list (an_init);\n+      return error_mark_node;\n+    }\n+\n+  /* If both are scalar, then the only reason why we will get this far is if\n+     there is some array notations inside it and was using a builtin array\n+     notation functions.  If so, we have already broken those guys up and now \n+     a simple build_x_modify_expr would do.  */\n+  if (lhs_rank == 0 && rhs_rank == 0)\n+    {\n+      if (found_builtin_fn)\n+\t{\n+\t  new_modify_expr = build_x_modify_expr (location, lhs,\n+\t\t\t\t\t\t modifycode, rhs, complain);\n+\t  finish_expr_stmt (new_modify_expr);\n+\t  pop_stmt_list (an_init);\n+\t  return an_init;\n+\t}\n+      else\n+\t{\n+\t  pop_stmt_list (an_init);\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  /* If for some reason location is not set, then find if LHS or RHS has\n+     location info.  If so, then use that so we atleast have an idea.  */\n+  if (location == UNKNOWN_LOCATION)\n+    {\n+      if (EXPR_LOCATION (lhs) != UNKNOWN_LOCATION)\n+\tlocation = EXPR_LOCATION (lhs);\n+      else if (EXPR_LOCATION (rhs) != UNKNOWN_LOCATION)\n+\tlocation = EXPR_LOCATION (rhs);\n+    }\n+      \n+  /* We need this when we have a scatter issue.  */\n+  extract_array_notation_exprs (lhs, true, &lhs_list);\n+  rhs_list = NULL;\n+  extract_array_notation_exprs (rhs, true, &rhs_list);\n+  rhs_list_size = vec_safe_length (rhs_list);\n+  lhs_list_size = vec_safe_length (lhs_list);\n+    \n+  if (lhs_rank == 0 && rhs_rank != 0)\n+    {\n+      if (location == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (rhs))\n+\tlocation = EXPR_LOCATION (rhs);\n+      error_at (location, \"%qD cannot be scalar when %qD is not\", lhs, rhs);\n+      return error_mark_node;\n+    }\n+  if (lhs_rank != 0 && rhs_rank != 0 && lhs_rank != rhs_rank)\n+    {\n+      error_at (location, \"rank mismatch between %qE and %qE\", lhs, rhs);\n+      return error_mark_node;\n+    }\n+  \n+  /* Assign the array notation components to variable so that they can satisfy\n+     the execute-once rule.  */\n+  for (ii = 0; ii < lhs_list_size; ii++)\n+    {\n+      tree anode = (*lhs_list)[ii];\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_START (anode), complain);\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (anode), complain);\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (anode), complain);\n+    }\n+  for (ii = 0; ii < rhs_list_size; ii++)\n+    if ((*rhs_list)[ii] && TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n+      {\n+\ttree aa = (*rhs_list)[ii];\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (aa), complain);\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (aa), complain);\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (aa), complain);\n+      }\n+  lhs_an_loop_info.safe_grow_cleared (lhs_rank);\n+  \n+  if (rhs_rank)\n+    rhs_an_loop_info.safe_grow_cleared (rhs_rank);\n+\n+  cond_expr.safe_grow_cleared (MAX (lhs_rank, rhs_rank));\n+  cilkplus_extract_an_triplets (lhs_list, lhs_list_size, lhs_rank,\n+\t\t\t\t&lhs_an_info);\n+  if (rhs_list)\n+    cilkplus_extract_an_triplets (rhs_list, rhs_list_size, rhs_rank,\n+\t\t\t\t  &rhs_an_info);\n+  if (cp_length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_an_info)\n+      || (rhs_list && cp_length_mismatch_in_expr_p (EXPR_LOCATION (rhs),\n+\t\t\t\t\t\t    rhs_an_info)))\n+    {\n+      pop_stmt_list (an_init);\n+      return error_mark_node;\n+    }\n+  tree rhs_len = (rhs_list_size > 0 && rhs_rank > 0) ?\n+    rhs_an_info[0][0].length : NULL_TREE;\n+  tree lhs_len = (lhs_list_size > 0 && lhs_rank > 0) ?\n+    lhs_an_info[0][0].length : NULL_TREE;\n+  if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n+      && TREE_CODE (lhs_len) == INTEGER_CST && rhs_len\n+      && TREE_CODE (rhs_len) == INTEGER_CST)\n+    {\n+      HOST_WIDE_INT l_length = int_cst_value (lhs_len);\n+      HOST_WIDE_INT r_length = int_cst_value (rhs_len);\n+      if (absu_hwi (l_length) != absu_hwi (r_length))\n+\t{\n+\t  error_at (location, \"length mismatch between LHS and RHS\");\n+\t  pop_stmt_list (an_init);\n+\t  return error_mark_node;\n+\t}\n+    }\n+   for (ii = 0; ii < lhs_rank; ii++)\n+    if (lhs_an_info[0][ii].start && TREE_TYPE (lhs_an_info[0][ii].start))\n+      lhs_an_loop_info[ii].var =\n+\tbuild_decl (location, VAR_DECL, NULL_TREE,\n+\t\t    TREE_TYPE (lhs_an_info[0][ii].start));\n+    else\n+      lhs_an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t     integer_type_node);\n+   if (rhs_list_size > 0)\n+     {\n+       rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n+\t\t\t\t\t\t  lhs_an_loop_info, lhs_rank,\n+\t\t\t\t\t\t  lhs); \n+       if (!rhs_array_operand)\n+\t return error_mark_node;\n+     }\n+  replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n+  rhs_list_size = 0;\n+  rhs_list = NULL;\n+  extract_array_notation_exprs (rhs, true, &rhs_list);\n+  rhs_list_size = vec_safe_length (rhs_list);    \n+  \n+  for (ii = 0; ii < lhs_rank; ii++)\n+    if (lhs_an_info[0][ii].is_vector)\n+      {\n+\tlhs_an_loop_info[ii].ind_init = build_x_modify_expr\n+\t  (location, lhs_an_loop_info[ii].var, NOP_EXPR,\n+\t   build_zero_cst (TREE_TYPE (lhs_an_loop_info[ii].var)), complain);\n+      }\n+  for (ii = 0; ii < rhs_rank; ii++)\n+    {\n+      /* When we have a polynomial, we assume that the indices are of type\n+\t integer.  */\n+      rhs_an_loop_info[ii].var =\n+\tbuild_decl (location, VAR_DECL, NULL_TREE,\n+\t\t    TREE_TYPE (rhs_an_info[0][ii].start));\n+      rhs_an_loop_info[ii].ind_init = build_x_modify_expr\n+\t(location, rhs_an_loop_info[ii].var, NOP_EXPR, \n+\t build_zero_cst (TREE_TYPE (rhs_an_loop_info[ii].var)), complain);\n+    }\n+\n+  if (lhs_rank)\n+    {\n+      lhs_array_operand =\n+\tcreate_array_refs (location, lhs_an_info, lhs_an_loop_info,\n+\t\t\t    lhs_list_size, lhs_rank);\n+      replace_array_notations (&lhs, true, lhs_list, lhs_array_operand);\n+    }\n+  \n+  if (rhs_array_operand)\n+    vec_safe_truncate (rhs_array_operand, 0);\n+  if (rhs_rank)\n+    {\n+      rhs_array_operand = create_array_refs (location, rhs_an_info,\n+\t\t\t\t\t      rhs_an_loop_info, rhs_list_size,\n+\t\t\t\t\t      rhs_rank);\n+      /* Replace all the array refs created by the above function because this\n+\t variable is blown away by the fix_sec_implicit_args function below.  */\n+      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n+      vec_safe_truncate (rhs_array_operand , 0);\n+      rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n+\t\t\t\t\t\t rhs_an_loop_info, rhs_rank,\n+\t\t\t\t\t\t rhs);\n+      if (!rhs_array_operand)\n+\treturn error_mark_node;\n+      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n+    }\n+\n+  array_expr_rhs = rhs;\n+  array_expr_lhs = lhs;\n+  \n+  array_expr = build_x_modify_expr (location, array_expr_lhs, modifycode,\n+\t\t\t\t    array_expr_rhs, complain);\n+  create_cmp_incr (location, &lhs_an_loop_info, lhs_rank, lhs_an_info,\n+\t\t   complain);\n+  if (rhs_rank) \n+    create_cmp_incr (location, &rhs_an_loop_info, rhs_rank, rhs_an_info, \n+\t\t     complain);\n+  for (ii = 0; ii < MAX (rhs_rank, lhs_rank); ii++)\n+    if (ii < lhs_rank && ii < rhs_rank)\n+      cond_expr[ii] = build_x_binary_op\n+\t(location, TRUTH_ANDIF_EXPR, lhs_an_loop_info[ii].cmp,\n+\t TREE_CODE (lhs_an_loop_info[ii].cmp), rhs_an_loop_info[ii].cmp,\n+\t TREE_CODE (rhs_an_loop_info[ii].cmp), NULL, complain);\n+    else if (ii < lhs_rank && ii >= rhs_rank)\n+      cond_expr[ii] = lhs_an_loop_info[ii].cmp;\n+    else\n+      /* No need to compare ii < rhs_rank && ii >= lhs_rank because valid Array\n+\t notation expression cannot RHS's rank cannot be greater than LHS.  */\n+      gcc_unreachable ();\n+  \n+  an_init = pop_stmt_list (an_init);\n+  append_to_statement_list_force (an_init, &loop_with_init);\n+  body = array_expr;\n+  for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n+    {\n+      tree incr_list = alloc_stmt_list ();\n+      tree init_list = alloc_stmt_list ();\n+      tree new_loop = push_stmt_list ();\n+\n+      if (lhs_rank)\n+\t{\n+\t  append_to_statement_list_force (lhs_an_loop_info[ii].ind_init,\n+\t\t\t\t\t  &init_list);\n+\t  append_to_statement_list_force (lhs_an_loop_info[ii].incr,\n+\t\t\t\t\t  &incr_list);\n+\t}\n+      if (rhs_rank)\n+\t{\n+\t  append_to_statement_list_force (rhs_an_loop_info[ii].ind_init,\n+\t\t\t\t\t  &init_list);\n+\t  append_to_statement_list_force (rhs_an_loop_info[ii].incr,\n+\t\t\t\t\t  &incr_list);\n+\t}\n+      create_an_loop (init_list, cond_expr[ii], incr_list, body);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list (body, &loop_with_init);\n+\n+  lhs_an_info.release ();\n+  lhs_an_loop_info.release ();\n+  if (rhs_rank) \n+    { \n+      rhs_an_info.release (); \n+      rhs_an_loop_info.release ();\n+    }\n+  cond_expr.release ();\n+\n+  return loop_with_init;\n+}\n+\n+/* Helper function for expand_conditonal_array_notations.  Encloses the\n+   conditional statement passed in ORIG_STMT with a loop around it and\n+   replaces the condition in STMT with a ARRAY_REF tree-node to the array.  \n+   The condition must have a ARRAY_NOTATION_REF tree.  */\n+\n+static tree\n+cp_expand_cond_array_notations (tree orig_stmt)\n+{\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  size_t list_size = 0;\n+  size_t rank = 0, ii = 0;\n+  tree an_init, body, stmt = NULL_TREE;\n+  tree builtin_loop, new_var = NULL_TREE;\n+  tree loop_with_init = alloc_stmt_list ();\n+  tsubst_flags_t complain = tf_warning_or_error;\n+  location_t location = UNKNOWN_LOCATION;\n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL;\n+\n+  if (TREE_CODE (orig_stmt) == COND_EXPR)\n+    {\n+      size_t cond_rank = 0, yes_rank = 0, no_rank = 0;\n+      tree yes_expr = COND_EXPR_THEN (orig_stmt);\n+      tree no_expr = COND_EXPR_ELSE (orig_stmt);\n+      tree cond = COND_EXPR_COND (orig_stmt);\n+      if (!find_rank (EXPR_LOCATION (cond), cond, cond, true, &cond_rank)\n+\t  || !find_rank (EXPR_LOCATION (yes_expr), yes_expr, yes_expr, true,\n+\t\t\t &yes_rank)\n+\t  || find_rank (EXPR_LOCATION (no_expr), no_expr, no_expr, true,\n+\t\t\t&no_rank))\n+\treturn error_mark_node;\n+      if (cond_rank != 0 && cond_rank != yes_rank && yes_rank != 0)\n+\t{\n+\t  error_at (EXPR_LOCATION (yes_expr), \"rank mismatch with controlling\"\n+\t\t    \" expression of parent if-statement\");\n+\t  return error_mark_node;\n+\t}\n+      else if (cond_rank != 0 && cond_rank != no_rank && no_rank != 0)\n+\t{\n+\t  error_at (EXPR_LOCATION (no_expr), \"rank mismatch with controlling \"\n+\t\t    \"expression of parent if-statement\");\n+\t  return error_mark_node;\n+\t}\n+    }\n+  else if (TREE_CODE (orig_stmt) == IF_STMT)\n+    {\n+      size_t cond_rank = 0, yes_rank = 0, no_rank = 0;\n+      tree yes_expr = THEN_CLAUSE (orig_stmt);\n+      tree no_expr = ELSE_CLAUSE (orig_stmt);\n+      tree cond = IF_COND (orig_stmt);\n+      if (!find_rank (EXPR_LOCATION (cond), cond, cond, true, &cond_rank)\n+\t  || (yes_expr\n+\t      && !find_rank (EXPR_LOCATION (yes_expr), yes_expr, yes_expr, true,\n+\t\t\t     &yes_rank))\n+\t  || (no_expr\n+\t      && !find_rank (EXPR_LOCATION (no_expr), no_expr, no_expr, true,\n+\t\t\t     &no_rank)))\n+\treturn error_mark_node;\n+      if (cond_rank != 0 && cond_rank != yes_rank && yes_rank != 0)\n+\t{\n+\t  error_at (EXPR_LOCATION (yes_expr), \"rank mismatch with controlling\"\n+\t\t    \" expression of parent if-statement\");\n+\t  return error_mark_node;\n+\t}\n+      else if (cond_rank != 0 && cond_rank != no_rank && no_rank != 0)\n+\t{\n+\t  error_at (EXPR_LOCATION (no_expr), \"rank mismatch with controlling \"\n+\t\t    \"expression of parent if-statement\");\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (!find_rank (EXPR_LOCATION (orig_stmt), orig_stmt, orig_stmt, true,\n+\t\t  &rank))\n+    return error_mark_node;\n+  if (rank == 0)\n+    return orig_stmt;\n+\n+  extract_array_notation_exprs (orig_stmt, false, &array_list);\n+  stmt = alloc_stmt_list ();\n+  for (ii = 0; ii < vec_safe_length (array_list); ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      if (TREE_CODE (array_node) == CALL_EXPR\n+\t  || TREE_CODE (array_node) == AGGR_INIT_EXPR)\n+\t{\n+\t  builtin_loop = expand_sec_reduce_builtin (array_node, &new_var);\n+\t  if (builtin_loop == error_mark_node)\n+\t    finish_expr_stmt (error_mark_node);\n+\t  else if (new_var)\n+\t    {\n+\t      vec<tree, va_gc> *sub_list = NULL, *new_var_list = NULL;\n+\t      vec_safe_push (sub_list, array_node);\n+\t      vec_safe_push (new_var_list, new_var);\n+\t      replace_array_notations (&orig_stmt, false, sub_list,\n+\t\t\t\t       new_var_list);\n+\t      append_to_statement_list_force (builtin_loop, &stmt);\n+\t    }\n+\t}\n+    }\n+  append_to_statement_list_force (orig_stmt, &stmt);\n+  rank = 0;\n+  array_list = NULL;\n+  if (!find_rank (EXPR_LOCATION (stmt), stmt, stmt, true, &rank))\n+    return error_mark_node;\n+  if (rank == 0)\n+    return stmt;\n+  \n+  extract_array_notation_exprs (stmt, true, &array_list);\n+  list_size = vec_safe_length (array_list);\n+  if (list_size == 0)\n+    return stmt;\n+\n+  location = EXPR_LOCATION (orig_stmt);\n+  list_size = vec_safe_length (array_list);\n+  an_loop_info.safe_grow_cleared (rank);\n+  \n+  an_init = push_stmt_list ();\n+\n+  /* Assign the array notation components to variable so that they can\n+     satisfy the exec-once rule.  */\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree anode = (*array_list)[ii];\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_START (anode), complain);\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (anode), complain);\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (anode), complain);\n+    }\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n+  for (ii = 0; ii < rank; ii++)\n+      if (TREE_TYPE (an_info[0][ii].start)\n+\t  && TREE_CODE (TREE_TYPE (an_info[0][ii].start)) != TEMPLATE_TYPE_PARM)\n+\t{\n+\t  an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t     TREE_TYPE (an_info[0][ii].start));\n+\t  an_loop_info[ii].ind_init = build_x_modify_expr\n+\t    (location, an_loop_info[ii].var, NOP_EXPR,\n+\t     build_zero_cst (TREE_TYPE (an_loop_info[ii].var)),\n+\t     tf_warning_or_error);\n+\t}\n+      else\n+\t{\n+\t  an_loop_info[ii].var = build_min_nt_loc (location, VAR_DECL,\n+\t\t\t\t\t\t   NULL_TREE, NULL_TREE);\n+\t  an_loop_info[ii].ind_init =\n+\t    build_x_modify_expr (location, an_loop_info[ii].var, NOP_EXPR,\n+\t\t\t\t integer_zero_node, tf_warning_or_error);\n+\t}\n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t     list_size, rank);\n+  replace_array_notations (&stmt, true, array_list, array_operand);\n+  create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n+  \n+  an_init = pop_stmt_list (an_init);\n+  append_to_statement_list_force (an_init, &loop_with_init);\n+  body = stmt;\n+\n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      create_an_loop (an_loop_info[ii].ind_init, an_loop_info[ii].cmp,\n+\t\t      an_loop_info[ii].incr, body);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+\n+  an_info.release ();\n+  an_loop_info.release ();\n+  \n+  return loop_with_init;\n+}\n+\n+/* Transforms array notations inside unary expression ORIG_STMT with an\n+   appropriate loop and ARRAY_REF (and returns all this as a super-tree called\n+   LOOP).  */\n+\n+static tree\n+expand_unary_array_notation_exprs (tree orig_stmt)\n+{\n+  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n+  size_t list_size = 0, rank = 0, ii = 0;\n+  tree body;\n+  tree builtin_loop, stmt = NULL_TREE, new_var = NULL_TREE;\n+  location_t location = EXPR_LOCATION (orig_stmt);\n+  tree an_init, loop_with_init = alloc_stmt_list ();\n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL;\n+  \n+  if (!find_rank (location, orig_stmt, orig_stmt, true, &rank))\n+    return error_mark_node;\n+  if (rank == 0)\n+    return orig_stmt;  \n+  \n+  extract_array_notation_exprs (orig_stmt, false, &array_list);\n+  list_size = vec_safe_length (array_list);\n+  location = EXPR_LOCATION (orig_stmt);\n+  stmt = NULL_TREE;\n+  for (ii = 0; ii < list_size; ii++)\n+    if (TREE_CODE ((*array_list)[ii]) == CALL_EXPR\n+\t|| TREE_CODE ((*array_list)[ii]) == AGGR_INIT_EXPR)\n+      {\n+\ttree list_node = (*array_list)[ii];\n+\tbuiltin_loop = expand_sec_reduce_builtin (list_node, &new_var);\n+\tif (builtin_loop == error_mark_node)\n+\t  return error_mark_node;\n+\telse if (builtin_loop)\n+\t  {\n+\t    vec<tree, va_gc> *sub_list = NULL, *new_var_list = NULL;\n+\t    stmt = alloc_stmt_list ();\n+\t    append_to_statement_list_force (builtin_loop, &stmt);\n+\t    vec_safe_push (sub_list, list_node);\n+\t    vec_safe_push (new_var_list, new_var);\n+\t    replace_array_notations (&orig_stmt, false, sub_list, new_var_list);\n+\t  }\t\n+      }\n+  if (stmt != NULL_TREE)\n+    append_to_statement_list_force (finish_expr_stmt (orig_stmt), &stmt);\n+  else\n+    stmt = orig_stmt;\n+  rank = 0;\n+  list_size = 0;\n+  array_list = NULL;\n+  extract_array_notation_exprs (stmt, true, &array_list);\n+  list_size = vec_safe_length (array_list);\n+\n+  if (!find_rank (EXPR_LOCATION (stmt), stmt, stmt, true, &rank))\n+    return error_mark_node;\n+  if (rank == 0 || list_size == 0)\n+    return stmt;\n+  an_loop_info.safe_grow_cleared (rank);\n+  an_init = push_stmt_list ();  \n+    /* Assign the array notation components to variable so that they can satisfy\n+     the exec-once rule.  */\n+  for (ii = 0; ii < list_size; ii++)\n+    {\n+      tree array_node = (*array_list)[ii];\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node),\n+\t\t\t    tf_warning_or_error);\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node),\n+\t\t\t    tf_warning_or_error);\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node),\n+\t\t\t    tf_warning_or_error);\n+    }\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n+  \n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t  TREE_TYPE (an_info[0][ii].start));\n+      an_loop_info[ii].ind_init = build_x_modify_expr\n+\t(location, an_loop_info[ii].var, NOP_EXPR, \n+\t build_zero_cst (TREE_TYPE (an_loop_info[ii].var)),\n+\t tf_warning_or_error);\n+    }\n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t     list_size, rank);\n+  replace_array_notations (&stmt, true, array_list, array_operand);\n+  create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n+  \n+  an_init = pop_stmt_list (an_init);\n+  append_to_statement_list_force (an_init, &loop_with_init);\n+  body = stmt;\n+  \n+  for (ii = 0; ii < rank; ii++)\n+    {\n+      tree new_loop = push_stmt_list ();\n+      create_an_loop (an_loop_info[ii].ind_init, an_loop_info[ii].cmp,\n+\t\t      an_loop_info[ii].incr, body);\n+      body = pop_stmt_list (new_loop);\n+    }\n+  append_to_statement_list_force (body, &loop_with_init);\n+\n+  an_info.release ();\n+  an_loop_info.release ();\n+\n+  return loop_with_init;\n+}\n+\n+/* Expands the array notation's builtin reduction function in EXPR\n+   (of type RETURN_EXPR) and returns a STATEMENT_LIST that contains a loop\n+   with the builtin function expansion and a return statement at the end.  */\n+\n+static tree\n+expand_return_expr (tree expr)\n+{\n+  tree new_mod_list, new_var, new_mod, retval_expr;\n+\n+  if (TREE_CODE (expr) != RETURN_EXPR)\n+    return expr;\n+\n+  location_t loc = EXPR_LOCATION (expr);\n+  new_mod_list = alloc_stmt_list ();\n+  retval_expr = TREE_OPERAND (expr, 0);\n+  new_var = build_decl (loc, VAR_DECL, NULL_TREE, TREE_TYPE (retval_expr));\n+  new_mod = expand_an_in_modify_expr (loc, new_var, NOP_EXPR,\n+\t\t\t\t\t TREE_OPERAND (retval_expr, 1),\n+\t\t\t\t\t tf_warning_or_error);\n+  TREE_OPERAND (retval_expr, 1) = new_var;\n+  TREE_OPERAND (expr, 0) = retval_expr;\n+  append_to_statement_list_force (new_mod, &new_mod_list);\n+  append_to_statement_list_force (expr, &new_mod_list);\n+  return new_mod_list;\n+}\n+\n+/* Expands ARRAY_NOTATION_REF and builtin functions in a compound statement,\n+   STMT. Returns the STMT with expanded array notations.  */\n+\n+tree\n+expand_array_notation_exprs (tree t)\n+{\n+  enum tree_code code;\n+  bool is_expr;\n+  location_t loc = UNKNOWN_LOCATION;\n+  \n+  if (!t)\n+    return t;\n+\n+  loc = EXPR_LOCATION (t);\n+\n+  code = TREE_CODE (t); \n+  is_expr = IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code));\n+  switch (code)\n+    {\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+    case STRING_CST:\n+    case BLOCK:\n+    case PLACEHOLDER_EXPR:\n+    case FIELD_DECL:\n+    case VOID_TYPE:\n+    case REAL_TYPE:\n+    case SSA_NAME:\n+    case LABEL_DECL:\n+    case RESULT_DECL:\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+    case INIT_EXPR:\n+    case ADDR_EXPR:\n+    case ARRAY_REF:\n+    case BIT_FIELD_REF:\n+    case VECTOR_CST:\n+    case COMPLEX_CST:\n+      return t;\n+    case MODIFY_EXPR:\n+      if (contains_array_notation_expr (t))\n+\tt = expand_an_in_modify_expr (loc, TREE_OPERAND (t, 0), NOP_EXPR, \n+\t\t\t\t\t TREE_OPERAND (t, 1), \n+\t\t\t\t\t tf_warning_or_error);\n+      return t;\n+    case MODOP_EXPR:\n+      if (contains_array_notation_expr (t) && !processing_template_decl)\n+\tt = expand_an_in_modify_expr\n+\t  (loc, TREE_OPERAND (t, 0), TREE_CODE (TREE_OPERAND (t, 1)),\n+\t   TREE_OPERAND (t, 2), tf_warning_or_error);\n+      return t;\n+    case CONSTRUCTOR:\n+      return t;\n+    case BIND_EXPR:\n+      {\n+\tBIND_EXPR_BODY (t) =\n+\t  expand_array_notation_exprs  (BIND_EXPR_BODY (t));\n+\treturn t;\n+      }\n+    case DECL_EXPR:\n+      {\n+\ttree x = DECL_EXPR_DECL (t);\n+\tif (t && TREE_CODE (x) != FUNCTION_DECL)\n+\t  if (DECL_INITIAL (x))\n+\t    t = expand_unary_array_notation_exprs (t);\n+      return t;\n+      }\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  *tsi_stmt_ptr (i) =\n+\t    expand_array_notation_exprs (*tsi_stmt_ptr (i));\n+\treturn t;\n+      }\n+\n+    case OMP_PARALLEL:\n+    case OMP_TASK:\n+    case OMP_FOR:\n+    case OMP_SINGLE:\n+    case OMP_SECTION:\n+    case OMP_SECTIONS:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+    case OMP_ATOMIC:\n+    case OMP_CLAUSE:\n+    case TARGET_EXPR:\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case POINTER_TYPE:\n+    case ARRAY_TYPE:\n+    case RECORD_TYPE:\n+    case METHOD_TYPE:\n+      return t;\n+    case RETURN_EXPR:\n+      if (contains_array_notation_expr (t))\n+\tt = expand_return_expr (t);\n+      return t;\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case AGGR_INIT_EXPR:\n+    case CALL_EXPR:\n+      t = expand_unary_array_notation_exprs (t);\n+      return t;\n+    case CONVERT_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case EXPR_STMT:\n+      TREE_OPERAND (t, 0) = expand_array_notation_exprs (TREE_OPERAND (t, 0));\n+      /* It is not necessary to wrap error_mark_node in EXPR_STMT.  */\n+      if (TREE_OPERAND (t, 0) == error_mark_node)\n+\treturn TREE_OPERAND (t, 0); \n+      return t;\n+    case COND_EXPR:\n+      t = cp_expand_cond_array_notations (t);\n+      if (TREE_CODE (t) == COND_EXPR)\n+\t{\n+\t  COND_EXPR_THEN (t) =\n+\t    expand_array_notation_exprs (COND_EXPR_THEN (t));\n+\t  COND_EXPR_ELSE (t) =\n+\t    expand_array_notation_exprs (COND_EXPR_ELSE (t));\n+\t}\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+\n+    case SWITCH_EXPR:\n+      t = cp_expand_cond_array_notations (t);\n+      if (TREE_CODE (t) == SWITCH_EXPR)\n+\tSWITCH_BODY (t) = expand_array_notation_exprs (SWITCH_BODY (t));\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    case FOR_STMT:      \n+      /* FIXME: Add a check for CILK_FOR_STMT here when we add Cilk tasking \n+\t keywords.  */\n+      if (TREE_CODE (t) == FOR_STMT)\n+\tFOR_BODY (t) = expand_array_notation_exprs (FOR_BODY (t));\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    case IF_STMT:\n+      t = cp_expand_cond_array_notations (t);\n+      /* If the above function added some extra instructions above the original\n+\t if statement, then we can't assume it is still IF_STMT so we have to\n+\t check again.  */\n+      if (TREE_CODE (t) == IF_STMT)\n+\t{\n+\t  if (THEN_CLAUSE (t))\n+\t    THEN_CLAUSE (t) = expand_array_notation_exprs (THEN_CLAUSE (t));\n+\t  if (ELSE_CLAUSE (t))\n+\t    ELSE_CLAUSE (t) = expand_array_notation_exprs (ELSE_CLAUSE (t));\n+\t}\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    case SWITCH_STMT:\n+      t = cp_expand_cond_array_notations (t);\n+      /* If the above function added some extra instructions above the original\n+\t switch statement, then we can't assume it is still SWITCH_STMT so we\n+\t have to check again.  */\n+      if (TREE_CODE (t) == SWITCH_STMT)\n+\t{\n+\t  if (SWITCH_STMT_BODY (t))\n+\t    SWITCH_STMT_BODY (t) =\n+\t      expand_array_notation_exprs (SWITCH_STMT_BODY (t));\n+\t}\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    case WHILE_STMT:\n+      t = cp_expand_cond_array_notations (t);\n+      /* If the above function added some extra instructions above the original\n+\t while statement, then we can't assume it is still WHILE_STMTso we\n+\t have to check again.  */\n+      if (TREE_CODE (t) == WHILE_STMT)\n+\t{\n+\t  if (WHILE_BODY (t))\n+\t    WHILE_BODY (t) = expand_array_notation_exprs (WHILE_BODY (t));\n+\t}\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    case DO_STMT:\n+      t = cp_expand_cond_array_notations (t);\n+      /* If the above function added some extra instructions above the original\n+\t do-while statement, then we can't assume it is still DO_STMT so we\n+\t have to check again.  */\n+      if (TREE_CODE (t) == DO_STMT)\n+\t{      \n+\t  if (DO_BODY (t))\n+\t    DO_BODY (t) = expand_array_notation_exprs (DO_BODY (t));\n+\t}\n+      else\n+\tt = expand_array_notation_exprs (t);\n+      return t;\n+    default:\n+      if (is_expr)\n+\t{\n+\t  int i, len;\n+\n+\t  /* Walk over all the sub-trees of this operand.  */\n+\t  len = TREE_CODE_LENGTH (code);\n+\n+\t  /* Go through the subtrees.  We need to do this in forward order so\n+\t     that the scope of a FOR_EXPR is handled properly.  */\n+\t  for (i = 0; i < len; ++i)\n+\t    TREE_OPERAND (t, i) =\n+\t      expand_array_notation_exprs (TREE_OPERAND (t, i));\n+\t}\n+      return t;\n+    }\n+  return t;\n+}\n+\n+/* Given the base of an array (ARRAY), the START_INDEX, the number of elements\n+   to be accessed (LENGTH) and the STRIDE, construct an ARRAY_NOTATION_REF tree\n+   of type TYPE and return it.  Restrictions on START_INDEX, LENGTH and STRIDE \n+   are the same as that of index field passed into ARRAY_REF.  The only\n+   additional restriction is that, unlike index in ARRAY_REF, stride, length\n+   and start_index cannot contain array notations.  */\n+\n+tree\n+build_array_notation_ref (location_t loc, tree array, tree start_index,\n+\t\t\t  tree length, tree stride, tree type)\n+{\n+  tree array_ntn_expr = NULL_TREE;\n+  \n+  /* When dealing with templates, do the type checking at a later time.  */\n+  if (processing_template_decl || !type)\n+    {\n+      if (!type && TREE_TYPE (array))\n+\ttype = TREE_TYPE (array);\n+      array_ntn_expr = build_min_nt_loc (loc, ARRAY_NOTATION_REF, array,\n+\t\t\t\t\t start_index, length, stride, type,\n+\t\t\t\t\t NULL_TREE);\n+      TREE_TYPE (array_ntn_expr) = type;\n+    }\n+  if (!stride)\n+    {\n+      if (TREE_CONSTANT (start_index) && TREE_CONSTANT (length)\n+\t  && TREE_CODE (start_index) != VAR_DECL\n+\t  && TREE_CODE (length) != VAR_DECL\n+\t  && tree_int_cst_lt (length, start_index))\n+\tstride = build_int_cst (TREE_TYPE (start_index), -1);\n+      else\n+\tstride = build_int_cst (TREE_TYPE (start_index), 1);\n+    }\n+\n+  if (!cilkplus_an_triplet_types_ok_p (loc, start_index, length, stride, type))\n+    return error_mark_node;\n+\n+  if (!processing_template_decl)\n+    {\n+      array_ntn_expr = build4 (ARRAY_NOTATION_REF, NULL_TREE, NULL_TREE,\n+\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n+      ARRAY_NOTATION_ARRAY (array_ntn_expr) = array;\n+      ARRAY_NOTATION_START (array_ntn_expr) = start_index;\n+      ARRAY_NOTATION_LENGTH (array_ntn_expr) = length;\n+      ARRAY_NOTATION_STRIDE (array_ntn_expr) = stride;\n+      if (type && (TREE_CODE (type) == ARRAY_TYPE\n+\t\t   || TREE_CODE (type) == POINTER_TYPE))\n+\tTREE_TYPE (array_ntn_expr) = TREE_TYPE (type);\n+      else\n+\tTREE_TYPE (array_ntn_expr) = type;\n+    }\n+  SET_EXPR_LOCATION (array_ntn_expr, loc);\n+\n+  return array_ntn_expr;\n+}\n+\n+/* Returns false if any of the Array notation triplet values: START_INDEX,\n+   LENGTH and STRIDE, are not of integral type and have a rank greater than\n+   zero.  */\n+\n+bool\n+cilkplus_an_triplet_types_ok_p (location_t loc, tree start_index, tree length,\n+\t\t\t\ttree stride, tree type)\n+{\n+  size_t stride_rank = 0, length_rank = 0, start_rank = 0;\n+  if (!TREE_TYPE (start_index) || !INTEGRAL_TYPE_P (TREE_TYPE (start_index)))\n+    {\n+      error_at (loc, \"start-index of array notation triplet is not an integer\");\n+      return false;\n+    }\n+  if (!TREE_TYPE (length) || !INTEGRAL_TYPE_P (TREE_TYPE (length)))\n+    {\n+      error_at (loc, \"length of array notation triplet is not an integer\");\n+      return false;\n+    }\n+  if (!TREE_TYPE (stride) || !INTEGRAL_TYPE_P (TREE_TYPE (stride)))\n+    {\n+      error_at (loc, \"stride of array notation triplet is not an integer\");\n+      return false;\n+    }\n+  if (!TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      error_at (loc, \"array notations cannot be used with function type\");\n+      return false;\n+    }\n+  while (type && (TREE_CODE (type) == POINTER_TYPE\n+\t\t  || TREE_CODE (type) == ARRAY_TYPE))\n+    {\n+      type = TREE_TYPE (type);\n+      if (type && TREE_CODE (type) == FUNCTION_TYPE)\n+\t{\n+\t  error_at (loc, \"array notations cannot be used with function pointer\"\n+\t\t    \" arrays\");\n+\t  return false;\n+\t}\n+    }\n+  if (!find_rank (loc, start_index, start_index, false, &start_rank)\n+      || !find_rank (loc, length, length, false, &length_rank)\n+      || !find_rank (loc, stride, stride, false, &stride_rank))\n+    return false;\n+\n+  if (start_rank != 0)\n+    {\n+      error_at (loc, \"rank of an array notation triplet%'s start-index is not \"\n+\t\t\"zero\");\n+      return false;\n+    }\n+  if (length_rank != 0)\n+    {\n+      error_at (loc, \"rank of an array notation triplet%'s length is not zero\");\n+      return false;\n+    }\n+  if (stride_rank != 0)\n+    {\n+      error_at (loc, \"rank of array notation triplet%'s stride is not zero\");\n+      return false;\n+    }\n+  return true;\n+}"}, {"sha": "d301db01a78a85dfd0f1d975ce6421975875f507", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -321,6 +321,7 @@ cp_common_init_ts (void)\n   MARK_TS_TYPED (USING_STMT);\n   MARK_TS_TYPED (LAMBDA_EXPR);\n   MARK_TS_TYPED (CTOR_INITIALIZER);\n+  MARK_TS_TYPED (ARRAY_NOTATION_REF);\n }\n \n #include \"gt-cp-cp-objcp-common.h\""}, {"sha": "00ee45013b3313f91ab2e82b2b513f4388c46a02", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -6138,6 +6138,10 @@ extern bool cxx_omp_privatize_by_reference\t(const_tree);\n extern void suggest_alternatives_for            (location_t, tree);\n extern tree strip_using_decl                    (tree);\n \n+/* In cp/cp-array-notations.c */\n+extern tree expand_array_notation_exprs         (tree);\n+bool cilkplus_an_triplet_types_ok_p             (location_t, tree, tree, tree,\n+\t\t\t\t\t\t tree);\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "a8f52cda0ae9d98c06711d19694b352062efbd8e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -1071,6 +1071,17 @@ dump_decl (tree t, int flags)\n       pp_cxx_right_bracket (cxx_pp);\n       break;\n \n+    case ARRAY_NOTATION_REF:\n+      dump_decl (ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_left_bracket (cxx_pp);\n+      dump_decl (ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_string (cxx_pp, \":\");\n+      dump_decl (ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_string (cxx_pp, \":\");\n+      dump_decl (ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_bracket (cxx_pp);\n+      break;\n+\n       /* So that we can do dump_decl on an aggr type.  */\n     case RECORD_TYPE:\n     case UNION_TYPE:\n@@ -2057,6 +2068,17 @@ dump_expr (tree t, int flags)\n       pp_cxx_right_bracket (cxx_pp);\n       break;\n \n+    case ARRAY_NOTATION_REF:\n+      dump_expr (ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_left_bracket (cxx_pp);\n+      dump_expr (ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_string (cxx_pp, \":\");\n+      dump_expr (ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_string (cxx_pp, \":\");\n+      dump_expr (ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_bracket (cxx_pp);\n+      break;\n+\n     case UNARY_PLUS_EXPR:\n       dump_unary_op (\"+\", t, flags);\n       break;"}, {"sha": "6fc45f30b36d56422931f19f190609456bafb04d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 319, "deletions": 50, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -6060,6 +6060,170 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   return error_mark_node;\n }\n \n+/* This function parses Cilk Plus array notations.  The starting index is\n+   passed in INIT_INDEX and the array name is passed in ARRAY_VALUE.  If the\n+   INIT_INDEX is NULL, then we have special case were the entire array is\n+   accessed (e.g. A[:]).  The return value of this function is a tree node\n+   called VALUE_TREE of type ARRAY_NOTATION_REF.  If some error occurred it\n+   returns error_mark_node.  */\n+\n+static tree\n+cp_parser_array_notation (location_t loc, cp_parser *parser, tree init_index,\n+\t\t\t  tree array_value)\n+{\n+  cp_token *token = NULL;\n+  tree start_index = NULL_TREE, length_index = NULL_TREE, stride = NULL_TREE;\n+  tree value_tree, type, array_type, array_type_domain;\n+  double_int x; \n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+\n+  if (!array_value || array_value == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n+  \n+  if (processing_template_decl)\n+    {\n+      array_type = TREE_TYPE (array_value);\n+      type = TREE_TYPE (array_type);\n+    }\n+  else\n+    {\n+      array_type = TREE_TYPE (array_value);\n+      gcc_assert (array_type);\n+      type = array_type;\n+    }\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (!token)\n+    {\n+      cp_parser_error (parser, \"expected %<:%> or numeral\");\n+      return error_mark_node;\n+    }\n+  else if (token->type == CPP_COLON)\n+    {\n+      if (!init_index)\n+\t{\n+\t  /* If we are here, then we have a case like this A[:].  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t  if (cp_lexer_peek_token (parser->lexer)->type != CPP_CLOSE_SQUARE)\n+\t    {\n+\t      cp_parser_error (parser, \"expected %<]%>\");\n+\t      cp_parser_skip_to_end_of_statement (parser);\n+\t      return error_mark_node;\n+\t    }\n+\t  if (TREE_CODE (array_type) == RECORD_TYPE\n+\t      || TREE_CODE (array_type) == POINTER_TYPE)\n+\t    {\n+\t      error_at (loc, \"start-index and length fields necessary for \"\n+\t\t\t\"using array notations in pointers or records\");\n+\t      cp_parser_skip_to_end_of_statement (parser);\n+\t      return error_mark_node;\n+\t    }\n+\t  if (TREE_CODE (array_type) == ARRAY_TYPE)\n+\t    {\n+\t      tree subtype = TREE_TYPE (array_type);\n+\t      while (subtype && TREE_CODE (subtype) == POINTER_TYPE)\n+\t\t{\n+\t\t  /* This could be a function ptr.  If so, then emit error.  */\n+\t\t  subtype = TREE_TYPE (subtype);\n+\t\t  if (subtype && TREE_CODE (subtype) == FUNCTION_TYPE)\n+\t\t    {\n+\t\t      error_at (loc, \"array notations cannot be used with\"\n+\t\t\t\t\" function pointer arrays\");\n+\t\t      cp_parser_skip_to_end_of_statement (parser);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  array_type_domain = TYPE_DOMAIN (array_type);\n+\t  if (!array_type_domain)\n+\t    {\n+\t      error_at (loc, \"start-index and length fields necessary for \"\n+\t\t\t\"using array notations in dimensionless arrays\");\n+\t      cp_parser_skip_to_end_of_statement (parser);\n+\t      return error_mark_node;\n+\t    }\n+\t  start_index = TYPE_MINVAL (array_type_domain);\n+\t  start_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node,\n+\t\t\t\t     start_index);\n+\t  x = TREE_INT_CST (TYPE_MAXVAL (array_type_domain));\n+\t  x.low++;\n+\t  length_index = double_int_to_tree (integer_type_node, x);\n+\t  length_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node,\n+\t\t\t\t      length_index);\n+\t  stride = build_int_cst (integer_type_node, 1);\n+\t  stride = fold_build1 (CONVERT_EXPR, ptrdiff_type_node, stride);\n+\t}\n+      else if (init_index != error_mark_node)\n+\t{\n+\t  /* If we hare here, then there are 2 possibilities:\n+\t     1. Array [ EXPR : EXPR ]\n+\t     2. Array [ EXPR : EXPR : EXPR ]\n+\t  */\n+\t  start_index = init_index;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t  saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+\t   /* The ':' is used in array notation.  Thus compiler cannot do scope \n+\t      correction automatically.  */\n+\t  parser->colon_corrects_to_scope_p = false;\n+\t  length_index = cp_parser_expression (parser, false, NULL);\n+\t  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+\t  if (!length_index || length_index == error_mark_node)\n+\t    cp_parser_skip_to_end_of_statement (parser);\n+\t \n+\t  if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      saved_colon_corrects_to_scope_p = \n+\t\tparser->colon_corrects_to_scope_p;\n+\t      /* Disable correcting single colon correcting to scope.  */\n+\t      parser->colon_corrects_to_scope_p = false;\n+\t      stride = cp_parser_expression (parser, false, NULL);\n+\t      parser->colon_corrects_to_scope_p = \n+\t\tsaved_colon_corrects_to_scope_p;\n+\t      if (!stride || stride == error_mark_node)\n+\t\t{\n+\t\t  cp_parser_skip_to_end_of_statement (parser);\n+\t\t  if (cp_lexer_peek_token (parser->lexer)->type\n+\t\t      == CPP_CLOSE_SQUARE)\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t    }\n+\t  else\n+\t    stride = build_one_cst (integer_type_node);\n+\t}\n+      else\n+\t{\n+\t  cp_parser_skip_to_end_of_statement (parser);\n+\t  return error_mark_node;\n+\t}\n+    }\n+  \n+  if (start_index == error_mark_node || length_index == error_mark_node\n+      || stride == error_mark_node || !start_index || !length_index\n+      || !stride)\n+    {\n+      if (cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_SQUARE)\n+\tcp_lexer_consume_token (parser->lexer);\n+      return error_mark_node;\n+    }\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+  \n+  /* We fold all 3 of the values to make things easier when we transform\n+     them later.  */\n+  start_index = fold (start_index);\n+  length_index = fold (length_index);\n+  stride = fold (stride);\n+\n+  value_tree = build_array_notation_ref (input_location, array_value,\n+\t\t\t\t\t start_index, length_index, stride,\n+\t\t\t\t\t type);\n+  return value_tree;\n+}\n+\n /* A subroutine of cp_parser_postfix_expression that also gets hijacked\n    by cp_parser_builtin_offsetof.  We're looking for\n \n@@ -6081,41 +6245,78 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n   /* Consume the `[' token.  */\n   cp_lexer_consume_token (parser->lexer);\n \n-  /* Parse the index expression.  */\n-  /* ??? For offsetof, there is a question of what to allow here.  If\n-     offsetof is not being used in an integral constant expression context,\n-     then we *could* get the right answer by computing the value at runtime.\n-     If we are in an integral constant expression context, then we might\n-     could accept any constant expression; hard to say without analysis.\n-     Rather than open the barn door too wide right away, allow only integer\n-     constant expressions here.  */\n-  if (for_offsetof)\n-    index = cp_parser_constant_expression (parser, false, NULL);\n+  if (flag_enable_cilkplus\n+      && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n+    /* If we are here, then we have something like this:\n+       ARRAY[:]\n+    */\n+    postfix_expression = cp_parser_array_notation (loc, parser, NULL_TREE,\n+\t\t\t\t\t\t   postfix_expression);\n   else\n     {\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+      /* Here are have these options:\n+\t 1. ARRAY[EXPR]               -- This is the normal array call.\n+\t 2. ARRAY[EXPR : EXPR]        -- Array notation expr with default stride\n+\t of 1.\n+\t 3. ARRAY[EXPR : EXPR : EXPR] -- Array Notation with userdefined stride.\n+\t 4. Array[Braced List]        -- This is handled by braced list.\n+      */\n+      \n+      /* Parse the index expression.  */\n+      /* ??? For offsetof, there is a question of what to allow here.  If\n+\t offsetof is not being used in an integral constant expression context,\n+\t then we *could* get the right answer by computing the value at runtime.\n+\t If we are in an integral constant expression context, then we might\n+\t could accept any constant expression; hard to say without analysis.\n+\t Rather than open the barn door too wide right away, allow only integer\n+\t constant expressions here.  */\n+      if (for_offsetof)\n+\tindex = cp_parser_constant_expression (parser, false, NULL);\n+      else\n \t{\n-\t  bool expr_nonconst_p;\n-\t  maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n-\t  index = cp_parser_braced_list (parser, &expr_nonconst_p);\n+\t  bool saved_colon_corrects_to_scope_p = \n+\t    parser->colon_corrects_to_scope_p;\n+\t  if (flag_enable_cilkplus)\n+\t    parser->colon_corrects_to_scope_p = false;\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t    {\n+\t      bool expr_nonconst_p;\n+\t      maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n+\t      index = cp_parser_braced_list (parser, &expr_nonconst_p);\n+\t      if (flag_enable_cilkplus\n+\t\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n+\t\t{\n+\t\t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t    \"braced list index is not allowed with array \"\n+\t\t\t    \"notations\");\n+\t\t  index = error_mark_node;\n+\t\t}\n+\t    }\n+\t  else\n+\t    index = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\t  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n \t}\n+      if (flag_enable_cilkplus\n+\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n+\tpostfix_expression = cp_parser_array_notation (loc, parser, index,\n+\t\t\t\t\t\t       postfix_expression);\n       else\n-\tindex = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-    }\n-\n-  /* Look for the closing `]'.  */\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-\n-  /* Build the ARRAY_REF.  */\n-  postfix_expression = grok_array_decl (loc, postfix_expression,\n-\t\t\t\t\tindex, decltype_p);\n+\t{\n+  \t  /* Look for the closing `]'.  */\n+\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n-  /* When not doing offsetof, array references are not permitted in\n-     constant-expressions.  */\n-  if (!for_offsetof\n-      && (cp_parser_non_integral_constant_expression (parser, NIC_ARRAY_REF)))\n-    postfix_expression = error_mark_node;\n+\t  /* Build the ARRAY_REF.  */\n+\t  postfix_expression = grok_array_decl (loc, postfix_expression,\n+\t\t\t\t\t\tindex, decltype_p);\n \n+\t  /* When not doing offsetof, array references are not permitted in\n+\t     constant-expressions.  */\n+\t  if (!for_offsetof\n+\t      && (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t      NIC_ARRAY_REF)))\n+\t    postfix_expression = error_mark_node;\n+\t}\n+    }\n   return postfix_expression;\n }\n \n@@ -9350,6 +9551,8 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   /* Consume the `}'.  */\n   cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n+  if (flag_enable_cilkplus && contains_array_notation_expr (compound_stmt))\n+    compound_stmt = expand_array_notation_exprs (compound_stmt);\n   return compound_stmt;\n }\n \n@@ -9542,6 +9745,14 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \n \t    /* Now we're all done with the switch-statement.  */\n \t    finish_switch_stmt (statement);\n+\t    if (flag_enable_cilkplus\n+\t\t&& contains_array_notation_expr (condition))\n+\t      {\n+\t\terror_at (EXPR_LOCATION (condition),\n+\t\t\t  \"array notations cannot be used as a condition for \"\n+\t\t\t  \"switch statement\");\n+\t\tstatement = error_mark_node;\n+\t      }      \n \t  }\n \n \treturn statement;\n@@ -10099,6 +10310,12 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tparser->in_statement = in_statement;\n \t/* We're done with the while-statement.  */\n \tfinish_while_stmt (statement);\n+\tif (flag_enable_cilkplus && contains_array_notation_expr (condition))\n+\t  {\n+\t    error_at (EXPR_LOCATION (condition), \"array notations cannot be \"\n+\t\t      \"used as a condition for while statement\");\n+\t    statement = error_mark_node;\n+\t  }\n       }\n       break;\n \n@@ -10125,6 +10342,15 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* Look for the `;'.  */\n \tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+\tif (flag_enable_cilkplus\n+\t    && contains_array_notation_expr (DO_COND (statement)))\n+\t  {\n+\t    error_at (EXPR_LOCATION (DO_COND (statement)),\n+\t\t      \"array notations cannot be used as a condition for a \"\n+\t\t      \"do-while statement\");\n+\t    statement = error_mark_node;\n+\t  }\n+\n       }\n       break;\n \n@@ -10143,8 +10369,17 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tcp_parser_already_scoped_statement (parser);\n \tparser->in_statement = in_statement;\n \n-\t/* We're done with the for-statement.  */\n-\tfinish_for_stmt (statement);\n+\tif (flag_enable_cilkplus\n+\t    && contains_array_notation_expr (FOR_COND (statement)))\n+\t  {\n+\t    error_at (EXPR_LOCATION (FOR_COND (statement)),\n+\t\t      \"array notations cannot be used in a condition for a \"\n+\t\t      \"for-loop\");\n+\t    statement = error_mark_node;\n+\t  }\n+\telse\n+\t  /* We're done with the for-statement.  */\n+\t  finish_for_stmt (statement);\n       }\n       break;\n \n@@ -16719,30 +16954,53 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t    {\n \t      bool non_constant_p;\n \n-\t      bounds\n-\t\t= cp_parser_constant_expression (parser,\n-\t\t\t\t\t\t /*allow_non_constant=*/true,\n-\t\t\t\t\t\t &non_constant_p);\n-\t      if (!non_constant_p)\n-\t\t/* OK */;\n-\t      else if (error_operand_p (bounds))\n-\t\t/* Already gave an error.  */;\n-\t      else if (!parser->in_function_body\n-\t\t       || current_binding_level->kind == sk_function_parms)\n+\t      if (flag_enable_cilkplus\n+\t\t  && cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n \t\t{\n-\t\t  /* Normally, the array bound must be an integral constant\n-\t\t     expression.  However, as an extension, we allow VLAs\n-\t\t     in function scopes as long as they aren't part of a\n-\t\t     parameter declaration.  */\n-\t\t  cp_parser_error (parser,\n-\t\t\t\t   \"array bound is not an integer constant\");\n \t\t  bounds = error_mark_node;\n+\t\t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t    \"array notations cannot be used in declaration\");\n+\t\t  cp_lexer_consume_token (parser->lexer);\n \t\t}\n-\t      else if (processing_template_decl)\n+\t      else\n \t\t{\n-\t\t  /* Remember this wasn't a constant-expression.  */\n-\t\t  bounds = build_nop (TREE_TYPE (bounds), bounds);\n-\t\t  TREE_SIDE_EFFECTS (bounds) = 1;\n+\t\t  bounds\n+\t\t    = cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t     /*allow_non_constant=*/true,\n+\t\t\t\t\t\t     &non_constant_p);\n+\t\t  if (!non_constant_p)\n+\t\t    /* OK */;\n+\t\t  else if (error_operand_p (bounds))\n+\t\t    /* Already gave an error.  */;\n+\t\t  else if (!parser->in_function_body\n+\t\t\t   || current_binding_level->kind == sk_function_parms)\n+\t\t    {\n+\t\t      /* Normally, the array bound must be an integral constant\n+\t\t\t expression.  However, as an extension, we allow VLAs\n+\t\t\t in function scopes as long as they aren't part of a\n+\t\t\t parameter declaration.  */\n+\t\t      cp_parser_error (parser,\n+\t\t\t\t       \"array bound is not an integer constant\");\n+\t\t      bounds = error_mark_node;\n+\t\t    }\n+\t\t  else if (processing_template_decl)\n+\t\t    {\n+\t\t      /* Remember this wasn't a constant-expression.  */\n+\t\t      bounds = build_nop (TREE_TYPE (bounds), bounds);\n+\t\t      TREE_SIDE_EFFECTS (bounds) = 1;\n+\t\t    }\n+\t\t  if (flag_enable_cilkplus\n+\t\t      && cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t\t    {\n+\t\t      location_t loc =\n+\t\t\tcp_lexer_peek_token (parser->lexer)->location;\n+\t\t      while (cp_lexer_next_token_is_not (parser->lexer,\n+\t\t\t\t\t\t\t CPP_CLOSE_SQUARE))\n+\t\t\tcp_lexer_consume_token (parser->lexer);\n+\t\t      error_at (loc, \"array notations cannot be used in \"\n+\t\t\t \t\"declaration\");\n+\t\t      bounds = error_mark_node; \n+\t\t    }\n \t\t}\n \t    }\n \t  else\n@@ -18113,6 +18371,11 @@ cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser,\n   cp_parser_function_body (parser, in_function_try_block);\n   if (check_body_p)\n     check_constexpr_ctor_body (last, list);\n+\n+  /* Transform all array notations to the equivalent array refs and loop.  */\n+  if (flag_enable_cilkplus && contains_array_notation_expr (body))\n+    body = expand_array_notation_exprs (body);\n+  \n   /* Finish the function body.  */\n   finish_function_body (body);\n \n@@ -22092,6 +22355,12 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n \n   finish_lambda_scope ();\n \n+  /* Expand all array notation expressions here.  */\n+  if (flag_enable_cilkplus && current_function_decl\n+      && contains_array_notation_expr (DECL_SAVED_TREE (current_function_decl)))\n+    DECL_SAVED_TREE (current_function_decl) =\n+      expand_array_notation_exprs (DECL_SAVED_TREE (current_function_decl));\n+  \n   /* Finish the function.  */\n   fn = finish_function ((ctor_initializer_p ? 1 : 0) |\n \t\t\t(inline_p ? 2 : 0));"}, {"sha": "c9e376c69c597d5e5096afdbf6203cdfea6be50e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -13753,6 +13753,20 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t RECUR (TREE_OPERAND (t, 1)),\n \t\t\t\t complain|decltype_flag));\n \n+    case ARRAY_NOTATION_REF:\n+      {\n+\ttree start_index, length, stride;\n+\top1 = tsubst_non_call_postfix_expression (ARRAY_NOTATION_ARRAY (t),\n+\t\t\t\t\t\t  args, complain, in_decl);\n+\tstart_index = RECUR (ARRAY_NOTATION_START (t));\n+\tlength = RECUR (ARRAY_NOTATION_LENGTH (t));\n+\tstride = RECUR (ARRAY_NOTATION_STRIDE (t));\n+\tif (!cilkplus_an_triplet_types_ok_p (loc, start_index, length, stride,\n+\t\t\t\t\t     TREE_TYPE (op1)))\n+\t  RETURN (error_mark_node);\n+\tRETURN (build_array_notation_ref (EXPR_LOCATION (t), op1, start_index,\n+\t\t\t\t\t  length, stride, TREE_TYPE (op1)));\n+      }\n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n \tRETURN (tsubst_copy (t, args, complain, in_decl));\n@@ -15725,6 +15739,9 @@ type_unification_real (tree tparms,\n       arg = args[ia];\n       ++ia;\n \n+      if (flag_enable_cilkplus && TREE_CODE (arg) == ARRAY_NOTATION_REF)\n+\treturn 1;\n+\n       if (unify_one_argument (tparms, targs, parm, arg, subr, strict,\n \t\t\t      flags, explain_p))\n \treturn 1;\n@@ -19126,6 +19143,11 @@ instantiate_decl (tree d, int defer_ok,\n       pointer_map_destroy (local_specializations);\n       local_specializations = saved_local_specializations;\n \n+      /* We expand all the array notation expressions here.  */\n+      if (flag_enable_cilkplus\n+\t  && contains_array_notation_expr (DECL_SAVED_TREE (d)))\n+\tDECL_SAVED_TREE (d) = expand_array_notation_exprs (DECL_SAVED_TREE (d));\n+      \n       /* Finish the function.  */\n       d = finish_function (0);\n       expand_or_defer_fn (d);"}, {"sha": "3f0faa8081d2b460d72b53c6c35334b4e678e3a1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -779,6 +779,22 @@ finish_return_stmt (tree expr)\n   tree r;\n   bool no_warning;\n \n+  if (flag_enable_cilkplus && contains_array_notation_expr (expr))\n+    {\n+      size_t rank = 0;\n+      \n+      if (!find_rank (input_location, expr, expr, false, &rank))\n+\treturn error_mark_node;\n+\n+      /* If the return expression contains array notations, then flag it as\n+\t error.  */\n+      if (rank >= 1)\n+\t{\n+\t  error_at (input_location, \"array notation expression cannot be \"\n+\t\t    \"used as a return value\");\n+\t  return error_mark_node;\n+\t}\n+    }\n   expr = check_return_expr (expr, &no_warning);\n \n   if (flag_openmp && !check_omp_return ())\n@@ -8073,6 +8089,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n+    case ARRAY_NOTATION_REF:\n     case ARRAY_REF:\n       r = cxx_eval_array_reference (call, t, allow_non_constant, addr,\n \t\t\t\t    non_constant_p, overflow_p);\n@@ -8884,6 +8901,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       want_rval = true;\n       /* Fall through.  */\n     case ARRAY_REF:\n+    case ARRAY_NOTATION_REF:\n     case ARRAY_RANGE_REF:\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:"}, {"sha": "4f71351f8eb83f847016a02cdca3758513f16ad5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -141,6 +141,7 @@ lvalue_kind (const_tree ref)\n     case INDIRECT_REF:\n     case ARROW_EXPR:\n     case ARRAY_REF:\n+    case ARRAY_NOTATION_REF:\n     case PARM_DECL:\n     case RESULT_DECL:\n       return clk_ordinary;"}, {"sha": "316a657d924f23ce05d09d23af684a135e560dc5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -3005,6 +3005,22 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n       return error_mark_node;\n     }\n \n+  /* If an array's index is an array notation, then its rank cannot be\n+     greater than one.  */ \n+  if (flag_enable_cilkplus && contains_array_notation_expr (idx))\n+    {\n+      size_t rank = 0;\n+\n+      /* If find_rank returns false, then it should have reported an error,\n+\t thus it is unnecessary for repetition.  */\n+      if (!find_rank (loc, idx, idx, true, &rank))\n+\treturn error_mark_node;\n+      if (rank > 1)\n+\t{\n+\t  error_at (loc, \"rank of the array%'s index is greater than 1\");\n+\t  return error_mark_node;\n+\t}\n+    }\n   if (TREE_TYPE (array) == error_mark_node\n       || TREE_TYPE (idx) == error_mark_node)\n     return error_mark_node;\n@@ -3477,8 +3493,12 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n       params = &allocated;\n     }\n \n-  nargs = convert_arguments (parm_types, params, fndecl, LOOKUP_NORMAL,\n-\t\t\t     complain);\n+  if (flag_enable_cilkplus\n+      && is_cilkplus_reduce_builtin (fndecl) != BUILT_IN_NONE)\n+    nargs = (*params)->length ();\n+  else\n+    nargs = convert_arguments (parm_types, params, fndecl, LOOKUP_NORMAL,\n+\t\t\t       complain);\n   if (nargs < 0)\n     return error_mark_node;\n \n@@ -3936,8 +3956,15 @@ cp_build_binary_op (location_t location,\n \t}\n     }\n \n-  type0 = TREE_TYPE (op0);\n-  type1 = TREE_TYPE (op1);\n+  if (flag_enable_cilkplus && contains_array_notation_expr (op0))\n+    type0 = find_correct_array_notation_type (op0);\n+  else\n+    type0 = TREE_TYPE (op0);\n+\n+  if (flag_enable_cilkplus && contains_array_notation_expr (op1))\n+    type1 = find_correct_array_notation_type (op1);\n+  else\n+    type1 = TREE_TYPE (op1);\n \n   /* The expression codes of the data types of the arguments tell us\n      whether the arguments are integers, floating, pointers, etc.  */\n@@ -5140,6 +5167,13 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n \n   gcc_assert (!identifier_p (arg) || !IDENTIFIER_OPNAME_P (arg));\n \n+  if (flag_enable_cilkplus && TREE_CODE (arg) == ARRAY_NOTATION_REF)\n+    {\n+      val = build_address (arg);\n+      if (TREE_CODE (arg) == OFFSET_REF)\n+\tPTRMEM_OK_P (val) = PTRMEM_OK_P (arg);\n+      return val;\n+    }\n   if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n       && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n     {\n@@ -7818,6 +7852,13 @@ convert_for_assignment (tree type, tree rhs,\n   tree rhstype;\n   enum tree_code coder;\n \n+  /* If we are dealing with built-in array notation function then we don't need\n+     to convert them.  They will be broken up into modify exprs in future,\n+     during which all these checks will be done.  */\n+  if (flag_enable_cilkplus\n+      && is_cilkplus_reduce_builtin (fndecl) != BUILT_IN_NONE)\n+    return rhs;\n+  \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);"}, {"sha": "9c3fe0efa14c07ffe15c2d886e6393927772566c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -1,3 +1,31 @@\n+2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-c++-common/cilk-plus/AN/array_test1.c: Make this an execution test.\n+\tAlso changed the returns from error as distinct values so that debugging\n+\tcan get easier.\n+\t* c-c++-common/cilk-plus/AN/if_test_errors.c (main): Made certain\n+\terrors specific to C, if necessary.  Also added new error hooks for C++.\n+\t* c-c++-common/cilk-plus/AN/misc.c (main): Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors.c (main): Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors2.c (main): Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors3.c (main): Likewise.\n+\t* c-c++-common/cilk-plus/AN/pr57541.c (main): Likewise.\n+\t* c-c++-common/cilk-plus/AN/parser_errors4.c (main): In addition to the\n+\tsame changes as parser_errors3.c, spaces were added between colons to\n+\tnot confuse C++ compiler with 2 colons as scope.\n+\t* c-c++-common/cilk-plus/AN/vla.c: Make this test C specific.\n+\t* g++.dg/cilk-plus/AN/array_test1_tplt.cc: New test.\n+\t* g++.dg/cilk-plus/AN/array_test2_tplt.cc: Likewise.\n+\t* g++.dg/cilk-plus/AN/array_test_ND_tplt.cc: Likewise.\n+\t* g++.dg/cilk-plus/AN/braced_list.cc: Likewise.\n+\t* g++.dg/cilk-plus/AN/builtin_fn_custom_tplt.cc: Likewise.\n+\t* g++.dg/cilk-plus/AN/builtin_fn_mutating_tplt.cc: Likewise.\n+\t* g++.dg/cilk-plus/AN/fp_triplet_values_tplt.c: Likewise.\n+\t* g++.dg/cilk-plus/AN/preincr_test.cc: Likewise.\n+\t* g++.dg/cilk-plus/AN/postincr_test.cc: Likewise.\n+\t* g++.dg/cilk-plus/cilk-plus.exp: New script.\n+\t* gcc/testsuite/g++.dg/dg.exp: Included Cilk Plus C++ tests in the list.\n+\t\n 2013-06-21  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR other/53317"}, {"sha": "579d396948e7468f443bfeccff0b308c9da74ea3", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/if_test_errors.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test_errors.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -18,19 +18,19 @@ int main (void)\n     array2[:] = 5;\n   else\n     array2[:] = 10;\n-  if (!(array[0:10:1] + array[0:10:1])) /* { dg-error \"condition and the then-block\" } */\n-    array2d[:][:] = 5;\n+  if (!(array[0:10:1] + array[0:10:1])) /* { dg-error \"condition and the then-block\" \"\" { target c } } */\n+    array2d[:][:] = 5; /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n   else\n     array2[:] = 10;\n \n-  if (!(array[0:10:1] + array[0:10:1])) /* { dg-error \"condition and the else-block\" } */\n+  if (!(array[0:10:1] + array[0:10:1])) /* { dg-error \"condition and the else-block\" \"\" { target c } } */\n     array2[:] = 5;\n   else\n-    array2d[:][:] = 10;\n+    array2d[:][:] = 10; /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n \n \n-  if (TwodArray[:][:] != 10) /* { dg-error \"condition and the then-block\" } */\n-    array2[:] = 10; \n+  if (TwodArray[:][:] != 10) /* { dg-error \"condition and the then-block\" \"\" { target c } } */\n+    array2[:] = 10;  /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n   else\n     array2[:] = 5;\n \n@@ -40,8 +40,8 @@ int main (void)\n     array4[32][:][:][:] = 5;\n \n   /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (FourDArray[42][0:10:1][9:10:-1][0:5:2] != 10) /* { dg-error \"condition and the then-block\" } */\n-    array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 10; \n+  if (FourDArray[42][0:10:1][9:10:-1][0:5:2] != 10) /* { dg-error \"condition and the then-block\" \"\" { target c } } */\n+    array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 10;  /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n   else\n     array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 5;\n "}, {"sha": "14421d94f0cb7d6c0164e9d720bef025316cbe47", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/misc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -73,13 +73,13 @@ int main (void)\n   while (ii != array2[1:x:3][1:2:1]) /* { dg-error \"array notations cannot be used as a condition for while statement\"  } */\n     x = 2;\n \n-  do { /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" } */\n+  do { /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c } } */\n     x = 3;\n-  } while (ii != array2[:][:]); \n+  } while (ii != array2[:][:]); /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c++ } } */\n \n-  do {  /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" } */\n+  do {  /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c } } */\n     x = 2;\n-  } while (ii != (x + array2[:][1:x:2]) + 2);\n+  } while (ii != (x + array2[:][1:x:2]) + 2); /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c++ } } */\n   \n   do { \n     x += 3;"}, {"sha": "18816e0ec6f814fbf7fc4b574a3d28d0eb6a3cc8", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -8,4 +8,4 @@ int main (void)\n   array2[:] = array2[: ;  /* { dg-error \"expected ']'\" } */\n \n   return 0;\n-} /* { dg-error \"expected ';' before\" } */\n+} /* { dg-error \"expected ';' before\" \"\" { target c } } */"}, {"sha": "4314090f4269d6e35423164e811da874cdb91dc7", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -5,7 +5,8 @@ int main (void)\n {\n   int array[10][10], array2[10];\n   \n-  array2[:] = array2[1:2:] ;  /* { dg-error \"expected expression before\" } */\n+  array2[:] = array2[1:2:] ;  /* { dg-error \"expected expression before\" \"\" { target c } } */ \n+  /* { dg-error  \"expected primary-expression before\" \"\" { target c++ } 8 } */\n \n-  return 0; /* { dg-error \"expected ';' before\" } */\n+  return 0; /* { dg-error \"expected ';' before\" \"\" { target c }  } */\n }"}, {"sha": "47b597986742f15231d40cb1d47a7107d062ffd8", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors3.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -5,7 +5,8 @@ int main (void)\n {\n   int array[10][10], array2[10];\n   \n-  array2[:] = array2[1::] ;  /* { dg-error \"expected expression before\" } */\n+  array2[:] = array2[1: :] ;  /* { dg-error \"expected expression before\" \"\" { target c }  } */ \n+  /* { dg-error \"expected primary-expression before\" \"\" { target c++ }  8 } */\n \n-  return 0; /* { dg-error \"expected ';' before\" } */\n+  return 0; /* { dg-error \"expected ';' before\" \"\" { target c } } */\n }"}, {"sha": "a0efc04d25e57690fa2ed347fba49e5ba084b6db", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -5,7 +5,7 @@ int main (void)\n {\n   int array[10][10], array2[10];\n   \n-  array2[:] = array2[::] ;  /* { dg-error \" expected ']' before ':' token\" } */\n+  array2[:] = array2[ : : ] ;  /* { dg-error \" expected ']' before ':' token\" }  */\n \n   return 0;\n }"}, {"sha": "9bff07991a93bcf434343a194cad80afa2ccbf5c", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57541.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -4,11 +4,14 @@\n int A[10];\n \n int main () {\n-  char c = (char)N; /* { dg-error \"undeclared\" } */\n+\n+  /* C compiler uses the term \"undeclared\" whereas C++ compiler uses\n+    \"not declared\".  Thus, grepping for declared seem to be the easiest.  */\n+  char c = (char)N; /* { dg-error \"declared\" } */\n   short s = (short)N;\n   long l = (long)N;\n   A[l:s:c];\n }\n \n-/* { dg-message \"note: each\" \"defined\" { target *-*-* }  7 } */\n+/* { dg-message \"note: each\" \"defined\" { target c }  10 } */\n "}, {"sha": "3b0777e0f3b25ef2d20fcdf90016c037470f208d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/vla.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -std=c99\" } */\n+/* { dg-do compile { target c } } */\n+/* { dg-options \"-fcilkplus -std=c99 -w\" } */\n \n int func (int x)\n {"}, {"sha": "e9ee7ec638583b862505f02215ddd8d6fcb1ae91", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_test1_tplt.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test1_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test1_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test1_tplt.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <cstdlib>\n+#include <string.h>\n+#if HAVE_IO\n+#include <cstdio>\n+#endif\n+template <class T> int main2 (char **argv);\n+\n+int main (void)\n+{\n+  int x = 1, y = 1, z = 1;\n+  char *array[2];\n+  array[0] = strdup (\"a.out\");\n+  array[1] = strdup (\"5\");\n+  x  = main2<unsigned char> (array);\n+  x += main2<char> (array);\n+  y  = main2<short> (array);\n+  y += main2<unsigned short> (array);\n+  y += main2<int> (array);\n+  y += main2<unsigned int> (array);\n+  z  = main2<long> (array);\n+  z += main2<long long> (array);\n+  y += main2<float> (array);\n+  z += main2<double> (array);\n+      \n+  return x+y+z;\n+}\n+template <class T>\n+int main2 (char **argv)\n+{\n+  T array[10];\n+  int ii = 0, x = 2, z= 0 , y = 0;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    array[ii] = 10;\n+\n+  array[0:10:1] = (T)15;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array[ii] != (T)15)\n+      return 1;\n+  \n+\n+  array[0:5:2] = (T)20;\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    if (array[ii] != (T)20)\n+      return 2;\n+\n+\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+\n+  array[x:5:z] = (T)50;\n+  \n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != (T)50)\n+      return 3;\n+\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]); /* (10 - 5) / 5 = 1 */\n+  y = 10-atoi(argv[1]);\n+  \n+  array[x:y:z] = (T)52;\n+#if HAVE_IO\n+  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n+    std::printf(\"%d\\t\", (int)array[ii]);\n+  std::printf(\"\\n\");\n+#endif\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != (T)52)\n+      return 4;\n+    \n+\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+  \n+  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = (T)25;\n+\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != (T)25)\n+      return 5;\n+  \n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+ \n+  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n+    (T)14;\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != (T)14)\n+      return 6;\n+  \n+\n+  array[atoi(\"5\"):5:1] = (T)65;\n+  \n+  for (ii = atoi (\"5\"); ii < 10; ii++)\n+    if (array[ii] != (T)65)\n+      return 7;\n+  \n+\n+  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = 99;\n+\n+#if HAVE_IO\n+  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n+    std::printf(\"%d\\t\", (int)array[ii]);\n+  std::printf(\"\\n\");\n+#endif\n+\n+  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n+    if (array[ii] != (T)99)\n+      return 8;\n+\n+  return 0;\n+}"}, {"sha": "87c37e1bb4cf832deb16070687dbe784514f35e4", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_test2_tplt.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test2_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test2_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test2_tplt.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,141 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <cstdlib>\n+#include <string.h>\n+template <class T> int main2(char **argv);\n+int main(void)\n+{\n+  int x = 1, y = 1, z = 1, w = 1; \n+  char *array[2]; \n+  array[0] = strdup (\"a.out\"); \n+  array[1] = strdup (\"5\");\n+  w  = main2<short>(array);\n+  w += main2<unsigned short> (array);\n+  x  = main2<char> (array);\n+  x += main2<unsigned char> (array);\n+  y  = main2<int> (array);\n+  y += main2<unsigned int> (array);\n+  z = main2<long> (array);\n+  z += main2<unsigned long> (array);\n+  z += main2<long long> (array);\n+      \n+  return (w+x+y+z);\n+}\n+\n+template<class T>\n+int main2(char **argv)\n+{\n+  T array[10], array2[10]; \n+  int  ii = 0, x = 2, z= 0 , y = 0 ;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 10;\n+      array2[ii] = 5000000;\n+    }\n+\n+  array2[0:10:1] = array[0:10:1];\n+\n+  for (ii = 0; ii < 10; ii++)\n+    if (array2[ii] != array[ii])\n+      return 1; \n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 10;\n+      array2[ii] = 5000000;\n+    }\n+  \n+  array2[0:5:2] = array[0:5:2];\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    if (array[ii] != array2[ii])\n+      return 2;\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 10;\n+      array2[ii] = 5000000;\n+    }\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+ \n+  array2[x:5:z] = array[x:5:z];\n+\n+  for (ii = x; ii < 5; ii += z)\n+    if (array2[ii] != array[ii])\n+      return 3;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii] = 500;\n+      array2[ii] = 1000000;\n+    }\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+\n+  array2[x:y:z] = array[x:y:z];\n+  for (ii = x; ii < 10; ii = ii + z)\n+    if (array2[ii] != array[ii])\n+      return 4;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 500;\n+      array2[ii] = 1000000;\n+    }\n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+\n+  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = \n+    array2[x:y:((10-atoi(argv[1]))/atoi(argv[1]))];\n+\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != array2[ii])\n+      return 6;\n+  \n+  \n+  x = atoi(argv[1]);\n+  z = (10-atoi(argv[1]))/atoi(argv[1]);\n+  y = 10-atoi(argv[1]);\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 500;\n+      array2[ii] = 1000000;\n+    }\n+  \n+  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n+    array2[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))];\n+  for (ii = x; ii < 10; ii += z)\n+    if (array[ii] != array2[ii])\n+      return 6;\n+\n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 4;\n+      array2[ii] = 2;\n+    }\n+\n+  array[atoi(\"5\"):5:1] = array2[atoi(\"5\"):5:1];\n+\n+  for (ii = atoi (\"5\"); ii < 10; ii++)\n+    if (array[ii] != array2[ii])\n+      return 7;\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      array[ii]  = 5;\n+      array2[ii] = 1;\n+    }\n+  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = array2[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")];\n+\n+  for (ii = 5; ii < 10; ii++)\n+    if (array2[ii] != array[ii])\n+      return 8;\n+ \n+  return 0;\n+}"}, {"sha": "479ba1348991005b8a615610a2869e4ea1533bff", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_test_ND_tplt.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test_ND_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test_ND_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test_ND_tplt.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#include <cstdlib>\n+#include<string.h>\n+template <class T> int main2(char **argv);\n+\n+int main(void)\n+{\n+  int x = 1, y=1, z=1, w = 1;\n+  char *array[3];\n+  array[0] = strdup (\"a.out\");\n+  array[1] = strdup (\"10\");\n+  array[2] = strdup (\"15\");\n+  w  = main2<char> (array);\n+  w += main2<unsigned char> (array);\n+  x  = main2<int> (array);\n+  x += main2<unsigned int> (array);\n+  y  = main2<long> (array);\n+  y += main2<unsigned long> (array);\n+  z  = main2<short> (array);\n+  z += main2<unsigned short> (array);\n+  return x+y+z;\n+}\n+\n+template <class T>\n+int main2(char **argv)\n+{  \n+  T array[10][15];\n+  T array_2[10][15];\n+  int ii = 0, jj = 0,x = 0, z= 1 , y = 10 ,argc = 3;\n+ \n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  array_2[0:5:2][0:5:3] = array[0:5:2][0:5:3] + 1 + 5 + array[0][5] + x;\n+\n+  for (ii = 0; ii < 10; ii += 2)\n+    {\n+      for (jj = 0; jj < 15; jj += 3)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + 1 + 5 + array[0][5] + x)\n+\t    return 1;\n+\t}\n+    }\n+\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  x = atoi(argv[1]);\n+  y = atoi(argv[2]);\n+  array_2[0:x:1][0:y:1] = array[0:x:1][0:y:1] + x + y + array[0:x:1][0:y:1];\n+\n+  for (ii = 0; ii < x; ii++)\n+    {\n+      for (jj = 0; jj < y; jj++)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + x + y + array[ii][jj])\n+\t    return 2;\n+\t}\n+    }\n+\n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  x = atoi(argv[1]);\n+  y = atoi(argv[2]);\n+  z = (20- atoi (argv[1]))/atoi(argv[1]);\n+  /* (20-10)/10 evaluates to 1 all the time :-). */\n+  array_2[0:x:z][0:y:z] = array[0:x:z][0:y:z] + array[0:x:z][0:y:z] + y + z;\n+  \n+  for (ii = 0; ii < x; ii += z)\n+    {\n+      for (jj = 0; jj < y; jj += z)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] + y + z)\n+\t    return 3;\n+\t}\n+    }\n+\n+\n+ \n+  for (ii = 0; ii < 10; ii++) {\n+    for (jj = 0; jj< 15; jj++) {\n+      array[ii][jj] = ii+jj;\n+      array_2[ii][jj] = 0;\n+    }\n+  }\n+  x = argc-3;\n+  y = 20-atoi(argv[1]);\n+  z = (20- atoi (argv[1]))/atoi(argv[1]);\n+  /* (20-10)/10 evaluates to 1 all the time :-). */\n+  array_2[(argc-3):(20-atoi(argv[1])):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): ((30-atoi(argv[2]))/atoi(argv[2]))] = array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] + array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] * array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])];\n+  \n+  for (ii = 0; ii < 10; ii++)\n+    {\n+      for (jj = 0; jj < 15; jj++)\n+\t{\n+\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] * array[ii][jj])\n+\t    return 4;\n+\t}\n+    }\n+  return 0;\n+}"}, {"sha": "b91de7a499dc35cc1c5eeb945e00ebb0e96ed742", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/braced_list.cc", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbraced_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbraced_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbraced_list.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus -std=c++11 \" } */\n+\n+int main (void)\n+{\n+  int Array[100], Array2[100];\n+\n+  Array[{1,2}:2] = 5; /* { dg-error \"braced list index is not allowed\" } */\n+  Array[1:{1,2}:2] = 5; /* { dg-error \"expected primary-expression before\" } */\n+  Array[1:10:{1,2}] = 5; /* { dg-error \"expected primary-expression before\" } */\n+\n+  return 0;\n+}"}, {"sha": "3d9e87bceb5f6b7a5d34e06ce75342b9b96d5379", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/builtin_fn_custom_tplt.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom_tplt.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus \" } */\n+\n+#if HAVE_IO \n+#include <cstdio>\n+#endif\n+\n+#include <cstdlib>\n+\n+template <class T>\n+T my_func (T x, T y)\n+{\n+  if (x > y)\n+    return x;\n+  else\n+    return y;\n+}\n+\n+template <class T>\n+T main_func (T  *array, T *array2, T identity_val, int size)\n+{\n+  T result;\n+\n+  result = __sec_reduce (identity_val, array[0:size:1] * array2[0:size:1],\n+\t\t\t my_func); // my_func (identity_val, array[5] * array2[5]);\n+  return result;\n+}\n+int main (void)\n+{\n+  int    i_index = 0, f_index = 0, d_index = 0, l_index = 0;\n+  int    iarray[10], iarray2[10], i_result, i_max;\n+  long   larray[10], larray2[10], l_result, l_max;\n+  float  farray[10], farray2[10], f_result, f_max;\n+  double darray[10], darray2[10], d_result, d_max;\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      if (ii%2 && ii)\n+\t{\n+\t  darray[ii] = (double)(1.0000/(double)ii);\n+\t  farray[ii] = (float)(1.00/(float)ii);\n+\t}\n+      else\n+\t{\n+\t  darray[ii] = (double) ii + 0.10;\n+\t  farray[ii] = (float) (1.00/((float)(ii+1.000)));\n+\t}\n+      darray2[ii] = (double) (1.00000/ (double)(ii+1));\n+      farray2[ii] = (float) (1.00/ (float)(ii+1));\n+    }\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      iarray[ii] = ii;\n+      larray[ii] = (long)ii;\n+    }\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      iarray2[ii] = (ii-5);\n+      larray2[ii] = long (ii-5);\n+    }\n+#if HAVE_IO\n+  printf(\"Int: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%2d \", iarray[ii] * iarray2[ii]);\n+    }\n+  printf(\"\\nfloat: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%4.3f \", farray[ii] * farray2[ii]);\n+    }\n+\n+  printf(\"\\nlong: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%2d \", larray[ii] * larray2[ii]);\n+    }\n+\n+  printf(\"\\ndouble: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%4.3f \", (float) (darray[ii] * darray2[ii]));\n+    }\n+  printf(\"\\n\");\n+#endif\n+\n+  i_result = main_func<int> (iarray, iarray2, iarray[0] * iarray2[0], 10);\n+  f_result = main_func<float>(farray, farray2, 0.00, 10);\n+  d_result = main_func<double>(darray, darray2, 0.0000, 10);\n+  l_result = main_func<long>(larray, larray2, 0, 10);\n+\n+#if HAVE_IO\n+  printf(\"int result    = %2d\\n\", i_result);\n+  printf (\"long result   = %2d\\n\", l_result);\n+  printf(\"float result  = %4.3f\\n\", f_result);\n+  printf(\"double result = %4.3lf\\n\", d_result);\n+#endif\n+    \n+  i_max = iarray[0] * iarray2[0];\n+  f_max = farray[0] * farray2[0];\n+  d_max = darray[0] * darray2[0];\n+  l_max = larray[0] * larray2[0];\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      if (i_max < iarray[ii] * iarray2[ii])\n+\ti_max = iarray[ii] * iarray2[ii];\n+      if (f_max < farray[ii] * farray2[ii])\n+\tf_max = farray[ii] * farray2[ii];\n+      if (d_max < darray[ii] * darray2[ii])\n+\td_max = darray[ii] * darray2[ii];\n+      if (l_max < larray[ii] * larray2[ii])\n+\tl_max = larray[ii] * larray2[ii];\n+    }\n+\n+  if (i_max != i_result)\n+    return 1;\n+  if (f_max != f_result)\n+    return 2;\n+  if (d_max != d_result)\n+    return 3;\n+  if (l_max != l_result)\n+    return 4;\n+  return 0;\n+}\n+"}, {"sha": "db81912cbe530e296a4f51f98905788547d5da04", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/builtin_fn_mutating_tplt.cc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating_tplt.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,134 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" }  */\n+\n+#if HAVE_IO \n+#include <cstdio>\n+#include<iostream>\n+#endif\n+\n+#include <cstdlib>\n+\n+template <class T>\n+T my_func (T *x, T y)\n+{\n+  if (*x < y)\n+    *x = y;\n+  else\n+    *x = *x;\n+}\n+\n+template <class T> T my_func (T *x, T y);\n+template <class T>\n+T main_func (T  *array, T *array2, T identity_val, int size)\n+{\n+  T result = identity_val;\n+  \n+  __sec_reduce_mutating (&result, array[0:size] * array2[0:size:1], my_func);\n+  \n+#if HAVE_IO\n+  std::cout << \"Result = \" << result << std::endl;\n+#endif\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  int    iarray[10], iarray2[10], i_result = 0, i_max;\n+  long   larray[10], larray2[10], l_result = 0, l_max;\n+  float  farray[10], farray2[10], f_result = 0, f_max;\n+  double darray[10], darray2[10], d_result = 0, d_max;\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      if (ii%2 && ii)\n+\t{\n+\t  darray[ii] = (double)(1.0000/(double)(ii));\n+\t  farray[ii] = (float)(1.00/(float)(ii));\n+\t}\n+      else\n+\t{\n+\t  darray[ii] = (double) ii + 0.10;\n+\t  farray[ii] = (float) (1.00/((float)(ii) + 0.10));\n+\t}\n+      darray2[ii] = (double) (1.00000/ (double)(ii+1));\n+      farray2[ii] = (float) (1.00/ (float)(ii+1));\n+    }\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      iarray[ii] = ii;\n+      larray[ii] = (long)ii;\n+    }\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      iarray2[ii] = (ii-5);\n+      larray2[ii] = (long)ii-5;\n+    }\n+#if HAVE_IO\n+  printf(\"\\nInt: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%2d \", iarray[ii] * iarray2[ii]);\n+    }\n+  printf(\"\\nfloat: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%3.2f \", farray[ii] * farray2[ii]);\n+    }\n+\n+  printf(\"\\nlong: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%2d \", larray[ii] * larray2[ii]);\n+    }\n+\n+  printf(\"\\ndouble: \");\n+  for (int ii=0; ii < 10; ii++)\n+    {\n+      printf(\"%4.3lf \", (float) (darray[ii] * darray2[ii]));\n+    }\n+  printf(\"\\n\");\n+#endif\n+\n+  i_result = main_func<int> (iarray, iarray2, 0, 10);\n+  l_result = main_func<long>(larray, larray2, 0, 10);\n+  f_result = main_func<float>(farray, farray2, 0.00, 10);\n+  d_result = main_func<double>(darray, darray2, 0.0000, 10);\n+  \n+  i_max = iarray[0] * iarray2[0];\n+  d_max = darray[0] * darray2[0];\n+  f_max = farray[0] * farray2[0];\n+  l_max = larray[0] * larray2[0];\n+  for (int ii = 0; ii < 10; ii++)\n+    {\n+      if (iarray[ii] * iarray2[ii] > i_max)\n+\ti_max = iarray[ii] * iarray2[ii];\n+      if (darray[ii] * darray2[ii] > d_max)\n+\td_max = darray[ii] * darray2[ii];\n+      if (farray[ii] * farray2[ii] > f_max)\n+\tf_max = farray[ii] * farray2[ii];\n+      if (larray[ii] * larray2[ii] > l_max)\n+\tl_max = larray[ii] * larray2[ii];\n+    }\n+#if HAVE_IO\n+  printf(\"int result    = %2d\\n\", i_max);\n+  printf(\"long result   = %2d\\n\", l_max);\n+  printf(\"float result  = %4.3f\\n\", f_max);\n+  printf(\"double result = %4.3lf\\n\", (float)d_max);\n+#endif\n+  \n+ if (i_max != i_result)\n+   return 1;\n+\n+ if (f_max != f_result)\n+   return 2;\n+\n+ if (l_max != l_result)\n+   return 3;\n+\n+ if (d_max != d_result)\n+   return 4;\n+ \n+  return 0;\n+}\n+"}, {"sha": "1387558a83406066f24fc52dba303bea3998cea6", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/fp_triplet_values_tplt.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Ffp_triplet_values_tplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Ffp_triplet_values_tplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Ffp_triplet_values_tplt.c?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+float q;\n+\n+void func (int *x)\n+{\n+  *x = 5;\n+}\n+template <class T> int main2 (T x, T y, T z);\n+\n+int main (void)\n+{\n+  main2 <float> (1.5, 2.3, 3.443);\n+  main2 <double> (1.34393, 2.38383, 4.38383);\n+  return 0;\n+}\n+template <class T> \n+int main2 (T x, T y, T z)\n+{\n+  int array[10], array2[10];\n+  array2[:] = array[x:2]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n+  array2[:] = array[1:y]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[1:2:z] = array[:]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n+  func (&array2[1:x:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[y:9]++; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n+  array2[1:x]++; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[1:9:x]++; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n+  \n+  ++array2[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[:] = array[q:1:3]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n+  array2[:] = array[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  array2[:] = array[1:3:q]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n+  func (&array2[1:q:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n+  return 0;\n+} "}, {"sha": "b0952c71bca59681e87b2b6fa86faeb2663a2f01", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/postincr_test.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpostincr_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpostincr_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpostincr_test.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+#define HAVE_IO 0\n+\n+#if HAVE_IO\n+#include <cstdio>\n+#endif\n+\n+#include <cstdlib>\n+template <class T> int main2(int argc);\n+\n+int main (void)\n+{\n+    return (main2<int>(1) + main2<long> (1) + main2<long long> (1));\n+}\n+\n+#if HAVE_IO\n+template <class T> int print_array (T *array, int size);\n+template <class T> int print_array (T *array, int size)\n+{\n+    for (int ii = 0; ii < size; ii++)\n+          printf(\"%d \", array[ii]);\n+      printf(\"\\n\");\n+        return 0;\n+}\n+#endif\n+\n+template <class T>\n+int main2(int argc)\n+{\n+  T array[10], array_serial[10];\n+\n+  for (int ii = 0; ii < 10; ii++) {\n+    array[ii] = 0;\n+    array_serial[ii] = 0;\n+  }\n+\n+  array[:] = 19383;\n+  for (int ii = 0; ii < 10; ii++)\n+    array_serial[ii] = 19383;\n+\n+  array[:]++;\n+  \n+  for (int ii = 0; ii < 10; ii++)\n+    array_serial[ii]++;\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+\n+  for (int ii  = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 1;\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    array[:]++;\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    for (int jj = 0; jj < 10; jj++)\n+      array_serial[jj]++;\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+\n+  for (int ii  = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 2;\n+\n+  if (argc == 2)\n+    array[0:10:1]++; \n+  \n+  if (argc == 2)\n+    {\n+      for (int ii = 0; ii < 10; ii++)\n+\tarray_serial[ii]++;\n+    }\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+\n+  for (int ii  = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 3;\n+\n+  array[0:10/argc:argc]++; \n+  \n+  for (int ii = 0; ii < 10; ii += argc) \n+    array_serial[ii]++;\n+\n+\n+  for (int ii  = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 4;\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "f5552c7ed0e0a8b8bf726e238150d1c1e4c3504d", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/preincr_test.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpreincr_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpreincr_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpreincr_test.cc?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+\n+#define HAVE_IO 0\n+\n+#if HAVE_IO\n+#include <cstdio>\n+#endif\n+\n+#include <cstdlib>\n+template <class T> int main2(int argc);\n+\n+int main (void)\n+{ \n+  return (main2<int>(1) + main2<long> (1) + main2<long long> (1));\n+}\n+\n+#if HAVE_IO\n+template <class T> int print_array (T *array, int size);\n+template <class T> int print_array (T *array, int size)\n+{\n+      for (int ii = 0; ii < size; ii++) \n+\tprintf(\"%d \", array[ii]); \n+      printf(\"\\n\"); \n+      return 0;\n+}\n+#endif\n+\n+template <class T>\n+int main2(int argc)\n+{\n+  int array[10], array_serial[10];\n+\n+  for (int ii = 0; ii < 10; ii++) {\n+    array[ii] = 0;\n+    array_serial[ii] = 0;\n+  }\n+\n+  array[:] = 19383;\n+  for (int ii = 0; ii < 10; ii++) \n+    array_serial[ii] = 19383;\n+\n+  ++array[:];\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    ++array_serial[ii];\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+  for (int ii = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 1;\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    ++array[:];\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    for (int jj = 0; jj < 10; jj++)\n+      ++array_serial[jj];\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+  for (int ii = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 2;\n+\n+  if (argc == 2)\n+    ++array[0:10:1]; \n+\n+  if (argc == 2)\n+    {\n+      for (int ii = 0; ii < 10; ii++)\n+\t++array_serial[ii];\n+    }\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+  for (int ii = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 3;\n+\n+  ++array[0:10/argc:argc]; \n+  \n+  for (int ii = 0; ii < 10; ii += argc)\n+    {\n+      ++array_serial[ii];\n+    }\n+\n+#if HAVE_IO\n+  print_array<T>(array, 10);\n+  print_array<T>(array_serial, 10);\n+#endif\n+\n+  for (int ii = 0; ii < 10; ii++)\n+    if (array_serial[ii] != array[ii])\n+      return 4;\n+\n+  return 0;\n+}"}, {"sha": "a1535290a5c026ccd9e39ccd2d00f9e12dcd8923", "filename": "gcc/testsuite/g++.dg/cilk-plus/cilk-plus.exp", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -0,0 +1,48 @@\n+#   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Written by Balaji V. Iyer <balaji.v.iyer@intel.com>\n+\n+\n+load_lib g++-dg.exp\n+\n+dg-init\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -g -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O3 -ftree-vectorize -fcilkplus -g\" \" \"\n+dg-finish\n+\n+dg-init\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -g -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -g -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -g -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -g -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/g++.dg/cilk-plus/AN/*.cc]] \" -O3 -ftree-vectorize -fcilkplus -g\" \" \"\n+dg-finish"}, {"sha": "710218e67c5f206f8992e9d52650f65099ca1151", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce86d2eb54f42359291f388a833fa05b6f1bf19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=2ce86d2eb54f42359291f388a833fa05b6f1bf19", "patch": "@@ -33,6 +33,7 @@ dg-init\n set tests [lsort [find $srcdir/$subdir *.C]]\n set tests [prune $tests $srcdir/$subdir/bprob/*]\n set tests [prune $tests $srcdir/$subdir/charset/*]\n+set tests [prune $tests $srcdir/$subdir/cilk-plus/AN/*]\n set tests [prune $tests $srcdir/$subdir/compat/*]\n set tests [prune $tests $srcdir/$subdir/debug/*]\n set tests [prune $tests $srcdir/$subdir/dfp/*]"}]}