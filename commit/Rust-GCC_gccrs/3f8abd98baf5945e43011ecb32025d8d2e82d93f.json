{"sha": "3f8abd98baf5945e43011ecb32025d8d2e82d93f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4YWJkOThiYWY1OTQ1ZTQzMDExZWNiMzIwMjVkOGQyZTgyZDkzZg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2005-03-15T15:48:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T15:48:37Z"}, "message": "s-intman-posix.adb (Notify_Exception): Adjust signature, as handler for sigactions with SA_SIGINFO set.\n\n2005-03-08  Olivier Hainque  <hainque@adacore.com>\n\n\t* s-intman-posix.adb (Notify_Exception): Adjust signature, as handler\n\tfor sigactions with SA_SIGINFO set. Call\n\t__gnat_adjust_context_for_raise before raising, to perform the\n\tpotentially required adjustments to the machine context for the GCC\n\tunwinder.\n\n\t* raise.h (__gnat_adjust_context_for_raise): New prototype.\n\n\t* init.c (__gnat_adjust_context_for_raise) HPUX: Initial revision.\n\tAdjust PC by one in the provided machine context.\n\t(__gnat_install_handler) HPUX: Set SA_SIGINFO in the sigaction flags,\n\tso that the handler is passed the context structure to adjust prior to\n\tthe raise.\n\t(__gnat_error_handler) HPUX: Adjust the signature to match what an\n\tSA_SIGINFO sigaction should look like. Call\n\t__gnat_adjust_context_for_raise before actually raising.\n\t(__gnat_adjust_context_for_raise): Default noop to help PC\n\tadjustments before raise from signal handlers.\n\t(__gnat_error_handler): Indirectly call a predicate function to\n\tdetermine if a condition should be resignaled or not.\n\t(__gnat_set_resignal_predicate): User interface to modify the predicate.\n\t(__gnat_default_resignal_p): Default GNAT predicate.\n\nFrom-SVN: r96482", "tree": {"sha": "313419272b6493965898a2e40f850fa09f2d6163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/313419272b6493965898a2e40f850fa09f2d6163"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f8abd98baf5945e43011ecb32025d8d2e82d93f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8abd98baf5945e43011ecb32025d8d2e82d93f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8abd98baf5945e43011ecb32025d8d2e82d93f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8abd98baf5945e43011ecb32025d8d2e82d93f/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e98a4c668eac2b10f06ff207a24d2ca4e867128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98a4c668eac2b10f06ff207a24d2ca4e867128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e98a4c668eac2b10f06ff207a24d2ca4e867128"}], "stats": {"total": 215, "additions": 176, "deletions": 39}, "files": [{"sha": "e2b6ec44af76dd7a388f3c45ff993c5828071822", "filename": "gcc/ada/init.c", "status": "modified", "additions": 141, "deletions": 30, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8abd98baf5945e43011ecb32025d8d2e82d93f/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8abd98baf5945e43011ecb32025d8d2e82d93f/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=3f8abd98baf5945e43011ecb32025d8d2e82d93f", "patch": "@@ -547,7 +547,7 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n {\n }\n \n-/* Routines called by 5amastop.adb.  */\n+/* Routines called by s-mastop-tru64.adb.  */\n \n #define SC_GP 29\n \n@@ -558,7 +558,7 @@ __gnat_get_code_loc (struct sigcontext *context)\n }\n \n void\n-__gnat_enter_handler ( struct sigcontext *context, char *pc)\n+__gnat_enter_handler (struct sigcontext *context, char *pc)\n {\n   context->sc_pc = (long) pc;\n   context->sc_regs[SC_GP] = exc_lookup_gp (pc);\n@@ -578,11 +578,29 @@ __gnat_machine_state_length (void)\n #elif defined (__hpux__)\n \n #include <signal.h>\n+#include <sys/ucontext.h>\n \n-static void __gnat_error_handler (int);\n+static void\n+__gnat_error_handler (int sig, siginfo_t *siginfo, void *ucontext);\n+\n+/* __gnat_adjust_context_for_raise - see comments along with the default\n+   version later in this file.  */\n+\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n+{\n+  mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n+\n+  if (UseWideRegs (mcontext))\n+    mcontext->ss_wide.ss_32.ss_pcoq_head_lo ++;\n+  else\n+    mcontext->ss_narrow.ss_pcoq_head ++;\n+}\n \n static void\n-__gnat_error_handler (int sig)\n+__gnat_error_handler (int sig, siginfo_t *siginfo, void *ucontext)\n {\n   struct Exception_Data *exception;\n   char *msg;\n@@ -610,6 +628,8 @@ __gnat_error_handler (int sig)\n       msg = \"unhandled signal\";\n     }\n \n+  __gnat_adjust_context_for_raise (sig, ucontext);\n+\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -637,8 +657,8 @@ __gnat_install_handler (void)\n \n   sigaltstack (&stack, NULL);\n \n-  act.sa_handler = __gnat_error_handler;\n-  act.sa_flags = SA_NODEFER | SA_RESTART | SA_ONSTACK;\n+  act.sa_sigaction = __gnat_error_handler;\n+  act.sa_flags = SA_NODEFER | SA_RESTART | SA_ONSTACK | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n   /* Do not install handlers if interrupt state is \"System\" */\n@@ -835,9 +855,16 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n       implementation of __gnat_portable_no_block_spawn, __gnat_portable_wait */\n    __gnat_plist_init();\n \n+   /* Note that we do not activate this for the compiler itself to avoid a\n+      bootstrap path problem.  Older version of gnatbind will generate a call\n+      to __gnat_initialize() without argument. Therefore we cannot use eh in\n+      this case.  It will be possible to remove the following #ifdef at some\n+      point.  */\n+#ifdef IN_RTS\n    /* Install the Structured Exception handler.  */\n    if (eh)\n      __gnat_install_SEH_handler (eh);\n+#endif\n }\n \n /***************************************/\n@@ -1285,6 +1312,70 @@ struct descriptor_s {unsigned short len, mbz; char *adr; };\n \n long __gnat_error_handler (int *, void *);\n \n+/* To deal with VMS conditions and their mapping to Ada exceptions,\n+   the __gnat_error_handler routine below is installed as an exception\n+   vector having precedence over DEC frame handlers.  Some conditions\n+   still need to be handled by such handlers, however, in which case\n+   __gnat_error_handler needs to return SS$_RESIGNAL.  Consider for\n+   instance the use of a third party library compiled with DECAda and\n+   performing it's own exception handling internally.\n+\n+   To allow some user-level flexibility, which conditions should be\n+   resignaled is controlled by a predicate function, provided with the\n+   condition value and returning a boolean indication stating whether\n+   this condition should be resignaled or not.\n+\n+   That predicate function is called indirectly, via a function pointer,\n+   by __gnat_error_handler, and changing that pointer is allowed to the\n+   the user code by way of the __gnat_set_resignal_predicate interface.\n+\n+   The user level function may then implement what it likes, including\n+   for instance the maintenance of a dynamic data structure if the set\n+   of to be resignalled conditions has to change over the program's\n+   lifetime.\n+\n+   ??? This is not a perfect solution to deal with the possible\n+   interactions between the GNAT and the DECAda exception handling\n+   models and better (more general) schemes are studied.  This is so\n+   just provided as a conveniency workaround in the meantime, and\n+   should be use with caution since the implementation has been kept\n+   very simple.  */\n+\n+typedef int\n+resignal_predicate (int code);\n+\n+/* Default GNAT predicate for resignaling conditions.  */\n+\n+static int\n+__gnat_default_resignal_p (int code)\n+{\n+  return\n+    code == CMA$_EXIT_THREAD\n+    || code == SS$_DEBUG /* Gdb attach, resignal to merge activate gdbstub. */\n+    || code == 1409786   /* Nickerson bug #33 ??? */\n+    || code == 1381050   /* Nickerson bug #33 ??? */\n+    || code == 20480426  /* RDB-E-STREAM_EOF */\n+    || code == 11829410  /* Resignalled as Use_Error for CE10VRC */\n+  ;\n+}\n+\n+/* Static pointer to predicate that the __gnat_error_handler exception\n+   vector invokes to determine if it should resignal a condition.  */\n+\n+static resignal_predicate * __gnat_resignal_p = __gnat_default_resignal_p;\n+\n+/* User interface to change the predicate pointer to PREDICATE. Reset to\n+   the default if PREDICATE is null.  */\n+\n+void\n+__gnat_set_resignal_predicate (resignal_predicate * predicate)\n+{\n+  if (predicate == 0)\n+    __gnat_resignal_p = __gnat_default_resignal_p;\n+  else\n+    __gnat_resignal_p = predicate;\n+}\n+\n long\n __gnat_error_handler (int *sigargs, void *mechargs)\n {\n@@ -1301,30 +1392,10 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n   long curr_invo_handle;\n   long *mstate;\n \n-  /* Resignaled condtions aren't effected by by pragma Import_Exception */\n-\n-  switch (sigargs[1])\n-  {\n-\n-    case CMA$_EXIT_THREAD:\n-      return SS$_RESIGNAL;\n-\n-    case SS$_DEBUG: /* Gdb attach, resignal to merge activate gdbstub. */\n-      return SS$_RESIGNAL;\n-\n-    case 1409786: /* Nickerson bug #33 ??? */\n-      return SS$_RESIGNAL;\n-\n-    case 1381050: /* Nickerson bug #33 ??? */\n-      return SS$_RESIGNAL;\n-\n-    case 20480426: /* RDB-E-STREAM_EOF */\n-      return SS$_RESIGNAL;\n-\n-    case 11829410: /* Resignalled as Use_Error for CE10VRC */\n-      return SS$_RESIGNAL;\n-\n-  }\n+  /* Check for conditions to resignal which aren't effected by pragma\n+     Import_Exception.  */\n+  if (__gnat_resignal_p (sigargs [1]))\n+    return SS$_RESIGNAL;\n \n #ifdef IN_RTS\n   /* See if it's an imported exception. Beware that registered exceptions\n@@ -1901,3 +1972,43 @@ __gnat_init_float (void)\n {\n }\n #endif\n+\n+/***********************************/\n+/* __gnat_adjust_context_for_raise */\n+/***********************************/\n+\n+#ifndef HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+/* All targets without a specific version will use an empty one */\n+\n+/* UCONTEXT is a pointer to a context structure received by a signal handler\n+   about to propagate an exception. Adjust it to compensate the fact that the\n+   generic unwinder thinks the corresponding PC is a call return address.  */\n+\n+void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n+\t\t\t\t void *ucontext ATTRIBUTE_UNUSED)\n+{\n+  /* The point is that the interrupted context PC typically is the address\n+     that we should search an EH region for, which is different from the call\n+     return address case. The target independant part of the GCC unwinder\n+     don't differentiate the two situations, so we compensate here for the\n+     adjustments it will blindly make.\n+\n+     signo is passed because on some targets for some signals the PC in\n+     context points to the instruction after the faulting one, in which case\n+     the unwinder adjustment is still desired.  */\n+\n+  /* On a number of targets, we have arranged for the adjustment to be\n+     performed by the MD_FALLBACK_FRAME_STATE circuitry, so we don't provide a\n+     specific instance of this routine.  The MD_FALLBACK doesn't have access\n+     to the signal number, though, so the compensation is systematic there and\n+     might be wrong in some cases.  */\n+\n+  /* Having the compensation wrong leads to potential failures.  A very\n+     typical case is what happens when there is no compensation and a signal\n+     triggers for the first instruction in a region : the unwinder adjustment\n+     has it search in the wrong EH region.  */\n+}\n+\n+#endif"}, {"sha": "ad5bacff7728507de32a322c12339ac3fb4bbc18", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8abd98baf5945e43011ecb32025d8d2e82d93f/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8abd98baf5945e43011ecb32025d8d2e82d93f/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=3f8abd98baf5945e43011ecb32025d8d2e82d93f", "patch": "@@ -70,5 +70,6 @@ extern void __gnat_initialize\t\t(void *);\n extern void __gnat_init_float\t\t(void);\n extern void __gnat_install_handler\t(void);\n extern void __gnat_install_SEH_handler  (void *);\n+extern void __gnat_adjust_context_for_raise (int, void *);\n \n extern int gnat_exit_status;"}, {"sha": "154a7f4aff6574d52d206011a4f6d8f5e79ebd36", "filename": "gcc/ada/s-intman-posix.adb", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8abd98baf5945e43011ecb32025d8d2e82d93f/gcc%2Fada%2Fs-intman-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8abd98baf5945e43011ecb32025d8d2e82d93f/gcc%2Fada%2Fs-intman-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-posix.adb?ref=3f8abd98baf5945e43011ecb32025d8d2e82d93f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -88,7 +88,10 @@ package body System.Interrupt_Management is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Notify_Exception (signo : Signal);\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address);\n    --  This function identifies the Ada exception to be raised using\n    --  the information when the system received a synchronous signal.\n    --  Since this function is machine and OS dependent, different code\n@@ -101,7 +104,24 @@ package body System.Interrupt_Management is\n    Signal_Mask : aliased sigset_t;\n    --  The set of signals handled by Notify_Exception\n \n-   procedure Notify_Exception (signo : Signal) is\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address)\n+   is\n+      pragma Unreferenced (siginfo);\n+\n+      --  The GCC unwinder requires adjustments to the signal's machine\n+      --  context to be able to properly unwind through the signal handler.\n+      --  This is achieved by the target specific subprogram below, provided\n+      --  by init.c to be usable by the non-tasking handler also.\n+\n+      procedure Adjust_Context_For_Raise\n+        (signo    : Signal;\n+         ucontext : System.Address);\n+      pragma Import\n+        (C, Adjust_Context_For_Raise, \"__gnat_adjust_context_for_raise\");\n+\n       Result  : Interfaces.C.int;\n \n    begin\n@@ -111,6 +131,11 @@ package body System.Interrupt_Management is\n       Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n       pragma Assert (Result = 0);\n \n+      --  Perform the necessary context adjustments required by the GCC/ZCX\n+      --  unwinder, harmless in the SJLJ case.\n+\n+      Adjust_Context_For_Raise (signo, ucontext);\n+\n       --  Check that treatment of exception propagation here\n       --  is consistent with treatment of the abort signal in\n       --  System.Task_Primitives.Operations.\n@@ -179,12 +204,12 @@ begin\n \n       --  Setting SA_SIGINFO asks the kernel to pass more than just the signal\n       --  number argument to the handler when it is called. The set of extra\n-      --  parameters typically includes a pointer to a structure describing\n-      --  the interrupted context. Although the Notify_Exception handler does\n-      --  not use this information, it is actually required for the GCC/ZCX\n-      --  exception propagation scheme because on some targets (at least\n-      --  alpha-tru64), the structure contents are not even filled when this\n-      --  flag is not set.\n+      --  parameters includes a pointer to the interrupted context, which the\n+      --  ZCX propagation scheme needs.\n+\n+      --  Most man pages for sigaction mention that sa_sigaction should be set\n+      --  instead of sa_handler when SA_SIGINFO is on.  In practice, the two\n+      --  fields are actually union'ed and located at the same offset.\n \n       --  On some targets, we set sa_flags to SA_NODEFER so that during the\n       --  handler execution we do not change the Signal_Mask to be masked for"}]}