{"sha": "8b7773a4ee4833570eb306cbd64884c288f89d57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI3NzczYTRlZTQ4MzM1NzBlYjMwNmNiZDY0ODg0YzI4OGY4OWQ1Nw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-08-09T16:05:46Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-08-09T16:05:46Z"}, "message": "cgraph.h (cgraph_indirect_call_info): Field anc_offse renamd to offset, updated all users.\n\n2012-08-09  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (cgraph_indirect_call_info): Field anc_offse renamd to\n\toffset, updated all users.  New field agg_contents.\n\t* ipa-prop.h (jump_func_type): Removed IPA_JF_CONST_MEMBER_PTR.\n\t(ipa_pass_through_data): New field agg_preserved.\n\t(ipa_ancestor_jf_data): Likewise.\n\t(ipa_member_ptr_cst): Removed.\n\t(ipa_agg_jf_item): New type.\n\t(ipa_agg_jump_function): Likewise.\n\t(ipa_jump_func): New field agg.  Removed field member_cst.\n\t(ipa_get_jf_pass_through_agg_preserved): New function.\n\t(ipa_get_jf_ancestor_agg_preserved): Likewise.\n\t(ipa_get_jf_member_ptr_pfn): Removed.\n\t(ipa_find_agg_cst_for_param): Declare.\n\t(ipa_load_from_parm_agg): Likewise.\n\t* ipa-prop.c (param_analysis_info): Fields modified and\n\tvisited_statements rename to parm_modified and parm_visited_statements\n\trespectively, added fields ref_modified, ref_visited_statements,\n\tpt_modified and pt_visited_statements.\n\t(ipa_print_node_jump_functions_for_edge): Do not dump const member\n\tfunctions.  Dump agg_preserved flags and aggregate jump functions.\n\t(ipa_set_jf_simple_pass_through): Set also agg_preserved.\n\t(ipa_set_ancestor_jf): Likewise.\n\t(ipa_set_jf_arith_pass_through): Clear agg_preserved.\n\t(ipa_set_jf_member_ptr_cst): Removed.\n\t(is_parm_modified_before_stmt): Logic reversed, renamed to\n\tparm_preserved_before_stmt_p.  Cache visited bitmap only for\n\tnaked DECL parameters.  All callers updated.\n\t(load_from_unmodified_param): Allow NULL parms_ainfo.\n\t(parm_ref_data_preserved_p): New function.\n\t(parm_ref_data_pass_through_p): Likewise.\n\t(ipa_load_from_parm_agg_1): Likewise.\n\t(ipa_load_from_parm_agg): Likewise.\n\t(compute_complex_assign_jump_func): Check if aggregate contents are\n\tpreserved.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(compute_scalar_jump_functions): Removed.\n\t(type_like_member_ptr_p): Also check field position are known and\n\tsane.\n\t(compute_pass_through_member_ptrs): Removed.\n\t(determine_cst_member_ptr): Likewise.\n\t(ipa_known_agg_contents_list): New type.\n\t(determine_known_aggregate_parts): New function.\n\t(compute_cst_member_ptr_arguments): Removed.\n\t(ipa_compute_jump_functions_for_edge): Compute all kinds of jump\n\tfunctions (scalar, aggregate and member pointer).\n\t(ipa_get_member_ptr_load_param): Incorporate into\n\tipa_get_stmt_member_ptr_load_param, also pass back an offset.\n\t(ipa_note_param_call): Clear agg_contents.\n\t(ipa_analyze_indirect_call_uses): Also look for simple pointers loaded\n\tfrom aggregates.  In such cases, store offset of the called field.\n\t(ipa_analyze_node): Initialize new fields of param_analysis_info.\n\t(update_jump_functions_after_inlining): Handle aggregate contents.\n\t(ipa_find_agg_cst_for_param): New function.\n\t(try_make_edge_direct_simple_call): Handle called aggregate values.\n\t(update_indirect_edges_after_inlining): Make sure aggregate preserving\n\tjump functions comply with type compatibility requirements.\n\t(ipa_edge_duplication_hook): Copy also aggregate jump functions.\n\t(ipa_write_jump_function): Stream agg_preserved flags and aggregate\n\tjump functions.  Do not stream member pointer constant jump functions.\n\t(ipa_read_jump_function): Likewise.\n\t(ipa_write_indirect_edge_info): Stream new cgraph_indirect_call_info\n\tfields.\n\t(ipa_read_indirect_edge_info): Likewise.\n\n\t* testsuite/gcc.dg/ipa/iinline-4.c: New test.\n\t* testsuite/gcc.dg/ipa/iinline-5.c: Likewise.\n\t* testsuite/gcc.dg/ipa/iinline-6.c: Likewise.\n\t* testsuite/gcc.dg/ipa/iinline-7.c: Likewise.\n\t* testsuite/gcc.dg/lto/20120723_0.c: Likewise.\n\t* testsuite/gcc.dg/lto/20120723_1.c: Likewise.\n\nFrom-SVN: r190260", "tree": {"sha": "b4b8ef818a3ba89f292cf70e40875c201119ffe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4b8ef818a3ba89f292cf70e40875c201119ffe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b7773a4ee4833570eb306cbd64884c288f89d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7773a4ee4833570eb306cbd64884c288f89d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7773a4ee4833570eb306cbd64884c288f89d57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7773a4ee4833570eb306cbd64884c288f89d57/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b67b3838e94c69f500c84ff58ffa44720a0ec79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67b3838e94c69f500c84ff58ffa44720a0ec79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67b3838e94c69f500c84ff58ffa44720a0ec79c"}], "stats": {"total": 1846, "additions": 1519, "deletions": 327}, "files": [{"sha": "0fe531c66894b3c8967bf4470747a81584cc26b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -1,3 +1,69 @@\n+2012-08-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.h (cgraph_indirect_call_info): Field anc_offse renamd to\n+\toffset, updated all users.  New field agg_contents.\n+\t* ipa-prop.h (jump_func_type): Removed IPA_JF_CONST_MEMBER_PTR.\n+\t(ipa_pass_through_data): New field agg_preserved.\n+\t(ipa_ancestor_jf_data): Likewise.\n+\t(ipa_member_ptr_cst): Removed.\n+\t(ipa_agg_jf_item): New type.\n+\t(ipa_agg_jump_function): Likewise.\n+\t(ipa_jump_func): New field agg.  Removed field member_cst.\n+\t(ipa_get_jf_pass_through_agg_preserved): New function.\n+\t(ipa_get_jf_ancestor_agg_preserved): Likewise.\n+\t(ipa_get_jf_member_ptr_pfn): Removed.\n+\t(ipa_find_agg_cst_for_param): Declare.\n+\t(ipa_load_from_parm_agg): Likewise.\n+\t* ipa-prop.c (param_analysis_info): Fields modified and\n+\tvisited_statements rename to parm_modified and parm_visited_statements\n+\trespectively, added fields ref_modified, ref_visited_statements,\n+\tpt_modified and pt_visited_statements.\n+\t(ipa_print_node_jump_functions_for_edge): Do not dump const member\n+\tfunctions.  Dump agg_preserved flags and aggregate jump functions.\n+\t(ipa_set_jf_simple_pass_through): Set also agg_preserved.\n+\t(ipa_set_ancestor_jf): Likewise.\n+\t(ipa_set_jf_arith_pass_through): Clear agg_preserved.\n+\t(ipa_set_jf_member_ptr_cst): Removed.\n+\t(is_parm_modified_before_stmt): Logic reversed, renamed to\n+\tparm_preserved_before_stmt_p.  Cache visited bitmap only for\n+\tnaked DECL parameters.  All callers updated.\n+\t(load_from_unmodified_param): Allow NULL parms_ainfo.\n+\t(parm_ref_data_preserved_p): New function.\n+\t(parm_ref_data_pass_through_p): Likewise.\n+\t(ipa_load_from_parm_agg_1): Likewise.\n+\t(ipa_load_from_parm_agg): Likewise.\n+\t(compute_complex_assign_jump_func): Check if aggregate contents are\n+\tpreserved.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(compute_scalar_jump_functions): Removed.\n+\t(type_like_member_ptr_p): Also check field position are known and\n+\tsane.\n+\t(compute_pass_through_member_ptrs): Removed.\n+\t(determine_cst_member_ptr): Likewise.\n+\t(ipa_known_agg_contents_list): New type.\n+\t(determine_known_aggregate_parts): New function.\n+\t(compute_cst_member_ptr_arguments): Removed.\n+\t(ipa_compute_jump_functions_for_edge): Compute all kinds of jump\n+\tfunctions (scalar, aggregate and member pointer).\n+\t(ipa_get_member_ptr_load_param): Incorporate into\n+\tipa_get_stmt_member_ptr_load_param, also pass back an offset.\n+\t(ipa_note_param_call): Clear agg_contents.\n+\t(ipa_analyze_indirect_call_uses): Also look for simple pointers loaded\n+\tfrom aggregates.  In such cases, store offset of the called field.\n+\t(ipa_analyze_node): Initialize new fields of param_analysis_info.\n+\t(update_jump_functions_after_inlining): Handle aggregate contents.\n+\t(ipa_find_agg_cst_for_param): New function.\n+\t(try_make_edge_direct_simple_call): Handle called aggregate values.\n+\t(update_indirect_edges_after_inlining): Make sure aggregate preserving\n+\tjump functions comply with type compatibility requirements.\n+\t(ipa_edge_duplication_hook): Copy also aggregate jump functions.\n+\t(ipa_write_jump_function): Stream agg_preserved flags and aggregate\n+\tjump functions.  Do not stream member pointer constant jump functions.\n+\t(ipa_read_jump_function): Likewise.\n+\t(ipa_write_indirect_edge_info): Stream new cgraph_indirect_call_info\n+\tfields.\n+\t(ipa_read_indirect_edge_info): Likewise.\n+\n 2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/39423"}, {"sha": "24ede64448cb8d5cb1fe55d458d1fb7eb84aa62b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -338,9 +338,11 @@ typedef enum cgraph_inline_failed_enum {\n \n struct GTY(()) cgraph_indirect_call_info\n {\n-  /* Offset accumulated from ancestor jump functions of inlined call graph\n-     edges.  */\n-  HOST_WIDE_INT anc_offset;\n+  /* When polymorphic is set, this field contains offset where the object which\n+     was actually used in the polymorphic resides within a larger structure.\n+     If agg_contents is set, the field contains the offset within the aggregate\n+     from which the address to call was loaded.  */\n+  HOST_WIDE_INT offset;\n   /* OBJ_TYPE_REF_TOKEN of a polymorphic call (if polymorphic is set).  */\n   HOST_WIDE_INT otr_token;\n   /* Type of the object from OBJ_TYPE_REF_OBJECT. */\n@@ -353,6 +355,12 @@ struct GTY(()) cgraph_indirect_call_info\n   /* Set when the call is a virtual call with the parameter being the\n      associated object pointer rather than a simple direct call.  */\n   unsigned polymorphic : 1;\n+  /* Set when the call is a call of a pointer loaded from contents of an\n+     aggregate at offset.  */\n+  unsigned agg_contents : 1;\n+  /* When the previous bit is set, this one determines whether the destination\n+     is loaded from a parameter passed by reference. */\n+  unsigned by_ref : 1;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {"}, {"sha": "b9184702aed6d64d8f6e56ff9d649c96893bc90a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -1107,7 +1107,7 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n     }\n \n   token = ie->indirect_info->otr_token;\n-  anc_offset = ie->indirect_info->anc_offset;\n+  anc_offset = ie->indirect_info->offset;\n   otr_type = ie->indirect_info->otr_type;\n \n   t = VEC_index (tree, known_vals, param_index);"}, {"sha": "7f90984c703b5f6c10d1fc5e47ff785f940bf2a1", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 700, "deletions": 307, "changes": 1007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -44,8 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n \n struct param_analysis_info\n {\n-  bool modified;\n-  bitmap visited_statements;\n+  bool parm_modified, ref_modified, pt_modified;\n+  bitmap parm_visited_statements, pt_visited_statements;\n };\n \n /* Vector where the parameter infos are actually stored. */\n@@ -178,24 +178,21 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t    }\n \t  fprintf (f, \"\\n\");\n \t}\n-      else if (type == IPA_JF_CONST_MEMBER_PTR)\n-\t{\n-\t  fprintf (f, \"CONST MEMBER PTR: \");\n-\t  print_generic_expr (f, jump_func->value.member_cst.pfn, 0);\n-\t  fprintf (f, \", \");\n-\t  print_generic_expr (f, jump_func->value.member_cst.delta, 0);\n-\t  fprintf (f, \"\\n\");\n-\t}\n       else if (type == IPA_JF_PASS_THROUGH)\n \t{\n \t  fprintf (f, \"PASS THROUGH: \");\n-\t  fprintf (f, \"%d, op %s \",\n+\t  fprintf (f, \"%d, op %s\",\n \t\t   jump_func->value.pass_through.formal_id,\n \t\t   tree_code_name[(int)\n \t\t\t\t  jump_func->value.pass_through.operation]);\n \t  if (jump_func->value.pass_through.operation != NOP_EXPR)\n-\t    print_generic_expr (f,\n-\t\t\t\tjump_func->value.pass_through.operand, 0);\n+\t    {\n+\t      fprintf (f, \" \");\n+\t      print_generic_expr (f,\n+\t\t\t\t  jump_func->value.pass_through.operand, 0);\n+\t    }\n+\t  if (jump_func->value.pass_through.agg_preserved)\n+\t    fprintf (f, \", agg_preserved\");\n \t  fprintf (f, \"\\n\");\n \t}\n       else if (type == IPA_JF_ANCESTOR)\n@@ -205,8 +202,34 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t\t   jump_func->value.ancestor.formal_id,\n \t\t   jump_func->value.ancestor.offset);\n \t  print_generic_expr (f, jump_func->value.ancestor.type, 0);\n+\t  if (jump_func->value.ancestor.agg_preserved)\n+\t    fprintf (f, \", agg_preserved\");\n \t  fprintf (f, \"\\n\");\n \t}\n+\n+      if (jump_func->agg.items)\n+\t{\n+\t  struct ipa_agg_jf_item *item;\n+\t  int j;\n+\n+\t  fprintf (f, \"         Aggregate passed by %s:\\n\",\n+\t\t   jump_func->agg.by_ref ? \"reference\" : \"value\");\n+\t  FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, jump_func->agg.items,\n+\t\t\t    j, item)\n+\t    {\n+\t      fprintf (f, \"           offset: \" HOST_WIDE_INT_PRINT_DEC \", \",\n+\t\t       item->offset);\n+\t      if (TYPE_P (item->value))\n+\t\tfprintf (f, \"clobber of \" HOST_WIDE_INT_PRINT_DEC \" bits\",\n+\t\t\t tree_low_cst (TYPE_SIZE (item->value), 1));\n+\t      else\n+\t\t{\n+\t\t  fprintf (f, \"cst: \");\n+\t\t  print_generic_expr (f, item->value, 0);\n+\t\t}\n+\t      fprintf (f, \"\\n\");\n+\t    }\n+\t}\n     }\n }\n \n@@ -286,12 +309,14 @@ ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant)\n \n /* Set JFUNC to be a simple pass-through jump function.  */\n static void\n-ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id)\n+ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n+\t\t\t\tbool agg_preserved)\n {\n   jfunc->type = IPA_JF_PASS_THROUGH;\n   jfunc->value.pass_through.operand = NULL_TREE;\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = NOP_EXPR;\n+  jfunc->value.pass_through.agg_preserved = agg_preserved;\n }\n \n /* Set JFUNC to be an arithmetic pass through jump function.  */\n@@ -304,30 +329,20 @@ ipa_set_jf_arith_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.operand = operand;\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = operation;\n+  jfunc->value.pass_through.agg_preserved = false;\n }\n \n /* Set JFUNC to be an ancestor jump function.  */\n \n static void\n ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n-\t\t     tree type, int formal_id)\n+\t\t     tree type, int formal_id, bool agg_preserved)\n {\n   jfunc->type = IPA_JF_ANCESTOR;\n   jfunc->value.ancestor.formal_id = formal_id;\n   jfunc->value.ancestor.offset = offset;\n   jfunc->value.ancestor.type = type;\n-}\n-\n-/* Simple function filling in a member pointer constant jump function (with PFN\n-   and DELTA as the constant value) into JFUNC.  */\n-\n-static void\n-ipa_set_jf_member_ptr_cst (struct ipa_jump_func *jfunc,\n-\t\t\t   tree pfn, tree delta)\n-{\n-  jfunc->type = IPA_JF_CONST_MEMBER_PTR;\n-  jfunc->value.member_cst.pfn = pfn;\n-  jfunc->value.member_cst.delta = delta;\n+  jfunc->value.ancestor.agg_preserved = agg_preserved;\n }\n \n /* Structure to be passed in between detect_type_change and\n@@ -581,30 +596,35 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-/* Return true if the formal parameter PARM might have been modified in this\n-   function before reaching the statement STMT.  PARM_AINFO is a pointer to a\n-   structure containing temporary information about PARM.  */\n+/* Return true if a load from a formal parameter PARM_LOAD is known to retreive\n+   a value known not to be modified in this function before reaching the\n+   statement STMT.  PARM_AINFO is a pointer to a structure containing temporary\n+   information about the parameter.  */\n \n static bool\n-is_parm_modified_before_stmt (struct param_analysis_info *parm_ainfo,\n-\t\t\t      gimple stmt, tree parm)\n+parm_preserved_before_stmt_p (struct param_analysis_info *parm_ainfo,\n+\t\t\t       gimple stmt, tree parm_load)\n {\n   bool modified = false;\n+  bitmap *visited_stmts;\n   ao_ref refd;\n \n-  if (parm_ainfo->modified)\n-    return true;\n+  if (parm_ainfo && parm_ainfo->parm_modified)\n+    return false;\n \n   gcc_checking_assert (gimple_vuse (stmt) != NULL_TREE);\n-  ao_ref_init (&refd, parm);\n-  walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified,\n-\t\t      &modified, &parm_ainfo->visited_statements);\n-  if (modified)\n-    {\n-      parm_ainfo->modified = true;\n-      return true;\n-    }\n-  return false;\n+  ao_ref_init (&refd, parm_load);\n+  /* We can cache visited statements only when parm_ainfo is available and when\n+     we are looking at a naked load of the whole parameter.  */\n+  if (!parm_ainfo || TREE_CODE (parm_load) != PARM_DECL)\n+    visited_stmts = NULL;\n+  else\n+    visited_stmts = &parm_ainfo->parm_visited_statements;\n+  walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n+\t\t      visited_stmts);\n+  if (parm_ainfo && modified)\n+    parm_ainfo->parm_modified = true;\n+  return !modified;\n }\n \n /* If STMT is an assignment that loads a value from an parameter declaration,\n@@ -628,12 +648,158 @@ load_from_unmodified_param (struct ipa_node_params *info,\n \n   index = ipa_get_param_decl_index (info, op1);\n   if (index < 0\n-      || is_parm_modified_before_stmt (&parms_ainfo[index], stmt, op1))\n+      || !parm_preserved_before_stmt_p (parms_ainfo ? &parms_ainfo[index]\n+\t\t\t\t\t: NULL, stmt, op1))\n     return -1;\n \n   return index;\n }\n \n+/* Return true if memory reference REF loads data that are known to be\n+   unmodified in this function before reaching statement STMT.  PARM_AINFO, if\n+   non-NULL, is a pointer to a structure containing temporary information about\n+   PARM.  */\n+\n+static bool\n+parm_ref_data_preserved_p (struct param_analysis_info *parm_ainfo,\n+\t\t\t      gimple stmt, tree ref)\n+{\n+  bool modified = false;\n+  ao_ref refd;\n+\n+  gcc_checking_assert (gimple_vuse (stmt));\n+  if (parm_ainfo && parm_ainfo->ref_modified)\n+    return false;\n+\n+  ao_ref_init (&refd, ref);\n+  walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n+\t\t      NULL);\n+  if (parm_ainfo && modified)\n+    parm_ainfo->ref_modified = true;\n+  return !modified;\n+}\n+\n+/* Return true if the data pointed to by PARM is known to be unmodified in this\n+   function before reaching call statement CALL into which it is passed.\n+   PARM_AINFO is a pointer to a structure containing temporary information\n+   about PARM.  */\n+\n+static bool\n+parm_ref_data_pass_through_p (struct param_analysis_info *parm_ainfo,\n+\t\t\t       gimple call, tree parm)\n+{\n+  bool modified = false;\n+  ao_ref refd;\n+\n+  /* It's unnecessary to calculate anything about memory contnets for a const\n+     function because it is not goin to use it.  But do not cache the result\n+     either.  Also, no such calculations for non-pointers.  */\n+  if (!gimple_vuse (call)\n+      || !POINTER_TYPE_P (TREE_TYPE (parm)))\n+    return false;\n+\n+  if (parm_ainfo->pt_modified)\n+    return false;\n+\n+  ao_ref_init_from_ptr_and_size (&refd, parm, NULL_TREE);\n+  walk_aliased_vdefs (&refd, gimple_vuse (call), mark_modified, &modified,\n+\t\t      parm_ainfo ? &parm_ainfo->pt_visited_statements : NULL);\n+  if (modified)\n+    parm_ainfo->pt_modified = true;\n+  return !modified;\n+}\n+\n+/* Return true if we can prove that OP is a memory reference loading unmodified\n+   data from an aggregate passed as a parameter and if the aggregate is passed\n+   by reference, that the alias type of the load corresponds to the type of the\n+   formal parameter (so that we can rely on this type for TBAA in callers).\n+   INFO and PARMS_AINFO describe parameters of the current function (but the\n+   latter can be NULL), STMT is the load statement.  If function returns true,\n+   *INDEX_P, *OFFSET_P and *BY_REF is filled with the parameter index, offset\n+   within the aggregate and whether it is a load from a value passed by\n+   reference respectively.  */\n+\n+static bool\n+ipa_load_from_parm_agg_1 (struct ipa_node_params *info,\n+\t\t\t  struct param_analysis_info *parms_ainfo, gimple stmt,\n+\t\t\t  tree op, int *index_p, HOST_WIDE_INT *offset_p,\n+\t\t\t  bool *by_ref_p)\n+{\n+  int index;\n+  HOST_WIDE_INT size, max_size;\n+  tree base = get_ref_base_and_extent (op, offset_p, &size, &max_size);\n+\n+  if (max_size == -1 || max_size != size || *offset_p < 0)\n+    return false;\n+\n+  if (DECL_P (base))\n+    {\n+      int index = ipa_get_param_decl_index (info, base);\n+      if (index >= 0\n+\t  && parm_preserved_before_stmt_p (parms_ainfo ? &parms_ainfo[index]\n+\t\t\t\t\t   : NULL, stmt, op))\n+\t{\n+\t  *index_p = index;\n+\t  *by_ref_p = false;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  if (TREE_CODE (base) != MEM_REF\n+\t   || TREE_CODE (TREE_OPERAND (base, 0)) != SSA_NAME\n+\t   || !integer_zerop (TREE_OPERAND (base, 1)))\n+    return false;\n+\n+  if (SSA_NAME_IS_DEFAULT_DEF (TREE_OPERAND (base, 0)))\n+    {\n+      tree parm = SSA_NAME_VAR (TREE_OPERAND (base, 0));\n+      index = ipa_get_param_decl_index (info, parm);\n+    }\n+  else\n+    {\n+      /* This branch catches situations where a pointer parameter is not a\n+\t gimple register, for example:\n+\n+\t void hip7(S*) (struct S * p)\n+\t {\n+\t void (*<T2e4>) (struct S *) D.1867;\n+\t struct S * p.1;\n+\n+\t <bb 2>:\n+\t p.1_1 = p;\n+\t D.1867_2 = p.1_1->f;\n+\t D.1867_2 ();\n+\t gdp = &p;\n+      */\n+\n+      gimple def = SSA_NAME_DEF_STMT (TREE_OPERAND (base, 0));\n+      index = load_from_unmodified_param (info, parms_ainfo, def);\n+    }\n+\n+  if (index >= 0\n+      && parm_ref_data_preserved_p (parms_ainfo ? &parms_ainfo[index] : NULL,\n+\t\t\t\t    stmt, op))\n+    {\n+      *index_p = index;\n+      *by_ref_p = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Just like the previous function, just without the param_analysis_info\n+   pointer, for users outside of this file.  */\n+\n+bool\n+ipa_load_from_parm_agg (struct ipa_node_params *info, gimple stmt,\n+\t\t\ttree op, int *index_p, HOST_WIDE_INT *offset_p,\n+\t\t\tbool *by_ref_p)\n+{\n+  return ipa_load_from_parm_agg_1 (info, NULL, stmt, op, index_p, offset_p,\n+\t\t\t\t   by_ref_p);\n+}\n+\n /* Given that an actual argument is an SSA_NAME (given in NAME) and is a result\n    of an assignment statement STMT, try to determine whether we are actually\n    handling any of the following cases and construct an appropriate jump\n@@ -731,7 +897,11 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t}\n       else if (gimple_assign_single_p (stmt)\n \t       && !detect_type_change_ssa (tc_ssa, call, jfunc))\n-\tipa_set_jf_simple_pass_through (jfunc, index);\n+\t{\n+\t  bool agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n+\t\t\t\t\t\t     call, tc_ssa);\n+\t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n+\t}\n       return;\n     }\n \n@@ -757,7 +927,9 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n   if (index >= 0\n       && !detect_type_change (op1, base, call, jfunc, offset))\n-    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (op1), index);\n+    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (op1), index,\n+\t\t\t parm_ref_data_pass_through_p (&parms_ainfo[index],\n+\t\t\t\t\t\t       call, ssa));\n }\n \n /* Extract the base, offset and MEM_REF expression from a statement ASSIGN if\n@@ -828,6 +1000,7 @@ get_ancestor_addr_info (gimple assign, tree *obj_p, HOST_WIDE_INT *offset)\n \n static void\n compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n+\t\t\t\t    struct param_analysis_info *parms_ainfo,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n \t\t\t\t    gimple call, gimple phi)\n {\n@@ -881,7 +1054,9 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n     }\n \n   if (!detect_type_change (obj, expr, call, jfunc, offset))\n-    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (obj), index);\n+    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (obj), index,\n+\t\t\t parm_ref_data_pass_through_p (&parms_ainfo[index],\n+\t\t\t\t\t\t       call, parm));\n }\n \n /* Given OP which is passed as an actual argument to a called function,\n@@ -916,55 +1091,6 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n   ipa_set_jf_known_type (jfunc, offset, TREE_TYPE (base), TREE_TYPE (op));\n }\n \n-\n-/* Determine the jump functions of scalar arguments.  Scalar means SSA names\n-   and constants of a number of selected types.  INFO is the ipa_node_params\n-   structure associated with the caller, PARMS_AINFO describes state of\n-   analysis with respect to individual formal parameters.  ARGS is the\n-   ipa_edge_args structure describing the callsite CALL which is the call\n-   statement being examined.*/\n-\n-static void\n-compute_scalar_jump_functions (struct ipa_node_params *info,\n-\t\t\t       struct param_analysis_info *parms_ainfo,\n-\t\t\t       struct ipa_edge_args *args,\n-\t\t\t       gimple call)\n-{\n-  tree arg;\n-  unsigned num = 0;\n-\n-  for (num = 0; num < gimple_call_num_args (call); num++)\n-    {\n-      struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, num);\n-      arg = gimple_call_arg (call, num);\n-\n-      if (is_gimple_ip_invariant (arg))\n-\tipa_set_jf_constant (jfunc, arg);\n-      else if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n-\t    {\n-\t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n-\n-\t      if (index >= 0\n-\t\t  && !detect_type_change_ssa (arg, call, jfunc))\n-\t\tipa_set_jf_simple_pass_through (jfunc, index);\n-\t    }\n-\t  else\n-\t    {\n-\t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n-\t      if (is_gimple_assign (stmt))\n-\t\tcompute_complex_assign_jump_func (info, parms_ainfo, jfunc,\n-\t\t\t\t\t\t  call, stmt, arg);\n-\t      else if (gimple_code (stmt) == GIMPLE_PHI)\n-\t\tcompute_complex_ancestor_jump_func (info, jfunc, call, stmt);\n-\t    }\n-\t}\n-      else\n-\tcompute_known_type_jump_func (arg, jfunc, call);\n-    }\n-}\n-\n /* Inspect the given TYPE and return true iff it has the same structure (the\n    same number of fields of the same types) as a C++ member pointer.  If\n    METHOD_PTR and DELTA are non-NULL, store the trees representing the\n@@ -980,14 +1106,16 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n \n   fld = TYPE_FIELDS (type);\n   if (!fld || !POINTER_TYPE_P (TREE_TYPE (fld))\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (fld))) != METHOD_TYPE)\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (fld))) != METHOD_TYPE\n+      || !host_integerp (DECL_FIELD_OFFSET (fld), 1))\n     return false;\n \n   if (method_ptr)\n     *method_ptr = fld;\n \n   fld = DECL_CHAIN (fld);\n-  if (!fld || INTEGRAL_TYPE_P (fld))\n+  if (!fld || INTEGRAL_TYPE_P (fld)\n+      || !host_integerp (DECL_FIELD_OFFSET (fld), 1))\n     return false;\n   if (delta)\n     *delta = fld;\n@@ -998,54 +1126,9 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n   return true;\n }\n \n-/* Go through arguments of the CALL and for every one that looks like a member\n-   pointer, check whether it can be safely declared pass-through and if so,\n-   mark that to the corresponding item of jump FUNCTIONS.  Return true iff\n-   there are non-pass-through member pointers within the arguments.  INFO\n-   describes formal parameters of the caller.  PARMS_INFO is a pointer to a\n-   vector containing intermediate information about each formal parameter.  */\n-\n-static bool\n-compute_pass_through_member_ptrs (struct ipa_node_params *info,\n-\t\t\t\t  struct param_analysis_info *parms_ainfo,\n-\t\t\t\t  struct ipa_edge_args *args,\n-\t\t\t\t  gimple call)\n-{\n-  bool undecided_members = false;\n-  unsigned num;\n-  tree arg;\n-\n-  for (num = 0; num < gimple_call_num_args (call); num++)\n-    {\n-      arg = gimple_call_arg (call, num);\n-\n-      if (type_like_member_ptr_p (TREE_TYPE (arg), NULL, NULL))\n-\t{\n-\t  if (TREE_CODE (arg) == PARM_DECL)\n-\t    {\n-\t      int index = ipa_get_param_decl_index (info, arg);\n-\n-\t      gcc_assert (index >=0);\n-\t      if (!is_parm_modified_before_stmt (&parms_ainfo[index], call,\n-\t\t\t\t\t\t arg))\n-\t\t{\n-\t\t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args,\n-\t\t\t\t\t\t\t\t       num);\n-\t\t  ipa_set_jf_simple_pass_through (jfunc, index);\n-\t\t}\n-\t      else\n-\t\tundecided_members = true;\n-\t    }\n-\t  else\n-\t    undecided_members = true;\n-\t}\n-    }\n-\n-  return undecided_members;\n-}\n-\n /* If RHS is an SSA_NAME and it is defined by a simple copy assign statement,\n-   return the rhs of its defining statement.  */\n+   return the rhs of its defining statement.  Otherwise return RHS as it\n+   is.  */\n \n static inline tree\n get_ssa_def_if_simple_copy (tree rhs)\n@@ -1062,104 +1145,213 @@ get_ssa_def_if_simple_copy (tree rhs)\n   return rhs;\n }\n \n-/* Traverse statements from CALL backwards, scanning whether the argument ARG\n-   which is a member pointer is filled in with constant values.  If it is, fill\n-   the jump function JFUNC in appropriately.  METHOD_FIELD and DELTA_FIELD are\n-   fields of the record type of the member pointer.  To give an example, we\n-   look for a pattern looking like the following:\n+/* TODO: Turn this into a PARAM.  */\n+#define IPA_MAX_AFF_JF_ITEMS 16\n+\n+/* Simple linked list, describing known contents of an aggregate beforere\n+   call.  */\n \n-     D.2515.__pfn ={v} printStuff;\n-     D.2515.__delta ={v} 0;\n-     i_1 = doprinting (D.2515);  */\n+struct ipa_known_agg_contents_list\n+{\n+  /* Offset and size of the described part of the aggregate.  */\n+  HOST_WIDE_INT offset, size;\n+  /* Known constant value or NULL if the contents is known to be unknown.  */\n+  tree constant;\n+  /* Pointer to the next structure in the list.  */\n+  struct ipa_known_agg_contents_list *next;\n+};\n+\n+/* Traverse statements from CALL backwards, scanning whether an aggregate given\n+   in ARG is filled in with constant values.  ARG can either be an aggregate\n+   expression or a pointer to an aggregate.  JFUNC is the jump function into\n+   which the constants are subsequently stored.  */\n \n static void\n-determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n-\t\t\t  tree delta_field, struct ipa_jump_func *jfunc)\n+determine_known_aggregate_parts (gimple call, tree arg,\n+\t\t\t\t struct ipa_jump_func *jfunc)\n {\n+  struct ipa_known_agg_contents_list *list = NULL;\n+  int item_count = 0, const_count = 0;\n+  HOST_WIDE_INT arg_offset, arg_size;\n   gimple_stmt_iterator gsi;\n-  tree method = NULL_TREE;\n-  tree delta = NULL_TREE;\n+  tree arg_base;\n+  bool check_ref, by_ref;\n+  ao_ref r;\n \n-  gsi = gsi_for_stmt (call);\n+  /* The function operates in three stages.  First, we prepare check_ref, r,\n+     arg_base and arg_offset based on what is actually passed as an actual\n+     argument.  */\n \n+  if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+    {\n+      by_ref = true;\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  tree type_size;\n+          if (!host_integerp (TYPE_SIZE (TREE_TYPE (TREE_TYPE (arg))), 1))\n+            return;\n+\t  check_ref = true;\n+\t  arg_base = arg;\n+\t  arg_offset = 0;\n+\t  type_size = TYPE_SIZE (TREE_TYPE (TREE_TYPE (arg)));\n+\t  arg_size = tree_low_cst (type_size, 1);\n+\t  ao_ref_init_from_ptr_and_size (&r, arg_base, NULL_TREE);\n+\t}\n+      else if (TREE_CODE (arg) == ADDR_EXPR)\n+\t{\n+\t  HOST_WIDE_INT arg_max_size;\n+\n+\t  arg = TREE_OPERAND (arg, 0);\n+\t  arg_base = get_ref_base_and_extent (arg, &arg_offset, &arg_size,\n+\t\t\t\t\t  &arg_max_size);\n+\t  if (arg_max_size == -1\n+\t      || arg_max_size != arg_size\n+\t      || arg_offset < 0)\n+\t    return;\n+\t  if (DECL_P (arg_base))\n+\t    {\n+\t      tree size;\n+\t      check_ref = false;\n+\t      size = build_int_cst (integer_type_node, arg_size);\n+\t      ao_ref_init_from_ptr_and_size (&r, arg_base, size);\n+\t    }\n+\t  else\n+\t    return;\n+\t}\n+      else\n+\treturn;\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT arg_max_size;\n+\n+      gcc_checking_assert (AGGREGATE_TYPE_P (TREE_TYPE (arg)));\n+\n+      by_ref = false;\n+      check_ref = false;\n+      arg_base = get_ref_base_and_extent (arg, &arg_offset, &arg_size,\n+\t\t\t\t\t  &arg_max_size);\n+      if (arg_max_size == -1\n+\t  || arg_max_size != arg_size\n+\t  || arg_offset < 0)\n+\treturn;\n+\n+      ao_ref_init (&r, arg);\n+    }\n+\n+  /* Second stage walks back the BB, looks at individual statements and as long\n+     as it is confident of how the statements affect contents of the\n+     aggregates, it builds a sorted linked list of ipa_agg_jf_list structures\n+     describing it.  */\n+  gsi = gsi_for_stmt (call);\n   gsi_prev (&gsi);\n   for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n+      struct ipa_known_agg_contents_list *n, **p;\n       gimple stmt = gsi_stmt (gsi);\n-      tree lhs, rhs, fld;\n+      HOST_WIDE_INT lhs_offset, lhs_size, lhs_max_size;\n+      tree lhs, rhs, lhs_base;\n+      bool partial_overlap;\n \n-      if (!stmt_may_clobber_ref_p (stmt, arg))\n+      if (!stmt_may_clobber_ref_p_1 (stmt, &r))\n \tcontinue;\n       if (!gimple_assign_single_p (stmt))\n-\treturn;\n+\tbreak;\n \n       lhs = gimple_assign_lhs (stmt);\n       rhs = gimple_assign_rhs1 (stmt);\n+      if (!is_gimple_reg_type (rhs))\n+\tbreak;\n \n-      if (TREE_CODE (lhs) != COMPONENT_REF\n-\t  || TREE_OPERAND (lhs, 0) != arg)\n-\treturn;\n+      lhs_base = get_ref_base_and_extent (lhs, &lhs_offset, &lhs_size,\n+\t\t\t\t\t  &lhs_max_size);\n+      if (lhs_max_size == -1\n+\t  || lhs_max_size != lhs_size\n+\t  || (lhs_offset < arg_offset\n+\t      && lhs_offset + lhs_size > arg_offset)\n+\t  || (lhs_offset < arg_offset + arg_size\n+\t      && lhs_offset + lhs_size > arg_offset + arg_size))\n+\tbreak;\n \n-      fld = TREE_OPERAND (lhs, 1);\n-      if (!method && fld == method_field)\n+      if (check_ref)\n \t{\n-\t  rhs = get_ssa_def_if_simple_copy (rhs);\n-\t  if (TREE_CODE (rhs) == ADDR_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (rhs, 0)) == FUNCTION_DECL\n-\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (rhs, 0))) == METHOD_TYPE)\n-\t    {\n-\t      method = TREE_OPERAND (rhs, 0);\n-\t      if (delta)\n-\t\t{\n-\t\t  ipa_set_jf_member_ptr_cst (jfunc, rhs, delta);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  else\n-\t    return;\n+\t  if (TREE_CODE (lhs_base) != MEM_REF\n+\t      || TREE_OPERAND (lhs_base, 0) != arg_base\n+\t      || !integer_zerop (TREE_OPERAND (lhs_base, 1)))\n+\t    break;\n \t}\n+      else if (lhs_base != arg_base)\n+\tbreak;\n \n-      if (!delta && fld == delta_field)\n+      if (lhs_offset + lhs_size < arg_offset\n+\t  || lhs_offset >= (arg_offset + arg_size))\n+\tcontinue;\n+\n+      partial_overlap = false;\n+      p = &list;\n+      while (*p && (*p)->offset < lhs_offset)\n \t{\n-\t  rhs = get_ssa_def_if_simple_copy (rhs);\n-\t  if (TREE_CODE (rhs) == INTEGER_CST)\n+\t  if ((*p)->offset + (*p)->size > lhs_offset)\n \t    {\n-\t      delta = rhs;\n-\t      if (method)\n-\t\t{\n-\t\t  ipa_set_jf_member_ptr_cst (jfunc, rhs, delta);\n-\t\t  return;\n-\t\t}\n+\t      partial_overlap = true;\n+\t      break;\n \t    }\n+\t  p = &(*p)->next;\n+\t}\n+      if (partial_overlap)\n+\tbreak;\n+      if (*p && (*p)->offset < lhs_offset + lhs_size)\n+\t{\n+\t  if ((*p)->offset == lhs_offset && (*p)->size == lhs_size)\n+\t    /* We already know this value is subsequently overwritten with\n+\t       something else.  */\n+\t    continue;\n \t  else\n-\t    return;\n+\t    /* Otherwise this is a partial overlap which we cannot\n+\t       represent.  */\n+\t    break;\n \t}\n-    }\n \n-  return;\n-}\n+      rhs = get_ssa_def_if_simple_copy (rhs);\n+      n = XALLOCA (struct ipa_known_agg_contents_list);\n+      n->size = lhs_size;\n+      n->offset = lhs_offset;\n+      if (is_gimple_ip_invariant (rhs))\n+\t{\n+\t  n->constant = rhs;\n+\t  const_count++;\n+\t}\n+      else\n+\tn->constant = NULL_TREE;\n+      n->next = *p;\n+      *p = n;\n \n-/* Go through the arguments of the CALL and for every member pointer within\n-   tries determine whether it is a constant.  If it is, create a corresponding\n-   constant jump function in FUNCTIONS which is an array of jump functions\n-   associated with the call.  */\n+      item_count++;\n+      if (const_count == IPA_MAX_AFF_JF_ITEMS\n+\t  || item_count == 2 * IPA_MAX_AFF_JF_ITEMS)\n+\tbreak;\n+    }\n \n-static void\n-compute_cst_member_ptr_arguments (struct ipa_edge_args *args,\n-\t\t\t\t  gimple call)\n-{\n-  unsigned num;\n-  tree arg, method_field, delta_field;\n+  /* Third stage just goes over the list and creates an appropriate vector of\n+     ipa_agg_jf_item structures out of it, of sourse only if there are\n+     any known constants to begin with.  */\n \n-  for (num = 0; num < gimple_call_num_args (call); num++)\n+  if (const_count)\n     {\n-      struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, num);\n-      arg = gimple_call_arg (call, num);\n-\n-      if (jfunc->type == IPA_JF_UNKNOWN\n-\t  && type_like_member_ptr_p (TREE_TYPE (arg), &method_field,\n-\t\t\t\t     &delta_field))\n-\tdetermine_cst_member_ptr (call, arg, method_field, delta_field, jfunc);\n+      jfunc->agg.by_ref = by_ref;\n+      jfunc->agg.items = VEC_alloc (ipa_agg_jf_item_t, gc, const_count);\n+      while (list)\n+\t{\n+\t  if (list->constant)\n+\t    {\n+\t      struct ipa_agg_jf_item *item;\n+\t      item = VEC_quick_push (ipa_agg_jf_item_t,\n+\t\t\t\t     jfunc->agg.items, NULL);\n+\t      item->offset = list->offset - arg_offset;\n+\t      item->value = list->constant;\n+\t    }\n+\t  list = list->next;\n+\t}\n     }\n }\n \n@@ -1174,23 +1366,70 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n   struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n   gimple call = cs->call_stmt;\n-  int arg_num = gimple_call_num_args (call);\n+  int n, arg_num = gimple_call_num_args (call);\n \n   if (arg_num == 0 || args->jump_functions)\n     return;\n   VEC_safe_grow_cleared (ipa_jump_func_t, gc, args->jump_functions, arg_num);\n \n-  /* We will deal with constants and SSA scalars first:  */\n-  compute_scalar_jump_functions (info, parms_ainfo, args, call);\n+  for (n = 0; n < arg_num; n++)\n+    {\n+      struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, n);\n+      tree arg = gimple_call_arg (call, n);\n \n-  /* Let's check whether there are any potential member pointers and if so,\n-     whether we can determine their functions as pass_through.  */\n-  if (!compute_pass_through_member_ptrs (info, parms_ainfo, args, call))\n-    return;\n+      if (is_gimple_ip_invariant (arg))\n+\tipa_set_jf_constant (jfunc, arg);\n+      else if (!is_gimple_reg_type (TREE_TYPE (arg))\n+\t       && TREE_CODE (arg) == PARM_DECL)\n+\t{\n+\t  int index = ipa_get_param_decl_index (info, arg);\n \n-  /* Finally, let's check whether we actually pass a new constant member\n-     pointer here...  */\n-  compute_cst_member_ptr_arguments (args, call);\n+\t  gcc_assert (index >=0);\n+\t  /* Aggregate passed by value, check for pass-through, otherwise we\n+\t     will attempt to fill in aggregate contents later in this\n+\t     for cycle.  */\n+\t  if (parm_preserved_before_stmt_p (&parms_ainfo[index], call, arg))\n+\t    {\n+\t      ipa_set_jf_simple_pass_through (jfunc, index, false);\n+\t      continue;\n+\t    }\n+\t}\n+      else if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n+\t    {\n+\t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n+\t      if (index >= 0\n+\t\t  && !detect_type_change_ssa (arg, call, jfunc))\n+\t\t{\n+\t\t  bool agg_p;\n+\t\t  agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n+\t\t\t\t\t\t\tcall, arg);\n+\t\t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n+\t      if (is_gimple_assign (stmt))\n+\t\tcompute_complex_assign_jump_func (info, parms_ainfo, jfunc,\n+\t\t\t\t\t\t  call, stmt, arg);\n+\t      else if (gimple_code (stmt) == GIMPLE_PHI)\n+\t\tcompute_complex_ancestor_jump_func (info, parms_ainfo, jfunc,\n+\t\t\t\t\t\t    call, stmt);\n+\t    }\n+\t}\n+      else\n+\tcompute_known_type_jump_func (arg, jfunc, call);\n+\n+      if ((jfunc->type != IPA_JF_PASS_THROUGH\n+\t      || !ipa_get_jf_pass_through_agg_preserved (jfunc))\n+\t  && (jfunc->type != IPA_JF_ANCESTOR\n+\t      || !ipa_get_jf_ancestor_agg_preserved (jfunc))\n+\t  && (AGGREGATE_TYPE_P (TREE_TYPE (arg))\n+\t      || (POINTER_TYPE_P (TREE_TYPE (arg)))))\n+\tdetermine_known_aggregate_parts (call, arg, jfunc);\n+    }\n }\n \n /* Compute jump functions for all edges - both direct and indirect - outgoing\n@@ -1217,16 +1456,22 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n     ipa_compute_jump_functions_for_edge (parms_ainfo, cs);\n }\n \n-/* If RHS looks like a rhs of a statement loading pfn from a member\n-   pointer formal parameter, return the parameter, otherwise return\n-   NULL.  If USE_DELTA, then we look for a use of the delta field\n-   rather than the pfn.  */\n+/* If STMT looks like a statement loading a value from a member pointer formal\n+   parameter, return that parameter and store the offset of the field to\n+   *OFFSET_P, if it is non-NULL.  Otherwise return NULL (but *OFFSET_P still\n+   might be clobbered).  If USE_DELTA, then we look for a use of the delta\n+   field rather than the pfn.  */\n \n static tree\n-ipa_get_member_ptr_load_param (tree rhs, bool use_delta)\n+ipa_get_stmt_member_ptr_load_param (gimple stmt, bool use_delta,\n+\t\t\t\t    HOST_WIDE_INT *offset_p)\n {\n-  tree rec, ref_field, ref_offset, fld, fld_offset, ptr_field, delta_field;\n+  tree rhs, rec, ref_field, ref_offset, fld, ptr_field, delta_field;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return NULL_TREE;\n \n+  rhs = gimple_assign_rhs1 (stmt);\n   if (TREE_CODE (rhs) == COMPONENT_REF)\n     {\n       ref_field = TREE_OPERAND (rhs, 1);\n@@ -1243,43 +1488,24 @@ ipa_get_member_ptr_load_param (tree rhs, bool use_delta)\n   if (TREE_CODE (rec) != PARM_DECL\n       || !type_like_member_ptr_p (TREE_TYPE (rec), &ptr_field, &delta_field))\n     return NULL_TREE;\n-\n   ref_offset = TREE_OPERAND (rhs, 1);\n \n+  if (use_delta)\n+    fld = delta_field;\n+  else\n+    fld = ptr_field;\n+  if (offset_p)\n+    *offset_p = int_bit_position (fld);\n+\n   if (ref_field)\n     {\n       if (integer_nonzerop (ref_offset))\n \treturn NULL_TREE;\n-\n-      if (use_delta)\n-\tfld = delta_field;\n-      else\n-\tfld = ptr_field;\n-\n       return ref_field == fld ? rec : NULL_TREE;\n     }\n-\n-  if (use_delta)\n-    fld_offset = byte_position (delta_field);\n   else\n-    fld_offset = byte_position (ptr_field);\n-\n-  return tree_int_cst_equal (ref_offset, fld_offset) ? rec : NULL_TREE;\n-}\n-\n-/* If STMT looks like a statement loading a value from a member pointer formal\n-   parameter, this function returns that parameter.  */\n-\n-static tree\n-ipa_get_stmt_member_ptr_load_param (gimple stmt, bool use_delta)\n-{\n-  tree rhs;\n-\n-  if (!gimple_assign_single_p (stmt))\n-    return NULL_TREE;\n-\n-  rhs = gimple_assign_rhs1 (stmt);\n-  return ipa_get_member_ptr_load_param (rhs, use_delta);\n+    return tree_int_cst_equal (byte_position (fld), ref_offset) ? rec\n+      : NULL_TREE;\n }\n \n /* Returns true iff T is an SSA_NAME defined by a statement.  */\n@@ -1305,8 +1531,9 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n \n   cs = cgraph_edge (node, stmt);\n   cs->indirect_info->param_index = param_index;\n-  cs->indirect_info->anc_offset = 0;\n+  cs->indirect_info->offset = 0;\n   cs->indirect_info->polymorphic = 0;\n+  cs->indirect_info->agg_contents = 0;\n   return cs;\n }\n \n@@ -1365,7 +1592,9 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n \n        return (S.*f)(4);\n      }\n-*/\n+\n+   Moreover, the function also looks for called pointers loaded from aggregates\n+   passed by value or reference.  */\n \n static void\n ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n@@ -1380,6 +1609,8 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n   gimple branch;\n   int index;\n   basic_block bb, virt_bb, join;\n+  HOST_WIDE_INT offset;\n+  bool by_ref;\n \n   if (SSA_NAME_IS_DEFAULT_DEF (target))\n     {\n@@ -1390,20 +1621,27 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n       return;\n     }\n \n+  def = SSA_NAME_DEF_STMT (target);\n+  if (gimple_assign_single_p (def)\n+      && ipa_load_from_parm_agg_1 (info, parms_ainfo, def,\n+\t\t\t\t   gimple_assign_rhs1 (def), &index, &offset,\n+\t\t\t\t   &by_ref))\n+    {\n+      struct cgraph_edge *cs = ipa_note_param_call (node, index, call);\n+      cs->indirect_info->offset = offset;\n+      cs->indirect_info->agg_contents = 1;\n+      cs->indirect_info->by_ref = by_ref;\n+      return;\n+    }\n+\n   /* Now we need to try to match the complex pattern of calling a member\n      pointer. */\n-\n-  if (!POINTER_TYPE_P (TREE_TYPE (target))\n+  if (gimple_code (def) != GIMPLE_PHI\n+      || gimple_phi_num_args (def) != 2\n+      || !POINTER_TYPE_P (TREE_TYPE (target))\n       || TREE_CODE (TREE_TYPE (TREE_TYPE (target))) != METHOD_TYPE)\n     return;\n \n-  def = SSA_NAME_DEF_STMT (target);\n-  if (gimple_code (def) != GIMPLE_PHI)\n-    return;\n-\n-  if (gimple_phi_num_args (def) != 2)\n-    return;\n-\n   /* First, we need to check whether one of these is a load from a member\n      pointer that is a parameter to this function. */\n   n1 = PHI_ARG_DEF (def, 0);\n@@ -1414,15 +1652,15 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n   d2 = SSA_NAME_DEF_STMT (n2);\n \n   join = gimple_bb (def);\n-  if ((rec = ipa_get_stmt_member_ptr_load_param (d1, false)))\n+  if ((rec = ipa_get_stmt_member_ptr_load_param (d1, false, &offset)))\n     {\n-      if (ipa_get_stmt_member_ptr_load_param (d2, false))\n+      if (ipa_get_stmt_member_ptr_load_param (d2, false, NULL))\n \treturn;\n \n       bb = EDGE_PRED (join, 0)->src;\n       virt_bb = gimple_bb (d2);\n     }\n-  else if ((rec = ipa_get_stmt_member_ptr_load_param (d2, false)))\n+  else if ((rec = ipa_get_stmt_member_ptr_load_param (d2, false, &offset)))\n     {\n       bb = EDGE_PRED (join, 1)->src;\n       virt_bb = gimple_bb (d1);\n@@ -1477,15 +1715,19 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n \n   rec2 = ipa_get_stmt_member_ptr_load_param (def,\n \t\t\t\t\t     (TARGET_PTRMEMFUNC_VBIT_LOCATION\n-\t\t\t\t\t      == ptrmemfunc_vbit_in_delta));\n-\n+\t\t\t\t\t      == ptrmemfunc_vbit_in_delta),\n+\t\t\t\t\t     NULL);\n   if (rec != rec2)\n     return;\n \n   index = ipa_get_param_decl_index (info, rec);\n-  if (index >= 0 && !is_parm_modified_before_stmt (&parms_ainfo[index],\n-\t\t\t\t\t\t   call, rec))\n-    ipa_note_param_call (node, index, call);\n+  if (index >= 0\n+      && parm_preserved_before_stmt_p (&parms_ainfo[index], call, rec))\n+    {\n+      struct cgraph_edge *cs = ipa_note_param_call (node, index, call);\n+      cs->indirect_info->offset = offset;\n+      cs->indirect_info->agg_contents = 1;\n+    }\n \n   return;\n }\n@@ -1540,7 +1782,7 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n \n   cs = ipa_note_param_call (node, index, call);\n   ii = cs->indirect_info;\n-  ii->anc_offset = anc_offset;\n+  ii->offset = anc_offset;\n   ii->otr_token = tree_low_cst (OBJ_TYPE_REF_TOKEN (target), 1);\n   ii->otr_type = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (target)));\n   ii->polymorphic = 1;\n@@ -1685,8 +1927,12 @@ ipa_analyze_node (struct cgraph_node *node)\n   ipa_compute_jump_functions (node, parms_ainfo);\n \n   for (i = 0; i < param_count; i++)\n-    if (parms_ainfo[i].visited_statements)\n-      BITMAP_FREE (parms_ainfo[i].visited_statements);\n+    {\n+      if (parms_ainfo[i].parm_visited_statements)\n+\tBITMAP_FREE (parms_ainfo[i].parm_visited_statements);\n+      if (parms_ainfo[i].pt_visited_statements)\n+\tBITMAP_FREE (parms_ainfo[i].pt_visited_statements);\n+    }\n \n   current_function_decl = NULL;\n   pop_cfun ();\n@@ -1733,26 +1979,50 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n       if (dst->type == IPA_JF_ANCESTOR)\n \t{\n \t  struct ipa_jump_func *src;\n+\t  int dst_fid = dst->value.ancestor.formal_id;\n \n \t  /* Variable number of arguments can cause havoc if we try to access\n \t     one that does not exist in the inlined edge.  So make sure we\n \t     don't.  */\n-\t  if (dst->value.ancestor.formal_id >= ipa_get_cs_argument_count (top))\n+\t  if (dst_fid >= ipa_get_cs_argument_count (top))\n \t    {\n \t      dst->type = IPA_JF_UNKNOWN;\n \t      continue;\n \t    }\n \n-\t  src = ipa_get_ith_jump_func (top, dst->value.ancestor.formal_id);\n+\t  src = ipa_get_ith_jump_func (top, dst_fid);\n+\n+\t  if (src->agg.items\n+\t      && (dst->value.ancestor.agg_preserved || !src->agg.by_ref))\n+\t    {\n+\t      struct ipa_agg_jf_item *item;\n+\t      int j;\n+\n+\t      /* Currently we do not produce clobber aggregate jump functions,\n+\t\t replace with merging when we do.  */\n+\t      gcc_assert (!dst->agg.items);\n+\n+\t      dst->agg.items = VEC_copy (ipa_agg_jf_item_t, gc, src->agg.items);\n+\t      dst->agg.by_ref = src->agg.by_ref;\n+\t      FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, dst->agg.items, j, item)\n+\t\titem->offset -= dst->value.ancestor.offset;\n+\t    }\n+\n \t  if (src->type == IPA_JF_KNOWN_TYPE)\n \t    combine_known_type_and_ancestor_jfs (src, dst);\n \t  else if (src->type == IPA_JF_PASS_THROUGH\n \t\t   && src->value.pass_through.operation == NOP_EXPR)\n-\t    dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n+\t    {\n+\t      dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n+\t      dst->value.ancestor.agg_preserved &=\n+\t\tsrc->value.pass_through.agg_preserved;\n+\t    }\n \t  else if (src->type == IPA_JF_ANCESTOR)\n \t    {\n \t      dst->value.ancestor.formal_id = src->value.ancestor.formal_id;\n \t      dst->value.ancestor.offset += src->value.ancestor.offset;\n+\t      dst->value.ancestor.agg_preserved &=\n+\t\tsrc->value.ancestor.agg_preserved;\n \t    }\n \t  else\n \t    dst->type = IPA_JF_UNKNOWN;\n@@ -1766,9 +2036,33 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      && (dst->value.pass_through.formal_id\n \t\t  < ipa_get_cs_argument_count (top)))\n \t    {\n-\t      src = ipa_get_ith_jump_func (top,\n-\t\t\t\t\t   dst->value.pass_through.formal_id);\n-\t      *dst = *src;\n+\t      bool agg_p;\n+\t      int dst_fid = dst->value.pass_through.formal_id;\n+\t      src = ipa_get_ith_jump_func (top, dst_fid);\n+\t      agg_p = dst->value.pass_through.agg_preserved;\n+\n+\t      dst->type = src->type;\n+\t      dst->value = src->value;\n+\n+\t      if (src->agg.items\n+\t\t  && (agg_p || !src->agg.by_ref))\n+\t\t{\n+\t\t  /* Currently we do not produce clobber aggregate jump\n+\t\t     functions, replace with merging when we do.  */\n+\t\t  gcc_assert (!dst->agg.items);\n+\n+\t\t  dst->agg.by_ref = src->agg.by_ref;\n+\t\t  dst->agg.items = VEC_copy (ipa_agg_jf_item_t, gc,\n+\t\t\t\t\t     src->agg.items);\n+\t\t}\n+\n+\t      if (!agg_p)\n+\t\t{\n+\t\t  if (dst->type == IPA_JF_PASS_THROUGH)\n+\t\t    dst->value.pass_through.agg_preserved = false;\n+\t\t  else if (dst->type == IPA_JF_ANCESTOR)\n+\t\t    dst->value.ancestor.agg_preserved = false;\n+\t\t}\n \t    }\n \t  else\n \t    dst->type = IPA_JF_UNKNOWN;\n@@ -1815,6 +2109,35 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n   return ie;\n }\n \n+/* Retrieve value from aggregate jump function AGG for the given OFFSET or\n+   return NULL if there is not any.  BY_REF specifies whether the value has to\n+   be passed by reference or by value.  */\n+\n+tree\n+ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n+\t\t\t    HOST_WIDE_INT offset, bool by_ref)\n+{\n+  struct ipa_agg_jf_item *item;\n+  int i;\n+\n+  if (by_ref != agg->by_ref)\n+    return NULL;\n+\n+  FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, agg->items, i, item)\n+    {\n+      if (item->offset == offset)\n+\t{\n+\t  /* Currently we do not have clobber values, return NULL for them once\n+\t     we do.  */\n+\t  gcc_checking_assert (is_gimple_ip_invariant (item->value));\n+\t  return item->value;\n+\t}\n+      else if (item->offset > offset)\n+\treturn NULL;\n+    }\n+  return NULL;\n+}\n+\n /* Try to find a destination for indirect edge IE that corresponds to a simple\n    call or a call of a member function pointer and where the destination is a\n    pointer formal parameter described by jump function JFUNC.  If it can be\n@@ -1826,13 +2149,20 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n {\n   tree target;\n \n-  if (jfunc->type == IPA_JF_CONST)\n-    target = ipa_get_jf_constant (jfunc);\n-  else if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n-    target = ipa_get_jf_member_ptr_pfn (jfunc);\n+  if (ie->indirect_info->agg_contents)\n+    {\n+      target = ipa_find_agg_cst_for_param (&jfunc->agg,\n+\t\t\t\t\t   ie->indirect_info->offset,\n+\t\t\t\t\t   ie->indirect_info->by_ref);\n+      if (!target)\n+\treturn NULL;\n+    }\n   else\n-    return NULL;\n-\n+    {\n+      if (jfunc->type != IPA_JF_CONST)\n+\treturn NULL;\n+      target = ipa_get_jf_constant (jfunc);\n+    }\n   return ipa_make_edge_direct_to_target (ie, target);\n }\n \n@@ -1853,7 +2183,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n   binfo = TYPE_BINFO (ipa_get_jf_known_type_base_type (jfunc));\n   gcc_checking_assert (binfo);\n   binfo = get_binfo_at_offset (binfo, ipa_get_jf_known_type_offset (jfunc)\n-\t\t\t       + ie->indirect_info->anc_offset,\n+\t\t\t       + ie->indirect_info->offset,\n \t\t\t       ie->indirect_info->otr_type);\n   if (binfo)\n     target = gimple_get_virt_method_for_binfo (ie->indirect_info->otr_token,\n@@ -1889,6 +2219,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n     {\n       struct cgraph_indirect_call_info *ici = ie->indirect_info;\n       struct ipa_jump_func *jfunc;\n+      int param_index;\n \n       next_ie = ie->next_callee;\n \n@@ -1902,14 +2233,27 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  continue;\n \t}\n \n-      jfunc = ipa_get_ith_jump_func (top, ici->param_index);\n+      param_index = ici->param_index;\n+      jfunc = ipa_get_ith_jump_func (top, param_index);\n       if (jfunc->type == IPA_JF_PASS_THROUGH\n \t  && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n-\tici->param_index = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t{\n+\t  if (ici->agg_contents\n+\t      && !ipa_get_jf_pass_through_agg_preserved (jfunc))\n+\t    ici->param_index = -1;\n+\t  else\n+\t    ici->param_index = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t}\n       else if (jfunc->type == IPA_JF_ANCESTOR)\n \t{\n- \t  ici->param_index = ipa_get_jf_ancestor_formal_id (jfunc);\n- \t  ici->anc_offset += ipa_get_jf_ancestor_offset (jfunc);\n+\t  if (ici->agg_contents\n+\t      && !ipa_get_jf_ancestor_agg_preserved (jfunc))\n+\t    ici->param_index = -1;\n+\t  else\n+\t    {\n+\t      ici->param_index = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t      ici->offset += ipa_get_jf_ancestor_offset (jfunc);\n+\t    }\n \t}\n       else\n \t/* Either we can find a destination for this edge now or never. */\n@@ -2077,13 +2421,14 @@ ipa_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   ipa_free_node_params_substructures (IPA_NODE_REF (node));\n }\n \n-/* Hook that is called by cgraph.c when a node is duplicated.  */\n+/* Hook that is called by cgraph.c when an edge is duplicated.  */\n \n static void\n ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t\t\t   __attribute__((unused)) void *data)\n {\n   struct ipa_edge_args *old_args, *new_args;\n+  unsigned int i;\n \n   ipa_check_create_edge_args ();\n \n@@ -2092,6 +2437,12 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \n   new_args->jump_functions = VEC_copy (ipa_jump_func_t, gc,\n \t\t\t\t       old_args->jump_functions);\n+\n+  for (i = 0; i < VEC_length (ipa_jump_func_t, old_args->jump_functions); i++)\n+    VEC_index (ipa_jump_func_t, new_args->jump_functions, i)->agg.items\n+      = VEC_copy (ipa_agg_jf_item_t, gc,\n+\t\t  VEC_index (ipa_jump_func_t,\n+\t\t\t     old_args->jump_functions, i)->agg.items);\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -2788,8 +3139,11 @@ static void\n ipa_write_jump_function (struct output_block *ob,\n \t\t\t struct ipa_jump_func *jump_func)\n {\n-  streamer_write_uhwi (ob, jump_func->type);\n+  struct ipa_agg_jf_item *item;\n+  struct bitpack_d bp;\n+  int i, count;\n \n+  streamer_write_uhwi (ob, jump_func->type);\n   switch (jump_func->type)\n     {\n     case IPA_JF_UNKNOWN:\n@@ -2806,16 +3160,33 @@ ipa_write_jump_function (struct output_block *ob,\n       stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n       streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n       streamer_write_uhwi (ob, jump_func->value.pass_through.operation);\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n+      streamer_write_bitpack (&bp);\n       break;\n     case IPA_JF_ANCESTOR:\n       streamer_write_uhwi (ob, jump_func->value.ancestor.offset);\n       stream_write_tree (ob, jump_func->value.ancestor.type, true);\n       streamer_write_uhwi (ob, jump_func->value.ancestor.formal_id);\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, jump_func->value.ancestor.agg_preserved, 1);\n+      streamer_write_bitpack (&bp);\n       break;\n-    case IPA_JF_CONST_MEMBER_PTR:\n-      stream_write_tree (ob, jump_func->value.member_cst.pfn, true);\n-      stream_write_tree (ob, jump_func->value.member_cst.delta, false);\n-      break;\n+    }\n+\n+  count = VEC_length (ipa_agg_jf_item_t, jump_func->agg.items);\n+  streamer_write_uhwi (ob, count);\n+  if (count)\n+    {\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, jump_func->agg.by_ref, 1);\n+      streamer_write_bitpack (&bp);\n+    }\n+\n+  FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, jump_func->agg.items, i, item)\n+    {\n+      streamer_write_uhwi (ob, item->offset);\n+      stream_write_tree (ob, item->value, true);\n     }\n }\n \n@@ -2826,8 +3197,10 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t\t\tstruct ipa_jump_func *jump_func,\n \t\t\tstruct data_in *data_in)\n {\n-  jump_func->type = (enum jump_func_type) streamer_read_uhwi (ib);\n+  struct bitpack_d bp;\n+  int i, count;\n \n+  jump_func->type = (enum jump_func_type) streamer_read_uhwi (ib);\n   switch (jump_func->type)\n     {\n     case IPA_JF_UNKNOWN:\n@@ -2846,16 +3219,32 @@ ipa_read_jump_function (struct lto_input_block *ib,\n       jump_func->value.pass_through.formal_id = streamer_read_uhwi (ib);\n       jump_func->value.pass_through.operation\n \t= (enum tree_code) streamer_read_uhwi (ib);\n+      bp = streamer_read_bitpack (ib);\n+      jump_func->value.pass_through.agg_preserved = bp_unpack_value (&bp, 1);\n       break;\n     case IPA_JF_ANCESTOR:\n       jump_func->value.ancestor.offset = streamer_read_uhwi (ib);\n       jump_func->value.ancestor.type = stream_read_tree (ib, data_in);\n       jump_func->value.ancestor.formal_id = streamer_read_uhwi (ib);\n+      bp = streamer_read_bitpack (ib);\n+      jump_func->value.ancestor.agg_preserved = bp_unpack_value (&bp, 1);\n       break;\n-    case IPA_JF_CONST_MEMBER_PTR:\n-      jump_func->value.member_cst.pfn = stream_read_tree (ib, data_in);\n-      jump_func->value.member_cst.delta = stream_read_tree (ib, data_in);\n-      break;\n+    }\n+\n+  count = streamer_read_uhwi (ib);\n+  jump_func->agg.items = VEC_alloc (ipa_agg_jf_item_t, gc, count);\n+  if (count)\n+    {\n+      bp = streamer_read_bitpack (ib);\n+      jump_func->agg.by_ref = bp_unpack_value (&bp, 1);\n+    }\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipa_agg_jf_item *item = VEC_quick_push (ipa_agg_jf_item_t,\n+\t\t\t\t       jump_func->agg.items, NULL);\n+\n+      item->offset = streamer_read_uhwi (ib);\n+      item->value = stream_read_tree (ib, data_in);\n     }\n }\n \n@@ -2870,9 +3259,11 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   struct bitpack_d bp;\n \n   streamer_write_hwi (ob, ii->param_index);\n-  streamer_write_hwi (ob, ii->anc_offset);\n+  streamer_write_hwi (ob, ii->offset);\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, ii->polymorphic, 1);\n+  bp_pack_value (&bp, ii->agg_contents, 1);\n+  bp_pack_value (&bp, ii->by_ref, 1);\n   streamer_write_bitpack (&bp);\n \n   if (ii->polymorphic)\n@@ -2894,9 +3285,11 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   struct bitpack_d bp;\n \n   ii->param_index = (int) streamer_read_hwi (ib);\n-  ii->anc_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+  ii->offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n   bp = streamer_read_bitpack (ib);\n   ii->polymorphic = bp_unpack_value (&bp, 1);\n+  ii->agg_contents = bp_unpack_value (&bp, 1);\n+  ii->by_ref = bp_unpack_value (&bp, 1);\n   if (ii->polymorphic)\n     {\n       ii->otr_token = (HOST_WIDE_INT) streamer_read_hwi (ib);"}, {"sha": "489e5d859b803ff121500bbb9a03cddf3214dcd2", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -44,10 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n                   argument.\n    Unknown      - neither of the above.\n \n-   IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers, it is a special\n-   constant in this regard because it is in fact a structure consisting of two\n-   values.  Other constants are represented with IPA_JF_CONST.\n-\n    IPA_JF_ANCESTOR is a special pass-through jump function, which means that\n    the result is an address of a part of the object pointed to by the formal\n    parameter to which the function refers.  It is mainly intended to represent\n@@ -74,7 +70,6 @@ enum jump_func_type\n   IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */\n   IPA_JF_KNOWN_TYPE,        /* represented by field known_type */\n   IPA_JF_CONST,             /* represented by field costant */\n-  IPA_JF_CONST_MEMBER_PTR,  /* represented by field member_cst */\n   IPA_JF_PASS_THROUGH,\t    /* represented by field pass_through */\n   IPA_JF_ANCESTOR\t    /* represented by field ancestor */\n };\n@@ -104,6 +99,13 @@ struct GTY(()) ipa_pass_through_data\n      arithmetic operation where the caller's parameter is the first operand and\n      operand field from this structure is the second one.  */\n   enum tree_code operation;\n+  /* When the passed value is a pointer, it is set to true only when we are\n+     certain that no write to the object it points to has occurred since the\n+     caller functions started execution, except for changes noted in the\n+     aggregate part of the jump function (see description of\n+     ipa_agg_jump_function).  The flag is used only when the operation is\n+     NOP_EXPR.  */\n+  bool agg_preserved;\n };\n \n /* Structure holding data required to describe an ancestor pass-through\n@@ -117,21 +119,56 @@ struct GTY(()) ipa_ancestor_jf_data\n   tree type;\n   /* Number of the caller's formal parameter being passed.  */\n   int formal_id;\n+  /* Flag with the same meaning like agg_preserve in ipa_pass_through_data.  */\n+  bool agg_preserved;\n };\n \n-/* Structure holding a C++ member pointer constant.  Holds a pointer to the\n-   method and delta offset.  */\n-struct GTY(()) ipa_member_ptr_cst\n+/* An element in an aggegate part of a jump function describing a known value\n+   at a given offset.  When it is part of a pass-through jump function with\n+   agg_preserved set or an ancestor jump function with agg_preserved set, all\n+   unlisted positions are assumed to be preserved but the value can be a type\n+   node, which means that the particular piece (starting at offset and having\n+   the size of the type) is clobbered with an unknown value.  When\n+   agg_preserved is false or the type of the containing jump function is\n+   different, all unlisted parts are assumed to be unknown and all values must\n+   fullfill is_gimple_ip_invariant.  */\n+\n+typedef struct GTY(()) ipa_agg_jf_item\n+{\n+  /* The offset at which the known value is located within the aggregate.  */\n+  HOST_WIDE_INT offset;\n+\n+  /* The known constant or type if this is a clobber.  */\n+  tree value;\n+} ipa_agg_jf_item_t;\n+\n+DEF_VEC_O (ipa_agg_jf_item_t);\n+DEF_VEC_ALLOC_O (ipa_agg_jf_item_t, gc);\n+\n+/* Aggregate jump function - i.e. description of contents of aggregates passed\n+   either by reference or value.  */\n+\n+struct GTY(()) ipa_agg_jump_function\n {\n-  tree pfn;\n-  tree delta;\n+  /* Description of the individual items.  */\n+  VEC (ipa_agg_jf_item_t, gc) *items;\n+  /* True if the data was passed by reference (as opposed to by value). */\n+  bool by_ref;\n };\n \n+typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;\n+DEF_VEC_P (ipa_agg_jump_function_p);\n+DEF_VEC_ALLOC_P (ipa_agg_jump_function_p, heap);\n+\n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n typedef struct GTY (()) ipa_jump_func\n {\n+  /* Aggregate contants description.  See struct ipa_agg_jump_function and its\n+     description.  */\n+  struct ipa_agg_jump_function agg;\n+\n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump\n      function context.  constant represents the actual constant in constant jump\n@@ -140,7 +177,6 @@ typedef struct GTY (()) ipa_jump_func\n   {\n     struct ipa_known_type_data GTY ((tag (\"IPA_JF_KNOWN_TYPE\"))) known_type;\n     tree GTY ((tag (\"IPA_JF_CONST\"))) constant;\n-    struct ipa_member_ptr_cst GTY ((tag (\"IPA_JF_CONST_MEMBER_PTR\"))) member_cst;\n     struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n     struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n   } GTY ((desc (\"%1.type\"))) value;\n@@ -214,6 +250,15 @@ ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n   return jfunc->value.pass_through.operation;\n }\n \n+/* Return the agg_preserved flag of a pass through jump functin JFUNC.  */\n+\n+static inline bool\n+ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  return jfunc->value.pass_through.agg_preserved;\n+}\n+\n /* Return the offset of an ancestor jump function JFUNC.  */\n \n static inline HOST_WIDE_INT\n@@ -242,13 +287,13 @@ ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.formal_id;\n }\n \n-/* Return the pfn part of a member pointer constant jump function JFUNC.  */\n+/* Return the agg_preserved flag of an ancestor jump functin JFUNC.  */\n \n-static inline tree\n-ipa_get_jf_member_ptr_pfn (struct ipa_jump_func *jfunc)\n+static inline bool\n+ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n {\n-  gcc_checking_assert (jfunc->type == IPA_JF_CONST_MEMBER_PTR);\n-  return jfunc->value.member_cst.pfn;\n+  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n+  return jfunc->value.ancestor.agg_preserved;\n }\n \n /* Summary describing a single formal parameter.  */\n@@ -456,6 +501,12 @@ struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree);\n /* Functions related to both.  */\n void ipa_analyze_node (struct cgraph_node *);\n \n+/* Aggregate jump function related functions.  */\n+tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *, HOST_WIDE_INT,\n+\t\t\t\t bool);\n+bool ipa_load_from_parm_agg (struct ipa_node_params *, gimple, tree, int *,\n+\t\t\t     HOST_WIDE_INT *, bool *);\n+\n /* Debugging interface.  */\n void ipa_print_node_params (FILE *, struct cgraph_node *node);\n void ipa_print_all_params (FILE *);"}, {"sha": "eddc103bf538055cd9d8dc28b5e09f364c63b968", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -1,3 +1,12 @@\n+2012-08-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/iinline-4.c: New test.\n+\t* gcc.dg/ipa/iinline-5.c: Likewise.\n+\t* gcc.dg/ipa/iinline-6.c: Likewise.\n+\t* gcc.dg/ipa/iinline-7.c: Likewise.\n+\t* gcc.dg/lto/20120723_0.c: Likewise.\n+\t* gcc.dg/lto/20120723_1.c: Likewise.\n+\n 2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/39423"}, {"sha": "4de90d6f6b523f5ed41ff47d0eaa2cf7c983f83b", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-4.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-4.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -0,0 +1,221 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  unsigned u;\n+};\n+\n+struct U\n+{\n+  struct U *next;\n+  struct S s;\n+  short a[8];\n+};\n+\n+extern void non_existent(struct S *p, int);\n+\n+/* ----- 1 ----- */\n+\n+static void hooray1 (struct S *p)\n+{\n+  non_existent (p, 1);\n+}\n+\n+static void hiphip1 (struct S *p)\n+{\n+  p->f (p);\n+}\n+\n+int test1 (void)\n+{\n+  struct S s;\n+  s.i = 1234;\n+  s.f = hooray1;\n+  s.u = 1001;\n+  hiphip1 (&s);\n+  return 0;\n+}\n+\n+/* ----- 2 ----- */\n+\n+struct S *gp;\n+\n+static void hooray2 (struct S *p)\n+{\n+  non_existent (p, 2);\n+}\n+\n+static void hip2 (struct S *p)\n+{\n+  p->f (p);\n+}\n+\n+static void hiphip2 (struct S *p)\n+{\n+  hip2 (p);\n+}\n+\n+int test2 (void)\n+{\n+  struct S *p = gp;\n+  p->i = 2341;\n+  p->f = hooray2;\n+  p->u = 1002;\n+  hiphip2 (p);\n+  return 0;\n+}\n+\n+/* ----- 3 ----- */\n+\n+static void hooray3 (struct S *p)\n+{\n+  non_existent (p, 2);\n+}\n+\n+static void hip3 (struct S *p)\n+{\n+  p->f (p);\n+}\n+\n+static __attribute__ ((flatten)) void hiphip3 (struct S *p)\n+{\n+  hip3 (p);\n+}\n+\n+int test3 (void)\n+{\n+  struct S *p = gp;\n+  p->i = 2341;\n+  p->f = hooray3;\n+  p->u = 1003;\n+  hiphip3 (p);\n+  return 0;\n+}\n+\n+/* ----- 4 ----- */\n+\n+static void hooray4 (struct S *p)\n+{\n+  non_existent (p, 3);\n+}\n+\n+static void hiphip4 (struct S s)\n+{\n+  s.f (&s);\n+}\n+\n+int test4(void)\n+{\n+  struct S s;\n+  s.i = 3412;\n+  s.f = hooray4;\n+  s.u = 1004;\n+  hiphip4 (s);\n+  return 0;\n+}\n+\n+/* ----- 5 ----- */\n+\n+struct U *gu;\n+\n+static void hooray5 (struct S *p)\n+{\n+  non_existent (p, 5);\n+}\n+\n+static void hip5 (struct S *p)\n+{\n+  p->f (p);\n+}\n+\n+static void hiphip5 (struct U *u)\n+{\n+  hip5 (&u->s);\n+}\n+\n+int test5 (void)\n+{\n+  struct U *u = gu;\n+  u->next = u;\n+  u->s.i = 9876;\n+  u->s.f = hooray5;\n+  u->s.u = 1005;\n+  hiphip5 (u);\n+  return 0;\n+}\n+\n+/* ----- 6 ----- */\n+\n+static void hooray6 (struct S *p)\n+{\n+  non_existent (p, 6);\n+}\n+\n+static void hip6 (struct S *p)\n+{\n+  p->f (p);\n+}\n+\n+static __attribute__ ((flatten)) void hiphip6 (struct U *u)\n+{\n+  hip6 (&u->s);\n+}\n+\n+int test6 (void)\n+{\n+  struct U *u = gu;\n+  u->next = u;\n+  u->s.i = 9876;\n+  u->s.f = hooray6;\n+  u->s.u = 1006;\n+  hiphip6 (u);\n+  return 0;\n+}\n+\n+/* ----- 7 ----- */\n+\n+struct S **gdp;\n+\n+\n+static void hooray7 (struct S *p)\n+{\n+  non_existent (p, 7);\n+}\n+\n+static void hip7 (struct S *p)\n+{\n+  p->f (p);\n+  gdp = &p;\n+}\n+\n+static void hiphip7 (struct S *p)\n+{\n+  hip7 (p);\n+  gdp = &p;\n+}\n+\n+int test7 (void)\n+{\n+  struct S *p = gp;\n+  p->i = 7341;\n+  p->f = hooray7;\n+  p->u = 1007;\n+  hiphip7 (p);\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-ipa-dump \"hooray1\\[^\\\\n\\]*inline copy in test1\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray2\\[^\\\\n\\]*inline copy in test2\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray3\\[^\\\\n\\]*inline copy in test3\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray4\\[^\\\\n\\]*inline copy in test4\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray5\\[^\\\\n\\]*inline copy in test5\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray6\\[^\\\\n\\]*inline copy in test6\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray7\\[^\\\\n\\]*inline copy in test7\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "8fb47caffccac78f8a4a10da33185d4aab32e3c3", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-5.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-5.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -0,0 +1,124 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  int j,k,l;\n+};\n+\n+struct Z\n+{\n+  unsigned u;\n+  void (*f)(struct Z *, int);\n+  struct Z *next;\n+};\n+\n+static struct Z *gz;\n+static struct S *gs;\n+static int gr = 111;\n+char gc[1024];\n+\n+static __attribute__ ((noinline, noclone)) struct S *\n+get_s (void)\n+{\n+  return (struct S *) &gc;\n+}\n+\n+\n+static void wrong_target_1 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void wrong_target_2 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void wrong_target_3 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void good_target (struct Z *z, int i)\n+{\n+  gr = 0;\n+}\n+\n+static void good_target_3 (struct S *s)\n+{\n+  gr = 0;\n+}\n+\n+static void g1 (struct S *s)\n+{\n+  struct Z *z = (struct Z*) s;\n+  z->f (z, 8);\n+}\n+\n+static void f1 (struct S *s)\n+{\n+  gz->f = good_target;\n+  g1 (s);\n+}\n+\n+static void g2 (struct Z *z)\n+{\n+  z->f (z, 8);\n+}\n+\n+static void f2 (struct S *s)\n+{\n+  gz->f = good_target;\n+  g2 ((struct Z*) s);\n+}\n+\n+static void g3 (struct S *s)\n+{\n+  s->f (s);\n+}\n+\n+static void h3 (struct Z *z)\n+{\n+  gs->f = good_target_3;\n+  g3 ((struct S *) z);\n+}\n+\n+static void f3 (struct S *s)\n+{\n+  h3 ((struct Z*) s);\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  struct S *s = get_s();\n+  s->i = 5678;\n+  s->f = wrong_target_1;\n+  s->j = 1234;\n+  gz = (struct Z *) s;\n+  f1 (s);\n+\n+  s = get_s();\n+  gz = (struct Z *) s;\n+  s->i = 9999;\n+  s->f = wrong_target_1;\n+  f2 (s);\n+\n+  s = get_s();\n+  gs = s;\n+  s->i = 9999;\n+  s->f = wrong_target_3;\n+  f3 (s);\n+\n+  return gr;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump-not \"wrong_target\\[^\\\\n\\]*inline copy in\" \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "5a9b759d883415ade44e0d33781d4868ac2ec15f", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-6.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-6.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -0,0 +1,72 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  int j,k,l;\n+};\n+\n+struct Z\n+{\n+  unsigned u;\n+  void (*f)(struct Z *, int);\n+  struct Z *next;\n+};\n+\n+static struct S *gs;\n+static int gr = 111;\n+char gc[1024];\n+\n+static __attribute__ ((noinline, noclone)) struct S *\n+get_s (void)\n+{\n+  return (struct S *) &gc;\n+}\n+\n+static void wrong_target (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void good_target (struct S *s)\n+{\n+  gr = 0;\n+}\n+\n+static void g1 (struct S *s)\n+{\n+  s->f (s);\n+}\n+\n+static void f2 (struct Z *z)\n+{\n+  gs->f = good_target;\n+  g1 ((struct S *) z);\n+}\n+\n+static inline __attribute__ ((flatten)) void f1 (struct S *s)\n+{\n+  f2 ((struct Z *) s);\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  struct S *s = get_s();\n+  s->i = 5678;\n+  s->f = wrong_target;\n+  s->j = 1234;\n+  gs = s;\n+  f1 (s);\n+\n+  return gr;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump-not \"wrong_target\\[^\\\\n\\]*inline copy in\" \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "c95d374d24898c2ee66aeebb6b7905003ee9fcde", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-7.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-7.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -0,0 +1,157 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  int j,k,l;\n+};\n+\n+struct U\n+{\n+  struct U *next;\n+  struct S s;\n+  short a[8];\n+};\n+\n+struct Z\n+{\n+  unsigned u;\n+  void (*f)(struct Z *, int);\n+  struct Z *next;\n+};\n+\n+static struct Z *gz;\n+static struct U *gu;\n+static int gr = 111;\n+char gc[1024];\n+\n+static __attribute__ ((noinline, noclone)) struct U *\n+get_u (void)\n+{\n+  return (struct U *) &gc;\n+}\n+\n+static void wrong_target_1 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void wrong_target_2 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void wrong_target_3 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void wrong_target_4 (struct S *s)\n+{\n+  abort ();\n+}\n+\n+static void good_target (struct Z *z, int i)\n+{\n+  gr = 0;\n+}\n+\n+static void good_target_4 (struct S *s)\n+{\n+  gr = 0;\n+}\n+\n+static void g1 (struct S *s)\n+{\n+  struct Z *z = (struct Z*) s;\n+  z->f (z, 8);\n+}\n+\n+static void f1 (struct U *u)\n+{\n+  gz->f = good_target;\n+  g1 (&u->s);\n+}\n+\n+static void g2 (struct Z *z)\n+{\n+  z->f (z, 8);\n+}\n+\n+static void f2 (struct U *u)\n+{\n+  gz->f = good_target;\n+  g2 ((struct Z*) &u->s);\n+}\n+\n+static void h3 (struct Z *z)\n+{\n+  z->f (z, 8);\n+}\n+\n+static void g3 (struct S *s)\n+{\n+  h3 ((struct Z*) s);\n+}\n+\n+static void f3 (struct U *u)\n+{\n+  gz->f = good_target;\n+  g3 (&u->s);\n+}\n+\n+static void h4 (struct S *s)\n+{\n+  s->f (s);\n+}\n+\n+static void g4 (struct U *u)\n+{\n+  h4 (&u->s);\n+}\n+\n+static inline __attribute__ ((flatten)) void f4 (struct Z *z)\n+{\n+  gu->s.f = good_target_4;\n+  g4 ((struct U *) z);\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  struct U *u = get_u ();\n+  u->next = u;\n+  u->s.i = 5678;\n+  u->s.f = wrong_target_1;\n+  u->s.j = 1234;\n+  gz = (struct Z *) &u->s;\n+  f1 (u);\n+\n+  u = get_u();\n+  u->s.i = 9999;\n+  u->s.f = wrong_target_2;\n+  gz = (struct Z *) &u->s;\n+  f2 (u);\n+\n+  u = get_u();\n+  u->s.i = 9998;\n+  u->s.f = wrong_target_3;\n+  gz = (struct Z *) &u->s;\n+  f3 (u);\n+\n+  u = get_u();\n+  u->s.i = 9998;\n+  u->s.f = wrong_target_4;\n+  gu = u;\n+  f4 ((struct Z *) u);\n+  return gr;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump-not \"wrong_target\\[^\\\\n\\]*inline copy in\" \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "ea08a0067dac2a6225672fed0f7b4519f9822da0", "filename": "gcc/testsuite/gcc.dg/lto/20120723_0.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_0.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -0,0 +1,52 @@\n+/* Make sure that by reference and by value aggregate jump functions do not get\n+   mixed up.  */\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {{-O3 -fno-early-inlining -flto}} } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  int j;\n+};\n+\n+struct E\n+{\n+  struct S *p;\n+};\n+\n+struct S *gs;\n+int gr = 111;\n+char gc[1024];\n+\n+static __attribute__ ((noinline, noclone)) struct S *\n+get_s (void)\n+{\n+  return (struct S *) &gc;\n+}\n+\n+static void wrong_target (struct S *s)\n+{\n+  abort ();\n+}\n+\n+void bar (struct S *s)\n+{\n+  s->f (s);\n+}\n+\n+extern void foo (struct S *s);\n+\n+int main (int argc, char **argv)\n+{\n+  struct S *s = get_s();\n+  gs = s;\n+  s->i = 5678;\n+  s->f = wrong_target;\n+  s->j = 1234;\n+  foo (s);\n+\n+  return gr;\n+}"}, {"sha": "5c50861b41895b12100760aefeed20090aff5852", "filename": "gcc/testsuite/gcc.dg/lto/20120723_1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7773a4ee4833570eb306cbd64884c288f89d57/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20120723_1.c?ref=8b7773a4ee4833570eb306cbd64884c288f89d57", "patch": "@@ -0,0 +1,39 @@\n+/* Make sure that by reference and by value aggregate jump functions do not get\n+   mixed up.  */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  int j;\n+};\n+\n+struct E\n+{\n+  struct S *p;\n+};\n+\n+extern struct S *gs;\n+extern int gr;\n+extern char gc[1024];\n+\n+static __attribute__ ((noinline, noclone)) struct S *\n+get_s (void)\n+{\n+  return (struct S *) &gc;\n+}\n+\n+static void good_target (struct S *s)\n+{\n+  gr = 0;\n+}\n+\n+extern void bar (struct E e);\n+\n+void foo (struct E e)\n+{\n+  gs->f = good_target;\n+  bar (e);\n+}"}]}