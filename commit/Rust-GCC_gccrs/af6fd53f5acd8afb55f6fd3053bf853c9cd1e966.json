{"sha": "af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2ZmQ1M2Y1YWNkOGFmYjU1ZjZmZDMwNTNiZjg1M2M5Y2QxZTk2Ng==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-03-15T16:30:02Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-03-15T16:30:02Z"}, "message": "Compile-time improvement: 2/n.\n\n\t* cp-tree.h (struct cxx_binding): New datatype;\n\t(struct lang_identifier): Use it.\n\t(LOCAL_BINDING_P): Adjust definition.\n\t(INHERITED_VALUE_BINDING_P): Likewise.\n\t(BINDING_SCOPE): Likewise.\n\t(BINDING_HAS_LEVEL_P): Likewise.\n\t(BINDING_VALUE): Likewise.\n\t(BINDING_TYPE): Likewise.\n\t(IDENTIFIER_VALUE): Likewise.\n\t(struct tree_binding): Remove.\n\t(TS_CP_BINDING): Likewise.\n\t((union lang_tree_node): Remove field \"binding\".\n\t(cxx_binding_clear): New macro.\n\t(binding_for_name): Adjust return type.\n\t(qualified_lookup_using_namespace): Adjust prototype.\n\t(lookup_using_namespace): Adjust prototype.\n\t(cxx_scope_find_binding_for_name): Declare.\n\t* cp-tree.def: Remove CPLUS_BINDING definition.\n\t* parse.y (parse_scoped_id): Don't type-abuse of 'id'.  Allocate\n\ttemporary cxx_binding on stack.  Simplify.\n\t* decl.c (push_binding): Adjust local variable type.\n\t(add_binding): Likewise.\n\t(push_class_binding): Likewise.\n\t(pop_binding): Likewise.\n\t(poplevel): Likewise.\n\t(poplevel_class): Likewise.\n\t(free_bindings):  Adjust type.\n\t(find_binding): Adjust return type, add a third parameter. Remove\n\tnon-useful assertion now that we use static typing.\n\t(cxx_scope_find_binding_for_name): New function.\n\t(binding_for_name): Use it.  Adjust local variable type. Simplify.\n\t(namespace_binding):  Simplify.\n\t(set_namespace_binding): Likewise.\n\t(set_identifier_type_value_with_scope): Adjust local variable type.\n\t(lookup_tag): Don't type-abuse of local variable 'old'.\n\t(lookup_namespace_name): Likewise.  Allocate binding on stack.\n\t(select_decl): Adjust prototype.\n\t(unqualified_namespace_lookup):  Allocate binding on stack.\n\tDon't type-abuse of local variable 'val'.\n\t(lookup_name_real): Likewise.\n\t(maybe_inject_for_scope_var): Adjust local variable type.\n\t(cp_tree_node_structure): Remove CPLUS_BINDING case label.\n\t(namespace_binding): Adjust logic, simplify.\n\t(BINDING_LEVEL): Adjust definition.\n\t(push_class_level_binding): Adjust local variable type.\n\t(struct cxx_saved_binding): Adjust field 'binding' type.\n\t* decl2.c (ambiguous_decl): Adjust prototype.\n\t(lookup_using_namespace): Adjust local variable type.\n\t(qualified_lookup_using_namespace): Catch type error and correct\n\tensueing logic error.\n\t(do_nonmember_using_decl): Adjust local variable type.  Allocate\n\ttemporary cxx_binding on stack.\n\t(do_toplevel_using_decl): Adjust local variable type.\n\t* ptree.c (cxx_print_cxx_binding): New function.\n\t(cxx_print_identifier): Use it.\n\t(cxx_print_xnode): Delete CPLUS_BINDING case label.\n\nFrom-SVN: r64405", "tree": {"sha": "7349be09ef1983abeeb19f9341ad6d3f522f3799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7349be09ef1983abeeb19f9341ad6d3f522f3799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "151c68c36f3c591d162f7aab74d38ee7384f9f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151c68c36f3c591d162f7aab74d38ee7384f9f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151c68c36f3c591d162f7aab74d38ee7384f9f3d"}], "stats": {"total": 479, "additions": 262, "deletions": 217}, "files": [{"sha": "10da17a4e78291e09ab65844dc903ae641025026", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "patch": "@@ -1,3 +1,61 @@\n+2003-03-15    <gcc@integrable-solutions.net>\n+\t\n+\tCompile-time improvement: 2/n.\n+\t* cp-tree.h (struct cxx_binding): New datatype;\n+\t(struct lang_identifier): Use it.\n+\t(LOCAL_BINDING_P): Adjust definition.\n+\t(INHERITED_VALUE_BINDING_P): Likewise.\n+\t(BINDING_SCOPE): Likewise.\n+\t(BINDING_HAS_LEVEL_P): Likewise.\n+\t(BINDING_VALUE): Likewise.\n+\t(BINDING_TYPE): Likewise.\n+\t(IDENTIFIER_VALUE): Likewise.\n+\t(struct tree_binding): Remove.\n+\t(TS_CP_BINDING): Likewise.\n+\t((union lang_tree_node): Remove field \"binding\".\n+\t(cxx_binding_clear): New macro.\n+\t(binding_for_name): Adjust return type.\n+\t(qualified_lookup_using_namespace): Adjust prototype.\n+\t(lookup_using_namespace): Adjust prototype.\n+\t(cxx_scope_find_binding_for_name): Declare.\n+\t* cp-tree.def: Remove CPLUS_BINDING definition.\n+\t* decl.c (push_binding): Adjust local variable type.\n+\t(add_binding): Likewise.\n+\t(push_class_binding): Likewise.\n+\t(pop_binding): Likewise.\n+\t(poplevel): Likewise.\n+\t(poplevel_class): Likewise.\n+\t(free_bindings):  Adjust type.\n+\t(find_binding): Adjust return type, add a third parameter. Remove\n+\tnon-useful assertion now that we use static typing.  \n+\t(cxx_scope_find_binding_for_name): New function.\n+\t(binding_for_name): Use it.  Adjust local variable type. Simplify. \n+\t(namespace_binding):  Simplify.\n+\t(set_namespace_binding): Likewise.\n+\t(set_identifier_type_value_with_scope): Adjust local variable type.\n+\t(lookup_tag): Don't type-abuse of local variable 'old'.\n+\t(lookup_namespace_name): Likewise.  Allocate binding on stack.\n+\t(select_decl): Adjust prototype.\n+\t(unqualified_namespace_lookup):  Allocate binding on stack.\n+\tDon't type-abuse of local variable 'val'.\n+\t(lookup_name_real): Likewise.\n+\t(maybe_inject_for_scope_var): Adjust local variable type.\n+\t(cp_tree_node_structure): Remove CPLUS_BINDING case label.\n+\t(namespace_binding): Adjust logic, simplify.\n+\t(BINDING_LEVEL): Adjust definition.\n+\t(push_class_level_binding): Adjust local variable type.\n+\t(struct cxx_saved_binding): Adjust field 'binding' type.\n+\t* decl2.c (ambiguous_decl): Adjust prototype.\n+\t(lookup_using_namespace): Adjust local variable type.\n+\t(qualified_lookup_using_namespace): Catch type error and correct\n+\tensueing logic error.\n+\t(do_nonmember_using_decl): Adjust local variable type.  Allocate\n+\ttemporary cxx_binding on stack.\n+\t(do_toplevel_using_decl): Adjust local variable type.\n+\t* ptree.c (cxx_print_cxx_binding): New function.\n+\t(cxx_print_identifier): Use it.\n+\t(cxx_print_xnode): Delete CPLUS_BINDING case label.\n+\n 2003-03-15  Roger Sayle  <roger@eyesopen.com>\n \n \t* tree.c (count_functions): Fix whitespace."}, {"sha": "e95d5935b70fece207774d801f1cf10147348ee4", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "patch": "@@ -222,11 +222,6 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'x', 2)\n    the template may be a LOOKUP_EXPR.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n-/* An association between name and entity. Parameters are the scope\n-   and the (non-type) value.  TREE_TYPE indicates the type bound to\n-   the name. */\n-DEFTREECODE (CPLUS_BINDING, \"binding\", 'x', 2)\n-\n /* A list-like node for chaining overloading candidates. TREE_TYPE is \n    the original name, and the parameter is the FUNCTION_DECL.  */\n DEFTREECODE (OVERLOAD, \"overload\", 'x', 1)"}, {"sha": "59699cd918cc7e2ff353199a0d8a10b48f953ecd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "patch": "@@ -44,7 +44,6 @@ struct diagnostic_context;\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n       LOOKUP_EXPR_GLOBAL (in LOOKUP_EXPR).\n       TREE_INDIRECT_USING (in NAMESPACE_DECL).\n-      LOCAL_BINDING_P (in CPLUS_BINDING)\n       ICS_USER_FLAG (in _CONV)\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n@@ -56,14 +55,12 @@ struct diagnostic_context;\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (in _TYPE).\n-      INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       BINFO_DEPENDENT_BASE_P (in BINFO)\n       DECL_INITIALIZED_P (in VAR_DECL)\n    2: IDENTIFIER_OPNAME_P.\n       TYPE_POLYMORPHIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n-      BINDING_HAS_LEVEL_P (in CPLUS_BINDING)\n       BINFO_LOST_PRIMARY_P (in BINFO)\n       TREE_PARMLIST (in TREE_LIST)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n@@ -225,14 +222,41 @@ struct diagnostic_context;\n /* Datatype used to temporarily save C++ bindings (for implicit\n    instantiations purposes and like).  Implemented in decl.c.  */\n typedef struct cxx_saved_binding cxx_saved_binding;\n+\n+/* Datatype that represents binding established by a declaration between\n+   a name and a C++ entity.  */\n+typedef struct cxx_binding cxx_binding;\n+\n+/* (GC-)allocate a cxx_binding object.  */\n+#define cxx_binding_make() (ggc_alloc (sizeof (cxx_binding)))\n+\n+/* Zero out a cxx_binding pointed to by B.  */\n+#define cxx_binding_clear(B) memset ((B), 0, sizeof (cxx_binding))\n+\n+struct cxx_binding GTY(())\n+{\n+  /* Link to chain together various bindings for this name.  */\n+  cxx_binding *previous;\n+  /* The non-type entity this name is bound to.  */\n+  tree value;\n+  /* The type entity this name is bound to.  */\n+  tree type;\n+  union tree_binding_u {\n+    tree GTY ((tag (\"0\"))) scope;\n+    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n+  } GTY ((desc (\"%0.has_level\"))) scope;\n+  unsigned has_level : 1;\n+  unsigned value_is_inherited : 1;\n+  unsigned is_local : 1;\n+};\n \f\n /* Language-dependent contents of an identifier.  */\n \n struct lang_identifier GTY(())\n {\n   struct c_common_identifier c_common;\n-  tree namespace_bindings;\n-  tree bindings;\n+  cxx_binding *namespace_bindings;\n+  cxx_binding *bindings;\n   tree class_value;\n   tree class_template_info;\n   struct lang_id2 *x;\n@@ -275,30 +299,28 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n \n /* Nonzero if this binding is for a local scope, as opposed to a class\n    or namespace scope.  */\n-#define LOCAL_BINDING_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define LOCAL_BINDING_P(NODE) ((NODE)->is_local)\n \n /* Nonzero if BINDING_VALUE is from a base class of the class which is\n    currently being defined.  */\n-#define INHERITED_VALUE_BINDING_P(NODE) TREE_LANG_FLAG_1 (NODE)\n+#define INHERITED_VALUE_BINDING_P(NODE) ((NODE)->value_is_inherited)\n \n /* For a binding between a name and an entity at a non-local scope,\n    defines the scope where the binding is declared.  (Either a class\n    _TYPE node, or a NAMESPACE_DECL.)  This macro should be used only\n    for namespace-level bindings; on the IDENTIFIER_BINDING list\n    BINDING_LEVEL is used instead.  */\n-#define BINDING_SCOPE(NODE) \\\n-  (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->scope.scope)\n+#define BINDING_SCOPE(NODE) ((NODE)->scope.scope)\n \n /* Nonzero if NODE has BINDING_LEVEL, rather than BINDING_SCOPE.  */\n-#define BINDING_HAS_LEVEL_P(NODE) TREE_LANG_FLAG_2 (NODE)\n+#define BINDING_HAS_LEVEL_P(NODE) ((NODE)->has_level)\n \n /* This is the declaration bound to the name. Possible values:\n    variable, overloaded function, namespace, template, enumerator.  */\n-#define BINDING_VALUE(NODE) \\\n-  (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->value)\n+#define BINDING_VALUE(NODE) ((NODE)->value)\n \n /* If name is bound to a type, this is the type (struct, union, enum).  */\n-#define BINDING_TYPE(NODE)     TREE_TYPE (NODE)\n+#define BINDING_TYPE(NODE)     ((NODE)->type)\n \n #define IDENTIFIER_GLOBAL_VALUE(NODE) \\\n   namespace_binding ((NODE), global_namespace)\n@@ -332,17 +354,6 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n     && DECL_NAME (NODE) != NULL_TREE\t\t\t\\\n     && MAIN_NAME_P (DECL_NAME (NODE)))\n \n-\n-struct tree_binding GTY(())\n-{\n-  struct tree_common common;\n-  union tree_binding_u {\n-    tree GTY ((tag (\"0\"))) scope;\n-    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n-  } GTY ((desc (\"BINDING_HAS_LEVEL_P ((tree)&%0)\"))) scope;\n-  tree value;\n-};\n-\n /* The overloaded FUNCTION_DECL.  */\n #define OVL_FUNCTION(NODE) \\\n   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n@@ -420,8 +431,8 @@ struct tree_srcloc GTY(())\n #define IDENTIFIER_TEMPLATE(NODE)\t\\\n   (LANG_IDENTIFIER_CAST (NODE)->class_template_info)\n \n-/* The IDENTIFIER_BINDING is the innermost CPLUS_BINDING for the\n-    identifier.  It's TREE_CHAIN is the next outermost binding.  Each\n+/* The IDENTIFIER_BINDING is the innermost cxx_binding for the\n+    identifier.  It's PREVIOUS is the next outermost binding.  Each\n     BINDING_VALUE is a DECL for the associated declaration.  Thus,\n     name lookup consists simply of pulling off the node at the front\n     of the list (modulo oddities for looking up the names of types,\n@@ -433,9 +444,7 @@ struct tree_srcloc GTY(())\n /* The IDENTIFIER_VALUE is the value of the IDENTIFIER_BINDING, or\n    NULL_TREE if there is no binding.  */\n #define IDENTIFIER_VALUE(NODE)\t\t\t\\\n-  (IDENTIFIER_BINDING (NODE)\t\t\t\\\n-   ? BINDING_VALUE (IDENTIFIER_BINDING (NODE))\t\\\n-   : NULL_TREE)\n+  (IDENTIFIER_BINDING (NODE) ? IDENTIFIER_BINDING (NODE)->value : NULL)\n \n /* If IDENTIFIER_CLASS_VALUE is set, then NODE is bound in the current\n    class, and IDENTIFIER_CLASS_VALUE is the value binding.  This is\n@@ -540,7 +549,6 @@ union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\"),\n \t\t\tdesc (\"tree_node_structure (&%h)\"))) generic;\n   struct template_parm_index_s GTY ((tag (\"TS_CP_TPI\"))) tpi;\n   struct ptrmem_cst GTY ((tag (\"TS_CP_PTRMEM\"))) ptrmem;\n-  struct tree_binding GTY ((tag (\"TS_CP_BINDING\"))) binding;\n   struct tree_overload GTY ((tag (\"TS_CP_OVERLOAD\"))) overload;\n   struct tree_baselink GTY ((tag (\"TS_CP_BASELINK\"))) baselink;\n   struct tree_wrapper GTY ((tag (\"TS_CP_WRAPPER\"))) wrapper;\n@@ -3705,7 +3713,7 @@ extern tree declare_local_label                 (tree);\n extern tree define_label\t\t\t(const char *, int, tree);\n extern void check_goto\t\t\t\t(tree);\n extern void define_case_label\t\t\t(void);\n-extern tree binding_for_name                    (tree, tree);\n+extern cxx_binding *binding_for_name (tree, tree);\n extern tree namespace_binding                   (tree, tree);\n extern void set_namespace_binding               (tree, tree, tree);\n extern tree lookup_namespace_name\t\t(tree, tree);\n@@ -3722,8 +3730,8 @@ extern tree namespace_ancestor\t\t\t(tree, tree);\n extern bool is_ancestor                         (tree, tree);\n extern tree unqualified_namespace_lookup\t(tree, int, tree *);\n extern tree check_for_out_of_scope_variable     (tree);\n-extern bool lookup_using_namespace (tree, tree, tree, tree, int, tree *);\n-extern bool qualified_lookup_using_namespace (tree, tree, tree, int);\n+extern bool lookup_using_namespace (tree, cxx_binding *, tree, tree, int, tree *);\n+extern bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n extern tree build_library_fn\t\t\t(tree, tree);\n extern tree build_library_fn_ptr\t\t(const char *, tree);\n extern tree build_cp_library_fn_ptr\t\t(const char *, tree);\n@@ -3795,6 +3803,7 @@ extern int nonstatic_local_decl_p               (tree);\n extern tree declare_global_var                  (tree, tree);\n extern void register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n+extern cxx_binding *cxx_scope_find_binding_for_name (tree, tree);\n extern tree cp_fname_init\t\t\t(const char *);\n extern bool have_extern_spec;\n "}, {"sha": "db116e1f7a87fec42e93e0a7e2f4ceeccb3943fb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 120, "deletions": 138, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "patch": "@@ -98,8 +98,8 @@ static void push_binding (tree, tree, struct cp_binding_level*);\n static int add_binding (tree, tree);\n static void pop_binding (tree, tree);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n-static tree find_binding (tree, tree);\n-static tree select_decl (tree, int);\n+static cxx_binding *find_binding (tree, tree, cxx_binding *);\n+static tree select_decl (cxx_binding *, int);\n static int lookup_flags (int, int);\n static tree qualify_lookup (tree, int);\n static tree record_builtin_java_type (const char *, int);\n@@ -887,33 +887,31 @@ finish_scope (void)\n \n /* For a binding between a name and an entity at a block scope,\n    this is the `struct cp_binding_level' for the block.  */\n-#define BINDING_LEVEL(NODE) \\\n-  (((struct tree_binding*)(NODE))->scope.level)\n+#define BINDING_LEVEL(NODE) ((NODE)->scope.level)\n \n-/* A free list of CPLUS_BINDING nodes, connected by their\n+/* A free list of cxx_binding nodes, connected by their\n    TREE_CHAINs.  */\n \n-static GTY((deletable (\"\"))) tree free_bindings;\n+static GTY((deletable (\"\"))) cxx_binding *free_bindings;\n \n /* Make DECL the innermost binding for ID.  The LEVEL is the binding\n    level at which this declaration is being bound.  */\n \n static void\n-push_binding (tree id, \n-              tree decl,\n-              struct cp_binding_level* level)\n+push_binding (tree id, tree decl, struct cp_binding_level* level)\n {\n-  tree binding;\n+  cxx_binding *binding;\n \n   if (free_bindings)\n     {\n       binding = free_bindings;\n-      free_bindings = TREE_CHAIN (binding);\n+      free_bindings = binding->previous;\n     }\n   else\n-    binding = make_node (CPLUS_BINDING);\n+    binding = cxx_binding_make ();\n \n   /* Now, fill in the binding information.  */\n+  binding->previous = IDENTIFIER_BINDING (id);\n   BINDING_VALUE (binding) = decl;\n   BINDING_TYPE (binding) = NULL_TREE;\n   BINDING_LEVEL (binding) = level;\n@@ -922,7 +920,6 @@ push_binding (tree id,\n   BINDING_HAS_LEVEL_P (binding) = 1;\n \n   /* And put it on the front of the list of bindings for ID.  */\n-  TREE_CHAIN (binding) = IDENTIFIER_BINDING (id);\n   IDENTIFIER_BINDING (id) = binding;\n }\n \n@@ -935,7 +932,7 @@ push_binding (tree id,\n static int\n add_binding (tree id, tree decl)\n {\n-  tree binding = IDENTIFIER_BINDING (id);\n+  cxx_binding *binding = IDENTIFIER_BINDING (id);\n   int ok = 1;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -1079,7 +1076,7 @@ int\n push_class_binding (tree id, tree decl)\n {\n   int result = 1;\n-  tree binding = IDENTIFIER_BINDING (id);\n+  cxx_binding *binding = IDENTIFIER_BINDING (id);\n   tree context;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -1134,7 +1131,7 @@ push_class_binding (tree id, tree decl)\n static void\n pop_binding (tree id, tree decl)\n {\n-  tree binding;\n+  cxx_binding *binding;\n \n   if (id == NULL_TREE)\n     /* It's easiest to write the loops that call this function without\n@@ -1146,7 +1143,7 @@ pop_binding (tree id, tree decl)\n   binding = IDENTIFIER_BINDING (id);\n \n   /* The name should be bound.  */\n-  my_friendly_assert (binding != NULL_TREE, 0);\n+  my_friendly_assert (binding != NULL, 0);\n \n   /* The DECL will be either the ordinary binding or the type\n      binding for this identifier.  Remove that binding.  */\n@@ -1161,10 +1158,10 @@ pop_binding (tree id, tree decl)\n     {\n       /* We're completely done with the innermost binding for this\n \t identifier.  Unhook it from the list of bindings.  */\n-      IDENTIFIER_BINDING (id) = TREE_CHAIN (binding);\n+      IDENTIFIER_BINDING (id) = binding->previous;\n \n       /* Add it to the free list.  */\n-      TREE_CHAIN (binding) = free_bindings;\n+      binding->previous = free_bindings;\n       free_bindings = binding;\n \n       /* Clear the BINDING_LEVEL so the garbage collector doesn't walk\n@@ -1376,8 +1373,8 @@ poplevel (int keep, int reverse, int functionbody)\n       if (leaving_for_scope && TREE_CODE (link) == VAR_DECL\n           && DECL_NAME (link))\n \t{\n-\t  tree outer_binding\n-\t    = TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (link)));\n+\t  cxx_binding *outer_binding\n+\t    = IDENTIFIER_BINDING (DECL_NAME (link))->previous;\n \t  tree ns_binding;\n \n \t  if (!outer_binding)\n@@ -1432,7 +1429,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t\t\t     current_binding_level->level_chain->\n \t\t\t     dead_vars_from_for);\n \n-\t      /* Although we don't pop the CPLUS_BINDING, we do clear\n+\t      /* Although we don't pop the cxx_binding, we do clear\n \t\t its BINDING_LEVEL since the level is going away now.  */\n \t      BINDING_LEVEL (IDENTIFIER_BINDING (DECL_NAME (link)))\n \t\t= 0;\n@@ -1657,15 +1654,15 @@ poplevel_class (void)\n \t     shadowed;\n \t     shadowed = TREE_CHAIN (shadowed))\n \t  {\n-\t    tree t;\n-\n-\t    t = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n-\t    while (t && BINDING_LEVEL (t) != b)\n-\t      t = TREE_CHAIN (t);\n+\t    cxx_binding *binding;\n+            \n+\t    binding = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n+\t    while (binding && BINDING_LEVEL (binding) != b)\n+\t      binding = binding->previous;\n \n-\t    if (t)\n+\t    if (binding)\n \t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed))\n-\t\t= BINDING_VALUE (t);\n+\t\t= BINDING_VALUE (binding);\n \t  }\n     }\n   else\n@@ -2023,90 +2020,88 @@ print_binding_stack (void)\n \n /* Namespace binding access routines: The namespace_bindings field of\n    the identifier is polymorphic, with three possible values:\n-   NULL_TREE, a list of CPLUS_BINDINGS, or any other tree_node\n-   indicating the BINDING_VALUE of global_namespace.  */\n+   NULL_TREE, a list of \"cxx_binding\"s.  */\n \n /* Check whether the a binding for the name to scope is known.\n    Assumes that the bindings of the name are already a list\n    of bindings. Returns the binding found, or NULL_TREE.  */\n \n-static tree\n-find_binding (tree name, tree scope)\n+static inline cxx_binding *\n+find_binding (tree name, tree scope, cxx_binding *front)\n {\n-  tree iter, prev = NULL_TREE;\n+  cxx_binding *iter;\n+  cxx_binding *prev = NULL;\n \n   timevar_push (TV_NAME_LOOKUP);\n   scope = ORIGINAL_NAMESPACE (scope);\n \n-  for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name); iter;\n-       iter = TREE_CHAIN (iter))\n+  for (iter = front; iter != NULL; iter = iter->previous)\n     {\n-      my_friendly_assert (TREE_CODE (iter) == CPLUS_BINDING, 374);\n       if (BINDING_SCOPE (iter) == scope)\n \t{\n \t  /* Move binding found to the front of the list, so\n              subsequent lookups will find it faster.  */\n \t  if (prev)\n \t    {\n-\t      TREE_CHAIN (prev) = TREE_CHAIN (iter);\n-\t      TREE_CHAIN (iter) = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+\t      prev->previous = iter->previous;\n+\t      iter->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n \t      IDENTIFIER_NAMESPACE_BINDINGS (name) = iter;\n \t    }\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, iter);\n \t}\n       prev = iter;\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL);\n+}\n+\n+/* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n+cxx_binding *\n+cxx_scope_find_binding_for_name (tree scope, tree name)\n+{\n+  cxx_binding *b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+  if (b)\n+    {\n+      scope = ORIGINAL_NAMESPACE (scope);\n+      /* Fold-in case where NAME is used only once.  */\n+      if (scope == BINDING_SCOPE (b) && b->previous == NULL)\n+        return b;\n+      return find_binding (name, scope, b);\n+    }\n+  return b;\n }\n \n /* Always returns a binding for name in scope. If the\n    namespace_bindings is not a list, convert it to one first.\n    If no binding is found, make a new one.  */\n \n-tree\n+cxx_binding *\n binding_for_name (tree name, tree scope)\n {\n-  tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  tree result;\n+  cxx_binding *result;\n \n   scope = ORIGINAL_NAMESPACE (scope);\n-\n-  if (b && TREE_CODE (b) != CPLUS_BINDING)\n-    {\n-      /* Get rid of optimization for global scope.  */\n-      IDENTIFIER_NAMESPACE_BINDINGS (name) = NULL_TREE;\n-      BINDING_VALUE (binding_for_name (name, global_namespace)) = b;\n-      b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-    }\n-  if (b && (result = find_binding (name, scope)))\n+  result = cxx_scope_find_binding_for_name (scope, name);\n+  if (result)\n     return result;\n   /* Not found, make a new one.  */\n-  result = make_node (CPLUS_BINDING);\n-  TREE_CHAIN (result) = b;\n-  IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n-  BINDING_SCOPE (result) = scope;\n+  result = cxx_binding_make ();\n+  result->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n   BINDING_TYPE (result) = NULL_TREE;\n   BINDING_VALUE (result) = NULL_TREE;\n+  BINDING_SCOPE (result) = scope;\n+  IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n   return result;\n }\n \n-/* Return the binding value for name in scope, considering that\n-   namespace_binding may or may not be a list of CPLUS_BINDINGS.  */\n+/* Return the binding value for name in scope.  */\n \n tree\n namespace_binding (tree name, tree scope)\n {\n-  tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  if (b == NULL_TREE)\n-    return NULL_TREE;\n-  if (scope == NULL_TREE)\n-    scope = global_namespace;\n-  if (TREE_CODE (b) != CPLUS_BINDING)\n-    return (scope == global_namespace) ? b : NULL_TREE;\n-  name = find_binding (name,scope);\n-  if (name == NULL_TREE)\n-    return name;\n-  return BINDING_VALUE (name);\n+  cxx_binding *b =\n+    cxx_scope_find_binding_for_name (scope ? scope : global_namespace, name);\n+\n+  return b ? b->value : NULL_TREE;\n }\n \n /* Set the binding value for name in scope. If modifying the binding\n@@ -2115,21 +2110,11 @@ namespace_binding (tree name, tree scope)\n void\n set_namespace_binding (tree name, tree scope, tree val)\n {\n-  tree b;\n+  cxx_binding *b;\n \n   timevar_push (TV_NAME_LOOKUP);\n   if (scope == NULL_TREE)\n     scope = global_namespace;\n-\n-  if (scope == global_namespace)\n-    {\n-      b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-      if (b == NULL_TREE || TREE_CODE (b) != CPLUS_BINDING)\n-\t{\n-\t  IDENTIFIER_NAMESPACE_BINDINGS (name) = val;\n-          POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n-\t}\n-    }\n   b = binding_for_name (name, scope);\n   BINDING_VALUE (b) = val;\n   timevar_pop (TV_NAME_LOOKUP);\n@@ -2267,7 +2252,7 @@ struct cxx_saved_binding GTY(())\n   /* The name of the current binding.  */\n   tree identifier;\n   /* The binding we're saving.  */\n-  tree binding;\n+  cxx_binding *binding;\n   tree class_value;\n   tree real_type_value;\n };\n@@ -2315,7 +2300,7 @@ store_bindings (tree names, cxx_saved_binding *old_bindings)\n       saved->binding = IDENTIFIER_BINDING (id);\n       saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n       saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-      IDENTIFIER_BINDING (id) = NULL_TREE;\n+      IDENTIFIER_BINDING (id) = NULL;\n       IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n       old_bindings = saved;\n     skip_it:\n@@ -2455,7 +2440,7 @@ set_identifier_type_value_with_scope (tree id,\n     }\n   else\n     {\n-      tree binding = binding_for_name (id, current_namespace);\n+      cxx_binding *binding = binding_for_name (id, current_namespace);\n       BINDING_TYPE (binding) = type;\n       /* Store marker instead of real type.  */\n       type = global_type_node;\n@@ -4328,7 +4313,7 @@ maybe_push_decl (tree decl)\n void\n push_class_level_binding (tree name, tree x)\n {\n-  tree binding;\n+  cxx_binding *binding;\n   timevar_push (TV_NAME_LOOKUP);\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n@@ -4570,7 +4555,7 @@ push_overloaded_decl (tree decl, int flags)\n \t\t  *d = tree_cons (NULL_TREE, new_binding,\n \t\t\t\t  TREE_CHAIN (*d));\n \n-\t\t/* And update the CPLUS_BINDING node.  */\n+\t\t/* And update the cxx_binding node.  */\n \t\tBINDING_VALUE (IDENTIFIER_BINDING (name))\n \t\t  = new_binding;\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n@@ -5236,10 +5221,8 @@ follow_tag_typedef (tree type)\n    reported.  */\n \n static tree\n-lookup_tag (enum tree_code form,\n-            tree name,\n-            struct cp_binding_level* binding_level,\n-            int thislevel_only)\n+lookup_tag (enum tree_code form, tree name,\n+            struct cp_binding_level* binding_level, int thislevel_only)\n {\n   register struct cp_binding_level *level;\n   /* Nonzero if, we should look past a template parameter level, even\n@@ -5262,18 +5245,22 @@ lookup_tag (enum tree_code form,\n \t/* Do namespace lookup.  */\n \tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n \t  {\n-\t    tree old = binding_for_name (name, tail);\n+            cxx_binding *binding =\n+              cxx_scope_find_binding_for_name (tail, name);\n+\t    tree old;\n \n \t    /* If we just skipped past a template parameter level,\n \t       even though THISLEVEL_ONLY, and we find a template\n \t       class declaration, then we use the _TYPE node for the\n \t       template.  See the example below.  */\n \t    if (thislevel_only && !allow_template_parms_p\n-\t\t&& old && BINDING_VALUE (old)\n-\t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (old)))\n-\t      old = TREE_TYPE (BINDING_VALUE (old));\n-\t    else\n-\t      old = BINDING_TYPE (old);\n+\t\t&& binding && BINDING_VALUE (binding)\n+\t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (binding)))\n+\t      old = TREE_TYPE (BINDING_VALUE (binding));\n+\t    else if (binding)\n+\t      old = BINDING_TYPE (binding);\n+            else\n+              old = NULL_TREE;\n \n \t    if (old)\n \t      {\n@@ -5373,6 +5360,7 @@ lookup_namespace_name (tree namespace, tree name)\n {\n   tree val;\n   tree template_id = NULL_TREE;\n+  cxx_binding binding;\n \n   timevar_push (TV_NAME_LOOKUP);\n   my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n@@ -5402,13 +5390,13 @@ lookup_namespace_name (tree namespace, tree name)\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n \n-  val = make_node (CPLUS_BINDING);\n-  if (!qualified_lookup_using_namespace (name, namespace, val, 0))\n+  cxx_binding_clear (&binding);\n+  if (!qualified_lookup_using_namespace (name, namespace, &binding, 0))\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n-  if (BINDING_VALUE (val))\n+  if (binding.value)\n     {\n-      val = BINDING_VALUE (val);\n+      val = binding.value;\n \n       if (template_id)\n \t{\n@@ -5723,7 +5711,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n /* Select the right _DECL from multiple choices.  */\n \n static tree\n-select_decl (tree binding, int flags)\n+select_decl (cxx_binding *binding, int flags)\n {\n   tree val;\n   val = BINDING_VALUE (binding);\n@@ -5759,44 +5747,42 @@ select_decl (tree binding, int flags)\n tree\n unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n {\n-  tree b = make_node (CPLUS_BINDING);\n   tree initial = current_decl_namespace ();\n   tree scope = initial;\n   tree siter;\n   struct cp_binding_level *level;\n   tree val = NULL_TREE;\n+  cxx_binding binding;\n \n   timevar_push (TV_NAME_LOOKUP);\n+  cxx_binding_clear (&binding);\n   if (spacesp)\n     *spacesp = NULL_TREE;\n \n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n+      cxx_binding *b = cxx_scope_find_binding_for_name (scope, name);\n       if (spacesp)\n \t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n-      val = binding_for_name (name, scope);\n \n       /* Ignore anticipated built-in functions.  */\n-      if (val && BINDING_VALUE (val)\n-          && DECL_P (BINDING_VALUE (val))\n-          && DECL_LANG_SPECIFIC (BINDING_VALUE (val))\n-          && DECL_ANTICIPATED (BINDING_VALUE (val)))\n-        {\n-          BINDING_VALUE (b) = NULL_TREE;\n-          BINDING_TYPE (b) = NULL_TREE;\n-        }\n-      else\n+      if (b && BINDING_VALUE (b)\n+          && DECL_P (BINDING_VALUE (b))\n+          && DECL_LANG_SPECIFIC (BINDING_VALUE (b))\n+          && DECL_ANTICIPATED (BINDING_VALUE (b)))\n+        /* Keep binding cleared.  */;\n+      else if (b)\n         {\n           /* Initialize binding for this context.  */\n-          BINDING_VALUE (b) = BINDING_VALUE (val);\n-          BINDING_TYPE (b) = BINDING_TYPE (val);\n+          binding.value = BINDING_VALUE (b);\n+          binding.type = BINDING_TYPE (b);\n         }\n \n       /* Add all _DECLs seen through local using-directives.  */\n       for (level = current_binding_level;\n \t   !level->namespace_p;\n \t   level = level->level_chain)\n-\tif (!lookup_using_namespace (name, b, level->using_directives,\n+\tif (!lookup_using_namespace (name, &binding, level->using_directives,\n                                      scope, flags, spacesp))\n \t  /* Give up because of error.  */\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n@@ -5806,15 +5792,16 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n       siter = initial;\n       while (1)\n \t{\n-\t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter),\n+\t  if (!lookup_using_namespace (name, &binding,\n+                                       DECL_NAMESPACE_USING (siter),\n \t\t\t\t       scope, flags, spacesp))\n \t    /* Give up because of error.  */\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t  if (siter == scope) break;\n \t  siter = CP_DECL_CONTEXT (siter);\n \t}\n \n-      val = select_decl (b, flags);\n+      val = select_decl (&binding, flags);\n       if (scope == global_namespace)\n \tbreak;\n     }\n@@ -5864,15 +5851,15 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, int flags)\n {\n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n-      tree val;\n+      cxx_binding binding;\n \n-      val = make_node (CPLUS_BINDING);\n+      cxx_binding_clear (&binding);\n       flags |= LOOKUP_COMPLAIN;\n       if (is_type_p)\n \tflags |= LOOKUP_PREFER_TYPES;\n-      if (!qualified_lookup_using_namespace (name, scope, val, flags))\n+      if (!qualified_lookup_using_namespace (name, scope, &binding, flags))\n \treturn NULL_TREE;\n-      return select_decl (val, flags);\n+      return select_decl (&binding, flags);\n     }\n   else\n     return lookup_member (scope, name, 0, is_type_p);\n@@ -5951,13 +5938,10 @@ check_for_out_of_scope_variable (tree decl)\n    using IDENTIFIER_CLASS_VALUE.  */\n \n tree\n-lookup_name_real (tree name, \n-\t\t  int prefer_type, \n-\t\t  int nonclass, \n-\t\t  int namespaces_only,\n-\t\t  int flags)\n+lookup_name_real (tree name, int prefer_type, int nonclass, \n+\t\t  int namespaces_only, int flags)\n {\n-  tree t;\n+  cxx_binding *iter;\n   tree val = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -5997,20 +5981,20 @@ lookup_name_real (tree name,\n   if (current_class_type == NULL_TREE)\n     nonclass = 1;\n \n-  for (t = IDENTIFIER_BINDING (name); t; t = TREE_CHAIN (t))\n+  for (iter = IDENTIFIER_BINDING (name); iter; iter = iter->previous)\n     {\n       tree binding;\n \n-      if (!LOCAL_BINDING_P (t) && nonclass)\n+      if (!LOCAL_BINDING_P (iter) && nonclass)\n \t/* We're not looking for class-scoped bindings, so keep going.  */\n \tcontinue;\n \n       /* If this is the kind of thing we're looking for, we're done.  */\n-      if (qualify_lookup (BINDING_VALUE (t), flags))\n-\tbinding = BINDING_VALUE (t);\n+      if (qualify_lookup (BINDING_VALUE (iter), flags))\n+\tbinding = BINDING_VALUE (iter);\n       else if ((flags & LOOKUP_PREFER_TYPES)\n-\t       && qualify_lookup (BINDING_TYPE (t), flags))\n-\tbinding = BINDING_TYPE (t);\n+\t       && qualify_lookup (BINDING_TYPE (iter), flags))\n+\tbinding = BINDING_TYPE (iter);\n       else\n \tbinding = NULL_TREE;\n \n@@ -6024,7 +6008,7 @@ lookup_name_real (tree name,\n   /* Now lookup in namespace scopes.  */\n   if (!val)\n     {\n-      t = unqualified_namespace_lookup (name, flags, 0);\n+      tree t = unqualified_namespace_lookup (name, flags, 0);\n       if (t)\n \tval = t;\n     }\n@@ -7996,12 +7980,11 @@ maybe_inject_for_scope_var (tree decl)\n \t Otherwise, we need to preserve the temp slot for decl to last\n \t into the outer binding level.  */\n \n-      tree outer_binding\n-\t= TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (decl)));\n+      cxx_binding *outer_binding\n+\t= IDENTIFIER_BINDING (DECL_NAME (decl))->previous;\n \n       if (outer_binding && BINDING_LEVEL (outer_binding) == outer\n-\t  && (TREE_CODE (BINDING_VALUE (outer_binding))\n-\t      == VAR_DECL)\n+\t  && (TREE_CODE (BINDING_VALUE (outer_binding)) == VAR_DECL)\n \t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n \t{\n \t  BINDING_VALUE (outer_binding)\n@@ -14505,7 +14488,6 @@ cp_tree_node_structure (union lang_tree_node * t)\n     {\n     case DEFAULT_ARG:\t\treturn TS_CP_DEFAULT_ARG;\n     case IDENTIFIER_NODE:\treturn TS_CP_IDENTIFIER;\n-    case CPLUS_BINDING:\t\treturn TS_CP_BINDING;\n     case OVERLOAD:\t\treturn TS_CP_OVERLOAD;\n     case TEMPLATE_PARM_INDEX:\treturn TS_CP_TPI;\n     case PTRMEM_CST:\t\treturn TS_CP_PTRMEM;"}, {"sha": "9937e754ab7a93f6f70e762cd263e41ab9e326eb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "patch": "@@ -63,7 +63,7 @@ static void mark_vtable_entries (tree);\n static void grok_function_init (tree, tree);\n static bool maybe_emit_vtables (tree);\n static void add_using_namespace (tree, tree, bool);\n-static tree ambiguous_decl (tree, tree, tree,int);\n+static cxx_binding *ambiguous_decl (tree, cxx_binding *, cxx_binding *, int);\n static tree build_anon_union_vars (tree);\n static bool acceptable_java_type (tree);\n static void output_vtable_inherit (tree);\n@@ -3497,11 +3497,11 @@ merge_functions (tree s1, tree s2)\n    XXX In what way should I treat extern declarations?\n    XXX I don't want to repeat the entire duplicate_decls here */\n \n-static tree\n-ambiguous_decl (tree name, tree old, tree new, int flags)\n+static cxx_binding *\n+ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n {\n   tree val, type;\n-  my_friendly_assert (old != NULL_TREE, 393);\n+  my_friendly_assert (old != NULL, 393);\n   /* Copy the value.  */\n   val = BINDING_VALUE (new);\n   if (val)\n@@ -3536,12 +3536,8 @@ ambiguous_decl (tree name, tree old, tree new, int flags)\n     BINDING_VALUE (old) = val;\n   else if (val && val != BINDING_VALUE (old))\n     {\n-      if (is_overloaded_fn (BINDING_VALUE (old)) \n-\t  && is_overloaded_fn (val))\n-\t{\n-\t  BINDING_VALUE (old) = merge_functions (BINDING_VALUE (old),\n-\t\t\t\t\t\t val);\n-\t}\n+      if (is_overloaded_fn (BINDING_VALUE (old)) && is_overloaded_fn (val))\n+        BINDING_VALUE (old) = merge_functions (BINDING_VALUE (old), val);\n       else\n \t{\n \t  /* Some declarations are functions, some are not.  */\n@@ -3587,35 +3583,35 @@ ambiguous_decl (tree name, tree old, tree new, int flags)\n    Returns false on errors.  */\n \n bool\n-lookup_using_namespace (tree name, tree val, tree usings, tree scope,\n+lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n                         int flags, tree *spacesp)\n {\n   tree iter;\n-  tree val1;\n   timevar_push (TV_NAME_LOOKUP);\n   /* Iterate over all used namespaces in current, searching for using\n      directives of scope.  */\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n     if (TREE_VALUE (iter) == scope)\n       {\n-\tif (spacesp)\n-\t  *spacesp = tree_cons (TREE_PURPOSE (iter), NULL_TREE,\n-\t\t\t\t*spacesp);\n-\tval1 = binding_for_name (name, TREE_PURPOSE (iter));\n-\t/* Resolve ambiguities.  */\n-\tval = ambiguous_decl (name, val, val1, flags);\n+        cxx_binding *val1 =\n+          cxx_scope_find_binding_for_name (TREE_PURPOSE (iter), name);\n+        if (spacesp)\n+          *spacesp = tree_cons (TREE_PURPOSE (iter), NULL_TREE, *spacesp);\n+        /* Resolve ambiguities.  */\n+        if (val1)\n+          val = ambiguous_decl (name, val, val1, flags);\n       }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n                           BINDING_VALUE (val) != error_mark_node);\n }\n \n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n-   Returns the name/type pair found into the CPLUS_BINDING RESULT,\n+   Returns the name/type pair found into the cxx_binding *RESULT,\n    or false on error.  */\n \n bool\n-qualified_lookup_using_namespace (tree name, tree scope, tree result,\n+qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n                                   int flags)\n {\n   /* Maintain a list of namespaces visited...  */\n@@ -3626,11 +3622,12 @@ qualified_lookup_using_namespace (tree name, tree scope, tree result,\n   timevar_push (TV_NAME_LOOKUP);\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n-  while (scope && (result != error_mark_node))\n+  while (scope && result->value != error_mark_node)\n     {\n+      cxx_binding *binding = cxx_scope_find_binding_for_name (scope, name);\n       seen = tree_cons (scope, NULL_TREE, seen);\n-      result = ambiguous_decl (name, result,\n-                               binding_for_name (name, scope), flags);\n+      if (binding)\n+        result = ambiguous_decl (name, result, binding, flags);\n       if (!BINDING_VALUE (result) && !BINDING_TYPE (result))\n \t/* Consider using directives.  */\n \tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n@@ -3647,7 +3644,7 @@ qualified_lookup_using_namespace (tree name, tree scope, tree result,\n       else\n \tscope = NULL_TREE; /* If there never was a todo list.  */\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result != error_mark_node);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);\n }\n \n /* [namespace.memdef]/2 */\n@@ -4203,22 +4200,22 @@ static void\n do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n                          tree *newval, tree *newtype)\n {\n-  tree decls;\n+  cxx_binding decls;\n \n   *newval = *newtype = NULL_TREE;\n-  decls = make_node (CPLUS_BINDING);\n-  if (!qualified_lookup_using_namespace (name, scope, decls, 0))\n+  cxx_binding_clear (&decls);\n+  if (!qualified_lookup_using_namespace (name, scope, &decls, 0))\n     /* Lookup error */\n     return;\n \n-  if (!BINDING_VALUE (decls) && !BINDING_TYPE (decls))\n+  if (!decls.value && !decls.type)\n     {\n       error (\"`%D' not declared\", name);\n       return;\n     }\n \n   /* Check for using functions.  */\n-  if (BINDING_VALUE (decls) && is_overloaded_fn (BINDING_VALUE (decls)))\n+  if (decls.value && is_overloaded_fn (decls.value))\n     {\n       tree tmp, tmp1;\n \n@@ -4230,7 +4227,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t}\n \n       *newval = oldval;\n-      for (tmp = BINDING_VALUE (decls); tmp; tmp = OVL_NEXT (tmp))\n+      for (tmp = decls.value; tmp; tmp = OVL_NEXT (tmp))\n \t{\n \t  tree new_fn = OVL_CURRENT (tmp);\n \n@@ -4290,12 +4287,12 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n     }\n   else \n     {\n-      *newval = BINDING_VALUE (decls);\n+      *newval = decls.value;\n       if (oldval && !decls_match (*newval, oldval))\n \terror (\"`%D' is already declared in this scope\", name);\n     }\n \n-  *newtype = BINDING_TYPE (decls);\n+  *newtype = decls.type;\n   if (oldtype && *newtype && !same_type_p (oldtype, *newtype))\n     {\n       error (\"using declaration `%D' introduced ambiguous type `%T'\",\n@@ -4309,8 +4306,9 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n void\n do_toplevel_using_decl (tree decl)\n {\n-  tree scope, name, binding;\n+  tree scope, name;\n   tree oldval, oldtype, newval, newtype;\n+  cxx_binding *binding;\n \n   decl = validate_nonmember_using_decl (decl, &scope, &name);\n   if (decl == NULL_TREE)"}, {"sha": "305a4f135c6fb92821a0b8ffed59fdb3ce50eeb3", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6fd53f5acd8afb55f6fd3053bf853c9cd1e966/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=af6fd53f5acd8afb55f6fd3053bf853c9cd1e966", "patch": "@@ -153,12 +153,21 @@ cxx_print_type (FILE *file, tree node, int indent)\n     }\n }\n \n+\n+static void\n+cxx_print_binding (FILE *stream, cxx_binding *binding, const char *prefix)\n+{\n+  fprintf (stream, \"%s <\", prefix);\n+  fprintf (stream, HOST_PTR_PRINTF, (char *) binding);\n+  fprintf (stream, \">\");\n+}\n+\n void\n cxx_print_identifier (FILE *file, tree node, int indent)\n {\n-  print_node (file, \"bindings\", IDENTIFIER_NAMESPACE_BINDINGS (node), indent + 4);\n+  cxx_print_binding (file, IDENTIFIER_NAMESPACE_BINDINGS (node), \"bindings\");\n   print_node (file, \"class\", IDENTIFIER_CLASS_VALUE (node), indent + 4);\n-  print_node (file, \"local bindings\", IDENTIFIER_BINDING (node), indent + 4);\n+  cxx_print_binding (file, IDENTIFIER_BINDING (node), \"local bindings\");\n   print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n   print_node (file, \"template\", IDENTIFIER_TEMPLATE (node), indent + 4);\n   print_node (file, \"implicit\", IDENTIFIER_IMPLICIT_DECL (node), indent + 4);\n@@ -170,12 +179,6 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n {\n   switch (TREE_CODE (node))\n     {\n-    case CPLUS_BINDING:\n-      fprintf (file, \" scope \");\n-      fprintf (file, HOST_PTR_PRINTF, BINDING_SCOPE (node));\n-      print_node (file, \"value\", BINDING_VALUE (node), indent+4);\n-      print_node (file, \"chain\", TREE_CHAIN (node), indent+4);\n-      break;\n     case OVERLOAD:\n       print_node (file, \"function\", OVL_FUNCTION (node), indent+4);\n       print_node (file, \"chain\", TREE_CHAIN (node), indent+4);"}]}