{"sha": "1a52709222c9c5fd3b9446d3ef1db6b87d020e13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE1MjcwOTIyMmM5YzVmZDNiOTQ0NmQzZWYxZGI2Yjg3ZDAyMGUxMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:17:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:17:37Z"}, "message": "[52/77] Use scalar_int_mode in extract/store_bit_field\n\nAfter a certain point, extract_bit_field and store_bit_field\nensure that they're dealing with integer modes or BLKmode MEMs.\nThis patch uses scalar_int_mode and opt_scalar_int_mode for\nthose parts.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expmed.c (store_bit_field_using_insv): Add op0_mode and\n\tvalue_mode arguments.  Use scalar_int_mode internally.\n\t(store_bit_field_1): Rename the new integer mode from imode\n\tto op0_mode and use it instead of GET_MODE (op0).  Update calls\n\tto store_split_bit_field, store_bit_field_using_insv and\n\tstore_fixed_bit_field.\n\t(store_fixed_bit_field): Add op0_mode and value_mode arguments.\n\tUse scalar_int_mode internally.  Use a bit count rather than a mode\n\twhen calculating the largest bit size for get_best_mode.\n\tUpdate calls to store_split_bit_field and store_fixed_bit_field_1.\n\t(store_fixed_bit_field_1): Add mode and value_mode arguments.\n\tRemove assertion that OP0 has a scalar integer mode.\n\t(store_split_bit_field): Add op0_mode and value_mode arguments.\n\tUpdate calls to extract_fixed_bit_field.\n\t(extract_bit_field_using_extv): Add an op0_mode argument.\n\tUse scalar_int_mode internally.\n\t(extract_bit_field_1): Rename the new integer mode from imode to\n\top0_mode and use it instead of GET_MODE (op0).  Update calls to\n\textract_split_bit_field, extract_bit_field_using_extv and\n\textract_fixed_bit_field.\n\t(extract_fixed_bit_field): Add an op0_mode argument.  Update calls\n\tto extract_split_bit_field and extract_fixed_bit_field_1.\n\t(extract_fixed_bit_field_1): Add a mode argument.  Remove assertion\n\tthat OP0 has a scalar integer mode.  Use as_a <scalar_int_mode>\n\ton the target mode.\n\t(extract_split_bit_field): Add an op0_mode argument.  Update call\n\tto extract_fixed_bit_field.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251504", "tree": {"sha": "1c64817b9f94aeeb80879dd906ac7785f018193b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c64817b9f94aeeb80879dd906ac7785f018193b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a52709222c9c5fd3b9446d3ef1db6b87d020e13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a52709222c9c5fd3b9446d3ef1db6b87d020e13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a52709222c9c5fd3b9446d3ef1db6b87d020e13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a52709222c9c5fd3b9446d3ef1db6b87d020e13/comments", "author": null, "committer": null, "parents": [{"sha": "59b5118623ad2e755fbb16b03f2ea122bceebdd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b5118623ad2e755fbb16b03f2ea122bceebdd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b5118623ad2e755fbb16b03f2ea122bceebdd2"}], "stats": {"total": 361, "additions": 218, "deletions": 143}, "files": [{"sha": "5d467d0fc07c92427761af6ad4bdeac4e5bdd779", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a52709222c9c5fd3b9446d3ef1db6b87d020e13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a52709222c9c5fd3b9446d3ef1db6b87d020e13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a52709222c9c5fd3b9446d3ef1db6b87d020e13", "patch": "@@ -1,3 +1,35 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expmed.c (store_bit_field_using_insv): Add op0_mode and\n+\tvalue_mode arguments.  Use scalar_int_mode internally.\n+\t(store_bit_field_1): Rename the new integer mode from imode\n+\tto op0_mode and use it instead of GET_MODE (op0).  Update calls\n+\tto store_split_bit_field, store_bit_field_using_insv and\n+\tstore_fixed_bit_field.\n+\t(store_fixed_bit_field): Add op0_mode and value_mode arguments.\n+\tUse scalar_int_mode internally.  Use a bit count rather than a mode\n+\twhen calculating the largest bit size for get_best_mode.\n+\tUpdate calls to store_split_bit_field and store_fixed_bit_field_1.\n+\t(store_fixed_bit_field_1): Add mode and value_mode arguments.\n+\tRemove assertion that OP0 has a scalar integer mode.\n+\t(store_split_bit_field): Add op0_mode and value_mode arguments.\n+\tUpdate calls to extract_fixed_bit_field.\n+\t(extract_bit_field_using_extv): Add an op0_mode argument.\n+\tUse scalar_int_mode internally.\n+\t(extract_bit_field_1): Rename the new integer mode from imode to\n+\top0_mode and use it instead of GET_MODE (op0).  Update calls to\n+\textract_split_bit_field, extract_bit_field_using_extv and\n+\textract_fixed_bit_field.\n+\t(extract_fixed_bit_field): Add an op0_mode argument.  Update calls\n+\tto extract_split_bit_field and extract_fixed_bit_field_1.\n+\t(extract_fixed_bit_field_1): Add a mode argument.  Remove assertion\n+\tthat OP0 has a scalar integer mode.  Use as_a <scalar_int_mode>\n+\ton the target mode.\n+\t(extract_split_bit_field): Add an op0_mode argument.  Update call\n+\tto extract_fixed_bit_field.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3839c7622430b22a2ec7eee424c56b0452a39059", "filename": "gcc/expmed.c", "status": "modified", "additions": 186, "deletions": 143, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a52709222c9c5fd3b9446d3ef1db6b87d020e13/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a52709222c9c5fd3b9446d3ef1db6b87d020e13/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1a52709222c9c5fd3b9446d3ef1db6b87d020e13", "patch": "@@ -45,27 +45,31 @@ struct target_expmed default_target_expmed;\n struct target_expmed *this_target_expmed = &default_target_expmed;\n #endif\n \n-static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,\n+static void store_fixed_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   rtx, bool);\n-static void store_fixed_bit_field_1 (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   rtx, scalar_int_mode, bool);\n+static void store_fixed_bit_field_1 (rtx, scalar_int_mode,\n+\t\t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t\t     unsigned HOST_WIDE_INT,\n-\t\t\t\t     rtx, bool);\n-static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t     rtx, scalar_int_mode, bool);\n+static void store_split_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   rtx, bool);\n-static rtx extract_fixed_bit_field (machine_mode, rtx,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   rtx, scalar_int_mode, bool);\n+static rtx extract_fixed_bit_field (machine_mode, rtx, opt_scalar_int_mode,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n-static rtx extract_fixed_bit_field_1 (machine_mode, rtx,\n+static rtx extract_fixed_bit_field_1 (machine_mode, rtx, scalar_int_mode,\n \t\t\t\t      unsigned HOST_WIDE_INT,\n \t\t\t\t      unsigned HOST_WIDE_INT, rtx, int, bool);\n static rtx lshift_value (machine_mode, unsigned HOST_WIDE_INT, int);\n-static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n+static rtx extract_split_bit_field (rtx, opt_scalar_int_mode,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, int, bool);\n static void do_cmp_and_jump (rtx, rtx, enum rtx_code, machine_mode, rtx_code_label *);\n static rtx expand_smod_pow2 (machine_mode, rtx, HOST_WIDE_INT);\n@@ -571,21 +575,24 @@ simple_mem_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n }\n \f\n /* Try to use instruction INSV to store VALUE into a field of OP0.\n-   BITSIZE and BITNUM are as for store_bit_field.  */\n+   If OP0_MODE is defined, it is the mode of OP0, otherwise OP0 is a\n+   BLKmode MEM.  VALUE_MODE is the mode of VALUE.  BITSIZE and BITNUM\n+   are as for store_bit_field.  */\n \n static bool\n store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n+\t\t\t    opt_scalar_int_mode op0_mode,\n \t\t\t    unsigned HOST_WIDE_INT bitsize,\n \t\t\t    unsigned HOST_WIDE_INT bitnum,\n-\t\t\t    rtx value)\n+\t\t\t    rtx value, scalar_int_mode value_mode)\n {\n   struct expand_operand ops[4];\n   rtx value1;\n   rtx xop0 = op0;\n   rtx_insn *last = get_last_insn ();\n   bool copy_back = false;\n \n-  machine_mode op_mode = insv->field_mode;\n+  scalar_int_mode op_mode = insv->field_mode;\n   unsigned int unit = GET_MODE_BITSIZE (op_mode);\n   if (bitsize == 0 || bitsize > unit)\n     return false;\n@@ -598,7 +605,7 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n     {\n       /* Convert from counting within OP0 to counting in OP_MODE.  */\n       if (BYTES_BIG_ENDIAN)\n-\tbitnum += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\tbitnum += unit - GET_MODE_BITSIZE (op0_mode.require ());\n \n       /* If xop0 is a register, we need it in OP_MODE\n \t to make it acceptable to the format of insv.  */\n@@ -651,30 +658,28 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n \n   /* Convert VALUE to op_mode (which insv insn wants) in VALUE1.  */\n   value1 = value;\n-  if (GET_MODE (value) != op_mode)\n+  if (value_mode != op_mode)\n     {\n-      if (GET_MODE_BITSIZE (GET_MODE (value)) >= bitsize)\n+      if (GET_MODE_BITSIZE (value_mode) >= bitsize)\n \t{\n \t  rtx tmp;\n \t  /* Optimization: Don't bother really extending VALUE\n \t     if it has all the bits we will actually use.  However,\n \t     if we must narrow it, be sure we do it correctly.  */\n \n-\t  if (GET_MODE_SIZE (GET_MODE (value)) < GET_MODE_SIZE (op_mode))\n+\t  if (GET_MODE_SIZE (value_mode) < GET_MODE_SIZE (op_mode))\n \t    {\n-\t      tmp = simplify_subreg (op_mode, value1, GET_MODE (value), 0);\n+\t      tmp = simplify_subreg (op_mode, value1, value_mode, 0);\n \t      if (! tmp)\n \t\ttmp = simplify_gen_subreg (op_mode,\n-\t\t\t\t\t   force_reg (GET_MODE (value),\n-\t\t\t\t\t\t      value1),\n-\t\t\t\t\t   GET_MODE (value), 0);\n+\t\t\t\t\t   force_reg (value_mode, value1),\n+\t\t\t\t\t   value_mode, 0);\n \t    }\n \t  else\n \t    {\n \t      tmp = gen_lowpart_if_possible (op_mode, value1);\n \t      if (! tmp)\n-\t\ttmp = gen_lowpart (op_mode, force_reg (GET_MODE (value),\n-\t\t\t\t\t\t       value1));\n+\t\ttmp = gen_lowpart (op_mode, force_reg (value_mode, value1));\n \t    }\n \t  value1 = tmp;\n \t}\n@@ -829,12 +834,12 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      if we aren't.  This must come after the entire register case above,\n      since that case is valid for any mode.  The following cases are only\n      valid for integral modes.  */\n-  opt_scalar_int_mode opt_imode = int_mode_for_mode (GET_MODE (op0));\n+  opt_scalar_int_mode op0_mode = int_mode_for_mode (GET_MODE (op0));\n   scalar_int_mode imode;\n-  if (!opt_imode.exists (&imode) || imode != GET_MODE (op0))\n+  if (!op0_mode.exists (&imode) || imode != GET_MODE (op0))\n     {\n       if (MEM_P (op0))\n-\top0 = adjust_bitfield_address_size (op0, opt_imode.else_blk (),\n+\top0 = adjust_bitfield_address_size (op0, op0_mode.else_blk (),\n \t\t\t\t\t    0, MEM_SIZE (op0));\n       else\n \top0 = gen_lowpart (op0_mode.require (), op0);\n@@ -949,11 +954,15 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      with 64 bit registers that uses SFmode for float.  It can also\n      occur for unaligned float or complex fields.  */\n   orig_value = value;\n-  if (GET_MODE (value) != VOIDmode\n-      && GET_MODE_CLASS (GET_MODE (value)) != MODE_INT\n-      && GET_MODE_CLASS (GET_MODE (value)) != MODE_PARTIAL_INT)\n-    {\n-      value = gen_reg_rtx (int_mode_for_mode (GET_MODE (value)).require ());\n+  scalar_int_mode value_mode;\n+  if (GET_MODE (value) == VOIDmode)\n+    /* By this point we've dealt with values that are bigger than a word,\n+       so word_mode is a conservatively correct choice.  */\n+    value_mode = word_mode;\n+  else if (!is_a <scalar_int_mode> (GET_MODE (value), &value_mode))\n+    {\n+      value_mode = int_mode_for_mode (GET_MODE (value)).require ();\n+      value = gen_reg_rtx (value_mode);\n       emit_move_insn (gen_lowpart (GET_MODE (orig_value), value), orig_value);\n     }\n \n@@ -962,23 +971,25 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      Don't do this if op0 is a single hard register wider than word\n      such as a float or vector register.  */\n   if (!MEM_P (op0)\n-      && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD\n+      && GET_MODE_SIZE (op0_mode.require ()) > UNITS_PER_WORD\n       && (!REG_P (op0)\n \t  || !HARD_REGISTER_P (op0)\n-\t  || HARD_REGNO_NREGS (REGNO (op0), GET_MODE (op0)) != 1))\n+\t  || HARD_REGNO_NREGS (REGNO (op0), op0_mode.require ()) != 1))\n     {\n       if (bitnum % BITS_PER_WORD + bitsize > BITS_PER_WORD)\n \t{\n \t  if (!fallback_p)\n \t    return false;\n \n-\t  store_split_bit_field (op0, bitsize, bitnum, bitregion_start,\n-\t\t\t\t bitregion_end, value, reverse);\n+\t  store_split_bit_field (op0, op0_mode, bitsize, bitnum,\n+\t\t\t\t bitregion_start, bitregion_end,\n+\t\t\t\t value, value_mode, reverse);\n \t  return true;\n \t}\n-      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n+      op0 = simplify_gen_subreg (word_mode, op0, op0_mode.require (),\n \t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n       gcc_assert (op0);\n+      op0_mode = word_mode;\n       bitnum %= BITS_PER_WORD;\n     }\n \n@@ -990,9 +1001,10 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!MEM_P (op0)\n       && !reverse\n       && get_best_reg_extraction_insn (&insv, EP_insv,\n-\t\t\t\t       GET_MODE_BITSIZE (GET_MODE (op0)),\n+\t\t\t\t       GET_MODE_BITSIZE (op0_mode.require ()),\n \t\t\t\t       fieldmode)\n-      && store_bit_field_using_insv (&insv, op0, bitsize, bitnum, value))\n+      && store_bit_field_using_insv (&insv, op0, op0_mode,\n+\t\t\t\t     bitsize, bitnum, value, value_mode))\n     return true;\n \n   /* If OP0 is a memory, try copying it to a register and seeing if a\n@@ -1001,7 +1013,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     {\n       if (get_best_mem_extraction_insn (&insv, EP_insv, bitsize, bitnum,\n \t\t\t\t\tfieldmode)\n-\t  && store_bit_field_using_insv (&insv, op0, bitsize, bitnum, value))\n+\t  && store_bit_field_using_insv (&insv, op0, op0_mode,\n+\t\t\t\t\t bitsize, bitnum, value, value_mode))\n \treturn true;\n \n       rtx_insn *last = get_last_insn ();\n@@ -1029,8 +1042,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!fallback_p)\n     return false;\n \n-  store_fixed_bit_field (op0, bitsize, bitnum, bitregion_start,\n-\t\t\t bitregion_end, value, reverse);\n+  store_fixed_bit_field (op0, op0_mode, bitsize, bitnum, bitregion_start,\n+\t\t\t bitregion_end, value, value_mode, reverse);\n   return true;\n }\n \n@@ -1124,16 +1137,19 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n }\n \f\n /* Use shifts and boolean operations to store VALUE into a bit field of\n-   width BITSIZE in OP0, starting at bit BITNUM.\n+   width BITSIZE in OP0, starting at bit BITNUM.  If OP0_MODE is defined,\n+   it is the mode of OP0, otherwise OP0 is a BLKmode MEM.  VALUE_MODE is\n+   the mode of VALUE.\n \n    If REVERSE is true, the store is to be done in reverse order.  */\n \n static void\n-store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+store_fixed_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n+\t\t       unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitnum,\n \t\t       unsigned HOST_WIDE_INT bitregion_start,\n \t\t       unsigned HOST_WIDE_INT bitregion_end,\n-\t\t       rtx value, bool reverse)\n+\t\t       rtx value, scalar_int_mode value_mode, bool reverse)\n {\n   /* There is a case not handled here:\n      a structure with a known alignment of just a halfword\n@@ -1142,46 +1158,49 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n      and a field split across two bytes.\n      Such cases are not supposed to be able to occur.  */\n \n+  scalar_int_mode best_mode;\n   if (MEM_P (op0))\n     {\n-      machine_mode mode = GET_MODE (op0);\n-      if (GET_MODE_BITSIZE (mode) == 0\n-\t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n-\tmode = word_mode;\n-      scalar_int_mode best_mode;\n+      unsigned int max_bitsize = BITS_PER_WORD;\n+      scalar_int_mode imode;\n+      if (op0_mode.exists (&imode) && GET_MODE_BITSIZE (imode) < max_bitsize)\n+\tmax_bitsize = GET_MODE_BITSIZE (imode);\n+\n       if (!get_best_mode (bitsize, bitnum, bitregion_start, bitregion_end,\n-\t\t\t  MEM_ALIGN (op0), GET_MODE_BITSIZE (mode),\n-\t\t\t  MEM_VOLATILE_P (op0), &best_mode))\n+\t\t\t  MEM_ALIGN (op0), max_bitsize, MEM_VOLATILE_P (op0),\n+\t\t\t  &best_mode))\n \t{\n \t  /* The only way this should occur is if the field spans word\n \t     boundaries.  */\n-\t  store_split_bit_field (op0, bitsize, bitnum, bitregion_start,\n-\t\t\t\t bitregion_end, value, reverse);\n+\t  store_split_bit_field (op0, op0_mode, bitsize, bitnum,\n+\t\t\t\t bitregion_start, bitregion_end,\n+\t\t\t\t value, value_mode, reverse);\n \t  return;\n \t}\n \n       op0 = narrow_bit_field_mem (op0, best_mode, bitsize, bitnum, &bitnum);\n     }\n+  else\n+    best_mode = op0_mode.require ();\n \n-  store_fixed_bit_field_1 (op0, bitsize, bitnum, value, reverse);\n+  store_fixed_bit_field_1 (op0, best_mode, bitsize, bitnum,\n+\t\t\t   value, value_mode, reverse);\n }\n \n /* Helper function for store_fixed_bit_field, stores\n-   the bit field always using the MODE of OP0.  */\n+   the bit field always using MODE, which is the mode of OP0.  The other\n+   arguments are as for store_fixed_bit_field.  */\n \n static void\n-store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+store_fixed_bit_field_1 (rtx op0, scalar_int_mode mode,\n+\t\t\t unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitnum,\n-\t\t\t rtx value, bool reverse)\n+\t\t\t rtx value, scalar_int_mode value_mode, bool reverse)\n {\n-  machine_mode mode;\n   rtx temp;\n   int all_zero = 0;\n   int all_one = 0;\n \n-  mode = GET_MODE (op0);\n-  gcc_assert (SCALAR_INT_MODE_P (mode));\n-\n   /* Note that bitsize + bitnum can be greater than GET_MODE_BITSIZE (mode)\n      for invalid input, such as f5 from gcc.dg/pr48335-2.c.  */\n \n@@ -1216,10 +1235,10 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     }\n   else\n     {\n-      int must_and = (GET_MODE_BITSIZE (GET_MODE (value)) != bitsize\n+      int must_and = (GET_MODE_BITSIZE (value_mode) != bitsize\n \t\t      && bitnum + bitsize != GET_MODE_BITSIZE (mode));\n \n-      if (GET_MODE (value) != mode)\n+      if (value_mode != mode)\n \tvalue = convert_to_mode (mode, value, 1);\n \n       if (must_and)\n@@ -1272,18 +1291,21 @@ store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n    OP0 is the REG, SUBREG or MEM rtx for the first of the objects.\n    BITSIZE is the field width; BITPOS the position of its first bit\n    (within the word).\n-   VALUE is the value to store.\n+   VALUE is the value to store, which has mode VALUE_MODE.\n+   If OP0_MODE is defined, it is the mode of OP0, otherwise OP0 is\n+   a BLKmode MEM.\n \n    If REVERSE is true, the store is to be done in reverse order.\n \n    This does not yet handle fields wider than BITS_PER_WORD.  */\n \n static void\n-store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+store_split_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n+\t\t       unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitpos,\n \t\t       unsigned HOST_WIDE_INT bitregion_start,\n \t\t       unsigned HOST_WIDE_INT bitregion_end,\n-\t\t       rtx value, bool reverse)\n+\t\t       rtx value, scalar_int_mode value_mode, bool reverse)\n {\n   unsigned int unit, total_bits, bitsdone = 0;\n \n@@ -1297,8 +1319,8 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   /* If OP0 is a memory with a mode, then UNIT must not be larger than\n      OP0's mode as well.  Otherwise, store_fixed_bit_field will call us\n      again, and we will mutually recurse forever.  */\n-  if (MEM_P (op0) && GET_MODE_BITSIZE (GET_MODE (op0)) > 0)\n-    unit = MIN (unit, GET_MODE_BITSIZE (GET_MODE (op0)));\n+  if (MEM_P (op0) && op0_mode.exists ())\n+    unit = MIN (unit, GET_MODE_BITSIZE (op0_mode.require ()));\n \n   /* If VALUE is a constant other than a CONST_INT, get it into a register in\n      WORD_MODE.  If we can do this using gen_lowpart_common, do so.  Note\n@@ -1310,20 +1332,18 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       if (word && (value != word))\n \tvalue = word;\n       else\n-\tvalue = gen_lowpart_common (word_mode,\n-\t\t\t\t    force_reg (GET_MODE (value) != VOIDmode\n-\t\t\t\t\t       ? GET_MODE (value)\n-\t\t\t\t\t       : word_mode, value));\n+\tvalue = gen_lowpart_common (word_mode, force_reg (value_mode, value));\n+      value_mode = word_mode;\n     }\n \n-  total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n+  total_bits = GET_MODE_BITSIZE (value_mode);\n \n   while (bitsdone < bitsize)\n     {\n       unsigned HOST_WIDE_INT thissize;\n       unsigned HOST_WIDE_INT thispos;\n       unsigned HOST_WIDE_INT offset;\n-      rtx part, word;\n+      rtx part;\n \n       offset = (bitpos + bitsdone) / unit;\n       thispos = (bitpos + bitsdone) % unit;\n@@ -1357,19 +1377,18 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    & ((HOST_WIDE_INT_1 << thissize) - 1));\n           /* Likewise, but the source is little-endian.  */\n           else if (reverse)\n-\t    part = extract_fixed_bit_field (word_mode, value, thissize,\n+\t    part = extract_fixed_bit_field (word_mode, value, value_mode,\n+\t\t\t\t\t    thissize,\n \t\t\t\t\t    bitsize - bitsdone - thissize,\n \t\t\t\t\t    NULL_RTX, 1, false);\n \t  else\n-\t    {\n-\t      int total_bits = GET_MODE_BITSIZE (GET_MODE (value));\n-\t      /* The args are chosen so that the last part includes the\n-\t\t lsb.  Give extract_bit_field the value it needs (with\n-\t\t endianness compensation) to fetch the piece we want.  */\n-\t      part = extract_fixed_bit_field (word_mode, value, thissize,\n-\t\t\t\t\t      total_bits - bitsize + bitsdone,\n-\t\t\t\t\t      NULL_RTX, 1, false);\n-\t    }\n+\t    /* The args are chosen so that the last part includes the\n+\t       lsb.  Give extract_bit_field the value it needs (with\n+\t       endianness compensation) to fetch the piece we want.  */\n+\t    part = extract_fixed_bit_field (word_mode, value, value_mode,\n+\t\t\t\t\t    thissize,\n+\t\t\t\t\t    total_bits - bitsize + bitsdone,\n+\t\t\t\t\t    NULL_RTX, 1, false);\n \t}\n       else\n \t{\n@@ -1380,34 +1399,44 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    & ((HOST_WIDE_INT_1 << thissize) - 1));\n \t  /* Likewise, but the source is big-endian.  */\n           else if (reverse)\n-\t    part = extract_fixed_bit_field (word_mode, value, thissize,\n+\t    part = extract_fixed_bit_field (word_mode, value, value_mode,\n+\t\t\t\t\t    thissize,\n \t\t\t\t\t    total_bits - bitsdone - thissize,\n \t\t\t\t\t    NULL_RTX, 1, false);\n \t  else\n-\t    part = extract_fixed_bit_field (word_mode, value, thissize,\n-\t\t\t\t\t    bitsdone, NULL_RTX, 1, false);\n+\t    part = extract_fixed_bit_field (word_mode, value, value_mode,\n+\t\t\t\t\t    thissize, bitsdone, NULL_RTX,\n+\t\t\t\t\t    1, false);\n \t}\n \n       /* If OP0 is a register, then handle OFFSET here.  */\n+      rtx op0_piece = op0;\n+      opt_scalar_int_mode op0_piece_mode = op0_mode;\n       if (SUBREG_P (op0) || REG_P (op0))\n \t{\n-\t  machine_mode op0_mode = GET_MODE (op0);\n-\t  if (op0_mode != BLKmode && GET_MODE_SIZE (op0_mode) < UNITS_PER_WORD)\n-\t    word = offset ? const0_rtx : op0;\n+\t  scalar_int_mode imode;\n+\t  if (op0_mode.exists (&imode)\n+\t      && GET_MODE_SIZE (imode) < UNITS_PER_WORD)\n+\t    {\n+\t      if (offset)\n+\t\top0_piece = const0_rtx;\n+\t    }\n \t  else\n-\t    word = operand_subword_force (op0, offset * unit / BITS_PER_WORD,\n-\t\t\t\t\t  GET_MODE (op0));\n+\t    {\n+\t      op0_piece = operand_subword_force (op0,\n+\t\t\t\t\t\t offset * unit / BITS_PER_WORD,\n+\t\t\t\t\t\t GET_MODE (op0));\n+\t      op0_piece_mode = word_mode;\n+\t    }\n \t  offset &= BITS_PER_WORD / unit - 1;\n \t}\n-      else\n-\tword = op0;\n \n       /* OFFSET is in UNITs, and UNIT is in bits.  If WORD is const0_rtx,\n \t it is just an out-of-bounds access.  Ignore it.  */\n-      if (word != const0_rtx)\n-\tstore_fixed_bit_field (word, thissize, offset * unit + thispos,\n-\t\t\t       bitregion_start, bitregion_end, part,\n-\t\t\t       reverse);\n+      if (op0_piece != const0_rtx)\n+\tstore_fixed_bit_field (op0_piece, op0_piece_mode, thissize,\n+\t\t\t       offset * unit + thispos, bitregion_start,\n+\t\t\t       bitregion_end, part, word_mode, reverse);\n       bitsdone += thissize;\n     }\n }\n@@ -1439,11 +1468,13 @@ convert_extracted_bit_field (rtx x, machine_mode mode,\n \n /* Try to use an ext(z)v pattern to extract a field from OP0.\n    Return the extracted value on success, otherwise return null.\n-   EXT_MODE is the mode of the extraction and the other arguments\n-   are as for extract_bit_field.  */\n+   EXTV describes the extraction instruction to use.  If OP0_MODE\n+   is defined, it is the mode of OP0, otherwise OP0 is a BLKmode MEM.\n+   The other arguments are as for extract_bit_field.  */\n \n static rtx\n extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n+\t\t\t      opt_scalar_int_mode op0_mode,\n \t\t\t      unsigned HOST_WIDE_INT bitsize,\n \t\t\t      unsigned HOST_WIDE_INT bitnum,\n \t\t\t      int unsignedp, rtx target,\n@@ -1452,7 +1483,7 @@ extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n   struct expand_operand ops[4];\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n-  machine_mode ext_mode = extv->field_mode;\n+  scalar_int_mode ext_mode = extv->field_mode;\n   unsigned unit = GET_MODE_BITSIZE (ext_mode);\n \n   if (bitsize == 0 || unit < bitsize)\n@@ -1466,13 +1497,13 @@ extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n     {\n       /* Convert from counting within OP0 to counting in EXT_MODE.  */\n       if (BYTES_BIG_ENDIAN)\n-\tbitnum += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n+\tbitnum += unit - GET_MODE_BITSIZE (op0_mode.require ());\n \n       /* If op0 is a register, we need it in EXT_MODE to make it\n \t acceptable to the format of ext(z)v.  */\n-      if (GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode)\n+      if (GET_CODE (op0) == SUBREG && op0_mode.require () != ext_mode)\n \treturn NULL_RTX;\n-      if (REG_P (op0) && GET_MODE (op0) != ext_mode)\n+      if (REG_P (op0) && op0_mode.require () != ext_mode)\n \top0 = gen_lowpart_SUBREG (ext_mode, op0);\n     }\n \n@@ -1673,14 +1704,14 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* Make sure we are playing with integral modes.  Pun with subregs\n      if we aren't.  */\n-  opt_scalar_int_mode opt_imode = int_mode_for_mode (GET_MODE (op0));\n+  opt_scalar_int_mode op0_mode = int_mode_for_mode (GET_MODE (op0));\n   scalar_int_mode imode;\n-  if (!opt_imode.exists (&imode) || imode != GET_MODE (op0))\n+  if (!op0_mode.exists (&imode) || imode != GET_MODE (op0))\n     {\n       if (MEM_P (op0))\n-\top0 = adjust_bitfield_address_size (op0, opt_imode.else_blk (),\n+\top0 = adjust_bitfield_address_size (op0, op0_mode.else_blk (),\n \t\t\t\t\t    0, MEM_SIZE (op0));\n-      else if (opt_imode.exists (&imode))\n+      else if (op0_mode.exists (&imode))\n \t{\n \t  op0 = gen_lowpart (imode, op0);\n \n@@ -1719,11 +1750,11 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      bit of either OP0 or a word of OP0.  */\n   if (!MEM_P (op0)\n       && !reverse\n-      && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n+      && lowpart_bit_field_p (bitnum, bitsize, op0_mode.require ())\n       && bitsize == GET_MODE_BITSIZE (mode1)\n-      && TRULY_NOOP_TRUNCATION_MODES_P (mode1, GET_MODE (op0)))\n+      && TRULY_NOOP_TRUNCATION_MODES_P (mode1, op0_mode.require ()))\n     {\n-      rtx sub = simplify_gen_subreg (mode1, op0, GET_MODE (op0),\n+      rtx sub = simplify_gen_subreg (mode1, op0, op0_mode.require (),\n \t\t\t\t     bitnum / BITS_PER_UNIT);\n       if (sub)\n \treturn convert_extracted_bit_field (sub, mode, tmode, unsignedp);\n@@ -1826,18 +1857,19 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* If OP0 is a multi-word register, narrow it to the affected word.\n      If the region spans two words, defer to extract_split_bit_field.  */\n-  if (!MEM_P (op0) && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n+  if (!MEM_P (op0) && GET_MODE_SIZE (op0_mode.require ()) > UNITS_PER_WORD)\n     {\n       if (bitnum % BITS_PER_WORD + bitsize > BITS_PER_WORD)\n \t{\n \t  if (!fallback_p)\n \t    return NULL_RTX;\n-\t  target = extract_split_bit_field (op0, bitsize, bitnum, unsignedp,\n-\t\t\t\t\t    reverse);\n+\t  target = extract_split_bit_field (op0, op0_mode, bitsize, bitnum,\n+\t\t\t\t\t    unsignedp, reverse);\n \t  return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n \t}\n-      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n+      op0 = simplify_gen_subreg (word_mode, op0, op0_mode.require (),\n \t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n+      op0_mode = word_mode;\n       bitnum %= BITS_PER_WORD;\n     }\n \n@@ -1851,10 +1883,11 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t contains the field, with appropriate checks for endianness\n \t and TRULY_NOOP_TRUNCATION.  */\n       && get_best_reg_extraction_insn (&extv, pattern,\n-\t\t\t\t       GET_MODE_BITSIZE (GET_MODE (op0)),\n+\t\t\t\t       GET_MODE_BITSIZE (op0_mode.require ()),\n \t\t\t\t       tmode))\n     {\n-      rtx result = extract_bit_field_using_extv (&extv, op0, bitsize, bitnum,\n+      rtx result = extract_bit_field_using_extv (&extv, op0, op0_mode,\n+\t\t\t\t\t\t bitsize, bitnum,\n \t\t\t\t\t\t unsignedp, target, mode,\n \t\t\t\t\t\t tmode);\n       if (result)\n@@ -1868,9 +1901,9 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       if (get_best_mem_extraction_insn (&extv, pattern, bitsize, bitnum,\n \t\t\t\t\ttmode))\n \t{\n-\t  rtx result = extract_bit_field_using_extv (&extv, op0, bitsize,\n-\t\t\t\t\t\t     bitnum, unsignedp,\n-\t\t\t\t\t\t     target, mode,\n+\t  rtx result = extract_bit_field_using_extv (&extv, op0, op0_mode,\n+\t\t\t\t\t\t     bitsize, bitnum,\n+\t\t\t\t\t\t     unsignedp, target, mode,\n \t\t\t\t\t\t     tmode);\n \t  if (result)\n \t    return result;\n@@ -1906,8 +1939,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n        do a load.  */\n     int_mode = int_mode_for_mode (mode).require ();\n \n-  target = extract_fixed_bit_field (int_mode, op0, bitsize, bitnum, target,\n-\t\t\t\t    unsignedp, reverse);\n+  target = extract_fixed_bit_field (int_mode, op0, op0_mode, bitsize,\n+\t\t\t\t    bitnum, target, unsignedp, reverse);\n \n   /* Complex values must be reversed piecewise, so we need to undo the global\n      reversal, convert to the complex mode and reverse again.  */\n@@ -1986,7 +2019,8 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n }\n \f\n /* Use shifts and boolean operations to extract a field of BITSIZE bits\n-   from bit BITNUM of OP0.\n+   from bit BITNUM of OP0.  If OP0_MODE is defined, it is the mode of OP0,\n+   otherwise OP0 is a BLKmode MEM.\n \n    UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).\n    If REVERSE is true, the extraction is to be done in reverse order.\n@@ -1997,39 +2031,40 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n static rtx\n extract_fixed_bit_field (machine_mode tmode, rtx op0,\n+\t\t\t opt_scalar_int_mode op0_mode,\n \t\t\t unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitnum, rtx target,\n \t\t\t int unsignedp, bool reverse)\n {\n+  scalar_int_mode mode;\n   if (MEM_P (op0))\n     {\n-      scalar_int_mode mode;\n       if (!get_best_mode (bitsize, bitnum, 0, 0, MEM_ALIGN (op0),\n \t\t\t  BITS_PER_WORD, MEM_VOLATILE_P (op0), &mode))\n \t/* The only way this should occur is if the field spans word\n \t   boundaries.  */\n-\treturn extract_split_bit_field (op0, bitsize, bitnum, unsignedp,\n-\t\t\t\t\treverse);\n+\treturn extract_split_bit_field (op0, op0_mode, bitsize, bitnum,\n+\t\t\t\t\tunsignedp, reverse);\n \n       op0 = narrow_bit_field_mem (op0, mode, bitsize, bitnum, &bitnum);\n     }\n+  else\n+    mode = op0_mode.require ();\n \n-  return extract_fixed_bit_field_1 (tmode, op0, bitsize, bitnum,\n+  return extract_fixed_bit_field_1 (tmode, op0, mode, bitsize, bitnum,\n \t\t\t\t    target, unsignedp, reverse);\n }\n \n /* Helper function for extract_fixed_bit_field, extracts\n-   the bit field always using the MODE of OP0.  */\n+   the bit field always using MODE, which is the mode of OP0.\n+   The other arguments are as for extract_fixed_bit_field.  */\n \n static rtx\n-extract_fixed_bit_field_1 (machine_mode tmode, rtx op0,\n+extract_fixed_bit_field_1 (machine_mode tmode, rtx op0, scalar_int_mode mode,\n \t\t\t   unsigned HOST_WIDE_INT bitsize,\n \t\t\t   unsigned HOST_WIDE_INT bitnum, rtx target,\n \t\t\t   int unsignedp, bool reverse)\n {\n-  machine_mode mode = GET_MODE (op0);\n-  gcc_assert (SCALAR_INT_MODE_P (mode));\n-\n   /* Note that bitsize + bitnum can be greater than GET_MODE_BITSIZE (mode)\n      for invalid input, such as extract equivalent of f5 from\n      gcc.dg/pr48335-2.c.  */\n@@ -2056,16 +2091,19 @@ extract_fixed_bit_field_1 (machine_mode tmode, rtx op0,\n \t    subtarget = 0;\n \t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, bitnum, subtarget, 1);\n \t}\n-      /* Convert the value to the desired mode.  */\n-      if (mode != tmode)\n-\top0 = convert_to_mode (tmode, op0, 1);\n+      /* Convert the value to the desired mode.  TMODE must also be a\n+\t scalar integer for this conversion to make sense, since we\n+\t shouldn't reinterpret the bits.  */\n+      scalar_int_mode new_mode = as_a <scalar_int_mode> (tmode);\n+      if (mode != new_mode)\n+\top0 = convert_to_mode (new_mode, op0, 1);\n \n       /* Unless the msb of the field used to be the msb when we shifted,\n \t mask out the upper bits.  */\n \n       if (GET_MODE_BITSIZE (mode) != bitnum + bitsize)\n-\treturn expand_binop (GET_MODE (op0), and_optab, op0,\n-\t\t\t     mask_rtx (GET_MODE (op0), 0, bitsize, 0),\n+\treturn expand_binop (new_mode, and_optab, op0,\n+\t\t\t     mask_rtx (new_mode, 0, bitsize, 0),\n \t\t\t     target, 1, OPTAB_LIB_WIDEN);\n       return op0;\n     }\n@@ -2115,11 +2153,14 @@ lshift_value (machine_mode mode, unsigned HOST_WIDE_INT value,\n    OP0 is the REG, SUBREG or MEM rtx for the first of the two words.\n    BITSIZE is the field width; BITPOS, position of its first bit, in the word.\n    UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.\n+   If OP0_MODE is defined, it is the mode of OP0, otherwise OP0 is\n+   a BLKmode MEM.\n \n    If REVERSE is true, the extraction is to be done in reverse order.  */\n \n static rtx\n-extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+extract_split_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n+\t\t\t unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitpos, int unsignedp,\n \t\t\t bool reverse)\n {\n@@ -2138,7 +2179,7 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n   while (bitsdone < bitsize)\n     {\n       unsigned HOST_WIDE_INT thissize;\n-      rtx part, word;\n+      rtx part;\n       unsigned HOST_WIDE_INT thispos;\n       unsigned HOST_WIDE_INT offset;\n \n@@ -2152,19 +2193,21 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       thissize = MIN (thissize, unit - thispos);\n \n       /* If OP0 is a register, then handle OFFSET here.  */\n+      rtx op0_piece = op0;\n+      opt_scalar_int_mode op0_piece_mode = op0_mode;\n       if (SUBREG_P (op0) || REG_P (op0))\n \t{\n-\t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n+\t  op0_piece = operand_subword_force (op0, offset, op0_mode.require ());\n+\t  op0_piece_mode = word_mode;\n \t  offset = 0;\n \t}\n-      else\n-\tword = op0;\n \n       /* Extract the parts in bit-counting order,\n \t whose meaning is determined by BYTES_PER_UNIT.\n \t OFFSET is in UNITs, and UNIT is in bits.  */\n-      part = extract_fixed_bit_field (word_mode, word, thissize,\n-\t\t\t\t      offset * unit + thispos, 0, 1, reverse);\n+      part = extract_fixed_bit_field (word_mode, op0_piece, op0_piece_mode,\n+\t\t\t\t      thissize, offset * unit + thispos,\n+\t\t\t\t      0, 1, reverse);\n       bitsdone += thissize;\n \n       /* Shift this part into place for the result.  */"}]}