{"sha": "383d9c83756ed27807c0a8e5864ff542e3561905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzZDljODM3NTZlZDI3ODA3YzBhOGU1ODY0ZmY1NDJlMzU2MTkwNQ==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-06-07T06:51:24Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-06-07T06:51:24Z"}, "message": "tree-vectorizer.h (vect_recog_func_ptr): Make last argument to be a pointer.\n\n\n        * tree-vectorizer.h (vect_recog_func_ptr): Make last argument to\n        be a pointer.\n        * tree-vect-patterns.c (vect_recog_widen_sum_pattern,\n        vect_recog_widen_mult_pattern, vect_recog_dot_prod_pattern,\n        vect_recog_pow_pattern): Likewise.\n        (vect_pattern_recog_1): Remove declaration.\n        (widened_name_p): Remove declaration.  Add new argument to\n        specify whether to check that both types are either signed or\n        unsigned.\n        (vect_recog_widen_mult_pattern): Update documentation.  Handle\n        unsigned patterns and multiplication by constants.\n        (vect_pattern_recog_1): Update vect_recog_func references.  Use\n        statement information from the statement returned from pattern\n        detection functions.\n        (vect_pattern_recog): Update vect_recog_func reference.\n        * tree-vect-stmts.c (vectorizable_type_promotion): For widening\n        multiplication by a constant use the type of the other operand.\n\nFrom-SVN: r174735", "tree": {"sha": "d44318b140c4de62e09469dc53c5ff1df072e042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d44318b140c4de62e09469dc53c5ff1df072e042"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/383d9c83756ed27807c0a8e5864ff542e3561905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383d9c83756ed27807c0a8e5864ff542e3561905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/383d9c83756ed27807c0a8e5864ff542e3561905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383d9c83756ed27807c0a8e5864ff542e3561905/comments", "author": null, "committer": null, "parents": [{"sha": "f527cc50e36411b205e37b7227bde8a9e7c6a0f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f527cc50e36411b205e37b7227bde8a9e7c6a0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f527cc50e36411b205e37b7227bde8a9e7c6a0f9"}], "stats": {"total": 511, "additions": 423, "deletions": 88}, "files": [{"sha": "021a33a349677092276ae8fe85ab479716056887", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -1,3 +1,22 @@\n+2011-06-07  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vectorizer.h (vect_recog_func_ptr): Make last argument to be\n+\ta pointer.\n+\t* tree-vect-patterns.c (vect_recog_widen_sum_pattern,\n+\tvect_recog_widen_mult_pattern, vect_recog_dot_prod_pattern,\n+\tvect_recog_pow_pattern): Likewise.\n+\t(vect_pattern_recog_1): Remove declaration.\n+\t(widened_name_p): Remove declaration.  Add new argument to specify\n+\twhether to check that both types are either signed or unsigned.\n+\t(vect_recog_widen_mult_pattern): Update documentation.  Handle\n+\tunsigned patterns and multiplication by constants.\n+\t(vect_pattern_recog_1): Update vect_recog_func references.  Use\n+\tstatement information from the statement returned from pattern\n+\tdetection functions.\n+\t(vect_pattern_recog): Update vect_recog_func reference.\n+\t* tree-vect-stmts.c (vectorizable_type_promotion): For widening\n+\tmultiplication by a constant use the type of the other operand.\n+\n 2011-06-06  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR rtl-optimization/49145"}, {"sha": "2ddc298359dd18167020d12db616da60eb6b15f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -1,3 +1,17 @@\n+2011-06-07  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_widen_mult_qi_to_hi):\n+\tAdd NEON as supporting target.\n+\t(check_effective_target_vect_widen_mult_hi_to_si): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi_pattern): New.\n+\t(check_effective_target_vect_widen_mult_hi_to_si_pattern): New.\n+\t* gcc.dg/vect/vect-widen-mult-u8.c: Expect to be vectorized\n+\tusing widening multiplication on targets that support it.\n+\t* gcc.dg/vect/vect-widen-mult-u16.c: Likewise.\n+\t* gcc.dg/vect/vect-widen-mult-const-s16.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-const-u16.c: New test.\n+\n 2011-06-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tUpdated all testcases in the ObjC/ObjC++ testsuites to use the"}, {"sha": "a2fe9755abcd5e253ff70f8a3793e978b325ebe2", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-s16.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-s16.c?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+#include <stdlib.h>\n+\n+#define N 32\n+\n+__attribute__ ((noinline)) void \n+foo (int *__restrict a,\n+     short *__restrict b,\n+     int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = b[i] * 2333;\n+\n+  for (i = 0; i < n; i++)\n+    if (a[i] != b[i] * 2333)\n+      abort ();\n+}\n+\n+__attribute__ ((noinline)) void\n+bar (int *__restrict a,\n+     short *__restrict b,\n+     int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = b[i] * (short) 2333;\n+\n+  for (i = 0; i < n; i++)\n+    if (a[i] != b[i] * (short) 2333)\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  int a[N];\n+  short b[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = 0;\n+      b[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (a, b, N);\n+  bar (a, b, N);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "e712da964239f75b9266467ee32d9c6f2c595607", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-const-u16.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-const-u16.c?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+#include <stdlib.h>\n+\n+#define N 32\n+\n+__attribute__ ((noinline)) void \n+foo (unsigned int *__restrict a,\n+     unsigned short *__restrict b,\n+     int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = b[i] * 2333;\n+\n+  for (i = 0; i < n; i++)\n+    if (a[i] != b[i] * 2333)\n+      abort ();\n+}\n+\n+__attribute__ ((noinline)) void\n+bar (unsigned int *__restrict a,\n+     unsigned short *__restrict b,\n+     int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = (unsigned short) 2333 * b[i];\n+\n+  for (i = 0; i < n; i++)\n+    if (a[i] != b[i] * (unsigned short) 2333)\n+      abort ();\n+}\n+\n+__attribute__ ((noinline)) void\n+baz (unsigned int *__restrict a,\n+     unsigned short *__restrict b,\n+     int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = b[i] * 233333333;\n+\n+  for (i = 0; i < n; i++)\n+    if (a[i] != b[i] * 233333333)\n+      abort ();\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned int a[N];\n+  unsigned short b[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = 0;\n+      b[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (a, b, N);\n+  bar (a, b, N);\n+  baz (a, b, N);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "71faa11adb76b0a6054b07864033401b68bdb291", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u16.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u16.c?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -9,13 +9,11 @@ unsigned short X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n unsigned short Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n unsigned int result[N];\n \n-/* short->int widening-mult */\n+/* unsigned short->unsigned int widening-mult.  */\n __attribute__ ((noinline)) int\n foo1(int len) {\n   int i;\n \n-  /* Not vectorized because X[i] and Y[i] are casted to 'int'\n-     so the widening multiplication pattern is not recognized.  */\n   for (i=0; i<len; i++) {\n     result[i] = (unsigned int)(X[i] * Y[i]);\n   }\n@@ -43,8 +41,8 @@ int main (void)\n   return 0;\n }\n \n-/*The induction loop is vectorized  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_pack_trunc } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_hi_to_si || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 1 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "ef8030215b857494ef7ef3c8aae13fbec99da638", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8.c?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -9,7 +9,7 @@ unsigned char X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n unsigned char Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n unsigned short result[N];\n \n-/* char->short widening-mult */\n+/* unsigned char-> unsigned short widening-mult.  */\n __attribute__ ((noinline)) int\n foo1(int len) {\n   int i;\n@@ -28,8 +28,7 @@ int main (void)\n   for (i=0; i<N; i++) {\n     X[i] = i;\n     Y[i] = 64-i;\n-    if (i%4 == 0)\n-      X[i] = 5;\n+    __asm__ volatile (\"\");\n   }\n \n   foo1 (N);\n@@ -43,5 +42,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "7d3a27135f5d4ea7395972ad3b27500cb90f9ccc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -2668,7 +2668,8 @@ proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n \t} else {\n \t    set et_vect_widen_mult_qi_to_hi_saved 0\n \t}\n-        if { [istarget powerpc*-*-*] } {\n+        if { [istarget powerpc*-*-*]\n+              || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {\n             set et_vect_widen_mult_qi_to_hi_saved 1\n         }\n     }\n@@ -2701,14 +2702,61 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n \t      || [istarget spu-*-*]\n \t      || [istarget ia64-*-*]\n \t      || [istarget i?86-*-*]\n-\t      || [istarget x86_64-*-*] } {\n+\t      || [istarget x86_64-*-*]\n+              || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {\n             set et_vect_widen_mult_hi_to_si_saved 1\n         }\n     }\n     verbose \"check_effective_target_vect_widen_mult_hi_to_si: returning $et_vect_widen_mult_hi_to_si_saved\" 2\n     return $et_vect_widen_mult_hi_to_si_saved\n }\n \n+# Return 1 if the target plus current options supports a vector\n+# widening multiplication of *char* args into *short* result, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n+    global et_vect_widen_mult_qi_to_hi_pattern\n+\n+    if [info exists et_vect_widen_mult_qi_to_hi_pattern_saved] {\n+        verbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern: using cached result\" 2\n+    } else {\n+        set et_vect_widen_mult_qi_to_hi_pattern_saved 0\n+        if { [istarget powerpc*-*-*]\n+              || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {\n+            set et_vect_widen_mult_qi_to_hi_pattern_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_widen_mult_qi_to_hi_pattern: returning $et_vect_widen_mult_qi_to_hi_pattern_saved\" 2\n+    return $et_vect_widen_mult_qi_to_hi_pattern_saved\n+}\n+\n+# Return 1 if the target plus current options supports a vector\n+# widening multiplication of *short* args into *int* result, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n+    global et_vect_widen_mult_hi_to_si_pattern\n+\n+    if [info exists et_vect_widen_mult_hi_to_si_pattern_saved] {\n+        verbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern: using cached result\" 2\n+    } else {\n+        set et_vect_widen_mult_hi_to_si_pattern_saved 0\n+        if { [istarget powerpc*-*-*]\n+              || [istarget spu-*-*]\n+              || [istarget ia64-*-*]\n+              || [istarget i?86-*-*]\n+              || [istarget x86_64-*-*]\n+              || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {\n+            set et_vect_widen_mult_hi_to_si_pattern_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_widen_mult_hi_to_si_pattern: returning $et_vect_widen_mult_hi_to_si_pattern_saved\" 2\n+    return $et_vect_widen_mult_hi_to_si_pattern_saved\n+}\n+\n # Return 1 if the target plus current options supports a vector\n # dot-product of signed chars, 0 otherwise.\n #"}, {"sha": "f0add8c60743c28e3dacc1444aef025b8127db83", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 159, "deletions": 64, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -38,16 +38,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"diagnostic-core.h\"\n \n-/* Function prototypes */\n-static void vect_pattern_recog_1\n-  (gimple (* ) (gimple, tree *, tree *), gimple_stmt_iterator);\n-static bool widened_name_p (tree, gimple, tree *, gimple *);\n-\n /* Pattern recognition functions  */\n-static gimple vect_recog_widen_sum_pattern (gimple, tree *, tree *);\n-static gimple vect_recog_widen_mult_pattern (gimple, tree *, tree *);\n-static gimple vect_recog_dot_prod_pattern (gimple, tree *, tree *);\n-static gimple vect_recog_pow_pattern (gimple, tree *, tree *);\n+static gimple vect_recog_widen_sum_pattern (gimple *, tree *, tree *);\n+static gimple vect_recog_widen_mult_pattern (gimple *, tree *, tree *);\n+static gimple vect_recog_dot_prod_pattern (gimple *, tree *, tree *);\n+static gimple vect_recog_pow_pattern (gimple *, tree *, tree *);\n static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n@@ -61,10 +56,12 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n    is a result of a type-promotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n    where the type of name0 (HALF_TYPE) is smaller than the type of NAME.\n-*/\n+   If CHECK_SIGN is TRUE, check that either both types are signed or both are\n+   unsigned.  */\n \n static bool\n-widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt)\n+widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n+\t\tbool check_sign)\n {\n   tree dummy;\n   gimple dummy_gimple;\n@@ -98,7 +95,7 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt)\n \n   *half_type = TREE_TYPE (oprnd0);\n   if (!INTEGRAL_TYPE_P (type) || !INTEGRAL_TYPE_P (*half_type)\n-      || (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (*half_type))\n+      || ((TYPE_UNSIGNED (type) != TYPE_UNSIGNED (*half_type)) && check_sign)\n       || (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 2)))\n     return false;\n \n@@ -168,23 +165,23 @@ vect_recog_temp_ssa_var (tree type, gimple stmt)\n          inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple\n-vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n+vect_recog_dot_prod_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n {\n   gimple stmt;\n   tree oprnd0, oprnd1;\n   tree oprnd00, oprnd01;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (*last_stmt);\n   tree type, half_type;\n   gimple pattern_stmt;\n   tree prod_type;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n   tree var;\n \n-  if (!is_gimple_assign (last_stmt))\n+  if (!is_gimple_assign (*last_stmt))\n     return NULL;\n \n-  type = gimple_expr_type (last_stmt);\n+  type = gimple_expr_type (*last_stmt);\n \n   /* Look for the following pattern\n           DX = (TYPE1) X;\n@@ -210,7 +207,7 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n+  if (gimple_assign_rhs_code (*last_stmt) != PLUS_EXPR)\n     return NULL;\n \n   if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n@@ -231,14 +228,14 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n         return NULL;\n-      oprnd0 = gimple_assign_rhs1 (last_stmt);\n-      oprnd1 = gimple_assign_rhs2 (last_stmt);\n+      oprnd0 = gimple_assign_rhs1 (*last_stmt);\n+      oprnd1 = gimple_assign_rhs2 (*last_stmt);\n       if (!types_compatible_p (TREE_TYPE (oprnd0), type)\n \t  || !types_compatible_p (TREE_TYPE (oprnd1), type))\n         return NULL;\n-      stmt = last_stmt;\n+      stmt = *last_stmt;\n \n-      if (widened_name_p (oprnd0, stmt, &half_type, &def_stmt))\n+      if (widened_name_p (oprnd0, stmt, &half_type, &def_stmt, true))\n         {\n           stmt = def_stmt;\n           oprnd0 = gimple_assign_rhs1 (stmt);\n@@ -247,7 +244,7 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n         half_type = type;\n     }\n \n-  /* So far so good. Since last_stmt was detected as a (summation) reduction,\n+  /* So far so good.  Since *last_stmt was detected as a (summation) reduction,\n      we know that oprnd1 is the reduction variable (defined by a loop-header\n      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n      Left to check that oprnd0 is defined by a (widen_)mult_expr  */\n@@ -293,10 +290,10 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n       if (!types_compatible_p (TREE_TYPE (oprnd0), prod_type)\n           || !types_compatible_p (TREE_TYPE (oprnd1), prod_type))\n         return NULL;\n-      if (!widened_name_p (oprnd0, stmt, &half_type0, &def_stmt))\n+      if (!widened_name_p (oprnd0, stmt, &half_type0, &def_stmt, true))\n         return NULL;\n       oprnd00 = gimple_assign_rhs1 (def_stmt);\n-      if (!widened_name_p (oprnd1, stmt, &half_type1, &def_stmt))\n+      if (!widened_name_p (oprnd1, stmt, &half_type1, &def_stmt, true))\n         return NULL;\n       oprnd01 = gimple_assign_rhs1 (def_stmt);\n       if (!types_compatible_p (half_type0, half_type1))\n@@ -322,7 +319,7 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n   /* We don't allow changing the order of the computation in the inner-loop\n      when doing outer-loop vectorization.  */\n-  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n+  gcc_assert (!nested_in_vect_loop_p (loop, *last_stmt));\n \n   return pattern_stmt;\n }\n@@ -342,64 +339,158 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n    where type 'TYPE' is at least double the size of type 'type'.\n \n+   Also detect unsgigned cases:\n+\n+     unsigned type a_t, b_t;\n+     unsigned TYPE u_prod_T;\n+     TYPE a_T, b_T, prod_T;\n+\n+     S1  a_t = ;\n+     S2  b_t = ;\n+     S3  a_T = (TYPE) a_t;\n+     S4  b_T = (TYPE) b_t;\n+     S5  prod_T = a_T * b_T;\n+     S6  u_prod_T = (unsigned TYPE) prod_T;\n+\n+   and multiplication by constants:\n+\n+     type a_t;\n+     TYPE a_T, prod_T;\n+\n+     S1  a_t = ;\n+     S3  a_T = (TYPE) a_t;\n+     S5  prod_T = a_T * CONST;\n+\n    Input:\n \n-   * LAST_STMT: A stmt from which the pattern search begins. In the example,\n-   when this function is called with S5, the pattern {S3,S4,S5} is be detected.\n+   * LAST_STMT: A stmt from which the pattern search begins.  In the example,\n+   when this function is called with S5, the pattern {S3,S4,S5,(S6)} is\n+   detected.\n \n    Output:\n \n    * TYPE_IN: The type of the input arguments to the pattern.\n \n-   * TYPE_OUT: The type of the output  of this pattern.\n+   * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the sequence of\n-   stmts that constitute the pattern. In this case it will be:\n+   stmts that constitute the pattern.  In this case it will be:\n         WIDEN_MULT <a_t, b_t>\n */\n \n static gimple\n-vect_recog_widen_mult_pattern (gimple last_stmt,\n+vect_recog_widen_mult_pattern (gimple *last_stmt,\n \t\t\t       tree *type_in,\n \t\t\t       tree *type_out)\n {\n   gimple def_stmt0, def_stmt1;\n   tree oprnd0, oprnd1;\n   tree type, half_type0, half_type1;\n   gimple pattern_stmt;\n-  tree vectype, vectype_out;\n+  tree vectype, vectype_out = NULL_TREE;\n   tree dummy;\n   tree var;\n   enum tree_code dummy_code;\n   int dummy_int;\n   VEC (tree, heap) *dummy_vec;\n+  bool op0_ok, op1_ok;\n \n-  if (!is_gimple_assign (last_stmt))\n+  if (!is_gimple_assign (*last_stmt))\n     return NULL;\n \n-  type = gimple_expr_type (last_stmt);\n+  type = gimple_expr_type (*last_stmt);\n \n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (last_stmt) != MULT_EXPR)\n+  if (gimple_assign_rhs_code (*last_stmt) != MULT_EXPR)\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  oprnd0 = gimple_assign_rhs1 (*last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (*last_stmt);\n   if (!types_compatible_p (TREE_TYPE (oprnd0), type)\n       || !types_compatible_p (TREE_TYPE (oprnd1), type))\n     return NULL;\n \n-  /* Check argument 0 */\n-  if (!widened_name_p (oprnd0, last_stmt, &half_type0, &def_stmt0))\n-    return NULL;\n-  oprnd0 = gimple_assign_rhs1 (def_stmt0);\n+  /* Check argument 0.  */\n+  op0_ok = widened_name_p (oprnd0, *last_stmt, &half_type0, &def_stmt0, false);\n+  /* Check argument 1.  */\n+  op1_ok = widened_name_p (oprnd1, *last_stmt, &half_type1, &def_stmt1, false);\n \n-  /* Check argument 1 */\n-  if (!widened_name_p (oprnd1, last_stmt, &half_type1, &def_stmt1))\n+  /* In case of multiplication by a constant one of the operands may not match\n+     the pattern, but not both.  */\n+  if (!op0_ok && !op1_ok)\n     return NULL;\n-  oprnd1 = gimple_assign_rhs1 (def_stmt1);\n+\n+  if (op0_ok && op1_ok)\n+    {\n+      oprnd0 = gimple_assign_rhs1 (def_stmt0);\n+      oprnd1 = gimple_assign_rhs1 (def_stmt1);\n+    }\t       \n+  else if (!op0_ok)\n+    {\n+      if (CONSTANT_CLASS_P (oprnd0)\n+\t  && TREE_CODE (half_type1) == INTEGER_TYPE\n+\t  && tree_int_cst_lt (oprnd0, TYPE_MAXVAL (half_type1))\n+          && tree_int_cst_lt (TYPE_MINVAL (half_type1), oprnd0))\n+        {\n+\t  /* OPRND0 is a constant of HALF_TYPE1.  */\n+ \t  half_type0 = half_type1;\n+          oprnd1 = gimple_assign_rhs1 (def_stmt1);\n+        }\n+      else\n+\treturn NULL;\n+    }\n+  else if (!op1_ok)\n+    {\n+      if (CONSTANT_CLASS_P (oprnd1)\n+          && TREE_CODE (half_type0) == INTEGER_TYPE\n+          && tree_int_cst_lt (oprnd1, TYPE_MAXVAL (half_type0))\n+          && tree_int_cst_lt (TYPE_MINVAL (half_type0), oprnd1))\n+        {\n+\t  /* OPRND1 is a constant of HALF_TYPE0.  */\n+          half_type1 = half_type0;\n+          oprnd0 = gimple_assign_rhs1 (def_stmt0);\n+        }\n+      else\n+        return NULL;\n+    }\n+\n+  /* Handle unsigned case.  Look for\n+     S6  u_prod_T = (unsigned TYPE) prod_T;\n+     Use unsigned TYPE as the type for WIDEN_MULT_EXPR.  */\n+  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (half_type0))\n+    {\n+      tree lhs = gimple_assign_lhs (*last_stmt), use_lhs;\n+      imm_use_iterator imm_iter;\n+      use_operand_p use_p;\n+      int nuses = 0;\n+      gimple use_stmt = NULL;\n+      tree use_type;\n+\n+      if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (half_type1))\n+        return NULL;\n+\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+        {\n+          use_stmt = USE_STMT (use_p);\n+          nuses++;\n+        }\n+\n+      if (nuses != 1 || !is_gimple_assign (use_stmt)\n+          || gimple_assign_rhs_code (use_stmt) != NOP_EXPR)\n+        return NULL;\n+\n+      use_lhs = gimple_assign_lhs (use_stmt);\n+      use_type = TREE_TYPE (use_lhs);\n+      if (!INTEGRAL_TYPE_P (use_type)\n+          || (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (use_type))\n+          || (TYPE_PRECISION (type) != TYPE_PRECISION (use_type)))\n+        return NULL;\n+\n+      type = use_type;\n+      *last_stmt = use_stmt;\n+    }\n \n   if (!types_compatible_p (half_type0, half_type1))\n     return NULL;\n@@ -413,7 +504,7 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n   vectype_out = get_vectype_for_scalar_type (type);\n   if (!vectype\n       || !vectype_out\n-      || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n+      || !supportable_widening_operation (WIDEN_MULT_EXPR, *last_stmt,\n \t\t\t\t\t  vectype_out, vectype,\n \t\t\t\t\t  &dummy, &dummy, &dummy_code,\n \t\t\t\t\t  &dummy_code, &dummy_int, &dummy_vec))\n@@ -462,16 +553,16 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n */\n \n static gimple\n-vect_recog_pow_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n+vect_recog_pow_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n {\n   tree fn, base, exp = NULL;\n   gimple stmt;\n   tree var;\n \n-  if (!is_gimple_call (last_stmt) || gimple_call_lhs (last_stmt) == NULL)\n+  if (!is_gimple_call (*last_stmt) || gimple_call_lhs (*last_stmt) == NULL)\n     return NULL;\n \n-  fn = gimple_call_fndecl (last_stmt);\n+  fn = gimple_call_fndecl (*last_stmt);\n   if (fn == NULL_TREE || DECL_BUILT_IN_CLASS (fn) != BUILT_IN_NORMAL)\n    return NULL;\n \n@@ -481,8 +572,8 @@ vect_recog_pow_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n     case BUILT_IN_POWI:\n     case BUILT_IN_POWF:\n     case BUILT_IN_POW:\n-      base = gimple_call_arg (last_stmt, 0);\n-      exp = gimple_call_arg (last_stmt, 1);\n+      base = gimple_call_arg (*last_stmt, 0);\n+      exp = gimple_call_arg (*last_stmt, 1);\n       if (TREE_CODE (exp) != REAL_CST\n \t  && TREE_CODE (exp) != INTEGER_CST)\n         return NULL;\n@@ -574,21 +665,21 @@ vect_recog_pow_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \t inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple\n-vect_recog_widen_sum_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n+vect_recog_widen_sum_pattern (gimple *last_stmt, tree *type_in, tree *type_out)\n {\n   gimple stmt;\n   tree oprnd0, oprnd1;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (*last_stmt);\n   tree type, half_type;\n   gimple pattern_stmt;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n   tree var;\n \n-  if (!is_gimple_assign (last_stmt))\n+  if (!is_gimple_assign (*last_stmt))\n     return NULL;\n \n-  type = gimple_expr_type (last_stmt);\n+  type = gimple_expr_type (*last_stmt);\n \n   /* Look for the following pattern\n           DX = (TYPE) X;\n@@ -600,25 +691,25 @@ vect_recog_widen_sum_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n+  if (gimple_assign_rhs_code (*last_stmt) != PLUS_EXPR)\n     return NULL;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  oprnd0 = gimple_assign_rhs1 (*last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (*last_stmt);\n   if (!types_compatible_p (TREE_TYPE (oprnd0), type)\n       || !types_compatible_p (TREE_TYPE (oprnd1), type))\n     return NULL;\n \n-  /* So far so good. Since last_stmt was detected as a (summation) reduction,\n+  /* So far so good.  Since *last_stmt was detected as a (summation) reduction,\n      we know that oprnd1 is the reduction variable (defined by a loop-header\n      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.\n      Left to check that oprnd0 is defined by a cast from type 'type' to type\n      'TYPE'.  */\n \n-  if (!widened_name_p (oprnd0, last_stmt, &half_type, &stmt))\n+  if (!widened_name_p (oprnd0, *last_stmt, &half_type, &stmt, true))\n     return NULL;\n \n   oprnd0 = gimple_assign_rhs1 (stmt);\n@@ -639,7 +730,7 @@ vect_recog_widen_sum_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n   /* We don't allow changing the order of the computation in the inner-loop\n      when doing outer-loop vectorization.  */\n-  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n+  gcc_assert (!nested_in_vect_loop_p (loop, *last_stmt));\n \n   return pattern_stmt;\n }\n@@ -669,23 +760,27 @@ vect_recog_widen_sum_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n \n static void\n vect_pattern_recog_1 (\n-\tgimple (* vect_recog_func) (gimple, tree *, tree *),\n+\tgimple (* vect_recog_func) (gimple *, tree *, tree *),\n \tgimple_stmt_iterator si)\n {\n   gimple stmt = gsi_stmt (si), pattern_stmt;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info stmt_info;\n   stmt_vec_info pattern_stmt_info;\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  loop_vec_info loop_vinfo;\n   tree pattern_vectype;\n   tree type_in, type_out;\n   enum tree_code code;\n   int i;\n   gimple next;\n \n-  pattern_stmt = (* vect_recog_func) (stmt, &type_in, &type_out);\n+  pattern_stmt = (* vect_recog_func) (&stmt, &type_in, &type_out);\n   if (!pattern_stmt)\n     return;\n \n+  si = gsi_for_stmt (stmt);\n+  stmt_info = vinfo_for_stmt (stmt);\n+  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+ \n   if (VECTOR_MODE_P (TYPE_MODE (type_in)))\n     {\n       /* No need to check target support (already checked by the pattern\n@@ -832,7 +927,7 @@ vect_pattern_recog (loop_vec_info loop_vinfo)\n   unsigned int nbbs = loop->num_nodes;\n   gimple_stmt_iterator si;\n   unsigned int i, j;\n-  gimple (* vect_recog_func_ptr) (gimple, tree *, tree *);\n+  gimple (* vect_recog_func_ptr) (gimple *, tree *, tree *);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_pattern_recog ===\");"}, {"sha": "1b2ed20040de34fb522422c6886c13408465462e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -3232,6 +3232,33 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \tfprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n+\n+  op_type = TREE_CODE_LENGTH (code);\n+  if (op_type == binary_op)\n+    {\n+      bool ok;\n+\n+      op1 = gimple_assign_rhs2 (stmt);\n+      if (code == WIDEN_MULT_EXPR)\n+        {\n+\t  /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n+\t     OP1.  */\n+          if (CONSTANT_CLASS_P (op0))\n+            ok = vect_is_simple_use_1 (op1, loop_vinfo, NULL,\n+                             &def_stmt, &def, &dt[1], &vectype_in);\n+          else\n+            ok = vect_is_simple_use (op1, loop_vinfo, NULL, &def_stmt, &def,\n+                                     &dt[1]);\n+\n+          if (!ok)\n+            {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t        fprintf (vect_dump, \"use not simple.\");\n+              return false;\n+            }\n+        }        \n+    }\n+\n   /* If op0 is an external or constant def use a vector type with\n      the same size as the output vector type.  */\n   if (!vectype_in)\n@@ -3264,18 +3291,6 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  op_type = TREE_CODE_LENGTH (code);\n-  if (op_type == binary_op)\n-    {\n-      op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, loop_vinfo, NULL, &def_stmt, &def, &dt[1]))\n-        {\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"use not simple.\");\n-          return false;\n-        }\n-    }\n-\n   /* Supportable by target?  */\n   if (!supportable_widening_operation (code, stmt, vectype_out, vectype_in,\n \t\t\t\t       &decl1, &decl2, &code1, &code2,\n@@ -3301,6 +3316,14 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n     fprintf (vect_dump, \"transform type promotion operation. ncopies = %d.\",\n                         ncopies);\n \n+  if (code == WIDEN_MULT_EXPR)\n+    {\n+      if (CONSTANT_CLASS_P (op0))\n+\top0 = fold_convert (TREE_TYPE (op1), op0);\n+      else if (CONSTANT_CLASS_P (op1))\n+\top1 = fold_convert (TREE_TYPE (op0), op1);\n+    }\n+\n   /* Handle def.  */\n   /* In case of multi-step promotion, we first generate promotion operations\n      to the intermediate types, and then from that types to the final one."}, {"sha": "b87452ab080cfb7d84bdc99b73a4e310bedbceab", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383d9c83756ed27807c0a8e5864ff542e3561905/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=383d9c83756ed27807c0a8e5864ff542e3561905", "patch": "@@ -896,7 +896,7 @@ extern void vect_slp_transform_bb (basic_block);\n /* Pattern recognition functions.\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n-typedef gimple (* vect_recog_func_ptr) (gimple, tree *, tree *);\n+typedef gimple (* vect_recog_func_ptr) (gimple *, tree *, tree *);\n #define NUM_PATTERNS 4\n void vect_pattern_recog (loop_vec_info);\n "}]}