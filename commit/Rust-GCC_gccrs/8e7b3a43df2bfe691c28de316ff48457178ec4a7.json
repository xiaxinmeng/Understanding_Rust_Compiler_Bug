{"sha": "8e7b3a43df2bfe691c28de316ff48457178ec4a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3YjNhNDNkZjJiZmU2OTFjMjhkZTMxNmZmNDg0NTcxNzhlYzRhNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-20T14:13:28Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-20T14:13:28Z"}, "message": "fold-const.c (fold): Remove variable \"invert\".\n\n\t* fold-const.c (fold): Remove variable \"invert\".\n\tMove the handling of relational expressions that can be folded\n\tto a constant ...\n\t(fold_relational_const): ... here.\n\t(tree_expr_nonzero_p): New.\n\nFrom-SVN: r79745", "tree": {"sha": "ce892def893b74ec079a512c9c6075886e2a8acf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce892def893b74ec079a512c9c6075886e2a8acf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7b3a43df2bfe691c28de316ff48457178ec4a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7b3a43df2bfe691c28de316ff48457178ec4a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7b3a43df2bfe691c28de316ff48457178ec4a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7b3a43df2bfe691c28de316ff48457178ec4a7/comments", "author": null, "committer": null, "parents": [{"sha": "c048d56d7e1750c411ffc7f67415beab926c1d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c048d56d7e1750c411ffc7f67415beab926c1d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c048d56d7e1750c411ffc7f67415beab926c1d05"}], "stats": {"total": 290, "additions": 203, "deletions": 87}, "files": [{"sha": "659cca4878ed7cb48ee4979fd7718125681fbe6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7b3a43df2bfe691c28de316ff48457178ec4a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7b3a43df2bfe691c28de316ff48457178ec4a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e7b3a43df2bfe691c28de316ff48457178ec4a7", "patch": "@@ -1,3 +1,11 @@\n+2004-03-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c (fold): Remove variable \"invert\".\n+\tMove the handling of relational expressions that can be folded\n+\tto a constant ...\n+\t(fold_relational_const): ... here.\n+\t(tree_expr_nonzero_p): New.\n+\n 2004-03-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/14635"}, {"sha": "0565b252dba7cd4a2bb9fe29aa060edcad3560f0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 195, "deletions": 87, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7b3a43df2bfe691c28de316ff48457178ec4a7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7b3a43df2bfe691c28de316ff48457178ec4a7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8e7b3a43df2bfe691c28de316ff48457178ec4a7", "patch": "@@ -115,6 +115,7 @@ static bool tree_swap_operands_p (tree, tree, bool);\n \n static tree fold_negate_const (tree, tree);\n static tree fold_abs_const (tree, tree);\n+static tree fold_relational_const (enum tree_code, tree, tree, tree);\n \n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n@@ -5391,7 +5392,6 @@ fold (tree expr)\n   tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n   enum tree_code code = TREE_CODE (t);\n   int kind = TREE_CODE_CLASS (code);\n-  int invert;\n   /* WINS will be nonzero when the switch is done\n      if all operands are constant.  */\n   int wins = 1;\n@@ -7919,92 +7919,9 @@ fold (tree expr)\n \t\t\t\tinteger_zero_node));\n \t}\n \n-      /* From here on, the only cases we handle are when the result is\n-\t known to be a constant.\n-\n-\t To compute GT, swap the arguments and do LT.\n-\t To compute GE, do LT and invert the result.\n-\t To compute LE, swap the arguments, do LT and invert the result.\n-\t To compute NE, do EQ and invert the result.\n-\n-\t Therefore, the code below must handle only EQ and LT.  */\n-\n-      if (code == LE_EXPR || code == GT_EXPR)\n-\t{\n-\t  tem = arg0, arg0 = arg1, arg1 = tem;\n-\t  code = swap_tree_comparison (code);\n-\t}\n-\n-      /* Note that it is safe to invert for real values here because we\n-\t will check below in the one case that it matters.  */\n-\n-      t1 = NULL_TREE;\n-      invert = 0;\n-      if (code == NE_EXPR || code == GE_EXPR)\n-\t{\n-\t  invert = 1;\n-\t  code = invert_tree_comparison (code);\n-\t}\n-\n-      /* Compute a result for LT or EQ if args permit;\n-\t otherwise return T.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-\t{\n-\t  if (code == EQ_EXPR)\n-\t    t1 = build_int_2 (tree_int_cst_equal (arg0, arg1), 0);\n-\t  else\n-\t    t1 = build_int_2 ((TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t       ? INT_CST_LT_UNSIGNED (arg0, arg1)\n-\t\t\t       : INT_CST_LT (arg0, arg1)),\n-\t\t\t      0);\n-\t}\n-\n-#if 0 /* This is no longer useful, but breaks some real code.  */\n-      /* Assume a nonexplicit constant cannot equal an explicit one,\n-\t since such code would be undefined anyway.\n-\t Exception: on sysvr4, using #pragma weak,\n-\t a label can come out as 0.  */\n-      else if (TREE_CODE (arg1) == INTEGER_CST\n-\t       && !integer_zerop (arg1)\n-\t       && TREE_CONSTANT (arg0)\n-\t       && TREE_CODE (arg0) == ADDR_EXPR\n-\t       && code == EQ_EXPR)\n-\tt1 = build_int_2 (0, 0);\n-#endif\n-      /* Two real constants can be compared explicitly.  */\n-      else if (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  /* If either operand is a NaN, the result is false with two\n-\t     exceptions: First, an NE_EXPR is true on NaNs, but that case\n-\t     is already handled correctly since we will be inverting the\n-\t     result for NE_EXPR.  Second, if we had inverted a LE_EXPR\n-\t     or a GE_EXPR into a LT_EXPR, we must return true so that it\n-\t     will be inverted into false.  */\n-\n-\t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg0))\n-\t      || REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n-\t    t1 = build_int_2 (invert && code == LT_EXPR, 0);\n-\n-\t  else if (code == EQ_EXPR)\n-\t    t1 = build_int_2 (REAL_VALUES_EQUAL (TREE_REAL_CST (arg0),\n-\t\t\t\t\t\t TREE_REAL_CST (arg1)),\n-\t\t\t      0);\n-\t  else\n-\t    t1 = build_int_2 (REAL_VALUES_LESS (TREE_REAL_CST (arg0),\n-\t\t\t\t\t\tTREE_REAL_CST (arg1)),\n-\t\t\t      0);\n-\t}\n-\n-      if (t1 == NULL_TREE)\n-\treturn t;\n-\n-      if (invert)\n-\tTREE_INT_CST_LOW (t1) ^= 1;\n-\n-      TREE_TYPE (t1) = type;\n-      if (TREE_CODE (type) == BOOLEAN_TYPE)\n-\treturn lang_hooks.truthvalue_conversion (t1);\n-      return t1;\n+      /* Both ARG0 and ARG1 are known to be constants at this point.  */\n+      t1 = fold_relational_const (code, type, arg0, arg1);\n+      return (t1 == NULL_TREE ? t : t1);\n \n     case COND_EXPR:\n       /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n@@ -8963,6 +8880,106 @@ tree_expr_nonnegative_p (tree t)\n   return 0;\n }\n \n+/* Return true when T is an address and is known to be nonzero.\n+   For floating point we further ensure that T is not denormal.\n+   Similar logic is present in nonzero_address in rtlanal.h  */\n+\n+static bool\n+tree_expr_nonzero_p (tree t)\n+{\n+  tree type = TREE_TYPE (t);\n+\n+  /* Doing something usefull for floating point would need more work.  */\n+  if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n+    return false;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case ABS_EXPR:\n+      if (!TREE_UNSIGNED (type) && !flag_wrapv)\n+\treturn tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n+\n+    case INTEGER_CST:\n+      return !integer_zerop (t);\n+\n+    case PLUS_EXPR:\n+      if (!TREE_UNSIGNED (type) && !flag_wrapv)\n+\t{\n+\t  /* With the presence of negative values it is hard\n+\t     to say something.  */\n+\t  if (!tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n+\t      || !tree_expr_nonnegative_p (TREE_OPERAND (t, 1)))\n+\t    return false;\n+\t  /* One of operands must be positive and the other non-negative.  */\n+\t  return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n+\t          || tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n+\t}\n+      break;\n+\n+    case MULT_EXPR:\n+      if (!TREE_UNSIGNED (type) && !flag_wrapv)\n+\t{\n+\t  return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n+\t          && tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n+\t}\n+      break;\n+\n+    case NOP_EXPR:\n+      {\n+\ttree inner_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\ttree outer_type = TREE_TYPE (t);\n+\n+\treturn (TYPE_PRECISION (inner_type) >= TYPE_PRECISION (outer_type)\n+\t\t&& tree_expr_nonzero_p (TREE_OPERAND (t, 0)));\n+      }\n+      break;\n+\n+   case ADDR_EXPR:\n+      /* Weak declarations may link to NULL.  */\n+      if (DECL_P (TREE_OPERAND (t, 0)))\n+\treturn !DECL_WEAK (TREE_OPERAND (t, 0));\n+      /* Constants and all other cases are never weak.  */\n+      return true;\n+\n+    case COND_EXPR:\n+      return (tree_expr_nonzero_p (TREE_OPERAND (t, 1))\n+\t      && tree_expr_nonzero_p (TREE_OPERAND (t, 2)));\n+\n+    case MIN_EXPR:\n+      return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n+\t      && tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n+\n+    case MAX_EXPR:\n+      if (tree_expr_nonzero_p (TREE_OPERAND (t, 0)))\n+\t{\n+\t  /* When both operands are nonzero, then MAX must be too.  */\n+\t  if (tree_expr_nonzero_p (TREE_OPERAND (t, 1)))\n+\t    return true;\n+\n+\t  /* MAX where operand 0 is positive is positive.  */\n+\t  return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\t}\n+      /* MAX where operand 1 is positive is positive.  */\n+      else if (tree_expr_nonzero_p (TREE_OPERAND (t, 1))\n+\t       && tree_expr_nonnegative_p (TREE_OPERAND (t, 1)))\n+\treturn true;\n+      break;\n+\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case BIND_EXPR:\n+      return tree_expr_nonzero_p (TREE_OPERAND (t, 1));\n+\n+    case SAVE_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n /* Return true if `r' is known to be non-negative.\n    Only handles constants at the moment.  */\n \n@@ -9094,4 +9111,95 @@ fold_abs_const (tree arg0, tree type)\n   return t;\n }\n \n+/* Given CODE, a relational operator, the target type, TYPE and two\n+   constant operands OP0 and OP1, return the result of the\n+   relational operation.  If the result is not a compile time\n+   constant, then return NULL_TREE.  */\n+\n+static tree\n+fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n+{\n+  tree tem;\n+  int invert;\n+\n+  /* From here on, the only cases we handle are when the result is\n+     known to be a constant.\n+\n+     To compute GT, swap the arguments and do LT.\n+     To compute GE, do LT and invert the result.\n+     To compute LE, swap the arguments, do LT and invert the result.\n+     To compute NE, do EQ and invert the result.\n+\n+     Therefore, the code below must handle only EQ and LT.  */\n+\n+  if (code == LE_EXPR || code == GT_EXPR)\n+    {\n+      tem = op0, op0 = op1, op1 = tem;\n+      code = swap_tree_comparison (code);\n+    }\n+\n+  /* Note that it is safe to invert for real values here because we\n+     will check below in the one case that it matters.  */\n+\n+  tem = NULL_TREE;\n+  invert = 0;\n+  if (code == NE_EXPR || code == GE_EXPR)\n+    {\n+      invert = 1;\n+      code = invert_tree_comparison (code);\n+    }\n+\n+  /* Compute a result for LT or EQ if args permit;\n+     Otherwise return T.  */\n+  if (TREE_CODE (op0) == INTEGER_CST && TREE_CODE (op1) == INTEGER_CST)\n+    {\n+      if (code == EQ_EXPR)\n+        tem = build_int_2 (tree_int_cst_equal (op0, op1), 0);\n+      else\n+        tem = build_int_2 ((TREE_UNSIGNED (TREE_TYPE (op0))\n+\t\t\t    ? INT_CST_LT_UNSIGNED (op0, op1)\n+\t\t\t    : INT_CST_LT (op0, op1)),\n+\t\t\t   0);\n+    }\n+\n+  else if (code == EQ_EXPR && !TREE_SIDE_EFFECTS (op0)\n+           && integer_zerop (op1) && tree_expr_nonzero_p (op0))\n+    tem = build_int_2 (0, 0);\n+\n+  /* Two real constants can be compared explicitly.  */\n+  else if (TREE_CODE (op0) == REAL_CST && TREE_CODE (op1) == REAL_CST)\n+    {\n+      /* If either operand is a NaN, the result is false with two\n+\t exceptions: First, an NE_EXPR is true on NaNs, but that case\n+\t is already handled correctly since we will be inverting the\n+\t result for NE_EXPR.  Second, if we had inverted a LE_EXPR\n+\t or a GE_EXPR into a LT_EXPR, we must return true so that it\n+\t will be inverted into false.  */\n+\n+      if (REAL_VALUE_ISNAN (TREE_REAL_CST (op0))\n+          || REAL_VALUE_ISNAN (TREE_REAL_CST (op1)))\n+        tem = build_int_2 (invert && code == LT_EXPR, 0);\n+\n+      else if (code == EQ_EXPR)\n+        tem = build_int_2 (REAL_VALUES_EQUAL (TREE_REAL_CST (op0),\n+\t\t\t\t\t      TREE_REAL_CST (op1)),\n+\t\t\t   0);\n+      else\n+        tem = build_int_2 (REAL_VALUES_LESS (TREE_REAL_CST (op0),\n+\t\t\t\t\t     TREE_REAL_CST (op1)),\n+\t\t\t   0);\n+    }\n+\n+  if (tem == NULL_TREE)\n+    return NULL_TREE;\n+\n+  if (invert)\n+    TREE_INT_CST_LOW (tem) ^= 1;\n+\n+  TREE_TYPE (tem) = type;\n+  if (TREE_CODE (type) == BOOLEAN_TYPE)\n+    return (*lang_hooks.truthvalue_conversion) (tem);\n+  return tem;\n+}\n+\n #include \"gt-fold-const.h\""}]}