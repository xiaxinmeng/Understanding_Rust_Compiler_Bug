{"sha": "8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmMGZiNWNlZmI5ODFmMTZjM2JhZTljMDBkMWM2ZDhmNTg4NmEwZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-03-19T13:36:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-03-19T13:36:18Z"}, "message": "revert: re PR middle-end/63155 (memory hog)\n\n2015-03-19  Richard Biener  <rguenther@suse.de>\n\n\tRevert\n\t2015-03-10  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/63155\n\t* tree-ssa-coalesce.h (verify_ssa_coalescing): Declare.\n\t* tree-ssa-coalesce.c: Include timevar.h.\n\t(attempt_coalesce): Handle graph being NULL.\n\t(coalesce_partitions): Call verify_ssa_coalescing if ENABLE_CHECKING.\n\tSplit out abnormal coalescing to ...\n\t(perform_abnormal_coalescing): ... this function.\n\t(coalesce_ssa_name): Perform abnormal coalescing without computing\n\tlive/conflict.\n\t(verify_ssa_coalescing_worker): New function.\n\t(verify_ssa_coalescing): Likewise.\n\nFrom-SVN: r221515", "tree": {"sha": "5358cb58a065a12943260386c9af2dd4b3066b58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5358cb58a065a12943260386c9af2dd4b3066b58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c5c36d495fc500eb69e19db0487c78a3127f3d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5c36d495fc500eb69e19db0487c78a3127f3d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c5c36d495fc500eb69e19db0487c78a3127f3d8"}], "stats": {"total": 172, "additions": 38, "deletions": 134}, "files": [{"sha": "902de0564e29aeec020912632d312e3e6832eb0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "patch": "@@ -1,3 +1,20 @@\n+2015-03-19  Richard Biener  <rguenther@suse.de>\n+\n+\tRevert\n+\t2015-03-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/63155\n+\t* tree-ssa-coalesce.h (verify_ssa_coalescing): Declare.\n+\t* tree-ssa-coalesce.c: Include timevar.h.\n+\t(attempt_coalesce): Handle graph being NULL.\n+\t(coalesce_partitions): Call verify_ssa_coalescing if ENABLE_CHECKING.\n+\tSplit out abnormal coalescing to ...\n+\t(perform_abnormal_coalescing): ... this function.\n+\t(coalesce_ssa_name): Perform abnormal coalescing without computing\n+\tlive/conflict.\n+\t(verify_ssa_coalescing_worker): New function.\n+\t(verify_ssa_coalescing): Likewise.\n+\n 2015-03-19  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "1afeefef2ef7312802b4c9000d44e17ab7ed01e9", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 21, "deletions": 133, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "patch": "@@ -59,7 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-live.h\"\n #include \"tree-ssa-coalesce.h\"\n #include \"diagnostic-core.h\"\n-#include \"timevar.h\"\n \n \n /* This set of routines implements a coalesce_list.  This is an object which\n@@ -1122,8 +1121,8 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \n \n /* Attempt to coalesce ssa versions X and Y together using the partition\n-   mapping in MAP and checking conflicts in GRAPH if not NULL.\n-   Output any debug info to DEBUG, if it is nun-NULL.  */\n+   mapping in MAP and checking conflicts in GRAPH.  Output any debug info to\n+   DEBUG, if it is nun-NULL.  */\n \n static inline bool\n attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n@@ -1155,8 +1154,7 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n     fprintf (debug, \" [map: %d, %d] \", p1, p2);\n \n \n-  if (!graph\n-      || !ssa_conflicts_test_p (graph, p1, p2))\n+  if (!ssa_conflicts_test_p (graph, p1, p2))\n     {\n       var1 = partition_to_var (map, p1);\n       var2 = partition_to_var (map, p2);\n@@ -1170,13 +1168,10 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n \n       /* z is the new combined partition.  Remove the other partition from\n \t the list, and merge the conflicts.  */\n-      if (graph)\n-\t{\n-\t  if (z == p1)\n-\t    ssa_conflicts_merge (graph, p1, p2);\n-\t  else\n-\t    ssa_conflicts_merge (graph, p2, p1);\n-\t}\n+      if (z == p1)\n+\tssa_conflicts_merge (graph, p1, p2);\n+      else\n+\tssa_conflicts_merge (graph, p2, p1);\n \n       if (debug)\n \tfprintf (debug, \": Success -> %d\\n\", z);\n@@ -1190,16 +1185,24 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n }\n \n \n-/* Perform all abnormal coalescing on MAP.\n-   Debug output is sent to DEBUG if it is non-NULL.  */\n+/* Attempt to Coalesce partitions in MAP which occur in the list CL using\n+   GRAPH.  Debug output is sent to DEBUG if it is non-NULL.  */\n \n static void\n-perform_abnormal_coalescing (var_map map, FILE *debug)\n+coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n+\t\t     FILE *debug)\n {\n+  int x = 0, y = 0;\n+  tree var1, var2;\n+  int cost;\n   basic_block bb;\n   edge e;\n   edge_iterator ei;\n \n+  /* First, coalesce all the copies across abnormal edges.  These are not placed\n+     in the coalesce list because they do not need to be sorted, and simply\n+     consume extra memory/compilation time in large programs.  */\n+\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -1223,23 +1226,11 @@ perform_abnormal_coalescing (var_map map, FILE *debug)\n \t\tif (debug)\n \t\t  fprintf (debug, \"Abnormal coalesce: \");\n \n-\t\tif (!attempt_coalesce (map, NULL, v1, v2, debug))\n+\t\tif (!attempt_coalesce (map, graph, v1, v2, debug))\n \t\t  fail_abnormal_edge_coalesce (v1, v2);\n \t      }\n \t  }\n     }\n-}\n-\n-/* Attempt to Coalesce partitions in MAP which occur in the list CL using\n-   GRAPH.  Debug output is sent to DEBUG if it is non-NULL.  */\n-\n-static void\n-coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n-\t\t     FILE *debug)\n-{\n-  int x = 0, y = 0;\n-  tree var1, var2;\n-  int cost;\n \n   /* Now process the items in the coalesce list.  */\n \n@@ -1294,11 +1285,6 @@ coalesce_ssa_name (void)\n   var_map map;\n   unsigned int i;\n \n-#ifdef ENABLE_CHECKING\n-  /* Verify we can perform all must coalesces.  */\n-  verify_ssa_coalescing ();\n-#endif\n-\n   cl = create_coalesce_list ();\n   map = create_outofssa_var_map (cl, used_in_copies);\n \n@@ -1355,15 +1341,6 @@ coalesce_ssa_name (void)\n       return map;\n     }\n \n-  /* First, coalesce all the copies across abnormal edges.  These are not placed\n-     in the coalesce list because they do not need to be sorted, and simply\n-     consume extra memory/compilation time in large programs.\n-     Performing abnormal coalescing also needs no live/conflict computation\n-     because it must succeed (but we lose checking that it indeed does).\n-     Still for PR63155 this reduces memory usage from 10GB to zero.  */\n-  perform_abnormal_coalescing (map,\n-\t\t\t       ((dump_flags & TDF_DETAILS) ? dump_file : NULL));\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);\n \n@@ -1394,100 +1371,11 @@ coalesce_ssa_name (void)\n \n   /* Now coalesce everything in the list.  */\n   coalesce_partitions (map, graph, cl,\n-\t\t       ((dump_flags & TDF_DETAILS) ? dump_file : NULL));\n+\t\t       ((dump_flags & TDF_DETAILS) ? dump_file\n+\t\t\t\t\t\t   : NULL));\n \n   delete_coalesce_list (cl);\n   ssa_conflicts_delete (graph);\n \n   return map;\n }\n-\n-\n-/* Helper for verify_ssa_coalescing.  Operates in two modes:\n-   1) scan the function for coalesces we must perform and store the\n-      SSA names participating in USED_IN_COPIES\n-   2) scan the function for coalesces and verify they can be performed\n-      under the constraints of GRAPH updating MAP in the process\n-   FIXME:  This can be extended to verify that the virtual operands\n-   form a factored use-def chain (coalescing the active virtual use\n-   with the virtual def at virtual def point).  */\n-\n-static void\n-verify_ssa_coalescing_worker (bitmap used_in_copies,\n-\t\t\t      var_map map, ssa_conflicts_p graph)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (e->flags & EDGE_ABNORMAL)\n-\t  {\n-\t    gphi_iterator gsi;\n-\t    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n-\t\t gsi_next (&gsi))\n-\t      {\n-\t\tgphi *phi = gsi.phi ();\n-\t\ttree arg = PHI_ARG_DEF (phi, e->dest_idx);\n-\t\tif (SSA_NAME_IS_DEFAULT_DEF (arg)\n-\t\t    && (!SSA_NAME_VAR (arg)\n-\t\t\t|| TREE_CODE (SSA_NAME_VAR (arg)) != PARM_DECL))\n-\t\t  continue;\n-\n-\t\ttree res = PHI_RESULT (phi);\n-\n-\t\tint v1 = SSA_NAME_VERSION (res);\n-\t\tint v2 = SSA_NAME_VERSION (arg);\n-\t\tif (used_in_copies)\n-\t\t  {\n-\t\t    bitmap_set_bit (used_in_copies, v1);\n-\t\t    bitmap_set_bit (used_in_copies, v2);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    int p1 = var_to_partition (map, res);\n-\t\t    int p2 = var_to_partition (map, arg);\n-\t\t    if (p1 != p2)\n-\t\t      {\n-\t\t\tif (ssa_conflicts_test_p (graph, p1, p2))\n-\t\t\t  fail_abnormal_edge_coalesce (v1, v2);\n-\t\t\tint z = var_union (map,\n-\t\t\t\t\t   partition_to_var (map, p1),\n-\t\t\t\t\t   partition_to_var (map, p2));\n-\t\t\tif (z == p1)\n-\t\t\t  ssa_conflicts_merge (graph, p1, p2);\n-\t\t\telse\n-\t\t\t  ssa_conflicts_merge (graph, p2, p1);\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-    }\n-}\n-\n-/* Verify that we can coalesce SSA names we must coalesce.  */\n-\n-DEBUG_FUNCTION void\n-verify_ssa_coalescing (void)\n-{\n-  auto_timevar tv (TV_TREE_SSA_VERIFY);\n-  bitmap used_in_copies = BITMAP_ALLOC (NULL);\n-  verify_ssa_coalescing_worker (used_in_copies, NULL, NULL);\n-  if (bitmap_empty_p (used_in_copies))\n-    {\n-      BITMAP_FREE (used_in_copies);\n-      return;\n-    }\n-  var_map map = init_var_map (num_ssa_names);\n-  partition_view_bitmap (map, used_in_copies, true);\n-  BITMAP_FREE (used_in_copies);\n-  tree_live_info_p liveinfo = calculate_live_ranges (map, false);\n-  ssa_conflicts_p graph = build_ssa_conflict_graph (liveinfo);\n-  delete_tree_live_info (liveinfo);\n-  verify_ssa_coalescing_worker (NULL, map, graph);\n-  ssa_conflicts_delete (graph);\n-  delete_var_map (map);\n-}"}, {"sha": "99b188a3931cedf7469b240525288c7d4be8adbb", "filename": "gcc/tree-ssa-coalesce.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/gcc%2Ftree-ssa-coalesce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d/gcc%2Ftree-ssa-coalesce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.h?ref=8cf0fb5cefb981f16c3bae9c00d1c6d8f5886a0d", "patch": "@@ -21,6 +21,5 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_COALESCE_H\n \n extern var_map coalesce_ssa_name (void);\n-extern void verify_ssa_coalescing (void);\n \n #endif /* GCC_TREE_SSA_COALESCE_H */"}]}