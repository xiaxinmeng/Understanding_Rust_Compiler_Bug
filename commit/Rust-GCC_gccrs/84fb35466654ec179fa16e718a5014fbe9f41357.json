{"sha": "84fb35466654ec179fa16e718a5014fbe9f41357", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmYjM1NDY2NjU0ZWMxNzlmYTE2ZTcxOGE1MDE0ZmJlOWY0MTM1Nw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-23T10:55:51Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-24T01:16:01Z"}, "message": "analyzer: add -fno-analyzer-feasibility\n\nThis patch provides a new option \"-fno-analyzer-feasibility\" as a way\nto disable feasibility-checking of the constraints along the control\nflow paths for -fanalyzer diagnostics.  I'm adding this in the hope of\nmaking it easier to debug issues involving the feasibility-checking\nlogic.\n\nThe patch adds a new rejected_constraint object which is captured if\nexploded_path::feasible_p fails, and adds logic that uses this to emit\nan additional custom_event within the checker_path for the diagnostic,\nshowing where in the control flow path the diagnostic would have been\nrejected, and giving details of why.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (struct rejected_constraint): New decl.\n\t* analyzer.opt (fanalyzer-feasibility): New option.\n\t* diagnostic-manager.cc (path_builder::path_builder): Add\n\t\"problem\" param and use it to initialize new field.\n\t(path_builder::get_feasibility_problem): New accessor.\n\t(path_builder::m_feasibility_problem): New field.\n\t(dedupe_winners::add): Remove inversion of logic in \"if\" clause,\n\tswapping if/else suites.  In the !feasible_p suite, inspect\n\tflag_analyzer_feasibility and add code to handle when this\n\tis off, accepting the infeasible path, but recording the\n\tfeasibility_problem.\n\t(diagnostic_manager::emit_saved_diagnostic): Pass the\n\tfeasibility_problem to the path_builder.\n\t(diagnostic_manager::add_events_for_eedge): If we have\n\ta feasibility_problem at this edge, use it to add a custom event.\n\t* engine.cc (exploded_path::feasible_p): Pass a\n\trejected_constraint ** to model.maybe_update_for_edge and transfer\n\townership of any created instance to any feasibility_problem.\n\t(feasibility_problem::dump_to_pp): New.\n\t* exploded-graph.h (feasibility_problem::feasibility_problem):\n\tDrop \"model\" param; add rejected_constraint * param.\n\t(feasibility_problem::~feasibility_problem): New.\n\t(feasibility_problem::dump_to_pp): New decl.\n\t(feasibility_problem::m_model): Drop field.\n\t(feasibility_problem::m_rc): New field.\n\t* program-point.cc (function_point::get_location): Handle\n\tPK_BEFORE_SUPERNODE and PK_AFTER_SUPERNODE.\n\t* program-state.cc (program_state::on_edge): Pass NULL to new\n\tparam of region_model::maybe_update_for_edge.\n\t* region-model.cc (region_model::add_constraint): New overload\n\tadding a rejected_constraint ** param.\n\t(region_model::maybe_update_for_edge): Add rejected_constraint **\n\tparam and pass it to the various apply_constraints_for_ calls.\n\t(region_model::apply_constraints_for_gcond): Add\n\trejected_constraint ** param and pass it to add_constraint calls.\n\t(region_model::apply_constraints_for_gswitch): Likewise.\n\t(region_model::apply_constraints_for_exception): Likewise.\n\t(rejected_constraint::dump_to_pp): New.\n\t* region-model.h (region_model::maybe_update_for_edge):\n\tAdd rejected_constraint ** param.\n\t(region_model::add_constraint): New overload adding a\n\trejected_constraint ** param.\n\t(region_model::apply_constraints_for_gcond): Add\n\trejected_constraint ** param.\n\t(region_model::apply_constraints_for_gswitch): Likewise.\n\t(region_model::apply_constraints_for_exception): Likewise.\n\t(struct rejected_constraint): New.\n\ngcc/ChangeLog:\n\t* doc/analyzer.texi (Analyzer Paths): Add note about\n\t-fno-analyzer-feasibility.\n\t* doc/invoke.texi (Static Analyzer Options): Add\n\t-fno-analyzer-feasibility.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/feasibility-2.c: New test.", "tree": {"sha": "8c1102256b9609bb2744c227c31d974ec63ced12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c1102256b9609bb2744c227c31d974ec63ced12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84fb35466654ec179fa16e718a5014fbe9f41357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fb35466654ec179fa16e718a5014fbe9f41357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fb35466654ec179fa16e718a5014fbe9f41357", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fb35466654ec179fa16e718a5014fbe9f41357/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10a83805e047a583348e8bef18b966ecb8eee5d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a83805e047a583348e8bef18b966ecb8eee5d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a83805e047a583348e8bef18b966ecb8eee5d4"}], "stats": {"total": 268, "additions": 219, "deletions": 49}, "files": [{"sha": "aa43b7f66a9099d3db050bafd3610e1a39c2b7d1", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -71,6 +71,7 @@ class region_model;\n class region_model_context;\n   class impl_region_model_context;\n class call_details;\n+struct rejected_constraint;\n class constraint_manager;\n class equiv_class;\n "}, {"sha": "a4d384211f37655b971f40c85467a409156b37dd", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -126,6 +126,10 @@ fanalyzer-fine-grained\n Common Var(flag_analyzer_fine_grained) Init(0)\n Avoid combining multiple statements into one exploded edge.\n \n+fanalyzer-feasibility\n+Common Var(flag_analyzer_feasibility) Init(1)\n+Verify that paths are feasible when emitting diagnostics.\n+\n fanalyzer-show-duplicate-count\n Common Var(flag_analyzer_show_duplicate_count) Init(0)\n Issue a note when diagnostics are deduplicated."}, {"sha": "13dd3da606f022b620d280e6d9ade0c8a9ca4635", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -160,10 +160,12 @@ class path_builder\n {\n public:\n   path_builder (const exploded_graph &eg,\n-\t\tconst exploded_path &epath)\n+\t\tconst exploded_path &epath,\n+\t\tconst feasibility_problem *problem)\n   : m_eg (eg),\n     m_diag_enode (epath.get_final_enode ()),\n-    m_reachability (eg, m_diag_enode)\n+    m_reachability (eg, m_diag_enode),\n+    m_feasibility_problem (problem)\n   {}\n \n   const exploded_node *get_diag_node () const { return m_diag_enode; }\n@@ -175,6 +177,11 @@ class path_builder\n \n   const extrinsic_state &get_ext_state () const { return m_eg.get_ext_state (); }\n \n+  const feasibility_problem *get_feasibility_problem () const\n+  {\n+    return m_feasibility_problem;\n+  }\n+\n private:\n   typedef reachability<eg_traits> enode_reachability;\n \n@@ -185,6 +192,8 @@ class path_builder\n \n   /* Precompute all enodes from which the diagnostic is reachable.  */\n   enode_reachability m_reachability;\n+\n+  const feasibility_problem *m_feasibility_problem;\n };\n \n /* class diagnostic_manager.  */\n@@ -436,24 +445,38 @@ class dedupe_winners\n \t\t   sd->m_snode->m_index);\n \n     feasibility_problem *p = NULL;\n-    if (!dc->get_path ().feasible_p (logger, &p, m_engine, eg))\n+    if (dc->get_path ().feasible_p (logger, &p, m_engine, eg))\n       {\n \tif (logger)\n-\t  logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n-\t\t       \" due to infeasible path\",\n+\t  logger->log (\"accepting %qs at EN: %i, SN: %i with feasible path\",\n \t\t       sd->m_d->get_kind (), sd->m_enode->m_index,\n \t\t       sd->m_snode->m_index);\n-\tsd->set_infeasible (p);\n-\tdelete dc;\n-\treturn;\n+\tsd->set_feasible ();\n       }\n     else\n-      if (logger)\n-\tlogger->log (\"accepting %qs at EN: %i, SN: %i with feasible path\",\n-\t\t     sd->m_d->get_kind (), sd->m_enode->m_index,\n-\t\t     sd->m_snode->m_index);\n-\n-    sd->set_feasible ();\n+      {\n+\tif (flag_analyzer_feasibility)\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n+\t\t\t   \" due to infeasible path\",\n+\t\t\t   sd->m_d->get_kind (), sd->m_enode->m_index,\n+\t\t\t   sd->m_snode->m_index);\n+\t    sd->set_infeasible (p);\n+\t    delete dc;\n+\t    return;\n+\t  }\n+\telse\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"accepting %qs at EN: %i, SN: %i\"\n+\t\t\t   \" despite infeasible path (due to %qs)\",\n+\t\t\t   sd->m_d->get_kind (), sd->m_enode->m_index,\n+\t\t\t   sd->m_snode->m_index,\n+\t\t\t   \"-fno-analyzer-feasibility\");\n+\t    sd->set_infeasible (p);\n+\t  }\n+      }\n \n     dedupe_key *key = new dedupe_key (*sd, dc->get_path ());\n     if (dedupe_candidate **slot = m_map.get (key))\n@@ -598,7 +621,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n   pretty_printer *pp = global_dc->printer->clone ();\n \n   /* Precompute all enodes from which the diagnostic is reachable.  */\n-  path_builder pb (eg, epath);\n+  path_builder pb (eg, epath, sd.get_feasibility_problem ());\n \n   /* This is the diagnostic_path subclass that will be built for\n      the diagnostic.  */\n@@ -1043,6 +1066,22 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n       }\n       break;\n     }\n+\n+  if (pb.get_feasibility_problem ()\n+      && &pb.get_feasibility_problem ()->m_eedge == &eedge)\n+    {\n+      pretty_printer pp;\n+      pp_format_decoder (&pp) = default_tree_printer;\n+      pp_string (&pp,\n+\t\t \"this path would have been rejected as infeasible\"\n+\t\t \" at this edge: \");\n+      pb.get_feasibility_problem ()->dump_to_pp (&pp);\n+      emission_path->add_event (new custom_event\n+\t\t\t\t(dst_point.get_location (),\n+\t\t\t\t dst_point.get_fndecl (),\n+\t\t\t\t dst_stack_depth,\n+\t\t\t\t pp_formatted_text (&pp)));\n+    }\n }\n \n /* Return true if EEDGE is a significant edge in the path to the diagnostic"}, {"sha": "aa43e4cb808bb2f2af365db9bba947a1e3ca8591", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -3284,16 +3284,19 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out,\n \t\t\t sedge->get_description (false));\n \n \t  const gimple *last_stmt = src_point.get_supernode ()->get_last_stmt ();\n-\t  if (!model.maybe_update_for_edge (*sedge, last_stmt, NULL))\n+\t  rejected_constraint *rc = NULL;\n+\t  if (!model.maybe_update_for_edge (*sedge, last_stmt, NULL, &rc))\n \t    {\n \t      if (logger)\n \t\t{\n \t\t  logger->log (\"rejecting due to region model\");\n \t\t  model.dump_to_pp (logger->get_printer (), true, false);\n \t\t}\n \t      if (out)\n-\t\t*out = new feasibility_problem (edge_idx, model, *eedge,\n-\t\t\t\t\t\tlast_stmt);\n+\t\t*out = new feasibility_problem (edge_idx, *eedge,\n+\t\t\t\t\t\tlast_stmt, rc);\n+\t      else\n+\t\tdelete rc;\n \t      return false;\n \t    }\n \t}\n@@ -3399,6 +3402,22 @@ exploded_path::dump () const\n   dump (stderr);\n }\n \n+/* class feasibility_problem.  */\n+\n+void\n+feasibility_problem::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"edge from EN: %i to EN: %i\",\n+\t     m_eedge.m_src->m_index, m_eedge.m_dest->m_index);\n+  if (m_rc)\n+    {\n+      pp_string (pp, \"; rejected constraint: \");\n+      m_rc->dump_to_pp (pp);\n+      pp_string (pp, \"; rmodel: \");\n+      m_rc->m_model.dump_to_pp (pp, true, false);\n+    }\n+}\n+\n /* A family of cluster subclasses for use when generating .dot output for\n    exploded graphs (-fdump-analyzer-exploded-graph), for grouping the\n    enodes into hierarchical boxes."}, {"sha": "a6ca4b9a99d2e5c8d31fce7a2039af34b264afa8", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -880,17 +880,20 @@ class feasibility_problem\n {\n public:\n   feasibility_problem (unsigned eedge_idx,\n-\t\t       const region_model &model,\n \t\t       const exploded_edge &eedge,\n-\t\t       const gimple *last_stmt)\n-  : m_eedge_idx (eedge_idx), m_model (model), m_eedge (eedge),\n-    m_last_stmt (last_stmt)\n+\t\t       const gimple *last_stmt,\n+\t\t       rejected_constraint *rc)\n+  : m_eedge_idx (eedge_idx), m_eedge (eedge),\n+    m_last_stmt (last_stmt), m_rc (rc)\n   {}\n+  ~feasibility_problem () { delete m_rc; }\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n \n   unsigned m_eedge_idx;\n-  region_model m_model;\n   const exploded_edge &m_eedge;\n   const gimple *m_last_stmt;\n+  rejected_constraint *m_rc;\n };\n \n /* Finding the shortest exploded_path within an exploded_graph.  */"}, {"sha": "0aadd73a272d444d21404f49bec58118a31df2b7", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -199,8 +199,12 @@ function_point::get_location () const\n   const gimple *stmt = get_stmt ();\n   if (stmt)\n     return stmt->location;\n-\n-  return UNKNOWN_LOCATION;\n+  if (m_kind == PK_BEFORE_SUPERNODE)\n+    return m_supernode->get_start_location ();\n+  else if (m_kind == PK_AFTER_SUPERNODE)\n+    return m_supernode->get_end_location ();\n+  else\n+    return UNKNOWN_LOCATION;\n }\n \n /* Create a function_point representing the entrypoint of function FUN.  */"}, {"sha": "78b87d509e41e3ab22d8282dd729bc57ec2b7685", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -872,7 +872,7 @@ program_state::on_edge (exploded_graph &eg,\n \t\t\t\t  last_stmt);\n   if (!m_region_model->maybe_update_for_edge (*succ,\n \t\t\t\t\t      last_stmt,\n-\t\t\t\t\t      &ctxt))\n+\t\t\t\t\t      &ctxt, NULL))\n     {\n       logger * const logger = eg.get_logger ();\n       if (logger)"}, {"sha": "981fb779df21ba07acf40ef95f455208f8c91461", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 60, "deletions": 18, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -1810,6 +1810,20 @@ region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n   return true;\n }\n \n+/* As above, but when returning false, if OUT is non-NULL, write a\n+   new rejected_constraint to *OUT.  */\n+\n+bool\n+region_model::add_constraint (tree lhs, enum tree_code op, tree rhs,\n+\t\t\t      region_model_context *ctxt,\n+\t\t\t      rejected_constraint **out)\n+{\n+  bool sat = add_constraint (lhs, op, rhs, ctxt);\n+  if (!sat && out)\n+    *out = new rejected_constraint (*this, lhs, op, rhs);\n+  return sat;\n+}\n+\n /* Subroutine of region_model::add_constraint for handling optimized\n    && and || conditionals.\n \n@@ -2188,6 +2202,8 @@ region_model::update_for_phis (const supernode *snode,\n /* Attempt to update this model for taking EDGE (where the last statement\n    was LAST_STMT), returning true if the edge can be taken, false\n    otherwise.\n+   When returning false, if OUT is non-NULL, write a new rejected_constraint\n+   to it.\n \n    For CFG superedges where LAST_STMT is a conditional or a switch\n    statement, attempt to add the relevant conditions for EDGE to this\n@@ -2207,7 +2223,8 @@ region_model::update_for_phis (const supernode *snode,\n bool\n region_model::maybe_update_for_edge (const superedge &edge,\n \t\t\t\t     const gimple *last_stmt,\n-\t\t\t\t     region_model_context *ctxt)\n+\t\t\t\t     region_model_context *ctxt,\n+\t\t\t\t     rejected_constraint **out)\n {\n   /* Handle frame updates for interprocedural edges.  */\n   switch (edge.m_kind)\n@@ -2247,20 +2264,21 @@ region_model::maybe_update_for_edge (const superedge &edge,\n   if (const gcond *cond_stmt = dyn_cast <const gcond *> (last_stmt))\n     {\n       const cfg_superedge *cfg_sedge = as_a <const cfg_superedge *> (&edge);\n-      return apply_constraints_for_gcond (*cfg_sedge, cond_stmt, ctxt);\n+      return apply_constraints_for_gcond (*cfg_sedge, cond_stmt, ctxt, out);\n     }\n \n   if (const gswitch *switch_stmt = dyn_cast <const gswitch *> (last_stmt))\n     {\n       const switch_cfg_superedge *switch_sedge\n \t= as_a <const switch_cfg_superedge *> (&edge);\n-      return apply_constraints_for_gswitch (*switch_sedge, switch_stmt, ctxt);\n+      return apply_constraints_for_gswitch (*switch_sedge, switch_stmt,\n+\t\t\t\t\t    ctxt, out);\n     }\n \n   /* Apply any constraints due to an exception being thrown.  */\n   if (const cfg_superedge *cfg_sedge = dyn_cast <const cfg_superedge *> (&edge))\n     if (cfg_sedge->get_flags () & EDGE_EH)\n-      return apply_constraints_for_exception (last_stmt, ctxt);\n+      return apply_constraints_for_exception (last_stmt, ctxt, out);\n \n   return true;\n }\n@@ -2338,12 +2356,15 @@ region_model::update_for_call_summary (const callgraph_superedge &cg_sedge,\n    If they are feasible, add the constraints and return true.\n \n    Return false if the constraints contradict existing knowledge\n-   (and so the edge should not be taken).  */\n+   (and so the edge should not be taken).\n+   When returning false, if OUT is non-NULL, write a new rejected_constraint\n+   to it.  */\n \n bool\n region_model::apply_constraints_for_gcond (const cfg_superedge &sedge,\n \t\t\t\t\t   const gcond *cond_stmt,\n-\t\t\t\t\t   region_model_context *ctxt)\n+\t\t\t\t\t   region_model_context *ctxt,\n+\t\t\t\t\t   rejected_constraint **out)\n {\n   ::edge cfg_edge = sedge.get_cfg_edge ();\n   gcc_assert (cfg_edge != NULL);\n@@ -2354,7 +2375,7 @@ region_model::apply_constraints_for_gcond (const cfg_superedge &sedge,\n   tree rhs = gimple_cond_rhs (cond_stmt);\n   if (cfg_edge->flags & EDGE_FALSE_VALUE)\n     op = invert_tree_comparison (op, false /* honor_nans */);\n-  return add_constraint (lhs, op, rhs, ctxt);\n+  return add_constraint (lhs, op, rhs, ctxt, out);\n }\n \n /* Given an EDGE guarded by SWITCH_STMT, determine appropriate constraints\n@@ -2363,12 +2384,15 @@ region_model::apply_constraints_for_gcond (const cfg_superedge &sedge,\n    If they are feasible, add the constraints and return true.\n \n    Return false if the constraints contradict existing knowledge\n-   (and so the edge should not be taken).  */\n+   (and so the edge should not be taken).\n+   When returning false, if OUT is non-NULL, write a new rejected_constraint\n+   to it.  */\n \n bool\n region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n \t\t\t\t\t     const gswitch *switch_stmt,\n-\t\t\t\t\t     region_model_context *ctxt)\n+\t\t\t\t\t     region_model_context *ctxt,\n+\t\t\t\t\t     rejected_constraint **out)\n {\n   tree index  = gimple_switch_index (switch_stmt);\n   tree case_label = edge.get_case_label ();\n@@ -2380,13 +2404,13 @@ region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n       if (upper_bound)\n \t{\n \t  /* Range.  */\n-\t  if (!add_constraint (index, GE_EXPR, lower_bound, ctxt))\n+\t  if (!add_constraint (index, GE_EXPR, lower_bound, ctxt, out))\n \t    return false;\n-\t  return add_constraint (index, LE_EXPR, upper_bound, ctxt);\n+\t  return add_constraint (index, LE_EXPR, upper_bound, ctxt, out);\n \t}\n       else\n \t/* Single-value.  */\n-\treturn add_constraint (index, EQ_EXPR, lower_bound, ctxt);\n+\treturn add_constraint (index, EQ_EXPR, lower_bound, ctxt, out);\n     }\n   else\n     {\n@@ -2406,14 +2430,16 @@ region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n \t      /* Exclude this range-valued case.\n \t\t For now, we just exclude the boundary values.\n \t\t TODO: exclude the values within the region.  */\n-\t      if (!add_constraint (index, NE_EXPR, other_lower_bound, ctxt))\n+\t      if (!add_constraint (index, NE_EXPR, other_lower_bound,\n+\t\t\t\t   ctxt, out))\n \t\treturn false;\n-\t      if (!add_constraint (index, NE_EXPR, other_upper_bound, ctxt))\n+\t      if (!add_constraint (index, NE_EXPR, other_upper_bound,\n+\t\t\t\t   ctxt, out))\n \t\treturn false;\n \t    }\n \t  else\n \t    /* Exclude this single-valued case.  */\n-\t    if (!add_constraint (index, NE_EXPR, other_lower_bound, ctxt))\n+\t    if (!add_constraint (index, NE_EXPR, other_lower_bound, ctxt, out))\n \t      return false;\n \t}\n       return true;\n@@ -2425,11 +2451,14 @@ region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n    If they are feasible, add the constraints and return true.\n \n    Return false if the constraints contradict existing knowledge\n-   (and so the edge should not be taken).  */\n+   (and so the edge should not be taken).\n+   When returning false, if OUT is non-NULL, write a new rejected_constraint\n+   to it.  */\n \n bool\n region_model::apply_constraints_for_exception (const gimple *last_stmt,\n-\t\t\t\t\t       region_model_context *ctxt)\n+\t\t\t\t\t       region_model_context *ctxt,\n+\t\t\t\t\t       rejected_constraint **out)\n {\n   gcc_assert (last_stmt);\n   if (const gcall *call = dyn_cast <const gcall *> (last_stmt))\n@@ -2442,7 +2471,7 @@ region_model::apply_constraints_for_exception (const gimple *last_stmt,\n \t     leak report due to the result being lost when following\n \t     the EH edge.  */\n \t  if (tree lhs = gimple_call_lhs (call))\n-\t    return add_constraint (lhs, EQ_EXPR, null_pointer_node, ctxt);\n+\t    return add_constraint (lhs, EQ_EXPR, null_pointer_node, ctxt, out);\n \t  return true;\n \t}\n   return true;\n@@ -2862,6 +2891,19 @@ debug (const region_model &rmodel)\n   rmodel.dump (false);\n }\n \n+/* struct rejected_constraint.  */\n+\n+void\n+rejected_constraint::dump_to_pp (pretty_printer *pp) const\n+{\n+  region_model m (m_model);\n+  const svalue *lhs_sval = m.get_rvalue (m_lhs, NULL);\n+  const svalue *rhs_sval = m.get_rvalue (m_rhs, NULL);\n+  lhs_sval->dump_to_pp (pp, true);\n+  pp_printf (pp, \" %s \", op_symbol_code (m_op));\n+  rhs_sval->dump_to_pp (pp, true);\n+}\n+\n /* class engine.  */\n \n /* Dump the managed objects by class to LOGGER, and the per-class totals.  */"}, {"sha": "a61aff2c4b38a2f72f1eb12718b05053672e3a1a", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -2586,7 +2586,8 @@ class region_model\n \n   bool maybe_update_for_edge (const superedge &edge,\n \t\t\t      const gimple *last_stmt,\n-\t\t\t      region_model_context *ctxt);\n+\t\t\t      region_model_context *ctxt,\n+\t\t\t      rejected_constraint **out);\n \n   const region *push_frame (function *fun, const vec<const svalue *> *arg_sids,\n \t\t\t    region_model_context *ctxt);\n@@ -2630,6 +2631,9 @@ class region_model\n \t\t\t   region_model_context *ctxt);\n   bool add_constraint (tree lhs, enum tree_code op, tree rhs,\n \t\t       region_model_context *ctxt);\n+  bool add_constraint (tree lhs, enum tree_code op, tree rhs,\n+\t\t       region_model_context *ctxt,\n+\t\t       rejected_constraint **out);\n \n   const region *create_region_for_heap_alloc (const svalue *size_in_bytes);\n   const region *create_region_for_alloca (const svalue *size_in_bytes);\n@@ -2699,12 +2703,15 @@ class region_model\n \t\t\t\tregion_model_context *ctxt);\n   bool apply_constraints_for_gcond (const cfg_superedge &edge,\n \t\t\t\t    const gcond *cond_stmt,\n-\t\t\t\t    region_model_context *ctxt);\n+\t\t\t\t    region_model_context *ctxt,\n+\t\t\t\t    rejected_constraint **out);\n   bool apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n \t\t\t\t      const gswitch *switch_stmt,\n-\t\t\t\t      region_model_context *ctxt);\n+\t\t\t\t      region_model_context *ctxt,\n+\t\t\t\t      rejected_constraint **out);\n   bool apply_constraints_for_exception (const gimple *last_stmt,\n-\t\t\t\t\tregion_model_context *ctxt);\n+\t\t\t\t\tregion_model_context *ctxt,\n+\t\t\t\t\trejected_constraint **out);\n \n   int poison_any_pointers_to_descendents (const region *reg,\n \t\t\t\t\t  enum poison_kind pkind);\n@@ -2851,6 +2858,24 @@ struct model_merger\n   region_model *m_merged_model;\n };\n \n+/* A record that can (optionally) be written out when\n+   region_model::add_constraint fails.  */\n+\n+struct rejected_constraint\n+{\n+  rejected_constraint (const region_model &model,\n+\t\t     tree lhs, enum tree_code op, tree rhs)\n+  : m_model (model), m_lhs (lhs), m_op (op), m_rhs (rhs)\n+  {}\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+\n+  region_model m_model;\n+  tree m_lhs;\n+  enum tree_code m_op;\n+  tree m_rhs;\n+};\n+\n /* A bundle of state.  */\n \n class engine"}, {"sha": "96fe9bb1a06f345b2635e0dcb09b5f7f390fddaa", "filename": "gcc/doc/analyzer.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -329,7 +329,8 @@ we only emit the simplest path (which could be intraprocedural, if\n it can be reproduced without a caller).  We apply a check that\n each duplicate warning's shortest path is feasible, rejecting any\n warnings for which the shortest path is infeasible (which could lead to\n-false negatives).\n+false negatives).  This check can be suppressed (for debugging purposes)\n+using @option{-fno-analyzer-feasibility}.\n \n We use the shortest feasible @code{exploded_path} through the\n @code{exploded_graph} (a list of @code{exploded_edge *}) to build a"}, {"sha": "75203ba2420137e3071690cee7bfab5245851fe6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -393,6 +393,7 @@ Objective-C and Objective-C++ Dialects}.\n -fanalyzer @gol\n -fanalyzer-call-summaries @gol\n -fanalyzer-checker=@var{name} @gol\n+-fno-analyzer-feasibility @gol\n -fanalyzer-fine-grained @gol\n -fanalyzer-state-merge @gol\n -fanalyzer-state-purge @gol\n@@ -8993,6 +8994,17 @@ such as the @code{taint} checker that implements\n @option{-Wanalyzer-tainted-array-index}, and this option is required\n to enable them.\n \n+@item -fno-analyzer-feasibility\n+@opindex fanalyzer-feasibility\n+@opindex fno-analyzer-feasibility\n+This option is intended for analyzer developers.\n+\n+By default the analyzer verifies that there is a feasible control flow path\n+for each diagnostic it emits: that the conditions that hold are not mutually\n+exclusive.  Diagnostics for which no feasible path can be found are rejected.\n+This filtering can be suppressed with @option{-fno-analyzer-feasibility}, for\n+debugging issues in this code.\n+\n @item -fanalyzer-fine-grained\n @opindex fanalyzer-fine-grained\n @opindex fno-analyzer-fine-grained"}, {"sha": "9fe62d22cc263c77687afabc113d8bbbdda43a81", "filename": "gcc/testsuite/gcc.dg/analyzer/feasibility-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb35466654ec179fa16e718a5014fbe9f41357/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-2.c?ref=84fb35466654ec179fa16e718a5014fbe9f41357", "patch": "@@ -0,0 +1,20 @@\n+/* Verify that -fno-analyzer-feasibility works.  */\n+/* { dg-additional-options \"-fno-analyzer-feasibility\" } */\n+\n+#include \"analyzer-decls.h\"\n+\n+void test_1 (int flag)\n+{\n+  int a;\n+  if (flag)\n+    a = 1;\n+  else\n+    a = 2;\n+\n+  if (a == 1) /* (can only be the case when \"flag\" was true above).  */\n+    if (!flag)\n+      {\n+\t__analyzer_dump_path (); /* { dg-message \"note: path\" \"path diag\" } */\n+\t/* { dg-message \"infeasible\" \"infeasibility event\" { target *-*-* } .-1 } */\n+      }\n+}"}]}