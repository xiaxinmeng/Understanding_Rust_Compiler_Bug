{"sha": "e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg4MTc3NGQwZGRhNmQ1MTI3ZWI4ZjA2NDJmNmVkYzE2ZGMwYjFlNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-02T11:38:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-02T14:58:14Z"}, "message": "Rewrite SLP induction vectorization\n\nThis rewrites SLP induction vectorization to handle different\ninductions in the different SLP lanes.  It also changes SLP\nbuild to represent the initial value (but not the cycle) so\nit can be enhanced to handle outer loop vectorization later.\n\nNote this FAILs gcc.dg/vect/costmodel/x86_64/costmodel-pr30843.c\nbecause it removes one CSE optimization that no longer works\nwith non-uniform initial value and step.  I'll see to recover\nfrom this after outer loop vectorization of inductions works.\n\nIt might be a bit friendlier to variable-size vectors now\nbut then we're now building the step vector from scalars ...\n\n2020-11-02  Richard Biener  <rguenther@suse.de>\n\n\t* tree.h (build_real_from_wide): Declare.\n\t* tree.c (build_real_from_wide): New function.\n\t* tree-vect-slp.c (vect_build_slp_tree_2): Remove\n\trestriction on induction vectorization, represent\n\tthe initial value.\n\t* tree-vect-loop.c (vect_model_induction_cost): Inline ...\n\t(vectorizable_induction): ... here.  Rewrite SLP\n\tcode generation.\n\n\t* gcc.dg/vect/slp-49.c: New testcase.", "tree": {"sha": "246429551c79f231c1b41f6cf035e478fdc00452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/246429551c79f231c1b41f6cf035e478fdc00452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86deadf8d3ac55b3cd07e15d4e83e3b6ccd9ee81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86deadf8d3ac55b3cd07e15d4e83e3b6ccd9ee81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86deadf8d3ac55b3cd07e15d4e83e3b6ccd9ee81"}], "stats": {"total": 369, "additions": 222, "deletions": 147}, "files": [{"sha": "3f53baf707be8cfc75a92a782923d1a85d00d912", "filename": "gcc/testsuite/gcc.dg/vect/slp-49.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-49.c?ref=e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int a[1024];\n+\n+void __attribute__((noipa))\n+foo(int k)\n+{\n+  int j = 5;\n+  for (int i = 0; i < 512; ++i)\n+    {\n+      a[2*i] = j;\n+      a[2*i+1] = k;\n+      j++;\n+      k+=3;\n+    }\n+}\n+\n+int\n+main()\n+{\n+  check_vect ();\n+\n+  foo (17);\n+\n+  for (int i = 0; i < 512; ++i)\n+    {\n+      if (a[2*i] != 5 + i\n+\t  || a[2*i+1] != 17 + 3 * i)\n+\t__builtin_abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" } } */"}, {"sha": "fcea28935bc6d0daac8f03ed0f82b04a41798f00", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 161, "deletions": 135, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "patch": "@@ -4443,34 +4443,6 @@ vect_model_reduction_cost (loop_vec_info loop_vinfo,\n }\n \n \n-/* Function vect_model_induction_cost.\n-\n-   Models cost for induction operations.  */\n-\n-static void\n-vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies,\n-\t\t\t   stmt_vector_for_cost *cost_vec)\n-{\n-  unsigned inside_cost, prologue_cost;\n-\n-  if (PURE_SLP_STMT (stmt_info))\n-    return;\n-\n-  /* loop cost for vec_loop.  */\n-  inside_cost = record_stmt_cost (cost_vec, ncopies, vector_stmt,\n-\t\t\t\t  stmt_info, 0, vect_body);\n-\n-  /* prologue cost for vec_init and vec_step.  */\n-  prologue_cost = record_stmt_cost (cost_vec, 2, scalar_to_vec,\n-\t\t\t\t    stmt_info, 0, vect_prologue);\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"vect_model_induction_cost: inside_cost = %d, \"\n-                     \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n-}\n-\n-\n \n /* Function get_initial_def_for_reduction\n \n@@ -7796,7 +7768,7 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \n   if (slp_node && !nunits.is_constant ())\n     {\n-      /* The current SLP code creates the initial value element-by-element.  */\n+      /* The current SLP code creates the step value element-by-element.  */\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"SLP induction not supported for variable-length\"\n@@ -7806,9 +7778,46 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      unsigned inside_cost = 0, prologue_cost = 0;\n+      if (slp_node)\n+\t{\n+\t  /* We eventually need to set a vector type on invariant\n+\t     arguments.  */\n+\t  unsigned j;\n+\t  slp_tree child;\n+\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (slp_node), j, child)\n+\t    if (!vect_maybe_update_slp_op_vectype\n+\t\t(child, SLP_TREE_VECTYPE (slp_node)))\n+\t      {\n+\t\tif (dump_enabled_p ())\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"incompatible vector types for \"\n+\t\t\t\t   \"invariants\\n\");\n+\t\treturn false;\n+\t      }\n+\t  /* loop cost for vec_loop.  */\n+\t  inside_cost\n+\t    = record_stmt_cost (cost_vec,\n+\t\t\t\tSLP_TREE_NUMBER_OF_VEC_STMTS (slp_node),\n+\t\t\t\tvector_stmt, stmt_info, 0, vect_body);\n+\t}\n+      else /* if (!slp_node) */\n+\t{\n+\t  /* loop cost for vec_loop.  */\n+\t  inside_cost = record_stmt_cost (cost_vec, ncopies, vector_stmt,\n+\t\t\t\t\t  stmt_info, 0, vect_body);\n+\t  /* prologue cost for vec_init and vec_step.  */\n+\t  prologue_cost = record_stmt_cost (cost_vec, 2, scalar_to_vec,\n+\t\t\t\t\t    stmt_info, 0, vect_prologue);\n+\t}\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"vect_model_induction_cost: inside_cost = %d, \"\n+\t\t\t \"prologue_cost = %d .\\n\", inside_cost,\n+\t\t\t prologue_cost);\n+\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n       DUMP_VECT_SCOPE (\"vectorizable_induction\");\n-      vect_model_induction_cost (stmt_info, ncopies, cost_vec);\n       return true;\n     }\n \n@@ -7827,164 +7836,148 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n   tree step_vectype = get_same_sized_vectype (TREE_TYPE (step_expr), vectype);\n \n   pe = loop_preheader_edge (iv_loop);\n-  init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n-\t\t\t\t     loop_preheader_edge (iv_loop));\n-\n-  stmts = NULL;\n-  if (!nested_in_vect_loop)\n-    {\n-      /* Convert the initial value to the IV update type.  */\n-      tree new_type = TREE_TYPE (step_expr);\n-      init_expr = gimple_convert (&stmts, new_type, init_expr);\n-\n-      /* If we are using the loop mask to \"peel\" for alignment then we need\n-\t to adjust the start value here.  */\n-      tree skip_niters = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n-      if (skip_niters != NULL_TREE)\n-\t{\n-\t  if (FLOAT_TYPE_P (vectype))\n-\t    skip_niters = gimple_build (&stmts, FLOAT_EXPR, new_type,\n-\t\t\t\t\tskip_niters);\n-\t  else\n-\t    skip_niters = gimple_convert (&stmts, new_type, skip_niters);\n-\t  tree skip_step = gimple_build (&stmts, MULT_EXPR, new_type,\n-\t\t\t\t\t skip_niters, step_expr);\n-\t  init_expr = gimple_build (&stmts, MINUS_EXPR, new_type,\n-\t\t\t\t    init_expr, skip_step);\n-\t}\n-    }\n-\n-  if (stmts)\n-    {\n-      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n-    }\n-\n   /* Find the first insertion point in the BB.  */\n   basic_block bb = gimple_bb (phi);\n   si = gsi_after_labels (bb);\n \n   /* For SLP induction we have to generate several IVs as for example\n-     with group size 3 we need [i, i, i, i + S] [i + S, i + S, i + 2*S, i + 2*S]\n-     [i + 2*S, i + 3*S, i + 3*S, i + 3*S].  The step is the same uniform\n-     [VF*S, VF*S, VF*S, VF*S] for all.  */\n+     with group size 3 we need\n+       [i0, i1, i2, i0 + S0] [i1 + S1, i2 + S2, i0 + 2*S0, i1 + 2*S1]\n+       [i2 + 2*S2, i0 + 3*S0, i1 + 3*S1, i2 + 3*S2].  */\n   if (slp_node)\n     {\n       /* Enforced above.  */\n       unsigned int const_nunits = nunits.to_constant ();\n \n-      /* Generate [VF*S, VF*S, ... ].  */\n-      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n-\t{\n-\t  expr = build_int_cst (integer_type_node, vf);\n-\t  expr = fold_convert (TREE_TYPE (step_expr), expr);\n-\t}\n-      else\n-\texpr = build_int_cst (TREE_TYPE (step_expr), vf);\n-      new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n-\t\t\t      expr, step_expr);\n-      if (! CONSTANT_CLASS_P (new_name))\n-\tnew_name = vect_init_vector (loop_vinfo, stmt_info, new_name,\n-\t\t\t\t     TREE_TYPE (step_expr), NULL);\n-      new_vec = build_vector_from_val (step_vectype, new_name);\n-      vec_step = vect_init_vector (loop_vinfo, stmt_info,\n-\t\t\t\t   new_vec, step_vectype, NULL);\n+      /* The initial values are vectorized, but any lanes > group_size\n+\t need adjustment.  */\n+      slp_tree init_node\n+\t= SLP_TREE_CHILDREN (slp_node)[pe->dest_idx];\n \n-      /* Now generate the IVs.  */\n+      /* Gather steps.  Since we do not vectorize inductions as\n+\t cycles we have to reconstruct the step from SCEV data.  */\n       unsigned group_size = SLP_TREE_LANES (slp_node);\n+      tree *steps = XALLOCAVEC (tree, group_size);\n+      stmt_vec_info phi_info;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, phi_info)\n+\tsteps[i] = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (phi_info);\n+\n+      /* Now generate the IVs.  */\n       unsigned nvects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-      unsigned elts = const_nunits * nvects;\n-      /* Compute the number of distinct IVs we need.  First reduce\n-\t group_size if it is a multiple of const_nunits so we get\n-\t one IV for a group_size of 4 but const_nunits 2.  */\n-      unsigned group_sizep = group_size;\n-      if (group_sizep % const_nunits == 0)\n-\tgroup_sizep = group_sizep / const_nunits;\n-      unsigned nivs = least_common_multiple (group_sizep,\n+      gcc_assert ((const_nunits * nvects) % group_size == 0);\n+      unsigned nivs = least_common_multiple (group_size,\n \t\t\t\t\t     const_nunits) / const_nunits;\n-      gcc_assert (elts % group_size == 0);\n-      tree elt = init_expr;\n+      unsigned lup_mul = (nvects * const_nunits) / group_size;\n+      tree stept = TREE_TYPE (step_vectype);\n+      tree lupdate_mul\n+\t= build_vector_from_val (step_vectype,\n+\t\t\t\t SCALAR_FLOAT_TYPE_P (stept)\n+\t\t\t\t ? build_real_from_wide (stept, lup_mul,\n+\t\t\t\t\t\t\t UNSIGNED)\n+\t\t\t\t : build_int_cstu (stept, lup_mul));\n       unsigned ivn;\n+      auto_vec<tree> vec_steps;\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n \t  tree_vector_builder elts (step_vectype, const_nunits, 1);\n-\t  stmts = NULL;\n+\t  tree_vector_builder mul_elts (step_vectype, const_nunits, 1);\n \t  for (unsigned eltn = 0; eltn < const_nunits; ++eltn)\n \t    {\n-\t      if (ivn*const_nunits + eltn >= group_size\n-\t\t  && (ivn * const_nunits + eltn) % group_size == 0)\n-\t\telt = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (elt),\n-\t\t\t\t    elt, step_expr);\n+\t      tree elt = steps[(ivn*const_nunits + eltn) % group_size];\n \t      elts.quick_push (elt);\n+\t      unsigned mul_elt = (ivn*const_nunits + eltn) / group_size;\n+\t      mul_elts.quick_push (SCALAR_FLOAT_TYPE_P (stept)\n+\t\t\t\t   ? build_real_from_wide (stept,\n+\t\t\t\t\t\t\t   mul_elt, UNSIGNED)\n+\t\t\t\t   : build_int_cstu (stept, mul_elt));\n \t    }\n-\t  vec_init = gimple_build_vector (&stmts, &elts);\n-\t  vec_init = gimple_convert (&stmts, vectype, vec_init);\n+\t  stmts = NULL;\n+\t  vec_step = gimple_build_vector (&stmts, &elts);\n+\t  vec_step = gimple_convert (&stmts, step_vectype, vec_step);\n+\t  vec_steps.safe_push (vec_step);\n+\t  tree step_mul = gimple_build_vector (&stmts, &mul_elts);\n \t  if (stmts)\n \t    {\n \t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n \t      gcc_assert (!new_bb);\n \t    }\n \n \t  /* Create the induction-phi that defines the induction-operand.  */\n-\t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n+\t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var,\n+\t\t\t\t\t    \"vec_iv_\");\n \t  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n \t  induc_def = PHI_RESULT (induction_phi);\n \n \t  /* Create the iv update inside the loop  */\n-\t  gimple_seq stmts = NULL;\n+\t  stmts = NULL;\n+\t  tree up = gimple_build (&stmts, MULT_EXPR, step_vectype,\n+\t\t\t\t  vec_step, lupdate_mul);\n+\t  if (stmts)\n+\t    {\n+\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t      gcc_assert (!new_bb);\n+\t    }\n+\t  stmts = NULL;\n \t  vec_def = gimple_convert (&stmts, step_vectype, induc_def);\n \t  vec_def = gimple_build (&stmts,\n-\t\t\t\t  PLUS_EXPR, step_vectype, vec_def, vec_step);\n+\t\t\t\t  PLUS_EXPR, step_vectype, vec_def, up);\n \t  vec_def = gimple_convert (&stmts, vectype, vec_def);\n \t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n+\t  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n+\t\t       UNKNOWN_LOCATION);\n+\n+\t  vec_init = vect_get_slp_vect_def (init_node, ivn);\n+\t  if (!integer_zerop (step_mul))\n+\t    {\n+\t      stmts = NULL;\n+\t      vec_def = gimple_convert (&stmts, step_vectype, vec_init);\n+\t      up = gimple_build (&stmts, MULT_EXPR, step_vectype,\n+\t\t\t\t vec_step, step_mul);\n+\t      vec_def = gimple_build (&stmts, PLUS_EXPR, step_vectype,\n+\t\t\t\t      vec_def, up);\n+\t      vec_init = gimple_convert (&stmts, vectype, vec_def);\n+\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t      gcc_assert (!new_bb);\n+\t    }\n \n \t  /* Set the arguments of the phi node:  */\n \t  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n-\t  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n-\t\t       UNKNOWN_LOCATION);\n \n \t  SLP_TREE_VEC_STMTS (slp_node).quick_push (induction_phi);\n \t}\n-      /* Fill up to the number of vectors we need for the whole group.  */\n-      nivs = least_common_multiple (group_size,\n-\t\t\t\t    const_nunits) / const_nunits;\n-      for (; ivn < nivs; ++ivn)\n-\tSLP_TREE_VEC_STMTS (slp_node)\n-\t  .quick_push (SLP_TREE_VEC_STMTS (slp_node)[0]);\n \n-      /* Re-use IVs when we can.  */\n+      /* Re-use IVs when we can.  We are generating further vector\n+\t stmts by adding VF' * stride to the IVs generated above.  */\n       if (ivn < nvects)\n \t{\n \t  unsigned vfp\n \t    = least_common_multiple (group_size, const_nunits) / group_size;\n-\t  /* Generate [VF'*S, VF'*S, ... ].  */\n-\t  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n-\t    {\n-\t      expr = build_int_cst (integer_type_node, vfp);\n-\t      expr = fold_convert (TREE_TYPE (step_expr), expr);\n-\t    }\n-\t  else\n-\t    expr = build_int_cst (TREE_TYPE (step_expr), vfp);\n-\t  new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n-\t\t\t\t  expr, step_expr);\n-\t  if (! CONSTANT_CLASS_P (new_name))\n-\t    new_name = vect_init_vector (loop_vinfo, stmt_info, new_name,\n-\t\t\t\t\t TREE_TYPE (step_expr), NULL);\n-\t  new_vec = build_vector_from_val (step_vectype, new_name);\n-\t  vec_step = vect_init_vector (loop_vinfo, stmt_info, new_vec,\n-\t\t\t\t       step_vectype, NULL);\n+\t  tree lupdate_mul\n+\t    = build_vector_from_val (step_vectype,\n+\t\t\t\t     SCALAR_FLOAT_TYPE_P (stept)\n+\t\t\t\t     ? build_real_from_wide (stept,\n+\t\t\t\t\t\t\t     vfp, UNSIGNED)\n+\t\t\t\t     : build_int_cstu (stept, vfp));\n \t  for (; ivn < nvects; ++ivn)\n \t    {\n \t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs];\n-\t      tree def;\n-\t      if (gimple_code (iv) == GIMPLE_PHI)\n-\t\tdef = gimple_phi_result (iv);\n-\t      else\n-\t\tdef = gimple_assign_lhs (iv);\n+\t      tree def = gimple_get_lhs (iv);\n \t      gimple_seq stmts = NULL;\n+\t      if (ivn < 2*nivs)\n+\t\t{\n+\t\t  vec_steps[ivn - nivs]\n+\t\t    = gimple_build (&stmts, MULT_EXPR, step_vectype,\n+\t\t\t\t    vec_steps[ivn - nivs], lupdate_mul);\n+\t\t  if (stmts)\n+\t\t    {\n+\t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t\t      gcc_assert (!new_bb);\n+\t\t    }\n+\t\t}\n+\t      stmts = NULL;\n \t      def = gimple_convert (&stmts, step_vectype, def);\n-\t      def = gimple_build (&stmts,\n-\t\t\t\t  PLUS_EXPR, step_vectype, def, vec_step);\n+\t      def = gimple_build (&stmts, PLUS_EXPR, step_vectype,\n+\t\t\t\t  def, vec_steps[ivn % nivs]);\n \t      def = gimple_convert (&stmts, vectype, def);\n \t      if (gimple_code (iv) == GIMPLE_PHI)\n \t\tgsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n@@ -8001,6 +7994,39 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n       return true;\n     }\n \n+  init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n+\t\t\t\t     loop_preheader_edge (iv_loop));\n+\n+  stmts = NULL;\n+  if (!nested_in_vect_loop)\n+    {\n+      /* Convert the initial value to the IV update type.  */\n+      tree new_type = TREE_TYPE (step_expr);\n+      init_expr = gimple_convert (&stmts, new_type, init_expr);\n+\n+      /* If we are using the loop mask to \"peel\" for alignment then we need\n+\t to adjust the start value here.  */\n+      tree skip_niters = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n+      if (skip_niters != NULL_TREE)\n+\t{\n+\t  if (FLOAT_TYPE_P (vectype))\n+\t    skip_niters = gimple_build (&stmts, FLOAT_EXPR, new_type,\n+\t\t\t\t\tskip_niters);\n+\t  else\n+\t    skip_niters = gimple_convert (&stmts, new_type, skip_niters);\n+\t  tree skip_step = gimple_build (&stmts, MULT_EXPR, new_type,\n+\t\t\t\t\t skip_niters, step_expr);\n+\t  init_expr = gimple_build (&stmts, MINUS_EXPR, new_type,\n+\t\t\t\t    init_expr, skip_step);\n+\t}\n+    }\n+\n+  if (stmts)\n+    {\n+      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+      gcc_assert (!new_bb);\n+    }\n+\n   /* Create the vector that holds the initial_value of the induction.  */\n   if (nested_in_vect_loop)\n     {"}, {"sha": "63a59c0c8ed388f24d782048fa0187283403ba59", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "patch": "@@ -1441,20 +1441,14 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t  return NULL;\n \n \tvect_def_type def_type = STMT_VINFO_DEF_TYPE (stmt_info);\n-\t/* Induction from different IVs is not supported.  */\n \tif (def_type == vect_induction_def)\n \t  {\n-\t    stmt_vec_info other_info;\n-\t    FOR_EACH_VEC_ELT (stmts, i, other_info)\n-\t      if (stmt_info != other_info)\n-\t\treturn NULL;\n-\n-\t    /* Induction PHIs are leafs.  */\n-\t    (*tree_size)++;\n-\t    node = vect_create_new_slp_node (node, stmts, nops);\n-\t    SLP_TREE_VECTYPE (node) = vectype;\n-\t    SLP_TREE_CHILDREN (node).quick_grow_cleared (nops);\n-\t    return node;\n+\t    /* Induction PHIs are not cycles but walk the initial\n+\t       value.  */\n+\t    class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\t    if (nested_in_vect_loop_p (loop, stmt_info))\n+\t      loop = loop->inner;\n+\t    skip_args[loop_latch_edge (loop)->dest_idx] = true;\n \t  }\n \telse if (def_type == vect_reduction_def\n \t\t || def_type == vect_double_reduction_def"}, {"sha": "739c288378aff8af128562eb47ed48f6e4e7264e", "filename": "gcc/tree.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "patch": "@@ -2250,6 +2250,22 @@ build_real_from_int_cst (tree type, const_tree i)\n   return v;\n }\n \n+/* Return a new REAL_CST node whose type is TYPE\n+   and whose value is the integer value I which has sign SGN.  */\n+\n+tree\n+build_real_from_wide (tree type, const wide_int_ref &i, signop sgn)\n+{\n+  REAL_VALUE_TYPE d;\n+\n+  /* Clear all bits of the real value type so that we can later do\n+     bitwise comparisons to see if two values are the same.  */\n+  memset (&d, 0, sizeof d);\n+\n+  real_from_integer (&d, TYPE_MODE (type), i, sgn);\n+  return build_real (type, d);\n+}\n+\n /* Return a newly constructed STRING_CST node whose value is the LEN\n    characters at STR when STR is nonnull, or all zeros otherwise.\n    Note that for a C string literal, LEN should include the trailing NUL."}, {"sha": "04e564c979898f1c5141ec3255b74afafa4e5e36", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e881774d0dda6d5127eb8f0642f6edc16dc0b1e7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e881774d0dda6d5127eb8f0642f6edc16dc0b1e7", "patch": "@@ -4429,6 +4429,7 @@ extern tree build_constructor_from_vec (tree, const vec<tree, va_gc> *);\n extern tree build_constructor_va (tree, int, ...);\n extern tree build_clobber (tree);\n extern tree build_real_from_int_cst (tree, const_tree);\n+extern tree build_real_from_wide (tree, const wide_int_ref &, signop);\n extern tree build_complex (tree, tree, tree);\n extern tree build_complex_inf (tree, bool);\n extern tree build_each_one_cst (tree);"}]}