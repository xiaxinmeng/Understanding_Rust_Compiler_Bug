{"sha": "f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkZDdmOTg4M2IxYzFiODcwN2E5YTJlZjQ3ZjJjMWE5M2FiMTQxZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-17T01:38:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-17T01:38:15Z"}, "message": "flow.c (propagate_block): Replace code that computes and uses regs_sometimes_live with simpler code that...\n\n        * flow.c (propagate_block): Replace code that computes and uses\n        regs_sometimes_live with simpler code that just walks the set of\n        currently live registers.\n\nFrom-SVN: r23148", "tree": {"sha": "a35462fddc989356efe72938f1947c653a458399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a35462fddc989356efe72938f1947c653a458399"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d/comments", "author": null, "committer": null, "parents": [{"sha": "0a578fee772469fe17168079f48b5b1a37b30522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a578fee772469fe17168079f48b5b1a37b30522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a578fee772469fe17168079f48b5b1a37b30522"}], "stats": {"total": 73, "additions": 19, "deletions": 54}, "files": [{"sha": "fe6d68238155589de1b52d3e322919bff965744b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d", "patch": "@@ -1,5 +1,9 @@\n Sat Oct 17 02:26:03 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de> \n \n+\t* flow.c (propagate_block): Replace code that computes and uses\n+\tregs_sometimes_live with simpler code that just walks the set of\n+\tcurrently live registers.\n+\n \t* Makefile.in (insn-extract.o): Fix dependencies.\n \t* genextract.c (main): Generate includes for insn-config.h and\n \trecog.h."}, {"sha": "10f9c07344d1ee8c0cc99984d128af0bdbc930d6", "filename": "gcc/flow.c", "status": "modified", "additions": 15, "deletions": 54, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f8dd7f9883b1c1b8707a9a2ef47f2c1a93ab141d", "patch": "@@ -1704,16 +1704,6 @@ propagate_block (old, first, last, final, significant, bnum)\n   regset live;\n   regset dead;\n \n-  /* The following variables are used only if FINAL is nonzero.  */\n-  /* This vector gets one element for each reg that has been live\n-     at any point in the basic block that has been scanned so far.\n-     SOMETIMES_MAX says how many elements are in use so far.  */\n-  register int *regs_sometimes_live;\n-  int sometimes_max = 0;\n-  /* This regset has 1 for each reg that we have seen live so far.\n-     It and REGS_SOMETIMES_LIVE are updated together.  */\n-  regset maxlive;\n-\n   /* The loop depth may change in the middle of a basic block.  Since we\n      scan from end to beginning, we start with the depth at the end of the\n      current basic block, and adjust as we pass ends and starts of loops.  */\n@@ -1743,18 +1733,12 @@ propagate_block (old, first, last, final, significant, bnum)\n       register int i;\n \n       num_scratch = 0;\n-      maxlive = ALLOCA_REG_SET ();\n-      COPY_REG_SET (maxlive, old);\n-      regs_sometimes_live = (int *) alloca (max_regno * sizeof (int));\n \n       /* Process the regs live at the end of the block.\n-\t Enter them in MAXLIVE and REGS_SOMETIMES_LIVE.\n-\t Also mark them as not local to any one basic block. */\n+\t Mark them as not local to any one basic block. */\n       EXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n \t\t\t\t {\n \t\t\t\t   REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n-\t\t\t\t   regs_sometimes_live[sometimes_max] = i;\n-\t\t\t\t   sometimes_max++;\n \t\t\t\t });\n     }\n \n@@ -1888,6 +1872,16 @@ propagate_block (old, first, last, final, significant, bnum)\n \t    ;\n \t  else\n \t    {\n+\t      /* Any regs live at the time of a call instruction\n+\t\t must not go in a register clobbered by calls.\n+\t\t Find all regs now live and record this for them.  */\n+\n+\t      if (GET_CODE (insn) == CALL_INSN && final)\n+\t\tEXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n+\t\t\t\t\t   {\n+\t\t\t\t\t     REG_N_CALLS_CROSSED (i)++;\n+\t\t\t\t\t   });\n+\n \t      /* LIVE gets the regs used in INSN;\n \t\t DEAD gets those set by it.  Dead insns don't make anything\n \t\t live.  */\n@@ -1952,44 +1946,13 @@ propagate_block (old, first, last, final, significant, bnum)\n \t      AND_COMPL_REG_SET (old, dead);\n \t      IOR_REG_SET (old, live);\n \n-\t      if (GET_CODE (insn) == CALL_INSN && final)\n-\t\t{\n-\t\t  /* Any regs live at the time of a call instruction\n-\t\t     must not go in a register clobbered by calls.\n-\t\t     Find all regs now live and record this for them.  */\n-\n-\t\t  register int *p = regs_sometimes_live;\n-\n-\t\t  for (i = 0; i < sometimes_max; i++, p++)\n-\t\t    if (REGNO_REG_SET_P (old, *p))\n-\t\t      REG_N_CALLS_CROSSED (*p)++;\n-\t\t}\n \t    }\n \n-\t  /* On final pass, add any additional sometimes-live regs\n-\t     into MAXLIVE and REGS_SOMETIMES_LIVE.\n-\t     Also update counts of how many insns each reg is live at.  */\n-\n+\t  /* On final pass, update counts of how many insns each reg is live\n+\t     at.  */\n \t  if (final)\n-\t    {\n-\t      register int regno;\n-\t      register int *p;\n-\n-\t      EXECUTE_IF_AND_COMPL_IN_REG_SET\n-\t\t(live, maxlive, 0, regno,\n-\t\t {\n-\t\t   regs_sometimes_live[sometimes_max++] = regno;\n-\t\t   SET_REGNO_REG_SET (maxlive, regno);\n-\t\t });\n-\n-\t      p = regs_sometimes_live;\n-\t      for (i = 0; i < sometimes_max; i++)\n-\t\t{\n-\t\t  regno = *p++;\n-\t\t  if (REGNO_REG_SET_P (old, regno))\n-\t\t    REG_LIVE_LENGTH (regno)++;\n-\t\t}\n-\t    }\n+\t    EXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n+\t\t\t\t       { REG_LIVE_LENGTH (i)++; });\n \t}\n     flushed: ;\n       if (insn == first)\n@@ -1998,8 +1961,6 @@ propagate_block (old, first, last, final, significant, bnum)\n \n   FREE_REG_SET (dead);\n   FREE_REG_SET (live);\n-  if (final)\n-    FREE_REG_SET (maxlive);\n \n   if (num_scratch > max_scratch)\n     max_scratch = num_scratch;"}]}