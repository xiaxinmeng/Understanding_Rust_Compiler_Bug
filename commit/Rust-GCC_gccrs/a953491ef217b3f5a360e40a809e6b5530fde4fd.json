{"sha": "a953491ef217b3f5a360e40a809e6b5530fde4fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk1MzQ5MWVmMjE3YjNmNWEzNjBlNDBhODA5ZTZiNTUzMGZkZTRmZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-04T17:44:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-04T17:44:09Z"}, "message": "lra-constraints.c (valid_address_p): Move earlier in file.\n\ngcc/\n\t* lra-constraints.c (valid_address_p): Move earlier in file.\n\t(address_eliminator): New structure.\n\t(satisfies_memory_constraint_p): New function.\n\t(satisfies_address_constraint_p): Likewise.\n\t(process_alt_operands, process_address, curr_insn_transform): Use them.\n\nFrom-SVN: r211242", "tree": {"sha": "ada1ddb59758df7083bed7959e9c36510920eaa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ada1ddb59758df7083bed7959e9c36510920eaa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a953491ef217b3f5a360e40a809e6b5530fde4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a953491ef217b3f5a360e40a809e6b5530fde4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a953491ef217b3f5a360e40a809e6b5530fde4fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a953491ef217b3f5a360e40a809e6b5530fde4fd/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c3317563e01d865568dd8baa2986e0f4fa122a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3317563e01d865568dd8baa2986e0f4fa122a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c3317563e01d865568dd8baa2986e0f4fa122a8"}], "stats": {"total": 183, "additions": 125, "deletions": 58}, "files": [{"sha": "03c381f4e3aad11f319dbea24bb225ce15bd2781", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a953491ef217b3f5a360e40a809e6b5530fde4fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a953491ef217b3f5a360e40a809e6b5530fde4fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a953491ef217b3f5a360e40a809e6b5530fde4fd", "patch": "@@ -1,3 +1,11 @@\n+2014-06-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lra-constraints.c (valid_address_p): Move earlier in file.\n+\t(address_eliminator): New structure.\n+\t(satisfies_memory_constraint_p): New function.\n+\t(satisfies_address_constraint_p): Likewise.\n+\t(process_alt_operands, process_address, curr_insn_transform): Use them.\n+\n 2014-06-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* lra-int.h (lra_static_insn_data): Make operand_alternative a"}, {"sha": "cafbc898c664f8adbf0d17fb004a9cd420696b64", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 117, "deletions": 58, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a953491ef217b3f5a360e40a809e6b5530fde4fd/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a953491ef217b3f5a360e40a809e6b5530fde4fd/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=a953491ef217b3f5a360e40a809e6b5530fde4fd", "patch": "@@ -317,6 +317,118 @@ in_mem_p (int regno)\n   return get_reg_class (regno) == NO_REGS;\n }\n \n+/* Return 1 if ADDR is a valid memory address for mode MODE in address\n+   space AS, and check that each pseudo has the proper kind of hard\n+   reg.\t */\n+static int\n+valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t rtx addr, addr_space_t as)\n+{\n+#ifdef GO_IF_LEGITIMATE_ADDRESS\n+  lra_assert (ADDR_SPACE_GENERIC_P (as));\n+  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n+  return 0;\n+\n+ win:\n+  return 1;\n+#else\n+  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n+#endif\n+}\n+\n+namespace {\n+  /* Temporarily eliminates registers in an address (for the lifetime of\n+     the object).  */\n+  class address_eliminator {\n+  public:\n+    address_eliminator (struct address_info *ad);\n+    ~address_eliminator ();\n+\n+  private:\n+    struct address_info *m_ad;\n+    rtx *m_base_loc;\n+    rtx m_base_reg;\n+    rtx *m_index_loc;\n+    rtx m_index_reg;\n+  };\n+}\n+\n+address_eliminator::address_eliminator (struct address_info *ad)\n+  : m_ad (ad),\n+    m_base_loc (strip_subreg (ad->base_term)),\n+    m_base_reg (NULL_RTX),\n+    m_index_loc (strip_subreg (ad->index_term)),\n+    m_index_reg (NULL_RTX)\n+{\n+  if (m_base_loc != NULL)\n+    {\n+      m_base_reg = *m_base_loc;\n+      lra_eliminate_reg_if_possible (m_base_loc);\n+      if (m_ad->base_term2 != NULL)\n+\t*m_ad->base_term2 = *m_ad->base_term;\n+    }\n+  if (m_index_loc != NULL)\n+    {\n+      m_index_reg = *m_index_loc;\n+      lra_eliminate_reg_if_possible (m_index_loc);\n+    }\n+}\n+\n+address_eliminator::~address_eliminator ()\n+{\n+  if (m_base_loc && *m_base_loc != m_base_reg)\n+    {\n+      *m_base_loc = m_base_reg;\n+      if (m_ad->base_term2 != NULL)\n+\t*m_ad->base_term2 = *m_ad->base_term;\n+    }\n+  if (m_index_loc && *m_index_loc != m_index_reg)\n+    *m_index_loc = m_index_reg;\n+}\n+\n+/* Return true if the eliminated form of AD is a legitimate target address.  */\n+static bool\n+valid_address_p (struct address_info *ad)\n+{\n+  address_eliminator eliminator (ad);\n+  return valid_address_p (ad->mode, *ad->outer, ad->as);\n+}\n+\n+#ifdef EXTRA_CONSTRAINT_STR\n+/* Return true if the eliminated form of memory reference OP satisfies\n+   extra memory constraint CONSTRAINT.  */\n+static bool\n+satisfies_memory_constraint_p (rtx op, const char *constraint)\n+{\n+  struct address_info ad;\n+\n+  decompose_mem_address (&ad, op);\n+  address_eliminator eliminator (&ad);\n+  return EXTRA_CONSTRAINT_STR (op, *constraint, constraint);\n+}\n+\n+/* Return true if the eliminated form of address AD satisfies extra\n+   address constraint CONSTRAINT.  */\n+static bool\n+satisfies_address_constraint_p (struct address_info *ad,\n+\t\t\t\tconst char *constraint)\n+{\n+  address_eliminator eliminator (ad);\n+  return EXTRA_CONSTRAINT_STR (*ad->outer, *constraint, constraint);\n+}\n+\n+/* Return true if the eliminated form of address OP satisfies extra\n+   address constraint CONSTRAINT.  */\n+static bool\n+satisfies_address_constraint_p (rtx op, const char *constraint)\n+{\n+  struct address_info ad;\n+\n+  decompose_lea_address (&ad, &op);\n+  return satisfies_address_constraint_p (&ad, constraint);\n+}\n+#endif\n+\n /* Initiate equivalences for LRA.  As we keep original equivalences\n    before any elimination, we need to make copies otherwise any change\n    in insns might change the equivalences.  */\n@@ -1938,7 +2050,8 @@ process_alt_operands (int only_alternative)\n #ifdef EXTRA_CONSTRAINT_STR\n \t\t      if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t\t{\n-\t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t\t  if (MEM_P (op)\n+\t\t\t      && satisfies_memory_constraint_p (op, p))\n \t\t\t    win = true;\n \t\t\t  else if (spilled_pseudo_p (op))\n \t\t\t    win = true;\n@@ -1957,7 +2070,7 @@ process_alt_operands (int only_alternative)\n \t\t\t}\n \t\t      if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t\t{\n-\t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t\t  if (satisfies_address_constraint_p (op, p))\n \t\t\t    win = true;\n \n \t\t\t  /* If we didn't already win, we can reload\n@@ -2573,60 +2686,6 @@ process_alt_operands (int only_alternative)\n   return ok_p;\n }\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE in address\n-   space AS, and check that each pseudo has the proper kind of hard\n-   reg.\t */\n-static int\n-valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t rtx addr, addr_space_t as)\n-{\n-#ifdef GO_IF_LEGITIMATE_ADDRESS\n-  lra_assert (ADDR_SPACE_GENERIC_P (as));\n-  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n-  return 0;\n-\n- win:\n-  return 1;\n-#else\n-  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n-#endif\n-}\n-\n-/* Return whether address AD is valid.  */\n-\n-static bool\n-valid_address_p (struct address_info *ad)\n-{\n-  /* Some ports do not check displacements for eliminable registers,\n-     so we replace them temporarily with the elimination target.  */\n-  rtx saved_base_reg = NULL_RTX;\n-  rtx saved_index_reg = NULL_RTX;\n-  rtx *base_term = strip_subreg (ad->base_term);\n-  rtx *index_term = strip_subreg (ad->index_term);\n-  if (base_term != NULL)\n-    {\n-      saved_base_reg = *base_term;\n-      lra_eliminate_reg_if_possible (base_term);\n-      if (ad->base_term2 != NULL)\n-\t*ad->base_term2 = *ad->base_term;\n-    }\n-  if (index_term != NULL)\n-    {\n-      saved_index_reg = *index_term;\n-      lra_eliminate_reg_if_possible (index_term);\n-    }\n-  bool ok_p = valid_address_p (ad->mode, *ad->outer, ad->as);\n-  if (saved_base_reg != NULL_RTX)\n-    {\n-      *base_term = saved_base_reg;\n-      if (ad->base_term2 != NULL)\n-\t*ad->base_term2 = *ad->base_term;\n-    }\n-  if (saved_index_reg != NULL_RTX)\n-    *index_term = saved_index_reg;\n-  return ok_p;\n-}\n-\n /* Make reload base reg + disp from address AD.  Return the new pseudo.  */\n static rtx\n base_plus_disp_to_reg (struct address_info *ad)\n@@ -2834,7 +2893,7 @@ process_address_1 (int nop, rtx *before, rtx *after)\n      EXTRA_CONSTRAINT_STR for the validation.  */\n   if (constraint[0] != 'p'\n       && EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint)\n-      && EXTRA_CONSTRAINT_STR (op, constraint[0], constraint))\n+      && satisfies_address_constraint_p (&ad, constraint))\n     return change_p;\n #endif\n \n@@ -3553,7 +3612,7 @@ curr_insn_transform (void)\n \t\t  break;\n #ifdef EXTRA_CONSTRAINT_STR\n \t\tif (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n-\t\t    && EXTRA_CONSTRAINT_STR (tem, c, constraint))\n+\t\t    && satisfies_memory_constraint_p (tem, constraint))\n \t\t  break;\n #endif\n \t      }"}]}