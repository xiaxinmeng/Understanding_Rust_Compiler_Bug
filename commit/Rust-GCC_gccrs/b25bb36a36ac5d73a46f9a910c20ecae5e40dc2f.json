{"sha": "b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1YmIzNmEzNmFjNWQ3M2E0NmY5YTkxMGMyMGVjYWU1ZTQwZGMyZg==", "commit": {"author": {"name": "Danny Smith", "email": "dannysmith@users.sourceforge.net", "date": "2002-06-11T05:25:44Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2002-06-11T05:25:44Z"}, "message": "gthr-win32.h: Wrap all functions in extern \"C\".\n\n\t* gthr-win32.h: Wrap all functions in extern \"C\".\n\t(__gthread_key_t): Typedef as unsigned long,\n\tnot win32 DWORD.\n\t(__GTHREAD_ONCE_INIT): Use 0, not win32 FALSE.\n\t(__gthread_mutex_t): Typedef as void*, not win32 HANDLE.\n\t(__gthr_win32_once, __gthr_win32_key_create,\n\t__gthr_win32_key_delete, __gthr_win32_getspecific,\n\t__gthr_win32_setspecific, __gthr_win32_mutex_init_function,\n\t__gthr_win32_mutex_lock,__gthr_win32_mutex_trylock,\n\t__gthr_win32_mutex_unlock): Declare.\n\t(__gthread_once,__gthread_key_create,\n\t__gthread_key_delete, __gthread_getspecific,\n\t__gthread_setspecific, __gthread_mutex_init_function,\n\t__gthread_mutex_lock,__gthread_mutex_trylock,\n\t__gthread_mutex_unlock): Call corresponding\n\t__gthr_win32_* extern implementations if #defined\n\t__GTHREAD_HIDE_WIN32API.\n\t* config/i386/t-mingw32 (LIB2FUNCS_EXTRA): Set to\n\t$(srcdir)/config/i386/gthr-win32.c\n\t* config/i386/gthr-win32.c: New implementation file.\n\t(__gthr_win32_once, __gthr_win32_key_create,\n\t__gthr_win32_key_delete, __gthr_win32_getspecific,\n\t__gthr_win32_setspecific, __gthr_win32_mutex_init_function,\n\t__gthr_win32_mutex_lock,__gthr_win32_mutex_trylock,\n\t__gthr_win32_mutex_unlock): New functions, based on\n\tstatic inlines in gthr-win32.h.\n\nFrom-SVN: r54484", "tree": {"sha": "f6283ed4f74366bef33687bff46a7119233f9661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6283ed4f74366bef33687bff46a7119233f9661"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/comments", "author": null, "committer": null, "parents": [{"sha": "a69c385e7318af362c94b35283c833ff8dca03e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a69c385e7318af362c94b35283c833ff8dca03e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a69c385e7318af362c94b35283c833ff8dca03e1"}], "stats": {"total": 328, "additions": 314, "deletions": 14}, "files": [{"sha": "3ebc3c81f6ab41c3214d44a42ddf5aec58716856", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "patch": "@@ -1,3 +1,32 @@\n+2002-06-11  Danny Smith  <dannysmith@users.sourforge.net>\n+\n+\t* gthr-win32.h: Wrap functions in extern \"C\".\n+\t(__gthread_key_t): Typedef as unsigned long,\n+\tnot win32 DWORD.\n+\t(__GTHREAD_ONCE_INIT): Use 0, not win32 FALSE.\n+\t(__gthread_mutex_t): Typedef as void*, not win32 HANDLE.\n+\t(__gthr_win32_once, __gthr_win32_key_create,\n+\t__gthr_win32_key_delete, __gthr_win32_getspecific,\n+\t__gthr_win32_setspecific, __gthr_win32_mutex_init_function,\n+\t__gthr_win32_mutex_lock,__gthr_win32_mutex_trylock,\n+\t__gthr_win32_mutex_unlock): Declare.\n+\t(__gthread_once,__gthread_key_create,\n+\t__gthread_key_delete, __gthread_getspecific,\n+\t__gthread_setspecific, __gthread_mutex_init_function,\n+\t__gthread_mutex_lock,__gthread_mutex_trylock,\n+\t__gthread_mutex_unlock): Call corresponding\n+\t__gthr_win32_* extern implementations if #defined\n+\t__GTHREAD_HIDE_WIN32API.\n+\t* config/i386/t-mingw32 (LIB2FUNCS_EXTRA): Set to\n+\t$(srcdir)/config/i386/gthr-win32.c \n+\t* config/i386/gthr-win32.c: New implementation file.\n+\t(__gthr_win32_once, __gthr_win32_key_create,\n+\t__gthr_win32_key_delete, __gthr_win32_getspecific,\n+\t__gthr_win32_setspecific, __gthr_win32_mutex_init_function,\n+\t__gthr_win32_mutex_lock,__gthr_win32_mutex_trylock,\n+\t__gthr_win32_mutex_unlock): New functions, based on\n+\tstatic inlines in gthr-win32.h.\n+\n 2002-06-10  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (override_options): Don't warn about"}, {"sha": "06dc2045d245bcdca9755b585946a9690e2b4d98", "filename": "gcc/config/i386/gthr-win32.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgthr-win32.c?ref=b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "patch": "@@ -0,0 +1,174 @@\n+/* Implementation of W32-specific threads compatibility routines for\n+   libgcc2.   */ \n+\n+/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n+   Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n+   Modified and moved to separate file by Danny Smith\n+   <dannysmith@users.sourceforge.net>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\n+#ifndef __GTHREAD_HIDE_WIN32API\n+# define __GTHREAD_HIDE_WIN32API\n+#endif\n+#include <gthr-win32.h>\n+#include <windows.h>\n+\n+/* Windows32 threads specific definitions. The windows32 threading model\n+   does not map well into pthread-inspired gcc's threading model, and so \n+   there are caveats one needs to be aware of.\n+\n+   1. The destructor supplied to __gthread_key_create is ignored for\n+      generic x86-win32 ports. This will certainly cause memory leaks \n+      due to unreclaimed eh contexts (sizeof (eh_context) is at least \n+      24 bytes for x86 currently).\n+\n+      This memory leak may be significant for long-running applications\n+      that make heavy use of C++ EH.\n+\n+      However, Mingw runtime (version 0.3 or newer) provides a mechanism\n+      to emulate pthreads key dtors; the runtime provides a special DLL,\n+      linked in if -mthreads option is specified, that runs the dtors in\n+      the reverse order of registration when each thread exits. If\n+      -mthreads option is not given, a stub is linked in instead of the\n+      DLL, which results in memory leak. Other x86-win32 ports can use \n+      the same technique of course to avoid the leak.\n+\n+   2. The error codes returned are non-POSIX like, and cast into ints.\n+      This may cause incorrect error return due to truncation values on \n+      hw where sizeof (DWORD) > sizeof (int).\n+   \n+   3. We might consider using Critical Sections instead of Windows32 \n+      mutexes for better performance, but emulating __gthread_mutex_trylock \n+      interface becomes more complicated (Win9x does not support\n+      TryEnterCriticalSectioni, while NT does).\n+  \n+   The basic framework should work well enough. In the long term, GCC\n+   needs to use Structured Exception Handling on Windows32.  */\n+\n+int\n+__gthr_win32_once (__gthread_once_t *once, void (*func) (void))\n+{\n+  if (once == NULL || func == NULL)\n+    return EINVAL;\n+\n+  if (! once->done)\n+    {\n+      if (InterlockedIncrement (&(once->started)) == 0)\n+        {\n+\t  (*func) ();\n+\t  once->done = TRUE;\n+\t}\n+      else\n+\t{\n+\t  /* Another thread is currently executing the code, so wait for it \n+\t     to finish; yield the CPU in the meantime.  If performance \n+\t     does become an issue, the solution is to use an Event that \n+\t     we wait on here (and set above), but that implies a place to \n+\t     create the event before this routine is called.  */ \n+\t  while (! once->done)\n+\t    Sleep (0);\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Windows32 thread local keys don't support destructors; this leads to\n+   leaks, especially in threaded applications making extensive use of \n+   C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n+\n+int\n+__gthr_win32_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+{\n+  int status = 0;\n+  DWORD tls_index = TlsAlloc ();\n+  if (tls_index != 0xFFFFFFFF)\n+    {\n+      *key = tls_index;\n+#ifdef MINGW32_SUPPORTS_MT_EH\n+      /* Mingw runtime will run the dtors in reverse order for each thread\n+         when the thread exits.  */\n+      status = __mingwthr_key_dtor (*key, dtor);\n+#endif\n+    }\n+  else\n+    status = (int) GetLastError ();\n+  return status;\n+}\n+\n+int\n+__gthr_win32_key_delete (__gthread_key_t key)\n+{\n+  return (TlsFree (key) != 0) ? 0 : (int) GetLastError ();\n+}\n+\n+void *\n+__gthr_win32_getspecific (__gthread_key_t key)\n+{\n+  DWORD lasterror;\n+  void *ptr;\n+  lasterror = GetLastError();\n+  ptr = TlsGetValue(key);\n+  SetLastError( lasterror );\n+  return ptr;\n+}\n+\n+int\n+__gthr_win32_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return (TlsSetValue (key, (void*) ptr) != 0) ? 0 : (int) GetLastError ();\n+}\n+\n+void\n+__gthr_win32_mutex_init_function (__gthread_mutex_t *mutex)\n+{\n+  /* Create unnamed mutex with default security attr and no initial owner.  */ \n+  *mutex = CreateMutex (NULL, 0, NULL);\n+}\n+\n+int\n+__gthr_win32_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  if (WaitForSingleObject (*mutex, INFINITE) == WAIT_OBJECT_0)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+int\n+__gthr_win32_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  if (WaitForSingleObject (*mutex, 0) == WAIT_OBJECT_0)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+int\n+__gthr_win32_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+    return (ReleaseMutex (*mutex) != 0) ? 0 : 1;\n+}"}, {"sha": "28096f8c48d90dd820bdc32d75092b4ff82aa7ef", "filename": "gcc/config/i386/t-mingw32", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2Fconfig%2Fi386%2Ft-mingw32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2Fconfig%2Fi386%2Ft-mingw32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-mingw32?ref=b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "patch": "@@ -2,3 +2,6 @@\n # collect2 doesn't work for i386-mingw32* yet.\n #\n USE_COLLECT2=\n+\n+# We hide calls to w32api needed for w32 thread support here:\n+LIB2FUNCS_EXTRA = $(srcdir)/config/i386/gthr-win32.c"}, {"sha": "97f4f49ebb2d3844046ad7956db40a53b25f4e7a", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 108, "deletions": 14, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "patch": "@@ -328,37 +328,32 @@ __gthread_objc_condition_signal(objc_condition_t condition)\n \n #else /* _LIBOBJC */\n \n-#include <windows.h>\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n \n-typedef DWORD __gthread_key_t;\n+typedef unsigned long __gthread_key_t;\n \n typedef struct {\n   int done;\n   long started;\n } __gthread_once_t;\n \n-typedef HANDLE __gthread_mutex_t;\n+typedef void* __gthread_mutex_t;\n \n-#define __GTHREAD_ONCE_INIT {FALSE, -1}\n+#define __GTHREAD_ONCE_INIT {0, -1}\n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n #define __GTHREAD_MUTEX_INIT_DEFAULT 0\n \n #if __MINGW32_MAJOR_VERSION >= 1 || \\\n   (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n #define MINGW32_SUPPORTS_MT_EH 1\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-extern int __mingwthr_key_dtor (DWORD, void (*) (void *));\n-#ifdef __cplusplus\n-}\n-#endif\n-\n /* Mingw runtime >= v0.3 provides a magic variable that is set to non-zero\n    if -mthreads option was specified, or 0 otherwise. This is to get around\n    the lack of weak symbols in PE-COFF.  */\n extern int _CRT_MT;\n-#endif\n+extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));\n+#endif /* __MINGW32__ version */\n \n static inline int\n __gthread_active_p (void)\n@@ -370,6 +365,100 @@ __gthread_active_p (void)\n #endif\n }\n \n+#ifdef __GTHREAD_HIDE_WIN32API\n+\n+/* The implementations are in config/i386/gthr-win32.c in libgcc.a.\n+   Only stubs are exposed to avoid polluting the C++ namespace with\n+   windows api definitions.  */\n+\n+extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));\n+extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));\n+extern int __gthr_win32_key_delete (__gthread_key_t);\n+extern void * __gthr_win32_getspecific (__gthread_key_t);\n+extern int __gthr_win32_setspecific (__gthread_key_t, const void *);\n+extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);\n+extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);\n+extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);\n+extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);\n+\n+static inline int\n+__gthread_once (__gthread_once_t *once, void (*func) (void))\n+{\n+  if ( __gthread_active_p ())\n+    return __gthr_win32_once (once, func);\n+  else\n+    return -1;\t\n+}\n+\n+static inline int\n+__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+{\n+  return __gthr_win32_key_create (key, dtor);\n+}\n+\n+static inline int\n+__gthread_key_dtor (__gthread_key_t key, void *ptr)\n+{\n+  /* Nothing needed.  */\n+  return 0;\n+}\n+  \n+ static inline int\n+__gthread_key_delete (__gthread_key_t key)\n+{\n+   return __gthr_win32_key_delete (key);\n+}\n+\n+static inline void *\n+__gthread_getspecific (__gthread_key_t key)\n+{\n+  return __gthr_win32_getspecific (key);\n+}\n+\n+static inline int\n+__gthread_setspecific (__gthread_key_t key, const void *ptr)\n+{\n+  return __gthr_win32_setspecific (key, ptr);\n+}\n+\n+static inline void\n+__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+{\n+  __gthr_win32_mutex_init_function (mutex);\n+}\n+\n+static inline int\n+__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_mutex_lock (mutex);\n+  else\n+    return 0;\n+}\n+\n+static inline int\n+__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_mutex_trylock (mutex);\n+  else\n+    return 0;\t\n+}\n+\n+static inline int\n+__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_mutex_unlock (mutex);\n+  else\n+    return 0;\t\n+}\n+\n+#else /* ! __GTHREAD_HIDE_WIN32API */\n+\n+#include <windows.h>\n+#include <errno.h>\n+\n static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n@@ -504,7 +593,12 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+#endif /*  __GTHREAD_HIDE_WIN32API */\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n #endif /* _LIBOBJC */\n \n #endif /* ! GCC_GTHR_WIN32_H */\n-"}]}