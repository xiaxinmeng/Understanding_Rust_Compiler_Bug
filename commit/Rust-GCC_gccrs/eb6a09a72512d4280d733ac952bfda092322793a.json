{"sha": "eb6a09a72512d4280d733ac952bfda092322793a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2YTA5YTcyNTEyZDQyODBkNzMzYWM5NTJiZmRhMDkyMzIyNzkzYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-24T03:07:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-24T03:07:13Z"}, "message": "varpool.c (dump_varpool_node): Dump used_by_single_function.\n\n\n\t* varpool.c (dump_varpool_node): Dump used_by_single_function.\n\t* tree-pass.h (make_pass_ipa_single_use): New pass.\n\t* cgraph.h (used_by_single_function): New flag.\n\t* lto-cgraph.c (lto_output_varpool_node, input_varpool_node): Stream\n\tit.\n\t* passes.def (pass_ipa_single_use): Scedule.\n\t* ipa.c (BOTTOM): New macro.\n\t(meet): New function\n\t(propagate_single_user): New function.\n\t(ipa_single_use): New function.\n\t(pass_data_ipa_single_use): New pass.\n\t(pass_ipa_single_use): New pass.\n\t(pass_ipa_single_use::gate): New gate.\n\t(make_pass_ipa_single_use): New function.\n\nFrom-SVN: r211925", "tree": {"sha": "a51449e3f96f4e51de47700bc16b67cd2476d8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a51449e3f96f4e51de47700bc16b67cd2476d8ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb6a09a72512d4280d733ac952bfda092322793a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6a09a72512d4280d733ac952bfda092322793a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6a09a72512d4280d733ac952bfda092322793a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6a09a72512d4280d733ac952bfda092322793a/comments", "author": null, "committer": null, "parents": [{"sha": "d7dab049c733dce5c6bc35aae0194a0cef3aaa9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7dab049c733dce5c6bc35aae0194a0cef3aaa9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7dab049c733dce5c6bc35aae0194a0cef3aaa9f"}], "stats": {"total": 253, "additions": 253, "deletions": 0}, "files": [{"sha": "8854cd7a2b6f435e06d2456c6bdadcb37bcf3a3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -1,3 +1,20 @@\n+2014-06-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* varpool.c (dump_varpool_node): Dump used_by_single_function.\n+\t* tree-pass.h (make_pass_ipa_single_use): New pass.\n+\t* cgraph.h (used_by_single_function): New flag.\n+\t* lto-cgraph.c (lto_output_varpool_node, input_varpool_node): Stream\n+\tit.\n+\t* passes.def (pass_ipa_single_use): Scedule.\n+\t* ipa.c (BOTTOM): New macro.\n+\t(meet): New function\n+\t(propagate_single_user): New function.\n+\t(ipa_single_use): New function.\n+\t(pass_data_ipa_single_use): New pass.\n+\t(pass_ipa_single_use): New pass.\n+\t(pass_ipa_single_use::gate): New gate.\n+\t(make_pass_ipa_single_use): New function.\n+\n 2014-06-23  Kai Tietz  <ktietz@redhat.com>\n \n \tPR target/39284"}, {"sha": "ce6b9e64de82e9bc3920b9c80f7c1ad9bdc0fce2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -719,6 +719,12 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n   unsigned dynamically_initialized : 1;\n \n   ENUM_BITFIELD(tls_model) tls_model : 3;\n+\n+  /* Set if the variable is known to be used by single function only.\n+     This is computed by ipa_signle_use pass and used by late optimizations\n+     in places where optimization would be valid for local static variable\n+     if we did not do any inter-procedural code movement.  */\n+  unsigned used_by_single_function : 1;\n };\n \n /* Every top level asm statement is put into a asm_node.  */"}, {"sha": "33bf5104530456811a80da0bfa67e30ac6f209c6", "filename": "gcc/ipa.c", "status": "modified", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -1096,3 +1096,226 @@ make_pass_ipa_cdtor_merge (gcc::context *ctxt)\n {\n   return new pass_ipa_cdtor_merge (ctxt);\n }\n+\n+/* Invalid pointer representing BOTTOM for single user dataflow.  */\n+#define BOTTOM ((cgraph_node *)(size_t) 2)\n+\n+/* Meet operation for single user dataflow.\n+   Here we want to associate variables with sigle function that may access it.\n+\n+   FUNCTION is current single user of a variable, VAR is variable that uses it.\n+   Latttice is stored in SINGLE_USER_MAP.\n+\n+   We represent: \n+    - TOP by no entry in SIGNLE_USER_MAP\n+    - BOTTOM by BOTTOM in AUX pointer (to save lookups)\n+    - known single user by cgraph pointer in SINGLE_USER_MAP.  */\n+\n+cgraph_node *\n+meet (cgraph_node *function, varpool_node *var,\n+       pointer_map<cgraph_node *> &single_user_map)\n+{\n+  struct cgraph_node *user, **f;\n+\n+  if (var->aux == BOTTOM)\n+    return BOTTOM;\n+\n+  f = single_user_map.contains (var);\n+  if (!f)\n+    return function;\n+  user = *f;\n+  if (!function)\n+    return user;\n+  else if (function != user)\n+    return BOTTOM;\n+  else\n+    return function;\n+}\n+\n+/* Propagation step of single-use dataflow.\n+\n+   Check all uses of VNODE and see if they are used by single function FUNCTION.\n+   SINGLE_USER_MAP represents the dataflow lattice.  */\n+\n+cgraph_node *\n+propagate_single_user (varpool_node *vnode, cgraph_node *function,\n+\t\t       pointer_map<cgraph_node *> &single_user_map)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  gcc_assert (!vnode->externally_visible);\n+\n+  /* If node is an alias, first meet with its target.  */\n+  if (vnode->alias)\n+    function = meet (function, varpool_alias_target (vnode), single_user_map);\n+\n+  /* Check all users and see if they correspond to a single function.  */\n+  for (i = 0;\n+       ipa_ref_list_referring_iterate (&vnode->ref_list, i, ref)\n+       && function != BOTTOM; i++)\n+    {\n+      struct cgraph_node *cnode = dyn_cast <cgraph_node *> (ref->referring);\n+      if (cnode)\n+\t{\n+\t  if (cnode->global.inlined_to)\n+\t    cnode = cnode->global.inlined_to;\n+\t  if (!function)\n+\t    function = cnode;\n+\t  else if (function != cnode)\n+\t    function = BOTTOM;\n+\t}\n+      else\n+        function = meet (function, dyn_cast <varpool_node *> (ref->referring), single_user_map);\n+    }\n+  return function;\n+}\n+\n+/* Pass setting used_by_single_function flag.\n+   This flag is set on variable when there is only one function that may possibly\n+   referr to it.  */\n+\n+static unsigned int\n+ipa_single_use (void)\n+{\n+  varpool_node *first = (varpool_node *) (void *) 1;\n+  varpool_node *var;\n+  pointer_map<cgraph_node *> single_user_map;\n+\n+  FOR_EACH_DEFINED_VARIABLE (var)\n+    if (!varpool_all_refs_explicit_p (var))\n+      var->aux = BOTTOM;\n+    else\n+      {\n+\t/* Enqueue symbol for dataflow.  */\n+        var->aux = first;\n+\tfirst = var;\n+      }\n+\n+  /* The actual dataflow.  */\n+\n+  while (first != (void *) 1)\n+    {\n+      cgraph_node *user, *orig_user, **f;\n+\n+      var = first;\n+      first = (varpool_node *)first->aux;\n+\n+      f = single_user_map.contains (var);\n+      if (f)\n+\torig_user = *f;\n+      else\n+\torig_user = NULL;\n+      user = propagate_single_user (var, orig_user, single_user_map);\n+\n+      gcc_checking_assert (var->aux != BOTTOM);\n+\n+      /* If user differs, enqueue all references.  */\n+      if (user != orig_user)\n+\t{\n+\t  unsigned int i;\n+\t  ipa_ref *ref;\n+\n+\t  *single_user_map.insert (var) = user;\n+\n+\t  /* Enqueue all aliases for re-processing.  */\n+\t  for (i = 0;\n+\t       ipa_ref_list_referring_iterate (&var->ref_list, i, ref); i++)\n+\t    if (ref->use == IPA_REF_ALIAS\n+\t\t&& !ref->referring->aux)\n+\t      {\n+\t\tref->referring->aux = first;\n+\t\tfirst = dyn_cast <varpool_node *> (ref->referring);\n+\t      }\n+\t  /* Enqueue all users for re-processing.  */\n+\t  for (i = 0;\n+\t       ipa_ref_list_reference_iterate (&var->ref_list, i, ref); i++)\n+\t    if (!ref->referred->aux\n+\t        && ref->referred->definition\n+\t\t&& is_a <varpool_node *> (ref->referred))\n+\t      {\n+\t\tref->referred->aux = first;\n+\t\tfirst = dyn_cast <varpool_node *> (ref->referred);\n+\t      }\n+\n+\t  /* If user is BOTTOM, just punt on this var.  */\n+\t  if (user == BOTTOM)\n+\t    var->aux = BOTTOM;\n+\t  else\n+\t    var->aux = NULL;\n+\t}\n+      else\n+\tvar->aux = NULL;\n+    }\n+\n+  FOR_EACH_DEFINED_VARIABLE (var)\n+    {\n+      if (var->aux != BOTTOM)\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  if (!single_user_map.contains (var))\n+          gcc_assert (single_user_map.contains (var));\n+#endif\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Variable %s/%i is used by single function\\n\",\n+\t\t       var->name (), var->order);\n+\t    }\n+\t  var->used_by_single_function = true;\n+\t}\n+      var->aux = NULL;\n+    }\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_single_use =\n+{\n+  IPA_PASS, /* type */\n+  \"single-use\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_ipa_single_use : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_single_use (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_single_use, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *) { return ipa_single_use (); }\n+\n+}; // class pass_ipa_single_use\n+\n+bool\n+pass_ipa_single_use::gate (function *)\n+{\n+  return optimize;\n+}\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_single_use (gcc::context *ctxt)\n+{\n+  return new pass_ipa_single_use (ctxt);\n+}"}, {"sha": "ffc62473d1c48553a15248ffca99632358fe059e", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -614,6 +614,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n \t  /* in_other_partition.  */\n     }\n   bp_pack_value (&bp, node->tls_model, 3);\n+  bp_pack_value (&bp, node->used_by_single_function, 1);\n   streamer_write_bitpack (&bp);\n \n   group = node->get_comdat_group ();\n@@ -1275,6 +1276,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   if (node->alias && !node->analyzed && node->weakref)\n     node->alias_target = get_alias_symbol (node->decl);\n   node->tls_model = (enum tls_model)bp_unpack_value (&bp, 3);\n+  node->used_by_single_function = (enum tls_model)bp_unpack_value (&bp, 1);\n   group = read_identifier (ib);\n   if (group)\n     {"}, {"sha": "de4c69dde8136d7ad9313afb94b05fbd00da9be0", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -109,6 +109,8 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n   NEXT_PASS (pass_ipa_reference);\n+  /* This pass needs to be scheduled after any IP code duplication.   */\n+  NEXT_PASS (pass_ipa_single_use);\n   /* Comdat privatization come last, as direct references to comdat local\n      symbols are not allowed outside of the comdat group.  Privatizing early\n      would result in missed optimizations due to this restriction.  */"}, {"sha": "b3a9de2686a354148d58d2a61f72745a8fdb4abe", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -472,6 +472,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_tm (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_omp_simd_clone (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_profile (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cdtor_merge (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_single_use (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_comdats (gcc::context *ctxt);\n \n extern gimple_opt_pass *make_pass_cleanup_cfg_post_optimizing (gcc::context"}, {"sha": "580144e08993ef013fd392d38dcd8f93bcb083b9", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6a09a72512d4280d733ac952bfda092322793a/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=eb6a09a72512d4280d733ac952bfda092322793a", "patch": "@@ -211,6 +211,8 @@ dump_varpool_node (FILE *f, varpool_node *node)\n     fprintf (f, \" initialized\");\n   if (node->output)\n     fprintf (f, \" output\");\n+  if (node->used_by_single_function)\n+    fprintf (f, \" used-by-single-function\");\n   if (TREE_READONLY (node->decl))\n     fprintf (f, \" read-only\");\n   if (ctor_for_folding (node->decl) != error_mark_node)"}]}