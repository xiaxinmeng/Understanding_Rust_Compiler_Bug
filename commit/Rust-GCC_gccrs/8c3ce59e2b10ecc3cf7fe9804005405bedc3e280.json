{"sha": "8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzY2U1OWUyYjEwZWNjM2NmN2ZlOTgwNDAwNTQwNWJlZGMzZTI4MA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2019-04-30T03:00:59Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2019-04-30T03:00:59Z"}, "message": "re PR tree-optimization/90240 (ICE in try_improve_iv_set, at tree-ssa-loop-ivopts.c:6694)\n\n\tPR tree-optimization/90240\n\tRevert:\n\t2019-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>\n\n\tPR tree-optimization/90078\n\t* tree-ssa-loop-ivopts.c (comp_cost::operator +,-,+=,-+,/=,*=): Add\n\tchecks for infinite_cost overflow.\n\n\t* gcc/testsuite/g++.dg/tree-ssa/pr90078.C: New test.\n\nFrom-SVN: r270673", "tree": {"sha": "975cba07711e0530b593d2d2fd96957261cb3536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/975cba07711e0530b593d2d2fd96957261cb3536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/comments", "author": null, "committer": null, "parents": [{"sha": "0c0b2104b467f85b7dcdd97285fbfa22c08b70f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0b2104b467f85b7dcdd97285fbfa22c08b70f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0b2104b467f85b7dcdd97285fbfa22c08b70f8"}], "stats": {"total": 231, "additions": 19, "deletions": 212}, "files": [{"sha": "99c54020f405ce1e6046f9548fe2077aa10feca3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "patch": "@@ -1,3 +1,13 @@\n+2019-04-30  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90240\n+\tRevert:\n+\t2019-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90078\n+\t* tree-ssa-loop-ivopts.c (comp_cost::operator +,-,+=,-+,/=,*=): Add\n+\tchecks for infinite_cost overflow.\n+\n 2019-04-29  Jeff Law  <law@redhat.com>\n \n \t* passes.def: Move -Wrestrict pass after copy propagation."}, {"sha": "eb2599a5e2753e580323b7b69a00e958b082755f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "patch": "@@ -1,3 +1,12 @@\n+2019-04-30  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90240\n+\tRevert:\n+\t2019-04-23  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90078\n+\t* gcc/testsuite/g++.dg/tree-ssa/pr90078.C: New test.\n+\n 2019-04-29  Vladislav Ivanishin  <vlad@ispras.ru>\n \n         * gcc.dg/uninit-25-gimple.c: New test."}, {"sha": "e36f50e9d8aaed5e02634457fbb2fbbe8ea03e80", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr90078.C", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c0b2104b467f85b7dcdd97285fbfa22c08b70f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90078.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c0b2104b467f85b7dcdd97285fbfa22c08b70f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90078.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90078.C?ref=0c0b2104b467f85b7dcdd97285fbfa22c08b70f8", "patch": "@@ -1,199 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-std=c++14 -O2 -ftemplate-depth=1000000\" }\n-\n-template <class T, int Dim0, int Dim1, int Dim2> struct Tensor3;\n-template <class A, class T, int Dim0, int Dim1, int Dim2, char i, char j,\n-          char k>\n-struct Tensor3_Expr;\n-\n-template <class T, int Dim0, int Dim1, int Dim2, int Dim3> struct Tensor4;\n-template <class A, class T, int Dim0, int Dim1, int Dim2, int Dim3, char i,\n-          char j, char k, char l>\n-struct Tensor4_Expr;\n-\n-template <char i, int Dim> struct Index\n-{};\n-template <const int N> struct Number\n-{\n-  Number(){};\n-  operator int() const { return N; }\n-};\n-\n-template <class T, int Tensor_Dim0, int Tensor_Dim1, int Tensor_Dim2>\n-struct Tensor3\n-{\n-  T data[Tensor_Dim0][Tensor_Dim1][Tensor_Dim2];\n-\n-  T operator()(const int N1, const int N2, const int N3) const\n-  {\n-    return data[N1][N2][N3];\n-  }\n-\n-  template <char i, char j, char k, int Dim0, int Dim1, int Dim2>\n-  Tensor3_Expr<const Tensor3<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2>, T,\n-               Dim0, Dim1, Dim2, i, j, k>\n-  operator()(const Index<i, Dim0>, const Index<j, Dim1>,\n-             const Index<k, Dim2>) const\n-  {\n-    return Tensor3_Expr<const Tensor3<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2>,\n-                        T, Dim0, Dim1, Dim2, i, j, k>(*this);\n-  }\n-};\n-\n-template <class A, class T, int Dim0, int Dim1, int Dim2, char i, char j,\n-          char k>\n-struct Tensor3_Expr\n-{\n-  A iter;\n-\n-  Tensor3_Expr(const A &a) : iter(a) {}\n-  T operator()(const int N1, const int N2, const int N3) const\n-  {\n-    return iter(N1, N2, N3);\n-  }\n-};\n-\n-template <class A, class T, int Tensor_Dim0, int Tensor_Dim1, int Tensor_Dim2,\n-          int Dim0, int Dim1, int Dim2, char i, char j, char k>\n-struct Tensor3_Expr<Tensor3<A, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2>, T, Dim0,\n-                   Dim1, Dim2, i, j, k>\n-{\n-  Tensor3<A, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2> &iter;\n-\n-  Tensor3_Expr(Tensor3<A, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2> &a) : iter(a)\n-  {}\n-  T operator()(const int N1, const int N2, const int N3) const\n-  {\n-    return iter(N1, N2, N3);\n-  }\n-};\n-\n-template <class A, class B, class T, class U, int Dim0, int Dim1, int Dim23,\n-          int Dim4, int Dim5, char i, char j, char k, char l, char m>\n-struct Tensor3_times_Tensor3_21\n-{\n-  Tensor3_Expr<A, T, Dim0, Dim1, Dim23, i, j, k> iterA;\n-  Tensor3_Expr<B, U, Dim23, Dim4, Dim5, k, l, m> iterB;\n-\n-  template <int CurrentDim>\n-  T eval(const int N1, const int N2, const int N3, const int N4,\n-         const Number<CurrentDim> &) const\n-  {\n-    return iterA(N1, N2, CurrentDim - 1) * iterB(CurrentDim - 1, N3, N4)\n-           + eval(N1, N2, N3, N4, Number<CurrentDim - 1>());\n-  }\n-  T eval(const int N1, const int N2, const int N3, const int N4,\n-         const Number<1> &) const\n-  {\n-    return iterA(N1, N2, 0) * iterB(0, N3, N4);\n-  }\n-\n-  Tensor3_times_Tensor3_21(\n-    const Tensor3_Expr<A, T, Dim0, Dim1, Dim23, i, j, k> &a,\n-    const Tensor3_Expr<B, U, Dim23, Dim4, Dim5, k, l, m> &b)\n-      : iterA(a), iterB(b)\n-  {}\n-  T operator()(const int &N1, const int &N2, const int &N3,\n-               const int &N4) const\n-  {\n-    return eval(N1, N2, N3, N4, Number<Dim23>());\n-  }\n-};\n-\n-template <class A, class B, class T, class U, int Dim0, int Dim1, int Dim23,\n-          int Dim4, int Dim5, char i, char j, char k, char l, char m>\n-Tensor4_Expr<Tensor3_times_Tensor3_21<A, B, T, U, Dim0, Dim1, Dim23, Dim4,\n-                                      Dim5, i, j, k, l, m>,\n-             T, Dim0, Dim1, Dim4, Dim5, i, j, l, m>\n-operator*(const Tensor3_Expr<A, T, Dim0, Dim1, Dim23, i, j, k> &a,\n-          const Tensor3_Expr<B, U, Dim23, Dim4, Dim5, k, l, m> &b)\n-{\n-  using TensorExpr = Tensor3_times_Tensor3_21<A, B, T, U, Dim0, Dim1, Dim23,\n-                                              Dim4, Dim5, i, j, k, l, m>;\n-  return Tensor4_Expr<TensorExpr, T, Dim0, Dim1, Dim4, Dim5, i, j, l, m>(\n-    TensorExpr(a, b));\n-};\n-\n-template <class T, int Tensor_Dim0, int Tensor_Dim1, int Tensor_Dim2,\n-          int Tensor_Dim3>\n-struct Tensor4\n-{\n-  T data[Tensor_Dim0][Tensor_Dim1][Tensor_Dim2][Tensor_Dim3];\n-\n-  Tensor4() {}\n-  T &operator()(const int N1, const int N2, const int N3, const int N4)\n-  {\n-    return data[N1][N2][N3][N4];\n-  }\n-\n-  template <char i, char j, char k, char l, int Dim0, int Dim1, int Dim2,\n-            int Dim3>\n-  Tensor4_Expr<Tensor4<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2, Tensor_Dim3>,\n-               T, Dim0, Dim1, Dim2, Dim3, i, j, k, l>\n-  operator()(const Index<i, Dim0>, const Index<j, Dim1>, const Index<k, Dim2>,\n-             const Index<l, Dim3>)\n-  {\n-    return Tensor4_Expr<\n-      Tensor4<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2, Tensor_Dim3>, T, Dim0,\n-      Dim1, Dim2, Dim3, i, j, k, l>(*this);\n-  };\n-};\n-\n-template <class A, class T, int Dim0, int Dim1, int Dim2, int Dim3, char i,\n-          char j, char k, char l>\n-struct Tensor4_Expr\n-{\n-  A iter;\n-\n-  Tensor4_Expr(const A &a) : iter(a) {}\n-  T operator()(const int N1, const int N2, const int N3, const int N4) const\n-  {\n-    return iter(N1, N2, N3, N4);\n-  }\n-};\n-\n-template <class A, class T, int Dim0, int Dim1, int Dim2, int Dim3, char i,\n-          char j, char k, char l>\n-struct Tensor4_Expr<Tensor4<A, Dim0, Dim1, Dim2, Dim3>, T, Dim0, Dim1, Dim2,\n-                   Dim3, i, j, k, l>\n-{\n-  Tensor4<A, Dim0, Dim1, Dim2, Dim3> &iter;\n-\n-  Tensor4_Expr(Tensor4<A, Dim0, Dim1, Dim2, Dim3> &a) : iter(a) {}\n-  T operator()(const int N1, const int N2, const int N3, const int N4) const\n-  {\n-    return iter(N1, N2, N3, N4);\n-  }\n-\n-  template <class B, class U, int Dim1_0, int Dim1_1, int Dim1_2, int Dim1_3,\n-            char i_1, char j_1, char k_1, char l_1>\n-  auto &operator=(const Tensor4_Expr<B, U, Dim1_0, Dim1_1, Dim1_2, Dim1_3, i_1,\n-                                     j_1, k_1, l_1> &rhs)\n-  {\n-    for(int ii = 0; ii < Dim0; ++ii)\n-      for(int jj = 0; jj < Dim1; ++jj)\n-        for(int kk = 0; kk < Dim2; ++kk)\n-          for(int ll = 0; ll < Dim3; ++ll)\n-            {\n-              iter(ii, jj, kk, ll) = rhs(ii, jj, kk, ll);\n-            }\n-    return *this;\n-  }\n-};\n-\n-int main()\n-{\n-  Tensor3<float, 100, 100, 1000> t1;\n-  Tensor3<float, 1000, 100, 100> t2;\n-\n-  Index<'l', 100> l;\n-  Index<'m', 100> m;\n-  Index<'k', 1000> k;\n-  Index<'n', 100> n;\n-  Index<'o', 100> o;\n-\n-  Tensor4<float, 100, 100, 100, 100> res;\n-  res(l, m, n, o) = t1(l, m, k) * t2(k, n, o);\n-  return 0;\n-}\n-"}, {"sha": "a2b6b2b2312497333ea1c5c3999c0734b627cd4c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c3ce59e2b10ecc3cf7fe9804005405bedc3e280/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8c3ce59e2b10ecc3cf7fe9804005405bedc3e280", "patch": "@@ -243,9 +243,6 @@ operator+ (comp_cost cost1, comp_cost cost2)\n   if (cost1.infinite_cost_p () || cost2.infinite_cost_p ())\n     return infinite_cost;\n \n-  if (cost1.cost + cost2.cost >= infinite_cost.cost)\n-    return infinite_cost;\n-\n   cost1.cost += cost2.cost;\n   cost1.complexity += cost2.complexity;\n \n@@ -259,8 +256,6 @@ operator- (comp_cost cost1, comp_cost cost2)\n     return infinite_cost;\n \n   gcc_assert (!cost2.infinite_cost_p ());\n-  if (cost1.cost - cost2.cost >= infinite_cost.cost)\n-    return infinite_cost;\n \n   cost1.cost -= cost2.cost;\n   cost1.complexity -= cost2.complexity;\n@@ -281,8 +276,6 @@ comp_cost::operator+= (HOST_WIDE_INT c)\n   if (infinite_cost_p ())\n     return *this;\n \n-  if (this->cost + c >= infinite_cost.cost)\n-    return infinite_cost;\n   this->cost += c;\n \n   return *this;\n@@ -294,8 +287,6 @@ comp_cost::operator-= (HOST_WIDE_INT c)\n   if (infinite_cost_p ())\n     return *this;\n \n-  if (this->cost - c >= infinite_cost.cost)\n-    return infinite_cost;\n   this->cost -= c;\n \n   return *this;\n@@ -304,7 +295,6 @@ comp_cost::operator-= (HOST_WIDE_INT c)\n comp_cost\n comp_cost::operator/= (HOST_WIDE_INT c)\n {\n-  gcc_assert (c != 0);\n   if (infinite_cost_p ())\n     return *this;\n \n@@ -319,9 +309,6 @@ comp_cost::operator*= (HOST_WIDE_INT c)\n   if (infinite_cost_p ())\n     return *this;\n \n-  if (this->cost * c >= infinite_cost.cost)\n-    return infinite_cost;\n-\n   this->cost *= c;\n \n   return *this;"}]}