{"sha": "770ebe99fe48aca10f3553c4195deba1757d328a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwZWJlOTlmZTQ4YWNhMTBmMzU1M2M0MTk1ZGViYTE3NTdkMzI4YQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-03-20T17:13:16Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-03-20T17:13:16Z"}, "message": "This PR shows that we get the load/store_lanes logic wrong for arm big-endian.\n\nIt is tricky to get right. Aarch64 does it by adding the appropriate lane-swapping\noperations during expansion.\n\nI'd like to do the same on arm eventually, but we'd need to port and validate the VTBL-generating\ncode and add it to all the right places and I'm not comfortable enough doing it for GCC 8, but I am keen\nin getting the wrong-code fixed.\nAs I say in the PR, vectorisation on armeb is already severely restricted (we disable many patterns on BYTES_BIG_ENDIAN)\nand the load/store_lanes patterns really were not working properly at all, so disabling them is not\na radical approach.\n\nThe way to do that is to return false in ARRAY_MODE_SUPPORTED_P for BYTES_BIG_ENDIAN.\n\nBootstrapped and tested on arm-none-linux-gnueabihf.\nAlso tested on armeb-none-eabi.\n\n\n     PR target/82518\n     * config/arm/arm.c (arm_array_mode_supported_p): Return false for\n     BYTES_BIG_ENDIAN.\n\n     * lib/target-supports.exp (check_effective_target_vect_load_lanes):\n     Disable for armeb targets.\n     * gcc.target/arm/pr82518.c: New test.\n\nFrom-SVN: r258687", "tree": {"sha": "16f58159f03d1ab59f47648999b34f8d718cbae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16f58159f03d1ab59f47648999b34f8d718cbae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/770ebe99fe48aca10f3553c4195deba1757d328a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770ebe99fe48aca10f3553c4195deba1757d328a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770ebe99fe48aca10f3553c4195deba1757d328a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770ebe99fe48aca10f3553c4195deba1757d328a/comments", "author": null, "committer": null, "parents": [{"sha": "6f87580f7d0726d9683ca0f4a703a857f06f00d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f87580f7d0726d9683ca0f4a703a857f06f00d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f87580f7d0726d9683ca0f4a703a857f06f00d5"}], "stats": {"total": 37, "additions": 35, "deletions": 2}, "files": [{"sha": "cb6ab8191b3d7ce429629b80439e8020436045e4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770ebe99fe48aca10f3553c4195deba1757d328a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770ebe99fe48aca10f3553c4195deba1757d328a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=770ebe99fe48aca10f3553c4195deba1757d328a", "patch": "@@ -27162,7 +27162,10 @@ static bool\n arm_array_mode_supported_p (machine_mode mode,\n \t\t\t    unsigned HOST_WIDE_INT nelems)\n {\n-  if (TARGET_NEON\n+  /* We don't want to enable interleaved loads and stores for BYTES_BIG_ENDIAN\n+     for now, as the lane-swapping logic needs to be extended in the expanders.\n+     See PR target/82518.  */\n+  if (TARGET_NEON && !BYTES_BIG_ENDIAN\n       && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))\n       && (nelems >= 2 && nelems <= 4))\n     return true;"}, {"sha": "c3e45b86acb5ae05728c19cf799fd493faad33bc", "filename": "gcc/testsuite/gcc.target/arm/pr82518.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770ebe99fe48aca10f3553c4195deba1757d328a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr82518.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770ebe99fe48aca10f3553c4195deba1757d328a/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr82518.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr82518.c?ref=770ebe99fe48aca10f3553c4195deba1757d328a", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-additional-options \"-O3 -fno-inline -std=gnu99\" } */\n+/* { dg-add-options arm_neon } */\n+\n+typedef struct { int x, y; } X;\n+\n+void f4(X *p, int n)\n+{\n+  for (int i = 0; i < n; i++)\n+  { p[i].x = i;\n+    p[i].y = i + 1;\n+  }\n+}\n+\n+__attribute ((aligned (16))) X arr[100];\n+\n+int main(void)\n+{\n+  volatile int fail = 0;\n+  f4 (arr, 100);\n+  for (int i = 0; i < 100; i++)\n+    if (arr[i].y != i+1 || arr[i].x != i)\n+      fail = 1;\n+  if (fail)\n+     __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "55e726909d5eb8e5b0d129387265fe90c1eeec72", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770ebe99fe48aca10f3553c4195deba1757d328a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770ebe99fe48aca10f3553c4195deba1757d328a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=770ebe99fe48aca10f3553c4195deba1757d328a", "patch": "@@ -6611,7 +6611,8 @@ proc check_effective_target_vect_load_lanes { } {\n \tverbose \"check_effective_target_vect_load_lanes: using cached result\" 2\n     } else {\n \tset et_vect_load_lanes 0\n-\tif { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])\n+\t# We don't support load_lanes correctly on big-endian arm.\n+\tif { ([istarget arm-*-*] && [check_effective_target_arm_neon_ok])\n \t     || [istarget aarch64*-*-*] } {\n \t    set et_vect_load_lanes 1\n \t}"}]}