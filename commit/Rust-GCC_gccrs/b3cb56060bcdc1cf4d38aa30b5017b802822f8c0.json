{"sha": "b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjYjU2MDYwYmNkYzFjZjRkMzhhYTMwYjUwMTdiODAyODIyZjhjMA==", "commit": {"author": {"name": "GCC Administrator", "email": "gccadmin@gcc.gnu.org", "date": "2020-08-14T00:16:24Z"}, "committer": {"name": "GCC Administrator", "email": "gccadmin@gcc.gnu.org", "date": "2020-08-14T00:16:24Z"}, "message": "Daily bump.", "tree": {"sha": "c2625ac9079a1fdac94f150917a5de0397000498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2625ac9079a1fdac94f150917a5de0397000498"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/comments", "author": null, "committer": null, "parents": [{"sha": "2ec32ddf822887cddc8910ed30dc105890def4ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec32ddf822887cddc8910ed30dc105890def4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec32ddf822887cddc8910ed30dc105890def4ee"}], "stats": {"total": 1782, "additions": 1781, "deletions": 1}, "files": [{"sha": "9c480977e7e816ac36079100d2bfcf9d9cc67e49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,90 @@\n+2020-08-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (ANALYZER_OBJS): Add analyzer/region.o,\n+\tanalyzer/region-model-impl-calls.o,\n+\tanalyzer/region-model-manager.o,\n+\tanalyzer/region-model-reachability.o, analyzer/store.o, and\n+\tanalyzer/svalue.o.\n+\t* doc/analyzer.texi: Update for changes to analyzer\n+\timplementation.\n+\t* tristate.h (tristate::get_value): New accessor.\n+\n+2020-08-13  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-builtin.def (CET_NORMAL): Merge to CET BDESC array.\n+\t(__builtin_ia32_rddspd, __builtin_ia32_rddspq, __builtin_ia32_incsspd)\n+\t(__builtin_ia32_incsspq, __builtin_ia32_wrssd, __builtin_ia32_wrssq)\n+\t(__builtin_ia32_wrussd, __builtin_ia32_wrussq): Use CODE_FOR_nothing.\n+\t* config/i386/i386-builtins.c: Remove handling of CET_NORMAL builtins.\n+\t* config/i386/i386.md (@rdssp<mode>): Implement as parametrized\n+\tname pattern.  Use SWI48 mode iterator.  Introduce input operand\n+\tand remove explicit XOR zeroing from insn template.\n+\t(@incssp<mode>): Implement as parametrized name pattern.\n+\tUse SWI48 mode iterator.\n+\t(@wrss<mode>): Ditto.\n+\t(@wruss<mode>): Ditto.\n+\t(rstorssp): Remove expander.  Rename insn pattern from *rstorssp<mode>.\n+\tUse DImode memory operand.\n+\t(clrssbsy): Remove expander.  Rename insn pattern from *clrssbsy<mode>.\n+\tUse DImode memory operand.\n+\t(save_stack_nonlocal): Update for parametrized name patterns.\n+\tUse cleared register as an argument to gen_rddsp.\n+\t(restore_stack_nonlocal): Update for parametrized name patterns.\n+\t* config/i386/i386-expand.c (ix86_expand_builtin):\n+\t[case IX86_BUILTIN_RDSSPD, case IX86_BUILTIN_RDSSPQ]: Expand here.\n+\t[case IX86_BUILTIN_INCSSPD, case IX86_BUILTIN_INCSSPQ]: Ditto.\n+\t[case IX86_BUILTIN_RSTORSSP, case IX86_BUILTIN_CLRSSBSY]:\n+\tGenerate DImode memory operand.\n+\t[case IX86_BUILTIN_WRSSD, case IX86_BUILTIN_WRSSQ]\n+\t[case IX86_BUILTIN_WRUSSD, case IX86_BUILTIN_WRUSSD]:\n+\tUpdate for parameterized name patterns.\n+\n+2020-08-13  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR target/96506\n+\t* config/rs6000/rs6000-call.c (rs6000_promote_function_mode): Disallow\n+\tMMA types as return values.\n+\t(rs6000_function_arg): Disallow MMA types as function arguments.\n+\n+2020-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tRevert:\n+\t2020-08-12  Peixin Qiao  <qiaopeixin@huawei.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_function_value): Add if\n+\tcondition to check ag_mode after entering if condition of\n+\taarch64_vfp_is_call_or_return_candidate. If TARGET_FLOAT is\n+\tset as false by -mgeneral-regs-only, report the diagnostic\n+\tinformation of -mgeneral-regs-only imcompatible with the use\n+\tof fp/simd register(s).\n+\n+2020-08-13  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/96482\n+\t* ipa-cp.c (ipcp_bits_lattice::meet_with_1): Mask m_value\n+\twith m_mask.\n+\n+2020-08-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (gimplify_omp_taskloop_expr): New function.\n+\t(gimplify_omp_for): Use it.  For OMP_FOR_NON_RECTANGULAR\n+\tloops adjust in outer taskloop the var-outer decls.\n+\t* omp-expand.c (expand_omp_taskloop_for_inner): Handle non-rectangular\n+\tloops.\n+\t(expand_omp_for): Don't reject non-rectangular taskloop.\n+\t* omp-general.c (omp_extract_for_data): Don't assert that\n+\tnon-rectangular loops have static schedule, instead treat loop->m1\n+\tor loop->m2 as if loop->n1 or loop->n2 is non-constant.\n+\n+2020-08-13  Hongtao Liu  <hongtao.liu@intel.com>\n+\n+\tPR target/96246\n+\t* config/i386/sse.md (<avx512>_load<mode>_mask,\n+\t<avx512>_load<mode>_mask): Extend to generate blendm\n+\tinstructions.\n+\t(<avx512>_blendm<mode>, <avx512>_blendm<mode>): Change\n+\tdefine_insn to define_expand.\n+\n 2020-08-12  Roger Sayle  <roger@nextmovesoftware.com>\n \t    Uro\u0161 Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "da579e6d532c127a850a8eb3670b78eb8fa1eb75", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1 +1 @@\n-20200813\n+20200814"}, {"sha": "f8e59651590e860552ded928ae13d3f08fb38a5e", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 1393, "deletions": 0, "changes": 1393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,1396 @@\n+2020-08-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* analyzer-logging.cc: Ignore \"-Wformat-diag\".\n+\t(logger::enter_scope): Use inc_indent in both overloads.\n+\t(logger::exit_scope): Use dec_indent.\n+\t* analyzer-logging.h (logger::inc_indent): New.\n+\t(logger::dec_indent): New.\n+\t* analyzer-selftests.cc (run_analyzer_selftests): Call\n+\tanalyzer_store_cc_tests.\n+\t* analyzer-selftests.h (analyzer_store_cc_tests): New decl.\n+\t* analyzer.cc (get_stmt_location): New function.\n+\t* analyzer.h (class initial_svalue): New forward decl.\n+\t(class unaryop_svalue): New forward decl.\n+\t(class binop_svalue): New forward decl.\n+\t(class sub_svalue): New forward decl.\n+\t(class unmergeable_svalue): New forward decl.\n+\t(class placeholder_svalue): New forward decl.\n+\t(class widening_svalue): New forward decl.\n+\t(class compound_svalue): New forward decl.\n+\t(class conjured_svalue): New forward decl.\n+\t(svalue_set): New typedef.\n+\t(class map_region): Delete.\n+\t(class array_region): Delete.\n+\t(class frame_region): New forward decl.\n+\t(class function_region): New forward decl.\n+\t(class label_region): New forward decl.\n+\t(class decl_region): New forward decl.\n+\t(class element_region): New forward decl.\n+\t(class offset_region): New forward decl.\n+\t(class cast_region): New forward decl.\n+\t(class field_region): New forward decl.\n+\t(class string_region): New forward decl.\n+\t(class region_model_manager): New forward decl.\n+\t(class store_manager): New forward decl.\n+\t(class store): New forward decl.\n+\t(class call_details): New forward decl.\n+\t(struct svalue_id_merger_mapping): Delete.\n+\t(struct canonicalization): Delete.\n+\t(class function_point): New forward decl.\n+\t(class engine): New forward decl.\n+\t(dump_tree): New function decl.\n+\t(print_quoted_type): New function decl.\n+\t(readability_comparator): New function decl.\n+\t(tree_cmp): New function decl.\n+\t(class path_var): Move here from region-model.h\n+\t(bit_offset_t, bit_size_t, byte_size_t): New typedefs.\n+\t(class region_offset): New class.\n+\t(get_stmt_location): New decl.\n+\t(struct member_function_hash_traits): New struct.\n+\t(class consolidation_map): New class.\n+\tIgnore \"-Wformat-diag\".\n+\t* analyzer.opt (-param=analyzer-max-svalue-depth=): New param.\n+\t(-param=analyzer-max-enodes-for-full-dump=): New param.\n+\t* call-string.cc: Ignore -Wformat-diag.\n+\t* checker-path.cc: Move includes of \"analyzer/call-string.h\" and\n+\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n+\tand also include \"analyzer/store.h\" before it.\n+\t(state_change_event::state_change_event): Replace \"tree var\" param\n+\twith \"const svalue *sval\".  Convert \"origin\" param from tree to\n+\t\"const svalue *\".\n+\t(state_change_event::get_desc): Call get_representative_tree to\n+\tconvert the var and origin from const svalue * to tree.  Use\n+\tsvalue::get_desc rather than %qE when describing state changes.\n+\t(checker_path::add_final_event): Use get_stmt_location.\n+\t* checker-path.h (state_change_event::state_change_event): Port\n+\tfrom tree to const svalue *.\n+\t(state_change_event::get_lvalue): Delete.\n+\t(state_change_event::get_dest_function): New.\n+\t(state_change_event::m_var): Replace with...\n+\t(state_change_event::m_sval): ...this.\n+\t(state_change_event::m_origin): Convert from tree to\n+\tconst svalue *.\n+\t* constraint-manager.cc: Include \"analyzer/call-string.h\",\n+\t\"analyzer/program-point.h\", and \"analyzer/store.h\" before\n+\t\"analyzer/region-model.h\".\n+\t(struct bound, struct range): Move to constraint-manager.h.\n+\t(compare_constants): New function.\n+\t(range::dump): Rename to...\n+\t(range::dump_to_pp): ...this.  Support NULL constants.\n+\t(range::dump): Reintroduce for dumping to stderr.\n+\t(range::constrained_to_single_element): Return result, rather than\n+\twriting to *OUT.\n+\t(range::eval_condition): New.\n+\t(range::below_lower_bound): New.\n+\t(range::above_upper_bound): New.\n+\t(equiv_class::equiv_class): Port from svalue_id to const svalue *.\n+\t(equiv_class::print): Likewise.\n+\t(equiv_class::hash): Likewise.\n+\t(equiv_class::operator==): Port from svalue_id to const svalue *.\n+\t(equiv_class::add): Port from svalue_id to const svalue *. Drop\n+\t\"cm\" param.\n+\t(equiv_class::del): Port from svalue_id to const svalue *.\n+\t(equiv_class::get_representative): Likewise.\n+\t(equiv_class::remap_svalue_ids): Delete.\n+\t(svalue_id_cmp_by_id): Rename to...\n+\t(svalue_cmp_by_ptr): ...this, porting from svalue_id to\n+\tconst svalue *.\n+\t(equiv_class::canonicalize): Update qsort comparator.\n+\t(constraint::implied_by): New.\n+\t(constraint_manager::constraint_manager): Copy m_mgr in copy ctor.\n+\t(constraint_manager::dump_to_pp): Add \"multiline\" param\n+\t(constraint_manager::dump): Pass \"true\" for \"multiline\".\n+\t(constraint_manager::add_constraint): Port from svalue_id to\n+\tconst svalue *.  Split out second part into...\n+\t(constraint_manager::add_unknown_constraint): ...this new\n+\tfunction.  Remove self-constraints when merging equivalence\n+\tclasses.\n+\t(constraint_manager::add_constraint_internal): Remove constraints\n+\tthat would be implied by the new constraint.  Port from svalue_id\n+\tto const svalue *.\n+\t(constraint_manager::get_equiv_class_by_sid): Rename to...\n+\t(constraint_manager::get_equiv_class_by_svalue): ...this, porting\n+\tfrom svalue_id to const svalue *.\n+\t(constraint_manager::get_or_add_equiv_class): Port from svalue_id\n+\tto const svalue *.\n+\t(constraint_manager::eval_condition): Make const.  Call\n+\tcompare_constants and return early if it provides a known result.\n+\t(constraint_manager::get_ec_bounds): New.\n+\t(constraint_manager::eval_condition): New overloads.  Make\n+\texisting one const, and use compare_constants.\n+\t(constraint_manager::purge): Convert \"p\" param to a template\n+\trather that an abstract base class.  Port from svalue_id to\n+\tconst svalue *.\n+\t(class dead_svalue_purger): New class.\n+\t(constraint_manager::remap_svalue_ids): Delete.\n+\t(constraint_manager::on_liveness_change): New.\n+\t(equiv_class_cmp): Port from svalue_id to const svalue *.\n+\t(constraint_manager::canonicalize): Likewise.  Combine with\n+\tpurging of redundant equivalence classes and constraints.\n+\t(class cleaned_constraint_manager): Delete.\n+\t(class merger_fact_visitor): Make \"m_cm_b\" const.  Add \"m_merger\"\n+\tfield.\n+\t(merger_fact_visitor::fact): Port from svalue_id to const svalue *.\n+\tAdd special case for widening.\n+\t(constraint_manager::merge): Port from svalue_id to const svalue *.\n+\t(constraint_manager::clean_merger_input): Delete.\n+\t(constraint_manager::for_each_fact): Port from svalue_id to\n+\tconst svalue *.\n+\t(constraint_manager::validate): Likewise.\n+\t(selftest::test_constraint_conditions): Provide a\n+\tregion_model_manager when creating region_model instances.\n+\tAdd test for self-equality not creating equivalence classes.\n+\t(selftest::test_transitivity): Provide a region_model_manager when\n+\tcreating region_model instances.  Verify that EC-merging happens\n+\twhen constraints are implied.\n+\t(selftest::test_constant_comparisons):  Provide a\n+\tregion_model_manager when creating region_model instances.\n+\t(selftest::test_constraint_impl): Likewise.  Remove over-specified\n+\tassertions.\n+\t(selftest::test_equality): Provide a region_model_manager when\n+\tcreating region_model instances.\n+\t(selftest::test_many_constants): Likewise.  Provide a\n+\tprogram_point when testing merging.\n+\t(selftest::run_constraint_manager_tests): Move call to\n+\ttest_constant_comparisons to outside the transitivity guard.\n+\t* constraint-manager.h (struct bound): Move here from\n+\tconstraint-manager.cc.\n+\t(struct range): Likewise.\n+\t(struct::eval_condition): New decl.\n+\t(struct::below_lower_bound): New decl.\n+\t(struct::above_upper_bound): New decl.\n+\t(equiv_class::add): Port from svalue_id to const svalue *.\n+\t(equiv_class::del): Likewise.\n+\t(equiv_class::get_representative): Likewise.\n+\t(equiv_class::remap_svalue_ids): Drop.\n+\t(equiv_class::m_cst_sid): Convert to..\n+\t(equiv_class::m_cst_sval): ...this.\n+\t(equiv_class::m_vars): Port from svalue_id to const svalue *.\n+\t(constraint::bool implied_by): New decl.\n+\t(fact_visitor::on_fact): Port from svalue_id to const svalue *.\n+\t(constraint_manager::constraint_manager): Add mgr param.\n+\t(constraint_manager::clone): Delete.\n+\t(constraint_manager::maybe_get_constant): Delete.\n+\t(constraint_manager::get_sid_for_constant): Delete.\n+\t(constraint_manager::get_num_svalues): Delete.\n+\t(constraint_manager::dump_to_pp): Add \"multiline\" param.\n+\t(constraint_manager::get_equiv_class): Port from svalue_id to\n+\tconst svalue *.\n+\t(constraint_manager::add_constraint):  Likewise.\n+\t(constraint_manager::get_equiv_class_by_sid): Rename to...\n+\t(constraint_manager::get_equiv_class_by_svalue): ...this, porting\n+\tfrom svalue_id to const svalue *.\n+\t(constraint_manager::add_unknown_constraint): New decl.\n+\t(constraint_manager::get_or_add_equiv_class): Port from svalue_id\n+\tto const svalue *.\n+\t(constraint_manager::eval_condition): Likewise.  Add overloads.\n+\t(constraint_manager::get_ec_bounds): New decl.\n+\t(constraint_manager::purge): Convert to template.\n+\t(constraint_manager::remap_svalue_ids): Delete.\n+\t(constraint_manager::on_liveness_change): New decl.\n+\t(constraint_manager::canonicalize): Drop param.\n+\t(constraint_manager::clean_merger_input): Delete.\n+\t(constraint_manager::m_mgr): New field.\n+\t* diagnostic-manager.cc: Move includes of\n+\t\"analyzer/call-string.h\" and \"analyzer/program-point.h\" to before\n+\t\"analyzer/region-model.h\", and also include \"analyzer/store.h\"\n+\tbefore it.\n+\t(saved_diagnostic::saved_diagnostic): Add \"sval\" param.\n+\t(diagnostic_manager::diagnostic_manager): Add engine param.\n+\t(diagnostic_manager::add_diagnostic): Add \"sval\" param, passing it\n+\tto saved_diagnostic ctor.  Update overload to pass NULL for it.\n+\t(dedupe_winners::dedupe_winners): Add engine param.\n+\t(dedupe_winners::add): Add \"eg\" param.  Pass m_engine to\n+\tfeasible_p.\n+\t(dedupe_winner::m_engine): New field.\n+\t(diagnostic_manager::emit_saved_diagnostics): Pass engine to\n+\tdedupe_winners.  Pass &eg when adding candidates.  Pass svalue\n+\trather than tree to prune_path.  Use get_stmt_location to get\n+\tprimary location of diagnostic.\n+\t(diagnostic_manager::emit_saved_diagnostic): Likewise.\n+\t(get_any_origin): Drop.\n+\t(state_change_event_creator::on_global_state_change): Pass NULL\n+\tconst svalue * rather than NULL_TREE trees to state_change_event\n+\tctor.\n+\t(state_change_event_creator::on_state_change): Port from tree and\n+\tsvalue_id to const svalue *.\n+\t(for_each_state_change): Port from svalue_id to const svalue *.\n+\t(struct null_assignment_sm_context): New.\n+\t(diagnostic_manager::add_events_for_eedge):  Add state change\n+\tevents for assignment to NULL.\n+\t(diagnostic_manager::prune_path): Update param from tree to\n+\tconst svalue *.\n+\t(diagnostic_manager::prune_for_sm_diagnostic): Port from tracking\n+\tby tree to by const svalue *.\n+\t* diagnostic-manager.h (saved_diagnostic::saved_diagnostic): Add sval\n+\tparam.\n+\t(saved_diagnostic::m_sval): New field.\n+\t(diagnostic_manager::diagnostic_manager): Add engine param.\n+\t(diagnostic_manager::get_engine): New.\n+\t(diagnostic_manager::add_diagnostic): Add \"sval\" param.\n+\t(diagnostic_manager::prune_path): Likewise.\n+\t(diagnostic_manager::prune_for_sm_diagnostic): New overload.\n+\t(diagnostic_manager::m_eng): New field.\n+\t* engine.cc: Move includes of \"analyzer/call-string.h\" and\n+\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n+\tand also include \"analyzer/store.h\" before it.\n+\t(impl_region_model_context::impl_region_model_context): Update for\n+\tremoval of m_change field.\n+\t(impl_region_model_context::remap_svalue_ids): Delete.\n+\t(impl_region_model_context::on_svalue_leak): New.\n+\t(impl_region_model_context::on_svalue_purge): Delete.\n+\t(impl_region_model_context::on_liveness_change): New.\n+\t(impl_region_model_context::on_unknown_change): Update param\n+\tfrom svalue_id to const svalue *.  Add is_mutable param.\n+\t(setjmp_svalue::compare_fields): Delete.\n+\t(setjmp_svalue::accept): New.\n+\t(setjmp_svalue::add_to_hash): Delete.\n+\t(setjmp_svalue::dump_to_pp): New.\n+\t(setjmp_svalue::print_details): Delete.\n+\t(impl_sm_context::impl_sm_context): Drop \"change\" param.\n+\t(impl_sm_context::get_fndecl_for_call): Drop \"m_change\".\n+\t(impl_sm_context::on_transition): Drop ATTRIBUTE_UNUSED from\n+\t\"stmt\" param.  Drop m_change.  Port from svalue_id to\n+\tconst svalue *.\n+\t(impl_sm_context::warn_for_state): Drop m_change.  Port from\n+\tsvalue_id to const svalue *.\n+\t(impl_sm_context::get_readable_tree): Rename to...\n+\t(impl_sm_context::get_diagnostic_tree): ...this.  Port from\n+\tsvalue_id to const svalue *.\n+\t(impl_sm_context::is_zero_assignment): New.\n+\t(impl_sm_context::m_change): Delete field.\n+\t(leak_stmt_finder::find_stmt): Handle m_var being NULL.\n+\t(readability):  Increase penalty for MEM_REF.  For SSA_NAMEs,\n+\tslightly favor the underlying var over the SSA name.  Heavily\n+\tpenalize temporaries.  Handle RESULT_DECL.\n+\t(readability_comparator): Make non-static.  Consider stack depths.\n+\t(impl_region_model_context::on_state_leak): Convert from svalue_id\n+\tto const svalue *, updating for region_model changes.  Use\n+\tid_equal.\n+\t(impl_region_model_context::on_inherited_svalue): Delete.\n+\t(impl_region_model_context::on_cast): Delete.\n+\t(impl_region_model_context::on_condition):  Drop m_change.\n+\t(impl_region_model_context::on_phi): Likewise.\n+\t(impl_region_model_context::on_unexpected_tree_code): Handle t\n+\tbeing NULL.\n+\t(point_and_state::validate): Update stack checking for\n+\tregion_model changes.\n+\t(eg_traits::dump_args_t::show_enode_details_p): New.\n+\t(exploded_node::exploded_node): Initialize m_num_processed_stmts.\n+\t(exploded_node::get_processed_stmt): New function.\n+\t(exploded_node::get_dot_fillcolor): Add more colors.\n+\t(exploded_node::dump_dot): Guard the printing of the point and\n+\tstate with show_enode_details_p.  Print the processed stmts for\n+\tthis enode after the initial state.\n+\t(exploded_node::dump_to_pp): Pass true for new multiline param\n+\tof program_state::dump_to_pp.\n+\t(exploded_node::on_stmt): Drop \"change\" param.  Log the stmt.\n+\tSet input_location.  Implement __analyzer_describe.  Update\n+\timplementation of __analyzer_dump and __analyzer_eval.\n+\tRemove purging of sm-state for unknown fncalls from here.\n+\t(exploded_node::on_edge): Drop \"change\" param.\n+\t(exploded_node::on_longjmp): Port from region_id/svalue_id to\n+\tconst region */const svalue *.  Call program_state::detect_leaks.\n+\tDrop state_change.\n+\t(exploded_node::detect_leaks): Update for changes to region_model.\n+\tCall program_state::detect_leaks.\n+\t(exploded_edge::exploded_edge): Drop ext_state and change params.\n+\t(exploded_edge::dump_dot): \"args\" is no longer used.  Drop dumping\n+\tof m_change.\n+\t(exploded_graph::exploded_graph): Pass engine to\n+\tm_diagnostic_manager ctor.  Use program_point::origin.\n+\t(exploded_graph::add_function_entry):  Drop ctxt.  Use\n+\tprogram_state::push_frame.  Drop state_change.\n+\t(exploded_graph::get_or_create_node): Drop \"change\" param.  Add\n+\t\"enode_for_diag\" param.  Update dumping calls for API changes.\n+\tPass point to can_merge_with_p.  Show enode indices\n+\twithin -Wanalyzer-too-complex diagnostic for hitting the per-point\n+\tlimit.\n+\t(exploded_graph::add_edge): Drop \"change\" param.  Log which nodes\n+\tare being connected.  Update for changes to exploded_edge ctor.\n+\t(exploded_graph::get_per_program_point_data): New.\n+\t(exploded_graph::process_worklist): Pass point to\n+\tcan_merge_with_p.  Drop state_change.  Update dumping call for API\n+\tchange.\n+\t(exploded_graph::process_node):  Drop state_change.  Split the\n+\tnode in-place if an sm-state-change occurs.  Update\n+\tm_num_processed_stmts.  Update dumping calls for API change.\n+\t(exploded_graph::log_stats): Call engine::log_stats.\n+\t(exploded_graph::dump_states_for_supernode): Update dumping\n+\tcall.\n+\t(exploded_path::feasible_p): Add \"eng\" and \"eg\" params.\n+\tRename \"i\" to \"end_idx\".  Pass the manager to the region_model\n+\tctor.  Update for every processed stmt in the enode, not just the\n+\tfirst.  Keep track of which snodes have been visited, and call\n+\tloop_replay_fixup when revisiting one.\n+\t(enode_label::get_text): Update dump call for new param.\n+\t(exploded_graph::dump_exploded_nodes): Likewise.\n+\t(exploded_graph::get_node_by_index): New.\n+\t(impl_run_checkers): Create engine instance and pass its address\n+\tto extrinsic_state ctor.\n+\t* exploded-graph.h\n+\t(impl_region_model_context::impl_region_model_context): Drop\n+\t\"change\" params.\n+\t(impl_region_model_context::void remap_svalue_ids): Delete.\n+\t(impl_region_model_context::on_svalue_purge): Delete.\n+\t(impl_region_model_context::on_svalue_leak): New.\n+\t(impl_region_model_context::on_liveness_change): New.\n+\t(impl_region_model_context::on_state_leak): Update signature.\n+\t(impl_region_model_context::on_inherited_svalue): Delete.\n+\t(impl_region_model_context::on_cast): Delete.\n+\t(impl_region_model_context::on_unknown_change): Update signature.\n+\t(impl_region_model_context::m_change): Delete.\n+\t(eg_traits::dump_args_t::show_enode_details_p): New.\n+\t(exploded_node::on_stmt): Drop \"change\" param.\n+\t(exploded_node::on_edge): Likewise.\n+\t(exploded_node::get_processed_stmt): New decl.\n+\t(exploded_node::m_num_processed_stmts): New field.\n+\t(exploded_edge::exploded_edge): Drop ext_state and change params.\n+\t(exploded_edge::m_change): Delete.\n+\t(exploded_graph::get_engine): New accessor.\n+\t(exploded_graph::get_or_create_node): Drop \"change\" param.  Add\n+\t\"enode_for_diag\" param.\n+\t(exploded_graph::add_edge): Drop \"change\" param.\n+\t(exploded_graph::get_per_program_point_data): New decl.\n+\t(exploded_graph::get_node_by_index): New decl.\n+\t(exploded_path::feasible_p): Add \"eng\" and \"eg\" params.\n+\t* program-point.cc: Include \"analyzer/store.h\" before including\n+\t\"analyzer/region-model.h\".\n+\t(function_point::function_point): Move here from\n+\tprogram-point.h.\n+\t(function_point::get_function): Likewise.\n+\t(function_point::from_function_entry): Likewise.\n+\t(function_point::before_supernode): Likewise.\n+\t(function_point::next_stmt): New function.\n+\t* program-point.h (function_point::function_point): Move\n+\timplementation from here to program-point.cc.\n+\t(function_point::get_function): Likewise.\n+\t(function_point::from_function_entry): Likewise.\n+\t(function_point::before_supernode): Likewise.\n+\t(function_point::next_stmt): New decl.\n+\t(program_point::operator!=): New.\n+\t(program_point::origin): New.\n+\t(program_point::next_stmt): New.\n+\t(program_point::m_function_point): Make non-const.\n+\t* program-state.cc: Move includes of \"analyzer/call-string.h\" and\n+\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n+\tand also include \"analyzer/store.h\" before it.\n+\t(extrinsic_state::get_model_manager): New.\n+\t(sm_state_map::sm_state_map): Pass in sm and sm_idx to ctor,\n+\trather than pass the around.\n+\t(sm_state_map::clone_with_remapping): Delete.\n+\t(sm_state_map::print): Remove \"sm\" param in favor of \"m_sm\".  Add\n+\t\"simple\" and \"multiline\" params and support multiline vs single\n+\tline dumping.\n+\t(sm_state_map::dump): Remove \"sm\" param in favor of \"m_sm\".  Add\n+\t\"simple\" param.\n+\t(sm_state_map::hash): Port from svalue_id to const svalue *.\n+\t(sm_state_map::operator==): Likewise.\n+\t(sm_state_map::get_state): Likewise.  Call canonicalize_svalue on\n+\tinput.  Handle inheritance of sm-state.  Call get_default_state.\n+\t(sm_state_map::get_origin): Port from svalue_id to const svalue *.\n+\t(sm_state_map::set_state): Likewise.  Pass in ext_state.  Reject\n+\tattempts to set state on UNKNOWN.\n+\t(sm_state_map::impl_set_state): Port from svalue_id to\n+\tconst svalue *.  Pass in ext_state.  Call canonicalize_svalue on\n+\tinput.\n+\t(sm_state_map::purge_for_unknown_fncall): Delete.\n+\t(sm_state_map::on_svalue_leak): New.\n+\t(sm_state_map::remap_svalue_ids): Delete.\n+\t(sm_state_map::on_liveness_change): New.\n+\t(sm_state_map::on_unknown_change): Reimplement.\n+\t(sm_state_map::on_svalue_purge): Delete.\n+\t(sm_state_map::on_inherited_svalue): Delete.\n+\t(sm_state_map::on_cast): Delete.\n+\t(sm_state_map::validate): Delete.\n+\t(sm_state_map::canonicalize_svalue): New.\n+\t(program_state::program_state): Update to pass manager to\n+\tregion_model's ctor.  Constify num_states and pass state machine\n+\tand index to sm_state_map ctor.\n+\t(program_state::print): Update for changes to dump API.\n+\t(program_state::dump_to_pp): Ignore the summarize param.  Add\n+\t\"multiline\" param.\n+\t(program_state::dump_to_file): Add \"multiline\" param.\n+\t(program_state::dump): Pass \"true\" for new \"multiline\" param.\n+\t(program_state::push_frame): New.\n+\t(program_state::on_edge): Drop \"change\" param.  Call\n+\tprogram_state::detect_leaks.\n+\t(program_state::prune_for_point): Add enode_for_diag param.\n+\tReimplement based on store class.  Call detect_leaks\n+\t(program_state::remap_svalue_ids): Delete.\n+\t(program_state::get_representative_tree): Port from svalue_id to\n+\tconst svalue *.\n+\t(program_state::can_merge_with_p): Add \"point\" param.  Add early\n+\treject for sm-differences.  Drop id remapping.\n+\t(program_state::validate): Drop region model and sm_state_map\n+\tvalidation.\n+\t(state_change::sm_change::dump): Delete.\n+\t(state_change::sm_change::remap_svalue_ids): Delete.\n+\t(state_change::sm_change::on_svalue_purge): Delete.\n+\t(log_set_of_svalues): New.\n+\t(state_change::sm_change::validate): Delete.\n+\t(state_change::state_change): Delete.\n+\t(state_change::add_sm_change): Delete.\n+\t(state_change::affects_p): Delete.\n+\t(state_change::dump): Delete.\n+\t(state_change::remap_svalue_ids): Delete.\n+\t(state_change::on_svalue_purge): Delete.\n+\t(state_change::validate): Delete.\n+\t(selftest::assert_dump_eq): Delete.\n+\t(ASSERT_DUMP_EQ): Delete.\n+\t(selftest::test_sm_state_map): Update for changes to region_model\n+\tand sm_state_map, porting from svalue_id to const svalue *.\n+\t(selftest::test_program_state_dumping): Likewise.  Drop test of\n+\tdumping, renaming to...\n+\t(selftest::test_program_state_1): ...this.\n+\t(selftest::test_program_state_dumping_2): Likewise, renaming to...\n+\t(selftest::test_program_state_2): ...this.\n+\t(selftest::test_program_state_merging): Update for changes to\n+\tregion_model.\n+\t(selftest::test_program_state_merging_2): Likewise.\n+\t(selftest::analyzer_program_state_cc_tests): Update for renamed\n+\ttests.\n+\t* program-state.h (extrinsic_state::extrinsic_state): Add logger\n+\tand engine params.\n+\t(extrinsic_state::get_logger): New accessor.\n+\t(extrinsic_state::get_engine): New accessor.\n+\t(extrinsic_state::get_model_manager): New accessor.\n+\t(extrinsic_state::m_logger): New field.\n+\t(extrinsic_state::m_engine): New field.\n+\t(struct default_hash_traits<svalue_id>): Delete.\n+\t(pod_hash_traits<svalue_id>::hash): Delete.\n+\t(pod_hash_traits<svalue_id>::equal): Delete.\n+\t(pod_hash_traits<svalue_id>::mark_deleted): Delete.\n+\t(pod_hash_traits<svalue_id>::mark_empty): Delete.\n+\t(pod_hash_traits<svalue_id>::is_deleted): Delete.\n+\t(pod_hash_traits<svalue_id>::is_empty): Delete.\n+\t(sm_state_map::entry_t::entry_t): Port from svalue_id to\n+\tconst svalue *.\n+\t(sm_state_map::entry_t::m_origin): Likewise.\n+\t(sm_state_map::map_t): Likewise.\n+\t(sm_state_map::sm_state_map): Add state_machine and index params.\n+\t(sm_state_map::clone_with_remapping): Delete.\n+\t(sm_state_map::print):  Drop sm param; add simple and multiline\n+\tparams.\n+\t(sm_state_map::dump): Drop sm param; add simple param.\n+\t(sm_state_map::get_state): Port from svalue_id to const svalue *.\n+\tAdd ext_state param.\n+\t(sm_state_map::get_origin): Likewise.\n+\t(sm_state_map::set_state): Likewise.\n+\t(sm_state_map::impl_set_state): Likewise.\n+\t(sm_state_map::purge_for_unknown_fncall): Delete.\n+\t(sm_state_map::remap_svalue_ids): Delete.\n+\t(sm_state_map::on_svalue_purge): Delete.\n+\t(sm_state_map::on_svalue_leak): New.\n+\t(sm_state_map::on_liveness_change): New.\n+\t(sm_state_map::on_inherited_svalue): Delete.\n+\t(sm_state_map::on_cast): Delete.\n+\t(sm_state_map::validate): Delete.\n+\t(sm_state_map::on_unknown_change): Port from svalue_id to\n+\tconst svalue *.  Add is_mutable and ext_state params.\n+\t(sm_state_map::canonicalize_svalue): New.\n+\t(sm_state_map::m_sm): New field.\n+\t(sm_state_map::m_sm_idx): New field.\n+\t(program_state::operator=): Delete.\n+\t(program_state::dump_to_pp): Drop \"summarize\" param, adding\n+\t\"simple\" and \"multiline\".\n+\t(program_state::dump_to_file): Likewise.\n+\t(program_state::dump): Rename \"summarize\" to \"simple\".\n+\t(program_state::push_frame): New.\n+\t(program_state::get_current_function): New.\n+\t(program_state::on_edge): Drop \"change\" param.\n+\t(program_state::prune_for_point): Likewise.  Add enode_for_diag\n+\tparam.\n+\t(program_state::remap_svalue_ids): Delete.\n+\t(program_state::get_representative_tree): Port from svalue_id to\n+\tconst svalue *.\n+\t(program_state::can_purge_p): Likewise.  Pass ext_state to get_state.\n+\t(program_state::can_merge_with_p): Add point param.\n+\t(program_state::detect_leaks): New.\n+\t(state_change_visitor::on_state_change): Port from tree and\n+\tsvalue_id to a pair of const svalue *.\n+\t(class state_change): Delete.\n+\t* region.cc: New file.\n+\t* region-model-impl-calls.cc: New file.\n+\t* region-model-manager.cc: New file.\n+\t* region-model-reachability.cc: New file.\n+\t* region-model-reachability.h: New file.\n+\t* region-model.cc: Include \"analyzer/call-string.h\",\n+\t\"analyzer/program-point.h\", and \"analyzer/store.h\" before\n+\t\"analyzer/region-model.h\".  Include\n+\t\"analyzer/region-model-reachability.h\".\n+\t(dump_tree): Make non-static.\n+\t(dump_quoted_tree): Make non-static.\n+\t(print_quoted_type): Make non-static.\n+\t(path_var::dump): Delete.\n+\t(dump_separator): Delete.\n+\t(class impl_constraint_manager): Delete.\n+\t(svalue_id::print): Delete.\n+\t(svalue_id::dump_node_name_to_pp): Delete.\n+\t(svalue_id::validate): Delete.\n+\t(region_id::print): Delete.\n+\t(region_id::dump_node_name_to_pp): Delete.\n+\t(region_id::validate): Delete.\n+\t(region_id_set::region_id_set): Delete.\n+\t(svalue_id_set::svalue_id_set): Delete.\n+\t(svalue::operator==): Delete.\n+\t(svalue::hash): Delete.\n+\t(svalue::print): Delete.\n+\t(svalue::dump_dot_to_pp): Delete.\n+\t(svalue::remap_region_ids): Delete.\n+\t(svalue::walk_for_canonicalization): Delete.\n+\t(svalue::get_child_sid): Delete.\n+\t(svalue::maybe_get_constant): Delete.\n+\t(region_svalue::compare_fields): Delete.\n+\t(region_svalue::add_to_hash): Delete.\n+\t(region_svalue::print_details): Delete.\n+\t(region_svalue::dump_dot_to_pp): Delete.\n+\t(region_svalue::remap_region_ids): Delete.\n+\t(region_svalue::merge_values): Delete.\n+\t(region_svalue::walk_for_canonicalization): Delete.\n+\t(region_svalue::eval_condition): Delete.\n+\t(constant_svalue::compare_fields): Delete.\n+\t(constant_svalue::add_to_hash): Delete.\n+\t(constant_svalue::merge_values): Delete.\n+\t(constant_svalue::eval_condition): Move to svalue.cc.\n+\t(constant_svalue::print_details): Delete.\n+\t(constant_svalue::get_child_sid): Delete.\n+\t(unknown_svalue::compare_fields): Delete.\n+\t(unknown_svalue::add_to_hash): Delete.\n+\t(unknown_svalue::print_details): Delete.\n+\t(poison_kind_to_str): Move to svalue.cc.\n+\t(poisoned_svalue::compare_fields): Delete.\n+\t(poisoned_svalue::add_to_hash): Delete.\n+\t(poisoned_svalue::print_details): Delete.\n+\t(region_kind_to_str): Move to region.cc and reimplement.\n+\t(region::operator==): Delete.\n+\t(region::get_parent_region): Delete.\n+\t(region::set_value): Delete.\n+\t(region::become_active_view): Delete.\n+\t(region::deactivate_any_active_view): Delete.\n+\t(region::deactivate_view): Delete.\n+\t(region::get_value): Delete.\n+\t(region::get_inherited_child_sid): Delete.\n+\t(region_model::copy_region): Delete.\n+\t(region_model::copy_struct_region): Delete.\n+\t(region_model::copy_union_region): Delete.\n+\t(region_model::copy_array_region): Delete.\n+\t(region::hash): Delete.\n+\t(region::print): Delete.\n+\t(region::dump_dot_to_pp): Delete.\n+\t(region::dump_to_pp): Delete.\n+\t(region::dump_child_label): Delete.\n+\t(region::validate): Delete.\n+\t(region::remap_svalue_ids): Delete.\n+\t(region::remap_region_ids): Delete.\n+\t(region::add_view): Delete.\n+\t(region::get_view): Delete.\n+\t(region::region): Move to region.cc.\n+\t(region::add_to_hash): Delete.\n+\t(region::print_fields): Delete.\n+\t(region::non_null_p): Delete.\n+\t(primitive_region::clone): Delete.\n+\t(primitive_region::walk_for_canonicalization): Delete.\n+\t(map_region::map_region): Delete.\n+\t(map_region::compare_fields): Delete.\n+\t(map_region::print_fields): Delete.\n+\t(map_region::validate): Delete.\n+\t(map_region::dump_dot_to_pp): Delete.\n+\t(map_region::dump_child_label): Delete.\n+\t(map_region::get_or_create): Delete.\n+\t(map_region::get): Delete.\n+\t(map_region::add_to_hash): Delete.\n+\t(map_region::remap_region_ids): Delete.\n+\t(map_region::unbind): Delete.\n+\t(map_region::get_tree_for_child_region): Delete.\n+\t(map_region::get_tree_for_child_region): Delete.\n+\t(tree_cmp): Move to region.cc.\n+\t(map_region::can_merge_p): Delete.\n+\t(map_region::walk_for_canonicalization): Delete.\n+\t(map_region::get_value_by_name): Delete.\n+\t(struct_or_union_region::valid_key_p): Delete.\n+\t(struct_or_union_region::compare_fields): Delete.\n+\t(struct_region::clone): Delete.\n+\t(struct_region::compare_fields): Delete.\n+\t(union_region::clone): Delete.\n+\t(union_region::compare_fields): Delete.\n+\t(frame_region::compare_fields): Delete.\n+\t(frame_region::clone): Delete.\n+\t(frame_region::valid_key_p): Delete.\n+\t(frame_region::print_fields): Delete.\n+\t(frame_region::add_to_hash): Delete.\n+\t(globals_region::compare_fields): Delete.\n+\t(globals_region::clone): Delete.\n+\t(globals_region::valid_key_p): Delete.\n+\t(code_region::compare_fields): Delete.\n+\t(code_region::clone): Delete.\n+\t(code_region::valid_key_p): Delete.\n+\t(array_region::array_region): Delete.\n+\t(array_region::get_element): Delete.\n+\t(array_region::clone): Delete.\n+\t(array_region::compare_fields): Delete.\n+\t(array_region::print_fields): Delete.\n+\t(array_region::validate): Delete.\n+\t(array_region::dump_dot_to_pp): Delete.\n+\t(array_region::dump_child_label): Delete.\n+\t(array_region::get_or_create): Delete.\n+\t(array_region::get): Delete.\n+\t(array_region::add_to_hash): Delete.\n+\t(array_region::remap_region_ids): Delete.\n+\t(array_region::get_key_for_child_region): Delete.\n+\t(array_region::key_cmp): Delete.\n+\t(array_region::walk_for_canonicalization): Delete.\n+\t(array_region::key_from_constant): Delete.\n+\t(array_region::constant_from_key): Delete.\n+\t(function_region::compare_fields): Delete.\n+\t(function_region::clone): Delete.\n+\t(function_region::valid_key_p): Delete.\n+\t(stack_region::stack_region): Delete.\n+\t(stack_region::compare_fields): Delete.\n+\t(stack_region::clone): Delete.\n+\t(stack_region::print_fields): Delete.\n+\t(stack_region::dump_child_label): Delete.\n+\t(stack_region::validate): Delete.\n+\t(stack_region::push_frame): Delete.\n+\t(stack_region::get_current_frame_id): Delete.\n+\t(stack_region::pop_frame): Delete.\n+\t(stack_region::add_to_hash): Delete.\n+\t(stack_region::remap_region_ids): Delete.\n+\t(stack_region::can_merge_p): Delete.\n+\t(stack_region::walk_for_canonicalization): Delete.\n+\t(stack_region::get_value_by_name): Delete.\n+\t(heap_region::heap_region): Delete.\n+\t(heap_region::compare_fields): Delete.\n+\t(heap_region::clone): Delete.\n+\t(heap_region::walk_for_canonicalization): Delete.\n+\t(root_region::root_region): Delete.\n+\t(root_region::compare_fields): Delete.\n+\t(root_region::clone): Delete.\n+\t(root_region::print_fields): Delete.\n+\t(root_region::validate): Delete.\n+\t(root_region::dump_child_label): Delete.\n+\t(root_region::push_frame): Delete.\n+\t(root_region::get_current_frame_id): Delete.\n+\t(root_region::pop_frame): Delete.\n+\t(root_region::ensure_stack_region): Delete.\n+\t(root_region::get_stack_region): Delete.\n+\t(root_region::ensure_globals_region): Delete.\n+\t(root_region::get_code_region): Delete.\n+\t(root_region::ensure_code_region): Delete.\n+\t(root_region::get_globals_region): Delete.\n+\t(root_region::ensure_heap_region): Delete.\n+\t(root_region::get_heap_region): Delete.\n+\t(root_region::remap_region_ids): Delete.\n+\t(root_region::can_merge_p): Delete.\n+\t(root_region::add_to_hash): Delete.\n+\t(root_region::walk_for_canonicalization): Delete.\n+\t(root_region::get_value_by_name): Delete.\n+\t(symbolic_region::symbolic_region): Delete.\n+\t(symbolic_region::compare_fields): Delete.\n+\t(symbolic_region::clone): Delete.\n+\t(symbolic_region::walk_for_canonicalization): Delete.\n+\t(symbolic_region::print_fields): Delete.\n+\t(region_model::region_model): Add region_model_manager * param.\n+\tReimplement in terms of store, dropping impl_constraint_manager\n+\tsubclass.\n+\t(region_model::operator=): Reimplement in terms of store\n+\t(region_model::operator==): Likewise.\n+\t(region_model::hash): Likewise.\n+\t(region_model::print): Delete.\n+\t(region_model::print_svalue): Delete.\n+\t(region_model::dump_dot_to_pp): Delete.\n+\t(region_model::dump_dot_to_file): Delete.\n+\t(region_model::dump_dot): Delete.\n+\t(region_model::dump_to_pp): Replace \"summarize\" param with\n+\t\"simple\" and \"multiline\".  Port to store-based implementation.\n+\t(region_model::dump): Replace \"summarize\" param with \"simple\" and\n+\t\"multiline\".\n+\t(dump_vec_of_tree): Delete.\n+\t(region_model::dump_summary_of_rep_path_vars): Delete.\n+\t(region_model::validate): Delete.\n+\t(svalue_id_cmp_by_constant_svalue_model): Delete.\n+\t(svalue_id_cmp_by_constant_svalue): Delete.\n+\t(region_model::canonicalize): Drop \"ctxt\" param.  Reimplement in\n+\tterms of store and constraints.\n+\t(region_model::canonicalized_p): Remove NULL arg to canonicalize.\n+\t(region_model::loop_replay_fixup): New.\n+\t(poisoned_value_diagnostic::emit): Tweak wording of warnings.\n+\t(region_model::check_for_poison): Delete.\n+\t(region_model::get_gassign_result): New.\n+\t(region_model::on_assignment): Port to store-based implementation.\n+\t(region_model::on_call_pre): Delete calls to check_for_poison.\n+\tMove implementations to region-model-impl-calls.c and port to\n+\tstore-based implementation.\n+\t(region_model::on_call_post): Likewise.\n+\t(class reachable_regions): Move to region-model-reachability.h/cc\n+\tand port to store-based implementation.\n+\t(region_model::handle_unrecognized_call): Port to store-based\n+\timplementation.\n+\t(region_model::get_reachable_svalues): New.\n+\t(region_model::on_setjmp): Port to store-based implementation.\n+\t(region_model::on_longjmp): Likewise.\n+\t(region_model::handle_phi): Drop is_back_edge param and the logic\n+\tusing it.\n+\t(region_model::get_lvalue_1): Port from region_id to const region *.\n+\t(region_model::make_region_for_unexpected_tree_code): Delete.\n+\t(assert_compat_types): If the check fails, use internal_error to\n+\tshow the types.\n+\t(region_model::get_lvalue): Port from region_id to const region *.\n+\t(region_model::get_rvalue_1): Port from svalue_id to const svalue *.\n+\t(region_model::get_rvalue): Likewise.\n+\t(region_model::get_or_create_ptr_svalue): Delete.\n+\t(region_model::get_or_create_constant_svalue): Delete.\n+\t(region_model::get_svalue_for_fndecl): Delete.\n+\t(region_model::get_region_for_fndecl): Delete.\n+\t(region_model::get_svalue_for_label): Delete.\n+\t(region_model::get_region_for_label): Delete.\n+\t(build_cast): Delete.\n+\t(region_model::maybe_cast_1): Delete.\n+\t(region_model::maybe_cast): Delete.\n+\t(region_model::get_field_region): Delete.\n+\t(region_model::get_store_value): New.\n+\t(region_model::region_exists_p): New.\n+\t(region_model::deref_rvalue): Port from svalue_id to const svalue *.\n+\t(region_model::set_value): Likewise.\n+\t(region_model::clobber_region): New.\n+\t(region_model::purge_region): New.\n+\t(region_model::zero_fill_region): New.\n+\t(region_model::mark_region_as_unknown): New.\n+\t(region_model::eval_condition): Port from svalue_id to\n+\tconst svalue *.\n+\t(region_model::eval_condition_without_cm): Likewise.\n+\t(region_model::compare_initial_and_pointer): New.\n+\t(region_model::add_constraint): Port from svalue_id to\n+\tconst svalue *.\n+\t(region_model::maybe_get_constant): Delete.\n+\t(region_model::get_representative_path_var): New.\n+\t(region_model::add_new_malloc_region): Delete.\n+\t(region_model::get_representative_tree): Port to const svalue *.\n+\t(region_model::get_representative_path_var): Port to\n+\tconst region *.\n+\t(region_model::get_path_vars_for_svalue): Delete.\n+\t(region_model::set_to_new_unknown_value): Delete.\n+\t(region_model::update_for_phis): Don't pass is_back_edge to handle_phi.\n+\t(region_model::update_for_call_superedge): Port from svalue_id to\n+\tconst svalue *.\n+\t(region_model::update_for_return_superedge): Port to store-based\n+\timplementation.\n+\t(region_model::update_for_call_summary): Replace\n+\tset_to_new_unknown_value with mark_region_as_unknown.\n+\t(region_model::get_root_region): Delete.\n+\t(region_model::get_stack_region_id): Delete.\n+\t(region_model::push_frame): Delete.\n+\t(region_model::get_current_frame_id): Delete.\n+\t(region_model::get_current_function): Delete.\n+\t(region_model::pop_frame): Delete.\n+\t(region_model::on_top_level_param): New.\n+\t(region_model::get_stack_depth): Delete.\n+\t(region_model::get_function_at_depth): Delete.\n+\t(region_model::get_globals_region_id): Delete.\n+\t(region_model::add_svalue): Delete.\n+\t(region_model::replace_svalue): Delete.\n+\t(region_model::add_region): Delete.\n+\t(region_model::get_svalue): Delete.\n+\t(region_model::get_region): Delete.\n+\t(make_region_for_type): Delete.\n+\t(region_model::add_region_for_type): Delete.\n+\t(region_model::on_top_level_param): New.\n+\t(class restrict_to_used_svalues): Delete.\n+\t(region_model::purge_unused_svalues): Delete.\n+\t(region_model::push_frame): New.\n+\t(region_model::remap_svalue_ids): Delete.\n+\t(region_model::remap_region_ids): Delete.\n+\t(region_model::purge_regions): Delete.\n+\t(region_model::get_descendents): Delete.\n+\t(region_model::delete_region_and_descendents): Delete.\n+\t(region_model::poison_any_pointers_to_bad_regions): Delete.\n+\t(region_model::can_merge_with_p): Delete.\n+\t(region_model::get_current_function): New.\n+\t(region_model::get_value_by_name): Delete.\n+\t(region_model::convert_byte_offset_to_array_index): Delete.\n+\t(region_model::pop_frame): New.\n+\t(region_model::get_or_create_mem_ref): Delete.\n+\t(region_model::get_stack_depth): New.\n+\t(region_model::get_frame_at_index): New.\n+\t(region_model::unbind_region_and_descendents): New.\n+\t(struct bad_pointer_finder): New.\n+\t(region_model::get_or_create_pointer_plus_expr): Delete.\n+\t(region_model::poison_any_pointers_to_descendents): New.\n+\t(region_model::get_or_create_view): Delete.\n+\t(region_model::can_merge_with_p): New.\n+\t(region_model::get_fndecl_for_call):  Port from svalue_id to\n+\tconst svalue *.\n+\t(struct append_ssa_names_cb_data): New.\n+\t(get_ssa_name_regions_for_current_frame): New.\n+\t(region_model::append_ssa_names_cb): New.\n+\t(model_merger::dump_to_pp): Add \"simple\" param.  Drop dumping of\n+\tremappings.\n+\t(model_merger::dump): Add \"simple\" param to both overloads.\n+\t(model_merger::can_merge_values_p): Delete.\n+\t(model_merger::record_regions): Delete.\n+\t(model_merger::record_svalues): Delete.\n+\t(svalue_id_merger_mapping::svalue_id_merger_mapping): Delete.\n+\t(svalue_id_merger_mapping::dump_to_pp): Delete.\n+\t(svalue_id_merger_mapping::dump): Delete.\n+\t(region_model::create_region_for_heap_alloc): New.\n+\t(region_model::create_region_for_alloca): New.\n+\t(region_model::record_dynamic_extents): New.\n+\t(canonicalization::canonicalization): Delete.\n+\t(canonicalization::walk_rid): Delete.\n+\t(canonicalization::walk_sid): Delete.\n+\t(canonicalization::dump_to_pp): Delete.\n+\t(canonicalization::dump): Delete.\n+\t(inchash::add): Delete overloads for svalue_id and region_id.\n+\t(engine::log_stats): New.\n+\t(assert_condition): Add overload comparing svalues.\n+\t(assert_dump_eq): Pass \"true\" for multiline.\n+\t(selftest::test_dump): Update for rewrite of region_model.\n+\t(selftest::test_dump_2): Rename to...\n+\t(selftest::test_struct): ...this.  Provide a region_model_manager\n+\twhen creating region_model instance.  Remove dump test.  Add\n+\tchecks for get_offset.\n+\t(selftest::test_dump_3): Rename to...\n+\t(selftest::test_array_1): ...this.  Provide a region_model_manager\n+\twhen creating region_model instance.  Remove dump test.\n+\t(selftest::test_get_representative_tree): Port from svalue_id to\n+\tnew API.  Add test coverage for various expressions.\n+\t(selftest::test_unique_constants): Provide a region_model_manager\n+\tfor the region_model.  Add test coverage for comparing const vs\n+\tnon-const.\n+\t(selftest::test_svalue_equality): Delete.\n+\t(selftest::test_region_equality): Delete.\n+\t(selftest::test_unique_unknowns): New.\n+\t(class purge_all_svalue_ids): Delete.\n+\t(class purge_one_svalue_id): Delete.\n+\t(selftest::test_purging_by_criteria): Delete.\n+\t(selftest::test_initial_svalue_folding): New.\n+\t(selftest::test_unaryop_svalue_folding): New.\n+\t(selftest::test_binop_svalue_folding): New.\n+\t(selftest::test_sub_svalue_folding): New.\n+\t(selftest::test_purge_unused_svalues): Delete.\n+\t(selftest::test_descendent_of_p): New.\n+\t(selftest::test_assignment): Provide a region_model_manager for\n+\tthe region_model.  Drop the dump test.\n+\t(selftest::test_compound_assignment): Likewise.\n+\t(selftest::test_stack_frames): Port to new implementation.\n+\t(selftest::test_get_representative_path_var): Likewise.\n+\t(selftest::test_canonicalization_1): Rename to...\n+\t(selftest::test_equality_1): ...this.  Port to new API, and add\n+\t(selftest::test_canonicalization_2): Provide a\n+\tregion_model_manager when creating region_model instances.\n+\tRemove redundant canicalization.\n+\t(selftest::test_canonicalization_3): Provide a\n+\tregion_model_manager when creating region_model instances.\n+\tRemove param from calls to region_model::canonicalize.\n+\t(selftest::test_canonicalization_4): Likewise.\n+\t(selftest::assert_region_models_merge): Constify\n+\tout_merged_svalue.  Port to new API.\n+\t(selftest::test_state_merging): Provide a\n+\tregion_model_manager when creating region_model instances.\n+\tProvide a program_point point when merging them.  Replace\n+\tset_to_new_unknown_value with usage of placeholder_svalues.\n+\tDrop get_value_by_name.  Port from svalue_id to const svalue *.\n+\tAdd test of heap allocation.\n+\t(selftest::test_constraint_merging):  Provide a\n+\tregion_model_manager when creating region_model instances.\n+\tProvide a program_point point when merging them.  Eliminate use\n+\tof set_to_new_unknown_value.\n+\t(selftest::test_widening_constraints): New.\n+\t(selftest::test_iteration_1): New.\n+\t(selftest::test_malloc_constraints): Port to store-based\n+\timplementation.\n+\t(selftest::test_var): New test.\n+\t(selftest::test_array_2): New test.\n+\t(selftest::test_mem_ref): New test.\n+\t(selftest::test_POINTER_PLUS_EXPR_then_MEM_REF): New.\n+\t(selftest::test_malloc): New.\n+\t(selftest::test_alloca): New.\n+\t(selftest::analyzer_region_model_cc_tests): Update for renamings.\n+\tCall new functions.\n+\t* region-model.h (class path_var): Move to analyzer.h.\n+\t(class svalue_id): Delete.\n+\t(class region_id): Delete.\n+\t(class id_map): Delete.\n+\t(svalue_id_map): Delete.\n+\t(region_id_map): Delete.\n+\t(id_map<T>::id_map): Delete.\n+\t(id_map<T>::put): Delete.\n+\t(id_map<T>::get_dst_for_src): Delete.\n+\t(id_map<T>::get_src_for_dst): Delete.\n+\t(id_map<T>::dump_to_pp): Delete.\n+\t(id_map<T>::dump): Delete.\n+\t(id_map<T>::update): Delete.\n+\t(one_way_svalue_id_map): Delete.\n+\t(one_way_region_id_map): Delete.\n+\t(class region_id_set): Delete.\n+\t(class svalue_id_set): Delete.\n+\t(struct complexity): New.\n+\t(class visitor): New.\n+\t(enum svalue_kind): Add SK_SETJMP, SK_INITIAL, SK_UNARYOP,\n+\tSK_BINOP, SK_SUB,SK_UNMERGEABLE, SK_PLACEHOLDER, SK_WIDENING,\n+\tSK_COMPOUND, and SK_CONJURED.\n+\t(svalue::operator==): Delete.\n+\t(svalue::operator!=): Delete.\n+\t(svalue::clone): Delete.\n+\t(svalue::hash): Delete.\n+\t(svalue::dump_dot_to_pp): Delete.\n+\t(svalue::dump_to_pp): New.\n+\t(svalue::dump): New.\n+\t(svalue::get_desc): New.\n+\t(svalue::dyn_cast_initial_svalue): New.\n+\t(svalue::dyn_cast_unaryop_svalue): New.\n+\t(svalue::dyn_cast_binop_svalue): New.\n+\t(svalue::dyn_cast_sub_svalue): New.\n+\t(svalue::dyn_cast_unmergeable_svalue): New.\n+\t(svalue::dyn_cast_widening_svalue): New.\n+\t(svalue::dyn_cast_compound_svalue): New.\n+\t(svalue::dyn_cast_conjured_svalue): New.\n+\t(svalue::maybe_undo_cast): New.\n+\t(svalue::unwrap_any_unmergeable): New.\n+\t(svalue::remap_region_ids): Delete\n+\t(svalue::can_merge_p): New.\n+\t(svalue::walk_for_canonicalization): Delete\n+\t(svalue::get_complexity): New.\n+\t(svalue::get_child_sid): Delete\n+\t(svalue::accept): New.\n+\t(svalue::live_p): New.\n+\t(svalue::implicitly_live_p): New.\n+\t(svalue::svalue): Add complexity param.\n+\t(svalue::add_to_hash): Delete\n+\t(svalue::print_details): Delete\n+\t(svalue::m_complexity): New field.\n+\t(region_svalue::key_t): New struct.\n+\t(region_svalue::region_svalue): Port from region_id to\n+\tconst region_id *.  Add complexity.\n+\t(region_svalue::compare_fields): Delete.\n+\t(region_svalue::clone): Delete.\n+\t(region_svalue::dump_dot_to_pp): Delete.\n+\t(region_svalue::get_pointee): Port from region_id to\n+\tconst region_id *.\n+\t(region_svalue::remap_region_ids): Delete.\n+\t(region_svalue::merge_values): Delete.\n+\t(region_svalue::dump_to_pp): New.\n+\t(region_svalue::accept): New.\n+\t(region_svalue::walk_for_canonicalization): Delete.\n+\t(region_svalue::eval_condition): Make params const.\n+\t(region_svalue::add_to_hash): Delete.\n+\t(region_svalue::print_details): Delete.\n+\t(region_svalue::m_rid): Replace with...\n+\t(region_svalue::m_reg): ...this.\n+\t(is_a_helper <region_svalue *>::test): Convert to...\n+\t(is_a_helper <const region_svalue *>::test): ...this.\n+\t(template <> struct default_hash_traits<region_svalue::key_t>):\n+\tNew.\n+\t(constant_svalue::constant_svalue): Add complexity.\n+\t(constant_svalue::compare_fields): Delete.\n+\t(constant_svalue::clone): Delete.\n+\t(constant_svalue::add_to_hash): Delete.\n+\t(constant_svalue::dump_to_pp): New.\n+\t(constant_svalue::accept): New.\n+\t(constant_svalue::implicitly_live_p): New.\n+\t(constant_svalue::merge_values): Delete.\n+\t(constant_svalue::eval_condition): Make params const.\n+\t(constant_svalue::get_child_sid): Delete.\n+\t(constant_svalue::print_details): Delete.\n+\t(is_a_helper <constant_svalue *>::test): Convert to...\n+\t(is_a_helper <const constant_svalue *>::test): ...this.\n+\t(class unknown_svalue): Update leading comment.\n+\t(unknown_svalue::unknown_svalue): Add complexity.\n+\t(unknown_svalue::compare_fields): Delete.\n+\t(unknown_svalue::add_to_hash): Delete.\n+\t(unknown_svalue::dyn_cast_unknown_svalue): Delete.\n+\t(unknown_svalue::print_details): Delete.\n+\t(unknown_svalue::dump_to_pp): New.\n+\t(unknown_svalue::accept): New.\n+\t(poisoned_svalue::key_t): New struct.\n+\t(poisoned_svalue::poisoned_svalue): Add complexity.\n+\t(poisoned_svalue::compare_fields): Delete.\n+\t(poisoned_svalue::clone): Delete.\n+\t(poisoned_svalue::add_to_hash): Delete.\n+\t(poisoned_svalue::dump_to_pp): New.\n+\t(poisoned_svalue::accept): New.\n+\t(poisoned_svalue::print_details): Delete.\n+\t(is_a_helper <poisoned_svalue *>::test): Convert to...\n+\t(is_a_helper <const poisoned_svalue *>::test): ...this.\n+\t(template <> struct default_hash_traits<poisoned_svalue::key_t>):\n+\tNew.\n+\t(setjmp_record::add_to_hash): New.\n+\t(setjmp_svalue::key_t): New struct.\n+\t(setjmp_svalue::compare_fields): Delete.\n+\t(setjmp_svalue::clone): Delete.\n+\t(setjmp_svalue::add_to_hash): Delete.\n+\t(setjmp_svalue::setjmp_svalue): Add complexity.\n+\t(setjmp_svalue::dump_to_pp): New.\n+\t(setjmp_svalue::accept): New.\n+\t(setjmp_svalue::void print_details): Delete.\n+\t(is_a_helper <const setjmp_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<setjmp_svalue::key_t>): New.\n+\t(class initial_svalue : public svalue): New.\n+\t(is_a_helper <const initial_svalue *>::test): New.\n+\t(class unaryop_svalue): New.\n+\t(is_a_helper <const unaryop_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<unaryop_svalue::key_t>): New.\n+\t(class binop_svalue): New.\n+\t(is_a_helper <const binop_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<binop_svalue::key_t>): New.\n+\t(class sub_svalue): New.\n+\t(is_a_helper <const sub_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<sub_svalue::key_t>): New.\n+\t(class unmergeable_svalue): New.\n+\t(is_a_helper <const unmergeable_svalue *>::test): New.\n+\t(class placeholder_svalue): New.\n+\t(is_a_helper <placeholder_svalue *>::test): New.\n+\t(class widening_svalue): New.\n+\t(is_a_helper <widening_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<widening_svalue::key_t>): New.\n+\t(class compound_svalue): New.\n+\t(is_a_helper <compound_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<compound_svalue::key_t>): New.\n+\t(class conjured_svalue): New.\n+\t(is_a_helper <conjured_svalue *>::test): New.\n+\t(template <> struct default_hash_traits<conjured_svalue::key_t>): New.\n+\t(enum region_kind): Delete RK_PRIMITIVE, RK_STRUCT, RK_UNION, and\n+\tRK_ARRAY.  Add RK_LABEL, RK_DECL, RK_FIELD, RK_ELEMENT, RK_OFFSET,\n+\tRK_CAST, RK_HEAP_ALLOCATED, RK_ALLOCA, RK_STRING, and RK_UNKNOWN.\n+\t(region_kind_to_str): Delete.\n+\t(region::~region): Move implementation to region.cc.\n+\t(region::operator==): Delete.\n+\t(region::operator!=): Delete.\n+\t(region::clone): Delete.\n+\t(region::get_id): New.\n+\t(region::cmp_ids): New.\n+\t(region::dyn_cast_map_region): Delete.\n+\t(region::dyn_cast_array_region): Delete.\n+\t(region::region_id get_parent): Delete.\n+\t(region::get_parent_region): Convert to a simple accessor.\n+\t(region::void set_value): Delete.\n+\t(region::svalue_id get_value): Delete.\n+\t(region::svalue_id get_value_direct): Delete.\n+\t(region::svalue_id get_inherited_child_sid): Delete.\n+\t(region::dyn_cast_frame_region): New.\n+\t(region::dyn_cast_function_region): New.\n+\t(region::dyn_cast_decl_region): New.\n+\t(region::dyn_cast_field_region): New.\n+\t(region::dyn_cast_element_region): New.\n+\t(region::dyn_cast_offset_region): New.\n+\t(region::dyn_cast_cast_region): New.\n+\t(region::dyn_cast_string_region): New.\n+\t(region::accept): New.\n+\t(region::get_base_region): New.\n+\t(region::base_region_p): New.\n+\t(region::descendent_of_p): New.\n+\t(region::maybe_get_frame_region): New.\n+\t(region::maybe_get_decl): New.\n+\t(region::hash): Delete.\n+\t(region::rint): Delete.\n+\t(region::dump_dot_to_pp): Delete.\n+\t(region::get_desc): New.\n+\t(region::dump_to_pp): Convert to vfunc, changing signature.\n+\t(region::dump_child_label): Delete.\n+\t(region::remap_svalue_ids): Delete.\n+\t(region::remap_region_ids): Delete.\n+\t(region::dump): New.\n+\t(region::walk_for_canonicalization): Delete.\n+\t(region::non_null_p): Drop region_model param.\n+\t(region::add_view): Delete.\n+\t(region::get_view): Delete.\n+\t(region::get_active_view): Delete.\n+\t(region::is_view_p): Delete.\n+\t(region::cmp_ptrs): New.\n+\t(region::validate): Delete.\n+\t(region::get_offset): New.\n+\t(region::get_byte_size): New.\n+\t(region::get_bit_size): New.\n+\t(region::get_subregions_for_binding): New.\n+\t(region::region): Add complexity param.  Convert parent from\n+\tregion_id to const region *.  Drop svalue_id.  Drop copy ctor.\n+\t(region::symbolic_for_unknown_ptr_p): New.\n+\t(region::add_to_hash): Delete.\n+\t(region::print_fields): Delete.\n+\t(region::get_complexity): New accessor.\n+\t(region::become_active_view): Delete.\n+\t(region::deactivate_any_active_view): Delete.\n+\t(region::deactivate_view): Delete.\n+\t(region::calc_offset): New.\n+\t(region::m_parent_rid): Delete.\n+\t(region::m_sval_id): Delete.\n+\t(region::m_complexity): New.\n+\t(region::m_id): New.\n+\t(region::m_parent): New.\n+\t(region::m_view_rids): Delete.\n+\t(region::m_is_view): Delete.\n+\t(region::m_active_view_rid): Delete.\n+\t(region::m_cached_offset): New.\n+\t(is_a_helper <region *>::test): Convert to...\n+\t(is_a_helper <const region *>::test): ... this.\n+\t(class primitive_region): Delete.\n+\t(class space_region): New.\n+\t(class map_region): Delete.\n+\t(is_a_helper <map_region *>::test): Delete.\n+\t(class frame_region): Reimplement.\n+\t(template <> struct default_hash_traits<frame_region::key_t>):\n+\tNew.\n+\t(class globals_region): Reimplement.\n+\t(is_a_helper <globals_region *>::test): Convert to...\n+\t(is_a_helper <const globals_region *>::test): ...this.\n+\t(class struct_or_union_region): Delete.\n+\t(is_a_helper <struct_or_union_region *>::test): Delete.\n+\t(class code_region): Reimplement.\n+\t(is_a_helper <const code_region *>::test): New.\n+\t(class struct_region): Delete.\n+\t(is_a_helper <struct_region *>::test): Delete.\n+\t(class function_region): Reimplement.\n+\t(is_a_helper <function_region *>::test): Convert to...\n+\t(is_a_helper <const function_region *>::test): ...this.\n+\t(class union_region): Delete.\n+\t(is_a_helper <union_region *>::test): Delete.\n+\t(class label_region): New.\n+\t(is_a_helper <const label_region *>::test): New.\n+\t(class scope_region): Delete.\n+\t(class stack_region): Reimplement.\n+\t(is_a_helper <stack_region *>::test): Convert to...\n+\t(is_a_helper <const stack_region *>::test): ...this.\n+\t(class heap_region): Reimplement.\n+\t(is_a_helper <heap_region *>::test): Convert to...\n+\t(is_a_helper <const heap_region *>::test): ...this.\n+\t(class root_region): Reimplement.\n+\t(is_a_helper <root_region *>::test): Convert to...\n+\t(is_a_helper <const root_region *>::test): ...this.\n+\t(class symbolic_region): Reimplement.\n+\t(is_a_helper <const symbolic_region *>::test): New.\n+\t(template <> struct default_hash_traits<symbolic_region::key_t>):\n+\tNew.\n+\t(class decl_region): New.\n+\t(is_a_helper <const decl_region *>::test): New.\n+\t(class field_region): New.\n+\t(template <> struct default_hash_traits<field_region::key_t>): New.\n+\t(class array_region): Delete.\n+\t(class element_region): New.\n+\t(is_a_helper <array_region *>::test): Delete.\n+\t(is_a_helper <const element_region *>::test): New.\n+\t(template <> struct default_hash_traits<element_region::key_t>):\n+\tNew.\n+\t(class offset_region): New.\n+\t(is_a_helper <const offset_region *>::test): New.\n+\t(template <> struct default_hash_traits<offset_region::key_t>):\n+\tNew.\n+\t(class cast_region): New.\n+\t(is_a_helper <const cast_region *>::test): New.\n+\t(template <> struct default_hash_traits<cast_region::key_t>): New.\n+\t(class heap_allocated_region): New.\n+\t(class alloca_region): New.\n+\t(class string_region): New.\n+\t(is_a_helper <const string_region *>::test): New.\n+\t(class unknown_region): New.\n+\t(class region_model_manager): New.\n+\t(struct append_ssa_names_cb_data): New.\n+\t(class call_details): New.\n+\t(region_model::region_model): Add region_model_manager param.\n+\t(region_model::print_svalue): Delete.\n+\t(region_model::dump_dot_to_pp): Delete.\n+\t(region_model::dump_dot_to_file): Delete.\n+\t(region_model::dump_dot): Delete.\n+\t(region_model::dump_to_pp): Drop summarize param in favor of\n+\tsimple and multiline.\n+\t(region_model::dump): Likewise.\n+\t(region_model::summarize_to_pp): Delete.\n+\t(region_model::summarize): Delete.\n+\t(region_model::void canonicalize): Drop ctxt param.\n+\t(region_model::void check_for_poison): Delete.\n+\t(region_model::get_gassign_result): New.\n+\t(region_model::impl_call_alloca): New.\n+\t(region_model::impl_call_analyzer_describe): New.\n+\t(region_model::impl_call_analyzer_eval): New.\n+\t(region_model::impl_call_builtin_expect): New.\n+\t(region_model::impl_call_calloc): New.\n+\t(region_model::impl_call_free): New.\n+\t(region_model::impl_call_malloc): New.\n+\t(region_model::impl_call_memset): New.\n+\t(region_model::impl_call_strlen): New.\n+\t(region_model::get_reachable_svalues): New.\n+\t(region_model::handle_phi): Drop is_back_edge param.\n+\t(region_model::region_id get_root_rid): Delete.\n+\t(region_model::root_region *get_root_region): Delete.\n+\t(region_model::region_id get_stack_region_id): Delete.\n+\t(region_model::push_frame): Convert from region_id and svalue_id\n+\tto const region * and const svalue *.\n+\t(region_model::get_current_frame_id): Replace with...\n+\t(region_model::get_current_frame): ...this.\n+\t(region_model::pop_frame): Convert from region_id to\n+\tconst region *.  Drop purge and stats param.  Add out_result.\n+\t(region_model::function *get_function_at_depth): Delete.\n+\t(region_model::get_globals_region_id): Delete.\n+\t(region_model::add_svalue): Delete.\n+\t(region_model::replace_svalue): Delete.\n+\t(region_model::add_region): Delete.\n+\t(region_model::add_region_for_type): Delete.\n+\t(region_model::get_svalue): Delete.\n+\t(region_model::get_region): Delete.\n+\t(region_model::get_lvalue): Convert from region_id to\n+\tconst region *.\n+\t(region_model::get_rvalue): Convert from svalue_id to\n+\tconst svalue *.\n+\t(region_model::get_or_create_ptr_svalue): Delete.\n+\t(region_model::get_or_create_constant_svalue): Delete.\n+\t(region_model::get_svalue_for_fndecl): Delete.\n+\t(region_model::get_svalue_for_label): Delete.\n+\t(region_model::get_region_for_fndecl): Delete.\n+\t(region_model::get_region_for_label): Delete.\n+\t(region_model::get_frame_at_index (int index) const;): New.\n+\t(region_model::maybe_cast): Delete.\n+\t(region_model::maybe_cast_1): Delete.\n+\t(region_model::get_field_region): Delete.\n+\t(region_model::id deref_rvalue): Convert from region_id and\n+\tsvalue_id to const region * and const svalue *.  Drop overload,\n+\tpassing in both a tree and an svalue.\n+\t(region_model::set_value): Convert from region_id and svalue_id to\n+\tconst region * and const svalue *.\n+\t(region_model::set_to_new_unknown_value): Delete.\n+\t(region_model::clobber_region (const region *reg);): New.\n+\t(region_model::purge_region (const region *reg);): New.\n+\t(region_model::zero_fill_region (const region *reg);): New.\n+\t(region_model::mark_region_as_unknown (const region *reg);): New.\n+\t(region_model::copy_region): Convert from region_id to\n+\tconst region *.\n+\t(region_model::eval_condition): Convert from svalue_id to\n+\tconst svalue *.\n+\t(region_model::eval_condition_without_cm): Likewise.\n+\t(region_model::compare_initial_and_pointer): New.\n+\t(region_model:maybe_get_constant): Delete.\n+\t(region_model::add_new_malloc_region): Delete.\n+\t(region_model::get_representative_tree): Convert from svalue_id to\n+\tconst svalue *.\n+\t(region_model::get_representative_path_var): Delete decl taking a\n+\tregion_id in favor of two decls, for svalue vs region, with an\n+\tsvalue_set to ensure termination.\n+\t(region_model::get_path_vars_for_svalue): Delete.\n+\t(region_model::create_region_for_heap_alloc): New.\n+\t(region_model::create_region_for_alloca): New.\n+\t(region_model::purge_unused_svalues): Delete.\n+\t(region_model::remap_svalue_ids): Delete.\n+\t(region_model::remap_region_ids): Delete.\n+\t(region_model::purge_regions): Delete.\n+\t(region_model::get_num_svalues): Delete.\n+\t(region_model::get_num_regions): Delete.\n+\t(region_model::get_descendents): Delete.\n+\t(region_model::get_store): New.\n+\t(region_model::delete_region_and_descendents): Delete.\n+\t(region_model::get_manager): New.\n+\t(region_model::unbind_region_and_descendents): New.\n+\t(region_model::can_merge_with_p): Add point param.  Drop\n+\tsvalue_id_merger_mapping.\n+\t(region_model::get_value_by_name): Delete.\n+\t(region_model::convert_byte_offset_to_array_index): Delete.\n+\t(region_model::get_or_create_mem_ref): Delete.\n+\t(region_model::get_or_create_pointer_plus_expr): Delete.\n+\t(region_model::get_or_create_view): Delete.\n+\t(region_model::get_lvalue_1): Convert from region_id to\n+\tconst region *.\n+\t(region_model::get_rvalue_1): Convert from svalue_id to\n+\tconst svalue *.\n+\t(region_model::get_ssa_name_regions_for_current_frame): New.\n+\t(region_model::append_ssa_names_cb): New.\n+\t(region_model::get_store_value): New.\n+\t(region_model::copy_struct_region): Delete.\n+\t(region_model::copy_union_region): Delete.\n+\t(region_model::copy_array_region): Delete.\n+\t(region_model::region_exists_p): New.\n+\t(region_model::make_region_for_unexpected_tree_code): Delete.\n+\t(region_model::loop_replay_fixup): New.\n+\t(region_model::poison_any_pointers_to_bad_regions): Delete.\n+\t(region_model::poison_any_pointers_to_descendents): New.\n+\t(region_model::dump_summary_of_rep_path_vars): Delete.\n+\t(region_model::on_top_level_param): New.\n+\t(region_model::record_dynamic_extents): New.\n+\t(region_model::m_mgr;): New.\n+\t(region_model::m_store;): New.\n+\t(region_model::m_svalues;): Delete.\n+\t(region_model::m_regions;): Delete.\n+\t(region_model::m_root_rid;): Delete.\n+\t(region_model::m_current_frame;): New.\n+\t(region_model_context::remap_svalue_ids): Delete.\n+\t(region_model_context::can_purge_p): Delete.\n+\t(region_model_context::on_svalue_leak): New.\n+\t(region_model_context::on_svalue_purge): Delete.\n+\t(region_model_context::on_liveness_change): New.\n+\t(region_model_context::on_inherited_svalue): Delete.\n+\t(region_model_context::on_cast): Delete.\n+\t(region_model_context::on_unknown_change): Convert from svalue_id to\n+\tconst svalue * and add is_mutable.\n+\t(class noop_region_model_context): Update for region_model_context\n+\tchanges.\n+\t(model_merger::model_merger): Add program_point.  Drop\n+\tsvalue_id_merger_mapping.\n+\t(model_merger::dump_to_pp): Add \"simple\" param.\n+\t(model_merger::dump): Likewise.\n+\t(model_merger::get_region_a): Delete.\n+\t(model_merger::get_region_b): Delete.\n+\t(model_merger::can_merge_values_p): Delete.\n+\t(model_merger::record_regions): Delete.\n+\t(model_merger::record_svalues): Delete.\n+\t(model_merger::m_point): New field.\n+\t(model_merger::m_map_regions_from_a_to_m): Delete.\n+\t(model_merger::m_map_regions_from_b_to_m): Delete.\n+\t(model_merger::m_sid_mapping): Delete.\n+\t(struct svalue_id_merger_mapping): Delete.\n+\t(class engine): New.\n+\t(struct canonicalization): Delete.\n+\t(inchash::add): Delete decls for hashing svalue_id and region_id.\n+\t(test_region_model_context::on_unexpected_tree_code): Require t to\n+\tbe non-NULL.\n+\t(selftest::assert_condition): Add overload comparing a pair of\n+\tconst svalue *.\n+\t* sm-file.cc: Include \"tristate.h\", \"selftest.h\",\n+\t\"analyzer/call-string.h\", \"analyzer/program-point.h\",\n+\t\"analyzer/store.h\", and \"analyzer/region-model.h\".\n+\t(fileptr_state_machine::get_default_state): New.\n+\t(fileptr_state_machine::on_stmt): Remove calls to\n+\tget_readable_tree in favor of get_diagnostic_tree.\n+\t* sm-malloc.cc: Include \"tristate.h\", \"selftest.h\",\n+\t\"analyzer/call-string.h\", \"analyzer/program-point.h\",\n+\t\"analyzer/store.h\", and \"analyzer/region-model.h\".\n+\t(malloc_state_machine::get_default_state): New.\n+\t(malloc_state_machine::reset_when_passed_to_unknown_fn_p): New.\n+\t(malloc_diagnostic::describe_state_change): Handle change.m_expr\n+\tbeing NULL.\n+\t(null_arg::emit): Avoid printing \"NULL '0'\".\n+\t(null_arg::describe_final_event): Avoid printing \"(0) NULL\".\n+\t(malloc_leak::emit): Handle m_arg being NULL.\n+\t(malloc_leak::describe_final_event): Handle ev.m_expr being NULL.\n+\t(malloc_state_machine::on_stmt): Don't call get_readable_tree.\n+\tCall get_diagnostic_tree when creating pending diagnostics.\n+\tUpdate for is_zero_assignment becoming a member function of\n+\tsm_ctxt.\n+\tDon't transition to m_non_heap for ADDR_EXPR(MEM_REF()).\n+\t(malloc_state_machine::reset_when_passed_to_unknown_fn_p): New\n+\tvfunc implementation.\n+\t* sm-sensitive.cc (sensitive_state_machine::warn_for_any_exposure): Call\n+\tget_diagnostic_tree and pass the result to warn_for_state.\n+\t* sm-signal.cc: Move includes of \"analyzer/call-string.h\" and\n+\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n+\tand also include \"analyzer/store.h\" before it.\n+\t(signal_unsafe_call::describe_state_change): Use\n+\tget_dest_function to get handler.\n+\t(update_model_for_signal_handler): Pass manager to region_model\n+\tctor.\n+\t(register_signal_handler::impl_transition): Update for changes to\n+\tget_or_create_node and add_edge.\n+\t* sm-taint.cc (taint_state_machine::on_stmt): Remove calls to\n+\tget_readable_tree, replacing them when calling warn_for_state with\n+\tcalls to get_diagnostic_tree.\n+\t* sm.cc (is_zero_assignment): Delete.\n+\t(any_pointer_p): Move to within namespace ana.\n+\t* sm.h (is_zero_assignment): Remove decl.\n+\t(any_pointer_p): Move decl to within namespace ana.\n+\t(state_machine::get_default_state): New vfunc.\n+\t(state_machine::reset_when_passed_to_unknown_fn_p): New vfunc.\n+\t(sm_context::get_readable_tree): Rename to...\n+\t(sm_context::get_diagnostic_tree): ...this.\n+\t(sm_context::is_zero_assignment): New vfunc.\n+\t* store.cc: New file.\n+\t* store.h: New file.\n+\t* svalue.cc: New file.\n+\n 2020-05-22  Mark Wielaard  <mark@klomp.org>\n \n \t* sm-signal.cc(signal_unsafe_call::emit): Possibly add"}, {"sha": "07d32a5f1415fcb5bb8febf51b428c27d524be70", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,28 @@\n+2020-08-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.h (enum class LOOK_where): New.\n+\t(operator|, operator&): Overloads for it.\n+\t(lookup_name_real): Replace NONCLASS & BLOCK_P parms with WHERE.\n+\t* name-lookup.c (identifier_type_value_w): Adjust\n+\tlookup_name_real call.\n+\t(lookup_name_real_1): Replace NONCLASS and BLOCK_P parameters\n+\twith WHERE bitmask. Don't search namespaces if not asked to.\n+\t(lookup_name_real): Adjust lookup_name_real_1 call.\n+\t(lookup_name_nonclass, lookup_name)\n+\t(lookup_name_prefer_type): Likewise.\n+\t* call.c (build_operator_new_call)\n+\t(add_operator_candidates): Adjust lookup_name_real calls.\n+\t* parser.c (cp_parser_lookup_name): Likewise.\n+\t* pt.c (tsubst_friend_class, lookup_init_capture_pack)\n+\t(tsubst_expr): Likewise.\n+\t* semantics.c (capture_decltype): Likewise.\n+\n+2020-08-13  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/92812\n+\t* typeck.c (build_static_cast_1): Implement P1975R0 by allowing\n+\tstatic_cast to aggregate type.\n+\n 2020-08-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/96497"}, {"sha": "f734d3cb49a2895f27a8af2e1fb00e87746cfa77", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,14 @@\n+2020-08-13  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/93671\n+\t* trans-array.c (structure_alloc_comps): Keep caf-mode when applying to\n+\tcomponents; get the caf_token correctly for allocated scalar components.\n+\n+2020-08-13  Matthew Krupcale  <mkrupcale@matthewkrupcale.com>\n+\n+\tPR fortran/96595\n+\t* invoke.texi: Fix typos.\n+\n 2020-08-12  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* gfortran.h: Add OMP_LIST_NONTEMPORAL."}, {"sha": "78eecead18c36274af4dd9a03dca007b40fcdf64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,241 @@\n+2020-08-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/96598\n+\t* gcc.dg/analyzer/pr96598.c: New test.\n+\n+2020-08-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93032\n+\tPR analyzer/93938\n+\tPR analyzer/94011\n+\tPR analyzer/94099\n+\tPR analyzer/94399\n+\tPR analyzer/94458\n+\tPR analyzer/94503\n+\tPR analyzer/94640\n+\tPR analyzer/94688\n+\tPR analyzer/94689\n+\tPR analyzer/94839\n+\tPR analyzer/95026\n+\tPR analyzer/95042\n+\tPR analyzer/95240\n+\t* g++.dg/analyzer/pr93212.C: Add dg-warning for dangling\n+\treference.\n+\t* g++.dg/analyzer/pr93950.C: Remove xfail.\n+\t* g++.dg/analyzer/pr94011.C: New test.\n+\t* g++.dg/analyzer/pr94028.C: Remove leak false positives; mark as\n+\tfailing on C++98.\n+\t* g++.dg/analyzer/pr94503.C: New test.\n+\t* g++.dg/analyzer/pr95042.C: New test.\n+\t* gcc.dg/analyzer/CVE-2005-1689-dedupe-issue-2.c: New test.\n+\t* gcc.dg/analyzer/CVE-2005-1689-dedupe-issue.c: Add xfail.\n+\t* gcc.dg/analyzer/CVE-2005-1689-minimal.c:\n+\tInclude \"analyzer-decls.h\".\n+\t(test_4, test_5, test_6, test_7, test_8): New tests.\n+\t* gcc.dg/analyzer/abs-1.c: New test.\n+\t* gcc.dg/analyzer/aliasing-1.c: New test.\n+\t* gcc.dg/analyzer/aliasing-2.c: New test.\n+\t* gcc.dg/analyzer/analyzer-decls.h (__analyzer_describe): New\n+\tdecl.\n+\t(__analyzer_dump_num_heap_regions): Remove.\n+\t* gcc.dg/analyzer/attribute-nonnull.c: Add dg-warnings for cases\n+\twhere NULL is directly used as an argument.\n+\t* gcc.dg/analyzer/bzero-1.c: New test.\n+\t* gcc.dg/analyzer/casts-1.c: New test.\n+\t* gcc.dg/analyzer/casts-2.c: New test.\n+\t* gcc.dg/analyzer/compound-assignment-1.c\n+\t(test_4): Remove xfail from leak false positive.\n+\t(called_by_test_5a): Add \"allocated here\" expected message.\n+\t(called_by_test_5b): Make expected leak message more precise.\n+\t* gcc.dg/analyzer/compound-assignment-3.c: Update expected leak\n+\tmessage.\n+\t* gcc.dg/analyzer/compound-assignment-4.c: New test.\n+\t* gcc.dg/analyzer/compound-assignment-5.c: New test.\n+\t* gcc.dg/analyzer/conditionals-notrans.c: Remove xfails.\n+\t* gcc.dg/analyzer/data-model-1.c (test_12d): Update expected\n+\tresults.\n+\t(test_13): Remove xfail.\n+\t(test_14): Remove xfail.\n+\t(test_15): Remove xfail.\n+\t(test_16): Remove xfails.  Add out-of-bounds access.\n+\t(test_16_alt): Remove xfails.\n+\t(test_23): Remove xfail.\n+\t(test_24): Remove xfail.\n+\t(test_25): Remove xfail.\n+\t(test_26): Update expected result.  Remove xfail.  Add xfail.\n+\t(test_27): Remove xfails.\n+\t(test_29): Add __analyzer_eval pointer comparisons.\n+\t(test_41): Generalize expected output for u.ptr comparison with\n+\tNULL for targets where this could be known to be false.\n+\t(test_42): Remove xfail.\n+\t(test_51): Remove xfails.\n+\t* gcc.dg/analyzer/data-model-13.c: Update for improvements to\n+\tsource location and wording of leak message.\n+\t* gcc.dg/analyzer/data-model-14.c: Remove -fanalyzer-fine-grained.\n+\t(test_1): Update for improvement to expected message.\n+\t(test_2): Remove xfail.\n+\t* gcc.dg/analyzer/data-model-18.c: Remove xfail.\n+\t* gcc.dg/analyzer/data-model-20.c: New test.\n+\t* gcc.dg/analyzer/data-model-5.c: Add dg-warning for deref of\n+\tNULL.  Add xfailing false leak.\n+\t* gcc.dg/analyzer/data-model-5b.c: Add xfailing false leak.\n+\t* gcc.dg/analyzer/data-model-5c.c: Update xfailing false leak.\n+\t* gcc.dg/analyzer/data-model-5d.c: Reimplement.\n+\t* gcc.dg/analyzer/data-model-6.c: Delete test.\n+\t* gcc.dg/analyzer/data-model-8.c: Remove xfail.\n+\t* gcc.dg/analyzer/describe-1.c: New test.\n+\t* gcc.dg/analyzer/dot-output.c: Remove xfail.\n+\t* gcc.dg/analyzer/explode-1.c: Add expected leak warning.\n+\t* gcc.dg/analyzer/explode-2.c: Add expected leak warnings.  Mark\n+\tdouble-free warnings as xfail for now.\n+\t* gcc.dg/analyzer/feasibility-1.c: New test.\n+\t* gcc.dg/analyzer/first-field-1.c: New test.\n+\t* gcc.dg/analyzer/first-field-2.c: New test.\n+\t* gcc.dg/analyzer/init.c: New test.\n+\t* gcc.dg/analyzer/leak-2.c: New test.\n+\t* gcc.dg/analyzer/loop-0-up-to-n-by-1-with-iter-obj.c: New test.\n+\t* gcc.dg/analyzer/loop-0-up-to-n-by-1.c: New test.\n+\t* gcc.dg/analyzer/loop-2a.c: Update expected behavior.\n+\t* gcc.dg/analyzer/loop-3.c: Mark use-after-free as xfail.  Add\n+\texpected warning about deref of unchecked pointer.\n+\t* gcc.dg/analyzer/loop-4.c: Remove -fno-analyzer-state-purge.\n+\tUpdate expected behavior.\n+\t* gcc.dg/analyzer/loop-n-down-to-1-by-1.c: New test.\n+\t* gcc.dg/analyzer/loop-start-down-to-end-by-1.c: New test.\n+\t* gcc.dg/analyzer/loop-start-down-to-end-by-step.c: New test.\n+\t* gcc.dg/analyzer/loop-start-to-end-by-step.c: New test.\n+\t* gcc.dg/analyzer/loop-start-up-to-end-by-1.c: New test.\n+\t* gcc.dg/analyzer/loop.c: Remove -fno-analyzer-state-purge.\n+\tUpdate expected behavior.\n+\t* gcc.dg/analyzer/malloc-1.c: Remove xfails from leak false\n+\tpositives.  Update expected wording of global_link.m_ptr leak.\n+\t(test_49): New test.\n+\t* gcc.dg/analyzer/malloc-4.c: Remove leak false positive.  Update\n+\texpected wording of leak warning.\n+\t* gcc.dg/analyzer/malloc-in-loop.c: New test.\n+\t* gcc.dg/analyzer/malloc-ipa-8-double-free.c: Update expected path\n+\tto show call to wrapped_malloc.\n+\t* gcc.dg/analyzer/malloc-ipa-8-unchecked.c: Remove\n+\t-fanalyzer-verbose-state-changes.\n+\t* gcc.dg/analyzer/malloc-paths-9.c: Remove comment about duplicate\n+\twarnings.  Remove duplicate use-after-free paths.\n+\t* gcc.dg/analyzer/malloc-vs-local-1a.c: Add dg-warning for deref\n+\tof unchecked pointer.  Update expected number of enodes.\n+\t* gcc.dg/analyzer/malloc-vs-local-2.c: Likewise.\n+\t* gcc.dg/analyzer/malloc-vs-local-3.c: Add dg-warning for deref of\n+\tunchecked pointer.  Update expected number of enodes.  Avoid\n+\toverspecifying the leak message.\n+\t* gcc.dg/analyzer/memset-1.c: New test.\n+\t* gcc.dg/analyzer/paths-3.c: Update expected number of enodes.\n+\t* gcc.dg/analyzer/paths-4.c: Likewise.\n+\t* gcc.dg/analyzer/paths-6.c: Likewise.\n+\t* gcc.dg/analyzer/paths-7.c: Likewise.\n+\t* gcc.dg/analyzer/pr93032-mztools-simplified.c: New test.\n+\t* gcc.dg/analyzer/pr93032-mztools.c: New test.\n+\t* gcc.dg/analyzer/pr93382.c: Mark taint tests as failing.\n+\t* gcc.dg/analyzer/pr93938.c: New test.\n+\t* gcc.dg/analyzer/pr94099.c: Replace uninit dg-warning with\n+\tdg-warning for NULL dereference.\n+\t* gcc.dg/analyzer/pr94399.c: New test.\n+\t* gcc.dg/analyzer/pr94447.c: Add dg-warning for NULL dereference.\n+\t* gcc.dg/analyzer/pr94458.c: New test.\n+\t* gcc.dg/analyzer/pr94640.c: New test.\n+\t* gcc.dg/analyzer/pr94688.c: New test.\n+\t* gcc.dg/analyzer/pr94689.c: New test.\n+\t* gcc.dg/analyzer/pr94839.c: New test.\n+\t* gcc.dg/analyzer/pr95026.c: New test.\n+\t* gcc.dg/analyzer/pr95240.c: New test.\n+\t* gcc.dg/analyzer/refcounting-1.c: New test.\n+\t* gcc.dg/analyzer/single-field.c: New test.\n+\t* gcc.dg/analyzer/stale-frame-1.c: New test.\n+\t* gcc.dg/analyzer/symbolic-1.c: New test.\n+\t* gcc.dg/analyzer/symbolic-2.c: New test.\n+\t* gcc.dg/analyzer/symbolic-3.c: New test.\n+\t* gcc.dg/analyzer/symbolic-4.c: New test.\n+\t* gcc.dg/analyzer/symbolic-5.c: New test.\n+\t* gcc.dg/analyzer/symbolic-6.c: New test.\n+\t* gcc.dg/analyzer/taint-1.c: Mark the \"gets unchecked value\"\n+\tevents as failing for now.  Update dg-message directives to avoid\n+\trelying on numbering.\n+\t* gcc.dg/analyzer/torture/loop-inc-ptr-1.c: New test.\n+\t* gcc.dg/analyzer/torture/loop-inc-ptr-2.c: New test.\n+\t* gcc.dg/analyzer/torture/loop-inc-ptr-3.c: New test.\n+\t* gcc.dg/analyzer/unknown-fns-2.c: New test.\n+\t* gcc.dg/analyzer/unknown-fns-3.c: New test.\n+\t* gcc.dg/analyzer/unknown-fns-4.c: New test.\n+\t* gcc.dg/analyzer/unknown-fns.c: Update dg-warning to reflect fixed\n+\tsource location for leak diagnostic.\n+\t* gcc.dg/analyzer/use-after-free.c: New test.\n+\t* gcc.dg/analyzer/vla-1.c: New test.\n+\t* gcc.dg/analyzer/zlib-4.c: Rewrite to avoid \"exit\" calls.  Add\n+\texpected leak warnings.\n+\t* gfortran.dg/analyzer/pr93993.f90: Remove leak of tm warning,\n+\twhich seems to have been a false positive.\n+\n+2020-08-13  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\tPR target/96506\n+\t* gcc.target/powerpc/pr96506.c: New test.\n+\n+2020-08-13  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/93671\n+\t* gfortran.dg/coarray/pr93671.f90: New test.\n+\n+2020-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tRevert:\n+\t2020-08-13  Peixin Qiao  <qiaopeixin@huawei.com>\n+\n+\t* gcc.target/aarch64/mgeneral-regs_1.c: Add the comment that\n+\t-mgeneral-regs-only is compatible with the use of vector type\n+\tused in the test case.\n+\n+2020-08-13  Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* gcc.target/nvptx/ia64-sync-5.c: New.\n+\n+2020-08-13  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/96482\n+\t* gcc.dg/ipa/pr96482-2.c: New test.\n+\n+2020-08-13  Hongtao Liu  <hongtao.liu@intel.com>\n+\n+\t* gcc.target/i386/avx512bw-pr96246-1.c: New test.\n+\t* gcc.target/i386/avx512bw-pr96246-2.c: New test.\n+\t* gcc.target/i386/avx512vl-pr96246-1.c: New test.\n+\t* gcc.target/i386/avx512vl-pr96246-2.c: New test.\n+\t* gcc.target/i386/avx512bw-vmovdqu16-1.c: Adjust test.\n+\t* gcc.target/i386/avx512bw-vmovdqu8-1.c: Ditto.\n+\t* gcc.target/i386/avx512f-vmovapd-1.c: Ditto.\n+\t* gcc.target/i386/avx512f-vmovaps-1.c: Ditto.\n+\t* gcc.target/i386/avx512f-vmovdqa32-1.c: Ditto.\n+\t* gcc.target/i386/avx512f-vmovdqa64-1.c: Ditto.\n+\t* gcc.target/i386/avx512vl-pr92686-movcc-1.c: Ditto.\n+\t* gcc.target/i386/avx512vl-pr96246-1.c: Ditto.\n+\t* gcc.target/i386/avx512vl-pr96246-2.c: Ditto.\n+\t* gcc.target/i386/avx512vl-vmovapd-1.c: Ditto.\n+\t* gcc.target/i386/avx512vl-vmovaps-1.c: Ditto.\n+\t* gcc.target/i386/avx512vl-vmovdqa32-1.c: Ditto.\n+\t* gcc.target/i386/avx512vl-vmovdqa64-1.c: Ditto.\n+\n+2020-08-13  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tPR middle-end/94600\n+\t* gcc.dg/pr94600-5.c, gcc.dg/pr94600-6.c, gcc.dg/pr94600-7.c,\n+\tgcc.dg/pr94600-8.c: Align t0 to 4-byte boundary.\n+\n+2020-08-13  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/92812\n+\t* g++.dg/cpp2a/paren-init27.C: New test.\n+\t* g++.dg/cpp2a/paren-init28.C: New test.\n+\t* g++.dg/cpp2a/paren-init29.C: New test.\n+\t* g++.dg/cpp2a/paren-init30.C: New test.\n+\t* g++.dg/cpp2a/paren-init31.C: New test.\n+\t* g++.dg/cpp2a/paren-init32.C: New test.\n+\n 2020-08-12  Roger Sayle  <roger@nextmovesoftware.com>\n \t    Uro\u0161 Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "56038176efa472da54d724cdba64020a1c4b522a", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,7 @@\n+2020-08-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libcp1plugin.cc (plugin_build_dependent_expr): Likewise.\n+\n 2020-07-30  H.J. Lu  <hjl.tools@gmail.com>\n \n \tPR bootstrap/96202"}, {"sha": "588b6f44051c22c34b0aaed198d8bb1756cc5eac", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,8 @@\n+2020-08-13  Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* config/nvptx/atomic.c: New.\n+\t* config/nvptx/t-nvptx (LIB2ADD): Add atomic.c.\n+\n 2020-08-03  Ian Lance Taylor  <iant@golang.org>\n \n \t* config/i386/morestack.S (BACKOFF) [x86_64]: Add 2048 bytes."}, {"sha": "2c18cdab0be6fa5e84f2b9d495da4f8929449218", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,13 @@\n+2020-08-13  Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* testsuite/libgomp.c-c++-common/reduction-16.c: New.\n+\n+2020-08-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c/loop-22.c (main): Add some further tests.\n+\t* testsuite/libgomp.c/loop-23.c (main): Likewise.\n+\t* testsuite/libgomp.c/loop-24.c: New test.\n+\n 2020-08-08  Jakub Jelinek  <jakub@redhat.com>\n \t    Tobias Burnus  <tobias@codesourcery.com>\n "}, {"sha": "9c7fc0ebbd15639f11a9d9d1517e0f87a96141a6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3cb56060bcdc1cf4d38aa30b5017b802822f8c0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b3cb56060bcdc1cf4d38aa30b5017b802822f8c0", "patch": "@@ -1,3 +1,10 @@\n+2020-08-13  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* acinclude.m4 (GLIBCXX_ENABLE_CHEADERS): Warn if the c_std\n+\toption is used and fail unless --enable-cheaders-obsolete is\n+\talso used.\n+\t* configure: Regenerate.\n+\n 2020-08-12  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/85828"}]}