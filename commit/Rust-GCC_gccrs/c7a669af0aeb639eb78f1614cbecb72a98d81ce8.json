{"sha": "c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhNjY5YWYwYWViNjM5ZWI3OGYxNjE0Y2JlY2I3MmE5OGQ4MWNlOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-11T15:33:25Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-13T14:34:48Z"}, "message": "Remove references to FSM threads.\n\nNow that the jump thread back registry has been split into the generic\ncopier and the custom (old) copier, it becomes trivial to remove the\nFSM bits from the jump threaders.\n\nFirst, there's no need for an EDGE_FSM_THREAD type.  The only reason\nwe were looking at the threading type was to determine what type of\ncopier to use, and now that the copier has been split, there's no need\nto even look.  However, there is one check in register_jump_thread\nwhere we verify that only the generic copier can thread through\nback-edges.  I've removed that check in favor of a flag passed to the\nconstructor.\n\nI've also removed all the FSM references from the code and tests.\nInterestingly, some tests weren't even testing the right thing.  They\nwere testing for \"FSM\" which would catch jump thread paths as well as\nthe backward threader *failing* on registering a path.  *big eye roll*\n\nThe only remaining code that was actually checking for EDGE_FSM_THREAD\nwas adjust_paths_after_duplication, and the checks could be written\nwithout looking at the edge type at all.  For the record, the code\nthere is horrible: it's convoluted, hard to read, and doesn't have any\ntests.  I'd smack myself if I could go back in time.\n\nAll that remains are the FSM references in the --param's themselves.\nI think we should s/fsm/threader/, since I envision a day when we can\nshare the cost basis code between the threaders.  However, I don't\nknow what the proper procedure is for renaming existing compiler\noptions.\n\nBy the way, param_fsm_maximum_phi_arguments is no longer relevant\nafter the rewrite.  We can nuke that one right away.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c\n\t(back_threader_profitability::profitable_path_p): Remove FSM\n\treferences.\n\t(back_threader_registry::register_path): Same.\n\t* tree-ssa-threadedge.c\n\t(jump_threader::simplify_control_stmt_condition): Same.\n\t* tree-ssa-threadupdate.c (jt_path_registry::jt_path_registry):\n\tAdd backedge_threads argument.\n\t(fwd_jt_path_registry::fwd_jt_path_registry): Pass\n\tbackedge_threads argument.\n\t(back_jt_path_registry::back_jt_path_registry):  Same.\n\t(dump_jump_thread_path): Adjust for FSM removal.\n\t(back_jt_path_registry::rewire_first_differing_edge): Same.\n\t(back_jt_path_registry::adjust_paths_after_duplication): Same.\n\t(back_jt_path_registry::update_cfg): Same.\n\t(jt_path_registry::register_jump_thread): Same.\n\t* tree-ssa-threadupdate.h (enum jump_thread_edge_type): Remove\n\tEDGE_FSM_THREAD.\n\t(class back_jt_path_registry): Add backedge_threads to\n\tconstructor.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr21417.c: Adjust for FSM removal.\n\t* gcc.dg/tree-ssa/pr66752-3.c: Same.\n\t* gcc.dg/tree-ssa/pr68198.c: Same.\n\t* gcc.dg/tree-ssa/pr69196-1.c: Same.\n\t* gcc.dg/tree-ssa/pr70232.c: Same.\n\t* gcc.dg/tree-ssa/pr77445.c: Same.\n\t* gcc.dg/tree-ssa/ranger-threader-4.c: Same.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-18.c: Same.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-6.c: Same.\n\t* gcc.dg/tree-ssa/ssa-thread-12.c: Same.\n\t* gcc.dg/tree-ssa/ssa-thread-13.c: Same.", "tree": {"sha": "a696301076a76ac2f3a927db342d94b700b0ff33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a696301076a76ac2f3a927db342d94b700b0ff33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8b2b89358481d36755dbc99e585a251780453b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b2b89358481d36755dbc99e585a251780453b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8b2b89358481d36755dbc99e585a251780453b0"}], "stats": {"total": 171, "additions": 85, "deletions": 86}, "files": [{"sha": "b934c9c73d5657bbb7d9162be4d711ec8c51c147", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21417.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21417.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -49,5 +49,5 @@ test (tree expr, int t, int D17630)\n /* We should thread the backedge to the top of the loop; ie we only\n    execute the if (expr->common.code != 142) test once per loop\n    iteration.  */\n-/* { dg-final { scan-tree-dump-times \"FSM jump thread\" 1 \"thread4\" } } */\n+/* { dg-final { scan-tree-dump-times \"jump thread\" 1 \"thread4\" } } */\n "}, {"sha": "e1464e21170c1fb331a5240ad0d9f7e8b56381a2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66752-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -32,9 +32,9 @@ foo (int N, int c, int b, int *a)\n    pt--;\n }\n \n-/* There are 4 FSM jump threading opportunities, all of which will be\n+/* There are 4 jump threading opportunities, all of which will be\n    realized, which will eliminate testing of FLAG, completely.  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM\" 4 \"thread1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 4 \"thread1\"} } */\n \n /* There should be no assignments or references to FLAG, verify they're\n    eliminated as early as possible.  */"}, {"sha": "af8b7a5bc5777c8cbd1e85dd06cce5e785f62d03", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68198.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -37,5 +37,5 @@ c_finish_omp_clauses (tree clauses)\n     }\n }\n \n-/* There are 3 FSM jump threading opportunities.  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM\" 3 \"thread1\"} } */\n+/* There are 3 jump threading opportunities.  */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 3 \"thread1\"} } */"}, {"sha": "dfabb483bcd180bca2cc3dcc0f5420b13cddc277", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr69196-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69196-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69196-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69196-1.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile { target sparc*-*-* i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -fdump-tree-thread1-details -fdisable-tree-ethread\" } */\n \n-/* { dg-final { scan-tree-dump \"FSM did not thread around loop and would copy too many statements\" \"thread1\" } } */\n+/* { dg-final { scan-tree-dump \"Did not thread around loop and would copy too many statements\" \"thread1\" } } */\n \n \n typedef __builtin_va_list __gnuc_va_list;"}, {"sha": "d636672fddcb515fe41487b149b24070e1868970", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr70232.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr70232.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr70232.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr70232.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -1,12 +1,12 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -w -fdump-tree-vrp1-details -fdump-tree-vrp2-details -fdump-tree-dom2-details -fdump-tree-dom3-details\" } */\n \n-/* All the threads found by the FSM threader should have too\n-   many statements to be profitable.  */\n-/* { dg-final { scan-tree-dump-not \"Registering FSM \" \"dom2\"} } */\n-/* { dg-final { scan-tree-dump-not \"Registering FSM \" \"dom3\"} } */\n-/* { dg-final { scan-tree-dump-not \"Registering FSM \" \"vrp1\"} } */\n-/* { dg-final { scan-tree-dump-not \"Registering FSM \" \"vrp2\"} } */\n+/* All the threads found by the threader should have too many\n+   statements to be profitable.  */\n+/* { dg-final { scan-tree-dump-not \"Registering jump \" \"dom2\"} } */\n+/* { dg-final { scan-tree-dump-not \"Registering jump \" \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-not \"Registering jump \" \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Registering jump \" \"vrp2\"} } */\n \n typedef _Bool bool;\n typedef unsigned char uint8_t;"}, {"sha": "883a63d70fc80b9d0ae7556a1f40225691a008c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77445.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -25,5 +25,5 @@ main (int argc)\n   if (b)\n     test2 ();\n }\n-/* { dg-final { scan-tree-dump-times \"Registering FSM jump thread\" 2 \"thread3\" } } */\n+/* { dg-final { scan-tree-dump-times \"Registering jump thread\" 2 \"thread3\" } } */\n /* { dg-final { scan-tree-dump-not \"Invalid sum\" \"thread3\" } } */"}, {"sha": "d5aa2e8912861a71f16037ee3cbf5f4286d28fe0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ranger-threader-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Franger-threader-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Franger-threader-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Franger-threader-4.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-additional-options \"-O2 -fdump-tree-vrp-details -fdump-tree-thread1-details --param logical-op-non-short-circuit=1\" }  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 8 \"thread1\" } }  */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 8 \"thread1\" } }  */\n \n /* Copied from ssa-thread-14.  */\n "}, {"sha": "60d4f76f076625ace9b6b2e7c7cfe01e4a3a0ee8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-18.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-18.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -21,5 +21,5 @@\n \t condition.\n \n    All the cases are picked up by VRP1 as jump threads.  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 6 \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 6 \"thread1\" } } */\n /* { dg-final { scan-tree-dump-times \"Threaded\" 2 \"vrp1\" } } */"}, {"sha": "b0a7d42347571cc8cf00cb968d50a8e73f3291c6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-thread1-details -fdump-tree-thread3-details\" } */\n \n-/* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 6 \"thread1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 1 \"thread3\" } } */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 6 \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 1 \"thread3\" } } */\n \n int sum0, sum1, sum2, sum3;\n int foo (char *s, char **ret)"}, {"sha": "08c0b8d3bcc6c4546468d86c5999f26be9ad0bda", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-12.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -1,8 +1,7 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread2-details -fdump-tree-thread3-details -fdump-tree-thread4-details -fno-finite-loops --param early-inlining-insns=14 -fno-inline-functions\" } */\n-/* { dg-final { scan-tree-dump \"FSM\" \"thread2\" } } */\n-/* { dg-final { scan-tree-dump \"FSM\" \"thread3\" } } */\n-/* { dg-final { scan-tree-dump \"FSM\" \"thread4\" } } */\n+/* { dg-options \"-O2 -fdump-tree-thread3-details -fdump-tree-thread4-details -fno-finite-loops --param early-inlining-insns=14 -fno-inline-functions\" } */\n+/* { dg-final { scan-tree-dump \"Registering jump thread\" \"thread3\" } } */\n+/* { dg-final { scan-tree-dump \"Registering jump thread\" \"thread4\" } } */\n \n typedef struct bitmap_head_def *bitmap;\n typedef const struct bitmap_head_def *const_bitmap;"}, {"sha": "ad38b8925c713d09f1c97f6070421de8ad622a99", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-13.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-ethread-details\" } */\n-/* { dg-final { scan-tree-dump \"FSM\" \"ethread\" } } */\n+/* { dg-final { scan-tree-dump \"Registering jump thread\" \"ethread\" } } */\n \n typedef struct rtx_def *rtx;\n typedef const struct rtx_def *const_rtx;"}, {"sha": "805b7ac5ef6a2f33cbc4d16c20fa1098b078e120", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -593,7 +593,7 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n   if (m_path.length () > (unsigned) param_max_fsm_thread_length)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n+\tfprintf (dump_file, \"  FAIL: Jump-thread path not considered: \"\n \t\t \"the number of basic blocks on the path \"\n \t\t \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n       return false;\n@@ -768,7 +768,7 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n   if (path_crosses_loops)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n+\tfprintf (dump_file, \"  FAIL: Jump-thread path not considered: \"\n \t\t \"the path crosses loops.\\n\");\n       return false;\n     }\n@@ -784,7 +784,7 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n       if (n_insns >= param_max_fsm_thread_path_insns)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n+\t    fprintf (dump_file, \"  FAIL: Jump-thread path not considered: \"\n \t\t     \"the number of instructions on the path \"\n \t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n \t  return false;\n@@ -793,7 +793,7 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n   else if (!m_speed_p && n_insns > 1)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n+\tfprintf (dump_file, \"  FAIL: Jump-thread path not considered: \"\n \t\t \"duplication of %i insns is needed and optimizing for size.\\n\",\n \t\t n_insns);\n       return false;\n@@ -818,25 +818,22 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"  FAIL: FSM would create irreducible loop without threading \"\n+\t\t \"  FAIL: Would create irreducible loop without threading \"\n \t\t \"multiway branch.\\n\");\n       return false;\n     }\n \n-  /* If this path does not thread through the loop latch, then we are\n-     using the FSM threader to find old style jump threads.  This\n-     is good, except the FSM threader does not re-use an existing\n-     threading path to reduce code duplication.\n-\n-     So for that case, drastically reduce the number of statements\n-     we are allowed to copy.  */\n+  /* The generic copier used by the backthreader does not re-use an\n+     existing threading path to reduce code duplication.  So for that\n+     case, drastically reduce the number of statements we are allowed\n+     to copy.  */\n   if (!(threaded_through_latch && threaded_multiway_branch)\n       && (n_insns * param_fsm_scale_path_stmts\n \t  >= param_max_jump_thread_duplication_stmts))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"  FAIL: FSM did not thread around loop and would copy too \"\n+\t\t \"  FAIL: Did not thread around loop and would copy too \"\n \t\t \"many statements.\\n\");\n       return false;\n     }\n@@ -849,7 +846,7 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"  FAIL: FSM Thread through multiway branch without threading \"\n+\t\t \"  FAIL: Thread through multiway branch without threading \"\n \t\t \"a multiway branch.\\n\");\n       return false;\n     }\n@@ -865,7 +862,7 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"  FAIL: FSM Thread through latch before loop opts would create non-empty latch\\n\");\n+\t\t \"  FAIL: Thread through latch before loop opts would create non-empty latch\\n\");\n       return false;\n \n     }\n@@ -887,16 +884,17 @@ back_threader_registry::register_path (const vec<basic_block> &m_path,\n   if (m_threaded_paths > m_max_allowable_paths)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n-\t\t \"the number of previously recorded FSM paths to \"\n+\tfprintf (dump_file, \"  FAIL: Jump-thread path not considered: \"\n+\t\t \"the number of previously recorded paths to \"\n \t\t \"thread exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n       return false;\n     }\n \n   vec<jump_thread_edge *> *jump_thread_path\n     = m_lowlevel_registry.allocate_thread_path ();\n \n-  /* Record the edges between the blocks in PATH.  */\n+  // The generic copier ignores the edge type.  We can build the\n+  // thread edges with any type.\n   for (unsigned int j = 0; j + 1 < m_path.length (); j++)\n     {\n       basic_block bb1 = m_path[m_path.length () - j - 1];\n@@ -905,11 +903,10 @@ back_threader_registry::register_path (const vec<basic_block> &m_path,\n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n       jump_thread_edge *x\n-\t= m_lowlevel_registry.allocate_thread_edge (e, EDGE_FSM_THREAD);\n+\t= m_lowlevel_registry.allocate_thread_edge (e, EDGE_COPY_SRC_BLOCK);\n       jump_thread_path->safe_push (x);\n     }\n \n-  /* Add the edge taken when the control variable has value ARG.  */\n   jump_thread_edge *x\n     = m_lowlevel_registry.allocate_thread_edge (taken_edge,\n \t\t\t\t\t\tEDGE_NO_COPY_SRC_BLOCK);"}, {"sha": "2b9a4c31592d6a3d3e8f372e2ff6725127ecf8e3", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -456,17 +456,17 @@ jump_threader::simplify_control_stmt_condition (edge e, gimple *stmt)\n \t= simplify_control_stmt_condition_1 (e, stmt, op0, cond_code, op1,\n \t\t\t\t\t     recursion_limit);\n \n-      /* If we were testing an integer/pointer against a constant, then\n-\t we can use the FSM code to trace the value of the SSA_NAME.  If\n-\t a value is found, then the condition will collapse to a constant.\n+      /* If we were testing an integer/pointer against a constant,\n+\t then we can trace the value of the SSA_NAME.  If a value is\n+\t found, then the condition will collapse to a constant.\n \n \t Return the SSA_NAME we want to trace back rather than the full\n-\t expression and give the FSM threader a chance to find its value.  */\n+\t expression and give the threader a chance to find its value.  */\n       if (cached_lhs == NULL)\n \t{\n \t  /* Recover the original operands.  They may have been simplified\n \t     using context sensitive equivalences.  Those context sensitive\n-\t     equivalences may not be valid on paths found by the FSM optimizer.  */\n+\t     equivalences may not be valid on paths.  */\n \t  tree op0 = gimple_cond_lhs (stmt);\n \t  tree op1 = gimple_cond_rhs (stmt);\n "}, {"sha": "c5a742312ef09335a1cb0d829b3a3696608a16e7", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -167,10 +167,11 @@ jump_thread_path_allocator::allocate_thread_path ()\n   return new (r) vec<jump_thread_edge *> ();\n }\n \n-jt_path_registry::jt_path_registry ()\n+jt_path_registry::jt_path_registry (bool backedge_threads)\n {\n   m_paths.create (5);\n   m_num_threaded_edges = 0;\n+  m_backedge_threads = backedge_threads;\n }\n \n jt_path_registry::~jt_path_registry ()\n@@ -179,6 +180,7 @@ jt_path_registry::~jt_path_registry ()\n }\n \n fwd_jt_path_registry::fwd_jt_path_registry ()\n+  : jt_path_registry (/*backedge_threads=*/false)\n {\n   m_removed_edges = new hash_table<struct removed_edges> (17);\n   m_redirection_data = NULL;\n@@ -189,6 +191,11 @@ fwd_jt_path_registry::~fwd_jt_path_registry ()\n   delete m_removed_edges;\n }\n \n+back_jt_path_registry::back_jt_path_registry ()\n+  : jt_path_registry (/*backedge_threads=*/true)\n+{\n+}\n+\n jump_thread_edge *\n jt_path_registry::allocate_thread_edge (edge e, jump_thread_edge_type t)\n {\n@@ -210,9 +217,8 @@ dump_jump_thread_path (FILE *dump_file,\n \t\t       bool registering)\n {\n   fprintf (dump_file,\n-\t   \"  %s%s jump thread: (%d, %d) incoming edge; \",\n+\t   \"  %s jump thread: (%d, %d) incoming edge; \",\n \t   (registering ? \"Registering\" : \"Cancelling\"),\n-\t   (path[0]->type == EDGE_FSM_THREAD ? \" FSM\": \"\"),\n \t   path[0]->e->src->index, path[0]->e->dest->index);\n \n   for (unsigned int i = 1; i < path.length (); i++)\n@@ -224,20 +230,24 @@ dump_jump_thread_path (FILE *dump_file,\n       if (path[i]->e == NULL)\n \tcontinue;\n \n-      if (path[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-\tfprintf (dump_file, \" (%d, %d) joiner; \",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n-      if (path[i]->type == EDGE_COPY_SRC_BLOCK)\n-       fprintf (dump_file, \" (%d, %d) normal;\",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n-      if (path[i]->type == EDGE_NO_COPY_SRC_BLOCK)\n-       fprintf (dump_file, \" (%d, %d) nocopy;\",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n-      if (path[0]->type == EDGE_FSM_THREAD)\n-\tfprintf (dump_file, \" (%d, %d) \",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+      fprintf (dump_file, \" (%d, %d) \",\n+\t       path[i]->e->src->index, path[i]->e->dest->index);\n+      switch (path[i]->type)\n+\t{\n+\tcase EDGE_COPY_SRC_JOINER_BLOCK:\n+\t  fprintf (dump_file, \"joiner\");\n+\t  break;\n+\tcase EDGE_COPY_SRC_BLOCK:\n+\t  fprintf (dump_file, \"normal\");\n+\t  break;\n+\tcase EDGE_NO_COPY_SRC_BLOCK:\n+\t  fprintf (dump_file, \"nocopy\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n-  fputc ('\\n', dump_file);\n+  fprintf (dump_file, \"; \\n\");\n }\n \n DEBUG_FUNCTION void\n@@ -2256,8 +2266,8 @@ back_jt_path_registry::rewire_first_differing_edge (unsigned path_num,\n   return true;\n }\n \n-/* After an FSM path has been jump threaded, adjust the remaining FSM\n-   paths that are subsets of this path, so these paths can be safely\n+/* After a path has been jump threaded, adjust the remaining paths\n+   that are subsets of this path, so these paths can be safely\n    threaded within the context of the new threaded path.\n \n    For example, suppose we have just threaded:\n@@ -2293,10 +2303,9 @@ back_jt_path_registry::adjust_paths_after_duplication (unsigned curr_path_num)\n \t  continue;\n \t}\n       /* Make sure the candidate to adjust starts with the same path\n-\t as the recently threaded path and is an FSM thread.  */\n+\t as the recently threaded path.  */\n       vec<jump_thread_edge *> *cand_path = m_paths[cand_path_num];\n-      if ((*cand_path)[0]->type != EDGE_FSM_THREAD\n-\t  || (*cand_path)[0]->e != (*curr_path)[0]->e)\n+      if ((*cand_path)[0]->e != (*curr_path)[0]->e)\n \t{\n \t  ++cand_path_num;\n \t  continue;\n@@ -2350,16 +2359,11 @@ back_jt_path_registry::adjust_paths_after_duplication (unsigned curr_path_num)\n \t      m_paths.unordered_remove (cand_path_num);\n \t      continue;\n \t    }\n-\t  if ((*cand_path)[j]->type != EDGE_FSM_THREAD)\n-\t    {\n-\t      /* If all the EDGE_FSM_THREADs are common, all that's\n-\t\t left is the final EDGE_NO_COPY_SRC_BLOCK.  */\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"Dropping illformed candidate.\\n\");\n-\t    }\n-\t  else\n-\t    /* Otherwise, just remove the redundant sub-path.  */\n+\t  /* Otherwise, just remove the redundant sub-path.  */\n+\t  if (cand_path->length () - j > 1)\n \t    cand_path->block_remove (0, j);\n+\t  else if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Dropping illformed candidate.\\n\");\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -2616,8 +2620,6 @@ back_jt_path_registry::update_cfg (bool /*peel_loop_headers*/)\n       vec<jump_thread_edge *> *path = m_paths[0];\n       edge entry = (*path)[0]->e;\n \n-      gcc_checking_assert ((*path)[0]->type == EDGE_FSM_THREAD);\n-\n       /* Do not jump-thread twice from the same starting edge.\n \n \t Previously we only checked that we weren't threading twice\n@@ -2631,7 +2633,7 @@ back_jt_path_registry::update_cfg (bool /*peel_loop_headers*/)\n \t     various reasons.  So check it first.  */\n \t  || !valid_jump_thread_path (path))\n \t{\n-\t  /* Remove invalid FSM jump-thread paths.  */\n+\t  /* Remove invalid jump-thread paths.  */\n \t  cancel_thread (path, \"Avoiding threading twice from same edge\");\n \t  m_paths.unordered_remove (0);\n \t  continue;\n@@ -2782,10 +2784,7 @@ jt_path_registry::register_jump_thread (vec<jump_thread_edge *> *path)\n \t  return false;\n \t}\n \n-      /* Only the FSM threader is allowed to thread across\n-\t backedges in the CFG.  */\n-      if (flag_checking\n-\t  && (*path)[0]->type != EDGE_FSM_THREAD)\n+      if (flag_checking && !m_backedge_threads)\n \tgcc_assert (((*path)[i]->e->flags & EDGE_DFS_BACK) == 0);\n     }\n "}, {"sha": "94c9bc8d3bb1a9de71af9bcb707dd1b064991257", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a669af0aeb639eb78f1614cbecb72a98d81ce8/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=c7a669af0aeb639eb78f1614cbecb72a98d81ce8", "patch": "@@ -24,7 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n enum jump_thread_edge_type\n {\n   EDGE_START_JUMP_THREAD,\n-  EDGE_FSM_THREAD,\n   EDGE_COPY_SRC_BLOCK,\n   EDGE_COPY_SRC_JOINER_BLOCK,\n   EDGE_NO_COPY_SRC_BLOCK\n@@ -63,7 +62,7 @@ class jump_thread_path_allocator\n class jt_path_registry\n {\n public:\n-  jt_path_registry ();\n+  jt_path_registry (bool backedge_threads);\n   virtual ~jt_path_registry ();\n   bool register_jump_thread (vec<jump_thread_edge *> *);\n   bool thread_through_all_blocks (bool peel_loop_headers);\n@@ -77,6 +76,9 @@ class jt_path_registry\n private:\n   virtual bool update_cfg (bool peel_loop_headers) = 0;\n   jump_thread_path_allocator m_allocator;\n+  // True if threading through back edges is allowed.  This is only\n+  // allowed in the generic copier in the backward threader.\n+  bool m_backedge_threads;\n   DISABLE_COPY_AND_ASSIGN (jt_path_registry);\n };\n \n@@ -107,6 +109,8 @@ class fwd_jt_path_registry : public jt_path_registry\n \n class back_jt_path_registry : public jt_path_registry\n {\n+public:\n+  back_jt_path_registry ();\n private:\n   bool update_cfg (bool peel_loop_headers) override;\n   void adjust_paths_after_duplication (unsigned curr_path_num);"}]}