{"sha": "729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5MjMyZGIwYjYzMGZmYjBhMTdkZmNmYTA4NTBmZjY4YWMzNWJiZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-07T04:14:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-07T04:14:35Z"}, "message": "compiler: stack allocate storage for temp slices.\n\n    \n    During the lowering phase, the variable arguments to a varargs call are\n    packaged up into a temporary slice object; the storage for this slice\n    was being unconditionally allocated on the heap.  Heap allocation is not\n    necessary, however, if the varargs call correspond to an \"append\", since\n    the append runtime routine only reads the slice storage (as opposed to\n    stashing away the storage pointer). Enhance the lowering code to keep\n    the slice storage on the stack for append() calls, to improve\n    performance.\n    \n    Addresses issue golang/go#17304.\n    \n    Reviewed-on: https://go-review.googlesource.com/30136\n\nFrom-SVN: r240853", "tree": {"sha": "06aaffbdacfd5be9e586426511018c5a5da5e1a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06aaffbdacfd5be9e586426511018c5a5da5e1a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/comments", "author": null, "committer": null, "parents": [{"sha": "c9616e9af9b1b7e8d9fa2c3ce5688fa98fcb6504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9616e9af9b1b7e8d9fa2c3ce5688fa98fcb6504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9616e9af9b1b7e8d9fa2c3ce5688fa98fcb6504"}], "stats": {"total": 168, "additions": 144, "deletions": 24}, "files": [{"sha": "dc9e1f4942e891bcee9490a4a2244e059a015eeb", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "patch": "@@ -1,4 +1,4 @@\n-60b84be3fa146d821dcd3939dad6336c89432cff\n+2431267d513804a3b1aa71adde9aefba9e3c3c59\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "343d354b8a1f0448191d58856439456045f14d3f", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 97, "deletions": 21, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "patch": "@@ -6977,7 +6977,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \tType* element_type = slice_type->array_type()->element_type();\n \tthis->lower_varargs(gogo, function, inserter,\n \t\t\t    Type::make_array_type(element_type, NULL),\n-\t\t\t    2);\n+\t\t\t    2, SLICE_STORAGE_DOES_NOT_ESCAPE);\n       }\n       break;\n \n@@ -8853,7 +8853,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n       go_assert(parameters != NULL && !parameters->empty());\n       Type* varargs_type = parameters->back().type();\n       this->lower_varargs(gogo, function, inserter, varargs_type,\n-\t\t\t  parameters->size());\n+\t\t\t  parameters->size(), SLICE_STORAGE_MAY_ESCAPE);\n     }\n \n   // If this is call to a method, call the method directly passing the\n@@ -8958,7 +8958,8 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n void\n Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t\t\t       Statement_inserter* inserter,\n-\t\t\t       Type* varargs_type, size_t param_count)\n+\t\t\t       Type* varargs_type, size_t param_count,\n+                               Slice_storage_escape_disp escape_disp)\n {\n   if (this->varargs_are_lowered_)\n     return;\n@@ -9027,8 +9028,11 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \t\tcontinue;\n \t      vals->push_back(*pa);\n \t    }\n-\t  Expression* val =\n+\t  Slice_construction_expression* sce =\n \t    Expression::make_slice_composite_literal(varargs_type, vals, loc);\n+\t  if (escape_disp == SLICE_STORAGE_DOES_NOT_ESCAPE)\n+\t      sce->set_storage_does_not_escape();\n+          Expression* val = sce;\n \t  gogo->lower_expression(function, inserter, &val);\n \t  new_args->push_back(val);\n \t}\n@@ -12280,7 +12284,7 @@ Array_construction_expression::do_export(Export* exp) const\n   exp->write_c_string(\")\");\n }\n \n-// Dump ast representation of an array construction expressin.\n+// Dump ast representation of an array construction expression.\n \n void\n Array_construction_expression::do_dump_expression(\n@@ -12295,6 +12299,7 @@ Array_construction_expression::do_dump_expression(\n     }\n   ast_dump_context->ostream() << \"]\" ;\n   ast_dump_context->dump_type(this->type_);\n+  this->dump_slice_storage_expression(ast_dump_context);\n   ast_dump_context->ostream() << \"{\" ;\n   if (this->indexes_ == NULL)\n     ast_dump_context->dump_expression_list(this->vals_);\n@@ -12350,7 +12355,8 @@ Slice_construction_expression::Slice_construction_expression(\n   Expression_list* vals, Location location)\n   : Array_construction_expression(EXPRESSION_SLICE_CONSTRUCTION,\n \t\t\t\t  type, indexes, vals, location),\n-    valtype_(NULL)\n+    valtype_(NULL), array_val_(NULL), slice_storage_(NULL),\n+    storage_escapes_(true)\n {\n   go_assert(type->is_slice_type());\n \n@@ -12371,7 +12377,6 @@ Slice_construction_expression::Slice_construction_expression(\n   this->valtype_ = Type::make_array_type(element_type, length);\n }\n \n-\n // Traversal.\n \n int\n@@ -12382,23 +12387,29 @@ Slice_construction_expression::do_traverse(Traverse* traverse)\n     return TRAVERSE_EXIT;\n   if (Type::traverse(this->valtype_, traverse) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n+  if (this->array_val_ != NULL\n+      && Expression::traverse(&this->array_val_, traverse) == TRAVERSE_EXIT)\n+    return TRAVERSE_EXIT;\n+  if (this->slice_storage_ != NULL\n+      && Expression::traverse(&this->slice_storage_, traverse) == TRAVERSE_EXIT)\n+    return TRAVERSE_EXIT;\n   return TRAVERSE_CONTINUE;\n }\n \n-// Return the backend representation for constructing a slice.\n+// Helper routine to create fixed array value underlying the slice literal.\n+// May be called during flattening, or later during do_get_backend().\n \n-Bexpression*\n-Slice_construction_expression::do_get_backend(Translate_context* context)\n+Expression*\n+Slice_construction_expression::create_array_val()\n {\n   Array_type* array_type = this->type()->array_type();\n   if (array_type == NULL)\n     {\n       go_assert(this->type()->is_error());\n-      return context->backend()->error_expression();\n+      return NULL;\n     }\n \n   Location loc = this->location();\n-  Type* element_type = array_type->element_type();\n   go_assert(this->valtype_ != NULL);\n \n   Expression_list* vals = this->vals();\n@@ -12408,11 +12419,71 @@ Slice_construction_expression::do_get_backend(Translate_context* context)\n       vals = new Expression_list;\n       vals->push_back(NULL);\n     }\n-  Expression* array_val =\n-    new Fixed_array_construction_expression(this->valtype_, this->indexes(),\n-\t\t\t\t\t    vals, loc);\n+  return new Fixed_array_construction_expression(\n+      this->valtype_, this->indexes(), vals, loc);\n+}\n+\n+// If we're previous established that the slice storage does not\n+// escape, then create a separate array temp val here for it. We\n+// need to do this as part of flattening so as to be able to insert\n+// the new temp statement.\n+\n+Expression*\n+Slice_construction_expression::do_flatten(Gogo* gogo, Named_object* no,\n+                                          Statement_inserter* inserter)\n+{\n+  if (this->type()->array_type() == NULL)\n+    return NULL;\n+\n+  // Base class flattening first\n+  this->Array_construction_expression::do_flatten(gogo, no, inserter);\n+\n+  // Create an stack-allocated storage temp if storage won't escape\n+  if (!this->storage_escapes_)\n+    {\n+      Location loc = this->location();\n+      this->array_val_ = create_array_val();\n+      go_assert(this->array_val_);\n+      Temporary_statement* temp =\n+          Statement::make_temporary(this->valtype_, this->array_val_, loc);\n+      inserter->insert(temp);\n+      this->slice_storage_ = Expression::make_temporary_reference(temp, loc);\n+    }\n+  return this;\n+}\n+\n+// When dumping a slice construction expression that has an explicit\n+// storeage temp, emit the temp here (if we don't do this the storage\n+// temp appears unused in the AST dump).\n+\n+void\n+Slice_construction_expression::\n+dump_slice_storage_expression(Ast_dump_context* ast_dump_context) const\n+{\n+  if (this->slice_storage_ == NULL)\n+    return;\n+  ast_dump_context->ostream() << \"storage=\" ;\n+  ast_dump_context->dump_expression(this->slice_storage_);\n+}\n+\n+// Return the backend representation for constructing a slice.\n+\n+Bexpression*\n+Slice_construction_expression::do_get_backend(Translate_context* context)\n+{\n+  if (this->array_val_ == NULL)\n+    this->array_val_ = create_array_val();\n+  if (this->array_val_ == NULL)\n+    {\n+      go_assert(this->type()->is_error());\n+      return context->backend()->error_expression();\n+    }\n+\n+  Location loc = this->location();\n+  Array_type* array_type = this->type()->array_type();\n+  Type* element_type = array_type->element_type();\n \n-  bool is_constant_initializer = array_val->is_immutable();\n+  bool is_constant_initializer = this->array_val_->is_immutable();\n \n   // We have to copy the initial values into heap memory if we are in\n   // a function or if the values are not constants.  We also have to\n@@ -12424,15 +12495,21 @@ Slice_construction_expression::do_get_backend(Translate_context* context)\n \t\t\t   && !context->is_const()));\n \n   Expression* space;\n-  if (!copy_to_heap)\n+\n+  if (this->slice_storage_ != NULL)\n+    {\n+      go_assert(!this->storage_escapes_);\n+      space = Expression::make_unary(OPERATOR_AND, this->slice_storage_, loc);\n+    }\n+  else if (!copy_to_heap)\n     {\n       // The initializer will only run once.\n-      space = Expression::make_unary(OPERATOR_AND, array_val, loc);\n+      space = Expression::make_unary(OPERATOR_AND, this->array_val_, loc);\n       space->unary_expression()->set_is_slice_init();\n     }\n   else\n     {\n-      space = Expression::make_heap_expression(array_val, loc);\n+      space = Expression::make_heap_expression(this->array_val_, loc);\n       Node* n = Node::make_node(this);\n       if ((n->encoding() & ESCAPE_MASK) == int(Node::ESCAPE_NONE))\n \t{\n@@ -12442,7 +12519,6 @@ Slice_construction_expression::do_get_backend(Translate_context* context)\n     }\n \n   // Build a constructor for the slice.\n-\n   Expression* len = this->valtype_->array_type()->length();\n   Expression* slice_val =\n     Expression::make_slice_value(this->type(), space, len, len, loc);\n@@ -12452,7 +12528,7 @@ Slice_construction_expression::do_get_backend(Translate_context* context)\n // Make a slice composite literal.  This is used by the type\n // descriptor code.\n \n-Expression*\n+Slice_construction_expression*\n Expression::make_slice_composite_literal(Type* type, Expression_list* vals,\n \t\t\t\t\t Location location)\n {"}, {"sha": "6db6eddc52984cd5f76568886d6abb25bb00026f", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729232db0b630ffb0a17dfcfa0850ff68ac35bbf/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=729232db0b630ffb0a17dfcfa0850ff68ac35bbf", "patch": "@@ -374,7 +374,7 @@ class Expression\n   make_array_composite_literal(Type*, Expression_list*, Location);\n \n   // Make a slice composite literal.\n-  static Expression*\n+  static Slice_construction_expression*\n   make_slice_composite_literal(Type*, Expression_list*, Location);\n \n   // Take an expression and allocate it on the heap.\n@@ -1067,6 +1067,18 @@ class Expression\n   virtual void\n   do_dump_expression(Ast_dump_context*) const = 0;\n \n+  // Varargs lowering creates a slice object (unnamed compiler temp)\n+  // to contain the variable length collection of values. The enum\n+  // below tells the lowering routine whether it can mark that temp\n+  // as non-escaping or not. For general varargs calls it is not always\n+  // safe to stack-allocated the storage, but for specific cases (ex:\n+  // call to append()) it is legal.\n+  enum Slice_storage_escape_disp\n+  {\n+    SLICE_STORAGE_MAY_ESCAPE,\n+    SLICE_STORAGE_DOES_NOT_ESCAPE\n+  };\n+\n  private:\n   // Convert to the desired statement classification, or return NULL.\n   // This is a controlled dynamic cast.\n@@ -2128,7 +2140,8 @@ class Call_expression : public Expression\n   // Let a builtin expression lower varargs.\n   void\n   lower_varargs(Gogo*, Named_object* function, Statement_inserter* inserter,\n-\t\tType* varargs_type, size_t param_count);\n+\t\tType* varargs_type, size_t param_count,\n+\t\tSlice_storage_escape_disp escape_disp);\n \n   // Let a builtin expression check whether types have been\n   // determined.\n@@ -3282,6 +3295,9 @@ class Array_construction_expression : public Expression\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n+  virtual void\n+  dump_slice_storage_expression(Ast_dump_context*) const { }\n+\n  private:\n   // The type of the array to construct.\n   Type* type_;\n@@ -3326,6 +3342,18 @@ class Slice_construction_expression : public Array_construction_expression\n   Slice_construction_expression(Type* type,\n \t\t\t\tconst std::vector<unsigned long>* indexes,\n \t\t\t\tExpression_list* vals, Location location);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  // Record that the storage for this slice (e.g. vals) cannot escape,\n+  // hence it can be stack-allocated.\n+  void\n+  set_storage_does_not_escape()\n+  {\n+    this->storage_escapes_ = false;\n+  }\n+\n  protected:\n   // Note that taking the address of a slice literal is invalid.\n \n@@ -3345,9 +3373,25 @@ class Slice_construction_expression : public Array_construction_expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  void\n+  dump_slice_storage_expression(Ast_dump_context* ast_dump_context) const;\n+\n+  // Create an array value for the constructed slice. Invoked during\n+  // flattening if slice storage does not escape, otherwise invoked\n+  // later on during do_get_backend().\n+  Expression*\n+  create_array_val();\n+\n  private:\n   // The type of the values in this slice.\n   Type* valtype_;\n+  // Array value expression, optionally filled in during flattening.\n+  Expression* array_val_;\n+  // Slice storage expression, optionally filled in during flattening.\n+  Expression* slice_storage_;\n+  // Normally true. Can be set to false if we know that the resulting\n+  // storage for the slice cannot escape.\n+  bool storage_escapes_;\n };\n \n // Construct a map."}]}