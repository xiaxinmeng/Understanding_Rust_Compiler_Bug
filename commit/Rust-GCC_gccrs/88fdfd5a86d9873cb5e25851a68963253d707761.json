{"sha": "88fdfd5a86d9873cb5e25851a68963253d707761", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmZGZkNWE4NmQ5ODczY2I1ZTI1ODUxYTY4OTYzMjUzZDcwNzc2MQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2007-05-26T21:15:22Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2007-05-26T21:15:22Z"}, "message": "string.c (compare0): Use gfc_charlen_type instead of int.\n\n2007-05-27  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* runtime/string.c (compare0): Use gfc_charlen_type instead of int.\n\t(fstrlen): Likewise.\n\t(find_option): Likewise.\n\t(fstrcpy): Use gfc_charlen_type instead of int, return length.\n\t(cf_strcpy): Likewise.\n\t* libgfortran.h: Change string prototypes to use gfc_charlen_type.\n\t* io/open.c (new_unit): Use snprintf if available.\n\t* io/list_read.c (nml_touch_nodes): Use memcpy instead of strcpy/strcat.\n\t(nml_read_obj): Likewise.\n\t* io/transfer.c (st_set_nml_var): Likewise.\n\t* io/write.c (output_float): Use snprintf if available.\n\t(nml_write_obj) Use memcpy instead of strcpy/strcat.\n\nFrom-SVN: r125100", "tree": {"sha": "284b051453fcf4ab80253b550ab8f310e5e3a4ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/284b051453fcf4ab80253b550ab8f310e5e3a4ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88fdfd5a86d9873cb5e25851a68963253d707761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fdfd5a86d9873cb5e25851a68963253d707761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fdfd5a86d9873cb5e25851a68963253d707761", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fdfd5a86d9873cb5e25851a68963253d707761/comments", "author": null, "committer": null, "parents": [{"sha": "c132497f1bf72635ce53a12dac9e432f0cdb8984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c132497f1bf72635ce53a12dac9e432f0cdb8984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c132497f1bf72635ce53a12dac9e432f0cdb8984"}], "stats": {"total": 138, "additions": 97, "deletions": 41}, "files": [{"sha": "246eee50289f4b14a77dccc95a3aed06f5bcd83d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -1,3 +1,20 @@\n+2007-05-27  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* runtime/string.c (compare0): Use gfc_charlen_type instead of\n+\tint.\n+\t(fstrlen): Likewise.\n+\t(find_option): Likewise.\n+\t(fstrcpy): Use gfc_charlen_type instead of int, return length.\n+\t(cf_strcpy): Likewise.\n+\t* libgfortran.h: Change string prototypes to use gfc_charlen_type.\n+\t* io/open.c (new_unit): Use snprintf if available.\n+\t* io/list_read.c (nml_touch_nodes): Use memcpy instead of\n+\tstrcpy/strcat.\n+\t(nml_read_obj): Likewise.\n+\t* io/transfer.c (st_set_nml_var): Likewise.\n+\t* io/write.c (output_float): Use snprintf if available.\n+\t(nml_write_obj) Use memcpy instead of strcpy/strcat.\n+\n 2007-05-26  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* io/unix.c (unix_stream): Rearrange struct members, remove"}, {"sha": "b06b1cab9297f48ebb24f20590b18533143eceed", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist input contributed by Paul Thomas\n \n@@ -1859,8 +1859,8 @@ nml_touch_nodes (namelist_info * nl)\n   index_type len = strlen (nl->var_name) + 1;\n   int dim;\n   char * ext_name = (char*)get_mem (len + 1);\n-  strcpy (ext_name, nl->var_name);\n-  strcat (ext_name, \"%\");\n+  memcpy (ext_name, nl->var_name, len-1);\n+  memcpy (ext_name + len - 1, \"%\", 2);\n   for (nl = nl->next; nl; nl = nl->next)\n     {\n       if (strncmp (nl->var_name, ext_name, len) == 0)\n@@ -2133,8 +2133,8 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t  case GFC_DTYPE_DERIVED:\n \t    obj_name_len = strlen (nl->var_name) + 1;\n \t    obj_name = get_mem (obj_name_len+1);\n-\t    strcpy (obj_name, nl->var_name);\n-\t    strcat (obj_name, \"%\");\n+\t    memcpy (obj_name, nl->var_name, obj_name_len-1);\n+\t    memcpy (obj_name + obj_name_len - 1, \"%\", 2);\n \n \t    /* If reading a derived type, disable the expanded read warning\n \t       since a single object can have multiple reads.  */"}, {"sha": "68be74b978f576d2a55b5ced60c559c521a25bb8", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -345,7 +345,12 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \tbreak;\n \n       opp->file = tmpname;\n+#ifdef HAVE_SNPRINTF\n+      opp->file_len = snprintf(opp->file, sizeof (tmpname), \"fort.%d\", \n+\t\t\t       (int) opp->common.unit);\n+#else\n       opp->file_len = sprintf(opp->file, \"fort.%d\", (int) opp->common.unit);\n+#endif\n       break;\n \n     default:"}, {"sha": "24bcc5e1a3eea5ada7fe18e5408788d0a63c10e1", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -2852,13 +2852,15 @@ st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n {\n   namelist_info *t1 = NULL;\n   namelist_info *nml;\n+  size_t var_name_len = strlen (var_name);\n \n   nml = (namelist_info*) get_mem (sizeof (namelist_info));\n \n   nml->mem_pos = var_addr;\n \n-  nml->var_name = (char*) get_mem (strlen (var_name) + 1);\n-  strcpy (nml->var_name, var_name);\n+  nml->var_name = (char*) get_mem (var_name_len + 1);\n+  memcpy (nml->var_name, var_name, var_name_len);\n+  nml->var_name[var_name_len] = '\\0';\n \n   nml->len = (int) len;\n   nml->string_length = (index_type) string_length;"}, {"sha": "e0c507f4750570a59b8a3bf81255ced09ba85b50", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist output contributed by Paul Thomas\n \n@@ -545,8 +545,13 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n    *   equal to the precision. The exponent always contains at least two\n    *   digits; if the value is zero, the exponent is 00.\n    */\n+#ifdef HAVE_SNPRINTF\n+  snprintf (buffer, sizeof (buffer), \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\"\n+\t   GFC_REAL_LARGEST_FORMAT \"e\", ndigits - 1, value);\n+#else\n   sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\"\n \t   GFC_REAL_LARGEST_FORMAT \"e\", ndigits - 1, value);\n+#endif\n \n   /* Check the resulting string has punctuation in the correct places.  */\n   if (d != 0 && (buffer[2] != '.' || buffer[ndigits + 2] != 'e'))\n@@ -1610,6 +1615,9 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   char rep_buff[NML_DIGITS];\n   namelist_info * cmp;\n   namelist_info * retval = obj->next;\n+  size_t base_name_len;\n+  size_t base_var_name_len;\n+  size_t tot_len;\n \n   /* Write namelist variable names in upper case. If a derived type,\n      nothing is output.  If a component, base and base_name are set.  */\n@@ -1755,32 +1763,43 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \n \t      /* First ext_name => get length of all possible components  */\n \n-\t      ext_name = (char*)get_mem ( (base_name ? strlen (base_name) : 0)\n-\t\t\t\t\t+ (base ? strlen (base->var_name) : 0)\n+\t      base_name_len = base_name ? strlen (base_name) : 0;\n+\t      base_var_name_len = base ? strlen (base->var_name) : 0;\n+\t      ext_name = (char*)get_mem ( base_name_len\n+\t\t\t\t\t+ base_var_name_len\n \t\t\t\t\t+ strlen (obj->var_name)\n \t\t\t\t\t+ obj->var_rank * NML_DIGITS\n \t\t\t\t\t+ 1);\n \n-\t      strcpy(ext_name, base_name ? base_name : \"\");\n-\t      clen = base ? strlen (base->var_name) : 0;\n-\t      strcat (ext_name, obj->var_name + clen);\n-\n+\t      memcpy (ext_name, base_name, base_name_len);\n+\t      clen = strlen (obj->var_name + base_var_name_len);\n+\t      memcpy (ext_name + base_name_len, \n+\t\t      obj->var_name + base_var_name_len, clen);\n+\t      \n \t      /* Append the qualifier.  */\n \n+\t      tot_len = base_name_len + clen;\n \t      for (dim_i = 0; dim_i < obj->var_rank; dim_i++)\n \t\t{\n-\t\t  strcat (ext_name, dim_i ? \"\" : \"(\");\n-\t\t  clen = strlen (ext_name);\n-\t\t  st_sprintf (ext_name + clen, \"%d\", (int) obj->ls[dim_i].idx);\n-\t\t  strcat (ext_name, (dim_i == obj->var_rank - 1) ? \")\" : \",\");\n+\t\t  if (!dim_i)\n+\t\t    {\n+\t\t      ext_name[tot_len] = '(';\n+\t\t      tot_len++;\n+\t\t    }\n+\t\t  st_sprintf (ext_name + tot_len, \"%d\", (int) obj->ls[dim_i].idx);\n+\t\t  tot_len += strlen (ext_name + tot_len);\n+\t\t  ext_name[tot_len] = (dim_i == obj->var_rank - 1) ? ')' : ',';\n+\t\t  tot_len++;\n \t\t}\n \n+\t      ext_name[tot_len] = '\\0';\n+\n \t      /* Now obj_name.  */\n \n \t      obj_name_len = strlen (obj->var_name) + 1;\n \t      obj_name = get_mem (obj_name_len+1);\n-\t      strcpy (obj_name, obj->var_name);\n-\t      strcat (obj_name, \"%\");\n+\t      memcpy (obj_name, obj->var_name, obj_name_len-1);\n+\t      memcpy (obj_name + obj_name_len-1, \"%\", 2);\n \n \t      /* Now loop over the components. Update the component pointer\n \t\t with the return value from nml_write_obj => this loop jumps"}, {"sha": "d42302a3002f1015dbfdc33d5acca0092b6477af", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -1,5 +1,5 @@\n /* Common declarations for all of libgfortran.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>, and\n    Andy Vaught <andy@xena.eas.asu.edu>\n \n@@ -650,17 +650,17 @@ internal_proto(get_unformatted_convert);\n \n /* string.c */\n \n-extern int find_option (st_parameter_common *, const char *, int,\n+extern int find_option (st_parameter_common *, const char *, gfc_charlen_type,\n \t\t\tconst st_option *, const char *);\n internal_proto(find_option);\n \n-extern int fstrlen (const char *, int);\n+extern gfc_charlen_type fstrlen (const char *, gfc_charlen_type);\n internal_proto(fstrlen);\n \n-extern void fstrcpy (char *, int, const char *, int);\n+extern gfc_charlen_type fstrcpy (char *, gfc_charlen_type, const char *, gfc_charlen_type);\n internal_proto(fstrcpy);\n \n-extern void cf_strcpy (char *, int, const char *);\n+extern gfc_charlen_type cf_strcpy (char *, gfc_charlen_type, const char *);\n internal_proto(cf_strcpy);\n \n /* io/intrinsics.c */"}, {"sha": "c0f70ef8ad2776614a83392950d0a8f37d29b377", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fdfd5a86d9873cb5e25851a68963253d707761/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=88fdfd5a86d9873cb5e25851a68963253d707761", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005, 2007 Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -37,64 +37,77 @@ Boston, MA 02110-1301, USA.  */\n    zero if not equal, nonzero if equal.  */\n \n static int\n-compare0 (const char *s1, int s1_len, const char *s2)\n+compare0 (const char *s1, gfc_charlen_type s1_len, const char *s2)\n {\n-  int len;\n+  size_t len;\n \n   /* Strip trailing blanks from the Fortran string.  */\n   len = fstrlen (s1, s1_len);\n-  if (len != (int) strlen(s2)) return 0; /* don't match */\n+  if (len != strlen(s2)) return 0; /* don't match */\n   return strncasecmp (s1, s2, len) == 0;\n }\n \n \n /* Given a fortran string, return its length exclusive of the trailing\n    spaces.  */\n-int\n-fstrlen (const char *string, int len)\n+\n+gfc_charlen_type\n+fstrlen (const char *string, gfc_charlen_type len)\n {\n-  for (len--; len >= 0; len--)\n-    if (string[len] != ' ')\n+  for (; len > 0; len--)\n+    if (string[len-1] != ' ')\n       break;\n \n-  return len + 1;\n+  return len;\n }\n \n \n-void\n-fstrcpy (char *dest, int destlen, const char *src, int srclen)\n+/* Copy a Fortran string (not null-terminated, hence length arguments\n+   for both source and destination strings. Returns the non-padded\n+   length of the destination.  */\n+\n+gfc_charlen_type\n+fstrcpy (char *dest, gfc_charlen_type destlen, \n+\t const char *src, gfc_charlen_type srclen)\n {\n   if (srclen >= destlen)\n     {\n       /* This will truncate if too long.  */\n       memcpy (dest, src, destlen);\n+      return destlen;\n     }\n   else\n     {\n       memcpy (dest, src, srclen);\n       /* Pad with spaces.  */\n       memset (&dest[srclen], ' ', destlen - srclen);\n+      return srclen;\n     }\n }\n \n \n-void\n-cf_strcpy (char *dest, int dest_len, const char *src)\n+/* Copy a null-terminated C string to a non-null-terminated Fortran\n+   string. Returns the non-padded length of the destination string.  */\n+\n+gfc_charlen_type\n+cf_strcpy (char *dest, gfc_charlen_type dest_len, const char *src)\n {\n-  int src_len;\n+  size_t src_len;\n \n   src_len = strlen (src);\n \n-  if (src_len >= dest_len)\n+  if (src_len >= (size_t) dest_len)\n     {\n       /* This will truncate if too long.  */\n       memcpy (dest, src, dest_len);\n+      return dest_len;\n     }\n   else\n     {\n       memcpy (dest, src, src_len);\n       /* Pad with spaces.  */\n       memset (&dest[src_len], ' ', dest_len - src_len);\n+      return src_len;\n     }\n }\n \n@@ -104,7 +117,7 @@ cf_strcpy (char *dest, int dest_len, const char *src)\n    if no default is provided.  */\n \n int\n-find_option (st_parameter_common *cmp, const char *s1, int s1_len,\n+find_option (st_parameter_common *cmp, const char *s1, gfc_charlen_type s1_len,\n \t     const st_option * opts, const char *error_message)\n {\n   for (; opts->name; opts++)"}]}