{"sha": "e6923541fae5081b646f240d54de2a32e17a0382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY5MjM1NDFmYWU1MDgxYjY0NmYyNDBkNTRkZTJhMzJlMTdhMDM4Mg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-26T19:32:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-26T19:32:36Z"}, "message": "libstdc++: Use __libc_single_threaded to optimise atomics [PR 96817]\n\nGlibc 2.32 adds a global variable that says whether the process is\nsingle-threaded. We can use this to decide whether to elide atomic\noperations, as a more precise and reliable indicator than\n__gthread_active_p.\n\nThis means that guard variables for statics and reference counting in\nshared_ptr can use less expensive, non-atomic ops even in processes that\nare linked to libpthread, as long as no threads have been created yet.\nIt also means that we switch to using atomics if libpthread gets loaded\nlater via dlopen (this still isn't supported in general, for other\nreasons).\n\nWe can't use __libc_single_threaded to replace __gthread_active_p\neverywhere. If we replaced the uses of __gthread_active_p in std::mutex\nthen we would elide the pthread_mutex_lock in the code below, but not\nthe pthread_mutex_unlock:\n\n  std::mutex m;\n  m.lock();            // pthread_mutex_lock\n  std::thread t([]{}); // __libc_single_threaded = false\n  t.join();\n  m.unlock();          // pthread_mutex_unlock\n\nWe need the lock and unlock to use the same \"is threading enabled\"\npredicate, and similarly for init/destroy pairs for mutexes and\ncondition variables, so that we don't try to release resources that were\nnever acquired.\n\nThere are other places that could use __libc_single_threaded, such as\n_Sp_locker in src/c++11/shared_ptr.cc and locale init functions, but\nthey can be changed later.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96817\n\t* include/ext/atomicity.h (__gnu_cxx::__is_single_threaded()):\n\tNew function wrapping __libc_single_threaded if available.\n\t(__exchange_and_add_dispatch, __atomic_add_dispatch): Use it.\n\t* libsupc++/guard.cc (__cxa_guard_acquire, __cxa_guard_abort)\n\t(__cxa_guard_release): Likewise.\n\t* testsuite/18_support/96817.cc: New test.", "tree": {"sha": "3c3af77ca37a9b2f461141e3a08ff459b0963209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3af77ca37a9b2f461141e3a08ff459b0963209"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6923541fae5081b646f240d54de2a32e17a0382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6923541fae5081b646f240d54de2a32e17a0382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6923541fae5081b646f240d54de2a32e17a0382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6923541fae5081b646f240d54de2a32e17a0382/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3991912e260d68f0da8d3711b5258c3a3009dc4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3991912e260d68f0da8d3711b5258c3a3009dc4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3991912e260d68f0da8d3711b5258c3a3009dc4c"}], "stats": {"total": 121, "additions": 102, "deletions": 19}, "files": [{"sha": "2d3e5fb0904b1905a9ba5947eb2d4d04b408f476", "filename": "libstdc++-v3/include/ext/atomicity.h", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6923541fae5081b646f240d54de2a32e17a0382/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6923541fae5081b646f240d54de2a32e17a0382/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h?ref=e6923541fae5081b646f240d54de2a32e17a0382", "patch": "@@ -34,11 +34,27 @@\n #include <bits/c++config.h>\n #include <bits/gthr.h>\n #include <bits/atomic_word.h>\n+#if __has_include(<sys/single_threaded.h>)\n+# include <sys/single_threaded.h>\n+#endif\n \n namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  __attribute__((__always_inline__))\n+  inline bool\n+  __is_single_threaded() _GLIBCXX_NOTHROW\n+  {\n+#ifndef __GTHREADS\n+    return true;\n+#elif __has_include(<sys/single_threaded.h>)\n+    return ::__libc_single_threaded;\n+#else\n+    return !__gthread_active_p();\n+#endif\n+  }\n+\n   // Functions for portable atomic access.\n   // To abstract locking primitives across all thread policies, use:\n   // __exchange_and_add_dispatch\n@@ -79,25 +95,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   __attribute__ ((__always_inline__))\n   __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)\n   {\n-#ifdef __GTHREADS\n-    if (__gthread_active_p())\n+    if (__is_single_threaded())\n+      return __exchange_and_add_single(__mem, __val);\n+    else\n       return __exchange_and_add(__mem, __val);\n-#endif\n-    return __exchange_and_add_single(__mem, __val);\n   }\n \n   inline void\n   __attribute__ ((__always_inline__))\n   __atomic_add_dispatch(_Atomic_word* __mem, int __val)\n   {\n-#ifdef __GTHREADS\n-    if (__gthread_active_p())\n-      {\n-\t__atomic_add(__mem, __val);\n-\treturn;\n-      }\n-#endif\n-    __atomic_add_single(__mem, __val);\n+    if (__is_single_threaded())\n+      __atomic_add_single(__mem, __val);\n+    else\n+      __atomic_add(__mem, __val);\n   }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "240eda8ee718d9f1a31899bdf3b139b36fc2c089", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6923541fae5081b646f240d54de2a32e17a0382/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6923541fae5081b646f240d54de2a32e17a0382/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=e6923541fae5081b646f240d54de2a32e17a0382", "patch": "@@ -252,7 +252,24 @@ namespace __cxxabiv1\n # ifdef _GLIBCXX_USE_FUTEX\n     // If __atomic_* and futex syscall are supported, don't use any global\n     // mutex.\n-    if (__gthread_active_p ())\n+\n+    // Use the same bits in the guard variable whether single-threaded or not,\n+    // so that __cxa_guard_release and __cxa_guard_abort match the logic here\n+    // even if __libc_single_threaded becomes false between now and then.\n+\n+    if (__gnu_cxx::__is_single_threaded())\n+      {\n+\t// No need to use atomics, and no need to wait for other threads.\n+\tint *gi = (int *) (void *) g;\n+\tif (*gi == 0)\n+\t  {\n+\t    *gi = _GLIBCXX_GUARD_PENDING_BIT;\n+\t    return 1;\n+\t  }\n+\telse\n+\t  throw_recursive_init_exception();\n+      }\n+    else\n       {\n \tint *gi = (int *) (void *) g;\n \tconst int guard_bit = _GLIBCXX_GUARD_BIT;\n@@ -302,7 +319,7 @@ namespace __cxxabiv1\n \t    syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, 0);\n \t  }\n       }\n-# else\n+# else // ! _GLIBCXX_USE_FUTEX\n     if (__gthread_active_p ())\n       {\n \tmutex_wrapper mw;\n@@ -340,18 +357,26 @@ namespace __cxxabiv1\n \t  }\n       }\n # endif\n-#endif\n+#endif // ! __GTHREADS\n \n     return acquire (g);\n   }\n \n   extern \"C\"\n-  void __cxa_guard_abort (__guard *g) throw ()\n+  void __cxa_guard_abort (__guard *g) noexcept\n   {\n #ifdef _GLIBCXX_USE_FUTEX\n     // If __atomic_* and futex syscall are supported, don't use any global\n     // mutex.\n-    if (__gthread_active_p ())\n+\n+    if (__gnu_cxx::__is_single_threaded())\n+      {\n+\t// No need to use atomics, and no other threads to wake.\n+\tint *gi = (int *) (void *) g;\n+\t*gi = 0;\n+\treturn;\n+      }\n+    else\n       {\n \tint *gi = (int *) (void *) g;\n \tconst int waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;\n@@ -385,12 +410,19 @@ namespace __cxxabiv1\n   }\n \n   extern \"C\"\n-  void __cxa_guard_release (__guard *g) throw ()\n+  void __cxa_guard_release (__guard *g) noexcept\n   {\n #ifdef _GLIBCXX_USE_FUTEX\n     // If __atomic_* and futex syscall are supported, don't use any global\n     // mutex.\n-    if (__gthread_active_p ())\n+\n+    if (__gnu_cxx::__is_single_threaded())\n+      {\n+\tint *gi = (int *) (void *) g;\n+\t*gi = _GLIBCXX_GUARD_BIT;\n+\treturn;\n+      }\n+    else\n       {\n \tint *gi = (int *) (void *) g;\n \tconst int guard_bit = _GLIBCXX_GUARD_BIT;\n@@ -401,6 +433,7 @@ namespace __cxxabiv1\n \t  syscall (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);\n \treturn;\n       }\n+\n #elif defined(__GTHREAD_HAS_COND)\n     if (__gthread_active_p())\n       {"}, {"sha": "4c4da40afa94f51a08de77111a75ba901295293b", "filename": "libstdc++-v3/testsuite/18_support/96817.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6923541fae5081b646f240d54de2a32e17a0382/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2F96817.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6923541fae5081b646f240d54de2a32e17a0382/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2F96817.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2F96817.cc?ref=e6923541fae5081b646f240d54de2a32e17a0382", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-pthread\"  }\n+// { dg-do run { target *-*-linux-gnu } }\n+// { dg-require-effective-target pthread }\n+\n+// PR libstdc++/96817\n+\n+int init()\n+{\n+#if __has_include(<sys/single_threaded.h>)\n+  // This deadlocks unless __libc_single_threaded is available in Glibc,\n+  // because __cxa_guard_acquire uses __gthread_active_p and the\n+  // multithreaded init can't detect recursion (see PR 97211).\n+  static int i = init();\n+#endif\n+  return 0;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  init();\n+}"}]}