{"sha": "c853d655ab27d288b9dcadb2920f7cd28dc1390d", "node_id": "C_kwDOANBUbNoAKGM4NTNkNjU1YWIyN2QyODhiOWRjYWRiMjkyMGY3Y2QyOGRjMTM5MGQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-10-12T07:27:19Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-10-13T16:44:20Z"}, "message": "Fix emit_group_store regression on big-endian\n\nThe recent optimization implemented for complex modes contains an oversight\nfor big-endian platforms: it uses a lowpart SUBREG when the integer modes\nhave different sizes, but this does not match the semantics of the PARALLELs\nwhich have a bundled byte offset; this offset is always zero in the code\npath and the lowpart is not at offset zero on big-endian platforms.\n\ngcc/\n\t* expr.cc (emit_group_stote): Fix handling of modes of different\n\tsizes for big-endian targets in latest change and add commentary.", "tree": {"sha": "8152e697ec7d8b0bc12afd787af0482c36624880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8152e697ec7d8b0bc12afd787af0482c36624880"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c853d655ab27d288b9dcadb2920f7cd28dc1390d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c853d655ab27d288b9dcadb2920f7cd28dc1390d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c853d655ab27d288b9dcadb2920f7cd28dc1390d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c853d655ab27d288b9dcadb2920f7cd28dc1390d/comments", "author": null, "committer": null, "parents": [{"sha": "fc748d47e95dd612f4a0ef408851df0293173fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc748d47e95dd612f4a0ef408851df0293173fd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc748d47e95dd612f4a0ef408851df0293173fd8"}], "stats": {"total": 44, "additions": 32, "deletions": 12}, "files": [{"sha": "b897b6dc38514a736f651c9f81ed27edee6efdf3", "filename": "gcc/expr.cc", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c853d655ab27d288b9dcadb2920f7cd28dc1390d/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c853d655ab27d288b9dcadb2920f7cd28dc1390d/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=c853d655ab27d288b9dcadb2920f7cd28dc1390d", "patch": "@@ -2813,57 +2813,77 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n       else\n \tadj_bytelen = bytelen;\n \n+      /* Deal with destination CONCATs by either storing into one of the parts\n+\t or doing a copy after storing into a register or stack temporary.  */\n       if (GET_CODE (dst) == CONCAT)\n \t{\n \t  if (known_le (bytepos + adj_bytelen,\n \t\t\tGET_MODE_SIZE (GET_MODE (XEXP (dst, 0)))))\n \t    dest = XEXP (dst, 0);\n+\n \t  else if (known_ge (bytepos, GET_MODE_SIZE (GET_MODE (XEXP (dst, 0)))))\n \t    {\n \t      bytepos -= GET_MODE_SIZE (GET_MODE (XEXP (dst, 0)));\n \t      dest = XEXP (dst, 1);\n \t    }\n+\n \t  else\n \t    {\n \t      machine_mode dest_mode = GET_MODE (dest);\n \t      machine_mode tmp_mode = GET_MODE (tmps[i]);\n-\t      scalar_int_mode imode;\n+\t      scalar_int_mode dest_imode;\n \n \t      gcc_assert (known_eq (bytepos, 0) && XVECLEN (src, 0));\n \n-\t      if (finish == 1\n+\t      /* If the source is a single scalar integer register, and the\n+\t\t destination has a complex mode for which a same-sized integer\n+\t\t mode exists, then we can take the left-justified part of the\n+\t\t source in the complex mode.  */\n+\t      if (finish == start + 1\n \t\t  && REG_P (tmps[i])\n-\t\t  && COMPLEX_MODE_P (dest_mode)\n \t\t  && SCALAR_INT_MODE_P (tmp_mode)\n-\t\t  && int_mode_for_mode (dest_mode).exists (&imode))\n+\t\t  && COMPLEX_MODE_P (dest_mode)\n+\t\t  && int_mode_for_mode (dest_mode).exists (&dest_imode))\n \t\t{\n-\t\t  if (tmp_mode != imode)\n+\t\t  const scalar_int_mode tmp_imode\n+\t\t    = as_a <scalar_int_mode> (tmp_mode);\n+\n+\t\t  if (GET_MODE_BITSIZE (dest_imode)\n+\t\t      < GET_MODE_BITSIZE (tmp_imode))\n \t\t    {\n-\t\t      rtx tmp = gen_reg_rtx (imode);\n-\t\t      emit_move_insn (tmp, gen_lowpart (imode, tmps[i]));\n-\t\t      dst = gen_lowpart (dest_mode, tmp);\n+\t\t      dest = gen_reg_rtx (dest_imode);\n+\t\t      if (BYTES_BIG_ENDIAN)\n+\t\t\ttmps[i] = expand_shift (RSHIFT_EXPR, tmp_mode, tmps[i],\n+\t\t\t\t\t\tGET_MODE_BITSIZE (tmp_imode)\n+\t\t\t\t\t\t- GET_MODE_BITSIZE (dest_imode),\n+\t\t\t\t\t\tNULL_RTX, 1);\n+\t\t      emit_move_insn (dest, gen_lowpart (dest_imode, tmps[i]));\n+\t\t      dst = gen_lowpart (dest_mode, dest);\n \t\t    }\n \t\t  else\n \t\t    dst = gen_lowpart (dest_mode, tmps[i]);\n \t\t}\n+\n+\t      /* Otherwise spill the source onto the stack using the more\n+\t\t aligned of the two modes.  */\n \t      else if (GET_MODE_ALIGNMENT (dest_mode)\n-\t\t  >= GET_MODE_ALIGNMENT (tmp_mode))\n+\t\t       >= GET_MODE_ALIGNMENT (tmp_mode))\n \t\t{\n \t\t  dest = assign_stack_temp (dest_mode,\n \t\t\t\t\t    GET_MODE_SIZE (dest_mode));\n-\t\t  emit_move_insn (adjust_address (dest,\n-\t\t\t\t\t\t  tmp_mode,\n-\t\t\t\t\t\t  bytepos),\n+\t\t  emit_move_insn (adjust_address (dest, tmp_mode, bytepos),\n \t\t\t\t  tmps[i]);\n \t\t  dst = dest;\n \t\t}\n+\n \t      else\n \t\t{\n \t\t  dest = assign_stack_temp (tmp_mode,\n \t\t\t\t\t    GET_MODE_SIZE (tmp_mode));\n \t\t  emit_move_insn (dest, tmps[i]);\n \t\t  dst = adjust_address (dest, dest_mode, bytepos);\n \t\t}\n+\n \t      break;\n \t    }\n \t}"}]}