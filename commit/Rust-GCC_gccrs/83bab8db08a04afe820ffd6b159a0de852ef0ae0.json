{"sha": "83bab8db08a04afe820ffd6b159a0de852ef0ae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNiYWI4ZGIwOGEwNGFmZTgyMGZmZDZiMTU5YTBkZTg1MmVmMGFlMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-08-25T00:58:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-08-25T00:58:27Z"}, "message": "Makefile.in (C_AND_OBJC_OBJS): Remove c-iterate.o.\n\n\t* Makefile.in (C_AND_OBJC_OBJS): Remove c-iterate.o.\n\t(c-iterate.o): Remove target.\n\t* gcc/c-common.h (enum rid): Remove RID_ITERATOR.\n\t* gcc/c-decl.c (init_decl_processing): Remove call to init_iterators.\n\t(finish_decl): Don't handle iterators.\n\t(grokdeclarator): Likewise.\n\t* gcc/c-parse.gperf: Remove __iterator and __iterator__ keywords.\n\t* gcc/c-gperf.h: Regenerated.\n\t* gcc/c-iterate.c: Removed.\n\t* gcc/c-lex.c (init_lex): Don't handle iterators.\n\t* gcc/c-parse.in (primary): Remove pop_iterator_stack call.\n\t(compstmt_primary_start): Remove push_iterator_stack call.\n\t(stmt): Don't allow iterator statements.  Replace iterator_expand\n\twith expand_expr_stmt.\n\t(all_iter_stmt): Remove.\n\t(all_iter_stmt_simple): Likewise.\n\t(all_iter_stmt_with_decl): Likewise.\n\t* gcc/c-tree.h (ITERATOR_P): Remove.\n\t(ITERATOR_BOUND_P): Likewise.\n\t(init_iterators): Remove declaration.\n\t(iterator_expand): Likewise.\n\t(iterator_for_loop_start): Likewise.\n\t(iterator_for_loop_end): Likewise.\n\t(iterator_for_loop_record): Likewise.\n\t(push_iterator_stack): Likewise.\n\t(pop_iterator_stack): Likewise.\n\t* gcc/c-typeck.c (decl_constant_value): Don't check ITERATOR_P.\n\t(readonly_warning): Likewise.\n\t* gcc/tree.h (ITERATOR_BOUND_P): Don't mention it.\n\n\t* Make-lang.in (cc1chill): Don't depend on c-iterate.o.\n\n\t* gcc.dg/noncompile/930622-2.c: Adjust error message.\n\nFrom-SVN: r35967", "tree": {"sha": "db5daa1309969dcd75e507b485cbdcb1ec86be2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5daa1309969dcd75e507b485cbdcb1ec86be2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83bab8db08a04afe820ffd6b159a0de852ef0ae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bab8db08a04afe820ffd6b159a0de852ef0ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83bab8db08a04afe820ffd6b159a0de852ef0ae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bab8db08a04afe820ffd6b159a0de852ef0ae0/comments", "author": null, "committer": null, "parents": [{"sha": "aee3c6b0389ecf8b01ee17fa25dc00b0666ee27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee3c6b0389ecf8b01ee17fa25dc00b0666ee27c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee3c6b0389ecf8b01ee17fa25dc00b0666ee27c"}], "stats": {"total": 1015, "additions": 182, "deletions": 833}, "files": [{"sha": "305e174478ea92595bce7613218b9772f33c4116", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -1,3 +1,35 @@\n+2000-08-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (C_AND_OBJC_OBJS): Remove c-iterate.o.\n+\t(c-iterate.o): Remove target.\n+\t* gcc/c-common.h (enum rid): Remove RID_ITERATOR.\n+\t* gcc/c-decl.c (init_decl_processing): Remove call to init_iterators.\n+\t(finish_decl): Don't handle iterators.\n+\t(grokdeclarator): Likewise.\n+\t* gcc/c-parse.gperf: Remove __iterator and __iterator__ keywords.\n+\t* gcc/c-gperf.h: Regenerated.\n+\t* gcc/c-iterate.c: Removed.\n+\t* gcc/c-lex.c (init_lex): Don't handle iterators.\n+\t* gcc/c-parse.in (primary): Remove pop_iterator_stack call.\n+\t(compstmt_primary_start): Remove push_iterator_stack call.\n+\t(stmt): Don't allow iterator statements.  Replace iterator_expand\n+\twith expand_expr_stmt.\n+\t(all_iter_stmt): Remove.\n+\t(all_iter_stmt_simple): Likewise.\n+\t(all_iter_stmt_with_decl): Likewise.\n+\t* gcc/c-tree.h (ITERATOR_P): Remove.\n+\t(ITERATOR_BOUND_P): Likewise.\n+\t(init_iterators): Remove declaration.\n+\t(iterator_expand): Likewise.\n+\t(iterator_for_loop_start): Likewise.\n+\t(iterator_for_loop_end): Likewise.\n+\t(iterator_for_loop_record): Likewise.\n+\t(push_iterator_stack): Likewise.\n+\t(pop_iterator_stack): Likewise.\n+\t* gcc/c-typeck.c (decl_constant_value): Don't check ITERATOR_P.\n+\t(readonly_warning): Likewise.\n+\t* gcc/tree.h (ITERATOR_BOUND_P): Don't mention it.\n+\t\t\n 2000-08-24  Jim Wilson  <wilson@cygnus.com>\n \n \t* c-common.c (decl_attributes, case A_ALIGN): Revert last change."}, {"sha": "4c12b33423ab56c92509f2ba399066a9a9ef4cf0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -678,7 +678,7 @@ LANG_FLAGS_TO_PASS = $(SUBDIR_FLAGS_TO_PASS) \\\n \n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n-  c-convert.o c-aux-info.o c-common.o c-iterate.o c-semantics.o @extra_c_objs@\n+  c-convert.o c-aux-info.o c-common.o c-semantics.o @extra_c_objs@\n \n # Language-specific object files for C.\n C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n@@ -1111,8 +1111,6 @@ c-aux-info.o : c-aux-info.c  $(CONFIG_H) system.h $(TREE_H) c-tree.h \\\n c-convert.o : c-convert.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h\n c-pragma.o: c-pragma.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) function.h \\\n     defaults.h c-pragma.h toplev.h $(GGC_H)\n-c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n-    c-common.h flags.h toplev.h $(EXPR_H)\n mbchar.o: mbchar.c $(CONFIG_H) system.h mbchar.h\n graph.o: graph.c $(CONFIG_H) system.h toplev.h flags.h output.h $(RTL_H) \\\n     function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h"}, {"sha": "ab294ed12001efdd6f275889e02603f272312f71", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -64,7 +64,6 @@ enum rid\n   RID_BOUNDED,\n   RID_UNBOUNDED,\n   RID_NOALIAS,\n-  RID_ITERATOR,\n   RID_COMPLEX,\n \n   RID_IN,"}, {"sha": "2e336f4fde7a30fe3d8f779e64bbff711b261415", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -3199,8 +3199,6 @@ init_decl_processing ()\n   /* Prepare to check format strings against argument lists.  */\n   init_function_format_info ();\n \n-  init_iterators ();\n-\n   incomplete_decl_finalize_hook = finish_incomplete_decl;\n \n   /* Record our roots.  */\n@@ -3580,14 +3578,6 @@ finish_decl (decl, init, asmspec_tree)\n   if (TREE_CODE (decl) == PARM_DECL)\n     init = 0;\n \n-  if (ITERATOR_P (decl))\n-    {\n-      if (init == 0)\n-\terror_with_decl (decl, \"iterator has no initial value\");\n-      else\n-\tinit = save_expr (init);\n-    }\n-\n   if (init)\n     {\n       if (TREE_CODE (decl) != TYPE_DECL)\n@@ -4254,7 +4244,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n     if (specbits & 1 << (int) RID_EXTERN) nclasses++;\n     if (specbits & 1 << (int) RID_REGISTER) nclasses++;\n     if (specbits & 1 << (int) RID_TYPEDEF) nclasses++;\n-    if (specbits & 1 << (int) RID_ITERATOR) nclasses++;\n \n     /* Warn about storage classes that are invalid for certain\n        kinds of declarations (parameters, typenames, etc.).  */\n@@ -4315,18 +4304,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n     else if (current_binding_level == global_binding_level\n \t     && specbits & (1 << (int) RID_AUTO))\n       error (\"top-level declaration of `%s' specifies `auto'\", name);\n-    else if ((specbits & 1 << (int) RID_ITERATOR)\n-\t     && TREE_CODE (declarator) != IDENTIFIER_NODE)\n-      {\n-\terror (\"iterator `%s' has derived type\", name);\n-\ttype = error_mark_node;\n-      }\n-    else if ((specbits & 1 << (int) RID_ITERATOR)\n-\t     && TREE_CODE (type) != INTEGER_TYPE)\n-      {\n-\terror (\"iterator `%s' has noninteger type\", name);\n-\ttype = error_mark_node;\n-      }\n   }\n \n   /* Now figure out the structure of the declarator proper.\n@@ -4879,9 +4856,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    TREE_STATIC (decl) = (specbits & (1 << (int) RID_STATIC)) != 0;\n \t    TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);\n \t  }\n-\n-\tif (specbits & 1 << (int) RID_ITERATOR)\n-\t  ITERATOR_P (decl) = 1;\n       }\n \n     /* Record `register' declaration for warnings on &"}, {"sha": "a864d2e30ce5415babfca69f0ed95f6a38f3e44f", "filename": "gcc/c-gperf.h", "status": "modified", "additions": 136, "deletions": 126, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-gperf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-gperf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gperf.h?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -1,5 +1,5 @@\n /* C code produced by gperf version 2.7.1 (19981006 egcs) */\n-/* Command-line: gperf -L C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ /work/src/gcc/gcc/c-parse.gperf  */\n+/* Command-line: gperf -L C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ ../../gcc/c-parse.gperf  */\n /* Command-line: gperf -L C -F ', 0, 0' -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n struct resword { const char *name; short token; enum rid rid; };\n #ifdef __GNUC__\n@@ -11,12 +11,12 @@ __inline\n #endif\n struct resword *is_reserved_word PARAMS ((const char *, unsigned int));\n \n-#define TOTAL_KEYWORDS 94\n+#define TOTAL_KEYWORDS 92\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 20\n-#define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 249\n-/* maximum key range = 246, duplicates = 0 */\n+#define MIN_HASH_VALUE 17\n+#define MAX_HASH_VALUE 301\n+/* maximum key range = 285, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -26,34 +26,34 @@ hash (str, len)\n      register const char *str;\n      register unsigned int len;\n {\n-  static unsigned char asso_values[] =\n+  static unsigned short asso_values[] =\n     {\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250,  11, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250,   1, 250,  78,  38,  61,\n-        1,  37,  47,  70,   1,  13, 250,   4,  94,  37,\n-       81,   1, 100, 250,  19,   8,  25,   4,  50,   1,\n-        2,   1,   2, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250, 250, 250, 250, 250,\n-      250, 250, 250, 250, 250, 250\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 113, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302,   1, 302,  78,  52, 111,\n+       34,   9,  46,  59,   1,  20, 302,   1, 118,  17,\n+       18,  39,  58, 302,   7,   6,  33,  70,  21,   2,\n+        5,   1,   1, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+      302, 302, 302, 302, 302, 302\n     };\n   register int hval = len;\n \n@@ -72,150 +72,160 @@ hash (str, len)\n \n static struct resword wordlist[] =\n   {\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"do\", DO, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"id\", OBJECTNAME, RID_ID},\n-    {\"__unbounded\", TYPE_QUAL, RID_UNBOUNDED},\n-    {\"__signed\", TYPESPEC, RID_SIGNED},\n-    {\"__unbounded__\", TYPE_QUAL, RID_UNBOUNDED},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__real__\", REALPART, NORID},\n     {\"__signed__\", TYPESPEC, RID_SIGNED},\n-    {\"unsigned\", TYPESPEC, RID_UNSIGNED},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__restrict__\", TYPE_QUAL, RID_RESTRICT},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__extension__\", EXTENSION, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"else\", ELSE, NORID},\n     {\"\", 0, 0},\n     {\"__imag__\", IMAGPART, NORID},\n     {\"\", 0, 0},\n     {\"__inline__\", SCSPEC, RID_INLINE},\n-    {\"\", 0, 0},\n-    {\"__iterator__\", SCSPEC, RID_ITERATOR},\n     {\"switch\", SWITCH, NORID},\n-    {\"__real__\", REALPART, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__restrict__\", TYPE_QUAL, RID_RESTRICT},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__typeof__\", TYPEOF, NORID},\n     {\"\", 0, 0},\n-    {\"short\", TYPESPEC, RID_SHORT},\n-    {\"@compatibility_alias\", ALIAS, NORID},\n-    {\"@protected\", PROTECTED, NORID},\n+    {\"__volatile__\", TYPE_QUAL, RID_VOLATILE},\n+    {\"while\", WHILE, NORID},\n     {\"\", 0, 0},\n-    {\"__iterator\", SCSPEC, RID_ITERATOR},\n-    {\"inout\", TYPE_QUAL, RID_INOUT},\n-    {\"oneway\", TYPE_QUAL, RID_ONEWAY},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"double\", TYPESPEC, RID_DOUBLE},\n-    {\"__bounded\", TYPE_QUAL, RID_BOUNDED},\n+    {\"__inline\", SCSPEC, RID_INLINE},\n     {\"\", 0, 0},\n-    {\"__bounded__\", TYPE_QUAL, RID_BOUNDED},\n-    {\"__extension__\", EXTENSION, NORID},\n+    {\"in\", TYPE_QUAL, RID_IN},\n+    {\"__volatile\", TYPE_QUAL, RID_VOLATILE},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__typeof__\", TYPEOF, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__signed\", TYPESPEC, RID_SIGNED},\n     {\"\", 0, 0},\n-    {\"out\", TYPE_QUAL, RID_OUT},\n     {\"__restrict\", TYPE_QUAL, RID_RESTRICT},\n-    {\"while\", WHILE, NORID},\n-    {\"\", 0, 0},\n     {\"struct\", STRUCT, NORID},\n-    {\"__inline\", SCSPEC, RID_INLINE},\n+    {\"\", 0, 0},\n     {\"restrict\", TYPE_QUAL, RID_RESTRICT},\n-    {\"@defs\", DEFS, NORID},\n-    {\"if\", IF, NORID},\n+    {\"oneway\", TYPE_QUAL, RID_ONEWAY},\n+    {\"id\", OBJECTNAME, RID_ID},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n     {\"sizeof\", SIZEOF, NORID},\n-    {\"__volatile__\", TYPE_QUAL, RID_VOLATILE},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"for\", FOR, NORID},\n+    {\"return\", RETURN, NORID},\n+    {\"__bounded__\", TYPE_QUAL, RID_BOUNDED},\n+    {\"extern\", SCSPEC, RID_EXTERN},\n+    {\"break\", BREAK, NORID},\n+    {\"if\", IF, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__ptrbase__\", PTR_BASE, NORID},\n+    {\"__ptrvalue__\", PTR_VALUE, NORID},\n+    {\"__ptrextent__\", PTR_EXTENT, NORID},\n     {\"\", 0, 0},\n-    {\"int\", TYPESPEC, RID_INT},\n+    {\"do\", DO, NORID},\n     {\"\", 0, 0},\n+    {\"__ptrbase\", PTR_BASE, NORID},\n+    {\"__ptrvalue\", PTR_VALUE, NORID},\n     {\"void\", TYPESPEC, RID_VOID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__const__\", TYPE_QUAL, RID_CONST},\n-    {\"__complex\", TYPESPEC, RID_COMPLEX},\n-    {\"__complex__\", TYPESPEC, RID_COMPLEX},\n-    {\"@private\", PRIVATE, NORID},\n-    {\"@selector\", SELECTOR, NORID},\n     {\"\", 0, 0},\n-    {\"float\", TYPESPEC, RID_FLOAT},\n+    {\"register\", SCSPEC, RID_REGISTER},\n     {\"\", 0, 0},\n-    {\"default\", DEFAULT, NORID},\n-    {\"__typeof\", TYPEOF, NORID},\n-    {\"enum\", ENUM, NORID},\n-    {\"@public\", PUBLIC, NORID},\n-    {\"break\", BREAK, NORID},\n-    {\"signed\", TYPESPEC, RID_SIGNED},\n-    {\"else\", ELSE, NORID},\n-    {\"__asm__\", ASM_KEYWORD, NORID},\n-    {\"for\", FOR, NORID},\n+    {\"short\", TYPESPEC, RID_SHORT},\n     {\"\", 0, 0},\n+    {\"__unbounded__\", TYPE_QUAL, RID_UNBOUNDED},\n     {\"__imag\", IMAGPART, NORID},\n+    {\"__asm__\", ASM_KEYWORD, NORID},\n+    {\"__typeof\", TYPEOF, NORID},\n+    {\"int\", TYPESPEC, RID_INT},\n+    {\"\", 0, 0},\n     {\"__alignof__\", ALIGNOF, NORID},\n     {\"\", 0, 0},\n     {\"__attribute__\", ATTRIBUTE, NORID},\n-    {\"__const\", TYPE_QUAL, RID_CONST},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"__bounded\", TYPE_QUAL, RID_BOUNDED},\n+    {\"inout\", TYPE_QUAL, RID_INOUT},\n     {\"\", 0, 0},\n-    {\"in\", TYPE_QUAL, RID_IN},\n-    {\"@end\", END, NORID},\n-    {\"__volatile\", TYPE_QUAL, RID_VOLATILE},\n+    {\"__attribute\", ATTRIBUTE, NORID},\n+    {\"enum\", ENUM, NORID},\n+    {\"__asm\", ASM_KEYWORD, NORID},\n     {\"\", 0, 0},\n-    {\"goto\", GOTO, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"union\", UNION, NORID},\n+    {\"__ptrextent\", PTR_EXTENT, NORID},\n     {\"\", 0, 0},\n-    {\"__label__\", LABEL, NORID},\n-    {\"bycopy\", TYPE_QUAL, RID_BYCOPY},\n+    {\"signed\", TYPESPEC, RID_SIGNED},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"out\", TYPE_QUAL, RID_OUT},\n     {\"\", 0, 0},\n-    {\"auto\", SCSPEC, RID_AUTO},\n     {\"byref\", TYPE_QUAL, RID_BYREF},\n-    {\"case\", CASE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__ptrbase__\", PTR_BASE, NORID},\n-    {\"__ptrvalue__\", PTR_VALUE, NORID},\n-    {\"__ptrextent__\", PTR_EXTENT, NORID},\n-    {\"register\", SCSPEC, RID_REGISTER},\n     {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@class\", CLASS, NORID},\n-    {\"__real\", REALPART, NORID},\n-    {\"__asm\", ASM_KEYWORD, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__builtin_va_arg\", VA_ARG, NORID},\n+    {\"union\", UNION, NORID},\n     {\"\", 0, 0},\n-    {\"__attribute\", ATTRIBUTE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"return\", RETURN, NORID},\n+    {\"asm\", ASM_KEYWORD, NORID},\n+    {\"__unbounded\", TYPE_QUAL, RID_UNBOUNDED},\n     {\"\", 0, 0},\n-    {\"@protocol\", PROTOCOL, NORID},\n+    {\"unsigned\", TYPESPEC, RID_UNSIGNED},\n+    {\"double\", TYPESPEC, RID_DOUBLE},\n+    {\"default\", DEFAULT, NORID},\n+    {\"\", 0, 0},\n+    {\"__const__\", TYPE_QUAL, RID_CONST},\n+    {\"float\", TYPESPEC, RID_FLOAT},\n+    {\"__complex__\", TYPESPEC, RID_COMPLEX},\n+    {\"\", 0, 0},\n+    {\"__complex\", TYPESPEC, RID_COMPLEX},\n+    {\"\", 0, 0},\n+    {\"__builtin_va_arg\", VA_ARG, NORID},\n+    {\"__label__\", LABEL, NORID},\n+    {\"case\", CASE, NORID},\n     {\"\", 0, 0},\n+    {\"__real\", REALPART, NORID},\n+    {\"@defs\", DEFS, NORID},\n     {\"__alignof\", ALIGNOF, NORID},\n-    {\"@encode\", ENCODE, NORID},\n-    {\"__ptrextent\", PTR_EXTENT, NORID},\n+    {\"goto\", GOTO, NORID},\n     {\"\", 0, 0},\n-    {\"@interface\", INTERFACE, NORID},\n+    {\"@private\", PRIVATE, NORID},\n+    {\"@selector\", SELECTOR, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@implementation\", IMPLEMENTATION, NORID},\n+    {\"typeof\", TYPEOF, NORID},\n+    {\"typedef\", SCSPEC, RID_TYPEDEF},\n+    {\"\", 0, 0},\n+    {\"continue\", CONTINUE, NORID},\n+    {\"@encode\", ENCODE, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__ptrbase\", PTR_BASE, NORID},\n-    {\"__ptrvalue\", PTR_VALUE, NORID},\n-    {\"extern\", SCSPEC, RID_EXTERN},\n+    {\"@interface\", INTERFACE, NORID},\n+    {\"\", 0, 0},\n+    {\"__const\", TYPE_QUAL, RID_CONST},\n     {\"inline\", SCSPEC, RID_INLINE},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"static\", SCSPEC, RID_STATIC},\n+    {\"auto\", SCSPEC, RID_AUTO},\n     {\"\", 0, 0},\n-    {\"asm\", ASM_KEYWORD, NORID},\n+    {\"volatile\", TYPE_QUAL, RID_VOLATILE},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"char\", TYPESPEC, RID_CHAR},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@implementation\", IMPLEMENTATION, NORID},\n+    {\"@protected\", PROTECTED, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n     {\"const\", TYPE_QUAL, RID_CONST},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"typeof\", TYPEOF, NORID},\n-    {\"typedef\", SCSPEC, RID_TYPEDEF},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"continue\", CONTINUE, NORID},\n     {\"\", 0, 0},\n-    {\"volatile\", TYPE_QUAL, RID_VOLATILE},\n+    {\"@end\", END, NORID},\n+    {\"bycopy\", TYPE_QUAL, RID_BYCOPY},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@compatibility_alias\", ALIAS, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"long\", TYPESPEC, RID_LONG},\n+    {\"char\", TYPESPEC, RID_CHAR},\n+    {\"static\", SCSPEC, RID_STATIC},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"long\", TYPESPEC, RID_LONG}\n+    {\"@class\", CLASS, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@protocol\", PROTOCOL, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@public\", PUBLIC, NORID}\n   };\n \n #ifdef __GNUC__"}, {"sha": "0e545d80d9de546e4f09ca35ab07c1adf28e1634", "filename": "gcc/c-iterate.c", "status": "removed", "additions": 0, "deletions": 587, "changes": 587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee3c6b0389ecf8b01ee17fa25dc00b0666ee27c/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee3c6b0389ecf8b01ee17fa25dc00b0666ee27c/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=aee3c6b0389ecf8b01ee17fa25dc00b0666ee27c", "patch": "@@ -1,587 +0,0 @@\n-/* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996\n-   1997, 1998, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* This file is part of the C front end.\n-   It is responsible for implementing iterators,\n-   both their declarations and the expansion of statements using them.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"c-tree.h\"\n-#include \"flags.h\"\n-#include \"obstack.h\"\n-#include \"rtl.h\"\n-#include \"toplev.h\"\n-#include \"expr.h\"\n-\f\n-/*\n-\t\tKEEPING TRACK OF EXPANSIONS\n-\n-   In order to clean out expansions corresponding to statements inside\n-   \"{(...)}\" constructs we have to keep track of all expansions.  The\n-   cleanup is needed when an automatic, or implicit, expansion on\n-   iterator, say X, happens to a statement which contains a {(...)}\n-   form with a statement already expanded on X.  In this case we have\n-   to go back and cleanup the inner expansion.  This can be further\n-   complicated by the fact that {(...)} can be nested.\n-\n-   To make this cleanup possible, we keep lists of all expansions, and\n-   to make it work for nested constructs, we keep a stack.  The list at\n-   the top of the stack (ITER_STACK.CURRENT_LEVEL) corresponds to the\n-   currently parsed level.  All expansions of the levels below the\n-   current one are kept in one list whose head is pointed to by\n-   ITER_STACK.SUBLEVEL_FIRST (SUBLEVEL_LAST is there for making merges\n-   easy).  The process works as follows:\n-\n-   -- On \"({\"  a new node is added to the stack by PUSH_ITERATOR_STACK.\n-\t       The sublevel list is not changed at this point.\n-\n-   -- On \"})\" the list for the current level is appended to the sublevel\n-\t      list. \n-\n-   -- On \";\"  sublevel lists are appended to the current level lists.\n-\t      The reason is this: if they have not been superseded by the\n-\t      expansion at the current level, they still might be\n-\t      superseded later by the expansion on the higher level.\n-\t      The levels do not have to distinguish levels below, so we\n-\t      can merge the lists together.  */\n-\n-struct  ixpansion\n-{\n-  tree ixdecl;\t\t\t/* Iterator decl */\n-  rtx  ixprologue_start;\t/* First insn of epilogue. NULL means */\n-  /* explicit (FOR) expansion*/\n-  rtx  ixprologue_end;\n-  rtx  ixepilogue_start;\n-  rtx  ixepilogue_end;\n-  struct ixpansion *next;\t/* Next in the list */\n-};\n-\n-struct iter_stack_node\n-{\n-  struct ixpansion *first;\t/* Head of list of ixpansions */\n-  struct ixpansion *last;\t/* Last node in list  of ixpansions */\n-  struct iter_stack_node *next; /* Next level iterator stack node  */\n-};\n-\n-struct iter_stack_node *iter_stack;\n-struct iter_stack_node sublevel_ixpansions;\n-\n-/* A special obstack, and a pointer to the start of\n-   all the data in it (so we can free everything easily).  */\n-static struct obstack ixp_obstack;\n-static char *ixp_firstobj;\n-\n-/* During collect_iterators, a list of SAVE_EXPRs already scanned.  */\n-static tree save_exprs;\n-\n-static void expand_stmt_with_iterators_1 PARAMS ((tree, tree));\n-static tree collect_iterators\t\tPARAMS ((tree, tree));\n-static void iterator_loop_prologue\tPARAMS ((tree, rtx *, rtx *));\n-static void iterator_loop_epilogue\tPARAMS ((tree, rtx *, rtx *));\n-static int top_level_ixpansion_p\tPARAMS ((void));\n-static void isn_append\t\t\tPARAMS ((struct iter_stack_node *,\n-\t\t\t\t\t\t struct iter_stack_node *));\n-static void istack_sublevel_to_current\tPARAMS ((void));\n-static void add_ixpansion\t\tPARAMS ((tree, rtx, rtx, rtx, rtx));\n-static void delete_ixpansion\t\tPARAMS ((tree));\n-\f\n-/* Initialize our obstack once per compilation.  */\n-\n-void\n-init_iterators ()\n-{\n-  gcc_obstack_init (&ixp_obstack);\n-  ixp_firstobj = (char *) obstack_alloc (&ixp_obstack, 0);\n-}\n-\n-/* Handle the start of an explicit `for' loop for iterator IDECL.  */\n-\n-void\n-iterator_for_loop_start (idecl)\n-     tree idecl;\n-{\n-  ITERATOR_BOUND_P (idecl) = 1;\n-  add_ixpansion (idecl, 0, 0, 0, 0);\n-  iterator_loop_prologue (idecl, 0, 0);\n-}\n-\n-/* Handle the end of an explicit `for' loop for iterator IDECL.  */\n-\n-void\n-iterator_for_loop_end (idecl)\n-     tree idecl;\n-{\n-  iterator_loop_epilogue (idecl, 0, 0);\n-  ITERATOR_BOUND_P (idecl) = 0;\n-}\n-\f\n-/*\n-  \t\tITERATOR RTL EXPANSIONS\n-\n-   Expanding simple statements with iterators is straightforward:\n-   collect the list of all free iterators in the statement, and\n-   generate a loop for each of them.\n-\n-   An iterator is \"free\" if it has not been \"bound\" by a FOR\n-   operator.  The DECL_RTL of the iterator is the loop counter.  */\n-\n-/* Expand a statement STMT, possibly containing iterator usage, into RTL.  */\n-\n-void\n-iterator_expand (stmt)\n-    tree stmt;\n-{\n-  tree iter_list;\n-  save_exprs = NULL_TREE;\n-  iter_list = collect_iterators (stmt, NULL_TREE);\n-  expand_stmt_with_iterators_1 (stmt, iter_list);\n-  istack_sublevel_to_current ();\n-}\n-\n-\n-static void \n-expand_stmt_with_iterators_1 (stmt, iter_list)\n-     tree stmt, iter_list;\n-{\n-  if (iter_list == 0)\n-    expand_expr_stmt (stmt);\n-  else\n-    {\n-      tree current_iterator = TREE_VALUE (iter_list);\n-      tree iter_list_tail   = TREE_CHAIN (iter_list);\n-      rtx p_start, p_end, e_start, e_end;\n-\n-      iterator_loop_prologue (current_iterator, &p_start, &p_end);\n-      expand_stmt_with_iterators_1 (stmt, iter_list_tail);\n-      iterator_loop_epilogue (current_iterator, &e_start, &e_end);\n-\n-      /** Delete all inner expansions based on current_iterator **/\n-      /** before adding the outer one. **/\n-\n-      delete_ixpansion (current_iterator);\n-      add_ixpansion (current_iterator, p_start, p_end, e_start, e_end);\n-    }\n-}\n-\n-\n-/* Return a list containing all the free (i.e. not bound by a\n-   containing `for' statement) iterators mentioned in EXP, plus those\n-   in LIST.  Do not add duplicate entries to the list.  */\n-\n-static tree\n-collect_iterators (exp, list)\n-     tree exp, list;\n-{\n-  if (exp == 0) return list;\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    case VAR_DECL:\n-      if (! ITERATOR_P (exp) || ITERATOR_BOUND_P (exp))\n-\treturn list;\n-      if (value_member (exp, list))\n-\treturn list;\n-      return tree_cons (NULL_TREE, exp, list);\n-\n-    case TREE_LIST:\n-      {\n-\ttree tail;\n-\tfor (tail = exp; tail; tail = TREE_CHAIN (tail))\n-\t  list = collect_iterators (TREE_VALUE (tail), list);\n-\treturn list;\n-      }\n-\n-    case SAVE_EXPR:\n-      /* In each scan, scan a given save_expr only once.  */\n-      if (value_member (exp, save_exprs))\n-\treturn list;\n-\n-      save_exprs = tree_cons (NULL_TREE, exp, save_exprs);\n-      return collect_iterators (TREE_OPERAND (exp, 0), list);\n-\n-      /* we do not automatically iterate blocks -- one must */\n-      /* use the FOR construct to do that */\n-\n-    case BLOCK:\n-      return list;\n-\n-    default:\n-      switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n-\t{\n-\tcase '1':\n-\t  return collect_iterators (TREE_OPERAND (exp, 0), list);\n-\n-\tcase '2':\n-\tcase '<':\n-\t  return collect_iterators (TREE_OPERAND (exp, 0),\n-\t\t\t\t    collect_iterators (TREE_OPERAND (exp, 1),\n-\t\t\t\t\t\t       list));\n-\n-\tcase 'e':\n-\tcase 'r':\n-\t  {\n-\t    int num_args = first_rtl_op (TREE_CODE (exp));\n-\t    int i;\n-\n-\t    for (i = 0; i < num_args; i++)\n-\t      list = collect_iterators (TREE_OPERAND (exp, i), list);\n-\t    return list;\n-\t  }\n-\tdefault:\n-\t  return list;\n-\t}\n-    }\n-}\n-\f\n-/* Emit rtl for the start of a loop for iterator IDECL.\n-\n-   If necessary, create loop counter rtx and store it as DECL_RTL of IDECL.\n-\n-   The prologue normally starts and ends with notes, which are returned\n-   by this function in *START_NOTE and *END_NODE.\n-   If START_NOTE and END_NODE are 0, we don't make those notes.  */\n-\n-static void\n-iterator_loop_prologue (idecl, start_note, end_note)\n-     tree idecl;\n-     rtx *start_note, *end_note;\n-{\n-  tree expr;\n-\n-  /* Force the save_expr in DECL_INITIAL to be calculated\n-     if it hasn't been calculated yet.  */\n-  expand_expr (DECL_INITIAL (idecl), const0_rtx, VOIDmode,\n-\t       EXPAND_NORMAL);\n-\n-  if (DECL_RTL (idecl) == 0)\n-    expand_decl (idecl);\n-\n-  if (start_note)\n-    *start_note = emit_note (0, NOTE_INSN_DELETED);\n-\n-  /* Initialize counter.  */\n-  expr = build (MODIFY_EXPR, TREE_TYPE (idecl), idecl, integer_zero_node);\n-  TREE_SIDE_EFFECTS (expr) = 1;\n-  expand_expr (expr, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  expand_start_loop_continue_elsewhere (1);\n-\n-  ITERATOR_BOUND_P (idecl) = 1;\n-\n-  if (end_note)\n-    *end_note = emit_note (0, NOTE_INSN_DELETED);\n-}\n-\n-/* Similar to the previous function, but for the end of the loop.\n-\n-   DECL_RTL is zeroed unless we are inside \"({...})\". The reason for that is\n-   described below.\n-\n-   When we create two (or more) loops based on the same IDECL, and\n-   both inside the same \"({...})\"  construct, we must be prepared to\n-   delete both of the loops and create a single one on the level\n-   above, i.e.  enclosing the \"({...})\". The new loop has to use the\n-   same counter rtl because the references to the iterator decl\n-   (IDECL) have already been expanded as references to the counter\n-   rtl.\n-\n-   It is incorrect to use the same counter reg in different functions,\n-   and it is desirable to use different counters in disjoint loops\n-   when we know there's no need to combine them (because then they can\n-   get allocated separately).  */\n-\n-static void\n-iterator_loop_epilogue (idecl, start_note, end_note)\n-     tree idecl;\n-     rtx *start_note, *end_note;\n-{\n-  tree test, incr;\n-\n-  if (start_note)\n-    *start_note = emit_note (0, NOTE_INSN_DELETED);\n-  expand_loop_continue_here ();\n-  incr = build_binary_op (PLUS_EXPR, idecl, integer_one_node, 0);\n-  incr = build (MODIFY_EXPR, TREE_TYPE (idecl), idecl, incr);\n-  TREE_SIDE_EFFECTS (incr) = 1;\n-  expand_expr (incr, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-  test = build_binary_op (LT_EXPR, idecl, DECL_INITIAL (idecl), 0);\n-  expand_exit_loop_if_false (0, test);\n-  expand_end_loop ();\n-\n-  ITERATOR_BOUND_P (idecl) = 0;\n-  /* we can reset rtl since there is not chance that this expansion */\n-  /* would be superseded by a higher level one */\n-  /* but don't do this if the decl is static, since we need to share */\n-  /* the same decl in that case.  */\n-  if (top_level_ixpansion_p () && ! TREE_STATIC (idecl))\n-    DECL_RTL (idecl) = 0;\n-  if (end_note)\n-    *end_note = emit_note (0, NOTE_INSN_DELETED);\n-}\n-\f\n-/* Return true if we are not currently inside a \"({...})\" construct.  */\n-\n-static int\n-top_level_ixpansion_p ()\n-{\n-  return iter_stack == 0;\n-}\n-\n-/* Given two chains of iter_stack_nodes,\n-   append the nodes in X into Y.  */\n-\n-static void\n-isn_append (x, y)\n-     struct iter_stack_node *x, *y;\n-{\n-  if (x->first == 0) \n-    return;\n-\n-  if (y->first == 0)\n-    {\n-      y->first = x->first;\n-      y->last  = x->last;\n-    }\n-  else\n-    {\n-      y->last->next = x->first;\n-      y->last = x->last;\n-    }\n-}\n-\n-/** Make X empty **/\n-\n-#define ISN_ZERO(X) (X).first=(X).last=0\n-\f\n-/* Move the ixpansions in sublevel_ixpansions into the current\n-   node on the iter_stack, or discard them if the iter_stack is empty.\n-   We do this at the end of a statement.  */\n-\n-static void\n-istack_sublevel_to_current ()\n-{\n-  /* At the top level we can throw away sublevel's expansions  **/\n-  /* because there is nobody above us to ask for a cleanup **/\n-  if (iter_stack != 0)\n-    /** Merging with empty sublevel list is a no-op **/\n-    if (sublevel_ixpansions.last)\n-      isn_append (&sublevel_ixpansions, iter_stack);\n-\n-  if (iter_stack == 0)\n-    obstack_free (&ixp_obstack, ixp_firstobj);\n-\n-  ISN_ZERO (sublevel_ixpansions);\n-}\n-\n-/* Push a new node on the iter_stack, when we enter a ({...}).  */\n-\n-void\n-push_iterator_stack ()\n-{\n-  struct iter_stack_node *new_top\n-    = (struct iter_stack_node *) \n-      obstack_alloc (&ixp_obstack, sizeof (struct iter_stack_node));\n-\n-  new_top->first = 0;\n-  new_top->last = 0;\n-  new_top->next = iter_stack;\n-  iter_stack = new_top;\n-}\n-\n-/* Pop iter_stack, moving the ixpansions in the node being popped\n-   into sublevel_ixpansions.  */\n-\n-void\n-pop_iterator_stack ()\n-{\n-  if (iter_stack == 0)\n-    abort ();\n-\n-  isn_append (iter_stack, &sublevel_ixpansions);\n-  /** Pop current level node: */\n-  iter_stack = iter_stack->next;\n-}\n-\f\n-\n-/* Record an iterator expansion (\"ixpansion\") for IDECL.\n-   The remaining parameters are the notes in the loop entry\n-   and exit rtl.  */\n-\n-static void\n-add_ixpansion (idecl, pro_start, pro_end, epi_start, epi_end)\n-     tree idecl;\n-     rtx pro_start, pro_end, epi_start, epi_end;\n-{\n-  struct ixpansion *newix;\n-    \n-  /* Do nothing if we are not inside \"({...})\",\n-     as in that case this expansion can't need subsequent RTL modification.  */\n-  if (iter_stack == 0)\n-    return;\n-\n-  newix = (struct ixpansion *) obstack_alloc (&ixp_obstack,\n-\t\t\t\t\t      sizeof (struct ixpansion));\n-  newix->ixdecl = idecl;\n-  newix->ixprologue_start = pro_start;\n-  newix->ixprologue_end   = pro_end;\n-  newix->ixepilogue_start = epi_start;\n-  newix->ixepilogue_end   = epi_end;\n-\n-  newix->next = iter_stack->first;\n-  iter_stack->first = newix;\n-  if (iter_stack->last == 0)\n-    iter_stack->last = newix;\n-}\n-\n-/* Delete the RTL for all ixpansions for iterator IDECL\n-   in our sublevels.  We do this when we make a larger\n-   containing expansion for IDECL.  */\n-\n-static void\n-delete_ixpansion (idecl)\n-     tree idecl;\n-{\n-  struct ixpansion *previx = 0, *ix;\n-\n-  for (ix = sublevel_ixpansions.first; ix; ix = ix->next)\n-    if (ix->ixdecl == idecl)\n-      {\n-\t/** zero means that this is a mark for FOR -- **/\n-\t/** we do not delete anything, just issue an error. **/\n-\n-\tif (ix->ixprologue_start == 0)\n-\t  error_with_decl (idecl,\n-\t\t\t   \"`for (%s)' appears within implicit iteration\");\n-\telse\n-\t  {\n-\t    rtx insn;\n-\t    /* We delete all insns, including notes because leaving loop */\n-\t    /* notes and barriers produced by iterator expansion would */\n-\t    /* be misleading to other phases */\n-\n-\t    for (insn = NEXT_INSN (ix->ixprologue_start);\n-\t\t insn != ix->ixprologue_end;\n-\t\t insn = NEXT_INSN (insn)) \n-\t      delete_insn (insn);\n-\t    for (insn = NEXT_INSN (ix->ixepilogue_start);\n-\t\t insn != ix->ixepilogue_end;\n-\t\t insn = NEXT_INSN (insn)) \n-\t      delete_insn (insn);\n-\t  }\n-\n-\t/* Delete this ixpansion from sublevel_ixpansions.  */\n-\tif (previx)\n-\t  previx->next = ix->next;\n-\telse \n-\t  sublevel_ixpansions.first = ix->next;\n-\tif (sublevel_ixpansions.last == ix)\n-\t  sublevel_ixpansions.last = previx;\n-      }\n-    else\n-      previx = ix;\n-}\n-\f\n-#ifdef DEBUG_ITERATORS\n-\n-/* The functions below are for use from source level debugger.\n-   They print short forms of iterator lists and the iterator stack.  */\n-\n-/* Print the name of the iterator D.  */\n-\n-void\n-prdecl (d)\n-     tree d;\n-{\n-  if (d)\n-    {\n-      if (TREE_CODE (d) == VAR_DECL)\n-\t{\n-\t  tree tname = DECL_NAME (d);\n-\t  char *dname = IDENTIFIER_POINTER (tname);\n-\t  fprintf (stderr, dname);\n-\t}\n-      else\n-\tfprintf (stderr, \"<<?>>\");\n-    }\n-  else\n-    fprintf (stderr, \"<<0>>\");\n-}\n-\n-/* Print Iterator List -- names only */\n-\n-tree\n-pil (head)\n-     tree head;\n-{\n-  tree current, next;\n-  for (current = head; current; current = next)\n-    {\n-      tree node = TREE_VALUE (current);\n-      prdecl (node);\n-      next = TREE_CHAIN (current);\n-      if (next) fprintf (stderr, \",\");\n-    }\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-/* Print IXpansion List */\n-\n-struct ixpansion *\n-pixl (head)\n-     struct ixpansion *head;\n-{\n-  struct ixpansion *current, *next;\n-  fprintf (stderr, \"> \");\n-  if (head == 0)\n-    fprintf (stderr, \"(empty)\");\n-\t\n-  for (current=head; current; current = next)\n-    {\n-      tree node = current->ixdecl;\n-      prdecl (node);\n-      next = current->next;\n-      if (next)\n-\tfprintf (stderr, \",\");\n-    }\n-  fprintf (stderr, \"\\n\");\n-  return head;\n-}\n-\n-/* Print Iterator Stack.  */\n-\n-void\n-pis ()\n-{\n-  struct iter_stack_node *stack_node;\n-\n-  fprintf (stderr, \"--SubLevel: \");\n-  pixl (sublevel_ixpansions.first);\n-  fprintf (stderr, \"--Stack:--\\n\");\n-  for (stack_node = iter_stack;\n-       stack_node;\n-       stack_node = stack_node->next)\n-    pixl (stack_node->first);\n-}\n-\n-#endif /* DEBUG_ITERATORS */"}, {"sha": "867c7be5519cd2f5773bad578a13793316286f86", "filename": "gcc/c-lex.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -300,7 +300,6 @@ init_lex ()\n   ridpointers[(int) RID_EXTERN] = get_identifier (\"extern\");\n   ridpointers[(int) RID_TYPEDEF] = get_identifier (\"typedef\");\n   ridpointers[(int) RID_REGISTER] = get_identifier (\"register\");\n-  ridpointers[(int) RID_ITERATOR] = get_identifier (\"iterator\");\n   ridpointers[(int) RID_COMPLEX] = get_identifier (\"complex\");\n   ridpointers[(int) RID_ID] = get_identifier (\"id\");\n   ridpointers[(int) RID_IN] = get_identifier (\"in\");\n@@ -328,7 +327,6 @@ init_lex ()\n       UNSET_RESERVED_WORD (\"typeof\");\n       UNSET_RESERVED_WORD (\"signed\");\n       UNSET_RESERVED_WORD (\"inline\");\n-      UNSET_RESERVED_WORD (\"iterator\");\n       UNSET_RESERVED_WORD (\"complex\");\n     }\n   else if (!flag_isoc99)\n@@ -340,7 +338,6 @@ init_lex ()\n       UNSET_RESERVED_WORD (\"typeof\");\n       if (! flag_isoc99)\n \tUNSET_RESERVED_WORD (\"inline\");\n-      UNSET_RESERVED_WORD (\"iterator\");\n       UNSET_RESERVED_WORD (\"complex\");\n     }\n }"}, {"sha": "1f36392b0440e2a654c4cca8c6e88b648d37413a", "filename": "gcc/c-parse.gperf", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-parse.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-parse.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.gperf?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -41,8 +41,6 @@ __imag, IMAGPART, NORID\n __imag__, IMAGPART, NORID\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n-__iterator, SCSPEC, RID_ITERATOR\n-__iterator__, SCSPEC, RID_ITERATOR\n __label__, LABEL, NORID\n __ptrbase, PTR_BASE, NORID\n __ptrbase__, PTR_BASE, NORID"}, {"sha": "469cb5f336e8651a3451d78904ef8a5ac10c190f", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -656,7 +656,6 @@ primary:\n \t\t{ tree rtl_exp;\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C forbids braced-groups within expressions\");\n-\t\t  pop_iterator_stack ();\n \t\t  pop_label_level ();\n \t\t  rtl_exp = expand_end_stmt_expr ($1);\n \t\t  /* The statements have side effects, so the group does.  */\n@@ -679,7 +678,6 @@ primary:\n \t\t{\n \t\t  /* Make sure we call expand_end_stmt_expr.  Otherwise\n \t\t     we are likely to lose sequences and crash later.  */\n-\t\t  pop_iterator_stack ();\n \t\t  pop_label_level ();\n \t\t  expand_end_stmt_expr ($1);\n \t\t  $$ = error_mark_node;\n@@ -1673,7 +1671,6 @@ compstmt_primary_start:\n \t\t     there is a way to turn off the entire subtree of blocks\n \t\t     that are contained in it.  */\n \t\t  keep_next_level ();\n-\t\t  push_iterator_stack ();\n \t\t  push_label_level ();\n \t\t  $$ = expand_start_stmt_expr ();\n \t\t  compstmt_count++;\n@@ -1753,7 +1750,6 @@ stmt_or_label:\n stmt:\n \t  compstmt\n \t\t{ stmt_count++; }\n-        | all_iter_stmt \n \t| expr ';'\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n@@ -1769,7 +1765,7 @@ stmt:\n \t\t      || TREE_CODE (TREE_TYPE ($1)) == FUNCTION_TYPE)\n \t\t    $1 = default_conversion ($1);\n #endif\n-\t\t  iterator_expand ($1); }\n+\t\t  expand_expr_stmt ($1); }\n \t| simple_if ELSE\n \t\t{ c_expand_start_else ();\n \t\t  $<itype>1 = stmt_count;\n@@ -1933,60 +1929,6 @@ stmt:\n \t| ';'\n \t;\n \n-all_iter_stmt:\n-\t  all_iter_stmt_simple\n-/*\t| all_iter_stmt_with_decl */\n-\t;\n-\n-all_iter_stmt_simple:\n-\t  FOR '(' primary ')' \n-\t  {\n-\t    /* The value returned by this action is  */\n-\t    /*      1 if everything is OK */ \n-\t    /*      0 in case of error or already bound iterator */\n-\n-\t    $<itype>$ = 0;\n-\t    if (TREE_CODE ($3) != VAR_DECL)\n-\t      error (\"invalid `for (ITERATOR)' syntax\");\n-\t    else if (! ITERATOR_P ($3))\n-\t      error (\"`%s' is not an iterator\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n-\t    else if (ITERATOR_BOUND_P ($3))\n-\t      error (\"`for (%s)' inside expansion of same iterator\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n-\t    else\n-\t      {\n-\t\t$<itype>$ = 1;\n-\t\titerator_for_loop_start ($3);\n-\t      }\n-\t  }\n-\t  lineno_labeled_stmt\n-\t  {\n-\t    if ($<itype>5)\n-\t      iterator_for_loop_end ($3);\n-\t  }\n-\n-/*  This really should allow any kind of declaration,\n-    for generality.  Fix it before turning it back on.\n-\n-all_iter_stmt_with_decl:\n-\t  FOR '(' ITERATOR pushlevel setspecs iterator_spec ')' \n-\t  {\n-*/\t    /* The value returned by this action is  */\n-\t    /*      1 if everything is OK */ \n-\t    /*      0 in case of error or already bound iterator */\n-/*\n-\t    iterator_for_loop_start ($6);\n-\t  }\n-\t  lineno_labeled_stmt\n-\t  {\n-\t    iterator_for_loop_end ($6);\n-\t    emit_line_note (input_filename, lineno);\n-\t    expand_end_bindings (getdecls (), 1, 0);\n-\t    $<ttype>$ = poplevel (1, 1, 0);\n-\t  }\n-*/\n-\n /* Any kind of label, including jump labels and case labels.\n    ANSI C accepts labels only before statements, but we allow them\n    also at the end of a compound statement.  */"}, {"sha": "af9a3b60d2578962f7ef676eb8c6236adcf9eac9", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -126,12 +126,6 @@ struct lang_type\n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n #define DECL_C_BIT_FIELD(NODE) DECL_LANG_FLAG_4 (NODE)\n \n-/* In a VAR_DECL, means the variable is really an iterator.  */\n-#define ITERATOR_P(D) (DECL_LANG_FLAG_4(D))\n-\n-/* In a VAR_DECL for an iterator, means we are within\n-   an explicit loop over that iterator.  */\n-#define ITERATOR_BOUND_P(NODE) ((NODE)->common.readonly_flag)\n \f\n /* in c-lang.c and objc-act.c */\n extern tree lookup_interface\t\t\tPARAMS ((tree));\n@@ -262,15 +256,6 @@ extern void process_init_element\t\tPARAMS ((tree));\n extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n \n-/* in c-iterate.c */\n-extern void init_iterators\t\t\tPARAMS ((void));\n-extern void iterator_expand\t\t\tPARAMS ((tree));\n-extern void iterator_for_loop_start\t\tPARAMS ((tree));\n-extern void iterator_for_loop_end\t\tPARAMS ((tree));\n-extern void iterator_for_loop_record\t\tPARAMS ((tree));\n-extern void push_iterator_stack\t\t\tPARAMS ((void));\n-extern void pop_iterator_stack\t\t\tPARAMS ((void));\n-\n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n "}, {"sha": "cd787d97295f495574d45aa4434591e52dc619e1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -847,7 +847,7 @@ decl_constant_value (decl)\n       current_function_decl != 0\n       && ! pedantic\n       && ! TREE_THIS_VOLATILE (decl)\n-      && TREE_READONLY (decl) && ! ITERATOR_P (decl)\n+      && TREE_READONLY (decl)\n       && DECL_INITIAL (decl) != 0\n       && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK\n       /* This is invalid if initial value is not constant.\n@@ -3280,11 +3280,6 @@ readonly_warning (arg, msgid)\n      tree arg;\n      const char *msgid;\n {\n-  /* Forbid assignments to iterators.  */\n-  if (TREE_CODE (arg) == VAR_DECL && ITERATOR_P (arg))\n-    pedwarn (\"%s of iterator `%s'\",  _(msgid), \n-\t     IDENTIFIER_POINTER (DECL_NAME (arg)));\n-\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))"}, {"sha": "9c15d173b6991056c4b488b2b8e9a58c2ef30d71", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -1,3 +1,7 @@\n+2000-08-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (cc1chill): Don't depend on c-iterate.o.\n+\n 2000-08-21  Nix  <nix@esperi.demon.co.uk>\n \n \t* lang-specs.h: Do not process -o or run the assembler if"}, {"sha": "7554b8e77a585d348ad20f5b02cc8a2dae6c9f07", "filename": "gcc/ch/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fch%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Fch%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMake-lang.in?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -1,5 +1,5 @@\n # Top level Makefile fragment for GNU CHILL.\n-#   Copyright (C) 1994, 1998 Free Software Foundation, Inc.\n+#   Copyright (C) 1994, 1998, 2000 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -95,7 +95,7 @@ chill-cross: $(srcdir)/ch/chill.in\n \n cc1chill$(exeext): $(P) $(CHILL_SRCS) $(LIBDEPS) $(BACKEND) \\\n \tinsn-config.h insn-flags.h insn-attr.h insn-codes.h \\\n-\tc-typeck.o c-aux-info.o c-common.o c-iterate.o \\\n+\tc-typeck.o c-aux-info.o c-common.o \\\n         ggc-callbacks.o\n \tcd ch; $(MAKE) $(LANG_FLAGS_TO_PASS) $(CHILL_FLAGS_TO_PASS) ../cc1chill$(exeext)\n "}, {"sha": "0ce3b7fcefea74b9d7234e7b5889017719d0a2d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -1,3 +1,7 @@\n+2000-08-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/930622-2.c: Adjust error message.\n+\n 2000-08-24  Richard Henderson  <rth@cygnus.com>\n \n \t* gcc.dg/ia64-sync-1.c: New test."}, {"sha": "a1450afbf1fccc7106a0b4859a85e7acfc5a6457", "filename": "gcc/testsuite/gcc.dg/noncompile/930622-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F930622-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F930622-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F930622-2.c?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -1,6 +1,6 @@\n f ()\n {\n   int i;\n-  for (i--)\t/* { dg-error \"syntax\" } */\n+  for (i--)\t/* { dg-error \"parse\" } */\n     ;\n }"}, {"sha": "067af986a267274f2e9b70ab1dfea1b3fb23ee28", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bab8db08a04afe820ffd6b159a0de852ef0ae0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=83bab8db08a04afe820ffd6b159a0de852ef0ae0", "patch": "@@ -219,8 +219,6 @@ struct tree_common\n \n        TREE_READONLY in\n            all expressions\n-       ITERATOR_BOUND_P in\n-           VAR_DECL if iterator (C)\n        TYPE_READONLY in\n            ..._TYPE\n "}]}