{"sha": "61dde664e4595c54df930963a2f7b731a8566bc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFkZGU2NjRlNDU5NWM1NGRmOTMwOTYzYTJmN2I3MzFhODU2NmJjOA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-07-17T18:24:46Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-07-17T18:24:46Z"}, "message": "regrename.c (maybe_mode_change): New function.\n\n\t* regrename.c (maybe_mode_change): New function.\n\t(find_oldest_value_reg, copyprop_hardreg_forward_1): Use it.\n\nFrom-SVN: r55541", "tree": {"sha": "1a3d40d300bfbabee7ce1905f8fc6645b753f36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a3d40d300bfbabee7ce1905f8fc6645b753f36b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61dde664e4595c54df930963a2f7b731a8566bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61dde664e4595c54df930963a2f7b731a8566bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61dde664e4595c54df930963a2f7b731a8566bc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61dde664e4595c54df930963a2f7b731a8566bc8/comments", "author": null, "committer": null, "parents": [{"sha": "97f51ac4afce58ff9db51095f4125ae6b80e6c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97f51ac4afce58ff9db51095f4125ae6b80e6c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97f51ac4afce58ff9db51095f4125ae6b80e6c2b"}], "stats": {"total": 87, "additions": 61, "deletions": 26}, "files": [{"sha": "57d6846283fa45fd3351bb722c7e43b159d0ea79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61dde664e4595c54df930963a2f7b731a8566bc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61dde664e4595c54df930963a2f7b731a8566bc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61dde664e4595c54df930963a2f7b731a8566bc8", "patch": "@@ -1,3 +1,8 @@\n+Wed Jul 17 19:23:32 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* regrename.c (maybe_mode_change): New function.\n+\t(find_oldest_value_reg, copyprop_hardreg_forward_1): Use it.\n+\n 2002-07-17  Rodney Brown  <rbrown64@csc.com.au>\n \n \t* config/i386/i386.c (ix86_expand_int_movcc): In the general case"}, {"sha": "fafc4cfa1b7e8e6335733dc0224655f8df1c2d94", "filename": "gcc/regrename.c", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61dde664e4595c54df930963a2f7b731a8566bc8/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61dde664e4595c54df930963a2f7b731a8566bc8/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=61dde664e4595c54df930963a2f7b731a8566bc8", "patch": "@@ -1049,6 +1049,9 @@ static int kill_autoinc_value PARAMS ((rtx *, void *));\n static void copy_value PARAMS ((rtx, rtx, struct value_data *));\n static bool mode_change_ok PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t    unsigned int));\n+static rtx maybe_mode_change PARAMS ((enum machine_mode, enum machine_mode,\n+\t\t\t\t      enum machine_mode, unsigned int,\n+\t\t\t\t      unsigned int));\n static rtx find_oldest_value_reg PARAMS ((enum reg_class, rtx,\n \t\t\t\t\t  struct value_data *));\n static bool replace_oldest_value_reg PARAMS ((rtx *, enum reg_class, rtx,\n@@ -1326,6 +1329,39 @@ mode_change_ok (orig_mode, new_mode, regno)\n   return true;\n }\n \n+/* Register REGNO was originally set in ORIG_MODE.  It - or a copy of it -\n+   was copied in COPY_MODE to COPY_REGNO, and then COPY_REGNO was accessed\n+   in NEW_MODE.\n+   Return a NEW_MODE rtx for REGNO if that's OK, otherwise return NULL_RTX.  */\n+\n+static rtx\n+maybe_mode_change (orig_mode, copy_mode, new_mode, regno, copy_regno)\n+     enum machine_mode orig_mode, copy_mode, new_mode;\n+     unsigned int regno, copy_regno;\n+{\n+  if (orig_mode == new_mode)\n+    return gen_rtx_raw_REG (new_mode, regno);\n+  else if (mode_change_ok (orig_mode, new_mode, regno))\n+    {\n+      int copy_nregs = HARD_REGNO_NREGS (copy_regno, copy_mode);\n+      int use_nregs = HARD_REGNO_NREGS (copy_regno, new_mode);\n+      int copy_offset\n+\t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n+      int offset\n+\t= GET_MODE_SIZE (orig_mode) - GET_MODE_SIZE (new_mode) - copy_offset;\n+      int byteoffset = offset % UNITS_PER_WORD;\n+      int wordoffset = offset - byteoffset;\n+\n+      offset = ((WORDS_BIG_ENDIAN ? wordoffset : 0)\n+\t\t+ (BYTES_BIG_ENDIAN ? byteoffset : 0));\n+      return gen_rtx_raw_REG (new_mode,\n+\t\t\t      regno + subreg_regno_offset (regno, orig_mode,\n+\t\t\t\t\t\t\t   offset,\n+\t\t\t\t\t\t\t   new_mode));\n+    }\n+  return NULL_RTX;\n+}\n+\n /* Find the oldest copy of the value contained in REGNO that is in\n    register class CLASS and has mode MODE.  If found, return an rtx\n    of that oldest register, otherwise return NULL.  */\n@@ -1357,20 +1393,12 @@ find_oldest_value_reg (class, reg, vd)\n   for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n     {\n       enum machine_mode oldmode = vd->e[i].mode;\n+      rtx new;\n \n     if (TEST_HARD_REG_BIT (reg_class_contents[class], i)\n-\t&& (oldmode == mode\n-\t    || mode_change_ok (oldmode, mode, i)))\n+\t&& (new = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i,\n+\t\t\t\t     regno)))\n       {\n-\tint offset = GET_MODE_SIZE (oldmode) - GET_MODE_SIZE (mode);\n-\tint byteoffset = offset % UNITS_PER_WORD;\n-\tint wordoffset = offset - byteoffset;\n-\trtx new;\n-\n-\toffset = ((WORDS_BIG_ENDIAN ? wordoffset : 0)\n-\t\t  + (BYTES_BIG_ENDIAN ? byteoffset : 0));\n-\tnew = (gen_rtx_raw_REG\n-\t       (mode, i + subreg_regno_offset (i, oldmode, offset, mode)));\n \tORIGINAL_REGNO (new) = ORIGINAL_REGNO (reg);\n \treturn new;\n       }\n@@ -1657,21 +1685,23 @@ copyprop_hardreg_forward_1 (bb, vd)\n \t  /* Otherwise, try all valid registers and see if its valid.  */\n \t  for (i = vd->e[regno].oldest_regno; i != regno;\n \t       i = vd->e[i].next_regno)\n-\t    if (vd->e[i].mode == mode\n-\t\t|| mode_change_ok (vd->e[i].mode, mode, i))\n-\t      {\n-\t\tnew = gen_rtx_raw_REG (mode, i);\n-\t\tif (validate_change (insn, &SET_SRC (set), new, 0))\n-\t\t  {\n-\t\t    ORIGINAL_REGNO (new) = ORIGINAL_REGNO (src);\n-\t\t    if (rtl_dump_file)\n-\t\t      fprintf (rtl_dump_file,\n-\t\t\t       \"insn %u: replaced reg %u with %u\\n\",\n-\t\t\t       INSN_UID (insn), regno, REGNO (new));\n-\t\t    changed = true;\n-\t\t    goto did_replacement;\n-\t\t  }\n-\t      }\n+\t    {\n+\t      new = maybe_mode_change (vd->e[i].mode, vd->e[regno].mode,\n+\t\t\t\t       mode, i, regno);\n+\t      if (new != NULL_RTX)\n+\t\t{\n+\t\t  if (validate_change (insn, &SET_SRC (set), new, 0))\n+\t\t    {\n+\t\t      ORIGINAL_REGNO (new) = ORIGINAL_REGNO (src);\n+\t\t      if (rtl_dump_file)\n+\t\t\tfprintf (rtl_dump_file,\n+\t\t\t\t \"insn %u: replaced reg %u with %u\\n\",\n+\t\t\t\t INSN_UID (insn), regno, REGNO (new));\n+\t\t      changed = true;\n+\t\t      goto did_replacement;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n       no_move_special_case:\n "}]}