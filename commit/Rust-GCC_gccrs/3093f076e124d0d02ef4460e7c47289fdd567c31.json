{"sha": "3093f076e124d0d02ef4460e7c47289fdd567c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5M2YwNzZlMTI0ZDBkMDJlZjQ0NjBlN2M0NzI4OWZkZDU2N2MzMQ==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-12-07T19:56:32Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-12-07T19:56:32Z"}, "message": "s390.c (s390_expand_mask_and_shift, [...]): New.\n\n2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_mask_and_shift, \n\tstruct alignment_context, init_alignment_context, \n\ts390_expand_cs_hqi): New.\n\t* config/s390/s390-protos.h (s390_expand_cs_hqi): Declare.\n\t* config/s390/s390.md (\"sync_compare_and_swaphi\",\n\t\"sync_compare_and_swapqi\"): New pattern.\n\n\t* lib/target-supports.exp (check_effective_target_sync_char_short):\n\tAdd s390*.\n\nFrom-SVN: r108178", "tree": {"sha": "e48a15246e3bdc728e23dc58b96dfc829f851557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e48a15246e3bdc728e23dc58b96dfc829f851557"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3093f076e124d0d02ef4460e7c47289fdd567c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3093f076e124d0d02ef4460e7c47289fdd567c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3093f076e124d0d02ef4460e7c47289fdd567c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3093f076e124d0d02ef4460e7c47289fdd567c31/comments", "author": null, "committer": null, "parents": [{"sha": "634010f7c8975c560733fea6f7318a307ebe64d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634010f7c8975c560733fea6f7318a307ebe64d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634010f7c8975c560733fea6f7318a307ebe64d7"}], "stats": {"total": 182, "additions": 182, "deletions": 0}, "files": [{"sha": "b7b8ff80509d024c0252b558abf66d0a8c9a0ae3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3093f076e124d0d02ef4460e7c47289fdd567c31", "patch": "@@ -1,3 +1,12 @@\n+2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_mask_and_shift, \n+\tstruct alignment_context, init_alignment_context, \n+\ts390_expand_cs_hqi): New.\n+\t* config/s390/s390-protos.h (s390_expand_cs_hqi): Declare.\n+\t* config/s390/s390.md (\"sync_compare_and_swaphi\",\n+\t\"sync_compare_and_swapqi\"): New pattern.\n+\n 2005-12-07  Daniel Berlin <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/25291"}, {"sha": "bb1516a88e52d5161aacfdd246c2950a6076a021", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=3093f076e124d0d02ef4460e7c47289fdd567c31", "patch": "@@ -75,6 +75,7 @@ extern void s390_expand_setmem (rtx, rtx, rtx);\n extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n+extern void s390_expand_cs_hqi (enum machine_mode, rtx, rtx, rtx, rtx);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);\n extern rtx s390_emit_call (rtx, rtx, rtx, rtx);"}, {"sha": "880ebdd108317b4b5de02a53e5e7f2ffd464effc", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=3093f076e124d0d02ef4460e7c47289fdd567c31", "patch": "@@ -3972,6 +3972,156 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n   return false;\n }\n \n+/* A subroutine of s390_expand_cs_hqi which returns a register which holds VAL\n+   of mode MODE shifted by COUNT bits.  */\n+\n+static inline rtx\n+s390_expand_mask_and_shift (rtx val, enum machine_mode mode, rtx count)\n+{\n+  val = expand_simple_binop (SImode, AND, val, GEN_INT (GET_MODE_MASK (mode)),\n+\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+  return expand_simple_binop (SImode, ASHIFT, val, count, \n+\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+}\n+\n+/* Structure to hold the initial parameters for a compare_and_swap operation\n+   in HImode and QImode.  */ \n+\n+struct alignment_context\n+{\n+  rtx memsi;\t  /* SI aligned memory location.  */ \n+  rtx shift;\t  /* Bit offset with regard to lsb.  */\n+  rtx modemask;\t  /* Mask of the HQImode shifted by SHIFT bits.  */\n+  rtx modemaski;  /* ~modemask */\n+  bool aligned;\t  /* True if memory is aliged, false else.  */\n+};\n+\n+/* A subroutine of s390_expand_cs_hqi to initialize the structure AC for\n+   transparent simplifying, if the memory alignment is known to be at least\n+   32bit.  MEM is the memory location for the actual operation and MODE its\n+   mode.  */\n+\n+static void\n+init_alignment_context (struct alignment_context *ac, rtx mem,\n+\t\t\tenum machine_mode mode)\n+{\n+  ac->shift = GEN_INT (GET_MODE_SIZE (SImode) - GET_MODE_SIZE (mode));\n+  ac->aligned = (MEM_ALIGN (mem) >= GET_MODE_BITSIZE (SImode));\n+\n+  if (ac->aligned)\n+    ac->memsi = adjust_address (mem, SImode, 0); /* Memory is aligned.  */\n+  else\n+    {\n+      /* Alignment is unknown.  */\n+      rtx byteoffset, addr, align;\n+\n+      /* Force the address into a register.  */\n+      addr = force_reg (Pmode, XEXP (mem, 0));\n+\n+      /* Align it to SImode.  */\n+      align = expand_simple_binop (Pmode, AND, addr,\n+\t\t\t\t   GEN_INT (-GET_MODE_SIZE (SImode)),\n+\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n+      /* Generate MEM.  */\n+      ac->memsi = gen_rtx_MEM (SImode, align);\n+      MEM_VOLATILE_P (ac->memsi) = MEM_VOLATILE_P (mem);\n+      set_mem_align (ac->memsi, GET_MODE_BITSIZE (SImode));\n+\n+      /* Calculate shiftcount.  */\n+      byteoffset = expand_simple_binop (Pmode, AND, addr,\n+\t\t\t\t\tGEN_INT (GET_MODE_SIZE (SImode) - 1),\n+\t\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT);\n+      /* As we already have some offset, evaluate the remaining distance.  */\n+      ac->shift = expand_simple_binop (SImode, MINUS, ac->shift, byteoffset,\n+\t\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+\n+    }\n+  /* Shift is the byte count, but we need the bitcount.  */\n+  ac->shift = expand_simple_binop (SImode, MULT, ac->shift, GEN_INT (BITS_PER_UNIT),\n+\t\t\t\t  NULL_RTX, 1, OPTAB_DIRECT);\n+  /* Calculate masks.  */\n+  ac->modemask = expand_simple_binop (SImode, ASHIFT, \n+\t\t\t\t     GEN_INT (GET_MODE_MASK (mode)), ac->shift,\n+\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+  ac->modemaski = expand_simple_unop (SImode, NOT, ac->modemask, NULL_RTX, 1);\n+}\n+\n+/* Expand an atomic compare and swap operation for HImode and QImode.  MEM is\n+   the memory location, CMP the old value to compare MEM with and NEW the value\n+   to set if CMP == MEM.\n+   CMP is never in memory for compare_and_swap_cc because\n+   expand_bool_compare_and_swap puts it into a register for later compare.  */\n+\n+void\n+s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx new)\n+{\n+  struct alignment_context ac;\n+  rtx cmpv, newv, val, resv, cc;\n+  rtx res = gen_reg_rtx (SImode);\n+  rtx csloop = gen_label_rtx ();\n+  rtx csend = gen_label_rtx ();\n+\n+  gcc_assert (register_operand (target, VOIDmode));\n+  gcc_assert (MEM_P (mem));\n+\n+  init_alignment_context (&ac, mem, mode);\n+\n+  /* Shift the values to the correct bit positions.  */\n+  if (!(ac.aligned && MEM_P (cmp)))\n+    cmp = s390_expand_mask_and_shift (cmp, mode, ac.shift);\n+  if (!(ac.aligned && MEM_P (new)))\n+    new = s390_expand_mask_and_shift (new, mode, ac.shift);\n+\n+  /* Load full word.  Subsequent loads are performed by CS.  */\n+  val = expand_simple_binop (SImode, AND, ac.memsi, ac.modemaski,\n+\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+\n+  /* Start CS loop.  */\n+  emit_label (csloop);\n+  /* val = \"<mem>00..0<mem>\" \n+   * cmp = \"00..0<cmp>00..0\"\n+   * new = \"00..0<new>00..0\" \n+   */\n+\n+  /* Patch cmp and new with val at correct position.  */\n+  if (ac.aligned && MEM_P (cmp))\n+    {\n+      cmpv = force_reg (SImode, val);\n+      store_bit_field (cmpv, GET_MODE_BITSIZE (mode), 0, SImode, cmp);\n+    }\n+  else\n+    cmpv = force_reg (SImode, expand_simple_binop (SImode, IOR, cmp, val,\n+\t\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n+  if (ac.aligned && MEM_P (new))\n+    {\n+      newv = force_reg (SImode, val);\n+      store_bit_field (newv, GET_MODE_BITSIZE (mode), 0, SImode, new);\n+    }\n+  else\n+    newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new, val,\n+\t\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n+\n+  /* Emit compare_and_swap pattern.  */\n+  emit_insn (gen_sync_compare_and_swap_ccsi (res, ac.memsi, cmpv, newv));\n+      \n+  /* Jump to end if we're done (likely?).  */\n+  s390_emit_jump (csend, s390_emit_compare (EQ, cmpv, ac.memsi));\n+\n+  /* Check for changes outside mode.  */\n+  resv = expand_simple_binop (SImode, AND, res, ac.modemaski, \n+\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+  cc = s390_emit_compare (NE, resv, val); \n+  emit_move_insn (val, resv);\n+  /* Loop internal if so.  */\n+  s390_emit_jump (csloop, cc);\n+\n+  emit_label (csend);\n+  \n+  /* Return the correct part of the bitfield.  */\n+  convert_move (target, expand_simple_binop (SImode, LSHIFTRT, res, ac.shift, \n+\t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT), 1);\n+}\n+\n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */\n "}, {"sha": "d75015d5688a15cdd3e803fe091ea79fc48bd883", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=3093f076e124d0d02ef4460e7c47289fdd567c31", "patch": "@@ -7270,6 +7270,22 @@\n \t  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n   \"\")\n \n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(parallel\n+    [(set (match_operand:HQI 0 \"register_operand\" \"\")\n+\t  (match_operand:HQI 1 \"memory_operand\" \"\"))\n+     (set (match_dup 1)\n+\t  (unspec_volatile:HQI\n+\t    [(match_dup 1)\n+\t     (match_operand:HQI 2 \"general_operand\" \"\")\n+\t     (match_operand:HQI 3 \"general_operand\" \"\")]\n+\t    UNSPECV_CAS))\n+     (set (reg:CCZ1 CC_REGNUM)\n+\t  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1], \n+\t\t       operands[2], operands[3]); DONE;\")\n+\n (define_expand \"sync_compare_and_swap_cc<mode>\"\n   [(parallel\n     [(set (match_operand:TDSI 0 \"register_operand\" \"\")"}, {"sha": "ec769baab19a7db3bb36abc86b833c648f7bd3a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3093f076e124d0d02ef4460e7c47289fdd567c31", "patch": "@@ -1,3 +1,8 @@\n+2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_sync_char_short):\n+\tAdd s390*.\n+\n 2005-12-06  Janis Johnson  <janis187@us.ibm.com>\n \n \t* lib/gcc-dg.exp (cleanup-dump): Remove options from test name."}, {"sha": "edafc749b52264bfca3c4183872ad42b87bc9fad", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3093f076e124d0d02ef4460e7c47289fdd567c31/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=3093f076e124d0d02ef4460e7c47289fdd567c31", "patch": "@@ -1380,6 +1380,7 @@ proc check_effective_target_sync_char_short { } {\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*]\n \t     || [istarget alpha*-*-*] \n+\t     || [istarget s390*-*-*] \n \t     || [istarget powerpc*-*-*] } {\n            set et_sync_char_short_saved 1\n         }"}]}