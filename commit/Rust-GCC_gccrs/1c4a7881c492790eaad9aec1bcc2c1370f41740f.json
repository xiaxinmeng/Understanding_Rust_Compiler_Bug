{"sha": "1c4a7881c492790eaad9aec1bcc2c1370f41740f", "node_id": "C_kwDOANBUbNoAKDFjNGE3ODgxYzQ5Mjc5MGVhYWQ5YWVjMWJjYzJjMTM3MGY0MTc0MGY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-18T21:59:12Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-18T21:59:12Z"}, "message": "analyzer: move more impl_* to known_function\n\nFix a missing check that the argument to __analyzer_dump_capacity must\nbe a pointer type (which would otherwise lead to an ICE).\n\nDo so by using the known_function_manager rather than by doing lots of\nstring matching.  Do the same for many other functions.\n\nDoing so moves the type-checking closer to the logic that makes use\nof it, by putting them in the same class, rather than splitting them\nup between two source files (and sometimes three, e.g. for \"pipe\").\nI hope this reduces the number of missing checks.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.cc (is_pipe_call_p): Delete.\n\t* analyzer.h (is_pipe_call_p): Delete.\n\t* region-model-impl-calls.cc (call_details::get_location): New.\n\t(class kf_analyzer_break): New, adapted from\n\tregion_model::on_stmt_pre.\n\t(region_model::impl_call_analyzer_describe): Convert to...\n\t(class kf_analyzer_describe): ...this.\n\t(region_model::impl_call_analyzer_dump_capacity): Convert to...\n\t(class kf_analyzer_dump_capacity): ...this.\n\t(region_model::impl_call_analyzer_dump_escaped): Convert to...\n\t(class kf_analyzer_dump_escaped): ...this.\n\t(class kf_analyzer_dump_exploded_nodes): New.\n\t(region_model::impl_call_analyzer_dump_named_constant): Convert\n\tto...\n\t(class kf_analyzer_dump_named_constant): ...this.\n\t(class dump_path_diagnostic): Move here from region-model.cc.\n\t(class kf_analyzer_dump_path) New, adapted from\n\tregion_model::on_stmt_pre.\n\t(class kf_analyzer_dump_region_model): Likewise.\n\t(region_model::impl_call_analyzer_eval): Convert to...\n\t(class kf_analyzer_eval): ...this.\n\t(region_model::impl_call_analyzer_get_unknown_ptr): Convert to...\n\t(class kf_analyzer_get_unknown_ptr): ...this.\n\t(class known_function_accept): Rename to...\n\t(class kf_accept): ...this.\n\t(class known_function_bind): Rename to...\n\t(class kf_bind): ...this.\n\t(class known_function_connect): Rename to...\n\t(class kf_connect): ...this.\n\t(region_model::impl_call_errno_location): Convert to...\n\t(class kf_errno_location): ...this.\n\t(class known_function_listen): Rename to...\n\t(class kf_listen): ...this.\n\t(region_model::impl_call_pipe): Convert to...\n\t(class kf_pipe): ...this.\n\t(region_model::impl_call_putenv): Convert to...\n\t(class kf_putenv): ...this.\n\t(region_model::impl_call_operator_new): Convert to...\n\t(class kf_operator_new): ...this.\n\t(region_model::impl_call_operator_delete): Convert to...\n\t(class kf_operator_delete): ...this.\n\t(class known_function_socket): Rename to...\n\t(class kf_socket): ...this.\n\t(register_known_functions): Rename param to KFM.  Break out\n\texisting known functions into a \"POSIX\" section, and add \"pipe\",\n\t\"pipe2\", and \"putenv\".  Add debugging functions\n\t\"__analyzer_break\", \"__analyzer_describe\",\n\t\"__analyzer_dump_capacity\", \"__analyzer_dump_escaped\",\n\t\"__analyzer_dump_exploded_nodes\",\n\t\"__analyzer_dump_named_constant\", \"__analyzer_dump_path\",\n\t\"__analyzer_dump_region_model\", \"__analyzer_eval\",\n\t\"__analyzer_get_unknown_ptr\".  Add C++ support functions\n\t\"operator new\", \"operator new []\", \"operator delete\", and\n\t\"operator delete []\".\n\t* region-model.cc (class dump_path_diagnostic): Move to\n\tregion-model-impl-calls.cc.\n\t(region_model::on_stmt_pre): Eliminate special-casing of\n\t\"__analyzer_describe\", \"__analyzer_dump_capacity\",\n\t\"__analyzer_dump_escaped\", \"__analyzer_dump_named_constant\",\n\t\"__analyzer_dump_path\", \"__analyzer_dump_region_model\",\n\t\"__analyzer_eval\", \"__analyzer_break\",\n\t\"__analyzer_dump_exploded_nodes\", \"__analyzer_get_unknown_ptr\",\n\t\"__errno_location\", \"pipe\", \"pipe2\", \"putenv\", \"operator new\",\n\t\"operator new []\", \"operator delete\", \"operator delete []\"\n\t\"pipe\" and \"pipe2\", handling them instead via the known_functions\n\tmechanism.\n\t* region-model.h (call_details::get_location): New decl.\n\t(region_model::impl_call_analyzer_describe): Delete decl.\n\t(region_model::impl_call_analyzer_dump_capacity): Delete decl.\n\t(region_model::impl_call_analyzer_dump_escaped): Delete decl.\n\t(region_model::impl_call_analyzer_dump_named_constant): Delete decl.\n\t(region_model::impl_call_analyzer_eval): Delete decl.\n\t(region_model::impl_call_analyzer_get_unknown_ptr): Delete decl.\n\t(region_model::impl_call_errno_location): Delete decl.\n\t(region_model::impl_call_pipe): Delete decl.\n\t(region_model::impl_call_putenv): Delete decl.\n\t(region_model::impl_call_operator_new): Delete decl.\n\t(region_model::impl_call_operator_delete): Delete decl.\n\t* sm-fd.cc: Update comments.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/analyzer-debugging-fns-1.c: New test.\n\t* gcc.dg/analyzer/attr-const-3.c: Increase the\n\t\"analyzer-max-svalue-depth\" from 0 to 4 to ensure that\n\t\"__analyzer_eval\" is recognized.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "0ee3c140f3c6c88b1e34454163a3674e1162f0de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ee3c140f3c6c88b1e34454163a3674e1162f0de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c4a7881c492790eaad9aec1bcc2c1370f41740f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4a7881c492790eaad9aec1bcc2c1370f41740f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4a7881c492790eaad9aec1bcc2c1370f41740f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4a7881c492790eaad9aec1bcc2c1370f41740f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3142265dedd84c2f3dbf824f2d1b0c182e3c8b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3142265dedd84c2f3dbf824f2d1b0c182e3c8b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3142265dedd84c2f3dbf824f2d1b0c182e3c8b3c"}], "stats": {"total": 798, "additions": 462, "deletions": 336}, "files": [{"sha": "96497dccfa1fa4bda2fc3fa7ee443ff4d3a86076", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -380,22 +380,6 @@ is_longjmp_call_p (const gcall *call)\n   return false;\n }\n \n-/* Return true if this is a \"pipe\" call.  */\n-\n-bool\n-is_pipe_call_p (const_tree fndecl, const char *funcname,\n-\t\tconst gcall *call, unsigned int num_args)\n-{\n-  if (!is_named_call_p (fndecl, funcname, call, num_args))\n-    return false;\n-\n-  /* We require a pointer for the initial argument.  */\n-  if (!POINTER_TYPE_P (TREE_TYPE (gimple_call_arg (call, 0))))\n-    return false;\n-\n-  return true;\n-}\n-\n /* For a CALL that matched is_special_named_call_p or is_named_call_p for\n    some name, return a name for the called function suitable for use in\n    diagnostics (stripping the leading underscores).  */"}, {"sha": "83bb0011a3f5f663de790dbe51dbb778a7b6d667", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -338,8 +338,6 @@ extern bool is_std_named_call_p (const_tree fndecl, const char *funcname,\n \t\t\t\t const gcall *call, unsigned int num_args);\n extern bool is_setjmp_call_p (const gcall *call);\n extern bool is_longjmp_call_p (const gcall *call);\n-extern bool is_pipe_call_p (const_tree fndecl, const char *funcname,\n-\t\t\t    const gcall *call, unsigned int num_args);\n \n extern const char *get_user_facing_name (const gcall *call);\n "}, {"sha": "a71eb3de98fb0f700991166f877b804930adfad6", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 441, "deletions": 174, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -133,6 +133,14 @@ call_details::num_args () const\n   return gimple_call_num_args (m_call);\n }\n \n+/* Get the location of the call statement.  */\n+\n+location_t\n+call_details::get_location () const\n+{\n+  return m_call->location;\n+}\n+\n /* Get argument IDX at the callsite as a tree.  */\n \n tree\n@@ -246,42 +254,79 @@ region_model::impl_call_alloca (const call_details &cd)\n   cd.maybe_set_lhs (ptr_sval);\n }\n \n-/* Handle a call to \"__analyzer_describe\".\n+/* Handle calls to \"__analyzer_break\" by triggering a breakpoint within\n+   the analyzer.  */\n+\n+class kf_analyzer_break : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &) const final override\n+  {\n+    /* TODO: is there a good cross-platform way to do this?  */\n+    raise (SIGINT);\n+  }\n+};\n+\n+/* Handler for calls to \"__analyzer_describe\".\n \n    Emit a warning describing the 2nd argument (which can be of any\n    type), at the given verbosity level.  This is for use when\n    debugging, and may be of use in DejaGnu tests.  */\n \n-void\n-region_model::impl_call_analyzer_describe (const gcall *call,\n-\t\t\t\t\t   region_model_context *ctxt)\n+class kf_analyzer_describe : public known_function\n {\n-  tree t_verbosity = gimple_call_arg (call, 0);\n-  tree t_val = gimple_call_arg (call, 1);\n-  const svalue *sval = get_rvalue (t_val, ctxt);\n-  bool simple = zerop (t_verbosity);\n-  label_text desc = sval->get_desc (simple);\n-  warning_at (call->location, 0, \"svalue: %qs\", desc.get ());\n-}\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 2;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    if (!cd.get_ctxt ())\n+      return;\n+    tree t_verbosity = cd.get_arg_tree (0);\n+    const svalue *sval = cd.get_arg_svalue (1);\n+    bool simple = zerop (t_verbosity);\n+    label_text desc = sval->get_desc (simple);\n+    warning_at (cd.get_location (), 0, \"svalue: %qs\", desc.get ());\n+  }\n+};\n \n-/* Handle a call to \"__analyzer_dump_capacity\".\n+/* Handler for calls to \"__analyzer_dump_capacity\".\n \n    Emit a warning describing the capacity of the base region of\n    the region pointed to by the 1st argument.\n    This is for use when debugging, and may be of use in DejaGnu tests.  */\n \n-void\n-region_model::impl_call_analyzer_dump_capacity (const gcall *call,\n-\t\t\t\t\t\tregion_model_context *ctxt)\n+class kf_analyzer_dump_capacity : public known_function\n {\n-  tree t_ptr = gimple_call_arg (call, 0);\n-  const svalue *sval_ptr = get_rvalue (t_ptr, ctxt);\n-  const region *reg = deref_rvalue (sval_ptr, t_ptr, ctxt);\n-  const region *base_reg = reg->get_base_region ();\n-  const svalue *capacity = get_capacity (base_reg);\n-  label_text desc = capacity->get_desc (true);\n-  warning_at (call->location, 0, \"capacity: %qs\", desc.get ());\n-}\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && POINTER_TYPE_P (cd.get_arg_type (0)));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+    tree t_ptr = cd.get_arg_tree (0);\n+    const svalue *sval_ptr = model->get_rvalue (t_ptr, ctxt);\n+    const region *reg = model->deref_rvalue (sval_ptr, t_ptr, ctxt);\n+    const region *base_reg = reg->get_base_region ();\n+    const svalue *capacity = model->get_capacity (base_reg);\n+    label_text desc = capacity->get_desc (true);\n+    warning_at (cd.get_call_stmt ()->location, 0,\n+\t\t\"capacity: %qs\", desc.get ());\n+  }\n+};\n \n /* Compare D1 and D2 using their names, and then IDs to order them.  */\n \n@@ -309,76 +354,176 @@ cmp_decls_ptr_ptr (const void *p1, const void *p2)\n   return cmp_decls (*d1, *d2);\n }\n \n-/* Handle a call to \"__analyzer_dump_escaped\".\n+/* Handler for calls to \"__analyzer_dump_escaped\".\n \n    Emit a warning giving the number of decls that have escaped, followed\n    by a comma-separated list of their names, in alphabetical order.\n \n    This is for use when debugging, and may be of use in DejaGnu tests.  */\n \n-void\n-region_model::impl_call_analyzer_dump_escaped (const gcall *call)\n+class kf_analyzer_dump_escaped : public known_function\n {\n-  auto_vec<tree> escaped_decls;\n-  for (auto iter : m_store)\n-    {\n-      const binding_cluster *c = iter.second;\n-      if (!c->escaped_p ())\n-\tcontinue;\n-      if (tree decl = c->get_base_region ()->maybe_get_decl ())\n-\tescaped_decls.safe_push (decl);\n-    }\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n \n-  /* Sort them into deterministic order; alphabetical is\n-     probably most user-friendly.  */\n-  escaped_decls.qsort (cmp_decls_ptr_ptr);\n+    auto_vec<tree> escaped_decls;\n+    for (auto iter : *model->get_store ())\n+      {\n+\tconst binding_cluster *c = iter.second;\n+\tif (!c->escaped_p ())\n+\t  continue;\n+\tif (tree decl = c->get_base_region ()->maybe_get_decl ())\n+\t  escaped_decls.safe_push (decl);\n+      }\n \n-  pretty_printer pp;\n-  pp_format_decoder (&pp) = default_tree_printer;\n-  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n-  bool first = true;\n-  for (auto iter : escaped_decls)\n-    {\n-      if (first)\n-\tfirst = false;\n-      else\n-\tpp_string (&pp, \", \");\n-      pp_printf (&pp, \"%qD\", iter);\n-    }\n-  /* Print the number to make it easier to write DejaGnu tests for\n-     the \"nothing has escaped\" case.  */\n-  warning_at (call->location, 0, \"escaped: %i: %s\",\n-\t      escaped_decls.length (),\n-\t      pp_formatted_text (&pp));\n-}\n+    /* Sort them into deterministic order; alphabetical is\n+       probably most user-friendly.  */\n+    escaped_decls.qsort (cmp_decls_ptr_ptr);\n+\n+    pretty_printer pp;\n+    pp_format_decoder (&pp) = default_tree_printer;\n+    pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+    bool first = true;\n+    for (auto iter : escaped_decls)\n+      {\n+\tif (first)\n+\t  first = false;\n+\telse\n+\t  pp_string (&pp, \", \");\n+\tpp_printf (&pp, \"%qD\", iter);\n+      }\n+    /* Print the number to make it easier to write DejaGnu tests for\n+       the \"nothing has escaped\" case.  */\n+    warning_at (cd.get_location (), 0, \"escaped: %i: %s\",\n+\t\tescaped_decls.length (),\n+\t\tpp_formatted_text (&pp));\n+  }\n+};\n+\n+/* Placeholder handler for calls to \"__analyzer_dump_exploded_nodes\".\n+   This is a no-op; the real implementation happens when the\n+   exploded_graph is postprocessed.  */\n+\n+class kf_analyzer_dump_exploded_nodes : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+};\n \n-/* Handle a call to \"__analyzer_dump_named_constant\".\n+/* Handler for calls to \"__analyzer_dump_named_constant\".\n \n    Look up the given name, and emit a warning describing the\n    state of the corresponding stashed value.\n \n    This is for use when debugging, and for DejaGnu tests.  */\n \n-void\n-region_model::\n-impl_call_analyzer_dump_named_constant (const gcall *call,\n-\t\t\t\t\tregion_model_context *ctxt)\n+class kf_analyzer_dump_named_constant : public known_function\n {\n-  call_details cd (call, this, ctxt);\n-  const char *name = cd.get_arg_string_literal (0);\n-  if (!name)\n-    {\n-      error_at (call->location, \"cannot determine name\");\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n       return;\n-    }\n-  tree value = get_stashed_constant_by_name (name);\n-  if (value)\n-    warning_at (call->location, 0, \"named constant %qs has value %qE\",\n-\t\tname, value);\n-  else\n-    warning_at (call->location, 0, \"named constant %qs has unknown value\",\n-\t\tname);\n-}\n+\n+    const char *name = cd.get_arg_string_literal (0);\n+    if (!name)\n+      {\n+\terror_at (cd.get_location (), \"cannot determine name\");\n+\treturn;\n+      }\n+    tree value = get_stashed_constant_by_name (name);\n+    if (value)\n+      warning_at (cd.get_location (), 0, \"named constant %qs has value %qE\",\n+\t\t  name, value);\n+    else\n+      warning_at (cd.get_location (), 0, \"named constant %qs has unknown value\",\n+\t\t  name);\n+  }\n+};\n+\n+/* A pending_diagnostic subclass for implementing \"__analyzer_dump_path\".  */\n+\n+class dump_path_diagnostic\n+  : public pending_diagnostic_subclass<dump_path_diagnostic>\n+{\n+public:\n+  int get_controlling_option () const final override\n+  {\n+    return 0;\n+  }\n+\n+  bool emit (rich_location *richloc) final override\n+  {\n+    inform (richloc, \"path\");\n+    return true;\n+  }\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"dump_path_diagnostic\";\n+  }\n+\n+  bool operator== (const dump_path_diagnostic &) const\n+  {\n+    return true;\n+  }\n+};\n+\n+/* Handle calls to \"__analyzer_dump_path\" by queuing a diagnostic at this\n+   exploded_node.  */\n+\n+class kf_analyzer_dump_path : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    ctxt->warn (make_unique<dump_path_diagnostic> ());\n+  }\n+};\n+\n+/* Handle calls to \"__analyzer_dump_region_model\" by dumping\n+   the region model's state to stderr.  */\n+\n+class kf_analyzer_dump_region_model : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+    model->dump (false);\n+  }\n+};\n \n /* Handle a call to \"__analyzer_eval\" by evaluating the input\n    and dumping as a dummy warning, so that test cases can use\n@@ -388,29 +533,49 @@ impl_call_analyzer_dump_named_constant (const gcall *call,\n    - though typically this doesn't help, as we have an SSA name as the arg,\n    and what's more interesting is usually the def stmt for that name.  */\n \n-void\n-region_model::impl_call_analyzer_eval (const gcall *call,\n-\t\t\t\t       region_model_context *ctxt)\n+class kf_analyzer_eval : public known_function\n {\n-  tree t_arg = gimple_call_arg (call, 0);\n-  tristate t = eval_condition (t_arg, NE_EXPR, integer_zero_node, ctxt);\n-  warning_at (call->location, 0, \"%s\", t.as_string ());\n-}\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+\n+    tree t_arg = cd.get_arg_tree (0);\n+    tristate t = model->eval_condition (t_arg, NE_EXPR, integer_zero_node,\n+\t\t\t\t\tctxt);\n+    warning_at (cd.get_location (), 0, \"%s\", t.as_string ());\n+  }\n+};\n \n-/* Handle the on_call_pre part of \"__analyzer_get_unknown_ptr\".  */\n+/* Handler for \"__analyzer_get_unknown_ptr\".  */\n \n-void\n-region_model::impl_call_analyzer_get_unknown_ptr (const call_details &cd)\n+class kf_analyzer_get_unknown_ptr : public known_function\n {\n-  const svalue *ptr_sval\n-    = m_mgr->get_or_create_unknown_svalue (cd.get_lhs_type ());\n-  cd.maybe_set_lhs (ptr_sval);\n-}\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_manager *mgr = cd.get_manager ();\n+    const svalue *ptr_sval\n+      = mgr->get_or_create_unknown_svalue (cd.get_lhs_type ());\n+    cd.maybe_set_lhs (ptr_sval);\n+  }\n+};\n \n /* Handle calls to \"accept\".\n    See e.g. https://man7.org/linux/man-pages/man3/accept.3p.html  */\n \n-class known_function_accept : public known_function\n+class kf_accept : public known_function\n {\n   class outcome_of_accept : public succeed_or_fail_call_info\n   {\n@@ -447,7 +612,7 @@ class known_function_accept : public known_function\n /* Handle calls to \"bind\".\n    See e.g. https://man7.org/linux/man-pages/man3/bind.3p.html  */\n \n-class known_function_bind : public known_function\n+class kf_bind : public known_function\n {\n public:\n   class outcome_of_bind : public succeed_or_fail_call_info\n@@ -519,7 +684,7 @@ region_model::impl_call_calloc (const call_details &cd)\n /* Handle calls to \"connect\".\n    See e.g. https://man7.org/linux/man-pages/man3/connect.3p.html  */\n \n-class known_function_connect : public known_function\n+class kf_connect : public known_function\n {\n public:\n   class outcome_of_connect : public succeed_or_fail_call_info\n@@ -555,19 +720,28 @@ class known_function_connect : public known_function\n   }\n };\n \n-/* Handle the on_call_pre part of \"__errno_location\".  */\n+/* Handler for glibc's \"__errno_location\".  */\n \n-void\n-region_model::impl_call_errno_location (const call_details &cd)\n+class kf_errno_location : public known_function\n {\n-  if (cd.get_lhs_region ())\n-    {\n-      const region *errno_reg = m_mgr->get_errno_region ();\n-      const svalue *errno_ptr = m_mgr->get_ptr_svalue (cd.get_lhs_type (),\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    if (cd.get_lhs_region ())\n+      {\n+\tregion_model_manager *mgr = cd.get_manager ();\n+\tconst region *errno_reg = mgr->get_errno_region ();\n+\tconst svalue *errno_ptr = mgr->get_ptr_svalue (cd.get_lhs_type (),\n \t\t\t\t\t\t       errno_reg);\n-      cd.maybe_set_lhs (errno_ptr);\n-    }\n-}\n+\tcd.maybe_set_lhs (errno_ptr);\n+      }\n+  }\n+};\n \n /* Handle the on_call_pre part of \"error\" and \"error_at_line\" from\n    GNU's non-standard <error.h>.\n@@ -660,7 +834,7 @@ region_model::impl_call_free (const call_details &cd)\n /* Handle calls to \"listen\".\n    See e.g. https://man7.org/linux/man-pages/man3/listen.3p.html  */\n \n-class known_function_listen : public known_function\n+class kf_listen : public known_function\n {\n   class outcome_of_listen : public succeed_or_fail_call_info\n   {\n@@ -758,10 +932,10 @@ region_model::impl_call_memset (const call_details &cd)\n   fill_region (sized_dest_reg, fill_value_u8);\n }\n \n-/* Handle the on_call_post part of \"pipe\".  */\n+/* Handler for calls to \"pipe\" and \"pipe2\".\n+   See e.g. https://www.man7.org/linux/man-pages/man2/pipe.2.html  */\n \n-void\n-region_model::impl_call_pipe (const call_details &cd)\n+class kf_pipe : public known_function\n {\n   class failure : public failed_call_info\n   {\n@@ -819,14 +993,32 @@ region_model::impl_call_pipe (const call_details &cd)\n     }\n   };\n \n-  /* Body of region_model::impl_call_pipe.  */\n-  if (cd.get_ctxt ())\n-    {\n-      cd.get_ctxt ()->bifurcate (make_unique<failure> (cd));\n-      cd.get_ctxt ()->bifurcate (make_unique<success> (cd));\n-      cd.get_ctxt ()->terminate_path ();\n-    }\n-}\n+public:\n+  kf_pipe (unsigned num_args)\n+  : m_num_args (num_args)\n+  {\n+    gcc_assert (num_args > 0);\n+  }\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == m_num_args\n+\t    && POINTER_TYPE_P (cd.get_arg_type (0)));\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    if (cd.get_ctxt ())\n+      {\n+\tcd.get_ctxt ()->bifurcate (make_unique<failure> (cd));\n+\tcd.get_ctxt ()->bifurcate (make_unique<success> (cd));\n+\tcd.get_ctxt ()->terminate_path ();\n+      }\n+  }\n+\n+private:\n+  unsigned m_num_args;\n+};\n \n /* A subclass of pending_diagnostic for complaining about 'putenv'\n    called on an auto var.  */\n@@ -912,70 +1104,104 @@ class putenv_of_auto_var\n   tree m_var_decl; // could be NULL\n };\n \n-/* Handle the on_call_pre part of \"putenv\".\n+/* Handler for calls to \"putenv\".\n \n    In theory we could try to model the state of the environment variables\n    for the process; for now we merely complain about putenv of regions\n    on the stack.  */\n \n-void\n-region_model::impl_call_putenv (const call_details &cd)\n+class kf_putenv : public known_function\n {\n-  tree fndecl = cd.get_fndecl_for_call ();\n-  gcc_assert (fndecl);\n-  region_model_context *ctxt = cd.get_ctxt ();\n-  const svalue *ptr_sval = cd.get_arg_svalue (0);\n-  const region *reg = deref_rvalue (ptr_sval, cd.get_arg_tree (0), ctxt);\n-  m_store.mark_as_escaped (reg);\n-  enum memory_space mem_space = reg->get_memory_space ();\n-  switch (mem_space)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case MEMSPACE_UNKNOWN:\n-    case MEMSPACE_CODE:\n-    case MEMSPACE_GLOBALS:\n-    case MEMSPACE_HEAP:\n-    case MEMSPACE_READONLY_DATA:\n-      break;\n-    case MEMSPACE_STACK:\n-      if (ctxt)\n-\tctxt->warn (make_unique<putenv_of_auto_var> (fndecl, reg));\n-      break;\n-    }\n-}\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && POINTER_TYPE_P (cd.get_arg_type (0)));\n+  }\n \n-/* Handle the on_call_pre part of \"operator new\".  */\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    tree fndecl = cd.get_fndecl_for_call ();\n+    gcc_assert (fndecl);\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (0);\n+    const region *reg\n+      = model->deref_rvalue (ptr_sval, cd.get_arg_tree (0), ctxt);\n+    model->get_store ()->mark_as_escaped (reg);\n+    enum memory_space mem_space = reg->get_memory_space ();\n+    switch (mem_space)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case MEMSPACE_UNKNOWN:\n+      case MEMSPACE_CODE:\n+      case MEMSPACE_GLOBALS:\n+      case MEMSPACE_HEAP:\n+      case MEMSPACE_READONLY_DATA:\n+\tbreak;\n+      case MEMSPACE_STACK:\n+\tif (ctxt)\n+\t  ctxt->warn (make_unique<putenv_of_auto_var> (fndecl, reg));\n+\tbreak;\n+      }\n+  }\n+};\n \n-void\n-region_model::impl_call_operator_new (const call_details &cd)\n+/* Handler for \"operator new\" and \"operator new []\".  */\n+\n+class kf_operator_new : public known_function\n {\n-  const svalue *size_sval = cd.get_arg_svalue (0);\n-  const region *new_reg\n-    = create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n-  if (cd.get_lhs_type ())\n-    {\n-      const svalue *ptr_sval\n-\t= m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n-      cd.maybe_set_lhs (ptr_sval);\n-    }\n-}\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    region_model_manager *mgr = cd.get_manager ();\n+    const svalue *size_sval = cd.get_arg_svalue (0);\n+    const region *new_reg\n+      = model->create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n+    if (cd.get_lhs_type ())\n+      {\n+\tconst svalue *ptr_sval\n+\t  = mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+\tcd.maybe_set_lhs (ptr_sval);\n+      }\n+  }\n+};\n \n-/* Handle the on_call_pre part of \"operator delete\", which comes in\n-   both sized and unsized variants (2 arguments and 1 argument\n-   respectively).  */\n+/* Handler for \"operator delete\", both the sized and unsized variants\n+   (2 arguments and 1 argument respectively), and for \"operator delete []\"  */\n \n-void\n-region_model::impl_call_operator_delete (const call_details &cd)\n+class kf_operator_delete : public known_function\n {\n-  const svalue *ptr_sval = cd.get_arg_svalue (0);\n-  if (const region *freed_reg = ptr_sval->maybe_get_region ())\n-    {\n-      /* If the ptr points to an underlying heap region, delete it,\n-\t poisoning pointers.  */\n-      unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n-    }\n-}\n+public:\n+  kf_operator_delete (unsigned num_args) : m_num_args (num_args) {}\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == m_num_args;\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (0);\n+    if (const region *freed_reg = ptr_sval->maybe_get_region ())\n+      {\n+\t/* If the ptr points to an underlying heap region, delete it,\n+\t   poisoning pointers.  */\n+\tmodel->unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+      }\n+  }\n+\n+private:\n+  unsigned m_num_args;\n+};\n \n /* Handle the on_call_post part of \"realloc\":\n \n@@ -1209,7 +1435,7 @@ region_model::impl_call_realloc (const call_details &cd)\n /* Handle calls to \"socket\".\n    See e.g. https://man7.org/linux/man-pages/man3/socket.3p.html  */\n \n-class known_function_socket : public known_function\n+class kf_socket : public known_function\n {\n public:\n   class outcome_of_socket : public succeed_or_fail_call_info\n@@ -1378,17 +1604,58 @@ region_model::impl_deallocation_call (const call_details &cd)\n   impl_call_free (cd);\n }\n \n-/* Add instances to MGR of known functions supported by the core of the\n+/* Populate KFM with instances of known functions supported by the core of the\n    analyzer (as opposed to plugins).  */\n \n void\n-register_known_functions (known_function_manager &mgr)\n+register_known_functions (known_function_manager &kfm)\n {\n-  mgr.add (\"accept\", make_unique<known_function_accept> ());\n-  mgr.add (\"bind\", make_unique<known_function_bind> ());\n-  mgr.add (\"connect\", make_unique<known_function_connect> ());\n-  mgr.add (\"listen\", make_unique<known_function_listen> ());\n-  mgr.add (\"socket\", make_unique<known_function_socket> ());\n+  /* Debugging/test support functions, all  with a \"__analyzer_\" prefix.  */\n+  {\n+    kfm.add (\"__analyzer_break\", make_unique<kf_analyzer_break> ());\n+    kfm.add (\"__analyzer_describe\", make_unique<kf_analyzer_describe> ());\n+    kfm.add (\"__analyzer_dump_capacity\",\n+\t     make_unique<kf_analyzer_dump_capacity> ());\n+    kfm.add (\"__analyzer_dump_escaped\",\n+\t     make_unique<kf_analyzer_dump_escaped> ());\n+    kfm.add (\"__analyzer_dump_exploded_nodes\",\n+\t     make_unique<kf_analyzer_dump_exploded_nodes> ());\n+    kfm.add (\"__analyzer_dump_named_constant\",\n+\t     make_unique<kf_analyzer_dump_named_constant> ());\n+    kfm.add (\"__analyzer_dump_path\", make_unique<kf_analyzer_dump_path> ());\n+    kfm.add (\"__analyzer_dump_region_model\",\n+\t     make_unique<kf_analyzer_dump_region_model> ());\n+    kfm.add (\"__analyzer_eval\",\n+\t     make_unique<kf_analyzer_eval> ());\n+    kfm.add (\"__analyzer_get_unknown_ptr\",\n+\t     make_unique<kf_analyzer_get_unknown_ptr> ());\n+  }\n+\n+  /* Known POSIX functions.  */\n+  {\n+    kfm.add (\"accept\", make_unique<kf_accept> ());\n+    kfm.add (\"bind\", make_unique<kf_bind> ());\n+    kfm.add (\"connect\", make_unique<kf_connect> ());\n+    kfm.add (\"listen\", make_unique<kf_listen> ());\n+    kfm.add (\"pipe\", make_unique<kf_pipe> (1));\n+    kfm.add (\"pipe2\", make_unique<kf_pipe> (2));\n+    kfm.add (\"putenv\", make_unique<kf_putenv> ());\n+    kfm.add (\"socket\", make_unique<kf_socket> ());\n+  }\n+\n+  /* glibc functions.  */\n+  {\n+    kfm.add (\"__errno_location\", make_unique<kf_errno_location> ());\n+  }\n+\n+  /* C++ support functions.  */\n+  {\n+    kfm.add (\"operator new\", make_unique<kf_operator_new> ());\n+    kfm.add (\"operator new []\", make_unique<kf_operator_new> ());\n+    kfm.add (\"operator delete\", make_unique<kf_operator_delete> (1));\n+    kfm.add (\"operator delete\", make_unique<kf_operator_delete> (2));\n+    kfm.add (\"operator delete []\", make_unique<kf_operator_delete> (1));\n+  }\n }\n \n } // namespace ana"}, {"sha": "81f58a59f4fb5cf1522402060f31ea1a327da04d", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 2, "deletions": 122, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -1159,31 +1159,6 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n     }\n }\n \n-/* A pending_diagnostic subclass for implementing \"__analyzer_dump_path\".  */\n-\n-class dump_path_diagnostic\n-  : public pending_diagnostic_subclass<dump_path_diagnostic>\n-{\n-public:\n-  int get_controlling_option () const final override\n-  {\n-    return 0;\n-  }\n-\n-  bool emit (rich_location *richloc) final override\n-  {\n-    inform (richloc, \"path\");\n-    return true;\n-  }\n-\n-  const char *get_kind () const final override { return \"dump_path_diagnostic\"; }\n-\n-  bool operator== (const dump_path_diagnostic &) const\n-  {\n-    return true;\n-  }\n-};\n-\n /* Handle the pre-sm-state part of STMT, modifying this object in-place.\n    Write true to *OUT_TERMINATE_PATH if the path should be terminated.\n    Write true to *OUT_UNKNOWN_SIDE_EFFECTS if the stmt has unknown\n@@ -1221,55 +1196,8 @@ region_model::on_stmt_pre (const gimple *stmt,\n \t   anything, for which we don't have a function body, or for which we\n \t   don't know the fndecl.  */\n \tconst gcall *call = as_a <const gcall *> (stmt);\n-\n-\t/* Debugging/test support.  */\n-\tif (is_special_named_call_p (call, \"__analyzer_describe\", 2))\n-\t  impl_call_analyzer_describe (call, ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_capacity\", 1))\n-\t  impl_call_analyzer_dump_capacity (call, ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_escaped\", 0))\n-\t  impl_call_analyzer_dump_escaped (call);\n-\telse if (is_special_named_call_p (call,\n-\t\t\t\t\t  \"__analyzer_dump_named_constant\",\n-\t\t\t\t\t  1))\n-\t  impl_call_analyzer_dump_named_constant (call, ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n-\t       diagnostic at this exploded_node.  */\n-\t    ctxt->warn (make_unique<dump_path_diagnostic> ());\n-\t  }\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_region_model\",\n-\t\t\t\t\t  0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_dump_region_model\" by dumping\n-\t       the region model's state to stderr.  */\n-\t    dump (false);\n-\t  }\n-\telse if (is_special_named_call_p (call, \"__analyzer_eval\", 1))\n-\t  impl_call_analyzer_eval (call, ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_break\", 0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_break\" by triggering a\n-\t       breakpoint.  */\n-\t    /* TODO: is there a good cross-platform way to do this?  */\n-\t    raise (SIGINT);\n-\t  }\n-\telse if (is_special_named_call_p (call,\n-\t\t\t\t\t  \"__analyzer_dump_exploded_nodes\",\n-\t\t\t\t\t  1))\n-\t  {\n-\t    /* This is handled elsewhere.  */\n-\t  }\n-\telse if (is_special_named_call_p (call, \"__analyzer_get_unknown_ptr\",\n-\t\t\t\t\t  0))\n-\t  {\n-\t    call_details cd (call, this, ctxt);\n-\t    impl_call_analyzer_get_unknown_ptr (cd);\n-\t  }\n-\telse\n-\t  *out_unknown_side_effects = on_call_pre (call, ctxt,\n-\t\t\t\t\t\t   out_terminate_path);\n+\t*out_unknown_side_effects\n+\t  = on_call_pre (call, ctxt, out_terminate_path);\n       }\n       break;\n \n@@ -2293,11 +2221,6 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_realloc (cd);\n \t  return false;\n \t}\n-      else if (is_named_call_p (callee_fndecl, \"__errno_location\", call, 0))\n-\t{\n-\t  impl_call_errno_location (cd);\n-\t  return false;\n-\t}\n       else if (is_named_call_p (callee_fndecl, \"error\"))\n \t{\n \t  if (impl_call_error (cd, 3, out_terminate_path))\n@@ -2334,20 +2257,6 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_memset (cd);\n \t  return false;\n \t}\n-      else if (is_pipe_call_p (callee_fndecl, \"pipe\", call, 1)\n-\t       || is_pipe_call_p (callee_fndecl, \"pipe2\", call, 2))\n-\t{\n-\t  /* Handle in \"on_call_post\"; bail now so that fd array\n-\t     is left untouched so that we can detect use-of-uninit\n-\t     for the case where the call fails.  */\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"putenv\", call, 1)\n-\t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n-\t{\n-\t  impl_call_putenv (cd);\n-\t  return false;\n-\t}\n       else if (is_named_call_p (callee_fndecl, \"strchr\", call, 2)\n \t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n \t{\n@@ -2360,22 +2269,6 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_strlen (cd);\n \t  return false;\n \t}\n-      else if (is_named_call_p (callee_fndecl, \"operator new\", call, 1))\n-\t{\n-\t  impl_call_operator_new (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"operator new []\", call, 1))\n-\t{\n-\t  impl_call_operator_new (cd);\n-\t  return false;\n-\t}\n-      else if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n-\t       || is_named_call_p (callee_fndecl, \"operator delete\", call, 2)\n-\t       || is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n-\t{\n-\t  /* Handle in \"on_call_post\".  */\n-\t}\n       else if (const known_function *kf = get_known_function (callee_fndecl))\n \t{\n \t  if (kf->matches_call_types_p (cd))\n@@ -2418,19 +2311,6 @@ region_model::on_call_post (const gcall *call,\n \t  impl_call_free (cd);\n \t  return;\n \t}\n-      if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n-\t  || is_named_call_p (callee_fndecl, \"operator delete\", call, 2)\n-\t  || is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n-\t{\n-\t  impl_call_operator_delete (cd);\n-\t  return;\n-\t}\n-      else if (is_pipe_call_p (callee_fndecl, \"pipe\", call, 1)\n-\t       || is_pipe_call_p (callee_fndecl, \"pipe2\", call, 2))\n-\t{\n-\t  impl_call_pipe (cd);\n-\t  return;\n-\t}\n       else if (is_named_call_p (callee_fndecl, \"strchr\", call, 2)\n \t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n \t{"}, {"sha": "c828d739482ab3a735b3bb178c2ca7dd68c5aa27", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -258,6 +258,7 @@ class call_details\n   unsigned num_args () const;\n \n   const gcall *get_call_stmt () const { return m_call; }\n+  location_t get_location () const;\n \n   tree get_arg_tree (unsigned idx) const;\n   tree get_arg_type (unsigned idx) const;\n@@ -339,19 +340,8 @@ class region_model\n \n   /* Specific handling for on_call_pre.  */\n   void impl_call_alloca (const call_details &cd);\n-  void impl_call_analyzer_describe (const gcall *call,\n-\t\t\t\t    region_model_context *ctxt);\n-  void impl_call_analyzer_dump_capacity (const gcall *call,\n-\t\t\t\t\t region_model_context *ctxt);\n-  void impl_call_analyzer_dump_escaped (const gcall *call);\n-  void impl_call_analyzer_dump_named_constant (const gcall *call,\n-\t\t\t\t\t       region_model_context *ctxt);\n-  void impl_call_analyzer_eval (const gcall *call,\n-\t\t\t\tregion_model_context *ctxt);\n-  void impl_call_analyzer_get_unknown_ptr (const call_details &cd);\n   void impl_call_builtin_expect (const call_details &cd);\n   void impl_call_calloc (const call_details &cd);\n-  void impl_call_errno_location (const call_details &cd);\n   bool impl_call_error (const call_details &cd, unsigned min_args,\n \t\t\tbool *out_terminate_path);\n   void impl_call_fgets (const call_details &cd);\n@@ -360,14 +350,10 @@ class region_model\n   void impl_call_malloc (const call_details &cd);\n   void impl_call_memcpy (const call_details &cd);\n   void impl_call_memset (const call_details &cd);\n-  void impl_call_pipe (const call_details &cd);\n-  void impl_call_putenv (const call_details &cd);\n   void impl_call_realloc (const call_details &cd);\n   void impl_call_strchr (const call_details &cd);\n   void impl_call_strcpy (const call_details &cd);\n   void impl_call_strlen (const call_details &cd);\n-  void impl_call_operator_new (const call_details &cd);\n-  void impl_call_operator_delete (const call_details &cd);\n   void impl_deallocation_call (const call_details &cd);\n \n   /* Implemented in varargs.cc.  */"}, {"sha": "3e500575428f27ec77141dde954c8fe8d83150f9", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -2233,7 +2233,7 @@ get_fd_state (region_model_context *ctxt,\n }\n \n /* Specialcase hook for handling pipe, for use by\n-   region_model::impl_call_pipe::success::update_model.  */\n+   kf_pipe::success::update_model.  */\n \n void\n region_model::mark_as_valid_fd (const svalue *sval, region_model_context *ctxt)\n@@ -2249,7 +2249,7 @@ region_model::mark_as_valid_fd (const svalue *sval, region_model_context *ctxt)\n }\n \n /* Specialcase hook for handling \"socket\", for use by\n-   known_function_socket::outcome_of_socket::update_model.  */\n+   kf_socket::outcome_of_socket::update_model.  */\n \n bool\n region_model::on_socket (const call_details &cd, bool successful)\n@@ -2267,7 +2267,7 @@ region_model::on_socket (const call_details &cd, bool successful)\n }\n \n /* Specialcase hook for handling \"bind\", for use by\n-   known_function_bind::outcome_of_bind::update_model.  */\n+   kf_bind::outcome_of_bind::update_model.  */\n \n bool\n region_model::on_bind (const call_details &cd, bool successful)\n@@ -2285,7 +2285,7 @@ region_model::on_bind (const call_details &cd, bool successful)\n }\n \n /* Specialcase hook for handling \"listen\", for use by\n-   known_function_listen::outcome_of_listen::update_model.  */\n+   kf_listen::outcome_of_listen::update_model.  */\n \n bool\n region_model::on_listen (const call_details &cd, bool successful)\n@@ -2303,7 +2303,7 @@ region_model::on_listen (const call_details &cd, bool successful)\n }\n \n /* Specialcase hook for handling \"accept\", for use by\n-   known_function_accept::outcome_of_accept::update_model.  */\n+   kf_accept::outcome_of_accept::update_model.  */\n \n bool\n region_model::on_accept (const call_details &cd, bool successful)\n@@ -2321,7 +2321,7 @@ region_model::on_accept (const call_details &cd, bool successful)\n }\n \n /* Specialcase hook for handling \"connect\", for use by\n-   known_function_connect::outcome_of_connect::update_model.  */\n+   kf_connect::outcome_of_connect::update_model.  */\n \n bool\n region_model::on_connect (const call_details &cd, bool successful)"}, {"sha": "6a2334449650d22d84846fb53f751cfe4909bb91", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-debugging-fns-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-debugging-fns-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-debugging-fns-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-debugging-fns-1.c?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -0,0 +1,11 @@\n+/* Various wrong declarations for the decls\n+   in analyzer-decls.h.\n+\n+   Make sure we don't ICE on these.  */\n+\n+extern void __analyzer_dump_capacity (int);\n+\n+void wrong_analyzer_dump_capacity (void)\n+{\n+  __analyzer_dump_capacity (42);\n+}"}, {"sha": "fc8527a5d0e703d2a0d7eaee8bdcbbd86a04ed13", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-const-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a7881c492790eaad9aec1bcc2c1370f41740f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-3.c?ref=1c4a7881c492790eaad9aec1bcc2c1370f41740f", "patch": "@@ -1,7 +1,7 @@\n /* Verify that we handle unknown values passed to  __attribute__ ((const))\n    (by imposing a complexity limit).  */\n \n-/* { dg-additional-options \"--param analyzer-max-svalue-depth=0\" } */\n+/* { dg-additional-options \"--param analyzer-max-svalue-depth=4\" } */\n \n #include \"analyzer-decls.h\"\n "}]}