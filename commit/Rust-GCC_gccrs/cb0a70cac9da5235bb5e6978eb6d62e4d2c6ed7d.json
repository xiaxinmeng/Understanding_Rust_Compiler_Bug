{"sha": "cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IwYTcwY2FjOWRhNTIzNWJiNWU2OTc4ZWI2ZDYyZTRkMmM2ZWQ3ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-06T04:11:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-06T04:11:54Z"}, "message": "compiler: Correct test for whether go/defer arg is parenthesized.\n\nFrom-SVN: r194240", "tree": {"sha": "8f69bc11f0b091bc74c2bd1b72af32d81af764d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f69bc11f0b091bc74c2bd1b72af32d81af764d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d/comments", "author": null, "committer": null, "parents": [{"sha": "4d901dd7357b5e4150026548449166ebd5edd48f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d901dd7357b5e4150026548449166ebd5edd48f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d901dd7357b5e4150026548449166ebd5edd48f"}], "stats": {"total": 133, "additions": 87, "deletions": 46}, "files": [{"sha": "8c00fa31da4879d44bd52c6a0bd7fbb3ede9cea7", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 82, "deletions": 42, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d", "patch": "@@ -141,7 +141,7 @@ Parse::expression_list(Expression* first, bool may_be_sink,\n   while (true)\n     {\n       ret->push_back(this->expression(PRECEDENCE_NORMAL, may_be_sink,\n-\t\t\t\t      may_be_composite_lit, NULL));\n+\t\t\t\t      may_be_composite_lit, NULL, NULL));\n \n       const Token* token = this->peek_token();\n       if (!token->is_op(OPERATOR_COMMA))\n@@ -394,7 +394,7 @@ Parse::array_type(bool may_use_ellipsis)\n   else\n     {\n       if (!token->is_op(OPERATOR_ELLIPSIS))\n-\tlength = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+\tlength = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n       else if (may_use_ellipsis)\n \t{\n \t  // An ellipsis is used in composite literals to represent a\n@@ -2137,7 +2137,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n       bool is_type_switch = false;\n       Expression* expr = this->expression(PRECEDENCE_NORMAL, false,\n \t\t\t\t\t  may_be_composite_lit,\n-\t\t\t\t\t  &is_type_switch);\n+\t\t\t\t\t  &is_type_switch, NULL);\n       if (is_type_switch)\n \t{\n \t  p_type_switch->found = true;\n@@ -2404,8 +2404,11 @@ Parse::receiver()\n \n // If MAY_BE_SINK is true, this operand may be \"_\".\n \n+// If IS_PARENTHESIZED is not NULL, *IS_PARENTHESIZED is set to true\n+// if the entire expression is in parentheses.\n+\n Expression*\n-Parse::operand(bool may_be_sink)\n+Parse::operand(bool may_be_sink, bool* is_parenthesized)\n {\n   const Token* token = this->peek_token();\n   Expression* ret;\n@@ -2581,11 +2584,14 @@ Parse::operand(bool may_be_sink)\n       if (token->is_op(OPERATOR_LPAREN))\n \t{\n \t  this->advance_token();\n-\t  ret = this->expression(PRECEDENCE_NORMAL, may_be_sink, true, NULL);\n+\t  ret = this->expression(PRECEDENCE_NORMAL, may_be_sink, true, NULL,\n+\t\t\t\t NULL);\n \t  if (!this->peek_token()->is_op(OPERATOR_RPAREN))\n \t    error_at(this->location(), \"missing %<)%>\");\n \t  else\n \t    this->advance_token();\n+\t  if (is_parenthesized != NULL)\n+\t    *is_parenthesized = true;\n \t  return ret;\n \t}\n       else if (token->is_op(OPERATOR_LSQUARE))\n@@ -2708,11 +2714,12 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t      this->unget_token(Token::make_identifier_token(identifier,\n \t\t\t\t\t\t\t     is_exported,\n \t\t\t\t\t\t\t     location));\n-\t      val = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+\t      val = this->expression(PRECEDENCE_NORMAL, false, true, NULL,\n+\t\t\t\t     NULL);\n \t    }\n \t}\n       else if (!token->is_op(OPERATOR_LCURLY))\n-\tval = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+\tval = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n       else\n \t{\n \t  // This must be a composite literal inside another composite\n@@ -2758,7 +2765,7 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t  vals->push_back(val);\n \n \t  if (!token->is_op(OPERATOR_LCURLY))\n-\t    val = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+\t    val = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n \t  else\n \t    {\n \t      // This must be a composite literal inside another\n@@ -2931,19 +2938,25 @@ Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n // If IS_TYPE_SWITCH is not NULL, this will recognize a type switch\n // guard (var := expr.(\"type\") using the literal keyword \"type\").\n \n+// If IS_PARENTHESIZED is not NULL, *IS_PARENTHESIZED is set to true\n+// if the entire expression is in parentheses.\n+\n Expression*\n Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n-\t\t    bool* is_type_switch)\n+\t\t    bool* is_type_switch, bool* is_parenthesized)\n {\n   Location start_loc = this->location();\n-  bool is_parenthesized = this->peek_token()->is_op(OPERATOR_LPAREN);\n+  bool operand_is_parenthesized = false;\n+  bool whole_is_parenthesized = false;\n+\n+  Expression* ret = this->operand(may_be_sink, &operand_is_parenthesized);\n \n-  Expression* ret = this->operand(may_be_sink);\n+  whole_is_parenthesized = operand_is_parenthesized;\n \n   // An unknown name followed by a curly brace must be a composite\n   // literal, and the unknown name must be a type.\n   if (may_be_composite_lit\n-      && !is_parenthesized\n+      && !operand_is_parenthesized\n       && ret->unknown_expression() != NULL\n       && this->peek_token()->is_op(OPERATOR_LCURLY))\n     {\n@@ -2959,6 +2972,7 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n     {\n       if (this->peek_token()->is_op(OPERATOR_LCURLY))\n \t{\n+\t  whole_is_parenthesized = false;\n \t  if (!may_be_composite_lit)\n \t    {\n \t      Type* t = ret->type();\n@@ -2968,17 +2982,18 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n \t\t\t _(\"parentheses required around this composite literal \"\n \t\t\t   \"to avoid parsing ambiguity\"));\n \t    }\n-\t  else if (is_parenthesized)\n+\t  else if (operand_is_parenthesized)\n \t    error_at(start_loc,\n \t\t     \"cannot parenthesize type in composite literal\");\n \t  ret = this->composite_lit(ret->type(), 0, ret->location());\n \t}\n       else if (this->peek_token()->is_op(OPERATOR_LPAREN))\n \t{\n+\t  whole_is_parenthesized = false;\n \t  Location loc = this->location();\n \t  this->advance_token();\n \t  Expression* expr = this->expression(PRECEDENCE_NORMAL, false, true,\n-\t\t\t\t\t      NULL);\n+\t\t\t\t\t      NULL, NULL);\n \t  if (this->peek_token()->is_op(OPERATOR_COMMA))\n \t    this->advance_token();\n \t  if (this->peek_token()->is_op(OPERATOR_ELLIPSIS))\n@@ -3014,19 +3029,29 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n     {\n       const Token* token = this->peek_token();\n       if (token->is_op(OPERATOR_LPAREN))\n-\tret = this->call(this->verify_not_sink(ret));\n+\t{\n+\t  whole_is_parenthesized = false;\n+\t  ret = this->call(this->verify_not_sink(ret));\n+\t}\n       else if (token->is_op(OPERATOR_DOT))\n \t{\n+\t  whole_is_parenthesized = false;\n \t  ret = this->selector(this->verify_not_sink(ret), is_type_switch);\n \t  if (is_type_switch != NULL && *is_type_switch)\n \t    break;\n \t}\n       else if (token->is_op(OPERATOR_LSQUARE))\n-\tret = this->index(this->verify_not_sink(ret));\n+\t{\n+\t  whole_is_parenthesized = false;\n+\t  ret = this->index(this->verify_not_sink(ret));\n+\t}\n       else\n \tbreak;\n     }\n \n+  if (whole_is_parenthesized && is_parenthesized != NULL)\n+    *is_parenthesized = true;\n+\n   return ret;\n }\n \n@@ -3108,7 +3133,7 @@ Parse::index(Expression* expr)\n \n   Expression* start;\n   if (!this->peek_token()->is_op(OPERATOR_COLON))\n-    start = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+    start = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n   else\n     {\n       mpz_t zero;\n@@ -3124,7 +3149,7 @@ Parse::index(Expression* expr)\n       if (this->advance_token()->is_op(OPERATOR_RSQUARE))\n \tend = Expression::make_nil(this->location());\n       else\n-\tend = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+\tend = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n     }\n   if (!this->peek_token()->is_op(OPERATOR_RSQUARE))\n     error_at(this->location(), \"missing %<]%>\");\n@@ -3233,12 +3258,16 @@ Parse::id_to_expression(const std::string& name, Location location)\n // If IS_TYPE_SWITCH is not NULL, this will recognize a type switch\n // guard (var := expr.(\"type\") using the literal keyword \"type\").\n \n+// If IS_PARENTHESIZED is not NULL, *IS_PARENTHESIZED is set to true\n+// if the entire expression is in parentheses.\n+\n Expression*\n Parse::expression(Precedence precedence, bool may_be_sink,\n-\t\t  bool may_be_composite_lit, bool* is_type_switch)\n+\t\t  bool may_be_composite_lit, bool* is_type_switch,\n+\t\t  bool *is_parenthesized)\n {\n   Expression* left = this->unary_expr(may_be_sink, may_be_composite_lit,\n-\t\t\t\t      is_type_switch);\n+\t\t\t\t      is_type_switch, is_parenthesized);\n \n   while (true)\n     {\n@@ -3295,6 +3324,9 @@ Parse::expression(Precedence precedence, bool may_be_sink,\n \t  return left;\n \t}\n \n+      if (is_parenthesized != NULL)\n+\t*is_parenthesized = false;\n+      \n       Operator op = token->op();\n       Location binop_location = token->location();\n \n@@ -3310,7 +3342,7 @@ Parse::expression(Precedence precedence, bool may_be_sink,\n       left = this->verify_not_sink(left);\n       Expression* right = this->expression(right_precedence, false,\n \t\t\t\t\t   may_be_composite_lit,\n-\t\t\t\t\t   NULL);\n+\t\t\t\t\t   NULL, NULL);\n       left = Expression::make_binary(op, left, right, binop_location);\n     }\n }\n@@ -3376,9 +3408,12 @@ Parse::expression_may_start_here()\n // If IS_TYPE_SWITCH is not NULL, this will recognize a type switch\n // guard (var := expr.(\"type\") using the literal keyword \"type\").\n \n+// If IS_PARENTHESIZED is not NULL, *IS_PARENTHESIZED is set to true\n+// if the entire expression is in parentheses.\n+\n Expression*\n Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n-\t\t  bool* is_type_switch)\n+\t\t  bool* is_type_switch, bool* is_parenthesized)\n {\n   const Token* token = this->peek_token();\n \n@@ -3395,7 +3430,7 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n       if (this->advance_token()->is_keyword(KEYWORD_CHAN))\n \t{\n \t  Expression* expr = this->primary_expr(false, may_be_composite_lit,\n-\t\t\t\t\t\tNULL);\n+\t\t\t\t\t\tNULL, NULL);\n \t  if (expr->is_error_expression())\n \t    return expr;\n \t  else if (!expr->is_type_expression())\n@@ -3448,7 +3483,8 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n       Operator op = token->op();\n       this->advance_token();\n \n-      Expression* expr = this->unary_expr(false, may_be_composite_lit, NULL);\n+      Expression* expr = this->unary_expr(false, may_be_composite_lit, NULL,\n+\t\t\t\t\t  NULL);\n       if (expr->is_error_expression())\n \t;\n       else if (op == OPERATOR_MULT && expr->is_type_expression())\n@@ -3464,7 +3500,7 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n     }\n   else\n     return this->primary_expr(may_be_sink, may_be_composite_lit,\n-\t\t\t      is_type_switch);\n+\t\t\t      is_type_switch, is_parenthesized);\n }\n \n // This is called for the obscure case of\n@@ -3747,7 +3783,8 @@ Parse::simple_stat(bool may_be_composite_lit, bool* return_exp,\n \t\t\t\t     may_be_composite_lit,\n \t\t\t\t     (p_type_switch == NULL\n \t\t\t\t      ? NULL\n-\t\t\t\t      : &p_type_switch->found));\n+\t\t\t\t      : &p_type_switch->found),\n+\t\t\t\t     NULL);\n   if (p_type_switch != NULL && p_type_switch->found)\n     {\n       p_type_switch->name.clear();\n@@ -3857,7 +3894,8 @@ Parse::send_stmt(Expression* channel)\n   go_assert(this->peek_token()->is_op(OPERATOR_CHANOP));\n   Location loc = this->location();\n   this->advance_token();\n-  Expression* val = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+  Expression* val = this->expression(PRECEDENCE_NORMAL, false, true, NULL,\n+\t\t\t\t     NULL);\n   Statement* s = Statement::make_send_statement(channel, val, loc);\n   this->gogo_->add_statement(s);\n }\n@@ -4092,11 +4130,12 @@ Parse::go_or_defer_stat()\n   bool is_go = this->peek_token()->is_keyword(KEYWORD_GO);\n   Location stat_location = this->location();\n \n-  const Token* token = this->advance_token();\n+  this->advance_token();\n   Location expr_location = this->location();\n-  bool is_parenthesized = token->is_op(OPERATOR_LPAREN);\n \n-  Expression* expr = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+  bool is_parenthesized = false;\n+  Expression* expr = this->expression(PRECEDENCE_NORMAL, false, true, NULL,\n+\t\t\t\t      &is_parenthesized);\n   Call_expression* call_expr = expr->call_expression();\n   if (is_parenthesized || call_expr == NULL)\n     {\n@@ -4198,7 +4237,7 @@ Parse::if_stat()\n \t  cond = Expression::make_error(this->location());\n \t}\n       if (cond == NULL)\n-\tcond = this->expression(PRECEDENCE_NORMAL, false, false, NULL);\n+\tcond = this->expression(PRECEDENCE_NORMAL, false, false, NULL, NULL);\n     }\n \n   this->gogo_->start_block(this->location());\n@@ -4329,7 +4368,7 @@ Parse::switch_stat(Label* label)\n \t  if (switch_val == NULL && !type_switch.found)\n \t    {\n \t      switch_val = this->expression(PRECEDENCE_NORMAL, false, false,\n-\t\t\t\t\t    &type_switch.found);\n+\t\t\t\t\t    &type_switch.found, NULL);\n \t      if (type_switch.found)\n \t\t{\n \t\t  type_switch.name.clear();\n@@ -4351,7 +4390,7 @@ Parse::switch_stat(Label* label)\n \t  error_at(token_loc, \"invalid variable name\");\n \t  this->advance_token();\n \t  this->expression(PRECEDENCE_NORMAL, false, false,\n-\t\t\t   &type_switch.found);\n+\t\t\t   &type_switch.found, NULL);\n \t  if (this->peek_token()->is_op(OPERATOR_SEMICOLON))\n \t    this->advance_token();\n \t  if (!this->peek_token()->is_op(OPERATOR_LCURLY))\n@@ -4854,7 +4893,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \t  // case rv := <-c:\n \t  this->advance_token();\n \t  Expression* e = this->expression(PRECEDENCE_NORMAL, false, false,\n-\t\t\t\t\t   NULL);\n+\t\t\t\t\t   NULL, NULL);\n \t  Receive_expression* re = e->receive_expression();\n \t  if (re == NULL)\n \t    {\n@@ -4889,7 +4928,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \t\t  // case rv, rc := <-c:\n \t\t  this->advance_token();\n \t\t  Expression* e = this->expression(PRECEDENCE_NORMAL, false,\n-\t\t\t\t\t\t   false, NULL);\n+\t\t\t\t\t\t   false, NULL, NULL);\n \t\t  Receive_expression* re = e->receive_expression();\n \t\t  if (re == NULL)\n \t\t    {\n@@ -4937,13 +4976,13 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \n   Expression* e;\n   if (saw_comma || !this->peek_token()->is_op(OPERATOR_CHANOP))\n-    e = this->expression(PRECEDENCE_NORMAL, true, true, NULL);\n+    e = this->expression(PRECEDENCE_NORMAL, true, true, NULL, NULL);\n   else\n     {\n       // case <-c:\n       *is_send = false;\n       this->advance_token();\n-      *channel = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+      *channel = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n \n       // The next token should be ':'.  If it is '<-', then we have\n       // case <-c <- v:\n@@ -4963,7 +5002,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n \t}\n       *is_send = false;\n       this->advance_token();\n-      *channel = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+      *channel = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n       if (saw_comma)\n \t{\n \t  // case v, e = <-c:\n@@ -4995,7 +5034,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n       *is_send = true;\n       *channel = this->verify_not_sink(e);\n       this->advance_token();\n-      *val = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+      *val = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n       return true;\n     }\n \n@@ -5142,7 +5181,7 @@ Parse::for_clause(Expression** cond, Block** post)\n       return;\n     }\n   else\n-    *cond = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n+    *cond = this->expression(PRECEDENCE_NORMAL, false, true, NULL, NULL);\n   if (!this->peek_token()->is_op(OPERATOR_SEMICOLON))\n     error_at(this->location(), \"expected semicolon\");\n   else\n@@ -5176,7 +5215,8 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n     error_at(this->location(), \"too many variables for range clause\");\n \n   this->advance_token();\n-  Expression* expr = this->expression(PRECEDENCE_NORMAL, false, false, NULL);\n+  Expression* expr = this->expression(PRECEDENCE_NORMAL, false, false, NULL,\n+\t\t\t\t      NULL);\n   p_range_clause->range = expr;\n \n   bool any_new = false;\n@@ -5223,7 +5263,7 @@ Parse::range_clause_expr(const Expression_list* vals,\n \n   this->advance_token();\n   p_range_clause->range = this->expression(PRECEDENCE_NORMAL, false, false,\n-\t\t\t\t\t   NULL);\n+\t\t\t\t\t   NULL, NULL);\n \n   p_range_clause->index = vals->front();\n   if (vals->size() == 1)"}, {"sha": "99e0eeebc246f76c60b125c4b45c7c949051638f", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=cb0a70cac9da5235bb5e6978eb6d62e4d2c6ed7d", "patch": "@@ -216,23 +216,24 @@ class Parse\n \t\t\t\t     Range_clause*, Type_switch*);\n   void function_decl(bool saw_nointerface);\n   Typed_identifier* receiver();\n-  Expression* operand(bool may_be_sink);\n+  Expression* operand(bool may_be_sink, bool *is_parenthesized);\n   Expression* enclosing_var_reference(Named_object*, Named_object*,\n \t\t\t\t      Location);\n   Expression* composite_lit(Type*, int depth, Location);\n   Expression* function_lit();\n   Expression* create_closure(Named_object* function, Enclosing_vars*,\n \t\t\t     Location);\n   Expression* primary_expr(bool may_be_sink, bool may_be_composite_lit,\n-\t\t\t   bool* is_type_switch);\n+\t\t\t   bool* is_type_switch, bool* is_parenthesized);\n   Expression* selector(Expression*, bool* is_type_switch);\n   Expression* index(Expression*);\n   Expression* call(Expression*);\n   Expression* expression(Precedence, bool may_be_sink,\n-\t\t\t bool may_be_composite_lit, bool* is_type_switch);\n+\t\t\t bool may_be_composite_lit, bool* is_type_switch,\n+\t\t\t bool *is_parenthesized);\n   bool expression_may_start_here();\n   Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n-\t\t\t bool* is_type_switch);\n+\t\t\t bool* is_type_switch, bool* is_parenthesized);\n   Type* reassociate_chan_direction(Channel_type*, Location);\n   Expression* qualified_expr(Expression*, Location);\n   Expression* id_to_expression(const std::string&, Location);"}]}