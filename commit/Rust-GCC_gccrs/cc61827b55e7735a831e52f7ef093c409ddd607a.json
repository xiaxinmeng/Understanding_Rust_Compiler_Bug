{"sha": "cc61827b55e7735a831e52f7ef093c409ddd607a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M2MTgyN2I1NWU3NzM1YTgzMWU1MmY3ZWYwOTNjNDA5ZGRkNjA3YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-29T14:38:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-29T14:46:24Z"}, "message": "c++: Identifier type value should not update binding\n\nThis simplification removes some unneeded behaviour in\nset_identifier_type_value_with_scope, which was updating the namespace\nbinding.  And causing update_binding to have to deal with meeting two\nimplicit typedefs.  But the typedef is already there, and there's no\nother way to have two such typedef's collide (we'll already have dealt\nwith that in lookup_elaborated_type).\n\nSo, let's kill this crufty code.\n\n\tgcc/cp/\n\t* name-lookup.c (update_binding): We never meet two implicit\n\ttypedefs.\n\t(do_pushdecl): Adjust set_identifier_type_value_with_scope calls.\n\t(set_identifier_type_value_with_scope): Do not update binding in\n\tthe namespace-case.  Assert it is already there.", "tree": {"sha": "160ddf646c00b4bc3d618a817354240b925c18e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/160ddf646c00b4bc3d618a817354240b925c18e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc61827b55e7735a831e52f7ef093c409ddd607a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc61827b55e7735a831e52f7ef093c409ddd607a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc61827b55e7735a831e52f7ef093c409ddd607a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc61827b55e7735a831e52f7ef093c409ddd607a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39a27bb01aa223ce89946f0a4de6b60c4c0b03d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39a27bb01aa223ce89946f0a4de6b60c4c0b03d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39a27bb01aa223ce89946f0a4de6b60c4c0b03d2"}], "stats": {"total": 50, "additions": 22, "deletions": 28}, "files": [{"sha": "f195e81280a8cc9c9e371f787a73b29fbeab0bf6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc61827b55e7735a831e52f7ef093c409ddd607a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc61827b55e7735a831e52f7ef093c409ddd607a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=cc61827b55e7735a831e52f7ef093c409ddd607a", "patch": "@@ -2365,33 +2365,24 @@ update_binding (cp_binding_level *level, cxx_binding *binding, tree *slot,\n   if (old == error_mark_node)\n     old = NULL_TREE;\n \n-  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n+  if (DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n-      tree other = to_type;\n-\n-      if (old && TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n-\tother = old;\n-\n-      /* Pushing an artificial typedef.  See if this matches either\n-\t the type slot or the old value slot.  */\n-      if (!other)\n-\t;\n-      else if (same_type_p (TREE_TYPE (other), TREE_TYPE (decl)))\n-\t/* Two artificial decls to same type.  Do nothing.  */\n-\treturn other;\n-      else\n-\tgoto conflict;\n+      /* Pushing an artificial decl.  We should not find another\n+         artificial decl here already -- lookup_elaborated_type will\n+         have already found it.  */\n+      gcc_checking_assert (!to_type\n+\t\t\t   && !(old && DECL_IMPLICIT_TYPEDEF_P (old)));\n \n       if (old)\n \t{\n \t  /* Slide decl into the type slot, keep old unaltered  */\n \t  to_type = decl;\n \t  to_val = old;\n-\t  goto done;\n \t}\n+      goto done;\n     }\n \n-  if (old && TREE_CODE (old) == TYPE_DECL && DECL_ARTIFICIAL (old))\n+  if (old && DECL_IMPLICIT_TYPEDEF_P (old))\n     {\n       /* Slide old into the type slot.  */\n       to_type = old;\n@@ -3122,7 +3113,7 @@ do_pushdecl (tree decl, bool hiding)\n \n \t  if (TREE_CODE (decl) == NAMESPACE_DECL)\n \t    /* A local namespace alias.  */\n-\t    set_identifier_type_value (name, NULL_TREE);\n+\t    set_identifier_type_value_with_scope (name, NULL_TREE, level);\n \n \t  if (!binding)\n \t    binding = create_local_binding (level, name);\n@@ -3150,10 +3141,7 @@ do_pushdecl (tree decl, bool hiding)\n \t      if (TYPE_NAME (type) != decl)\n \t\tset_underlying_type (decl);\n \n-\t      if (!ns)\n-\t\tset_identifier_type_value_with_scope (name, decl, level);\n-\t      else\n-\t\tSET_IDENTIFIER_TYPE_VALUE (name, global_type_node);\n+\t      set_identifier_type_value_with_scope (name, decl, level);\n \t    }\n \n \t  /* If this is a locally defined typedef in a function that\n@@ -3768,8 +3756,9 @@ identifier_type_value (tree id)\n }\n \n /* Push a definition of struct, union or enum tag named ID.  into\n-   binding_level B.  DECL is a TYPE_DECL for the type.  We assume that\n-   the tag ID is not already defined.  */\n+   binding_level B.  DECL is a TYPE_DECL for the type.  DECL has\n+   already been pushed into its binding level.  This is bookkeeping to\n+   find it easily.  */\n \n static void\n set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n@@ -3781,20 +3770,25 @@ set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n       /* Shadow the marker, not the real thing, so that the marker\n \t gets restored later.  */\n       tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-      b->type_shadowed\n-\t= tree_cons (id, old_type_value, b->type_shadowed);\n+      b->type_shadowed = tree_cons (id, old_type_value, b->type_shadowed);\n       type = decl ? TREE_TYPE (decl) : NULL_TREE;\n       TREE_TYPE (b->type_shadowed) = type;\n     }\n   else\n     {\n-      tree *slot = find_namespace_slot (current_namespace, id, true);\n       gcc_assert (decl);\n-      update_binding (b, NULL, slot, MAYBE_STAT_DECL (*slot), decl);\n+      if (CHECKING_P)\n+\t{\n+\t  tree *slot = find_namespace_slot (current_namespace, id);\n+\t  gcc_checking_assert (slot\n+\t\t\t       && (decl == MAYBE_STAT_TYPE (*slot)\n+\t\t\t\t   || decl == MAYBE_STAT_DECL (*slot)));\n+\t}\n \n       /* Store marker instead of real type.  */\n       type = global_type_node;\n     }\n+\n   SET_IDENTIFIER_TYPE_VALUE (id, type);\n }\n "}]}