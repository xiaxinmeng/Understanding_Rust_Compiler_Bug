{"sha": "a157febd0ca69d5b4570fc714c141fd5da555a7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE1N2ZlYmQwY2E2OWQ1YjQ1NzBmYzcxNGMxNDFmZDVkYTU1NWE3YQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "1999-12-04T03:00:04Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-12-04T03:00:04Z"}, "message": "c-common.c (enum attrs): Add A_NO_LIMIT_STACK.\n\n* c-common.c (enum attrs): Add A_NO_LIMIT_STACK.\n(init_attributes): Add A_NO_LIMIT_STACK.\n(decl_attributes): Handle A_NO_LIMIT_STACK.\n* c-decl.c (duplicate_decls): Handle DECL_NO_LIMIT_STACK.\n* explow.c (allocate_dynamic_stack_space) [!HAVE_allocate_stack]:\nHandle stack bounds checking.\n* flags.h (flag_stack_check): Use the word 'probe' rather than\n'check', because the flag doesn't actually cause any checking to\nbe done.\n* function.c (expand_function_start): Set\ncurrent_function_limit_stack.\n* function.h (struct function): Add limit_stack.\n(current_function_limit_stack): Define.\n* invoke.texi (Code Gen Options): Document new options.\n* rtl.h: Declare stack_limit_rtx.\n* toplev.c (stack_limit_rtx): New variable.\n(decode_f_option): Handle new options -fstack-limit-register=REG,\n-fstack-limit-symbol=IDENT, -fno-stack-limit.\n(main): Add stack_limit_rtx as GC root.\n* tree.h (DECL_NO_LIMIT_STACK): New macro.\n(struct tree_decl): New member no_limit_stack.\n\n* config/rs6000/rs6000.c (rs6000_allocate_stack_space): Handle\nstack_limit_rtx.\n* config/rs6000/rs6000.md (allocate_stack): Handle stack_limit_rtx.\n(conditional_trap+1): Get new mnemonic correct.\n(conditional_trap+2): New pattern for DImode traps.\n\n* config/m68k/m68k.c (output_function_prologue): Handle\nstack_limit_rtx.\n* config/m68k/m68k.md (trap): New insn.\n(conditional_trap): New insn.\n* md.texi (Standard Names): Document `trap' and\n`conditional_trap'.\n* optabs.c (gen_cond_trap): Use start_sequence()/end_sequence()\nso a cc0 setter doesn't get emitted at some random place in the\nfunction.\n\n* config/i960/i960.md (trap): New insn.\n(conditional_trap): New expander.\n(conditional_trap+1, conditional_trap+2): New insns for signed\nand unsigned cases.\n* config/i960/i960.c (i960_function_prologue): Use\nSTARTING_FRAME_OFFSET.  Handle stack_limit_rtx.\n\nCo-Authored-By: Greg McGary <gkm@gnu.org>\n\nFrom-SVN: r30771", "tree": {"sha": "9c9c8b5fa8e01f95d849e7b0f24402c7081b73d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c9c8b5fa8e01f95d849e7b0f24402c7081b73d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a157febd0ca69d5b4570fc714c141fd5da555a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a157febd0ca69d5b4570fc714c141fd5da555a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a157febd0ca69d5b4570fc714c141fd5da555a7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a157febd0ca69d5b4570fc714c141fd5da555a7a/comments", "author": null, "committer": null, "parents": [{"sha": "3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c12fcc27809a223032e1b0ad2beba1f6844a5c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c12fcc27809a223032e1b0ad2beba1f6844a5c6"}], "stats": {"total": 408, "additions": 401, "deletions": 7}, "files": [{"sha": "5e5489ab740e0be111a1dcae2a9d0ea665af746b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -1,3 +1,51 @@\n+1999-12-04  Geoffrey Keating  <geoffk@cygnus.com>\n+\t    Greg McGary  <gkm@gnu.org>\n+\n+\t* c-common.c (enum attrs): Add A_NO_LIMIT_STACK.\n+\t(init_attributes): Add A_NO_LIMIT_STACK.\n+\t(decl_attributes): Handle A_NO_LIMIT_STACK.\n+\t* c-decl.c (duplicate_decls): Handle DECL_NO_LIMIT_STACK.\n+\t* explow.c (allocate_dynamic_stack_space) [!HAVE_allocate_stack]:\n+ \tHandle stack bounds checking.\n+\t* flags.h (flag_stack_check): Use the word 'probe' rather than\n+ \t'check', because the flag doesn't actually cause any checking to\n+ \tbe done.\n+\t* function.c (expand_function_start): Set\n+ \tcurrent_function_limit_stack.\n+\t* function.h (struct function): Add limit_stack.\n+\t(current_function_limit_stack): Define.\n+\t* invoke.texi (Code Gen Options): Document new options.\n+\t* rtl.h: Declare stack_limit_rtx.\n+\t* toplev.c (stack_limit_rtx): New variable.\n+\t(decode_f_option): Handle new options -fstack-limit-register=REG,\n+\t-fstack-limit-symbol=IDENT, -fno-stack-limit.\n+\t(main): Add stack_limit_rtx as GC root.\n+\t* tree.h (DECL_NO_LIMIT_STACK): New macro.\n+\t(struct tree_decl): New member no_limit_stack.\n+\n+\t* config/rs6000/rs6000.c (rs6000_allocate_stack_space): Handle\n+ \tstack_limit_rtx.\n+\t* config/rs6000/rs6000.md (allocate_stack): Handle stack_limit_rtx.\n+\t(conditional_trap+1): Get new mnemonic correct.\n+\t(conditional_trap+2): New pattern for DImode traps.\n+\n+\t* config/m68k/m68k.c (output_function_prologue): Handle\n+\tstack_limit_rtx.\n+\t* config/m68k/m68k.md (trap): New insn.\n+\t(conditional_trap): New insn.\n+\t* md.texi (Standard Names): Document `trap' and\n+ \t`conditional_trap'.\n+\t* optabs.c (gen_cond_trap): Use start_sequence()/end_sequence()\n+\tso a cc0 setter doesn't get emitted at some random place in the\n+\tfunction.\n+\n+\t* config/i960/i960.md (trap): New insn.\n+\t(conditional_trap): New expander.\n+\t(conditional_trap+1, conditional_trap+2): New insns for signed\n+\tand unsigned cases.\n+\t* config/i960/i960.c (i960_function_prologue): Use \n+\tSTARTING_FRAME_OFFSET.  Handle stack_limit_rtx.\n+\n Thu Dec  2 21:22:45 1999  Greg McGary  <gkm@gnu.org>\n \t\t\t  Geoffrey Keating  <geoffk@cygnus.com>\n "}, {"sha": "866f53fa7282e72d581d6120b73ca01e2bdf0962", "filename": "gcc/c-common.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -140,7 +140,8 @@ int skip_evaluation;\n enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_NO_CHECK_MEMORY_USAGE, A_NO_INSTRUMENT_FUNCTION,\n \t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n-\t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC};\n+\t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC,\n+\t    A_NO_LIMIT_STACK};\n \n enum format_type { printf_format_type, scanf_format_type,\n \t\t   strftime_format_type };\n@@ -482,6 +483,7 @@ init_attributes ()\n   add_attribute (A_NO_INSTRUMENT_FUNCTION, \"no_instrument_function\", 0, 0, 1);\n   add_attribute (A_NO_CHECK_MEMORY_USAGE, \"no_check_memory_usage\", 0, 0, 1);\n   add_attribute (A_MALLOC, \"malloc\", 0, 0, 1);\n+  add_attribute (A_NO_LIMIT_STACK, \"no_stack_limit\", 0, 0, 1);\n }\n \f\n /* Default implementation of valid_lang_attribute, below.  By default, there\n@@ -1038,6 +1040,23 @@ decl_attributes (node, attributes, prefix_attributes)\n \t  else\n \t    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n \t  break;\n+\n+        case A_NO_LIMIT_STACK:\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"`%s' attribute applies only to functions\",\n+\t\t\t       IDENTIFIER_POINTER (name));\n+\t    }\n+\t  else if (DECL_INITIAL (decl))\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"can't set `%s' attribute after definition\",\n+\t\t\t       IDENTIFIER_POINTER (name));\n+\t    }\n+\t  else\n+\t    DECL_NO_LIMIT_STACK (decl) = 1;\n+\t  break;\n \t}\n     }\n }"}, {"sha": "2eba0e43b9bf523bc5bfee0e945e08a3d397688a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -1884,6 +1884,8 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n \t  DECL_NO_CHECK_MEMORY_USAGE (newdecl)\n \t    |= DECL_NO_CHECK_MEMORY_USAGE (olddecl);\n+\t  DECL_NO_LIMIT_STACK (newdecl)\n+\t    |= DECL_NO_LIMIT_STACK (olddecl);\n \t}\n \n       pop_obstacks ();"}, {"sha": "0c9ae30028eccde5a19c64759d98ab24010689cf", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"recog.h\"\n+#include \"toplev.h\"\n #include <math.h>\n \n /* Save the operands last given to a compare for use when we\n@@ -1431,6 +1432,34 @@ i960_function_prologue (file, size)\n   actual_fsize = (actual_fsize + 15) & ~0xF;\n #endif\n \n+  /* Check stack limit if necessary.  */\n+  if (current_function_limit_stack)\n+    {\n+      rtx min_stack = stack_limit_rtx;\n+      if (actual_fsize != 0)\n+\tmin_stack = plus_constant (stack_limit_rtx, -actual_fsize);\n+\n+      /* Now, emulate a little bit of reload.  We want to turn 'min_stack'\n+\t into an arith_operand.  Use register 20 as the temporary.  */\n+      if (legitimate_address_p (Pmode, min_stack, 1) \n+\t  && !arith_operand (min_stack, Pmode))\n+\t{\n+\t  rtx tmp = gen_rtx_MEM (Pmode, min_stack);\n+\t  fputs (\"\\tlda\\t\", file);\n+\t  i960_print_operand (file, tmp, 0);\n+\t  fputs (\",r4\\n\", file);\n+\t  min_stack = gen_rtx_REG (Pmode, 20);\n+\t}\n+      if (arith_operand (min_stack, Pmode))\n+\t{\n+\t  fputs (\"\\tcmpo\\tsp,\", file);\n+\t  i960_print_operand (file, min_stack, 0);\n+\t  fputs (\"\\n\\tfaultge.f\\n\", file);\n+\t}\n+      else\n+\twarning (\"stack limit expression is not supported\");\n+    }\n+\n   /* Allocate space for register save and locals.  */\n   if (actual_fsize > 0)\n     {\n@@ -1443,7 +1472,7 @@ i960_function_prologue (file, size)\n   /* Take hardware register save area created by the call instruction\n      into account, but store them before the argument block area.  */\n   lvar_size = actual_fsize - compute_frame_size (0) - n_saved_regs * 4;\n-  offset = 64 + lvar_size;\n+  offset = STARTING_FRAME_OFFSET + lvar_size;\n   /* Save registers on stack if needed.  */\n   /* ??? Is it worth to use the same algorithm as one for saving\n      global registers in local registers? */"}, {"sha": "38c14bae72a9ac4ed4ece62c07ed550c339caf2e", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -540,6 +540,39 @@\n   \"cmp%S0%B0%X0\t%2,%1,%l3\"\n   [(set_attr \"type\" \"branch\")])\n \f\n+;; Now the trap instructions.  The i960 appears to only have conditional\n+;; traps...\n+\n+(define_insn (\"trap\")\n+  [(trap_if (const_int 1) (const_int 0))]\n+  \"\"\n+  \"cmpo g0,g0 ; faulteq.t\")\n+\n+(define_expand \"conditional_trap\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+\t     [(match_dup 2) (const_int 0)]) \n+\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_compare_reg (GET_CODE (operands[0]), \n+\t\t\t\t i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+\t     [(reg:CC 36) (const_int 0)]) \n+\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n+  \"\"\n+  \"fault%C0.f\")\n+\n+(define_insn \"\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+\t     [(reg:CC_UNS 36) (const_int 0)]) \n+\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n+  \"\"\n+  \"fault%C0.f\")\n+\f\n ;; Normal move instructions.\n ;; This code is based on the sparc machine description.\n "}, {"sha": "8a798b7df656ddaecb395b7a14275e0842e35d83", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -151,6 +151,19 @@ output_function_prologue (stream, size)\n   int fsize = (size + 3) & -4;\n   int cfa_offset = INCOMING_FRAME_SP_OFFSET, cfa_store_offset = cfa_offset;\n   \n+  /* If the stack limit is a symbol, we can check it here,\n+     before actually allocating the space.  */\n+  if (current_function_limit_stack\n+      && GET_CODE (stack_limit_rtx) == SYMBOL_REF)\n+    {\n+#if defined (MOTOROLA)\n+      asm_fprintf (stream, \"\\tcmp.l %0I%s+%d,%Rsp\\n\\ttrapcs\\n\",\n+\t\t   XSTR (stack_limit_rtx, 0), fsize + 4);\n+#else\n+      asm_fprintf (stream, \"\\tcmpl %0I%s+%d,%Rsp\\n\\ttrapcs\\n\",\n+\t\t   XSTR (stack_limit_rtx, 0), fsize + 4);\n+#endif\n+    }\n \n   if (frame_pointer_needed)\n     {\n@@ -374,6 +387,24 @@ output_function_prologue (stream, size)\n #endif\n #endif\n \n+  /* If the stack limit is not a symbol, check it here.  \n+     This has the disadvantage that it may be too late...  */\n+  if (current_function_limit_stack)\n+    {\n+      if (REG_P (stack_limit_rtx))\n+\t{\n+#if defined (MOTOROLA)\n+\t  asm_fprintf (stream, \"\\tcmp.l %s,%Rsp\\n\\ttrapcs\\n\",\n+\t\t       reg_names[REGNO (stack_limit_rtx)]);\n+#else\n+\t  asm_fprintf (stream, \"\\tcmpl %s,%Rsp\\n\\ttrapcs\\n\",\n+\t\t       reg_names[REGNO (stack_limit_rtx)]);\n+#endif\n+\t}\n+      else if (GET_CODE (stack_limit_rtx) != SYMBOL_REF)\n+\twarning (\"stack limit expression is not supported\");\n+    }\n+  \n   if (num_saved_regs <= 2)\n     {\n       /* Store each separately in the same order moveml uses."}, {"sha": "62177190667ea142ef1354c0fc30fb8f9a7b7ca0", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -7897,3 +7897,31 @@\n \t(unspec:XF [(match_operand:XF 1 \"nonimmediate_operand\" \"fm\")] 2))]\n   \"TARGET_68881 && flag_fast_math\"\n   \"fcos%.x %1,%0\")\n+\n+(define_insn \"trap\"\n+  [(trap_if (const_int -1) (const_int 7))]\n+  \"\"\n+  \"trap %#7\")\n+\n+(define_insn \"conditional_trap\"\n+  [(trap_if (match_operator 0 \"valid_dbcc_comparison_p\"\n+\t\t\t    [(cc0) (const_int 0)])\n+\t    (match_operand:SI 1 \"const_int_operand\" \"I\"))]\n+  \"TARGET_68020 && ! flags_in_68881 ()\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[0]))\n+  {\n+  case EQ:  return \\\"trapeq\\\";\n+  case NE:  return \\\"trapne\\\";\n+  case GT:  return \\\"trapgt\\\";\n+  case GTU: return \\\"traphi\\\";\n+  case LT:  return \\\"traplt\\\";\n+  case LTU: return \\\"trapcs\\\";\n+  case GE:  return \\\"trapge\\\";\n+  case GEU: return \\\"trapcc\\\";\n+  case LE:  return \\\"traple\\\";\n+  case LEU: return \\\"trapls\\\";\n+  default: abort();\n+  }\n+}\")"}, {"sha": "a8db6d035c3a5d6008d6f90576dbfa313e87e223", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -4176,6 +4176,53 @@ rs6000_allocate_stack_space (file, size, copy_r12)\n      int copy_r12;\n {\n   int neg_size = -size;\n+\n+  if (current_function_limit_stack)\n+    {\n+      if (REG_P (stack_limit_rtx)\n+\t  && REGNO (stack_limit_rtx) > 1 \n+\t  && REGNO (stack_limit_rtx) <= 31)\n+\t{\n+\t  if (size <= 32767)\n+\t    asm_fprintf (file, \"\\t{cal %s,%d(%s)|addi %s,%s,%d}\\n\",\n+\t\t\t reg_names[0], reg_names[REGNO (stack_limit_rtx)], \n+\t\t\t size);\n+\t  else\n+\t    {\n+\t      asm_fprintf (file, \"\\t{cau|addis} %s,%s,0x%x\\n\",\n+\t\t\t   reg_names[0], reg_names[REGNO (stack_limit_rtx)], \n+\t\t\t   ((size + 0x8000) >> 16) & 0xffff);\n+\t      asm_fprintf (file, \"\\t{ai|addic} %s,%s,%d\\n\",\n+\t\t\t   reg_names[0], reg_names[0], \n+\t\t\t   (size & 0x7fff) | -(size & 0x8000));\n+\t    }\n+\t  if (TARGET_32BIT)\n+\t    asm_fprintf (file, \"\\t{t|tw}llt %s,%s\\n\", \n+\t\t\t reg_names[1], reg_names[0]);\n+\t  else\n+\t    asm_fprintf (file, \"\\ttdllt %s,%s\\n\", reg_names[1], reg_names[0]);\n+\t}\n+      else if (GET_CODE (stack_limit_rtx) == SYMBOL_REF\n+\t       && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n+\t{\n+\t  char * l_name = XSTR (stack_limit_rtx, 0);\n+\t  const char * stripped_name;\n+\n+\t  STRIP_NAME_ENCODING (stripped_name, l_name);\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,%s@ha+%d\\n\",\n+\t\t       reg_names[0], stripped_name, size);\n+\t  asm_fprintf (file, \"\\t{ai|addic} %s,%s,%s@l+%d\\n\",\n+\t\t       reg_names[0], reg_names[0], stripped_name, size);\n+\t  if (TARGET_32BIT)\n+\t    asm_fprintf (file, \"\\t{t|tw}llt %s,%s\\n\", \n+\t\t\t reg_names[1], reg_names[0]);\n+\t  else\n+\t    asm_fprintf (file, \"\\ttdllt %s,%s\\n\", reg_names[1], reg_names[0]);\n+\t}\n+      else\n+\twarning (\"stack limit expression is not supported\");\n+    }\n+\n   if (TARGET_UPDATE)\n     {\n       if (size < 32767)"}, {"sha": "bde6369f184e9a422fe0a95f41f86415b708e46f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -7882,6 +7882,16 @@\n \n   emit_move_insn (chain, stack_bot);\n \n+  /* Check stack bounds if necessary.  */\n+  if (current_function_limit_stack)\n+    {\n+      rtx available;\n+      available = expand_binop (Pmode, sub_optab, \n+\t\t\t\tstack_pointer_rtx, stack_limit_rtx,\n+\t\t\t\tNULL_RTX, 1, OPTAB_WIDEN);\n+      emit_insn (gen_cond_trap (LTU, available, operands[1], const0_rtx));\n+    }\n+\n   /* Under Windows NT, we need to add stack probes for large/variable\n      allocations, so do it via a call to the external function alloca\n      instead of doing it inline.  */\n@@ -11151,4 +11161,12 @@\n                              (match_operand:SI 2 \"reg_or_short_operand\" \"rI\")])\n \t    (const_int 0))]\n   \"\"\n-  \"t%V0%I2 %1,%2\")\n+  \"{t|tw}%V0%I2 %1,%2\")\n+\n+(define_insn \"\"\n+  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n+                            [(match_operand:DI 1 \"register_operand\" \"r\")\n+                             (match_operand:DI 2 \"reg_or_short_operand\" \"rI\")])\n+\t    (const_int 0))]\n+  \"TARGET_POWERPC64\"\n+  \"td%V0%I2 %1,%2\")"}, {"sha": "a8b5235521466d6c2e6f6c70c9cf778880f2fc0d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -1,3 +1,10 @@\n+1999-11-24  Geoffrey Keating  <geoffk@cygnus.com>\n+            Greg McGary  <gkm@gnu.org>\n+\n+\t* decl.c (duplicate_decls): Merge\n+ \tDECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT,\n+ \tDECL_NO_CHECK_MEMORY_USAGE, DECL_NO_LIMIT_STACK.\n+\n 1999-12-02  Mike Stump  <mrs@wrs.com>\n \n \t* init.c (perform_member_init): Handle parse errors better."}, {"sha": "deea199ddbdf6dafdfcb96097a17f158703e779c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -3364,6 +3364,16 @@ duplicate_decls (newdecl, olddecl)\n \n       /* Keep the old rtl since we can safely use it.  */\n       DECL_RTL (newdecl) = DECL_RTL (olddecl);\n+\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t{\n+\t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n+\t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n+\t  DECL_NO_CHECK_MEMORY_USAGE (newdecl)\n+\t    |= DECL_NO_CHECK_MEMORY_USAGE (olddecl);\n+\t  DECL_NO_LIMIT_STACK (newdecl)\n+\t    |= DECL_NO_LIMIT_STACK (olddecl);\n+\t}\n     }\n   /* If cannot merge, then use the new type and qualifiers,\n      and don't preserve the old rtl.  */"}, {"sha": "ca4259a7fa4a18ace717d28b23834968cce7bbee", "filename": "gcc/explow.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -1333,6 +1333,33 @@ allocate_dynamic_stack_space (size, target, known_align)\n       emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif\n       size = convert_modes (Pmode, ptr_mode, size, 1);\n+\n+      /* Check stack bounds if necessary.  */\n+      if (current_function_limit_stack)\n+\t{\n+\t  rtx available;\n+\t  rtx space_available = gen_label_rtx ();\n+#ifdef STACK_GROWS_DOWNWARD\n+\t  available = expand_binop (Pmode, sub_optab, \n+\t\t\t\t    stack_pointer_rtx, stack_limit_rtx,\n+\t\t\t\t    NULL_RTX, 1, OPTAB_WIDEN);\n+#else\n+\t  available = expand_binop (Pmode, sub_optab, \n+\t\t\t\t    stack_limit_rtx, stack_pointer_rtx,\n+\t\t\t\t    NULL_RTX, 1, OPTAB_WIDEN);\n+#endif\n+\t  emit_cmp_and_jump_insns (available, size, GEU, NULL_RTX, Pmode, 1,\n+\t\t\t\t   0, space_available);\n+#ifdef HAVE_trap\n+\t  if (HAVE_trap)\n+\t    emit_insn (gen_trap ());\n+\t  else\n+#endif\n+\t    error (\"stack limits not supported on this target\");\n+\t  emit_barrier ();\n+\t  emit_label (space_available);\n+\t}\n+\n       anti_adjust_stack (size);\n #ifdef SETJMP_VIA_SAVE_AREA\n       if (setjmpless_size != NULL_RTX)"}, {"sha": "92d121cb6ed97182cf4349b0c19684c42e4adf93", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -476,8 +476,8 @@ extern int flag_argument_noalias;\n    if alias analysis (in general) is enabled.  */\n extern int flag_strict_aliasing;\n \n-/* Emit code to check for stack overflow; also may cause large objects\n-   to be allocated dynamically.  */\n+/* Emit code to probe the stack, to help detect stack overflow; also\n+   may cause large objects to be allocated dynamically.  */\n extern int flag_stack_check;\n \n /* Do the full regmove optimization pass.  */"}, {"sha": "587fdfffe7dfd923055fecf4ba905e0f83d85e31", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -5946,6 +5946,9 @@ expand_function_start (subr, parms_have_cleanups)\n     = (flag_instrument_function_entry_exit\n        && ! DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (subr));\n \n+  current_function_limit_stack\n+    = (stack_limit_rtx != NULL_RTX && ! DECL_NO_LIMIT_STACK (subr));\n+\n   /* If function gets a static chain arg, store it in the stack frame.\n      Do this first, so it gets the first stack slot offset.  */\n   if (current_function_needs_context)"}, {"sha": "3c912bcf7ba5ca9c9c4bb558a13df43f7a80ce16", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -290,6 +290,10 @@ struct function\n   /* Nonzero if memory access checking be enabled in the current function.  */\n   int check_memory_usage;\n \n+  /* Nonzero if stack limit checking should be enabled in the current\n+     function.  */\n+  int limit_stack;\n+\n   /* Number of function calls seen so far in current function.  */\n   int x_function_call_count;\n \n@@ -490,6 +494,7 @@ extern struct function *all_functions;\n #define current_function_return_rtx (current_function->return_rtx)\n #define current_function_instrument_entry_exit (current_function->instrument_entry_exit)\n #define current_function_check_memory_usage (current_function->check_memory_usage)\n+#define current_function_limit_stack (current_function->limit_stack)\n #define current_function_uses_pic_offset_table (current_function->uses_pic_offset_table)\n #define current_function_uses_const_pool (current_function->uses_const_pool)\n #define current_function_cannot_inline (current_function->cannot_inline)"}, {"sha": "5e4eb757d27128dd3ed6d7fdfda1c25eb9321fde", "filename": "gcc/invoke.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -439,6 +439,7 @@ in the following sections.\n -freg-struct-return  -fshared-data  -fshort-enums\n -fshort-double  -fvolatile  -fvolatile-global -fvolatile-static\n -fverbose-asm -fpack-struct  -fstack-check\n+-fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym}\n -fargument-alias  -fargument-noalias\n -fargument-noalias-global\n -fleading-underscore\n@@ -7085,6 +7086,25 @@ environment with multiple threads, but only rarely need to specify it in\n a single-threaded environment since stack overflow is automatically\n detected on nearly all systems if there is only one stack.\n \n+Note that this switch does not actually cause checking to be done; the\n+operating system must do that.  The switch causes generation of code\n+to ensure that the operating system sees the stack being extended.\n+\n+@item -fstack-limit-register=@var{reg}\n+@itemx -fstack-limit-symbol=@var{sym}\n+@itemx -fno-stack-limit\n+Generate code to ensure that the stack does not grow beyond a certain value,\n+either the value of a register or the address of a symbol.  If the stack\n+would grow beyond the value, a signal is raised.  For most targets,\n+the signal is raised before the stack overruns the boundary, so\n+it is possible to catch the signal without taking special precautions.\n+\n+For instance, if the stack starts at address @samp{0x80000000} and grows\n+downwards you can use the flags\n+@samp{-fstack-limit-symbol=__stack_limit}\n+@samp{-Wl,--defsym,__stack_limit=0x7ffe0000} which will enforce a stack\n+limit of 128K.\n+\n @cindex aliasing of parameters\n @cindex parameters, aliased\n @item -fargument-alias"}, {"sha": "483016794c822f52d9f3ef7fe0283f637618f718", "filename": "gcc/md.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -2549,6 +2549,29 @@ sibling call (aka tail call) sites.\n The @code{sibcall_epilogue} pattern must not clobber any arguments used for\n parameter passing or any stack slots for arguments passed to the current\n function.  \n+\n+@cindex @code{trap} instruction pattern\n+@item @samp{trap}\n+This pattern, if defined, signals an error, typically by causing some\n+kind of signal to be raised.  Among other places, it is used by the Java\n+frontend to signal `invalid array index' exceptions.\n+\n+@cindex @code{conditional_trap} instruction pattern\n+@item @samp{conditional_trap}\n+Conditional trap instruction.  Operand 0 is a piece of RTL which\n+performs a comparison.  Operand 1 is the trap code, an integer.\n+\n+A typical @code{conditional_trap} pattern looks like\n+\n+@smallexample\n+(define_insn \"conditional_trap\"\n+  [(trap_if (match_operator 0 \"trap_operator\" \n+             [(cc0) (const_int 0)])\n+            (match_operand 1 \"const_int_operand\" \"i\"))]\n+  \"\"\n+  \"@dots{}\")\n+@end smallexample\n+\n @end table\n \n @node Pattern Ordering"}, {"sha": "5d80241969bc36e42e6ea91dc0b2a216537548d7", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -4806,11 +4806,17 @@ gen_cond_trap (code, op1, op2, tcode)\n       && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       rtx insn;\n+      start_sequence();\n       emit_insn (GEN_FCN (cmp_optab->handlers[(int) mode].insn_code) (op1, op2));\n       PUT_CODE (trap_rtx, code);\n       insn = gen_conditional_trap (trap_rtx, tcode);\n       if (insn)\n-\treturn insn;\n+\t{\n+\t  emit_insn (insn);\n+\t  insn = gen_sequence ();\n+\t}\n+      end_sequence();\n+      return insn;\n     }\n #endif\n "}, {"sha": "3677c4e967d03d2a6f81204781604590397c3d1f", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -1576,6 +1576,8 @@ extern void reg_scan\t\t\tPROTO ((rtx, int, int));\n extern void reg_scan_update\t\tPROTO ((rtx, rtx, int));\n extern void fix_register\t\tPROTO ((const char *, int, int));\n \n+extern void delete_null_pointer_checks\tPROTO ((rtx));\n+\n /* In regmove.c */\n #ifdef BUFSIZ\n extern void regmove_optimize\t\tPROTO ((rtx, int, FILE *));\n@@ -1703,6 +1705,8 @@ extern rtx addr_side_effect_eval\tPROTO ((rtx, int, int));\n extern int stack_regs_mentioned\t\tPROTO((rtx insn));\n #endif\n \n+/* In toplev.c */\n+\n+extern rtx stack_limit_rtx;\n \n-extern void delete_null_pointer_checks\tPROTO ((rtx));\n #endif /* _RTL_H */"}, {"sha": "fbbbb648916a2630ab4f111863f0a1fa732ce4ad", "filename": "gcc/toplev.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -720,6 +720,15 @@ int flag_pack_struct = 0;\n    to be allocated dynamically.  */\n int flag_stack_check;\n \n+/* When non-NULL, indicates that whenever space is allocated on the\n+   stack, the resulting stack pointer must not pass this\n+   address---that is, for stacks that grow downward, the stack pointer\n+   must always be greater than or equal to this address; for stacks\n+   that grow upward, the stack pointer must be less than this address.\n+   At present, the rtx may be either a REG or a SYMBOL_REF, although\n+   the support provided depends on the backend.  */\n+rtx stack_limit_rtx;\n+\n /* -fcheck-memory-usage causes extra code to be generated in order to check\n    memory accesses.  This is used by a detector of bad memory accesses such\n    as Checker.  */\n@@ -4889,6 +4898,25 @@ decode_f_option (arg)\n     align_jumps = read_integral_parameter (arg + 12, arg - 2, align_jumps);\n   else if (!strncmp (arg, \"align-labels=\", 13))\n     align_labels = read_integral_parameter (arg + 13, arg - 2, align_labels);\n+  else if (!strncmp (arg, \"stack-limit-register=\", 21))\n+    {\n+      int reg = decode_reg_name (arg + 21);\n+      if (reg < 0)\n+\terror (\"unrecognized register name `%s'\", arg + 21);\n+      else\n+\tstack_limit_rtx = gen_rtx_REG (Pmode, reg);\n+    }\n+  else if (!strncmp (arg, \"stack-limit-symbol=\", 19))\n+    {\n+      char *nm;\n+      if (ggc_p)\n+\tnm = ggc_alloc_string (arg + 19, strlen (arg + 19));\n+      else\n+\tnm = xstrdup (arg + 19);\n+      stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, nm);\n+    }\n+  else if (!strcmp (arg, \"no-stack-limit\"))\n+    stack_limit_rtx = NULL_RTX;\n   else if (!strcmp (arg, \"preprocessed\"))\n     /* Recognise this switch but do nothing.  This prevents warnings\n        about an unrecognised switch if cpplib has not been linked in.  */\n@@ -5323,6 +5351,7 @@ main (argc, argv)\n   init_ggc ();\n   ggc_add_root (&input_file_stack, 1, sizeof input_file_stack,\n \t\t&mark_file_stack);\n+  ggc_add_rtx_root (&stack_limit_rtx, 1);\n \n   /* Perform language-specific options intialization.  */\n   lang_init_options ();"}, {"sha": "7d181607a51b930cf14e91b818395cc269591e38", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a157febd0ca69d5b4570fc714c141fd5da555a7a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a157febd0ca69d5b4570fc714c141fd5da555a7a", "patch": "@@ -1307,6 +1307,10 @@ struct tree_type\n    disabled in this function.  */\n #define DECL_NO_CHECK_MEMORY_USAGE(NODE) ((NODE)->decl.no_check_memory_usage)\n \n+/* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n+   disabled in this function.  */\n+#define DECL_NO_LIMIT_STACK(NODE) ((NODE)->decl.no_limit_stack)\n+\n /* Additional flags for language-specific uses.  */\n #define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)\n #define DECL_LANG_FLAG_1(NODE) (DECL_CHECK (NODE)->decl.lang_flag_1)\n@@ -1376,6 +1380,7 @@ struct tree_decl\n   unsigned no_check_memory_usage : 1;\n   unsigned comdat_flag : 1;\n   unsigned malloc_flag : 1;\n+  unsigned no_limit_stack : 1;\n \n   /* For a FUNCTION_DECL, if inline, this is the size of frame needed.\n      If built-in, this is the code for which built-in function."}]}