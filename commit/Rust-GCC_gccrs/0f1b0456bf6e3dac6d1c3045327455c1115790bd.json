{"sha": "0f1b0456bf6e3dac6d1c3045327455c1115790bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYxYjA0NTZiZjZlM2RhYzZkMWMzMDQ1MzI3NDU1YzExMTU3OTBiZA==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2005-03-15T16:20:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T16:20:14Z"}, "message": "gnat_ugn.texi: Remove extended inline assembly example...\n\n2005-03-08  Geert Bosch  <bosch@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Cyrille Comar  <comar@adacore.com>\n\t    Sergey Rybin  <rybin@adacore.com>\n\n\t* gnat_ugn.texi: Remove extended inline assembly example, as it was far\n\ttoo specific and long-winded to be appropriate for the GNAT User's\n\tGuide.\n\tWarn about use of GCC switches not documented in the GNAT User's Guide,\n\tas these may cause generated code to not conform to Ada semantics.\n\tRemove mention of -gdwarf-2 for sparc64, since this is now the default.\n\tAdd documentation for -gnat95 and -gnat05 switches\n\tRemove paragraph documenting obsolete way to refer to third party\n\tlibraries.\n\tAdd a few references to Ada_05 that were missing.\n\tUpdate documentation on -gnatZ/-gnatL.\n\tDocument limitation when using -m64 under Solaris.\n\tChange the \"Name Casing\" subsection of the pretty-printer section\n\taccording to the changes in the dictionary processing.\n\n\t* gnat_rm.texi: Document the Ada_05 pragma.\n\tSection on record representation clauses describes the new more\n\trelaxed rules about placement of large packed bit array components.\n\tAdd documentation of GNAT.UTF_32\n\nFrom-SVN: r96513", "tree": {"sha": "9be0b9188bfec30912c9d326612fd0cba963c30c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9be0b9188bfec30912c9d326612fd0cba963c30c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f1b0456bf6e3dac6d1c3045327455c1115790bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1b0456bf6e3dac6d1c3045327455c1115790bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1b0456bf6e3dac6d1c3045327455c1115790bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1b0456bf6e3dac6d1c3045327455c1115790bd/comments", "author": null, "committer": null, "parents": [{"sha": "1a49cf99b76257b0a6e66021f97f05d292065229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a49cf99b76257b0a6e66021f97f05d292065229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a49cf99b76257b0a6e66021f97f05d292065229"}], "stats": {"total": 1226, "additions": 194, "deletions": 1032}, "files": [{"sha": "6ba0fd94e77e8dc8381488230d517c1bd0227c93", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1b0456bf6e3dac6d1c3045327455c1115790bd/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1b0456bf6e3dac6d1c3045327455c1115790bd/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0f1b0456bf6e3dac6d1c3045327455c1115790bd", "patch": "@@ -102,6 +102,7 @@ Implementation Defined Pragmas\n * Pragma Abort_Defer::\n * Pragma Ada_83::\n * Pragma Ada_95::\n+* Pragma Ada_05::\n * Pragma Annotate::\n * Pragma Assert::\n * Pragma Ast_Entry::\n@@ -629,6 +630,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Abort_Defer::\n * Pragma Ada_83::\n * Pragma Ada_95::\n+* Pragma Ada_05::\n * Pragma Annotate::\n * Pragma Assert::\n * Pragma Ast_Entry::\n@@ -781,6 +783,24 @@ contexts.  This pragma is useful when writing a reusable component that\n itself uses Ada 95 features, but which is intended to be usable from\n either Ada 83 or Ada 95 programs.\n \n+@node Pragma Ada_05\n+@unnumberedsec Pragma Ada_05\n+@findex Ada_05\n+@noindent\n+Syntax:\n+@smallexample @c ada\n+pragma Ada_05;\n+@end smallexample\n+\n+@noindent\n+A configuration pragma that establishes Ada 2005 mode for the unit to which\n+it applies, regardless of the mode set by the command line switches.\n+This mode is set automatically for the @code{Ada} and @code{System}\n+packages and their children, so you need not specify it in these\n+contexts.  This pragma is useful when writing a reusable component that\n+itself uses Ada 2005 features, but which is intended to be usable from\n+either Ada 83 or Ada 95 programs.\n+\n @node Pragma Annotate\n @unnumberedsec Pragma Annotate\n @findex Annotate\n@@ -9553,15 +9573,34 @@ thus the same lack of restriction applies.  For example, if you declare:\n then a component clause for a component of type R may start on any\n specified bit boundary, and may specify a value of 49 bits or greater.\n \n-Packed bit arrays that are longer than 64 bits must always be placed\n-on a storage unit (byte) boundary. Any component clause that does not\n+For packed bit arrays that are longer than 64 bits, there are two\n+cases. If the component size is a power of 2 (1,2,4,8,16,32 bits),\n+including the important case of single bits or boolean values, then\n+there are no limitations on placement of such components, and they\n+may start and end at arbitrary bit boundaries.\n+\n+If the component size is not a power of 2 (e.g. 3 or 5), then\n+an array of this type longer than 64 bits must always be placed on\n+on a storage unit (byte) boundary and occupy an integral number\n+of storage units (bytes). Any component clause that does not\n meet this requirement will be rejected.\n \n-The rules for other types are different for GNAT 3 and GNAT 5 versions\n-(based on GCC 2 and GCC 3 respectively). In GNAT 5, larger components\n-(other than packed arrays)\n-may also be placed on arbitrary boundaries, so for example, the following\n-is permitted:\n+Any aliased component, or component of an aliased type, must\n+have its normal alignment and size. A component clause that\n+does not meet this requirement will be rejected.\n+\n+The tag field of a tagged type always occupies an address sized field at\n+the start of the record.  No component clause may attempt to overlay this\n+tag. When a tagged type appears as a component, the tag field must have\n+proper alignment\n+\n+In the case of a record extension T1, of a type T, no component clause applied\n+to the type T1 can specify a storage location that would overlap the first\n+T'Size bytes of the record.\n+\n+For all other component types, including non-bit-packed arrays,\n+the component can be placed at an arbitrary bit boundary,\n+so for example, the following is permitted:\n \n @smallexample @c ada\n    type R is array (1 .. 10) of Boolean;\n@@ -9581,23 +9620,13 @@ is permitted:\n @end smallexample\n \n @noindent\n+Note: the above rules apply to recent releases of GNAT 5.\n In GNAT 3, there are more severe restrictions on larger components.\n For non-primitive types, including packed arrays with a size greater than\n 64 bits, component clauses must respect the alignment requirement of the\n type, in particular, always starting on a byte boundary, and the length\n must be a multiple of the storage unit.\n \n-The following rules regarding tagged types are enforced in both GNAT 3 and\n-GNAT 5:\n-\n-The tag field of a tagged type always occupies an address sized field at\n-the start of the record.  No component clause may attempt to overlay this\n-tag.\n-\n-In the case of a record extension T1, of a type T, no component clause applied\n-to the type T1 can specify a storage location that would overlap the first\n-T'Size bytes of the record.\n-\n @node Enumeration Clauses\n @section Enumeration Clauses\n \n@@ -11810,6 +11839,7 @@ of GNAT, and will generate a warning message.\n * GNAT.Spitbol.Table_VString (g-sptavs.ads)::\n * GNAT.Strings (g-string.ads)::\n * GNAT.String_Split (g-strspl.ads)::\n+* GNAT.UTF_32 (g-utf_32.ads)::\n * GNAT.Table (g-table.ads)::\n * GNAT.Task_Lock (g-tasloc.ads)::\n * GNAT.Threads (g-thread.ads)::\n@@ -12670,6 +12700,22 @@ a string wherever the separators appear, and provide direct access\n to the resulting slices. This package is instantiated from\n @code{GNAT.Array_Split}.\n \n+@node GNAT.UTF_32 (g-utf_32.ads)\n+@section @code{GNAT.UTF_32} (@file{g-table.ads})\n+@cindex @code{GNAT.UTF_32} (@file{g-table.ads})\n+@cindex Wide character codes\n+\n+@noindent\n+This is a package intended to be used in conjunction with the\n+@code{Wide_Character} type in Ada 95 and the\n+@code{Wide_Wide_Character} type in Ada 2005 (available\n+in @code{GNAT} in Ada 2005 mode). This package contains\n+Unicode categorization routines, as well as lexical\n+categorization routines corresponding to the Ada 2005\n+lexical rules for identifiers and strings, and also a\n+lower case to upper case fold routine corresponding to\n+the Ada 2005 rules for identifier equivalence.\n+\n @node GNAT.Table (g-table.ads)\n @section @code{GNAT.Table} (@file{g-table.ads})\n @cindex @code{GNAT.Table} (@file{g-table.ads})\n@@ -12709,7 +12755,7 @@ Provides facilities for creating and destroying threads with explicit calls.\n These threads are known to the GNAT run-time system.  These subprograms are\n exported C-convention procedures intended to be called from foreign code.\n By using these primitives rather than directly calling operating systems\n-routines, compatibility with the Ada tasking runt-time is provided.\n+routines, compatibility with the Ada tasking run-time is provided.\n \n @node GNAT.Traceback (g-traceb.ads)\n @section @code{GNAT.Traceback} (@file{g-traceb.ads})"}, {"sha": "d04028b3c09ad6bc426e4d62f646ec39e5a3b2b6", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 129, "deletions": 1013, "changes": 1142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1b0456bf6e3dac6d1c3045327455c1115790bd/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1b0456bf6e3dac6d1c3045327455c1115790bd/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0f1b0456bf6e3dac6d1c3045327455c1115790bd", "patch": "@@ -275,7 +275,7 @@ Switches for gcc\n * Stack Overflow Checking::\n * Using gcc for Syntax Checking::\n * Using gcc for Semantic Checking::\n-* Compiling Ada 83 Programs::\n+* Compiling Different Versions of Ada::\n * Character Set Control::\n * File Naming Control::\n * Subprogram Inlining Control::\n@@ -377,7 +377,6 @@ GNAT Project Manager\n * Variables from Imported Projects::\n * Naming Schemes::\n * Library Projects::\n-* Using Third-Party Libraries through Projects::\n * Stand-alone Library Projects::\n * Switches Related to Project Files::\n * Tools Supporting Project Files::\n@@ -599,7 +598,6 @@ Inline Assembler\n * Input Variables in Inline Assembler::\n * Inlining Inline Assembler Code::\n * Other Asm Functionality::\n-* A Complete Example::\n \n Compatibility and Porting Guide\n \n@@ -3622,6 +3620,12 @@ compilation process. These switches are fully described in this section.\n First we briefly list all the switches, in alphabetical order, then we\n describe the switches in more detail in functionally grouped sections.\n \n+More switches exist for GCC than those documented here, especially\n+for specific targets. However, their use is not recommended as\n+they may change code generation in ways that are incompatible with\n+the Ada run-time library, or can cause inconsistencies between\n+compilation units.\n+\n @menu\n * Output and Error Message Control::\n * Warning Message Control::\n@@ -3632,7 +3636,7 @@ describe the switches in more detail in functionally grouped sections.\n * Stack Overflow Checking::\n * Using gcc for Syntax Checking::\n * Using gcc for Semantic Checking::\n-* Compiling Ada 83 Programs::\n+* Compiling Different Versions of Ada::\n * Character Set Control::\n * File Naming Control::\n * Subprogram Inlining Control::\n@@ -3706,6 +3710,14 @@ where it can be read by the debugger. You must use the\n @cindex @option{-gnat83} (@command{gcc})\n Enforce Ada 83 restrictions.\n \n+@item -gnat95\n+@cindex @option{-gnat95} (@command{gcc})\n+Enforce Ada 95 restrictions.\n+\n+@item -gnat05\n+@cindex @option{-gnat05} (@command{gcc})\n+Allow full Ada 2005 features.\n+\n @item -gnata\n @cindex @option{-gnata} (@command{gcc})\n Assertions enabled. @code{Pragma Assert} and @code{pragma Debug} to be\n@@ -3824,7 +3836,8 @@ Output full source listing with embedded error messages.\n \n @item -gnatL\n @cindex @option{-gnatL} (@command{gcc})\n-Use the longjmp/setjmp method for exception handling\n+This switch is deprecated. You can use @option{--RTS=sjlj} instead to enable\n+@code{setjmp/longjmp} exception mechanism.\n \n @item -gnatm=@var{n}\n @cindex @option{-gnatm} (@command{gcc})\n@@ -3953,7 +3966,8 @@ to be generated and compiled).\n @end ifset\n \n @item -gnatZ\n-Use the zero cost method for exception handling\n+This switch is deprecated. When zero cost exception handling is not the\n+default and this is supported, you can use @option{--RTS=zcx} instead.\n \n @item ^-I^/SEARCH=^@var{dir}\n @cindex @option{^-I^/SEARCH^} (@command{gcc})\n@@ -5880,11 +5894,20 @@ units that would not normally be compiled (subunits,\n and specifications where a separate body is present).\n @end table\n \n-@node Compiling Ada 83 Programs\n-@subsection Compiling Ada 83 Programs\n+@node Compiling Different Versions of Ada\n+@subsection Compiling Different Versions of Ada\n @table @option\n-@cindex Ada 83 compatibility\n-@item -gnat83\n+@cindex Compatibility with Ada 83\n+@cindex Ada 83 mode\n+@cindex Ada 95 mode\n+@cindex Ada 2005 mode\n+\n+GNAT is primarily an Ada 95 compiler, but the switches described in\n+this section allow operation in Ada 83 compatibility mode, and also\n+allow the use of a preliminary implementation of many of the expected\n+new features in Ada 2005, the forthcoming new version of the standard.\n+\n+@item -gnat83 (Ada 83 Compatibility Mode)\n @cindex @option{-gnat83} (@command{gcc})\n @cindex ACVC, Ada 83 tests\n \n@@ -5912,6 +5935,47 @@ means that a correct Ada 83 program is usually also a correct Ada 95\n program.\n For further information, please refer to @ref{Compatibility and Porting Guide}.\n \n+@item -gnat95 (Ada 95 mode)\n+@cindex @option{-gnat95} (@command{gcc})\n+\n+@noindent\n+GNAT is primarily an Ada 95 compiler, and all current releases of GNAT Pro\n+compile in Ada 95 mode by default. Typically, Ada 95 is sufficiently upwards\n+compatible with Ada 83, that legacy Ada 83 programs may be compiled using\n+this default Ada95 mode without problems (see section above describing the\n+use of @option{-gnat83} to run in Ada 83 mode).\n+\n+In Ada 95 mode, the use of Ada 2005 features will in general cause error\n+messages or warnings. Some specialized releases of GNAT (notably the GAP\n+academic version) operate in Ada 2005 mode by default (see section below\n+describing the use of @option{-gnat05} to run in Ada 2005 mode). For such\n+versions the @option{-gnat95} switch may be used to enforce Ada 95 mode.\n+This option also can be used to cancel the effect of a previous\n+@option{-gnat83} or @option{-gnat05} switch earlier in the command line.\n+\n+\n+@item -gnat05 (Ada 2005 mode)\n+@cindex @option{-gnat05} (@command{gcc})\n+\n+@noindent\n+Although GNAT is primarily an Ada 95 compiler, it can be set to operate\n+in Ada 2005 mode using this option. Although the new standard has not\n+yet been issued (as of early 2005), many features have been discussed and\n+approved in ``Ada Issues'' (AI's). For the text of these AI's, see\n+@url{www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs}. Included with GNAT\n+releases is a file @file{features-ada0y} that describes the current set\n+of implemented Ada 2005 features.\n+\n+If these features are used in Ada 95 mode (which is the normal default),\n+then error messages or warnings may be\n+generated, reflecting the fact that these new features are otherwise\n+unauthorized extensions to Ada 95. The use of the @option{-gnat05}\n+switch (or an equivalent pragma) causes these messages to be suppressed.\n+\n+Note that some specialized releases of GNAT (notably the GAP academic\n+version) have Ada 2005 mode on by default, and in such environments,\n+the Ada 2005 features can be used freely without the use of switches.\n+\n @end table\n \n @node Character Set Control\n@@ -6300,7 +6364,7 @@ speed up compilation, but means that these tools cannot be used.\n \n @noindent\n GNAT uses two methods for handling exceptions at run-time. The\n-@code{longjmp/setjmp} method saves the context when entering\n+@code{setjmp/longjmp} method saves the context when entering\n a frame with an exception handler. Then when an exception is\n raised, the context can be restored immediately, without the\n need for tracing stack frames. This method provides very fast\n@@ -6327,39 +6391,35 @@ two exception handling methods is used.\n @table @option\n @c !sort!\n \n-@item -gnatL\n-@cindex @option{-gnatL} (@command{gcc})\n-This switch causes the longjmp/setjmp approach to be used\n+@item --RTS=sjlj\n+@cindex @option{--RTS=sjlj} (@command{gnatmake})\n+This switch causes the setjmp/longjmp run-time to be used\n for exception handling. If this is the default mechanism for the\n target (see below), then this has no effect. If the default\n mechanism for the target is zero cost exceptions, then\n-this switch can be used to modify this default, but it must be\n-used for all units in the partition, including all run-time\n-library units. One way to achieve this is to use the\n-@option{-a} and @option{-f} switches for @command{gnatmake}.\n+this switch can be used to modify this default, and must be\n+used for all units in the partition.\n This option is rarely used. One case in which it may be\n advantageous is if you have an application where exception\n raising is common and the overall performance of the\n application is improved by favoring exception propagation.\n \n-@item -gnatZ\n-@cindex @option{-gnatZ} (@command{gcc})\n+@item --RTS=zcx\n+@cindex @option{--RTS=zcx} (@command{gnatmake})\n @cindex Zero Cost Exceptions\n-This switch causes the zero cost approach to be sed\n+This switch causes the zero cost approach to be used\n for exception handling. If this is the default mechanism for the\n target (see below), then this has no effect. If the default\n-mechanism for the target is longjmp/setjmp exceptions, then\n-this switch can be used to modify this default, but it must be\n-used for all units in the partition, including all run-time\n-library units. One way to achieve this is to use the\n-@option{-a} and @option{-f} switches for @command{gnatmake}.\n+mechanism for the target is setjmp/longjmp exceptions, then\n+this switch can be used to modify this default, and must be\n+used for all units in the partition.\n This option can only be used if the zero cost approach\n is available for the target in use (see below).\n @end table\n \n @noindent\n-The @code{longjmp/setjmp} approach is available on all targets, but\n-the @code{zero cost} approach is only available on selected targets.\n+The @code{setjmp/longjmp} approach is available on all targets, while\n+the @code{zero cost} approach is available on selected targets.\n To determine whether zero cost exceptions can be used for a\n particular target, look at the private part of the file system.ads.\n Either @code{GCC_ZCX_Support} or @code{Front_End_ZCX_Support} must\n@@ -9966,6 +10026,7 @@ recognized by @code{GNAT}:\n @smallexample\n    Ada_83\n    Ada_95\n+   Ada_05\n    C_Pass_By_Copy\n    Component_Alignment\n    Detect_Blocking\n@@ -10324,7 +10385,6 @@ are used in this example.\n * Variables from Imported Projects::\n * Naming Schemes::\n * Library Projects::\n-* Using Third-Party Libraries through Projects::\n * Stand-alone Library Projects::\n * Switches Related to Project Files::\n * Tools Supporting Project Files::\n@@ -12592,66 +12652,11 @@ All @file{ALI} files will also be copied from the object directory to the\n library directory. To build executables, @command{gnatmake} will use the\n library rather than the individual object files.\n \n-@c **********************************************\n-@c * Using Third-Party Libraries through Projects\n-@c **********************************************\n-@node Using Third-Party Libraries through Projects\n-@section Using Third-Party Libraries through Projects\n-\n-Whether you are exporting your own library to make it available to\n-clients, or you are using a library provided by a third party, it is\n-convenient to have project files that automatically set the correct\n-command line switches for the compiler and linker.\n-\n-Such project files are very similar to the library project files;\n-@xref{Library Projects}. The only difference is that you set the\n-@code{Source_Dirs} and @code{Object_Dir} attribute so that they point to the\n-directories where, respectively, the sources and the read-only ALI files have\n-been installed.\n-\n-If you need to interface with a set of libraries, as opposed to a\n-single one, you need to create one library project for each of the\n-libraries. In addition, a top-level project that imports all these\n-library projects should be provided, so that the user of your library\n-has a single @code{with} clause to add to his own projects.\n-\n-For instance, let's assume you are providing two static libraries\n-@file{liba.a} and @file{libb.a}. The user needs to link with\n-both of these libraries. Each of these is associated with its\n-own set of header files. Let's assume furthermore that all the\n-header files for the two libraries have been installed in the same\n-directory @file{headers}. The @file{ALI} files are found in the same\n-@file{headers} directory.\n-\n-In this case, you should provide the following three projects:\n-\n-@smallexample @c projectfile\n-@group\n-with \"liba\", \"libb\";\n-project My_Library is\n-  for Source_Dirs use (\"headers\");\n-  for Object_Dir  use \"headers\";\n-end My_Library;\n-@end group\n-\n-@group\n-project Liba is\n-   for Source_Dirs use ();\n-   for Library_Dir use \"lib\";\n-   for Library_Name use \"a\";\n-   for Library_Kind use \"static\";\n-end Liba;\n-@end group\n-\n-@group\n-project Libb is\n-   for Source_Dirs use ();\n-   for Library_Dir use \"lib\";\n-   for Library_Name use \"b\";\n-   for Library_Kind use \"static\";\n-end Libb;\n-@end group\n-@end smallexample\n+@ifclear vms\n+It is also possible to create library project files for third-party libraries\n+that are precompiled and cannot be compiled locally thanks to the\n+@code{externally_built} attribute. (See @ref{Installing a library}).\n+@end ifclear\n \n @c *******************************\n @c * Stand-alone Library Projects *\n@@ -15382,16 +15387,15 @@ A casing schema is a string that has the following syntax:\n \n @smallexample\n @cartouche\n-  @var{casing_schema} ::= @var{identifier} | [*]@var{simple_identifier}[*]\n+  @var{casing_schema} ::= @var{identifier} | *@var{simple_identifier}*\n \n   @var{simple_identifier} ::= @var{letter}@{@var{letter_or_digit}@}\n @end cartouche\n @end smallexample\n \n @noindent\n-(The @code{[]} metanotation stands for an optional part;\n-see @cite{Ada Reference Manual}, Section 2.3) for the definition of the\n-@var{identifier} lexical element and the @var{letter_or_digit} category).\n+(See @cite{Ada Reference Manual}, Section 2.3) for the definition of the\n+@var{identifier} lexical element and the @var{letter_or_digit} category.)\n \n The casing schema string can be followed by white space and/or an Ada-style\n comment; any amount of white space is allowed before the string.\n@@ -15415,22 +15419,15 @@ if the whole name is in the dictionary, @command{gnatpp} uses for this name\n the casing defined by the dictionary; no subwords are checked for this word\n \n @item\n-for the first subword (that is, for the subword preceding the leftmost\n-``_''), @command{gnatpp} checks if the dictionary contains the corresponding\n-string of the form @code{@var{simple_identifier}*}, and if it does, the\n+for every subword @command{gnatpp} checks if the dictionary contains the\n+corresponding string of the form @code{*@var{simple_identifier}*}, and if it does, the\n casing of this @var{simple_identifier} is used for this subword\n \n @item\n-for the last subword (following the rightmost ``_'') @command{gnatpp}\n-checks if the dictionary contains the corresponding string of the form\n-@code{*@var{simple_identifier}}, and if it does, the casing of this\n-@var{simple_identifier} is used for this subword\n-\n-@item\n-for every intermediate subword (surrounded by two'_') @command{gnatpp} checks\n-if the dictionary contains the corresponding string of the form\n-@code{*@var{simple_identifier}*}, and if it does, the casing of this\n-simple_identifier is used for this subword\n+if the whole name does not contain any ``_'' inside, and if for this name\n+the dictionaty contains two entries - one of the form @var{identifier},\n+and another - of the form *@var{simple_identifier}*, then the first one\n+is applied to define the casing of this name\n \n @item\n if more than one dictionary file is passed as @command{gnatpp} switches, each\n@@ -15466,7 +15463,7 @@ And suppose we have two dictionaries:\n @i{dict1:}\n    NAME1\n    *NaMe3*\n-   *NAME2\n+   *Name1*\n @end cartouche\n \n @cartouche\n@@ -15494,11 +15491,11 @@ then we will get the following name casing in the @command{gnatpp} output:\n @cartouche\n procedure Test is\n    NAME1             : Integer := 1;\n-   Name4_NAME3_NAME2 : integer := 2;\n+   Name4_NAME3_Name2 : Integer := 2;\n    Name2_NAME3_Name4 : Boolean;\n    Name1_Var         : Float;\n begin\n-   Name2_NAME3_Name4 := Name4_NAME3_NAME2 > NAME1;\n+   Name2_NAME3_Name4 := Name4_NAME3_Name2 > NAME1;\n end Test;\n @end cartouche\n @end smallexample\n@@ -16734,7 +16731,7 @@ Source Search Path:\n Object Search Path:\n    <Current_Directory>\n    ../\n-   /home/comar/local/lib/gcc-lib/mips-sni-sysv4/2.7.2/adalib/\n+   /home/comar/local/lib/gcc-lib/x86-linux/3.4.3/adalib/\n \n Project Search Path:\n    <Current_Directory>\n@@ -17247,13 +17244,17 @@ third-party library @file{liba.a}:\n @smallexample @c projectfile\n @group\n project Liba is\n-   for Source_Dirs use ();\n+   for Externally_Built use \"true\";\n    for Library_Dir use \"lib\";\n    for Library_Name use \"a\";\n    for Library_Kind use \"static\";\n end Liba;\n @end group\n @end smallexample\n+This is an alternative to the use of @code{pragma Linker_Options}. It is\n+especially interesting in the context of systems with several interdependant\n+static libraries where finding a proper linker order is not easy and best be\n+left to the tools having visibility over project dependancy information.\n \n @noindent\n In order to use an Ada library manually, you need to make sure that this\n@@ -20822,6 +20823,8 @@ GNAT also supplies a number of implementation-defined pragmas as follows:\n \n @item  ADA_95\n \n+@item  ADA_05\n+\n @item  ANNOTATE\n \n @item  ASSERT\n@@ -21916,19 +21919,28 @@ this option) is required.\n The easiest way to build a 64bit application is to add\n @option{-m64 --RTS=m64} to the @command{gnatmake} flags.\n \n-To debug these applications, dwarf-2 debug information is required, so you\n-have to add @option{-gdwarf-2} to your gnatmake arguments.\n-In addition, a special\n-version of gdb, called @command{gdb64}, needs to be used.\n+To debug these applications, a special version of gdb called @command{gdb64}\n+needs to be used.\n \n To summarize, building and debugging a ``Hello World'' program in 64-bit mode\n amounts to:\n \n @smallexample\n-     $ gnatmake -m64 -gdwarf-2 --RTS=m64 hello.adb\n+     $ gnatmake -m64 -g --RTS=m64 hello.adb\n      $ gdb64 hello\n @end smallexample\n \n+In addition, the following capabilities are not supported when using the\n+@option{-m64} option:\n+\n+@table @code\n+@item -fstack-check does not work together with -m64.\n+Any application combining these options crashes at startup time.\n+\n+@item Call-chain backtrace computation does not work with -m64.\n+Thus the gnatbind switch -E is not supported.\n+@end table\n+\n @node IRIX-Specific Considerations\n @section IRIX-Specific Considerations\n @cindex IRIX thread library\n@@ -24600,7 +24612,6 @@ and with assembly language programming.\n * Input Variables in Inline Assembler::\n * Inlining Inline Assembler Code::\n * Other Asm Functionality::\n-* A Complete Example::\n @end menu\n \n @c ---------------------------------------------------------------------------\n@@ -25274,901 +25285,6 @@ optimizations, it will also disable other optimizations that might be\n important for efficiency. In general, you should set @code{Volatile}\n to @code{True} only if the compiler's optimizations have created\n problems.\n-\n-@c ---------------------------------------------------------------------------\n-@node A Complete Example\n-@section A Complete Example\n-\n-@noindent\n-This section contains a complete program illustrating a realistic usage\n-of GNAT's Inline Assembler capabilities.  It comprises a main procedure\n-@code{Check_CPU} and a package @code{Intel_CPU}.\n-The package declares a collection of functions that detect the properties\n-of the 32-bit x86 processor that is running the program.\n-The main procedure invokes these functions and displays the information.\n-\n-The Intel_CPU package could be enhanced by adding functions to\n-detect the type of x386 co-processor, the processor caching options and\n-special operations such as the SIMD extensions.\n-\n-Although the Intel_CPU package has been written for 32-bit Intel\n-compatible CPUs, it is OS neutral. It has been tested on DOS,\n-Windows/NT and GNU/Linux.\n-\n-@menu\n-* Check_CPU Procedure::\n-* Intel_CPU Package Specification::\n-* Intel_CPU Package Body::\n-@end menu\n-\n-@c ---------------------------------------------------------------------------\n-@node Check_CPU Procedure\n-@subsection @code{Check_CPU} Procedure\n-@cindex Check_CPU procedure\n-\n-@smallexample @c adanocomment\n----------------------------------------------------------------------\n---                                                                 --\n---  Uses the Intel_CPU package to identify the CPU the program is  --\n---  running on, and some of the features it supports.              --\n---                                                                 --\n----------------------------------------------------------------------\n-\n-with Intel_CPU;                     --  Intel CPU detection functions\n-with Ada.Text_IO;                   --  Standard text I/O\n-with Ada.Command_Line;              --  To set the exit status\n-\n-procedure Check_CPU is\n-\n-   Type_Found : Boolean := False;\n-   --  Flag to indicate that processor was identified\n-\n-   Features   : Intel_CPU.Processor_Features;\n-   --  The processor features\n-\n-   Signature  : Intel_CPU.Processor_Signature;\n-   --  The processor type signature\n-\n-begin\n-\n-   -----------------------------------\n-   --  Display the program banner.  --\n-   -----------------------------------\n-\n-   Ada.Text_IO.Put_Line (Ada.Command_Line.Command_Name &\n-                         \": check Intel CPU version and features, v1.0\");\n-   Ada.Text_IO.Put_Line (\"distribute freely, but no warranty whatsoever\");\n-   Ada.Text_IO.New_Line;\n-\n-   -----------------------------------------------------------------------\n-   --  We can safely start with the assumption that we are on at least  --\n-   --  a x386 processor. If the CPUID instruction is present, then we   --\n-   --  have a later processor type.                                     --\n-   -----------------------------------------------------------------------\n-\n-   if Intel_CPU.Has_CPUID = False then\n-\n-      --  No CPUID instruction, so we assume this is indeed a x386\n-      --  processor. We can still check if it has a FP co-processor.\n-      if Intel_CPU.Has_FPU then\n-         Ada.Text_IO.Put_Line\n-           (\"x386-type processor with a FP co-processor\");\n-      else\n-         Ada.Text_IO.Put_Line\n-           (\"x386-type processor without a FP co-processor\");\n-      end if;  --  check for FPU\n-\n-      --  Program done\n-      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Success);\n-      return;\n-\n-   end if;  --  check for CPUID\n-\n-   -----------------------------------------------------------------------\n-   --  If CPUID is supported, check if this is a true Intel processor,  --\n-   --  if it is not, display a warning.                                 --\n-   -----------------------------------------------------------------------\n-\n-   if Intel_CPU.Vendor_ID /= Intel_CPU.Intel_Processor then\n-      Ada.Text_IO.Put_Line (\"*** This is a Intel compatible processor\");\n-      Ada.Text_IO.Put_Line (\"*** Some information may be incorrect\");\n-   end if;  --  check if Intel\n-\n-   ----------------------------------------------------------------------\n-   --  With the CPUID instruction present, we can assume at least a    --\n-   --  x486 processor. If the CPUID support level is < 1 then we have  --\n-   --  to leave it at that.                                            --\n-   ----------------------------------------------------------------------\n-\n-   if Intel_CPU.CPUID_Level < 1 then\n-\n-      --  Ok, this is a x486 processor. we still can get the Vendor ID\n-      Ada.Text_IO.Put_Line (\"x486-type processor\");\n-      Ada.Text_IO.Put_Line (\"Vendor ID is \" & Intel_CPU.Vendor_ID);\n-\n-      --  We can also check if there is a FPU present\n-      if Intel_CPU.Has_FPU then\n-         Ada.Text_IO.Put_Line (\"Floating-Point support\");\n-      else\n-         Ada.Text_IO.Put_Line (\"No Floating-Point support\");\n-      end if;  --  check for FPU\n-\n-      --  Program done\n-      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Success);\n-      return;\n-\n-   end if;  --  check CPUID level\n-\n-   ---------------------------------------------------------------------\n-   --  With a CPUID level of 1 we can use the processor signature to  --\n-   --  determine it's exact type.                                     --\n-   ---------------------------------------------------------------------\n-\n-   Signature := Intel_CPU.Signature;\n-\n-   ----------------------------------------------------------------------\n-   --  Ok, now we go into a lot of messy comparisons to get the        --\n-   --  processor type. For clarity, no attememt to try to optimize the --\n-   --  comparisons has been made. Note that since Intel_CPU does not   --\n-   --  support getting cache info, we cannot distinguish between P5    --\n-   --  and Celeron types yet.                                          --\n-   ----------------------------------------------------------------------\n-\n-   --  x486SL\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0100# and\n-     Signature.Model           = 2#0100# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"x486SL processor\");\n-   end if;\n-\n-   --  x486DX2 Write-Back\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0100# and\n-     Signature.Model           = 2#0111# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"Write-Back Enhanced x486DX2 processor\");\n-   end if;\n-\n-   --  x486DX4\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0100# and\n-     Signature.Model           = 2#1000# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"x486DX4 processor\");\n-   end if;\n-\n-   --  x486DX4 Overdrive\n-   if Signature.Processor_Type = 2#01#   and\n-     Signature.Family          = 2#0100# and\n-     Signature.Model           = 2#1000# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"x486DX4 OverDrive processor\");\n-   end if;\n-\n-   --  Pentium (60, 66)\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0001# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"Pentium processor (60, 66)\");\n-   end if;\n-\n-   --  Pentium (75, 90, 100, 120, 133, 150, 166, 200)\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0010# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line\n-        (\"Pentium processor (75, 90, 100, 120, 133, 150, 166, 200)\");\n-   end if;\n-\n-   --  Pentium OverDrive (60, 66)\n-   if Signature.Processor_Type = 2#01#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0001# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"Pentium OverDrive processor (60, 66)\");\n-   end if;\n-\n-   --  Pentium OverDrive (75, 90, 100, 120, 133, 150, 166, 200)\n-   if Signature.Processor_Type = 2#01#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0010# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line\n-        (\"Pentium OverDrive cpu (75, 90, 100, 120, 133, 150, 166, 200)\");\n-   end if;\n-\n-   --  Pentium OverDrive processor for x486 processor-based systems\n-   if Signature.Processor_Type = 2#01#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0011# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line\n-        (\"Pentium OverDrive processor for x486 processor-based systems\");\n-   end if;\n-\n-   --  Pentium processor with MMX technology (166, 200)\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0100# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line\n-        (\"Pentium processor with MMX technology (166, 200)\");\n-   end if;\n-\n-   --  Pentium OverDrive with MMX for Pentium (75, 90, 100, 120, 133)\n-   if Signature.Processor_Type = 2#01#   and\n-     Signature.Family          = 2#0101# and\n-     Signature.Model           = 2#0100# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line\n-        (\"Pentium OverDrive processor with MMX \" &\n-         \"technology for Pentium processor (75, 90, 100, 120, 133)\");\n-   end if;\n-\n-   --  Pentium Pro processor\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0110# and\n-     Signature.Model           = 2#0001# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"Pentium Pro processor\");\n-   end if;\n-\n-   --  Pentium II processor, model 3\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0110# and\n-     Signature.Model           = 2#0011# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"Pentium II processor, model 3\");\n-   end if;\n-\n-   --  Pentium II processor, model 5 or Celeron processor\n-   if Signature.Processor_Type = 2#00#   and\n-     Signature.Family          = 2#0110# and\n-     Signature.Model           = 2#0101# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line\n-        (\"Pentium II processor, model 5 or Celeron processor\");\n-   end if;\n-\n-   --  Pentium Pro OverDrive processor\n-   if Signature.Processor_Type = 2#01#   and\n-     Signature.Family          = 2#0110# and\n-     Signature.Model           = 2#0011# then\n-      Type_Found := True;\n-      Ada.Text_IO.Put_Line (\"Pentium Pro OverDrive processor\");\n-   end if;\n-\n-   --  If no type recognized, we have an unknown. Display what\n-   --  we _do_ know\n-   if Type_Found = False then\n-      Ada.Text_IO.Put_Line (\"Unknown processor\");\n-   end if;\n-\n-   -----------------------------------------\n-   --  Display processor stepping level.  --\n-   -----------------------------------------\n-\n-   Ada.Text_IO.Put_Line (\"Stepping level:\" & Signature.Stepping'Img);\n-\n-   ---------------------------------\n-   --  Display vendor ID string.  --\n-   ---------------------------------\n-\n-   Ada.Text_IO.Put_Line (\"Vendor ID: \" & Intel_CPU.Vendor_ID);\n-\n-   ------------------------------------\n-   --  Get the processors features.  --\n-   ------------------------------------\n-\n-   Features := Intel_CPU.Features;\n-\n-   -----------------------------\n-   --  Check for a FPU unit.  --\n-   -----------------------------\n-\n-   if Features.FPU = True then\n-      Ada.Text_IO.Put_Line (\"Floating-Point unit available\");\n-   else\n-      Ada.Text_IO.Put_Line (\"no Floating-Point unit\");\n-   end if;  --  check for FPU\n-\n-   --------------------------------\n-   --  List processor features.  --\n-   --------------------------------\n-\n-   Ada.Text_IO.Put_Line (\"Supported features: \");\n-\n-   --  Virtual Mode Extension\n-   if Features.VME = True then\n-      Ada.Text_IO.Put_Line (\"    VME    - Virtual Mode Extension\");\n-   end if;\n-\n-   --  Debugging Extension\n-   if Features.DE = True then\n-      Ada.Text_IO.Put_Line (\"    DE     - Debugging Extension\");\n-   end if;\n-\n-   --  Page Size Extension\n-   if Features.PSE = True then\n-      Ada.Text_IO.Put_Line (\"    PSE    - Page Size Extension\");\n-   end if;\n-\n-   --  Time Stamp Counter\n-   if Features.TSC = True then\n-      Ada.Text_IO.Put_Line (\"    TSC    - Time Stamp Counter\");\n-   end if;\n-\n-   --  Model Specific Registers\n-   if Features.MSR = True then\n-      Ada.Text_IO.Put_Line (\"    MSR    - Model Specific Registers\");\n-   end if;\n-\n-   --  Physical Address Extension\n-   if Features.PAE = True then\n-      Ada.Text_IO.Put_Line (\"    PAE    - Physical Address Extension\");\n-   end if;\n-\n-   --  Machine Check Extension\n-   if Features.MCE = True then\n-      Ada.Text_IO.Put_Line (\"    MCE    - Machine Check Extension\");\n-   end if;\n-\n-   --  CMPXCHG8 instruction supported\n-   if Features.CX8 = True then\n-      Ada.Text_IO.Put_Line (\"    CX8    - CMPXCHG8 instruction\");\n-   end if;\n-\n-   --  on-chip APIC hardware support\n-   if Features.APIC = True then\n-      Ada.Text_IO.Put_Line (\"    APIC   - on-chip APIC hardware support\");\n-   end if;\n-\n-   --  Fast System Call\n-   if Features.SEP = True then\n-      Ada.Text_IO.Put_Line (\"    SEP    - Fast System Call\");\n-   end if;\n-\n-   --  Memory Type Range Registers\n-   if Features.MTRR = True then\n-      Ada.Text_IO.Put_Line (\"    MTTR   - Memory Type Range Registers\");\n-   end if;\n-\n-   --  Page Global Enable\n-   if Features.PGE = True then\n-      Ada.Text_IO.Put_Line (\"    PGE    - Page Global Enable\");\n-   end if;\n-\n-   --  Machine Check Architecture\n-   if Features.MCA = True then\n-      Ada.Text_IO.Put_Line (\"    MCA    - Machine Check Architecture\");\n-   end if;\n-\n-   --  Conditional Move Instruction Supported\n-   if Features.CMOV = True then\n-      Ada.Text_IO.Put_Line\n-        (\"    CMOV   - Conditional Move Instruction Supported\");\n-   end if;\n-\n-   --  Page Attribute Table\n-   if Features.PAT = True then\n-      Ada.Text_IO.Put_Line (\"    PAT    - Page Attribute Table\");\n-   end if;\n-\n-   --  36-bit Page Size Extension\n-   if Features.PSE_36 = True then\n-      Ada.Text_IO.Put_Line (\"    PSE_36 - 36-bit Page Size Extension\");\n-   end if;\n-\n-   --  MMX technology supported\n-   if Features.MMX = True then\n-      Ada.Text_IO.Put_Line (\"    MMX    - MMX technology supported\");\n-   end if;\n-\n-   --  Fast FP Save and Restore\n-   if Features.FXSR = True then\n-      Ada.Text_IO.Put_Line (\"    FXSR   - Fast FP Save and Restore\");\n-   end if;\n-\n-   ---------------------\n-   --  Program done.  --\n-   ---------------------\n-\n-   Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Success);\n-\n-exception\n-\n-   when others =>\n-      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Failure);\n-      raise;\n-\n-end Check_CPU;\n-@end smallexample\n-\n-@c ---------------------------------------------------------------------------\n-@node Intel_CPU Package Specification\n-@subsection @code{Intel_CPU} Package Specification\n-@cindex Intel_CPU package specification\n-\n-@smallexample @c adanocomment\n--------------------------------------------------------------------------\n---                                                                     --\n---  file: intel_cpu.ads                                                --\n---                                                                     --\n---           *********************************************             --\n---           * WARNING: for 32-bit Intel processors only *             --\n---           *********************************************             --\n---                                                                     --\n---  This package contains a number of subprograms that are useful in   --\n---  determining the Intel x86 CPU (and the features it supports) on    --\n---  which the program is running.                                      --\n---                                                                     --\n---  The package is based upon the information given in the Intel       --\n---  Application Note AP-485: \"Intel Processor Identification and the   --\n---  CPUID Instruction\" as of April 1998. This application note can be  --\n---  found on www.intel.com.                                            --\n---                                                                     --\n---  It currently deals with 32-bit processors only, will not detect    --\n---  features added after april 1998, and does not guarantee proper     --\n---  results on Intel-compatible processors.                            --\n---                                                                     --\n---  Cache info and x386 fpu type detection are not supported.          --\n---                                                                     --\n---  This package does not use any privileged instructions, so should   --\n---  work on any OS running on a 32-bit Intel processor.                --\n---                                                                     --\n--------------------------------------------------------------------------\n-\n-with Interfaces;             use Interfaces;\n---  for using unsigned types\n-\n-with System.Machine_Code;    use System.Machine_Code;\n---  for using inline assembler code\n-\n-with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;\n---  for inserting control characters\n-\n-package Intel_CPU is\n-\n-   ----------------------\n-   --  Processor bits  --\n-   ----------------------\n-\n-   subtype Num_Bits is Natural range 0 .. 31;\n-   --  the number of processor bits (32)\n-\n-   --------------------------\n-   --  Processor register  --\n-   --------------------------\n-\n-   --  define a processor register type for easy access to\n-   --  the individual bits\n-\n-   type Processor_Register is array (Num_Bits) of Boolean;\n-   pragma Pack (Processor_Register);\n-   for Processor_Register'Size use 32;\n-\n-   -------------------------\n-   --  Unsigned register  --\n-   -------------------------\n-\n-   --  define a processor register type for easy access to\n-   --  the individual bytes\n-\n-   type Unsigned_Register is\n-      record\n-         L1 : Unsigned_8;\n-         H1 : Unsigned_8;\n-         L2 : Unsigned_8;\n-         H2 : Unsigned_8;\n-      end record;\n-\n-   for Unsigned_Register use\n-      record\n-         L1 at 0 range  0 ..  7;\n-         H1 at 0 range  8 .. 15;\n-         L2 at 0 range 16 .. 23;\n-         H2 at 0 range 24 .. 31;\n-      end record;\n-\n-   for Unsigned_Register'Size use 32;\n-\n-   ---------------------------------\n-   --  Intel processor vendor ID  --\n-   ---------------------------------\n-\n-   Intel_Processor : constant String (1 .. 12) := \"GenuineIntel\";\n-   --  indicates an Intel manufactured processor\n-\n-   ------------------------------------\n-   --  Processor signature register  --\n-   ------------------------------------\n-\n-   --  a register type to hold the processor signature\n-\n-   type Processor_Signature is\n-      record\n-         Stepping       : Natural range 0 .. 15;\n-         Model          : Natural range 0 .. 15;\n-         Family         : Natural range 0 .. 15;\n-         Processor_Type : Natural range 0 .. 3;\n-         Reserved       : Natural range 0 .. 262143;\n-      end record;\n-\n-   for Processor_Signature use\n-      record\n-         Stepping       at 0 range  0 ..  3;\n-         Model          at 0 range  4 ..  7;\n-         Family         at 0 range  8 .. 11;\n-         Processor_Type at 0 range 12 .. 13;\n-         Reserved       at 0 range 14 .. 31;\n-      end record;\n-\n-   for Processor_Signature'Size use 32;\n-\n-   -----------------------------------\n-   --  Processor features register  --\n-   -----------------------------------\n-\n-   --  a processor register to hold the processor feature flags\n-\n-   type Processor_Features is\n-      record\n-         FPU    : Boolean;                --  floating point unit on chip\n-         VME    : Boolean;                --  virtual mode extension\n-         DE     : Boolean;                --  debugging extension\n-         PSE    : Boolean;                --  page size extension\n-         TSC    : Boolean;                --  time stamp counter\n-         MSR    : Boolean;                --  model specific registers\n-         PAE    : Boolean;                --  physical address extension\n-         MCE    : Boolean;                --  machine check extension\n-         CX8    : Boolean;                --  cmpxchg8 instruction\n-         APIC   : Boolean;                --  on-chip apic hardware\n-         Res_1  : Boolean;                --  reserved for extensions\n-         SEP    : Boolean;                --  fast system call\n-         MTRR   : Boolean;                --  memory type range registers\n-         PGE    : Boolean;                --  page global enable\n-         MCA    : Boolean;                --  machine check architecture\n-         CMOV   : Boolean;                --  conditional move supported\n-         PAT    : Boolean;                --  page attribute table\n-         PSE_36 : Boolean;                --  36-bit page size extension\n-         Res_2  : Natural range 0 .. 31;  --  reserved for extensions\n-         MMX    : Boolean;                --  MMX technology supported\n-         FXSR   : Boolean;                --  fast FP save and restore\n-         Res_3  : Natural range 0 .. 127; --  reserved for extensions\n-      end record;\n-\n-   for Processor_Features use\n-      record\n-         FPU    at 0 range  0 ..  0;\n-         VME    at 0 range  1 ..  1;\n-         DE     at 0 range  2 ..  2;\n-         PSE    at 0 range  3 ..  3;\n-         TSC    at 0 range  4 ..  4;\n-         MSR    at 0 range  5 ..  5;\n-         PAE    at 0 range  6 ..  6;\n-         MCE    at 0 range  7 ..  7;\n-         CX8    at 0 range  8 ..  8;\n-         APIC   at 0 range  9 ..  9;\n-         Res_1  at 0 range 10 .. 10;\n-         SEP    at 0 range 11 .. 11;\n-         MTRR   at 0 range 12 .. 12;\n-         PGE    at 0 range 13 .. 13;\n-         MCA    at 0 range 14 .. 14;\n-         CMOV   at 0 range 15 .. 15;\n-         PAT    at 0 range 16 .. 16;\n-         PSE_36 at 0 range 17 .. 17;\n-         Res_2  at 0 range 18 .. 22;\n-         MMX    at 0 range 23 .. 23;\n-         FXSR   at 0 range 24 .. 24;\n-         Res_3  at 0 range 25 .. 31;\n-      end record;\n-\n-   for Processor_Features'Size use 32;\n-\n-   -------------------\n-   --  Subprograms  --\n-   -------------------\n-\n-   function Has_FPU return Boolean;\n-   --  return True if a FPU is found\n-   --  use only if CPUID is not supported\n-\n-   function Has_CPUID return Boolean;\n-   --  return True if the processor supports the CPUID instruction\n-\n-   function CPUID_Level return Natural;\n-   --  return the CPUID support level (0, 1 or 2)\n-   --  can only be called if the CPUID instruction is supported\n-\n-   function Vendor_ID return String;\n-   --  return the processor vendor identification string\n-   --  can only be called if the CPUID instruction is supported\n-\n-   function Signature return Processor_Signature;\n-   --  return the processor signature\n-   --  can only be called if the CPUID instruction is supported\n-\n-   function Features return Processor_Features;\n-   --  return the processors features\n-   --  can only be called if the CPUID instruction is supported\n-\n-private\n-\n-   ------------------------\n-   --  EFLAGS bit names  --\n-   ------------------------\n-\n-   ID_Flag : constant Num_Bits := 21;\n-   --  ID flag bit\n-\n-end Intel_CPU;\n-@end smallexample\n-\n-@c ---------------------------------------------------------------------------\n-@node Intel_CPU Package Body\n-@subsection @code{Intel_CPU} Package Body\n-@cindex Intel_CPU package body\n-\n-@smallexample @c adanocomment\n-package body Intel_CPU is\n-\n-   ---------------------------\n-   --  Detect FPU presence  --\n-   ---------------------------\n-\n-   --  There is a FPU present if we can set values to the FPU Status\n-   --  and Control Words.\n-\n-   function Has_FPU return Boolean is\n-\n-      Register : Unsigned_16;\n-      --  processor register to store a word\n-\n-   begin\n-\n-      --  check if we can change the status word\n-      Asm (\n-\n-           --  the assembler code\n-           \"finit\"              & LF & HT &    --  reset status word\n-           \"movw $0x5A5A, %%ax\" & LF & HT &    --  set value status word\n-           \"fnstsw %0\"          & LF & HT &    --  save status word\n-           \"movw %%ax, %0\",                    --  store status word\n-\n-           --  output stored in Register\n-           --  register must be a memory location\n-           Outputs => Unsigned_16'Asm_output (\"=m\", Register),\n-\n-           --  tell compiler that we used eax\n-           Clobber => \"eax\");\n-\n-      --  if the status word is zero, there is no FPU\n-      if Register = 0 then\n-         return False;   --  no status word\n-      end if;  --  check status word value\n-\n-      --  check if we can get the control word\n-      Asm (\n-\n-           --  the assembler code\n-           \"fnstcw %0\",   --  save the control word\n-\n-           --  output into Register\n-           --  register must be a memory location\n-           Outputs => Unsigned_16'Asm_output (\"=m\", Register));\n-\n-      --  check the relevant bits\n-      if (Register and 16#103F#) /= 16#003F# then\n-         return False;   --  no control word\n-      end if;  --  check control word value\n-\n-      --  FPU found\n-      return True;\n-\n-   end Has_FPU;\n-\n-   --------------------------------\n-   --  Detect CPUID instruction  --\n-   --------------------------------\n-\n-   --  The processor supports the CPUID instruction if it is possible\n-   --  to change the value of ID flag bit in the EFLAGS register.\n-\n-   function Has_CPUID return Boolean is\n-\n-      Original_Flags, Modified_Flags : Processor_Register;\n-      --  EFLAG contents before and after changing the ID flag\n-\n-   begin\n-\n-      --  try flipping the ID flag in the EFLAGS register\n-      Asm (\n-\n-           --  the assembler code\n-           \"pushfl\"               & LF & HT &     --  push EFLAGS on stack\n-           \"pop %%eax\"            & LF & HT &     --  pop EFLAGS into eax\n-           \"movl %%eax, %0\"       & LF & HT &     --  save EFLAGS content\n-           \"xor $0x200000, %%eax\" & LF & HT &     --  flip ID flag\n-           \"push %%eax\"           & LF & HT &     --  push EFLAGS on stack\n-           \"popfl\"                & LF & HT &     --  load EFLAGS register\n-           \"pushfl\"               & LF & HT &     --  push EFLAGS on stack\n-           \"pop %1\",                              --  save EFLAGS content\n-\n-           --  output values, may be anything\n-           --  Original_Flags is %0\n-           --  Modified_Flags is %1\n-           Outputs =>\n-              (Processor_Register'Asm_output (\"=g\", Original_Flags),\n-               Processor_Register'Asm_output (\"=g\", Modified_Flags)),\n-\n-           --  tell compiler eax is destroyed\n-           Clobber => \"eax\");\n-\n-      --  check if CPUID is supported\n-      if Original_Flags(ID_Flag) /= Modified_Flags(ID_Flag) then\n-         return True;   --  ID flag was modified\n-      else\n-         return False;  --  ID flag unchanged\n-      end if;  --  check for CPUID\n-\n-   end Has_CPUID;\n-\n-   -------------------------------\n-   --  Get CPUID support level  --\n-   -------------------------------\n-\n-   function CPUID_Level return Natural is\n-\n-      Level : Unsigned_32;\n-      --  returned support level\n-\n-   begin\n-\n-      --  execute CPUID, storing the results in the Level register\n-      Asm (\n-\n-           --  the assembler code\n-           \"cpuid\",    --  execute CPUID\n-\n-           --  zero is stored in eax\n-           --  returning the support level in eax\n-           Inputs => Unsigned_32'Asm_input (\"a\", 0),\n-\n-           --  eax is stored in Level\n-           Outputs => Unsigned_32'Asm_output (\"=a\", Level),\n-\n-           --  tell compiler ebx, ecx and edx registers are destroyed\n-           Clobber => \"ebx, ecx, edx\");\n-\n-      --  return the support level\n-      return Natural (Level);\n-\n-   end CPUID_Level;\n-\n-   --------------------------------\n-   --  Get CPU Vendor ID String  --\n-   --------------------------------\n-\n-   --  The vendor ID string is returned in the ebx, ecx and edx register\n-   --  after executing the CPUID instruction with eax set to zero.\n-   --  In case of a true Intel processor the string returned is\n-   --  \"GenuineIntel\"\n-\n-   function Vendor_ID return String is\n-\n-      Ebx, Ecx, Edx : Unsigned_Register;\n-      --  registers containing the vendor ID string\n-\n-      Vendor_ID : String (1 .. 12);\n-      -- the vendor ID string\n-\n-   begin\n-\n-      --  execute CPUID, storing the results in the processor registers\n-      Asm (\n-\n-           --  the assembler code\n-           \"cpuid\",    --  execute CPUID\n-\n-           --  zero stored in eax\n-           --  vendor ID string returned in ebx, ecx and edx\n-           Inputs => Unsigned_32'Asm_input (\"a\", 0),\n-\n-           --  ebx is stored in Ebx\n-           --  ecx is stored in Ecx\n-           --  edx is stored in Edx\n-           Outputs => (Unsigned_Register'Asm_output (\"=b\", Ebx),\n-                       Unsigned_Register'Asm_output (\"=c\", Ecx),\n-                       Unsigned_Register'Asm_output (\"=d\", Edx)));\n-\n-      --  now build the vendor ID string\n-      Vendor_ID( 1) := Character'Val (Ebx.L1);\n-      Vendor_ID( 2) := Character'Val (Ebx.H1);\n-      Vendor_ID( 3) := Character'Val (Ebx.L2);\n-      Vendor_ID( 4) := Character'Val (Ebx.H2);\n-      Vendor_ID( 5) := Character'Val (Edx.L1);\n-      Vendor_ID( 6) := Character'Val (Edx.H1);\n-      Vendor_ID( 7) := Character'Val (Edx.L2);\n-      Vendor_ID( 8) := Character'Val (Edx.H2);\n-      Vendor_ID( 9) := Character'Val (Ecx.L1);\n-      Vendor_ID(10) := Character'Val (Ecx.H1);\n-      Vendor_ID(11) := Character'Val (Ecx.L2);\n-      Vendor_ID(12) := Character'Val (Ecx.H2);\n-\n-      --  return string\n-      return Vendor_ID;\n-\n-   end Vendor_ID;\n-\n-   -------------------------------\n-   --  Get processor signature  --\n-   -------------------------------\n-\n-   function Signature return Processor_Signature is\n-\n-      Result : Processor_Signature;\n-      --  processor signature returned\n-\n-   begin\n-\n-      --  execute CPUID, storing the results in the Result variable\n-      Asm (\n-\n-           --  the assembler code\n-           \"cpuid\",    --  execute CPUID\n-\n-           --  one is stored in eax\n-           --  processor signature returned in eax\n-           Inputs => Unsigned_32'Asm_input (\"a\", 1),\n-\n-           --  eax is stored in Result\n-           Outputs => Processor_Signature'Asm_output (\"=a\", Result),\n-\n-           --  tell compiler that ebx, ecx and edx are also destroyed\n-           Clobber => \"ebx, ecx, edx\");\n-\n-      --  return processor signature\n-      return Result;\n-\n-   end Signature;\n-\n-   ------------------------------\n-   --  Get processor features  --\n-   ------------------------------\n-\n-   function Features return Processor_Features is\n-\n-      Result : Processor_Features;\n-      --  processor features returned\n-\n-   begin\n-\n-      --  execute CPUID, storing the results in the Result variable\n-      Asm (\n-\n-           --  the assembler code\n-           \"cpuid\",    --  execute CPUID\n-\n-           --  one stored in eax\n-           --  processor features returned in edx\n-           Inputs => Unsigned_32'Asm_input (\"a\", 1),\n-\n-           --  edx is stored in Result\n-           Outputs => Processor_Features'Asm_output (\"=d\", Result),\n-\n-           --  tell compiler that ebx and ecx are also destroyed\n-           Clobber => \"ebx, ecx\");\n-\n-      --  return processor signature\n-      return Result;\n-\n-   end Features;\n-\n-end Intel_CPU;\n-@end smallexample\n @c END OF INLINE ASSEMBLER CHAPTER\n @c ===============================\n \n@@ -26367,7 +25483,7 @@ new Ada 95 reserved words are treated simply as identifiers as in Ada 83.\n However,\n in practice, it is usually advisable to make the necessary modifications\n to the program to remove the need for using this switch.\n-See @ref{Compiling Ada 83 Programs}.\n+See @ref{Compiling Different Versions of Ada}.\n \n @item Support for removed Ada 83 pragmas and attributes\n A number of pragmas and attributes from Ada 83 have been removed from Ada 95,"}]}