{"sha": "5fd40200428b562afe43bd6d10055d53726d2b65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkNDAyMDA0MjhiNTYyYWZlNDNiZDZkMTAwNTVkNTM3MjZkMmI2NQ==", "commit": {"author": {"name": "Robert Schuster", "email": "thebohemian@gmx.net", "date": "2004-11-12T13:17:42Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2004-11-12T13:17:42Z"}, "message": "Fixed regression:\n\n2004-11-11  Robert Schuster <thebohemian@gmx.net>\n\n       Fixed regression:\n       * gnu/java/beans/IntrospectionIncubator.java:\n       (addMethod): corrected classification of normal and property methods\n       (capitalize): added documentation\n       (DoubleKey): [class] added documentation\n\nFrom-SVN: r90527", "tree": {"sha": "83428cef03a6178d429c600dcaaf51d2f8ba5af6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83428cef03a6178d429c600dcaaf51d2f8ba5af6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd40200428b562afe43bd6d10055d53726d2b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd40200428b562afe43bd6d10055d53726d2b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd40200428b562afe43bd6d10055d53726d2b65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd40200428b562afe43bd6d10055d53726d2b65/comments", "author": {"login": "thebohemian", "id": 336602, "node_id": "MDQ6VXNlcjMzNjYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/336602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thebohemian", "html_url": "https://github.com/thebohemian", "followers_url": "https://api.github.com/users/thebohemian/followers", "following_url": "https://api.github.com/users/thebohemian/following{/other_user}", "gists_url": "https://api.github.com/users/thebohemian/gists{/gist_id}", "starred_url": "https://api.github.com/users/thebohemian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thebohemian/subscriptions", "organizations_url": "https://api.github.com/users/thebohemian/orgs", "repos_url": "https://api.github.com/users/thebohemian/repos", "events_url": "https://api.github.com/users/thebohemian/events{/privacy}", "received_events_url": "https://api.github.com/users/thebohemian/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e03665c19d2df42c511a5109d84de59d061cb25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e03665c19d2df42c511a5109d84de59d061cb25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e03665c19d2df42c511a5109d84de59d061cb25"}], "stats": {"total": 97, "additions": 86, "deletions": 11}, "files": [{"sha": "98d7e4eb897a6bb46297e66a7720af59fbf27bce", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd40200428b562afe43bd6d10055d53726d2b65/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd40200428b562afe43bd6d10055d53726d2b65/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5fd40200428b562afe43bd6d10055d53726d2b65", "patch": "@@ -1,3 +1,11 @@\n+2004-11-11  Robert Schuster <thebohemian@gmx.net>\n+  \n+  \tFixed regression:\n+  \t* gnu/java/beans/IntrospectionIncubator.java:\n+  \t(addMethod): corrected classification of normal and property methods\n+  \t(capitalize): added documentation\n+  \t(DoubleKey): [class] added documentation\n+\n 2004-11-09  Tom Tromey  <tromey@redhat.com>\n \n \t* include/jni.h: Added FIXME."}, {"sha": "21bf984d24c96bed4de1a6c471dd42b2197f5c45", "filename": "libjava/gnu/java/beans/IntrospectionIncubator.java", "status": "modified", "additions": 78, "deletions": 11, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd40200428b562afe43bd6d10055d53726d2b65/libjava%2Fgnu%2Fjava%2Fbeans%2FIntrospectionIncubator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd40200428b562afe43bd6d10055d53726d2b65/libjava%2Fgnu%2Fjava%2Fbeans%2FIntrospectionIncubator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2FIntrospectionIncubator.java?ref=5fd40200428b562afe43bd6d10055d53726d2b65", "patch": "@@ -57,9 +57,10 @@\n \n /**\n  ** IntrospectionIncubator takes in a bunch of Methods, and\n- ** Introspects only those Methods you give it. \n- ** Note that non-public and static methods are silently\n- ** discarded.\n+ ** Introspects only those Methods you give it.<br/>\n+ **\n+ ** See {@link addMethod(Method)} for details which rules apply to\n+ ** the methods.\n  **\n  ** @author John Keiser\n  ** @author Robert Schuster\n@@ -79,39 +80,75 @@ public class IntrospectionIncubator {\n \tpublic IntrospectionIncubator() {\n \t}\n \n-\t/* Paving the way for automatic Introspection */\n+\t/** Examines the given method and files it in a suitable collection.\n+\t * It files the method as a property method if it finds:\n+\t * <lu>\n+\t * <li>boolean \"is\" getter</li>\n+\t * <li>\"get\" style getter</li>\n+\t * <li>single argument setter</li>\n+\t * <li>indiced setter and getter</li> \n+\t * </ul>\n+\t * It files the method as a listener method if all of these rules apply:\n+\t * <lu>\n+\t * <li>the method name starts with \"add\" or \"remove\"</li>\n+\t * <li>there is only a single argument</li>\n+\t * <li>the argument type is a subclass of <code>java.util.EventListener</code></li>\n+\t * </ul>\n+\t * All public methods are filed as such. \n+\t *   \n+\t * @param method The method instance to examine.\n+\t */\n \tpublic void addMethod(Method method) {\n-\t\tif(Modifier.isPublic(method.getModifiers()) &&\n-\t\t\t!Modifier.isStatic(method.getModifiers())) {\n+\t\tif(Modifier.isPublic(method.getModifiers())) {\n \t\t\tString name = ClassHelper.getTruncatedName(method.getName());\n \t\t\tClass retType = method.getReturnType();\n \t\t\tClass[] params = method.getParameterTypes();\n \t\t\tboolean isVoid = retType.equals(java.lang.Void.TYPE);\n \t\t\tClass methodClass = method.getDeclaringClass();\n-\t\t\tif(propertyStopClass == null || (propertyStopClass.isAssignableFrom(methodClass) && !propertyStopClass.equals(methodClass))) {\n-\t\t\t\tif(name.startsWith(\"is\")\n+\t\t\t\n+\t\t\t/* Accepts the method for examination if no stop class is given or the method is declared in a subclass of the stop class.\n+\t\t\t * The rules for this are described in {@link java.beans.Introspector.getBeanInfo(Class, Class)}.\n+\t\t\t * This block finds out whether the method is a suitable getter or setter method (or read/write method).  \n+\t\t\t */\n+\t\t\tif(isReachable(propertyStopClass, methodClass)) {\n+\t\t\t\t/* At this point a method may regarded as a property's read or write method if its name\n+\t\t\t\t * starts with \"is\", \"get\" or \"set\". However, if a method is static it cannot be part\n+\t\t\t\t * of a property.\n+\t\t\t\t */\n+\t\t\t\tif(Modifier.isStatic(method.getModifiers())) {\n+\t\t\t\t\t// files method as other because it is static\n+\t\t\t\t\totherMethods.addElement(method);\n+\t\t\t\t} else if(name.startsWith(\"is\")\n \t\t\t\t   && retType.equals(java.lang.Boolean.TYPE)\n \t\t\t\t   && params.length == 0) {\n+\t\t\t\t   \t// files method as boolean \"is\" style getter\n \t\t\t\t\taddToPropertyHash(name,method,IS);\n \t\t\t\t} else if(name.startsWith(\"get\") && !isVoid) {\n \t\t\t\t\tif(params.length == 0) {\n+\t\t\t\t\t\t// files as legal non-argument getter\n \t\t\t\t\t\taddToPropertyHash(name,method,GET);\n \t\t\t\t\t} else if(params.length == 1 && params[0].equals(java.lang.Integer.TYPE)) {\n+\t\t\t\t\t\t// files as legal indiced getter\n \t\t\t\t\t\taddToPropertyHash(name,method,GET_I);\n \t\t\t\t\t} else {\n+\t\t\t\t\t\t// files as other because the method's signature is not Bean-like\n \t\t\t\t\t\totherMethods.addElement(method);\n \t\t\t\t\t}\n \t\t\t\t} else if(name.startsWith(\"set\") && isVoid) {\n \t\t\t\t\tif(params.length == 1) {\n+\t\t\t\t\t\t// files as legal single-argument setter method\n \t\t\t\t\t\taddToPropertyHash(name,method,SET);\n \t\t\t\t\t} else if(params.length == 2 && params[0].equals(java.lang.Integer.TYPE)) {\n+\t\t\t\t\t\t// files as legal indiced setter method\n \t\t\t\t\t\taddToPropertyHash(name,method,SET_I);\n \t\t\t\t\t} else {\n+\t\t\t\t\t\t// files as other because the method's signature is not Bean-like\n \t\t\t\t\t\totherMethods.addElement(method);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif(eventStopClass == null || (eventStopClass.isAssignableFrom(methodClass) && !eventStopClass.equals(methodClass))) {\n+\t\t\t\n+\t\t\tif(isReachable(eventStopClass, methodClass)) {\n \t\t\t\tif(name.startsWith(\"add\")\n \t\t\t\t          && isVoid\n \t\t\t\t          && params.length == 1\n@@ -124,9 +161,12 @@ public void addMethod(Method method) {\n \t\t\t\t\taddToListenerHash(name,method,REMOVE);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif(methodStopClass == null || (methodStopClass.isAssignableFrom(methodClass) && !methodStopClass.equals(methodClass))) {\n+\t\t\t \n+\t\t\tif(isReachable(methodStopClass, methodClass)) {\n+\t\t\t\t// files as reachable public method\n \t\t\t\totherMethods.addElement(method);\n \t\t\t}\n+\t\t\t\n \t\t}\n \t}\n \n@@ -293,7 +333,6 @@ void addToPropertyHash(String name, Method method, int funcType) {\n \t\tmethods[funcType] = method;\n \t}\n \n-\n \tvoid addToListenerHash(String name, Method method, int funcType) {\n \t\tString newName;\n \t\tClass type;\n@@ -321,6 +360,26 @@ void addToListenerHash(String name, Method method, int funcType) {\n \t\tmethods[funcType] = method;\n \t}\n \n+\t/* Determines whether <code>stopClass</code> is <code>null</code>\n+\t * or <code>declaringClass<code> is a true subclass of <code>stopClass</code>.\n+\t * This expression is useful to detect whether a method should be introspected or not.\n+\t * The rules for this are described in {@link java.beans.Introspector.getBeanInfo(Class, Class)}.\n+\t */\n+\tstatic boolean isReachable(Class stopClass, Class declaringClass) {\n+\t\treturn stopClass == null || (stopClass.isAssignableFrom(declaringClass) && !stopClass.equals(declaringClass));\n+\t}\n+\n+\t/** Transforms a property name into a part of a method name.\n+\t * E.g. \"value\" becomes \"Value\" which can then concatenated with\n+\t * \"set\", \"get\" or \"is\" to form a valid method name.\n+\t * \n+\t * Implementation notes:\n+\t * If \"\" is the argument, it is returned without changes.\n+\t * If <code>null</code> is the argument, <code>null</code> is returned.\n+\t * \n+\t * @param name Name of a property.\n+\t * @return Part of a method name of a property.\n+\t */\n \tstatic String capitalize(String name) {\n \t\ttry {\n \t\t\tif(Character.isUpperCase(name.charAt(0))) {\n@@ -338,6 +397,14 @@ static String capitalize(String name) {\n \t}\n }\n \n+/** This class is a hashmap key that consists of a <code>Class</code> and a\n+ * <code>String</code> element.\n+ * \n+ * It is used for XXX: find out what this is used for\n+ * \n+ * @author John Keiser\n+ * @author Robert Schuster\n+ */ \n class DoubleKey {\n \tClass type;\n \tString name;"}]}