{"sha": "bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmMzM3NzU0MGQyZTVkOGVhNjNmZGI4YWVkMTZjZmYxNmY2YmE4NQ==", "commit": {"author": {"name": "Andrey Belevantsev", "email": "abel@ispras.ru", "date": "2009-11-13T14:27:13Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2009-11-13T14:27:13Z"}, "message": "sched-deps.c (init_deps): New parameter lazy_reg_last.\n\n2009-11-13  Andrey Belevantsev  <abel@ispras.ru>\n\n        * sched-deps.c (init_deps): New parameter lazy_reg_last.  Don't\n        allocate reg_last when in case lazy_reg_last is true.\n        (init_deps_reg_last): New.\n        (free_deps): When max_reg is 0, this context is already freed.\n        * sched-int.h (init_deps_reg_last): Export.\n        (init_deps): Update prototype.\n        * sched-ebb.c (schedule_ebb): Update the call to init_deps.\n        * sched-rgn.c (sched_rgn_compute_dependencies): Likewise.\n        * ddg.c (build_intra_loop_deps): Likewise.\n        * sel-sched-ir.c (copy_deps_context, create_deps_context,\n        reset_deps_context, deps_init_id): Likewise.\n        (init_first_time_insn_data): Lazy allocate INSN_DEPS_CONTEXT.\n        (free_data_for_scheduled_insn): New, break down from ...\n        (free_first_time_insn_data): ... here.\n        (has_dependence_p): Allocate reg_last now, when it is needed.\n        (extend_insn_data): When maximal LUID is big enough, allocate\n        per-insn data in smaller chunks.\n        * sel-sched-ir.h (free_data_for_scheduled_insn): Export.\n        * sel-sched.c (update_seqnos_and_stage): Free INSN_DEPS_CONTEXT\n        in scheduled insn.\n\nFrom-SVN: r154147", "tree": {"sha": "33d70889d193e4a1474e119c509e0e1fcd50b507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33d70889d193e4a1474e119c509e0e1fcd50b507"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/comments", "author": {"login": "abonzo", "id": 20396542, "node_id": "MDQ6VXNlcjIwMzk2NTQy", "avatar_url": "https://avatars.githubusercontent.com/u/20396542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonzo", "html_url": "https://github.com/abonzo", "followers_url": "https://api.github.com/users/abonzo/followers", "following_url": "https://api.github.com/users/abonzo/following{/other_user}", "gists_url": "https://api.github.com/users/abonzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonzo/subscriptions", "organizations_url": "https://api.github.com/users/abonzo/orgs", "repos_url": "https://api.github.com/users/abonzo/repos", "events_url": "https://api.github.com/users/abonzo/events{/privacy}", "received_events_url": "https://api.github.com/users/abonzo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba0dc4bed674b0c5bf0df8a4b2fee35617f64335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba0dc4bed674b0c5bf0df8a4b2fee35617f64335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba0dc4bed674b0c5bf0df8a4b2fee35617f64335"}], "stats": {"total": 139, "additions": 115, "deletions": 24}, "files": [{"sha": "39eb3c6f530a662be01aa5d1e78a924c929f0a51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -1,3 +1,26 @@\n+2009-11-13  Andrey Belevantsev  <abel@ispras.ru>\n+\n+\t* sched-deps.c (init_deps): New parameter lazy_reg_last.  Don't\n+\tallocate reg_last when in case lazy_reg_last is true.\n+\t(init_deps_reg_last): New.\n+\t(free_deps): When max_reg is 0, this context is already freed.\n+\t* sched-int.h (init_deps_reg_last): Export.\n+\t(init_deps): Update prototype.\n+\t* sched-ebb.c (schedule_ebb): Update the call to init_deps.\n+\t* sched-rgn.c (sched_rgn_compute_dependencies): Likewise.\n+\t* ddg.c (build_intra_loop_deps): Likewise.\n+\t* sel-sched-ir.c (copy_deps_context, create_deps_context,\n+\treset_deps_context, deps_init_id): Likewise.\n+\t(init_first_time_insn_data): Lazy allocate INSN_DEPS_CONTEXT.\n+\t(free_data_for_scheduled_insn): New, break down from ...\n+\t(free_first_time_insn_data): ... here.\n+\t(has_dependence_p): Allocate reg_last now, when it is needed.\n+\t(extend_insn_data): When maximal LUID is big enough, allocate\n+\tper-insn data in smaller chunks.\n+\t* sel-sched-ir.h (free_data_for_scheduled_insn): Export.\n+\t* sel-sched.c (update_seqnos_and_stage): Free INSN_DEPS_CONTEXT\n+\tin scheduled insn. \n+\t\n 2009-11-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (call_value): Fix comment."}, {"sha": "0c54f8079fbbd9ae66627838f1e5bbf65924f959", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -388,7 +388,7 @@ build_intra_loop_deps (ddg_ptr g)\n \n   /* Build the dependence information, using the sched_analyze function.  */\n   init_deps_global ();\n-  init_deps (&tmp_deps);\n+  init_deps (&tmp_deps, false);\n \n   /* Do the intra-block data dependence analysis for the given block.  */\n   get_ebb_head_tail (g->bb, g->bb, &head, &tail);"}, {"sha": "fdc98fb3c4bb16dd5dd3a062ad1c13827a452336", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -3461,15 +3461,19 @@ sched_free_deps (rtx head, rtx tail, bool resolved_p)\n }\n \f\n /* Initialize variables for region data dependence analysis.\n-   n_bbs is the number of region blocks.  */\n+   When LAZY_REG_LAST is true, do not allocate reg_last array \n+   of struct deps immediately.  */\n \n void\n-init_deps (struct deps *deps)\n+init_deps (struct deps *deps, bool lazy_reg_last)\n {\n   int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n \n   deps->max_reg = max_reg;\n-  deps->reg_last = XCNEWVEC (struct deps_reg, max_reg);\n+  if (lazy_reg_last)\n+    deps->reg_last = NULL;\n+  else\n+    deps->reg_last = XCNEWVEC (struct deps_reg, max_reg);\n   INIT_REG_SET (&deps->reg_last_in_use);\n   INIT_REG_SET (&deps->reg_conditional_sets);\n \n@@ -3490,6 +3494,18 @@ init_deps (struct deps *deps)\n   deps->readonly = 0;\n }\n \n+/* Init only reg_last field of DEPS, which was not allocated before as \n+   we inited DEPS lazily.  */\n+void\n+init_deps_reg_last (struct deps *deps)\n+{\n+  gcc_assert (deps && deps->max_reg > 0);\n+  gcc_assert (deps->reg_last == NULL);\n+\n+  deps->reg_last = XCNEWVEC (struct deps_reg, deps->max_reg);\n+}\n+\n+\n /* Free insn lists found in DEPS.  */\n \n void\n@@ -3498,6 +3514,14 @@ free_deps (struct deps *deps)\n   unsigned i;\n   reg_set_iterator rsi;\n \n+  /* We set max_reg to 0 when this context was already freed.  */\n+  if (deps->max_reg == 0)\n+    {\n+      gcc_assert (deps->reg_last == NULL);\n+      return;\n+    }\n+  deps->max_reg = 0;\n+  \n   free_INSN_LIST_list (&deps->pending_read_insns);\n   free_EXPR_LIST_list (&deps->pending_read_mems);\n   free_INSN_LIST_list (&deps->pending_write_insns);\n@@ -3522,7 +3546,10 @@ free_deps (struct deps *deps)\n   CLEAR_REG_SET (&deps->reg_last_in_use);\n   CLEAR_REG_SET (&deps->reg_conditional_sets);\n \n-  free (deps->reg_last);\n+  /* As we initialize reg_last lazily, it is possible that we didn't allocate \n+     it at all.  */\n+  if (deps->reg_last)\n+    free (deps->reg_last);\n   deps->reg_last = NULL;\n \n   deps = NULL;"}, {"sha": "f005d1dace06ba5bcaff909d4e2cf213783fdddb", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -478,7 +478,7 @@ schedule_ebb (rtx head, rtx tail)\n       init_deps_global ();\n \n       /* Compute dependencies.  */\n-      init_deps (&tmp_deps);\n+      init_deps (&tmp_deps, false);\n       sched_analyze (&tmp_deps, head, tail);\n       free_deps (&tmp_deps);\n "}, {"sha": "35a517e91ff2c865eaac0b7d19ae25cf0207e2f2", "filename": "gcc/sched-int.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -1199,7 +1199,8 @@ extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);\n extern bool sched_insn_is_legitimate_for_speculation_p (const_rtx, ds_t);\n extern void add_dependence (rtx, rtx, enum reg_note);\n extern void sched_analyze (struct deps *, rtx, rtx);\n-extern void init_deps (struct deps *);\n+extern void init_deps (struct deps *, bool);\n+extern void init_deps_reg_last (struct deps *);\n extern void free_deps (struct deps *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);"}, {"sha": "1c05bfa3b92000361e4116cdceea68c274ad0ca9", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -3152,7 +3152,7 @@ sched_rgn_compute_dependencies (int rgn)\n       /* Initializations for region data dependence analysis.  */\n       bb_deps = XNEWVEC (struct deps, current_nr_blocks);\n       for (bb = 0; bb < current_nr_blocks; bb++)\n-\tinit_deps (bb_deps + bb);\n+\tinit_deps (bb_deps + bb, false);\n \n       /* Initialize bitmap used in add_branch_dependences.  */\n       insn_referenced = sbitmap_alloc (sched_max_luid);"}, {"sha": "10750746660a33fcce3b55fb458b318781761deb", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -433,7 +433,7 @@ reset_target_context (tc_t tc, bool clean_p)\n static void\n copy_deps_context (deps_t to, deps_t from)\n {\n-  init_deps (to);\n+  init_deps (to, false);\n   deps_join (to, from);\n }\n \n@@ -450,7 +450,7 @@ create_deps_context (void)\n {\n   deps_t dc = alloc_deps_context ();\n \n-  init_deps (dc);\n+  init_deps (dc, false);\n   return dc;\n }\n \n@@ -484,7 +484,7 @@ static void\n reset_deps_context (deps_t dc)\n {\n   clear_deps_context (dc);\n-  init_deps (dc);\n+  init_deps (dc, false);\n }\n \n /* This structure describes the dependence analysis hooks for advancing \n@@ -2674,7 +2674,7 @@ deps_init_id (idata_t id, insn_t insn, bool force_unique_p)\n   deps_init_id_data.force_unique_p = force_unique_p;\n   deps_init_id_data.force_use_p = false;\n \n-  init_deps (dc);\n+  init_deps (dc, false);\n \n   memcpy (&deps_init_id_sched_deps_info,\n \t  &const_deps_init_id_sched_deps_info,\n@@ -2746,35 +2746,54 @@ init_first_time_insn_data (insn_t insn)\n   /* These are needed for nops too.  */\n   INSN_LIVE (insn) = get_regset_from_pool ();\n   INSN_LIVE_VALID_P (insn) = false;\n-  \n+\n   if (!INSN_NOP_P (insn))\n     {\n       INSN_ANALYZED_DEPS (insn) = BITMAP_ALLOC (NULL);\n       INSN_FOUND_DEPS (insn) = BITMAP_ALLOC (NULL);\n       INSN_TRANSFORMED_INSNS (insn) \n         = htab_create (16, hash_transformed_insns,\n                        eq_transformed_insns, free_transformed_insns);\n-      init_deps (&INSN_DEPS_CONTEXT (insn));\n+      init_deps (&INSN_DEPS_CONTEXT (insn), true);\n     }\n }\n \n-/* Free the same data as above for INSN.  */\n-static void\n-free_first_time_insn_data (insn_t insn)\n+/* Free almost all above data for INSN that is scheduled already.  \n+   Used for extra-large basic blocks.  */\n+void\n+free_data_for_scheduled_insn (insn_t insn)\n {\n   gcc_assert (! first_time_insn_init (insn));\n-\n+  \n+  if (! INSN_ANALYZED_DEPS (insn))\n+    return;\n+  \n   BITMAP_FREE (INSN_ANALYZED_DEPS (insn));\n   BITMAP_FREE (INSN_FOUND_DEPS (insn));\n   htab_delete (INSN_TRANSFORMED_INSNS (insn));\n-  return_regset_to_pool (INSN_LIVE (insn));\n-  INSN_LIVE (insn) = NULL;\n-  INSN_LIVE_VALID_P (insn) = false;\n-\n+  \n   /* This is allocated only for bookkeeping insns.  */\n   if (INSN_ORIGINATORS (insn))\n     BITMAP_FREE (INSN_ORIGINATORS (insn));\n   free_deps (&INSN_DEPS_CONTEXT (insn));\n+\n+  INSN_ANALYZED_DEPS (insn) = NULL;\n+\n+  /* Clear the readonly flag so we would ICE when trying to recalculate \n+     the deps context (as we believe that it should not happen).  */\n+  (&INSN_DEPS_CONTEXT (insn))->readonly = 0;\n+}\n+\n+/* Free the same data as above for INSN.  */\n+static void\n+free_first_time_insn_data (insn_t insn)\n+{\n+  gcc_assert (! first_time_insn_init (insn));\n+\n+  free_data_for_scheduled_insn (insn);\n+  return_regset_to_pool (INSN_LIVE (insn));\n+  INSN_LIVE (insn) = NULL;\n+  INSN_LIVE_VALID_P (insn) = false;\n }\n \n /* Initialize region-scope data structures for basic blocks.  */\n@@ -3211,6 +3230,11 @@ has_dependence_p (expr_t expr, insn_t pred, ds_t **has_dep_pp)\n     return false;\n \n   dc = &INSN_DEPS_CONTEXT (pred);\n+\n+  /* We init this field lazily.  */\n+  if (dc->reg_last == NULL)\n+    init_deps_reg_last (dc);\n+  \n   if (!dc->readonly)\n     {\n       has_dependence_data.pro = NULL;\n@@ -3847,8 +3871,17 @@ extend_insn_data (void)\n              - VEC_length (sel_insn_data_def, s_i_d));\n   if (reserve > 0 \n       && ! VEC_space (sel_insn_data_def, s_i_d, reserve))\n-    VEC_safe_grow_cleared (sel_insn_data_def, heap, s_i_d,\n-                           3 * sched_max_luid / 2);\n+    {\n+      int size;\n+\n+      if (sched_max_luid / 2 > 1024)\n+        size = sched_max_luid + 1024;\n+      else\n+        size = 3 * sched_max_luid / 2;\n+        \n+\n+      VEC_safe_grow_cleared (sel_insn_data_def, heap, s_i_d, size);\n+    }\n }\n \n /* Finalize data structures for insns from current region.  */"}, {"sha": "9563d2a0a4fcd950b848a277768ba5b229d73e7b", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -1646,6 +1646,7 @@ extern void init_lv_sets (void);\n extern void free_lv_sets (void);\n extern void setup_nop_and_exit_insns (void);\n extern void free_nop_and_exit_insns (void);\n+extern void free_data_for_scheduled_insn (insn_t);\n extern void setup_nop_vinsn (void);\n extern void free_nop_vinsn (void);\n extern void sel_set_sched_flags (void);"}, {"sha": "05061c7ed71df247741faca229bebceef81dfe53", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=bcf3377540d2e5d8ea63fdb8aed16cff16f6ba85", "patch": "@@ -7364,6 +7364,12 @@ update_seqnos_and_stage (int min_seqno, int max_seqno,\n       gcc_assert (INSN_SEQNO (insn) < 0);\n       INSN_SEQNO (insn) += highest_seqno_in_use + max_seqno - min_seqno + 2;\n       gcc_assert (INSN_SEQNO (insn) <= new_hs);\n+\n+      /* When not pipelining, purge unneeded insn info on the scheduled insns.\n+         For example, having reg_last array of INSN_DEPS_CONTEXT in memory may\n+         require > 1GB of memory e.g. on limit-fnargs.c.  */\n+      if (! pipelining_p)\n+        free_data_for_scheduled_insn (insn);\n     }\n \n   ilist_clear (pscheduled_insns);"}]}