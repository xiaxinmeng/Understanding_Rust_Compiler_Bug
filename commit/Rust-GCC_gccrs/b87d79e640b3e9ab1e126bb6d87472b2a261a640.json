{"sha": "b87d79e640b3e9ab1e126bb6d87472b2a261a640", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg3ZDc5ZTY0MGIzZTlhYjFlMTI2YmI2ZDg3NDcyYjJhMjYxYTY0MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-07-24T19:15:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-07-24T19:15:00Z"}, "message": "Implement defaulted/deleted functions as per N2346\n\n        Implement defaulted/deleted functions as per N2346\n        * cp-tree.h (struct lang_decl_flags): Add defaulted_p bitfield.\n        (DECL_DELETED_FN): New macro.\n        (DECL_DEFAULTED_FN): New macro.\n        * class.c (user_provided_p): New fn.\n        (defaultable_fn_p): New fn.\n        (type_has_user_provided_constructor): New fn.\n        (type_has_user_provided_default_constructor): New fn.\n        (check_methods): A defaulted fn is still trivial.\n        (check_bases_and_members): Likewise.\n        * decl.c (grok_special_member_properties): Likewise.\n        (duplicate_decls): Complain about redeclaring a function as deleted.\n        (start_decl): initialized==2 means deleted.\n        (cp_finish_decl): Handle deleted/defaulted semantics.\n        * decl2.c (grokfield): Likewise.\n        (mark_used): Check DECL_DEFAULTED_FN instead of DECL_ARTIFICIAL.\n        Complain about using a deleted fn.\n        * init.c (build_value_init_1): Use type_has_user_provided_constructor.\n        (perform_member_init): Check for a user-provided default constructor\n        even if TYPE_NEEDS_CONSTRUCTING.\n        (build_new_1): Likewise.\n        * call.c (build_over_call): Don't call mark_used twice.\n        * method.c (implicitly_declare_fn): Set DECL_DEFAULTED_FN.\n        * search.c (check_final_overrider): Check for deleted mismatch.\n        * parser.c (cp_parser_init_declarator): Tell start_decl about =delete.\n        (cp_parser_pure_specifier): Handle =default and =delete.\n\n        * error.c (maybe_warn_cpp0x): Suggest -std=gnu++0x as well.\n\nFrom-SVN: r138123", "tree": {"sha": "38c6149cb50c1486bcdf000c5463ee69d1c647a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38c6149cb50c1486bcdf000c5463ee69d1c647a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b87d79e640b3e9ab1e126bb6d87472b2a261a640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87d79e640b3e9ab1e126bb6d87472b2a261a640", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87d79e640b3e9ab1e126bb6d87472b2a261a640", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87d79e640b3e9ab1e126bb6d87472b2a261a640/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3005b0f0c8081ccb719740c3c27ee13d5697add", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3005b0f0c8081ccb719740c3c27ee13d5697add", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3005b0f0c8081ccb719740c3c27ee13d5697add"}], "stats": {"total": 453, "additions": 406, "deletions": 47}, "files": [{"sha": "c9eaf0f055aed28bc252ef408191a43b4bf599cb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1,3 +1,34 @@\n+2008-07-23  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement defaulted/deleted functions as per N2346\n+\t* cp-tree.h (struct lang_decl_flags): Add defaulted_p bitfield.\n+\t(DECL_DELETED_FN): New macro.\n+\t(DECL_DEFAULTED_FN): New macro.\n+\t* class.c (user_provided_p): New fn.\n+\t(defaultable_fn_p): New fn.\n+\t(type_has_user_provided_constructor): New fn.\n+\t(type_has_user_provided_default_constructor): New fn.\n+\t(check_methods): A defaulted fn is still trivial.\n+\t(check_bases_and_members): Likewise.\n+\t* decl.c (grok_special_member_properties): Likewise.\n+\t(duplicate_decls): Complain about redeclaring a function as deleted.\n+\t(start_decl): initialized==2 means deleted.\n+\t(cp_finish_decl): Handle deleted/defaulted semantics.\n+\t* decl2.c (grokfield): Likewise.\n+\t(mark_used): Check DECL_DEFAULTED_FN instead of DECL_ARTIFICIAL.\n+\tComplain about using a deleted fn.\n+\t* init.c (build_value_init_1): Use type_has_user_provided_constructor.\n+\t(perform_member_init): Check for a user-provided default constructor\n+\teven if TYPE_NEEDS_CONSTRUCTING.\n+\t(build_new_1): Likewise.\n+\t* call.c (build_over_call): Don't call mark_used twice.\n+\t* method.c (implicitly_declare_fn): Set DECL_DEFAULTED_FN.\n+\t* search.c (check_final_overrider): Check for deleted mismatch.\n+\t* parser.c (cp_parser_init_declarator): Tell start_decl about =delete.\n+\t(cp_parser_pure_specifier): Handle =default and =delete.\n+\n+\t* error.c (maybe_warn_cpp0x): Suggest -std=gnu++0x as well.\n+\n 2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR 35058"}, {"sha": "2304b5da71be3cfa11a38bee2050632f1599c260", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -5090,6 +5090,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   int is_method = 0;\n   int nargs;\n   tree *argarray;\n+  bool already_used = false;\n \n   /* In a template, there is no need to perform all of the work that\n      is normally done.  We are only interested in the type of the call\n@@ -5310,7 +5311,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       /* [class.copy]: the copy constructor is implicitly defined even if\n \t the implementation elided its use.  */\n       if (TYPE_HAS_COMPLEX_INIT_REF (DECL_CONTEXT (fn)))\n-\tmark_used (fn);\n+\t{\n+\t  mark_used (fn);\n+\t  already_used = true;\n+\t}\n \n       /* If we're creating a temp and we already have one, don't create a\n \t new one.  If we're not creating a temp but we get one, use\n@@ -5370,7 +5374,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       return val;\n     }\n \n-  mark_used (fn);\n+  if (!already_used)\n+    mark_used (fn);\n \n   if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n     {"}, {"sha": "0649eec2486a7054031a2766616232866d19e3a1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 98, "deletions": 13, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -3045,7 +3045,7 @@ check_field_decls (tree t, tree *access_decls,\n \n       /* Core issue 80: A nonstatic data member is required to have a\n \t different name from the class iff the class has a\n-\t user-defined constructor.  */\n+\t user-declared constructor.  */\n       if (constructor_name_p (DECL_NAME (x), t)\n \t  && TYPE_HAS_USER_CONSTRUCTOR (t))\n \tpermerror (\"field %q+#D with same name as class\", x);\n@@ -3767,8 +3767,8 @@ check_methods (tree t)\n \t  if (DECL_PURE_VIRTUAL_P (x))\n \t    VEC_safe_push (tree, gc, CLASSTYPE_PURE_VIRTUALS (t), x);\n \t}\n-      /* All user-declared destructors are non-trivial.  */\n-      if (DECL_DESTRUCTOR_P (x))\n+      /* All user-provided destructors are non-trivial.  */\n+      if (DECL_DESTRUCTOR_P (x) && !DECL_DEFAULTED_FN (x))\n \tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 1;\n     }\n }\n@@ -4067,6 +4067,86 @@ type_has_user_nondefault_constructor (tree t)\n   return false;\n }\n \n+/* Returns true iff FN is a user-provided function, i.e. user-declared\n+   and not defaulted at its first declaration.  */\n+\n+static bool\n+user_provided_p (tree fn)\n+{\n+  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+    return true;\n+  else\n+    return (!DECL_ARTIFICIAL (fn)\n+\t    && !(DECL_DEFAULTED_FN (fn)\n+\t\t && DECL_INITIALIZED_IN_CLASS_P (fn)));\n+}\n+\n+/* Returns true iff class T has a user-provided constructor.  */\n+\n+bool\n+type_has_user_provided_constructor (tree t)\n+{\n+  tree fns;\n+\n+  if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n+    return false;\n+\n+  /* This can happen in error cases; avoid crashing.  */\n+  if (!CLASSTYPE_METHOD_VEC (t))\n+    return false;\n+\n+  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+    if (user_provided_p (OVL_CURRENT (fns)))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Returns true iff class T has a user-provided default constructor.  */\n+\n+bool\n+type_has_user_provided_default_constructor (tree t)\n+{\n+  tree fns;\n+\n+  if (!TYPE_HAS_USER_CONSTRUCTOR (t))\n+    return false;\n+\n+  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+    {\n+      tree fn = OVL_CURRENT (fns);\n+      if (user_provided_p (fn)\n+\t  && (skip_artificial_parms_for (fn, DECL_ARGUMENTS (fn))\n+\t      == NULL_TREE))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Returns true if FN can be explicitly defaulted.  */\n+\n+bool\n+defaultable_fn_p (tree fn)\n+{\n+  if (DECL_CONSTRUCTOR_P (fn))\n+    {\n+      if (skip_artificial_parms_for (fn, DECL_ARGUMENTS (fn))\n+\t  == NULL_TREE)\n+\treturn true;\n+      else if (copy_fn_p (fn) > 0)\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+  else if (DECL_DESTRUCTOR_P (fn))\n+    return true;\n+  else if (DECL_ASSIGNMENT_OPERATOR_P (fn))\n+    return copy_fn_p (fn);\n+  else\n+    return false;\n+}\n+\n /* Remove all zero-width bit-fields from T.  */\n \n static void\n@@ -4158,6 +4238,8 @@ check_bases_and_members (tree t)\n      should take a non-const reference argument.  */\n   int no_const_asn_ref;\n   tree access_decls;\n+  bool saved_complex_asn_ref;\n+  bool saved_nontrivial_dtor;\n \n   /* By default, we use const reference arguments and generate default\n      constructors.  */\n@@ -4171,6 +4253,12 @@ check_bases_and_members (tree t)\n   /* Check all the method declarations.  */\n   check_methods (t);\n \n+  /* Save the initial values of these flags which only indicate whether\n+     or not the class has user-provided functions.  As we analyze the\n+     bases and members we can set these flags for other reasons.  */\n+  saved_complex_asn_ref = TYPE_HAS_COMPLEX_ASSIGN_REF (t);\n+  saved_nontrivial_dtor = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);\n+\n   /* Check all the data member declarations.  We cannot call\n      check_field_decls until we have called check_bases check_methods,\n      as check_field_decls depends on TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n@@ -4186,30 +4274,27 @@ check_bases_and_members (tree t)\n \n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n-  TYPE_HAS_COMPLEX_INIT_REF (t)\n-    |= (TYPE_HAS_INIT_REF (t) || TYPE_CONTAINS_VPTR_P (t));\n+  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_CONTAINS_VPTR_P (t);\n   /* We need to call a constructor for this class if it has a\n-     user-declared constructor, or if the default constructor is going\n+     user-provided constructor, or if the default constructor is going\n      to initialize the vptr.  (This is not an if-and-only-if;\n      TYPE_NEEDS_CONSTRUCTING is set elsewhere if bases or members\n      themselves need constructing.)  */\n   TYPE_NEEDS_CONSTRUCTING (t)\n-    |= (TYPE_HAS_USER_CONSTRUCTOR (t) || TYPE_CONTAINS_VPTR_P (t));\n+    |= (type_has_user_provided_constructor (t) || TYPE_CONTAINS_VPTR_P (t));\n   /* [dcl.init.aggr]\n \n-     An aggregate is an array or a class with no user-declared\n+     An aggregate is an array or a class with no user-provided\n      constructors ... and no virtual functions.  \n \n      Again, other conditions for being an aggregate are checked\n      elsewhere.  */\n   CLASSTYPE_NON_AGGREGATE (t)\n-    |= (TYPE_HAS_USER_CONSTRUCTOR (t) || TYPE_POLYMORPHIC_P (t));\n+    |= (type_has_user_provided_constructor (t) || TYPE_POLYMORPHIC_P (t));\n   CLASSTYPE_NON_POD_P (t)\n     |= (CLASSTYPE_NON_AGGREGATE (t)\n-\t|| TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n-\t|| TYPE_HAS_ASSIGN_REF (t));\n-  TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n-    |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n+\t|| saved_nontrivial_dtor || saved_complex_asn_ref);\n+  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_DFLT (t)\n     |= (TYPE_HAS_DEFAULT_CONSTRUCTOR (t) || TYPE_CONTAINS_VPTR_P (t));\n "}, {"sha": "1488d4ce6f96340bddc89e69ce23d658cc54034d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1609,7 +1609,7 @@ struct lang_decl_flags GTY(())\n   unsigned repo_available_p : 1;\n   unsigned hidden_friend_p : 1;\n   unsigned threadprivate_p : 1;\n-  /* One unused bit.  */\n+  unsigned defaulted_p : 1;\n \n   union lang_decl_u {\n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n@@ -2626,6 +2626,14 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define CP_DECL_THREADPRIVATE_P(DECL) \\\n   (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (DECL))->decl_flags.threadprivate_p)\n \n+/* Nonzero if DECL was declared with '= delete'.  */\n+#define DECL_DELETED_FN(DECL) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.threadprivate_p)\n+\n+/* Nonzero if DECL was declared with '= default'.  */\n+#define DECL_DEFAULTED_FN(DECL) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.defaulted_p)\n+\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n@@ -4171,6 +4179,9 @@ extern void check_for_override\t\t\t(tree, tree);\n extern void push_class_stack\t\t\t(void);\n extern void pop_class_stack\t\t\t(void);\n extern bool type_has_user_nondefault_constructor (tree);\n+extern bool type_has_user_provided_constructor  (tree);\n+extern bool type_has_user_provided_default_constructor (tree);\n+extern bool defaultable_fn_p\t\t\t(tree);\n \n /* in cvt.c */\n extern tree convert_to_reference\t\t(tree, tree, int, int, tree);"}, {"sha": "d02cab2c867f31311c5891a5c0e236b9a9ef5b37", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1613,6 +1613,12 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  warning (OPT_Wredundant_decls, \"redundant redeclaration of %qD in same scope\", newdecl);\n \t  warning (OPT_Wredundant_decls, \"previous declaration of %q+D\", olddecl);\n \t}\n+\n+      if (DECL_DELETED_FN (newdecl))\n+\t{\n+\t  error (\"deleted definition of %qD\", newdecl);\n+\t  error (\"after previous declaration %q+D\", olddecl);\n+\t}\n     }\n \n   /* Deal with C++: must preserve virtual function table size.  */\n@@ -3931,13 +3937,14 @@ groktypename (cp_decl_specifier_seq *type_specifiers,\n    grokfield.)  The DECL corresponding to the DECLARATOR is returned.\n    If an error occurs, the error_mark_node is returned instead.\n    \n-   DECLSPECS are the decl-specifiers for the declaration.  INITIALIZED\n-   is true if an explicit initializer is present, but false if this is\n-   a variable implicitly initialized via a default constructor.\n-   ATTRIBUTES and PREFIX_ATTRIBUTES are GNU attributes associated with\n-   this declaration.  *PUSHED_SCOPE_P is set to the scope entered in\n-   this function, if any; if set, the caller is responsible for\n-   calling pop_scope.  */\n+   DECLSPECS are the decl-specifiers for the declaration.  INITIALIZED is 1\n+   if an explicit initializer is present, or 2 for an explicitly defaulted\n+   function, or 3 for an explicitly deleted function, but 0 if this is a\n+   variable implicitly initialized via a default constructor.  ATTRIBUTES\n+   and PREFIX_ATTRIBUTES are GNU attributes associated with this\n+   declaration.  *PUSHED_SCOPE_P is set to the scope entered in this\n+   function, if any; if set, the caller is responsible for calling\n+   pop_scope.  */\n \n tree\n start_decl (const cp_declarator *declarator,\n@@ -3991,12 +3998,15 @@ start_decl (const cp_declarator *declarator,\n     switch (TREE_CODE (decl))\n       {\n       case TYPE_DECL:\n-\terror (\"typedef %qD is initialized (use __typeof__ instead)\", decl);\n+\terror (\"typedef %qD is initialized (use decltype instead)\", decl);\n \treturn error_mark_node;\n \n       case FUNCTION_DECL:\n-\terror (\"function %q#D is initialized like a variable\", decl);\n-\treturn error_mark_node;\n+\tif (initialized == 3)\n+\t  /* We'll handle the rest of the semantics later, but we need to\n+\t     set this now so it's visible to duplicate_decls.  */\n+\t  DECL_DELETED_FN (decl) = 1;\n+\tbreak;\n \n       default:\n \tbreak;\n@@ -5686,10 +5696,38 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       else\n \tabstract_virtuals_error (decl, type);\n \n-      if (TREE_CODE (decl) == FUNCTION_DECL\n-\t  || TREE_TYPE (decl) == error_mark_node)\n+      if (TREE_TYPE (decl) == error_mark_node)\n \t/* No initialization required.  */\n \t;\n+      else if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  if (init)\n+\t    {\n+\t      if (init == ridpointers[(int)RID_DELETE])\n+\t\t{\n+\t\t  /* fixme check this is 1st decl */\n+\t\t  DECL_DELETED_FN (decl) = 1;\n+\t\t  DECL_DECLARED_INLINE_P (decl) = 1;\n+\t\t  DECL_INITIAL (decl) = error_mark_node;\n+\t\t}\n+\t      else if (init == ridpointers[(int)RID_DEFAULT])\n+\t\t{\n+\t\t  if (!defaultable_fn_p (decl))\n+\t\t    error (\"%qD cannot be defaulted\", decl);\n+\t\t  else\n+\t\t    {\n+\t\t      /* An out-of-class default definition is defined at\n+\t\t\t the point where it is explicitly defaulted.  */\n+\t\t      DECL_DEFAULTED_FN (decl) = 1;\n+\t\t      if (DECL_INITIAL (decl) == error_mark_node)\n+\t\t\tsynthesize_method (decl);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\terror (\"function %q#D is initialized like a variable\", decl);\n+\t    }\n+\t  /* else no initialization required.  */\n+\t}\n       else if (DECL_EXTERNAL (decl)\n \t       && ! (DECL_LANG_SPECIFIC (decl)\n \t\t     && DECL_NOT_REALLY_EXTERN (decl)))\n@@ -7361,7 +7399,7 @@ check_var_type (tree identifier, tree type)\n       Don't make a DECL node; just return the ..._TYPE node.\n      FIELD for a struct or union field; make a FIELD_DECL.\n      BITFIELD for a field with specified width.\n-   INITIALIZED is 1 if the decl has an initializer.\n+   INITIALIZED is as for start_decl.\n \n    ATTRLIST is a pointer to the list of attributes, which may be NULL\n    if there are none; *ATTRLIST may be modified if attributes from inside\n@@ -7459,6 +7497,9 @@ grokdeclarator (const cp_declarator *declarator,\n   else if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n \n+  if (initialized > 1)\n+    funcdef_flag = true;\n+\n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n   for (id_declarator = declarator;\n@@ -9670,6 +9711,8 @@ grok_special_member_properties (tree decl)\n \t     are no other parameters or else all other parameters have\n \t     default arguments.  */\n \t  TYPE_HAS_INIT_REF (class_type) = 1;\n+\t  if (!DECL_DEFAULTED_FN (decl))\n+\t    TYPE_HAS_COMPLEX_INIT_REF (class_type) = 1;\n \t  if (ctor > 1)\n \t    TYPE_HAS_CONST_INIT_REF (class_type) = 1;\n \t}\n@@ -9691,6 +9734,8 @@ grok_special_member_properties (tree decl)\n       if (assop)\n \t{\n \t  TYPE_HAS_ASSIGN_REF (class_type) = 1;\n+\t  if (!DECL_DEFAULTED_FN (decl))\n+\t    TYPE_HAS_COMPLEX_ASSIGN_REF (class_type) = 1;\n \t  if (assop != 1)\n \t    TYPE_HAS_CONST_ASSIGN_REF (class_type) = 1;\n \t}"}, {"sha": "6e6151d23f753045c783a86886fd0cebfe7b4c57", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -821,7 +821,25 @@ grokfield (const cp_declarator *declarator,\n \t{\n \t  /* Initializers for functions are rejected early in the parser.\n \t     If we get here, it must be a pure specifier for a method.  */\n-\t  if (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE)\n+\t  if (init == ridpointers[(int)RID_DELETE])\n+\t    {\n+\t      DECL_DELETED_FN (value) = 1;\n+\t      DECL_DECLARED_INLINE_P (value) = 1;\n+\t      DECL_INITIAL (value) = error_mark_node;\n+\t    }\n+\t  else if (init == ridpointers[(int)RID_DEFAULT])\n+\t    {\n+\t      if (!defaultable_fn_p (value))\n+\t\terror (\"%qD cannot be defaulted\", value);\n+\t      else\n+\t\t{\n+\t\t  DECL_DEFAULTED_FN (value) = 1;\n+\t\t  DECL_INITIALIZED_IN_CLASS_P (value) = 1;\n+\t\t  DECL_DECLARED_INLINE_P (value) = 1;\n+\t\t  DECL_INLINE (value) = 1;\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE)\n \t    {\n \t      gcc_assert (error_operand_p (init) || integer_zerop (init));\n \t      DECL_PURE_VIRTUAL_P (value) = 1;\n@@ -3739,7 +3757,7 @@ mark_used (tree decl)\n   /* Is it a synthesized method that needs to be synthesized?  */\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n-      && DECL_ARTIFICIAL (decl)\n+      && DECL_DEFAULTED_FN (decl)\n       && !DECL_THUNK_P (decl)\n       && ! DECL_INITIAL (decl)\n       /* Kludge: don't synthesize for default args.  Unfortunately this\n@@ -3752,6 +3770,12 @@ mark_used (tree decl)\n       /* If we've already synthesized the method we don't need to\n \t do the instantiation test below.  */\n     }\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && DECL_DELETED_FN (decl))\n+    {\n+      error (\"deleted function %q+D\", decl);\n+      error (\"used here\");\n+    }\n   else if ((DECL_NON_THUNK_FUNCTION_P (decl) || TREE_CODE (decl) == VAR_DECL)\n \t   && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n \t   && (!DECL_EXPLICIT_INSTANTIATION (decl)"}, {"sha": "ef26ad9114a026d94537218560a76bebe8556f58", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -2685,7 +2685,7 @@ maybe_warn_cpp0x (const char* str)\n     /* We really want to suppress this warning in system headers,\n        because libstdc++ uses variadic templates even when we aren't\n        in C++0x mode. */\n-    pedwarn (0, \"%s only available with -std=c++0x\", str);\n+    pedwarn (0, \"%s only available with -std=c++0x or -std=gnu++0x\", str);\n }\n \n /* Warn about the use of variadic templates when appropriate.  */"}, {"sha": "3dd6c4e328b62250c92813664eae8471506994e5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -346,7 +346,7 @@ build_value_init_1 (tree type, bool have_ctor)\n \n   if (CLASS_TYPE_P (type))\n     {\n-      if (TYPE_HAS_USER_CONSTRUCTOR (type) && !have_ctor)\n+      if (type_has_user_provided_constructor (type) && !have_ctor)\n \treturn build_cplus_new\n \t  (type,\n \t   build_special_member_call (NULL_TREE, complete_ctor_identifier,\n@@ -516,8 +516,17 @@ perform_member_init (tree member, tree init)\n                                             tf_warning_or_error));\n \t}\n       else\n-\tfinish_expr_stmt (build_aggr_init (decl, init, 0, \n-                                           tf_warning_or_error));\n+\t{\n+\t  if (CP_TYPE_CONST_P (type)\n+\t      && init == NULL_TREE\n+\t      && !type_has_user_provided_default_constructor (type))\n+\t    /* TYPE_NEEDS_CONSTRUCTING can be set just because we have a\n+\t       vtable; still give this diagnostic.  */\n+\t    permerror (\"%Juninitialized member %qD with %<const%> type %qT\",\n+\t\t       current_function_decl, member, type);\n+\t  finish_expr_stmt (build_aggr_init (decl, init, 0, \n+\t\t\t\t\t     tf_warning_or_error));\n+\t}\n     }\n   else\n     {\n@@ -1883,7 +1892,9 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n     return error_mark_node;\n \n   is_initialized = (TYPE_NEEDS_CONSTRUCTING (elt_type) || init);\n-  if (CP_TYPE_CONST_P (elt_type) && !is_initialized)\n+\n+  if (CP_TYPE_CONST_P (elt_type) && !init\n+      && !type_has_user_provided_default_constructor (elt_type))\n     {\n       if (complain & tf_error)\n         error (\"uninitialized const in %<new%> of %q#T\", elt_type);"}, {"sha": "0703d0a96f7ca4bf71565061adc2d5d3d4893349", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1056,7 +1056,10 @@ write_unqualified_name (const tree decl)\n   else if (DECL_LANG_SPECIFIC (decl) != NULL && DECL_DESTRUCTOR_P (decl))\n     write_special_name_destructor (decl);\n   else if (DECL_NAME (decl) == NULL_TREE)\n-    write_source_name (DECL_ASSEMBLER_NAME (decl));\n+    {\n+      gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n+      write_source_name (DECL_ASSEMBLER_NAME (decl));\n+    }\n   else if (DECL_CONV_FN_P (decl))\n     {\n       /* Conversion operator. Handle it right here."}, {"sha": "f3d23eba23dc22fab35a1e2aecfae03c92ea0b0e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1108,6 +1108,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n   DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n+  DECL_DEFAULTED_FN (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_INLINE (fn) = 1;"}, {"sha": "15b66b03b9586a6b45f0fb1863ab5be8ad99e93e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -12378,7 +12378,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   tree initializer;\n   tree decl = NULL_TREE;\n   tree scope;\n-  bool is_initialized;\n+  int is_initialized;\n   /* Only valid if IS_INITIALIZED is true.  In that case, CPP_EQ if\n      initialized with \"= ..\", CPP_OPEN_PAREN if initialized with\n      \"(...)\".  */\n@@ -12514,8 +12514,18 @@ cp_parser_init_declarator (cp_parser* parser,\n       || token->type == CPP_OPEN_PAREN\n       || token->type == CPP_OPEN_BRACE)\n     {\n-      is_initialized = true;\n+      is_initialized = 1;\n       initialization_kind = token->type;\n+\n+      if (token->type == CPP_EQ\n+\t  && function_declarator_p (declarator))\n+\t{\n+\t  cp_token *t2 = cp_lexer_peek_nth_token (parser->lexer, 2);\n+\t  if (t2->keyword == RID_DEFAULT)\n+\t    is_initialized = 2;\n+\t  else if (t2->keyword == RID_DELETE)\n+\t    is_initialized = 3;\n+\t}\n     }\n   else\n     {\n@@ -12527,7 +12537,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t  cp_parser_error (parser, \"expected initializer\");\n \t  return error_mark_node;\n \t}\n-      is_initialized = false;\n+      is_initialized = 0;\n       initialization_kind = CPP_EOF;\n     }\n \n@@ -15681,6 +15691,15 @@ cp_parser_pure_specifier (cp_parser* parser)\n     return error_mark_node;\n   /* Look for the `0' token.  */\n   token = cp_lexer_consume_token (parser->lexer);\n+\n+  /* Accept = default or = delete in c++0x mode.  */\n+  if (token->keyword == RID_DEFAULT\n+      || token->keyword == RID_DELETE)\n+    {\n+      maybe_warn_cpp0x (\"defaulted and deleted functions\");\n+      return token->u.value;\n+    }\n+\n   /* c_lex_with_flags marks a single digit '0' with PURE_ZERO.  */\n   if (token->type != CPP_NUMBER || !(token->flags & PURE_ZERO))\n     {"}, {"sha": "7fc040bc8c47f2368f64d3a3f678c1213713b89c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1912,6 +1912,20 @@ check_final_overrider (tree overrider, tree basefn)\n       return 0;\n     }\n \n+  if (DECL_DELETED_FN (basefn) != DECL_DELETED_FN (overrider))\n+    {\n+      if (DECL_DELETED_FN (overrider))\n+\t{\n+\t  error (\"deleted function %q+D\", overrider);\n+\t  error (\"overriding non-deleted function %q+D\", basefn);\n+\t}\n+      else\n+\t{\n+\t  error (\"non-deleted function %q+D\", overrider);\n+\t  error (\"overriding deleted function %q+D\", basefn);\n+\t}\n+      return 0;\n+    }\n   return 1;\n }\n "}, {"sha": "e8fe37eb39a45db793b07ccf054c962462bd173b", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted1.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted1.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -0,0 +1,43 @@\n+// Positive test for defaulted/deleted fns\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A\n+{\n+  int i;\n+  A() = default;\n+  A(const A&) = delete;\n+  A& operator=(const A&) = default;\n+  ~A();\n+};\n+\n+A::~A() = default;\n+\n+void f() = delete;\n+\n+struct B\n+{\n+  int i;\n+  B() = default;\n+};\n+\n+int main()\n+{\n+  A a1, a2;\n+  B b = {1};\n+  a1 = a2;\n+}\n+\n+// fns defaulted in class defn are trivial\n+struct C\n+{\n+  C() = default;\n+  C(const C&) = default;\n+  C& operator=(const C&) = default;\n+  ~C() = default;\n+};\n+\n+union U\n+{\n+  C c;\n+};"}, {"sha": "ea06d92530f02eab6acebadd138250c905e5d02a", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted2.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted2.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -0,0 +1,66 @@\n+// Negative test for defaulted/deleted fns.\n+// { dg-options \"-std=c++0x\" }\n+\n+void f();\t\t\t// { dg-error \"previous\" }\n+void f() = delete;\t\t// { dg-error \"deleted\" }\n+\n+struct A\n+{\n+  A() { }\t\t\t// { dg-error \"previous\" }\n+  void f() = default;\t\t// { dg-error \"default\" }\n+};\n+\n+A::A() = default;\t\t// { dg-error \"redefinition\" }\n+\n+void g() {}\t\t\t// { dg-error \"previous\" }\n+void g() = delete;\t\t// { dg-error \"redefinition\" }\n+\n+struct B\n+{\n+  B() = default;\n+};\n+\n+const B b;\t\t\t// { dg-error \"uninitialized const\" }\n+\n+struct C\n+{\n+  virtual void f() = delete;\t// { dg-error \"overriding deleted\" }\n+};\n+\n+struct D: public C\n+{\n+  virtual void f();\t\t// { dg-error \"non-deleted function\" }\n+};\n+\n+struct E\n+{\n+  const B b;\n+  E() { }\t\t\t// { dg-error \"uninitialized\" }\n+};\n+\n+struct F\n+{\n+  F() = default;\n+  F(const F&) = delete;\t\t// { dg-error \"deleted\" }\n+};\n+\n+struct G\n+{\n+  G();\n+};\n+\n+// ctor defaulted after class defn is not trivial\n+G::G() = default;\n+\n+union U\n+{\n+  G g;\t\t\t\t// { dg-error \"constructor\" }\n+};\n+\n+int main()\n+{\n+  F f;\n+  F f2(f);\t\t\t// { dg-error \"used\" }\n+  B* b = new const B;\t\t// { dg-error \"uninitialized const\" }\n+}\n+"}, {"sha": "217928781d332901ddc2ee4fc3d98a0f6b485371", "filename": "gcc/testsuite/g++.dg/parse/crash27.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash27.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -1,5 +1,4 @@\n // Bug: 23225\n \n void Dispatcher()\n-\t (__builtin_offsetof (ArgsType, largeMsgLen))\n-\t/* { dg-error \"function \" \"function\" { target *-*-* } 4 } */\n+\t (__builtin_offsetof (ArgsType, largeMsgLen)) // { dg-error \"initialize|end of input\" }"}, {"sha": "5d30b554369716bdbb554675af650f5a2648e91a", "filename": "gcc/testsuite/g++.dg/parse/error15.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -35,4 +35,4 @@ struct C\n   typename N::A f7;   // { dg-error \"15: error: invalid use of template-name 'N::A' without an argument list\" }\n };\n \n-// { dg-bogus \"bogus excess errors in declaration\" \"bogus excess errors in declaration\" { xfail *-*-* } 17 }\n+// { dg-bogus \"bogus excess errors in declaration\" \"bogus excess errors in declaration\" { target *-*-* } 17 }"}, {"sha": "c579775917ed6146b5fa004143101e6b3db27072", "filename": "gcc/testsuite/g++.dg/template/crash60.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash60.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash60.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash60.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -5,5 +5,5 @@ struct A\n     template<int> void foo(X);  // { dg-error \"declared\" }\n };\n \n-template<int> void f()(0);      // { dg-error \"initialized\" }\n+template<int> void f()(0);      // { dg-error \"initialize\" }\n  "}, {"sha": "ae07d91e739972bc81a512ebe0448ee7aa368f48", "filename": "gcc/testsuite/g++.dg/template/crash7.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash7.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -6,8 +6,10 @@\n // nested type.\n \n template <typename> struct A\n-{\t\t\t\t\t// { dg-error \"candidates\" }\n+{\t\t\t\t\t// { not-dg-error \"candidates\" }\n     template <typename> A(typename A::X) {} // { dg-error \"no type\" }\n };\n \n-A<void> a;\t// { dg-error \"instantiated|no match\" }\n+A<void> a;\t// { not-dg-error \"instantiated|no match\" }\n+// We currently don't give the \"no match\" error because we don't add the\n+// invalid constructor template to TYPE_METHODS."}, {"sha": "40f7a7cb67f7791c338df4baf2d135298cb8098e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/error2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ferror2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87d79e640b3e9ab1e126bb6d87472b2a261a640/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ferror2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ferror2.C?ref=b87d79e640b3e9ab1e126bb6d87472b2a261a640", "patch": "@@ -2,7 +2,7 @@\n // Origin: Carl Nygard <cnygard@bellatlantic.net>\n \n template <class RT>\n-class Test { // { dg-error \"\" } in instantiation\n+class Test {\n public:\n   Test(const RT& c = RT()) {} // { dg-error \"\" } reference to void\n };"}]}