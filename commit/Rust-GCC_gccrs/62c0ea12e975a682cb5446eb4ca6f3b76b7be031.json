{"sha": "62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjMGVhMTJlOTc1YTY4MmNiNTQ0NmViNGNhNmYzYjc2YjdiZTAzMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T21:53:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T21:53:33Z"}, "message": "(simplify_unary_operation): Correctly and consistently handle\nCONST_INT cases for FLOAT and UNSIGNED_FLOAT.\n\nFrom-SVN: r7470", "tree": {"sha": "0884fc31c84b6ba32f7cd320eefc449333747ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0884fc31c84b6ba32f7cd320eefc449333747ac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c0ea12e975a682cb5446eb4ca6f3b76b7be031/comments", "author": null, "committer": null, "parents": [{"sha": "ac7157f6c94451a44f4c7dc127a9bea28cb534ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7157f6c94451a44f4c7dc127a9bea28cb534ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7157f6c94451a44f4c7dc127a9bea28cb534ca"}], "stats": {"total": 69, "additions": 33, "deletions": 36}, "files": [{"sha": "eb541ae7b1d97e189613062ad7f3cde04b71046f", "filename": "gcc/cse.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c0ea12e975a682cb5446eb4ca6f3b76b7be031/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c0ea12e975a682cb5446eb4ca6f3b76b7be031/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "patch": "@@ -2886,70 +2886,67 @@ simplify_unary_operation (code, mode, op, op_mode)\n      check the wrong mode (input vs. output) for a conversion operation,\n      such as FIX.  At some point, this should be simplified.  */\n \n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-  if (code == FLOAT && GET_CODE (op) == CONST_INT)\n-    {\n-      REAL_VALUE_TYPE d;\n+#if !defined(REAL_IS_NOT_DOUBLE) || defined(REAL_ARITHMETIC)\n \n-#ifdef REAL_ARITHMETIC\n-      REAL_VALUE_FROM_INT (d, INTVAL (op), INTVAL (op) < 0 ? ~0 : 0);\n-#else\n-      d = (double) INTVAL (op);\n-#endif\n-      return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n-    }\n-  else if (code == UNSIGNED_FLOAT && GET_CODE (op) == CONST_INT)\n+  if (code == FLOAT && GET_MODE (op) == VOIDmode\n+      && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n     {\n+      HOST_WIDE_INT hv, lv;\n       REAL_VALUE_TYPE d;\n \n-#ifdef REAL_ARITHMETIC\n-      REAL_VALUE_FROM_INT (d, INTVAL (op), 0);\n-#else\n-      d = (double) (unsigned int) INTVAL (op);\n-#endif\n-      return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n-    }\n-\n-  else if (code == FLOAT && GET_CODE (op) == CONST_DOUBLE\n-\t   && GET_MODE (op) == VOIDmode)\n-    {\n-      REAL_VALUE_TYPE d;\n+      if (GET_CODE (op) == CONST_INT)\n+\tlv = INTVAL (op), hv = INTVAL (op) < 0 ? -1 : 0;\n+      else\n+\tlv = CONST_DOUBLE_HIGH (op),  hv = CONST_DOUBLE_LOW (op);\n \n #ifdef REAL_ARITHMETIC\n-      REAL_VALUE_FROM_INT (d, CONST_DOUBLE_LOW (op), CONST_DOUBLE_HIGH (op));\n+      REAL_VALUE_FROM_INT (d, lv, hv);\n #else\n-      if (CONST_DOUBLE_HIGH (op) < 0)\n+      if (hv < 0)\n \t{\n-\t  d = (double) (~ CONST_DOUBLE_HIGH (op));\n+\t  d = (double) (~ hv);\n \t  d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n \t\t* (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-\t  d += (double) (unsigned HOST_WIDE_INT) (~ CONST_DOUBLE_LOW (op));\n+\t  d += (double) (unsigned HOST_WIDE_INT) (~ lv);\n \t  d = (- d - 1.0);\n \t}\n       else\n \t{\n-\t  d = (double) CONST_DOUBLE_HIGH (op);\n+\t  d = (double) hv;\n \t  d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n \t\t* (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-\t  d += (double) (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+\t  d += (double) (unsigned HOST_WIDE_INT) lv;\n \t}\n #endif  /* REAL_ARITHMETIC */\n+\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n-  else if (code == UNSIGNED_FLOAT && GET_CODE (op) == CONST_DOUBLE\n-\t   && GET_MODE (op) == VOIDmode)\n+  else if (code == UNSIGNED_FLOAT && GET_MODE (op) == VOIDmode\n+\t   && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n     {\n+      HOST_WIDE_INT hv, lv;\n       REAL_VALUE_TYPE d;\n \n+      if (GET_CODE (op) == CONST_INT)\n+\tlv = INTVAL (op), hv = INTVAL (op) < 0 ? -1 : 0;\n+      else\n+\tlv = CONST_DOUBLE_HIGH (op),  hv = CONST_DOUBLE_LOW (op);\n+\n+      if (GET_MODE_BITSIZE (op_mode) >= HOST_BITS_PER_WIDE_INT * 2)\n+\t;\n+      else\n+\thv = 0, lv &= GET_MODE_MASK (op_mode);\n+\n #ifdef REAL_ARITHMETIC\n-      REAL_VALUE_FROM_UNSIGNED_INT (d, CONST_DOUBLE_LOW (op),\n-\t\t\t\t    CONST_DOUBLE_HIGH (op));\n+      REAL_VALUE_FROM_UNSIGNED_INT (d, lv, hv);\n #else\n-      d = (double) CONST_DOUBLE_HIGH (op);\n+\n+      d = (double) hv;\n       d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n \t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-      d += (double) (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n+      d += (double) (unsigned HOST_WIDE_INT) lv;\n #endif  /* REAL_ARITHMETIC */\n+\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n #endif"}]}