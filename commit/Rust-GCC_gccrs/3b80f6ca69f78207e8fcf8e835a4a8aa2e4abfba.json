{"sha": "3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I4MGY2Y2E2OWY3ODIwN2U4ZmNmOGU4MzVhNGE4YWEyZTRhYmZiYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-01-08T21:17:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-01-08T21:17:05Z"}, "message": "Makefile.in (OBJ, GEN, RTL_H): Add genrtl.[oh] bits.\n\n* Makefile.in (OBJ, GEN, RTL_H): Add genrtl.[oh] bits.\n* emit-rtl.c (gen_rtx): Move special code to ...\n(gen_rtx_CONST_INT): New function.\n(gen_rtx_REG): New function.\n(*): Update all calls to gen_rtx.\n* genemit.c (gen_exp): Emit calls to gen_rtx_FOO for constant FOO.\n* rtl.h: Include genrtl.h; prototype CONST_INT & REG generators.\n(GEN_INT): Call gen_rtx_CONST_INT.\n* gengenrtl.c: New file.\n\nFrom-SVN: r17312", "tree": {"sha": "c792e877a8974b6884a66403f5d9b9ee06c23290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c792e877a8974b6884a66403f5d9b9ee06c23290"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/comments", "author": null, "committer": null, "parents": [{"sha": "f4a233434d41848d9ae3bcb0f9518dfd986143ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a233434d41848d9ae3bcb0f9518dfd986143ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a233434d41848d9ae3bcb0f9518dfd986143ba"}], "stats": {"total": 558, "additions": 444, "deletions": 114}, "files": [{"sha": "3b8cf2b43c2b6f128516525b7d4dd7b88b2d22eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "patch": "@@ -1,3 +1,15 @@\n+Thu Jan  8 21:06:54 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* Makefile.in (OBJ, GEN, RTL_H): Add genrtl.[oh] bits.\n+\t* emit-rtl.c (gen_rtx): Move special code to ...\n+\t(gen_rtx_CONST_INT): New function.\n+\t(gen_rtx_REG): New function.\n+\t(*): Update all calls to gen_rtx.\n+\t* genemit.c (gen_exp): Emit calls to gen_rtx_FOO for constant FOO.\n+\t* rtl.h: Include genrtl.h; prototype CONST_INT & REG generators.\n+\t(GEN_INT): Call gen_rtx_CONST_INT.\n+\t* gengenrtl.c: New file.\n+\n Mon Jan  5 13:00:18 1998  John F. Carr  <jfc@mit.edu>\n \n \t* alias.c (*_dependence): Call base_alias_check before canon_rtx."}, {"sha": "d79d58a969dcafe9e5c2fb86e7cb93ac82d8bfd2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "patch": "@@ -589,7 +589,7 @@ SCHED_CFLAGS = @sched_cflags@\n # Language-independent object files.\n OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o \\\n- varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o real.o regmove.o \\\n+ varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o real.o regmove.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n@@ -600,7 +600,8 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n #  them before rtl.o is compiled.\n-GEN= genemit genoutput genrecog genextract genflags gencodes genconfig genpeep\n+GEN= genemit genoutput genrecog genextract genflags gencodes genconfig \\\n+ genpeep gengenrtl\n \n CCCP=cccp\n # Uncomment this line if you want to use cppmain (w/cpplib) as cpp.\n@@ -669,7 +670,8 @@ DPBIT_FUNCS = _pack_df _unpack_df _addsub_df _mul_df _div_df \\\n # If it is, rm *.o is an easy way to do it.\n # CONFIG_H = $(host_xm_file) $(tm_file)\n CONFIG_H =\n-RTL_H = rtl.h rtl.def gansidecl.h machmode.h machmode.def\n+RTL_BASE_H = rtl.h rtl.def gansidecl.h machmode.h machmode.def\n+RTL_H = $(RTL_BASE_H) genrtl.h\n TREE_H = tree.h real.h tree.def gansidecl.h machmode.h machmode.def\n BYTECODE_H = bytecode.h bc-emit.h bc-optab.h\n BASIC_BLOCK_H = basic-block.h bitmap.h\n@@ -1242,8 +1244,8 @@ $(srcdir)/c-gperf.h: c-parse.gperf\n c-decl.o : c-decl.c $(CONFIG_H) $(TREE_H) c-tree.h c-lex.h flags.h output.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(TREE_H) c-tree.h flags.h output.h\n c-lang.o : c-lang.c $(CONFIG_H) $(TREE_H)\n-c-lex.o : c-lex.c $(CONFIG_H) $(TREE_H) c-lex.h c-tree.h $(srcdir)/c-parse.h \\\n-    input.h flags.h $(srcdir)/c-gperf.h c-pragma.h\n+c-lex.o : c-lex.c $(CONFIG_H) $(TREE_H) $(RTL_H) c-lex.h c-tree.h \\\n+    $(srcdir)/c-parse.h input.h flags.h $(srcdir)/c-gperf.h c-pragma.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(TREE_H) c-tree.h flags.h\n c-convert.o : c-convert.c $(CONFIG_H) $(TREE_H) flags.h\n c-pragma.o: c-pragma.c $(CONFIG_H) $(TREE_H) except.h function.h \\\n@@ -1580,6 +1582,15 @@ stamp-output : $(md_file) genoutput $(srcdir)/move-if-change\n \t./genoutput $(md_file) > tmp-output.c\n \t$(srcdir)/move-if-change tmp-output.c insn-output.c\n \ttouch stamp-output\n+\n+genrtl.o : genrtl.c $(CONFIG_H) $(RTL_H)\n+genrtl.c genrtl.h : stamp-genrtl\n+stamp-genrtl: gengenrtl $(srcdir)/move-if-change $(RTL_BASE_H)\n+\t./gengenrtl tmp-genrtl.h tmp-genrtl.c\n+\t$(srcdir)/move-if-change tmp-genrtl.h genrtl.h\n+\t$(srcdir)/move-if-change tmp-genrtl.c genrtl.c\n+\ttouch stamp-genrtl\n+\n #\f\n # Compile the programs that generate insn-* from the machine description.\n # They are compiled with $(HOST_CC), and associated libraries,\n@@ -1673,6 +1684,14 @@ genoutput : genoutput.o $(HOST_RTL) $(HOST_LIBDEPS)\n \n genoutput.o : genoutput.c $(RTL_H) $(build_xm_file)\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genoutput.c\n+\n+gengenrtl : gengenrtl.o $(HOST_LIBDEPS)\n+\t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n+\t gengenrtl.o $(HOST_LIBS)\n+\n+gengenrtl.o : gengenrtl.c $(RTL_BASE_H)\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gengenrtl.c\n+\n #\f\n # Compile the libraries to be used by gen*.\n # If we are not cross-building, gen* use the same .o's that cc1 will use,"}, {"sha": "ef85c41cfd761454e8bb79db04cd60a58d678b20", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 101, "deletions": 102, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "patch": "@@ -259,6 +259,64 @@ static rtx make_jump_insn_raw\t\tPROTO((rtx));\n static rtx make_call_insn_raw\t\tPROTO((rtx));\n static rtx find_line_note\t\tPROTO((rtx));\n \f\n+rtx\n+gen_rtx_CONST_INT (mode, arg)\n+     enum machine_mode mode;\n+     HOST_WIDE_INT arg;\n+{\n+  if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n+    return &const_int_rtx[arg + MAX_SAVED_CONST_INT];\n+\n+#if STORE_FLAG_VALUE != 1 && STORE_FLAG_VALUE != -1\n+  if (const_true_rtx && arg == STORE_FLAG_VALUE)\n+    return const_true_rtx;\n+#endif\n+\n+  return gen_rtx_raw_CONST_INT (mode, arg);\n+}\n+\n+rtx\n+gen_rtx_REG (mode, regno)\n+     enum machine_mode mode;\n+     int regno;\n+{\n+  /* In case the MD file explicitly references the frame pointer, have\n+     all such references point to the same frame pointer.  This is\n+     used during frame pointer elimination to distinguish the explicit\n+     references to these registers from pseudos that happened to be\n+     assigned to them.\n+\n+     If we have eliminated the frame pointer or arg pointer, we will\n+     be using it as a normal register, for example as a spill\n+     register.  In such cases, we might be accessing it in a mode that\n+     is not Pmode and therefore cannot use the pre-allocated rtx.\n+\n+     Also don't do this when we are making new REGs in reload, since\n+     we don't want to get confused with the real pointers.  */\n+\n+  if (mode == Pmode && !reload_in_progress)\n+    {\n+      if (regno == FRAME_POINTER_REGNUM)\n+\treturn frame_pointer_rtx;\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+      if (regno == HARD_FRAME_POINTER_REGNUM)\n+\treturn hard_frame_pointer_rtx;\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM && HARD_FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      if (regno == ARG_POINTER_REGNUM)\n+\treturn arg_pointer_rtx;\n+#endif\n+#ifdef RETURN_ADDRESS_POINTER_REGNUM\n+      if (regno == RETURN_ADDRESS_POINTER_REGNUM)\n+\treturn return_address_pointer_rtx;\n+#endif\n+      if (regno == STACK_POINTER_REGNUM)\n+\treturn stack_pointer_rtx;\n+    }\n+\n+  return gen_rtx_raw_REG (mode, regno);\n+}\n+\n /* rtx gen_rtx (code, mode, [element1, ..., elementn])\n **\n **\t    This routine generates an RTX of the size specified by\n@@ -306,67 +364,9 @@ gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n #endif\n \n   if (code == CONST_INT)\n-    {\n-      HOST_WIDE_INT arg = va_arg (p, HOST_WIDE_INT);\n-\n-      if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n-\treturn &const_int_rtx[arg + MAX_SAVED_CONST_INT];\n-\n-#if STORE_FLAG_VALUE != 1 && STORE_FLAG_VALUE != -1\n-      if (const_true_rtx && arg == STORE_FLAG_VALUE)\n-\treturn const_true_rtx;\n-#endif\n-\n-      rt_val = rtx_alloc (code);\n-      INTVAL (rt_val) = arg;\n-    }\n+    rt_val = gen_rtx_CONST_INT (mode, va_arg (p, HOST_WIDE_INT));\n   else if (code == REG)\n-    {\n-      int regno = va_arg (p, int);\n-\n-      /* In case the MD file explicitly references the frame pointer, have\n-\t all such references point to the same frame pointer.  This is used\n-\t during frame pointer elimination to distinguish the explicit\n-\t references to these registers from pseudos that happened to be\n-\t assigned to them.\n-\n-\t If we have eliminated the frame pointer or arg pointer, we will\n-\t be using it as a normal register, for example as a spill register.\n-\t In such cases, we might be accessing it in a mode that is not\n-\t Pmode and therefore cannot use the pre-allocated rtx.\n-\n-\t Also don't do this when we are making new REGs in reload,\n-\t since we don't want to get confused with the real pointers.  */\n-\n-      if (regno == FRAME_POINTER_REGNUM && mode == Pmode\n-\t  && ! reload_in_progress)\n-\treturn frame_pointer_rtx;\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      if (regno == HARD_FRAME_POINTER_REGNUM && mode == Pmode\n-\t  && ! reload_in_progress)\n-\treturn hard_frame_pointer_rtx;\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM && HARD_FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-      if (regno == ARG_POINTER_REGNUM && mode == Pmode\n-\t  && ! reload_in_progress)\n-\treturn arg_pointer_rtx;\n-#endif\n-#ifdef RETURN_ADDRESS_POINTER_REGNUM\n-      if (return_address_pointer_rtx && regno == RETURN_ADDRESS_POINTER_REGNUM\n-\t  && mode == Pmode && ! reload_in_progress)\n-\treturn return_address_pointer_rtx;\n-#endif\n-      if (regno == STACK_POINTER_REGNUM && mode == Pmode\n-\t  && ! reload_in_progress)\n-\treturn stack_pointer_rtx;\n-      else\n-\t{\n-\t  rt_val = rtx_alloc (code);\n-\t  rt_val->mode = mode;\n-\t  REGNO (rt_val) = regno;\n-\t  return rt_val;\n-\t}\n-    }\n+    rt_val = gen_rtx_REG (mode, va_arg (p, int));\n   else\n     {\n       rt_val = rtx_alloc (code);\t/* Allocate the storage space.  */\n@@ -517,7 +517,7 @@ gen_reg_rtx (mode)\n \n       realpart = gen_reg_rtx (partmode);\n       imagpart = gen_reg_rtx (partmode);\n-      return gen_rtx (CONCAT, mode, realpart, imagpart);\n+      return gen_rtx_CONCAT (mode, realpart, imagpart);\n     }\n \n   /* Make sure regno_pointer_flag and regno_reg_rtx are large\n@@ -547,7 +547,7 @@ gen_reg_rtx (mode)\n       regno_pointer_flag_length *= 2;\n     }\n \n-  val = gen_rtx (REG, mode, reg_rtx_no);\n+  val = gen_rtx_raw_REG (mode, reg_rtx_no);\n   regno_reg_rtx[reg_rtx_no++] = val;\n   return val;\n }\n@@ -659,14 +659,14 @@ gen_lowpart_common (mode, x)\n       else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))\n \treturn gen_lowpart_common (mode, XEXP (x, 0));\n       else if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n-\treturn gen_rtx (GET_CODE (x), mode, XEXP (x, 0));\n+\treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == SUBREG\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || GET_MODE_SIZE (mode) == GET_MODE_UNIT_SIZE (GET_MODE (x))))\n     return (GET_MODE (SUBREG_REG (x)) == mode && SUBREG_WORD (x) == 0\n \t    ? SUBREG_REG (x)\n-\t    : gen_rtx (SUBREG, mode, SUBREG_REG (x), SUBREG_WORD (x) + word));\n+\t    : gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + word));\n   else if (GET_CODE (x) == REG)\n     {\n       /* If the register is not valid for MODE, return 0.  If we don't\n@@ -690,9 +690,9 @@ gen_lowpart_common (mode, x)\n \t       && x != arg_pointer_rtx\n #endif\n \t       && x != stack_pointer_rtx)\n-\treturn gen_rtx (REG, mode, REGNO (x) + word);\n+\treturn gen_rtx_REG (mode, REGNO (x) + word);\n       else\n-\treturn gen_rtx (SUBREG, mode, x, word);\n+\treturn gen_rtx_SUBREG (mode, x, word);\n     }\n   /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n      from the low-order part of the constant.  */\n@@ -984,8 +984,7 @@ gen_highpart (mode, x)\n       && GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT\n #endif\n       )\n-    return gen_rtx (CONST_INT, VOIDmode,\n-\t\t    CONST_DOUBLE_HIGH (x) & GET_MODE_MASK (mode));\n+    return GEN_INT (CONST_DOUBLE_HIGH (x) & GET_MODE_MASK (mode));\n   else if (GET_CODE (x) == CONST_INT)\n     return const0_rtx;\n   else if (GET_CODE (x) == MEM)\n@@ -1038,9 +1037,9 @@ gen_highpart (mode, x)\n \t  && x != arg_pointer_rtx\n #endif\n \t  && x != stack_pointer_rtx)\n-\treturn gen_rtx (REG, mode, REGNO (x) + word);\n+\treturn gen_rtx_REG (mode, REGNO (x) + word);\n       else\n-\treturn gen_rtx (SUBREG, mode, x, word);\n+\treturn gen_rtx_SUBREG (mode, x, word);\n     }\n   else\n     abort ();\n@@ -1131,12 +1130,12 @@ operand_subword (op, i, validate_address, mode)\n \t       || op == arg_pointer_rtx\n #endif\n \t       || op == stack_pointer_rtx)\n-\treturn gen_rtx (SUBREG, word_mode, op, i);\n+\treturn gen_rtx_SUBREG (word_mode, op, i);\n       else\n-\treturn gen_rtx (REG, word_mode, REGNO (op) + i);\n+\treturn gen_rtx_REG (word_mode, REGNO (op) + i);\n     }\n   else if (GET_CODE (op) == SUBREG)\n-    return gen_rtx (SUBREG, word_mode, SUBREG_REG (op), i + SUBREG_WORD (op));\n+    return gen_rtx_SUBREG (word_mode, SUBREG_REG (op), i + SUBREG_WORD (op));\n   else if (GET_CODE (op) == CONCAT)\n     {\n       int partwords = GET_MODE_UNIT_SIZE (GET_MODE (op)) / UNITS_PER_WORD;\n@@ -1163,7 +1162,7 @@ operand_subword (op, i, validate_address, mode)\n \t    addr = memory_address (word_mode, addr);\n \t}\n \n-      new = gen_rtx (MEM, word_mode, addr);\n+      new = gen_rtx_MEM (word_mode, addr);\n \n       MEM_VOLATILE_P (new) = MEM_VOLATILE_P (op);\n       MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (op);\n@@ -1397,8 +1396,7 @@ reverse_comparison (insn)\n     }\n   else\n     {\n-      rtx new = gen_rtx (COMPARE, VOIDmode,\n-\t\t\t CONST0_RTX (GET_MODE (comp)), comp);\n+      rtx new = gen_rtx_COMPARE (VOIDmode, CONST0_RTX (GET_MODE (comp)), comp);\n       if (GET_CODE (body) == SET)\n \tSET_SRC (body) = new;\n       else\n@@ -1439,7 +1437,7 @@ change_address (memref, mode, addr)\n   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))\n     return memref;\n \n-  new = gen_rtx (MEM, mode, addr);\n+  new = gen_rtx_MEM (mode, addr);\n   MEM_VOLATILE_P (new) = MEM_VOLATILE_P (memref);\n   RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (memref);\n   MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (memref);\n@@ -1454,9 +1452,10 @@ gen_label_rtx ()\n   register rtx label;\n \n   label = (output_bytecode\n-\t   ? gen_rtx (CODE_LABEL, VOIDmode, NULL, bc_get_bytecode_label ())\n-\t   : gen_rtx (CODE_LABEL, VOIDmode, 0, NULL_RTX,\n-\t\t      NULL_RTX, label_num++, NULL_PTR));\n+\t   ? gen_rtx_CODE_LABEL (VOIDmode, 0, bc_get_bytecode_label (),\n+\t\t\t\t NULL_RTX, 0, NULL_PTR)\n+\t   : gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX,\n+\t\t\t\t NULL_RTX, label_num++, NULL_PTR));\n \n   LABEL_NUSES (label) = 0;\n   return label;\n@@ -1488,16 +1487,17 @@ gen_inline_header_rtx (first_insn, first_parm_insn, first_labelno,\n      char *regno_align;\n      rtvec parm_reg_stack_loc;\n {\n-  rtx header = gen_rtx (INLINE_HEADER, VOIDmode,\n-\t\t\tcur_insn_uid++, NULL_RTX,\n-\t\t\tfirst_insn, first_parm_insn,\n-\t\t\tfirst_labelno, last_labelno,\n-\t\t\tmax_parm_regnum, max_regnum, args_size, pops_args,\n-\t\t\tstack_slots, forced_labels, function_flags,\n-\t\t\toutgoing_args_size, original_arg_vector,\n-\t\t\toriginal_decl_initial,\n-\t\t\tregno_rtx, regno_flag, regno_align,\n-\t\t\tparm_reg_stack_loc);\n+  rtx header = gen_rtx_INLINE_HEADER (VOIDmode,\n+\t\t\t\t      cur_insn_uid++, NULL_RTX,\n+\t\t\t\t      first_insn, first_parm_insn,\n+\t\t\t\t      first_labelno, last_labelno,\n+\t\t\t\t      max_parm_regnum, max_regnum, args_size,\n+\t\t\t\t      pops_args, stack_slots, forced_labels,\n+\t\t\t\t      function_flags, outgoing_args_size,\n+\t\t\t\t      original_arg_vector,\n+\t\t\t\t      original_decl_initial,\n+\t\t\t\t      regno_rtx, regno_flag, regno_align,\n+\t\t\t\t      parm_reg_stack_loc);\n   return header;\n }\n \n@@ -2092,9 +2092,8 @@ link_cc0_insns (insn)\n   if (GET_CODE (user) == INSN && GET_CODE (PATTERN (user)) == SEQUENCE)\n     user = XVECEXP (PATTERN (user), 0, 0);\n \n-  REG_NOTES (user) = gen_rtx (INSN_LIST, REG_CC_SETTER, insn,\n-\t\t\t      REG_NOTES (user));\n-  REG_NOTES (insn) = gen_rtx (INSN_LIST, REG_CC_USER, user, REG_NOTES (insn));\n+  REG_NOTES (user) = gen_rtx_INSN_LIST (REG_CC_SETTER, insn, REG_NOTES (user));\n+  REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_CC_USER, user, REG_NOTES (insn));\n }\n \n /* Return the next insn that uses CC0 after INSN, which is assumed to\n@@ -3239,7 +3238,7 @@ gen_sequence ()\n \t cache it.  */\n       push_obstacks_nochange ();\n       rtl_in_saveable_obstack ();\n-      result = gen_rtx (SEQUENCE, VOIDmode, rtvec_alloc (len));\n+      result = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (len));\n       pop_obstacks ();\n     }\n \n@@ -3376,7 +3375,7 @@ init_emit_once (line_numbers)\n       && STORE_FLAG_VALUE <= MAX_SAVED_CONST_INT)\n     const_true_rtx = &const_int_rtx[STORE_FLAG_VALUE + MAX_SAVED_CONST_INT];\n   else\n-    const_true_rtx = gen_rtx (CONST_INT, VOIDmode, STORE_FLAG_VALUE);\n+    const_true_rtx = gen_rtx_CONST_INT (VOIDmode, STORE_FLAG_VALUE);\n \n   dconst0 = REAL_VALUE_ATOF (\"0\", DFmode);\n   dconst1 = REAL_VALUE_ATOF (\"1\", DFmode);\n@@ -3441,33 +3440,33 @@ init_emit_once (line_numbers)\n   PUT_MODE (virtual_outgoing_args_rtx, Pmode);\n \n #ifdef RETURN_ADDRESS_POINTER_REGNUM\n-  return_address_pointer_rtx = gen_rtx (REG, Pmode,\n-\t\t\t\t\tRETURN_ADDRESS_POINTER_REGNUM);\n+  return_address_pointer_rtx = gen_rtx_REG (Pmode,\n+\t\t\t\t\t    RETURN_ADDRESS_POINTER_REGNUM);\n #endif\n \n #ifdef STRUCT_VALUE\n   struct_value_rtx = STRUCT_VALUE;\n #else\n-  struct_value_rtx = gen_rtx (REG, Pmode, STRUCT_VALUE_REGNUM);\n+  struct_value_rtx = gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM);\n #endif\n \n #ifdef STRUCT_VALUE_INCOMING\n   struct_value_incoming_rtx = STRUCT_VALUE_INCOMING;\n #else\n #ifdef STRUCT_VALUE_INCOMING_REGNUM\n   struct_value_incoming_rtx\n-    = gen_rtx (REG, Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n+    = gen_rtx_REG (Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n #else\n   struct_value_incoming_rtx = struct_value_rtx;\n #endif\n #endif\n \n #ifdef STATIC_CHAIN_REGNUM\n-  static_chain_rtx = gen_rtx (REG, Pmode, STATIC_CHAIN_REGNUM);\n+  static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n \n #ifdef STATIC_CHAIN_INCOMING_REGNUM\n   if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n-    static_chain_incoming_rtx = gen_rtx (REG, Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n+    static_chain_incoming_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n   else\n #endif\n     static_chain_incoming_rtx = static_chain_rtx;\n@@ -3484,6 +3483,6 @@ init_emit_once (line_numbers)\n #endif\n \n #ifdef PIC_OFFSET_TABLE_REGNUM\n-  pic_offset_table_rtx = gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM);\n+  pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n #endif\n }"}, {"sha": "9dacd528e46954354754011b512bbd15b167f93c", "filename": "gcc/genemit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "patch": "@@ -188,7 +188,7 @@ gen_exp (x)\n       return;\n \n     case MATCH_SCRATCH:\n-      printf (\"gen_rtx (SCRATCH, %smode, 0)\", GET_MODE_NAME (GET_MODE (x)));\n+      printf (\"gen_rtx_SCRATCH (%smode)\", GET_MODE_NAME (GET_MODE (x)));\n       return;\n \n     case ADDRESS:\n@@ -230,9 +230,9 @@ gen_exp (x)\n       break;\n     }\n \n-  printf (\"gen_rtx (\");\n+  printf (\"gen_rtx_\");\n   print_code (code);\n-  printf (\", %smode\", GET_MODE_NAME (GET_MODE (x)));\n+  printf (\" (%smode\", GET_MODE_NAME (GET_MODE (x)));\n \n   fmt = GET_RTX_FORMAT (code);\n   len = GET_RTX_LENGTH (code);\n@@ -371,7 +371,7 @@ gen_insn (insn)\n     }\n   else\n     {\n-      printf (\"  return gen_rtx (PARALLEL, VOIDmode, gen_rtvec (%d\", XVECLEN (insn, 1));\n+      printf (\"  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (%d\", XVECLEN (insn, 1));\n       for (i = 0; i < XVECLEN (insn, 1); i++)\n \t{\n \t  printf (\",\\n\\t\\t\");"}, {"sha": "977305d9a826150733c4d10604f55a9137e46eab", "filename": "gcc/gengenrtl.c", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "patch": "@@ -0,0 +1,287 @@\n+/* Generate code to allocate RTL structures.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#include \"hconfig.h\"\n+#include <stdio.h>\n+\n+#include \"obstack.h\"\n+#define\tobstack_chunk_alloc\txmalloc\n+#define\tobstack_chunk_free\tfree\n+\n+#define NO_GENRTL_H\n+#include \"rtl.h\"\n+\n+\n+struct rtx_definition \n+{\n+  const char *enumname, *name, *format;\n+};\n+\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS) { # ENUM, NAME, FORMAT },\n+\n+struct rtx_definition defs[] = \n+{  \n+#include \"rtl.def\"\t\t/* rtl expressions are documented here */\n+};\n+\n+const char *formats[NUM_RTX_CODE];\n+\n+static const char *\n+type_from_format (char c)\n+{\n+  switch (c)\n+    {\n+    case 'i':\n+      return \"int\";\n+    case 'w':\n+      return \"HOST_WIDE_INT\";\n+    case 's':\n+      return \"char *\";\n+    case 'e':\n+    case 'u':\n+      return \"rtx\";\n+    case 'E':\n+      return \"rtvec\";\n+    default:\n+      abort ();\n+    }\n+}\n+\n+static const char *\n+accessor_from_format (char c)\n+{\n+  switch (c)\n+    {\n+    case 'i':\n+      return \"XINT\";\n+    case 'w':\n+      return \"XWINT\";\n+    case 's':\n+      return \"XSTR\";\n+    case 'e':\n+    case 'u':\n+      return \"XEXP\";\n+    case 'E':\n+      return \"XVEC\";\n+    default:\n+      abort ();\n+    }\n+}\n+\n+static int\n+special_format (fmt)\n+     const char *fmt;\n+{\n+  return (strchr (fmt, '*') != 0\n+\t  || strchr (fmt, 'V') != 0\n+\t  || strchr (fmt, 'S') != 0\n+\t  || strchr (fmt, 'n') != 0);\n+}\n+\n+static int\n+special_rtx (idx)\n+     int idx;\n+{\n+  return (strcmp (defs[idx].enumname, \"CONST_INT\") == 0\n+\t  || strcmp (defs[idx].enumname, \"REG\") == 0);\n+}\n+\n+static void\n+find_formats ()\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_RTX_CODE; ++i)\n+    {\n+      const char **f;\n+\n+      if (special_format (defs[i].format))\n+\tcontinue;\n+\n+      for (f = formats; *f ; ++f)\n+\tif (!strcmp(*f, defs[i].format))\n+\t  break;\n+\n+      if (!*f)\n+\t*f = defs[i].format;\n+    }\n+}\n+\n+static void\n+gendecl (f, format)\n+     FILE *f;\n+     const char *format;\n+{\n+  const char *p;\n+  int i;\n+  \n+  fprintf (f, \"extern rtx gen_rtx_fmt_%s PROTO((RTX_CODE, enum machine_mode mode\",\n+\t   format);\n+  for (p = format, i = 0; *p ; ++p)\n+    if (*p != '0')\n+      fprintf (f, \", %s arg%d\", type_from_format (*p), i++);\n+  fprintf (f, \"));\\n\");\n+}\n+\n+static void \n+genmacro (f, idx)\n+     FILE *f;\n+     int idx;\n+{\n+  const char *p;\n+  int i;\n+\n+  fprintf (f, \"#define gen_rtx_%s%s(mode\",\n+\t   (special_rtx (idx) ? \"raw_\" : \"\"), defs[idx].enumname);\n+\n+  for (p = defs[idx].format, i = 0; *p ; ++p)\n+    if (*p != '0')\n+      fprintf (f, \", arg%d\", i++);\n+  fprintf (f, \")   \");\n+\n+  fprintf (f, \"gen_rtx_fmt_%s(%s,(mode)\", defs[idx].format, defs[idx].enumname);\n+  for (p = defs[idx].format, i = 0; *p ; ++p)\n+    if (*p != '0')\n+      fprintf (f, \",(arg%d)\", i++);\n+  fprintf (f, \")\\n\");\n+}\n+\n+static void\n+gendef (f, format)\n+     FILE *f;\n+     const char *format;\n+{\n+  const char *p;\n+  int i, j;\n+  \n+  fprintf (f, \"rtx\\ngen_rtx_fmt_%s (code, mode\", format);\n+  for (p = format, i = 0; *p ; ++p)\n+    if (*p != '0')\n+      fprintf (f, \", arg%d\", i++);\n+\n+  fprintf (f, \")\\n     RTX_CODE code;\\n     enum machine_mode mode;\\n\");\n+  for (p = format, i = 0; *p ; ++p)\n+    if (*p != '0')\n+      fprintf (f, \"     %s arg%d;\\n\", type_from_format (*p), i++);\n+\n+  /* See rtx_alloc in rtl.c for comments.  */\n+  fprintf (f, \"{\\n\");\n+  fprintf (f, \"  register int length = sizeof (struct rtx_def)\");\n+  fprintf (f, \" + %d * sizeof (rtunion);\\n\", strlen (format) - 1);\n+  fprintf (f, \"  rtx rt = (rtx)obstack_alloc (rtl_obstack, length);\\n\");\n+\n+  fprintf (f, \"  if (sizeof(struct rtx_def) - sizeof(rtunion) == sizeof(int))\\n\");\n+  fprintf (f, \"    *(int *)rt = 0;\\n\");\n+  fprintf (f, \"  else if (sizeof(struct rtx_def) - sizeof(rtunion) == sizeof(HOST_WIDE_INT))\\n\");\n+  fprintf (f, \"    *(HOST_WIDE_INT *)rt = 0;\\n\");\n+  fprintf (f, \"  else\\n\");\n+  fprintf (f, \"    bzero(rt, sizeof(struct rtx_def) - sizeof(rtunion));\\n\\n\");\n+\n+  fprintf (f, \"  PUT_CODE (rt, code);\\n\");\n+  fprintf (f, \"  PUT_MODE (rt, mode);\\n\");\n+\n+  for (p = format, i = j = 0; *p ; ++p, ++i)\n+    if (*p != '0')\n+      {\n+\tfprintf (f, \"  %s (rt, %d) = arg%d;\\n\",\n+\t\t accessor_from_format (*p), i, j++);\n+      }\n+\n+  fprintf (f, \"\\n  return rt;\\n}\\n\\n\");\n+}\n+\n+static void\n+genlegend (f)\n+     FILE *f;\n+{\n+  fprintf (f, \"/* Generated automaticaly by the program `gengenrtl'\\n\");\n+  fprintf (f, \"   from the RTL description file `rtl.def' */\\n\\n\");\n+}\n+\n+static void\n+genheader (f)\n+     FILE *f;\n+{\n+  int i;\n+  const char **fmt;\n+\n+  for (fmt = formats; *fmt; ++fmt)\n+    gendecl (f, *fmt);\n+\n+  fprintf(f, \"\\n\");\n+\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    {\n+      if (special_format (defs[i].format))\n+\tcontinue;\n+      genmacro (f, i);\n+    }\n+}\n+\n+static void\n+gencode (f)\n+     FILE *f;\n+{\n+  const char **fmt;\n+\n+  fprintf(f, \"#include \\\"config.h\\\"\\n\");\n+  fprintf(f, \"#include \\\"obstack.h\\\"\\n\");\n+  fprintf(f, \"#include \\\"rtl.h\\\"\\n\\n\");\n+  fprintf(f, \"extern struct obstack *rtl_obstack;\\n\\n\");\n+\n+  for (fmt = formats; *fmt; ++fmt)\n+    gendef (f, *fmt);\n+}\n+\n+int\n+main(argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  FILE *f;\n+\n+  if (argc != 3)\n+    exit (1);\n+\n+  find_formats ();\n+\n+  f = fopen (argv[1], \"w\");\n+  if (f == NULL)\n+    {\n+      perror(argv[1]);\n+      exit (1);\n+    }\n+  genlegend (f);\n+  genheader (f);\n+  fclose(f);\n+\n+  f = fopen (argv[2], \"w\");\n+  if (f == NULL)\n+    {\n+      perror(argv[2]);\n+      exit (1);\n+    }\n+  genlegend (f);\n+  gencode (f);\n+  fclose(f);\n+\n+  exit (0);\n+}"}, {"sha": "b7d70196963dc53deec92ba983aa1ffa734054d6", "filename": "gcc/rtl.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3b80f6ca69f78207e8fcf8e835a4a8aa2e4abfba", "patch": "@@ -681,8 +681,6 @@ extern int ceil_log2\t\t\tPROTO((unsigned HOST_WIDE_INT));\n extern rtx plus_constant_wide\t\t PROTO((rtx, HOST_WIDE_INT));\n extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));\n \n-#define GEN_INT(N) gen_rtx (CONST_INT, VOIDmode, (HOST_WIDE_INT) (N))\n-\n struct bc_label;\n extern rtx bc_gen_rtx\t\t\tPROTO ((char *, int,\n \t\t\t\t\t\tstruct bc_label *));\n@@ -934,6 +932,22 @@ extern rtx struct_value_incoming_rtx;\n extern rtx static_chain_rtx;\n extern rtx static_chain_incoming_rtx;\n \n+\n+/* Include the RTL generation functions.  */\n+\n+#ifndef NO_GENRTL_H\n+#include \"genrtl.h\"\n+#endif\n+\n+/* There are two RTL codes that require special attention; the generation\n+   functions included above do the raw handling.  */\n+\n+extern rtx gen_rtx_CONST_INT PROTO((enum machine_mode, HOST_WIDE_INT));\n+extern rtx gen_rtx_REG PROTO((enum machine_mode, int));\n+\n+#define GEN_INT(N)  gen_rtx_CONST_INT (VOIDmode, (N))\n+\n+\n /* If HARD_FRAME_POINTER_REGNUM is defined, then a special dummy reg\n    is used to represent the frame pointer.  This is because the\n    hard frame pointer and the automatic variables are separated by an amount\n@@ -1376,4 +1390,3 @@ extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n \n #endif /* _RTL_H */\n-"}]}