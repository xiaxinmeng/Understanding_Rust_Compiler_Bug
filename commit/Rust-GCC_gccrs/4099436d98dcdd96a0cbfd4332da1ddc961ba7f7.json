{"sha": "4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5OTQzNmQ5OGRjZGQ5NmEwY2JmZDQzMzJkYTFkZGM5NjFiYTdmNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-03-28T21:02:00Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-03-28T21:02:00Z"}, "message": "re PR fortran/55806 (Missed optimization with ANY or ALL)\n\n2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/55806\n\t* frontend-passes.c (optimize_code):  Keep track of\n\tcurrent code to make code insertion possible.\n\t(combine_array_constructor):  New function.\n\t(optimize_op):  Call it.\n\n2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/55806\n\t* gfortran.dg/array_constructor_43.f90:  New test.\n\t* gfortran.dg/random_seed_3.f90:  New test.\n\nFrom-SVN: r197216", "tree": {"sha": "1bf1d4747ca9b4c3527169167457134da4610898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bf1d4747ca9b4c3527169167457134da4610898"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/comments", "author": null, "committer": null, "parents": [{"sha": "777e69760d2e68900b2b9460124c2327e651cca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e69760d2e68900b2b9460124c2327e651cca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777e69760d2e68900b2b9460124c2327e651cca2"}], "stats": {"total": 148, "additions": 147, "deletions": 1}, "files": [{"sha": "8c3a4d994bd25bb7755d42e58aeead099293eb85", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "patch": "@@ -1,3 +1,11 @@\n+2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/55806\n+\t* frontend-passes.c (optimize_code):  Keep track of\n+\tcurrent code to make code insertion possible.\n+\t(combine_array_constructor):  New function.\n+\t(optimize_op):  Call it.\n+\n 2013-03-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/56650"}, {"sha": "a77afc58e4b962f2a5e3101b0b1bcc04cff81975", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "patch": "@@ -135,6 +135,10 @@ optimize_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   else\n     count_arglist = 0;\n \n+  current_code = c;\n+  inserted_block = NULL;\n+  changed_statement = NULL;\n+\n   if (op == EXEC_ASSIGN)\n     optimize_assignment (*c);\n   return 0;\n@@ -991,13 +995,98 @@ optimize_lexical_comparison (gfc_expr *e)\n   return false;\n }\n \n+/* Combine stuff like [a]>b into [a>b], for easier optimization later.  Do not\n+   do CHARACTER because of possible pessimization involving character\n+   lengths.  */\n+\n+static bool\n+combine_array_constructor (gfc_expr *e)\n+{\n+\n+  gfc_expr *op1, *op2;\n+  gfc_expr *scalar;\n+  gfc_expr *new_expr;\n+  gfc_constructor *c, *new_c;\n+  gfc_constructor_base oldbase, newbase;\n+  bool scalar_first;\n+\n+  /* Array constructors have rank one.  */\n+  if (e->rank != 1)\n+    return false;\n+\n+  op1 = e->value.op.op1;\n+  op2 = e->value.op.op2;\n+\n+  if (op1->expr_type == EXPR_ARRAY && op2->rank == 0)\n+    scalar_first = false;\n+  else if (op2->expr_type == EXPR_ARRAY && op1->rank == 0)\n+    {\n+      scalar_first = true;\n+      op1 = e->value.op.op2;\n+      op2 = e->value.op.op1;\n+    }\n+  else\n+    return false;\n+\n+  if (op2->ts.type == BT_CHARACTER)\n+    return false;\n+\n+  if (op2->expr_type == EXPR_CONSTANT)\n+    scalar = gfc_copy_expr (op2);\n+  else\n+    scalar = create_var (gfc_copy_expr (op2));\n+\n+  oldbase = op1->value.constructor;\n+  newbase = NULL;\n+  e->expr_type = EXPR_ARRAY;\n+\n+  c = gfc_constructor_first (oldbase);\n+\n+  for (c = gfc_constructor_first (oldbase); c;\n+       c = gfc_constructor_next (c))\n+    {\n+      new_expr = gfc_get_expr ();\n+      new_expr->ts = e->ts;\n+      new_expr->expr_type = EXPR_OP;\n+      new_expr->rank = c->expr->rank;\n+      new_expr->where = c->where;\n+      new_expr->value.op.op = e->value.op.op;\n+\n+      if (scalar_first)\n+\t{\n+\t  new_expr->value.op.op1 = gfc_copy_expr (scalar);\n+\t  new_expr->value.op.op2 = gfc_copy_expr (c->expr);\n+\t}\n+      else\n+\t{\n+\t  new_expr->value.op.op1 = gfc_copy_expr (c->expr);\n+\t  new_expr->value.op.op2 = gfc_copy_expr (scalar);\n+\t}\n+\n+      new_c = gfc_constructor_append_expr (&newbase, new_expr, &(e->where));\n+      new_c->iterator = c->iterator;\n+      c->iterator = NULL;\n+    }\n+\n+  gfc_free_expr (op1);\n+  gfc_free_expr (op2);\n+\n+  e->value.constructor = newbase;\n+  return true;\n+}\n+\n+\n /* Recursive optimization of operators.  */\n \n static bool\n optimize_op (gfc_expr *e)\n {\n+  bool changed;\n+\n   gfc_intrinsic_op op = e->value.op.op;\n \n+  changed = false;\n+\n   /* Only use new-style comparisons.  */\n   switch(op)\n     {\n@@ -1037,7 +1126,15 @@ optimize_op (gfc_expr *e)\n     case INTRINSIC_NE:\n     case INTRINSIC_GT:\n     case INTRINSIC_LT:\n-      return optimize_comparison (e, op);\n+      changed = optimize_comparison (e, op);\n+\n+      /* Fall through */\n+      /* Look at array constructors.  */\n+    case INTRINSIC_PLUS:\n+    case INTRINSIC_MINUS:\n+    case INTRINSIC_TIMES:\n+    case INTRINSIC_DIVIDE:\n+      return combine_array_constructor (e) || changed;\n \n     default:\n       break;"}, {"sha": "a24b837c4be58cfc8a0424ad01b2bd7061155779", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "patch": "@@ -1,3 +1,9 @@\n+2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/55806\n+\t* gfortran.dg/array_constructor_43.f90:  New test.\n+\t* gfortran.dg/random_seed_3.f90:  New test.\n+\n 2013-03-28  Ian Bolton  <ian.bolton@arm.com>\n \n \t* gcc.target/aarch64/inc/asm-adder-clobber-lr.c: New test."}, {"sha": "0fe96377e9770181221c20d2689c35053af461be", "filename": "gcc/testsuite/gfortran.dg/array_constructor_43.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_43.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_43.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_43.f90?ref=4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-ffrontend-optimize -fdump-tree-original\" }\n+program main\n+  implicit none\n+  real :: a,b,c,d\n+  call random_number(a)\n+  call random_number(b)\n+  call random_number(c)\n+  call random_number(d)\n+  if (any ([a,b,c,d] < 0.2)) print *,\"foo\"\n+end program main\n+! { dg-final { scan-tree-dump-times \"\\\\\\|\\\\\\|\" 3 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "c4be96541b037ee12a4fa8b94c2492a6bc0cbdfe", "filename": "gcc/testsuite/gfortran.dg/random_seed_3.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frandom_seed_3.f90?ref=4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! Check that array constructors using non-compile-time\n+! iterators are handled correctly.\n+program main\n+  implicit none\n+  call init_random_seed\n+contains\n+  SUBROUTINE init_random_seed()\n+    INTEGER :: i, n, clock\n+    INTEGER, DIMENSION(:), ALLOCATABLE :: seed\n+  \n+    CALL RANDOM_SEED(size = n)\n+    ALLOCATE(seed(n))\n+\n+    CALL SYSTEM_CLOCK(COUNT=clock)\n+    \n+    seed = clock + 37 * (/ (i - 1, i = 1, n) /)\n+    CALL RANDOM_SEED(PUT = seed)\n+  \n+    DEALLOCATE(seed)\n+  END SUBROUTINE init_random_seed\n+end program main"}]}