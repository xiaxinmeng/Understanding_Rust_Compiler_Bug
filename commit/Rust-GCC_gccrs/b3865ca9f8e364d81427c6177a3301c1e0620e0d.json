{"sha": "b3865ca9f8e364d81427c6177a3301c1e0620e0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4NjVjYTlmOGUzNjRkODE0MjdjNjE3N2EzMzAxYzFlMDYyMGUwZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-21T22:50:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-21T22:50:43Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r551", "tree": {"sha": "5e4ddc2c059c1280b2c4257b1b3715080b87d646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e4ddc2c059c1280b2c4257b1b3715080b87d646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3865ca9f8e364d81427c6177a3301c1e0620e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3865ca9f8e364d81427c6177a3301c1e0620e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3865ca9f8e364d81427c6177a3301c1e0620e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3865ca9f8e364d81427c6177a3301c1e0620e0d/comments", "author": null, "committer": null, "parents": [{"sha": "24f6f95eca9e40532078a888006cac1dc3e404c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24f6f95eca9e40532078a888006cac1dc3e404c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24f6f95eca9e40532078a888006cac1dc3e404c5"}], "stats": {"total": 233, "additions": 199, "deletions": 34}, "files": [{"sha": "844b32fdd554cc2d6019840edfffbe54441fa285", "filename": "gcc/config/m68k/sun3.h", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3865ca9f8e364d81427c6177a3301c1e0620e0d/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3865ca9f8e364d81427c6177a3301c1e0620e0d/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=b3865ca9f8e364d81427c6177a3301c1e0620e0d", "patch": "@@ -43,24 +43,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* -m68881 is the default */\n #define CPP_SPEC \\\n \"%{!msoft-float:%{mfpa:-D__HAVE_FPA__ }%{!mfpa:-D__HAVE_68881__ }}\\\n-%{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n-\n-#else\n-#if TARGET_DEFAULT & 0100\n-\n-/* -mfpa is the default */\n-#define CPP_SPEC \\\n-\"%{!msoft-float:%{m68881:-D__HAVE_68881__ }%{!m68881:-D__HAVE_FPA__ }}\\\n+%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}}} \\\n %{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n \n #else\n \n /* -msoft-float is the default */\n #define CPP_SPEC \\\n \"%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }\\\n+%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}}} \\\n %{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n \n-#endif\n #endif\n \n /* Prevent error on `-sun3' and `-target sun3' options.  */\n@@ -81,7 +74,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n  (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\t\\\n   || !strcmp (STR, \"imacros\") || !strcmp (STR, \"target\")\t\\\n-  || !strcmp (STR, \"assert\"))\n+  || !strcmp (STR, \"assert\") || !strcmp (STR, \"aux-info\"))\n \n /* -m68000 requires special flags to the assembler.  */\n \n@@ -167,14 +160,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Allow folding division by zero.  */\n #define REAL_INFINITY\n \n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+\n /* This is how to output an assembler line defining a `double' constant.  */\n \n #undef ASM_OUTPUT_DOUBLE\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n       fprintf (FILE, \"\\t.double 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n-    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+    else if (REAL_VALUE_ISNAN (VALUE))\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunion { double d; long l[2];} t;\t\t\t\t\\\n \tt.d = (VALUE);\t\t\t\t\t\t\t\\\n@@ -191,7 +187,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n   {\t\t\t\t\t\t\t\t\t\\\n     if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n       fprintf (FILE, \"\\t.single 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n-    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+    else if (REAL_VALUE_ISNAN (VALUE))\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tunion { float f; long l;} t;\t\t\t\t\t\\\n \tt.f = (VALUE);\t\t\t\t\t\t\t\\"}, {"sha": "77328f13ab6880df8486f06780f0d9bdba13ec23", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3865ca9f8e364d81427c6177a3301c1e0620e0d/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3865ca9f8e364d81427c6177a3301c1e0620e0d/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=b3865ca9f8e364d81427c6177a3301c1e0620e0d", "patch": "@@ -72,7 +72,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n    there are no such switches except those implemented by GCC itself.  */\n \n #define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\\\n- (!strcmp (STR, \"include\") || !strcmp (STR, \"imacros\"))\n+ (!strcmp (STR, \"include\") || !strcmp (STR, \"imacros\")\t\\\n+  || !strcmp (STR, \"aux-info\"))\n \n /* You should redefine CPP_PREDEFINES in any file which includes this one.\n    The definition should be appropriate for the type of target system\n@@ -249,6 +250,8 @@ do {\t\t\t\t \t\t\t\t\\\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE BITS_PER_WORD\n \n+#define MULTIBYTE_CHARS\n+\n #undef ASM_BYTE_OP\n #define ASM_BYTE_OP\t\"\\t.byte\"\n \n@@ -303,20 +306,20 @@ do {\t\t\t\t\t\t\t\t\t\\\n    the linker seems to want the alignment of data objects\n    to depend on their types.  We do exactly that here.  */\n \n-#define BSS_ASM_OP\t\"\\t.bss\"\n+#define BSS_ASM_OP\t\".bss\"\n \n #undef ASM_OUTPUT_ALIGNED_LOCAL\n #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"%s\\t%s,%u,%u\\n\",\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t%s,%u,%u\\n\",\t\t\t\t\t\\\n \t   BSS_ASM_OP, (NAME), (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n } while (0)\n \n /* This is the pseudo-op used to generate a 32-bit word of data with a\n    specific value in some section.  This is the same for all known svr4\n    assemblers.  */\n \n-#define INT_ASM_OP\t\t\"\\t.long\\t\"\n+#define INT_ASM_OP\t\t\".long\"\n \n /* This is the pseudo-op used to generate a contiguous sequence of byte\n    values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n@@ -335,17 +338,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define USE_CONST_SECTION\t1\n \n-#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"a\\\",@progbits\\n\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"a\\\",@progbits\\n\"\n+#define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"a\\\",@progbits\"\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"a\\\",@progbits\"\n \n /* On svr4, we *do* have support for the .init section, and we can put\n    stuff in there to be executed before `main'.  We let crtstuff.c and\n    other files know this by defining the following symbol.  The definition\n    says how to change sections to the .init section.  This is the same\n    for all know svr4 assemblers.  */\n \n-#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n+#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n \n /* A default list of other sections which we might be \"in\" at any given\n    time.  For targets that use additional sections (e.g. .tdesc) you\n@@ -409,7 +412,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     ctors_section ();\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n     assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n   } while (0)\n@@ -419,7 +422,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     dtors_section ();                   \t\t\t\t\\\n-    fprintf (FILE, \"%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n     assemble_name (FILE, NAME);              \t\t\t\t\\\n     fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n   } while (0)\n@@ -465,8 +468,8 @@ dtors_section ()\t\t\t\t\t\t\t\\\n    different pseudo-op names for these, they may be overridden in the\n    file which includes this one.  */\n \n-#define TYPE_ASM_OP\t\"\\t.type\"\n-#define SIZE_ASM_OP\t\"\\t.size\"\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n \n /* The following macro defines the format used to output the second\n    operand of the .type assembler directive.  Different svr4 assemblers\n@@ -484,7 +487,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n     assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n     putc (',', FILE);\t\t\t\t\t\t\t\\\n     fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n@@ -496,14 +499,14 @@ dtors_section ()\t\t\t\t\t\t\t\\\n \n #define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n     assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n     putc (',', FILE);\t\t\t\t\t\t\t\\\n     fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n     putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n     if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n \tassemble_name (FILE, NAME);\t\t\t\t\t\\\n \tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (decl)));\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n@@ -521,7 +524,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n \tlabelno++;\t\t\t\t\t\t\t\\\n \tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n \tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n-\tfprintf (FILE, \"%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n \tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n         fprintf (FILE, \",\");\t\t\t\t\t\t\\\n \tassemble_name (FILE, label);\t\t\t\t\t\\"}, {"sha": "16eda227e47eee85ea01b4e194ee11c7cd195fb9", "filename": "gcc/gcc.c", "status": "modified", "additions": 172, "deletions": 6, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3865ca9f8e364d81427c6177a3301c1e0620e0d/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3865ca9f8e364d81427c6177a3301c1e0620e0d/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=b3865ca9f8e364d81427c6177a3301c1e0620e0d", "patch": "@@ -124,6 +124,13 @@ static int cross_compile = 0;\n \n static struct obstack obstack;\n \n+/* This is the obstack to build an environment variable to pass to\n+   collect2 that describes all of the relavant switches of what to\n+   pass the compiler in building the list of pointers to constructors\n+   and destructors.  */\n+\n+static struct obstack collect_obstack;\n+\n extern char *version_string;\n \n static void set_spec ();\n@@ -237,6 +244,8 @@ or with constant text in a single argument.\n  %{|!S:X} like %{!S:X}, but if there is an S switch, substitute `-'.\n  %{.S:X} substitutes X, but only if processing a file with suffix S.\n  %{!.S:X} substitutes X, but only if NOT processing a file with suffix S.\n+ %(Spec) processes a specification defined in a specs file as *Spec:\n+ %[Spec] as above, but put __ around -D arguments\n \n The conditional text X in a %{S:X} or %{!S:X} construct may contain\n other nested % constructs or spaces, or even newlines.  They are\n@@ -352,7 +361,7 @@ static char *switches_need_spaces = SWITCHES_NEED_SPACES;\n #ifndef WORD_SWITCH_TAKES_ARG\n #define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\\\n  (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\\\n-  || !strcmp (STR, \"imacros\"))\n+  || !strcmp (STR, \"imacros\") || !strcmp (STR, \"aux-info\"))\n #endif\n \f\n /* Record the mapping from file suffixes for compilation specs.  */\n@@ -399,6 +408,7 @@ static struct compiler default_compilers[] =\n \t\t   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a}\\\n \t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} \\\n \t\t   %{traditional} %{v:-version} %{pg:-p} %{p} %{f*}\\\n+\t\t   %{aux-info*}\\\n \t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n               %{!S:as %{R} %{j} %{J} %{h} %{d2} %a \\\n@@ -431,6 +441,7 @@ static struct compiler default_compilers[] =\n \t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} \\\n \t\t   %{traditional} %{v:-version} %{pg:-p} %{p} %{f*} \\\n     \t\t   -lang-objc %{gen-decls} \\\n+\t\t   %{aux-info*}\\\n \t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n               %{!S:as %{R} %{j} %{J} %{h} %{d2} %a \\\n@@ -465,6 +476,7 @@ static struct compiler default_compilers[] =\n \t\t   %{!Q:-quiet} -dumpbase %b.cc %{d*} %{m*} %{a}\\\n \t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} %{traditional}\\\n \t\t   %{v:-version} %{pg:-p} %{p} %{f*}\\\n+\t\t   %{aux-info*}\\\n \t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n               %{!S:as %{R} %{j} %{J} %{h} %{d2} %a \\\n@@ -475,6 +487,7 @@ static struct compiler default_compilers[] =\n    \"cc1 %i %1 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n \t%{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} %{traditional}\\\n \t%{v:-version} %{pg:-p} %{p} %{f*}\\\n+\t%{aux-info*}\\\n \t%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t%{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n     %{!S:as %{R} %{j} %{J} %{h} %{d2} %a \\\n@@ -484,6 +497,7 @@ static struct compiler default_compilers[] =\n    \"cc1plus %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n \t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} %{traditional}\\\n \t    %{v:-version} %{pg:-p} %{p} %{f*}\\\n+\t    %{aux-info*}\\\n \t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n        %{!S:as %{R} %{j} %{J} %{h} %{d2} %a \\\n@@ -528,7 +542,7 @@ static char *link_command_spec = \"\\\n /* Use -l and have the linker do the search.  */\n static char *link_command_spec = \"\\\n %{!c:%{!M:%{!MM:%{!E:%{!S:ld %X %l %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} \\\n-\t\t\t%{r} %{T*} %{t} %{x} %{z}\\\n+\t\t\t%{r} %{s} %{T*} %{t} %{x} %{z}\\\n \t\t\t%{!A:%{!nostdlib:%S}} \\\n \t\t\t%{L*} %D %o %{!nostdlib:-lgcc %L -lgcc %{!A:%E}}\\n }}}}}\";\n #endif\n@@ -620,7 +634,6 @@ read_specs (filename)\n \t  else if (in[0] == '#')\n \t    {\n \t      while (*in && *in != '\\n') in++;\n-\t      if (*in) in++;\n \t    }\n \t  else\n \t    *out++ = *in++;\n@@ -678,7 +691,7 @@ skip_whitespace (p)\n }\n \f\n /* Structure to keep track of the specs that have been defined so far.  These\n-   are accessed using %Sspecname in a compiler or link spec. */\n+   are accessed using %(specname) or %[specname] in a compiler or link spec. */\n \n struct spec_list\n {\n@@ -1045,6 +1058,103 @@ choose_temp_base ()\n   mktemp (temp_filename);\n   temp_filename_length = strlen (temp_filename);\n }\n+\f\n+\n+/* Routine to add variables to the environment.  We do this to pass\n+   the pathname of the gcc driver, and the directories search to the\n+   collect2 program, which is being run as ld.  This way, we can be\n+   sure of executing the right compiler when collect2 wants to build\n+   constructors and destructors.  Since the environment variables we\n+   use come from an obstack, we don't have to worry about allocating\n+   space for them.  */\n+\n+#ifndef HAVE_PUTENV\n+\n+putenv (str)\n+     char *str;\n+{\n+#ifndef __MSDOS__\t\t/* not sure about MS/DOS */\n+#ifndef VMS\t\t\t/* nor about VMS */\n+\n+  extern char **environ;\n+  char **old_environ = environ;\n+  char **envp;\n+  int num_envs = 0;\n+  int name_len = 1;\n+  int str_len = strlen (str);\n+  char *p = str;\n+  int ch;\n+\n+  while ((ch = *p++) != '\\0' && ch != '=')\n+    name_len++;\n+\n+  if (!ch)\n+    abort ();\n+\n+  /* Search for replacing an existing environment variable, and\n+     count the number of total environment variables.  */\n+  for (envp = old_environ; *envp; envp++)\n+    {\n+      num_envs++;\n+      if (!strncmp (str, *envp, name_len))\n+\t{\n+\t  *envp = str;\n+\t  return;\n+\t}\n+    }\n+\n+  /* Add a new environment variable */\n+  environ = (char **) xmalloc (sizeof (char *) * (num_envs+2));\n+  *environ = str;\n+  bcopy (old_environ, environ+1, sizeof (char *) * (num_envs+1));\n+\n+#endif\t/* VMS */\n+#endif\t/* __MSDOS__ */\n+}\n+\n+#endif\t/* HAVE_PUTENV */\n+\n+\f\n+/* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables for collect.  */\n+\n+static void\n+putenv_from_prefixes (paths, env_var)\n+     struct path_prefix *paths;\n+     char *env_var;\n+{\n+  int suffix_len = (machine_suffix) ? strlen (machine_suffix) : 0;\n+  int first_time = TRUE;\n+  struct prefix_list *pprefix;\n+\n+  obstack_grow (&collect_obstack, env_var, strlen (env_var));\n+\n+  for (pprefix = paths->plist; pprefix != 0; pprefix = pprefix->next)\n+    {\n+      int len = strlen (pprefix->prefix);\n+\n+      if (machine_suffix)\n+\t{\n+\t  if (!first_time)\n+\t    obstack_grow (&collect_obstack, \":\", 1);\n+\t    \n+\t  first_time = FALSE;\n+\t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n+\t  obstack_grow (&collect_obstack, machine_suffix, suffix_len);\n+\t}\n+\n+      if (!pprefix->require_machine_suffix)\n+\t{\n+\t  if (!first_time)\n+\t    obstack_grow (&collect_obstack, \":\", 1);\n+\n+\t  first_time = FALSE;\n+\t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n+\t}\n+    }\n+  obstack_grow (&collect_obstack, \"\\0\", 1);\n+  putenv (obstack_finish (&collect_obstack));\n+}\n+\n \f\n /* Search for NAME using the prefix list PREFIXES.  MODE is passed to\n    access to check permissions.\n@@ -1427,7 +1537,7 @@ execute ()\n \n   /* If -v, print what we are about to do, and maybe query.  */\n \n-  if (verbose_flag || save_temps_flag)\n+  if (verbose_flag)\n     {\n       /* Print each piped command as a separate line.  */\n       for (i = 0; i < n_commands ; i++)\n@@ -2508,6 +2618,10 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      do_spec_1 (buf, 0, NULL);\n \t\t    }\n \t\t}\n+\n+\t      /* Discard the closing paren or bracket.  */\n+\t      if (*p)\n+\t\tp++;\n \t    }\n \t    break;\n \n@@ -2622,7 +2736,7 @@ handle_braces (p)\n \n \t  /* First see whether we have %*.  */\n \t  substitution = 0;\n-\t  while (*r && *r == '}')\n+\t  while (r < q)\n \t    {\n \t      if (*r == '%' && r[1] == '*')\n \t\tsubstitution = 1;\n@@ -2828,6 +2942,13 @@ main (argc, argv)\n \n   obstack_init (&obstack);\n \n+  /* Set up to remember the pathname of gcc and any options\n+     needed for collect.  */\n+  obstack_init (&collect_obstack);\n+  obstack_grow (&collect_obstack, \"COLLECT_GCC=\", sizeof (\"COLLECT_GCC=\")-1);\n+  obstack_grow (&collect_obstack, programname, strlen (programname)+1);\n+  putenv (obstack_finish (&collect_obstack));\n+\n   /* Choose directory for temp files.  */\n \n   choose_temp_base ();\n@@ -2983,6 +3104,40 @@ main (argc, argv)\n   if (error_count == 0)\n     {\n       int tmp = execution_count;\n+      int i;\n+      int first_time;\n+\n+      /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\n+\t for collect.  */\n+      putenv_from_prefixes (&exec_prefix, \"COMPILER_PATH=\");\n+      putenv_from_prefixes (&startfile_prefix, \"LIBRARY_PATH=\");\n+\n+      /* Build COLLECT_GCC_OPTIONS to have all of the options specified to\n+\t the compiler.  */\n+      obstack_grow (&collect_obstack, \"COLLECT_GCC_OPTIONS=\",\n+\t\t    sizeof (\"COLLECT_GCC_OPTIONS=\")-1);\n+\n+      first_time = TRUE;\n+      for (i = 0; i < n_switches; i++)\n+\t{\n+\t  char **args;\n+\t  if (!first_time)\n+\t    obstack_grow (&collect_obstack, \" \", 1);\n+\n+\t  first_time = FALSE;\n+\t  obstack_grow (&collect_obstack, \"-\", 1);\n+\t  obstack_grow (&collect_obstack, switches[i].part1,\n+\t\t\tstrlen (switches[i].part1));\n+\n+\t  for (args = switches[i].args; args && *args; args++)\n+\t    {\n+\t      obstack_grow (&collect_obstack, \" \", 1);\n+\t      obstack_grow (&collect_obstack, *args, strlen (*args));\n+\t    }\n+\t}\n+      obstack_grow (&collect_obstack, \"\\0\", 1);\n+      putenv (obstack_finish (&collect_obstack));\n+\n       value = do_spec (link_command_spec);\n       if (value < 0)\n \terror_count = 1;\n@@ -3236,6 +3391,7 @@ validate_all_switches ()\n   struct compiler *comp;\n   register char *p;\n   register char c;\n+  struct spec_list *spec;\n \n   for (comp = compilers; comp->spec; comp++)\n     {\n@@ -3246,6 +3402,16 @@ validate_all_switches ()\n \t  validate_switches (p + 1);\n     }\n \n+  /* look through the linked list of extra specs read from the specs file */\n+  for (spec = specs ; spec ; spec = spec->next)\n+    {\n+      p = spec->spec;\n+      while (c = *p++)\n+\tif (c == '%' && *p == '{')\n+\t  /* We have a switch spec.  */\n+\t  validate_switches (p + 1);\n+    }\n+\n   p = link_command_spec;\n   while (c = *p++)\n     if (c == '%' && *p == '{')"}]}