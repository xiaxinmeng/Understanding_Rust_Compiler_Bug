{"sha": "150655ee3f7d67672e2cc809f8abe56923491c62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwNjU1ZWUzZjdkNjc2NzJlMmNjODA5ZjhhYmU1NjkyMzQ5MWM2Mg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-09-04T14:52:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-09-04T14:52:41Z"}, "message": "wide-int-range.cc (wide_int_range_convert): New.\n\n\t* wide-int-range.cc (wide_int_range_convert): New.\n\t* wide-int-range.h (wide_int_range_convert): New.\n\t* tree-vrp.c (extract_range_from_unary_expr): Abstract wide int\n\tcode into wide_int_range_convert.\n\t(extract_range_into_wide_ints): Do not munge anti range constants\n\tinto the entire domain.  Just return the range back.\n\nFrom-SVN: r264085", "tree": {"sha": "fab8d76e903fd48987f1fdd63ff2b52124196a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fab8d76e903fd48987f1fdd63ff2b52124196a9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/150655ee3f7d67672e2cc809f8abe56923491c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150655ee3f7d67672e2cc809f8abe56923491c62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150655ee3f7d67672e2cc809f8abe56923491c62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150655ee3f7d67672e2cc809f8abe56923491c62/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fcfe0474aed3d43f16d14c92216ec68f35895fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcfe0474aed3d43f16d14c92216ec68f35895fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fcfe0474aed3d43f16d14c92216ec68f35895fd"}], "stats": {"total": 123, "additions": 86, "deletions": 37}, "files": [{"sha": "9b0d2d11771c573a56f5b8e30381d9be42fb9195", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=150655ee3f7d67672e2cc809f8abe56923491c62", "patch": "@@ -1,3 +1,12 @@\n+2018-09-04  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* wide-int-range.cc (wide_int_range_convert): New.\n+\t* wide-int-range.h (wide_int_range_convert): New.\n+\t* tree-vrp.c (extract_range_from_unary_expr): Abstract wide int\n+\tcode into wide_int_range_convert.\n+\t(extract_range_into_wide_ints): Do not munge anti range constants\n+\tinto the entire domain.  Just return the range back.\n+\n 2018-09-04  Martin Liska  <mliska@suse.cz>\n \n \t* genmatch.c (output_line_directive): Add new argument"}, {"sha": "8f16713300c8db25732b430ca1c968fc03c95ed9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=150655ee3f7d67672e2cc809f8abe56923491c62", "patch": "@@ -995,15 +995,18 @@ ranges_from_anti_range (const value_range *ar,\n /* Extract the components of a value range into a pair of wide ints in\n    [WMIN, WMAX].\n \n-   If the value range is anything but a VR_RANGE of constants, the\n+   If the value range is anything but a VR_*RANGE of constants, the\n    resulting wide ints are set to [-MIN, +MAX] for the type.  */\n \n static void inline\n extract_range_into_wide_ints (const value_range *vr,\n \t\t\t      signop sign, unsigned prec,\n \t\t\t      wide_int &wmin, wide_int &wmax)\n {\n-  if (range_int_cst_p (vr))\n+  if ((vr->type == VR_RANGE\n+       || vr->type == VR_ANTI_RANGE)\n+      && TREE_CODE (vr->min) == INTEGER_CST\n+      && TREE_CODE (vr->max) == INTEGER_CST)\n     {\n       wmin = wi::to_wide (vr->min);\n       wmax = wi::to_wide (vr->max);\n@@ -1850,44 +1853,41 @@ extract_range_from_unary_expr (value_range *vr,\n \t  return;\n \t}\n \n-      /* If VR0 is varying and we increase the type precision, assume\n-\t a full range for the following transformation.  */\n-      if (vr0.type == VR_VARYING\n-\t  && INTEGRAL_TYPE_P (inner_type)\n-\t  && TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type))\n-\t{\n-\t  vr0.type = VR_RANGE;\n-\t  vr0.min = TYPE_MIN_VALUE (inner_type);\n-\t  vr0.max = TYPE_MAX_VALUE (inner_type);\n-\t}\n-\n-      /* If VR0 is a constant range or anti-range and the conversion is\n-\t not truncating we can convert the min and max values and\n-\t canonicalize the resulting range.  Otherwise we can do the\n-\t conversion if the size of the range is less than what the\n-\t precision of the target type can represent and the range is\n-\t not an anti-range.  */\n-      if ((vr0.type == VR_RANGE\n-\t   || vr0.type == VR_ANTI_RANGE)\n+      /* We normalize everything to a VR_RANGE, but for constant\n+\t anti-ranges we must handle them by leaving the final result\n+\t as an anti range.  This allows us to convert things like\n+\t ~[0,5] seamlessly.  */\n+      value_range_type vr_type = VR_RANGE;\n+      if (vr0.type == VR_ANTI_RANGE\n \t  && TREE_CODE (vr0.min) == INTEGER_CST\n-\t  && TREE_CODE (vr0.max) == INTEGER_CST\n-\t  && (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n-\t      || (vr0.type == VR_RANGE\n-\t\t  && integer_zerop (int_const_binop (RSHIFT_EXPR,\n-\t\t       int_const_binop (MINUS_EXPR, vr0.max, vr0.min),\n-\t\t         size_int (TYPE_PRECISION (outer_type)))))))\n+\t  && TREE_CODE (vr0.max) == INTEGER_CST)\n+\tvr_type = VR_ANTI_RANGE;\n+\n+      /* NOTES: Previously we were returning VARYING for all symbolics, but\n+\t we can do better by treating them as [-MIN, +MAX].  For\n+\t example, converting [SYM, SYM] from INT to LONG UNSIGNED,\n+\t we can return: ~[0x8000000, 0xffffffff7fffffff].\n+\n+\t We were also failing to convert ~[0,0] from char* to unsigned,\n+\t instead choosing to return VR_VARYING.  Now we return ~[0,0].  */\n+      wide_int vr0_min, vr0_max, wmin, wmax;\n+      signop inner_sign = TYPE_SIGN (inner_type);\n+      signop outer_sign = TYPE_SIGN (outer_type);\n+      unsigned inner_prec = TYPE_PRECISION (inner_type);\n+      unsigned outer_prec = TYPE_PRECISION (outer_type);\n+      extract_range_into_wide_ints (&vr0, inner_sign, inner_prec,\n+\t\t\t\t    vr0_min, vr0_max);\n+      if (wide_int_range_convert (wmin, wmax,\n+\t\t\t\t  inner_sign, inner_prec,\n+\t\t\t\t  outer_sign, outer_prec,\n+\t\t\t\t  vr0_min, vr0_max))\n \t{\n-\t  tree new_min, new_max;\n-\t  new_min = force_fit_type (outer_type, wi::to_widest (vr0.min),\n-\t\t\t\t    0, false);\n-\t  new_max = force_fit_type (outer_type, wi::to_widest (vr0.max),\n-\t\t\t\t    0, false);\n-\t  set_and_canonicalize_value_range (vr, vr0.type,\n-\t\t\t\t\t    new_min, new_max, NULL);\n-\t  return;\n+\t  tree min = wide_int_to_tree (outer_type, wmin);\n+\t  tree max = wide_int_to_tree (outer_type, wmax);\n+\t  set_and_canonicalize_value_range (vr, vr_type, min, max, NULL);\n \t}\n-\n-      set_value_range_to_varying (vr);\n+      else\n+\tset_value_range_to_varying (vr);\n       return;\n     }\n   else if (code == ABS_EXPR)"}, {"sha": "8a3dfd256845f74ba2cd1c4f366365c6b3cef020", "filename": "gcc/wide-int-range.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2Fwide-int-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2Fwide-int-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.cc?ref=150655ee3f7d67672e2cc809f8abe56923491c62", "patch": "@@ -735,6 +735,39 @@ wide_int_range_abs (wide_int &min, wide_int &max,\n   return true;\n }\n \n+/* Convert range in [VR0_MIN, VR0_MAX] with INNER_SIGN and INNER_PREC,\n+   to a range in [MIN, MAX] with OUTER_SIGN and OUTER_PREC.\n+\n+   Return TRUE if we were able to successfully calculate the new range.\n+\n+   Caller is responsible for canonicalizing the resulting range.  */\n+\n+bool\n+wide_int_range_convert (wide_int &min, wide_int &max,\n+\t\t\tsignop inner_sign,\n+\t\t\tunsigned inner_prec,\n+\t\t\tsignop outer_sign,\n+\t\t\tunsigned outer_prec,\n+\t\t\tconst wide_int &vr0_min,\n+\t\t\tconst wide_int &vr0_max)\n+{\n+  /* If the conversion is not truncating we can convert the min and\n+     max values and canonicalize the resulting range.  Otherwise we\n+     can do the conversion if the size of the range is less than what\n+     the precision of the target type can represent.  */\n+  if (outer_prec >= inner_prec\n+      || wi::rshift (wi::sub (vr0_max, vr0_min),\n+\t\t     wi::uhwi (outer_prec, inner_prec),\n+\t\t     inner_sign) == 0)\n+    {\n+      min = wide_int::from (vr0_min, outer_prec, inner_sign);\n+      max = wide_int::from (vr0_max, outer_prec, inner_sign);\n+      return (!wi::eq_p (min, wi::min_value (outer_prec, outer_sign))\n+\t      || !wi::eq_p (max, wi::max_value (outer_prec, outer_sign)));\n+    }\n+  return false;\n+}\n+\n /* Calculate a division operation on two ranges and store the result in\n    [WMIN, WMAX] U [EXTRA_MIN, EXTRA_MAX].\n "}, {"sha": "589fdea4df696322e05123398f06b63e27edc538", "filename": "gcc/wide-int-range.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2Fwide-int-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150655ee3f7d67672e2cc809f8abe56923491c62/gcc%2Fwide-int-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.h?ref=150655ee3f7d67672e2cc809f8abe56923491c62", "patch": "@@ -109,6 +109,13 @@ extern bool wide_int_range_abs (wide_int &min, wide_int &max,\n \t\t\t\tconst wide_int &vr0_min,\n \t\t\t\tconst wide_int &vr0_max,\n \t\t\t\tbool overflow_undefined);\n+extern bool wide_int_range_convert (wide_int &min, wide_int &max,\n+\t\t\t\t    signop inner_sign,\n+\t\t\t\t    unsigned inner_prec,\n+\t\t\t\t    signop outer_sign,\n+\t\t\t\t    unsigned outer_prec,\n+\t\t\t\t    const wide_int &vr0_min,\n+\t\t\t\t    const wide_int &vr0_max);\n extern bool wide_int_range_div (wide_int &wmin, wide_int &wmax,\n \t\t\t\tenum tree_code code,\n \t\t\t\tsignop sign, unsigned prec,"}]}