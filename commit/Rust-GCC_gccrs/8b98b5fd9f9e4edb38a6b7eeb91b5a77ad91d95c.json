{"sha": "8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5OGI1ZmQ5ZjllNGVkYjM4YTZiN2VlYjkxYjVhNzdhZDkxZDk1Yw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2012-11-15T21:24:22Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2012-11-15T21:24:22Z"}, "message": "Add support for sparc fused compare-and-branch.\n\ngcc/\n\n2012-11-15  David S. Miller  <davem@davemloft.net>\n\n\t* configure.ac: Add check for assembler SPARC4 instruction\n\tsupport.\n\t* configure: Rebuild.\n\t* config.in: Add HAVE_AS_SPARC4 section.\n\t* config/sparc/sparc.opt (mcbcond): New option.\n\t* doc/invoke.texi: Document it.\n\t* config/sparc/constraints.md: New constraint 'A' for 5-bit signed\n\timmediates.\n\t* doc/md.texi: Document it.\n\t* config/sparc/sparc.c (dump_target_flag_bits): Handle MASK_CBCOND.\n\t(sparc_option_override): Likewise.\n\t(emit_cbcond_insn): New function.\n\t(emit_conditional_branch_insn): Call it.\n\t(emit_cbcond_nop): New function.\n\t(output_ubranch): Use cbcond, remove label arg.\n\t(output_cbcond): New function.\n\t* config/sparc/sparc-protos.h (output_ubranch): Update.\n\t(output_cbcond): Declare it.\n\t(emit_cbcond_nop): Likewise.\n\t* config/sparc/sparc.md (type attribute): New types 'cbcond'\n\tand uncond_cbcond.\n\t(emit_cbcond_nop): New attribute.\n\t(length attribute): Handle cbcond and uncond_cbcond.\n\t(in_call_delay attribute): Reject cbcond and uncond_cbcond.\n\t(in_branch_delay attribute): Likewise.\n\t(in_uncond_branch_delay attribute): Likewise.\n\t(in_annul_branch_delay attribute): Likewise.\n\t(*cbcond_sp32, *cbcond_sp64): New insn patterns.\n\t(jump): Rewrite into an expander.\n\t(*jump_ubranch, *jump_cbcond): New patterns.\n\t* config/sparc/niagara4.md: Match 'cbcond' in 'n4_cti'.\n\t* config/sparc/sparc.h (AS_NIAGARA4_FLAG): New macro, use it\n\twhen target default is niagara4.\n\t(SPARC_SIMM5_P): Define.\n\t* config/sparc/sol2.h (AS_SPARC64_FLAG): Adjust.\n\t(AS_SPARC32_FLAG): Define.\n\t(ASM_CPU32_DEFAULT_SPEC, ASM_CPU64_DEFAULT_SPEC): Use\n\tAS_NIAGARA4_FLAG as needed.\n\nFrom-SVN: r193543", "tree": {"sha": "f03d2f8dce9c22de2316eabb57bfd128e7c91f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f03d2f8dce9c22de2316eabb57bfd128e7c91f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2bf33cdb91a46f5c8ead75a57ec11766f8e6863e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf33cdb91a46f5c8ead75a57ec11766f8e6863e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf33cdb91a46f5c8ead75a57ec11766f8e6863e"}], "stats": {"total": 583, "additions": 521, "deletions": 62}, "files": [{"sha": "9abd396b4bfff493964d47f40be722f351c739a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -1,3 +1,44 @@\n+2012-11-15  David S. Miller  <davem@davemloft.net>\n+\n+\t* configure.ac: Add check for assembler SPARC4 instruction\n+\tsupport.\n+\t* configure: Rebuild.\n+\t* config.in: Add HAVE_AS_SPARC4 section.\n+\t* config/sparc/sparc.opt (mcbcond): New option.\n+\t* doc/invoke.texi: Document it.\n+\t* config/sparc/constraints.md: New constraint 'A' for 5-bit signed\n+\timmediates.\n+\t* doc/md.texi: Document it.\n+\t* config/sparc/sparc.c (dump_target_flag_bits): Handle MASK_CBCOND.\n+\t(sparc_option_override): Likewise.\n+\t(emit_cbcond_insn): New function.\n+\t(emit_conditional_branch_insn): Call it.\n+\t(emit_cbcond_nop): New function.\n+\t(output_ubranch): Use cbcond, remove label arg.\n+\t(output_cbcond): New function.\n+\t* config/sparc/sparc-protos.h (output_ubranch): Update.\n+\t(output_cbcond): Declare it.\n+\t(emit_cbcond_nop): Likewise.\n+\t* config/sparc/sparc.md (type attribute): New types 'cbcond'\n+\tand uncond_cbcond.\n+\t(emit_cbcond_nop): New attribute.\n+\t(length attribute): Handle cbcond and uncond_cbcond.\n+\t(in_call_delay attribute): Reject cbcond and uncond_cbcond.\n+\t(in_branch_delay attribute): Likewise.\n+\t(in_uncond_branch_delay attribute): Likewise.\n+\t(in_annul_branch_delay attribute): Likewise.\n+\t(*cbcond_sp32, *cbcond_sp64): New insn patterns.\n+\t(jump): Rewrite into an expander.\n+\t(*jump_ubranch, *jump_cbcond): New patterns.\n+\t* config/sparc/niagara4.md: Match 'cbcond' in 'n4_cti'.\n+\t* config/sparc/sparc.h (AS_NIAGARA4_FLAG): New macro, use it\n+\twhen target default is niagara4.\n+\t(SPARC_SIMM5_P): Define.\n+\t* config/sparc/sol2.h (AS_SPARC64_FLAG): Adjust.\n+\t(AS_SPARC32_FLAG): Define.\n+\t(ASM_CPU32_DEFAULT_SPEC, ASM_CPU64_DEFAULT_SPEC): Use\n+\tAS_NIAGARA4_FLAG as needed.\n+\n 2012-11-15  Steve Ellcey  <sellcey@mips.com>\n \n \t* expr.c (expand_cond_expr_using_cmove): Use promoted mode for temp."}, {"sha": "7038906340199a41ba5938f93a6db4375b3ab81c", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -266,6 +266,12 @@\n #endif\n \n \n+/* Define if your assembler supports SPARC4 instructions. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_SPARC4\n+#endif\n+\n+\n /* Define if your assembler supports fprnd. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_FPRND"}, {"sha": "525e3ac77b45ae2fe54efe993708b0103bb39b29", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -18,7 +18,7 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;;; Unused letters:\n-;;;    AB\n+;;;     B\n ;;;    a        jkl    q  tuv xyz\n \n \n@@ -58,6 +58,11 @@\n \n ;; Integer constant constraints\n \n+(define_constraint \"A\"\n+ \"Signed 5-bit integer constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_SIMM5_P (ival)\")))\n+\n (define_constraint \"H\"\n  \"Valid operand of double arithmetic operation\"\n  (and (match_code \"const_double\")"}, {"sha": "26f2391377272f1f49a608d9605d49edddd15166", "filename": "gcc/config/sparc/niagara4.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fniagara4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fniagara4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara4.md?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -54,10 +54,10 @@\n     (eq_attr \"type\" \"store,fpstore\"))\n   \"(n4_slot0 | n4_slot2) + n4_load_store\")\n \n-(define_insn_reservation \"n4_cti\" 2\n+(define_insn_reservation \"n4_cti\" 1\n   (and (eq_attr \"cpu\" \"niagara4\")\n-    (eq_attr \"type\" \"branch,call,sibcall,call_no_delay_slot,uncond_branch,return\"))\n-  \"n4_slot1, nothing\")\n+    (eq_attr \"type\" \"cbcond,uncond_cbcond,branch,call,sibcall,call_no_delay_slot,uncond_branch,return\"))\n+  \"n4_slot1\")\n \n (define_insn_reservation \"n4_fp\" 11\n   (and (eq_attr \"cpu\" \"niagara4\")"}, {"sha": "b64e10919dd21848d1c06db3cdcc15d674a3e139", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -391,6 +391,14 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"uns_small_int_operand\")))\n \n+;; Return true if OP is a register, or is a CONST_INT that can fit in a\n+;; signed 5-bit immediate field.  This is an acceptable second operand for\n+;; the cbcond instructions.\n+(define_predicate \"arith5_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+            (match_test \"SPARC_SIMM5_P (INTVAL (op))\"))))\n+\n \n ;; Predicates for miscellaneous instructions.\n "}, {"sha": "25ff347365084b9dc005a6ca383bcefcd11fbd8a", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -54,19 +54,56 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Supposedly the same as vanilla sparc svr4, except for the stuff below: */\n \n-/* This is here rather than in sparc.h because it's not known what\n-   other assemblers will accept.  */\n+/* If the assembler supports -xarch=sparc4, we switch to the explicit\n+   word size selection mechanism available both in GNU as and Sun as,\n+   for the Niagara4 and above configurations.  */\n+#ifdef HAVE_AS_SPARC4\n+\n+#define AS_SPARC32_FLAG \"\"\n+#define AS_SPARC64_FLAG \"\"\n \n #ifndef USE_GAS\n-#define AS_SPARC64_FLAG\t\"-xarch=v9\"\n-#else\n-#define AS_SPARC64_FLAG\t\"-TSO -64 -Av9\"\n+#undef ASM_ARCH32_SPEC\n+#define ASM_ARCH32_SPEC \"-m32\"\n+#undef ASM_ARCH64_SPEC\n+#define ASM_ARCH64_SPEC \"-m64\"\n #endif\n \n+/* Both Sun as and GNU as understand -K PIC.  */\n+#undef ASM_SPEC\n+#define ASM_SPEC ASM_SPEC_BASE \" %(asm_arch)\" ASM_PIC_SPEC\n+\n+#else /* HAVE_AS_SPARC4 */\n+\n+#define AS_SPARC32_FLAG \"-xarch=v8plus\"\n+#define AS_SPARC64_FLAG \"-xarch=v9\"\n+\n+#undef AS_NIAGARA4_FLAG\n+#define AS_NIAGARA4_FLAG AS_NIAGARA3_FLAG\n+\n+#undef ASM_ARCH32_SPEC\n+#define ASM_ARCH32_SPEC \"\"\n+\n+#undef ASM_ARCH64_SPEC\n+#define ASM_ARCH64_SPEC \"\"\n+\n+#undef ASM_ARCH_DEFAULT_SPEC\n+#define ASM_ARCH_DEFAULT_SPEC \"\"\n+\n+#undef ASM_ARCH_SPEC\n+#define ASM_ARCH_SPEC \"\"\n+\n+/* Both Sun as and GNU as understand -K PIC.  */\n+#undef ASM_SPEC\n+#define ASM_SPEC ASM_SPEC_BASE ASM_PIC_SPEC\n+\n+#endif /* HAVE_AS_SPARC4 */\n+\n+\n #undef ASM_CPU32_DEFAULT_SPEC\n #define ASM_CPU32_DEFAULT_SPEC\t\"\"\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC\tAS_SPARC64_FLAG\n+#define ASM_CPU64_DEFAULT_SPEC\t\"-xarch=v9\"\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_v9\n #undef CPP_CPU64_DEFAULT_SPEC\n@@ -83,7 +120,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef ASM_CPU32_DEFAULT_SPEC\n #define ASM_CPU32_DEFAULT_SPEC \"-xarch=v8plusa\"\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG \"a\"\n+#define ASM_CPU64_DEFAULT_SPEC \"-xarch=v9a\"\n #undef ASM_CPU_DEFAULT_SPEC\n #define ASM_CPU_DEFAULT_SPEC ASM_CPU32_DEFAULT_SPEC\n #endif\n@@ -94,7 +131,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef ASM_CPU32_DEFAULT_SPEC\n #define ASM_CPU32_DEFAULT_SPEC \"-xarch=v8plusb\"\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG \"b\"\n+#define ASM_CPU64_DEFAULT_SPEC \"-xarch=v9b\"\n #undef ASM_CPU_DEFAULT_SPEC\n #define ASM_CPU_DEFAULT_SPEC ASM_CPU32_DEFAULT_SPEC\n #endif\n@@ -105,7 +142,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef ASM_CPU32_DEFAULT_SPEC\n #define ASM_CPU32_DEFAULT_SPEC \"-xarch=v8plusb\"\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG \"b\"\n+#define ASM_CPU64_DEFAULT_SPEC \"-xarch=v9b\"\n #undef ASM_CPU_DEFAULT_SPEC\n #define ASM_CPU_DEFAULT_SPEC ASM_CPU32_DEFAULT_SPEC\n #endif\n@@ -116,7 +153,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef ASM_CPU32_DEFAULT_SPEC\n #define ASM_CPU32_DEFAULT_SPEC \"-xarch=v8plusb\"\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG \"b\"\n+#define ASM_CPU64_DEFAULT_SPEC \"-xarch=v9b\"\n #undef ASM_CPU_DEFAULT_SPEC\n #define ASM_CPU_DEFAULT_SPEC ASM_CPU32_DEFAULT_SPEC\n #endif\n@@ -127,7 +164,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef ASM_CPU32_DEFAULT_SPEC\n #define ASM_CPU32_DEFAULT_SPEC \"-xarch=v8plus\" AS_NIAGARA3_FLAG\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA3_FLAG\n+#define ASM_CPU64_DEFAULT_SPEC \"-xarch=v9\" AS_NIAGARA3_FLAG\n #undef ASM_CPU_DEFAULT_SPEC\n #define ASM_CPU_DEFAULT_SPEC ASM_CPU32_DEFAULT_SPEC\n #endif\n@@ -136,17 +173,13 @@ along with GCC; see the file COPYING3.  If not see\n #undef CPP_CPU64_DEFAULT_SPEC\n #define CPP_CPU64_DEFAULT_SPEC \"\"\n #undef ASM_CPU32_DEFAULT_SPEC\n-#define ASM_CPU32_DEFAULT_SPEC \"-xarch=v8plus\" AS_NIAGARA3_FLAG\n+#define ASM_CPU32_DEFAULT_SPEC AS_SPARC32_FLAG AS_NIAGARA4_FLAG\n #undef ASM_CPU64_DEFAULT_SPEC\n-#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA3_FLAG\n+#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA4_FLAG\n #undef ASM_CPU_DEFAULT_SPEC\n #define ASM_CPU_DEFAULT_SPEC ASM_CPU32_DEFAULT_SPEC\n #endif\n \n-/* Both Sun as and GNU as understand -K PIC.  */\n-#undef ASM_SPEC\n-#define ASM_SPEC ASM_SPEC_BASE ASM_PIC_SPEC\n-\n #undef CPP_CPU_SPEC\n #define CPP_CPU_SPEC \"\\\n %{mcpu=sparclet|mcpu=tsc701:-D__sparclet__} \\\n@@ -235,29 +268,17 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #undef ASM_CPU_SPEC\n #define ASM_CPU_SPEC \"\\\n-%{mcpu=v9:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\") DEF_ARCH64_SPEC(AS_SPARC64_FLAG) \"} \\\n-%{mcpu=ultrasparc:\" DEF_ARCH32_SPEC(\"-xarch=v8plusa\") DEF_ARCH64_SPEC(AS_SPARC64_FLAG \"a\") \"} \\\n-%{mcpu=ultrasparc3:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(AS_SPARC64_FLAG \"b\") \"} \\\n-%{mcpu=niagara:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(AS_SPARC64_FLAG \"b\") \"} \\\n-%{mcpu=niagara2:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(AS_SPARC64_FLAG \"b\") \"} \\\n-%{mcpu=niagara3:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\" AS_NIAGARA3_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA3_FLAG) \"} \\\n-%{mcpu=niagara4:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\" AS_NIAGARA3_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA3_FLAG) \"} \\\n-%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:\" DEF_ARCH32_SPEC(\"-xarch=v8\") DEF_ARCH64_SPEC(AS_SPARC64_FLAG) \"}}}}}}}} \\\n+%{mcpu=v9:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\") DEF_ARCH64_SPEC(\"-xarch=v9\") \"} \\\n+%{mcpu=ultrasparc:\" DEF_ARCH32_SPEC(\"-xarch=v8plusa\") DEF_ARCH64_SPEC(\"-xarch=v9a\") \"} \\\n+%{mcpu=ultrasparc3:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(\"-xarch=v9b\") \"} \\\n+%{mcpu=niagara:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(\"-xarch=v9b\") \"} \\\n+%{mcpu=niagara2:\" DEF_ARCH32_SPEC(\"-xarch=v8plusb\") DEF_ARCH64_SPEC(\"-xarch=v9b\") \"} \\\n+%{mcpu=niagara3:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\" AS_NIAGARA3_FLAG) DEF_ARCH64_SPEC(\"-xarch=v9\" AS_NIAGARA3_FLAG) \"} \\\n+%{mcpu=niagara4:\" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA4_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA4_FLAG) \"} \\\n+%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:\" DEF_ARCH32_SPEC(\"-xarch=v8\") DEF_ARCH64_SPEC(\"-xarch=v9\") \"}}}}}}}} \\\n %{!mcpu*:%(asm_cpu_default)} \\\n \"\n \n-#undef ASM_ARCH32_SPEC\n-#define ASM_ARCH32_SPEC \"\"\n-\n-#undef ASM_ARCH64_SPEC\n-#define ASM_ARCH64_SPEC \"\"\n-\n-#undef ASM_ARCH_DEFAULT_SPEC\n-#define ASM_ARCH_DEFAULT_SPEC \"\"\n-\n-#undef ASM_ARCH_SPEC\n-#define ASM_ARCH_SPEC \"\"\n-\n #ifdef USE_GLD\n /* Since binutils 2.21, GNU ld supports new *_sol2 emulations to strictly\n    follow the Solaris 2 ABI.  Prefer them if present.  */"}, {"sha": "d5b2b1f4e81ecad7203bdc5c1362eb56b5ae5bde", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -71,18 +71,20 @@ extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);\n extern int sparc_splitdi_legitimate (rtx, rtx);\n extern int sparc_split_regreg_legitimate (rtx, rtx);\n extern int sparc_absnegfloat_split_legitimate (rtx, rtx);\n-extern const char *output_ubranch (rtx, int, rtx);\n+extern const char *output_ubranch (rtx, rtx);\n extern const char *output_cbranch (rtx, rtx, int, int, int, rtx);\n extern const char *output_return (rtx);\n extern const char *output_sibcall (rtx, rtx);\n extern const char *output_v8plus_shift (rtx, rtx *, const char *);\n extern const char *output_v8plus_mult (rtx, rtx *, const char *);\n extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);\n extern const char *output_probe_stack_range (rtx, rtx);\n+extern const char *output_cbcond (rtx, rtx, rtx);\n extern bool emit_scc_insn (rtx []);\n extern void emit_conditional_branch_insn (rtx []);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n extern int empty_delay_slot (rtx);\n+extern int emit_cbcond_nop (rtx);\n extern int eligible_for_return_delay (rtx);\n extern int eligible_for_sibcall_delay (rtx);\n extern int tls_call_delay (rtx);"}, {"sha": "4e9de987457f7a866f79334266e3e1ceff431ac2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 235, "deletions": 10, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -840,6 +840,8 @@ dump_target_flag_bits (const int flags)\n     fprintf (stderr, \"VIS2 \");\n   if (flags & MASK_VIS3)\n     fprintf (stderr, \"VIS3 \");\n+  if (flags & MASK_CBCOND)\n+    fprintf (stderr, \"CBCOND \");\n   if (flags & MASK_DEPRECATED_V8_INSNS)\n     fprintf (stderr, \"DEPRECATED_V8_INSNS \");\n   if (flags & MASK_SPARCLET)\n@@ -946,7 +948,7 @@ sparc_option_override (void)\n       MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF },\n     /* UltraSPARC T4 */\n     { \"niagara4\",\tMASK_ISA,\n-      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF },\n+      MASK_V9|MASK_POPC|MASK_VIS2|MASK_VIS3|MASK_FMAF|MASK_CBCOND },\n   };\n   const struct cpu_table *cpu;\n   unsigned int i;\n@@ -1072,6 +1074,9 @@ sparc_option_override (void)\n   target_flags |= (cpu->enable\n #ifndef HAVE_AS_FMAF_HPC_VIS3\n \t\t   & ~(MASK_FMAF | MASK_VIS3)\n+#endif\n+#ifndef HAVE_AS_SPARC4\n+\t\t   & ~MASK_CBCOND\n #endif\n \t\t   );\n \n@@ -1088,7 +1093,8 @@ sparc_option_override (void)\n   if (TARGET_VIS3)\n     target_flags |= MASK_VIS2 | MASK_VIS;\n \n-  /* Don't allow -mvis, -mvis2, -mvis3, or -mfmaf if FPU is disabled.  */\n+  /* Don't allow -mvis, -mvis2, -mvis3, or -mfmaf if FPU is\n+     disabled.  */\n   if (! TARGET_FPU)\n     target_flags &= ~(MASK_VIS | MASK_VIS2 | MASK_VIS3 | MASK_FMAF);\n \n@@ -2660,6 +2666,24 @@ emit_v9_brxx_insn (enum rtx_code code, rtx op0, rtx label)\n \t\t\t\t    pc_rtx)));\n }\n \n+/* Emit a conditional jump insn for the UA2011 architecture using\n+   comparison code CODE and jump target LABEL.  This function exists\n+   to take advantage of the UA2011 Compare and Branch insns.  */\n+\n+static void\n+emit_cbcond_insn (enum rtx_code code, rtx op0, rtx op1, rtx label)\n+{\n+  rtx if_then_else;\n+\n+  if_then_else = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t       gen_rtx_fmt_ee(code, GET_MODE(op0),\n+\t\t\t\t\t\t      op0, op1),\n+\t\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t       pc_rtx);\n+\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else));\n+}\n+\n void\n emit_conditional_branch_insn (rtx operands[])\n {\n@@ -2674,6 +2698,20 @@ emit_conditional_branch_insn (rtx operands[])\n       operands[2] = XEXP (operands[0], 1);\n     }\n \n+  /* If we can tell early on that the comparison is against a constant\n+     that won't fit in the 5-bit signed immediate field of a cbcond,\n+     use one of the other v9 conditional branch sequences.  */\n+  if (TARGET_CBCOND\n+      && GET_CODE (operands[1]) == REG\n+      && (GET_MODE (operands[1]) == SImode\n+\t  || (TARGET_ARCH64 && GET_MODE (operands[1]) == DImode))\n+      && (GET_CODE (operands[2]) != CONST_INT\n+\t  || SPARC_SIMM5_P (INTVAL (operands[2]))))\n+    {\n+      emit_cbcond_insn (GET_CODE (operands[0]), operands[1], operands[2], operands[3]);\n+      return;\n+    }\n+\n   if (TARGET_ARCH64 && operands[2] == const0_rtx\n       && GET_CODE (operands[1]) == REG\n       && GET_MODE (operands[1]) == DImode)\n@@ -3014,6 +3052,44 @@ empty_delay_slot (rtx insn)\n   return 1;\n }\n \n+/* Return nonzero if we should emit a nop after a cbcond instruction.\n+   The cbcond instruction does not have a delay slot, however there is\n+   a severe performance penalty if a control transfer appears right\n+   after a cbcond.  Therefore we emit a nop when we detect this\n+   situation.  */\n+\n+int\n+emit_cbcond_nop (rtx insn)\n+{\n+  rtx next = next_active_insn (insn);\n+\n+  if (!next)\n+    return 1;\n+\n+  if (GET_CODE (next) == INSN\n+      && GET_CODE (PATTERN (next)) == SEQUENCE)\n+    next = XVECEXP (PATTERN (next), 0, 0);\n+  else if (GET_CODE (next) == CALL_INSN\n+\t   && GET_CODE (PATTERN (next)) == PARALLEL)\n+    {\n+      rtx delay = XVECEXP (PATTERN (next), 0, 1);\n+\n+      if (GET_CODE (delay) == RETURN)\n+\t{\n+\t  /* It's a sibling call.  Do not emit the nop if we're going\n+\t     to emit something other than the jump itself as the first\n+\t     instruction of the sibcall sequence.  */\n+\t  if (sparc_leaf_function_p || TARGET_FLAT)\n+\t    return 0;\n+\t}\n+    }\n+\n+  if (NONJUMP_INSN_P (next))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Return nonzero if TRIAL can go into the call delay slot.  */\n \n int\n@@ -7102,19 +7178,49 @@ sparc_preferred_simd_mode (enum machine_mode mode)\n    DEST is the destination insn (i.e. the label), INSN is the source.  */\n \n const char *\n-output_ubranch (rtx dest, int label, rtx insn)\n+output_ubranch (rtx dest, rtx insn)\n {\n   static char string[64];\n   bool v9_form = false;\n+  int delta;\n   char *p;\n \n-  if (TARGET_V9 && INSN_ADDRESSES_SET_P ())\n+  /* Even if we are trying to use cbcond for this, evaluate\n+     whether we can use V9 branches as our backup plan.  */\n+\n+  delta = 5000000;\n+  if (INSN_ADDRESSES_SET_P ())\n+    delta = (INSN_ADDRESSES (INSN_UID (dest))\n+\t     - INSN_ADDRESSES (INSN_UID (insn)));\n+\n+  /* Leave some instructions for \"slop\".  */\n+  if (TARGET_V9 && delta >= -260000 && delta < 260000)\n+    v9_form = true;\n+\n+  if (TARGET_CBCOND)\n     {\n-      int delta = (INSN_ADDRESSES (INSN_UID (dest))\n-\t\t   - INSN_ADDRESSES (INSN_UID (insn)));\n-      /* Leave some instructions for \"slop\".  */\n-      if (delta >= -260000 && delta < 260000)\n-\tv9_form = true;\n+      bool emit_nop = emit_cbcond_nop (insn);\n+      bool far = false;\n+      const char *rval;\n+\n+      if (delta < -500 || delta > 500)\n+\tfar = true;\n+\n+      if (far)\n+\t{\n+\t  if (v9_form)\n+\t    rval = \"ba,a,pt\\t%%xcc, %l0\";\n+\t  else\n+\t    rval = \"b,a\\t%l0\";\n+\t}\n+      else\n+\t{\n+\t  if (emit_nop)\n+\t    rval = \"cwbe\\t%%g0, %%g0, %l0\\n\\tnop\";\n+\t  else\n+\t    rval = \"cwbe\\t%%g0, %%g0, %l0\";\n+\t}\n+      return rval;\n     }\n \n   if (v9_form)\n@@ -7125,7 +7231,7 @@ output_ubranch (rtx dest, int label, rtx insn)\n   p = strchr (string, '\\0');\n   *p++ = '%';\n   *p++ = 'l';\n-  *p++ = '0' + label;\n+  *p++ = '0';\n   *p++ = '%';\n   *p++ = '(';\n   *p = '\\0';\n@@ -7604,6 +7710,125 @@ sparc_emit_fixunsdi (rtx *operands, enum machine_mode mode)\n   emit_label (donelab);\n }\n \n+/* Return the string to output a compare and branch instruction to DEST.\n+   DEST is the destination insn (i.e. the label), INSN is the source,\n+   and OP is the conditional expression.  */\n+\n+const char *\n+output_cbcond (rtx op, rtx dest, rtx insn)\n+{\n+  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+  enum rtx_code code = GET_CODE (op);\n+  const char *cond_str, *tmpl;\n+  int far, emit_nop, len;\n+  static char string[64];\n+  char size_char;\n+\n+  /* Compare and Branch is limited to +-2KB.  If it is too far away,\n+     change\n+\n+     cxbne X, Y, .LC30\n+\n+     to\n+\n+     cxbe X, Y, .+16\n+     nop\n+     ba,pt xcc, .LC30\n+      nop  */\n+\n+  len = get_attr_length (insn);\n+\n+  far = len == 4;\n+  emit_nop = len == 2;\n+\n+  if (far)\n+    code = reverse_condition (code);\n+\n+  size_char = ((mode == SImode) ? 'w' : 'x');\n+\n+  switch (code)\n+    {\n+    case NE:\n+      cond_str = \"ne\";\n+      break;\n+\n+    case EQ:\n+      cond_str = \"e\";\n+      break;\n+\n+    case GE:\n+      if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n+\tcond_str = \"pos\";\n+      else\n+\tcond_str = \"ge\";\n+      break;\n+\n+    case GT:\n+      cond_str = \"g\";\n+      break;\n+\n+    case LE:\n+      cond_str = \"le\";\n+      break;\n+\n+    case LT:\n+      if (mode == CC_NOOVmode || mode == CCX_NOOVmode)\n+\tcond_str = \"neg\";\n+      else\n+\tcond_str = \"l\";\n+      break;\n+\n+    case GEU:\n+      cond_str = \"cc\";\n+      break;\n+\n+    case GTU:\n+      cond_str = \"gu\";\n+      break;\n+\n+    case LEU:\n+      cond_str = \"leu\";\n+      break;\n+\n+    case LTU:\n+      cond_str = \"cs\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (far)\n+    {\n+      int veryfar = 1, delta;\n+\n+      if (INSN_ADDRESSES_SET_P ())\n+\t{\n+\t  delta = (INSN_ADDRESSES (INSN_UID (dest))\n+\t\t   - INSN_ADDRESSES (INSN_UID (insn)));\n+\t  /* Leave some instructions for \"slop\".  */\n+\t  if (delta >= -260000 && delta < 260000)\n+\t    veryfar = 0;\n+\t}\n+\n+      if (veryfar)\n+\ttmpl = \"c%cb%s\\t%%1, %%2, .+16\\n\\tnop\\n\\tb\\t%%3\\n\\tnop\";\n+      else\n+\ttmpl = \"c%cb%s\\t%%1, %%2, .+16\\n\\tnop\\n\\tba,pt\\t%%%%xcc, %%3\\n\\tnop\";\n+    }\n+  else\n+    {\n+      if (emit_nop)\n+\ttmpl = \"c%cb%s\\t%%1, %%2, %%3\\n\\tnop\";\n+      else\n+\ttmpl = \"c%cb%s\\t%%1, %%2, %%3\";\n+    }\n+\n+  snprintf (string, sizeof(string), tmpl, size_char, cond_str);\n+\n+  return string;\n+}\n+\n /* Return the string to output a conditional branch to LABEL, testing\n    register REG.  LABEL is the operand number of the label; REG is the\n    operand number of the reg.  OP is the conditional expression.  The mode"}, {"sha": "57c5eaccdbf5cfe7096f4ce18226c1809e9b5e07", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -195,7 +195,7 @@ extern enum cmodel sparc_cmodel;\n #endif\n #if TARGET_CPU_DEFAULT == TARGET_CPU_niagara4\n #define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n-#define ASM_CPU64_DEFAULT_SPEC \"-Av9\" AS_NIAGARA3_FLAG\n+#define ASM_CPU64_DEFAULT_SPEC AS_NIAGARA4_FLAG\n #endif\n \n #else\n@@ -337,7 +337,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=niagara:%{!mv8plus:-Av9b}} \\\n %{mcpu=niagara2:%{!mv8plus:-Av9b}} \\\n %{mcpu=niagara3:%{!mv8plus:-Av9\" AS_NIAGARA3_FLAG \"}} \\\n-%{mcpu=niagara4:%{!mv8plus:-Av9\" AS_NIAGARA3_FLAG \"}} \\\n+%{mcpu=niagara4:%{!mv8plus:\" AS_NIAGARA4_FLAG \"}} \\\n %{!mcpu*:%(asm_cpu_default)} \\\n \"\n \n@@ -1006,7 +1006,8 @@ extern char leaf_reg_remap[];\n /* Local macro to handle the two v9 classes of FP regs.  */\n #define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS || (CLASS) == EXTRA_FP_REGS)\n \n-/* Predicates for 10-bit, 11-bit and 13-bit signed constants.  */\n+/* Predicates for 5-bit, 10-bit, 11-bit and 13-bit signed constants.  */\n+#define SPARC_SIMM5_P(X)  ((unsigned HOST_WIDE_INT) (X) + 0x10 < 0x20)\n #define SPARC_SIMM10_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x200 < 0x400)\n #define SPARC_SIMM11_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x400 < 0x800)\n #define SPARC_SIMM13_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x1000 < 0x2000)\n@@ -1746,6 +1747,12 @@ extern int sparc_indent_opcode;\n #define AS_NIAGARA3_FLAG \"b\"\n #endif\n \n+#ifdef HAVE_AS_SPARC4\n+#define AS_NIAGARA4_FLAG \"-xarch=sparc4\"\n+#else\n+#define AS_NIAGARA4_FLAG \"-Av9\" AS_NIAGARA3_FLAG\n+#endif\n+\n /* We use gcc _mcount for profiling.  */\n #define NO_PROFILE_COUNTERS 0\n "}, {"sha": "15ecdb42accd52f149a5770d2ceeaa081558ce9d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -257,6 +257,7 @@\n   \"ialu,compare,shift,\n    load,sload,store,\n    uncond_branch,branch,call,sibcall,call_no_delay_slot,return,\n+   cbcond,uncond_cbcond,\n    imul,idiv,\n    fpload,fpstore,\n    fp,fpmove,\n@@ -275,6 +276,12 @@\n   (symbol_ref \"(empty_delay_slot (insn)\n \t\t? EMPTY_DELAY_SLOT_TRUE : EMPTY_DELAY_SLOT_FALSE)\"))\n \n+;; True if we are making use of compare-and-branch instructions.\n+;; True if we should emit a nop after a cbcond instruction\n+(define_attr \"emit_cbcond_nop\" \"false,true\"\n+  (symbol_ref \"(emit_cbcond_nop (insn)\n+                ? EMIT_CBCOND_NOP_TRUE : EMIT_CBCOND_NOP_FALSE)\"))\n+\n (define_attr \"branch_type\" \"none,icc,fcc,reg\"\n   (const_string \"none\"))\n \n@@ -377,6 +384,30 @@\n \t       (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n \t\t (const_int 4)\n \t\t (const_int 3))))\n+         (eq_attr \"type\" \"cbcond\")\n+\t   (if_then_else (lt (pc) (match_dup 3))\n+\t     (if_then_else (lt (minus (match_dup 3) (pc)) (const_int 500))\n+               (if_then_else (eq_attr \"emit_cbcond_nop\" \"true\")\n+                 (const_int 2)\n+                 (const_int 1))\n+               (const_int 4))\n+\t     (if_then_else (lt (minus (pc) (match_dup 3)) (const_int 500))\n+               (if_then_else (eq_attr \"emit_cbcond_nop\" \"true\")\n+                 (const_int 2)\n+                 (const_int 1))\n+               (const_int 4)))\n+         (eq_attr \"type\" \"uncond_cbcond\")\n+\t   (if_then_else (lt (pc) (match_dup 0))\n+\t     (if_then_else (lt (minus (match_dup 0) (pc)) (const_int 500))\n+               (if_then_else (eq_attr \"emit_cbcond_nop\" \"true\")\n+                 (const_int 2)\n+                 (const_int 1))\n+               (const_int 1))\n+\t     (if_then_else (lt (minus (pc) (match_dup 0)) (const_int 500))\n+               (if_then_else (eq_attr \"emit_cbcond_nop\" \"true\")\n+                 (const_int 2)\n+                 (const_int 1))\n+               (const_int 1)))\n \t ] (const_int 1)))\n \n ;; FP precision.\n@@ -397,7 +428,7 @@\n \t\t? TLS_CALL_DELAY_TRUE : TLS_CALL_DELAY_FALSE)\"))\n \n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n+  (cond [(eq_attr \"type\" \"uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n \t\t(const_string \"false\")\n \t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n \t\t(if_then_else (eq_attr \"length\" \"1\")\n@@ -431,19 +462,19 @@\n ;; because it prevents us from moving back the final store of inner loops.\n \n (define_attr \"in_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n (define_attr \"in_uncond_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n (define_attr \"in_annul_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n@@ -1313,6 +1344,32 @@\n ;; SPARC V9-specific jump insns.  None of these are guaranteed to be\n ;; in the architecture.\n \n+(define_insn \"*cbcond_sp32\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"noov_compare_operator\"\n+                       [(match_operand:SI 1 \"register_operand\" \"r\")\n+                        (match_operand:SI 2 \"arith5_operand\" \"rA\")])\n+                      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"TARGET_CBCOND\"\n+{\n+  return output_cbcond (operands[0], operands[3], insn);\n+}\n+  [(set_attr \"type\" \"cbcond\")])\n+\n+(define_insn \"*cbcond_sp64\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"noov_compare_operator\"\n+                       [(match_operand:DI 1 \"register_operand\" \"r\")\n+                        (match_operand:DI 2 \"arith5_operand\" \"rA\")])\n+                      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+  \"TARGET_ARCH64 && TARGET_CBCOND\"\n+{\n+  return output_cbcond (operands[0], operands[3], insn);\n+}\n+  [(set_attr \"type\" \"cbcond\")])\n+\n ;; There are no 32 bit brreg insns.\n \n ;; XXX\n@@ -6076,12 +6133,22 @@\n \n ;; Unconditional and other jump instructions.\n \n-(define_insn \"jump\"\n+(define_expand \"jump\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"* return output_ubranch (operands[0], 0, insn);\"\n+  \"\")\n+\n+(define_insn \"*jump_ubranch\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"! TARGET_CBCOND\"\n+  \"* return output_ubranch (operands[0], insn);\"\n   [(set_attr \"type\" \"uncond_branch\")])\n \n+(define_insn \"*jump_cbcond\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"TARGET_CBCOND\"\n+  \"* return output_ubranch (operands[0], insn);\"\n+  [(set_attr \"type\" \"uncond_cbcond\")])\n+\n (define_expand \"tablejump\"\n   [(parallel [(set (pc) (match_operand 0 \"register_operand\" \"r\"))\n \t      (use (label_ref (match_operand 1 \"\" \"\")))])]"}, {"sha": "241cb07b749b978368d287c580de500e6697648d", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -73,6 +73,10 @@ mvis3\n Target Report Mask(VIS3)\n Use UltraSPARC Visual Instruction Set version 3.0 extensions\n \n+mcbcond\n+Target Report Mask(CBCOND)\n+Use UltraSPARC Compare-and-Branch extensions\n+\n mfmaf\n Target Report Mask(FMAF)\n Use UltraSPARC Fused Multiply-Add extensions"}, {"sha": "76eec2983c1cda2f62b5f607cdae7d5848a65aa2", "filename": "gcc/configure", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -24142,6 +24142,48 @@ if test $gcc_cv_as_sparc_fmaf = yes; then\n \n $as_echo \"#define HAVE_AS_FMAF_HPC_VIS3 1\" >>confdefs.h\n \n+fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for SPARC4 instructions\" >&5\n+$as_echo_n \"checking assembler for SPARC4 instructions... \" >&6; }\n+if test \"${gcc_cv_as_sparc_sparc4+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_sparc_sparc4=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.text\n+       .register %g2, #scratch\n+       .register %g3, #scratch\n+       .align 4\n+       cxbe %g2, %g3, 1f\n+1:     cwbneg %g2, %g3, 1f\n+1:     sha1\n+       md5\n+       aes_kexpand0 %f4, %f6, %f8\n+       des_round %f38, %f40, %f42, %f44\n+       camellia_f %f54, %f56, %f58, %f60\n+       kasumi_fi_xor %f46, %f48, %f50, %f52' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -xarch=sparc4 -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_sparc_sparc4=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_sparc_sparc4\" >&5\n+$as_echo \"$gcc_cv_as_sparc_sparc4\" >&6; }\n+if test $gcc_cv_as_sparc_sparc4 = yes; then\n+\n+$as_echo \"#define HAVE_AS_SPARC4 1\" >>confdefs.h\n+\n fi\n     ;;\n "}, {"sha": "9781e69622060d4a6cad8c7ce34fa4a30d03b925", "filename": "gcc/configure.ac", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -3545,6 +3545,24 @@ foo:\n        fnaddd %f10, %f12, %f14],,\n       [AC_DEFINE(HAVE_AS_FMAF_HPC_VIS3, 1,\n                 [Define if your assembler supports FMAF, HPC, and VIS 3.0 instructions.])])\n+\n+    gcc_GAS_CHECK_FEATURE([SPARC4 instructions],\n+      gcc_cv_as_sparc_sparc4,,\n+      [-xarch=sparc4],\n+      [.text\n+       .register %g2, #scratch\n+       .register %g3, #scratch\n+       .align 4\n+       cxbe %g2, %g3, 1f\n+1:     cwbneg %g2, %g3, 1f\n+1:     sha1\n+       md5\n+       aes_kexpand0 %f4, %f6, %f8\n+       des_round %f38, %f40, %f42, %f44\n+       camellia_f %f54, %f56, %f58, %f60\n+       kasumi_fi_xor %f46, %f48, %f50, %f52],,\n+      [AC_DEFINE(HAVE_AS_SPARC4, 1,\n+                [Define if your assembler supports SPARC4 instructions.])])\n     ;;\n \n changequote(,)dnl"}, {"sha": "d5d5658a69fdf02e8eff284649f92560f3cd6f46", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -929,6 +929,7 @@ See RS/6000 and PowerPC Options.\n -munaligned-doubles  -mno-unaligned-doubles @gol\n -mv8plus  -mno-v8plus  -mvis  -mno-vis @gol\n -mvis2  -mno-vis2  -mvis3  -mno-vis3 @gol\n+-mcbcond -mno-cbcond @gol\n -mfmaf  -mno-fmaf  -mpopc  -mno-popc @gol\n -mfix-at697f}\n \n@@ -19153,6 +19154,15 @@ default is @option{-mvis3} when targeting a cpu that supports such\n instructions, such as niagara-3 and later.  Setting @option{-mvis3}\n also sets @option{-mvis2} and @option{-mvis}.\n \n+@item -mcbcond\n+@itemx -mno-cbcond\n+@opindex mcbcond\n+@opindex mno-cbcond\n+With @option{-mcbcond}, GCC generates code that takes advantage of\n+compare-and-branch instructions, as defined in the Sparc Architecture 2011.\n+The default is @option{-mcbcond} when targeting a cpu that supports such\n+instructions, such as niagara-4 and later.\n+\n @item -mpopc\n @itemx -mno-popc\n @opindex mpopc"}, {"sha": "396bf43fd3749c7ddd29a3177f1825f90896e30a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8b98b5fd9f9e4edb38a6b7eeb91b5a77ad91d95c", "patch": "@@ -3222,6 +3222,9 @@ when the Visual Instruction Set is available.\n @item C\n The constant all-ones, for floating-point.\n \n+@item A\n+Signed 5-bit constant\n+\n @item D\n A vector constant\n "}]}