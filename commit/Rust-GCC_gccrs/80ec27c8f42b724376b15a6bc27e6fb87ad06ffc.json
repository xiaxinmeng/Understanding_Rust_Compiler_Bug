{"sha": "80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBlYzI3YzhmNDJiNzI0Mzc2YjE1YTZiYzI3ZTZmYjg3YWQwNmZmYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-29T20:05:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-29T20:05:41Z"}, "message": "class.c (create_vtable_ptr): Put the vtable at the beginning of the class, not the end, in the new ABI.\n\n\t* class.c (create_vtable_ptr): Put the vtable at the beginning of\n\tthe class, not the end, in the new ABI.\n\t* tree.c (propagate_binfo_offsets): Do the right thing for the new\n\tABI.\n\nFrom-SVN: r31120", "tree": {"sha": "3e4c1a09ab83d4ae8ea3d6e7a5cd67b8f263a356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e4c1a09ab83d4ae8ea3d6e7a5cd67b8f263a356"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/comments", "author": null, "committer": null, "parents": [{"sha": "71e33c0d12683aea71612febf5d377e3bb0fb9f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e33c0d12683aea71612febf5d377e3bb0fb9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71e33c0d12683aea71612febf5d377e3bb0fb9f2"}], "stats": {"total": 119, "additions": 93, "deletions": 26}, "files": [{"sha": "7506b732768cb2afee5458d0c3e5927de6658de0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "patch": "@@ -1,3 +1,10 @@\n+1999-12-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (create_vtable_ptr): Put the vtable at the beginning of\n+\tthe class, not the end, in the new ABI.\n+\t* tree.c (propagate_binfo_offsets): Do the right thing for the new\n+\tABI.\n+\n 1999-12-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (lang_type): Add nearly_empty_p.  Adjust dummy."}, {"sha": "8f1a1a292edf576abfa4ec70634b3ac39de0709f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "patch": "@@ -4136,7 +4136,22 @@ create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n \t\t\t\t     empty_p);\n \n       /* Add the new field to the list of fields in this class.  */\n-      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), TYPE_VFIELD (t));\n+      if (!flag_new_abi)\n+\t/* In the old ABI, the vtable pointer goes at the end of the\n+\t   class.  */\n+\tTYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), TYPE_VFIELD (t));\n+      else\n+\t{\n+\t  /* But in the new ABI, the vtable pointer is the first thing\n+\t     in the class.  */\n+\t  TYPE_FIELDS (t) = chainon (TYPE_VFIELD (t), TYPE_FIELDS (t));\n+\t  /* If there were any baseclasses, they can't possibly be at\n+\t     offset zero any more, because that's where the vtable\n+\t     pointer is.  So, converting to a base class is going to\n+\t     take work.  */\n+\t  if (CLASSTYPE_N_BASECLASSES (t))\n+\t    TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (t) = 1;\n+\t}\n \n       /* We can't yet add this new field to the list of all virtual\n \t function table pointers in this class.  The"}, {"sha": "ce26ec9831518856c4c9db615822a1b1a058957e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 70, "deletions": 25, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ec27c8f42b724376b15a6bc27e6fb87ad06ffc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=80ec27c8f42b724376b15a6bc27e6fb87ad06ffc", "patch": "@@ -671,36 +671,81 @@ propagate_binfo_offsets (binfo, offset)\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n-  for (i = 0; i < n_baselinks; /* note increment is done in the loop.  */)\n+  if (flag_new_abi)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\ti += 1;\n-      else\n+      for (i = 0; i < n_baselinks; ++i)\n \t{\n-\t  int j;\n-\t  tree delta = NULL_TREE;\n-\n-\t  for (j = i+1; j < n_baselinks; j++)\n-\t    if (! TREE_VIA_VIRTUAL (TREE_VEC_ELT (binfos, j)))\n-\t      {\n-\t\t/* The next basetype offset must take into account the space\n-\t\t   between the classes, not just the size of each class.  */\n-\t\tdelta = size_binop (MINUS_EXPR,\n-\t\t\t\t    BINFO_OFFSET (TREE_VEC_ELT (binfos, j)),\n-\t\t\t\t    BINFO_OFFSET (base_binfo));\n-\t\tbreak;\n-\t      }\n-\n-\t  BINFO_OFFSET (base_binfo) = offset;\n+\t  tree base_binfo;\n+\n+\t  /* Figure out which base we're looking at.  */\n+\t  base_binfo = TREE_VEC_ELT (binfos, i);\n+\n+\t  /* Skip virtual bases.  Their BINFO_OFFSET doesn't matter\n+\t     since they are always reached by using offsets looked up\n+\t     at run-time.  */\n+\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t    continue;\n+\n+\t  /* Whatever offset this class used to have in its immediate\n+\t     derived class, it is now at OFFSET more bytes in its\n+\t     final derived class, since the immediate derived class is\n+\t     already at the indicated OFFSET.  */\n+\t  BINFO_OFFSET (base_binfo)\n+\t    = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);\n \n \t  propagate_binfo_offsets (base_binfo, offset);\n+\t}\n+    }\n+  else\n+    {\n+      /* This algorithm, used for the old ABI, is neither simple, nor\n+\t general.  For example, it mishandles the case of:\n+       \n+           struct A;\n+\t   struct B : public A;\n+\t   struct C : public B;\n+\t   \n+\t if B is at offset zero in C, but A is not in offset zero in\n+\t B.  In that case, it sets the BINFO_OFFSET for A to zero.\n+\t (This sitution arises in the new ABI if B has virtual\n+\t functions, but A does not.)  Rather than change this\n+\t algorithm, and risking breaking the old ABI, it is preserved\n+\t here.  */\n+      for (i = 0; i < n_baselinks; /* note increment is done in the\n+\t\t\t\t      loop.  */)\n+\t{\n+\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n-\t  /* Go to our next class that counts for offset propagation.  */\n-\t  i = j;\n-\t  if (i < n_baselinks)\n-\t    offset = size_binop (PLUS_EXPR, offset, delta);\n+\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t    i += 1;\n+\t  else\n+\t    {\n+\t      int j;\n+\t      tree delta = NULL_TREE;\n+\n+\t      for (j = i+1; j < n_baselinks; j++)\n+\t\tif (! TREE_VIA_VIRTUAL (TREE_VEC_ELT (binfos, j)))\n+\t\t  {\n+\t\t    /* The next basetype offset must take into account\n+\t\t       the space between the classes, not just the\n+\t\t       size of each class.  */\n+\t\t    delta = size_binop (MINUS_EXPR,\n+\t\t\t\t\tBINFO_OFFSET (TREE_VEC_ELT (binfos, \n+\t\t\t\t\t\t\t\t    j)),\n+\t\t\t\t\tBINFO_OFFSET (base_binfo));\n+\t\t    break;\n+\t\t  }\n+\n+\t      BINFO_OFFSET (base_binfo) = offset;\n+\n+\t      propagate_binfo_offsets (base_binfo, offset);\n+\n+\t      /* Go to our next class that counts for offset\n+                 propagation.  */\n+\t      i = j;\n+\t      if (i < n_baselinks)\n+\t\toffset = size_binop (PLUS_EXPR, offset, delta);\n+\t    }\n \t}\n     }\n }"}]}