{"sha": "e349ee739ed29cd4f7688629da646055c2b078da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM0OWVlNzM5ZWQyOWNkNGY3Njg4NjI5ZGE2NDYwNTVjMmIwNzhkYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-30T19:11:58Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-30T19:11:58Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r12126", "tree": {"sha": "23f4511ca9c14fc3616f021fc075b402c7218a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23f4511ca9c14fc3616f021fc075b402c7218a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e349ee739ed29cd4f7688629da646055c2b078da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e349ee739ed29cd4f7688629da646055c2b078da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e349ee739ed29cd4f7688629da646055c2b078da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e349ee739ed29cd4f7688629da646055c2b078da/comments", "author": null, "committer": null, "parents": [{"sha": "2670328aa55d5f80328a11b6decdbf6e0ca8449d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2670328aa55d5f80328a11b6decdbf6e0ca8449d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2670328aa55d5f80328a11b6decdbf6e0ca8449d"}], "stats": {"total": 1087, "additions": 768, "deletions": 319}, "files": [{"sha": "1f6eeb971e21b6a6db490a46f52baf86cc5b6ce0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 126, "deletions": 1, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -3,6 +3,131 @@ Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n \t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n \t(finish_file): Likewise.\n \n+Wed May 29 17:04:33 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Redo how and when temporaries are\n+\tcreated.\n+\t* decl.c (grok_reference_init): Don't try and be smart about\n+\trunning cleanups.\n+\n+Wed May 29 16:02:08 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Add NULL_TREE to all calls to build\n+\t(TARGET_EXPR...), now that it has 4 arguments.\n+\t* tree.c (build_cplus_new): Ditto.\n+\n+Thu May 23 16:40:30 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* error.c (dump_expr, case CAST_EXPR): Handle T() properly.\n+\n+\t* pt.c (instantiate_decl): Don't call push/pop_cp_function_context.\n+\t* decl.c (struct saved_scope): Remove named_labels,\n+\t{base,member}_init_list.\n+\t(maybe_push_to_top_level): Don't set them.  Call\n+\tpush_cp_function_context if appropriate.\n+\t(pop_from_top_level): Likewise.\n+\n+\t* method.c (do_build_assign_ref): Remove obsolete check of\n+\tTYPE_HAS_ASSIGN_REF (basetype).\n+\n+\t* decl.c (grokfndecl): Diagnose user definition of\n+ \timplicitly-declared methods.\n+\n+Thu May 23 12:13:08 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* method.c (do_build_copy_constructor): Add code to give\n+ \tmeaningful error messages instead of crashing.\n+  \t(do_build_assign_ref): Don't synthesize assignment operators for\n+ \tclasses containing reference or const members.\n+\n+\t* class.c (struct base_info): Remove cant_synth_copy_ctor\n+\tand cant_synth_asn_ref.\n+\t(finish_base_struct): Remove the code that tries to conditionalize\n+ \tsynthesis of copy constructors & assignment operators based on\n+ \taccess permissions. Instead, let it fail when it tries to\n+ \tsynthesize the copy constructor. This will give meaningful error\n+ \tmessages instead of silently generating code to perform a bitcopy.\n+\n+Wed May 22 11:45:19 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* lex.c (real_yylex): Remove old-n-crufty #if 0 code for\n+ \tdetermining types for constant values.\n+\n+\t* decl.c (struct named_label_list): Use instead of stuffing\n+\trandom items into a TREE_LIST node.\n+\t(named_label_uses): Use the new struct.\n+\t(poplevel): Ditto.\n+\t(lookup_label): Ditto.\n+\t(define_label): Add an error message to tell the user the line\n+ \twhere the goto is located in addition to the destination of the\n+ \tgoto.\n+\t(init_decl_processing): Use NULL instead of NULL_TREE to initialize\n+\tnamed_label_uses.\n+\t(finish_function): Ditto.\n+\t\n+\t(start_decl): Complain about defining a static data member\n+\tin a different type from which it was declared.\n+\n+Wed May 22 09:33:23 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (build_expr_type_conversion): Adjust.\n+\n+Tue May 21 11:21:56 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_method_call): Always convert 'this' to the\n+ \tappropriate type.\n+\n+\t* search.c (add_conversions): Put the conversion function in\n+ \tTREE_VALUE, the type in TREE_PURPOSE.\n+\t* cvt.c (build_type_conversion): Adjust.\n+\t* call.c (user_harshness): Adjust.\n+\n+\t* method.c (emit_thunk): Call temporary_allocation and\n+ \tpermanent_allocation around the ASM_OUTPUT_MI_THUNK case, too.\n+\n+\t* tree.c (build_cplus_array_type): Handle tweaking of\n+ \tTYPE_MAIN_VARIANT here.\n+\t* typeck.c (common_type): Not here.\n+\n+\t* typeck.c (complete_type): Only try to complete an array type if\n+ \tit has a domain.\n+\n+Mon May 20 14:55:59 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (grokvardecl): Call complete_type.\n+\t(grokdeclarator): Call complete_type for PARM_DECLs.\n+\n+Fri May 17 16:41:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): Re-set\n+ \tCLASSTYPE_GOT_SEMICOLON after calling finish_struct_1.\n+\n+Fri May 17 14:56:55 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (cp_expand_decl_cleanup): Remove, the backend is now\n+\tsmart enough to do it right.\n+\t* tree.c (cp_expand_decl_cleanup): Ditto.\n+\t* decl.c (cp_finish_decl): Use expand_decl_cleanup instead of\n+\tcp_expand_decl_cleanup.\n+\t(store_parm_decls): Ditto.\n+\t(hack_incomplete_structures): Ditto.\n+\t* except.c (push_eh_cleanup): Ditto.\n+\n+Fri May 17 13:13:51 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* expr.c (expand_expr, cond UNSAVE_EXPR): Move from the C++\n+\tfrontend to the backend where it belongs.\n+\t* tree.c (unsave_expr): Ditto.\n+\t(unsave_expr_now): Ditto.\n+\t* tree.def (UNSAVE_EXPR): Ditto.\n+\t* cp-tree.h (unsave_expr): Ditto.\n+\t(unsave_expr_now): Ditto.\n+\n+Fri May 17 11:02:41 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (emit_base_init): Make sure the partial EH cleanups live\n+\ton the function_obstack.\n+\n Thu May 16 15:29:33 1996  Bob Manson  <manson@charmed.cygnus.com>\n \n \t* expr.c (do_case): Don't try to dereference null TREE_TYPEs\n@@ -2369,7 +2494,7 @@ Mon Nov 13 15:45:34 1995  Mike Stump  <mrs@cygnus.com>\n \tindirect binding.\n \t* decl.c (cp_finish_decl): Ensure that we reuse stack slots as fast\n \tas they are unused.\n-\t(expand_static_init): Diotto.\n+\t(expand_static_init): Ditto.\n \t(cplus_expand_expr_stmt): Ditto.\n \t* decl2.c (finish_file): Ditto.\n \t* init.c (perform_member_init): Ditto."}, {"sha": "3accebcbe60a2262071173b8a7dbd4649074586a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -641,10 +641,10 @@ user_harshness (type, parmtype)\n     {\n       struct harshness_code tmp;\n \n-      if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n+      if (winner && TREE_VALUE (winner) == TREE_VALUE (conv))\n \tcontinue;\n \n-      if (tmp = convert_harshness (type, TREE_VALUE (conv), NULL_TREE),\n+      if (tmp = convert_harshness (type, TREE_PURPOSE (conv), NULL_TREE),\n \t  (tmp.code < USER_CODE) && (tmp.distance >= 0))\n \t{\n \t  if (winner)\n@@ -2531,8 +2531,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     {\n       int sub_flags = DECL_CONSTRUCTOR_P (function) ? flags : LOOKUP_NORMAL;\n       basetype = TREE_TYPE (instance);\n-      if (TYPE_METHOD_BASETYPE (TREE_TYPE (function)) != TYPE_MAIN_VARIANT (basetype)\n-\t  && TYPE_USES_COMPLEX_INHERITANCE (basetype))\n+      if (TYPE_METHOD_BASETYPE (TREE_TYPE (function))\n+\t  != TYPE_MAIN_VARIANT (basetype))\n \t{\n \t  basetype = DECL_CLASS_CONTEXT (function);\n \t  instance_ptr = convert_pointer_to (basetype, instance_ptr);"}, {"sha": "9227baf13aa327fff9de98fed0c7aaa37448bf21", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 40, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -1408,8 +1408,6 @@ struct base_info\n   tree rtti;\n   char cant_have_default_ctor;\n   char cant_have_const_ctor;\n-  char cant_synth_copy_ctor;\n-  char cant_synth_asn_ref;\n   char no_const_asn_ref;\n   char base_has_virtual;\n };\n@@ -1465,13 +1463,8 @@ finish_base_struct (t, b, t_binfo)\n \t    TREE_VEC_ELT (binfos, j) = TREE_VEC_ELT (binfos, j+1);\n \t}\n \n-      if (TYPE_HAS_INIT_REF (basetype)\n-\t  && !TYPE_HAS_CONST_INIT_REF (basetype))\n+      if (! TYPE_HAS_CONST_INIT_REF (basetype))\n \tb->cant_have_const_ctor = 1;\n-      if (! TYPE_HAS_INIT_REF (basetype)\n-\t  || (TYPE_HAS_NONPUBLIC_CTOR (basetype) == 2\n-\t      && ! is_friend_type (t, basetype)))\n-\tb->cant_synth_copy_ctor = 1;\n \n       if (TYPE_HAS_CONSTRUCTOR (basetype)\n \t  && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype))\n@@ -1488,11 +1481,6 @@ finish_base_struct (t, b, t_binfo)\n       if (TYPE_HAS_ASSIGN_REF (basetype)\n \t  && !TYPE_HAS_CONST_ASSIGN_REF (basetype))\n \tb->no_const_asn_ref = 1;\n-      if (! TYPE_HAS_ASSIGN_REF (basetype)\n-\t  || TYPE_HAS_ABSTRACT_ASSIGN_REF (basetype)\n-\t  || (TYPE_HAS_NONPUBLIC_ASSIGN_REF (basetype) == 2\n-\t      && ! is_friend_type (t, basetype)))\n-\tb->cant_synth_asn_ref = 1;\n \n       b->n_ancestors += CLASSTYPE_N_SUPERCLASSES (basetype);\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n@@ -1645,8 +1633,6 @@ finish_base_struct (t, b, t_binfo)\n \t{\n \t  cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t      basetype, t);\n-\t  b->cant_synth_asn_ref = 1;\n-\t  b->cant_synth_copy_ctor = 1;\n \t}\n     }\n   {\n@@ -1660,8 +1646,6 @@ finish_base_struct (t, b, t_binfo)\n \t    if (extra_warnings)\n \t      cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t\t  basetype, t);\n-\t    b->cant_synth_asn_ref = 1;\n-\t    b->cant_synth_copy_ctor = 1;\n \t  }\n       }\n   }    \n@@ -3016,8 +3000,6 @@ finish_struct_1 (t, attributes, warn_anon)\n   tree vfields;\n   int cant_have_default_ctor;\n   int cant_have_const_ctor;\n-  int cant_synth_copy_ctor;\n-  int cant_synth_asn_ref;\n   int no_const_asn_ref;\n \n   /* The index of the first base class which has virtual\n@@ -3108,8 +3090,6 @@ finish_struct_1 (t, attributes, warn_anon)\n       CLASSTYPE_RTTI (t) = base_info.rtti;\n       cant_have_default_ctor = base_info.cant_have_default_ctor;\n       cant_have_const_ctor = base_info.cant_have_const_ctor;\n-      cant_synth_copy_ctor = base_info.cant_synth_copy_ctor;\n-      cant_synth_asn_ref = base_info.cant_synth_asn_ref;\n       no_const_asn_ref = base_info.no_const_asn_ref;\n       base_has_virtual = base_info.base_has_virtual;\n       n_baseclasses = TREE_VEC_LENGTH (BINFO_BASETYPES (t_binfo));\n@@ -3126,8 +3106,6 @@ finish_struct_1 (t, attributes, warn_anon)\n       last_x = NULL_TREE;\n       cant_have_default_ctor = 0;\n       cant_have_const_ctor = 0;\n-      cant_synth_copy_ctor = 0;\n-      cant_synth_asn_ref = 0;\n       no_const_asn_ref = 0;\n       base_has_virtual = 0;\n     }\n@@ -3273,7 +3251,7 @@ finish_struct_1 (t, attributes, warn_anon)\n \n #if 0\n       if (DECL_NAME (x) == constructor_name (t))\n-\tcant_have_default_ctor = cant_synth_copy_ctor = 1;\n+\tcant_have_default_ctor = 1;\n #endif\n \n       if (TREE_TYPE (x) == error_mark_node)\n@@ -3313,8 +3291,8 @@ finish_struct_1 (t, attributes, warn_anon)\n \t     aggregate, initialization by a brace-enclosed list) is the\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n-\t  cant_synth_asn_ref = 1;\n \t  cant_have_default_ctor = 1;\n+\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n \t    {\n@@ -3336,8 +3314,8 @@ finish_struct_1 (t, attributes, warn_anon)\n \t     aggregate, initialization by a brace-enclosed list) is the\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n-\t  cant_synth_asn_ref = 1;\n \t  cant_have_default_ctor = 1;\n+\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t)\n \t      && extra_warnings)\n@@ -3508,18 +3486,10 @@ finish_struct_1 (t, attributes, warn_anon)\n \t\t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n \t\t}\n \n-\t      if (! TYPE_HAS_INIT_REF (type)\n-\t\t  || (TYPE_HAS_NONPUBLIC_CTOR (type)\n-\t\t      && ! is_friend (t, type)))\n-\t\tcant_synth_copy_ctor = 1;\n-\t      else if (!TYPE_HAS_CONST_INIT_REF (type))\n+\t      if (!TYPE_HAS_CONST_INIT_REF (type))\n \t\tcant_have_const_ctor = 1;\n \n-\t      if (! TYPE_HAS_ASSIGN_REF (type)\n-\t\t  || (TYPE_HAS_NONPUBLIC_ASSIGN_REF (type)\n-\t\t      && ! is_friend (t, type)))\n-\t\tcant_synth_asn_ref = 1;\n-\t      else if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n+\t      if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n \t\tno_const_asn_ref = 1;\n \n \t      if (TYPE_HAS_CONSTRUCTOR (type)\n@@ -3614,8 +3584,7 @@ finish_struct_1 (t, attributes, warn_anon)\n     }\n \n   /* Create default copy constructor, if needed.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! cant_synth_copy_ctor\n-      && ! IS_SIGNATURE (t))\n+  if (! TYPE_HAS_INIT_REF (t) && ! IS_SIGNATURE (t))\n     {\n       /* ARM 12.18: You get either X(X&) or X(const X&), but\n \t not both.  --Chip  */\n@@ -3630,8 +3599,7 @@ finish_struct_1 (t, attributes, warn_anon)\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n \n-  if (! TYPE_HAS_ASSIGN_REF (t) && ! cant_synth_asn_ref\n-      && ! IS_SIGNATURE (t))\n+  if (! TYPE_HAS_ASSIGN_REF (t) && ! IS_SIGNATURE (t))\n     {\n       tree default_fn = cons_up_default_function (t, name,\n \t\t\t\t\t\t  5 + no_const_asn_ref);"}, {"sha": "d1317743ac3699d915de86b7d41bd315b8c35acc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -2403,7 +2403,6 @@ extern void print_lang_statistics\t\tPROTO((void));\n extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n extern tree break_out_target_exprs\t\tPROTO((tree));\n-extern int cp_expand_decl_cleanup\t\tPROTO((tree, tree));\n extern tree get_type_decl\t\t\tPROTO((tree));\n extern tree vec_binfo_member\t\t\tPROTO((tree, tree));\n extern tree hack_decl_function_context \t\tPROTO((tree));"}, {"sha": "3672ee5b7fa5ab23365a0eb7e1563d9f6af36eb1", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 460, "deletions": 59, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -596,13 +596,24 @@ build_up_reference (type, arg, flags, checkconst)\n \n   if (TREE_ADDRESSABLE (targ) == 0)\n     {\n-      tree temp;\n+      if (! (flags&INDIRECT_BIND)\n+\t  && toplevel_bindings_p ())\n+\t{\n+\t  tree temp = get_temp_name (argtype, 0);\n+\t  /* Give this new temp some rtl and initialize it.  */\n+\t  DECL_INITIAL (temp) = targ;\n+\t  TREE_STATIC (temp) = 1;\n+\t  cp_finish_decl (temp, targ, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+\t  /* Do this after declaring it static.  */\n+\t  rval = build_unary_op (ADDR_EXPR, temp, 0);\n+\t  TREE_TYPE (rval) = type;\n+\t  literal_flag = TREE_CONSTANT (rval);\n+\t  goto done;\n+\t}\n \n       if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n \t{\n-\t  temp = build_cplus_new (argtype, targ);\n-\t  rval = build1 (ADDR_EXPR, type, temp);\n-\t  goto done;\n+\t  arg = build_cplus_new (argtype, targ);\n \t}\n       else if (flags&INDIRECT_BIND)\n \t{\n@@ -611,41 +622,41 @@ build_up_reference (type, arg, flags, checkconst)\n              use INDIRECT_BIND.  */\n \t  tree slot = build (VAR_DECL, argtype);\n \t  layout_decl (slot, 0);\n-\t  rval = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE);\n-\t  rval = build1 (ADDR_EXPR, type, rval);\n-\t  goto done;\n+\t  arg = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE, NULL_TREE);\n \t}\n       else\n \t{\n-\t  temp = get_temp_name (argtype, 0);\n-\t  if (toplevel_bindings_p ())\n-\t    {\n-\t      /* Give this new temp some rtl and initialize it.  */\n-\t      DECL_INITIAL (temp) = targ;\n-\t      TREE_STATIC (temp) = 1;\n-\t      cp_finish_decl (temp, targ, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n-\t      /* Do this after declaring it static.  */\n-\t      rval = build_unary_op (ADDR_EXPR, temp, 0);\n-\t      TREE_TYPE (rval) = type;\n-\t      literal_flag = TREE_CONSTANT (rval);\n-\t      goto done;\n-\t    }\n+\t  tree temp = get_temp_name (argtype, 0);\n+\t  rval = build_unary_op (ADDR_EXPR, temp, 0);\n+\t  if (binfo && !BINFO_OFFSET_ZEROP (binfo))\n+\t    rval = convert_pointer_to (target_type, rval);\n \t  else\n-\t    {\n-\t      rval = build_unary_op (ADDR_EXPR, temp, 0);\n-\t      if (binfo && !BINFO_OFFSET_ZEROP (binfo))\n-\t\trval = convert_pointer_to (target_type, rval);\n-\t      else\n-\t\tTREE_TYPE (rval) = type;\n+\t    TREE_TYPE (rval) = type;\n+\n+\t  temp = build (MODIFY_EXPR, argtype, temp, arg);\n+\t  TREE_SIDE_EFFECTS (temp) = 1;\n+\t  return build (COMPOUND_EXPR, type, temp, rval);\n+\t}\n+    }\n+\n+  if (! (flags&INDIRECT_BIND))\n+    {\n+      if (TREE_CODE (arg) == TARGET_EXPR)\n+\t{\n+\t  tree decl = TREE_OPERAND (arg, 0);\n+\t  tree cleanup;\n \n-\t      temp = build (MODIFY_EXPR, argtype, temp, arg);\n-\t      TREE_SIDE_EFFECTS (temp) = 1;\n-\t      return build (COMPOUND_EXPR, type, temp, rval);\n+\t  if (! toplevel_bindings_p ())\n+\t    {\n+\t      expand_decl (decl);\n+\t      cleanup = maybe_build_cleanup (decl);\n+\t      if (cleanup)\n+\t\texpand_decl_cleanup (decl, cleanup);\n \t    }\n \t}\n     }\n-  else\n-    rval = build1 (ADDR_EXPR, type, arg);\n+\n+  rval = build1 (ADDR_EXPR, type, arg);\n \n  done:\n   if (TYPE_USES_COMPLEX_INHERITANCE (argtype)\n@@ -1498,10 +1509,10 @@ build_type_conversion (code, xtype, expr, for_sure)\n   /* Nope; try looking for others.  */\n   for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n     {\n-      if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n+      if (winner && TREE_VALUE (winner) == TREE_VALUE (conv))\n \tcontinue;\n \n-      if (can_convert (xtype, TREE_VALUE (conv)))\n+      if (can_convert (xtype, TREE_PURPOSE (conv)))\n \t{\n \t  if (winner)\n \t    {\n@@ -1510,7 +1521,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t\t  cp_error (\"ambiguous conversion from `%T' to `%T'\", basetype,\n \t\t\t    xtype);\n \t\t  cp_error (\"  candidate conversions include `%T' and `%T'\",\n-\t\t\t    TREE_VALUE (winner), TREE_VALUE (conv));\n+\t\t\t    TREE_PURPOSE (winner), TREE_PURPOSE (conv));\n \t\t}\n \t      return NULL_TREE;\n \t    }\n@@ -1521,7 +1532,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n \n   if (winner)\n     return build_type_conversion_1 (xtype, basetype, expr,\n-\t\t\t\t    TREE_PURPOSE (winner), for_sure);\n+\t\t\t\t    DECL_NAME (TREE_VALUE (winner)), for_sure);\n \n   return NULL_TREE;\n }\n@@ -1580,10 +1591,10 @@ build_expr_type_conversion (desires, expr, complain)\n       int win = 0;\n       tree candidate;\n \n-      if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n+      if (winner && TREE_VALUE (winner) == TREE_VALUE (conv))\n \tcontinue;\n \n-      candidate = TREE_VALUE (conv);\n+      candidate = TREE_PURPOSE (conv);\n       if (TREE_CODE (candidate) == REFERENCE_TYPE)\n \tcandidate = TREE_TYPE (candidate);\n \n@@ -1609,7 +1620,7 @@ build_expr_type_conversion (desires, expr, complain)\n \t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n \t\t\t    basetype);\n \t\t  cp_error (\"  candidate conversions include `%T' and `%T'\",\n-\t\t\t    TREE_VALUE (winner), TREE_VALUE (conv));\n+\t\t\t    TREE_PURPOSE (winner), TREE_PURPOSE (conv));\n \t\t}\n \t      return error_mark_node;\n \t    }\n@@ -1620,11 +1631,11 @@ build_expr_type_conversion (desires, expr, complain)\n \n   if (winner)\n     {\n-      tree type = TREE_VALUE (winner);\n+      tree type = TREE_PURPOSE (winner);\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \ttype = TREE_TYPE (type);\n       return build_type_conversion_1 (type, basetype, expr,\n-\t\t\t\t      TREE_PURPOSE (winner), 1);\n+\t\t\t\t      DECL_NAME (TREE_VALUE (winner)), 1);\n     }\n \n   return NULL_TREE;\n@@ -1819,6 +1830,41 @@ null_ptr_cst (t)\n   return (INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t));\n }\n \n+tree\n+build_conv (code, type, from)\n+     enum tree_code code;\n+     tree type, from;\n+{\n+  tree t = build1 (code, type, from);\n+  int rank = ICS_STD_RANK (from);\n+  switch (code)\n+    {\n+    case PROMO_CONV:\n+      if (rank < PROMO_RANK)\n+\trank = PROMO_RANK;\n+      break;\n+      \n+    case PTR_CONV:\n+    case PMEM_CONV:\n+    case BASE_CONV:\n+    case STD_CONV:\n+      if (rank < STD_RANK)\n+\trank = STD_RANK;\n+      break;\n+\n+    case PBOOL_CONV:\n+      if (rank < PBOOL_RANK)\n+\trank = PBOOL_RANK;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  ICS_STD_RANK (t) = rank;\n+  ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n+  return t;\n+}\n+\n tree\n standard_conversion (to, from, expr)\n      tree to, from, expr;\n@@ -1830,25 +1876,27 @@ standard_conversion (to, from, expr)\n   if (from == to)\n     return from;\n \n-  conv = from;\n+  conv = build1 (EXACT_CONV, from, expr);\n+  if (TREE_CODE (expr) == USER_CONV)\n+    ICS_USER_FLAG (conv) = 1;\n \n   if (fcode == FUNCTION_TYPE)\n     {\n       from = build_pointer_type (from);\n       fcode = TREE_CODE (from);\n-      conv = build1 (LVALUE_CONV, from, conv);\n+      conv = build_conv (LVALUE_CONV, from, conv);\n     }\n   else if (fcode == ARRAY_TYPE)\n     {\n       from = build_pointer_type (TREE_TYPE (from));\n       fcode = TREE_CODE (from);\n-      conv = build1 (LVALUE_CONV, from, conv);\n+      conv = build_conv (LVALUE_CONV, from, conv);\n     }\n \n   if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n       && expr && null_ptr_cst (expr))\n     {\n-      conv = build1 (CONV_CONV, to, conv);\n+      conv = build_conv (STD_CONV, to, conv);\n     }\n   else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n     {\n@@ -1864,7 +1912,7 @@ standard_conversion (to, from, expr)\n \t  from = cp_build_type_variant (void_type_node,\n \t\t\t\t\tTYPE_READONLY (TREE_TYPE (from)),\n \t\t\t\t\tTYPE_VOLATILE (TREE_TYPE (from)));\n-\t  conv = build1 (CONV_CONV, from, conv);\n+\t  conv = build_conv (PTR_CONV, from, conv);\n \t}\n       else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n \t{\n@@ -1877,7 +1925,7 @@ standard_conversion (to, from, expr)\n \t\t\t     1)))\n \t    {\n \t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n-\t      conv = build1 (CONV_CONV, from, conv);\n+\t      conv = build_conv (PMEM_CONV, from, conv);\n \t    }\n \t  else\n \t    return 0;\n@@ -1890,7 +1938,7 @@ standard_conversion (to, from, expr)\n \t      from = cp_build_type_variant (TREE_TYPE (to),\n \t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n \t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n-\t      conv = build1 (CONV_CONV, from, conv);\n+\t      conv = build_conv (PTR_CONV, from, conv);\n \t    }\n \t  else\n \t    return 0;\n@@ -1901,7 +1949,7 @@ standard_conversion (to, from, expr)\n       if (! comptypes (from, to, 1) && comp_ptr_ttypes (to, from))\n \t{\n \t  from = to;\n-\t  conv = build1 (QUAL_CONV, from, conv);\n+\t  conv = build_conv (QUAL_CONV, from, conv);\n \t}\n     }\n   else if (TYPE_PTRMEMFUNC_P (to) && TYPE_PTRMEMFUNC_P (from))\n@@ -1923,29 +1971,32 @@ standard_conversion (to, from, expr)\n \t\t\t\t    TYPE_VOLATILE (fbase));\n       from = build_cplus_method_type (from, TREE_TYPE (fromfn),\n \t\t\t\t      TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n-      conv = build1 (CONV_CONV, from, conv);\n+      conv = build_conv (PMEM_CONV, from, conv);\n     }\n   else if (tcode == BOOLEAN_TYPE)\n     {\n-      if (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE\n-\t  || fcode == POINTER_TYPE)\n-\treturn build1 (CONV_CONV, to, conv);\n-      else\n+      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE\n+\t     || fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)))\n \treturn 0;\n+\n+      if (fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from))\n+\tconv = build_conv (PBOOL_CONV, to, conv);\n+      else\n+\tconv = build_conv (STD_CONV, to, conv);\n     }\n   else if (INTEGRAL_CODE_P (tcode) || tcode == REAL_TYPE)\n     {\n       if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n \treturn 0;\n       else if (to == type_promotes_to (from))\n-\tconv = build1 (PROMO_CONV, to, conv);\n+\tconv = build_conv (PROMO_CONV, to, conv);\n       else \n-\tconv = build1 (CONV_CONV, to, conv);\n+\tconv = build_conv (STD_CONV, to, conv);\n     }\n   else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t   && DERIVED_FROM_P (to, from))\n     {\n-      conv = build1 (CONV_CONV, to, conv);\n+      conv = build_conv (BASE_CONV, to, conv);\n     }\n   else\n     return 0;\n@@ -1958,16 +2009,366 @@ implicit_conversion (to, from, expr, flags)\n      tree to, from, expr;\n      int flags;\n {\n-  tree conv = standard_conversion (to, from, expr);\n+  tree t, conv = standard_conversion (to, from, expr);\n+  struct z_candidate *cand;\n \n   if (conv || (flags & LOOKUP_NO_CONVERSION))\n     return conv;\n \n   flags |= LOOKUP_NO_CONVERSION;\n \n-    /* try constructors */;\n-    /* try conversion ops */;\n+  cand = build_user_type_conversion_1 (to, expr, flags);\n+  if (! cand)\n+    return NULL_TREE;\n+\n+  conv = cand->second_conv;\n+\n+  for (t = conv; TREE_CODE (TREE_OPERAND (t, 0)) != EXACT_MATCH; )\n+    t = TREE_OPERAND (t, 0));\n+\n+  TREE_OPERAND (t, 0) = build (USER_CONV\n \n   return conv;\n }\n+\n+struct z_candidate *\n+add_method_candidate (candidates, method, instance, parms, flags)\n+     struct z_candidate *candidates;\n+     tree method, instance, parms;\n+     int flags;\n+{\n+  \n+}\n+\n+struct z_candidate *\n+build_user_type_conversion_1 (totype, expr, flags)\n+     tree totype, expr;\n+     int flags;\n+{\n+  struct z_candidate *candidates, *cand;\n+  tree fromtype = TREE_TYPE (expr);\n+  tree ctors = NULL_TREE, convs = NULL_TREE, t;\n+\n+  if (IS_AGGR_TYPE (totype))\n+    ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n+  if (IS_AGGR_TYPE (fromtype))\n+    convs = lookup_conversions (fromtype);\n+\n+  if (ctors)\n+    ctors = TREE_VALUE (ctors);\n+  for (; ctors; ctors = DECL_CHAIN (ctors))\n+    {\n+      candidates = add_ctor_candidate (candidates, ctors, expr, flags);\n+    }\n+\n+  for (; convs; convs = TREE_CHAIN (convs))\n+    {\n+      tree fn = TREE_VALUE (convs);\n+      tree ics = standard_conversion (totype, TREE_TYPE (TREE_TYPE (fn)), 0);\n+      if (ics)\n+\t{\n+\t  candidates = add_method_candidate\n+\t    (candidates, fn, expr, NULL_TREE, flags);\n+\t  candidates->second_ics = ics;\n+\t}\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+\tcp_error (\"no viable candidates\");\n+      return 0;\n+    }\n+\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, totype);\n+\n+  if (cand == 0)\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+\tcp_error (\"ambiguous user-defined type conversion\");\n+    }\n+\n+  return cand;\n+}\n+\n+/* Compare two implicit conversion sequences according to the rules set out in\n+   [over.ics.rank].  Return values:\n+\n+      1: ics1 is better than ics2\n+     -1: ics2 is better than ics1\n+      0: ics1 and ics2 are indistinguishable */\n+\n+int\n+compare_ics (ics1, ics2)\n+     tree ics1, ics2;\n+{\n+  tree main1, main2;\n+\n+  if (ICS_RANK (ics1) > ICS_RANK (ics2))\n+    return 1;\n+  else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n+    return -1;\n+\n+  /* User-defined  conversion sequence U1 is a better conversion sequence\n+     than another user-defined conversion sequence U2 if they contain the\n+     same user-defined conversion operator or constructor and if the sec-\n+     ond standard conversion sequence of U1 is  better  than  the  second\n+     standard conversion sequence of U2. */\n+\n+  if (ICS_RANK (ics1) == USER_RANK)\n+    {\n+      tree t1, t2;\n+\n+      for (t1 = ics1; TREE_CODE (t1) != USER_CONV; t1 = TREE_OPERAND (t1, 0))\n+\t;\n+      for (t2 = ics2; TREE_CODE (t2) != USER_CONV; t2 = TREE_OPERAND (t2, 0))\n+\t;\n+\n+      if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n+\treturn 0;\n+      else if (ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n+\treturn 1;\n+      else if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+\treturn -1;\n+\n+      /* else fall through */\n+    }\n+\n+#if 0 /* Handled by ranking */\n+  /* A conversion that is not a conversion of a pointer,  or  pointer  to\n+     member,  to  bool  is  better than another conversion that is such a\n+     conversion.  */\n+  {\n+    int bool1 = TREE_CODE (ics1) == BOOL_CONV;\n+    int bool2 = TREE_CODE (ics2) == BOOL_CONV;\n+\n+    if (bool1)\n+      {\n+\ttree it = TREE_TYPE (TREE_OPERAND (ics1, 0));\n+\tif (TREE_CODE (it) != POINTER_TYPE\n+\t    && ! TYPE_PTRMEMFUNC_TYPE (it))\n+\t  bool1 = 0;\n+      }\n+    if (bool2)\n+      {\n+\ttree it = TREE_TYPE (TREE_OPERAND (ics2, 0));\n+\tif (TREE_CODE (it) != POINTER_TYPE\n+\t    && ! TYPE_PTRMEMFUNC_TYPE (it))\n+\t  bool2 = 0;\n+      }\n+    if (bool1 && ! bool2)\n+      return 1;\n+    if (bool2 && ! bool1)\n+      return -1;\n+  }\n+#endif\n+\n+  if (TREE_CODE (ics1) == QUAL_CONV)\n+    main1 = TREE_OPERAND (ics1, 0);\n+  else\n+    main1 = ics1;\n+\n+  if (TREE_CODE (ics2) == QUAL_CONV)\n+    main2 = TREE_OPERAND (ics2, 0);\n+  else\n+    main2 = ics2;\n+\n+  if (TREE_CODE (main1) != TREE_CODE (main2))\n+    return 0;\n+\n+  if (TREE_CODE (main1) == PTR_CONV || TREE_CODE (main1) == PMEM_CONV\n+      || TREE_CODE (main1) == REF_BIND)\n+    {\n+      tree to1 = TREE_TYPE (main1);\n+      tree from1 = TREE_TYPE (TREE_OPERAND (main1, 0));\n+      tree to2 = TREE_TYPE (main2);\n+      tree from2 = TREE_TYPE (TREE_OPERAND (main2, 0));\n+      int distf, distt;\n+\n+      /* Standard conversion sequence S1 is a better conversion sequence than\n+\t standard conversion sequence S2 if...\n+\n+\t S1 and S2 differ only in their qualification conversion  and  they\n+\t yield types identical except for cv-qualifiers and S2 adds all the\n+\t qualifiers that S1 adds (and in the same places) and S2  adds  yet\n+\t more  cv-qualifiers  than  S1,  or the similar case with reference\n+\t binding15). */\n+      if (from1 == from2 && to1 == to2)\n+\t{\n+\t  to1 = TREE_TYPE (TREE_TYPE (ics1));\n+\t  to2 = TREE_TYPE (TREE_TYPE (ics2));\n+\t  if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n+\t      && TYPE_VOLATILE (to1) > TYPE_VOLATILE (to2))\n+\t    return 1;\n+\t  else if (TYPE_READONLY (to1) > TYPE_READONLY (to2)\n+\t\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n+\t    return 1;\n+\t  else if (TYPE_READONLY (to1) <= TYPE_READONLY (to2)\n+\t\t   && TYPE_VOLATILE (to1) < TYPE_VOLATILE (to2))\n+\t    return -1;\n+\t  else if (TYPE_READONLY (to1) < TYPE_READONLY (to2)\n+\t\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n+\t    return -1;\n+\t  return 0;\n+\t}\n+\t\n+      if (TYPE_PTRMEMFUNC_P (to1))\n+\t{\n+\t  to1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to1));\n+\t  from1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from1));\n+\t}\n+      else\n+\t{\n+\t  to1 = TREE_TYPE (to1);\n+\t  from1 = TREE_TYPE (from1);\n+\n+\t  if (TREE_CODE (to1) == OFFSET_TYPE)\n+\t    {\n+\t      to1 = TYPE_OFFSET_BASETYPE (to1);\n+\t      from1 = TYPE_OFFSET_BASETYPE (from1);\n+\t    }\n+\t}\n+\n+      if (TYPE_PTRMEMFUNC_P (to2))\n+\t{\n+\t  to2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to2));\n+\t  from2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from2));\n+\t}\n+      else\n+\t{\n+\t  to2 = TREE_TYPE (to2);\n+\t  from2 = TREE_TYPE (from2);\n+\n+\t  if (TREE_CODE (to2) == OFFSET_TYPE)\n+\t    {\n+\t      to2 = TYPE_OFFSET_BASETYPE (to2);\n+\t      from2 = TYPE_OFFSET_BASETYPE (from2);\n+\t    }\n+\t}\n+\n+      if (! (IS_AGGR_TYPE (from1) && IS_AGGR_TYPE (from2)))\n+\treturn 0;\n+\n+      distf = get_base_distance (from1, from2, 0, 0);\n+      if (distf == -1)\n+\tdistf = -get_base_distance (from2, from1, 0, 0);\n+      if (distf == -1)\n+\treturn 0;\n+\n+      /* If class B is derived directly or indirectly from class  A,  conver-\n+\t sion  of  B*  to  A*  is  better than conversion of B* to void*, and\n+\t conversion of A* to void* is better than conversion of B* to void*. */\n+\n+      if (TREE_CODE (to1) == VOID_TYPE && TREE_CODE (to2) == VOID_TYPE)\n+\t{\n+\t  if (distf > 0)\n+\t    return 1;\n+\t  else if (distf < 0)\n+\t    return -1;\n+\t}\n+      else if (TREE_CODE (to2) == VOID_TYPE && IS_AGGR_TYPE (to1)\n+\t       && get_base_distance (to1, from1, 0, 0) != -1)\n+\treturn 1;\n+      else if (TREE_CODE (to1) == VOID_TYPE && IS_AGGR_TYPE (to2)\n+\t       && get_base_distance (to2, from2, 0, 0) != -1)\n+\treturn -1;\n+\n+      if (! (IS_AGGR_TYPE (to1) && IS_AGGR_TYPE (to2)))\n+\treturn 0;\n+\n+      /* If  class B is derived directly or indirectly from class A and class\n+\t C is derived directly or indirectly from B */\n+\n+      distt = get_base_distance (to1, to2, 0, 0);\n+      if (distt == -1)\n+\tdistt = -get_base_distance (to2, to1, 0, 0);\n+      if (distt == -1)\n+\treturn 0;\n+\n+      /* --conversion of C* to B* is better than conversion of C* to A*, */\n+      if (distf == 0)\n+\t{\n+\t  if (distt > 0)\n+\t    return -1;\n+\t  else if (distt < 0)\n+\t    return 1;\n+\t}\n+      /* --conversion of B* to A* is better than conversion of C* to A*, */\n+      else if (distt == 0)\n+\t{\n+\t  if (distf > 0)\n+\t    return 1;\n+\t  else if (distf < 0)\n+\t    return -1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+int joust (cand1, cand2)\n+     struct z_candidate *cand1, *cand2;\n+{\n+  int winner = 0;\n+  int i;\n+\n+  for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n+    {\n+      int comp = compare_ics (TREE_VEC_ELT (cand1->convs, i),\n+\t\t\t      TREE_VEC_ELT (cand2->convs, i));\n+\n+      if (comp != 0)\n+\t{\n+\t  if (winner && comp != winner)\n+\t    return 0;\n+\t  winner = comp;\n+\t}\n+    }\n+\n+  if (winner == 0 && cand1->second_ics)\n+    winner = compare_ics (cand1->second_ics, cand2->second_ics);\n+\n+  return winner;\n+}\n+\n+struct z_candidate *\n+tourney (candidates)\n+     struct z_candidate *candidates;\n+{\n+  struct z_candidate *champ = candidates, *challenger;\n+  int fate;\n+\n+  /* This algorithm has a worst case of O(2n) (winner is last) , and a best\n+     case of O(n/2) (no winner); much better than a sorting algorithm.  */\n+\n+  for (challenger = champ->next; challenger; )\n+    {\n+      fate = joust (champ, challenger);\n+      if (fate == 1)\n+\tchallenger = challenger->next;\n+      else\n+\t{\n+\t  if (fate == 0)\n+\t    {\n+\t      champ = challenger->next;\n+\t      if (champ == 0)\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    champ = challenger;\n+\n+\t  challenger = champ->next;\n+\t}\n+    }\n+\n+  for (challenger = candidates; challenger != champ;\n+       challenger = challenger->next)\n+    {\n+      fate = joust (champ, challenger);\n+      if (fate != 1)\n+\treturn 0;\n+    }\n+\n+  return champ;\n+}\n #endif"}, {"sha": "fe1b60fb2dfdab15a33691b53fb56c223dae96bd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 89, "deletions": 64, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -300,18 +300,34 @@ tree pfn_identifier, index_identifier, delta_identifier, delta2_identifier;\n tree pfn_or_delta2_identifier, tag_identifier;\n tree vt_off_identifier;\n \n+struct named_label_list\n+{\n+  struct binding_level *binding_level;\n+  tree names_in_scope;\n+  tree label_decl;\n+  char *filename_o_goto;\n+  int lineno_o_goto;\n+  struct named_label_list *next;\n+};\n+\n /* A list (chain of TREE_LIST nodes) of named label uses.\n    The TREE_PURPOSE field is the list of variables defined\n    the the label's scope defined at the point of use.\n    The TREE_VALUE field is the LABEL_DECL used.\n    The TREE_TYPE field holds `current_binding_level' at the\n    point of the label's use.\n \n+   BWAHAHAAHAHahhahahahaah.  No, no, no, said the little chicken.\n+\n+   Look at the pretty struct named_label_list. See the pretty struct\n+   with the pretty named fields that describe what they do. See the\n+   pretty lack of gratuitous casts. Notice the code got a lot cleaner.\n+\n    Used only for jumps to as-yet undefined labels, since\n    jumps to defined labels can have their validity checked\n    by stmt.c.  */\n \n-static tree named_label_uses;\n+static struct named_label_list *named_label_uses = NULL;\n \n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n@@ -1199,12 +1215,12 @@ poplevel (keep, reverse, functionbody)\n     level_chain = current_binding_level->level_chain;\n     if (level_chain)\n       {\n-\ttree labels;\n-\tfor (labels = named_label_uses; labels; labels = TREE_CHAIN (labels))\n-\t  if (TREE_TYPE (labels) == (tree)current_binding_level)\n+\tstruct named_label_list *labels;\n+\tfor (labels = named_label_uses; labels; labels = labels->next)\n+\t  if (labels->binding_level == current_binding_level)\n \t    {\n-\t      TREE_TYPE (labels) = (tree)level_chain;\n-\t      TREE_PURPOSE (labels) = level_chain->names;\n+\t      labels->binding_level = level_chain;\n+\t      labels->names_in_scope = level_chain->names;\n \t    }\n       }\n   }\n@@ -1739,11 +1755,9 @@ struct saved_scope {\n   tree old_bindings;\n   struct saved_scope *prev;\n   tree class_name, class_type, function_decl;\n-  tree base_init_list, member_init_list;\n   struct binding_level *class_bindings;\n   tree *lang_base, *lang_stack, lang_name;\n   int lang_stacksize;\n-  tree named_labels;\n   int minimal_parse_mode;\n   tree last_function_parms;\n   tree template_parms;\n@@ -1803,6 +1817,9 @@ maybe_push_to_top_level (pseudo)\n   struct binding_level *b = inner_binding_level;\n   tree old_bindings = NULL_TREE;\n \n+  if (current_function_decl)\n+    push_cp_function_context (NULL_TREE);\n+\n   if (previous_class_type)\n     old_bindings = store_bindings (previous_class_values, old_bindings);\n \n@@ -1832,19 +1849,17 @@ maybe_push_to_top_level (pseudo)\n   s->class_name = current_class_name;\n   s->class_type = current_class_type;\n   s->function_decl = current_function_decl;\n-  s->base_init_list = current_base_init_list;\n-  s->member_init_list = current_member_init_list;\n   s->class_bindings = class_binding_level;\n   s->lang_stack = current_lang_stack;\n   s->lang_base = current_lang_base;\n   s->lang_stacksize = current_lang_stacksize;\n   s->lang_name = current_lang_name;\n-  s->named_labels = named_labels;\n   s->minimal_parse_mode = minimal_parse_mode;\n   s->last_function_parms = last_function_parms;\n   s->template_parms = current_template_parms;\n   s->previous_class_type = previous_class_type;\n   s->previous_class_values = previous_class_values;\n+\n   current_class_name = current_class_type = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   class_binding_level = (struct binding_level *)0;\n@@ -1902,8 +1917,6 @@ pop_from_top_level ()\n     }\n   current_class_name = s->class_name;\n   current_class_type = s->class_type;\n-  current_base_init_list = s->base_init_list;\n-  current_member_init_list = s->member_init_list;\n   current_function_decl = s->function_decl;\n   class_binding_level = s->class_bindings;\n   free (current_lang_base);\n@@ -1915,14 +1928,16 @@ pop_from_top_level ()\n     strict_prototype = strict_prototypes_lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n     strict_prototype = strict_prototypes_lang_c;\n-  named_labels = s->named_labels;\n   minimal_parse_mode = s->minimal_parse_mode;\n   last_function_parms = s->last_function_parms;\n   current_template_parms = s->template_parms;\n   previous_class_type = s->previous_class_type;\n   previous_class_values = s->previous_class_values;\n \n   free (s);\n+\n+  if (current_function_decl)\n+    pop_cp_function_context (NULL_TREE);\n }\n \f\n /* Push a definition of struct, union or enum tag \"name\".\n@@ -3717,13 +3732,20 @@ lookup_label (id)\n \n   if ((decl == NULL_TREE\n       || DECL_SOURCE_LINE (decl) == 0)\n-      && (named_label_uses == NULL_TREE\n-\t  || TREE_PURPOSE (named_label_uses) != current_binding_level->names\n-\t  || TREE_VALUE (named_label_uses) != decl))\n-    {\n-      named_label_uses\n-\t= tree_cons (current_binding_level->names, decl, named_label_uses);\n-      TREE_TYPE (named_label_uses) = (tree)current_binding_level;\n+      && (named_label_uses == NULL\n+\t  || named_label_uses->names_in_scope != current_binding_level->names\n+\t  || named_label_uses->label_decl != decl))\n+    {\n+      struct named_label_list *new_ent;\n+      new_ent\n+\t= (struct named_label_list*)oballoc (sizeof (struct named_label_list));\n+      new_ent->label_decl = decl;\n+      new_ent->names_in_scope = current_binding_level->names;\n+      new_ent->binding_level = current_binding_level;\n+      new_ent->lineno_o_goto = lineno;\n+      new_ent->filename_o_goto = input_filename;\n+      new_ent->next = named_label_uses;\n+      named_label_uses = new_ent;\n     }\n \n   /* Use a label already defined or ref'd with this name.  */\n@@ -3754,7 +3776,7 @@ lookup_label (id)\n   SET_IDENTIFIER_LABEL_VALUE (id, decl);\n \n   named_labels = tree_cons (NULL_TREE, decl, named_labels);\n-  TREE_VALUE (named_label_uses) = decl;\n+  named_label_uses->label_decl = decl;\n \n   return decl;\n }\n@@ -3830,7 +3852,7 @@ define_label (filename, line, name)\n     }\n   else\n     {\n-      tree uses, prev;\n+      struct named_label_list *uses, *prev;\n       int identified = 0;\n \n       /* Mark label as having been defined.  */\n@@ -3839,17 +3861,17 @@ define_label (filename, line, name)\n       DECL_SOURCE_FILE (decl) = filename;\n       DECL_SOURCE_LINE (decl) = line;\n \n-      for (prev = NULL_TREE, uses = named_label_uses;\n-\t   uses;\n-\t   prev = uses, uses = TREE_CHAIN (uses))\n-\tif (TREE_VALUE (uses) == decl)\n+      prev = NULL;\n+      uses = named_label_uses;\n+      while (uses != NULL)\n+\tif (uses->label_decl == decl)\n \t  {\n \t    struct binding_level *b = current_binding_level;\n \t    while (b)\n \t      {\n \t\ttree new_decls = b->names;\n-\t\ttree old_decls = ((tree)b == TREE_TYPE (uses)\n-\t\t\t\t  ? TREE_PURPOSE (uses) : NULL_TREE);\n+\t\ttree old_decls = (b == uses->binding_level)\n+\t\t\t\t  ? uses->names_in_scope : NULL_TREE;\n \t\twhile (new_decls != old_decls)\n \t\t  {\n \t\t    if (TREE_CODE (new_decls) == VAR_DECL\n@@ -3862,23 +3884,35 @@ define_label (filename, line, name)\n \t\t\t     && DECL_INITIAL (new_decls) != error_mark_node)\n \t\t\t    || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (new_decls))))\n \t\t      {\n-\t\t\tif (! identified)\n-\t\t\t  cp_error (\"jump to label `%D'\", decl);\n-\t\t\tidentified = 1;\n+\t\t\tif (! identified) \n+\t\t\t  {\n+\t\t\t    cp_error (\"jump to label `%D'\", decl);\n+\t\t\t    error_with_file_and_line (uses->filename_o_goto,\n+\t\t\t\t\t\t      uses->lineno_o_goto,\n+\t\t\t\t\t\t      \"  from here\");\n+\t\t\t    identified = 1;\n+\t\t\t}\n \t\t\tcp_error_at (\"  crosses initialization of `%#D'\",\n \t\t\t\t     new_decls);\n \t\t      }\n \t\t    new_decls = TREE_CHAIN (new_decls);\n \t\t  }\n-\t\tif ((tree)b == TREE_TYPE (uses))\n+\t\tif (b == uses->binding_level)\n \t\t  break;\n \t\tb = b->level_chain;\n \t      }\n \n-\t    if (prev)\n-\t      TREE_CHAIN (prev) = TREE_CHAIN (uses);\n+\t    if (prev != NULL)\n+\t      prev->next = uses->next;\n \t    else\n-\t      named_label_uses = TREE_CHAIN (uses);\n+\t      named_label_uses = uses->next;\n+\n+\t    uses = uses->next;\n+\t  }\n+\telse\n+\t  {\n+\t    prev = uses;\n+\t    uses = uses->next;\n \t  }\n       current_function_return_value = NULL_TREE;\n       return decl;\n@@ -4665,7 +4699,7 @@ init_decl_processing ()\n \n   current_function_decl = NULL_TREE;\n   named_labels = NULL_TREE;\n-  named_label_uses = NULL_TREE;\n+  named_label_uses = NULL;\n   current_binding_level = NULL_BINDING_LEVEL;\n   free_binding_level = NULL_BINDING_LEVEL;\n \n@@ -5797,8 +5831,13 @@ start_decl (declarator, declspecs, initialized, raises)\n \t  tree field = lookup_field (context, DECL_NAME (decl), 0, 0);\n \t  if (field == NULL_TREE || TREE_CODE (field) != VAR_DECL)\n \t    cp_error (\"`%#D' is not a static member of `%#T'\", decl, context);\n-\t  else if (duplicate_decls (decl, field))\n-\t    decl = field;\n+\t  else\n+\t    {\n+\t      if (DECL_CONTEXT (field) != context)\n+\t\tcp_pedwarn (\"ANSI C++ does not permit `%T::%D' to be defined as `%T::%D'\", DECL_CONTEXT (field), DECL_NAME (decl), context, DECL_NAME (decl));\n+\t      if (duplicate_decls (decl, field))\n+\t\tdecl = field;\n+\t    }\n \t}\n       else\n \t{\n@@ -6034,25 +6073,7 @@ grok_reference_init (decl, type, init, cleanupp)\n     goto fail;\n   else if (tmp != NULL_TREE)\n     {\n-      tree subtype = TREE_TYPE (type);\n       init = tmp;\n-\n-      /* Associate the cleanup with the reference so that we\n-\t don't get burned by \"aggressive\" cleanup policy.  */\n-      if (TYPE_NEEDS_DESTRUCTOR (subtype))\n-\t{\n-\t  if (TREE_CODE (tmp) == ADDR_EXPR)\n-\t    tmp = TREE_OPERAND (tmp, 0);\n-\t  if (TREE_CODE (tmp) == TARGET_EXPR)\n-\t    {\n-\t      *cleanupp = build_delete\n-\t\t(build_pointer_type (subtype),\n-\t\t build_unary_op (ADDR_EXPR, TREE_OPERAND (tmp, 0), 0),\n-\t\t integer_two_node, LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n-\t      TREE_OPERAND (tmp, 2) = error_mark_node;\n-\t    }\n-\t}\n-\n       DECL_INITIAL (decl) = save_expr (init);\n     }\n   else\n@@ -6620,7 +6641,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t{\n \t\t  /* XXX: Why don't we use decl here?  */\n \t\t  /* Ans: Because it was already expanded? */\n-\t\t  if (! cp_expand_decl_cleanup (NULL_TREE, cleanup))\n+\t\t  if (! expand_decl_cleanup (NULL_TREE, cleanup))\n \t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      decl);\n \t\t  /* Cleanup used up here.  */\n@@ -6710,7 +6731,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t      /* Store the cleanup, if there was one.  */\n \t      if (cleanup)\n \t\t{\n-\t\t  if (! cp_expand_decl_cleanup (decl, cleanup))\n+\t\t  if (! expand_decl_cleanup (decl, cleanup))\n \t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      decl);\n \t\t}\n@@ -7113,6 +7134,8 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       if (check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n+\t  if (tmp && DECL_ARTIFICIAL (tmp))\n+\t    cp_error (\"definition of implicitly-declared `%D'\", tmp);\n \t  if (tmp && duplicate_decls (decl, tmp))\n \t    return tmp;\n \t}\n@@ -7159,6 +7182,8 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n \t      revert_static_member_fn (&decl, NULL, NULL);\n \t      last_function_parms = TREE_CHAIN (last_function_parms);\n \t    }\n+\t  if (tmp && DECL_ARTIFICIAL (tmp))\n+\t    cp_error (\"definition of implicitly-declared `%D'\", tmp);\n \t  if (tmp && duplicate_decls (decl, tmp))\n \t    return tmp;\n \t}\n@@ -7224,7 +7249,7 @@ grokvardecl (type, declarator, specbits, initialized, constp)\n       DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype, declarator);\n     }\n   else\n-    decl = build_decl (VAR_DECL, declarator, type);\n+    decl = build_decl (VAR_DECL, declarator, complete_type (type));\n \n   DECL_ASSEMBLER_NAME (decl) = current_namespace_id (DECL_ASSEMBLER_NAME (decl));\n \n@@ -9118,7 +9143,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    return NULL_TREE;\n \t  }\n \n-\tdecl = build_decl (PARM_DECL, declarator, type);\n+\tdecl = build_decl (PARM_DECL, declarator, complete_type (type));\n \n \tbad_specifiers (decl, \"parameter\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n@@ -11279,7 +11304,7 @@ store_parm_decls ()\n \t\t  && (cleanup = maybe_build_cleanup (parm), cleanup))\n \t\t{\n \t\t  expand_decl (parm);\n-\t\t  if (! cp_expand_decl_cleanup (parm, cleanup))\n+\t\t  if (! expand_decl_cleanup (parm, cleanup))\n \t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t      parm);\n \t\t  parms_have_cleanups = 1;\n@@ -11973,7 +11998,7 @@ finish_function (lineno, call_poplevel, nested)\n       current_function_decl = NULL_TREE;\n     }\n \n-  named_label_uses = NULL_TREE;\n+  named_label_uses = NULL;\n   current_class_ptr = NULL_TREE;\n   current_class_ref = NULL_TREE;\n }\n@@ -12200,7 +12225,7 @@ hack_incomplete_structures (type)\n \t      expand_decl (decl);\n \t      cleanup = maybe_build_cleanup (decl);\n \t      expand_decl_init (decl);\n-\t      if (! cp_expand_decl_cleanup (decl, cleanup))\n+\t      if (! expand_decl_cleanup (decl, cleanup))\n \t\tcp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t\t  decl);\n \t    }"}, {"sha": "db4f294ff864b8fe29ddca9cc4898c189d77b0bd", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -1285,7 +1285,8 @@ dump_expr (t, nop)\n       break;\n \n     case CAST_EXPR:\n-      if (TREE_CHAIN (TREE_OPERAND (t, 0)))\n+      if (TREE_OPERAND (t, 0) == NULL_TREE\n+\t  || TREE_CHAIN (TREE_OPERAND (t, 0)))\n \t{\n \t  dump_type (TREE_TYPE (t), 0);\n \t  OB_PUTC ('(');"}, {"sha": "adebe3b47210ab694a643919cfb16f906faad025", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -962,7 +962,7 @@ push_eh_cleanup ()\n   cleanup = build (COMPOUND_EXPR, void_type_node, cleanup,\n \t\t   build_modify_expr (saved_in_catch, NOP_EXPR,\n \t\t\t\t      build_modify_expr (saved_throw_type, NOP_EXPR, integer_zero_node)));\n-  cp_expand_decl_cleanup (NULL_TREE, cleanup);\n+  expand_decl_cleanup (NULL_TREE, cleanup);\n \n   resume_momentary (yes);\n }"}, {"sha": "be3d89659e31e071652d09bf1d14f1d8eabcbd36", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -9,7 +9,7 @@\n @chapter Internal Architecture of the Compiler\n \n This is meant to describe the C++ front-end for gcc in detail.\n-Questions and comments to mrs@@cygnus.com.\n+Questions and comments to Mike Stump @code{<mrs@@cygnus.com>}.\n \n @menu\n * Limitations of g++::          \n@@ -310,9 +310,7 @@ vtables.  See also vtable and vfield.\n \n This section describes some of the macros used on trees.  The list\n should be alphabetical.  Eventually all macros should be documented\n-here.  There are some postscript drawings that can be used to better\n-understand from of the more complex data structures, contact Mike Stump\n-(@code{mrs@@cygnus.com}) for information about them.\n+here.\n \n @table @code\n @item BINFO_BASETYPES"}, {"sha": "bccbc29af3ce704dff8498725c04c88f4ddeacdc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -615,9 +615,14 @@ emit_base_init (t, immediately)\n       if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t{\n \t  start_protect ();\n+\n+\t  /* All cleanups must be on the function_obstack.  */\n+\t  push_obstacks_nochange ();\n+\t  resume_temporary_allocation ();\n \t  protect_list = tree_cons (NULL_TREE,\n \t\t\t\t    build_partial_cleanup_for (base_binfo),\n \t\t\t\t    protect_list);\n+\t  pop_obstacks ();\n \t}\n \n       rbase_init_list = TREE_CHAIN (rbase_init_list);"}, {"sha": "fffbc8a8059b8d170bf070d02bea95b061cfd3df", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -2750,24 +2750,6 @@ identifier_typedecl_value (node)\n   return NULL_TREE;\n }\n \n-struct try_type\n-{\n-  tree *node_var;\n-  char unsigned_flag;\n-  char long_flag;\n-  char long_long_flag;\n-};\n-\n-struct try_type type_sequence[] = \n-{\n-  { &integer_type_node, 0, 0, 0},\n-  { &unsigned_type_node, 1, 0, 0},\n-  { &long_integer_type_node, 0, 1, 0},\n-  { &long_unsigned_type_node, 1, 1, 0},\n-  { &long_long_integer_type_node, 0, 1, 1},\n-  { &long_long_unsigned_type_node, 1, 1, 1}\n-};\n-\n int\n real_yylex ()\n {\n@@ -3528,83 +3510,10 @@ real_yylex ()\n \t    yylval.ttype = build_int_2 (low, high);\n \t    TREE_TYPE (yylval.ttype) = long_long_unsigned_type_node;\n \n-#if 0\n-\t    /* Find the first allowable type that the value fits in.  */\n-\t    type = 0;\n-\t    for (i = 0; i < sizeof (type_sequence) / sizeof (type_sequence[0]);\n-\t\t i++)\n-\t      if (!(spec_long && !type_sequence[i].long_flag)\n-\t\t  && !(spec_long_long && !type_sequence[i].long_long_flag)\n-\t\t  && !(spec_unsigned && !type_sequence[i].unsigned_flag)\n-\t\t  /* A hex or octal constant traditionally is unsigned.  */\n-\t\t  && !(base != 10 && flag_traditional\n-\t\t       && !type_sequence[i].unsigned_flag)\n-\t\t  /* A decimal constant can't be unsigned int\n-\t\t     unless explicitly specified.  */\n-\t\t  && !(base == 10 && !spec_unsigned\n-\t\t       && *type_sequence[i].node_var == unsigned_type_node))\n-\t\tif (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var))\n-\t\t  {\n-\t\t    type = *type_sequence[i].node_var;\n-\t\t    break;\n-\t\t  }\n-\t    if (flag_traditional && type == long_unsigned_type_node\n-\t\t&& !spec_unsigned)\n-\t      type = long_integer_type_node;\n-\t      \n-\t    if (type == 0)\n-\t      {\n-\t\ttype = long_long_integer_type_node;\n-\t\twarning (\"integer constant out of range\");\n-\t      }\n-\n-\t    /* Warn about some cases where the type of a given constant\n-\t       changes from traditional C to ANSI C.  */\n-\t    if (warn_traditional)\n-\t      {\n-\t\ttree other_type = 0;\n-\n-\t\t/* This computation is the same as the previous one\n-\t\t   except that flag_traditional is used backwards.  */\n-\t\tfor (i = 0; i < sizeof (type_sequence) / sizeof (type_sequence[0]);\n-\t\t     i++)\n-\t\t  if (!(spec_long && !type_sequence[i].long_flag)\n-\t\t      && !(spec_long_long && !type_sequence[i].long_long_flag)\n-\t\t      && !(spec_unsigned && !type_sequence[i].unsigned_flag)\n-\t\t      /* A hex or octal constant traditionally is unsigned.  */\n-\t\t      && !(base != 10 && !flag_traditional\n-\t\t\t   && !type_sequence[i].unsigned_flag)\n-\t\t      /* A decimal constant can't be unsigned int\n-\t\t\t unless explicitly specified.  */\n-\t\t      && !(base == 10 && !spec_unsigned\n-\t\t\t   && *type_sequence[i].node_var == unsigned_type_node))\n-\t\t    if (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var))\n-\t\t      {\n-\t\t\tother_type = *type_sequence[i].node_var;\n-\t\t\tbreak;\n-\t\t      }\n-\t\tif (!flag_traditional && type == long_unsigned_type_node\n-\t\t    && !spec_unsigned)\n-\t\t  type = long_integer_type_node;\n-\t      \n-\t\tif (other_type != 0 && other_type != type)\n-\t\t  {\n-\t\t    if (flag_traditional)\n-\t\t      warning (\"type of integer constant would be different without -traditional\");\n-\t\t    else\n-\t\t      warning (\"type of integer constant would be different with -traditional\");\n-\t\t  }\n-\t      }\n-\n-#else /* 1 */\n \t    if (!spec_long && !spec_unsigned\n \t\t&& !(flag_traditional && base != 10)\n \t\t&& int_fits_type_p (yylval.ttype, integer_type_node))\n \t      {\n-#if 0\n-\t\tif (warn_traditional && base != 10)\n-\t\t  warning (\"small nondecimal constant becomes signed in ANSI C++\");\n-#endif\n \t\ttype = integer_type_node;\n \t      }\n \t    else if (!spec_long && (base != 10 || spec_unsigned)\n@@ -3622,10 +3531,6 @@ real_yylex ()\n \t\t     && int_fits_type_p (yylval.ttype,\n \t\t\t\t\t long_unsigned_type_node))\n \t      {\n-#if 0\n-\t\tif (warn_traditional && !spec_unsigned)\n-\t\t  warning (\"large integer constant becomes unsigned in ANSI C++\");\n-#endif\n \t\tif (flag_traditional && !spec_unsigned)\n \t\t  type = long_integer_type_node;\n \t\telse\n@@ -3642,11 +3547,6 @@ real_yylex ()\n \t    else if (int_fits_type_p (yylval.ttype,\n \t\t\t\t      long_long_unsigned_type_node))\n \t      {\n-#if 0\n-\t\tif (warn_traditional && !spec_unsigned)\n-\t\t  warning (\"large nondecimal constant is unsigned in ANSI C++\");\n-#endif\n-\n \t\tif (flag_traditional && !spec_unsigned)\n \t\t  type = long_long_integer_type_node;\n \t\telse\n@@ -3661,7 +3561,6 @@ real_yylex ()\n \t\tif (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n \t\t  warning (\"decimal integer constant is so large that it is unsigned\");\n \t      }\n-#endif\n \n \t    TREE_TYPE (yylval.ttype) = type;\n \t    *p = 0;"}, {"sha": "aa607e676a781a1280bc70ffcbb76bdde0d17a49", "filename": "gcc/cp/method.c", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -1751,9 +1751,11 @@ emit_thunk (thunk_fndecl)\n     abort ();\n   current_function_decl = thunk_fndecl;\n #ifdef ASM_OUTPUT_MI_THUNK\n+  temporary_allocation ();\n   assemble_start_function (thunk_fndecl, fnname);\n   ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n   assemble_end_function (thunk_fndecl, fnname);\n+  permanent_allocation (1);\n #else\n   save_ofp = flag_omit_frame_pointer;\n   flag_omit_frame_pointer = 1;\n@@ -1995,8 +1997,12 @@ do_build_copy_constructor (fndecl)\n \t    (build_reference_type (basetype), parm,\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n-\t  current_base_init_list = tree_cons (basetype,\n-\t\t\t\t\t      p, current_base_init_list);\n+\n+\t  if (p == error_mark_node)\n+\t    cp_error (\"in default copy constructor\");\n+\t  else \n+\t    current_base_init_list = tree_cons (basetype,\n+\t\t\t\t\t\tp, current_base_init_list);\n \t}\n \t\n       for (i = 0; i < n_bases; ++i)\n@@ -2009,9 +2015,15 @@ do_build_copy_constructor (fndecl)\n \t  p = convert_to_reference\n \t    (build_reference_type (basetype), parm,\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n-\t  p = convert_from_reference (p);\n-\t  current_base_init_list = tree_cons (basetype,\n-\t\t\t\t\t      p, current_base_init_list);\n+\n+\t  if (p == error_mark_node) \n+\t    cp_error (\"in default copy constructor\");\n+\t  else \n+\t    {\n+\t      p = convert_from_reference (p);\n+\t      current_base_init_list = tree_cons (basetype,\n+\t\t\t\t\t\t  p, current_base_init_list);\n+\t    }\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n@@ -2080,16 +2092,13 @@ do_build_assign_ref (fndecl)\n       for (i = 0; i < n_bases; ++i)\n \t{\n \t  tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n-\t  if (TYPE_HAS_ASSIGN_REF (basetype))\n-\t    {\n-\t      tree p = convert_to_reference\n-\t\t(build_reference_type (basetype), parm,\n-\t\t CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n-\t      p = convert_from_reference (p);\n-\t      p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n-\t\t\t\t     build_tree_list (NULL_TREE, p));\n-\t      expand_expr_stmt (p);\n-\t    }\n+\t  tree p = convert_to_reference\n+\t    (build_reference_type (basetype), parm,\n+\t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n+\t  p = convert_from_reference (p);\n+\t  p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n+\t\t\t\t build_tree_list (NULL_TREE, p));\n+\t  expand_expr_stmt (p);\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n@@ -2098,6 +2107,24 @@ do_build_assign_ref (fndecl)\n \n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n+\n+\t  if (TREE_READONLY (field))\n+\t    {\n+\t      if (DECL_NAME (field))\n+\t\tcp_error (\"non-static const member `%#D', can't use default assignment operator\", field);\n+\t      else\n+\t\tcp_error (\"non-static const member in type `%T', can't use default assignment operator\", current_class_type);\n+\t      continue;\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n+\t    {\n+\t      if (DECL_NAME (field))\n+\t\tcp_error (\"non-static reference member `%#D', can't use default assignment operator\", field);\n+\t      else\n+\t\tcp_error (\"non-static reference member in type `%T', can't use default assignment operator\", current_class_type);\n+\t      continue;\n+\t    }\n+\n \t  if (DECL_NAME (field))\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))"}, {"sha": "39fadec4f1163276ea3b874b211b071ae497b18b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -1187,6 +1187,7 @@ instantiate_class_template (type)\n \n       /* XXX handle attributes */\n       type = finish_struct_1 (type, NULL_TREE, 0);\n+      CLASSTYPE_GOT_SEMICOLON (type) = 1;\n     }\n   else\n     {\n@@ -2968,8 +2969,6 @@ instantiate_decl (d)\n   if (! push_tinst_level (d))\n     return d;\n \n-  if (TREE_CODE (d) == FUNCTION_DECL && nested)\n-    push_cp_function_context (NULL_TREE);\n   push_to_top_level ();\n \n   /* Trick tsubst into giving us a new decl in case the template changed.  */\n@@ -3044,8 +3043,6 @@ instantiate_decl (d)\n     }\n \n   pop_from_top_level ();\n-  if (TREE_CODE (d) == FUNCTION_DECL && nested)\n-    pop_cp_function_context (NULL_TREE);\n   pop_tinst_level ();\n \n   return d;"}, {"sha": "465234c63aa5ffd23be29f37ab14ceb02ce589e4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -3508,7 +3508,7 @@ add_conversions (binfo)\n       tree tmp = TREE_VEC_ELT (method_vec, i);\n       if (! IDENTIFIER_TYPENAME_P (DECL_NAME (tmp)))\n \tbreak;\n-      conversions = tree_cons (DECL_NAME (tmp), TREE_TYPE (TREE_TYPE (tmp)),\n+      conversions = tree_cons (TREE_TYPE (TREE_TYPE (tmp)), tmp,\n \t\t\t       conversions);\n     }\n }"}, {"sha": "b61932f387934647bc90b18ff9520cec46f527db", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -220,7 +220,7 @@ build_cplus_new (type, init)\n \t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   TREE_ADDRESSABLE (rval) = 1;\n-  rval = build (TARGET_EXPR, type, slot, rval, NULL_TREE);\n+  rval = build (TARGET_EXPR, type, slot, rval, NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   TREE_ADDRESSABLE (rval) = 1;\n \n@@ -399,7 +399,7 @@ build_cplus_method_type (basetype, rettype, argtypes)\n }\n \n tree\n-build_cplus_array_type (elt_type, index_type)\n+build_cplus_array_type_1 (elt_type, index_type)\n      tree elt_type;\n      tree index_type;\n {\n@@ -433,6 +433,24 @@ build_cplus_array_type (elt_type, index_type)\n   saveable_obstack = ambient_saveable_obstack;\n   return t;\n }\n+\n+tree\n+build_cplus_array_type (elt_type, index_type)\n+     tree elt_type;\n+     tree index_type;\n+{\n+  tree t;\n+  int constp = TYPE_READONLY (elt_type);\n+  int volatilep = TYPE_VOLATILE (elt_type);\n+  elt_type = TYPE_MAIN_VARIANT (elt_type);\n+\n+  t = build_cplus_array_type_1 (elt_type, index_type);\n+\n+  if (constp || volatilep)\n+    t = cp_build_type_variant (t, constp, volatilep);\n+\n+  return t;\n+}\n \f\n /* Make a variant type in the proper way for C/C++, propagating qualifiers\n    down to the element type of an array.  */\n@@ -451,9 +469,9 @@ cp_build_type_variant (type, constp, volatilep)\n \n       push_obstacks (TYPE_OBSTACK (real_main_variant),\n \t\t     TYPE_OBSTACK (real_main_variant));\n-      type = build_cplus_array_type (cp_build_type_variant (TREE_TYPE (type),\n-\t\t\t\t\t\t\t    constp, volatilep),\n-\t\t\t\t     TYPE_DOMAIN (type));\n+      type = build_cplus_array_type_1 (cp_build_type_variant\n+\t\t\t\t       (TREE_TYPE (type), constp, volatilep),\n+\t\t\t\t       TYPE_DOMAIN (type));\n \n       /* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not,\n \t make a copy.  (TYPE might have come from the hash table and\n@@ -467,6 +485,7 @@ cp_build_type_variant (type, constp, volatilep)\n \n       TYPE_MAIN_VARIANT (type) = real_main_variant;\n       pop_obstacks ();\n+      return type;\n     }\n   return build_type_variant (type, constp, volatilep);\n }\n@@ -1753,16 +1772,6 @@ break_out_target_exprs (t)\n   return mapcar (t, bot_manip);\n }\n \n-/* Since cleanup may have SAVE_EXPRs in it, we protect it with an\n-   UNSAVE_EXPR as the backend cannot yet handle SAVE_EXPRs in cleanups\n-   by itself.  */\n-int\n-cp_expand_decl_cleanup (decl, cleanup)\n-     tree decl, cleanup;\n-{\n-  return expand_decl_cleanup (decl, unsave_expr (cleanup));\n-}\n-\n /* Obstack used for allocating nodes in template function and variable\n    definitions.  */\n "}, {"sha": "d8b26e76633955d3bbd1c4578ce879a9944d182b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e349ee739ed29cd4f7688629da646055c2b078da/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e349ee739ed29cd4f7688629da646055c2b078da", "patch": "@@ -129,7 +129,7 @@ complete_type (type)\n {\n   if (TYPE_SIZE (type) != NULL_TREE)\n     ;\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n+  else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n       tree t = complete_type (TREE_TYPE (type));\n       if (TYPE_SIZE (t) != NULL_TREE)\n@@ -437,20 +437,15 @@ common_type (t1, t2)\n \n     case ARRAY_TYPE:\n       {\n-\tint constp \n-\t  = TYPE_READONLY (t1) || TYPE_READONLY (t2);\n-\tint volatilep\n-\t  = TYPE_VOLATILE (t1) || TYPE_VOLATILE (t2);\n \ttree elt = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t1, attributes);\n \tif (elt == TREE_TYPE (t2) && TYPE_DOMAIN (t2))\n \t  return build_type_attribute_variant (t2, attributes);\n \t/* Merge the element types, and have a size if either arg has one.  */\n-\tt1 = build_cplus_array_type (TYPE_MAIN_VARIANT (elt), TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n-\tif (constp || volatilep)\n-\t  t1 = cp_build_type_variant (t1, constp, volatilep);\n+\tt1 = build_cplus_array_type\n+\t  (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n "}]}