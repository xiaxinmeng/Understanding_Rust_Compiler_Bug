{"sha": "9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUzOGY3MDI4ZjZmNTBmZDBkMGZmMjQwZjZiZDNkZGY4YmVkYWI0MA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-02-25T18:17:06Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-02-25T18:17:06Z"}, "message": "type_traits: Add the trivial is_union and is_class; add the __is_union_or_class extension.\n\n2005-02-25  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/type_traits: Add the trivial is_union and is_class;\n\tadd the __is_union_or_class extension.\n\t(is_enum, is_empty): Use the latter.\n\t* include/tr1/type_traits_fwd.h: Add __is_union_or_class.\n\t* testsuite/testsuite_tr1.h: Add UnionType; trivial formatting\n\tfixes.\n\t* testsuite/tr1/4_metaprogramming/composite_type_traits/\n\tis_union_or_class/is_union_or_class.cc: New.\n\t* testsuite/tr1/4_metaprogramming/composite_type_traits/\n\tis_union_or_class/typedefs.cc: Likewise.\n\nFrom-SVN: r95541", "tree": {"sha": "49210fc23539041121c41b5c606fef5dfa83477e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49210fc23539041121c41b5c606fef5dfa83477e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/comments", "author": null, "committer": null, "parents": [{"sha": "9e22cddd6f76ca9e13c289ee325c3690ca23152e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e22cddd6f76ca9e13c289ee325c3690ca23152e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e22cddd6f76ca9e13c289ee325c3690ca23152e"}], "stats": {"total": 321, "additions": 213, "deletions": 108}, "files": [{"sha": "3982be6402d87eaed16428117a553dea25248c86", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "patch": "@@ -1,3 +1,16 @@\n+2005-02-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/type_traits: Add the trivial is_union and is_class;\n+\tadd the __is_union_or_class extension.\n+\t(is_enum, is_empty): Use the latter.\n+\t* include/tr1/type_traits_fwd.h: Add __is_union_or_class.\n+\t* testsuite/testsuite_tr1.h: Add UnionType; trivial formatting\n+\tfixes.\n+\t* testsuite/tr1/4_metaprogramming/composite_type_traits/\n+\tis_union_or_class/is_union_or_class.cc: New.\n+\t* testsuite/tr1/4_metaprogramming/composite_type_traits/\n+\tis_union_or_class/typedefs.cc: Likewise.\n+\n 2005-02-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/tr1/6_containers/unordered/instantiate/hash.cc: Guard"}, {"sha": "240542151e4a6e4cac9e64c149188c1380e4771a", "filename": "libstdc++-v3/include/tr1/type_traits", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits?ref=9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "patch": "@@ -166,47 +166,22 @@ namespace tr1\n   _DEFINE_SPEC(2, is_member_function_pointer, _Tp _Cp::*,\n \t       is_function<_Tp>::value)\n \n-  template<typename _Tp, bool = (is_fundamental<_Tp>::value\n-\t\t\t\t || is_array<_Tp>::value\n-\t\t\t\t || is_pointer<_Tp>::value\n-\t\t\t\t || is_reference<_Tp>::value\n-\t\t\t\t || is_member_pointer<_Tp>::value\n-\t\t\t\t || is_function<_Tp>::value)>\n-    struct __is_enum_helper\n-    : public __sfinae_types\n-    {\n-    private:\n-      static __one __test(bool);\n-      static __one __test(char);\n-      static __one __test(signed char);\n-      static __one __test(unsigned char);\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-      static __one __test(wchar_t);\n-#endif\n-      static __one __test(short);\n-      static __one __test(unsigned short);\n-      static __one __test(int);\n-      static __one __test(unsigned int);\n-      static __one __test(long);\n-      static __one __test(unsigned long);\n-      static __one __test(long long);\n-      static __one __test(unsigned long long);\n-      static __two __test(...);\n-\n-      struct __convert\n-      { operator _Tp() const; };\n-\n-    public:\n-      static const bool __value = sizeof(__test(__convert())) == 1;\n-    };\n-\n-  template<typename _Tp>\n-    struct __is_enum_helper<_Tp, true>\n-    { static const bool __value = false; };\n-\n   template<typename _Tp>\n     struct is_enum\n-    : public integral_constant<bool, __is_enum_helper<_Tp>::__value> { };\n+    : public integral_constant<bool, !(is_fundamental<_Tp>::value\n+\t\t\t\t       || is_array<_Tp>::value\n+\t\t\t\t       || is_pointer<_Tp>::value\n+\t\t\t\t       || is_reference<_Tp>::value\n+\t\t\t\t       || is_member_pointer<_Tp>::value\n+\t\t\t\t       || is_function<_Tp>::value\n+\t\t\t\t       || __is_union_or_class<_Tp>::value)>\n+    { };\n+\n+  template<typename>\n+    struct is_union { };\n+\n+  template<typename>\n+    struct is_class { };\n \n   template<typename _Tp, bool = (is_void<_Tp>::value\n \t\t\t\t || is_reference<_Tp>::value)>\n@@ -264,6 +239,26 @@ namespace tr1\n \t\t\t       (is_member_object_pointer<_Tp>::value\n \t\t\t\t|| is_member_function_pointer<_Tp>::value)>\n     { };\n+\n+  template<typename _Tp>\n+    struct __is_union_or_class_helper\n+    : public __sfinae_types\n+    {\n+    private:\n+      template<typename _Up>\n+        static __one __test(int _Up::*);\n+      template<typename>\n+        static __two __test(...);\n+    \n+    public:\n+      static const bool __value = sizeof(__test<_Tp>(0)) == 1;\n+    };\n+\n+  // Extension.\n+  template<typename _Tp>\n+    struct __is_union_or_class\n+    : public integral_constant<bool, __is_union_or_class_helper<_Tp>::__value>\n+    { };\n   \n   /// @brief  type properties [4.5.3].\n   template<typename>\n@@ -289,26 +284,21 @@ namespace tr1\n \t\t\t\t      remove_all_extents<_Tp>::type>::value)>\n     { };\n \n-  template<typename>\n-    struct __is_empty_helper_1\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_empty_helper_2\n-    : public _Tp { };\n-\n-  // Unfortunately, without compiler support we cannot tell union from\n-  // class types, and is_empty doesn't work at all with the former. \n-  template<typename _Tp, bool = (is_fundamental<_Tp>::value\n-\t\t\t\t || is_array<_Tp>::value\n-\t\t\t\t || is_pointer<_Tp>::value\n-\t\t\t\t || is_reference<_Tp>::value\n-\t\t\t\t || is_member_pointer<_Tp>::value\n-\t\t\t\t || is_enum<_Tp>::value\n-\t\t\t\t || is_function<_Tp>::value)>\n+  // N.B. Without compiler support we cannot tell union from class types,\n+  // and is_empty doesn't work at all with the former. \n+  template<typename _Tp, bool = !__is_union_or_class<_Tp>::value>\n     struct __is_empty_helper\n-    { static const bool __value = (sizeof(__is_empty_helper_1<_Tp>)\n-\t\t\t\t   == sizeof(__is_empty_helper_2<_Tp>)); };\n+    { \n+    private:\n+      template<typename>\n+        struct __ebo_1 { };\n+      template<typename _Up>\n+        struct __ebo_2\n+        : public _Up { };\n+           \n+    public:\n+      static const bool __value = sizeof(__ebo_1<_Tp>) == sizeof(__ebo_2<_Tp>);\n+    };\n \n   template<typename _Tp>\n     struct __is_empty_helper<_Tp, true>"}, {"sha": "2d25d9b4c1469bd83fb4130995cec02e739373d7", "filename": "libstdc++-v3/include/tr1/type_traits_fwd.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftype_traits_fwd.h?ref=9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "patch": "@@ -103,6 +103,10 @@ namespace tr1\n \n   template<typename _Tp>\n     struct is_member_pointer;\n+\n+  // Extension.\n+  template<typename _Tp>\n+    struct __is_union_or_class;\n    \n   /// @brief  type properties [4.5.3].\n   template<typename _Tp>"}, {"sha": "3e9fafc434c16de5304dce52c9720e0a319c1bfc", "filename": "libstdc++-v3/testsuite/testsuite_tr1.h", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_tr1.h?ref=9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "patch": "@@ -123,67 +123,69 @@ namespace __gnu_test\n   class AbstractClass\n   { virtual void rotate(int) = 0; };\n \n+  union UnionType { };\n \n- int truncate_float(float x) { return (int)x; }\n- long truncate_double(double x) { return (long)x; }\n \n- struct do_truncate_float_t\n- {\n-   do_truncate_float_t()\n-   {\n-     ++live_objects;\n-   }\n-\n-   do_truncate_float_t(const do_truncate_float_t&)\n-   {\n-     ++live_objects;\n-   }\n+  int truncate_float(float x) { return (int)x; }\n+  long truncate_double(double x) { return (long)x; }\n \n-   ~do_truncate_float_t()\n-   {\n-     --live_objects;\n-   }\n-\n-   int operator()(float x) { return (int)x; }\n+  struct do_truncate_float_t\n+  {\n+    do_truncate_float_t()\n+    {\n+      ++live_objects;\n+    }\n \n-   static int live_objects;\n- };\n+    do_truncate_float_t(const do_truncate_float_t&)\n+    {\n+      ++live_objects;\n+    }\n+    \n+    ~do_truncate_float_t()\n+    {\n+      --live_objects;\n+    }\n \n- int do_truncate_float_t::live_objects = 0;\n+    int operator()(float x) { return (int)x; }\n+    \n+    static int live_objects;\n+  };\n \n- struct do_truncate_double_t\n- {\n-   do_truncate_double_t()\n-   {\n-     ++live_objects;\n-   }\n+  int do_truncate_float_t::live_objects = 0;\n \n-   do_truncate_double_t(const do_truncate_double_t&)\n-   {\n+  struct do_truncate_double_t\n+  {\n+    do_truncate_double_t()\n+    {\n      ++live_objects;\n-   }\n-\n-   ~do_truncate_double_t()\n-   {\n-     --live_objects;\n-   }\n-\n-   long operator()(double x) { return (long)x; }\n-\n-   static int live_objects;\n- };\n+    }\n \n- int do_truncate_double_t::live_objects = 0;\n+    do_truncate_double_t(const do_truncate_double_t&)\n+    {\n+      ++live_objects;\n+    }\n \n- struct X\n- {\n-   int bar;\n+    ~do_truncate_double_t()\n+    {\n+      --live_objects;\n+    }\n \n-   int foo()                   { return 1; }\n-   int foo_c() const           { return 2; }\n-   int foo_v()  volatile       { return 3; }\n-   int foo_cv() const volatile { return 4; }\n- };\n+    long operator()(double x) { return (long)x; }\n+    \n+    static int live_objects;\n+  };\n+  \n+  int do_truncate_double_t::live_objects = 0;\n+  \n+  struct X\n+  {\n+    int bar;\n+    \n+    int foo()                   { return 1; }\n+    int foo_c() const           { return 2; }\n+    int foo_v()  volatile       { return 3; }\n+    int foo_cv() const volatile { return 4; }\n+  };\n }; // namespace __gnu_test\n \n #endif // _GLIBCXX_TESTSUITE_TR1_H"}, {"sha": "6027eb973867c81b727f32bb33d6bc366cf4f9ae", "filename": "libstdc++-v3/testsuite/tr1/4_metaprogramming/composite_type_traits/is_union_or_class/is_union_or_class.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fcomposite_type_traits%2Fis_union_or_class%2Fis_union_or_class.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fcomposite_type_traits%2Fis_union_or_class%2Fis_union_or_class.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fcomposite_type_traits%2Fis_union_or_class%2Fis_union_or_class.cc?ref=9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "patch": "@@ -0,0 +1,60 @@\n+// 2005-02-25  Paolo Carlini  <pcarlini@suse.de>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 4.5.2 Composite type traits\n+\n+#include <tr1/type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::tr1::__is_union_or_class;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_category<__is_union_or_class, UnionType>(true)) );\n+  VERIFY( (test_category<__is_union_or_class, ClassType>(true)) );\n+  VERIFY( (test_category<__is_union_or_class, DerivedType>(true)) );\n+  VERIFY( (test_category<__is_union_or_class, ConvType>(true)) );\n+  VERIFY( (test_category<__is_union_or_class, AbstractClass>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_category<__is_union_or_class, void>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, int>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, float>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, int[2]>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, int*>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, int(*)(int)>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, float&>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, float(&)(float)>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, int (ClassType::*)>(false)) );\n+  VERIFY( (test_category<__is_union_or_class,\n+\t   int (ClassType::*) (int)>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, int (int)>(false)) );\n+  VERIFY( (test_category<__is_union_or_class, EnumType>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d62829afea87ce35a685558fcbbcfe9345389d60", "filename": "libstdc++-v3/testsuite/tr1/4_metaprogramming/composite_type_traits/is_union_or_class/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fcomposite_type_traits%2Fis_union_or_class%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fcomposite_type_traits%2Fis_union_or_class%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F4_metaprogramming%2Fcomposite_type_traits%2Fis_union_or_class%2Ftypedefs.cc?ref=9e38f7028f6f50fd0d0ff240f6bd3ddf8bedab40", "patch": "@@ -0,0 +1,36 @@\n+// 2005-02-25  Paolo Carlini  <pcarlini@suse.de>\n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// \n+// NB: This file is for testing tr1/type_traits with NO OTHER INCLUDES.\n+\n+#include <tr1/type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::tr1::__is_union_or_class<int>  test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}]}