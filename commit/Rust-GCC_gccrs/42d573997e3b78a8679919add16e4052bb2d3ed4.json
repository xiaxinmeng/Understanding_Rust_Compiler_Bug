{"sha": "42d573997e3b78a8679919add16e4052bb2d3ed4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJkNTczOTk3ZTNiNzhhODY3OTkxOWFkZDE2ZTQwNTJiYjJkM2VkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-01-01T16:22:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-01-01T16:22:10Z"}, "message": "* ipa-inline-analysis.c: Fix formatting.\n\nFrom-SVN: r194769", "tree": {"sha": "662d641f18acb4ff1af6d11940384df9f8b950ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/662d641f18acb4ff1af6d11940384df9f8b950ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42d573997e3b78a8679919add16e4052bb2d3ed4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42d573997e3b78a8679919add16e4052bb2d3ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42d573997e3b78a8679919add16e4052bb2d3ed4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42d573997e3b78a8679919add16e4052bb2d3ed4/comments", "author": null, "committer": null, "parents": [{"sha": "2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b"}], "stats": {"total": 1083, "additions": 541, "deletions": 542}, "files": [{"sha": "f7b15c308b245daf33e8226b19b8528abf31612a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42d573997e3b78a8679919add16e4052bb2d3ed4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42d573997e3b78a8679919add16e4052bb2d3ed4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42d573997e3b78a8679919add16e4052bb2d3ed4", "patch": "@@ -1,3 +1,7 @@\n+2013-01-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c: Fix formatting.\n+\n 2013-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/55831"}, {"sha": "3e03b31d17dccebd88a6b43f74747d42097df116", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 537, "deletions": 542, "changes": 1079, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42d573997e3b78a8679919add16e4052bb2d3ed4/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42d573997e3b78a8679919add16e4052bb2d3ed4/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=42d573997e3b78a8679919add16e4052bb2d3ed4", "patch": "@@ -1,5 +1,5 @@\n /* Inlining decision heuristics.\n-   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011, 2012, 2013\n    Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n@@ -127,8 +127,7 @@ static void inline_node_duplication_hook (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *, void *);\n static void inline_edge_removal_hook (struct cgraph_edge *, void *);\n static void inline_edge_duplication_hook (struct cgraph_edge *,\n-\t\t\t\t\t  struct cgraph_edge *,\n-\t\t\t\t          void *);\n+\t\t\t\t\t  struct cgraph_edge *, void *);\n \n /* VECtor holding inline summaries.  \n    In GGC memory because conditions might point to constant trees.  */\n@@ -200,6 +199,7 @@ false_predicate_p (struct predicate *p)\n \n \n /* Return predicate that is set true when function is not inlined.  */\n+\n static inline struct predicate\n not_inlined_predicate (void)\n {\n@@ -254,7 +254,7 @@ add_condition (struct inline_summary *summary, int operand_num,\n \t  && c->val == val\n \t  && c->agg_contents == agg_contents\n \t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n-        return single_cond_predicate (i + predicate_first_dynamic_condition);\n+\treturn single_cond_predicate (i + predicate_first_dynamic_condition);\n     }\n   /* Too many conditions.  Give up and return constant true.  */\n   if (i == NUM_CONDITIONS - predicate_first_dynamic_condition)\n@@ -321,7 +321,7 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n \tinsert_here = i2;\n \n       /* If clause implies p->clause[i], then p->clause[i] becomes redundant.\n-\t Otherwise the p->clause[i] has to stay.  */\n+         Otherwise the p->clause[i] has to stay.  */\n       if ((p->clause[i] & clause) != clause)\n \ti2++;\n     }\n@@ -335,34 +335,35 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n \tcontinue;\n       cc1 = &(*conditions)[c1 - predicate_first_dynamic_condition];\n       /* We have no way to represent !CHANGED and !IS_NOT_CONSTANT\n-\t and thus there is no point for looking for them.  */\n-      if (cc1->code == CHANGED\n-\t  || cc1->code == IS_NOT_CONSTANT)\n+         and thus there is no point for looking for them.  */\n+      if (cc1->code == CHANGED || cc1->code == IS_NOT_CONSTANT)\n \tcontinue;\n       for (c2 = c1 + 1; c2 <= NUM_CONDITIONS; c2++)\n \tif (clause & (1 << c2))\n \t  {\n-\t    condition *cc1 = &(*conditions)[c1 - predicate_first_dynamic_condition];\n-\t    condition *cc2 = &(*conditions)[c2 - predicate_first_dynamic_condition];\n+\t    condition *cc1 =\n+\t      &(*conditions)[c1 - predicate_first_dynamic_condition];\n+\t    condition *cc2 =\n+\t      &(*conditions)[c2 - predicate_first_dynamic_condition];\n \t    if (cc1->operand_num == cc2->operand_num\n \t\t&& cc1->val == cc2->val\n \t\t&& cc2->code != IS_NOT_CONSTANT\n \t\t&& cc2->code != CHANGED\n-\t\t&& cc1->code == invert_tree_comparison \n-\t\t    (cc2->code,\n-\t\t     HONOR_NANS (TYPE_MODE (TREE_TYPE (cc1->val)))))\n+\t\t&& cc1->code == invert_tree_comparison\n+\t\t\t\t(cc2->code,\n+\t\t\t\t HONOR_NANS (TYPE_MODE (TREE_TYPE (cc1->val)))))\n \t      return;\n \t  }\n     }\n-\t\n+\n \n   /* We run out of variants.  Be conservative in positive direction.  */\n   if (i2 == MAX_CLAUSES)\n     return;\n   /* Keep clauses in decreasing order. This makes equivalence testing easy.  */\n   p->clause[i2 + 1] = 0;\n   if (insert_here >= 0)\n-    for (;i2 > insert_here; i2--)\n+    for (; i2 > insert_here; i2--)\n       p->clause[i2] = p->clause[i2 - 1];\n   else\n     insert_here = i2;\n@@ -390,7 +391,7 @@ and_predicates (conditions conditions,\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n     }\n-    \n+\n   /* Combine the predicates rest.  */\n   for (; p2->clause[i]; i++)\n     {\n@@ -410,11 +411,11 @@ predicates_equal_p (struct predicate *p, struct predicate *p2)\n   for (i = 0; p->clause[i]; i++)\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n-      gcc_checking_assert (p->clause [i] > p->clause[i + 1]);\n+      gcc_checking_assert (p->clause[i] > p->clause[i + 1]);\n       gcc_checking_assert (!p2->clause[i]\n-\t\t\t   || p2->clause [i] > p2->clause[i + 1]);\n+\t\t\t   || p2->clause[i] > p2->clause[i + 1]);\n       if (p->clause[i] != p2->clause[i])\n-        return false;\n+\treturn false;\n     }\n   return !p2->clause[i];\n }\n@@ -423,10 +424,11 @@ predicates_equal_p (struct predicate *p, struct predicate *p2)\n /* Return P | P2.  */\n \n static struct predicate\n-or_predicates (conditions conditions, struct predicate *p, struct predicate *p2)\n+or_predicates (conditions conditions,\n+\t       struct predicate *p, struct predicate *p2)\n {\n   struct predicate out = true_predicate ();\n-  int i,j;\n+  int i, j;\n \n   /* Avoid busy work.  */\n   if (false_predicate_p (p2) || true_predicate_p (p))\n@@ -440,8 +442,8 @@ or_predicates (conditions conditions, struct predicate *p, struct predicate *p2)\n   for (i = 0; p->clause[i]; i++)\n     for (j = 0; p2->clause[j]; j++)\n       {\n-        gcc_checking_assert (i < MAX_CLAUSES && j < MAX_CLAUSES);\n-        add_clause (conditions, &out, p->clause[i] | p2->clause[j]);\n+\tgcc_checking_assert (i < MAX_CLAUSES && j < MAX_CLAUSES);\n+\tadd_clause (conditions, &out, p->clause[i] | p2->clause[j]);\n       }\n   return out;\n }\n@@ -466,7 +468,7 @@ evaluate_predicate (struct predicate *p, clause_t possible_truths)\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n       if (!(p->clause[i] & possible_truths))\n-        return false;\n+\treturn false;\n     }\n   return true;\n }\n@@ -508,23 +510,25 @@ predicate_probability (conditions conds,\n \t      {\n \t\tif (i2 >= predicate_first_dynamic_condition)\n \t\t  {\n-\t\t    condition *c = &(*conds)[i2 - predicate_first_dynamic_condition];\n+\t\t    condition *c =\n+\t\t      &(*conds)[i2 - predicate_first_dynamic_condition];\n \t\t    if (c->code == CHANGED\n-\t\t\t&& (c->operand_num\n-\t\t\t    < (int) inline_param_summary.length ()))\n+\t\t\t&& (c->operand_num <\n+\t\t\t    (int) inline_param_summary.length ()))\n \t\t      {\n-\t\t\tint iprob = inline_param_summary[c->operand_num].change_prob;\n+\t\t\tint iprob =\n+\t\t\t  inline_param_summary[c->operand_num].change_prob;\n \t\t\tthis_prob = MAX (this_prob, iprob);\n \t\t      }\n \t\t    else\n \t\t      this_prob = REG_BR_PROB_BASE;\n-\t\t   }\n-\t\t else\n-\t\t   this_prob = REG_BR_PROB_BASE;\n+\t\t  }\n+\t\telse\n+\t\t  this_prob = REG_BR_PROB_BASE;\n \t      }\n \t  combined_prob = MIN (this_prob, combined_prob);\n \t  if (!combined_prob)\n-            return 0;\n+\t    return 0;\n \t}\n     }\n   return combined_prob;\n@@ -580,7 +584,7 @@ dump_clause (FILE *f, conditions conds, clause_t clause)\n \tif (found)\n \t  fprintf (f, \" || \");\n \tfound = true;\n-        dump_condition (f, conds, i);\n+\tdump_condition (f, conds, i);\n       }\n   fprintf (f, \")\");\n }\n@@ -599,7 +603,7 @@ dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n       {\n \tif (i)\n \t  fprintf (f, \" && \");\n-        dump_clause (f, conds, pred->clause[i]);\n+\tdump_clause (f, conds, pred->clause[i]);\n       }\n   fprintf (f, \"\\n\");\n }\n@@ -683,7 +687,7 @@ account_size_time (struct inline_summary *summary, int size, int time,\n     if (predicates_equal_p (&e->predicate, pred))\n       {\n \tfound = true;\n-        break;\n+\tbreak;\n       }\n   if (i == 256)\n     {\n@@ -692,14 +696,16 @@ account_size_time (struct inline_summary *summary, int size, int time,\n       e = &(*summary->entry)[0];\n       gcc_assert (!e->predicate.clause[0]);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"\\t\\tReached limit on number of entries, ignoring the predicate.\");\n+\tfprintf (dump_file,\n+\t\t \"\\t\\tReached limit on number of entries, \"\n+\t\t \"ignoring the predicate.\");\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS) && (time || size))\n     {\n-      fprintf (dump_file, \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate:\",\n-\t       ((double)size) / INLINE_SIZE_SCALE,\n-\t       ((double)time) / INLINE_TIME_SCALE,\n-\t       found ? \"\" : \"new \");\n+      fprintf (dump_file,\n+\t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate:\",\n+\t       ((double) size) / INLINE_SIZE_SCALE,\n+\t       ((double) time) / INLINE_TIME_SCALE, found ? \"\" : \"new \");\n       dump_predicate (dump_file, summary->conds, pred);\n     }\n   if (!found)\n@@ -728,13 +734,13 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n   if (predicate && !true_predicate_p (predicate))\n     {\n       if (!es->predicate)\n-        es->predicate = (struct predicate *)pool_alloc (edge_predicate_pool);\n+\tes->predicate = (struct predicate *) pool_alloc (edge_predicate_pool);\n       *es->predicate = *predicate;\n     }\n   else\n     {\n       if (es->predicate)\n-        pool_free (edge_predicate_pool, es->predicate);\n+\tpool_free (edge_predicate_pool, es->predicate);\n       es->predicate = NULL;\n     }\n }\n@@ -744,8 +750,7 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n static void\n set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n {\n-  if (false_predicate_p (&new_predicate)\n-      || true_predicate_p (&new_predicate))\n+  if (false_predicate_p (&new_predicate) || true_predicate_p (&new_predicate))\n     {\n       if (*p)\n \tpool_free (edge_predicate_pool, *p);\n@@ -754,7 +759,7 @@ set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n   else\n     {\n       if (!*p)\n-\t*p = (struct predicate *)pool_alloc (edge_predicate_pool);\n+\t*p = (struct predicate *) pool_alloc (edge_predicate_pool);\n       **p = new_predicate;\n     }\n }\n@@ -769,9 +774,10 @@ set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n \n static clause_t\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n-\t\t\t\tbool inline_p,\n-\t\t\t\tvec<tree> known_vals,\n-\t\t\t\tvec<ipa_agg_jump_function_p> known_aggs)\n+\t\t\t\t    bool inline_p,\n+\t\t\t\t    vec<tree> known_vals,\n+\t\t\t\t    vec<ipa_agg_jump_function_p>\n+\t\t\t\t    known_aggs)\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n   struct inline_summary *info = inline_summary (node);\n@@ -784,9 +790,9 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       tree res;\n \n       /* We allow call stmt to have fewer arguments than the callee function\n-\t (especially for K&R style programs).  So bound check here (we assume\n-\t known_aggs vector, if non-NULL, has the same length as\n-\t known_vals).  */\n+         (especially for K&R style programs).  So bound check here (we assume\n+         known_aggs vector, if non-NULL, has the same length as\n+         known_vals).  */\n       gcc_checking_assert (!known_aggs.exists ()\n \t\t\t   || (known_vals.length () == known_aggs.length ()));\n       if (c->operand_num >= (int) known_vals.length ())\n@@ -801,8 +807,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n \t  if (c->code == CHANGED\n \t      && !c->by_ref\n-\t      && (known_vals[c->operand_num]\n-\t\t  == error_mark_node))\n+\t      && (known_vals[c->operand_num] == error_mark_node))\n \t    continue;\n \n \t  if (known_aggs.exists ())\n@@ -828,8 +833,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       if (c->code == IS_NOT_CONSTANT || c->code == CHANGED)\n \tcontinue;\n       res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);\n-      if (res\n-\t  && integer_zerop (res))\n+      if (res && integer_zerop (res))\n \tcontinue;\n       clause |= 1 << (i + predicate_first_dynamic_condition);\n     }\n@@ -841,12 +845,13 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n static void\n evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n-\t\t\tclause_t *clause_ptr,\n-\t\t\tvec<tree> *known_vals_ptr,\n-\t\t\tvec<tree> *known_binfos_ptr,\n-\t\t\tvec<ipa_agg_jump_function_p> *known_aggs_ptr)\n+\t\t\t      clause_t *clause_ptr,\n+\t\t\t      vec<tree> *known_vals_ptr,\n+\t\t\t      vec<tree> *known_binfos_ptr,\n+\t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct cgraph_node *callee =\n+    cgraph_function_or_thunk_node (e->callee, NULL);\n   struct inline_summary *info = inline_summary (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n@@ -860,18 +865,17 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \n   if (ipa_node_params_vector.exists ()\n       && !e->call_stmt_cannot_inline_p\n-      && ((clause_ptr && info->conds)\n-\t  || known_vals_ptr || known_binfos_ptr))\n+      && ((clause_ptr && info->conds) || known_vals_ptr || known_binfos_ptr))\n     {\n       struct ipa_node_params *parms_info;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->global.inlined_to)\n-        parms_info = IPA_NODE_REF (e->caller->global.inlined_to);\n+\tparms_info = IPA_NODE_REF (e->caller->global.inlined_to);\n       else\n-        parms_info = IPA_NODE_REF (e->caller);\n+\tparms_info = IPA_NODE_REF (e->caller);\n \n       if (count && (info->conds || known_vals_ptr))\n \tknown_vals.safe_grow_cleared (count);\n@@ -888,7 +892,8 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t    {\n \t      if (known_vals.exists () && TREE_CODE (cst) != TREE_BINFO)\n \t\tknown_vals[i] = cst;\n-\t      else if (known_binfos_ptr != NULL && TREE_CODE (cst) == TREE_BINFO)\n+\t      else if (known_binfos_ptr != NULL\n+\t\t       && TREE_CODE (cst) == TREE_BINFO)\n \t\t(*known_binfos_ptr)[i] = cst;\n \t    }\n \t  else if (inline_p && !es->param[i].change_prob)\n@@ -940,8 +945,7 @@ inline_summary_alloc (void)\n     inline_edge_summary_vec.safe_grow_cleared (cgraph_edge_max_uid + 1);\n   if (!edge_predicate_pool)\n     edge_predicate_pool = create_alloc_pool (\"edge predicates\",\n-\t\t\t\t\t     sizeof (struct predicate),\n-\t\t\t\t\t     10);\n+\t\t\t\t\t     sizeof (struct predicate), 10);\n }\n \n /* We are called multiple time for given function; clear\n@@ -950,7 +954,7 @@ inline_summary_alloc (void)\n static void\n reset_inline_edge_summary (struct cgraph_edge *e)\n {\n-  if (e->uid < (int)inline_edge_summary_vec.length ())\n+  if (e->uid < (int) inline_edge_summary_vec.length ())\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n \n@@ -1005,10 +1009,11 @@ reset_inline_summary (struct cgraph_node *node)\n /* Hook that is called by cgraph.c when a node is removed.  */\n \n static void\n-inline_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+inline_node_removal_hook (struct cgraph_node *node,\n+\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n   struct inline_summary *info;\n-  if (vec_safe_length (inline_summary_vec) <= (unsigned)node->uid)\n+  if (vec_safe_length (inline_summary_vec) <= (unsigned) node->uid)\n     return;\n   info = inline_summary (node);\n   reset_inline_summary (node);\n@@ -1054,8 +1059,7 @@ remap_hint_predicate_after_duplication (struct predicate **p,\n     return;\n \n   new_predicate = remap_predicate_after_duplication (*p,\n-\t\t\t\t\t\t     possible_truths,\n-\t\t\t\t\t\t     info);\n+\t\t\t\t\t\t     possible_truths, info);\n   /* We do not want to free previous predicate; it is used by node origin.  */\n   *p = NULL;\n   set_hint_predicate (p, new_predicate);\n@@ -1065,29 +1069,28 @@ remap_hint_predicate_after_duplication (struct predicate **p,\n /* Hook that is called by cgraph.c when a node is duplicated.  */\n \n static void\n-inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n+inline_node_duplication_hook (struct cgraph_node *src,\n+\t\t\t      struct cgraph_node *dst,\n \t\t\t      ATTRIBUTE_UNUSED void *data)\n {\n   struct inline_summary *info;\n   inline_summary_alloc ();\n   info = inline_summary (dst);\n-  memcpy (info, inline_summary (src),\n-\t  sizeof (struct inline_summary));\n+  memcpy (info, inline_summary (src), sizeof (struct inline_summary));\n   /* TODO: as an optimization, we may avoid copying conditions\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n \n   /* When there are any replacements in the function body, see if we can figure\n      out that something was optimized out.  */\n-  if (ipa_node_params_vector.exists ()\n-      && dst->clone.tree_map)\n+  if (ipa_node_params_vector.exists () && dst->clone.tree_map)\n     {\n       vec<size_time_entry, va_gc> *entry = info->entry;\n       /* Use SRC parm info since it may not be copied yet.  */\n       struct ipa_node_params *parms_info = IPA_NODE_REF (src);\n       vec<tree> known_vals = vNULL;\n       int count = ipa_get_param_count (parms_info);\n-      int i,j;\n+      int i, j;\n       clause_t possible_truths;\n       struct predicate true_pred = true_predicate ();\n       size_time_entry *e;\n@@ -1098,32 +1101,31 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n       info->entry = 0;\n       known_vals.safe_grow_cleared (count);\n       for (i = 0; i < count; i++)\n-        {\n+\t{\n \t  tree t = ipa_get_param (parms_info, i);\n \t  struct ipa_replace_map *r;\n \n \t  for (j = 0; vec_safe_iterate (dst->clone.tree_map, j, &r); j++)\n \t    {\n-\t      if (r->old_tree == t\n-\t\t  && r->replace_p\n-\t\t  && !r->ref_p)\n+\t      if (r->old_tree == t && r->replace_p && !r->ref_p)\n \t\t{\n \t\t  known_vals[i] = r->new_tree;\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       possible_truths = evaluate_conditions_for_known_args (dst, false,\n-\t\t\t\t    known_vals, vNULL);\n+\t\t\t\t\t\t\t    known_vals,\n+\t\t\t\t\t\t\t    vNULL);\n       known_vals.release ();\n \n       account_size_time (info, 0, 0, &true_pred);\n \n       /* Remap size_time vectors.\n-\t Simplify the predicate by prunning out alternatives that are known\n-\t to be false.\n-\t TODO: as on optimization, we can also eliminate conditions known\n-\t to be true.  */\n+         Simplify the predicate by prunning out alternatives that are known\n+         to be false.\n+         TODO: as on optimization, we can also eliminate conditions known\n+         to be true.  */\n       for (i = 0; vec_safe_iterate (entry, i, &e); i++)\n \t{\n \t  struct predicate new_predicate;\n@@ -1137,7 +1139,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t}\n \n       /* Remap edge predicates with the same simplification as above.\n-\t Also copy constantness arrays.   */\n+         Also copy constantness arrays.   */\n       for (edge = dst->callees; edge; edge = edge->next_callee)\n \t{\n \t  struct predicate new_predicate;\n@@ -1160,7 +1162,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t}\n \n       /* Remap indirect edge predicates with the same simplificaiton as above. \n-\t Also copy constantness arrays.   */\n+         Also copy constantness arrays.   */\n       for (edge = dst->indirect_calls; edge; edge = edge->next_callee)\n \t{\n \t  struct predicate new_predicate;\n@@ -1181,21 +1183,17 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n       remap_hint_predicate_after_duplication (&info->loop_iterations,\n-\t\t\t\t\t      possible_truths,\n-\t\t\t\t\t      info);\n+\t\t\t\t\t      possible_truths, info);\n       remap_hint_predicate_after_duplication (&info->loop_stride,\n-\t\t\t\t\t      possible_truths,\n-\t\t\t\t\t      info);\n+\t\t\t\t\t      possible_truths, info);\n       remap_hint_predicate_after_duplication (&info->array_index,\n-\t\t\t\t\t      possible_truths,\n-\t\t\t\t\t      info);\n+\t\t\t\t\t      possible_truths, info);\n \n       /* If inliner or someone after inliner will ever start producing\n-\t non-trivial clones, we will get trouble with lack of information\n-\t about updating self sizes, because size vectors already contains\n-\t sizes of the calees.  */\n-      gcc_assert (!inlined_to_p \n-\t\t  || !optimized_out_size);\n+         non-trivial clones, we will get trouble with lack of information\n+         about updating self sizes, because size vectors already contains\n+         sizes of the calees.  */\n+      gcc_assert (!inlined_to_p || !optimized_out_size);\n     }\n   else\n     {\n@@ -1226,16 +1224,16 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n /* Hook that is called by cgraph.c when a node is duplicated.  */\n \n static void\n-inline_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n+inline_edge_duplication_hook (struct cgraph_edge *src,\n+\t\t\t      struct cgraph_edge *dst,\n \t\t\t      ATTRIBUTE_UNUSED void *data)\n {\n   struct inline_edge_summary *info;\n   struct inline_edge_summary *srcinfo;\n   inline_summary_alloc ();\n   info = inline_edge_summary (dst);\n   srcinfo = inline_edge_summary (src);\n-  memcpy (info, srcinfo,\n-\t  sizeof (struct inline_edge_summary));\n+  memcpy (info, srcinfo, sizeof (struct inline_edge_summary));\n   info->predicate = NULL;\n   edge_set_predicate (dst, srcinfo->predicate);\n   info->param = srcinfo->param.copy ();\n@@ -1245,7 +1243,8 @@ inline_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n /* Keep edge cache consistent across edge removal.  */\n \n static void\n-inline_edge_removal_hook (struct cgraph_edge *edge, void *data ATTRIBUTE_UNUSED)\n+inline_edge_removal_hook (struct cgraph_edge *edge,\n+\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n   if (edge_growth_cache.exists ())\n     reset_edge_growth_cache (edge);\n@@ -1279,38 +1278,37 @@ free_growth_caches (void)\n    Indent by INDENT.  */\n \n static void\n-dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n+dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n \t\t\t  struct inline_summary *info)\n {\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n-      struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+      struct cgraph_node *callee =\n+\tcgraph_function_or_thunk_node (edge->callee, NULL);\n       int i;\n \n-      fprintf (f, \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i time: %2i callee size:%2i stack:%2i\",\n-\t       indent, \"\", cgraph_node_name (callee),\n-\t       callee->uid, \n-\t       !edge->inline_failed ? \"inlined\"\n-\t       : cgraph_inline_failed_string (edge->inline_failed),\n-\t       indent, \"\",\n-\t       es->loop_depth,\t\n-               edge->frequency,\n-\t       es->call_stmt_size,\n-\t       es->call_stmt_time,\n-\t       (int)inline_summary (callee)->size / INLINE_SIZE_SCALE,\n-\t       (int)inline_summary (callee)->estimated_stack_size);\n+      fprintf (f,\n+\t       \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i\"\n+\t       \" time: %2i callee size:%2i stack:%2i\",\n+\t       indent, \"\", cgraph_node_name (callee), callee->uid,\n+\t       !edge->inline_failed\n+\t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n+\t       indent, \"\", es->loop_depth, edge->frequency,\n+\t       es->call_stmt_size, es->call_stmt_time,\n+\t       (int) inline_summary (callee)->size / INLINE_SIZE_SCALE,\n+\t       (int) inline_summary (callee)->estimated_stack_size);\n \n       if (es->predicate)\n \t{\n \t  fprintf (f, \" predicate: \");\n \t  dump_predicate (f, info->conds, es->predicate);\n \t}\n       else\n-\t  fprintf (f, \"\\n\");\n+\tfprintf (f, \"\\n\");\n       if (es->param.exists ())\n-        for (i = 0; i < (int)es->param.length (); i++)\n+\tfor (i = 0; i < (int) es->param.length (); i++)\n \t  {\n \t    int prob = es->param[i].change_prob;\n \n@@ -1323,13 +1321,13 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n \t  }\n       if (!edge->inline_failed)\n \t{\n-          fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n+\t  fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n \t\t   \" callee size %i\\n\",\n-\t\t   indent+2, \"\",\n-\t\t   (int)inline_summary (callee)->stack_frame_offset,\n-\t\t   (int)inline_summary (callee)->estimated_self_stack_size,\n-\t\t   (int)inline_summary (callee)->estimated_stack_size);\n-\t  dump_inline_edge_summary (f, indent+2, callee, info);\n+\t\t   indent + 2, \"\",\n+\t\t   (int) inline_summary (callee)->stack_frame_offset,\n+\t\t   (int) inline_summary (callee)->estimated_self_stack_size,\n+\t\t   (int) inline_summary (callee)->estimated_stack_size);\n+\t  dump_inline_edge_summary (f, indent + 2, callee, info);\n \t}\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n@@ -1338,10 +1336,8 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n       fprintf (f, \"%*sindirect call loop depth:%2i freq:%4i size:%2i\"\n \t       \" time: %2i\",\n \t       indent, \"\",\n-\t       es->loop_depth,\t\n-               edge->frequency,\n-\t       es->call_stmt_size,\n-\t       es->call_stmt_time);\n+\t       es->loop_depth,\n+\t       edge->frequency, es->call_stmt_size, es->call_stmt_time);\n       if (es->predicate)\n \t{\n \t  fprintf (f, \"predicate: \");\n@@ -1354,7 +1350,7 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n \n \n void\n-dump_inline_summary (FILE * f, struct cgraph_node *node)\n+dump_inline_summary (FILE *f, struct cgraph_node *node)\n {\n   if (node->analyzed)\n     {\n@@ -1367,22 +1363,17 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \tfprintf (f, \" always_inline\");\n       if (s->inlinable)\n \tfprintf (f, \" inlinable\");\n-      fprintf (f, \"\\n  self time:       %i\\n\",\n-\t       s->self_time);\n+      fprintf (f, \"\\n  self time:       %i\\n\", s->self_time);\n       fprintf (f, \"  global time:     %i\\n\", s->time);\n-      fprintf (f, \"  self size:       %i\\n\",\n-\t       s->self_size);\n+      fprintf (f, \"  self size:       %i\\n\", s->self_size);\n       fprintf (f, \"  global size:     %i\\n\", s->size);\n       fprintf (f, \"  self stack:      %i\\n\",\n \t       (int) s->estimated_self_stack_size);\n-      fprintf (f, \"  global stack:    %i\\n\",\n-\t       (int) s->estimated_stack_size);\n+      fprintf (f, \"  global stack:    %i\\n\", (int) s->estimated_stack_size);\n       if (s->growth)\n-        fprintf (f, \"  estimated growth:%i\\n\",\n-\t         (int) s->growth);\n+\tfprintf (f, \"  estimated growth:%i\\n\", (int) s->growth);\n       if (s->scc_no)\n-        fprintf (f, \"  In SCC:          %i\\n\",\n-\t         (int) s->scc_no);\n+\tfprintf (f, \"  In SCC:          %i\\n\", (int) s->scc_no);\n       for (i = 0; vec_safe_iterate (s->entry, i, &e); i++)\n \t{\n \t  fprintf (f, \"    size:%f, time:%f, predicate:\",\n@@ -1452,7 +1443,7 @@ initialize_inline_failed (struct cgraph_edge *e)\n \n static bool\n mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n-\t\t     void *data)\n+\t       void *data)\n {\n   bool *b = (bool *) data;\n   *b = true;\n@@ -1563,116 +1554,117 @@ eliminated_by_inlining_prob (gimple stmt)\n \n   switch (code)\n     {\n-      case GIMPLE_RETURN:\n-        return 2;\n-      case GIMPLE_ASSIGN:\n-\tif (gimple_num_ops (stmt) != 2)\n-\t  return 0;\n-\n-\trhs_code = gimple_assign_rhs_code (stmt);\n-\n-\t/* Casts of parameters, loads from parameters passed by reference\n-\t   and stores to return value or parameters are often free after\n-\t   inlining dua to SRA and further combining.\n-\t   Assume that half of statements goes away.  */\n-\tif (rhs_code == CONVERT_EXPR\n-\t    || rhs_code == NOP_EXPR\n-\t    || rhs_code == VIEW_CONVERT_EXPR\n-\t    || rhs_code == ADDR_EXPR\n-\t    || gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n-\t  {\n-\t    tree rhs = gimple_assign_rhs1 (stmt);\n-            tree lhs = gimple_assign_lhs (stmt);\n-\t    tree inner_rhs = get_base_address (rhs);\n-\t    tree inner_lhs = get_base_address (lhs);\n-\t    bool rhs_free = false;\n-\t    bool lhs_free = false;\n-\n-\t    if (!inner_rhs)\n-\t      inner_rhs = rhs;\n-\t    if (!inner_lhs)\n-\t      inner_lhs = lhs;\n-\n-\t    /* Reads of parameter are expected to be free.  */\n-\t    if (unmodified_parm (stmt, inner_rhs))\n-\t      rhs_free = true;\n-\t    /* Match expressions of form &this->field. Those will most likely\n-\t       combine with something upstream after inlining.  */\n-\t    else if (TREE_CODE (inner_rhs) == ADDR_EXPR)\n-\t      {\n-\t\ttree op = get_base_address (TREE_OPERAND (inner_rhs, 0));\n-\t\tif (TREE_CODE (op) == PARM_DECL)\n-\t\t  rhs_free = true;\n-\t        else if (TREE_CODE (op) == MEM_REF\n-\t\t\t && unmodified_parm (stmt, TREE_OPERAND (op, 0)))\n-\t\t  rhs_free = true;\n-\t      }\n-\n-\t    /* When parameter is not SSA register because its address is taken\n-\t       and it is just copied into one, the statement will be completely\n-\t       free after inlining (we will copy propagate backward).   */\n-\t    if (rhs_free && is_gimple_reg (lhs))\n-\t      return 2;\n-\n-\t    /* Reads of parameters passed by reference\n-\t       expected to be free (i.e. optimized out after inlining).  */\n-\t    if (TREE_CODE(inner_rhs) == MEM_REF\n-\t        && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0)))\n-\t      rhs_free = true;\n-\n-\t    /* Copying parameter passed by reference into gimple register is\n-\t       probably also going to copy propagate, but we can't be quite\n-\t       sure.  */\n-\t    if (rhs_free && is_gimple_reg (lhs))\n-\t      lhs_free = true;\n-\t   \n-\t    /* Writes to parameters, parameters passed by value and return value\n-\t       (either dirrectly or passed via invisible reference) are free.  \n-\n-\t       TODO: We ought to handle testcase like\n-\t       struct a {int a,b;};\n-\t       struct a\n-\t       retrurnsturct (void)\n-\t\t {\n-\t\t   struct a a ={1,2};\n-\t\t   return a;\n-\t\t }\n-\n-\t       This translate into:\n-\n-\t       retrurnsturct ()\n-\t\t {\n-\t\t   int a$b;\n-\t\t   int a$a;\n-\t\t   struct a a;\n-\t\t   struct a D.2739;\n-\n-\t\t <bb 2>:\n-\t\t   D.2739.a = 1;\n-\t\t   D.2739.b = 2;\n-\t\t   return D.2739;\n-\n-\t\t }\n-\t       For that we either need to copy ipa-split logic detecting writes\n-\t       to return value.  */\n-\t    if (TREE_CODE (inner_lhs) == PARM_DECL\n-\t\t|| TREE_CODE (inner_lhs) == RESULT_DECL\n-\t        || (TREE_CODE(inner_lhs) == MEM_REF\n-\t\t     && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0))\n-\t\t\t || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME\n-\t\t\t     && SSA_NAME_VAR (TREE_OPERAND (inner_lhs, 0))\n-\t\t\t     && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND\n-\t\t\t\t  (inner_lhs, 0))) == RESULT_DECL))))\n-\t      lhs_free = true;\n-\t    if (lhs_free\n-\t\t&& (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n-\t      rhs_free = true;\n-\t    if (lhs_free && rhs_free)\n-\t      return 1;\n-\t  }\n-\treturn 0;\n-      default:\n+    case GIMPLE_RETURN:\n+      return 2;\n+    case GIMPLE_ASSIGN:\n+      if (gimple_num_ops (stmt) != 2)\n \treturn 0;\n+\n+      rhs_code = gimple_assign_rhs_code (stmt);\n+\n+      /* Casts of parameters, loads from parameters passed by reference\n+         and stores to return value or parameters are often free after\n+         inlining dua to SRA and further combining.\n+         Assume that half of statements goes away.  */\n+      if (rhs_code == CONVERT_EXPR\n+\t  || rhs_code == NOP_EXPR\n+\t  || rhs_code == VIEW_CONVERT_EXPR\n+\t  || rhs_code == ADDR_EXPR\n+\t  || gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  tree inner_rhs = get_base_address (rhs);\n+\t  tree inner_lhs = get_base_address (lhs);\n+\t  bool rhs_free = false;\n+\t  bool lhs_free = false;\n+\n+\t  if (!inner_rhs)\n+\t    inner_rhs = rhs;\n+\t  if (!inner_lhs)\n+\t    inner_lhs = lhs;\n+\n+\t  /* Reads of parameter are expected to be free.  */\n+\t  if (unmodified_parm (stmt, inner_rhs))\n+\t    rhs_free = true;\n+\t  /* Match expressions of form &this->field. Those will most likely\n+\t     combine with something upstream after inlining.  */\n+\t  else if (TREE_CODE (inner_rhs) == ADDR_EXPR)\n+\t    {\n+\t      tree op = get_base_address (TREE_OPERAND (inner_rhs, 0));\n+\t      if (TREE_CODE (op) == PARM_DECL)\n+\t\trhs_free = true;\n+\t      else if (TREE_CODE (op) == MEM_REF\n+\t\t       && unmodified_parm (stmt, TREE_OPERAND (op, 0)))\n+\t\trhs_free = true;\n+\t    }\n+\n+\t  /* When parameter is not SSA register because its address is taken\n+\t     and it is just copied into one, the statement will be completely\n+\t     free after inlining (we will copy propagate backward).   */\n+\t  if (rhs_free && is_gimple_reg (lhs))\n+\t    return 2;\n+\n+\t  /* Reads of parameters passed by reference\n+\t     expected to be free (i.e. optimized out after inlining).  */\n+\t  if (TREE_CODE (inner_rhs) == MEM_REF\n+\t      && unmodified_parm (stmt, TREE_OPERAND (inner_rhs, 0)))\n+\t    rhs_free = true;\n+\n+\t  /* Copying parameter passed by reference into gimple register is\n+\t     probably also going to copy propagate, but we can't be quite\n+\t     sure.  */\n+\t  if (rhs_free && is_gimple_reg (lhs))\n+\t    lhs_free = true;\n+\n+\t  /* Writes to parameters, parameters passed by value and return value\n+\t     (either dirrectly or passed via invisible reference) are free.  \n+\n+\t     TODO: We ought to handle testcase like\n+\t     struct a {int a,b;};\n+\t     struct a\n+\t     retrurnsturct (void)\n+\t     {\n+\t     struct a a ={1,2};\n+\t     return a;\n+\t     }\n+\n+\t     This translate into:\n+\n+\t     retrurnsturct ()\n+\t     {\n+\t     int a$b;\n+\t     int a$a;\n+\t     struct a a;\n+\t     struct a D.2739;\n+\n+\t     <bb 2>:\n+\t     D.2739.a = 1;\n+\t     D.2739.b = 2;\n+\t     return D.2739;\n+\n+\t     }\n+\t     For that we either need to copy ipa-split logic detecting writes\n+\t     to return value.  */\n+\t  if (TREE_CODE (inner_lhs) == PARM_DECL\n+\t      || TREE_CODE (inner_lhs) == RESULT_DECL\n+\t      || (TREE_CODE (inner_lhs) == MEM_REF\n+\t\t  && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0))\n+\t\t      || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME\n+\t\t\t  && SSA_NAME_VAR (TREE_OPERAND (inner_lhs, 0))\n+\t\t\t  && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND\n+\t\t\t\t\t\t      (inner_lhs,\n+\t\t\t\t\t\t       0))) == RESULT_DECL))))\n+\t    lhs_free = true;\n+\t  if (lhs_free\n+\t      && (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n+\t    rhs_free = true;\n+\t  if (lhs_free && rhs_free)\n+\t    return 1;\n+\t}\n+      return 0;\n+    default:\n+      return 0;\n     }\n }\n \n@@ -1682,8 +1674,8 @@ eliminated_by_inlining_prob (gimple stmt)\n \n static void\n set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n-\t\t\t           struct inline_summary *summary,\n-\t\t\t           basic_block bb)\n+\t\t\t\t   struct inline_summary *summary,\n+\t\t\t\t   basic_block bb)\n {\n   gimple last;\n   tree op;\n@@ -1696,8 +1688,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   tree op2;\n \n   last = last_stmt (bb);\n-  if (!last\n-      || gimple_code (last) != GIMPLE_COND)\n+  if (!last || gimple_code (last) != GIMPLE_COND)\n     return;\n   if (!is_gimple_ip_invariant (gimple_cond_rhs (last)))\n     return;\n@@ -1709,8 +1700,8 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n     {\n       code = gimple_cond_code (last);\n       inverted_code\n-\t = invert_tree_comparison (code,\n-\t\t\t\t   HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n+\t= invert_tree_comparison (code,\n+\t\t\t\t  HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n@@ -1719,17 +1710,17 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n \t\t\t\t\t      ? code : inverted_code,\n \t\t\t\t\t      gimple_cond_rhs (last));\n \t  e->aux = pool_alloc (edge_predicate_pool);\n-\t  *(struct predicate *)e->aux = p;\n+\t  *(struct predicate *) e->aux = p;\n \t}\n     }\n \n   if (TREE_CODE (op) != SSA_NAME)\n     return;\n   /* Special case\n      if (builtin_constant_p (op))\n-       constant_code\n+     constant_code\n      else\n-       nonconstant_code.\n+     nonconstant_code.\n      Here we can predicate nonconstant_code.  We can't\n      really handle constant_code since we have no predicate\n      for this and also the constant code is not known to be\n@@ -1743,16 +1734,16 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  if (!unmodified_parm_or_parm_agg_item (info, set_stmt, op2, &index, &aggpos))\n+  if (!unmodified_parm_or_parm_agg_item\n+      (info, set_stmt, op2, &index, &aggpos))\n     return;\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_FALSE_VALUE)\n-      {\n-\tstruct predicate p = add_condition (summary, index, &aggpos,\n-\t\t\t\t\t    IS_NOT_CONSTANT, NULL_TREE);\n-\te->aux = pool_alloc (edge_predicate_pool);\n-\t*(struct predicate *)e->aux = p;\n-      }\n+  FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n+    {\n+      struct predicate p = add_condition (summary, index, &aggpos,\n+\t\t\t\t\t  IS_NOT_CONSTANT, NULL_TREE);\n+      e->aux = pool_alloc (edge_predicate_pool);\n+      *(struct predicate *) e->aux = p;\n+    }\n }\n \n \n@@ -1761,8 +1752,8 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n \n static void\n set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n-\t\t\t           struct inline_summary *summary,\n-\t\t\t           basic_block bb)\n+\t\t\t\t     struct inline_summary *summary,\n+\t\t\t\t     basic_block bb)\n {\n   gimple last;\n   tree op;\n@@ -1774,8 +1765,7 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n   size_t case_idx;\n \n   last = last_stmt (bb);\n-  if (!last\n-      || gimple_code (last) != GIMPLE_SWITCH)\n+  if (!last || gimple_code (last) != GIMPLE_SWITCH)\n     return;\n   op = gimple_switch_index (last);\n   if (!unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n@@ -1784,9 +1774,9 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       e->aux = pool_alloc (edge_predicate_pool);\n-      *(struct predicate *)e->aux = false_predicate ();\n+      *(struct predicate *) e->aux = false_predicate ();\n     }\n-  n = gimple_switch_num_labels(last);\n+  n = gimple_switch_num_labels (last);\n   for (case_idx = 0; case_idx < n; ++case_idx)\n     {\n       tree cl = gimple_switch_label (last, case_idx);\n@@ -1798,8 +1788,8 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n       max = CASE_HIGH (cl);\n \n       /* For default we might want to construct predicate that none\n-\t of cases is met, but it is bit hard to do not having negations\n-\t of conditionals handy.  */\n+         of cases is met, but it is bit hard to do not having negations\n+         of conditionals handy.  */\n       if (!min && !max)\n \tp = true_predicate ();\n       else if (!max)\n@@ -1811,8 +1801,8 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n \t  p2 = add_condition (summary, index, &aggpos, LE_EXPR, max);\n \t  p = and_predicates (summary->conds, &p1, &p2);\n \t}\n-      *(struct predicate *)e->aux\n-\t= or_predicates (summary->conds, &p, (struct predicate *)e->aux);\n+      *(struct predicate *) e->aux\n+\t= or_predicates (summary->conds, &p, (struct predicate *) e->aux);\n     }\n }\n \n@@ -1838,7 +1828,7 @@ compute_bb_predicates (struct cgraph_node *node,\n   /* Entry block is always executable.  */\n   ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n     = pool_alloc (edge_predicate_pool);\n-  *(struct predicate *)ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n+  *(struct predicate *) ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n     = true_predicate ();\n \n   /* A simple dataflow propagation of predicates forward in the CFG.\n@@ -1848,19 +1838,19 @@ compute_bb_predicates (struct cgraph_node *node,\n       done = true;\n       FOR_EACH_BB_FN (bb, my_function)\n \t{\n-          struct predicate p = false_predicate ();\n-          edge e;\n-          edge_iterator ei;\n+\t  struct predicate p = false_predicate ();\n+\t  edge e;\n+\t  edge_iterator ei;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n \t      if (e->src->aux)\n \t\t{\n \t\t  struct predicate this_bb_predicate\n-\t\t     = *(struct predicate *)e->src->aux;\n+\t\t    = *(struct predicate *) e->src->aux;\n \t\t  if (e->aux)\n \t\t    this_bb_predicate\n-\t\t       = and_predicates (summary->conds, &this_bb_predicate,\n-\t\t\t\t\t (struct predicate *)e->aux);\n+\t\t      = and_predicates (summary->conds, &this_bb_predicate,\n+\t\t\t\t\t(struct predicate *) e->aux);\n \t\t  p = or_predicates (summary->conds, &p, &this_bb_predicate);\n \t\t  if (true_predicate_p (&p))\n \t\t    break;\n@@ -1874,12 +1864,12 @@ compute_bb_predicates (struct cgraph_node *node,\n \t\t{\n \t\t  done = false;\n \t\t  bb->aux = pool_alloc (edge_predicate_pool);\n-\t\t  *((struct predicate *)bb->aux) = p;\n+\t\t  *((struct predicate *) bb->aux) = p;\n \t\t}\n-\t      else if (!predicates_equal_p (&p, (struct predicate *)bb->aux))\n+\t      else if (!predicates_equal_p (&p, (struct predicate *) bb->aux))\n \t\t{\n \t\t  done = false;\n-\t\t  *((struct predicate *)bb->aux) = p;\n+\t\t  *((struct predicate *) bb->aux) = p;\n \t\t}\n \t    }\n \t}\n@@ -1895,9 +1885,9 @@ typedef struct predicate predicate_t;\n \n static struct predicate\n will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n-\t\t\t            struct inline_summary *summary,\n-\t\t\t            tree expr,\n-\t\t\t            vec<predicate_t> nonconstant_names)\n+\t\t\t\t    struct inline_summary *summary,\n+\t\t\t\t    tree expr,\n+\t\t\t\t    vec<predicate_t> nonconstant_names)\n {\n   tree parm;\n   int index;\n@@ -1906,19 +1896,17 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n     expr = TREE_OPERAND (expr, 0);\n \n   parm = unmodified_parm (NULL, expr);\n-  if (parm\n-      && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n+  if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n     return add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n     return false_predicate ();\n   if (TREE_CODE (expr) == SSA_NAME)\n     return nonconstant_names[SSA_NAME_VERSION (expr)];\n-  if (BINARY_CLASS_P (expr)\n-      || COMPARISON_CLASS_P (expr))\n+  if (BINARY_CLASS_P (expr) || COMPARISON_CLASS_P (expr))\n     {\n       struct predicate p1 = will_be_nonconstant_expr_predicate\n-\t\t\t      (info, summary, TREE_OPERAND (expr, 0),\n-\t\t\t       nonconstant_names);\n+\t(info, summary, TREE_OPERAND (expr, 0),\n+\t nonconstant_names);\n       struct predicate p2;\n       if (true_predicate_p (&p1))\n \treturn p1;\n@@ -1930,8 +1918,8 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n   else if (TREE_CODE (expr) == COND_EXPR)\n     {\n       struct predicate p1 = will_be_nonconstant_expr_predicate\n-\t\t\t      (info, summary, TREE_OPERAND (expr, 0),\n-\t\t\t       nonconstant_names);\n+\t(info, summary, TREE_OPERAND (expr, 0),\n+\t nonconstant_names);\n       struct predicate p2;\n       if (true_predicate_p (&p1))\n \treturn p1;\n@@ -2018,16 +2006,16 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n     }\n \n   if (is_load)\n-    op_non_const = add_condition (summary, base_index, &aggpos, CHANGED, NULL);\n+    op_non_const =\n+      add_condition (summary, base_index, &aggpos, CHANGED, NULL);\n   else\n     op_non_const = false_predicate ();\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree parm = unmodified_parm (stmt, use);\n       int index;\n \n-      if (parm\n-\t  && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n+      if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n \t{\n \t  if (index != base_index)\n \t    p = add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n@@ -2041,7 +2029,7 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n   if (gimple_code (stmt) == GIMPLE_ASSIGN\n       && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n     nonconstant_names[SSA_NAME_VERSION (gimple_assign_lhs (stmt))]\n-\t= op_non_const;\n+      = op_non_const;\n   return op_non_const;\n }\n \n@@ -2055,15 +2043,16 @@ struct record_modified_bb_info\n    set except for info->stmt.  */\n \n static bool\n-record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef,\n-\t         void *data)\n+record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n {\n-  struct record_modified_bb_info *info = (struct record_modified_bb_info *) data;\n+  struct record_modified_bb_info *info =\n+    (struct record_modified_bb_info *) data;\n   if (SSA_NAME_DEF_STMT (vdef) == info->stmt)\n     return false;\n   bitmap_set_bit (info->bb_set,\n \t\t  SSA_NAME_IS_DEFAULT_DEF (vdef)\n-\t\t  ? ENTRY_BLOCK_PTR->index : gimple_bb (SSA_NAME_DEF_STMT (vdef))->index);\n+\t\t  ? ENTRY_BLOCK_PTR->index\n+\t\t  : gimple_bb (SSA_NAME_DEF_STMT (vdef))->index);\n   return false;\n }\n \n@@ -2081,6 +2070,7 @@ param_change_prob (gimple stmt, int i)\n   basic_block bb = gimple_bb (stmt);\n   tree base;\n \n+  /* Global invariants neve change.  */\n   if (is_gimple_min_invariant (op))\n     return 0;\n   /* We would have to do non-trivial analysis to really work out what\n@@ -2104,10 +2094,10 @@ param_change_prob (gimple stmt, int i)\n       if (!init_freq)\n \tinit_freq = 1;\n       if (init_freq < bb->frequency)\n-        return MAX ((init_freq * REG_BR_PROB_BASE +\n-\t\t    bb->frequency / 2) / bb->frequency, 1);\n+\treturn MAX ((init_freq * REG_BR_PROB_BASE +\n+\t\t     bb->frequency / 2) / bb->frequency, 1);\n       else\n-        return REG_BR_PROB_BASE;\n+\treturn REG_BR_PROB_BASE;\n     }\n \n   base = get_base_address (op);\n@@ -2130,27 +2120,27 @@ param_change_prob (gimple stmt, int i)\n \t\t\t  NULL);\n       if (bitmap_bit_p (info.bb_set, bb->index))\n \t{\n-          BITMAP_FREE (info.bb_set);\n+\t  BITMAP_FREE (info.bb_set);\n \t  return REG_BR_PROB_BASE;\n \t}\n \n       /* Assume that every memory is initialized at entry.\n-\t TODO: Can we easilly determine if value is always defined\n-\t and thus we may skip entry block?  */\n+         TODO: Can we easilly determine if value is always defined\n+         and thus we may skip entry block?  */\n       if (ENTRY_BLOCK_PTR->frequency)\n \tmax = ENTRY_BLOCK_PTR->frequency;\n       else\n \tmax = 1;\n \n       EXECUTE_IF_SET_IN_BITMAP (info.bb_set, 0, index, bi)\n \tmax = MIN (max, BASIC_BLOCK (index)->frequency);\n-      \n+\n       BITMAP_FREE (info.bb_set);\n       if (max < bb->frequency)\n-        return MAX ((max * REG_BR_PROB_BASE +\n+\treturn MAX ((max * REG_BR_PROB_BASE +\n \t\t     bb->frequency / 2) / bb->frequency, 1);\n       else\n-        return REG_BR_PROB_BASE;\n+\treturn REG_BR_PROB_BASE;\n     }\n   return REG_BR_PROB_BASE;\n }\n@@ -2251,19 +2241,18 @@ predicate_for_phi_result (struct inline_summary *summary, gimple phi,\n \n static struct predicate\n array_index_predicate (struct inline_summary *info,\n-\t\t       vec<predicate_t> nonconstant_names, tree op)\n+\t\t       vec< predicate_t> nonconstant_names, tree op)\n {\n   struct predicate p = false_predicate ();\n   while (handled_component_p (op))\n     {\n-      if (TREE_CODE (op) == ARRAY_REF\n-\t  || TREE_CODE (op) == ARRAY_RANGE_REF)\n-        {\n+      if (TREE_CODE (op) == ARRAY_REF || TREE_CODE (op) == ARRAY_RANGE_REF)\n+\t{\n \t  if (TREE_CODE (TREE_OPERAND (op, 1)) == SSA_NAME)\n-\t     p = or_predicates (info->conds, &p,\n-\t\t\t\t&nonconstant_names[\n-\t\t\t\t      SSA_NAME_VERSION (TREE_OPERAND (op, 1))]);\n-        }\n+\t    p = or_predicates (info->conds, &p,\n+\t\t\t       &nonconstant_names[SSA_NAME_VERSION\n+\t\t\t\t\t\t  (TREE_OPERAND (op, 1))]);\n+\t}\n       op = TREE_OPERAND (op, 0);\n     }\n   return p;\n@@ -2304,7 +2293,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       if (ipa_node_params_vector.exists ())\n \t{\n \t  parms_info = IPA_NODE_REF (node);\n-\t  nonconstant_names.safe_grow_cleared(SSANAMES (my_function)->length());\n+\t  nonconstant_names.safe_grow_cleared\n+\t    (SSANAMES (my_function)->length ());\n \t}\n     }\n \n@@ -2335,7 +2325,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       if (parms_info)\n \t{\n \t  if (bb->aux)\n-\t    bb_predicate = *(struct predicate *)bb->aux;\n+\t    bb_predicate = *(struct predicate *) bb->aux;\n \t  else\n \t    bb_predicate = false_predicate ();\n \t}\n@@ -2384,47 +2374,54 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      fprintf (dump_file, \"  \");\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t      fprintf (dump_file, \"\\t\\tfreq:%3.2f size:%3i time:%3i\\n\",\n-\t\t       ((double)freq)/CGRAPH_FREQ_BASE, this_size, this_time);\n+\t\t       ((double) freq) / CGRAPH_FREQ_BASE, this_size,\n+\t\t       this_time);\n \t    }\n \n \t  if (gimple_assign_load_p (stmt) && nonconstant_names.exists ())\n \t    {\n \t      struct predicate this_array_index;\n-\t      this_array_index = array_index_predicate (info, nonconstant_names,\n-\t\t\t\t\t\t        gimple_assign_rhs1 (stmt));\n+\t      this_array_index =\n+\t\tarray_index_predicate (info, nonconstant_names,\n+\t\t\t\t       gimple_assign_rhs1 (stmt));\n \t      if (!false_predicate_p (&this_array_index))\n-\t        array_index = and_predicates (info->conds, &array_index, &this_array_index);\n+\t\tarray_index =\n+\t\t  and_predicates (info->conds, &array_index,\n+\t\t\t\t  &this_array_index);\n \t    }\n \t  if (gimple_store_p (stmt) && nonconstant_names.exists ())\n \t    {\n \t      struct predicate this_array_index;\n-\t      this_array_index = array_index_predicate (info, nonconstant_names,\n-\t\t\t\t\t\t        gimple_get_lhs (stmt));\n+\t      this_array_index =\n+\t\tarray_index_predicate (info, nonconstant_names,\n+\t\t\t\t       gimple_get_lhs (stmt));\n \t      if (!false_predicate_p (&this_array_index))\n-\t        array_index = and_predicates (info->conds, &array_index, &this_array_index);\n+\t\tarray_index =\n+\t\t  and_predicates (info->conds, &array_index,\n+\t\t\t\t  &this_array_index);\n \t    }\n-\t   \n+\n \n \t  if (is_gimple_call (stmt))\n \t    {\n \t      struct cgraph_edge *edge = cgraph_edge (node, stmt);\n \t      struct inline_edge_summary *es = inline_edge_summary (edge);\n \n \t      /* Special case: results of BUILT_IN_CONSTANT_P will be always\n-\t\t resolved as constant.  We however don't want to optimize\n-\t\t out the cgraph edges.  */\n+\t         resolved as constant.  We however don't want to optimize\n+\t         out the cgraph edges.  */\n \t      if (nonconstant_names.exists ()\n \t\t  && gimple_call_builtin_p (stmt, BUILT_IN_CONSTANT_P)\n \t\t  && gimple_call_lhs (stmt)\n \t\t  && TREE_CODE (gimple_call_lhs (stmt)) == SSA_NAME)\n \t\t{\n \t\t  struct predicate false_p = false_predicate ();\n \t\t  nonconstant_names[SSA_NAME_VERSION (gimple_call_lhs (stmt))]\n-\t\t      = false_p;\n+\t\t    = false_p;\n \t\t}\n \t      if (ipa_node_params_vector.exists ())\n \t\t{\n-\t          int count = gimple_call_num_args (stmt);\n+\t\t  int count = gimple_call_num_args (stmt);\n \t\t  int i;\n \n \t\t  if (count)\n@@ -2444,12 +2441,12 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \n \t  /* TODO: When conditional jump or swithc is known to be constant, but\n- \t     we did not translate it into the predicates, we really can account\n+\t     we did not translate it into the predicates, we really can account\n \t     just maximum of the possible paths.  */\n \t  if (parms_info)\n \t    will_be_nonconstant\n-\t       = will_be_nonconstant_predicate (parms_info, info,\n-\t\t\t\t\t\tstmt, nonconstant_names);\n+\t      = will_be_nonconstant_predicate (parms_info, info,\n+\t\t\t\t\t       stmt, nonconstant_names);\n \t  if (this_time || this_size)\n \t    {\n \t      struct predicate p;\n@@ -2458,7 +2455,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \n \t      prob = eliminated_by_inlining_prob (stmt);\n \t      if (prob == 1 && dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"\\t\\t50%% will be eliminated by inlining\\n\");\n+\t\tfprintf (dump_file,\n+\t\t\t \"\\t\\t50%% will be eliminated by inlining\\n\");\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n@@ -2477,8 +2475,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t}\n \n \t      /* We account everything but the calls.  Calls have their own\n-\t\t size/time info attached to cgraph edges.  This is necessary\n-\t\t in order to make the cost disappear after inlining.  */\n+\t         size/time info attached to cgraph edges.  This is necessary\n+\t         in order to make the cost disappear after inlining.  */\n \t      if (!is_gimple_call (stmt))\n \t\t{\n \t\t  if (prob)\n@@ -2516,69 +2514,79 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       scev_initialize ();\n       FOR_EACH_LOOP (li, loop, 0)\n \t{\n-          vec<edge> exits;\n-          edge ex;\n+\t  vec<edge> exits;\n+\t  edge ex;\n \t  unsigned int j, i;\n \t  struct tree_niter_desc niter_desc;\n \t  basic_block *body = get_loop_body (loop);\n-\t  bb_predicate = *(struct predicate *)loop->header->aux;\n+\t  bb_predicate = *(struct predicate *) loop->header->aux;\n \n \t  exits = get_loop_exit_edges (loop);\n-          FOR_EACH_VEC_ELT (exits, j, ex)\n+\t  FOR_EACH_VEC_ELT (exits, j, ex)\n \t    if (number_of_iterations_exit (loop, ex, &niter_desc, false)\n \t\t&& !is_gimple_min_invariant (niter_desc.niter))\n-\t      {\n-\t\tpredicate will_be_nonconstant\n-\t\t = will_be_nonconstant_expr_predicate (parms_info, info,\n-\t\t\t\t\t\t       niter_desc.niter, nonconstant_names);\n-\t        if (!true_predicate_p (&will_be_nonconstant))\n-\t\t  will_be_nonconstant = and_predicates (info->conds,\n-\t\t\t\t\t\t\t&bb_predicate,\n-\t\t\t\t\t\t\t&will_be_nonconstant);\n-\t\tif (!true_predicate_p (&will_be_nonconstant)\n-\t\t    && !false_predicate_p (&will_be_nonconstant))\n-\t\t  /* This is slightly inprecise.  We may want to represent each loop with\n-\t\t     independent predicate.  */\n-\t\t  loop_iterations = and_predicates (info->conds, &loop_iterations, &will_be_nonconstant);\n-\t      }\n-          exits.release ();\n+\t    {\n+\t      predicate will_be_nonconstant\n+\t\t= will_be_nonconstant_expr_predicate (parms_info, info,\n+\t\t\t\t\t\t      niter_desc.niter,\n+\t\t\t\t\t\t      nonconstant_names);\n+\t      if (!true_predicate_p (&will_be_nonconstant))\n+\t\twill_be_nonconstant = and_predicates (info->conds,\n+\t\t\t\t\t\t      &bb_predicate,\n+\t\t\t\t\t\t      &will_be_nonconstant);\n+\t      if (!true_predicate_p (&will_be_nonconstant)\n+\t\t  && !false_predicate_p (&will_be_nonconstant))\n+\t\t/* This is slightly inprecise.  We may want to represent each\n+\t\t   loop with independent predicate.  */\n+\t\tloop_iterations =\n+\t\t  and_predicates (info->conds, &loop_iterations,\n+\t\t\t\t  &will_be_nonconstant);\n+\t    }\n+\t  exits.release ();\n \n-          for (i = 0; i < loop->num_nodes; i++)\n+\t  for (i = 0; i < loop->num_nodes; i++)\n \t    {\n \t      gimple_stmt_iterator gsi;\n-\t      bb_predicate = *(struct predicate *)body[i]->aux;\n-\t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t      bb_predicate = *(struct predicate *) body[i]->aux;\n+\t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi);\n+\t\t   gsi_next (&gsi))\n \t\t{\n \t\t  gimple stmt = gsi_stmt (gsi);\n \t\t  affine_iv iv;\n \t\t  ssa_op_iter iter;\n \t\t  tree use;\n \n \t\t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-\t\t    {\n-\t\t      predicate will_be_nonconstant;\n-\n-\t\t      if (!simple_iv (loop, loop_containing_stmt (stmt), use, &iv, true)\n-\t\t\t  || is_gimple_min_invariant (iv.step))\n-\t\t\tcontinue;\n+\t\t  {\n+\t\t    predicate will_be_nonconstant;\n+\n+\t\t    if (!simple_iv\n+\t\t\t(loop, loop_containing_stmt (stmt), use, &iv, true)\n+\t\t\t|| is_gimple_min_invariant (iv.step))\n+\t\t      continue;\n+\t\t    will_be_nonconstant\n+\t\t      = will_be_nonconstant_expr_predicate (parms_info, info,\n+\t\t\t\t\t\t\t    iv.step,\n+\t\t\t\t\t\t\t    nonconstant_names);\n+\t\t    if (!true_predicate_p (&will_be_nonconstant))\n \t\t      will_be_nonconstant\n-\t\t       = will_be_nonconstant_expr_predicate (parms_info, info,\n-\t\t\t\t\t\t\t     iv.step, nonconstant_names);\n-\t\t      if (!true_predicate_p (&will_be_nonconstant))\n-\t\t\twill_be_nonconstant = and_predicates (info->conds,\n-\t\t\t\t\t\t\t      &bb_predicate,\n-\t\t\t\t\t\t\t      &will_be_nonconstant);\n-\t\t      if (!true_predicate_p (&will_be_nonconstant)\n-\t\t\t  && !false_predicate_p (&will_be_nonconstant))\n-\t\t\t/* This is slightly inprecise.  We may want to represent each loop with\n-\t\t\t   independent predicate.  */\n-\t\t\tloop_stride = and_predicates (info->conds, &loop_stride, &will_be_nonconstant);\n-\t\t    }\n+\t\t\t = and_predicates (info->conds,\n+\t\t\t\t\t   &bb_predicate,\n+\t\t\t\t\t   &will_be_nonconstant);\n+\t\t    if (!true_predicate_p (&will_be_nonconstant)\n+\t\t\t&& !false_predicate_p (&will_be_nonconstant))\n+\t\t      /* This is slightly inprecise.  We may want to represent\n+\t\t\t each loop with independent predicate.  */\n+\t\t      loop_stride =\n+\t\t\tand_predicates (info->conds, &loop_stride,\n+\t\t\t\t\t&will_be_nonconstant);\n+\t\t  }\n \t\t}\n \t    }\n \t  free (body);\n \t}\n-      set_hint_predicate (&inline_summary (node)->loop_iterations, loop_iterations);\n+      set_hint_predicate (&inline_summary (node)->loop_iterations,\n+\t\t\t  loop_iterations);\n       set_hint_predicate (&inline_summary (node)->loop_stride, loop_stride);\n       scev_finalize ();\n     }\n@@ -2691,8 +2699,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->estimated_stack_size = info->estimated_self_stack_size;\n #ifdef ENABLE_CHECKING\n   inline_update_overall_summary (node);\n-  gcc_assert (info->time == info->self_time\n-\t      && info->size == info->self_size);\n+  gcc_assert (info->time == info->self_time && info->size == info->self_size);\n #endif\n \n   pop_cfun ();\n@@ -2709,24 +2716,24 @@ compute_inline_parameters_for_current (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_inline_parameters =\n+struct gimple_opt_pass pass_inline_parameters = \n {\n  {\n   GIMPLE_PASS,\n-  \"inline_param\",\t\t\t/* name */\n-  OPTGROUP_INLINE,                      /* optinfo_flags */\n-  NULL,\t\t\t\t\t/* gate */\n-  compute_inline_parameters_for_current,/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_INLINE_PARAMETERS,\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n- }\n+  \"inline_param\",\t\t/* name */\n+  OPTGROUP_INLINE,\t\t/* optinfo_flags */\n+  NULL,\t\t\t/* gate */\n+  compute_inline_parameters_for_current,\t/* execute */\n+  NULL,\t\t\t/* sub */\n+  NULL,\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_INLINE_PARAMETERS,\t/* tv_id */\n+  0,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t/* todo_flags_finish */\n+  }\n };\n \n \n@@ -2776,20 +2783,18 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n \t\t\t     vec<tree> known_binfos,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     inline_hints *hints)\n-\t\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n   int call_size = es->call_stmt_size;\n   int call_time = es->call_stmt_time;\n   if (!e->callee\n       && estimate_edge_devirt_benefit (e, &call_size, &call_time,\n \t\t\t\t       known_vals, known_binfos, known_aggs)\n-      && hints\n-      && cgraph_maybe_hot_edge_p (e))\n+      && hints && cgraph_maybe_hot_edge_p (e))\n     *hints |= INLINE_HINT_indirect_call;\n   *size += call_size * INLINE_SIZE_SCALE;\n   *time += call_time * prob / REG_BR_PROB_BASE\n-\t    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n+    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n   if (*time > MAX_TIME * INLINE_TIME_SCALE)\n     *time = MAX_TIME * INLINE_TIME_SCALE;\n }\n@@ -2812,26 +2817,29 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n-      if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n+      if (!es->predicate\n+\t  || evaluate_predicate (es->predicate, possible_truths))\n \t{\n \t  if (e->inline_failed)\n \t    {\n \t      /* Predicates of calls shall not use NOT_CHANGED codes,\n-\t\t sowe do not need to compute probabilities.  */\n+\t         sowe do not need to compute probabilities.  */\n \t      estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE,\n-\t\t\t\t\t   known_vals, known_binfos, known_aggs,\n-\t\t\t\t\t   hints);\n+\t\t\t\t\t   known_vals, known_binfos,\n+\t\t\t\t\t   known_aggs, hints);\n \t    }\n \t  else\n \t    estimate_calls_size_and_time (e->callee, size, time, hints,\n \t\t\t\t\t  possible_truths,\n-\t\t\t\t\t  known_vals, known_binfos, known_aggs);\n+\t\t\t\t\t  known_vals, known_binfos,\n+\t\t\t\t\t  known_aggs);\n \t}\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n-      if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n+      if (!es->predicate\n+\t  || evaluate_predicate (es->predicate, possible_truths))\n \testimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE,\n \t\t\t\t     known_vals, known_binfos, known_aggs,\n \t\t\t\t     hints);\n@@ -2849,10 +2857,10 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<tree> known_binfos,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t       \t     int *ret_size, int *ret_time,\n+\t\t\t     int *ret_size, int *ret_time,\n \t\t\t     inline_hints *ret_hints,\n \t\t\t     vec<inline_param_summary_t>\n-\t\t\t       inline_param_summary)\n+\t\t\t     inline_param_summary)\n {\n   struct inline_summary *info = inline_summary (node);\n   size_time_entry *e;\n@@ -2861,24 +2869,21 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   inline_hints hints = 0;\n   int i;\n \n-  if (dump_file\n-      && (dump_flags & TDF_DETAILS))\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       bool found = false;\n       fprintf (dump_file, \"   Estimating body: %s/%i\\n\"\n-\t\t\t  \"   Known to be false: \",\n-\t       cgraph_node_name (node),\n-\t       node->uid);\n+\t       \"   Known to be false: \", cgraph_node_name (node), node->uid);\n \n       for (i = predicate_not_inlined_condition;\n \t   i < (predicate_first_dynamic_condition\n-\t\t+ (int)vec_safe_length (info->conds)); i++)\n+\t\t+ (int) vec_safe_length (info->conds)); i++)\n \tif (!(possible_truths & (1 << i)))\n \t  {\n \t    if (found)\n \t      fprintf (dump_file, \", \");\n \t    found = true;\n-            dump_condition (dump_file, info->conds, i);\n+\t    dump_condition (dump_file, info->conds, i);\n \t  }\n     }\n \n@@ -2887,7 +2892,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n       {\n \tsize += e->size;\n \tgcc_checking_assert (e->time >= 0);\n-        gcc_checking_assert (time >= 0);\n+\tgcc_checking_assert (time >= 0);\n \tif (!inline_param_summary.exists ())\n \t  time += e->time;\n \telse\n@@ -2898,25 +2903,25 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t\t      inline_param_summary);\n \t    gcc_checking_assert (prob >= 0);\n \t    gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n-\t    time += ((gcov_type)e->time * prob) / REG_BR_PROB_BASE;\n+\t    time += ((gcov_type) e->time * prob) / REG_BR_PROB_BASE;\n \t  }\n-        if (time > MAX_TIME * INLINE_TIME_SCALE)\n-            time = MAX_TIME * INLINE_TIME_SCALE;\n-        gcc_checking_assert (time >= 0);\n-\t\t\t\t\t         \n+\tif (time > MAX_TIME * INLINE_TIME_SCALE)\n+\t  time = MAX_TIME * INLINE_TIME_SCALE;\n+\tgcc_checking_assert (time >= 0);\n+\n       }\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n \n   if (info->loop_iterations\n       && !evaluate_predicate (info->loop_iterations, possible_truths))\n-    hints |=INLINE_HINT_loop_iterations;\n+    hints |= INLINE_HINT_loop_iterations;\n   if (info->loop_stride\n       && !evaluate_predicate (info->loop_stride, possible_truths))\n-    hints |=INLINE_HINT_loop_stride;\n+    hints |= INLINE_HINT_loop_stride;\n   if (info->array_index\n       && !evaluate_predicate (info->array_index, possible_truths))\n-    hints |=INLINE_HINT_array_index;\n+    hints |= INLINE_HINT_array_index;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n   if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n@@ -2929,9 +2934,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   time = RDIV (time, INLINE_TIME_SCALE);\n   size = RDIV (size, INLINE_SIZE_SCALE);\n \n-  if (dump_file\n-      && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n   size:%i time:%i\\n\", (int)size, (int)time);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n   size:%i time:%i\\n\", (int) size, (int) time);\n   if (ret_time)\n     *ret_time = time;\n   if (ret_size)\n@@ -2949,11 +2953,11 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \n void\n estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n-\t\t\t\tvec<tree> known_vals,\n-\t\t\t\tvec<tree> known_binfos,\n-\t\t\t\tvec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t\tint *ret_size, int *ret_time,\n-\t\t\t\tinline_hints *hints)\n+\t\t\t\t   vec<tree> known_vals,\n+\t\t\t\t   vec<tree> known_binfos,\n+\t\t\t\t   vec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t\t   int *ret_size, int *ret_time,\n+\t\t\t\t   inline_hints *hints)\n {\n   clause_t clause;\n \n@@ -2982,8 +2986,7 @@ remap_predicate (struct inline_summary *info,\n \t\t struct predicate *p,\n \t\t vec<int> operand_map,\n \t\t vec<int> offset_map,\n-\t\t clause_t possible_truths,\n-\t\t struct predicate *toplev_predicate)\n+\t\t clause_t possible_truths, struct predicate *toplev_predicate)\n {\n   int i;\n   struct predicate out = true_predicate ();\n@@ -2999,7 +3002,7 @@ remap_predicate (struct inline_summary *info,\n \n       gcc_assert (i < MAX_CLAUSES);\n \n-      for (cond = 0; cond < NUM_CONDITIONS; cond ++)\n+      for (cond = 0; cond < NUM_CONDITIONS; cond++)\n \t/* Do we have condition we can't disprove?   */\n \tif (clause & possible_truths & (1 << cond))\n \t  {\n@@ -3008,42 +3011,42 @@ remap_predicate (struct inline_summary *info,\n \t       inlined function.  */\n \t    if (cond >= predicate_first_dynamic_condition)\n \t      {\n-\t\t struct condition *c;\n-\n-\t\t c = &(*callee_info->conds)[cond\n-\t\t\t\t\t    - predicate_first_dynamic_condition];\n-\t\t /* See if we can remap condition operand to caller's operand.\n-\t\t    Otherwise give up.  */\n-\t\t if (!operand_map.exists ()\n-\t\t     || (int)operand_map.length () <= c->operand_num\n-\t\t     || operand_map[c->operand_num] == -1\n-\t\t     /* TODO: For non-aggregate conditions, adding an offset is\n-\t\t\tbasically an arithmetic jump function processing which\n-\t\t\twe should support in future.  */\n-\t\t     || ((!c->agg_contents || !c->by_ref)\n-\t\t\t && offset_map[c->operand_num] > 0)\n-\t\t     || (c->agg_contents && c->by_ref\n-\t\t\t && offset_map[c->operand_num] < 0))\n-\t\t   cond_predicate = true_predicate ();\n-\t\t else\n-\t\t   {\n-\t\t     struct agg_position_info ap;\n-\t\t     HOST_WIDE_INT offset_delta = offset_map[c->operand_num];\n-\t\t     if (offset_delta < 0)\n-\t\t       {\n-\t\t\t gcc_checking_assert (!c->agg_contents || !c->by_ref);\n-\t\t\t offset_delta = 0;\n-\t\t       }\n-\t\t     gcc_assert (!c->agg_contents\n-\t\t\t\t || c->by_ref\n-\t\t\t\t || offset_delta == 0);\n-\t\t     ap.offset = c->offset + offset_delta;\n-\t\t     ap.agg_contents = c->agg_contents;\n-\t\t     ap.by_ref = c->by_ref;\n-\t\t     cond_predicate = add_condition (info,\n-\t\t\t\t\t\t     operand_map[c->operand_num],\n-\t\t\t\t\t\t     &ap, c->code, c->val);\n-\t\t   }\n+\t\tstruct condition *c;\n+\n+\t\tc = &(*callee_info->conds)[cond\n+\t\t\t\t\t   -\n+\t\t\t\t\t   predicate_first_dynamic_condition];\n+\t\t/* See if we can remap condition operand to caller's operand.\n+\t\t   Otherwise give up.  */\n+\t\tif (!operand_map.exists ()\n+\t\t    || (int) operand_map.length () <= c->operand_num\n+\t\t    || operand_map[c->operand_num] == -1\n+\t\t    /* TODO: For non-aggregate conditions, adding an offset is\n+\t\t       basically an arithmetic jump function processing which\n+\t\t       we should support in future.  */\n+\t\t    || ((!c->agg_contents || !c->by_ref)\n+\t\t\t&& offset_map[c->operand_num] > 0)\n+\t\t    || (c->agg_contents && c->by_ref\n+\t\t\t&& offset_map[c->operand_num] < 0))\n+\t\t  cond_predicate = true_predicate ();\n+\t\telse\n+\t\t  {\n+\t\t    struct agg_position_info ap;\n+\t\t    HOST_WIDE_INT offset_delta = offset_map[c->operand_num];\n+\t\t    if (offset_delta < 0)\n+\t\t      {\n+\t\t\tgcc_checking_assert (!c->agg_contents || !c->by_ref);\n+\t\t\toffset_delta = 0;\n+\t\t      }\n+\t\t    gcc_assert (!c->agg_contents\n+\t\t\t\t|| c->by_ref || offset_delta == 0);\n+\t\t    ap.offset = c->offset + offset_delta;\n+\t\t    ap.agg_contents = c->agg_contents;\n+\t\t    ap.by_ref = c->by_ref;\n+\t\t    cond_predicate = add_condition (info,\n+\t\t\t\t\t\t    operand_map[c->operand_num],\n+\t\t\t\t\t\t    &ap, c->code, c->val);\n+\t\t  }\n \t      }\n \t    /* Fixed conditions remains same, construct single\n \t       condition predicate.  */\n@@ -3065,8 +3068,7 @@ remap_predicate (struct inline_summary *info,\n    Compute peak stack usage.  */\n \n static void\n-inline_update_callee_summaries (struct cgraph_node *node,\n-\t\t\t        int depth)\n+inline_update_callee_summaries (struct cgraph_node *node, int depth)\n {\n   struct cgraph_edge *e;\n   struct inline_summary *callee_info = inline_summary (node);\n@@ -3075,12 +3077,11 @@ inline_update_callee_summaries (struct cgraph_node *node,\n \n   callee_info->stack_frame_offset\n     = caller_info->stack_frame_offset\n-      + caller_info->estimated_self_stack_size;\n+    + caller_info->estimated_self_stack_size;\n   peak = callee_info->stack_frame_offset\n-      + callee_info->estimated_self_stack_size;\n-  if (inline_summary (node->global.inlined_to)->estimated_stack_size\n-      < peak)\n-    inline_summary (node->global.inlined_to)->estimated_stack_size = peak;\n+    + callee_info->estimated_self_stack_size;\n+  if (inline_summary (node->global.inlined_to)->estimated_stack_size < peak)\n+      inline_summary (node->global.inlined_to)->estimated_stack_size = peak;\n   cgraph_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -3108,7 +3109,7 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n       struct inline_edge_summary *inlined_es\n-\t\t\t\t    = inline_edge_summary (inlined_edge);\n+\t= inline_edge_summary (inlined_edge);\n \n       for (i = 0; i < ipa_get_cs_argument_count (args); i++)\n \t{\n@@ -3129,7 +3130,7 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n \t      es->param[i].change_prob = prob;\n \t    }\n \t}\n-  }\n+    }\n }\n \n /* Update edge summaries of NODE after INLINED_EDGE has been inlined.\n@@ -3140,14 +3141,14 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n    Also update change probabilities.  */\n \n static void\n-remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n-\t\t       struct cgraph_node *node,\n-\t\t       struct inline_summary *info,\n-\t\t       struct inline_summary *callee_info,\n-\t\t       vec<int> operand_map,\n-\t\t       vec<int> offset_map,\n-\t\t       clause_t possible_truths,\n-\t\t       struct predicate *toplev_predicate)\n+remap_edge_summaries (struct cgraph_edge *inlined_edge,\n+\t\t      struct cgraph_node *node,\n+\t\t      struct inline_summary *info,\n+\t\t      struct inline_summary *callee_info,\n+\t\t      vec<int> operand_map,\n+\t\t      vec<int> offset_map,\n+\t\t      clause_t possible_truths,\n+\t\t      struct predicate *toplev_predicate)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n@@ -3163,12 +3164,11 @@ remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n \t    {\n \t      p = remap_predicate (info, callee_info,\n \t\t\t\t   es->predicate, operand_map, offset_map,\n-\t\t\t\t   possible_truths,\n-\t\t\t\t   toplev_predicate);\n+\t\t\t\t   possible_truths, toplev_predicate);\n \t      edge_set_predicate (e, &p);\n \t      /* TODO: We should remove the edge for code that will be\n-\t\t optimized out, but we need to keep verifiers and tree-inline\n-\t\t happy.  Make it cold for now.  */\n+\t         optimized out, but we need to keep verifiers and tree-inline\n+\t         happy.  Make it cold for now.  */\n \t      if (false_predicate_p (&p))\n \t\t{\n \t\t  e->count = 0;\n@@ -3227,17 +3227,13 @@ remap_hint_predicate (struct inline_summary *info,\n   p = remap_predicate (info, callee_info,\n \t\t       *hint,\n \t\t       operand_map, offset_map,\n-\t\t       possible_truths,\n-\t\t       toplev_predicate);\n-  if (!false_predicate_p (&p)\n-      && !true_predicate_p (&p))\n+\t\t       possible_truths, toplev_predicate);\n+  if (!false_predicate_p (&p) && !true_predicate_p (&p))\n     {\n       if (!*hint)\n \tset_hint_predicate (hint, p);\n       else\n-\t**hint = and_predicates (info->conds, \n-\t\t\t\t *hint,\n-\t\t\t\t &p);\n+\t**hint = and_predicates (info->conds, *hint, &p);\n     }\n }\n \n@@ -3312,19 +3308,19 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t\t\t\t\t    &toplev_predicate);\n       if (!false_predicate_p (&p))\n \t{\n-\t  gcov_type add_time = ((gcov_type)e->time * edge->frequency\n+\t  gcov_type add_time = ((gcov_type) e->time * edge->frequency\n \t\t\t\t+ CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n \t  int prob = predicate_probability (callee_info->conds,\n \t\t\t\t\t    &e->predicate,\n \t\t\t\t\t    clause, es->param);\n-\t  add_time = ((gcov_type)add_time * prob) / REG_BR_PROB_BASE;\n+\t  add_time = ((gcov_type) add_time * prob) / REG_BR_PROB_BASE;\n \t  if (add_time > MAX_TIME * INLINE_TIME_SCALE)\n \t    add_time = MAX_TIME * INLINE_TIME_SCALE;\n \t  if (prob != REG_BR_PROB_BASE\n \t      && dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"\\t\\tScaling time by probability:%f\\n\",\n-\t\t       (double)prob / REG_BR_PROB_BASE);\n+\t\t       (double) prob / REG_BR_PROB_BASE);\n \t    }\n \t  account_size_time (info, e->size, add_time, &p);\n \t}\n@@ -3333,16 +3329,13 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t\t\toffset_map, clause, &toplev_predicate);\n   remap_hint_predicate (info, callee_info,\n \t\t\t&callee_info->loop_iterations,\n-\t\t\toperand_map, offset_map,\n-\t\t\tclause, &toplev_predicate);\n+\t\t\toperand_map, offset_map, clause, &toplev_predicate);\n   remap_hint_predicate (info, callee_info,\n \t\t\t&callee_info->loop_stride,\n-\t\t\toperand_map, offset_map,\n-\t\t\tclause, &toplev_predicate);\n+\t\t\toperand_map, offset_map, clause, &toplev_predicate);\n   remap_hint_predicate (info, callee_info,\n \t\t\t&callee_info->array_index,\n-\t\t\toperand_map, offset_map,\n-\t\t\tclause, &toplev_predicate);\n+\t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -3371,10 +3364,10 @@ inline_update_overall_summary (struct cgraph_node *node)\n     {\n       info->size += e->size, info->time += e->time;\n       if (info->time > MAX_TIME * INLINE_TIME_SCALE)\n-        info->time = MAX_TIME * INLINE_TIME_SCALE;\n+\tinfo->time = MAX_TIME * INLINE_TIME_SCALE;\n     }\n   estimate_calls_size_and_time (node, &info->size, &info->time, NULL,\n-\t\t\t\t~(clause_t)(1 << predicate_false_condition),\n+\t\t\t\t~(clause_t) (1 << predicate_false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n@@ -3386,8 +3379,7 @@ simple_edge_hints (struct cgraph_edge *edge)\n {\n   int hints = 0;\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n-\t\t\t    ? edge->caller->global.inlined_to\n-\t\t\t    : edge->caller);\n+\t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n   if (inline_summary (to)->scc_no\n       && inline_summary (to)->scc_no == inline_summary (edge->callee)->scc_no\n       && !cgraph_edge_recursive_p (edge))\n@@ -3437,7 +3429,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache.exists ())\n     {\n-      if ((int)edge_growth_cache.length () <= edge->uid)\n+      if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (cgraph_edge_max_uid);\n       edge_growth_cache[edge->uid].time = time + (time >= 0);\n \n@@ -3537,7 +3529,8 @@ estimate_time_after_inlining (struct cgraph_node *node,\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n   if (!es->predicate || !false_predicate_p (es->predicate))\n     {\n-      gcov_type time = inline_summary (node)->time + estimate_edge_time (edge);\n+      gcov_type time =\n+\tinline_summary (node)->time + estimate_edge_time (edge);\n       if (time < 0)\n \ttime = 0;\n       if (time > MAX_TIME)\n@@ -3588,7 +3581,7 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n       if (e->caller == node\n \t  || (e->caller->global.inlined_to\n \t      && e->caller->global.inlined_to == node))\n-        d->self_recursive = true;\n+\td->self_recursive = true;\n       d->growth += estimate_edge_growth (e);\n     }\n   return false;\n@@ -3600,7 +3593,7 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n int\n do_estimate_growth (struct cgraph_node *node)\n {\n-  struct growth_data d = {0, false};\n+  struct growth_data d = { 0, false };\n   struct inline_summary *info = inline_summary (node);\n \n   cgraph_for_node_and_aliases (node, do_estimate_growth_1, &d, true);\n@@ -3618,18 +3611,18 @@ do_estimate_growth (struct cgraph_node *node)\n       if (cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units\n-\t since they come from various template instantiations.\n-\t Take this into account.  */\n-      else  if (DECL_COMDAT (node->symbol.decl)\n-\t\t&& cgraph_can_remove_if_no_direct_calls_p (node))\n+         since they come from various template instantiations.\n+         Take this into account.  */\n+      else if (DECL_COMDAT (node->symbol.decl)\n+\t       && cgraph_can_remove_if_no_direct_calls_p (node))\n \td.growth -= (info->size\n \t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n \t\t     + 50) / 100;\n     }\n \n   if (node_growth_cache.exists ())\n     {\n-      if ((int)node_growth_cache.length () <= node->uid)\n+      if ((int) node_growth_cache.length () <= node->uid)\n \tnode_growth_cache.safe_grow_cleared (cgraph_max_uid);\n       node_growth_cache[node->uid] = d.growth + (d.growth >= 0);\n     }\n@@ -3687,7 +3680,7 @@ inline_generate_summary (void)\n   struct cgraph_node *node;\n \n   function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+    cgraph_add_function_insertion_hook (&add_new_function, NULL);\n \n   ipa_register_cgraph_hooks ();\n   inline_free_summary ();\n@@ -3707,7 +3700,7 @@ read_predicate (struct lto_input_block *ib)\n   clause_t clause;\n   int k = 0;\n \n-  do \n+  do\n     {\n       gcc_assert (k <= MAX_CLAUSES);\n       clause = out.clause[k++] = streamer_read_uhwi (ib);\n@@ -3741,8 +3734,7 @@ read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n     {\n       es->param.safe_grow_cleared (length);\n       for (i = 0; i < length; i++)\n-\tes->param[i].change_prob\n-\t  = streamer_read_uhwi (ib);\n+\tes->param[i].change_prob = streamer_read_uhwi (ib);\n     }\n }\n \n@@ -3820,7 +3812,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n \t  vec_safe_push (info->entry, e);\n \t}\n-     \n+\n       p = read_predicate (&ib);\n       set_hint_predicate (&info->loop_iterations, p);\n       p = read_predicate (&ib);\n@@ -3859,7 +3851,7 @@ inline_read_summary (void)\n \t\t\t\t\t       LTO_section_inline_summary,\n \t\t\t\t\t       NULL, &len);\n       if (data)\n-        inline_read_section (file_data, data, len);\n+\tinline_read_section (file_data, data, len);\n       else\n \t/* Fatal error here.  We do not want to support compiling ltrans units\n \t   with different version of compiler or different flags than the WPA\n@@ -3870,10 +3862,10 @@ inline_read_summary (void)\n     {\n       ipa_register_cgraph_hooks ();\n       if (!flag_ipa_cp)\n-        ipa_prop_read_jump_functions ();\n+\tipa_prop_read_jump_functions ();\n     }\n   function_insertion_hook_holder =\n-      cgraph_add_function_insertion_hook (&add_new_function, NULL);\n+    cgraph_add_function_insertion_hook (&add_new_function, NULL);\n }\n \n \n@@ -3886,8 +3878,8 @@ write_predicate (struct output_block *ob, struct predicate *p)\n   if (p)\n     for (j = 0; p->clause[j]; j++)\n       {\n-\t gcc_assert (j < MAX_CLAUSES);\n-\t streamer_write_uhwi (ob, p->clause[j]);\n+\tgcc_assert (j < MAX_CLAUSES);\n+\tstreamer_write_uhwi (ob, p->clause[j]);\n       }\n   streamer_write_uhwi (ob, 0);\n }\n@@ -3906,7 +3898,7 @@ write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n   streamer_write_uhwi (ob, es->loop_depth);\n   write_predicate (ob, es->predicate);\n   streamer_write_uhwi (ob, es->param.length ());\n-  for (i = 0; i < (int)es->param.length (); i++)\n+  for (i = 0; i < (int) es->param.length (); i++)\n     streamer_write_uhwi (ob, es->param[i].change_prob);\n }\n \n@@ -3945,8 +3937,11 @@ inline_write_summary (void)\n \t  int i;\n \t  size_time_entry *e;\n \t  struct condition *c;\n-  \n-\t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, (symtab_node)node));\n+\n+\t  streamer_write_uhwi (ob,\n+\t\t\t       lto_symtab_encoder_encode (encoder,\n+\t\t\t\t\t\t\t  (symtab_node)\n+\t\t\t\t\t\t\t  node));\n \t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n \t  streamer_write_hwi (ob, info->self_size);\n \t  streamer_write_hwi (ob, info->self_time);\n@@ -3964,7 +3959,7 @@ inline_write_summary (void)\n \t      bp_pack_value (&bp, c->by_ref, 1);\n \t      streamer_write_bitpack (&bp);\n \t      if (c->agg_contents)\n-\t        streamer_write_uhwi (ob, c->offset);\n+\t\tstreamer_write_uhwi (ob, c->offset);\n \t    }\n \t  streamer_write_uhwi (ob, vec_safe_length (info->entry));\n \t  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)"}]}