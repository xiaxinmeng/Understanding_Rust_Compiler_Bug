{"sha": "d5f76abaa18183f5f559ab89e5afd23d10509ae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmNzZhYmFhMTgxODNmNWY1NTlhYjg5ZTVhZmQyM2QxMDUwOWFlMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-04-22T21:44:58Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-04-22T21:44:58Z"}, "message": "boehm.c (mark_reference_fields): Added `last_view_index' argument.\n\n\t* boehm.c (mark_reference_fields): Added `last_view_index'\n\targument.  Use DECL_FIELD_OFFSET to determine field's offset.\n\nFrom-SVN: r33346", "tree": {"sha": "b163d7f989de7cf9a0e0b4587ee70814fe288c09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b163d7f989de7cf9a0e0b4587ee70814fe288c09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5f76abaa18183f5f559ab89e5afd23d10509ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f76abaa18183f5f559ab89e5afd23d10509ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f76abaa18183f5f559ab89e5afd23d10509ae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f76abaa18183f5f559ab89e5afd23d10509ae1/comments", "author": null, "committer": null, "parents": [{"sha": "7841261c9904f8ff899e7bc3c09d4c7f0859287b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7841261c9904f8ff899e7bc3c09d4c7f0859287b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7841261c9904f8ff899e7bc3c09d4c7f0859287b"}], "stats": {"total": 58, "additions": 38, "deletions": 20}, "files": [{"sha": "9fdc4b68550995a4be5dcf9c6013b9ba2d59b39f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f76abaa18183f5f559ab89e5afd23d10509ae1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f76abaa18183f5f559ab89e5afd23d10509ae1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d5f76abaa18183f5f559ab89e5afd23d10509ae1", "patch": "@@ -1,3 +1,8 @@\n+2000-04-22  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* boehm.c (mark_reference_fields): Added `last_view_index'\n+\targument.  Use DECL_FIELD_OFFSET to determine field's offset.\n+\n Thu Apr 20 17:41:28 2000  Mo DeJong  <mdejong@cygnus.com>\n \n \t* parse.h (INTERFACE_INNER_MODIFIERS): New macro."}, {"sha": "237158d2fd0db1fba9b93de220826e895033058d", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f76abaa18183f5f559ab89e5afd23d10509ae1/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f76abaa18183f5f559ab89e5afd23d10509ae1/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=d5f76abaa18183f5f559ab89e5afd23d10509ae1", "patch": "@@ -31,11 +31,13 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"java-tree.h\"\n #include \"parse.h\"\n \n-static unsigned int mark_reference_fields PARAMS ((tree,\n-\t\t\t\t\t\t   unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t\t   unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t\t   unsigned int,\n-\t\t\t\t\t\t   int *, int *, int *));\n+static void mark_reference_fields PARAMS ((tree,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t   unsigned int,\n+\t\t\t\t\t   int *, int *,\n+\t\t\t\t\t   int *,\n+\t\t\t\t\t   HOST_WIDE_INT *));\n static void set_bit PARAMS ((unsigned HOST_WIDE_INT *,\n \t\t\t     unsigned HOST_WIDE_INT *,\n \t\t\t     unsigned int));\n@@ -69,33 +71,45 @@ set_bit (low, high, n)\n }\n \n /* Recursively mark reference fields.  */\n-static unsigned int\n+static void\n mark_reference_fields (field, low, high, ubit,\n-\t\t       pointer_after_end, all_bits_set, last_set_index)\n+\t\t       pointer_after_end, all_bits_set,\n+\t\t       last_set_index, last_view_index)\n      tree field;\n      unsigned HOST_WIDE_INT *low, *high;\n      unsigned int ubit;\n-     int *pointer_after_end, *all_bits_set, *last_set_index;\n+     int *pointer_after_end, *all_bits_set;\n+     int *last_set_index;\n+     HOST_WIDE_INT *last_view_index;\n {\n-  unsigned int count = 0;\n-\n   /* See if we have fields from our superclass.  */\n   if (DECL_NAME (field) == NULL_TREE)\n     {\n-      count += mark_reference_fields (TYPE_FIELDS (TREE_TYPE (field)),\n-\t\t\t\t      low, high, ubit,\n-\t\t\t\t      pointer_after_end, all_bits_set,\n-\t\t\t\t      last_set_index);\n+      mark_reference_fields (TYPE_FIELDS (TREE_TYPE (field)),\n+\t\t\t     low, high, ubit,\n+\t\t\t     pointer_after_end, all_bits_set,\n+\t\t\t     last_set_index, last_view_index);\n       field = TREE_CHAIN (field);\n     }\n \n   for (; field != NULL_TREE; field = TREE_CHAIN (field))\n     {\n+      HOST_WIDE_INT offset = tree_low_cst (byte_position (field), 1);\n+\n       if (FIELD_STATIC (field))\n \tcontinue;\n \n       if (JREFERENCE_TYPE_P (TREE_TYPE (field)))\n \t{\n+\t  unsigned int count;\n+\n+\t  /* If this reference slot appears to overlay a slot we think\n+\t     we already covered, then we are doomed.  */\n+\t  if (offset <= *last_view_index)\n+\t    abort ();\n+\n+\t  count = offset * BITS_PER_UNIT / POINTER_SIZE;\n+\n \t  *last_set_index = count;\n \t  /* First word in object corresponds to most significant byte\n \t     of bitmap.  */\n@@ -106,10 +120,8 @@ mark_reference_fields (field, low, high, ubit,\n       else\n \t*all_bits_set = 0;\n \n-      ++count;\n+      *last_view_index = offset;\n     }\n-\n-  return count;\n }\n \n /* Return the marking bitmap for the class TYPE.  For now this is a\n@@ -121,6 +133,7 @@ get_boehm_type_descriptor (tree type)\n   int bit;\n   int all_bits_set = 1;\n   int last_set_index = 0;\n+  HOST_WIDE_INT last_view_index = -1;\n   int pointer_after_end = 0;\n   unsigned HOST_WIDE_INT low = 0, high = 0;\n   tree field, value;\n@@ -151,9 +164,9 @@ get_boehm_type_descriptor (tree type)\n   ubit = (unsigned int) bit;\n \n   field = TYPE_FIELDS (type);\n-  count = mark_reference_fields (field, &low, &high, ubit,\n-\t\t\t\t &pointer_after_end, &all_bits_set,\n-\t\t\t\t &last_set_index);\n+  mark_reference_fields (field, &low, &high, ubit,\n+\t\t\t &pointer_after_end, &all_bits_set,\n+\t\t\t &last_set_index, &last_view_index);\n \n   /* If the object is all pointers, or if the part with pointers fits\n      in our bitmap, then we are ok.  Otherwise we have to allocate it"}]}