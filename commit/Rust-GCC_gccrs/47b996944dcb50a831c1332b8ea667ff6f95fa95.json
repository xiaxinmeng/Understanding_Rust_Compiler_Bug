{"sha": "47b996944dcb50a831c1332b8ea667ff6f95fa95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiOTk2OTQ0ZGNiNTBhODMxYzEzMzJiOGVhNjY3ZmY2Zjk1ZmE5NQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-08-21T10:12:53Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-08-21T10:12:53Z"}, "message": "re PR fortran/36158 (Transformational function BESSEL_YN(n1,n2,x) and BESSEL_JN missing)\n\n2010-08-21  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36158\n        PR fortran/33197\n        * intrinsic.c (add_sym): Init value attribute.\n        (set_attr_value): New function.\n        (add_functions) Use it and add JN/YN resolvers.\n        * symbol.c (gfc_copy_formal_args_intr): Copy value attr.\n        * intrinsic.h (gfc_resolve_bessel_n2): New prototype.\n        * gfortran.h (gfc_intrinsic_arg): Add value attribute.\n        * iresolve.c (gfc_resolve_bessel_n2): New function.\n        * trans-intrinsic.c (gfc_get_symbol_for_expr): Create\n        formal arg list.\n        (gfc_conv_intrinsic_function,gfc_is_intrinsic_libcall):\n        Add GFC_ISYM_JN2/GFC_ISYM_YN2 as case value.\n        * simplify.c (): For YN set to -INF if previous values\n        was -INF.\n        * trans-expr.c (gfc_conv_procedure_call): Don't crash\n        if sym->as is NULL.\n        * iresolve.c (gfc_resolve_extends_type_of): Set the\n        type of the dummy argument to the one of the actual.\n\n2010-08-21  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36158\n        PR fortran/33197\n        * m4/bessel.m4: Implement bessel_jn and bessel_yn.\n        * gfortran.map: Add the generated bessel_jn_r{4,8,10,16}\n        and bessel_yn_r{4,8,10,16}.\n        * Makefile.am: Add bessel.m4.\n        * Makefile.in: Regenerated.\n        * generated/bessel_r4.c: Generated.\n        * generated/bessel_r16.c: Generated.\n        * generated/bessel_r8.c: Generated.\n        * generated/bessel_r10.c: Generated.\n\n2010-08-21  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36158\n        PR fortran/33197\n        * gfortran.dg/bessel_6.f90: New.\n        * gfortran.dg/bessel_7.f90: New.\n\nFrom-SVN: r163440", "tree": {"sha": "f963b78e966a67d516f6105c26a4b775d5c2dcfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f963b78e966a67d516f6105c26a4b775d5c2dcfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47b996944dcb50a831c1332b8ea667ff6f95fa95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b996944dcb50a831c1332b8ea667ff6f95fa95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b996944dcb50a831c1332b8ea667ff6f95fa95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b996944dcb50a831c1332b8ea667ff6f95fa95/comments", "author": null, "committer": null, "parents": [{"sha": "508e475706c3560a86b08446e1bb764773b93ed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508e475706c3560a86b08446e1bb764773b93ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508e475706c3560a86b08446e1bb764773b93ed9"}], "stats": {"total": 1298, "additions": 1248, "deletions": 50}, "files": [{"sha": "111004d3e1be483ddd41965b425db50370dde83c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1,3 +1,25 @@\n+2010-08-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36158\n+\tPR fortran/33197\n+\t* intrinsic.c (add_sym): Init value attribute.\n+\t(set_attr_value): New function.\n+\t(add_functions) Use it and add JN/YN resolvers.\n+\t* symbol.c (gfc_copy_formal_args_intr): Copy value attr.\n+\t* intrinsic.h (gfc_resolve_bessel_n2): New prototype.\n+\t* gfortran.h (gfc_intrinsic_arg): Add value attribute.\n+\t* iresolve.c (gfc_resolve_bessel_n2): New function.\n+\t* trans-intrinsic.c (gfc_get_symbol_for_expr): Create\n+\tformal arg list.\n+\t(gfc_conv_intrinsic_function,gfc_is_intrinsic_libcall):\n+\tAdd GFC_ISYM_JN2/GFC_ISYM_YN2 as case value.\n+\t* simplify.c (): For YN set to -INF if previous values\n+\twas -INF.\n+\t* trans-expr.c (gfc_conv_procedure_call): Don't crash\n+\tif sym->as is NULL.\n+\t* iresolve.c (gfc_resolve_extends_type_of): Set the\n+\ttype of the dummy argument to the one of the actual.\n+\n 2010-08-20  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lang.opt (MD, MMD): Use NoDriverArg instead of NoArgDriver."}, {"sha": "9fb46d55dc2319f29cde1733b9e5d9d58562a6c4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1540,7 +1540,7 @@ typedef struct gfc_intrinsic_arg\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n \n   gfc_typespec ts;\n-  int optional;\n+  unsigned optional:1, value:1;\n   ENUM_BITFIELD (sym_intent) intent:2;\n   gfc_actual_arglist *actual;\n "}, {"sha": "9087106d9586a93ed64632a0735dd15c88398f5c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -330,6 +330,7 @@ add_sym (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type\n \t  next_arg->ts.type = type;\n \t  next_arg->ts.kind = kind;\n \t  next_arg->optional = optional;\n+\t  next_arg->value = 0;\n \t  next_arg->intent = intent;\n \t}\n     }\n@@ -1065,6 +1066,30 @@ make_noreturn (void)\n     next_sym[-1].noreturn = 1;\n }\n \n+/* Set the attr.value of the current procedure.  */\n+\n+static void\n+set_attr_value (int n, ...)\n+{\n+  gfc_intrinsic_arg *arg;\n+  va_list argp;\n+  int i;\n+\n+  if (sizing != SZ_NOTHING)\n+    return;\n+\n+  va_start (argp, n);\n+  arg = next_sym[-1].formal;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      gcc_assert (arg != NULL);\n+      arg->value = va_arg (argp, int);\n+      arg = arg->next;\n+    }\n+  va_end (argp);\n+}\n+\n \n /* Add intrinsic functions.  */\n \n@@ -1318,9 +1343,10 @@ add_functions (void)\n \t     n, BT_INTEGER, di, REQUIRED, x, BT_REAL, dd, REQUIRED);\n \n   add_sym_3 (\"bessel_jn\", GFC_ISYM_JN2, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n-\t     gfc_check_bessel_n2, gfc_simplify_bessel_jn2, NULL,\n+\t     gfc_check_bessel_n2, gfc_simplify_bessel_jn2, gfc_resolve_bessel_n2,\n \t     \"n1\", BT_INTEGER, di, REQUIRED,\"n2\", BT_INTEGER, di, REQUIRED,\n \t     x, BT_REAL, dr, REQUIRED);\n+  set_attr_value (3, true, true, true);\n \n   make_generic (\"bessel_jn\", GFC_ISYM_JN, GFC_STD_F2008);\n \n@@ -1359,9 +1385,10 @@ add_functions (void)\n \t     n, BT_INTEGER, di, REQUIRED, x, BT_REAL, dd, REQUIRED);\n \n   add_sym_3 (\"bessel_yn\", GFC_ISYM_YN2, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n-\t     gfc_check_bessel_n2, gfc_simplify_bessel_yn2, NULL,\n+\t     gfc_check_bessel_n2, gfc_simplify_bessel_yn2, gfc_resolve_bessel_n2,\n \t     \"n1\", BT_INTEGER, di, REQUIRED,\"n2\", BT_INTEGER, di, REQUIRED,\n \t      x, BT_REAL, dr, REQUIRED);\n+  set_attr_value (3, true, true, true);\n \n   make_generic (\"bessel_yn\", GFC_ISYM_YN, GFC_STD_F2008);\n "}, {"sha": "5de0116ecdba60eb9e4cdab279883d24f23b5ab0", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -380,6 +380,7 @@ void gfc_resolve_atan (gfc_expr *, gfc_expr *);\n void gfc_resolve_atanh (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan2 (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_besn (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *a);\n void gfc_resolve_btest (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ceiling (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_char (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "6565187423eaa43abbcf5e37ae0f2f481a4f2392", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -415,6 +415,45 @@ gfc_resolve_besn (gfc_expr *f, gfc_expr *n, gfc_expr *x)\n }\n \n \n+void\n+gfc_resolve_bessel_n2 (gfc_expr *f, gfc_expr *n1, gfc_expr *n2, gfc_expr *x)\n+{\n+  gfc_typespec ts;\n+  gfc_clear_ts (&ts);\n+  \n+  f->ts = x->ts;\n+  f->rank = 1;\n+  if (n1->expr_type == EXPR_CONSTANT && n2->expr_type == EXPR_CONSTANT)\n+    {\n+      f->shape = gfc_get_shape (1);\n+      mpz_init (f->shape[0]);\n+      mpz_sub (f->shape[0], n2->value.integer, n1->value.integer);\n+      mpz_add_ui (f->shape[0], f->shape[0], 1);\n+    }\n+\n+  if (n1->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      gfc_convert_type (n1, &ts, 2);\n+    }\n+\n+  if (n2->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      gfc_convert_type (n2, &ts, 2);\n+    }\n+\n+  if (f->value.function.isym->id == GFC_ISYM_JN2)\n+    f->value.function.name = gfc_get_string (PREFIX (\"bessel_jn_r%d\"),\n+\t\t\t\t\t     f->ts.kind);\n+  else\n+    f->value.function.name = gfc_get_string (PREFIX (\"bessel_yn_r%d\"),\n+\t\t\t\t\t     f->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_btest (gfc_expr *f, gfc_expr *i, gfc_expr *pos)\n {\n@@ -883,6 +922,10 @@ gfc_resolve_extends_type_of (gfc_expr *f, gfc_expr *a, gfc_expr *mo)\n \n   f->ts.type = BT_LOGICAL;\n   f->ts.kind = 4;\n+\n+  f->value.function.isym->formal->ts = a->ts;\n+  f->value.function.isym->formal->next->ts = mo->ts;\n+\n   /* Call library function.  */\n   f->value.function.name = gfc_get_string (PREFIX (\"is_extension_of\"));\n }"}, {"sha": "4cb29fbfc6780b42aac6d596df1fe1f63fbee61b", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1210,11 +1210,7 @@ gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n \n   if (x->expr_type != EXPR_CONSTANT || order1->expr_type != EXPR_CONSTANT\n       || order2->expr_type != EXPR_CONSTANT)\n-    {\n-      gfc_error (\"Sorry, non-constant transformational Bessel function at %L\"\n-\t\t   \" not yet supported\", &order2->where);\n-      return &gfc_bad_expr;\n-    }\n+    return NULL;\n \n   n1 = mpz_get_si (order1->value.integer);\n   n2 = mpz_get_si (order2->value.integer);\n@@ -1253,7 +1249,7 @@ gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n \t  if (jn)\n \t    mpfr_set_ui (e->value.real, 0.0, GFC_RND_MODE);\n \t  else\n-            mpfr_set_inf (e->value.real, -1);\n+\t    mpfr_set_inf (e->value.real, -1);\n \t  gfc_constructor_append_expr (&result->value.constructor, e,\n \t\t\t\t       &x->where);\n \t}\n@@ -1334,6 +1330,17 @@ gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n   for (i = 2; i <= n2-n1; i++)\n     {\n       e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n+\n+      /* Special case: For YN, if the previous N gave -INF, set\n+\t also N+1 to -INF.  */\n+      if (!jn && !gfc_option.flag_range_check && mpfr_inf_p (last2))\n+\t{\n+\t  mpfr_set_inf (e->value.real, -1);\n+\t  gfc_constructor_append_expr (&result->value.constructor, e,\n+\t\t\t\t       &x->where);\n+\t  continue;\n+\t}\n+\n       mpfr_mul_si (e->value.real, x2rev, jn ? (n2-i+1) : (n1+i-1),\n \t\t   GFC_RND_MODE);\n       mpfr_mul (e->value.real, e->value.real, last2, GFC_RND_MODE);"}, {"sha": "b4fc82c6ac983696558c6e216b5b75ab1c676358", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -4108,6 +4108,7 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src)\n       /* May need to copy more info for the symbol.  */\n       formal_arg->sym->ts = curr_arg->ts;\n       formal_arg->sym->attr.optional = curr_arg->optional;\n+      formal_arg->sym->attr.value = curr_arg->value;\n       formal_arg->sym->attr.intent = curr_arg->intent;\n       formal_arg->sym->attr.flavor = FL_VARIABLE;\n       formal_arg->sym->attr.dummy = 1;"}, {"sha": "f7badd71b2847fb89edfbf49c5aff70a7078b996", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -3015,7 +3015,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      bool f;\n \t      f = (fsym != NULL)\n \t\t  && !(fsym->attr.pointer || fsym->attr.allocatable)\n-\t\t  && fsym->as->type != AS_ASSUMED_SHAPE;\n+\t\t  && fsym->as && fsym->as->type != AS_ASSUMED_SHAPE;\n \t      if (comp)\n \t\tf = f || !comp->attr.always_explicit;\n \t      else"}, {"sha": "373770fef7d339104a7222b7d20c66eab92b15bb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1562,7 +1562,8 @@ gfc_get_symbol_for_expr (gfc_expr * expr)\n       sym->as->rank = expr->rank;\n     }\n \n-  /* TODO: proper argument lists for external intrinsics.  */\n+  gfc_copy_formal_args_intr (sym, expr->value.function.isym);\n+\n   return sym;\n }\n \n@@ -5389,6 +5390,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n     case GFC_ISYM_IERRNO:\n     case GFC_ISYM_IRAND:\n     case GFC_ISYM_ISATTY:\n+    case GFC_ISYM_JN2:\n     case GFC_ISYM_LINK:\n     case GFC_ISYM_LSTAT:\n     case GFC_ISYM_MALLOC:\n@@ -5407,6 +5409,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n     case GFC_ISYM_TIME8:\n     case GFC_ISYM_UMASK:\n     case GFC_ISYM_UNLINK:\n+    case GFC_ISYM_YN2:\n       gfc_conv_intrinsic_funcall (se, expr);\n       break;\n \n@@ -5499,6 +5502,7 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n     case GFC_ISYM_ALL:\n     case GFC_ISYM_ANY:\n     case GFC_ISYM_COUNT:\n+    case GFC_ISYM_JN2:\n     case GFC_ISYM_MATMUL:\n     case GFC_ISYM_MAXLOC:\n     case GFC_ISYM_MAXVAL:\n@@ -5509,6 +5513,7 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n     case GFC_ISYM_SHAPE:\n     case GFC_ISYM_SPREAD:\n     case GFC_ISYM_TRANSPOSE:\n+    case GFC_ISYM_YN2:\n       /* Ignore absent optional parameters.  */\n       return 1;\n "}, {"sha": "1bdada5606dc78da5b0b1fd8c14566528fc6fecf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1,3 +1,10 @@\n+2010-08-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36158\n+\tPR fortran/33197\n+\t* gfortran.dg/bessel_6.f90: New.\n+\t* gfortran.dg/bessel_7.f90: New.\n+\n 2010-08-20  Jan Hubicka  <jh@suse.cz>\n \n \tPR c++/45307"}, {"sha": "1834d67a0f530ab81fd8128d602e10d6951839e7", "filename": "gcc/testsuite/gfortran.dg/bessel_6.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_6.f90?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+!\n+! PR fortran/36158\n+! PR fortran/33197\n+!\n+! Run-time tests for transformations BESSEL_JN\n+!\n+implicit none\n+real,parameter :: values(*) = [0.0, 0.5, 1.0, 0.9, 1.8,2.0,3.0,4.0,4.25,8.0,34.53, 475.78] \n+real,parameter :: myeps(size(values)) = epsilon(0.0) &\n+                  * [2, 7, 5, 6, 9, 12, 12, 7, 7, 8, 75, 6 ]\n+! The following is sufficient for me - the values above are a bit\n+! more tolerant\n+!                  * [0, 5, 3, 4, 6, 7, 7, 5, 5, 6, 66, 4 ]\n+integer,parameter :: mymax(size(values)) =  &\n+                 [100, 17, 23, 21, 27, 28, 32, 35, 36, 41, 49, 50 ]\n+integer, parameter :: Nmax = 100\n+real :: rec(0:Nmax), lib(0:Nmax)\n+integer :: i\n+\n+do i = 1, ubound(values,dim=1)\n+  call compare(mymax(i), values(i), myeps(i))\n+end do\n+\n+contains\n+\n+subroutine compare(mymax, X, myeps)\n+\n+integer :: i, nit, mymax\n+real X, myeps, myeps2\n+\n+rec(0:mymax) = BESSEL_JN(0, mymax, X)\n+lib(0:mymax) = [ (BESSEL_JN(i, X), i=0,mymax) ]\n+\n+!print *, 'YN for X = ', X, ' -- Epsilon = ',epsilon(x)\n+do i = 0, mymax\n+!  print '(i2,2e17.9,e12.2,f18.10,2l3)', i, rec(i), lib(i), &\n+!        rec(i)-lib(i),           ((rec(i)-lib(i))/rec(i))/epsilon(x), &\n+!        rec(i) == lib(i) .or. abs((rec(i)-lib(i))/rec(i)) < myeps\n+if (.not. (rec(i) == lib(i) .or. abs((rec(i)-lib(i))/rec(i)) < myeps)) &\n+  call abort()\n+end do\n+\n+end\n+end"}, {"sha": "87b206c945de0adec072113da059867b9cb2ba53", "filename": "gcc/testsuite/gfortran.dg/bessel_7.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_7.f90?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+!\n+! PR fortran/36158\n+! PR fortran/33197\n+!\n+! Run-time tests for transformations BESSEL_YN\n+!\n+implicit none\n+real,parameter :: values(*) = [0.0, 0.5, 1.0, 0.9, 1.8,2.0,3.0,4.0,4.25,8.0,34.53, 475.78] \n+real,parameter :: myeps(size(values)) = epsilon(0.0) &\n+                  * [2, 2, 2, 5, 5, 2, 12, 2, 4, 3, 30, 130 ]\n+! The following is sufficient for me - the values above are a bit\n+! more tolerant\n+!                  * [0, 0, 0, 3, 3, 0, 9, 0, 2, 1, 22, 130 ]\n+integer,parameter :: nit(size(values)) =  &\n+                 [100, 100, 100, 100, 100, 100, 10, 100, 100, 100, 10, 25 ]\n+integer, parameter :: Nmax = 100\n+real :: rec(0:Nmax), lib(0:Nmax)\n+integer :: i\n+\n+do i = 1, ubound(values,dim=1)\n+  call compare(values(i), myeps(i), nit(i), 3*epsilon(0.0))\n+end do\n+\n+contains\n+\n+subroutine compare(X, myeps, nit, myeps2)\n+\n+integer :: i, nit\n+real X, myeps, myeps2\n+\n+rec = BESSEL_YN(0, Nmax, X)\n+lib = [ (BESSEL_YN(i, X), i=0,Nmax) ]\n+\n+!print *, 'YN for X = ', X, ' -- Epsilon = ',epsilon(x)\n+do i = 0, Nmax\n+!  print '(i2,2e17.9,e12.2,f14.10,2l3)', i, rec(i), lib(i), &\n+!        rec(i)-lib(i), ((rec(i)-lib(i))/rec(i))/epsilon(x), &\n+!        i > nit .or. rec(i) == lib(i) &\n+!                .or. abs((rec(i)-lib(i))/rec(i)) < myeps2, &\n+!        rec(i) == lib(i) .or. abs((rec(i)-lib(i))/rec(i)) < myeps\n+if (.not. (i > nit .or. rec(i) == lib(i) &\n+                   .or. abs((rec(i)-lib(i))/rec(i)) < myeps2)) &\n+  call abort ()\n+if (.not. (rec(i) == lib(i) .or. abs((rec(i)-lib(i))/rec(i)) < myeps)) &\n+  call abort ()\n+end do\n+\n+end\n+end"}, {"sha": "2e2ba26021e5918449886a7c4531893e60b88d64", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1,3 +1,17 @@\n+2010-08-19  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36158\n+\tPR fortran/33197\n+\t* m4/bessel.m4: Implement bessel_jn and bessel_yn.\n+\t* gfortran.map: Add the generated bessel_jn_r{4,8,10,16}\n+\tand bessel_yn_r{4,8,10,16}.\n+\t* Makefile.am: Add bessel.m4.\n+\t* Makefile.in: Regenerated.\n+\t* generated/bessel_r4.c: Generated.\n+\t* generated/bessel_r16.c: Generated.\n+\t* generated/bessel_r8.c: Generated.\n+\t* generated/bessel_r10.c: Generated.\n+\n 2010-08-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/45108\n@@ -33,8 +47,8 @@\n \n 2010-08-01  Janne Blomqvist  <jb@gcc.gnu.org>\n \n-        * io/unix.c (file_exists): Use access(2) instead of stat(2) to\n-        test file existence.\n+\t* io/unix.c (file_exists): Use access(2) instead of stat(2) to\n+\ttest file existence.\n \t(fallback_access): Move up in file, implement F_OK.\n \n 2010-07-31  David Edelsohn  <edelsohn@gnu.org>"}, {"sha": "8d470b79c407f9df57e7133cfc87e2278204be39", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -175,6 +175,12 @@ $(srcdir)/generated/any_l4.c \\\n $(srcdir)/generated/any_l8.c \\\n $(srcdir)/generated/any_l16.c\n \n+i_bessel_c= \\\n+$(srcdir)/generated/bessel_r4.c \\\n+$(srcdir)/generated/bessel_r8.c \\\n+$(srcdir)/generated/bessel_r10.c \\\n+$(srcdir)/generated/bessel_r16.c\n+\n i_count_c= \\\n $(srcdir)/generated/count_1_l.c \\\n $(srcdir)/generated/count_2_l.c \\\n@@ -583,11 +589,11 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n-    m4/unpack.m4 m4/spread.m4\n+    m4/unpack.m4 m4/spread.m4 m4/bessel.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n-    $(i_product_c) $(i_sum_c) \\\n+    $(i_product_c) $(i_sum_c) $(i_bessel_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n@@ -821,6 +827,9 @@ if MAINTAINER_MODE\n $(i_all_c): m4/all.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 all.m4 > $@\n \n+$(i_bessel_c): m4/bessel.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 bessel.m4 > $@\n+\n $(i_any_c): m4/any.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 any.m4 > $@\n "}, {"sha": "d4b5146f16834ea389888ad7ecb424cbf397858f", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 77, "deletions": 35, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -143,67 +143,68 @@ am__objects_11 = product_i1.lo product_i2.lo product_i4.lo \\\n am__objects_12 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \\\n \tsum_r4.lo sum_r8.lo sum_r10.lo sum_r16.lo sum_c4.lo sum_c8.lo \\\n \tsum_c10.lo sum_c16.lo\n-am__objects_13 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \\\n+am__objects_13 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo\n+am__objects_14 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \\\n \tmatmul_i16.lo matmul_r4.lo matmul_r8.lo matmul_r10.lo \\\n \tmatmul_r16.lo matmul_c4.lo matmul_c8.lo matmul_c10.lo \\\n \tmatmul_c16.lo\n-am__objects_14 = matmul_l4.lo matmul_l8.lo matmul_l16.lo\n-am__objects_15 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \\\n+am__objects_15 = matmul_l4.lo matmul_l8.lo matmul_l16.lo\n+am__objects_16 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \\\n \ttranspose_r4.lo transpose_r8.lo transpose_r10.lo \\\n \ttranspose_r16.lo transpose_c4.lo transpose_c8.lo \\\n \ttranspose_c10.lo transpose_c16.lo\n-am__objects_16 = shape_i4.lo shape_i8.lo shape_i16.lo\n-am__objects_17 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo\n-am__objects_18 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo\n-am__objects_19 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n-am__objects_20 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n+am__objects_17 = shape_i4.lo shape_i8.lo shape_i16.lo\n+am__objects_18 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo\n+am__objects_19 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo\n+am__objects_20 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n+am__objects_21 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n \treshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \\\n \treshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo\n-am__objects_21 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \\\n+am__objects_22 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \\\n \tin_pack_i8.lo in_pack_i16.lo in_pack_r4.lo in_pack_r8.lo \\\n \tin_pack_r10.lo in_pack_r16.lo in_pack_c4.lo in_pack_c8.lo \\\n \tin_pack_c10.lo in_pack_c16.lo\n-am__objects_22 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \\\n+am__objects_23 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \\\n \tin_unpack_i8.lo in_unpack_i16.lo in_unpack_r4.lo \\\n \tin_unpack_r8.lo in_unpack_r10.lo in_unpack_r16.lo \\\n \tin_unpack_c4.lo in_unpack_c8.lo in_unpack_c10.lo \\\n \tin_unpack_c16.lo\n-am__objects_23 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \\\n+am__objects_24 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \\\n \texponent_r16.lo\n-am__objects_24 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \\\n+am__objects_25 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \\\n \tfraction_r16.lo\n-am__objects_25 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \\\n+am__objects_26 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \\\n \tnearest_r16.lo\n-am__objects_26 = set_exponent_r4.lo set_exponent_r8.lo \\\n+am__objects_27 = set_exponent_r4.lo set_exponent_r8.lo \\\n \tset_exponent_r10.lo set_exponent_r16.lo\n-am__objects_27 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_c4_i4.lo \\\n+am__objects_28 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_c4_i4.lo \\\n \tpow_c8_i4.lo pow_c10_i4.lo pow_c16_i4.lo pow_i4_i8.lo \\\n \tpow_i8_i8.lo pow_i16_i8.lo pow_r4_i8.lo pow_r8_i8.lo \\\n \tpow_r10_i8.lo pow_r16_i8.lo pow_c4_i8.lo pow_c8_i8.lo \\\n \tpow_c10_i8.lo pow_c16_i8.lo pow_i4_i16.lo pow_i8_i16.lo \\\n \tpow_i16_i16.lo pow_r4_i16.lo pow_r8_i16.lo pow_r10_i16.lo \\\n \tpow_r16_i16.lo pow_c4_i16.lo pow_c8_i16.lo pow_c10_i16.lo \\\n \tpow_c16_i16.lo\n-am__objects_28 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \\\n+am__objects_29 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \\\n \trrspacing_r16.lo\n-am__objects_29 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \\\n+am__objects_30 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \\\n \tspacing_r16.lo\n-am__objects_30 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \\\n+am__objects_31 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \\\n \tpack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \\\n \tpack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo\n-am__objects_31 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n+am__objects_32 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n \tunpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \\\n \tunpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \\\n \tunpack_c16.lo\n-am__objects_32 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n+am__objects_33 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n \tspread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \\\n \tspread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \\\n \tspread_c16.lo\n-am__objects_33 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n+am__objects_34 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n \tcshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \\\n \tcshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \\\n \tcshift0_c10.lo cshift0_c16.lo\n-am__objects_34 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+am__objects_35 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_5) $(am__objects_6) $(am__objects_7) \\\n \t$(am__objects_8) $(am__objects_9) $(am__objects_10) \\\n \t$(am__objects_11) $(am__objects_12) $(am__objects_13) \\\n@@ -213,11 +214,11 @@ am__objects_34 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_23) $(am__objects_24) $(am__objects_25) \\\n \t$(am__objects_26) $(am__objects_27) $(am__objects_28) \\\n \t$(am__objects_29) $(am__objects_30) $(am__objects_31) \\\n-\t$(am__objects_32) $(am__objects_33)\n-am__objects_35 = close.lo file_pos.lo format.lo inquire.lo \\\n+\t$(am__objects_32) $(am__objects_33) $(am__objects_34)\n+am__objects_36 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo fbuf.lo\n-am__objects_36 = associated.lo abort.lo access.lo args.lo \\\n+am__objects_37 = associated.lo abort.lo access.lo args.lo \\\n \tbit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \\\n \tcpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \\\n \tenv.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \\\n@@ -232,8 +233,8 @@ am__objects_36 = associated.lo abort.lo access.lo args.lo \\\n \tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n \tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n-am__objects_37 =\n-am__objects_38 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_38 =\n+am__objects_39 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -257,18 +258,18 @@ am__objects_38 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_39 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_40 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_40 = misc_specifics.lo\n-am__objects_41 = $(am__objects_38) $(am__objects_39) $(am__objects_40) \\\n+am__objects_41 = misc_specifics.lo\n+am__objects_42 = $(am__objects_39) $(am__objects_40) $(am__objects_41) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_42 = $(am__objects_1) $(am__objects_34) $(am__objects_35) \\\n-\t$(am__objects_36) $(am__objects_37) $(am__objects_41)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_42)\n+am__objects_43 = $(am__objects_1) $(am__objects_35) $(am__objects_36) \\\n+\t$(am__objects_37) $(am__objects_38) $(am__objects_42)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_43)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -590,6 +591,12 @@ $(srcdir)/generated/any_l4.c \\\n $(srcdir)/generated/any_l8.c \\\n $(srcdir)/generated/any_l16.c\n \n+i_bessel_c = \\\n+$(srcdir)/generated/bessel_r4.c \\\n+$(srcdir)/generated/bessel_r8.c \\\n+$(srcdir)/generated/bessel_r10.c \\\n+$(srcdir)/generated/bessel_r16.c\n+\n i_count_c = \\\n $(srcdir)/generated/count_1_l.c \\\n $(srcdir)/generated/count_2_l.c \\\n@@ -997,11 +1004,11 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n-    m4/unpack.m4 m4/spread.m4\n+    m4/unpack.m4 m4/spread.m4 m4/bessel.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n-    $(i_product_c) $(i_sum_c) \\\n+    $(i_product_c) $(i_sum_c) $(i_bessel_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n@@ -1328,6 +1335,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/args.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/associated.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backtrace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bit_intrinsics.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bounds.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/c99_functions.Plo@am__quote@\n@@ -3456,6 +3467,34 @@ sum_c16.lo: $(srcdir)/generated/sum_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sum_c16.lo `test -f '$(srcdir)/generated/sum_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/sum_c16.c\n \n+bessel_r4.lo: $(srcdir)/generated/bessel_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT bessel_r4.lo -MD -MP -MF $(DEPDIR)/bessel_r4.Tpo -c -o bessel_r4.lo `test -f '$(srcdir)/generated/bessel_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/bessel_r4.Tpo $(DEPDIR)/bessel_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/bessel_r4.c' object='bessel_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel_r4.lo `test -f '$(srcdir)/generated/bessel_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r4.c\n+\n+bessel_r8.lo: $(srcdir)/generated/bessel_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT bessel_r8.lo -MD -MP -MF $(DEPDIR)/bessel_r8.Tpo -c -o bessel_r8.lo `test -f '$(srcdir)/generated/bessel_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/bessel_r8.Tpo $(DEPDIR)/bessel_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/bessel_r8.c' object='bessel_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel_r8.lo `test -f '$(srcdir)/generated/bessel_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r8.c\n+\n+bessel_r10.lo: $(srcdir)/generated/bessel_r10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT bessel_r10.lo -MD -MP -MF $(DEPDIR)/bessel_r10.Tpo -c -o bessel_r10.lo `test -f '$(srcdir)/generated/bessel_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/bessel_r10.Tpo $(DEPDIR)/bessel_r10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/bessel_r10.c' object='bessel_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel_r10.lo `test -f '$(srcdir)/generated/bessel_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r10.c\n+\n+bessel_r16.lo: $(srcdir)/generated/bessel_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT bessel_r16.lo -MD -MP -MF $(DEPDIR)/bessel_r16.Tpo -c -o bessel_r16.lo `test -f '$(srcdir)/generated/bessel_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/bessel_r16.Tpo $(DEPDIR)/bessel_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/bessel_r16.c' object='bessel_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel_r16.lo `test -f '$(srcdir)/generated/bessel_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r16.c\n+\n matmul_i1.lo: $(srcdir)/generated/matmul_i1.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT matmul_i1.lo -MD -MP -MF $(DEPDIR)/matmul_i1.Tpo -c -o matmul_i1.lo `test -f '$(srcdir)/generated/matmul_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/matmul_i1.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/matmul_i1.Tpo $(DEPDIR)/matmul_i1.Plo\n@@ -5525,6 +5564,9 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n @MAINTAINER_MODE_TRUE@$(i_all_c): m4/all.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 all.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_bessel_c): m4/bessel.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 bessel.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_any_c): m4/any.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 any.m4 > $@\n "}, {"sha": "579de8445b0d6c469b6bfe21ed91b69daa6099ee", "filename": "libgfortran/generated/bessel_r10.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r10.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,183 @@\n+/* Implementation of the BESSEL_JN and BESSEL_YN transformational\n+   function using a recurrence algorithm.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+\n+\n+#if defined (HAVE_JNL)\n+extern void bessel_jn_r10 (gfc_array_r10 * const restrict ret, int n1,\n+\t\t\t\t     int n2, GFC_REAL_10 x);\n+export_proto(bessel_jn_r10);\n+\n+void\n+bessel_jn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2, GFC_REAL_10 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_10 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_10) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0L))\n+    {\n+      ret->data[0] = 1.0L;\n+      for (i = 1; i <= n2-n1; i++)\n+        ret->data[i*stride] = 0.0L;\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = jnl (n2, x);\n+  ret->data[(n2-n1)*stride] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = jnl (n2 - 1, x);\n+  ret->data[(n2-n1-1)*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0L/x;\n+\n+  for (i = n2-n1-2; i >= 0; i--)\n+    {\n+      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      last1 = last2;\n+      last2 = ret->data[i*stride];\n+    }\n+}\n+\n+#endif\n+\n+#if defined (HAVE_YNL)\n+extern void bessel_yn_r10 (gfc_array_r10 * const restrict ret,\n+\t\t\t\t     int n1, int n2, GFC_REAL_10 x);\n+export_proto(bessel_yn_r10);\n+\n+void\n+bessel_yn_r10 (gfc_array_r10 * const restrict ret, int n1, int n2,\n+\t\t\t GFC_REAL_10 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_10 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_10) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0L))\n+    {\n+      for (i = 0; i <= n2-n1; i++)\n+#if defined(GFC_REAL_10_INFINITY)\n+        ret->data[i*stride] = -GFC_REAL_10_INFINITY;\n+#else\n+        ret->data[i*stride] = -GFC_REAL_10_HUGE;\n+#endif\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = ynl (n1, x);\n+  ret->data[0] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = ynl (n1 + 1, x);\n+  ret->data[1*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0L/x;\n+\n+  for (i = 2; i <= n1+n2; i++)\n+    {\n+#if defined(GFC_REAL_10_INFINITY)\n+      if (unlikely (last2 == -GFC_REAL_10_INFINITY))\n+\t{\n+\t  ret->data[i*stride] = -GFC_REAL_10_INFINITY;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  last1 = last2;\n+\t  last2 = ret->data[i*stride];\n+\t}\n+    }\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "a3ef181012e1c89a9027aa19957a1f35cffd343d", "filename": "libgfortran/generated/bessel_r16.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r16.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,183 @@\n+/* Implementation of the BESSEL_JN and BESSEL_YN transformational\n+   function using a recurrence algorithm.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+\n+\n+#if defined (HAVE_JNL)\n+extern void bessel_jn_r16 (gfc_array_r16 * const restrict ret, int n1,\n+\t\t\t\t     int n2, GFC_REAL_16 x);\n+export_proto(bessel_jn_r16);\n+\n+void\n+bessel_jn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2, GFC_REAL_16 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_16 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0L))\n+    {\n+      ret->data[0] = 1.0L;\n+      for (i = 1; i <= n2-n1; i++)\n+        ret->data[i*stride] = 0.0L;\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = jnl (n2, x);\n+  ret->data[(n2-n1)*stride] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = jnl (n2 - 1, x);\n+  ret->data[(n2-n1-1)*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0L/x;\n+\n+  for (i = n2-n1-2; i >= 0; i--)\n+    {\n+      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      last1 = last2;\n+      last2 = ret->data[i*stride];\n+    }\n+}\n+\n+#endif\n+\n+#if defined (HAVE_YNL)\n+extern void bessel_yn_r16 (gfc_array_r16 * const restrict ret,\n+\t\t\t\t     int n1, int n2, GFC_REAL_16 x);\n+export_proto(bessel_yn_r16);\n+\n+void\n+bessel_yn_r16 (gfc_array_r16 * const restrict ret, int n1, int n2,\n+\t\t\t GFC_REAL_16 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_16 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_16) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0L))\n+    {\n+      for (i = 0; i <= n2-n1; i++)\n+#if defined(GFC_REAL_16_INFINITY)\n+        ret->data[i*stride] = -GFC_REAL_16_INFINITY;\n+#else\n+        ret->data[i*stride] = -GFC_REAL_16_HUGE;\n+#endif\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = ynl (n1, x);\n+  ret->data[0] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = ynl (n1 + 1, x);\n+  ret->data[1*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0L/x;\n+\n+  for (i = 2; i <= n1+n2; i++)\n+    {\n+#if defined(GFC_REAL_16_INFINITY)\n+      if (unlikely (last2 == -GFC_REAL_16_INFINITY))\n+\t{\n+\t  ret->data[i*stride] = -GFC_REAL_16_INFINITY;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  last1 = last2;\n+\t  last2 = ret->data[i*stride];\n+\t}\n+    }\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "961c67cb5649a4643476a9bfc57c56389a092e5c", "filename": "libgfortran/generated/bessel_r4.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r4.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,183 @@\n+/* Implementation of the BESSEL_JN and BESSEL_YN transformational\n+   function using a recurrence algorithm.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+\n+\n+#if defined (HAVE_JNF)\n+extern void bessel_jn_r4 (gfc_array_r4 * const restrict ret, int n1,\n+\t\t\t\t     int n2, GFC_REAL_4 x);\n+export_proto(bessel_jn_r4);\n+\n+void\n+bessel_jn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2, GFC_REAL_4 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_4 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0F))\n+    {\n+      ret->data[0] = 1.0F;\n+      for (i = 1; i <= n2-n1; i++)\n+        ret->data[i*stride] = 0.0F;\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = jnf (n2, x);\n+  ret->data[(n2-n1)*stride] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = jnf (n2 - 1, x);\n+  ret->data[(n2-n1-1)*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0F/x;\n+\n+  for (i = n2-n1-2; i >= 0; i--)\n+    {\n+      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      last1 = last2;\n+      last2 = ret->data[i*stride];\n+    }\n+}\n+\n+#endif\n+\n+#if defined (HAVE_YNF)\n+extern void bessel_yn_r4 (gfc_array_r4 * const restrict ret,\n+\t\t\t\t     int n1, int n2, GFC_REAL_4 x);\n+export_proto(bessel_yn_r4);\n+\n+void\n+bessel_yn_r4 (gfc_array_r4 * const restrict ret, int n1, int n2,\n+\t\t\t GFC_REAL_4 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_4 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_4) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0F))\n+    {\n+      for (i = 0; i <= n2-n1; i++)\n+#if defined(GFC_REAL_4_INFINITY)\n+        ret->data[i*stride] = -GFC_REAL_4_INFINITY;\n+#else\n+        ret->data[i*stride] = -GFC_REAL_4_HUGE;\n+#endif\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = ynf (n1, x);\n+  ret->data[0] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = ynf (n1 + 1, x);\n+  ret->data[1*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0F/x;\n+\n+  for (i = 2; i <= n1+n2; i++)\n+    {\n+#if defined(GFC_REAL_4_INFINITY)\n+      if (unlikely (last2 == -GFC_REAL_4_INFINITY))\n+\t{\n+\t  ret->data[i*stride] = -GFC_REAL_4_INFINITY;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  last1 = last2;\n+\t  last2 = ret->data[i*stride];\n+\t}\n+    }\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "c896ae41a91d63d6d44afeeacbc29d050cbfc55b", "filename": "libgfortran/generated/bessel_r8.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgenerated%2Fbessel_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r8.c?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,183 @@\n+/* Implementation of the BESSEL_JN and BESSEL_YN transformational\n+   function using a recurrence algorithm.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+\n+\n+#if defined (HAVE_JN)\n+extern void bessel_jn_r8 (gfc_array_r8 * const restrict ret, int n1,\n+\t\t\t\t     int n2, GFC_REAL_8 x);\n+export_proto(bessel_jn_r8);\n+\n+void\n+bessel_jn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2, GFC_REAL_8 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_8 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0))\n+    {\n+      ret->data[0] = 1.0;\n+      for (i = 1; i <= n2-n1; i++)\n+        ret->data[i*stride] = 0.0;\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = jn (n2, x);\n+  ret->data[(n2-n1)*stride] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = jn (n2 - 1, x);\n+  ret->data[(n2-n1-1)*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0/x;\n+\n+  for (i = n2-n1-2; i >= 0; i--)\n+    {\n+      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      last1 = last2;\n+      last2 = ret->data[i*stride];\n+    }\n+}\n+\n+#endif\n+\n+#if defined (HAVE_YN)\n+extern void bessel_yn_r8 (gfc_array_r8 * const restrict ret,\n+\t\t\t\t     int n1, int n2, GFC_REAL_8 x);\n+export_proto(bessel_yn_r8);\n+\n+void\n+bessel_yn_r8 (gfc_array_r8 * const restrict ret, int n1, int n2,\n+\t\t\t GFC_REAL_8 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_8 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof (GFC_REAL_8) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0))\n+    {\n+      for (i = 0; i <= n2-n1; i++)\n+#if defined(GFC_REAL_8_INFINITY)\n+        ret->data[i*stride] = -GFC_REAL_8_INFINITY;\n+#else\n+        ret->data[i*stride] = -GFC_REAL_8_HUGE;\n+#endif\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = yn (n1, x);\n+  ret->data[0] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = yn (n1 + 1, x);\n+  ret->data[1*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0/x;\n+\n+  for (i = 2; i <= n1+n2; i++)\n+    {\n+#if defined(GFC_REAL_8_INFINITY)\n+      if (unlikely (last2 == -GFC_REAL_8_INFINITY))\n+\t{\n+\t  ret->data[i*stride] = -GFC_REAL_8_INFINITY;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  last1 = last2;\n+\t  last2 = ret->data[i*stride];\n+\t}\n+    }\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "8c0978d3eb39ad8fb83b4ba0310d106b34a8225a", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -1107,6 +1107,14 @@ GFORTRAN_1.4 {\n   global:\n     _gfortran_error_stop_numeric;\n     _gfortran_selected_real_kind2008;\n+    _gfortran_bessel_jn_r4;\n+    _gfortran_bessel_jn_r8;\n+    _gfortran_bessel_jn_r10;\n+    _gfortran_bessel_jn_r16;\n+    _gfortran_bessel_yn_r4;\n+    _gfortran_bessel_yn_r8;\n+    _gfortran_bessel_yn_r10;\n+    _gfortran_bessel_yn_r16;\n } GFORTRAN_1.3; \n \n F2C_1.0 {"}, {"sha": "a4790dd8bf50b27f632e817c9d46d8221e319328", "filename": "libgfortran/m4/bessel.m4", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fm4%2Fbessel.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b996944dcb50a831c1332b8ea667ff6f95fa95/libgfortran%2Fm4%2Fbessel.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fbessel.m4?ref=47b996944dcb50a831c1332b8ea667ff6f95fa95", "patch": "@@ -0,0 +1,185 @@\n+`/* Implementation of the BESSEL_JN and BESSEL_YN transformational\n+   function using a recurrence algorithm.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>'\n+\n+include(iparm.m4)dnl\n+include(`mtype.m4')dnl\n+\n+`#if defined (HAVE_'rtype_name`)\n+\n+\n+\n+#if defined (HAVE_JN'Q`)\n+extern void bessel_jn_r'rtype_kind` ('rtype` * const restrict ret, int n1,\n+\t\t\t\t     int n2, 'rtype_name` x);\n+export_proto(bessel_jn_r'rtype_kind`);\n+\n+void\n+bessel_jn_r'rtype_kind` ('rtype` * const restrict ret, int n1, int n2, 'rtype_name` x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  'rtype_name` last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof ('rtype_name`) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0'Q`))\n+    {\n+      ret->data[0] = 1.0'Q`;\n+      for (i = 1; i <= n2-n1; i++)\n+        ret->data[i*stride] = 0.0'Q`;\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = jn'q` (n2, x);\n+  ret->data[(n2-n1)*stride] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = jn'q` (n2 - 1, x);\n+  ret->data[(n2-n1-1)*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0'Q`/x;\n+\n+  for (i = n2-n1-2; i >= 0; i--)\n+    {\n+      ret->data[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      last1 = last2;\n+      last2 = ret->data[i*stride];\n+    }\n+}\n+\n+#endif\n+\n+#if defined (HAVE_YN'Q`)\n+extern void bessel_yn_r'rtype_kind` ('rtype` * const restrict ret,\n+\t\t\t\t     int n1, int n2, 'rtype_name` x);\n+export_proto(bessel_yn_r'rtype_kind`);\n+\n+void\n+bessel_yn_r'rtype_kind` ('rtype` * const restrict ret, int n1, int n2,\n+\t\t\t 'rtype_name` x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  'rtype_name` last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->data == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->data = internal_malloc_size (sizeof ('rtype_name`) * size);\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0.0'Q`))\n+    {\n+      for (i = 0; i <= n2-n1; i++)\n+#if defined('rtype_name`_INFINITY)\n+        ret->data[i*stride] = -'rtype_name`_INFINITY;\n+#else\n+        ret->data[i*stride] = -'rtype_name`_HUGE;\n+#endif\n+      return;\n+    }\n+\n+  ret->data = ret->data;\n+  last1 = yn'q` (n1, x);\n+  ret->data[0] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = yn'q` (n1 + 1, x);\n+  ret->data[1*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = 2.0'Q`/x;\n+\n+  for (i = 2; i <= n1+n2; i++)\n+    {\n+#if defined('rtype_name`_INFINITY)\n+      if (unlikely (last2 == -'rtype_name`_INFINITY))\n+\t{\n+\t  ret->data[i*stride] = -'rtype_name`_INFINITY;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  ret->data[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  last1 = last2;\n+\t  last2 = ret->data[i*stride];\n+\t}\n+    }\n+}\n+#endif\n+\n+#endif'\n+"}]}