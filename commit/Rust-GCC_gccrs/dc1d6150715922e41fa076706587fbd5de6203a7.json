{"sha": "dc1d6150715922e41fa076706587fbd5de6203a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxZDYxNTA3MTU5MjJlNDFmYTA3NjcwNjU4N2ZiZDVkZTYyMDNhNw==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1996-03-30T12:48:15Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1996-03-30T12:48:15Z"}, "message": "(expand_divmod, case TRUNC_DIV_EXPR): Move some code\nto avoid shifting by a too large count.\n\nFrom-SVN: r11645", "tree": {"sha": "7d852cd4f40b4ae39bde04c2d50dd0f28b290880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d852cd4f40b4ae39bde04c2d50dd0f28b290880"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc1d6150715922e41fa076706587fbd5de6203a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1d6150715922e41fa076706587fbd5de6203a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1d6150715922e41fa076706587fbd5de6203a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1d6150715922e41fa076706587fbd5de6203a7/comments", "author": null, "committer": null, "parents": [{"sha": "6f334f4405d90f7d34f6354ca59bcd3f2579aae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f334f4405d90f7d34f6354ca59bcd3f2579aae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f334f4405d90f7d34f6354ca59bcd3f2579aae9"}], "stats": {"total": 144, "additions": 74, "deletions": 70}, "files": [{"sha": "e49b93c89efb43fd1931596503d9ad37599a6b15", "filename": "gcc/expmed.c", "status": "modified", "additions": 74, "deletions": 70, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1d6150715922e41fa076706587fbd5de6203a7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1d6150715922e41fa076706587fbd5de6203a7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=dc1d6150715922e41fa076706587fbd5de6203a7", "patch": "@@ -2855,91 +2855,95 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    pre_shift = floor_log2 (d);\n \t\t    if (rem_flag)\n \t\t      {\n-\t\t\tremainder = expand_binop (compute_mode, and_optab, op0,\n-\t\t\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << pre_shift) - 1),\n-\t\t\t\t\t\t  remainder, 1,\n-\t\t\t\t\t\t  OPTAB_LIB_WIDEN);\n+\t\t\tremainder =\n+\t\t\t  expand_binop (compute_mode, and_optab, op0,\n+\t\t\t\t\tGEN_INT (((HOST_WIDE_INT) 1 << pre_shift) - 1),\n+\t\t\t\t\tremainder, 1,\n+\t\t\t\t\tOPTAB_LIB_WIDEN);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n \t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t     build_int_2 (pre_shift, 0),\n \t\t\t\t\t     tquotient, 1);\n \t\t  }\n-\t\telse if (d >= ((unsigned HOST_WIDE_INT) 1 << (size - 1)))\n-\t\t  {\n-\t\t    /* Most significant bit of divisor is set, emit a scc insn.\n-\t\t       emit_store_flag needs to be passed a place for the\n-\t\t       result.  */\n-\t\t    quotient = emit_store_flag (tquotient, GEU, op0, op1,\n-\t\t\t\t\t\tcompute_mode, 1, 1);\n-\t\t    if (quotient == 0)\n-\t\t      goto fail1;\n-\t\t  }\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT)\n \t\t  {\n-\t\t    /* Find a suitable multiplier and right shift count instead\n-\t\t       of multiplying with D.  */\n-\n-\t\t    mh = choose_multiplier (d, size, size,\n-\t\t\t\t\t    &ml, &post_shift, &dummy);\n-\n-\t\t    /* If the suggested multiplier is more than SIZE bits, we\n-\t\t       can do better for even divisors, using an initial right\n-\t\t       shift.  */\n-\t\t    if (mh != 0 && (d & 1) == 0)\n-\t\t      {\n-\t\t\tpre_shift = floor_log2 (d & -d);\n-\t\t\tmh = choose_multiplier (d >> pre_shift, size,\n-\t\t\t\t\t\tsize - pre_shift,\n-\t\t\t\t\t\t&ml, &post_shift, &dummy);\n-\t\t\tif (mh)\n-\t\t\t  abort ();\n-\t\t      }\n-\t\t    else\n-\t\t      pre_shift = 0;\n-\n-\t\t    if (mh != 0)\n+\t\t    if (d >= ((unsigned HOST_WIDE_INT) 1 << (size - 1)))\n \t\t      {\n-\t\t\trtx t1, t2, t3, t4;\n-\n-\t\t\textra_cost = (shift_cost[post_shift - 1]\n-\t\t\t\t      + shift_cost[1] + 2 * add_cost);\n-\t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n-\t\t\t\t\t\t   NULL_RTX, 1,\n-\t\t\t\t\t\t   max_cost - extra_cost);\n-\t\t\tif (t1 == 0)\n+\t\t\t/* Most significant bit of divisor is set; emit an scc\n+\t\t\t   insn.  */\n+\t\t\tquotient = emit_store_flag (tquotient, GEU, op0, op1,\n+\t\t\t\t\t\t    compute_mode, 1, 1);\n+\t\t\tif (quotient == 0)\n \t\t\t  goto fail1;\n-\t\t\tt2 = force_operand (gen_rtx (MINUS, compute_mode,\n-\t\t\t\t\t\t     op0, t1),\n-\t\t\t\t\t    NULL_RTX);\n-\t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t   build_int_2 (1, 0), NULL_RTX, 1);\n-\t\t\tt4 = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t\t     t1, t3),\n-\t\t\t\t\t    NULL_RTX);\n-\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t4,\n-\t\t\t\t\t\t build_int_2 (post_shift - 1,\n-\t\t\t\t\t\t\t      0),\n-\t\t\t\t\t\t tquotient, 1);\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\trtx t1, t2;\n+\t\t\t/* Find a suitable multiplier and right shift count\n+\t\t\t   instead of multiplying with D.  */\n \n-\t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t   build_int_2 (pre_shift, 0),\n-\t\t\t\t\t   NULL_RTX, 1);\n-\t\t\textra_cost = (shift_cost[pre_shift]\n-\t\t\t\t      + shift_cost[post_shift]);\n-\t\t\tt2 = expand_mult_highpart (compute_mode, t1, ml,\n-\t\t\t\t\t\t   NULL_RTX, 1,\n-\t\t\t\t\t\t   max_cost - extra_cost);\n-\t\t\tif (t2 == 0)\n-\t\t\t  goto fail1;\n-\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t\t build_int_2 (post_shift, 0),\n-\t\t\t\t\t\t tquotient, 1);\n+\t\t\tmh = choose_multiplier (d, size, size,\n+\t\t\t\t\t\t&ml, &post_shift, &dummy);\n+\n+\t\t\t/* If the suggested multiplier is more than SIZE bits,\n+\t\t\t   we can do better for even divisors, using an\n+\t\t\t   initial right shift.  */\n+\t\t\tif (mh != 0 && (d & 1) == 0)\n+\t\t\t  {\n+\t\t\t    pre_shift = floor_log2 (d & -d);\n+\t\t\t    mh = choose_multiplier (d >> pre_shift, size,\n+\t\t\t\t\t\t    size - pre_shift,\n+\t\t\t\t\t\t    &ml, &post_shift, &dummy);\n+\t\t\t    if (mh)\n+\t\t\t      abort ();\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  pre_shift = 0;\n+\n+\t\t\tif (mh != 0)\n+\t\t\t  {\n+\t\t\t    rtx t1, t2, t3, t4;\n+\n+\t\t\t    extra_cost = (shift_cost[post_shift - 1]\n+\t\t\t\t\t  + shift_cost[1] + 2 * add_cost);\n+\t\t\t    t1 = expand_mult_highpart (compute_mode, op0, ml,\n+\t\t\t\t\t\t       NULL_RTX, 1,\n+\t\t\t\t\t\t       max_cost - extra_cost);\n+\t\t\t    if (t1 == 0)\n+\t\t\t      goto fail1;\n+\t\t\t    t2 = force_operand (gen_rtx (MINUS, compute_mode,\n+\t\t\t\t\t\t\t op0, t1),\n+\t\t\t\t\t\tNULL_RTX);\n+\t\t\t    t3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t\t       build_int_2 (1, 0), NULL_RTX,1);\n+\t\t\t    t4 = force_operand (gen_rtx (PLUS, compute_mode,\n+\t\t\t\t\t\t\t t1, t3),\n+\t\t\t\t\t\tNULL_RTX);\n+\t\t\t    quotient =\n+\t\t\t      expand_shift (RSHIFT_EXPR, compute_mode, t4,\n+\t\t\t\t\t    build_int_2 (post_shift - 1, 0),\n+\t\t\t\t\t    tquotient, 1);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    rtx t1, t2;\n+\n+\t\t\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t       build_int_2 (pre_shift, 0),\n+\t\t\t\t\t       NULL_RTX, 1);\n+\t\t\t    extra_cost = (shift_cost[pre_shift]\n+\t\t\t\t\t  + shift_cost[post_shift]);\n+\t\t\t    t2 = expand_mult_highpart (compute_mode, t1, ml,\n+\t\t\t\t\t\t       NULL_RTX, 1,\n+\t\t\t\t\t\t       max_cost - extra_cost);\n+\t\t\t    if (t2 == 0)\n+\t\t\t      goto fail1;\n+\t\t\t    quotient =\n+\t\t\t      expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t\t    build_int_2 (post_shift, 0),\n+\t\t\t\t\t    tquotient, 1);\n+\t\t\t  }\n \t\t      }\n \t\t  }\n \t\telse\t\t/* Too wide mode to use tricky code */"}]}