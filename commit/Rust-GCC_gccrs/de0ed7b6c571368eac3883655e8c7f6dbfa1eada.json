{"sha": "de0ed7b6c571368eac3883655e8c7f6dbfa1eada", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUwZWQ3YjZjNTcxMzY4ZWFjMzg4MzY1NWU4YzdmNmRiZmExZWFkYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-02-01T05:48:00Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-02-01T05:48:00Z"}, "message": "verify.cc (state::enter_subroutine): New method.\n\n\t* verify.cc (state::enter_subroutine): New method.\n\t(handle_jsr_insn): Use it.\n\t(state::merge): When processing a `ret', correctly use\n\tsubroutine's state to determine which local variables have\n\tchanged.\n\t(push_exception_jump): Don't let stack overflow.\n\nFrom-SVN: r49388", "tree": {"sha": "3977f2b9fcce80a05b099d1825b384de53c309ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3977f2b9fcce80a05b099d1825b384de53c309ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de0ed7b6c571368eac3883655e8c7f6dbfa1eada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0ed7b6c571368eac3883655e8c7f6dbfa1eada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de0ed7b6c571368eac3883655e8c7f6dbfa1eada", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0ed7b6c571368eac3883655e8c7f6dbfa1eada/comments", "author": null, "committer": null, "parents": [{"sha": "6f48900c2b2a9d1ee6d394a67efef714adb07e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f48900c2b2a9d1ee6d394a67efef714adb07e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f48900c2b2a9d1ee6d394a67efef714adb07e09"}], "stats": {"total": 49, "additions": 39, "deletions": 10}, "files": [{"sha": "45cab3883c93dff2f3838c8af8bbfa63e23259b6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ed7b6c571368eac3883655e8c7f6dbfa1eada/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ed7b6c571368eac3883655e8c7f6dbfa1eada/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=de0ed7b6c571368eac3883655e8c7f6dbfa1eada", "patch": "@@ -1,3 +1,12 @@\n+2002-01-31  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (state::enter_subroutine): New method.\n+\t(handle_jsr_insn): Use it.\n+\t(state::merge): When processing a `ret', correctly use\n+\tsubroutine's state to determine which local variables have\n+\tchanged.\n+\t(push_exception_jump): Don't let stack overflow.\n+\n 2002-01-31  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gnu/gcj/convert/Convert.java: Only include one copyright year in"}, {"sha": "c9cfb885fdf84f595ad219bd15c30102aab840be", "filename": "libjava/verify.cc", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0ed7b6c571368eac3883655e8c7f6dbfa1eada/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0ed7b6c571368eac3883655e8c7f6dbfa1eada/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=de0ed7b6c571368eac3883655e8c7f6dbfa1eada", "patch": "@@ -891,6 +891,18 @@ class _Jv_BytecodeVerifier\n       // FIXME: subroutine handling?\n     }\n \n+    // Modify this state to reflect entry into a subroutine.\n+    void enter_subroutine (int npc, int max_locals)\n+    {\n+      subroutine = npc;\n+      // Mark all items as unchanged.  Each subroutine needs to keep\n+      // track of its `changed' state independently.  In the case of\n+      // nested subroutines, this information will be merged back into\n+      // parent by the `ret'.\n+      for (int i = 0; i < max_locals; ++i)\n+\tlocal_changed[i] = false;\n+    }\n+\n     // Merge STATE_OLD into this state.  Destructively modifies this\n     // state.  Returns true if the new state was in fact changed.\n     // Will throw an exception if the states are not mergeable.\n@@ -936,7 +948,12 @@ class _Jv_BytecodeVerifier\n       // Merge local variables.\n       for (int i = 0; i < max_locals; ++i)\n \t{\n-\t  if (! ret_semantics || local_changed[i])\n+\t  // If we're not processing a `ret', then we merge every\n+\t  // local variable.  If we are processing a `ret', then we\n+\t  // only merge locals which changed in the subroutine.  When\n+\t  // processing a `ret', STATE_OLD is the state at the point\n+\t  // of the `ret', and THIS is the state just after the `jsr'.\n+\t  if (! ret_semantics || state_old->local_changed[i])\n \t    {\n \t      if (locals[i].merge (state_old->locals[i], true, verifier))\n \t\t{\n@@ -1264,6 +1281,8 @@ class _Jv_BytecodeVerifier\n \t\t\t\t\t\t   this, true);\n     state s (current_state, current_method->max_stack,\n \t     current_method->max_locals);\n+    if (current_method->max_stack < 1)\n+      verify_fail (\"stack overflow at exception handler\");\n     s.set_exception (t, current_method->max_stack);\n     push_jump_merge (pc, &s);\n   }\n@@ -1401,18 +1420,19 @@ class _Jv_BytecodeVerifier\n       current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n     check_nonrecursive_call (current_state->subroutine, npc);\n \n-    // Temporarily modify the current state so that it looks like we are\n-    // in the subroutine.\n+    // Create a new state and modify it as appropriate for entry into\n+    // a subroutine.  We're writing this in a weird way because,\n+    // unfortunately, push_type only works on the current state.\n     push_type (return_address_type);\n-    int save = current_state->subroutine;\n-    current_state->subroutine = npc;\n-\n-    // Merge into the subroutine.\n     push_jump_merge (npc, current_state);\n-\n-    // Undo our modifications.\n-    current_state->subroutine = save;\n+    // Clean up the weirdness.\n     pop_type (return_address_type);\n+\n+    // On entry to the subroutine, the subroutine number must be set\n+    // and the locals must be marked as cleared.  We do this after\n+    // merging state so that we don't erroneously \"notice\" a variable\n+    // change merely on entry.\n+    states[npc]->enter_subroutine (npc, current_method->max_locals);\n   }\n \n   jclass construct_primitive_array_type (type_val prim)"}]}