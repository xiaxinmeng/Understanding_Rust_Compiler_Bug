{"sha": "3127848955bbdaa2fca1b4984b3d78b42d1a36e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEyNzg0ODk1NWJiZGFhMmZjYTFiNDk4NGIzZDc4YjQyZDFhMzZlMQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2010-10-30T13:17:15Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-10-30T13:17:15Z"}, "message": "Align long double parameters on stack to 4byte in 32bit.\n\n2010-10-30  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/46195\n\t* config/i386/i386.c (contains_aligned_value_p): Renamed to ...\n\t(ix86_compat_aligned_value_p): This.\n\t(ix86_old_function_arg_boundary): Renamed to ...\n\t(ix86_compat_function_arg_boundary): This.  Updated.\n\t(ix86_contains_aligned_value_p): New.\n\t(ix86_function_arg_boundary): Align long double parameters on\n\tstack to 4byte in 32bit.\n\nFrom-SVN: r166088", "tree": {"sha": "b0af389ca8d4064e80270e11f499ff0d1002bb4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0af389ca8d4064e80270e11f499ff0d1002bb4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3127848955bbdaa2fca1b4984b3d78b42d1a36e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3127848955bbdaa2fca1b4984b3d78b42d1a36e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3127848955bbdaa2fca1b4984b3d78b42d1a36e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3127848955bbdaa2fca1b4984b3d78b42d1a36e1/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46a88c12210a5677435efa706e424a4e37ab4646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a88c12210a5677435efa706e424a4e37ab4646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a88c12210a5677435efa706e424a4e37ab4646"}], "stats": {"total": 106, "additions": 94, "deletions": 12}, "files": [{"sha": "00bb74fa23326a79402d4209b08c6d2cf8c3a18a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3127848955bbdaa2fca1b4984b3d78b42d1a36e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3127848955bbdaa2fca1b4984b3d78b42d1a36e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3127848955bbdaa2fca1b4984b3d78b42d1a36e1", "patch": "@@ -1,3 +1,14 @@\n+2010-10-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/46195\n+\t* config/i386/i386.c (contains_aligned_value_p): Renamed to ...\n+\t(ix86_compat_aligned_value_p): This.\n+\t(ix86_old_function_arg_boundary): Renamed to ...\n+\t(ix86_compat_function_arg_boundary): This.  Updated.\n+\t(ix86_contains_aligned_value_p): New.\n+\t(ix86_function_arg_boundary): Align long double parameters on\n+\tstack to 4byte in 32bit.\n+\n 2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented Objective-C 2.0 @property, @synthesize and @dynamic."}, {"sha": "4cd3f070b913731997b524d1e005ea1fb39a223f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 83, "deletions": 12, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3127848955bbdaa2fca1b4984b3d78b42d1a36e1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3127848955bbdaa2fca1b4984b3d78b42d1a36e1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3127848955bbdaa2fca1b4984b3d78b42d1a36e1", "patch": "@@ -6952,10 +6952,12 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n-/* Return true when TYPE should be 128bit aligned for 32bit argument passing\n-   ABI.  */\n+/* Return true when TYPE should be 128bit aligned for 32bit argument\n+   passing ABI.  XXX: This function is obsolete and is only used for\n+   checking psABI compatibility with previous versions of GCC.  */\n+\n static bool\n-contains_aligned_value_p (const_tree type)\n+ix86_compat_aligned_value_p (const_tree type)\n {\n   enum machine_mode mode = TYPE_MODE (type);\n   if (((TARGET_SSE && SSE_REG_MODE_P (mode))\n@@ -6982,15 +6984,15 @@ contains_aligned_value_p (const_tree type)\n \t    for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t      {\n \t\tif (TREE_CODE (field) == FIELD_DECL\n-\t\t    && contains_aligned_value_p (TREE_TYPE (field)))\n+\t\t    && ix86_compat_aligned_value_p (TREE_TYPE (field)))\n \t\t  return true;\n \t      }\n \t    break;\n \t  }\n \n \tcase ARRAY_TYPE:\n \t  /* Just for use if some languages passes arrays by value.  */\n-\t  if (contains_aligned_value_p (TREE_TYPE (type)))\n+\t  if (ix86_compat_aligned_value_p (TREE_TYPE (type)))\n \t    return true;\n \t  break;\n \n@@ -7001,9 +7003,13 @@ contains_aligned_value_p (const_tree type)\n   return false;\n }\n \n+/* Return the alignment boundary for MODE and TYPE with alignment ALIGN.\n+   XXX: This function is obsolete and is only used for checking psABI\n+   compatibility with previous versions of GCC.  */\n+\n static int\n-ix86_old_function_arg_boundary (enum machine_mode mode, const_tree type,\n-\t\t\t\tint align)\n+ix86_compat_function_arg_boundary (enum machine_mode mode,\n+\t\t\t\t   const_tree type, int align)\n {\n   /* In 32bit, only _Decimal128 and __float128 are aligned to their\n      natural boundaries.  */\n@@ -7023,7 +7029,7 @@ ix86_old_function_arg_boundary (enum machine_mode mode, const_tree type,\n \t}\n       else\n \t{\n-\t  if (!contains_aligned_value_p (type))\n+\t  if (!ix86_compat_aligned_value_p (type))\n \t    align = PARM_BOUNDARY;\n \t}\n     }\n@@ -7032,6 +7038,59 @@ ix86_old_function_arg_boundary (enum machine_mode mode, const_tree type,\n   return align;\n }\n \n+/* Return true when TYPE should be 128bit aligned for 32bit argument\n+   passing ABI.  */\n+\n+static bool\n+ix86_contains_aligned_value_p (const_tree type)\n+{\n+  enum machine_mode mode = TYPE_MODE (type);\n+\n+  if (mode == XFmode || mode == XCmode)\n+    return false;\n+\n+  if (TYPE_ALIGN (type) < 128)\n+    return false;\n+\n+  if (AGGREGATE_TYPE_P (type))\n+    {\n+      /* Walk the aggregates recursively.  */\n+      switch (TREE_CODE (type))\n+\t{\n+\tcase RECORD_TYPE:\n+\tcase UNION_TYPE:\n+\tcase QUAL_UNION_TYPE:\n+\t  {\n+\t    tree field;\n+\n+\t    /* Walk all the structure fields.  */\n+\t    for (field = TYPE_FIELDS (type);\n+\t\t field;\n+\t\t field = DECL_CHAIN (field))\n+\t      {\n+\t\tif (TREE_CODE (field) == FIELD_DECL\n+\t\t    && ix86_contains_aligned_value_p (TREE_TYPE (field)))\n+\t\t  return true;\n+\t      }\n+\t    break;\n+\t  }\n+\n+\tcase ARRAY_TYPE:\n+\t  /* Just for use if some languages passes arrays by value.  */\n+\t  if (ix86_contains_aligned_value_p (TREE_TYPE (type)))\n+\t    return true;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    return TYPE_ALIGN (type) >= 128;\n+\n+  return false;\n+}\n+\n /* Gives the alignment boundary, in bits, of an argument with the\n    specified mode and type.  */\n \n@@ -7055,13 +7114,25 @@ ix86_function_arg_boundary (enum machine_mode mode, const_tree type)\n       static bool warned;\n       int saved_align = align;\n \n-      if (!TARGET_64BIT && align < 128)\n-\talign = PARM_BOUNDARY;\n+      if (!TARGET_64BIT)\n+\t{\n+\t  /* i386 ABI defines XFmode arguments to be 4 byte aligned.  */\n+\t  if (!type)\n+\t    {\n+\t      if (mode == XFmode || mode == XCmode)\n+\t\talign = PARM_BOUNDARY;\n+\t    }\n+\t  else if (!ix86_contains_aligned_value_p (type))\n+\t    align = PARM_BOUNDARY;\n+\n+\t  if (align < 128)\n+\t    align = PARM_BOUNDARY;\n+\t}\n \n       if (warn_psabi\n \t  && !warned\n-\t  && align != ix86_old_function_arg_boundary (mode, type,\n-\t\t\t\t\t\t      saved_align))\n+\t  && align != ix86_compat_function_arg_boundary (mode, type,\n+\t\t\t\t\t\t\t saved_align))\n \t{\n \t  warned = true;\n \t  inform (input_location,"}]}