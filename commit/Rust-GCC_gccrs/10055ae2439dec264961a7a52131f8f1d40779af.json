{"sha": "10055ae2439dec264961a7a52131f8f1d40779af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAwNTVhZTI0MzlkZWMyNjQ5NjFhN2E1MjEzMWY4ZjFkNDA3NzlhZg==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1993-01-09T02:03:56Z"}, "committer": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1993-01-09T02:03:56Z"}, "message": "Cygnus<-->FSF merge.\n\nFrom-SVN: r3162", "tree": {"sha": "f6c519452a4f92bed83219aaaa43ae611424297c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6c519452a4f92bed83219aaaa43ae611424297c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10055ae2439dec264961a7a52131f8f1d40779af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10055ae2439dec264961a7a52131f8f1d40779af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10055ae2439dec264961a7a52131f8f1d40779af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10055ae2439dec264961a7a52131f8f1d40779af/comments", "author": null, "committer": null, "parents": [{"sha": "76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76e616dbb8637ec8b69727b670ce22ab71bf6bd8"}], "stats": {"total": 328, "additions": 3, "deletions": 325}, "files": [{"sha": "b21817132193b1bca43f6481733dfd0b2daac22b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10055ae2439dec264961a7a52131f8f1d40779af/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10055ae2439dec264961a7a52131f8f1d40779af/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=10055ae2439dec264961a7a52131f8f1d40779af", "patch": "@@ -369,7 +369,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n  insn-peep.o reorg.o sched.o final.o recog.o reg-stack.o \\\n  insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n- insn-attrtab.o aux-output.o getpwd.o $(EXTRA_OBJS)\n+ insn-attrtab.o aux-output.o getpwd.o convert.o $(EXTRA_OBJS)\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load"}, {"sha": "55264732b9a00b6c996f419c7ab745d040d79166", "filename": "gcc/c-convert.c", "status": "modified", "additions": 2, "deletions": 324, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10055ae2439dec264961a7a52131f8f1d40779af/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10055ae2439dec264961a7a52131f8f1d40779af/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=10055ae2439dec264961a7a52131f8f1d40779af", "patch": "@@ -26,6 +26,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"config.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"convert.h\"\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -37,338 +38,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n    Here is a list of all the functions that assume that widening and\n    narrowing is always done with a NOP_EXPR:\n-     In c-convert.c, convert_to_integer.\n+     In convert.c, convert_to_integer.\n      In c-typeck.c, build_binary_op (boolean ops), and truthvalue_conversion.\n      In expr.c: expand_expr, for operands of a MULT_EXPR.\n      In fold-const.c: fold.\n      In tree.c: get_narrower and get_unwidened.  */\n \f\n /* Subroutines of `convert'.  */\n \n-static tree\n-convert_to_pointer (type, expr)\n-     tree type, expr;\n-{\n-  register tree intype = TREE_TYPE (expr);\n-  register enum tree_code form = TREE_CODE (intype);\n-  \n-  if (integer_zerop (expr))\n-    {\n-      if (type == TREE_TYPE (null_pointer_node))\n-\treturn null_pointer_node;\n-      expr = build_int_2 (0, 0);\n-      TREE_TYPE (expr) = type;\n-      return expr;\n-    }\n-\n-  if (form == POINTER_TYPE)\n-    return build1 (NOP_EXPR, type, expr);\n-\n-\n-  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n-    {\n-      if (type_precision (intype) == POINTER_SIZE)\n-\treturn build1 (CONVERT_EXPR, type, expr);\n-      expr = convert (type_for_size (POINTER_SIZE, 0), expr);\n-      if (TYPE_MODE (TREE_TYPE (expr)) != TYPE_MODE (type))\n-\t/* There is supposed to be some integral type\n-\t   that is the same width as a pointer.  */\n-\tabort ();\n-      return convert_to_pointer (type, expr);\n-    }\n-\n-  error (\"cannot convert to a pointer type\");\n-\n-  return null_pointer_node;\n-}\n-\n-static tree\n-convert_to_real (type, expr)\n-     tree type, expr;\n-{\n-  register enum tree_code form = TREE_CODE (TREE_TYPE (expr));\n-\n-  if (form == REAL_TYPE)\n-    return build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n-\t\t   type, expr);\n-\n-  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n-    return build1 (FLOAT_EXPR, type, expr);\n-\n-  if (form == POINTER_TYPE)\n-    error (\"pointer value used where a float was expected\");\n-  else\n-    error (\"aggregate value used where a float was expected\");\n-\n-  {\n-    register tree tem = make_node (REAL_CST);\n-    TREE_TYPE (tem) = type;\n-    TREE_REAL_CST (tem) = REAL_VALUE_ATOF (\"0.0\");\n-    return tem;\n-  }\n-}\n-\f\n-/* The result of this is always supposed to be a newly created tree node\n-   not in use in any existing structure.  */\n-\n-static tree\n-convert_to_integer (type, expr)\n-     tree type, expr;\n-{\n-  register tree intype = TREE_TYPE (expr);\n-  register enum tree_code form = TREE_CODE (intype);\n-\n-  if (form == POINTER_TYPE)\n-    {\n-      if (integer_zerop (expr))\n-\texpr = integer_zero_node;\n-      else\n-\texpr = fold (build1 (CONVERT_EXPR,\n-\t\t\t     type_for_size (POINTER_SIZE, 0), expr));\n-      intype = TREE_TYPE (expr);\n-      form = TREE_CODE (intype);\n-      if (intype == type)\n-\treturn expr;\n-    }\n \n-  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n-    {\n-      register unsigned outprec = TYPE_PRECISION (type);\n-      register unsigned inprec = TYPE_PRECISION (intype);\n-      register enum tree_code ex_form = TREE_CODE (expr);\n-\n-      /* If we are widening the type, put in an explicit conversion.\n-\t Similarly if we are not changing the width.  However, if this is\n-\t a logical operation that just returns 0 or 1, we can change the\n-\t type of the expression (see below).  */\n-\n-      if (TREE_CODE_CLASS (ex_form) == '<'\n-\t  || ex_form == TRUTH_AND_EXPR || ex_form == TRUTH_ANDIF_EXPR\n-\t  || ex_form == TRUTH_OR_EXPR || ex_form == TRUTH_ORIF_EXPR\n-\t  || ex_form == TRUTH_XOR_EXPR || ex_form == TRUTH_NOT_EXPR)\n-\t{\n-\t  TREE_TYPE (expr) = type;\n-\t  return expr;\n-\t}\n-      else if (outprec >= inprec)\n-\treturn build1 (NOP_EXPR, type, expr);\n-\n-/* Here detect when we can distribute the truncation down past some arithmetic.\n-   For example, if adding two longs and converting to an int,\n-   we can equally well convert both to ints and then add.\n-   For the operations handled here, such truncation distribution\n-   is always safe.\n-   It is desirable in these cases:\n-   1) when truncating down to full-word from a larger size\n-   2) when truncating takes no work.\n-   3) when at least one operand of the arithmetic has been extended\n-   (as by C's default conversions).  In this case we need two conversions\n-   if we do the arithmetic as already requested, so we might as well\n-   truncate both and then combine.  Perhaps that way we need only one.\n-\n-   Note that in general we cannot do the arithmetic in a type\n-   shorter than the desired result of conversion, even if the operands\n-   are both extended from a shorter type, because they might overflow\n-   if combined in that type.  The exceptions to this--the times when\n-   two narrow values can be combined in their narrow type even to\n-   make a wider result--are handled by \"shorten\" in build_binary_op.  */\n-\n-      switch (ex_form)\n-\t{\n-\tcase RSHIFT_EXPR:\n-\t  /* We can pass truncation down through right shifting\n-\t     when the shift count is a nonpositive constant.  */\n-\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n-\t      && tree_int_cst_lt (TREE_OPERAND (expr, 1), integer_one_node))\n-\t    goto trunc1;\n-\t  break;\n-\n-\tcase LSHIFT_EXPR:\n-\t  /* We can pass truncation down through left shifting\n-\t     when the shift count is a nonnegative constant.  */\n-\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n-\t      && ! tree_int_cst_lt (TREE_OPERAND (expr, 1), integer_zero_node)\n-\t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n-\t    {\n-\t      /* If shift count is less than the width of the truncated type,\n-\t\t really shift.  */\n-\t      if (tree_int_cst_lt (TREE_OPERAND (expr, 1), TYPE_SIZE (type)))\n-\t\t/* In this case, shifting is like multiplication.  */\n-\t\tgoto trunc1;\n-\t      else\n-\t\t/* If it is >= that width, result is zero.\n-\t\t   Handling this with trunc1 would give the wrong result:\n-\t\t   (int) ((long long) a << 32) is well defined (as 0)\n-\t\t   but (int) a << 32 is undefined and would get a warning.  */\n-\t\treturn convert_to_integer (type, integer_zero_node);\n-\t    }\n-\t  break;\n-\n-\tcase MAX_EXPR:\n-\tcase MIN_EXPR:\n-\tcase MULT_EXPR:\n-\t  {\n-\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n-\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n-\n-\t    /* Don't distribute unless the output precision is at least as big\n-\t       as the actual inputs.  Otherwise, the comparison of the\n-\t       truncated values will be wrong.  */\n-\t    if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t&& outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t/* If signedness of arg0 and arg1 don't match,\n-\t\t   we can't necessarily find a type to compare them in.  */\n-\t\t&& (TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t    == TREE_UNSIGNED (TREE_TYPE (arg1))))\n-\t      goto trunc1;\n-\t    break;\n-\t  }\n-\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\tcase BIT_AND_EXPR:\n-\tcase BIT_IOR_EXPR:\n-\tcase BIT_XOR_EXPR:\n-\tcase BIT_ANDTC_EXPR:\n-\ttrunc1:\n-\t  {\n-\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n-\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n-\n-\t    if (outprec >= BITS_PER_WORD\n-\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n-\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1)))\n-\t      {\n-\t\t/* Do the arithmetic in type TYPEX,\n-\t\t   then convert result to TYPE.  */\n-\t\tregister tree typex = type;\n-\n-\t\t/* Can't do arithmetic in enumeral types\n-\t\t   so use an integer type that will hold the values.  */\n-\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t\t  typex = type_for_size (TYPE_PRECISION (typex),\n-\t\t\t\t\t TREE_UNSIGNED (typex));\n-\n-\t\t/* But now perhaps TYPEX is as wide as INPREC.\n-\t\t   In that case, do nothing special here.\n-\t\t   (Otherwise would recurse infinitely in convert.  */\n-\t\tif (TYPE_PRECISION (typex) != inprec)\n-\t\t  {\n-\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n-\t\t       or vice versa.\n-\t\t       Exception: if either of the original operands were\n-\t\t       unsigned then can safely do the work as unsigned.\n-\t\t       And we may need to do it as unsigned\n-\t\t       if we truncate to the original size.  */\n-\t\t    typex = ((TREE_UNSIGNED (TREE_TYPE (expr))\n-\t\t\t      || TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t      || TREE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t\t     ? unsigned_type (typex) : signed_type (typex));\n-\t\t    return convert (type,\n-\t\t\t\t    build_binary_op (ex_form,\n-\t\t\t\t\t\t     convert (typex, arg0),\n-\t\t\t\t\t\t     convert (typex, arg1),\n-\t\t\t\t\t\t     0));\n-\t\t  }\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tcase NEGATE_EXPR:\n-\tcase BIT_NOT_EXPR:\n-\t  {\n-\t    register tree typex = type;\n-\n-\t    /* Can't do arithmetic in enumeral types\n-\t       so use an integer type that will hold the values.  */\n-\t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t      typex = type_for_size (TYPE_PRECISION (typex),\n-\t\t\t\t     TREE_UNSIGNED (typex));\n-\n-\t    /* But now perhaps TYPEX is as wide as INPREC.\n-\t       In that case, do nothing special here.\n-\t       (Otherwise would recurse infinitely in convert.  */\n-\t    if (TYPE_PRECISION (typex) != inprec)\n-\t      {\n-\t\t/* Don't do unsigned arithmetic where signed was wanted,\n-\t\t   or vice versa.  */\n-\t\ttypex = (TREE_UNSIGNED (TREE_TYPE (expr))\n-\t\t\t ? unsigned_type (typex) : signed_type (typex));\n-\t\treturn convert (type,\n-\t\t\t\tbuild_unary_op (ex_form,\n-\t\t\t\t\t\tconvert (typex, TREE_OPERAND (expr, 0)),\n-\t\t\t\t\t\t1));\n-\t      }\n-\t  }\n-\n-\tcase NOP_EXPR:\n-\t  /* If truncating after truncating, might as well do all at once.\n-\t     If truncating after extending, we may get rid of wasted work.  */\n-\t  return convert (type, get_unwidened (TREE_OPERAND (expr, 0), type));\n-\n-\tcase COND_EXPR:\n-\t  /* Can treat the two alternative values like the operands\n-\t     of an arithmetic expression.  */\n-\t  {\n-\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n-\t    tree arg2 = get_unwidened (TREE_OPERAND (expr, 2), type);\n-\n-\t    if (outprec >= BITS_PER_WORD\n-\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n-\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg2)))\n-\t      {\n-\t\t/* Do the arithmetic in type TYPEX,\n-\t\t   then convert result to TYPE.  */\n-\t\tregister tree typex = type;\n-\n-\t\t/* Can't do arithmetic in enumeral types\n-\t\t   so use an integer type that will hold the values.  */\n-\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t\t  typex = type_for_size (TYPE_PRECISION (typex),\n-\t\t\t\t\t TREE_UNSIGNED (typex));\n-\n-\t\t/* But now perhaps TYPEX is as wide as INPREC.\n-\t\t   In that case, do nothing special here.\n-\t\t   (Otherwise would recurse infinitely in convert.  */\n-\t\tif (TYPE_PRECISION (typex) != inprec)\n-\t\t  {\n-\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n-\t\t       or vice versa.  */\n-\t\t    typex = (TREE_UNSIGNED (TREE_TYPE (expr))\n-\t\t\t     ? unsigned_type (typex) : signed_type (typex));\n-\t\t    return convert (type,\n-\t\t\t\t    fold (build (COND_EXPR, typex,\n-\t\t\t\t\t\t TREE_OPERAND (expr, 0),\n-\t\t\t\t\t\t convert (typex, arg1),\n-\t\t\t\t\t\t convert (typex, arg2))));\n-\t\t  }\n-\t\telse\n-\t\t  /* It is sometimes worthwhile\n-\t\t     to push the narrowing down through the conditional.  */\n-\t\t  return fold (build (COND_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (expr, 0),\n-\t\t\t\t      convert (type, TREE_OPERAND (expr, 1)), \n-\t\t\t\t      convert (type, TREE_OPERAND (expr, 2))));\n-\t      }\n-\t  }\n-\t}\n-\n-      return build1 (NOP_EXPR, type, expr);\n-    }\n-\n-  if (form == REAL_TYPE)\n-    return build1 (FIX_TRUNC_EXPR, type, expr);\n-\n-  error (\"aggregate value used where an integer was expected\");\n-\n-  {\n-    register tree tem = build_int_2 (0, 0);\n-    TREE_TYPE (tem) = type;\n-    return tem;\n-  }\n-}\n \f\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value"}]}