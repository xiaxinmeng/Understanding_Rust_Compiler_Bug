{"sha": "93c590ee1aa41d3df7298d7dd1596994163f6d74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjNTkwZWUxYWE0MWQzZGY3Mjk4ZDdkZDE1OTY5OTQxNjNmNmQ3NA==", "commit": {"author": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2016-04-25T05:03:09Z"}, "committer": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2016-04-25T05:03:09Z"}, "message": "neon.md (widen_<us>sum<mode>): New patterns where mode is VQI to improve mixed mode vectorization.\n\n2016-04-25  Michael Collison  <michael.collison@linaro.org>\n\n    * config/arm/neon.md (widen_<us>sum<mode>): New patterns where\n    mode is VQI to improve mixed mode vectorization.\n    * config/arm/neon.md (vec_sel_widen_ssum_lo<VQI:mode><VW:mode>3): New\n    define_insn to match low half of signed vaddw.\n    * config/arm/neon.md (vec_sel_widen_ssum_hi<VQI:mode><VW:mode>3): New\n    define_insn to match high half of signed vaddw.\n    * config/arm/neon.md (vec_sel_widen_usum_lo<VQI:mode><VW:mode>3): New\n    define_insn to match low half of unsigned vaddw.\n    * config/arm/neon.md (vec_sel_widen_usum_hi<VQI:mode><VW:mode>3): New\n    define_insn to match high half of unsigned vaddw.\n    * config/arm/arm.c (arm_simd_vect_par_cnst_half): New function.\n    (arm_simd_check_vect_par_cnst_half_p): Likewise.\n    * config/arm/arm-protos.h (arm_simd_vect_par_cnst_half): Prototype\n    for new function.\n    (arm_simd_check_vect_par_cnst_half_p): Likewise.\n    * config/arm/predicates.md (vect_par_constant_high): Support\n    big endian and simplify by calling\n    arm_simd_check_vect_par_cnst_half\n    (vect_par_constant_low): Likewise.\n    * testsuite/gcc.target/arm/neon-vaddws16.c: New test.\n    * testsuite/gcc.target/arm/neon-vaddws32.c: New test.\n    * testsuite/gcc.target/arm/neon-vaddwu16.c: New test.\n    * testsuite/gcc.target/arm/neon-vaddwu32.c: New test.\n    * testsuite/gcc.target/arm/neon-vaddwu8.c: New test.\n    * testsuite/lib/target-supports.exp\n      (check_effective_target_vect_widen_sum_hi_to_si_pattern): Indicate\n      that arm neon support vector widen sum of HImode TO SImode.\n\nFrom-SVN: r235402", "tree": {"sha": "232a7b2f09a3eaab8167683bda4524742de85802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/232a7b2f09a3eaab8167683bda4524742de85802"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93c590ee1aa41d3df7298d7dd1596994163f6d74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c590ee1aa41d3df7298d7dd1596994163f6d74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93c590ee1aa41d3df7298d7dd1596994163f6d74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93c590ee1aa41d3df7298d7dd1596994163f6d74/comments", "author": null, "committer": null, "parents": [{"sha": "151a16073f59ef1445d9e66a0f65e1ced9060416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151a16073f59ef1445d9e66a0f65e1ced9060416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151a16073f59ef1445d9e66a0f65e1ced9060416"}], "stats": {"total": 380, "additions": 328, "deletions": 52}, "files": [{"sha": "4b7607a07a7d35e75d2cac1bedf0a6d71cc8392c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -1,3 +1,25 @@\n+2016-04-25  Michael Collison  <michael.collison@linaro.org>\n+\n+    * config/arm/neon.md (widen_<us>sum<mode>): New patterns where\n+    mode is VQI to improve mixed mode vectorization.\n+    * config/arm/neon.md (vec_sel_widen_ssum_lo<VQI:mode><VW:mode>3): New\n+    define_insn to match low half of signed vaddw.\n+    * config/arm/neon.md (vec_sel_widen_ssum_hi<VQI:mode><VW:mode>3): New\n+    define_insn to match high half of signed vaddw.\n+    * config/arm/neon.md (vec_sel_widen_usum_lo<VQI:mode><VW:mode>3): New\n+    define_insn to match low half of unsigned vaddw.\n+    * config/arm/neon.md (vec_sel_widen_usum_hi<VQI:mode><VW:mode>3): New\n+    define_insn to match high half of unsigned vaddw.\n+    * config/arm/arm.c (arm_simd_vect_par_cnst_half): New function.\n+    (arm_simd_check_vect_par_cnst_half_p): Likewise.\n+    * config/arm/arm-protos.h (arm_simd_vect_par_cnst_half): Prototype\n+    for new function.\n+    (arm_simd_check_vect_par_cnst_half_p): Likewise.\n+    * config/arm/predicates.md (vect_par_constant_high): Support\n+    big endian and simplify by calling\n+    arm_simd_check_vect_par_cnst_half\n+    (vect_par_constant_low): Likewise.\n+\t\n 2016-04-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*lea<mode>_general_4): Use const_0_to_3_operand"}, {"sha": "d8179c441bb53dced94d2ebf497aad093e4ac600", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -50,7 +50,9 @@ extern tree arm_builtin_decl (unsigned code, bool initialize_p\n \t\t\t      ATTRIBUTE_UNUSED);\n extern void arm_init_builtins (void);\n extern void arm_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update);\n-\n+extern rtx arm_simd_vect_par_cnst_half (machine_mode mode, bool high);\n+extern bool arm_simd_check_vect_par_cnst_half_p (rtx op, machine_mode mode,\n+\t\t\t\t\t\t bool high);\n #ifdef RTX_CODE\n extern bool arm_vector_mode_supported_p (machine_mode);\n extern bool arm_small_register_classes_for_mode_p (machine_mode);"}, {"sha": "71b51439dc7ba5be67671e9fb4c3f18040cce58f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -30302,4 +30302,80 @@ arm_sched_fusion_priority (rtx_insn *insn, int max_pri,\n   return;\n }\n \n+\n+/* Construct and return a PARALLEL RTX vector with elements numbering the\n+   lanes of either the high (HIGH == TRUE) or low (HIGH == FALSE) half of\n+   the vector - from the perspective of the architecture.  This does not\n+   line up with GCC's perspective on lane numbers, so we end up with\n+   different masks depending on our target endian-ness.  The diagram\n+   below may help.  We must draw the distinction when building masks\n+   which select one half of the vector.  An instruction selecting\n+   architectural low-lanes for a big-endian target, must be described using\n+   a mask selecting GCC high-lanes.\n+\n+                 Big-Endian             Little-Endian\n+\n+GCC             0   1   2   3           3   2   1   0\n+              | x | x | x | x |       | x | x | x | x |\n+Architecture    3   2   1   0           3   2   1   0\n+\n+Low Mask:         { 2, 3 }                { 0, 1 }\n+High Mask:        { 0, 1 }                { 2, 3 }\n+*/\n+\n+rtx\n+arm_simd_vect_par_cnst_half (machine_mode mode, bool high)\n+{\n+  int nunits = GET_MODE_NUNITS (mode);\n+  rtvec v = rtvec_alloc (nunits / 2);\n+  int high_base = nunits / 2;\n+  int low_base = 0;\n+  int base;\n+  rtx t1;\n+  int i;\n+\n+  if (BYTES_BIG_ENDIAN)\n+    base = high ? low_base : high_base;\n+  else\n+    base = high ? high_base : low_base;\n+\n+  for (i = 0; i < nunits / 2; i++)\n+    RTVEC_ELT (v, i) = GEN_INT (base + i);\n+\n+  t1 = gen_rtx_PARALLEL (mode, v);\n+  return t1;\n+}\n+\n+/* Check OP for validity as a PARALLEL RTX vector with elements\n+   numbering the lanes of either the high (HIGH == TRUE) or low lanes,\n+   from the perspective of the architecture.  See the diagram above\n+   arm_simd_vect_par_cnst_half_p for more details.  */\n+\n+bool\n+arm_simd_check_vect_par_cnst_half_p (rtx op, machine_mode mode,\n+\t\t\t\t       bool high)\n+{\n+  rtx ideal = arm_simd_vect_par_cnst_half (mode, high);\n+  HOST_WIDE_INT count_op = XVECLEN (op, 0);\n+  HOST_WIDE_INT count_ideal = XVECLEN (ideal, 0);\n+  int i = 0;\n+\n+  if (!VECTOR_MODE_P (mode))\n+    return false;\n+\n+  if (count_op != count_ideal)\n+    return false;\n+\n+  for (i = 0; i < count_ideal; i++)\n+    {\n+      rtx elt_op = XVECEXP (op, 0, i);\n+      rtx elt_ideal = XVECEXP (ideal, 0, i);\n+\n+      if (!CONST_INT_P (elt_op)\n+\t  || INTVAL (elt_ideal) != INTVAL (elt_op))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "6b4896de61fc76844ac00b05feb42fa857bba4ca", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 120, "deletions": 3, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -1204,16 +1204,133 @@\n \n ;; Widening operations\n \n+(define_expand \"widen_ssum<mode>3\"\n+  [(set (match_operand:<V_double_width> 0 \"s_register_operand\" \"\")\n+\t(plus:<V_double_width>\n+\t (sign_extend:<V_double_width>\n+\t  (match_operand:VQI 1 \"s_register_operand\" \"\"))\n+\t (match_operand:<V_double_width> 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\"\n+  {\n+    machine_mode mode = GET_MODE (operands[1]);\n+    rtx p1, p2;\n+\n+    p1  = arm_simd_vect_par_cnst_half (mode, false);\n+    p2  = arm_simd_vect_par_cnst_half (mode, true);\n+\n+    if (operands[0] != operands[2])\n+      emit_move_insn (operands[0], operands[2]);\n+\n+    emit_insn (gen_vec_sel_widen_ssum_lo<mode><V_half>3 (operands[0],\n+\t\t\t\t\t\t\t operands[1],\n+\t\t\t\t\t\t\t p1,\n+\t\t\t\t\t\t\t operands[0]));\n+    emit_insn (gen_vec_sel_widen_ssum_hi<mode><V_half>3 (operands[0],\n+\t\t\t\t\t\t\t operands[1],\n+\t\t\t\t\t\t\t p2,\n+\t\t\t\t\t\t\t operands[0]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"vec_sel_widen_ssum_lo<VQI:mode><VW:mode>3\"\n+  [(set (match_operand:<VW:V_widen> 0 \"s_register_operand\" \"=w\")\n+\t(plus:<VW:V_widen>\n+\t (sign_extend:<VW:V_widen>\n+\t  (vec_select:VW\n+\t   (match_operand:VQI 1 \"s_register_operand\" \"%w\")\n+\t   (match_operand:VQI 2 \"vect_par_constant_low\" \"\")))\n+\t (match_operand:<VW:V_widen> 3 \"s_register_operand\" \"0\")))]\n+  \"TARGET_NEON\"\n+{\n+  return BYTES_BIG_ENDIAN ?  \"vaddw.<V_s_elem>\\t%q0, %q3, %f1\" :\n+    \"vaddw.<V_s_elem>\\t%q0, %q3, %e1\";\n+}\n+  [(set_attr \"type\" \"neon_add_widen\")])\n+\n+(define_insn \"vec_sel_widen_ssum_hi<VQI:mode><VW:mode>3\"\n+  [(set (match_operand:<VW:V_widen> 0 \"s_register_operand\" \"=w\")\n+\t(plus:<VW:V_widen>\n+\t (sign_extend:<VW:V_widen>\n+\t  (vec_select:VW (match_operand:VQI 1 \"s_register_operand\" \"%w\")\n+\t\t\t (match_operand:VQI 2 \"vect_par_constant_high\" \"\")))\n+\t (match_operand:<VW:V_widen> 3 \"s_register_operand\" \"0\")))]\n+  \"TARGET_NEON\"\n+{\n+  return BYTES_BIG_ENDIAN ?  \"vaddw.<V_s_elem>\\t%q0, %q3, %e1\" :\n+    \"vaddw.<V_s_elem>\\t%q0, %q3, %f1\";\n+}\n+  [(set_attr \"type\" \"neon_add_widen\")])\n+\n (define_insn \"widen_ssum<mode>3\"\n   [(set (match_operand:<V_widen> 0 \"s_register_operand\" \"=w\")\n-\t(plus:<V_widen> (sign_extend:<V_widen>\n-\t\t\t  (match_operand:VW 1 \"s_register_operand\" \"%w\"))\n-\t\t        (match_operand:<V_widen> 2 \"s_register_operand\" \"w\")))]\n+\t(plus:<V_widen>\n+\t (sign_extend:<V_widen>\n+\t  (match_operand:VW 1 \"s_register_operand\" \"%w\"))\n+\t (match_operand:<V_widen> 2 \"s_register_operand\" \"w\")))]\n   \"TARGET_NEON\"\n   \"vaddw.<V_s_elem>\\t%q0, %q2, %P1\"\n   [(set_attr \"type\" \"neon_add_widen\")]\n )\n \n+(define_expand \"widen_usum<mode>3\"\n+  [(set (match_operand:<V_double_width> 0 \"s_register_operand\" \"\")\n+\t(plus:<V_double_width>\n+\t (zero_extend:<V_double_width>\n+\t  (match_operand:VQI 1 \"s_register_operand\" \"\"))\n+\t (match_operand:<V_double_width> 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_NEON\"\n+  {\n+    machine_mode mode = GET_MODE (operands[1]);\n+    rtx p1, p2;\n+\n+    p1  = arm_simd_vect_par_cnst_half (mode, false);\n+    p2  = arm_simd_vect_par_cnst_half (mode, true);\n+\n+    if (operands[0] != operands[2])\n+      emit_move_insn (operands[0], operands[2]);\n+\n+    emit_insn (gen_vec_sel_widen_usum_lo<mode><V_half>3 (operands[0],\n+\t\t\t\t\t\t\t operands[1],\n+\t\t\t\t\t\t\t p1,\n+\t\t\t\t\t\t\t operands[0]));\n+    emit_insn (gen_vec_sel_widen_usum_hi<mode><V_half>3 (operands[0],\n+\t\t\t\t\t\t\t operands[1],\n+\t\t\t\t\t\t\t p2,\n+\t\t\t\t\t\t\t operands[0]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"vec_sel_widen_usum_lo<VQI:mode><VW:mode>3\"\n+  [(set (match_operand:<VW:V_widen> 0 \"s_register_operand\" \"=w\")\n+\t(plus:<VW:V_widen>\n+\t (zero_extend:<VW:V_widen>\n+\t  (vec_select:VW\n+\t   (match_operand:VQI 1 \"s_register_operand\" \"%w\")\n+\t   (match_operand:VQI 2 \"vect_par_constant_low\" \"\")))\n+\t (match_operand:<VW:V_widen> 3 \"s_register_operand\" \"0\")))]\n+  \"TARGET_NEON\"\n+{\n+  return BYTES_BIG_ENDIAN ?  \"vaddw.<V_u_elem>\\t%q0, %q3, %f1\" :\n+    \"vaddw.<V_u_elem>\\t%q0, %q3, %e1\";\n+}\n+  [(set_attr \"type\" \"neon_add_widen\")])\n+\n+(define_insn \"vec_sel_widen_usum_hi<VQI:mode><VW:mode>3\"\n+  [(set (match_operand:<VW:V_widen> 0 \"s_register_operand\" \"=w\")\n+\t(plus:<VW:V_widen>\n+\t (zero_extend:<VW:V_widen>\n+\t  (vec_select:VW (match_operand:VQI 1 \"s_register_operand\" \"%w\")\n+\t\t\t (match_operand:VQI 2 \"vect_par_constant_high\" \"\")))\n+\t (match_operand:<VW:V_widen> 3 \"s_register_operand\" \"0\")))]\n+  \"TARGET_NEON\"\n+{\n+ return BYTES_BIG_ENDIAN ?  \"vaddw.<V_u_elem>\\t%q0, %q3, %e1\" :\n+    \"vaddw.<V_u_elem>\\t%q0, %q3, %f1\";\n+}\n+  [(set_attr \"type\" \"neon_add_widen\")])\n+\n (define_insn \"widen_usum<mode>3\"\n   [(set (match_operand:<V_widen> 0 \"s_register_operand\" \"=w\")\n \t(plus:<V_widen> (zero_extend:<V_widen>"}, {"sha": "ad92f6c5419b351b076af13cef234a9d002952e7", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -612,59 +612,13 @@\n (define_special_predicate \"vect_par_constant_high\" \n   (match_code \"parallel\")\n {\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int i;\n-  int base = GET_MODE_NUNITS (mode);\n-\n-  if ((count < 1)\n-      || (count != base/2))\n-    return false;\n-    \n-  if (!VECTOR_MODE_P (mode))\n-    return false;\n-\n-  for (i = 0; i < count; i++)\n-   {\n-     rtx elt = XVECEXP (op, 0, i);\n-     int val;\n-\n-     if (!CONST_INT_P (elt))\n-       return false;\n-\n-     val = INTVAL (elt);\n-     if (val != (base/2) + i)\n-       return false;\n-   }\n-  return true; \n+  return arm_simd_check_vect_par_cnst_half_p (op, mode, true);\n })\n \n (define_special_predicate \"vect_par_constant_low\"\n   (match_code \"parallel\")\n {\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int i;\n-  int base = GET_MODE_NUNITS (mode);\n-\n-  if ((count < 1)\n-      || (count != base/2))\n-    return false;\n-    \n-  if (!VECTOR_MODE_P (mode))\n-    return false;\n-\n-  for (i = 0; i < count; i++)\n-   {\n-     rtx elt = XVECEXP (op, 0, i);\n-     int val;\n-\n-     if (!CONST_INT_P (elt))\n-       return false;\n-\n-     val = INTVAL (elt);\n-     if (val != i)\n-       return false;\n-   } \n-  return true; \n+  return arm_simd_check_vect_par_cnst_half_p (op, mode, false);\n })\n \n (define_predicate \"const_double_vcvt_power_of_two_reciprocal\""}, {"sha": "d49f1895160e173bb3590aaa9144d3ed98ecee00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -1,3 +1,14 @@\n+2016-04-25  Michael Collison <michael.collison@arm.com>\n+\n+\t* testsuite/gcc.target/arm/neon-vaddws16.c: New test.\n+\t* testsuite/gcc.target/arm/neon-vaddws32.c: New test.\n+\t* testsuite/gcc.target/arm/neon-vaddwu16.c: New test.\n+\t* testsuite/gcc.target/arm/neon-vaddwu32.c: New test.\n+\t* testsuite/gcc.target/arm/neon-vaddwu8.c: New test.\n+\t* testsuite/lib/target-supports.exp\n+\t(check_effective_target_vect_widen_sum_hi_to_si_pattern): Indicate\n+\tthat arm neon support vector widen sum of HImode TO SImode.\n+\n 2016-04-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/70712"}, {"sha": "82811343e49526de235ece5899f6443b2558b2ea", "filename": "gcc/testsuite/gcc.target/arm/neon-vaddws16.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddws16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddws16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddws16.c?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-add-options arm_neon } */\n+\n+\n+\n+int\n+t6 (int len, void * dummy, short * __restrict x)\n+{\n+  len = len & ~31;\n+  int result = 0;\n+  __asm volatile (\"\");\n+  for (int i = 0; i < len; i++)\n+    result += x[i];\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.s16\" } } */"}, {"sha": "8c1869180121fa9ca16f9669721a8196ea2c4f18", "filename": "gcc/testsuite/gcc.target/arm/neon-vaddws32.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddws32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddws32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddws32.c?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-add-options arm_neon } */\n+\n+\n+int\n+t6 (int len, void * dummy, int * __restrict x)\n+{\n+  len = len & ~31;\n+  long long result = 0;\n+  __asm volatile (\"\");\n+  for (int i = 0; i < len; i++)\n+    result += x[i];\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.s32\" } } */"}, {"sha": "580bb06100630d5b8c28447c7c8859b7312aa90a", "filename": "gcc/testsuite/gcc.target/arm/neon-vaddwu16.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu16.c?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-add-options arm_neon } */\n+\n+\n+int\n+t6 (int len, void * dummy, unsigned short * __restrict x)\n+{\n+  len = len & ~31;\n+  unsigned int result = 0;\n+  __asm volatile (\"\");\n+  for (int i = 0; i < len; i++)\n+    result += x[i];\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw.u16\" } } */"}, {"sha": "21b063342dc82fadad57d0134ab78380da26b608", "filename": "gcc/testsuite/gcc.target/arm/neon-vaddwu32.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu32.c?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-add-options arm_neon } */\n+\n+\n+int\n+t6 (int len, void * dummy, unsigned int * __restrict x)\n+{\n+  len = len & ~31;\n+  unsigned long long result = 0;\n+  __asm volatile (\"\");\n+  for (int i = 0; i < len; i++)\n+    result += x[i];\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.u32\" } } */"}, {"sha": "d350ed537e65457790a31d69e4226bd51228fcc4", "filename": "gcc/testsuite/gcc.target/arm/neon-vaddwu8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vaddwu8.c?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-add-options arm_neon } */\n+\n+\n+\n+int\n+t6 (int len, void * dummy, char * __restrict x)\n+{\n+  len = len & ~31;\n+  unsigned short result = 0;\n+  __asm volatile (\"\");\n+  for (int i = 0; i < len; i++)\n+    result += x[i];\n+  return result;\n+}\n+\n+/* { dg-final { scan-assembler \"vaddw\\.u8\" } } */"}, {"sha": "422bbab16cb6fcdbe77ed6661d34a8ba17b5b41b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93c590ee1aa41d3df7298d7dd1596994163f6d74/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=93c590ee1aa41d3df7298d7dd1596994163f6d74", "patch": "@@ -4348,6 +4348,8 @@ proc check_effective_target_vect_widen_sum_hi_to_si_pattern { } {\n         set et_vect_widen_sum_hi_to_si_pattern_saved 0\n         if { [istarget powerpc*-*-*]\n              || [istarget aarch64*-*-*]\n+\t     || ([istarget arm*-*-*] &&\n+\t\t [check_effective_target_arm_neon_ok])\n              || [istarget ia64-*-*] } {\n             set et_vect_widen_sum_hi_to_si_pattern_saved 1\n         }"}]}