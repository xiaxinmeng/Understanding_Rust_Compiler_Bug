{"sha": "de5cd98e3ba2dd0303d2242c9431343aef530441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU1Y2Q5OGUzYmEyZGQwMzAzZDIyNDJjOTQzMTM0M2FlZjUzMDQ0MQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2008-05-20T12:49:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-20T12:49:41Z"}, "message": "2008-05-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_cat.adb\n\t(Set_Categorization_From_Scope): Do not set In_Remote_Types unless in\n\tthe visible part of the spec of a remote types unit.\n\t(Validate_Remote_Access_Object_Type_Declaration):\n\tNew local subprogram Is_Valid_Remote_Object_Type, replaces\n\tIs_Recursively_Limited_Private.\n\t(Validate_RACW_Primitives): Enforce E.2.2(14) rules: the types of all\n\tnon-controlling formals (and the return type, even though this is not\n\texplicit in the standard) must support external streaming.\n\t(Validate_RCI_Subprogram_Declaration): Enforce E.2.3(14) rules: same\n\tas above for of RAS types and RCI subprograms. (The return type is not\n\tchecked yet).\n\tUpdate comments related to RACWs designating limited interfaces per\n\tARG ruling on AI05-060.\n\n\t* sem_util.ads, sem_util.adb\n\t(Is_Remote_Access_To_Class_Wide_Type): Only rely on Is_Remote_Types and\n\tIs_Remote_Call_Interface to identify RACW types in a stable and\n\tconsistent way. We used to rely in this predicate on the privateness of\n\tthe designated type and its ancestors, but depending on the currently\n\tvisible private parts, this caused false negatives. We now uniformly\n\trely on checks made at the point where the RACW type is declared.\n\t(Inspect_Deferred_Constant_Completion): Moved from Sem_Ch7.\n\nFrom-SVN: r135637", "tree": {"sha": "6437292a76507ceb6e207f3c9d77a601170e7f8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6437292a76507ceb6e207f3c9d77a601170e7f8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de5cd98e3ba2dd0303d2242c9431343aef530441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5cd98e3ba2dd0303d2242c9431343aef530441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de5cd98e3ba2dd0303d2242c9431343aef530441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5cd98e3ba2dd0303d2242c9431343aef530441/comments", "author": null, "committer": null, "parents": [{"sha": "1543e3abae60c26bc45fceca7b8a7f2e517a8001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1543e3abae60c26bc45fceca7b8a7f2e517a8001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1543e3abae60c26bc45fceca7b8a7f2e517a8001"}], "stats": {"total": 316, "additions": 185, "deletions": 131}, "files": [{"sha": "cc96974425a51a48f63b1c23bba8fb6a6860ad21", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 135, "deletions": 72, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5cd98e3ba2dd0303d2242c9431343aef530441/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5cd98e3ba2dd0303d2242c9431343aef530441/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=de5cd98e3ba2dd0303d2242c9431343aef530441", "patch": "@@ -76,7 +76,7 @@ package body Sem_Cat is\n    --  at any place.\n \n    function In_RCI_Declaration (N : Node_Id) return Boolean;\n-   --  Determines if a declaration is  within the visible part of  a Remote\n+   --  Determines if a declaration is  within the visible part of a Remote\n    --  Call Interface compilation unit, for semantic checking purposes only,\n    --  (returns false within an instance and within the package body).\n \n@@ -98,15 +98,10 @@ package body Sem_Cat is\n \n    procedure Validate_Remote_Access_Object_Type_Declaration (T : Entity_Id);\n    --  Check validity of declaration if RCI or RT unit. It should not contain\n-   --  the declaration of an access-to-object type unless it is a\n-   --  general access type that designates a class-wide limited\n-   --  private type. There are also constraints about the primitive\n-   --  subprograms of the class-wide type. RM E.2 (9, 13, 14)\n-\n-   function Is_Recursively_Limited_Private (E : Entity_Id) return Boolean;\n-   --  Return True if E is a limited private type, or if E is a private\n-   --  extension of a type whose parent verifies this property (hence the\n-   --  recursive keyword).\n+   --  the declaration of an access-to-object type unless it is a general\n+   --  access type that designates a class-wide limited private type. There are\n+   --  also constraints about the primitive subprograms of the class-wide type.\n+   --  RM E.2 (9, 13, 14)\n \n    ---------------------------------------\n    -- Check_Categorization_Dependencies --\n@@ -446,6 +441,9 @@ package body Sem_Cat is\n                     (Specification (Unit_Declaration_Node (Unit_Entity)))\n         and then not In_Package_Body (Unit_Entity)\n         and then not In_Instance;\n+\n+      --  What about the case of a nested package in the visible part???\n+      --  This case is missed by the List_Containing check above???\n    end In_RCI_Declaration;\n \n    -----------------------\n@@ -531,47 +529,6 @@ package body Sem_Cat is\n         and then not Is_Remote_Access_To_Subprogram_Type (U_E);\n    end Is_Non_Remote_Access_Type;\n \n-   ------------------------------------\n-   -- Is_Recursively_Limited_Private --\n-   ------------------------------------\n-\n-   function Is_Recursively_Limited_Private (E : Entity_Id) return Boolean is\n-      P : constant Node_Id := Parent (E);\n-\n-   begin\n-      if Nkind (P) = N_Private_Type_Declaration\n-        and then Is_Limited_Record (E)\n-      then\n-         return True;\n-\n-      --  A limited interface is not currently a legal ancestor for the\n-      --  designated type of an RACW type, because a type that implements\n-      --  such an interface need not be limited. However, the ARG seems to\n-      --  incline towards allowing an access to classwide limited interface\n-      --  type as a remote access type. This may be revised when the ARG\n-      --  rules on this question, but it seems safe to allow it for now,\n-      --  in order to see whether it is a useful extension for distributed\n-      --  programming, in particular for Brad Moore's buffer taxonomy.\n-\n-      elsif Is_Limited_Record (E)\n-        and then Is_Limited_Interface (E)\n-      then\n-         return True;\n-\n-      elsif Nkind (P) = N_Private_Extension_Declaration then\n-         return Is_Recursively_Limited_Private (Etype (E));\n-\n-      elsif Nkind (P) = N_Formal_Type_Declaration\n-        and then Ekind (E) = E_Record_Type_With_Private\n-        and then Is_Generic_Type (E)\n-        and then Is_Limited_Record (E)\n-      then\n-         return True;\n-      else\n-         return False;\n-      end if;\n-   end Is_Recursively_Limited_Private;\n-\n    ----------------------------------\n    -- Missing_Read_Write_Attribute --\n    ----------------------------------\n@@ -755,7 +712,10 @@ package body Sem_Cat is\n          end if;\n       end if;\n \n-      Set_Is_Remote_Types (E, Is_Remote_Types (Scop));\n+      Set_Is_Remote_Types\n+        (E, Is_Remote_Types (Scop)\n+              and then not (In_Private_Part (Scop)\n+                              or else In_Package_Body (Scop)));\n    end Set_Categorization_From_Scope;\n \n    ------------------------------\n@@ -1399,6 +1359,18 @@ package body Sem_Cat is\n                     (\"limited return type must have Read and Write attributes\",\n                      Parent (Subprogram));\n                   Explain_Limited_Type (Rtyp, Parent (Subprogram));\n+\n+               --  Check that the return type supports external streaming.\n+               --  Note that the language of the standard (E.2.2(14)) does not\n+               --  explicitly mention that case, but it really does not make\n+               --  sense to return a value containing a local access type.\n+\n+               elsif Missing_Read_Write_Attributes (Rtyp)\n+                       and then not Error_Posted (Rtyp)\n+               then\n+                  Illegal_RACW (\"return type containing non-remote access \"\n+                    & \"must have Read and Write attributes\",\n+                    Parent (Subprogram));\n                end if;\n \n             end if;\n@@ -1422,8 +1394,9 @@ package body Sem_Cat is\n             elsif Ekind (Param_Type) = E_Anonymous_Access_Type\n               or else Ekind (Param_Type) = E_Anonymous_Access_Subprogram_Type\n             then\n-               --  From RM E.2.2(14), no access parameter other than\n-               --  controlling ones may be used.\n+               --  From RM E.2.2(14), no anonumous access parameter other than\n+               --  controlling ones may be used (because an anonymous access\n+               --  type never supports external streaming).\n \n                Illegal_RACW (\"non-controlling access parameter\", Param_Spec);\n \n@@ -1441,6 +1414,12 @@ package body Sem_Cat is\n                      Param_Spec);\n                   Explain_Limited_Type (Param_Type, Param_Spec);\n                end if;\n+\n+            elsif Missing_Read_Write_Attributes (Param_Type)\n+               and then not Error_Posted (Param_Type)\n+            then\n+               Illegal_RACW (\"parameter containing non-remote access \"\n+                 & \"must have Read and Write attributes\", Param_Spec);\n             end if;\n \n             --  Check next parameter in this subprogram\n@@ -1522,19 +1501,25 @@ package body Sem_Cat is\n       Error_Node      : Node_Id := N;\n \n    begin\n-      --  There are two possible cases in which this procedure is called:\n+      --  This procedure enforces rules on subprogram and access to subprogram\n+      --  declarations in RCI units. These rules do not apply to expander\n+      --  generated routines, which are not remote subprograms. It is called:\n \n-      --    1. called from Analyze_Subprogram_Declaration.\n-      --    2. called from Validate_Object_Declaration (access to subprogram).\n+      --    1. from Analyze_Subprogram_Declaration.\n+      --    2. from Validate_Object_Declaration (access to subprogram).\n \n-      if not In_RCI_Declaration (N) then\n+      if not (Comes_From_Source (N) and then In_RCI_Declaration (N)) then\n          return;\n       end if;\n \n       if K = N_Subprogram_Declaration then\n          Profile := Parameter_Specifications (Specification (N));\n \n       else pragma Assert (K = N_Object_Declaration);\n+         --  The above assertion is dubious, the visible declarations of an\n+         --  RCI unit never contain an object declaration, this should be an\n+         --  ACCESS-to-object declaration???\n+\n          Id := Defining_Identifier (N);\n \n          if Nkind (Id) = N_Defining_Identifier\n@@ -1550,7 +1535,7 @@ package body Sem_Cat is\n \n       --  Iterate through the parameter specification list, checking that\n       --  no access parameter and no limited type parameter in the list.\n-      --  RM E.2.3 (14)\n+      --  RM E.2.3(14).\n \n       if Present (Profile) then\n          Param_Spec := First (Profile);\n@@ -1570,7 +1555,7 @@ package body Sem_Cat is\n                  (Defining_Entity (Specification (N)))\n                then\n                   Error_Msg_N\n-                    (\"subprogram in rci unit cannot have access parameter\",\n+                    (\"subprogram in 'R'C'I unit cannot have access parameter\",\n                       Error_Node);\n                end if;\n \n@@ -1649,21 +1634,48 @@ package body Sem_Cat is\n \n                   if Ada_Version >= Ada_05 then\n                      Error_Msg_N\n-                       (\"limited parameter in rci unit \"\n+                       (\"limited parameter in 'R'C'I unit \"\n                           & \"must have visible read/write attributes \",\n                         Error_Node);\n                   else\n                      Error_Msg_N\n-                       (\"limited parameter in rci unit \"\n+                       (\"limited parameter in 'R'C'I unit \"\n                           & \"must have read/write attributes \",\n                         Error_Node);\n                   end if;\n                   Explain_Limited_Type (Param_Type, Error_Node);\n                end if;\n-            end if;\n \n+            --  In Ada 95, any non-remote access type (or any type with a\n+            --  component of a non-remote access type) that is visible in an\n+            --  RCI unit comes from a Remote_Types or Remote_Call_Interface\n+            --  unit, and thus is already guaranteed to support external\n+            --  streaming. However in Ada 2005 we have to account for the case\n+            --  of named access types from declared pure units as well, which\n+            --  may or may not support external streaming, and so we need to\n+            --  perform a specific check for E.2.3(14/2) here.\n+\n+            --  Note that if the declaration of the type itself is illegal, we\n+            --  do not perform this check since it might be a cascaded error.\n+\n+            else\n+               if K = N_Subprogram_Declaration then\n+                  Error_Node := Param_Spec;\n+               end if;\n+\n+               if Missing_Read_Write_Attributes (Param_Type)\n+                    and then not Error_Posted (Param_Type)\n+               then\n+                  Error_Msg_N\n+                    (\"parameter containing non-remote access in 'R'C'I \"\n+                     & \"subprogram must have visible \"\n+                     & \"Read and Write attributes\", Error_Node);\n+               end if;\n+            end if;\n             Next (Param_Spec);\n          end loop;\n+\n+         --  No check on return type???\n       end if;\n    end Validate_RCI_Subprogram_Declaration;\n \n@@ -1672,6 +1684,61 @@ package body Sem_Cat is\n    ----------------------------------------------------\n \n    procedure Validate_Remote_Access_Object_Type_Declaration (T : Entity_Id) is\n+\n+      function Is_Valid_Remote_Object_Type (E : Entity_Id) return Boolean;\n+      --  True if tagged type E is a valid candidate as the root type of the\n+      --  designated type for a RACW, i.e. a tagged limited private type, or a\n+      --  limited interface type, or a private extension of such a type.\n+\n+      ---------------------------------\n+      -- Is_Valid_Remote_Object_Type --\n+      ---------------------------------\n+\n+      function Is_Valid_Remote_Object_Type (E : Entity_Id) return Boolean is\n+         P : constant Node_Id := Parent (E);\n+\n+      begin\n+         pragma Assert (Is_Tagged_Type (E));\n+\n+         --  Simple case: a limited private type\n+\n+         if Nkind (P) = N_Private_Type_Declaration\n+           and then Is_Limited_Record (E)\n+         then\n+            return True;\n+\n+         --  A limited interface is not currently a legal ancestor for the\n+         --  designated type of an RACW type, because a type that implements\n+         --  such an interface need not be limited. However, the ARG seems to\n+         --  incline towards allowing an access to classwide limited interface\n+         --  type as a remote access type, as resolved in AI05-060. But note\n+         --  that the expansion circuitry for RACWs that designate classwide\n+         --  interfaces is not complete yet.\n+\n+         elsif Is_Limited_Record (E) and then Is_Limited_Interface (E) then\n+            return True;\n+\n+         --  A generic tagged limited type is a valid candidate. Limitedness\n+         --  will be checked again on the actual at instantiation point.\n+\n+         elsif Nkind (P) = N_Formal_Type_Declaration\n+           and then Ekind (E) = E_Record_Type_With_Private\n+           and then Is_Generic_Type (E)\n+           and then Is_Limited_Record (E)\n+         then\n+            return True;\n+\n+         --  A private extension declaration is a valid candidate if its parent\n+         --  type is.\n+\n+         elsif Nkind (P) = N_Private_Extension_Declaration then\n+            return Is_Valid_Remote_Object_Type (Etype (E));\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Valid_Remote_Object_Type;\n+\n       Direct_Designated_Type : Entity_Id;\n       Desig_Type             : Entity_Id;\n \n@@ -1718,20 +1785,16 @@ package body Sem_Cat is\n       Direct_Designated_Type := Designated_Type (T);\n       Desig_Type := Etype (Direct_Designated_Type);\n \n-      if not Is_Recursively_Limited_Private (Desig_Type) then\n+      --  Why is the check below not in\n+      --  Validate_Remote_Access_To_Class_Wide_Type???\n+\n+      if not Is_Valid_Remote_Object_Type (Desig_Type) then\n          Error_Msg_N\n            (\"error in designated type of remote access to class-wide type\", T);\n          Error_Msg_N\n            (\"\\must be tagged limited private or private extension\", T);\n          return;\n       end if;\n-\n-      --  Now this is an RCI unit access-to-class-wide-limited-private type\n-      --  declaration. Set the type entity to be Is_Remote_Call_Interface to\n-      --  optimize later checks by avoiding tree traversal to find out if this\n-      --  entity is inside an RCI unit.\n-\n-      Set_Is_Remote_Call_Interface (T);\n    end Validate_Remote_Access_Object_Type_Declaration;\n \n    -----------------------------------------------\n@@ -1749,7 +1812,7 @@ package body Sem_Cat is\n \n       --    Storage_Pool and Storage_Size are not defined for such types\n       --\n-      --    The expected type of allocator must not not be such a type.\n+      --    The expected type of allocator must not be such a type.\n \n       --    The actual parameter of generic instantiation must not be such a\n       --    type if the formal parameter is of an access type."}, {"sha": "95fd0c59c9e105686f22a4a77d34b8482c4d87ef", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5cd98e3ba2dd0303d2242c9431343aef530441/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5cd98e3ba2dd0303d2242c9431343aef530441/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=de5cd98e3ba2dd0303d2242c9431343aef530441", "patch": "@@ -1992,7 +1992,6 @@ package body Sem_Util is\n \n    function Current_Subprogram return Entity_Id is\n       Scop : constant Entity_Id := Current_Scope;\n-\n    begin\n       if Is_Subprogram (Scop) or else Is_Generic_Subprogram (Scop) then\n          return Scop;\n@@ -5510,6 +5509,41 @@ package body Sem_Util is\n       end if;\n    end Insert_Explicit_Dereference;\n \n+   ------------------------------------------\n+   -- Inspect_Deferred_Constant_Completion --\n+   ------------------------------------------\n+\n+   procedure Inspect_Deferred_Constant_Completion (Decls : List_Id) is\n+      Decl   : Node_Id;\n+\n+   begin\n+      Decl := First (Decls);\n+      while Present (Decl) loop\n+\n+         --  Deferred constant signature\n+\n+         if Nkind (Decl) = N_Object_Declaration\n+           and then Constant_Present (Decl)\n+           and then No (Expression (Decl))\n+\n+            --  No need to check internally generated constants\n+\n+           and then Comes_From_Source (Decl)\n+\n+            --  The constant is not completed. A full object declaration\n+            --  or a pragma Import complete a deferred constant.\n+\n+           and then not Has_Completion (Defining_Identifier (Decl))\n+         then\n+            Error_Msg_N\n+              (\"constant declaration requires initialization expression\",\n+              Defining_Identifier (Decl));\n+         end if;\n+\n+         Decl := Next (Decl);\n+      end loop;\n+   end Inspect_Deferred_Constant_Completion;\n+\n    -------------------\n    -- Is_AAMP_Float --\n    -------------------\n@@ -6740,60 +6774,13 @@ package body Sem_Util is\n    function Is_Remote_Access_To_Class_Wide_Type\n      (E : Entity_Id) return Boolean\n    is\n-      D : Entity_Id;\n-\n-      function Comes_From_Limited_Private_Type_Declaration\n-        (E : Entity_Id) return Boolean;\n-      --  Check that the type is declared by a limited type declaration,\n-      --  or else is derived from a Remote_Type ancestor through private\n-      --  extensions.\n-\n-      -------------------------------------------------\n-      -- Comes_From_Limited_Private_Type_Declaration --\n-      -------------------------------------------------\n-\n-      function Comes_From_Limited_Private_Type_Declaration\n-        (E : Entity_Id) return Boolean\n-      is\n-         N : constant Node_Id := Declaration_Node (E);\n-\n-      begin\n-         if Nkind (N) = N_Private_Type_Declaration\n-           and then Limited_Present (N)\n-         then\n-            return True;\n-         end if;\n-\n-         if Nkind (N) = N_Private_Extension_Declaration then\n-            return\n-              Comes_From_Limited_Private_Type_Declaration (Etype (E))\n-                or else\n-                 (Is_Remote_Types (Etype (E))\n-                    and then Is_Limited_Record (Etype (E))\n-                    and then Has_Private_Declaration (Etype (E)));\n-         end if;\n-\n-         return False;\n-      end Comes_From_Limited_Private_Type_Declaration;\n-\n-   --  Start of processing for Is_Remote_Access_To_Class_Wide_Type\n-\n    begin\n-      if not (Is_Remote_Call_Interface (E)\n-               or else Is_Remote_Types (E))\n-        or else Ekind (E) /= E_General_Access_Type\n-      then\n-         return False;\n-      end if;\n-\n-      D := Designated_Type (E);\n-\n-      if Ekind (D) /= E_Class_Wide_Type then\n-         return False;\n-      end if;\n+      --  A remote access to class-wide type is a general access to object type\n+      --  declared in the visible part of a Remote_Types or Remote_Call_\n+      --  Interface unit.\n \n-      return Comes_From_Limited_Private_Type_Declaration\n-               (Defining_Identifier (Parent (D)));\n+      return Ekind (E) = E_General_Access_Type\n+        and then (Is_Remote_Call_Interface (E) or else Is_Remote_Types (E));\n    end Is_Remote_Access_To_Class_Wide_Type;\n \n    -----------------------------------------\n@@ -6807,8 +6794,7 @@ package body Sem_Util is\n       return (Ekind (E) = E_Access_Subprogram_Type\n                 or else (Ekind (E) = E_Record_Type\n                            and then Present (Corresponding_Remote_Type (E))))\n-        and then (Is_Remote_Call_Interface (E)\n-                   or else Is_Remote_Types (E));\n+        and then (Is_Remote_Call_Interface (E) or else Is_Remote_Types (E));\n    end Is_Remote_Access_To_Subprogram_Type;\n \n    --------------------\n@@ -6863,8 +6849,8 @@ package body Sem_Util is\n       Subp_Decl : Node_Id := Parent (Parent (Proc_Nam));\n \n       function Is_Entry (Nam : Node_Id) return Boolean;\n-      --  Determine whether Nam is an entry. Traverse selectors\n-      --  if there are nested selected components.\n+      --  Determine whether Nam is an entry. Traverse selectors if there are\n+      --  nested selected components.\n \n       --------------\n       -- Is_Entry --"}, {"sha": "175b3156cd86395ce50942db316e4337b24bcbb3", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5cd98e3ba2dd0303d2242c9431343aef530441/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5cd98e3ba2dd0303d2242c9431343aef530441/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=de5cd98e3ba2dd0303d2242c9431343aef530441", "patch": "@@ -547,10 +547,10 @@ package Sem_Util is\n \n    function Has_Overriding_Initialize (T : Entity_Id) return Boolean;\n    --  Predicate to determine whether a controlled type has a user-defined\n-   --  initialize procedure, which makes the type not preelaborable.\n+   --  Initialize primitive, which makes the type not preelaborable.\n \n    function Has_Preelaborable_Initialization (E : Entity_Id) return Boolean;\n-   --  Return True iff type E has preelaborable initialisation as defined in\n+   --  Return True iff type E has preelaborable initialization as defined in\n    --  Ada 2005 (see AI-161 for details of the definition of this attribute).\n \n    function Has_Private_Component (Type_Id : Entity_Id) return Boolean;\n@@ -611,6 +611,11 @@ package Sem_Util is\n    --  N (which is the prefix, e.g. of an indexed component) as an\n    --  explicit dereference.\n \n+   procedure Inspect_Deferred_Constant_Completion (Decls : List_Id);\n+   --  Examine all deferred constants in the declaration list Decls and check\n+   --  whether they have been completed by a full constant declaration or an\n+   --  Import pragma. Emit the error message if that is not the case.\n+\n    function Is_AAMP_Float (E : Entity_Id) return Boolean;\n    --  Defined for all type entities. Returns True only for the base type\n    --  of float types with AAMP format. The particular format is determined"}]}