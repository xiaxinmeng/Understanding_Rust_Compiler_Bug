{"sha": "199b1891cb3855b293e0abf18a894645738e3132", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk5YjE4OTFjYjM4NTViMjkzZTBhYmYxOGE4OTQ2NDU3MzhlMzEzMg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-06-24T16:22:44Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-06-24T16:22:44Z"}, "message": "Dump profile-based number of iterations\n\n\t* analyze_brprob.py: Parse and display average number\n\tof loop iterations.\n\t* cfgloop.c (flow_loop_dump): Dump average number of loop iterations.\n\t* cfgloop.h: Change 'struct loop' to 'const struct loop' for a\n\tfew functions.\n\t* cfgloopanal.c (expected_loop_iterations_unbounded): Set a new\n\targument to true if the expected number of iterations is\n\tloop-based.\n\nFrom-SVN: r237762", "tree": {"sha": "58def27bed7c883fb39401708de460fccdea696c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58def27bed7c883fb39401708de460fccdea696c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/199b1891cb3855b293e0abf18a894645738e3132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/199b1891cb3855b293e0abf18a894645738e3132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/199b1891cb3855b293e0abf18a894645738e3132", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/199b1891cb3855b293e0abf18a894645738e3132/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04619cb86e06ee543dd4ab2b3b8e7fad772883bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04619cb86e06ee543dd4ab2b3b8e7fad772883bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04619cb86e06ee543dd4ab2b3b8e7fad772883bd"}], "stats": {"total": 77, "additions": 70, "deletions": 7}, "files": [{"sha": "d5f194af4d3c066148c6b7861626f23edfe1f1b1", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/199b1891cb3855b293e0abf18a894645738e3132/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/199b1891cb3855b293e0abf18a894645738e3132/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=199b1891cb3855b293e0abf18a894645738e3132", "patch": "@@ -1,3 +1,8 @@\n+2016-06-24  Martin Liska  <mliska@suse.cz>\n+\n+\t* analyze_brprob.py: Parse and display average number\n+\tof loop iterations.\n+\n 2016-06-23  Andi Kleen  <ak@linux.intel.com>\n \n \t* gen_autofdo_event.py: New file to regenerate"}, {"sha": "c276d810a4f6ddd2ed948b169dbdd21a0a1efe82", "filename": "contrib/analyze_brprob.py", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/199b1891cb3855b293e0abf18a894645738e3132/contrib%2Fanalyze_brprob.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/199b1891cb3855b293e0abf18a894645738e3132/contrib%2Fanalyze_brprob.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fanalyze_brprob.py?ref=199b1891cb3855b293e0abf18a894645738e3132", "patch": "@@ -67,9 +67,26 @@\n import re\n import argparse\n \n+from math import *\n+\n def percentage(a, b):\n     return 100.0 * a / b\n \n+def average(values):\n+    return 1.0 * sum(values) / len(values)\n+\n+def average_cutoff(values, cut):\n+    l = len(values)\n+    skip = floor(l * cut / 2)\n+    if skip > 0:\n+        values.sort()\n+        values = values[skip:-skip]\n+    return average(values)\n+\n+def median(values):\n+    values.sort()\n+    return values[int(len(values) / 2)]\n+\n class Summary:\n     def __init__(self, name):\n         self.name = name\n@@ -93,6 +110,7 @@ class Profile:\n     def __init__(self, filename):\n         self.filename = filename\n         self.heuristics = {}\n+        self.niter_vector = []\n \n     def add(self, name, prediction, count, hits):\n         if not name in self.heuristics:\n@@ -106,6 +124,10 @@ def add(self, name, prediction, count, hits):\n         s.hits += hits\n         s.fits += max(hits, count - hits)\n \n+    def add_loop_niter(self, niter):\n+        if niter > 0:\n+            self.niter_vector.append(niter)\n+\n     def branches_max(self):\n         return max([v.branches for k, v in self.heuristics.items()])\n \n@@ -127,6 +149,13 @@ def dump(self, sorting):\n              percentage(v.hits, v.count), percentage(v.fits, v.count),\n              v.count, v.count_formatted(), percentage(v.count, self.count_max()) ))\n \n+        print ('\\nLoop count: %d' % len(self.niter_vector)),\n+        print('  avg. # of iter: %.2f' % average(self.niter_vector))\n+        print('  median # of iter: %.2f' % median(self.niter_vector))\n+        for v in [1, 5, 10, 20, 30]:\n+            cut = 0.01 * v\n+            print('  avg. (%d%% cutoff) # of iter: %.2f' % (v, average_cutoff(self.niter_vector, cut)))\n+\n parser = argparse.ArgumentParser()\n parser.add_argument('dump_file', metavar = 'dump_file', help = 'IPA profile dump file')\n parser.add_argument('-s', '--sorting', dest = 'sorting', choices = ['branches', 'hitrate', 'coverage'], default = 'branches')\n@@ -135,6 +164,7 @@ def dump(self, sorting):\n \n profile = Profile(sys.argv[1])\n r = re.compile('  (.*) heuristics( of edge [0-9]*->[0-9]*)?( \\\\(.*\\\\))?: (.*)%.*exec ([0-9]*) hit ([0-9]*)')\n+loop_niter_str = ';;  profile-based iteration count: '\n for l in open(args.dump_file).readlines():\n     m = r.match(l)\n     if m != None and m.group(3) == None:\n@@ -144,5 +174,8 @@ def dump(self, sorting):\n         hits = int(m.group(6))\n \n         profile.add(name, prediction, count, hits)\n+    elif l.startswith(loop_niter_str):\n+        v = int(l[len(loop_niter_str):])\n+        profile.add_loop_niter(v)\n \n profile.dump(args.sorting)"}, {"sha": "80048f15a664f194fc8ae0a2e4da84eae382d332", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/199b1891cb3855b293e0abf18a894645738e3132/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/199b1891cb3855b293e0abf18a894645738e3132/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=199b1891cb3855b293e0abf18a894645738e3132", "patch": "@@ -1,3 +1,12 @@\n+2016-06-24  Martin Liska  <mliska@suse.cz>\n+\n+\t* cfgloop.c (flow_loop_dump): Dump average number of loop iterations.\n+\t* cfgloop.h: Change 'struct loop' to 'const struct loop' for a\n+\tfew functions.\n+\t* cfgloopanal.c (expected_loop_iterations_unbounded): Set a new\n+\targument to true if the expected number of iterations is\n+\tloop-based.\n+\n 2016-06-24  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* configure.ac (HAVE_AS_GOTOF_IN_DATA): Use $as_ix86_gas_32_opt to"}, {"sha": "e6174bd2191b3a8cc0dd4d65ad8f71188ceec370", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/199b1891cb3855b293e0abf18a894645738e3132/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/199b1891cb3855b293e0abf18a894645738e3132/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=199b1891cb3855b293e0abf18a894645738e3132", "patch": "@@ -136,6 +136,14 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n \t   loop_depth (loop), (long) (loop_outer (loop)\n \t\t\t\t      ? loop_outer (loop)->num : -1));\n \n+  if (loop->latch)\n+    {\n+      bool read_profile_p;\n+      gcov_type nit = expected_loop_iterations_unbounded (loop, &read_profile_p);\n+      if (read_profile_p && !loop->any_estimate)\n+\tfprintf (file, \";;  profile-based iteration count: %lu\\n\", nit);\n+    }\n+\n   fprintf (file, \";;  nodes:\");\n   bbs = get_loop_body (loop);\n   for (i = 0; i < loop->num_nodes; i++)\n@@ -1913,7 +1921,7 @@ get_estimated_loop_iterations (struct loop *loop, widest_int *nit)\n    false, otherwise returns true.  */\n \n bool\n-get_max_loop_iterations (struct loop *loop, widest_int *nit)\n+get_max_loop_iterations (const struct loop *loop, widest_int *nit)\n {\n   if (!loop->any_upper_bound)\n     return false;\n@@ -1927,7 +1935,7 @@ get_max_loop_iterations (struct loop *loop, widest_int *nit)\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-get_max_loop_iterations_int (struct loop *loop)\n+get_max_loop_iterations_int (const struct loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;"}, {"sha": "dfc7525dcad5ca6bcc06df1495dc748ac92473f4", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/199b1891cb3855b293e0abf18a894645738e3132/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/199b1891cb3855b293e0abf18a894645738e3132/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=199b1891cb3855b293e0abf18a894645738e3132", "patch": "@@ -319,7 +319,8 @@ extern void verify_loop_structure (void);\n \n /* Loop analysis.  */\n extern bool just_once_each_iteration_p (const struct loop *, const_basic_block);\n-gcov_type expected_loop_iterations_unbounded (struct loop *);\n+gcov_type expected_loop_iterations_unbounded (const struct loop *,\n+\t\t\t\t\t      bool *read_profile_p = NULL);\n extern unsigned expected_loop_iterations (struct loop *);\n extern rtx doloop_condition_get (rtx);\n \n@@ -778,10 +779,10 @@ loop_outermost (struct loop *loop)\n \n extern void record_niter_bound (struct loop *, const widest_int &, bool, bool);\n extern HOST_WIDE_INT get_estimated_loop_iterations_int (struct loop *);\n-extern HOST_WIDE_INT get_max_loop_iterations_int (struct loop *);\n+extern HOST_WIDE_INT get_max_loop_iterations_int (const struct loop *);\n extern HOST_WIDE_INT get_likely_max_loop_iterations_int (struct loop *);\n extern bool get_estimated_loop_iterations (struct loop *loop, widest_int *nit);\n-extern bool get_max_loop_iterations (struct loop *loop, widest_int *nit);\n+extern bool get_max_loop_iterations (const struct loop *loop, widest_int *nit);\n extern bool get_likely_max_loop_iterations (struct loop *loop, widest_int *nit);\n extern int bb_loop_depth (const_basic_block);\n "}, {"sha": "c16398692788b0407a45e91756bc515db40dd1b5", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/199b1891cb3855b293e0abf18a894645738e3132/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/199b1891cb3855b293e0abf18a894645738e3132/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=199b1891cb3855b293e0abf18a894645738e3132", "patch": "@@ -231,12 +231,15 @@ average_num_loop_insns (const struct loop *loop)\n    value.  */\n \n gcov_type\n-expected_loop_iterations_unbounded (struct loop *loop)\n+expected_loop_iterations_unbounded (const struct loop *loop,\n+\t\t\t\t    bool *read_profile_p)\n {\n   edge e;\n   edge_iterator ei;\n   gcov_type expected;\n   \n+  if (read_profile_p)\n+    *read_profile_p = false;\n \n   /* Average loop rolls about 3 times. If we have no profile at all, it is\n      best we can do.  */\n@@ -258,7 +261,11 @@ expected_loop_iterations_unbounded (struct loop *loop)\n       if (count_in == 0)\n \texpected = count_latch * 2;\n       else\n-\texpected = (count_latch + count_in - 1) / count_in;\n+\t{\n+\t  expected = (count_latch + count_in - 1) / count_in;\n+\t  if (read_profile_p)\n+\t    *read_profile_p = true;\n+\t}\n     }\n   else\n     {"}]}