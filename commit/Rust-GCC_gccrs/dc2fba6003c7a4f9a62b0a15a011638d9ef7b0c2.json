{"sha": "dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyZmJhNjAwM2M3YTRmOWE2MmIwYTE1YTAxMTYzOGQ5ZWY3YjBjMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T20:55:10Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T20:55:10Z"}, "message": "(dbxout_parms): For parameters passed in memory...\n\n(dbxout_parms): For parameters passed in memory, delete\nobsolete code to handle parameters converted and stored back to\nthe stack slot where they were passed in.\n(dbxout_reg_parms): Delete obsolete ifdefed out code.  Combine\nredundant PARM_PASSED_IN_MEMORY tests.  For case where parameter\nlives in memory, output stab if it doesn't live where it was passed.\n\nFrom-SVN: r9057", "tree": {"sha": "1d26c8a118b305750e3137e80d696f6a10e61342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d26c8a118b305750e3137e80d696f6a10e61342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2/comments", "author": null, "committer": null, "parents": [{"sha": "d0a71ec5ce482d65809497f26b84c8b42f542e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a71ec5ce482d65809497f26b84c8b42f542e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0a71ec5ce482d65809497f26b84c8b42f542e22"}], "stats": {"total": 94, "additions": 6, "deletions": 88}, "files": [{"sha": "8cdf96f44dececd067bf63b4894604647b723a2b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 6, "deletions": 88, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=dc2fba6003c7a4f9a62b0a15a011638d9ef7b0c2", "patch": "@@ -2126,36 +2126,7 @@ dbxout_parms (parms)\n \t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \n-\t    if (GET_CODE (DECL_RTL (parms)) == REG\n-\t\t&& REGNO (DECL_RTL (parms)) >= 0\n-\t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n-\t      dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n-\t    else\n-\t      {\n-\t\tint original_value = current_sym_value;\n-\n-\t\t/* This is the case where the parm is passed as an int or double\n-\t\t   and it is converted to a char, short or float and stored back\n-\t\t   in the parmlist.  In this case, describe the parm\n-\t\t   with the variable's declared type, and adjust the address\n-\t\t   if the least significant bytes (which we are using) are not\n-\t\t   the first ones.  */\n-\t\tif (BYTES_BIG_ENDIAN\n-\t\t    && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n-\t\t  current_sym_value += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n-\t\t\t\t\t- GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-\n-\t\tif (GET_CODE (DECL_RTL (parms)) == MEM\n-\t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n-\t\t    && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n-\t\t    && INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == current_sym_value)\n-\t\t  dbxout_type (TREE_TYPE (parms), 0, 0);\n-\t\telse\n-\t\t  {\n-\t\t    current_sym_value = original_value;\n-\t\t    dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n-\t\t  }\n-\t      }\n+\t    dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n \t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n \t    dbxout_finish_symbol (parms);\n \t  }\n@@ -2323,78 +2294,25 @@ dbxout_reg_parms (parms)\n      tree parms;\n {\n   for (; parms; parms = TREE_CHAIN (parms))\n-    if (DECL_NAME (parms))\n+    if (DECL_NAME (parms) && PARM_PASSED_IN_MEMORY (parms))\n       {\n \tdbxout_prepare_symbol (parms);\n \n \t/* Report parms that live in registers during the function\n \t   but were passed in memory.  */\n \tif (GET_CODE (DECL_RTL (parms)) == REG\n \t    && REGNO (DECL_RTL (parms)) >= 0\n-\t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER\n-\t    && PARM_PASSED_IN_MEMORY (parms))\n+\t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n \t  dbxout_symbol_location (parms, TREE_TYPE (parms),\n \t\t\t\t  0, DECL_RTL (parms));\n-\telse if (GET_CODE (DECL_RTL (parms)) == CONCAT\n-\t\t && PARM_PASSED_IN_MEMORY (parms))\n+\telse if (GET_CODE (DECL_RTL (parms)) == CONCAT)\n \t  dbxout_symbol_location (parms, TREE_TYPE (parms),\n \t\t\t\t  0, DECL_RTL (parms));\n \t/* Report parms that live in memory but not where they were passed.  */\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n-\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n-\t\t && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n-\t\t && PARM_PASSED_IN_MEMORY (parms)\n \t\t && ! rtx_equal_p (DECL_RTL (parms), DECL_INCOMING_RTL (parms)))\n-\t  {\n-#if 0 /* ??? It is not clear yet what should replace this.  */\n-\t    int offset = DECL_OFFSET (parms) / BITS_PER_UNIT;\n-\t    /* A parm declared char is really passed as an int,\n-\t       so it occupies the least significant bytes.\n-\t       On a big-endian machine those are not the low-numbered ones.  */\n-\t    if (BYTES_BIG_ENDIAN\n-\t\t&& offset != -1\n-\t\t&& TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n-\t      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n-\t\t\t - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n-\t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n-#endif\n-\t    dbxout_symbol_location (parms, TREE_TYPE (parms),\n-\t\t\t\t    0, DECL_RTL (parms));\n-\t  }\n-#if 0\n-\telse if (GET_CODE (DECL_RTL (parms)) == MEM\n-\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG)\n-\t  {\n-\t    /* Parm was passed via invisible reference.\n-\t       That is, its address was passed in a register.\n-\t       Output it as if it lived in that register.\n-\t       The debugger will know from the type\n-\t       that it was actually passed by invisible reference.  */\n-\n-\t    current_sym_code = N_RSYM;\n-\n-\t    /* DECL_RTL looks like (MEM (REG...).  Get the register number.  */\n-\t    current_sym_value = REGNO (XEXP (DECL_RTL (parms), 0));\n-\t    current_sym_addr = 0;\n-\n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\n-\t\tfprintf (asmfile, \"%s \\\"%s:r\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\t      }\n-\t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s \\\"(anon):r\", ASM_STABS_OP);\n-\t      }\n-\n-\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n-\t    dbxout_finish_symbol (parms);\n-\t  }\n-#endif\n+\t  dbxout_symbol_location (parms, TREE_TYPE (parms),\n+\t\t\t\t  0, DECL_RTL (parms));\n       }\n }\n \f"}]}