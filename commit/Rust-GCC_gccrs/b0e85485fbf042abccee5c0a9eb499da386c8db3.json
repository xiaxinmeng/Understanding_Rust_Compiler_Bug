{"sha": "b0e85485fbf042abccee5c0a9eb499da386c8db3", "node_id": "C_kwDOANBUbNoAKGIwZTg1NDg1ZmJmMDQyYWJjY2VlNWMwYTllYjQ5OWRhMzg2YzhkYjM", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-04-14T10:14:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2023-04-14T10:15:12Z"}, "message": "Fortran: Fix an excess finalization during allocation [PR104272]\n\n2023-04-14  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/104272\n\t* gfortran.h : Add expr3_not_explicit bit field to gfc_code.\n\t* resolve.cc (resolve_allocate_expr): Set bit field when the\n\tdefault initializer is applied to expr3.\n\t* trans-stmt.cc (gfc_trans_allocate): If expr3_not_explicit is\n\tset, do not deallocate expr3.\n\ngcc/testsuite/\n\tPR fortran/104272\n\t* gfortran.dg/class_result_8.f90 : Number of builtin_frees down\n\tfrom 6 to 5 without memory leaks.\n\t* gfortran.dg/finalize_52.f90: New test", "tree": {"sha": "2d26d1a45f52c274db699e9e80f993b37520b27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d26d1a45f52c274db699e9e80f993b37520b27c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0e85485fbf042abccee5c0a9eb499da386c8db3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e85485fbf042abccee5c0a9eb499da386c8db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0e85485fbf042abccee5c0a9eb499da386c8db3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0e85485fbf042abccee5c0a9eb499da386c8db3/comments", "author": null, "committer": null, "parents": [{"sha": "bf24f2db2841b97bc5e86bf9294d61eef32f83b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf24f2db2841b97bc5e86bf9294d61eef32f83b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf24f2db2841b97bc5e86bf9294d61eef32f83b3"}], "stats": {"total": 71, "additions": 68, "deletions": 3}, "files": [{"sha": "db77d24e8b5bf7b01f96ddec21c557a2530d4c94", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b0e85485fbf042abccee5c0a9eb499da386c8db3", "patch": "@@ -3005,6 +3005,8 @@ typedef struct gfc_code\n       /* Take the array specification from expr3 to allocate arrays\n \t without an explicit array specification.  */\n       unsigned arr_spec_from_expr3:1;\n+      /* expr3 is not explicit  */\n+      unsigned expr3_not_explicit:1;\n     }\n     alloc;\n "}, {"sha": "55d8e326a87fab0dc0c7decfcc8bdf32640f0070", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=b0e85485fbf042abccee5c0a9eb499da386c8db3", "patch": "@@ -8089,6 +8089,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n   if (!t)\n     goto failure;\n \n+  code->ext.alloc.expr3_not_explicit = 0;\n   if (e->ts.type == BT_CLASS && CLASS_DATA (e)->attr.dimension\n \t&& !code->expr3 && code->ext.alloc.ts.type == BT_DERIVED)\n     {\n@@ -8097,13 +8098,15 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n \t when the allocated type is different from the declared type but\n \t no SOURCE exists by setting expr3.  */\n       code->expr3 = gfc_default_initializer (&code->ext.alloc.ts);\n+      code->ext.alloc.expr3_not_explicit = 1;\n     }\n   else if (flag_coarray != GFC_FCOARRAY_LIB && e->ts.type == BT_DERIVED\n \t   && e->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n \t   && e->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n     {\n       /* We have to zero initialize the integer variable.  */\n       code->expr3 = gfc_get_int_expr (gfc_default_integer_kind, &e->where, 0);\n+      code->ext.alloc.expr3_not_explicit = 1;\n     }\n \n   if (e->ts.type == BT_CLASS && !unlimited && !UNLIMITED_POLY (code->expr3))"}, {"sha": "776f98d08d92c961f6cc4917405a6797e3d638c8", "filename": "gcc/fortran/trans-stmt.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ffortran%2Ftrans-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ffortran%2Ftrans-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.cc?ref=b0e85485fbf042abccee5c0a9eb499da386c8db3", "patch": "@@ -6458,12 +6458,15 @@ gfc_trans_allocate (gfc_code * code)\n       /* Deallocate any allocatable components in expressions that use a\n \t temporary object, i.e. are not a simple alias of to an EXPR_VARIABLE.\n \t E.g. temporaries of a function call need freeing of their components\n-\t here.  */\n+\t here. Explicit derived type allocation of class entities uses expr3\n+\t to carry the default initializer. This must not be deallocated or\n+\t finalized.  */\n       if ((code->expr3->ts.type == BT_DERIVED\n \t   || code->expr3->ts.type == BT_CLASS)\n \t  && (code->expr3->expr_type != EXPR_VARIABLE || temp_obj_created)\n \t  && code->expr3->ts.u.derived->attr.alloc_comp\n-\t  && !code->expr3->must_finalize)\n+\t  && !code->expr3->must_finalize\n+\t  && !code->ext.alloc.expr3_not_explicit)\n \t{\n \t  tmp = gfc_deallocate_alloc_comp (code->expr3->ts.u.derived,\n \t\t\t\t\t   expr3, code->expr3->rank);"}, {"sha": "9a1fb2ba50f61d770376d65705cbf1c47831c47e", "filename": "gcc/testsuite/gfortran.dg/class_result_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_result_8.f90?ref=b0e85485fbf042abccee5c0a9eb499da386c8db3", "patch": "@@ -37,5 +37,5 @@ program polymorphic_operators_memory_leaks\n    call assign_a_type (a, add_a_type(a,b))\n    print *, a%x\n end\n-! { dg-final { scan-tree-dump-times \"builtin_free\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"builtin_free\" 5 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"builtin_malloc\" 7 \"original\" } }"}, {"sha": "be2ca1715f9724211d45dbc152a3544dceb08285", "filename": "gcc/testsuite/gfortran.dg/finalize_52.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_52.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0e85485fbf042abccee5c0a9eb499da386c8db3/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_52.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_52.f90?ref=b0e85485fbf042abccee5c0a9eb499da386c8db3", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR104272 in which allocate caused an unwanted finalization\n+!\n+! Contributed by Kai Germaschewski  <kai.germaschewski@gmail.com>\n+!\n+module solver_m\n+    implicit none\n+\n+    type, abstract, public :: solver_base_t\n+    end type solver_base_t\n+\n+    type, public, extends(solver_base_t) :: solver_gpu_t\n+       complex, dimension(:), allocatable :: x\n+    contains\n+       final :: solver_gpu_final\n+    end type solver_gpu_t\n+\n+    type, public, extends(solver_gpu_t) :: solver_sparse_gpu_t\n+    contains\n+       final :: solver_sparse_gpu_final\n+    end type solver_sparse_gpu_t\n+\n+    integer :: final_counts = 0\n+\n+ contains\n+\n+    impure elemental subroutine solver_gpu_final(this)\n+       type(solver_gpu_t), intent(INOUT) :: this\n+       final_counts = final_counts + 1\n+    end subroutine solver_gpu_final\n+\n+    impure elemental subroutine solver_sparse_gpu_final(this)\n+       type(solver_sparse_gpu_t), intent(INOUT) :: this\n+       final_counts = final_counts + 10\n+    end subroutine solver_sparse_gpu_final\n+\n+ end module solver_m\n+\n+ subroutine test\n+    use solver_m\n+    implicit none\n+\n+    class(solver_base_t), dimension(:), allocatable :: solver\n+\n+    allocate(solver_sparse_gpu_t :: solver(2))\n+\n+    if (final_counts .ne. 0) stop 1\n+ end subroutine\n+\n+program main\n+    use solver_m\n+    implicit none\n+\n+    call test\n+    if (final_counts .ne. 22) stop 2 ! Scalar finalizers for rank 1/size 2\n+end program"}]}