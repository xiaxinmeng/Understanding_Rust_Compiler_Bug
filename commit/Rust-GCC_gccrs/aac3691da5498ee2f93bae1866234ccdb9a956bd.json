{"sha": "aac3691da5498ee2f93bae1866234ccdb9a956bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjMzY5MWRhNTQ5OGVlMmY5M2JhZTE4NjYyMzRjY2RiOWE5NTZiZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-31T01:13:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-31T01:13:32Z"}, "message": "typeck2.c (initializer_constant_valid_p): Moved to c-common.c.\n\n        * typeck2.c (initializer_constant_valid_p): Moved to c-common.c.\n        * cp-tree.h (initializer_constant_valid_p): Remove.\n\nFrom-SVN: r28350", "tree": {"sha": "695d952bea26b79b648b698c87f8316e43f026c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/695d952bea26b79b648b698c87f8316e43f026c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aac3691da5498ee2f93bae1866234ccdb9a956bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac3691da5498ee2f93bae1866234ccdb9a956bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac3691da5498ee2f93bae1866234ccdb9a956bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac3691da5498ee2f93bae1866234ccdb9a956bd/comments", "author": null, "committer": null, "parents": [{"sha": "7e8176d77891d6bfb95844e3918690ccbfcc7b71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8176d77891d6bfb95844e3918690ccbfcc7b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8176d77891d6bfb95844e3918690ccbfcc7b71"}], "stats": {"total": 146, "additions": 5, "deletions": 141}, "files": [{"sha": "97f0c93466e1aff95ffc284fca5a183d29a4573d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac3691da5498ee2f93bae1866234ccdb9a956bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac3691da5498ee2f93bae1866234ccdb9a956bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aac3691da5498ee2f93bae1866234ccdb9a956bd", "patch": "@@ -1,3 +1,8 @@\n+1999-07-30  Richard Henderson  <rth@cygnus.com>\n+\n+\t* typeck2.c (initializer_constant_valid_p): Moved to c-common.c.\n+\t* cp-tree.h (initializer_constant_valid_p): Remove.\n+\n 1999-07-28  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (conditional_conversion): Don't build BASE_CONVs for"}, {"sha": "2a17d4846272198bbc86fe410579a4b18d2aaf5c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac3691da5498ee2f93bae1866234ccdb9a956bd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac3691da5498ee2f93bae1866234ccdb9a956bd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aac3691da5498ee2f93bae1866234ccdb9a956bd", "patch": "@@ -3586,7 +3586,6 @@ extern tree build_functional_cast\t\tPROTO((tree, tree));\n extern char *enum_name_string\t\t\tPROTO((tree, tree));\n extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n extern void check_for_new_type\t\t\tPROTO((const char *, flagged_type_tree));\n-extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n \n /* in xref.c */\n extern void GNU_xref_begin\t\t\tPROTO((const char *));"}, {"sha": "865ea2db88c52b49efce3bf12225665e71a9f972", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac3691da5498ee2f93bae1866234ccdb9a956bd/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac3691da5498ee2f93bae1866234ccdb9a956bd/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=aac3691da5498ee2f93bae1866234ccdb9a956bd", "patch": "@@ -378,146 +378,6 @@ my_friendly_assert (cond, where)\n     my_friendly_abort (where);\n }\n \f\n-/* Return nonzero if VALUE is a valid constant-valued expression\n-   for use in initializing a static variable; one that can be an\n-   element of a \"constant\" initializer.\n-\n-   Return null_pointer_node if the value is absolute;\n-   if it is relocatable, return the variable that determines the relocation.\n-   We assume that VALUE has been folded as much as possible;\n-   therefore, we do not need to check for such things as\n-   arithmetic-combinations of integers.  */\n-\n-tree\n-initializer_constant_valid_p (value, endtype)\n-     tree value;\n-     tree endtype;\n-{\n-  switch (TREE_CODE (value))\n-    {\n-    case CONSTRUCTOR:\n-      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n-\t  && TREE_CONSTANT (value))\n-\treturn\n-\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n-\t\t\t\t\tendtype);\n-\t\n-      return TREE_STATIC (value) ? null_pointer_node : 0;\n-\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-    case PTRMEM_CST:\n-      return null_pointer_node;\n-\n-    case ADDR_EXPR:\n-      return TREE_OPERAND (value, 0);\n-\n-    case NON_LVALUE_EXPR:\n-      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-      /* Allow conversions between pointer types.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (value))\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between real types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == REAL_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == REAL_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow length-preserving conversions between integer types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between other integer types only if\n-\t explicit value.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n-\t{\n-\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t     endtype);\n-\t  if (inner == null_pointer_node)\n-\t    return null_pointer_node;\n-\t  return 0;\n-\t}\n-\n-      /* Allow (int) &foo provided int is as wide as a pointer.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-\n-      /* Likewise conversions from int to pointers, but also allow\n-\t conversions from 0.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n-\t{\n-\t  if (integer_zerop (TREE_OPERAND (value, 0)))\n-\t    return null_pointer_node;\n-\t  else if (TYPE_PRECISION (TREE_TYPE (value))\n-\t\t   <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\t    return initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t endtype);\n-\t}\n-\n-      /* Allow conversions to union types if the value inside is okay.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-      return 0;\n-\n-    case PLUS_EXPR:\n-      if ((TREE_CODE (endtype) == INTEGER_TYPE)\n-\t  && (TYPE_PRECISION (endtype) < POINTER_SIZE))\n-\treturn 0;\n-      {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t    endtype);\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t    endtype);\n-\t/* If either term is absolute, use the other terms relocation.  */\n-\tif (valid0 == null_pointer_node)\n-\t  return valid1;\n-\tif (valid1 == null_pointer_node)\n-\t  return valid0;\n-\treturn 0;\n-      }\n-\n-    case MINUS_EXPR:\n-      if ((TREE_CODE (endtype) == INTEGER_TYPE)\n-\t  && (TYPE_PRECISION (endtype) < POINTER_SIZE))\n-\treturn 0;\n-      {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t    endtype);\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t    endtype);\n-\t/* Win if second argument is absolute.  */\n-\tif (valid1 == null_pointer_node)\n-\t  return valid0;\n-\t/* Win if both arguments have the same relocation.\n-\t   Then the value is absolute.  */\n-\tif (valid0 == valid1)\n-\t  return null_pointer_node;\n-\treturn 0;\n-      }\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\f\n /* Perform appropriate conversions on the initial value of a variable,\n    store it in the declaration DECL,\n    and print any error messages that are appropriate."}]}