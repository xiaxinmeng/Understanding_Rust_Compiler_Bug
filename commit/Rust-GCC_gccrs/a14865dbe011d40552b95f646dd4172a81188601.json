{"sha": "a14865dbe011d40552b95f646dd4172a81188601", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE0ODY1ZGJlMDExZDQwNTUyYjk1ZjY0NmRkNDE3MmE4MTE4ODYwMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-12-10T23:34:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-12-10T23:34:20Z"}, "message": "loop.texi: Document number_of_latch_executions and number_of_cond_exit_executions.\n\n\t* doc/loop.texi: Document number_of_latch_executions and\n\tnumber_of_cond_exit_executions.\n\t* tree-scalar-evolution.c (compute_overall_effect_of_inner_loop,\n\tchrec_is_positive, number_of_iterations_for_all_loops,\n\tscev_const_prop): Use number_of_latch_executions.\n\t(set_nb_iterations_in_loop): Do not increase the value of the\n\tnumber of iterations.\n\t(number_of_iterations_in_loop): Renamed to ...\n\t(number_of_latch_executions): ... this.\n\t(number_of_exit_cond_executions): New function.\n\t* tree-scalar-evolution.h (number_of_iterations_in_loop): Declaration\n\tremoved.\n\t(number_of_latch_executions, number_of_exit_cond_executions): Declare.\n\t* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables): Use\n\tnumber_of_latch_executions.\n\t* tree-data-ref.c (get_number_of_iters_for_loop): Use\n\tnumber_of_exit_cond_executions.\n\t* tree-vect-analyze.c (vect_get_loop_niters): Ditto.\n\t* cfgloop.h (struct loop): Improve description of the nb_iterations\n\tfield.\n\n\t* gcc.dg/tree-ssa/loop-17.c: Update outcome.\n\nFrom-SVN: r119718", "tree": {"sha": "49e4518b80f9f2c4c2ddf2edcbb93a2d6e48c84d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49e4518b80f9f2c4c2ddf2edcbb93a2d6e48c84d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a14865dbe011d40552b95f646dd4172a81188601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a14865dbe011d40552b95f646dd4172a81188601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a14865dbe011d40552b95f646dd4172a81188601", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a14865dbe011d40552b95f646dd4172a81188601/comments", "author": null, "committer": null, "parents": [{"sha": "c7463db95a98bc9b4372e2ab77df993f5dddd337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7463db95a98bc9b4372e2ab77df993f5dddd337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7463db95a98bc9b4372e2ab77df993f5dddd337"}], "stats": {"total": 137, "additions": 83, "deletions": 54}, "files": [{"sha": "b069e0ff80936782574801b78d2c76c2c6e23736", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -1,3 +1,26 @@\n+2006-12-10  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* doc/loop.texi: Document number_of_latch_executions and\n+\tnumber_of_cond_exit_executions.\n+\t* tree-scalar-evolution.c (compute_overall_effect_of_inner_loop,\n+\tchrec_is_positive, number_of_iterations_for_all_loops,\n+\tscev_const_prop): Use number_of_latch_executions.\n+\t(set_nb_iterations_in_loop): Do not increase the value of the\n+\tnumber of iterations.\n+\t(number_of_iterations_in_loop): Renamed to ...\n+\t(number_of_latch_executions): ... this.\n+\t(number_of_exit_cond_executions): New function.\n+\t* tree-scalar-evolution.h (number_of_iterations_in_loop): Declaration\n+\tremoved.\n+\t(number_of_latch_executions, number_of_exit_cond_executions): Declare.\n+\t* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables): Use\n+\tnumber_of_latch_executions.\n+\t* tree-data-ref.c (get_number_of_iters_for_loop): Use\n+\tnumber_of_exit_cond_executions.\n+\t* tree-vect-analyze.c (vect_get_loop_niters): Ditto.\n+\t* cfgloop.h (struct loop): Improve description of the nb_iterations\n+\tfield.\n+\n 2006-12-10  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-alias.c (compact_name_tags): Use sort_tags_by_id."}, {"sha": "4a13a6ac06bca2459282bb3ed32a0f4e2770610b", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -119,10 +119,10 @@ struct loop\n   /* Auxiliary info specific to a pass.  */\n   void *aux;\n \n-  /* The probable number of times the loop is executed at runtime.\n+  /* The number of times the latch of the loop is executed.\n      This is an INTEGER_CST or an expression containing symbolic\n      names.  Don't access this field directly:\n-     number_of_iterations_in_loop computes and caches the computed\n+     number_of_latch_executions computes and caches the computed\n      information in this field.  */\n   tree nb_iterations;\n "}, {"sha": "1b189c778fd9501bfddb4ded7ed351460524c41f", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -397,13 +397,15 @@ calculations.\n @cindex Number of iterations analysis\n \n Both on GIMPLE and on RTL, there are functions available to determine\n-the number of iterations of a loop, with a similar interface.  In many\n-cases, it is not possible to determine number of iterations\n-unconditionally -- the determined number is correct only if some\n-assumptions are satisfied.  The analysis tries to verify these\n-conditions using the information contained in the program; if it fails,\n-the conditions are returned together with the result.  The following\n-information and conditions are provided by the analysis:\n+the number of iterations of a loop, with a similar interface.  The\n+number of iterations of a loop in GCC is defined as the number of\n+executions of the loop latch.  In many cases, it is not possible to\n+determine the number of iterations unconditionally -- the determined\n+number is correct only if some assumptions are satisfied.  The analysis\n+tries to verify these conditions using the information contained in the\n+program; if it fails, the conditions are returned together with the\n+result.  The following information and conditions are provided by the\n+analysis:\n \n @itemize\n @item @code{assumptions}: If this condition is false, the rest of\n@@ -431,16 +433,16 @@ number of iterations -- @code{find_loop_niter} on GIMPLE and\n @code{find_simple_exit} on RTL.  Finally, there are functions that\n provide the same information, but additionally cache it, so that\n repeated calls to number of iterations are not so costly --\n-@code{number_of_iterations_in_loop} on GIMPLE and\n-@code{get_simple_loop_desc} on RTL.\n+@code{number_of_latch_executions} on GIMPLE and @code{get_simple_loop_desc}\n+on RTL.\n \n Note that some of these functions may behave slightly differently than\n others -- some of them return only the expression for the number of\n iterations, and fail if there are some assumptions.  The function\n-@code{number_of_iterations_in_loop} works only for single-exit loops,\n-and it returns the value for number of iterations higher by one with\n-respect to all other functions (i.e., it returns number of executions of\n-the exit statement, not of the loop latch).\n+@code{number_of_latch_executions} works only for single-exit loops.\n+The function @code{number_of_cond_exit_executions} can be used to\n+determine number of executions of the exit condition of a single-exit\n+loop (i.e., the @code{number_of_latch_executions} increased by one).\n \n @node Dependency analysis\n @section Data Dependency Analysis"}, {"sha": "0b9b664feba8d3e4a0b8a2d10801de722a5a3e77", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -1,3 +1,7 @@\n+2006-12-10  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-17.c: Update outcome.\n+\n 2006-12-10  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/23994"}, {"sha": "d2903cef234d3ffbe75888d14e99945193a4fd57", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-17.c?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -15,5 +15,5 @@ int foo (int *p)\n   return i;\n }\n \n-/* { dg-final { scan-tree-dump \"set_nb_iterations_in_loop = 2\" \"sccp\" } } */\n+/* { dg-final { scan-tree-dump \"set_nb_iterations_in_loop = 1\" \"sccp\" } } */\n /* { dg-final { cleanup-tree-dump \"sccp\" } } */"}, {"sha": "fdaaaafac931723f1496507fd2a9ddb7d47029b8", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -2305,7 +2305,7 @@ static tree\n get_number_of_iters_for_loop (int loopnum)\n {\n   struct loop *loop = get_loop (loopnum);\n-  tree numiter = number_of_iterations_in_loop (loop);\n+  tree numiter = number_of_exit_cond_executions (loop);\n \n   if (TREE_CODE (numiter) == INTEGER_CST)\n     return numiter;"}, {"sha": "10d5da5d271bd09f05c6c3618e4a13e55b3e2c42", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -468,20 +468,14 @@ compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n       if (CHREC_VARIABLE (evolution_fn) >= (unsigned) loop->num)\n \t{\n \t  struct loop *inner_loop = get_chrec_loop (evolution_fn);\n-\t  tree nb_iter = number_of_iterations_in_loop (inner_loop);\n+\t  tree nb_iter = number_of_latch_executions (inner_loop);\n \n \t  if (nb_iter == chrec_dont_know)\n \t    return chrec_dont_know;\n \t  else\n \t    {\n \t      tree res;\n-\t      tree type = chrec_type (nb_iter);\n \n-\t      /* Number of iterations is off by one (the ssa name we\n-\t\t analyze must be defined before the exit).  */\n-\t      nb_iter = chrec_fold_minus (type, nb_iter,\n-\t\t\t\t\t  build_int_cst (type, 1));\n-\t      \n \t      /* evolution_fn is the evolution function in LOOP.  Get\n \t\t its value in the nb_iter-th iteration.  */\n \t      res = chrec_apply (inner_loop->num, evolution_fn, nb_iter);\n@@ -510,7 +504,7 @@ bool\n chrec_is_positive (tree chrec, bool *value)\n {\n   bool value0, value1, value2;\n-  tree type, end_value, nb_iter;\n+  tree end_value, nb_iter;\n   \n   switch (TREE_CODE (chrec))\n     {\n@@ -533,13 +527,10 @@ chrec_is_positive (tree chrec, bool *value)\n       if (!evolution_function_is_affine_p (chrec))\n \treturn false;\n \n-      nb_iter = number_of_iterations_in_loop (get_chrec_loop (chrec));\n+      nb_iter = number_of_latch_executions (get_chrec_loop (chrec));\n       if (chrec_contains_undetermined (nb_iter))\n \treturn false;\n \n-      type = chrec_type (nb_iter);\n-      nb_iter = chrec_fold_minus (type, nb_iter, build_int_cst (type, 1));\n-\n #if 0\n       /* TODO -- If the test is after the exit, we may decrease the number of\n \t iterations by one.  */\n@@ -892,19 +883,6 @@ static inline tree\n set_nb_iterations_in_loop (struct loop *loop, \n \t\t\t   tree res)\n {\n-  tree type = chrec_type (res);\n-\n-  res = chrec_fold_plus (type, res, build_int_cst (type, 1));\n-\n-  /* FIXME HWI: However we want to store one iteration less than the\n-     count of the loop in order to be compatible with the other\n-     nb_iter computations in loop-iv.  This also allows the\n-     representation of nb_iters that are equal to MAX_INT.  */\n-  if (TREE_CODE (res) == INTEGER_CST\n-      && (TREE_INT_CST_LOW (res) == 0\n-\t  || TREE_OVERFLOW (res)))\n-    res = chrec_dont_know;\n-  \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  (set_nb_iterations_in_loop = \");\n@@ -2465,7 +2443,7 @@ resolve_mixers (struct loop *loop, tree chrec)\n    the loop body has been executed 6 times.  */\n \n tree \n-number_of_iterations_in_loop (struct loop *loop)\n+number_of_latch_executions (struct loop *loop)\n {\n   tree res, type;\n   edge exit;\n@@ -2500,6 +2478,33 @@ number_of_iterations_in_loop (struct loop *loop)\n   return set_nb_iterations_in_loop (loop, res);\n }\n \n+/* Returns the number of executions of the exit condition of LOOP,\n+   i.e., the number by one higher than number_of_latch_executions.\n+   Note that unline number_of_latch_executions, this number does\n+   not necessarily fit in the unsigned variant of the type of\n+   the control variable -- if the number of iterations is a constant,\n+   we return chrec_dont_know if adding one to number_of_latch_executions\n+   overflows; however, in case the number of iterations is symbolic\n+   expression, the caller is responsible for dealing with this\n+   the possible overflow.  */\n+\n+tree \n+number_of_exit_cond_executions (struct loop *loop)\n+{\n+  tree ret = number_of_latch_executions (loop);\n+  tree type = chrec_type (ret);\n+\n+  if (chrec_contains_undetermined (ret))\n+    return ret;\n+\n+  ret = chrec_fold_plus (type, ret, build_int_cst (type, 1));\n+  if (TREE_CODE (ret) == INTEGER_CST\n+      && TREE_OVERFLOW (ret))\n+    return chrec_dont_know;\n+\n+  return ret;\n+}\n+\n /* One of the drivers for testing the scalar evolutions analysis.\n    This function computes the number of iterations for all the loops\n    from the EXIT_CONDITIONS array.  */\n@@ -2514,7 +2519,7 @@ number_of_iterations_for_all_loops (VEC(tree,heap) **exit_conditions)\n   \n   for (i = 0; VEC_iterate (tree, *exit_conditions, i, cond); i++)\n     {\n-      tree res = number_of_iterations_in_loop (loop_containing_stmt (cond));\n+      tree res = number_of_latch_executions (loop_containing_stmt (cond));\n       if (chrec_contains_undetermined (res))\n \tnb_chrec_dont_know_loops++;\n       else\n@@ -2956,7 +2961,7 @@ scev_const_prop (void)\n       if (!exit)\n \tcontinue;\n \n-      niter = number_of_iterations_in_loop (loop);\n+      niter = number_of_latch_executions (loop);\n       if (niter == chrec_dont_know\n \t  /* If computing the number of iterations is expensive, it may be\n \t     better not to introduce computations involving it.  */"}, {"sha": "464fe8fc519cc23fc2f4de6d073c1fe936b17eee", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -22,7 +22,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #ifndef GCC_TREE_SCALAR_EVOLUTION_H\n #define GCC_TREE_SCALAR_EVOLUTION_H\n \n-extern tree number_of_iterations_in_loop (struct loop *);\n+extern tree number_of_latch_executions (struct loop *);\n+extern tree number_of_exit_cond_executions (struct loop *);\n extern tree get_loop_exit_condition (struct loop *);\n \n extern void scev_initialize (void);"}, {"sha": "c26727a808decf35dd3241f303b807dd73bd910f", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -279,18 +279,12 @@ canonicalize_loop_induction_variables (struct loop *loop,\n   edge exit = NULL;\n   tree niter;\n \n-  niter = number_of_iterations_in_loop (loop);\n+  niter = number_of_latch_executions (loop);\n   if (TREE_CODE (niter) == INTEGER_CST)\n     {\n       exit = single_exit (loop);\n       if (!just_once_each_iteration_p (loop, exit->src))\n \treturn false;\n-\n-      /* The result of number_of_iterations_in_loop is by one higher than\n-\t we expect (i.e. it returns number of executions of the exit\n-\t condition, not of the loop latch edge).  */\n-      niter = fold_build2 (MINUS_EXPR, TREE_TYPE (niter), niter,\n-\t\t\t   build_int_cst (TREE_TYPE (niter), 1));\n     }\n   else\n     {"}, {"sha": "7506150b6ad2ffc120e13d67338350f49008dc25", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a14865dbe011d40552b95f646dd4172a81188601/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=a14865dbe011d40552b95f646dd4172a81188601", "patch": "@@ -2393,7 +2393,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== get_loop_niters ===\");\n \n-  niters = number_of_iterations_in_loop (loop);\n+  niters = number_of_exit_cond_executions (loop);\n \n   if (niters != NULL_TREE\n       && niters != chrec_dont_know)"}]}