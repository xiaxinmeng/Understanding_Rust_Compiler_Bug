{"sha": "cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZiZWFlZGZkZGJjYjRkMGJmMjY0MzZiOWQ5MDA2NjY3ZjFhMmRkZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-27T22:26:15Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-27T22:26:15Z"}, "message": "rtl.h (debug_bb_n_slim, [...]): Remove prototypes.\n\n\t* rtl.h (debug_bb_n_slim, debug_bb_slim, debug_insn_slim): Remove\n\tprototypes.\n\t(debug_rtl_slim): Rename to dump_rtl_slim.\n\t(print_value_slim): Rename to dump_value_slim.\n\t* ira.c (ira_update_equiv_info_by_shuffle_insn): Update\n\tprint_value_slim user.\n\t* lra.c (lra_process_new_insns): Use dump_insn_slim to dump single\n\tinsns.  Use dump_rtl_slim for insn chains.\n\t* lra-constraints.c (get_reload_reg): Update print_value_slim user.\n\t(process_addr_reg): Likewise.\n\t(equiv_address_substitution): Likewise.\n\t(inherit_reload_reg): Likewise.  Use dump_insn_slim to dump single\n\tinsns.\n\t(check_and_process_move): Likewise.\n\t(lra_constraints): Likewise.\n\t(split_reg): Likewise.\n\t(update_ebb_live_info): Likewise.\n\t(remove_inheritance_pseudos): Likewise.\n\t* sched-vis.c: Don't include sched-int.h.\n\tRemove #ifdef INSN_SCHEDULING tests.\n\t(print_value_slim): Rename to dump_value_slim.  Simplify a few\n\tcases using GET_RTX_NAME.\n\t(print_pattern): Do not handle UNSPEC and UNSPECV here, explain why.\n\t(print_insn): Reorganize code to be independent of INSN_SCHEDULING.\n\tAlways print CALL_INSN patterns.  Harmonize INSN_UID dumping template.\n\tHandle NOTE_INSN_CALL_ARG_LOCATION.\n\t(dump_rtl_slim): Copied from debug_rtl_slim.\n\t(debug_rtl_slim): Wrapper around dump_rtl_slim to stderr.\n\t* haifa-sched.c (schedule_insn): Update print_insn user.\n\nFrom-SVN: r193873", "tree": {"sha": "5a205a6205f6e25e3d64b5c9f8227e22e33ff3db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a205a6205f6e25e3d64b5c9f8227e22e33ff3db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/comments", "author": null, "committer": null, "parents": [{"sha": "916bad5528903202476629ae03d4af03779b4f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916bad5528903202476629ae03d4af03779b4f88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916bad5528903202476629ae03d4af03779b4f88"}], "stats": {"total": 286, "additions": 136, "deletions": 150}, "files": [{"sha": "8d84f78fdc9fdd85dc526756ae19825e812f9340", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -1,3 +1,35 @@\n+2012-11-27  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* rtl.h (debug_bb_n_slim, debug_bb_slim, debug_insn_slim): Remove\n+\tprototypes.\n+\t(debug_rtl_slim): Rename to dump_rtl_slim.\n+\t(print_value_slim): Rename to dump_value_slim.\n+\t* ira.c (ira_update_equiv_info_by_shuffle_insn): Update\n+\tprint_value_slim user.\n+\t* lra.c (lra_process_new_insns): Use dump_insn_slim to dump single\n+\tinsns.  Use dump_rtl_slim for insn chains.\n+\t* lra-constraints.c (get_reload_reg): Update print_value_slim user.\n+\t(process_addr_reg): Likewise.\n+\t(equiv_address_substitution): Likewise.\n+\t(inherit_reload_reg): Likewise.  Use dump_insn_slim to dump single\n+\tinsns.\n+\t(check_and_process_move): Likewise.\n+\t(lra_constraints): Likewise.\n+\t(split_reg): Likewise.\n+\t(update_ebb_live_info): Likewise.\n+\t(remove_inheritance_pseudos): Likewise.\n+\t* sched-vis.c: Don't include sched-int.h.\n+\tRemove #ifdef INSN_SCHEDULING tests.\n+\t(print_value_slim): Rename to dump_value_slim.  Simplify a few\n+\tcases using GET_RTX_NAME.\n+\t(print_pattern): Do not handle UNSPEC and UNSPECV here, explain why.\n+\t(print_insn): Reorganize code to be independent of INSN_SCHEDULING.\n+\tAlways print CALL_INSN patterns.  Harmonize INSN_UID dumping template.\n+\tHandle NOTE_INSN_CALL_ARG_LOCATION.\n+\t(dump_rtl_slim): Copied from debug_rtl_slim.\n+\t(debug_rtl_slim): Wrapper around dump_rtl_slim to stderr.\n+\t* haifa-sched.c (schedule_insn): Update print_insn user.\n+\n 2012-11-27  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/55458"}, {"sha": "c835bf82622668edd9a91a1e3d8d8361232c946b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -3719,7 +3719,8 @@ schedule_insn (rtx insn)\n \n       print_insn (buf, insn, 0);\n       buf[40] = 0;\n-      fprintf (sched_dump, \";;\\t%3i--> %-40s:\", clock_var, buf);\n+      fprintf (sched_dump, \";;\\t%3i--> %s%-40s:\",\n+\t       clock_var, (*current_sched_info->print_insn) (insn, 1), buf);\n \n       if (recog_memoized (insn) < 0)\n \tfprintf (sched_dump, \"nothing\");"}, {"sha": "f0cbd6dc72e51e57f80cc7c1cc16095939f4e60c", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -2246,7 +2246,7 @@ ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx insns)\n \t      fprintf (ira_dump_file,\n \t\t       \"      Adding equiv note to insn %u for reg %d \",\n \t\t       INSN_UID (insn), to_regno);\n-\t      print_value_slim (ira_dump_file, x, 1);\n+\t      dump_value_slim (ira_dump_file, x, 1);\n \t      fprintf (ira_dump_file, \"\\n\");\n \t    }\n \t}"}, {"sha": "635bb47064f8aaef5a23bf0d0e86b7d899b9a11c", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -425,7 +425,7 @@ get_reload_reg (enum op_type type, enum machine_mode mode, rtx original,\n \tif (lra_dump_file != NULL)\n \t  {\n \t    fprintf (lra_dump_file, \"\t Reuse r%d for reload \", regno);\n-\t    print_value_slim (lra_dump_file, original, 1);\n+\t    dump_value_slim (lra_dump_file, original, 1);\n \t  }\n \tif (new_class != lra_get_allocno_class (regno))\n \t  change_class (regno, new_class, \", change\", false);\n@@ -994,7 +994,7 @@ check_and_process_move (bool *change_p, bool *sec_mem_p)\n       if (lra_dump_file != NULL)\n \t{\n \t  fprintf (lra_dump_file, \"Deleting move %u\\n\", INSN_UID (curr_insn));\n-\t  debug_rtl_slim (lra_dump_file, curr_insn, curr_insn, -1, 0);\n+\t  dump_insn_slim (lra_dump_file, curr_insn);\n \t}\n       lra_set_insn_deleted (curr_insn);\n       return true;\n@@ -1088,7 +1088,7 @@ process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n \t      fprintf (lra_dump_file,\n \t\t       \"Changing pseudo %d in address of insn %u on equiv \",\n \t\t       REGNO (reg), INSN_UID (curr_insn));\n-\t      print_value_slim (lra_dump_file, *loc, 1);\n+\t      dump_value_slim (lra_dump_file, *loc, 1);\n \t      fprintf (lra_dump_file, \"\\n\");\n \t    }\n \t  *loc = copy_rtx (*loc);\n@@ -2215,7 +2215,7 @@ equiv_address_substitution (struct address_info *ad)\n     {\n       fprintf (lra_dump_file, \"Changing address in insn %d \",\n \t       INSN_UID (curr_insn));\n-      print_value_slim (lra_dump_file, *ad->outer, 1);\n+      dump_value_slim (lra_dump_file, *ad->outer, 1);\n     }\n   if (base_reg != new_base_reg)\n     {\n@@ -2272,7 +2272,7 @@ equiv_address_substitution (struct address_info *ad)\n       else\n \t{\n \t  fprintf (lra_dump_file, \" on equiv \");\n-\t  print_value_slim (lra_dump_file, *ad->outer, 1);\n+\t  dump_value_slim (lra_dump_file, *ad->outer, 1);\n \t  fprintf (lra_dump_file, \"\\n\");\n \t}\n     }\n@@ -2676,7 +2676,7 @@ curr_insn_transform (void)\n \t      fprintf (lra_dump_file,\n \t\t       \"Changing pseudo %d in operand %i of insn %u on equiv \",\n \t\t       REGNO (old), i, INSN_UID (curr_insn));\n-\t      print_value_slim (lra_dump_file, subst, 1);\n+\t      dump_value_slim (lra_dump_file, subst, 1);\n \t      fprintf (lra_dump_file, \"\\n\");\n \t    }\n \t  op_change_p = change_p = true;\n@@ -3467,8 +3467,7 @@ lra_constraints (bool first_p)\n \t\t\t       \"      Removing equiv init insn %i (freq=%d)\\n\",\n \t\t\t       INSN_UID (curr_insn),\n \t\t\t       BLOCK_FOR_INSN (curr_insn)->frequency);\n-\t\t      debug_rtl_slim (lra_dump_file,\n-\t\t\t\t      curr_insn, curr_insn, -1, 0);\n+\t\t      dump_insn_slim (lra_dump_file, curr_insn);\n \t\t    }\n \t\t  if (contains_reg_p (x, true, false))\n \t\t    lra_risky_transformations_p = true;\n@@ -3807,7 +3806,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t\t   \"    Rejecting inheritance %d->%d \"\n \t\t   \"as it results in 2 or more insns:\\n\",\n \t\t   original_regno, REGNO (new_reg));\n-\t  debug_rtl_slim (lra_dump_file, new_insns, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, new_insns, NULL_RTX, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n \t}\n@@ -3853,8 +3852,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n \t\t   \"    Inheritance reuse change %d->%d (bb%d):\\n\",\n \t\t   original_regno, REGNO (new_reg),\n \t\t   BLOCK_FOR_INSN (usage_insn)->index);\n-\t  debug_rtl_slim (lra_dump_file, usage_insn, usage_insn,\n-\t\t\t  -1, 0);\n+\t  dump_insn_slim (lra_dump_file, usage_insn);\n \t}\n     }\n   if (lra_dump_file != NULL)\n@@ -4058,7 +4056,7 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n \t    (lra_dump_file,\n \t     \"\t  Rejecting split %d->%d resulting in > 2 %s save insns:\\n\",\n \t     original_regno, REGNO (new_reg), call_save_p ? \"call\" : \"\");\n-\t  debug_rtl_slim (lra_dump_file, save, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, save, NULL_RTX, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n \t}\n@@ -4074,7 +4072,7 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n \t\t   \"\tRejecting split %d->%d \"\n \t\t   \"resulting in > 2 %s restore insns:\\n\",\n \t\t   original_regno, REGNO (new_reg), call_save_p ? \"call\" : \"\");\n-\t  debug_rtl_slim (lra_dump_file, restore, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, restore, NULL_RTX, -1, 0);\n \t  fprintf (lra_dump_file,\n \t\t   \"\t))))))))))))))))))))))))))))))))))))))))))))))))\\n\");\n \t}\n@@ -4101,8 +4099,7 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n \t{\n \t  fprintf (lra_dump_file, \"    Split reuse change %d->%d:\\n\",\n \t\t   original_regno, REGNO (new_reg));\n-\t  debug_rtl_slim (lra_dump_file, usage_insn, usage_insn,\n-\t\t\t  -1, 0);\n+\t  dump_insn_slim (lra_dump_file, usage_insn);\n \t}\n     }\n   lra_assert (NOTE_P (usage_insn) || NONDEBUG_INSN_P (usage_insn));\n@@ -4245,7 +4242,7 @@ update_ebb_live_info (rtx head, rtx tail)\n \t  if (lra_dump_file != NULL)\n \t    {\n \t      fprintf (lra_dump_file, \"\t    Removing dead insn:\\n \");\n-\t      debug_rtl_slim (lra_dump_file, curr_insn, curr_insn, -1, 0);\n+\t      dump_insn_slim (lra_dump_file, curr_insn);\n \t    }\n \t  lra_set_insn_deleted (curr_insn);\n \t}\n@@ -4861,8 +4858,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t\t       bitmap_bit_p (&lra_split_regs, sregno)\n \t\t\t       || bitmap_bit_p (&lra_split_regs, dregno)\n \t\t\t       ? \"split\" : \"inheritance\");\n-\t\t      debug_rtl_slim (lra_dump_file,\n-\t\t\t\t      curr_insn, curr_insn, -1, 0);\n+\t\t      dump_insn_slim (lra_dump_file, curr_insn);\n \t\t    }\n \t\t  lra_set_insn_deleted (curr_insn);\n \t\t  done_p = true;\n@@ -4914,8 +4910,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t\t      if (lra_dump_file != NULL)\n \t\t\t{\n \t\t\t  fprintf (lra_dump_file, \"    Change reload insn:\\n\");\n-\t\t\t  debug_rtl_slim (lra_dump_file,\n-\t\t\t\t\t  curr_insn, curr_insn, -1, 0);\n+\t\t\t  dump_insn_slim (lra_dump_file, curr_insn);\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -4958,7 +4953,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t      if (restored_regs_p && lra_dump_file != NULL)\n \t\t{\n \t\t  fprintf (lra_dump_file, \"   Insn after restoring regs:\\n\");\n-\t\t  debug_rtl_slim (lra_dump_file, curr_insn, curr_insn, -1, 0);\n+\t\t  dump_insn_slim (lra_dump_file, curr_insn);\n \t\t}\n \t    }\n \t}"}, {"sha": "d67760f394e286287400d732af7d4ef2cf7d0182", "filename": "gcc/lra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -1817,16 +1817,16 @@ lra_process_new_insns (rtx insn, rtx before, rtx after, const char *title)\n \n   if (lra_dump_file != NULL && (before != NULL_RTX || after != NULL_RTX))\n     {\n-      debug_rtl_slim (lra_dump_file, insn, insn, -1, 0);\n+      dump_insn_slim (lra_dump_file, insn);\n       if (before != NULL_RTX)\n \t{\n \t  fprintf (lra_dump_file,\"    %s before:\\n\", title);\n-\t  debug_rtl_slim (lra_dump_file, before, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, before, NULL_RTX, -1, 0);\n \t}\n       if (after != NULL_RTX)\n \t{\n \t  fprintf (lra_dump_file, \"    %s after:\\n\", title);\n-\t  debug_rtl_slim (lra_dump_file, after, NULL_RTX, -1, 0);\n+\t  dump_rtl_slim (lra_dump_file, after, NULL_RTX, -1, 0);\n \t}\n       fprintf (lra_dump_file, \"\\n\");\n     }"}, {"sha": "a0fb4f7aa4f91be5cf798ef9bb5cdda0316561b1", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -2575,14 +2575,6 @@ extern rtx make_compound_operation (rtx, enum rtx_code);\n /* In cfgcleanup.c  */\n extern void delete_dead_jumptables (void);\n \n-/* In sched-vis.c.  */\n-extern void debug_bb_n_slim (int);\n-extern void debug_bb_slim (struct basic_block_def *);\n-extern void print_value_slim (FILE *, const_rtx, int);\n-extern void debug_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n-extern void dump_insn_slim (FILE *f, const_rtx x);\n-extern void debug_insn_slim (const_rtx x);\n-\n /* In sched-rgn.c.  */\n extern void schedule_insns (void);\n \n@@ -2609,9 +2601,12 @@ extern void print_inline_rtx (FILE *, const_rtx, int);\n    sched-vis.c is compiled always.  FIXME: Ideally these functions would\n    not be in sched-vis.c but in rtl.c, because they are not only used\n    by the scheduler anymore but for all \"slim\" RTL dumping.  */\n-extern void print_insn (char *, const_rtx, int);\n-extern void print_pattern (char *, const_rtx, int);\n+extern void dump_value_slim (FILE *, const_rtx, int);\n+extern void dump_insn_slim (FILE *, const_rtx);\n+extern void dump_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n extern void print_value (char *, const_rtx, int);\n+extern void print_pattern (char *, const_rtx, int);\n+extern void print_insn (char *, const_rtx, int);\n \n /* In function.c */\n extern void reposition_prologue_and_epilogue_notes (void);"}, {"sha": "18a3f07d4d58503d619bd7c007e0f32a3104c71e", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 77, "deletions": 114, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=cfbeaedfddbcb4d0bf26436b9d9006667f1a2dde", "patch": "@@ -1,6 +1,5 @@\n-/* Instruction scheduling pass.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010\n+/* Printing of RTL in \"slim\", mnemonic like form.\n+   Copyright (C) 1992-2012\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n@@ -20,6 +19,10 @@ for more details.\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n+\n+/* Historically this form of RTL dumping was introduced along with\n+   the Haifa instruction scheduling pass, hence the name of this file.\n+   But there is nothing in this file left that is scheduler-specific.  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -31,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-attr.h\"\n-#include \"sched-int.h\"\n #include \"dumpfile.h\"\t/* for the TDF_* flags */\n \n static char *safe_concat (char *, char *, const char *);\n@@ -498,11 +500,7 @@ print_value (char *buf, const_rtx x, int verbose)\n \t  sprintf (t, \"r%d\", REGNO (x));\n \t  cur = safe_concat (buf, cur, t);\n \t}\n-      if (verbose\n-#ifdef INSN_SCHEDULING\n-\t  && !current_sched_info\n-#endif\n-\t )\n+      if (verbose)\n \t{\n \t  sprintf (t, \":%s\", GET_MODE_NAME (GET_MODE (x)));\n \t  cur = safe_concat (buf, cur, t);\n@@ -553,7 +551,7 @@ print_value (char *buf, const_rtx x, int verbose)\n    memory.  */\n \n void\n-print_value_slim (FILE *f, const_rtx x, int verbose)\n+dump_value_slim (FILE *f, const_rtx x, int verbose)\n {\n   char buf[BUF_LEN];\n \n@@ -590,12 +588,9 @@ print_pattern (char *buf, const_rtx x, int verbose)\n       print_exp (buf, x, verbose);\n       break;\n     case CLOBBER:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"clobber %s\", t1);\n-      break;\n     case USE:\n       print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"use %s\", t1);\n+      sprintf (buf, \"%s %s\", GET_RTX_NAME (GET_CODE (x)), t1);\n       break;\n     case VAR_LOCATION:\n       print_value (t1, PAT_VAR_LOCATION_LOC (x), verbose);\n@@ -657,151 +652,102 @@ print_pattern (char *buf, const_rtx x, int verbose)\n       sprintf (buf, \"trap_if %s\", t1);\n       break;\n     case UNSPEC:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"unspec{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s}\", t1);\n-      }\n-      break;\n     case UNSPEC_VOLATILE:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"unspec/v{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s}\", t1);\n-      }\n-      break;\n+      /* Fallthru -- leave UNSPECs to print_exp.  */\n     default:\n       print_value (buf, x, verbose);\n     }\n }\t\t\t\t/* print_pattern */\n \n-/* This is the main function in rtl visualization mechanism. It\n-   accepts an rtx and tries to recognize it as an insn, then prints it\n-   properly in human readable form, resembling assembler mnemonics.\n-   For every insn it prints its UID and BB the insn belongs too.\n-   (Probably the last \"option\" should be extended somehow, since it\n-   depends now on sched.c inner variables ...)  */\n+/* This is the main function in slim rtl visualization mechanism.\n+\n+   X is an insn, to be printed into BUF.\n+\n+   This function tries to print it properly in human-readable form,\n+   resembling assembler mnemonics (instead of the older Lisp-style\n+   form).\n+\n+   If VERBOSE is TRUE, insns are printed with more complete (but\n+   longer) pattern names and with extra information, and prefixed\n+   with their INSN_UIDs.  */\n \n void\n print_insn (char *buf, const_rtx x, int verbose)\n {\n-  char t[BUF_LEN];\n-  const_rtx insn = x;\n+  /* Collect the string to output for X in t1.  t2 is a scratch area.  */\n+  char t1[BUF_LEN], t2[BUF_LEN];\n \n   switch (GET_CODE (x))\n     {\n     case INSN:\n-      print_pattern (t, PATTERN (x), verbose);\n-#ifdef INSN_SCHEDULING\n-      if (verbose && current_sched_info)\n-\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1),\n-\t\t t);\n-      else\n-#endif\n-\tsprintf (buf, \" %4d %s\", INSN_UID (x), t);\n+      print_pattern (t1, PATTERN (x), verbose);\n       break;\n \n     case DEBUG_INSN:\n       {\n \tconst char *name = \"?\";\n \n-\tif (DECL_P (INSN_VAR_LOCATION_DECL (insn)))\n+\tif (DECL_P (INSN_VAR_LOCATION_DECL (x)))\n \t  {\n-\t    tree id = DECL_NAME (INSN_VAR_LOCATION_DECL (insn));\n+\t    tree id = DECL_NAME (INSN_VAR_LOCATION_DECL (x));\n \t    char idbuf[32];\n \t    if (id)\n \t      name = IDENTIFIER_POINTER (id);\n-\t    else if (TREE_CODE (INSN_VAR_LOCATION_DECL (insn))\n+\t    else if (TREE_CODE (INSN_VAR_LOCATION_DECL (x))\n \t\t     == DEBUG_EXPR_DECL)\n \t      {\n \t\tsprintf (idbuf, \"D#%i\",\n-\t\t\t DEBUG_TEMP_UID (INSN_VAR_LOCATION_DECL (insn)));\n+\t\t\t DEBUG_TEMP_UID (INSN_VAR_LOCATION_DECL (x)));\n \t\tname = idbuf;\n \t      }\n \t    else\n \t      {\n \t\tsprintf (idbuf, \"D.%i\",\n-\t\t\t DECL_UID (INSN_VAR_LOCATION_DECL (insn)));\n+\t\t\t DECL_UID (INSN_VAR_LOCATION_DECL (x)));\n \t\tname = idbuf;\n \t      }\n \t  }\n-\tif (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))\n-\t  sprintf (buf, \" %4d: debug %s optimized away\", INSN_UID (insn), name);\n+\tif (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (x)))\n+\t  sprintf (t1, \"debug %s optimized away\", name);\n \telse\n \t  {\n-\t    print_pattern (t, INSN_VAR_LOCATION_LOC (insn), verbose);\n-\t    sprintf (buf, \" %4d: debug %s => %s\", INSN_UID (insn), name, t);\n+\t    print_pattern (t2, INSN_VAR_LOCATION_LOC (x), verbose);\n+\t    sprintf (t1, \"debug %s => %s\", name, t2);\n \t  }\n       }\n       break;\n \n     case JUMP_INSN:\n-      print_pattern (t, PATTERN (x), verbose);\n-#ifdef INSN_SCHEDULING\n-      if (verbose && current_sched_info)\n-\tsprintf (buf, \"%s: jump %s\", (*current_sched_info->print_insn) (x, 1),\n-\t\t t);\n-      else\n-#endif\n-\tsprintf (buf, \" %4d %s\", INSN_UID (x), t);\n+      print_pattern (t1, PATTERN (x), verbose);\n       break;\n     case CALL_INSN:\n-      x = PATTERN (insn);\n-      if (GET_CODE (x) == PARALLEL)\n-\t{\n-\t  x = XVECEXP (x, 0, 0);\n-\t  print_pattern (t, x, verbose);\n-\t}\n+      if (GET_CODE (PATTERN (x)) == PARALLEL)\n+        print_pattern (t1, XVECEXP (PATTERN (x), 0, 0), verbose);\n       else\n-\tstrcpy (t, \"call <...>\");\n-#ifdef INSN_SCHEDULING\n-      if (verbose && current_sched_info)\n-\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (insn, 1), t);\n-      else\n-#endif\n-\tsprintf (buf, \" %4d %s\", INSN_UID (insn), t);\n+\tprint_pattern (t1, PATTERN (x), verbose);\n       break;\n     case CODE_LABEL:\n-      sprintf (buf, \"L%d:\", INSN_UID (x));\n+      sprintf (t1, \"L%d:\", INSN_UID (x));\n       break;\n     case BARRIER:\n-      sprintf (buf, \"i%4d: barrier\", INSN_UID (x));\n+      sprintf (t1, \"barrier\");\n       break;\n     case NOTE:\n       {\n-        int uid = INSN_UID (x);\n-        const char *note_name = GET_NOTE_INSN_NAME (NOTE_KIND (x));\n \tswitch (NOTE_KIND (x))\n \t  {\n \t  case NOTE_INSN_EH_REGION_BEG:\n \t  case NOTE_INSN_EH_REGION_END:\n-\t    sprintf (buf, \" %4d %s %d\", uid, note_name,\n-\t\t     NOTE_EH_HANDLER (x));\n+\t    sprintf (t2, \"%d\", NOTE_EH_HANDLER (x));\n \t    break;\n \n \t  case NOTE_INSN_BLOCK_BEG:\n \t  case NOTE_INSN_BLOCK_END:\n-\t    sprintf (buf, \" %4d %s %d\", uid, note_name,\n-\t\t     BLOCK_NUMBER (NOTE_BLOCK (x)));\n+\t    sprintf (t2, \"%d\", BLOCK_NUMBER (NOTE_BLOCK (x)));\n \t    break;\n \n \t  case NOTE_INSN_BASIC_BLOCK:\n-\t    sprintf (buf, \" %4d %s %d\", uid, note_name,\n-\t\t     NOTE_BASIC_BLOCK (x)->index);\n+\t    sprintf (t2, \"%d\", NOTE_BASIC_BLOCK (x)->index);\n \t    break;\n \n \t  case NOTE_INSN_DELETED_LABEL:\n@@ -810,26 +756,35 @@ print_insn (char *buf, const_rtx x, int verbose)\n \t      const char *label = NOTE_DELETED_LABEL_NAME (x);\n \t      if (label == NULL)\n \t\tlabel = \"\";\n-\t      sprintf (buf, \" %4d %s (\\\"%s\\\")\", uid, note_name, label);\n+\t      sprintf (t2, \"(\\\"%s\\\")\", label);\n \t    }\n \t    break;\n \n \t  case NOTE_INSN_VAR_LOCATION:\n-\t    print_pattern (t, NOTE_VAR_LOCATION (x), verbose);\n-\t    sprintf (buf, \" %4d %s {%s}\", uid, note_name, t);\n+\t  case NOTE_INSN_CALL_ARG_LOCATION:\n+\t    /* It's safe here to use t1 for scratch because the output\n+\t       is printed in t2 and put back in t1 at the bottom of\n+\t       the inner switch statement.  */\n+\t    print_pattern (t1, NOTE_VAR_LOCATION (x), verbose);\n+\t    sprintf (t2, \"{%s}\", t1);\n \t    break;\n \n \t  default:\n-\t    sprintf (buf, \" %4d %s\", uid, note_name);\n+\t    t2[0] = '\\0';\n \t    break;\n \t  }\n+\tsprintf (t1, \"%s %s\", GET_NOTE_INSN_NAME (NOTE_KIND (x)), t2);\n \tbreak;\n       }\n     default:\n-      sprintf (buf, \"i%4d  <What %s?>\", INSN_UID (x),\n-\t       GET_RTX_NAME (GET_CODE (x)));\n+      sprintf (t1, \"<What %s?>\", GET_RTX_NAME (GET_CODE (x)));\n       break;\n     }\n+\n+  if (verbose)\n+    sprintf (buf, \" %4d: %s\", INSN_UID (x), t1);\n+  else\n+    sprintf (buf, \"%s\", t1);\n }\t\t\t\t/* print_insn */\n \n /* Emit a slim dump of X (an insn) to the file F, including any register\n@@ -854,20 +809,12 @@ dump_insn_slim (FILE *f, const_rtx x)\n       }\n }\n \n-/* Emit a slim dump of X (an insn) to stderr.  */\n-extern void debug_insn_slim (const_rtx);\n-DEBUG_FUNCTION void\n-debug_insn_slim (const_rtx x)\n-{\n-  dump_insn_slim (stderr, x);\n-}\n-\n /* Same as above, but stop at LAST or when COUNT == 0.\n    If COUNT < 0 it will stop only at LAST or NULL rtx.  */\n-extern void debug_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n-DEBUG_FUNCTION void\n-debug_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n-\t\tint count, int flags ATTRIBUTE_UNUSED)\n+\n+void\n+dump_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n+\t       int count, int flags ATTRIBUTE_UNUSED)\n {\n   const_rtx insn, tail;\n \n@@ -882,6 +829,22 @@ debug_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n     }\n }\n \n+/* Emit a slim dump of X (an insn) to stderr.  */\n+extern void debug_insn_slim (const_rtx);\n+DEBUG_FUNCTION void\n+debug_insn_slim (const_rtx x)\n+{\n+  dump_insn_slim (stderr, x);\n+}\n+\n+/* Same as above, but using dump_rtl_slim.  */\n+extern void debug_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n+DEBUG_FUNCTION void\n+debug_rtl_slim (const_rtx first, const_rtx last, int count, int flags)\n+{\n+  dump_rtl_slim (stderr, first, last, count, flags);\n+}\n+\n extern void debug_bb_slim (basic_block);\n DEBUG_FUNCTION void\n debug_bb_slim (basic_block bb)"}]}