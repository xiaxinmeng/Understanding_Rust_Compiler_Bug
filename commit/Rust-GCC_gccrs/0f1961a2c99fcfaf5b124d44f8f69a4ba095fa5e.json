{"sha": "0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYxOTYxYTJjOTlmY2ZhZjViMTI0ZDQ0ZjhmNjlhNGJhMDk1ZmE1ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-23T22:25:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-23T22:25:20Z"}, "message": "ipa-cp.c (constant_val_insert): Remove.\n\n\n\t* ipa-cp.c (constant_val_insert): Remove.\n\t(ipcp_propagate_one_const): Remove.\n\t(ipcp_create_replace_map): Always insert replacements to the map.\n\t(ipcp_insert_stage): Do not try to insert statements by hand.\n\t* tree-inline.c (insert_init_stmt): Break out from ...\n\t(setup_one_parameter): ... here; allow NULL BB pointer.\n\t(tree_function_versioning): Use setup_one_parameter to process\n\treplacement map.\n\nFrom-SVN: r139525", "tree": {"sha": "c9bbe6833014579b204e7133f3787630aadcaaef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9bbe6833014579b204e7133f3787630aadcaaef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/comments", "author": null, "committer": null, "parents": [{"sha": "d4b7d0f0520f0f91874b1404b53bd6519affe559", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b7d0f0520f0f91874b1404b53bd6519affe559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b7d0f0520f0f91874b1404b53bd6519affe559"}], "stats": {"total": 239, "additions": 98, "deletions": 141}, "files": [{"sha": "6068239dde444c685d6cfe40385b5f6b908c5d23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "patch": "@@ -1,3 +1,14 @@\n+2008-08-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (constant_val_insert): Remove.\n+\t(ipcp_propagate_one_const): Remove.\n+\t(ipcp_create_replace_map): Always insert replacements to the map.\n+\t(ipcp_insert_stage): Do not try to insert statements by hand.\n+\t* tree-inline.c (insert_init_stmt): Break out from ...\n+\t(setup_one_parameter): ... here; allow NULL BB pointer.\n+\t(tree_function_versioning): Use setup_one_parameter to process\n+\treplacement map.\n+\n 2008-08-23  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.c (decl_address_ip_invariant_p): New function."}, {"sha": "78a24bcb71750e9789357186f7f170ebdc9e4061", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 11, "deletions": 83, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "patch": "@@ -369,20 +369,6 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n     ipcp_get_ith_lattice (info, i)->type = IPA_TOP;\n }\n \n-/* Create a new assignment statement and make it the first statement in the\n-   function.  PARM1 is the lhs of the assignment and VAL is the rhs. */\n-static void\n-constant_val_insert (tree parm1 ATTRIBUTE_UNUSED, tree val ATTRIBUTE_UNUSED)\n-{\n-  gimple init_stmt = NULL;\n-  edge e_step;\n-\n-  init_stmt = gimple_build_assign (parm1, val);\n-  gcc_assert (init_stmt);\n-  e_step = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun));\n-  gsi_insert_on_edge_immediate (e_step, init_stmt);\n-}\n-\n /* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n    Return the tree.  */\n static tree\n@@ -403,21 +389,6 @@ build_const_val (struct ipcp_lattice *lat, tree tree_type)\n   return val;\n }\n \n-/* Build the tree representing the constant and call constant_val_insert().  */\n-static void\n-ipcp_propagate_one_const (struct cgraph_node *node, int param,\n-\t\t\t  struct ipcp_lattice *lat)\n-{\n-  tree const_val;\n-  tree parm_tree;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"propagating const to %s\\n\", cgraph_node_name (node));\n-  parm_tree = ipa_get_ith_param (IPA_NODE_REF (node), param);\n-  const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n-  constant_val_insert (parm_tree, const_val);\n-}\n-\n /* Compute the proper scale for NODE.  It is the ratio between the number of\n    direct calls (represented on the incoming cgraph_edges) and sum of all\n    invocations of NODE (represented as count in cgraph_node).  */\n@@ -755,33 +726,19 @@ ipcp_print_profile_data (FILE * f)\n    PARM_TREE is the formal parameter found to be constant.  LAT represents the\n    constant.  */\n static struct ipa_replace_map *\n-ipcp_create_replace_map (struct function *func, tree parm_tree,\n-\t\t\t struct ipcp_lattice *lat)\n+ipcp_create_replace_map (tree parm_tree, struct ipcp_lattice *lat)\n {\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n   replace_map = XCNEW (struct ipa_replace_map);\n-  if (is_gimple_reg (parm_tree)\n-      && gimple_default_def (func, parm_tree)\n-      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func,\n-\t\t\t\t\t\t\t\t parm_tree)))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"replacing param with const\\n\");\n-      const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n-      replace_map->old_tree =gimple_default_def (func, parm_tree);\n-      replace_map->new_tree = const_val;\n-      replace_map->replace_p = true;\n-      replace_map->ref_p = false;\n-    }\n-  else\n-    {\n-      replace_map->old_tree = NULL;\n-      replace_map->new_tree = NULL;\n-      replace_map->replace_p = false;\n-      replace_map->ref_p = false;\n-    }\n+  if (dump_file)\n+    fprintf (dump_file, \"replacing param with const\\n\");\n+  const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n+  replace_map->old_tree = parm_tree;\n+  replace_map->new_tree = const_val;\n+  replace_map->replace_p = true;\n+  replace_map->ref_p = false;\n \n   return replace_map;\n }\n@@ -939,8 +896,7 @@ ipcp_insert_stage (void)\n \t    {\n \t      parm_tree = ipa_get_ith_param (info, i);\n \t      replace_param =\n-\t\tipcp_create_replace_map (DECL_STRUCT_FUNCTION (node->decl),\n-\t\t\t\t\t parm_tree, lat);\n+\t\tipcp_create_replace_map (parm_tree, lat);\n \t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n \t    }\n \t}\n@@ -963,36 +919,8 @@ ipcp_insert_stage (void)\n \tfprintf (dump_file, \"versioned function %s\\n\",\n \t\t cgraph_node_name (node));\n       ipcp_init_cloned_node (node, node1);\n-      if (const_param > 0)\n-\t{\n-\t  push_cfun (DECL_STRUCT_FUNCTION (node1->decl));\n-\t  gimple_register_cfg_hooks ();\n-\t  current_function_decl = node1->decl;\n-\n-\t  for (i = 0; i < count; i++)\n-\t    {\n-\t      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t      if (ipcp_lat_is_insertable (lat))\n-\t\t{\n-\t\t  parm_tree = ipa_get_ith_param (info, i);\n-\t\t  if (!is_gimple_reg (parm_tree))\n-\t\t    ipcp_propagate_one_const (node1, i, lat);\n-\t\t}\n-\t    }\n-\t  if (gimple_in_ssa_p (cfun))\n-\t    {\n-\t      update_ssa (TODO_update_ssa);\n-#ifdef   ENABLE_CHECKING\n-\t      verify_ssa (true);\n-#endif\n-\t    }\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\t  free_dominance_info (CDI_POST_DOMINATORS);\n-\t  pop_cfun ();\n-\t  current_function_decl = NULL;\n-\t  /* We've possibly introduced direct calls.  */\n-\t  ipcp_update_cloned_node (node1);\n-\t}\n+      /* We've possibly introduced direct calls.  */\n+      ipcp_update_cloned_node (node1);\n \n       if (dump_file)\n \tdump_function_to_file (node1->decl, dump_file, dump_flags);"}, {"sha": "2f5994181b1a91e244b6c6830bd42a52142b50d0", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "patch": "@@ -951,6 +951,7 @@ decode_options (unsigned int argc, const char **argv)\n   flag_tree_builtin_call_dce = opt2;\n   flag_tree_pre = opt2;\n       flag_tree_switch_conversion = 1;\n+      flag_ipa_cp = opt2;\n \n       /* Allow more virtual operators to increase alias precision.  */\n "}, {"sha": "7be46cfe7c1e1bb25a958fa966a7c837c8861ea1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 75, "deletions": 58, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0f1961a2c99fcfaf5b124d44f8f69a4ba095fa5e", "patch": "@@ -1856,10 +1856,52 @@ self_inlining_addr_expr (tree value, tree fn)\n }\n \n static void\n+insert_init_stmt (basic_block bb, gimple init_stmt)\n+{\n+  gimple_stmt_iterator si = gsi_last_bb (bb);\n+  gimple_stmt_iterator i;\n+  gimple_seq seq = gimple_seq_alloc ();\n+  struct gimplify_ctx gctx;\n+\n+  push_gimplify_context (&gctx);\n+\n+  i = gsi_start (seq);\n+  gimple_regimplify_operands (init_stmt, &i);\n+\n+  if (gimple_in_ssa_p (cfun)\n+      && init_stmt\n+      && !gimple_seq_empty_p (seq))\n+    {\n+      /* The replacement can expose previously unreferenced\n+\t variables.  */\n+      for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n+\tfind_new_referenced_vars (gsi_stmt (i));\n+\n+      /* Insert the gimplified sequence needed for INIT_STMT\n+\t after SI.  INIT_STMT will be inserted after SEQ.  */\n+      gsi_insert_seq_after (&si, seq, GSI_NEW_STMT);\n+     }\n+\n+  pop_gimplify_context (NULL);\n+\n+  /* If VAR represents a zero-sized variable, it's possible that the\n+     assignment statement may result in no gimple statements.  */\n+  if (init_stmt)\n+    gsi_insert_after (&si, init_stmt, GSI_NEW_STMT);\n+\n+  if (gimple_in_ssa_p (cfun))\n+    for (;!gsi_end_p (si); gsi_next (&si))\n+      mark_symbols_for_renaming (gsi_stmt (si));\n+}\n+\n+/* Initialize parameter P with VALUE.  If needed, produce init statement\n+   at the end of BB.  When BB is NULL, we return init statement to be\n+   output later.  */\n+static gimple\n setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t\t     basic_block bb, tree *vars)\n {\n-  gimple init_stmt;\n+  gimple init_stmt = NULL;\n   tree var;\n   tree rhs = value;\n   tree def = (gimple_in_ssa_p (cfun)\n@@ -1902,7 +1944,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t  && ! self_inlining_addr_expr (value, fn))\n \t{\n \t  insert_decl_map (id, p, value);\n-\t  return;\n+\t  return NULL;\n \t}\n     }\n \n@@ -1960,27 +2002,25 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n       && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def))\n     {\n       insert_decl_map (id, def, rhs);\n-      return;\n+      return NULL;\n     }\n \n   /* If the value of argument is never used, don't care about initializing\n      it.  */\n   if (gimple_in_ssa_p (cfun) && !def && is_gimple_reg (p))\n     {\n       gcc_assert (!value || !TREE_SIDE_EFFECTS (value));\n-      return;\n+      return NULL;\n     }\n \n   /* Initialize this VAR_DECL from the equivalent argument.  Convert\n      the argument to the proper type in case it was promoted.  */\n   if (value)\n     {\n-      gimple_stmt_iterator si = gsi_last_bb (bb);\n-\n       if (rhs == error_mark_node)\n \t{\n \t  insert_decl_map (id, p, var);\n-\t  return;\n+\t  return NULL;\n \t}\n \n       STRIP_USELESS_TYPE_CONVERSION (rhs);\n@@ -1997,51 +2037,10 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n       else\n         init_stmt = gimple_build_assign (var, rhs);\n \n-      /* If we did not create a gimple value and we did not create a gimple\n-\t cast of a gimple value, then we will need to gimplify INIT_STMT\n-\t at the end.  Note that is_gimple_cast only checks the outer\n-\t tree code, not its operand.  Thus the explicit check that its\n-\t operand is a gimple value.  */\n-      if ((!is_gimple_val (rhs)\n-\t  && (!is_gimple_cast (rhs)\n-\t      || !is_gimple_val (TREE_OPERAND (rhs, 0))))\n-\t  || !is_gimple_reg (var))\n-\t{\n-\t  gimple_stmt_iterator i;\n-\t  gimple_seq seq = gimple_seq_alloc ();\n-          struct gimplify_ctx gctx;\n-\n-\t  push_gimplify_context (&gctx);\n-\n-\t  i = gsi_start (seq);\n-\t  gimple_regimplify_operands (init_stmt, &i);\n-\n-\t  if (gimple_in_ssa_p (cfun)\n-              && init_stmt\n-\t      && !gimple_seq_empty_p (seq))\n-\t    {\n-\t      /* The replacement can expose previously unreferenced\n-\t\t variables.  */\n-\t      for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n-\t\tfind_new_referenced_vars (gsi_stmt (i));\n-\n-\t      /* Insert the gimplified sequence needed for INIT_STMT\n-\t\t after SI.  INIT_STMT will be inserted after SEQ.  */\n-\t      gsi_insert_seq_after (&si, seq, GSI_NEW_STMT);\n-\t     }\n-\n-\t  pop_gimplify_context (NULL);\n-\t}\n-\n-      /* If VAR represents a zero-sized variable, it's possible that the\n-\t assignment statement may result in no gimple statements.  */\n-      if (init_stmt)\n-        gsi_insert_after (&si, init_stmt, GSI_NEW_STMT);\n-\n-      if (gimple_in_ssa_p (cfun))\n-\tfor (;!gsi_end_p (si); gsi_next (&si))\n-\t  mark_symbols_for_renaming (gsi_stmt (si));\n+      if (bb && init_stmt)\n+        insert_init_stmt (bb, init_stmt);\n     }\n+  return init_stmt;\n }\n \n /* Generate code to initialize the parameters of the function at the\n@@ -4149,8 +4148,11 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   unsigned i;\n   struct ipa_replace_map *replace_info;\n   basic_block old_entry_block;\n+  VEC (gimple, heap) *init_stmts = VEC_alloc (gimple, heap, 10);\n+\n   tree t_step;\n   tree old_current_function_decl = current_function_decl;\n+  tree vars = NULL_TREE;\n \n   gcc_assert (TREE_CODE (old_decl) == FUNCTION_DECL\n \t      && TREE_CODE (new_decl) == FUNCTION_DECL);\n@@ -4207,10 +4209,16 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n     DECL_ARGUMENTS (new_decl) =\n       copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id);\n   \n+  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n+  \n+  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n+  number_blocks (id.dst_fn);\n+  \n   /* If there's a tree_map, prepare for substitution.  */\n   if (tree_map)\n     for (i = 0; i < VARRAY_ACTIVE_SIZE (tree_map); i++)\n       {\n+\tgimple init;\n \treplace_info\n \t  = (struct ipa_replace_map *) VARRAY_GENERIC_PTR (tree_map, i);\n \tif (replace_info->replace_p)\n@@ -4223,16 +4231,17 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n \t\tif (TREE_CODE (op) == VAR_DECL)\n \t\t  add_referenced_var (op);\n \t      }\n-\t    insert_decl_map (&id, replace_info->old_tree,\n-\t\t\t     replace_info->new_tree);\n+\t    gcc_assert (TREE_CODE (replace_info->old_tree) == PARM_DECL);\n+\t    init = setup_one_parameter (&id, replace_info->old_tree,\n+\t    \t\t\t        replace_info->new_tree, id.src_fn,\n+\t\t\t\t        NULL,\n+\t\t\t\t        &vars);\n+\t    if (init)\n+\t      VEC_safe_push (gimple, heap, init_stmts, init);\n \t  }\n       }\n   \n-  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n-  \n-  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n-  number_blocks (id.dst_fn);\n-  \n+  declare_inline_vars (DECL_INITIAL (new_decl), vars);\n   if (DECL_STRUCT_FUNCTION (old_decl)->local_decls != NULL_TREE)\n     /* Add local vars.  */\n     for (t_step = DECL_STRUCT_FUNCTION (old_decl)->local_decls;\n@@ -4260,6 +4269,13 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (new_decl);\n \n+  if (VEC_length (gimple, init_stmts))\n+    {\n+      basic_block bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+      while (VEC_length (gimple, init_stmts))\n+\tinsert_init_stmt (bb, VEC_pop (gimple, init_stmts));\n+    }\n+\n   /* Clean up.  */\n   pointer_map_destroy (id.decl_map);\n   if (!update_clones)\n@@ -4284,6 +4300,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n     }\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n+  VEC_free (gimple, heap, init_stmts);\n   pop_cfun ();\n   current_function_decl = old_current_function_decl;\n   gcc_assert (!current_function_decl"}]}