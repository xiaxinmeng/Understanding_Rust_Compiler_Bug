{"sha": "3e94065c619b935e1d9e6881a84aadc6ff8b759b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U5NDA2NWM2MTliOTM1ZTFkOWU2ODgxYTg0YWFkYzZmZjhiNzU5Yg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-05-01T13:11:36Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-05-01T13:11:36Z"}, "message": "re PR fortran/31732 (Assignment to array slice affects whole array)\n\n2007-05-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n        PR fortran/31732\n\t* dependency.c (gfc_full_array_ref_p):  If the reference is\n\tto a single element, check that the array has a single\n\telement and that the correct element is referenced.\n\n2007-05-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n        PR fortran/31732\n\t* gfortran.dg/array_memset_2:  New test case.\n\nFrom-SVN: r124326", "tree": {"sha": "8f9ca6c80481c38590f0340e4ff70275e32c2d6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f9ca6c80481c38590f0340e4ff70275e32c2d6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e94065c619b935e1d9e6881a84aadc6ff8b759b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e94065c619b935e1d9e6881a84aadc6ff8b759b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e94065c619b935e1d9e6881a84aadc6ff8b759b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e94065c619b935e1d9e6881a84aadc6ff8b759b/comments", "author": null, "committer": null, "parents": [{"sha": "617428e9f67b900a68a948163d4ec06b0cb477ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617428e9f67b900a68a948163d4ec06b0cb477ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617428e9f67b900a68a948163d4ec06b0cb477ed"}], "stats": {"total": 68, "additions": 68, "deletions": 0}, "files": [{"sha": "66e61587fc095a2e4a46fa62cdccc6fd2798d44a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3e94065c619b935e1d9e6881a84aadc6ff8b759b", "patch": "@@ -1,3 +1,10 @@\n+2007-05-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+        PR fortran/31732\n+\t* dependency.c (gfc_full_array_ref_p):  If the reference is\n+\tto a single element, check that the array has a single\n+\telement and that the correct element is referenced.\n+\n 2007-05-01  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* intrinsic.c (add_functions): Fixed ELEMENTAL specifications."}, {"sha": "bdda6d871d3febf5ac2c0a2cf0cf6b1f8ffc817b", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=3e94065c619b935e1d9e6881a84aadc6ff8b759b", "patch": "@@ -1126,6 +1126,24 @@ gfc_full_array_ref_p (gfc_ref *ref)\n \n   for (i = 0; i < ref->u.ar.dimen; i++)\n     {\n+      /* If we have a single element in the reference, we need to check\n+\t that the array has a single element and that we actually reference\n+\t the correct element.  */\n+      if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT)\n+\t{\n+\t  if (!ref->u.ar.as\n+\t      || !ref->u.ar.as->lower[i]\n+\t      || !ref->u.ar.as->upper[i]\n+\t      || gfc_dep_compare_expr (ref->u.ar.as->lower[i],\n+\t\t\t\t       ref->u.ar.as->upper[i])\n+\t      || !ref->u.ar.start[i]\n+\t      || gfc_dep_compare_expr (ref->u.ar.start[i],\n+\t\t\t\t       ref->u.ar.as->lower[i]))\n+\t    return false;\n+\t  else\n+\t    continue;\n+\t}\n+\n       /* Check the lower bound.  */\n       if (ref->u.ar.start[i]\n \t  && (!ref->u.ar.as"}, {"sha": "82c9109817f309e7e2c820cc724295583f952793", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3e94065c619b935e1d9e6881a84aadc6ff8b759b", "patch": "@@ -1,3 +1,8 @@\n+2007-05-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+        PR fortran/31732\n+\t* gfortran.dg/array_memset_2:  New test case.\n+\n 2007-05-01  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR testsuite/31615"}, {"sha": "58ce8fe6442b82ea60a1f8ca576f90afdea51cfe", "filename": "gcc/testsuite/gfortran.dg/array_memset_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memset_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e94065c619b935e1d9e6881a84aadc6ff8b759b/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memset_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memset_2.f90?ref=3e94065c619b935e1d9e6881a84aadc6ff8b759b", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+\n+module foo\n+contains\n+  subroutine bar(a)\n+    real, dimension(:,:) :: a\n+    a(1,:) = 0.\n+  end subroutine bar\n+end module foo\n+\n+program test\n+  use foo\n+  implicit none\n+  real, dimension (2,2) :: a, d, e\n+  real, dimension (1,2) :: b\n+  real, dimension (2) :: c\n+  data a, d, e /12*1.0/\n+  data b /2*1.0/\n+  data c /2*1.0/\n+\n+  a(1,:) = 0.    ! This can't be optimized to a memset.\n+  b(1,:) = 0.    ! This is optimized to memset.\n+  c = 0.         ! This is optimized to memset.\n+  d(:,1) = 0.    ! This can't be otimized to a memset.\n+  call bar(e)\n+\n+  if (any(a /= reshape((/ 0.0, 1.0, 0.0, 1.0/), shape(a)))) call abort\n+  if (any(b /= 0.)) call abort\n+  if (any(c /= 0.)) call abort\n+  if (any(d /= reshape((/ 0.0, 0.0, 1.0, 1.0/), shape(d)))) call abort\n+  if (any(e /= reshape((/ 0.0, 1.0, 0.0, 1.0/), shape(e)))) call abort\n+\n+end program\n+\n+! { dg-final { scan-tree-dump-times \"memset\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+! { dg-final { cleanup-modules \"foo\" } }"}]}