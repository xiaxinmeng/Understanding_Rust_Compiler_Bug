{"sha": "4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZmNWFhMGMwNWIzYTQyYTQ1NGQ3NjI3NWNmN2UxZjE3Y2JiNzQxMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2019-07-04T08:05:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-04T08:05:31Z"}, "message": "[Ada] CCG: reduce generated temporaries\n\n2019-07-04  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb (In_Place_Assign_OK): Moved to top level and add\n\tsupport for record aggregates.\n\t(Component_Check): Use Is_CCG_Supported_Aggregate instead of a\n\tsimilar local predicate.\n\t(Convert_To_Assignments): Take advantage of In_Place_Assign_OK\n\tpredicate when possible.\n\t(Is_CCG_Supported_Aggregate): Return False for records with\n\trepresentation clauses and fix the logic for dealing with nested\n\taggregates.\n\nFrom-SVN: r273049", "tree": {"sha": "e9397beeccbdd5165514d77a067bd2c712a74efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9397beeccbdd5165514d77a067bd2c712a74efa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8be36d2873dd1cf9586790ff6c91dc17f37daa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8be36d2873dd1cf9586790ff6c91dc17f37daa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8be36d2873dd1cf9586790ff6c91dc17f37daa6"}], "stats": {"total": 585, "additions": 296, "deletions": 289}, "files": [{"sha": "46f30aa87fe54031dbddfa80acc6ab72385003c3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412", "patch": "@@ -1,3 +1,15 @@\n+2019-07-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_aggr.adb (In_Place_Assign_OK): Moved to top level and add\n+\tsupport for record aggregates.\n+\t(Component_Check): Use Is_CCG_Supported_Aggregate instead of a\n+\tsimilar local predicate.\n+\t(Convert_To_Assignments): Take advantage of In_Place_Assign_OK\n+\tpredicate when possible.\n+\t(Is_CCG_Supported_Aggregate): Return False for records with\n+\trepresentation clauses and fix the logic for dealing with nested\n+\taggregates.\n+\n 2019-07-04  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* opt.adb (Set_Config_Switches): Keep assertions policy as"}, {"sha": "7099d93691cea8e3a68ca9098c8194a0967ad74e", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 284, "deletions": 289, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=4ff5aa0c05b3a42a454d76275cf7e1f17cbb7412", "patch": "@@ -217,6 +217,11 @@ package body Exp_Aggr is\n    --  defaults. An aggregate for a type with mutable components must be\n    --  expanded into individual assignments.\n \n+   function In_Place_Assign_OK (N : Node_Id) return Boolean;\n+   --  Predicate to determine whether an aggregate assignment can be done in\n+   --  place, because none of the new values can depend on the components of\n+   --  the target of the assignment.\n+\n    procedure Initialize_Discriminants (N : Node_Id; Typ : Entity_Id);\n    --  If the type of the aggregate is a type extension with renamed discrimi-\n    --  nants, we must initialize the hidden discriminants of the parent.\n@@ -646,24 +651,8 @@ package body Exp_Aggr is\n          --  Checks 11: The C code generator cannot handle aggregates that are\n          --  not part of an object declaration.\n \n-         if Modify_Tree_For_C then\n-            declare\n-               Par : Node_Id := Parent (N);\n-\n-            begin\n-               --  Skip enclosing nested aggregates and their qualified\n-               --  expressions.\n-\n-               while Nkind (Par) = N_Aggregate\n-                 or else Nkind (Par) = N_Qualified_Expression\n-               loop\n-                  Par := Parent (Par);\n-               end loop;\n-\n-               if Nkind (Par) /= N_Object_Declaration then\n-                  return False;\n-               end if;\n-            end;\n+         if Modify_Tree_For_C and then not Is_CCG_Supported_Aggregate (N) then\n+            return False;\n          end if;\n \n          --  Checks on components\n@@ -4134,6 +4123,254 @@ package body Exp_Aggr is\n       Insert_Actions_After (Decl, Aggr_Code);\n    end Convert_Array_Aggr_In_Allocator;\n \n+   ------------------------\n+   -- In_Place_Assign_OK --\n+   ------------------------\n+\n+   function In_Place_Assign_OK (N : Node_Id) return Boolean is\n+      Is_Array : constant Boolean := Is_Array_Type (Etype (N));\n+\n+      Aggr_In : Node_Id;\n+      Aggr_Lo : Node_Id;\n+      Aggr_Hi : Node_Id;\n+      Obj_In  : Node_Id;\n+      Obj_Lo  : Node_Id;\n+      Obj_Hi  : Node_Id;\n+\n+      function Safe_Aggregate (Aggr : Node_Id) return Boolean;\n+      --  Check recursively that each component of a (sub)aggregate does not\n+      --  depend on the variable being assigned to.\n+\n+      function Safe_Component (Expr : Node_Id) return Boolean;\n+      --  Verify that an expression cannot depend on the variable being\n+      --  assigned to. Room for improvement here (but less than before).\n+\n+      --------------------\n+      -- Safe_Aggregate --\n+      --------------------\n+\n+      function Safe_Aggregate (Aggr : Node_Id) return Boolean is\n+         Expr : Node_Id;\n+\n+      begin\n+         if Nkind (Parent (Aggr)) = N_Iterated_Component_Association then\n+            return False;\n+         end if;\n+\n+         if Present (Expressions (Aggr)) then\n+            Expr := First (Expressions (Aggr));\n+            while Present (Expr) loop\n+               if Nkind (Expr) = N_Aggregate then\n+                  if not Safe_Aggregate (Expr) then\n+                     return False;\n+                  end if;\n+\n+               elsif not Safe_Component (Expr) then\n+                  return False;\n+               end if;\n+\n+               Next (Expr);\n+            end loop;\n+         end if;\n+\n+         if Present (Component_Associations (Aggr)) then\n+            Expr := First (Component_Associations (Aggr));\n+            while Present (Expr) loop\n+               if Nkind (Expression (Expr)) = N_Aggregate then\n+                  if not Safe_Aggregate (Expression (Expr)) then\n+                     return False;\n+                  end if;\n+\n+               --  If association has a box, no way to determine yet\n+               --  whether default can be assigned in place.\n+\n+               elsif Box_Present (Expr) then\n+                  return False;\n+\n+               elsif not Safe_Component (Expression (Expr)) then\n+                  return False;\n+               end if;\n+\n+               Next (Expr);\n+            end loop;\n+         end if;\n+\n+         return True;\n+      end Safe_Aggregate;\n+\n+      --------------------\n+      -- Safe_Component --\n+      --------------------\n+\n+      function Safe_Component (Expr : Node_Id) return Boolean is\n+         Comp : Node_Id := Expr;\n+\n+         function Check_Component (Comp : Node_Id) return Boolean;\n+         --  Do the recursive traversal, after copy\n+\n+         ---------------------\n+         -- Check_Component --\n+         ---------------------\n+\n+         function Check_Component (Comp : Node_Id) return Boolean is\n+         begin\n+            if Is_Overloaded (Comp) then\n+               return False;\n+            end if;\n+\n+            return Compile_Time_Known_Value (Comp)\n+\n+              or else (Is_Entity_Name (Comp)\n+                        and then Present (Entity (Comp))\n+                        and then Ekind (Entity (Comp)) not in Type_Kind\n+                        and then No (Renamed_Object (Entity (Comp))))\n+\n+              or else (Nkind (Comp) = N_Attribute_Reference\n+                        and then Check_Component (Prefix (Comp)))\n+\n+              or else (Nkind (Comp) in N_Binary_Op\n+                        and then Check_Component (Left_Opnd  (Comp))\n+                        and then Check_Component (Right_Opnd (Comp)))\n+\n+              or else (Nkind (Comp) in N_Unary_Op\n+                        and then Check_Component (Right_Opnd (Comp)))\n+\n+              or else (Nkind (Comp) = N_Selected_Component\n+                        and then Is_Array\n+                        and then Check_Component (Prefix (Comp)))\n+\n+              or else (Nkind_In (Comp, N_Unchecked_Type_Conversion,\n+                                 N_Type_Conversion)\n+                        and then Check_Component (Expression (Comp)));\n+         end Check_Component;\n+\n+      --  Start of processing for Safe_Component\n+\n+      begin\n+         --  If the component appears in an association that may correspond\n+         --  to more than one element, it is not analyzed before expansion\n+         --  into assignments, to avoid side effects. We analyze, but do not\n+         --  resolve the copy, to obtain sufficient entity information for\n+         --  the checks that follow. If component is overloaded we assume\n+         --  an unsafe function call.\n+\n+         if not Analyzed (Comp) then\n+            if Is_Overloaded (Expr) then\n+               return False;\n+\n+            elsif Nkind (Expr) = N_Aggregate\n+               and then not Is_Others_Aggregate (Expr)\n+            then\n+               return False;\n+\n+            elsif Nkind (Expr) = N_Allocator then\n+\n+               --  For now, too complex to analyze\n+\n+               return False;\n+\n+            elsif Nkind (Parent (Expr)) =\n+                    N_Iterated_Component_Association\n+            then\n+               --  Ditto for iterated component associations, which in\n+               --  general require an enclosing loop and involve nonstatic\n+               --  expressions.\n+\n+               return False;\n+            end if;\n+\n+            Comp := New_Copy_Tree (Expr);\n+            Set_Parent (Comp, Parent (Expr));\n+            Analyze (Comp);\n+         end if;\n+\n+         if Nkind (Comp) = N_Aggregate then\n+            return Safe_Aggregate (Comp);\n+         else\n+            return Check_Component (Comp);\n+         end if;\n+      end Safe_Component;\n+\n+   --  Start of processing for In_Place_Assign_OK\n+\n+   begin\n+      --  By-copy semantic cannot be guaranteed for controlled objects or\n+      --  objects with discriminants.\n+\n+      if Needs_Finalization (Etype (N))\n+        or else Has_Discriminants (Etype (N))\n+      then\n+         return False;\n+\n+      elsif Is_Array and then Present (Component_Associations (N)) then\n+\n+         --  On assignment, sliding can take place, so we cannot do the\n+         --  assignment in place unless the bounds of the aggregate are\n+         --  statically equal to those of the target.\n+\n+         --  If the aggregate is given by an others choice, the bounds are\n+         --  derived from the left-hand side, and the assignment is safe if\n+         --  the expression is.\n+\n+         if Is_Others_Aggregate (N) then\n+            return\n+              Safe_Component\n+               (Expression (First (Component_Associations (N))));\n+         end if;\n+\n+         Aggr_In := First_Index (Etype (N));\n+\n+         if Nkind (Parent (N)) = N_Assignment_Statement then\n+            Obj_In := First_Index (Etype (Name (Parent (N))));\n+\n+         else\n+            --  Context is an allocator. Check bounds of aggregate against\n+            --  given type in qualified expression.\n+\n+            pragma Assert (Nkind (Parent (Parent (N))) = N_Allocator);\n+            Obj_In := First_Index (Etype (Entity (Subtype_Mark (Parent (N)))));\n+         end if;\n+\n+         while Present (Aggr_In) loop\n+            Get_Index_Bounds (Aggr_In, Aggr_Lo, Aggr_Hi);\n+            Get_Index_Bounds (Obj_In, Obj_Lo, Obj_Hi);\n+\n+            if not Compile_Time_Known_Value (Aggr_Lo)\n+              or else not Compile_Time_Known_Value (Obj_Lo)\n+              or else not Compile_Time_Known_Value (Obj_Hi)\n+              or else Expr_Value (Aggr_Lo) /= Expr_Value (Obj_Lo)\n+            then\n+               return False;\n+\n+            --  For an assignment statement we require static matching of\n+            --  bounds. Ditto for an allocator whose qualified expression\n+            --  is a constrained type. If the expression in the allocator\n+            --  is an unconstrained array, we accept an upper bound that\n+            --  is not static, to allow for nonstatic expressions of the\n+            --  base type. Clearly there are further possibilities (with\n+            --  diminishing returns) for safely building arrays in place\n+            --  here.\n+\n+            elsif Nkind (Parent (N)) = N_Assignment_Statement\n+              or else Is_Constrained (Etype (Parent (N)))\n+            then\n+               if not Compile_Time_Known_Value (Aggr_Hi)\n+                 or else Expr_Value (Aggr_Hi) /= Expr_Value (Obj_Hi)\n+               then\n+                  return False;\n+               end if;\n+            end if;\n+\n+            Next_Index (Aggr_In);\n+            Next_Index (Obj_In);\n+         end loop;\n+      end if;\n+\n+      --  Now check the component values themselves\n+\n+      return Safe_Aggregate (N);\n+   end In_Place_Assign_OK;\n+\n    ----------------------------\n    -- Convert_To_Assignments --\n    ----------------------------\n@@ -4232,10 +4469,11 @@ package body Exp_Aggr is\n          Establish_Transient_Scope (N, Manage_Sec_Stack => False);\n       end if;\n \n-      --  If the aggregate is nonlimited, create a temporary. If it is limited\n-      --  and context is an assignment, this is a subaggregate for an enclosing\n-      --  aggregate being expanded. It must be built in place, so use target of\n-      --  the current assignment.\n+      --  If the aggregate is nonlimited, create a temporary since aggregates\n+      --  have \"by copy\" semantic. If it is limited and context is an\n+      --  assignment, this is a subaggregate for an enclosing aggregate being\n+      --  expanded. It must be built in place, so use target of the current\n+      --  assignment.\n \n       if Is_Limited_Type (Typ)\n         and then Nkind (Parent (N)) = N_Assignment_Statement\n@@ -4245,16 +4483,14 @@ package body Exp_Aggr is\n            Build_Record_Aggr_Code (N, Typ, Target_Expr));\n          Rewrite (Parent (N), Make_Null_Statement (Loc));\n \n-      --  Generating C, do not declare a temporary to initialize an aggregate\n-      --  assigned to Out or In_Out parameters whose type has no discriminants.\n-      --  This avoids stack overflow errors at run time.\n+      --  Do not declare a temporary to initialize an aggregate assigned to an\n+      --  identifier when in place assignment is possible preserving the\n+      --  by-copy semantic of aggregates. This avoids large stack usage and\n+      --  generates more efficient code.\n \n-      elsif Modify_Tree_For_C\n-        and then Nkind (Parent (N)) = N_Assignment_Statement\n+      elsif Nkind (Parent (N)) = N_Assignment_Statement\n         and then Nkind (Name (Parent (N))) = N_Identifier\n-        and then Ekind_In (Entity (Name (Parent (N))), E_Out_Parameter,\n-                                                       E_In_Out_Parameter)\n-        and then not Has_Discriminants (Etype (Entity (Name (Parent (N)))))\n+        and then In_Place_Assign_OK (N)\n       then\n          Target_Expr := New_Copy_Tree (Name (Parent (N)));\n          Insert_Actions (Parent (N),\n@@ -4945,11 +5181,6 @@ package body Exp_Aggr is\n       --  subaggregate we start the computation from. Dim is the dimension\n       --  corresponding to the subaggregate.\n \n-      function In_Place_Assign_OK return Boolean;\n-      --  Simple predicate to determine whether an aggregate assignment can\n-      --  be done in place, because none of the new values can depend on the\n-      --  components of the target of the assignment.\n-\n       procedure Others_Check (Sub_Aggr : Node_Id; Dim : Pos);\n       --  Checks that if an others choice is present in any subaggregate, no\n       --  aggregate index is outside the bounds of the index constraint.\n@@ -5437,243 +5668,6 @@ package body Exp_Aggr is\n          end if;\n       end Compute_Others_Present;\n \n-      ------------------------\n-      -- In_Place_Assign_OK --\n-      ------------------------\n-\n-      function In_Place_Assign_OK return Boolean is\n-         Aggr_In : Node_Id;\n-         Aggr_Lo : Node_Id;\n-         Aggr_Hi : Node_Id;\n-         Obj_In  : Node_Id;\n-         Obj_Lo  : Node_Id;\n-         Obj_Hi  : Node_Id;\n-\n-         function Safe_Aggregate (Aggr : Node_Id) return Boolean;\n-         --  Check recursively that each component of a (sub)aggregate does not\n-         --  depend on the variable being assigned to.\n-\n-         function Safe_Component (Expr : Node_Id) return Boolean;\n-         --  Verify that an expression cannot depend on the variable being\n-         --  assigned to. Room for improvement here (but less than before).\n-\n-         --------------------\n-         -- Safe_Aggregate --\n-         --------------------\n-\n-         function Safe_Aggregate (Aggr : Node_Id) return Boolean is\n-            Expr : Node_Id;\n-\n-         begin\n-            if Nkind (Parent (Aggr)) = N_Iterated_Component_Association then\n-               return False;\n-            end if;\n-\n-            if Present (Expressions (Aggr)) then\n-               Expr := First (Expressions (Aggr));\n-               while Present (Expr) loop\n-                  if Nkind (Expr) = N_Aggregate then\n-                     if not Safe_Aggregate (Expr) then\n-                        return False;\n-                     end if;\n-\n-                  elsif not Safe_Component (Expr) then\n-                     return False;\n-                  end if;\n-\n-                  Next (Expr);\n-               end loop;\n-            end if;\n-\n-            if Present (Component_Associations (Aggr)) then\n-               Expr := First (Component_Associations (Aggr));\n-               while Present (Expr) loop\n-                  if Nkind (Expression (Expr)) = N_Aggregate then\n-                     if not Safe_Aggregate (Expression (Expr)) then\n-                        return False;\n-                     end if;\n-\n-                  --  If association has a box, no way to determine yet\n-                  --  whether default can be assigned in place.\n-\n-                  elsif Box_Present (Expr) then\n-                     return False;\n-\n-                  elsif not Safe_Component (Expression (Expr)) then\n-                     return False;\n-                  end if;\n-\n-                  Next (Expr);\n-               end loop;\n-            end if;\n-\n-            return True;\n-         end Safe_Aggregate;\n-\n-         --------------------\n-         -- Safe_Component --\n-         --------------------\n-\n-         function Safe_Component (Expr : Node_Id) return Boolean is\n-            Comp : Node_Id := Expr;\n-\n-            function Check_Component (Comp : Node_Id) return Boolean;\n-            --  Do the recursive traversal, after copy\n-\n-            ---------------------\n-            -- Check_Component --\n-            ---------------------\n-\n-            function Check_Component (Comp : Node_Id) return Boolean is\n-            begin\n-               if Is_Overloaded (Comp) then\n-                  return False;\n-               end if;\n-\n-               return Compile_Time_Known_Value (Comp)\n-\n-                 or else (Is_Entity_Name (Comp)\n-                           and then Present (Entity (Comp))\n-                           and then No (Renamed_Object (Entity (Comp))))\n-\n-                 or else (Nkind (Comp) = N_Attribute_Reference\n-                           and then Check_Component (Prefix (Comp)))\n-\n-                 or else (Nkind (Comp) in N_Binary_Op\n-                           and then Check_Component (Left_Opnd  (Comp))\n-                           and then Check_Component (Right_Opnd (Comp)))\n-\n-                 or else (Nkind (Comp) in N_Unary_Op\n-                           and then Check_Component (Right_Opnd (Comp)))\n-\n-                 or else (Nkind (Comp) = N_Selected_Component\n-                           and then Check_Component (Prefix (Comp)))\n-\n-                 or else (Nkind_In (Comp, N_Unchecked_Type_Conversion,\n-                                    N_Type_Conversion)\n-                           and then Check_Component (Expression (Comp)));\n-            end Check_Component;\n-\n-         --  Start of processing for Safe_Component\n-\n-         begin\n-            --  If the component appears in an association that may correspond\n-            --  to more than one element, it is not analyzed before expansion\n-            --  into assignments, to avoid side effects. We analyze, but do not\n-            --  resolve the copy, to obtain sufficient entity information for\n-            --  the checks that follow. If component is overloaded we assume\n-            --  an unsafe function call.\n-\n-            if not Analyzed (Comp) then\n-               if Is_Overloaded (Expr) then\n-                  return False;\n-\n-               elsif Nkind (Expr) = N_Aggregate\n-                  and then not Is_Others_Aggregate (Expr)\n-               then\n-                  return False;\n-\n-               elsif Nkind (Expr) = N_Allocator then\n-\n-                  --  For now, too complex to analyze\n-\n-                  return False;\n-\n-               elsif Nkind (Parent (Expr)) =\n-                       N_Iterated_Component_Association\n-               then\n-                  --  Ditto for iterated component associations, which in\n-                  --  general require an enclosing loop and involve nonstatic\n-                  --  expressions.\n-\n-                  return False;\n-               end if;\n-\n-               Comp := New_Copy_Tree (Expr);\n-               Set_Parent (Comp, Parent (Expr));\n-               Analyze (Comp);\n-            end if;\n-\n-            if Nkind (Comp) = N_Aggregate then\n-               return Safe_Aggregate (Comp);\n-            else\n-               return Check_Component (Comp);\n-            end if;\n-         end Safe_Component;\n-\n-      --  Start of processing for In_Place_Assign_OK\n-\n-      begin\n-         if Present (Component_Associations (N)) then\n-\n-            --  On assignment, sliding can take place, so we cannot do the\n-            --  assignment in place unless the bounds of the aggregate are\n-            --  statically equal to those of the target.\n-\n-            --  If the aggregate is given by an others choice, the bounds are\n-            --  derived from the left-hand side, and the assignment is safe if\n-            --  the expression is.\n-\n-            if Is_Others_Aggregate (N) then\n-               return\n-                 Safe_Component\n-                  (Expression (First (Component_Associations (N))));\n-            end if;\n-\n-            Aggr_In := First_Index (Etype (N));\n-\n-            if Nkind (Parent (N)) = N_Assignment_Statement then\n-               Obj_In  := First_Index (Etype (Name (Parent (N))));\n-\n-            else\n-               --  Context is an allocator. Check bounds of aggregate against\n-               --  given type in qualified expression.\n-\n-               pragma Assert (Nkind (Parent (Parent (N))) = N_Allocator);\n-               Obj_In :=\n-                 First_Index (Etype (Entity (Subtype_Mark (Parent (N)))));\n-            end if;\n-\n-            while Present (Aggr_In) loop\n-               Get_Index_Bounds (Aggr_In, Aggr_Lo, Aggr_Hi);\n-               Get_Index_Bounds (Obj_In, Obj_Lo, Obj_Hi);\n-\n-               if not Compile_Time_Known_Value (Aggr_Lo)\n-                 or else not Compile_Time_Known_Value (Obj_Lo)\n-                 or else not Compile_Time_Known_Value (Obj_Hi)\n-                 or else Expr_Value (Aggr_Lo) /= Expr_Value (Obj_Lo)\n-               then\n-                  return False;\n-\n-               --  For an assignment statement we require static matching of\n-               --  bounds. Ditto for an allocator whose qualified expression\n-               --  is a constrained type. If the expression in the allocator\n-               --  is an unconstrained array, we accept an upper bound that\n-               --  is not static, to allow for nonstatic expressions of the\n-               --  base type. Clearly there are further possibilities (with\n-               --  diminishing returns) for safely building arrays in place\n-               --  here.\n-\n-               elsif Nkind (Parent (N)) = N_Assignment_Statement\n-                 or else Is_Constrained (Etype (Parent (N)))\n-               then\n-                  if not Compile_Time_Known_Value (Aggr_Hi)\n-                    or else Expr_Value (Aggr_Hi) /= Expr_Value (Obj_Hi)\n-                  then\n-                     return False;\n-                  end if;\n-               end if;\n-\n-               Next_Index (Aggr_In);\n-               Next_Index (Obj_In);\n-            end loop;\n-         end if;\n-\n-         --  Now check the component values themselves\n-\n-         return Safe_Aggregate (N);\n-      end In_Place_Assign_OK;\n-\n       ------------------\n       -- Others_Check --\n       ------------------\n@@ -6256,11 +6250,11 @@ package body Exp_Aggr is\n       else\n          Maybe_In_Place_OK :=\n           (Nkind (Parent (N)) = N_Assignment_Statement\n-            and then In_Place_Assign_OK)\n+            and then In_Place_Assign_OK (N))\n \n             or else\n              (Nkind (Parent (Parent (N))) = N_Allocator\n-              and then In_Place_Assign_OK);\n+              and then In_Place_Assign_OK (N));\n       end if;\n \n       --  If this is an array of tasks, it will be expanded into build-in-place\n@@ -7686,30 +7680,31 @@ package body Exp_Aggr is\n    function Is_CCG_Supported_Aggregate\n      (N : Node_Id) return Boolean\n    is\n-      In_Obj_Decl : Boolean := False;\n-      P           : Node_Id := Parent (N);\n+      P : Node_Id := Parent (N);\n \n    begin\n-      while Present (P) loop\n-         if Nkind (P) = N_Object_Declaration then\n-            In_Obj_Decl := True;\n-         end if;\n+      --  Aggregates are not supported for non standard rep clauses since\n+      --  they may lead to extra padding fields in CCG.\n+\n+      if Ekind (Etype (N)) in Record_Kind\n+        and then Has_Non_Standard_Rep (Etype (N))\n+      then\n+         return False;\n+      end if;\n \n+      while Present (P) and then Nkind (P) = N_Aggregate loop\n          P := Parent (P);\n       end loop;\n \n       --  Cases where aggregates are supported by the CCG backend\n \n-      if In_Obj_Decl then\n-         if Nkind (Parent (N)) = N_Object_Declaration then\n-            return True;\n+      if Nkind (P) = N_Object_Declaration then\n+         return True;\n \n-         elsif Nkind (Parent (N)) = N_Qualified_Expression\n-            and then Nkind_In (Parent (Parent (N)), N_Allocator,\n-                                                    N_Object_Declaration)\n-         then\n-            return True;\n-         end if;\n+      elsif Nkind (P) = N_Qualified_Expression\n+        and then Nkind_In (Parent (P), N_Allocator, N_Object_Declaration)\n+      then\n+         return True;\n       end if;\n \n       return False;"}]}