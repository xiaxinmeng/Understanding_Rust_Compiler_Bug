{"sha": "6fd21094e5a9d8517b00bffa08f132759baefbbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZkMjEwOTRlNWE5ZDg1MTdiMDBiZmZhMDhmMTMyNzU5YmFlZmJiYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-11T14:37:57Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-11T14:37:57Z"}, "message": "rtlanal.c (insn_rtx_cost): New function, moved and renamed from combine.c's combine_insn_cost.\n\n\n\t* rtlanal.c (insn_rtx_cost): New function, moved and renamed from\n\tcombine.c's combine_insn_cost.\n\t* rtl.h (insn_rtx_cost): Prototype here.\n\t* combine.c (combine_insn_cost): Delete function.\n\t(combine_validate_cost): Update callers of combine_insn_cost to\n\tcall insn_rtx_cost instead.\n\t(combine_instructions): Likewise.  Use NONJUMP_INSN_P to avoid\n\trequesting the rtx_cost of call and/or jump instructions.\n\n\t* ifcvt.c (total_bb_rtx_cost): Use insn_rtx_cost instead of calling\n\trtx_cost directly.  Don't request/use the cost of call or jump\n\tinstructions.  Return -1 if the cost of any instruction can't be\n\tdetermined (or the BB contains a function call).\n\t(find_if_case_1): Abort transformation if total_bb_rtx_cost returns\n\t-1 (i.e. can't determine the cost of any instruction or the basic\n\tblock contains a subroutine call).\n\t(find_if_case_2): Likewise.\n\nFrom-SVN: r84513", "tree": {"sha": "ad634004c869136a8ba76616632680e13bc31501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad634004c869136a8ba76616632680e13bc31501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fd21094e5a9d8517b00bffa08f132759baefbbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd21094e5a9d8517b00bffa08f132759baefbbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd21094e5a9d8517b00bffa08f132759baefbbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd21094e5a9d8517b00bffa08f132759baefbbc/comments", "author": null, "committer": null, "parents": [{"sha": "06a67bdd66ac806bea322b14f4e94fd03ad444f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a67bdd66ac806bea322b14f4e94fd03ad444f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a67bdd66ac806bea322b14f4e94fd03ad444f2"}], "stats": {"total": 140, "additions": 87, "deletions": 53}, "files": [{"sha": "d52f351748702339eba72beba952355d40b218f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fd21094e5a9d8517b00bffa08f132759baefbbc", "patch": "@@ -1,3 +1,23 @@\n+2004-07-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* rtlanal.c (insn_rtx_cost): New function, moved and renamed from\n+\tcombine.c's combine_insn_cost.\n+\t* rtl.h (insn_rtx_cost): Prototype here.\n+\t* combine.c (combine_insn_cost): Delete function.\n+\t(combine_validate_cost): Update callers of combine_insn_cost to\n+\tcall insn_rtx_cost instead.\n+\t(combine_instructions): Likewise.  Use NONJUMP_INSN_P to avoid\n+\trequesting the rtx_cost of call and/or jump instructions.\n+\n+\t* ifcvt.c (total_bb_rtx_cost): Use insn_rtx_cost instead of calling\n+\trtx_cost directly.  Don't request/use the cost of call or jump\n+\tinstructions.  Return -1 if the cost of any instruction can't be\n+\tdetermined (or the BB contains a function call).\n+\t(find_if_case_1): Abort transformation if total_bb_rtx_cost returns\n+\t-1 (i.e. can't determine the cost of any instruction or the basic\n+\tblock contains a subroutine call).\n+\t(find_if_case_2): Likewise.\n+\n 2004-07-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* rs6000.c (struct processor_costs): Change semantics of fields to"}, {"sha": "1bdceb5ef9c500a3b0e2410b847f93e3b3e3d574", "filename": "gcc/combine.c", "status": "modified", "additions": 11, "deletions": 46, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6fd21094e5a9d8517b00bffa08f132759baefbbc", "patch": "@@ -284,7 +284,7 @@ static basic_block this_basic_block;\n    those blocks as starting points.  */\n static sbitmap refresh_blocks;\n \f\n-/* The following array records the combine_insn_cost for every insn\n+/* The following array records the insn_rtx_cost for every insn\n    in the instruction stream.  */\n \n static int *uid_insn_cost;\n@@ -515,44 +515,8 @@ do_SUBST_INT (int *into, int newval)\n \n #define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n \f\n-/* Calculate the rtx_cost of a single instruction.  A return value of zero\n-   indicates an instruction without a known cost.  */\n-\n-static int\n-combine_insn_cost (rtx pat)\n-{\n-  int i, cost;\n-  rtx set;\n-\n-  /* Extract the single set rtx from the instruction pattern.\n-     We can't use single_set since we only have the pattern.  */\n-  if (GET_CODE (pat) == SET)\n-    set = pat;\n-  else if (GET_CODE (pat) == PARALLEL)\n-    {\n-      set = NULL_RTX;\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t{\n-\t  rtx x = XVECEXP (pat, 0, i);\n-\t  if (GET_CODE (x) == SET)\n-\t    {\n-\t      if (set)\n-\t\treturn 0;\n-\t      set = x;\n-\t    }\n-\t}\n-      if (!set)\n-\treturn 0;\n-    }\n-  else\n-    return 0;\n-\n-  cost = rtx_cost (SET_SRC (set), SET);\n-  return cost > 0 ? cost : COSTS_N_INSNS (1);\n-}\n-\n /* Subroutine of try_combine.  Determine whether the combine replacement\n-   patterns NEWPAT and NEWI2PAT are cheaper according to combine_insn_cost\n+   patterns NEWPAT and NEWI2PAT are cheaper according to insn_rtx_cost\n    that the original instruction sequence I1, I2 and I3.  Note that I1\n    and/or NEWI2PAT may be NULL_RTX.  This function returns false, if the\n    costs of all instructions can be estimated, and the replacements are\n@@ -565,7 +529,7 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat)\n   int new_i2_cost, new_i3_cost;\n   int old_cost, new_cost;\n \n-  /* Lookup the original combine_insn_costs.  */\n+  /* Lookup the original insn_rtx_costs.  */\n   i2_cost = INSN_UID (i2) <= last_insn_cost\n \t    ? uid_insn_cost[INSN_UID (i2)] : 0;\n   i3_cost = INSN_UID (i3) <= last_insn_cost\n@@ -584,11 +548,11 @@ combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat)\n       i1_cost = 0;\n     }\n \n-  /* Calculate the replacement combine_insn_costs.  */\n-  new_i3_cost = combine_insn_cost (newpat);\n+  /* Calculate the replacement insn_rtx_costs.  */\n+  new_i3_cost = insn_rtx_cost (newpat);\n   if (newi2pat)\n     {\n-      new_i2_cost = combine_insn_cost (newi2pat);\n+      new_i2_cost = insn_rtx_cost (newi2pat);\n       new_cost = (new_i2_cost > 0 && new_i3_cost > 0)\n \t\t ? new_i2_cost + new_i3_cost : 0;\n     }\n@@ -708,7 +672,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   refresh_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (refresh_blocks);\n \n-  /* Allocate array of current combine_insn_costs.  */\n+  /* Allocate array of current insn_rtx_costs.  */\n   uid_insn_cost = xcalloc (max_uid_cuid + 1, sizeof (int));\n   last_insn_cost = max_uid_cuid;\n \n@@ -731,8 +695,9 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t\t\t\t\tNULL);\n #endif\n \n-\t  /* Record the current combine_insn_cost of this instruction.  */\n-\t  uid_insn_cost[INSN_UID (insn)] = combine_insn_cost (PATTERN (insn));\n+\t  /* Record the current insn_rtx_cost of this instruction.  */\n+\t  if (NONJUMP_INSN_P (insn))\n+\t    uid_insn_cost[INSN_UID (insn)] = insn_rtx_cost (PATTERN (insn));\n \t  if (dump_file)\n \t    fprintf(dump_file, \"insn_cost %d: %d\\n\",\n \t\t    INSN_UID (insn), uid_insn_cost[INSN_UID (insn)]);\n@@ -2655,7 +2620,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   }\n #endif\n \n-  /* Only allow this combination if combine_insn_costs reports that the\n+  /* Only allow this combination if insn_rtx_costs reports that the\n      replacement instructions are cheaper than the originals.  */\n   if (!combine_validate_cost (i1, i2, i3, newpat, newi2pat))\n     {"}, {"sha": "ac478af71ba78ea29427f9b35e27b06b8346875b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=6fd21094e5a9d8517b00bffa08f132759baefbbc", "patch": "@@ -161,7 +161,9 @@ count_bb_insns (basic_block bb)\n   return count;\n }\n \n-/* Count the total rtx_cost of non-jump active insns in BB.  */\n+/* Count the total insn_rtx_cost of non-jump active insns in BB.\n+   This function returns -1, if the cost of any instruction could\n+   not be estimated.  */\n \n static int\n total_bb_rtx_cost (basic_block bb)\n@@ -171,9 +173,16 @@ total_bb_rtx_cost (basic_block bb)\n \n   while (1)\n     {\n-      if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == INSN)\n-\tcount += rtx_cost (PATTERN (insn), 0);\n-\n+      if (NONJUMP_INSN_P (insn))\n+\t{\n+\t  int cost = insn_rtx_cost (PATTERN (insn));\n+\t  if (cost == 0)\n+\t    return -1;\n+\t  count += cost;\n+\t}\n+      else if (CALL_P (insn))\n+\treturn -1;\n+ \n       if (insn == BB_END (bb))\n \tbreak;\n       insn = NEXT_INSN (insn);\n@@ -2867,7 +2876,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest, new_bb;\n   edge then_succ = then_bb->succ;\n-  int then_bb_index;\n+  int then_bb_index, bb_cost;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -2904,7 +2913,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, then_bb->index);\n \n   /* THEN is small.  */\n-  if (total_bb_rtx_cost (then_bb) >= COSTS_N_INSNS (BRANCH_COST))\n+  bb_cost = total_bb_rtx_cost (then_bb);\n+  if (bb_cost < 0 || bb_cost >= COSTS_N_INSNS (BRANCH_COST))\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */\n@@ -2947,6 +2957,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest;\n   edge else_succ = else_bb->succ;\n+  int bb_cost;\n   rtx note;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n@@ -2995,7 +3006,8 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, else_bb->index);\n \n   /* ELSE is small.  */\n-  if (total_bb_rtx_cost (else_bb) >= COSTS_N_INSNS (BRANCH_COST))\n+  bb_cost = total_bb_rtx_cost (else_bb);\n+  if (bb_cost < 0 || bb_cost >= COSTS_N_INSNS (BRANCH_COST))\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */"}, {"sha": "bc87dd280e0f4e7ed3f04de66437ffeb474888c7", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6fd21094e5a9d8517b00bffa08f132759baefbbc", "patch": "@@ -1879,6 +1879,7 @@ extern int loc_mentioned_in_p (rtx *, rtx);\n extern rtx find_first_parameter_load (rtx, rtx);\n extern bool keep_with_call_p (rtx);\n extern bool label_is_jump_target_p (rtx, rtx);\n+extern int insn_rtx_cost (rtx);\n \n /* flow.c */\n "}, {"sha": "81d4f4024f57c48258b42cf8fc50d5d693c558a2", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd21094e5a9d8517b00bffa08f132759baefbbc/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6fd21094e5a9d8517b00bffa08f132759baefbbc", "patch": "@@ -4785,3 +4785,39 @@ num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,\n   return nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))\n \t ? 1 : bitwidth - floor_log2 (nonzero) - 1;\n }\n+\n+/* Calculate the rtx_cost of a single instruction.  A return value of\n+   zero indicates an instruction pattern without a known cost.  */\n+\n+int\n+insn_rtx_cost (rtx pat)\n+{\n+  int i, cost;\n+  rtx set;\n+\n+  /* Extract the single set rtx from the instruction pattern.\n+     We can't use single_set since we only have the pattern.  */\n+  if (GET_CODE (pat) == SET)\n+    set = pat;\n+  else if (GET_CODE (pat) == PARALLEL)\n+    {\n+      set = NULL_RTX;\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx x = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (x) == SET)\n+\t    {\n+\t      if (set)\n+\t\treturn 0;\n+\t      set = x;\n+\t    }\n+\t}\n+      if (!set)\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  cost = rtx_cost (SET_SRC (set), SET);\n+  return cost > 0 ? cost : COSTS_N_INSNS (1);\n+}"}]}