{"sha": "12286f25cddbf8e8b3a810442ffa4959da315c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIyODZmMjVjZGRiZjhlOGIzYTgxMDQ0MmZmYTQ5NTlkYTMxNWMzMQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2016-10-26T16:17:44Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-10-26T16:17:44Z"}, "message": "Refactor atomic compare_and_swap to make it fit for ARMv8-M Baseline\n\n2016-10-26  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    * config/arm/arm.c (arm_expand_compare_and_swap): Add new bdst local\n    variable.  Add the new parameter to the insn generator.  Set that\n    parameter to be CC flag for 32-bit targets, bval otherwise.  Set the\n    return value from the negation of that parameter for Thumb-1, keeping\n    the logic unchanged otherwise except for using bdst as the destination\n    register of the compare_and_swap insn.\n    (arm_split_compare_and_swap): Add explanation about how is the value\n    returned to the function comment.  Rename scratch variable to\n    neg_bval.  Adapt initialization of variables holding operands to the\n    new operand numbers.  Use return register to hold result of store\n    exclusive for Thumb-1, scratch register otherwise.  Construct the\n    appropriate cbranch for Thumb-1 targets, keeping the logic unchanged\n    for 32-bit targets.  Guard Z flag setting to restrict to 32bit targets.\n    Use gen_cbranchsi4 rather than hand-written conditional branch to loop\n    for strongly ordered compare_and_swap.\n    * config/arm/predicates.md (cc_register_operand): New predicate.\n    * config/arm/sync.md (atomic_compare_and_swap<mode>_1): Use a\n    match_operand with the new predicate to accept either the CC flag or a\n    destination register for the boolean return value, restricting it to\n    CC flag only via constraint.  Adapt operand numbers accordingly.\n\nFrom-SVN: r241577", "tree": {"sha": "c8632b4205444925ba31c7042892f0ca848154a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8632b4205444925ba31c7042892f0ca848154a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12286f25cddbf8e8b3a810442ffa4959da315c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12286f25cddbf8e8b3a810442ffa4959da315c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12286f25cddbf8e8b3a810442ffa4959da315c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12286f25cddbf8e8b3a810442ffa4959da315c31/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f4bf94e9c3c8b11607234439a72347729717ae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4bf94e9c3c8b11607234439a72347729717ae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4bf94e9c3c8b11607234439a72347729717ae6"}], "stats": {"total": 158, "additions": 108, "deletions": 50}, "files": [{"sha": "5a79b961a1a71b855b22f65e71e74410a77fe261", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12286f25cddbf8e8b3a810442ffa4959da315c31", "patch": "@@ -1,3 +1,26 @@\n+2016-10-26  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/arm.c (arm_expand_compare_and_swap): Add new bdst local\n+\tvariable.  Add the new parameter to the insn generator.  Set that\n+\tparameter to be CC flag for 32-bit targets, bval otherwise.  Set the\n+\treturn value from the negation of that parameter for Thumb-1, keeping\n+\tthe logic unchanged otherwise except for using bdst as the destination\n+\tregister of the compare_and_swap insn.\n+\t(arm_split_compare_and_swap): Add explanation about how is the value\n+\treturned to the function comment.  Rename scratch variable to\n+\tneg_bval.  Adapt initialization of variables holding operands to the\n+\tnew operand numbers.  Use return register to hold result of store\n+\texclusive for Thumb-1, scratch register otherwise.  Construct the\n+\tappropriate cbranch for Thumb-1 targets, keeping the logic unchanged\n+\tfor 32-bit targets.  Guard Z flag setting to restrict to 32bit targets.\n+\tUse gen_cbranchsi4 rather than hand-written conditional branch to loop\n+\tfor strongly ordered compare_and_swap.\n+\t* config/arm/predicates.md (cc_register_operand): New predicate.\n+\t* config/arm/sync.md (atomic_compare_and_swap<mode>_1): Use a\n+\tmatch_operand with the new predicate to accept either the CC flag or a\n+\tdestination register for the boolean return value, restricting it to\n+\tCC flag only via constraint.  Adapt operand numbers accordingly.\n+\n 2016-10-26  Jeff Law  <law@redhat.com>\n \n \t* config/frv/frv.c (comparison_string): Do not fall through after"}, {"sha": "781353e6f64b3fc6622f699dd7bad447192888aa", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=12286f25cddbf8e8b3a810442ffa4959da315c31", "patch": "@@ -28152,9 +28152,9 @@ emit_unlikely_jump (rtx insn)\n void\n arm_expand_compare_and_swap (rtx operands[])\n {\n-  rtx bval, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n+  rtx bval, bdst, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n   machine_mode mode;\n-  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n \n   bval = operands[0];\n   rval = operands[1];\n@@ -28211,43 +28211,54 @@ arm_expand_compare_and_swap (rtx operands[])\n       gcc_unreachable ();\n     }\n \n-  emit_insn (gen (rval, mem, oldval, newval, is_weak, mod_s, mod_f));\n+  bdst = TARGET_THUMB1 ? bval : gen_rtx_REG (CCmode, CC_REGNUM);\n+  emit_insn (gen (bdst, rval, mem, oldval, newval, is_weak, mod_s, mod_f));\n \n   if (mode == QImode || mode == HImode)\n     emit_move_insn (operands[1], gen_lowpart (mode, rval));\n \n   /* In all cases, we arrange for success to be signaled by Z set.\n      This arrangement allows for the boolean result to be used directly\n-     in a subsequent branch, post optimization.  */\n-  x = gen_rtx_REG (CCmode, CC_REGNUM);\n-  x = gen_rtx_EQ (SImode, x, const0_rtx);\n-  emit_insn (gen_rtx_SET (bval, x));\n+     in a subsequent branch, post optimization.  For Thumb-1 targets, the\n+     boolean negation of the result is also stored in bval because Thumb-1\n+     backend lacks dependency tracking for CC flag due to flag-setting not\n+     being represented at RTL level.  */\n+  if (TARGET_THUMB1)\n+      emit_insn (gen_cstoresi_eq0_thumb1 (bval, bdst));\n+  else\n+    {\n+      x = gen_rtx_EQ (SImode, bdst, const0_rtx);\n+      emit_insn (gen_rtx_SET (bval, x));\n+    }\n }\n \n /* Split a compare and swap pattern.  It is IMPLEMENTATION DEFINED whether\n    another memory store between the load-exclusive and store-exclusive can\n    reset the monitor from Exclusive to Open state.  This means we must wait\n    until after reload to split the pattern, lest we get a register spill in\n-   the middle of the atomic sequence.  */\n+   the middle of the atomic sequence.  Success of the compare and swap is\n+   indicated by the Z flag set for 32bit targets and by neg_bval being zero\n+   for Thumb-1 targets (ie. negation of the boolean value returned by\n+   atomic_compare_and_swapmode standard pattern in operand 0).  */\n \n void\n arm_split_compare_and_swap (rtx operands[])\n {\n-  rtx rval, mem, oldval, newval, scratch;\n+  rtx rval, mem, oldval, newval, neg_bval;\n   machine_mode mode;\n   enum memmodel mod_s, mod_f;\n   bool is_weak;\n   rtx_code_label *label1, *label2;\n   rtx x, cond;\n \n-  rval = operands[0];\n-  mem = operands[1];\n-  oldval = operands[2];\n-  newval = operands[3];\n-  is_weak = (operands[4] != const0_rtx);\n-  mod_s = memmodel_from_int (INTVAL (operands[5]));\n-  mod_f = memmodel_from_int (INTVAL (operands[6]));\n-  scratch = operands[7];\n+  rval = operands[1];\n+  mem = operands[2];\n+  oldval = operands[3];\n+  newval = operands[4];\n+  is_weak = (operands[5] != const0_rtx);\n+  mod_s = memmodel_from_int (INTVAL (operands[6]));\n+  mod_f = memmodel_from_int (INTVAL (operands[7]));\n+  neg_bval = TARGET_THUMB1 ? operands[0] : operands[8];\n   mode = GET_MODE (mem);\n \n   bool is_armv8_sync = arm_arch8 && is_mm_sync (mod_s);\n@@ -28279,26 +28290,44 @@ arm_split_compare_and_swap (rtx operands[])\n \n   arm_emit_load_exclusive (mode, rval, mem, use_acquire);\n \n-  cond = arm_gen_compare_reg (NE, rval, oldval, scratch);\n-  x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n-\t\t\t    gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n-  emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n+  /* Z is set to 0 for 32bit targets (resp. rval set to 1) if oldval != rval,\n+     as required to communicate with arm_expand_compare_and_swap.  */\n+  if (TARGET_32BIT)\n+    {\n+      cond = arm_gen_compare_reg (NE, rval, oldval, neg_bval);\n+      x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n+\t\t\t\tgen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n+      emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n+    }\n+  else\n+    {\n+      emit_move_insn (neg_bval, const1_rtx);\n+      cond = gen_rtx_NE (VOIDmode, rval, oldval);\n+      if (thumb1_cmpneg_operand (oldval, SImode))\n+\temit_unlikely_jump (gen_cbranchsi4_scratch (neg_bval, rval, oldval,\n+\t\t\t\t\t\t    label2, cond));\n+      else\n+\temit_unlikely_jump (gen_cbranchsi4_insn (cond, rval, oldval, label2));\n+    }\n \n-  arm_emit_store_exclusive (mode, scratch, mem, newval, use_release);\n+  arm_emit_store_exclusive (mode, neg_bval, mem, newval, use_release);\n \n   /* Weak or strong, we want EQ to be true for success, so that we\n      match the flags that we got from the compare above.  */\n-  cond = gen_rtx_REG (CCmode, CC_REGNUM);\n-  x = gen_rtx_COMPARE (CCmode, scratch, const0_rtx);\n-  emit_insn (gen_rtx_SET (cond, x));\n+  if (TARGET_32BIT)\n+    {\n+      cond = gen_rtx_REG (CCmode, CC_REGNUM);\n+      x = gen_rtx_COMPARE (CCmode, neg_bval, const0_rtx);\n+      emit_insn (gen_rtx_SET (cond, x));\n+    }\n \n   if (!is_weak)\n     {\n-      x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n-      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n-\t\t\t\tgen_rtx_LABEL_REF (Pmode, label1), pc_rtx);\n-      emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n+      /* Z is set to boolean value of !neg_bval, as required to communicate\n+\t with arm_expand_compare_and_swap.  */\n+      x = gen_rtx_NE (VOIDmode, neg_bval, const0_rtx);\n+      emit_unlikely_jump (gen_cbranchsi4 (x, neg_bval, const0_rtx, label1));\n     }\n \n   if (!is_mm_relaxed (mod_f))"}, {"sha": "af727edaa570fe67948c4432d9fa7bb90815feb8", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=12286f25cddbf8e8b3a810442ffa4959da315c31", "patch": "@@ -391,6 +391,12 @@\n \t     || mode == CC_DGTUmode));\n })\n \n+;; Any register, including CC\n+(define_predicate \"cc_register_operand\"\n+  (and (match_code \"reg\")\n+       (ior (match_operand 0 \"s_register_operand\")\n+\t    (match_operand 0 \"cc_register\"))))\n+\n (define_special_predicate \"arm_extendqisi_mem_op\"\n   (and (match_operand 0 \"memory_operand\")\n        (match_test \"TARGET_ARM ? arm_legitimate_address_outer_p (mode,"}, {"sha": "b4e0713108d9867d7226fad3241e46d1faf3172a", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12286f25cddbf8e8b3a810442ffa4959da315c31/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=12286f25cddbf8e8b3a810442ffa4959da315c31", "patch": "@@ -190,20 +190,20 @@\n })\n \n (define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n-  [(set (reg:CC_Z CC_REGNUM)\t\t\t\t\t;; bool out\n+  [(set (match_operand 0 \"cc_register_operand\" \"=&c\")\t\t;; bool out\n \t(unspec_volatile:CC_Z [(const_int 0)] VUNSPEC_ATOMIC_CAS))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\t\t;; val out\n+   (set (match_operand:SI 1 \"s_register_operand\" \"=&r\")\t\t;; val out\n \t(zero_extend:SI\n-\t  (match_operand:NARROW 1 \"mem_noofs_operand\" \"+Ua\")))\t;; memory\n-   (set (match_dup 1)\n+\t  (match_operand:NARROW 2 \"mem_noofs_operand\" \"+Ua\")))\t;; memory\n+   (set (match_dup 2)\n \t(unspec_volatile:NARROW\n-\t  [(match_operand:SI 2 \"arm_add_operand\" \"rIL\")\t\t;; expected\n-\t   (match_operand:NARROW 3 \"s_register_operand\" \"r\")\t;; desired\n-\t   (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n-\t   (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n-\t   (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+\t  [(match_operand:SI 3 \"arm_add_operand\" \"rIL\")\t\t;; expected\n+\t   (match_operand:NARROW 4 \"s_register_operand\" \"r\")\t;; desired\n+\t   (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n+\t   (match_operand:SI 6 \"const_int_operand\")\t\t;; mod_s\n+\t   (match_operand:SI 7 \"const_int_operand\")]\t\t;; mod_f\n \t  VUNSPEC_ATOMIC_CAS))\n-   (clobber (match_scratch:SI 7 \"=&r\"))]\n+   (clobber (match_scratch:SI 8 \"=&r\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -219,19 +219,19 @@\n   [(SI \"rIL\") (DI \"rDi\")])\n \n (define_insn_and_split \"atomic_compare_and_swap<mode>_1\"\n-  [(set (reg:CC_Z CC_REGNUM)\t\t\t\t\t;; bool out\n+  [(set (match_operand 0 \"cc_register_operand\" \"=&c\")\t\t;; bool out\n \t(unspec_volatile:CC_Z [(const_int 0)] VUNSPEC_ATOMIC_CAS))\n-   (set (match_operand:SIDI 0 \"s_register_operand\" \"=&r\")\t;; val out\n-\t(match_operand:SIDI 1 \"mem_noofs_operand\" \"+Ua\"))\t;; memory\n-   (set (match_dup 1)\n+   (set (match_operand:SIDI 1 \"s_register_operand\" \"=&r\")\t;; val out\n+\t(match_operand:SIDI 2 \"mem_noofs_operand\" \"+Ua\"))\t;; memory\n+   (set (match_dup 2)\n \t(unspec_volatile:SIDI\n-\t  [(match_operand:SIDI 2 \"<cas_cmp_operand>\" \"<cas_cmp_str>\") ;; expect\n-\t   (match_operand:SIDI 3 \"s_register_operand\" \"r\")\t;; desired\n-\t   (match_operand:SI 4 \"const_int_operand\")\t\t;; is_weak\n-\t   (match_operand:SI 5 \"const_int_operand\")\t\t;; mod_s\n-\t   (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+\t  [(match_operand:SIDI 3 \"<cas_cmp_operand>\" \"<cas_cmp_str>\") ;; expect\n+\t   (match_operand:SIDI 4 \"s_register_operand\" \"r\")\t;; desired\n+\t   (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n+\t   (match_operand:SI 6 \"const_int_operand\")\t\t;; mod_s\n+\t   (match_operand:SI 7 \"const_int_operand\")]\t\t;; mod_f\n \t  VUNSPEC_ATOMIC_CAS))\n-   (clobber (match_scratch:SI 7 \"=&r\"))]\n+   (clobber (match_scratch:SI 8 \"=&r\"))]\n   \"<sync_predtab>\"\n   \"#\"\n   \"&& reload_completed\""}]}