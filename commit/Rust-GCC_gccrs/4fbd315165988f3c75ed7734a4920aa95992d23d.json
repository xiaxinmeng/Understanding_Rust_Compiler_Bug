{"sha": "4fbd315165988f3c75ed7734a4920aa95992d23d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiZDMxNTE2NTk4OGYzYzc1ZWQ3NzM0YTQ5MjBhYTk1OTkyZDIzZA==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2006-12-12T21:45:37Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2006-12-12T21:45:37Z"}, "message": "reload1.c (eliminate_regs_in_insn): Merge the plus_src \"else\" and the offset == 0 \"then\" clauses.\n\n\t* reload1.c (eliminate_regs_in_insn): Merge the plus_src \"else\" and\n\tthe offset == 0 \"then\" clauses.\n\t* config/rs6000/predicates.md (gpc_reg_operand): Check for\n\treload_in_progress.\n\nFrom-SVN: r119800", "tree": {"sha": "97db062dd1b11e54b0d0fffd54b801b7831bc114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97db062dd1b11e54b0d0fffd54b801b7831bc114"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fbd315165988f3c75ed7734a4920aa95992d23d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbd315165988f3c75ed7734a4920aa95992d23d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbd315165988f3c75ed7734a4920aa95992d23d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbd315165988f3c75ed7734a4920aa95992d23d/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad7082e3d95afb5f313a8663050876ef5fd35534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7082e3d95afb5f313a8663050876ef5fd35534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7082e3d95afb5f313a8663050876ef5fd35534"}], "stats": {"total": 43, "additions": 19, "deletions": 24}, "files": [{"sha": "61fb81a14d14d3634a21f0f2b13d291e318f5766", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbd315165988f3c75ed7734a4920aa95992d23d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbd315165988f3c75ed7734a4920aa95992d23d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fbd315165988f3c75ed7734a4920aa95992d23d", "patch": "@@ -1,3 +1,10 @@\n+2006-12-12  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* reload1.c (eliminate_regs_in_insn): Merge the plus_src \"else\" and\n+\tthe offset == 0 \"then\" clauses.\n+\t* config/rs6000/predicates.md (gpc_reg_operand): Check for\n+\treload_in_progress.\n+\n 2006-12-12  Marcin Dalecki  <martin@dalecki.de>\n \n \t* doc/passes.texi: remove docs about \"redundant PHI removal\"."}, {"sha": "0b4f7df44d63b3d6fb13cfd49091dbffc8250237", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbd315165988f3c75ed7734a4920aa95992d23d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbd315165988f3c75ed7734a4920aa95992d23d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=4fbd315165988f3c75ed7734a4920aa95992d23d", "patch": "@@ -81,10 +81,13 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) > 0 && exact_log2 (INTVAL (op)) >= 0\")))\n \n-;; Return 1 if op is a register that is not special.\n+;; Return 1 if op is a register that is not special.  We accept anything\n+;; during reload_in_progress since eliminate_regs_in_insn() sometimes\n+;; creates invalid insns which will be fixed up later in reload.\n (define_predicate \"gpc_reg_operand\"\n    (and (match_operand 0 \"register_operand\")\n-\t(match_test \"(GET_CODE (op) != REG\n+\t(match_test \"(reload_in_progress\n+\t\t      || GET_CODE (op) != REG\n \t\t      || (REGNO (op) >= ARG_POINTER_REGNUM\n \t\t\t  && !XER_REGNO_P (REGNO (op)))\n \t\t      || REGNO (op) < MQ_REGNO)"}, {"sha": "7ba93a6e2f0427a53295123e4ce650fd1ab90f5b", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbd315165988f3c75ed7734a4920aa95992d23d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbd315165988f3c75ed7734a4920aa95992d23d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4fbd315165988f3c75ed7734a4920aa95992d23d", "patch": "@@ -3098,7 +3098,12 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t    if (GET_CODE (XEXP (plus_cst_src, 0)) == SUBREG)\n \t      to_rtx = gen_lowpart (GET_MODE (XEXP (plus_cst_src, 0)),\n \t\t\t\t    to_rtx);\n-\t    if (offset == 0)\n+\t    /* If we have a nonzero offset, and the source is already\n+\t       a simple REG, the following transformation would\n+\t       increase the cost of the insn by replacing a simple REG\n+\t       with (plus (reg sp) CST).  So try only when we already\n+\t       had a PLUS before.  */\n+\t    if (offset == 0 || plus_src)\n \t      {\n \t\tint num_clobbers;\n \t\t/* We assume here that if we need a PARALLEL with\n@@ -3107,7 +3112,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t   There's not much we can do if that doesn't work.  */\n \t\tPATTERN (insn) = gen_rtx_SET (VOIDmode,\n \t\t\t\t\t      SET_DEST (old_set),\n-\t\t\t\t\t      to_rtx);\n+\t\t\t\t\t      plus_constant (to_rtx, offset));\n \t\tnum_clobbers = 0;\n \t\tINSN_CODE (insn) = recog (PATTERN (insn), insn, &num_clobbers);\n \t\tif (num_clobbers)\n@@ -3120,26 +3125,6 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t  }\n \t\tgcc_assert (INSN_CODE (insn) >= 0);\n \t      }\n-\t    /* If we have a nonzero offset, and the source is already\n-\t       a simple REG, the following transformation would\n-\t       increase the cost of the insn by replacing a simple REG\n-\t       with (plus (reg sp) CST).  So try only when we already\n-\t       had a PLUS before.  */\n-\t    else if (plus_src)\n-\t      {\n-\t\tnew_body = old_body;\n-\t\tif (! replace)\n-\t\t  {\n-\t\t    new_body = copy_insn (old_body);\n-\t\t    if (REG_NOTES (insn))\n-\t\t      REG_NOTES (insn) = copy_insn_1 (REG_NOTES (insn));\n-\t\t  }\n-\t\tPATTERN (insn) = new_body;\n-\t\told_set = single_set (insn);\n-\n-\t\tXEXP (SET_SRC (old_set), 0) = to_rtx;\n-\t\tXEXP (SET_SRC (old_set), 1) = GEN_INT (offset);\n-\t      }\n \t    else\n \t      break;\n "}]}