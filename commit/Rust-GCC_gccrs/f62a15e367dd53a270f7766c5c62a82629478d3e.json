{"sha": "f62a15e367dd53a270f7766c5c62a82629478d3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyYTE1ZTM2N2RkNTNhMjcwZjc3NjZjNWM2MmE4MjYyOTQ3OGQzZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-12-04T12:55:59Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1998-12-04T12:55:59Z"}, "message": "final.c (cleanup_subreg_operands): Delete some unused code.\n\n\t* final.c (cleanup_subreg_operands): Delete some unused code.\n\t* recog.h (MAX_RECOG_ALTERNATIVES): New macro.\n\t(struct insn_alternative): New structure definition.\n\t(recog_op_alt): Declare variable.\n\t(preprocess_constraints): Declare function.\n\t* recog.c (recog_op_alt): New variable.\n\t(extract_insn): Verify number of alternatives is in range.\n\t(preprocess_constraints): New function.\n\t* reg-stack.c: Include recog.h.\n\t(constrain_asm_operands): Delete.\n\t(get_asm_operand_lengths): Delete.\n\t(get_asm_operand_n_inputs): New function.\n\t(record_asm_reg_life): Delete OPERANDS, CONSTRAINTS, N_INPUTS and\n\tN_OUTPUTS args.  All callers changed.\n\tCompute number of inputs and outputs here by calling\n\tget_asm_operand_n_inputs.\n\tInstead of constrain_asm_operands, call extract_insn,\n\tconstrain_operands and preprocess_constaints.  Use information\n\tcomputed by these functions throughout.\n\t(record_reg_life): Delete code that is unused due to changes in\n\trecord_asm_reg_life.\n\t(subst_asm_stack_regs): Delete OPERANDS, OPERAND_LOC, CONSTRAINTS,\n\tN_INPUTS and N_OUTPUTS args.  All callers changed.\n\tSimilar changes as in record_asm_reg_life.\n\t(subst_stack_regs): Move n_operands declaration into the if statement\n\twhere it's used.\n\tDelete code that is unused due to changes in subst_asm_stack_regs.\n\t* stmt.c (expand_asm_operands): Verify number of alternatives is in\n\trange.\n\t* Makefile.in (reg-stack.o): Depend on recog.h.\n\nFrom-SVN: r24090", "tree": {"sha": "7eac8b63b458dd5da67b48a5a4d8ca0d0304223f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eac8b63b458dd5da67b48a5a4d8ca0d0304223f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f62a15e367dd53a270f7766c5c62a82629478d3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62a15e367dd53a270f7766c5c62a82629478d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62a15e367dd53a270f7766c5c62a82629478d3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62a15e367dd53a270f7766c5c62a82629478d3e/comments", "author": null, "committer": null, "parents": [{"sha": "71eb0b9ec35acd4843115354a94be4dcb150f7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71eb0b9ec35acd4843115354a94be4dcb150f7af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71eb0b9ec35acd4843115354a94be4dcb150f7af"}], "stats": {"total": 754, "additions": 308, "deletions": 446}, "files": [{"sha": "fac1096173103fa5ac31833650095064b9c64c34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -1,3 +1,37 @@\n+Fri Dec  4 20:15:57 1998  Bernd Schmidt  <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* final.c (cleanup_subreg_operands): Delete some unused code.\n+\n+\t* recog.h (MAX_RECOG_ALTERNATIVES): New macro.\n+\t(struct insn_alternative): New structure definition.\n+\t(recog_op_alt): Declare variable.\n+\t(preprocess_constraints): Declare function.\n+\t* recog.c (recog_op_alt): New variable.\n+\t(extract_insn): Verify number of alternatives is in range.\n+\t(preprocess_constraints): New function.\n+\t* reg-stack.c: Include recog.h.\n+\t(constrain_asm_operands): Delete.\n+\t(get_asm_operand_lengths): Delete.\n+\t(get_asm_operand_n_inputs): New function.\n+\t(record_asm_reg_life): Delete OPERANDS, CONSTRAINTS, N_INPUTS and\n+\tN_OUTPUTS args.  All callers changed.\n+\tCompute number of inputs and outputs here by calling\n+\tget_asm_operand_n_inputs.\n+\tInstead of constrain_asm_operands, call extract_insn,\n+\tconstrain_operands and preprocess_constaints.  Use information\n+\tcomputed by these functions throughout.\n+\t(record_reg_life): Delete code that is unused due to changes in\n+\trecord_asm_reg_life.\n+\t(subst_asm_stack_regs): Delete OPERANDS, OPERAND_LOC, CONSTRAINTS,\n+\tN_INPUTS and N_OUTPUTS args.  All callers changed.\n+\tSimilar changes as in record_asm_reg_life.\n+\t(subst_stack_regs): Move n_operands declaration into the if statement\n+\twhere it's used.\n+\tDelete code that is unused due to changes in subst_asm_stack_regs.\n+\t* stmt.c (expand_asm_operands): Verify number of alternatives is in\n+\trange.\n+\t* Makefile.in (reg-stack.o): Depend on recog.h.\n+\n Fri Dec  4 02:23:24 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* except.c (set_exception_version_code): Argument is an \"int\"."}, {"sha": "97bec2488dbb94be42c29b3352f48d7517fe988d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -1535,7 +1535,7 @@ final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h $(REGS_H) \\\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H)  \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    insn-flags.h insn-codes.h real.h toplev.h\n-reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) \\\n+reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) recog.h \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h\n dyn-string.o: dyn-string.c dyn-string.h $(CONFIG_H) system.h\n "}, {"sha": "32ed6fbf9f24dffba0bcced46029ba8bc24bda55", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -3031,23 +3031,8 @@ void\n cleanup_subreg_operands (insn)\n      rtx insn;\n {\n-  int insn_code_number, i;\n-\n-  /* Ignore things we can not handle.  */\n-  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i'\n-      || GET_CODE (PATTERN (insn)) == USE\n-      || GET_CODE (PATTERN (insn)) == ADDR_VEC\n-      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-      || GET_CODE (PATTERN (insn)) == ASM_INPUT\n-      || asm_noperands (PATTERN (insn)) >= 0)\n-    return;\n-\n-  /* Try to recognize the instruction.\n-     If successful, verify that the operands satisfy the\n-     constraints for the instruction.  Crash if they don't,\n-     since `reload' should have changed them so that they do.  */\n+  int i;\n \n-  insn_code_number = recog_memoized (insn);\n   extract_insn (insn);\n   for (i = 0; i < recog_n_operands; i++)\n     {"}, {"sha": "19bc3b2bcf8940746fbb36b3e346b7ad7159d1fc", "filename": "gcc/recog.c", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -96,6 +96,10 @@ enum op_type recog_op_type[MAX_RECOG_OPERANDS];\n char recog_operand_address_p[MAX_RECOG_OPERANDS];\n #endif\n \n+/* Contains a vector of operand_alternative structures for every operand.\n+   Set up by preprocess_constraints.  */\n+struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALTERNATIVES];\n+\n /* On return from `constrain_operands', indicate which alternative\n    was satisfied.  */\n \n@@ -1803,8 +1807,115 @@ extract_insn (insn)\n     recog_op_type[i] = (recog_constraints[i][0] == '=' ? OP_OUT\n \t\t\t: recog_constraints[i][0] == '+' ? OP_INOUT\n \t\t\t: OP_IN);\n+\n+  if (recog_n_alternatives > MAX_RECOG_ALTERNATIVES)\n+    abort ();\n }\n \n+/* After calling extract_insn, you can use this function to extract some\n+   information from the constraint strings into a more usable form.\n+   The collected data is stored in recog_op_alt.  */\n+void\n+preprocess_constraints ()\n+{\n+  int i;\n+\n+  for (i = 0; i < recog_n_operands; i++)\n+    {\n+      int j;\n+      struct operand_alternative *op_alt;\n+      char *p = recog_constraints[i];\n+\n+      op_alt = recog_op_alt[i];\n+\n+      for (j = 0; j < recog_n_alternatives; j++)\n+\t{\n+\t  op_alt[j].class = NO_REGS;\n+\t  op_alt[j].constraint = p;\n+\t  op_alt[j].matches = -1;\n+\t  op_alt[j].matched = -1;\n+\n+\t  if (*p == '\\0' || *p == ',')\n+\t    {\n+\t      op_alt[j].anything_ok = 1;\n+\t      continue;\n+\t    }\n+\n+\t  for (;;)\n+\t    {\n+\t      char c = *p++;\n+\t      if (c == '#')\n+\t\tdo\n+\t\t  c = *p++;\n+\t\twhile (c != ',' && c != '\\0');\n+\t      if (c == ',' || c == '\\0')\n+\t\tbreak;\n+\n+\t      switch (c)\n+\t\t{\n+\t\tcase '=': case '+': case '*': case '%':\n+\t\tcase 'E': case 'F': case 'G': case 'H':\n+\t\tcase 's': case 'i': case 'n':\n+\t\tcase 'I': case 'J': case 'K': case 'L':\n+\t\tcase 'M': case 'N': case 'O': case 'P':\n+#ifdef EXTRA_CONSTRAINT\n+\t\tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n+#endif\n+\t\t  /* These don't say anything we care about.  */\n+\t\t  break;\n+\n+\t\tcase '?':\n+\t\t  op_alt[j].reject += 6;\n+\t\t  break;\n+\t\tcase '!':\n+\t\t  op_alt[j].reject += 600;\n+\t\t  break;\n+\t\tcase '&':\n+\t\t  op_alt[j].earlyclobber = 1;\n+\t\t  break;\t\t  \n+\n+\t\tcase '0': case '1': case '2': case '3': case '4':\n+\t\tcase '5': case '6': case '7': case '8': case '9':\n+\t\t  op_alt[j].matches = c - '0';\n+\t\t  op_alt[op_alt[j].matches].matched = i;\n+\t\t  break;\n+\n+\t\tcase 'm':\n+\t\t  op_alt[j].memory_ok = 1;\n+\t\t  break;\n+\t\tcase '<':\n+\t\t  op_alt[j].decmem_ok = 1;\n+\t\t  break;\n+\t\tcase '>':\n+\t\t  op_alt[j].incmem_ok = 1;\n+\t\t  break;\n+\t\tcase 'V':\n+\t\t  op_alt[j].nonoffmem_ok = 1;\n+\t\t  break;\n+\t\tcase 'o':\n+\t\t  op_alt[j].offmem_ok = 1;\n+\t\t  break;\n+\t\tcase 'X':\n+\t\t  op_alt[j].anything_ok = 1;\n+\t\t  break;\n+\n+\t\tcase 'p':\n+\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) BASE_REG_CLASS];\n+\t\t  break;\n+\n+\t\tcase 'g': case 'r':\n+\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) GENERAL_REGS];\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) REG_CLASS_FROM_LETTER (c)];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+ \n #ifdef REGISTER_CONSTRAINTS\n \n /* Check the operands of an insn against the insn's operand constraints"}, {"sha": "d30b9929faa625b301b7d08305dc30edbffde684", "filename": "gcc/recog.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -18,13 +18,54 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* Random number that should be large enough for all purposes.  */\n+#define MAX_RECOG_ALTERNATIVES 30\n+\n /* Types of operands.  */\n enum op_type {\n   OP_IN,\n   OP_OUT,\n   OP_INOUT\n };\n \n+struct operand_alternative\n+{\n+  /* Pointer to the beginning of the constraint string for this alternative,\n+     for easier access by alternative number.  */\n+  char *constraint;\n+\n+  /* The register class valid for this alternative (possibly NO_REGS).  */\n+  enum reg_class class;\n+\n+  /* \"Badness\" of this alternative, computed from number of '?' and '!'\n+     characters in the constraint string.  */\n+  unsigned int reject;\n+\n+  /* -1 if no matching constraint was found, or an operand number.  */\n+  int matches;\n+  /* The same information, but reversed: -1 if this operand is not\n+     matched by any other, or the operand number of the operand that\n+     matches this one.  */\n+  int matched;\n+\n+  /* Nonzero if '&' was found in the constraint string.  */\n+  unsigned int earlyclobber:1;\n+  /* Nonzero if 'm' was found in the constraint string.  */\n+  unsigned int memory_ok:1;  \n+  /* Nonzero if 'o' was found in the constraint string.  */\n+  unsigned int offmem_ok:1;  \n+  /* Nonzero if 'V' was found in the constraint string.  */\n+  unsigned int nonoffmem_ok:1;\n+  /* Nonzero if '<' was found in the constraint string.  */\n+  unsigned int decmem_ok:1;\n+  /* Nonzero if '>' was found in the constraint string.  */\n+  unsigned int incmem_ok:1;\n+  /* Nonzero if 'X' was found in the constraint string, or if the constraint\n+     string for this alternative was empty.  */\n+  unsigned int anything_ok:1;\n+};\n+\n+\n extern void init_recog\t\t\tPROTO((void));\n extern void init_recog_no_volatile\tPROTO((void));\n extern int recog_memoized\t\tPROTO((rtx));\n@@ -67,6 +108,7 @@ extern int recog\t\t\tPROTO((rtx, rtx, int *));\n extern void add_clobbers\t\tPROTO((rtx, int));\n extern void insn_extract\t\tPROTO((rtx));\n extern void extract_insn\t\tPROTO((rtx));\n+extern void preprocess_constraints\tPROTO((void));\n \n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;\n@@ -116,6 +158,10 @@ extern enum op_type recog_op_type[];\n extern char recog_operand_address_p[];\n #endif\n \n+/* Contains a vector of operand_alternative structures for every operand.\n+   Set up by preprocess_constraints.  */\n+struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALTERNATIVES];\n+\n /* Access the output function for CODE.  */\n \n #define OUT_FCN(CODE) (*insn_outfun[(int) (CODE)])"}, {"sha": "e3917063bebce5400d82a0bb6eb1fd24b49fc1a4", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 109, "deletions": 429, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -166,6 +166,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"insn-flags.h\"\n+#include \"recog.h\"\n #include \"toplev.h\"\n \n #ifdef STACK_REGS\n@@ -241,14 +242,11 @@ static void straighten_stack\t\tPROTO((rtx, stack));\n static void pop_stack\t\t\tPROTO((stack, int));\n static void record_label_references\tPROTO((rtx, rtx));\n static rtx *get_true_reg\t\tPROTO((rtx *));\n-static int constrain_asm_operands\tPROTO((int, rtx *, char **, int *,\n-\t\t\t\t\t       enum reg_class *));\n \n-static void record_asm_reg_life\t\tPROTO((rtx,stack, rtx *, char **,\n-\t\t\t\t\t       int, int));\n+static void record_asm_reg_life\t\tPROTO((rtx, stack));\n static void record_reg_life_pat\t\tPROTO((rtx, HARD_REG_SET *,\n \t\t\t\t\t       HARD_REG_SET *, int));\n-static void get_asm_operand_lengths\tPROTO((rtx, int, int *, int *));\n+static int get_asm_operand_n_inputs\tPROTO((rtx));\n static void record_reg_life\t\tPROTO((rtx, int, stack));\n static void find_blocks\t\t\tPROTO((rtx));\n static rtx stack_result\t\t\tPROTO((tree));\n@@ -263,8 +261,7 @@ static void move_for_stack_reg\t\tPROTO((rtx, stack, rtx));\n static void swap_rtx_condition\t\tPROTO((rtx));\n static void compare_for_stack_reg\tPROTO((rtx, stack, rtx));\n static void subst_stack_regs_pat\tPROTO((rtx, stack, rtx));\n-static void subst_asm_stack_regs\tPROTO((rtx, stack, rtx *, rtx **,\n-\t\t\t\t\t       char **, int, int));\n+static void subst_asm_stack_regs\tPROTO((rtx, stack));\n static void subst_stack_regs\t\tPROTO((rtx, stack));\n static void change_stack\t\tPROTO((rtx, stack, stack, rtx (*) ()));\n \n@@ -607,297 +604,8 @@ get_true_reg (pat)\n       }\n }\n \f\n-/* Scan the OPERANDS and OPERAND_CONSTRAINTS of an asm_operands.\n-   N_OPERANDS is the total number of operands.  Return which alternative\n-   matched, or -1 is no alternative matches.\n-\n-   OPERAND_MATCHES is an array which indicates which operand this\n-   operand matches due to the constraints, or -1 if no match is required.\n-   If two operands match by coincidence, but are not required to match by\n-   the constraints, -1 is returned.\n-\n-   OPERAND_CLASS is an array which indicates the smallest class\n-   required by the constraints.  If the alternative that matches calls\n-   for some class `class', and the operand matches a subclass of `class',\n-   OPERAND_CLASS is set to `class' as required by the constraints, not to\n-   the subclass. If an alternative allows more than one class,\n-   OPERAND_CLASS is set to the smallest class that is a union of the\n-   allowed classes.  */\n-\n-static int\n-constrain_asm_operands (n_operands, operands, operand_constraints,\n-\t\t\toperand_matches, operand_class)\n-     int n_operands;\n-     rtx *operands;\n-     char **operand_constraints;\n-     int *operand_matches;\n-     enum reg_class *operand_class;\n-{\n-  char **constraints = (char **) alloca (n_operands * sizeof (char *));\n-  char *q;\n-  int this_alternative, this_operand;\n-  int n_alternatives;\n-  int j;\n-\n-  for (j = 0; j < n_operands; j++)\n-    constraints[j] = operand_constraints[j];\n-\n-  /* Compute the number of alternatives in the operands.  reload has\n-     already guaranteed that all operands have the same number of\n-     alternatives.  */\n-\n-  if (n_operands == 0)\n-    n_alternatives = 0;\n-  else\n-    {\n-      n_alternatives = 1;\n-      for (q = constraints[0]; *q; q++)\n-\tn_alternatives += (*q == ',');\n-    }\n-\n-  this_alternative = 0;\n-  while (this_alternative < n_alternatives)\n-    {\n-      int lose = 0;\n-      int i;\n-\n-      /* No operands match, no narrow class requirements yet.  */\n-      for (i = 0; i < n_operands; i++)\n-\t{\n-\t  operand_matches[i] = -1;\n-\t  operand_class[i] = NO_REGS;\n-\t}\n-\n-      for (this_operand = 0; this_operand < n_operands; this_operand++)\n-\t{\n-\t  rtx op = operands[this_operand];\n-\t  enum machine_mode mode = GET_MODE (op);\n-\t  char *p = constraints[this_operand];\n-\t  int offset = 0;\n-\t  int win = 0;\n-\t  int c;\n-\n-\t  if (GET_CODE (op) == SUBREG)\n-\t    {\n-\t      if (GET_CODE (SUBREG_REG (op)) == REG\n-\t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n-\t\toffset = SUBREG_WORD (op);\n-\t      op = SUBREG_REG (op);\n-\t    }\n-\n-\t  /* An empty constraint or empty alternative\n-\t     allows anything which matched the pattern.  */\n-\t  if (*p == 0 || *p == ',')\n-\t    win = 1;\n-\n-\t  while (*p && (c = *p++) != ',')\n-\t    switch (c)\n-\t      {\n-\t      case '=':\n-\t      case '+':\n-\t      case '?':\n-\t      case '&':\n-\t      case '!':\n-\t      case '*':\n-\t      case '%':\n-\t\t/* Ignore these.  */\n-\t\tbreak;\n-\n-\t      case '#':\n-\t\t/* Ignore rest of this alternative.  */\n-\t\twhile (*p && *p != ',') p++;\n-\t\tbreak;\n-\n-\t      case '0':\n-\t      case '1':\n-\t      case '2':\n-\t      case '3':\n-\t      case '4':\n-\t      case '5':\n-\t\t/* This operand must be the same as a previous one.\n-\t\t   This kind of constraint is used for instructions such\n-\t\t   as add when they take only two operands.\n-\n-\t\t   Note that the lower-numbered operand is passed first.  */\n-\n-\t\tif (operands_match_p (operands[c - '0'],\n-\t\t\t\t      operands[this_operand]))\n-\t\t  {\n-\t\t    operand_matches[this_operand] = c - '0';\n-\t\t    win = 1;\n-\t\t  }\n-\t\tbreak;\n-\n-\t      case 'p':\n-\t\t/* p is used for address_operands.  Since this is an asm,\n-\t\t   just to make sure that the operand is valid for Pmode.  */\n-\n-\t\tif (strict_memory_address_p (Pmode, op))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'g':\n-\t\t/* Anything goes unless it is a REG and really has a hard reg\n-\t\t   but the hard reg is not in the class GENERAL_REGS.  */\n-\t\tif (GENERAL_REGS == ALL_REGS\n-\t\t    || GET_CODE (op) != REG\n-\t\t    || reg_fits_class_p (op, GENERAL_REGS, offset, mode))\n-\t\t  {\n-\t\t    if (GET_CODE (op) == REG)\n-\t\t      operand_class[this_operand]\n-\t\t\t= reg_class_subunion[(int) operand_class[this_operand]][(int) GENERAL_REGS];\n-\t\t    win = 1;\n-\t\t  }\n-\t\tbreak;\n-\n-\t      case 'r':\n-\t\tif (GET_CODE (op) == REG\n-\t\t    && (GENERAL_REGS == ALL_REGS\n-\t\t\t|| reg_fits_class_p (op, GENERAL_REGS, offset, mode)))\n-\t\t  {\n-\t\t    operand_class[this_operand]\n-\t\t      = reg_class_subunion[(int) operand_class[this_operand]][(int) GENERAL_REGS];\n-\t\t    win = 1;\n-\t\t  }\n-\t\tbreak;\n-\n-\t      case 'X':\n-\t\t/* This is used for a MATCH_SCRATCH in the cases when we\n-\t\t   don't actually need anything.  So anything goes any time.  */\n-\t\twin = 1;\n-\t\tbreak;\n-\n-\t      case 'm':\n-\t\tif (GET_CODE (op) == MEM)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case '<':\n-\t\tif (GET_CODE (op) == MEM\n-\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_DEC))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case '>':\n-\t\tif (GET_CODE (op) == MEM\n-\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_INC\n-\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_INC))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'E':\n-\t\t/* Match any CONST_DOUBLE, but only if\n-\t\t   we can examine the bits of it reliably.  */\n-\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n-\t\t    && GET_CODE (op) != VOIDmode && ! flag_pretend_float)\n-\t\t  break;\n-\t\tif (GET_CODE (op) == CONST_DOUBLE)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'F':\n-\t\tif (GET_CODE (op) == CONST_DOUBLE)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'G':\n-\t      case 'H':\n-\t\tif (GET_CODE (op) == CONST_DOUBLE\n-\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (op, c))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 's':\n-\t\tif (GET_CODE (op) == CONST_INT\n-\t\t    || (GET_CODE (op) == CONST_DOUBLE\n-\t\t\t&& GET_MODE (op) == VOIDmode))\n-\t\t  break;\n-\t\t/* Fall through */\n-\t      case 'i':\n-\t\tif (CONSTANT_P (op))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'n':\n-\t\tif (GET_CODE (op) == CONST_INT\n-\t\t    || (GET_CODE (op) == CONST_DOUBLE\n-\t\t\t&& GET_MODE (op) == VOIDmode))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'I':\n-\t      case 'J':\n-\t      case 'K':\n-\t      case 'L':\n-\t      case 'M':\n-\t      case 'N':\n-\t      case 'O':\n-\t      case 'P':\n-\t\tif (GET_CODE (op) == CONST_INT\n-\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (op), c))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-#ifdef EXTRA_CONSTRAINT\n-              case 'Q':\n-              case 'R':\n-              case 'S':\n-              case 'T':\n-              case 'U':\n-\t\tif (EXTRA_CONSTRAINT (op, c))\n-\t\t  win = 1;\n-\t\tbreak;\n-#endif\n-\n-\t      case 'V':\n-\t\tif (GET_CODE (op) == MEM && ! offsettable_memref_p (op))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      case 'o':\n-\t\tif (offsettable_memref_p (op))\n-\t\t  win = 1;\n-\t\tbreak;\n-\n-\t      default:\n-\t\tif (GET_CODE (op) == REG\n-\t\t    && reg_fits_class_p (op, REG_CLASS_FROM_LETTER (c),\n-\t\t\t\t\t offset, mode))\n-\t\t  {\n-\t\t    operand_class[this_operand]\n-\t\t      = reg_class_subunion[(int)operand_class[this_operand]][(int) REG_CLASS_FROM_LETTER (c)];\n-\t\t    win = 1;\n-\t\t  }\n-\t      }\n-\n-\t  constraints[this_operand] = p;\n-\t  /* If this operand did not win somehow,\n-\t     this alternative loses.  */\n-\t  if (! win)\n-\t    lose = 1;\n-\t}\n-      /* This alternative won; the operands are ok.\n-\t Change whichever operands this alternative says to change.  */\n-      if (! lose)\n-\tbreak;\n-\n-      this_alternative++;\n-    }\n-\n-  /* For operands constrained to match another operand, copy the other\n-     operand's class to this operand's class.  */\n-  for (j = 0; j < n_operands; j++)\n-    if (operand_matches[j] >= 0)\n-      operand_class[j] = operand_class[operand_matches[j]];\n-\n-  return this_alternative == n_alternatives ? -1 : this_alternative;\n-}\n-\f\n /* Record the life info of each stack reg in INSN, updating REGSTACK.\n-   N_INPUTS is the number of inputs; N_OUTPUTS the outputs.  CONSTRAINTS\n-   is an array of the constraint strings used in the asm statement.\n+   N_INPUTS is the number of inputs; N_OUTPUTS the outputs.\n    OPERANDS is an array of all operands for the insn, and is assumed to\n    contain all output operands, then all inputs operands.\n \n@@ -906,43 +614,47 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n    numbers below refer to that explanation.  */\n \n static void\n-record_asm_reg_life (insn, regstack, operands, constraints,\n-\t\t     n_inputs, n_outputs)\n+record_asm_reg_life (insn, regstack)\n      rtx insn;\n      stack regstack;\n-     rtx *operands;\n-     char **constraints;\n-     int n_inputs, n_outputs;\n {\n   int i;\n-  int n_operands = n_inputs + n_outputs;\n-  int first_input = n_outputs;\n   int n_clobbers;\n   int malformed_asm = 0;\n   rtx body = PATTERN (insn);\n \n-  int *operand_matches = (int *) alloca (n_operands * sizeof (int));\n-\n-  enum reg_class *operand_class \n-    = (enum reg_class *) alloca (n_operands * sizeof (enum reg_class));\n-\n   int reg_used_as_output[FIRST_PSEUDO_REGISTER];\n   int implicitly_dies[FIRST_PSEUDO_REGISTER];\n+  int alt;\n \n   rtx *clobber_reg;\n+  int n_inputs, n_outputs;\n \n   /* Find out what the constraints require.  If no constraint\n      alternative matches, this asm is malformed.  */\n-  i = constrain_asm_operands (n_operands, operands, constraints,\n-\t\t\t      operand_matches, operand_class);\n-  if (i < 0)\n-    malformed_asm = 1;\n+  extract_insn (insn);\n+  constrain_operands (1);\n+  alt = which_alternative;\n+\n+  preprocess_constraints ();\n+\n+  n_inputs = get_asm_operand_n_inputs (body);\n+  n_outputs = recog_n_operands - n_inputs;\n+\n+  if (alt < 0)\n+    {\n+      malformed_asm = 1;\n+      /* Avoid further trouble with this insn.  */\n+      PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n+      PUT_MODE (insn, VOIDmode);\n+      return;\n+    }\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n-  for (i = 0; i < n_operands; i++)\n-    if (GET_CODE (operands[i]) == SUBREG\n-\t&& GET_CODE (SUBREG_REG (operands[i])) == REG)\n-      operands[i] = SUBREG_REG (operands[i]);\n+  for (i = 0; i < recog_n_operands; i++)\n+    if (GET_CODE (recog_operand[i]) == SUBREG\n+\t&& GET_CODE (SUBREG_REG (recog_operand[i])) == REG)\n+      recog_operand[i] = SUBREG_REG (recog_operand[i]);\n \n   /* Set up CLOBBER_REG.  */\n \n@@ -978,15 +690,15 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n \n   bzero ((char *) reg_used_as_output, sizeof (reg_used_as_output));\n   for (i = 0; i < n_outputs; i++)\n-    if (STACK_REG_P (operands[i]))\n+    if (STACK_REG_P (recog_operand[i]))\n       {\n-\tif (reg_class_size[(int) operand_class[i]] != 1)\n+\tif (reg_class_size[(int) recog_op_alt[i][alt].class] != 1)\n \t  {\n \t    error_for_asm (insn, \"Output constraint %d must specify a single register\", i);\n \t    malformed_asm = 1;\n \t  }\n         else\n-\t  reg_used_as_output[REGNO (operands[i])] = 1;\n+\t  reg_used_as_output[REGNO (recog_operand[i])] = 1;\n       }\n \n \n@@ -1011,19 +723,19 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n      popped.  */\n \n   bzero ((char *) implicitly_dies, sizeof (implicitly_dies));\n-  for (i = first_input; i < first_input + n_inputs; i++)\n-    if (STACK_REG_P (operands[i]))\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n+    if (STACK_REG_P (recog_operand[i]))\n       {\n \t/* An input reg is implicitly popped if it is tied to an\n \t   output, or if there is a CLOBBER for it.  */\n \tint j;\n \n \tfor (j = 0; j < n_clobbers; j++)\n-\t  if (operands_match_p (clobber_reg[j], operands[i]))\n+\t  if (operands_match_p (clobber_reg[j], recog_operand[i]))\n \t    break;\n \n-\tif (j < n_clobbers || operand_matches[i] >= 0)\n-\t  implicitly_dies[REGNO (operands[i])] = 1;\n+\tif (j < n_clobbers || recog_op_alt[i][alt].matches >= 0)\n+\t  implicitly_dies[REGNO (recog_operand[i])] = 1;\n       }\n \n   /* Search for first non-popped reg.  */\n@@ -1049,13 +761,13 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n      ???  Detect this more deterministically by having constraint_asm_operands\n      record any earlyclobber.  */\n \n-  for (i = first_input; i < first_input + n_inputs; i++)\n-    if (operand_matches[i] == -1)\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n+    if (recog_op_alt[i][alt].matches == -1)\n       {\n \tint j;\n \n \tfor (j = 0; j < n_outputs; j++)\n-\t  if (operands_match_p (operands[j], operands[i]))\n+\t  if (operands_match_p (recog_operand[j], recog_operand[i]))\n \t    {\n \t      error_for_asm (insn,\n \t\t\t     \"Output operand %d must use `&' constraint\", j);\n@@ -1074,7 +786,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n   /* Process all outputs */\n   for (i = 0; i < n_outputs; i++)\n     {\n-      rtx op = operands[i];\n+      rtx op = recog_operand[i];\n \n       if (! STACK_REG_P (op))\n \t{\n@@ -1096,11 +808,12 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n     }\n \n   /* Process all inputs */\n-  for (i = first_input; i < first_input + n_inputs; i++)\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n     {\n-      if (! STACK_REG_P (operands[i]))\n+      rtx op = recog_operand[i];\n+      if (! STACK_REG_P (op))\n \t{\n-\t  if (stack_regs_mentioned_p (operands[i]))\n+\t  if (stack_regs_mentioned_p (op))\n \t    abort ();\n \t  else\n \t    continue;\n@@ -1110,13 +823,12 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n \t But don't record a death note if there is already a death note,\n \t or if the input is also an output.  */\n \n-      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]))\n-\t  && operand_matches[i] == -1\n-\t  && find_regno_note (insn, REG_DEAD, REGNO (operands[i])) == NULL_RTX)\n-\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, operands[i],\n-\t\t\t\t\t      REG_NOTES (insn));\n+      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (op))\n+\t  && recog_op_alt[i][alt].matches == -1\n+\t  && find_regno_note (insn, REG_DEAD, REGNO (op)) == NULL_RTX)\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, op, REG_NOTES (insn));\n \n-      SET_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]));\n+      SET_HARD_REG_BIT (regstack->reg_set, REGNO (op));\n     }\n }\n \n@@ -1178,29 +890,25 @@ record_reg_life_pat (pat, src, dest, douse)\n    N_INPUTS and N_OUTPUTS are pointers to ints into which the results are\n    placed.  */\n \n-static void\n-get_asm_operand_lengths (body, n_operands, n_inputs, n_outputs)\n+static int\n+get_asm_operand_n_inputs (body)\n      rtx body;\n-     int n_operands;\n-     int *n_inputs, *n_outputs;\n {\n   if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n-    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n+    return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n \n   else if (GET_CODE (body) == ASM_OPERANDS)\n-    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (body);\n+    return ASM_OPERANDS_INPUT_LENGTH (body);\n \n   else if (GET_CODE (body) == PARALLEL\n \t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n-    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)));\n+    return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)));\n \n   else if (GET_CODE (body) == PARALLEL\n \t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n-    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n-  else\n-    abort ();\n+    return ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n \n-  *n_outputs = n_operands - *n_inputs;\n+  abort ();\n }\n \f\n /* Scan INSN, which is in BLOCK, and record the life & death of stack\n@@ -1244,18 +952,7 @@ record_reg_life (insn, block, regstack)\n   n_operands = asm_noperands (PATTERN (insn));\n   if (n_operands >= 0)\n     {\n-      /* This insn is an `asm' with operands.  Decode the operands,\n-\t decide how many are inputs, and record the life information.  */\n-\n-      rtx operands[MAX_RECOG_OPERANDS];\n-      rtx body = PATTERN (insn);\n-      int n_inputs, n_outputs;\n-      char **constraints = (char **) alloca (n_operands * sizeof (char *));\n-\n-      decode_asm_operands (body, operands, NULL_PTR, constraints, NULL_PTR);\n-      get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n-      record_asm_reg_life (insn, regstack, operands, constraints,\n-\t\t\t   n_inputs, n_outputs);\n+      record_asm_reg_life (insn, regstack);\n       return;\n     }\n \n@@ -2417,12 +2114,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \f\n /* Substitute hard regnums for any stack regs in INSN, which has\n    N_INPUTS inputs and N_OUTPUTS outputs.  REGSTACK is the stack info\n-   before the insn, and is updated with changes made here.  CONSTRAINTS is\n-   an array of the constraint strings used in the asm statement.\n-\n-   OPERANDS is an array of the operands, and OPERANDS_LOC is a\n-   parallel array of where the operands were found.  The output operands\n-   all precede the input operands.\n+   before the insn, and is updated with changes made here.\n \n    There are several requirements and assumptions about the use of\n    stack-like regs in asm statements.  These rules are enforced by\n@@ -2431,21 +2123,12 @@ subst_stack_regs_pat (insn, regstack, pat)\n    requirements, since record_asm_stack_regs removes any problem asm.  */\n \n static void\n-subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n-\t\t      n_inputs, n_outputs)\n+subst_asm_stack_regs (insn, regstack)\n      rtx insn;\n      stack regstack;\n-     rtx *operands, **operands_loc;\n-     char **constraints;\n-     int n_inputs, n_outputs;\n {\n-  int n_operands = n_inputs + n_outputs;\n-  int first_input = n_outputs;\n   rtx body = PATTERN (insn);\n-\n-  int *operand_matches = (int *) alloca (n_operands * sizeof (int));\n-  enum reg_class *operand_class \n-    = (enum reg_class *) alloca (n_operands * sizeof (enum reg_class));\n+  int alt;\n \n   rtx *note_reg;\t\t/* Array of note contents */\n   rtx **note_loc;\t\t/* Address of REG field of each note */\n@@ -2459,24 +2142,31 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n   int n_clobbers;\n   rtx note;\n   int i;\n+  int n_inputs, n_outputs;\n \n   /* Find out what the constraints required.  If no constraint\n      alternative matches, that is a compiler bug: we should have caught\n      such an insn during the life analysis pass (and reload should have\n      caught it regardless).  */\n+  extract_insn (insn);\n+  constrain_operands (1);\n+  alt = which_alternative;\n \n-  i = constrain_asm_operands (n_operands, operands, constraints,\n-\t\t\t      operand_matches, operand_class);\n-  if (i < 0)\n+  preprocess_constraints ();\n+\n+  n_inputs = get_asm_operand_n_inputs (body);\n+  n_outputs = recog_n_operands - n_inputs;\n+  \n+  if (alt < 0)\n     abort ();\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n-  for (i = 0; i < n_operands; i++)\n-    if (GET_CODE (operands[i]) == SUBREG\n-\t&& GET_CODE (SUBREG_REG (operands[i])) == REG)\n+  for (i = 0; i < recog_n_operands; i++)\n+    if (GET_CODE (recog_operand[i]) == SUBREG\n+\t&& GET_CODE (SUBREG_REG (recog_operand[i])) == REG)\n       {\n-\toperands_loc[i] = & SUBREG_REG (operands[i]);\n-\toperands[i] = SUBREG_REG (operands[i]);\n+\trecog_operand_loc[i] = & SUBREG_REG (recog_operand[i]);\n+\trecog_operand[i] = SUBREG_REG (recog_operand[i]);\n       }\n \n   /* Set up NOTE_REG, NOTE_LOC and NOTE_KIND.  */\n@@ -2546,34 +2236,35 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \n   /* Put the input regs into the desired place in TEMP_STACK.  */\n \n-  for (i = first_input; i < first_input + n_inputs; i++)\n-    if (STACK_REG_P (operands[i])\n-\t&& reg_class_subset_p (operand_class[i], FLOAT_REGS)\n-\t&& operand_class[i] != FLOAT_REGS)\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n+    if (STACK_REG_P (recog_operand[i])\n+\t&& reg_class_subset_p (recog_op_alt[i][alt].class,\n+\t\t\t       FLOAT_REGS)\n+\t&& recog_op_alt[i][alt].class != FLOAT_REGS)\n       {\n \t/* If an operand needs to be in a particular reg in\n \t   FLOAT_REGS, the constraint was either 't' or 'u'.  Since\n \t   these constraints are for single register classes, and reload\n \t   guaranteed that operand[i] is already in that class, we can\n-\t   just use REGNO (operands[i]) to know which actual reg this\n+\t   just use REGNO (recog_operand[i]) to know which actual reg this\n \t   operand needs to be in.  */\n \n-\tint regno = get_hard_regnum (&temp_stack, operands[i]);\n+\tint regno = get_hard_regnum (&temp_stack, recog_operand[i]);\n \n \tif (regno < 0)\n \t  abort ();\n \n-\tif (regno != REGNO (operands[i]))\n+\tif (regno != REGNO (recog_operand[i]))\n \t  {\n-\t    /* operands[i] is not in the right place.  Find it\n+\t    /* recog_operand[i] is not in the right place.  Find it\n \t       and swap it with whatever is already in I's place.\n-\t       K is where operands[i] is now.  J is where it should\n+\t       K is where recog_operand[i] is now.  J is where it should\n \t       be.  */\n \t    int j, k, temp;\n \n \t    k = temp_stack.top - (regno - FIRST_STACK_REG);\n \t    j = (temp_stack.top\n-\t\t - (REGNO (operands[i]) - FIRST_STACK_REG));\n+\t\t - (REGNO (recog_operand[i]) - FIRST_STACK_REG));\n \n \t    temp = temp_stack.reg[k];\n \t    temp_stack.reg[k] = temp_stack.reg[j];\n@@ -2589,15 +2280,15 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n   /* Make the needed input register substitutions.  Do death notes and\n      clobbers too, because these are for inputs, not outputs.  */\n \n-  for (i = first_input; i < first_input + n_inputs; i++)\n-    if (STACK_REG_P (operands[i]))\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n+    if (STACK_REG_P (recog_operand[i]))\n       {\n-\tint regnum = get_hard_regnum (regstack, operands[i]);\n+\tint regnum = get_hard_regnum (regstack, recog_operand[i]);\n \n \tif (regnum < 0)\n \t  abort ();\n \n-\treplace_reg (operands_loc[i], regnum);\n+\treplace_reg (recog_operand_loc[i], regnum);\n       }\n \n   for (i = 0; i < n_notes; i++)\n@@ -2629,21 +2320,21 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \n   /* Now remove from REGSTACK any inputs that the asm implicitly popped.  */\n \n-  for (i = first_input; i < first_input + n_inputs; i++)\n-    if (STACK_REG_P (operands[i]))\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n+    if (STACK_REG_P (recog_operand[i]))\n       {\n \t/* An input reg is implicitly popped if it is tied to an\n \t   output, or if there is a CLOBBER for it.  */\n \tint j;\n \n \tfor (j = 0; j < n_clobbers; j++)\n-\t  if (operands_match_p (clobber_reg[j], operands[i]))\n+\t  if (operands_match_p (clobber_reg[j], recog_operand[i]))\n \t    break;\n \n-\tif (j < n_clobbers || operand_matches[i] >= 0)\n+\tif (j < n_clobbers || recog_op_alt[i][alt].matches >= 0)\n \t  {\n-\t    /* operands[i] might not be at the top of stack.  But that's OK,\n-\t       because all we need to do is pop the right number of regs\n+\t    /* recog_operand[i] might not be at the top of stack.  But that's\n+\t       OK, because all we need to do is pop the right number of regs\n \t       off of the top of the reg-stack.  record_asm_stack_regs\n \t       guaranteed that all implicitly popped regs were grouped\n \t       at the top of the reg-stack.  */\n@@ -2664,7 +2355,7 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n       int j;\n \n       for (j = 0; j < n_outputs; j++)\n-\tif (STACK_REG_P (operands[j]) && REGNO (operands[j]) == i)\n+\tif (STACK_REG_P (recog_operand[j]) && REGNO (recog_operand[j]) == i)\n \t  {\n \t    regstack->reg[++regstack->top] = i;\n \t    SET_HARD_REG_BIT (regstack->reg_set, i);\n@@ -2680,31 +2371,32 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n      in the death notes have already been substituted.  */\n \n   for (i = 0; i < n_outputs; i++)\n-    if (STACK_REG_P (operands[i]))\n+    if (STACK_REG_P (recog_operand[i]))\n       {\n \tint j;\n \n \tfor (j = 0; j < n_notes; j++)\n-\t  if (REGNO (operands[i]) == REGNO (note_reg[j])\n+\t  if (REGNO (recog_operand[i]) == REGNO (note_reg[j])\n \t      && note_kind[j] == REG_UNUSED)\n \t    {\n-\t      insn = emit_pop_insn (insn, regstack, operands[i],\n+\t      insn = emit_pop_insn (insn, regstack, recog_operand[i],\n \t\t\t\t    emit_insn_after);\n \t      break;\n \t    }\n       }\n \n-  for (i = first_input; i < first_input + n_inputs; i++)\n-    if (STACK_REG_P (operands[i]))\n+  for (i = n_outputs; i < n_outputs + n_inputs; i++)\n+    if (STACK_REG_P (recog_operand[i]))\n       {\n \tint j;\n \n \tfor (j = 0; j < n_notes; j++)\n-\t  if (REGNO (operands[i]) == REGNO (note_reg[j])\n+\t  if (REGNO (recog_operand[i]) == REGNO (note_reg[j])\n \t      && note_kind[j] == REG_DEAD\n-\t      && TEST_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i])))\n+\t      && TEST_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\t    REGNO (recog_operand[i])))\n \t    {\n-\t      insn = emit_pop_insn (insn, regstack, operands[i],\n+\t      insn = emit_pop_insn (insn, regstack, recog_operand[i],\n \t\t\t\t    emit_insn_after);\n \t      break;\n \t    }\n@@ -2723,7 +2415,6 @@ subst_stack_regs (insn, regstack)\n {\n   register rtx *note_link, note;\n   register int i;\n-  int n_operands;\n \n   if (GET_CODE (insn) == CALL_INSN)\n    {\n@@ -2755,25 +2446,14 @@ subst_stack_regs (insn, regstack)\n \n   if (GET_MODE (insn) == QImode)\n     {\n-      n_operands = asm_noperands (PATTERN (insn));\n+      int n_operands = asm_noperands (PATTERN (insn));\n       if (n_operands >= 0)\n \t{\n \t  /* This insn is an `asm' with operands.  Decode the operands,\n \t     decide how many are inputs, and do register substitution.\n \t     Any REG_UNUSED notes will be handled by subst_asm_stack_regs.  */\n \n-\t  rtx operands[MAX_RECOG_OPERANDS];\n-\t  rtx *operands_loc[MAX_RECOG_OPERANDS];\n-\t  rtx body = PATTERN (insn);\n-\t  int n_inputs, n_outputs;\n-\t  char **constraints\n-\t    = (char **) alloca (n_operands * sizeof (char *));\n-\n-\t  decode_asm_operands (body, operands, operands_loc,\n-\t\t\t       constraints, NULL_PTR);\n-\t  get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n-\t  subst_asm_stack_regs (insn, regstack, operands, operands_loc,\n-\t\t\t\tconstraints, n_inputs, n_outputs);\n+\t  subst_asm_stack_regs (insn, regstack);\n \t  return;\n \t}\n "}, {"sha": "7a8a6571305f5e5b92572e05969767eac135ae14", "filename": "gcc/stmt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62a15e367dd53a270f7766c5c62a82629478d3e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f62a15e367dd53a270f7766c5c62a82629478d3e", "patch": "@@ -1219,6 +1219,12 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       int nalternatives = n_occurrences (',', TREE_STRING_POINTER (tmp));\n       tree next = inputs;\n \n+      if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n+\t{\n+\t  error (\"too many alternatives in `asm'\");\n+\t  return;\n+\t}\n+      \n       tmp = outputs;\n       while (tmp)\n \t{"}]}