{"sha": "45120407b56b3ca66644e33d5ba728438fc7160c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUxMjA0MDdiNTZiM2NhNjY2NDRlMzNkNWJhNzI4NDM4ZmM3MTYwYw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-17T22:34:06Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-17T22:34:06Z"}, "message": "sparc.md (sltu, sgeu): Don't FAIL, call gen_compare_reg.\n\n\t* config/sparc/sparc.md (sltu, sgeu): Don't FAIL, call\n\tgen_compare_reg.\n\t(movsf_const_intreg, movsf_const_high, movsf_const_lo,\n\tmovdf_const_intreg and helper splits): New patterns to move float\n\tconstants into integer registers.\n\t(negtf2, negdf2, abstf2, absdf2): Rework using new patterns and\n\tsplits.\n\nFrom-SVN: r21813", "tree": {"sha": "b049e1530ce1db3c813d5d5cd2864d8a4c16a016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b049e1530ce1db3c813d5d5cd2864d8a4c16a016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45120407b56b3ca66644e33d5ba728438fc7160c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45120407b56b3ca66644e33d5ba728438fc7160c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45120407b56b3ca66644e33d5ba728438fc7160c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45120407b56b3ca66644e33d5ba728438fc7160c/comments", "author": null, "committer": null, "parents": [{"sha": "648f19f64760673ea9cbf6c429477353b92e68c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648f19f64760673ea9cbf6c429477353b92e68c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648f19f64760673ea9cbf6c429477353b92e68c6"}], "stats": {"total": 384, "additions": 323, "deletions": 61}, "files": [{"sha": "a99a818c9905565189cc7495c4681f716603b5e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45120407b56b3ca66644e33d5ba728438fc7160c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45120407b56b3ca66644e33d5ba728438fc7160c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45120407b56b3ca66644e33d5ba728438fc7160c", "patch": "@@ -1,3 +1,13 @@\n+Mon Aug 17 21:26:38 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.md (sltu, sgeu): Don't FAIL, call\n+\tgen_compare_reg.\n+\t(movsf_const_intreg, movsf_const_high, movsf_const_lo,\n+\tmovdf_const_intreg and helper splits): New patterns to move float\n+\tconstants into integer registers.\n+\t(negtf2, negdf2, abstf2, absdf2): Rework using new patterns and\n+\tsplits.\n+\n Mon Aug 17 11:46:19 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* From Graham"}, {"sha": "c4c800390864f6e924e84af1980f0f0e0c8e7a97", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 313, "deletions": 61, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45120407b56b3ca66644e33d5ba728438fc7160c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45120407b56b3ca66644e33d5ba728438fc7160c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=45120407b56b3ca66644e33d5ba728438fc7160c", "patch": "@@ -37,10 +37,12 @@\n ;;\t\t\t9\tsethh\n ;;\t\t\t10\tsetlm\n ;;\t\t\t11\tembmedany_sethi, embmedany_brsum\n+;;                      12\tmovsf_const_high\n ;;\t\t\t13\tembmedany_textuhi\n ;;\t\t\t14\tembmedany_texthi\n ;;\t\t\t15\tembmedany_textulo\n ;;\t\t\t16\tembmedany_textlo\n+;;                      17\tmovsf_const_lo\n ;;\t\t\t18\tsethm\n ;;\t\t\t19\tsetlo\n ;;\n@@ -983,8 +985,7 @@\n       if (gen_v9_scc (LTU, operands))\n \tDONE;\n     }\n-  /* XXX less than unsigned == Carry */\n-  FAIL;\n+  operands[1] = gen_compare_reg (LTU, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n (define_expand \"sgeu\"\n@@ -998,7 +999,7 @@\n       if (gen_v9_scc (GEU, operands))\n \tDONE;\n     }\n-  FAIL;\n+  operands[1] = gen_compare_reg (GEU, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n (define_expand \"sleu\"\n@@ -2722,6 +2723,74 @@\n \f\n ;; Floating point move insns\n \n+(define_insn \"*movsf_const_intreg\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,r\")\n+        (match_operand:SF 1 \"\"                 \"m,F\"))]\n+  \"TARGET_FPU\n+   && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && GET_CODE (operands[0]) == REG\"\n+  \"*\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  if (which_alternative == 0)\n+    return \\\"ld\\\\t%1, %0\\\";\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  if (SPARC_SIMM13_P (i) || SPARC_SETHI_P (i))\n+    {\n+      operands[1] = GEN_INT (i);\n+      if (SPARC_SIMM13_P (INTVAL (operands[1])))\n+        return \\\"mov\\\\t%1, %0\\\";\n+      else if (SPARC_SETHI_P (INTVAL (operands[1])))\n+        return \\\"sethi\\\\t%%hi(%a1), %0\\\";\n+    }\n+  else\n+    return \\\"#\\\";\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+;; There isn't much I can do about this, if I change the\n+;; mode then flow info gets really confused because the\n+;; destination no longer looks the same.  Ho hum...\n+(define_insn \"*movsf_const_high\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (unspec:SF [(match_operand 1 \"const_int_operand\" \"\")] 12))]\n+  \"\"\n+  \"sethi\\\\t%%hi(%a1), %0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*movsf_const_lo\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (unspec:SF [(match_operand 1 \"register_operand\" \"r\")\n+                    (match_operand 2 \"const_int_operand\" \"\")] 17))]\n+  \"\"\n+  \"or\\\\t%1, %%lo(%a2), %0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_FPU\n+   && GET_CODE (operands[0]) == REG\n+   && REGNO (operands[0]) < 32\"\n+  [(set (match_dup 0) (unspec:SF [(match_dup 1)] 12))\n+   (set (match_dup 0) (unspec:SF [(match_dup 0) (match_dup 1)] 17))]\n+  \"\n+{\n+  REAL_VALUE_TYPE r;\n+  long i;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (r, i);\n+  operands[1] = GEN_INT (i);\n+}\")\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n@@ -2808,6 +2877,60 @@\n   [(set_attr \"type\" \"move,load,store\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*movdf_const_intreg\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=e,e,r\")\n+        (match_operand:DF 1 \"\"                 \"T,o,F\"))]\n+  \"TARGET_FPU\n+   && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && GET_CODE (operands[0]) == REG\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"ldd\\\\t%1, %0\\\";\n+  else\n+    return \\\"#\\\";\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_FPU\n+   && GET_CODE (operands[1]) == CONST_DOUBLE\n+   && GET_CODE (operands[0]) == REG\n+   && REGNO (operands[0]) < 32\n+   && reload_completed\"\n+  [(clobber (const_int 0))]\n+  \"\n+{\n+  REAL_VALUE_TYPE r;\n+  long l[2];\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+  operands[0] = gen_rtx_raw_REG (DImode, REGNO (operands[0]));\n+\n+  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n+\t\t\tGEN_INT (l[0])));\n+\n+  /* Slick... but this trick loses if this subreg constant part\n+     can be done in one insn.  */\n+  if (l[1] == l[0]\n+      && !(SPARC_SETHI_P (l[0])\n+\t   || SPARC_SIMM13_P (l[0])))\n+    {\n+      emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n+\t\t\t    gen_highpart (SImode, operands[0])));\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n+\t\t\t    GEN_INT (l[1])));\n+    }\n+  DONE;\n+}\")\n+\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n@@ -6274,44 +6397,109 @@\n   [(set_attr \"type\" \"fpdivs\")\n    (set_attr \"length\" \"1\")])\n \n-;; XXX\n-(define_insn \"negtf2\"\n+(define_expand \"negtf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n-  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n   \"TARGET_FPU\"\n-  \"*\n-{\n-  /* v9: can't use fnegs, won't work with upper regs.  */\n-  if (which_alternative == 0)\n-   return TARGET_V9 ? \\\"fnegd %0,%0\\\" : \\\"fnegs %0,%0\\\";\n-  else\n-   return TARGET_V9 ? \\\"fnegd %1,%0\\;fmovd %S1,%S0\\\"\n-     : \\\"fnegs %1,%0\\;fmovs %R1,%R0\\;fmovs %S1,%S0\\;fmovs %T1,%T0\\\";\n-}\"\n+  \"\")\n+\n+(define_insn \"*negtf2_notv9\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n+  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n+  \"TARGET_FPU\n+   && ! TARGET_V9\"\n+  \"@\n+  fnegs\\\\t%0, %0\n+  #\"\n   [(set_attr \"type\" \"fpmove\")\n-   (set_attr_alternative \"length\"\n-     [(const_int 1)\n-      (if_then_else (eq_attr \"isa\" \"v9\") (const_int 2) (const_int 4))])])\n+   (set_attr \"length\" \"1,2\")])\n \n-;; XXX\n-(define_insn \"negdf2\"\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n+  \"TARGET_FPU\n+   && ! TARGET_V9\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[1]) == REG\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && reload_completed\"\n+  [(set (match_dup 2) (neg (match_dup 3)))\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 6) (match_dup 7))]\n+  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n+   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n+   operands[6] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 2);\n+   operands[7] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 2);\")\n+\n+(define_insn \"*negtf2_v9\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n+  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n+  \"TARGET_FPU && TARGET_V9\"\n+  \"@\n+  fnegd\\\\t%0, %0\n+  #\"\n+  [(set_attr \"type\" \"fpmove\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n+  \"TARGET_FPU\n+   && TARGET_V9\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[1]) == REG\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && reload_completed\"\n+  [(set (match_dup 2) (neg:DF (match_dup 3)))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n+   operands[5] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\")\n+\n+(define_expand \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"TARGET_FPU\"\n+  \"\")\n+\n+(define_insn \"*negdf2_notv9\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"0,e\")))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  if (TARGET_V9)\n-    return \\\"fnegd %1,%0\\\";\n-  else if (which_alternative == 0)\n-   return \\\"fnegs %0,%0\\\";\n-  else\n-   return \\\"fnegs %1,%0\\;fmovs %R1,%R0\\\";\n-}\"\n+  \"TARGET_FPU && ! TARGET_V9\"\n+  \"@\n+  fnegs\\\\t%0, %0\n+  #\"\n   [(set_attr \"type\" \"fpmove\")\n-   (set_attr_alternative \"length\"\n-     [(const_int 1)\n-      (if_then_else (eq_attr \"isa\" \"v9\") (const_int 1) (const_int 2))])])\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"TARGET_FPU\n+   && ! TARGET_V9\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[1]) == REG\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && reload_completed\"\n+  [(set (match_dup 2) (neg:SF (match_dup 3)))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n+   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\")\n+\n+(define_insn \"*negdf2_v9\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_V9\"\n+  \"fnegd\\\\t%0, %0\"\n+  [(set_attr \"type\" \"fpmove\")\n+   (set_attr \"length\" \"1\")])\n \n (define_insn \"negsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n@@ -6321,44 +6509,108 @@\n   [(set_attr \"type\" \"fpmove\")\n    (set_attr \"length\" \"1\")])\n \n-;; XXX\n (define_insn \"abstf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n+  \"TARGET_FPU\"\n+  \"\")\n+\n+(define_insn \"*abstf2_notv9\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n   ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n+  \"TARGET_FPU && ! TARGET_V9\"\n+  \"@\n+  fabss\\\\t%0, %0\n+  #\"\n+  [(set_attr \"type\" \"fpmove\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n+  \"TARGET_FPU\n+   && ! TARGET_V9\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[1]) == REG\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && reload_completed\"\n+  [(set (match_dup 2) (abs:SF (match_dup 3)))\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 6) (match_dup 7))]\n+  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n+   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n+   operands[6] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 2);\n+   operands[7] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 2);\")\n+\n+(define_insn \"*abstf2_v9\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n+  ; We don't use quad float insns here so we don't need TARGET_HARD_QUAD.\n+  \"TARGET_FPU && TARGET_V9\"\n+  \"@\n+  fabsd\\\\t%0, %0\n+  #\"\n+  [(set_attr \"type\" \"fpmove\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n+  \"TARGET_FPU\n+   && TARGET_V9\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[1]) == REG\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && reload_completed\"\n+  [(set (match_dup 2) (abs:DF (match_dup 3)))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n+   operands[5] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\")\n+\n+(define_expand \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\"\n-  \"*\n-{\n-  /* v9: can't use fabss, won't work with upper regs.  */\n-  if (which_alternative == 0)\n-    return TARGET_V9 ? \\\"fabsd %0,%0\\\" : \\\"fabss %0,%0\\\";\n-  else\n-    return TARGET_V9 ? \\\"fabsd %1,%0\\;fmovd %S1,%S0\\\"\n-      : \\\"fabss %1,%0\\;fmovs %R1,%R0\\;fmovs %S1,%S0\\;fmovs %T1,%T0\\\";\n-}\"\n+  \"\")\n+\n+(define_insn \"*absdf2_notv9\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0,e\")))]\n+  \"TARGET_FPU && ! TARGET_V9\"\n+  \"@\n+  fabss\\\\t%0, %0\n+  #\"\n   [(set_attr \"type\" \"fpmove\")\n-   (set_attr_alternative \"length\"\n-     [(const_int 1)\n-      (if_then_else (eq_attr \"isa\" \"v9\") (const_int 2) (const_int 4))])])\n+   (set_attr \"length\" \"1,2\")])\n \n-;; XXX\n-(define_insn \"absdf2\"\n+(define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n \t(abs:DF (match_operand:DF 1 \"register_operand\" \"0,e\")))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  if (TARGET_V9)\n-    return \\\"fabsd %1,%0\\\";\n-  else if (which_alternative == 0)\n-    return \\\"fabss %0,%0\\\";\n-  else\n-    return \\\"fabss %1,%0\\;fmovs %R1,%R0\\\";\n-}\"\n+  \"TARGET_FPU\n+   && ! TARGET_V9\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[1]) == REG\n+   && REGNO (operands[0]) != REGNO (operands[1])\n+   && reload_completed\"\n+  [(set (match_dup 2) (abs:SF (match_dup 3)))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n+   operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n+   operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\")\n+\n+(define_insn \"*absdf2_v9\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_V9\"\n+  \"fabsd\\\\t%0, %0\"\n   [(set_attr \"type\" \"fpmove\")\n-   (set_attr_alternative \"length\"\n-     [(const_int 1)\n-      (if_then_else (eq_attr \"isa\" \"v9\") (const_int 1) (const_int 2))])])\n+   (set_attr \"length\" \"1\")])\n \n (define_insn \"abssf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")"}]}