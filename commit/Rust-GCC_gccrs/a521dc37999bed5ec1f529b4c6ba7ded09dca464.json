{"sha": "a521dc37999bed5ec1f529b4c6ba7ded09dca464", "node_id": "C_kwDOANBUbNoAKGE1MjFkYzM3OTk5YmVkNWVjMWY1MjliNGM2YmE3ZGVkMDlkY2E0NjQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-29T16:18:20Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-04T07:45:58Z"}, "message": "[Ada] Use static stack allocation for small string if-expressions\n\nThis changes the expanded code generated for if-expressions of 1-dimensional\narrays to create a static temporary on the stack if a small upper bound can\nbe computed for the length of a subtype covering the result.  Static stack\nallocation is preferred over dynamic allocation for code generation purpose.\n\nThis also contains a couple of enhancements to the support code for checks,\nso as to avoid generating useless checks during the modified expansion.\n\ngcc/ada/\n\n\t* checks.adb (Apply_Length_Check_On_Assignment): Return early if\n\tthe Suppress_Assignment_Checks flag is set.\n\t(Selected_Range_Checks): Deal with conditional expressions.\n\t* exp_ch4.adb (Too_Large_Length_For_Array): New constant.\n\t(Expand_Concatenate): Use it in lieu of Too_Large_Max_Length.\n\t(Expand_N_If_Expression): If the result has a unidimensional array\n\ttype but the dependent expressions have constrained subtypes with\n\tknown bounds, create a static temporary on the stack with a subtype\n\tcovering the result.\n\t(Get_First_Index_Bounds): Deal with string literals.\n\t* uintp.ads (Uint_256): New deferred constant.\n\t* sinfo.ads (Suppress_Assignment_Checks): Document new usage.", "tree": {"sha": "88955b877c7effb7e9b767fdf1d2525fe8ff585b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88955b877c7effb7e9b767fdf1d2525fe8ff585b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a521dc37999bed5ec1f529b4c6ba7ded09dca464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a521dc37999bed5ec1f529b4c6ba7ded09dca464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a521dc37999bed5ec1f529b4c6ba7ded09dca464", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a521dc37999bed5ec1f529b4c6ba7ded09dca464/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0896e2b79a3f7864b08f221a157a5c7fe8958116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0896e2b79a3f7864b08f221a157a5c7fe8958116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0896e2b79a3f7864b08f221a157a5c7fe8958116"}], "stats": {"total": 395, "additions": 364, "deletions": 31}, "files": [{"sha": "22577c8fe583170445d89c2865574152e1674573", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a521dc37999bed5ec1f529b4c6ba7ded09dca464", "patch": "@@ -2297,6 +2297,15 @@ package body Checks is\n       Assign : constant Node_Id := Parent (Target);\n \n    begin\n+      --  Do not apply length checks if parent is still an assignment statement\n+      --  with Suppress_Assignment_Checks flag set.\n+\n+      if Nkind (Assign) = N_Assignment_Statement\n+        and then Suppress_Assignment_Checks (Assign)\n+      then\n+         return;\n+      end if;\n+\n       --  No check is needed for the initialization of an object whose\n       --  nominal subtype is unconstrained.\n \n@@ -6462,7 +6471,7 @@ package body Checks is\n       end if;\n \n       --  Do not set range check flag if parent is assignment statement or\n-      --  object declaration with Suppress_Assignment_Checks flag set\n+      --  object declaration with Suppress_Assignment_Checks flag set.\n \n       if Nkind (Parent (N)) in N_Assignment_Statement | N_Object_Declaration\n         and then Suppress_Assignment_Checks (Parent (N))\n@@ -10500,6 +10509,11 @@ package body Checks is\n       --  Returns expression to compute:\n       --    N'First or N'Last using Duplicate_Subexpr_No_Checks\n \n+      function Is_Cond_Expr_Ge (N : Node_Id; V : Node_Id) return Boolean;\n+      function Is_Cond_Expr_Le (N : Node_Id; V : Node_Id) return Boolean;\n+      --  Return True if N is a conditional expression whose dependent\n+      --  expressions are all known and greater/lower than or equal to V.\n+\n       function Range_E_Cond\n         (Exptyp : Entity_Id;\n          Typ    : Entity_Id;\n@@ -10522,6 +10536,16 @@ package body Checks is\n       --  Return expression to compute:\n       --    Exp'First < Typ'First or else Exp'Last > Typ'Last\n \n+      function \"<\" (Left, Right : Node_Id) return Boolean\n+      is (if Is_Floating_Point_Type (S_Typ)\n+          then Expr_Value_R (Left) < Expr_Value_R (Right)\n+          else Expr_Value   (Left) < Expr_Value   (Right));\n+      function \"<=\" (Left, Right : Node_Id) return Boolean\n+      is (if Is_Floating_Point_Type (S_Typ)\n+          then Expr_Value_R (Left) <= Expr_Value_R (Right)\n+          else Expr_Value   (Left) <= Expr_Value   (Right));\n+      --  Convenience comparison functions of integer or floating point values\n+\n       ---------------\n       -- Add_Check --\n       ---------------\n@@ -10702,6 +10726,60 @@ package body Checks is\n               Make_Integer_Literal (Loc, Indx)));\n       end Get_N_Last;\n \n+      ---------------------\n+      -- Is_Cond_Expr_Ge --\n+      ---------------------\n+\n+      function Is_Cond_Expr_Ge (N : Node_Id; V : Node_Id) return Boolean is\n+      begin\n+         --  Only if expressions are relevant for the time being\n+\n+         if Nkind (N) = N_If_Expression then\n+            declare\n+               Cond  : constant Node_Id := First (Expressions (N));\n+               Thenx : constant Node_Id := Next (Cond);\n+               Elsex : constant Node_Id := Next (Thenx);\n+\n+            begin\n+               return Compile_Time_Known_Value (Thenx)\n+                 and then V <= Thenx\n+                 and then\n+                   ((Compile_Time_Known_Value (Elsex) and then V <= Elsex)\n+                    or else Is_Cond_Expr_Ge (Elsex, V));\n+            end;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Cond_Expr_Ge;\n+\n+      ---------------------\n+      -- Is_Cond_Expr_Le --\n+      ---------------------\n+\n+      function Is_Cond_Expr_Le (N : Node_Id; V : Node_Id) return Boolean is\n+      begin\n+         --  Only if expressions are relevant for the time being\n+\n+         if Nkind (N) = N_If_Expression then\n+            declare\n+               Cond  : constant Node_Id := First (Expressions (N));\n+               Thenx : constant Node_Id := Next (Cond);\n+               Elsex : constant Node_Id := Next (Thenx);\n+\n+            begin\n+               return Compile_Time_Known_Value (Thenx)\n+                 and then Thenx <= V\n+                 and then\n+                   ((Compile_Time_Known_Value (Elsex) and then Elsex <= V)\n+                    or else Is_Cond_Expr_Le (Elsex, V));\n+            end;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Cond_Expr_Le;\n+\n       ------------------\n       -- Range_E_Cond --\n       ------------------\n@@ -10783,13 +10861,6 @@ package body Checks is\n                    Get_E_First_Or_Last (Loc, Typ, Indx, Name_Last)));\n       end Range_N_Cond;\n \n-      function \"<\" (Left, Right : Node_Id) return Boolean\n-      is (if Is_Floating_Point_Type (S_Typ)\n-          then Expr_Value_R (Left) < Expr_Value_R (Right)\n-          else Expr_Value   (Left) < Expr_Value   (Right));\n-      --  Convenience comparison function of integer or floating point\n-      --  values.\n-\n    --  Start of processing for Selected_Range_Checks\n \n    begin\n@@ -10885,6 +10956,14 @@ package body Checks is\n                then\n                   LB := T_LB;\n                   Known_LB := True;\n+\n+               --  Similarly; deal with the case where the low bound is a\n+               --  conditional expression whose result is greater than or\n+               --  equal to the target low bound.\n+\n+               elsif Is_Cond_Expr_Ge (LB, T_LB) then\n+                  LB := T_LB;\n+                  Known_LB := True;\n                end if;\n \n                --  Likewise for the high bound\n@@ -10897,6 +10976,10 @@ package body Checks is\n                then\n                   HB := T_HB;\n                   Known_HB := True;\n+\n+               elsif Is_Cond_Expr_Le (HB, T_HB) then\n+                  HB := T_HB;\n+                  Known_HB := True;\n                end if;\n             end if;\n "}, {"sha": "288ce9a9958dc57225f3822bee5e0b61cbfe8f02", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 270, "deletions": 22, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a521dc37999bed5ec1f529b4c6ba7ded09dca464", "patch": "@@ -81,6 +81,10 @@ with Warnsw;         use Warnsw;\n \n package body Exp_Ch4 is\n \n+   Too_Large_Length_For_Array : constant Unat := Uint_256;\n+   --  Threshold from which we do not try to create static array temporaries in\n+   --  order to eliminate dynamic stack allocations.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -2693,9 +2697,6 @@ package body Exp_Ch4 is\n       --  this loop is complete, always contains the last operand (which is not\n       --  the same as Operands (NN), since null operands are skipped).\n \n-      Too_Large_Max_Length : constant Unat := UI_From_Int (256);\n-      --  Threshold from which the computation of maximum lengths is useless\n-\n       --  Arrays describing the operands, only the first NN entries of each\n       --  array are set (NN < N when we exclude known null operands).\n \n@@ -2711,9 +2712,9 @@ package body Exp_Ch4 is\n       --  corresponding entry in Is_Fixed_Length is True.\n \n       Max_Length : array (1 .. N) of Unat;\n-      --  Set to the maximum length of operand, or Too_Large_Max_Length if it\n-      --  is not known. Entries in this array are set only if the corresponding\n-      --  entry in Is_Fixed_Length is False;\n+      --  Set to the maximum length of operand, or Too_Large_Length_For_Array\n+      --  if it is not known. Entries in this array are set only if the\n+      --  corresponding entry in Is_Fixed_Length is False;\n \n       Opnd_Low_Bound : array (1 .. N) of Node_Id;\n       --  Set to lower bound of operand. Either an integer literal in the case\n@@ -2733,9 +2734,9 @@ package body Exp_Ch4 is\n       --  to just do a Copy_Node to get an appropriate copy. The extra zeroth\n       --  entry always is set to zero. The length is of type Artyp.\n \n-      Max_Aggr_Length : Unat := Too_Large_Max_Length;\n-      --  Set to the maximum total length, or at least Too_Large_Max_Length if\n-      --  it is not known.\n+      Max_Aggr_Length : Unat := Too_Large_Length_For_Array;\n+      --  Set to the maximum total length, or Too_Large_Length_For_Array at\n+      --  least if it is not known.\n \n       Low_Bound : Node_Id := Empty;\n       --  A tree node representing the low bound of the result (of type Ityp).\n@@ -3115,7 +3116,7 @@ package body Exp_Ch4 is\n                   end;\n \n                else\n-                  Max_Length (NN) := Too_Large_Max_Length;\n+                  Max_Length (NN) := Too_Large_Length_For_Array;\n                end if;\n \n                Append_To (Actions,\n@@ -3362,7 +3363,7 @@ package body Exp_Ch4 is\n \n       if Compile_Time_Known_Value (Low_Bound)\n         and then not Compile_Time_Known_Value (High_Bound)\n-        and then Max_Aggr_Length < Too_Large_Max_Length\n+        and then Max_Aggr_Length < Too_Large_Length_For_Array\n       then\n          declare\n             Known_High_Bound : constant Node_Id :=\n@@ -5860,19 +5861,43 @@ package body Exp_Ch4 is\n       Elsex : constant Node_Id    := Next (Thenx);\n       Typ   : constant Entity_Id  := Etype (N);\n \n-      Actions      : List_Id;\n-      Decl         : Node_Id;\n-      Expr         : Node_Id;\n-      New_If       : Node_Id;\n-      New_N        : Node_Id;\n-\n+      Force_Expand : constant Boolean := Is_Anonymous_Access_Actual (N);\n       --  Determine if we are dealing with a special case of a conditional\n       --  expression used as an actual for an anonymous access type which\n       --  forces us to transform the if expression into an expression with\n       --  actions in order to create a temporary to capture the level of the\n       --  expression in each branch.\n \n-      Force_Expand : constant Boolean := Is_Anonymous_Access_Actual (N);\n+      function OK_For_Single_Subtype (T1, T2 : Entity_Id) return Boolean;\n+      --  Return true if it is acceptable to use a single subtype for two\n+      --  dependent expressions of subtype T1 and T2 respectively, which are\n+      --  unidimensional arrays whose index bounds are known at compile time.\n+\n+      ---------------------------\n+      -- OK_For_Single_Subtype --\n+      ---------------------------\n+\n+      function OK_For_Single_Subtype (T1, T2 : Entity_Id) return Boolean is\n+         Lo1, Hi1 : Uint;\n+         Lo2, Hi2 : Uint;\n+\n+      begin\n+         Get_First_Index_Bounds (T1, Lo1, Hi1);\n+         Get_First_Index_Bounds (T2, Lo2, Hi2);\n+\n+         --  Return true if the length of the covering subtype is not too large\n+\n+         return\n+           UI_Max (Hi1, Hi2) - UI_Min (Lo1, Lo2) < Too_Large_Length_For_Array;\n+      end OK_For_Single_Subtype;\n+\n+      --  Local variables\n+\n+      Actions : List_Id;\n+      Decl    : Node_Id;\n+      Expr    : Node_Id;\n+      New_If  : Node_Id;\n+      New_N   : Node_Id;\n \n    --  Start of processing for Expand_N_If_Expression\n \n@@ -6049,6 +6074,223 @@ package body Exp_Ch4 is\n                 Prefix => New_Occurrence_Of (Cnn, Loc));\n          end;\n \n+      --  If the result is a unidimensional unconstrained array but the two\n+      --  dependent expressions have constrained subtypes with known bounds,\n+      --  then we expand as follows:\n+\n+      --      subtype Txx is Typ (<static low-bound> .. <static high-bound>);\n+      --      Cnn : Txx;\n+      --      if cond then\n+      --         <<then actions>>\n+      --         Cnn (<then low-bound .. then high-bound>) := then-expr;\n+      --      else\n+      --         <<else actions>>\n+      --         Cnn (<else low bound .. else high-bound>) := else-expr;\n+      --      end if;\n+\n+      --  and replace the if expression by a slice of Cnn, provided that Txx\n+      --  is not too large. This will create a static temporary instead of the\n+      --  dynamic one of the next case and thus help the code generator.\n+\n+      --  Note that we need to deal with the case where the else expression is\n+      --  itself such a slice, in order to catch if expressions with more than\n+      --  two dependent expressions in the source code.\n+\n+      elsif Is_Array_Type (Typ)\n+        and then Number_Dimensions (Typ) = 1\n+        and then not Is_Constrained (Typ)\n+        and then Is_Constrained (Etype (Thenx))\n+        and then Compile_Time_Known_Bounds (Etype (Thenx))\n+        and then\n+          ((Is_Constrained (Etype (Elsex))\n+             and then Compile_Time_Known_Bounds (Etype (Elsex))\n+             and then OK_For_Single_Subtype (Etype (Thenx), Etype (Elsex)))\n+            or else\n+           (Nkind (Elsex) = N_Slice\n+             and then Is_Constrained (Etype (Prefix (Elsex)))\n+             and then Compile_Time_Known_Bounds (Etype (Prefix (Elsex)))\n+             and then\n+               OK_For_Single_Subtype (Etype (Thenx), Etype (Prefix (Elsex)))))\n+        and then not Generate_C_Code\n+      then\n+         declare\n+            Ityp : constant Entity_Id := Base_Type (Etype (First_Index (Typ)));\n+\n+            function Build_New_Bound\n+              (Then_Bnd  : Uint;\n+               Else_Bnd  : Uint;\n+               Slice_Bnd : Node_Id) return Node_Id;\n+            --  Build a new bound from the bounds of the if expression\n+\n+            function To_Ityp (V : Uint) return Node_Id;\n+            --  Convert V to an index value in Ityp\n+\n+            ---------------------\n+            -- Build_New_Bound --\n+            ---------------------\n+\n+            function Build_New_Bound\n+              (Then_Bnd  : Uint;\n+               Else_Bnd  : Uint;\n+               Slice_Bnd : Node_Id) return Node_Id is\n+\n+            begin\n+               if Nkind (Elsex) = N_Slice then\n+                  if Compile_Time_Known_Value (Slice_Bnd)\n+                    and then Expr_Value (Slice_Bnd) = Then_Bnd\n+                  then\n+                     return To_Ityp (Then_Bnd);\n+\n+                  else\n+                     return Make_If_Expression (Loc,\n+                       Expressions => New_List (\n+                         Duplicate_Subexpr (Cond),\n+                         To_Ityp (Then_Bnd),\n+                         New_Copy_Tree (Slice_Bnd)));\n+                  end if;\n+\n+               elsif Then_Bnd = Else_Bnd then\n+                  return To_Ityp (Then_Bnd);\n+\n+               else\n+                  return Make_If_Expression (Loc,\n+                    Expressions => New_List (\n+                      Duplicate_Subexpr (Cond),\n+                      To_Ityp (Then_Bnd),\n+                      To_Ityp (Else_Bnd)));\n+               end if;\n+            end Build_New_Bound;\n+\n+            -------------\n+            -- To_Ityp --\n+            -------------\n+\n+            function To_Ityp (V : Uint) return Node_Id is\n+               Result : constant Node_Id := Make_Integer_Literal (Loc, V);\n+\n+            begin\n+               if Is_Enumeration_Type (Ityp) then\n+                  return\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (Ityp, Loc),\n+                      Attribute_Name => Name_Val,\n+                      Expressions    => New_List (Result));\n+               else\n+                  return Result;\n+               end if;\n+            end To_Ityp;\n+\n+            Ent                  : Node_Id;\n+            Slice_Lo, Slice_Hi   : Node_Id;\n+            Subtyp_Ind           : Node_Id;\n+            Else_Lo, Else_Hi     : Uint;\n+            Min_Lo, Max_Hi       : Uint;\n+            Then_Lo, Then_Hi     : Uint;\n+            Then_List, Else_List : List_Id;\n+\n+         begin\n+            Get_First_Index_Bounds (Etype (Thenx), Then_Lo, Then_Hi);\n+\n+            if Nkind (Elsex) = N_Slice then\n+               Slice_Lo := Low_Bound (Discrete_Range (Elsex));\n+               Slice_Hi := High_Bound (Discrete_Range (Elsex));\n+               Get_First_Index_Bounds\n+                 (Etype (Prefix (Elsex)), Else_Lo, Else_Hi);\n+\n+            else\n+               Slice_Lo := Empty;\n+               Slice_Hi := Empty;\n+               Get_First_Index_Bounds (Etype (Elsex), Else_Lo, Else_Hi);\n+            end if;\n+\n+            Min_Lo := UI_Min (Then_Lo, Else_Lo);\n+            Max_Hi := UI_Max (Then_Hi, Else_Hi);\n+\n+            --  Now we construct an array object with appropriate bounds and\n+            --  mark it as internal to prevent useless initialization when\n+            --  Initialize_Scalars is enabled. Also since this is the actual\n+            --  result entity, we make sure we have debug information for it.\n+\n+            Subtyp_Ind :=\n+              Make_Subtype_Indication (Loc,\n+                Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+                Constraint   =>\n+                  Make_Index_Or_Discriminant_Constraint (Loc,\n+                    Constraints => New_List (\n+                      Make_Range (Loc,\n+                        Low_Bound  => To_Ityp (Min_Lo),\n+                        High_Bound => To_Ityp (Max_Hi)))));\n+\n+            Ent := Make_Temporary (Loc, 'C');\n+            Set_Is_Internal       (Ent);\n+            Set_Debug_Info_Needed (Ent);\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Ent,\n+                Object_Definition   => Subtyp_Ind);\n+\n+            --  If the result of the expression appears as the initializing\n+            --  expression of an object declaration, we can just rename the\n+            --  result, rather than copying it.\n+\n+            Mutate_Ekind (Ent, E_Variable);\n+            Set_OK_To_Rename (Ent);\n+\n+            Then_List := New_List (\n+              Make_Assignment_Statement (Loc,\n+                Name       =>\n+                  Make_Slice (Loc,\n+                    Prefix         => New_Occurrence_Of (Ent, Loc),\n+                    Discrete_Range =>\n+                      Make_Range (Loc,\n+                        Low_Bound  => To_Ityp (Then_Lo),\n+                        High_Bound => To_Ityp (Then_Hi))),\n+                Expression => Relocate_Node (Thenx)));\n+\n+            Set_Suppress_Assignment_Checks (Last (Then_List));\n+\n+            if Nkind (Elsex) = N_Slice then\n+               Else_List := New_List (\n+                 Make_Assignment_Statement (Loc,\n+                   Name       =>\n+                     Make_Slice (Loc,\n+                       Prefix         => New_Occurrence_Of (Ent, Loc),\n+                       Discrete_Range =>\n+                         Make_Range (Loc,\n+                           Low_Bound  => New_Copy_Tree (Slice_Lo),\n+                           High_Bound => New_Copy_Tree (Slice_Hi))),\n+                   Expression => Relocate_Node (Elsex)));\n+\n+            else\n+               Else_List := New_List (\n+                 Make_Assignment_Statement (Loc,\n+                   Name       =>\n+                     Make_Slice (Loc,\n+                       Prefix         => New_Occurrence_Of (Ent, Loc),\n+                       Discrete_Range =>\n+                         Make_Range (Loc,\n+                           Low_Bound  => To_Ityp (Else_Lo),\n+                           High_Bound => To_Ityp (Else_Hi))),\n+                   Expression => Relocate_Node (Elsex)));\n+            end if;\n+\n+            Set_Suppress_Assignment_Checks (Last (Else_List));\n+\n+            New_If :=\n+              Make_Implicit_If_Statement (N,\n+                Condition       => Duplicate_Subexpr (Cond),\n+                Then_Statements => Then_List,\n+                Else_Statements => Else_List);\n+\n+            New_N :=\n+              Make_Slice (Loc,\n+                Prefix         => New_Occurrence_Of (Ent, Loc),\n+                Discrete_Range => Make_Range (Loc,\n+                  Low_Bound  => Build_New_Bound (Then_Lo, Else_Lo, Slice_Lo),\n+                  High_Bound => Build_New_Bound (Then_Hi, Else_Hi, Slice_Hi)));\n+         end;\n+\n       --  If the result is an unconstrained array and the if expression is in a\n       --  context other than the initializing expression of the declaration of\n       --  an object, then we pull out the if expression as follows:\n@@ -6223,7 +6465,7 @@ package body Exp_Ch4 is\n          end if;\n \n       --  For the sake of GNATcoverage, generate an intermediate temporary in\n-      --  the case where the if-expression is a condition in an outer decision,\n+      --  the case where the if expression is a condition in an outer decision,\n       --  in order to make sure that no branch is shared between the decisions.\n \n       elsif Opt.Suppress_Control_Flow_Optimizations\n@@ -13400,10 +13642,16 @@ package body Exp_Ch4 is\n \n       --  This follows Sem_Eval.Compile_Time_Known_Bounds\n \n-      Typ := Underlying_Type (Etype (First_Index (T)));\n+      if Ekind (T) = E_String_Literal_Subtype then\n+         Lo := Expr_Value (String_Literal_Low_Bound (T));\n+         Hi := Lo + String_Literal_Length (T) - 1;\n \n-      Lo := Expr_Value (Type_Low_Bound (Typ));\n-      Hi := Expr_Value (Type_High_Bound (Typ));\n+      else\n+         Typ := Underlying_Type (Etype (First_Index (T)));\n+\n+         Lo := Expr_Value (Type_Low_Bound (Typ));\n+         Hi := Expr_Value (Type_High_Bound (Typ));\n+      end if;\n    end Get_First_Index_Bounds;\n \n    ------------------------"}, {"sha": "a9099e3a0d9478ac4fd4bd249b0c28063d15957c", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=a521dc37999bed5ec1f529b4c6ba7ded09dca464", "patch": "@@ -2299,7 +2299,7 @@ package Sinfo is\n    --    can be set in N_Object_Declaration nodes, to similarly suppress any\n    --    checks on the initializing value. In assignment statements it also\n    --    suppresses access checks in the generated code for out- and in-out\n-   --    parameters in entry calls.\n+   --    parameters in entry calls, as well as length checks.\n \n    --  Suppress_Loop_Warnings\n    --    Used in N_Loop_Statement node to indicate that warnings within the"}, {"sha": "1b408fc4f4600454e18fe30c8b6d9bcfa0ff473e", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521dc37999bed5ec1f529b4c6ba7ded09dca464/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=a521dc37999bed5ec1f529b4c6ba7ded09dca464", "patch": "@@ -70,6 +70,7 @@ package Uintp is\n    Uint_80  : constant Uint;\n    Uint_127 : constant Uint;\n    Uint_128 : constant Uint;\n+   Uint_256 : constant Uint;\n \n    Uint_Minus_1   : constant Uint;\n    Uint_Minus_2   : constant Uint;\n@@ -507,6 +508,7 @@ private\n    Uint_80  : constant Uint := Uint (Uint_Direct_Bias + 80);\n    Uint_127 : constant Uint := Uint (Uint_Direct_Bias + 127);\n    Uint_128 : constant Uint := Uint (Uint_Direct_Bias + 128);\n+   Uint_256 : constant Uint := Uint (Uint_Direct_Bias + 256);\n \n    Uint_Minus_1   : constant Uint := Uint (Uint_Direct_Bias - 1);\n    Uint_Minus_2   : constant Uint := Uint (Uint_Direct_Bias - 2);"}]}