{"sha": "5c85f29537662f1f4195a102cbf0182ffa32d8ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM4NWYyOTUzNzY2MmYxZjQxOTVhMTAyY2JmMDE4MmZmYTMyZDhhYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-25T19:43:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-25T19:43:07Z"}, "message": "Merge load/stores in ipa-modref summaries\n\nthis patch adds logic needed to merge neighbouring accesses in ipa-modref\nsummaries.  This helps analyzing array initializers and similar code.  It is\nbit of work, since it breaks the fact that modref tree makes a good lattice for\ndataflow: the access ranges can be extended indefinitely.  For this reason I\nadded counter tracking number of adjustments and a cap to limit them during the\ndataflow.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Document --param modref-max-adjustments.\n\t* ipa-modref-tree.c (test_insert_search_collapse): Update.\n\t(test_merge): Update.\n\t* ipa-modref-tree.h (struct modref_access_node): Add adjustments;\n\t(modref_access_node::operator==): Fix handling of access ranges.\n\t(modref_access_node::contains): Constify parameter; handle also\n\tmismatched parm offsets.\n\t(modref_access_node::update): New function.\n\t(modref_access_node::merge): New function.\n\t(unspecified_modref_access_node): Update constructor.\n\t(modref_ref_node::insert_access): Add record_adjustments parameter;\n\thandle merging.\n\t(modref_ref_node::try_merge_with): New private function.\n\t(modref_tree::insert): New record_adjustments parameter.\n\t(modref_tree::merge): New record_adjustments parameter.\n\t(modref_tree::copy_from): Update.\n\t* ipa-modref.c (dump_access): Dump adjustments field.\n\t(get_access): Update constructor.\n\t(record_access): Update call of insert.\n\t(record_access_lto): Update call of insert.\n\t(merge_call_side_effects): Add record_adjustments parameter.\n\t(get_access_for_fnspec): Update.\n\t(process_fnspec): Update.\n\t(analyze_call): Update.\n\t(analyze_function): Update.\n\t(read_modref_records): Update.\n\t(ipa_merge_modref_summary_after_inlining): Update.\n\t(propagate_unknown_call): Update.\n\t(modref_propagate_in_scc): Update.\n\t* params.opt (param-max-modref-adjustments=): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/ipa/modref-1.c: Update testcase.\n\t* gcc.dg/tree-ssa/modref-4.c: Update testcase.\n\t* gcc.dg/tree-ssa/modref-8.c: New test.", "tree": {"sha": "ebfc0f226199e0f3d67e8aeb37b7f78f69239d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebfc0f226199e0f3d67e8aeb37b7f78f69239d60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c85f29537662f1f4195a102cbf0182ffa32d8ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c85f29537662f1f4195a102cbf0182ffa32d8ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c85f29537662f1f4195a102cbf0182ffa32d8ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c85f29537662f1f4195a102cbf0182ffa32d8ac/comments", "author": null, "committer": null, "parents": [{"sha": "bb24717e5042b6e8a3847e780a8d215edb9c62f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb24717e5042b6e8a3847e780a8d215edb9c62f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb24717e5042b6e8a3847e780a8d215edb9c62f6"}], "stats": {"total": 420, "additions": 342, "deletions": 78}, "files": [{"sha": "b83bd902cec81004d44489da7bcc716b21904ce4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -13423,6 +13423,10 @@ Setting to 0 disables the analysis completely.\n @item modref-max-escape-points\n Specifies the maximum number of escape points tracked by modref per SSA-name.\n \n+@item modref-max-adjustments\n+Specifies the maximum number the access range is enlarged during modref dataflow\n+analysis.\n+\n @item profile-func-internal-id\n A parameter to control whether to use function internal id in profile\n database lookup. If the value is 0, the compiler uses an id that"}, {"sha": "69395b0113c782b0c1d61ced26f05650a0ee228c", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -41,7 +41,7 @@ test_insert_search_collapse ()\n   ASSERT_FALSE (t->every_base);\n \n   /* Insert into an empty tree.  */\n-  t->insert (1, 2, a);\n+  t->insert (1, 2, a, false);\n   ASSERT_NE (t->bases, NULL);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_FALSE (t->every_base);\n@@ -59,7 +59,7 @@ test_insert_search_collapse ()\n   ASSERT_EQ (ref_node->ref, 2);\n \n   /* Insert when base exists but ref does not.  */\n-  t->insert (1, 3, a);\n+  t->insert (1, 3, a, false);\n   ASSERT_NE (t->bases, NULL);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_EQ (t->search (1), base_node);\n@@ -72,42 +72,42 @@ test_insert_search_collapse ()\n \n   /* Insert when base and ref exist, but access is not dominated by nor\n      dominates other accesses.  */\n-  t->insert (1, 2, a);\n+  t->insert (1, 2, a, false);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_EQ (t->search (1), base_node);\n \n   ref_node = base_node->search (2);\n   ASSERT_NE (ref_node, NULL);\n \n   /* Insert when base and ref exist and access is dominated.  */\n-  t->insert (1, 2, a);\n+  t->insert (1, 2, a, false);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->search (2), ref_node);\n \n   /* Insert ref to trigger ref list collapse for base 1.  */\n-  t->insert (1, 4, a);\n+  t->insert (1, 4, a, false);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->refs, NULL);\n   ASSERT_EQ (base_node->search (2), NULL);\n   ASSERT_EQ (base_node->search (3), NULL);\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Further inserts to collapsed ref list are ignored.  */\n-  t->insert (1, 5, a);\n+  t->insert (1, 5, a, false);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->refs, NULL);\n   ASSERT_EQ (base_node->search (2), NULL);\n   ASSERT_EQ (base_node->search (3), NULL);\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Insert base to trigger base list collapse.  */\n-  t->insert (5, 6, a);\n+  t->insert (5, 6, a, false);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);\n \n   /* Further inserts to collapsed base list are ignored.  */\n-  t->insert (7, 8, a);\n+  t->insert (7, 8, a, false);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);\n@@ -123,22 +123,22 @@ test_merge ()\n   modref_access_node a = unspecified_modref_access_node;\n \n   t1 = new modref_tree<alias_set_type>(3, 4, 1);\n-  t1->insert (1, 1, a);\n-  t1->insert (1, 2, a);\n-  t1->insert (1, 3, a);\n-  t1->insert (2, 1, a);\n-  t1->insert (3, 1, a);\n+  t1->insert (1, 1, a, false);\n+  t1->insert (1, 2, a, false);\n+  t1->insert (1, 3, a, false);\n+  t1->insert (2, 1, a, false);\n+  t1->insert (3, 1, a, false);\n \n   t2 = new modref_tree<alias_set_type>(10, 10, 10);\n-  t2->insert (1, 2, a);\n-  t2->insert (1, 3, a);\n-  t2->insert (1, 4, a);\n-  t2->insert (3, 2, a);\n-  t2->insert (3, 3, a);\n-  t2->insert (3, 4, a);\n-  t2->insert (3, 5, a);\n-\n-  t1->merge (t2, NULL);\n+  t2->insert (1, 2, a, false);\n+  t2->insert (1, 3, a, false);\n+  t2->insert (1, 4, a, false);\n+  t2->insert (3, 2, a, false);\n+  t2->insert (3, 3, a, false);\n+  t2->insert (3, 4, a, false);\n+  t2->insert (3, 5, a, false);\n+\n+  t1->merge (t2, NULL, false);\n \n   ASSERT_FALSE (t1->every_base);\n   ASSERT_NE (t1->bases, NULL);"}, {"sha": "6f6932f08751085329845070eff901329c08d9b9", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 229, "deletions": 18, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n       Again ref is an template to allow LTO streaming.\n    3) Access: this level represent info about individual accesses.  Presently\n       we record whether access is through a dereference of a function parameter\n+      and if so we record the access range.\n */\n \n #ifndef GCC_MODREF_TREE_H\n@@ -57,6 +58,9 @@ struct GTY(()) modref_access_node\n      a function parameter.  */\n   int parm_index;\n   bool parm_offset_known;\n+  /* Number of times interval was extended during dataflow.\n+     This has to be limited in order to keep dataflow finite.  */\n+  unsigned char adjustments;\n \n   /* Return true if access node holds no useful info.  */\n   bool useful_p () const\n@@ -84,6 +88,8 @@ struct GTY(()) modref_access_node\n \t      && !known_eq (parm_offset, a.parm_offset))\n \t    return false;\n \t}\n+      if (range_info_useful_p () != a.range_info_useful_p ())\n+\treturn false;\n       if (range_info_useful_p ()\n \t  && (!known_eq (a.offset, offset)\n \t      || !known_eq (a.size, size)\n@@ -92,16 +98,24 @@ struct GTY(()) modref_access_node\n       return true;\n     }\n   /* Return true A is a subaccess.  */\n-  bool contains (modref_access_node &a) const\n+  bool contains (const modref_access_node &a) const\n     {\n-      if (parm_index != a.parm_index)\n-\treturn false;\n+      poly_int64 aoffset_adj = 0;\n       if (parm_index >= 0)\n \t{\n-\t  if (parm_offset_known\n-\t      && (!a.parm_offset_known\n-\t\t  || !known_eq (parm_offset, a.parm_offset)))\n+\t  if (parm_index != a.parm_index)\n \t    return false;\n+\t  if (parm_offset_known)\n+\t    {\n+\t       if (!a.parm_offset_known)\n+\t\t return false;\n+\t       /* Accesses are never below parm_offset, so look\n+\t\t  for smaller offset.  */\n+\t       if (!known_le (parm_offset, a.parm_offset))\n+\t\t return false;\n+\t       aoffset_adj = (a.parm_offset - parm_offset)\n+\t\t\t     << LOG2_BITS_PER_UNIT;\n+\t    }\n \t}\n       if (range_info_useful_p ())\n \t{\n@@ -111,20 +125,181 @@ struct GTY(()) modref_access_node\n \t     to fit the store, so smaller or unknown sotre is more general\n \t     than large store.  */\n \t  if (known_size_p (size)\n-\t      && !known_le (size, a.size))\n+\t      && (!known_size_p (a.size)\n+\t\t  || !known_le (size, a.size)))\n \t    return false;\n \t  if (known_size_p (max_size))\n-\t    return known_subrange_p (a.offset, a.max_size, offset, max_size);\n+\t    return known_subrange_p (a.offset + aoffset_adj,\n+\t\t\t\t     a.max_size, offset, max_size);\n \t  else\n-\t    return known_le (offset, a.offset);\n+\t    return known_le (offset, a.offset + aoffset_adj);\n \t}\n       return true;\n     }\n+  /* Update access range to new parameters.\n+     If RECORD_ADJUSTMENTS is true, record number of changes in the access\n+     and if threshold is exceeded start dropping precision\n+     so only constantly many updates are possible.  This makes dataflow\n+     to converge.  */\n+  void update (poly_int64 parm_offset1,\n+\t       poly_int64 offset1, poly_int64 size1, poly_int64 max_size1,\n+\t       bool record_adjustments)\n+    {\n+      if (known_eq (offset, offset1)\n+\t  && known_eq (size, size1)\n+\t  && known_eq (max_size, max_size1))\n+\treturn;\n+      if (!record_adjustments\n+\t  || (++adjustments) < param_modref_max_adjustments)\n+\t{\n+\t  parm_offset = parm_offset1;\n+\t  offset = offset1;\n+\t  size = size1;\n+\t  max_size = max_size1;\n+\t}\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"--param param=modref-max-adjustments limit reached:\");\n+\t  if (!known_eq (parm_offset, parm_offset1))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" parm_offset cleared\");\n+\t      parm_offset_known = false;\n+\t    }\n+\t  if (!known_eq (size, size1))\n+\t    {\n+\t      size = -1;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" size cleared\");\n+\t    }\n+\t  if (!known_eq (max_size, max_size1))\n+\t    {\n+\t      max_size = -1;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" max_size cleared\");\n+\t    }\n+\t  if (!known_eq (offset, offset1))\n+\t    {\n+\t      offset = 0;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \" offset cleared\");\n+\t    }\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+  /* Merge in access A if it is possible to do without losing\n+     precision.  Return true if successful.\n+     If RECORD_ADJUSTMENTs is true, remember how many interval\n+     was prolonged and punt when there are too many.  */\n+  bool merge (const modref_access_node &a, bool record_adjustments)\n+    {\n+      poly_int64 aoffset_adj = 0, offset_adj = 0;\n+      poly_int64 new_parm_offset = parm_offset;\n+\n+      /* We assume that containment was tested earlier.  */\n+      gcc_checking_assert (!contains (a) && !a.contains (*this));\n+      if (parm_index >= 0)\n+\t{\n+\t  if (parm_index != a.parm_index)\n+\t    return false;\n+\t  if (parm_offset_known)\n+\t    {\n+\t      if (!a.parm_offset_known)\n+\t\treturn false;\n+\t      if (known_le (a.parm_offset, parm_offset))\n+\t\t{\n+\t\t  offset_adj = (parm_offset - a.parm_offset)\n+\t\t\t\t<< LOG2_BITS_PER_UNIT;\n+\t\t  aoffset_adj = 0;\n+\t\t  new_parm_offset = a.parm_offset;\n+\t\t}\n+\t      else if (known_le (parm_offset, a.parm_offset))\n+\t\t{\n+\t\t  aoffset_adj = (a.parm_offset - parm_offset)\n+\t\t\t\t << LOG2_BITS_PER_UNIT;\n+\t\t  offset_adj = 0;\n+\t\t}\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t}\n+      /* See if we can merge ranges.  */\n+      if (range_info_useful_p ())\n+\t{\n+\t  poly_int64 offset1 = offset + offset_adj;\n+\t  poly_int64 aoffset1 = a.offset + aoffset_adj;\n+\n+\t  /* In this case we have containment that should be\n+\t     handled earlier.  */\n+\t  gcc_checking_assert (a.range_info_useful_p ());\n+\n+\t  /* If a.size is less specified than size, merge only\n+\t     if intervals are otherwise equivalent.  */\n+\t  if (known_size_p (size)\n+\t      && (!known_size_p (a.size) || known_lt (a.size, size)))\n+\t    {\n+\t      if (((known_size_p (max_size) || known_size_p (a.max_size))\n+\t\t   && !known_eq (max_size, a.max_size))\n+\t\t   || !known_eq (offset1, aoffset1))\n+\t\treturn false;\n+\t      update (new_parm_offset, offset1, a.size, max_size,\n+\t\t      record_adjustments);\n+\t      return true;\n+\t    }\n+\t  /* If sizes are same, we can extend the interval.  */\n+\t  if ((known_size_p (size) || known_size_p (a.size))\n+\t      && !known_eq (size, a.size))\n+\t    return false;\n+\t  if (known_le (offset1, aoffset1))\n+\t    {\n+\t      if (!known_size_p (max_size))\n+\t\t{\n+\t\t  update (new_parm_offset, offset1, size, max_size,\n+\t\t\t  record_adjustments);\n+\t\t  return true;\n+\t\t}\n+\t      else if (known_ge (offset1 + max_size, aoffset1))\n+\t\t{\n+\t\t  poly_int64 new_max_size = max_size;\n+\t\t  if (known_le (max_size, a.max_size + aoffset1 - offset1))\n+\t\t    new_max_size = a.max_size + aoffset1 - offset1;\n+\t\t  update (new_parm_offset, offset1, size, new_max_size,\n+\t\t\t  record_adjustments);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else if (known_le (aoffset1, offset1))\n+\t    {\n+\t      if (!known_size_p (a.max_size))\n+\t\t{\n+\t\t  update (new_parm_offset, aoffset1, size, a.max_size,\n+\t\t\t  record_adjustments);\n+\t\t  return true;\n+\t\t}\n+\t      else if (known_ge (aoffset1 + a.max_size, offset1))\n+\t\t{\n+\t\t  poly_int64 new_max_size = a.max_size;\n+\t\t  if (known_le (a.max_size, max_size + offset1 - aoffset1))\n+\t\t    new_max_size = max_size + offset1 - aoffset1;\n+\t\t  update (new_parm_offset, aoffset1, size, new_max_size,\n+\t\t\t  record_adjustments);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  return false;\n+\t}\n+      update (new_parm_offset, offset + offset_adj,\n+\t      size, max_size, record_adjustments);\n+      return true;\n+    }\n };\n \n /* Access node specifying no useful info.  */\n const modref_access_node unspecified_modref_access_node\n-\t\t = {0, -1, -1, 0, -1, false};\n+\t\t = {0, -1, -1, 0, -1, false, 0};\n \n template <typename T>\n struct GTY((user)) modref_ref_node\n@@ -149,8 +324,10 @@ struct GTY((user)) modref_ref_node\n \n   /* Insert access with OFFSET and SIZE.\n      Collapse tree if it has more than MAX_ACCESSES entries.\n+     If RECORD_ADJUSTMENTs is true avoid too many interval extensions.\n      Return true if record was changed.  */\n-  bool insert_access (modref_access_node a, size_t max_accesses)\n+  bool insert_access (modref_access_node a, size_t max_accesses,\n+\t\t      bool record_adjustments)\n   {\n     /* If this base->ref pair has no access information, bail out.  */\n     if (every_access)\n@@ -176,7 +353,17 @@ struct GTY((user)) modref_ref_node\n \t  return false;\n \tif (a.contains (*a2))\n \t  {\n-\t    *a2 = a;\n+\t    a.adjustments = 0;\n+\t    a2->parm_index = a.parm_index;\n+\t    a2->parm_offset_known = a.parm_offset_known;\n+\t    a2->update (a.parm_offset, a.offset, a.size, a.max_size,\n+\t\t\trecord_adjustments);\n+\t    try_merge_with (i);\n+\t    return true;\n+\t  }\n+\tif (a2->merge (a, record_adjustments))\n+\t  {\n+\t    try_merge_with (i);\n \t    return true;\n \t  }\n \tgcc_checking_assert (!(a == *a2));\n@@ -192,9 +379,28 @@ struct GTY((user)) modref_ref_node\n \tcollapse ();\n \treturn true;\n       }\n+    a.adjustments = 0;\n     vec_safe_push (accesses, a);\n     return true;\n   }\n+private:\n+  /* Try to optimize the access list after entry INDEX was modified.  */\n+  void\n+  try_merge_with (size_t index)\n+  {\n+    modref_access_node *a2;\n+    size_t i;\n+\n+    FOR_EACH_VEC_SAFE_ELT (accesses, i, a2)\n+      if (i != index)\n+\tif ((*accesses)[index].contains (*a2)\n+\t    || (*accesses)[index].merge (*a2, false))\n+\t{\n+\t  if (index == accesses->length () - 1)\n+\t    index = i;\n+\t  accesses->unordered_remove (i);\n+\t}\n+  }\n };\n \n /* Base of an access.  */\n@@ -342,7 +548,8 @@ struct GTY((user)) modref_tree\n \n   /* Insert memory access to the tree.\n      Return true if something changed.  */\n-  bool insert (T base, T ref, modref_access_node a)\n+  bool insert (T base, T ref, modref_access_node a,\n+\t       bool record_adjustments)\n   {\n     if (every_base)\n       return false;\n@@ -387,7 +594,8 @@ struct GTY((user)) modref_tree\n       {\n \tif (ref_node->every_access)\n \t  return changed;\n-\tchanged |= ref_node->insert_access (a, max_accesses);\n+\tchanged |= ref_node->insert_access (a, max_accesses,\n+\t\t\t\t\t    record_adjustments);\n \t/* See if we failed to add useful access.  */\n \tif (ref_node->every_access)\n \t  {\n@@ -456,7 +664,8 @@ struct GTY((user)) modref_tree\n      PARM_MAP, if non-NULL, maps parm indexes of callee to caller.  -2 is used\n      to signalize that parameter is local and does not need to be tracked.\n      Return true if something has changed.  */\n-  bool merge (modref_tree <T> *other, vec <modref_parm_map> *parm_map)\n+  bool merge (modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n+\t      bool record_accesses)\n   {\n     if (!other || every_base)\n       return false;\n@@ -501,7 +710,8 @@ struct GTY((user)) modref_tree\n \t\t{\n \t\t  changed |= insert (base_node->base,\n \t\t\t\t     ref_node->ref,\n-\t\t\t\t     unspecified_modref_access_node);\n+\t\t\t\t     unspecified_modref_access_node,\n+\t\t\t\t     record_accesses);\n \t\t}\n \t      else\n \t\tFOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n@@ -525,7 +735,8 @@ struct GTY((user)) modref_tree\n \t\t\t\t = (*parm_map) [a.parm_index].parm_index;\n \t\t\t  }\n \t\t      }\n-\t\t    changed |= insert (base_node->base, ref_node->ref, a);\n+\t\t    changed |= insert (base_node->base, ref_node->ref, a,\n+\t\t\t\t       record_accesses);\n \t\t  }\n \t    }\n       }\n@@ -537,7 +748,7 @@ struct GTY((user)) modref_tree\n   /* Copy OTHER to THIS.  */\n   void copy_from (modref_tree <T> *other)\n   {\n-    merge (other, NULL);\n+    merge (other, NULL, false);\n   }\n \n   /* Search BASE in tree; return NULL if failed.  */"}, {"sha": "0d5ab9c0561c0c3d7d879cd95066970285b9371f", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -426,6 +426,8 @@ dump_access (modref_access_node *a, FILE *out)\n       print_dec ((poly_int64_pod)a->size, out, SIGNED);\n       fprintf (out, \" max_size:\");\n       print_dec ((poly_int64_pod)a->max_size, out, SIGNED);\n+      if (a->adjustments)\n+\tfprintf (out, \" adjusted %i times\", a->adjustments);\n     }\n   fprintf (out, \"\\n\");\n }\n@@ -656,7 +658,7 @@ get_access (ao_ref *ref)\n \n   base = ao_ref_base (ref);\n   modref_access_node a = {ref->offset, ref->size, ref->max_size,\n-\t\t\t  0, -1, false};\n+\t\t\t  0, -1, false, 0};\n   if (TREE_CODE (base) == MEM_REF || TREE_CODE (base) == TARGET_MEM_REF)\n     {\n       tree memref = base;\n@@ -708,7 +710,7 @@ record_access (modref_records *tt, ao_ref *ref)\n        fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i parm=%i\\n\",\n \t\tbase_set, ref_set, a.parm_index);\n     }\n-  tt->insert (base_set, ref_set, a);\n+  tt->insert (base_set, ref_set, a, false);\n }\n \n /* IPA version of record_access_tree.  */\n@@ -774,7 +776,7 @@ record_access_lto (modref_records_lto *tt, ao_ref *ref)\n \t       a.parm_index);\n     }\n \n-  tt->insert (base_type, ref_type, a);\n+  tt->insert (base_type, ref_type, a, false);\n }\n \n /* Returns true if and only if we should store the access to EXPR.\n@@ -858,12 +860,15 @@ parm_map_for_arg (gimple *stmt, int i)\n \n /* Merge side effects of call STMT to function with CALLEE_SUMMARY\n    int CUR_SUMMARY.  Return true if something changed.\n-   If IGNORE_STORES is true, do not merge stores.  */\n+   If IGNORE_STORES is true, do not merge stores.\n+   If RECORD_ADJUSTMENTS is true cap number of adjustments to\n+   a given access to make dataflow finite.  */\n \n bool\n merge_call_side_effects (modref_summary *cur_summary,\n \t\t\t gimple *stmt, modref_summary *callee_summary,\n-\t\t\t bool ignore_stores, cgraph_node *callee_node)\n+\t\t\t bool ignore_stores, cgraph_node *callee_node,\n+\t\t\t bool record_adjustments)\n {\n   auto_vec <modref_parm_map, 32> parm_map;\n   bool changed = false;\n@@ -902,11 +907,13 @@ merge_call_side_effects (modref_summary *cur_summary,\n     fprintf (dump_file, \"\\n\");\n \n   /* Merge with callee's summary.  */\n-  changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map);\n+  changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map,\n+\t\t\t\t\trecord_adjustments);\n   if (!ignore_stores)\n     {\n       changed |= cur_summary->stores->merge (callee_summary->stores,\n-\t\t\t\t\t     &parm_map);\n+\t\t\t\t\t     &parm_map,\n+\t\t\t\t\t     record_adjustments);\n       if (!cur_summary->writes_errno\n \t  && callee_summary->writes_errno)\n \t{\n@@ -941,7 +948,7 @@ get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n     }\n   modref_access_node a = {0, -1, -1,\n \t\t\t  map.parm_offset, map.parm_index,\n-\t\t\t  map.parm_offset_known};\n+\t\t\t  map.parm_offset_known, 0};\n   poly_int64 size_hwi;\n   if (size\n       && poly_int_tree_p (size, &size_hwi)\n@@ -1044,12 +1051,14 @@ process_fnspec (modref_summary *cur_summary,\n \t      cur_summary->loads->insert (0, 0,\n \t\t\t\t\t  get_access_for_fnspec (call,\n \t\t\t\t\t\t\t\t fnspec, i,\n-\t\t\t\t\t\t\t\t map));\n+\t\t\t\t\t\t\t\t map),\n+\t\t\t\t\t  false);\n \t    if (cur_summary_lto)\n \t      cur_summary_lto->loads->insert (0, 0,\n \t\t\t\t\t      get_access_for_fnspec (call,\n \t\t\t\t\t\t\t\t     fnspec, i,\n-\t\t\t\t\t\t\t\t     map));\n+\t\t\t\t\t\t\t\t     map),\n+\t\t\t\t\t      false);\n \t  }\n     }\n   if (ignore_stores)\n@@ -1077,12 +1086,14 @@ process_fnspec (modref_summary *cur_summary,\n \t      cur_summary->stores->insert (0, 0,\n \t\t\t\t\t   get_access_for_fnspec (call,\n \t\t\t\t\t\t\t\t  fnspec, i,\n-\t\t\t\t\t\t\t\t  map));\n+\t\t\t\t\t\t\t\t  map),\n+\t\t\t\t\t   false);\n \t    if (cur_summary_lto)\n \t      cur_summary_lto->stores->insert (0, 0,\n \t\t\t\t\t       get_access_for_fnspec (call,\n \t\t\t\t\t\t\t\t      fnspec, i,\n-\t\t\t\t\t\t\t\t      map));\n+\t\t\t\t\t\t\t\t      map),\n+\t\t\t\t\t       false);\n \t  }\n       if (fnspec.errno_maybe_written_p () && flag_errno_math)\n \t{\n@@ -1168,7 +1179,7 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n     }\n \n   merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores,\n-\t\t\t   callee_node);\n+\t\t\t   callee_node, false);\n \n   return true;\n }\n@@ -2134,6 +2145,7 @@ analyze_function (function *f, bool ipa)\n   if (!ipa)\n     {\n       bool changed = true;\n+      bool first = true;\n       while (changed)\n \t{\n \t  changed = false;\n@@ -2144,13 +2156,14 @@ analyze_function (function *f, bool ipa)\n \t\t\t   ignore_stores_p (current_function_decl,\n \t\t\t\t\t    gimple_call_flags\n \t\t\t\t\t\t (recursive_calls[i])),\n-\t\t\t   fnode);\n+\t\t\t   fnode, !first);\n \t      if (!summary->useful_p (ecf_flags, false))\n \t\t{\n \t\t  remove_summary (lto, nolto, ipa);\n \t\t  return;\n \t\t}\n \t    }\n+\t  first = false;\n \t}\n     }\n   if (summary && !summary->useful_p (ecf_flags))\n@@ -2501,11 +2514,11 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \t\t    }\n \t\t}\n \t      modref_access_node a = {offset, size, max_size, parm_offset,\n-\t\t\t\t      parm_index, parm_offset_known};\n+\t\t\t\t      parm_index, parm_offset_known, false};\n \t      if (nolto_ref_node)\n-\t\tnolto_ref_node->insert_access (a, max_accesses);\n+\t\tnolto_ref_node->insert_access (a, max_accesses, false);\n \t      if (lto_ref_node)\n-\t\tlto_ref_node->insert_access (a, max_accesses);\n+\t\tlto_ref_node->insert_access (a, max_accesses, false);\n \t    }\n \t}\n     }\n@@ -3187,16 +3200,18 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n       if (!ignore_stores)\n \t{\n \t  if (to_info && callee_info)\n-\t    to_info->stores->merge (callee_info->stores, &parm_map);\n+\t    to_info->stores->merge (callee_info->stores, &parm_map, false);\n \t  if (to_info_lto && callee_info_lto)\n-\t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map);\n+\t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map,\n+\t\t\t\t\tfalse);\n \t}\n       if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n \t{\n \t  if (to_info && callee_info)\n-\t    to_info->loads->merge (callee_info->loads, &parm_map);\n+\t    to_info->loads->merge (callee_info->loads, &parm_map, false);\n \t  if (to_info_lto && callee_info_lto)\n-\t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map);\n+\t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map,\n+\t\t\t\t       false);\n \t}\n     }\n \n@@ -3346,7 +3361,7 @@ get_access_for_fnspec (cgraph_edge *e, attr_fnspec &fnspec,\n     size = TYPE_SIZE_UNIT (get_parm_type (e->callee->decl, i));\n   modref_access_node a = {0, -1, -1,\n \t\t\t  map.parm_offset, map.parm_index,\n-\t\t\t  map.parm_offset_known};\n+\t\t\t  map.parm_offset_known, 0};\n   poly_int64 size_hwi;\n   if (size\n       && poly_int_tree_p (size, &size_hwi)\n@@ -3399,10 +3414,10 @@ propagate_unknown_call (cgraph_node *node,\n \t\t}\n \t      if (cur_summary)\n \t\tchanged |= cur_summary->loads->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n \t      if (cur_summary_lto)\n \t\tchanged |= cur_summary_lto->loads->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n \t    }\n \t}\n       if (ignore_stores_p (node->decl, ecf_flags))\n@@ -3429,10 +3444,10 @@ propagate_unknown_call (cgraph_node *node,\n \t\t}\n \t      if (cur_summary)\n \t\tchanged |= cur_summary->stores->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n \t      if (cur_summary_lto)\n \t\tchanged |= cur_summary_lto->stores->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map));\n+\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n \t    }\n \t}\n       if (fnspec.errno_maybe_written_p () && flag_errno_math)\n@@ -3491,6 +3506,7 @@ static void\n modref_propagate_in_scc (cgraph_node *component_node)\n {\n   bool changed = true;\n+  bool first = true;\n   int iteration = 0;\n \n   while (changed)\n@@ -3628,11 +3644,12 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      if (callee_summary)\n \t\t{\n \t\t  changed |= cur_summary->loads->merge\n-\t\t\t\t  (callee_summary->loads, &parm_map);\n+\t\t\t\t  (callee_summary->loads, &parm_map, !first);\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary->stores->merge\n-\t\t\t\t      (callee_summary->stores, &parm_map);\n+\t\t\t\t      (callee_summary->stores, &parm_map,\n+\t\t\t\t       !first);\n \t\t      if (!cur_summary->writes_errno\n \t\t\t  && callee_summary->writes_errno)\n \t\t\t{\n@@ -3644,11 +3661,13 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      if (callee_summary_lto)\n \t\t{\n \t\t  changed |= cur_summary_lto->loads->merge\n-\t\t\t\t  (callee_summary_lto->loads, &parm_map);\n+\t\t\t\t  (callee_summary_lto->loads, &parm_map,\n+\t\t\t\t   !first);\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary_lto->stores->merge\n-\t\t\t\t      (callee_summary_lto->stores, &parm_map);\n+\t\t\t\t      (callee_summary_lto->stores, &parm_map,\n+\t\t\t\t       !first);\n \t\t      if (!cur_summary_lto->writes_errno\n \t\t\t  && callee_summary_lto->writes_errno)\n \t\t\t{\n@@ -3674,6 +3693,7 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t    }\n \t}\n       iteration++;\n+      first = false;\n     }\n   if (dump_file)\n     fprintf (dump_file,"}, {"sha": "cec43d205330980926943320e430be7e4ca23973", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -1013,6 +1013,10 @@ Maximum depth of DFS walk used by modref escape analysis.\n Common Joined UInteger Var(param_modref_max_escape_points) Init(256) Param Optimization\n Maximum number of escape points tracked by modref per SSA-name.\n \n+-param=modref-max-adjustments=\n+Common Joined UInteger Var(param_modref_max_adjustments) Init(8) IntegerRange (0, 254) Param Optimization\n+Maximum number of times a given range is adjusted during the dataflow\n+\n -param=tm-max-aggregate-size=\n Common Joined UInteger Var(param_tm_max_aggregate_size) Init(9) Param Optimization\n Size in bytes after which thread-local aggregates should be instrumented with the logging functions instead of save/restore pairs."}, {"sha": "5314e7dbbf7830f5fa4ca8cc7ab33c656b2f776a", "filename": "gcc/testsuite/gcc.dg/ipa/modref-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodref-1.c?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -10,15 +10,15 @@ void a(char *ptr, char *ptr2)\n __attribute__((noinline))\n void b(char *ptr)\n {\n-  a(ptr+1,&ptr[2]);\n+  a(ptr+1,&ptr[3]);\n }\n \n int main()\n {\n-  char c[3]={0,1,0};\n+  char c[4]={0,1,0,0};\n   b(c);\n-  return c[0]+c[2];\n+  return c[0]+c[3];\n }\n /* Check that both param offsets are determined correctly.  */\n /* { dg-final { scan-ipa-dump \"param offset:1\" \"modref\"  } } */\n-/* { dg-final { scan-ipa-dump \"param offset:2\" \"modref\"  } } */\n+/* { dg-final { scan-ipa-dump \"param offset:3\" \"modref\"  } } */"}, {"sha": "a277c70677ed0a9dd0febe756d6ff65cdb5ce3e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-4.c?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -10,17 +10,17 @@ void a(char *ptr, char *ptr2)\n __attribute__((noinline))\n void b(char *ptr)\n {\n-  a(ptr+1,&ptr[2]);\n+  a(ptr+1,&ptr[3]);\n }\n \n int main()\n {\n-  char c[4]={0,1,2,0};\n+  char c[5]={0,1,2,0,0};\n   b(c);\n-  return c[0]+c[3];\n+  return c[0]+c[4];\n }\n /* Check that both param offsets are determined correctly and the computation\n    is optimized out.  */\n /* { dg-final { scan-tree-dump \"param offset:1\" \"modref1\"  } } */\n-/* { dg-final { scan-tree-dump \"param offset:2\" \"modref1\"  } } */\n+/* { dg-final { scan-tree-dump \"param offset:3\" \"modref1\"  } } */\n /* { dg-final { scan-tree-dump \"return 0\" \"modref1\"  } } */"}, {"sha": "15ae4acc03f3efb7785d735b01ff3eb8d2740c0f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c85f29537662f1f4195a102cbf0182ffa32d8ac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-8.c?ref=5c85f29537662f1f4195a102cbf0182ffa32d8ac", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O2 --param modref-max-adjustments=8 -fdump-tree-modref1\"  } */\n+/* { dg-do compile } */\n+void\n+set (char *p)\n+{\n+   p[1]=1;\n+   p[0]=0;\n+   p[2]=2;\n+   p[4]=4;\n+   p[3]=3;\n+}\n+\n+void\n+recurse (char *p, int n)\n+{\n+\t*p = 0;\n+\tif (n)\n+\t  recurse (p+1,n-1);\n+}\n+/* { dg-final { scan-tree-dump-not \"param=modref-max-accesses\" \"modref1\" } } */\n+/* { dg-final { scan-tree-dump \"param=modref-max-adjustments\" \"modref1\" } } */\n+/* In set all accesses should merge together.  */\n+/* { dg-final { scan-tree-dump \"access: Parm 0 param offset:0 offset:0 size:8 max_size:40\" \"modref1\" } } */\n+/* In recurse we should cap the recrusion after 8 attempts and set max_size to -1.  */\n+/* { dg-final { scan-tree-dump \"access: Parm 0 param offset:0 offset:0 size:8 max_size:-1 adjusted 8 times\" \"modref1\" } } */"}]}