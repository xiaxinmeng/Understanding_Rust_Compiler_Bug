{"sha": "76545796c5181baef9511af159178aef8d93de7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1NDU3OTZjNTE4MWJhZWY5NTExYWYxNTkxNzhhZWY4ZDkzZGU3Yw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-04-11T16:02:00Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-04-11T16:02:00Z"}, "message": "call.c (build_conditional_expr_1, [...]): Protect error calls with complain & tf_error.\n\n2013-04-11  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* call.c (build_conditional_expr_1, build_over_call): Protect\n\terror calls with complain & tf_error.\n\t* typeck.c (finish_class_member_access_expr, cp_build_binary_op,\n\tbuild_x_unary_op, cp_build_unary_op, cp_build_compound_expr,\n\tbuild_ptrmemfunc): Likewise.\n\t(lookup_destructor): Take tsubst_flags_t parameter, adjust.\n\n\t* cvt.c (warn_ref_binding): Rename to diagnose_ref_binding.\n\t(convert_to_reference): Adjust.\n\nFrom-SVN: r197813", "tree": {"sha": "45373e6c1fa83e644725f453a809abafe53be489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45373e6c1fa83e644725f453a809abafe53be489"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76545796c5181baef9511af159178aef8d93de7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76545796c5181baef9511af159178aef8d93de7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76545796c5181baef9511af159178aef8d93de7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76545796c5181baef9511af159178aef8d93de7c/comments", "author": null, "committer": null, "parents": [{"sha": "ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d"}], "stats": {"total": 132, "additions": 86, "deletions": 46}, "files": [{"sha": "e6670b247edc23e779a4ec280da5c5b8adbde61b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=76545796c5181baef9511af159178aef8d93de7c", "patch": "@@ -1,3 +1,15 @@\n+2013-04-11  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* call.c (build_conditional_expr_1, build_over_call): Protect\n+\terror calls with complain & tf_error.\n+\t* typeck.c (finish_class_member_access_expr, cp_build_binary_op,\n+\tbuild_x_unary_op, cp_build_unary_op, cp_build_compound_expr,\n+\tbuild_ptrmemfunc): Likewise.\n+\t(lookup_destructor): Take tsubst_flags_t parameter, adjust.\n+\n+\t* cvt.c (warn_ref_binding): Rename to diagnose_ref_binding.\n+\t(convert_to_reference): Adjust.\n+\n 2013-04-11  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst_copy) [VAR_DECL]: Don't call tsubst for"}, {"sha": "4c59866323ee43bf1724fc4e13728e5d2c98810f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=76545796c5181baef9511af159178aef8d93de7c", "patch": "@@ -4577,8 +4577,9 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t  || (conv2 && conv2->kind == ck_ambig)\n \t  || (conv3 && conv3->kind == ck_ambig))\n \t{\n-\t  error (\"operands to ?: have different types %qT and %qT\",\n-\t\t arg2_type, arg3_type);\n+\t  if (complain & tf_error)\n+\t    error (\"operands to ?: have different types %qT and %qT\",\n+\t\t   arg2_type, arg3_type);\n \t  result = error_mark_node;\n \t}\n       else if (conv2 && (!conv2->bad_p || !conv3))\n@@ -4760,10 +4761,11 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n       /* In this case, there is always a common type.  */\n       result_type = type_after_usual_arithmetic_conversions (arg2_type,\n \t\t\t\t\t\t\t     arg3_type);\n-      do_warn_double_promotion (result_type, arg2_type, arg3_type,\n-\t\t\t\t\"implicit conversion from %qT to %qT to \"\n-\t\t\t\t\"match other result of conditional\",\n-\t\t\t\tinput_location);\n+      if (complain & tf_warning)\n+\tdo_warn_double_promotion (result_type, arg2_type, arg3_type,\n+\t\t\t\t  \"implicit conversion from %qT to %qT to \"\n+\t\t\t\t  \"match other result of conditional\",\n+\t\t\t\t  input_location);\n \n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t  && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n@@ -6790,9 +6792,14 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       /* Check that the base class is accessible.  */\n       if (!accessible_base_p (TREE_TYPE (argtype),\n \t\t\t      BINFO_TYPE (cand->conversion_path), true))\n-\terror (\"%qT is not an accessible base of %qT\",\n-\t       BINFO_TYPE (cand->conversion_path),\n-\t       TREE_TYPE (argtype));\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"%qT is not an accessible base of %qT\",\n+\t\t   BINFO_TYPE (cand->conversion_path),\n+\t\t   TREE_TYPE (argtype));\n+\t  else\n+\t    return error_mark_node;\n+\t}\n       /* If fn was found by a using declaration, the conversion path\n \t will be to the derived class, not the base declaring fn. We\n \t must convert from derived to base.  */"}, {"sha": "a3b73580b234bce1304e9e37e59939b735afa3a4", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=76545796c5181baef9511af159178aef8d93de7c", "patch": "@@ -40,7 +40,7 @@ static tree cp_convert_to_pointer (tree, tree, tsubst_flags_t);\n static tree convert_to_pointer_force (tree, tree, tsubst_flags_t);\n static tree build_type_conversion (tree, tree);\n static tree build_up_reference (tree, tree, int, tree, tsubst_flags_t);\n-static void warn_ref_binding (location_t, tree, tree, tree);\n+static void diagnose_ref_binding (location_t, tree, tree, tree);\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -371,7 +371,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl,\n    non-volatile const type.  */\n \n static void\n-warn_ref_binding (location_t loc, tree reftype, tree intype, tree decl)\n+diagnose_ref_binding (location_t loc, tree reftype, tree intype, tree decl)\n {\n   tree ttl = TREE_TYPE (reftype);\n \n@@ -456,9 +456,9 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \ttree ttl = TREE_TYPE (reftype);\n \ttree ttr = lvalue_type (expr);\n \n-\tif ((complain & tf_warning)\n+\tif ((complain & tf_error)\n \t    && ! real_lvalue_p (expr))\n-\t  warn_ref_binding (loc, reftype, intype, decl);\n+\t  diagnose_ref_binding (loc, reftype, intype, decl);\n \n \tif (! (convtype & CONV_CONST)\n \t    && !at_least_as_qualified_p (ttl, ttr))\n@@ -502,8 +502,8 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t\t\t\t\t ICR_CONVERTING, 0, 0, complain);\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;\n-      if (complain & tf_warning)\n-\twarn_ref_binding (loc, reftype, intype, decl);\n+      if (complain & tf_error)\n+\tdiagnose_ref_binding (loc, reftype, intype, decl);\n       rval = build_up_reference (reftype, rval, flags, decl, complain);\n     }\n "}, {"sha": "50405c377f35c8821322cbdbbe85142331d397d6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76545796c5181baef9511af159178aef8d93de7c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=76545796c5181baef9511af159178aef8d93de7c", "patch": "@@ -54,7 +54,7 @@ static tree get_delta_difference (tree, tree, bool, bool, tsubst_flags_t);\n static void casts_away_constness_r (tree *, tree *, tsubst_flags_t);\n static bool casts_away_constness (tree, tree, tsubst_flags_t);\n static void maybe_warn_about_returning_address_of_local (tree);\n-static tree lookup_destructor (tree, tree, tree);\n+static tree lookup_destructor (tree, tree, tree, tsubst_flags_t);\n static void warn_args_num (location_t, tree, bool);\n static int convert_arguments (tree, vec<tree, va_gc> **, tree, int,\n                               tsubst_flags_t);\n@@ -2469,16 +2469,18 @@ build_class_member_access_expr (tree object, tree member,\n    SCOPE is NULL, by OBJECT.DTOR_NAME, where DTOR_NAME is ~type.  */\n \n static tree\n-lookup_destructor (tree object, tree scope, tree dtor_name)\n+lookup_destructor (tree object, tree scope, tree dtor_name,\n+\t\t   tsubst_flags_t complain)\n {\n   tree object_type = TREE_TYPE (object);\n   tree dtor_type = TREE_OPERAND (dtor_name, 0);\n   tree expr;\n \n   if (scope && !check_dtor_name (scope, dtor_type))\n     {\n-      error (\"qualified type %qT does not match destructor name ~%qT\",\n-\t     scope, dtor_type);\n+      if (complain & tf_error)\n+\terror (\"qualified type %qT does not match destructor name ~%qT\",\n+\t       scope, dtor_type);\n       return error_mark_node;\n     }\n   if (identifier_p (dtor_type))\n@@ -2489,16 +2491,18 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n \tdtor_type = object_type;\n       else\n \t{\n-\t  error (\"object type %qT does not match destructor name ~%qT\",\n-\t\t object_type, dtor_type);\n+\t  if (complain & tf_error)\n+\t    error (\"object type %qT does not match destructor name ~%qT\",\n+\t\t   object_type, dtor_type);\n \t  return error_mark_node;\n \t}\n       \n     }\n   else if (!DERIVED_FROM_P (dtor_type, TYPE_MAIN_VARIANT (object_type)))\n     {\n-      error (\"the type being destroyed is %qT, but the destructor refers to %qT\",\n-\t     TYPE_MAIN_VARIANT (object_type), dtor_type);\n+      if (complain & tf_error)\n+\terror (\"the type being destroyed is %qT, but the destructor \"\n+\t       \"refers to %qT\", TYPE_MAIN_VARIANT (object_type), dtor_type);\n       return error_mark_node;\n     }\n   expr = lookup_member (dtor_type, complete_dtor_identifier,\n@@ -2731,7 +2735,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t}\n \n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\tmember = lookup_destructor (object, scope, name);\n+\tmember = lookup_destructor (object, scope, name, complain);\n       else\n \t{\n \t  /* Look up the member.  */\n@@ -3933,7 +3937,8 @@ cp_build_binary_op (location_t location,\n   if ((invalid_op_diag\n        = targetm.invalid_binary_op (code, type0, type1)))\n     {\n-      error (invalid_op_diag);\n+      if (complain & tf_error)\n+\terror (invalid_op_diag);\n       return error_mark_node;\n     }\n \n@@ -4600,7 +4605,8 @@ cp_build_binary_op (location_t location,\n \t      || !same_scalar_type_ignoring_signedness (TREE_TYPE (type0),\n \t\t\t\t\t\t\tTREE_TYPE (type1)))\n \t    {\n-\t      binary_op_error (location, code, type0, type1);\n+\t      if (complain & tf_error)\n+\t\tbinary_op_error (location, code, type0, type1);\n \t      return error_mark_node;\n \t    }\n \t  arithmetic_types_p = 1;\n@@ -4612,11 +4618,12 @@ cp_build_binary_op (location_t location,\n       && (shorten || common || short_compare))\n     {\n       result_type = cp_common_type (type0, type1);\n-      do_warn_double_promotion (result_type, type0, type1,\n-\t\t\t\t\"implicit conversion from %qT to %qT \"\n-\t\t\t\t\"to match other operand of binary \"\n-\t\t\t\t\"expression\",\n-\t\t\t\tlocation);\n+      if (complain & tf_warning)\n+\tdo_warn_double_promotion (result_type, type0, type1,\n+\t\t\t\t  \"implicit conversion from %qT to %qT \"\n+\t\t\t\t  \"to match other operand of binary \"\n+\t\t\t\t  \"expression\",\n+\t\t\t\t  location);\n     }\n \n   if (!result_type)\n@@ -4954,10 +4961,11 @@ build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n \t  tree fn = get_first_fn (xarg);\n \t  if (DECL_CONSTRUCTOR_P (fn) || DECL_DESTRUCTOR_P (fn))\n \t    {\n-\t      error (DECL_CONSTRUCTOR_P (fn)\n-                     ? G_(\"taking address of constructor %qE\")\n-                     : G_(\"taking address of destructor %qE\"),\n-                     xarg);\n+\t      if (complain & tf_error)\n+\t\terror (DECL_CONSTRUCTOR_P (fn)\n+\t\t       ? G_(\"taking address of constructor %qE\")\n+\t\t       : G_(\"taking address of destructor %qE\"),\n+\t\t       xarg);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -4970,17 +4978,23 @@ build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n \t  if (TREE_CODE (xarg) != OFFSET_REF\n \t      || !TYPE_P (TREE_OPERAND (xarg, 0)))\n \t    {\n-              error (\"invalid use of %qE to form a pointer-to-member-function\",\n-                     xarg);\n-              if (TREE_CODE (xarg) != OFFSET_REF)\n-                inform (input_location, \"  a qualified-id is required\");\n+\t      if (complain & tf_error)\n+\t\t{\n+\t\t  error (\"invalid use of %qE to form a \"\n+\t\t\t \"pointer-to-member-function\", xarg);\n+\t\t  if (TREE_CODE (xarg) != OFFSET_REF)\n+\t\t    inform (input_location, \"  a qualified-id is required\");\n+\t\t}\n \t      return error_mark_node;\n \t    }\n \t  else\n \t    {\n-\t      error (\"parentheses around %qE cannot be used to form a\"\n-\t\t     \" pointer-to-member-function\",\n-\t\t     xarg);\n+\t      if (complain & tf_error)\n+\t\terror (\"parentheses around %qE cannot be used to form a\"\n+\t\t       \" pointer-to-member-function\",\n+\t\t       xarg);\n+\t      else\n+\t\treturn error_mark_node;\n \t      PTRMEM_OK_P (xarg) = 1;\n \t    }\n \t}\n@@ -5395,7 +5409,8 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t\t\t\t    : code),\n \t\t\t\t   TREE_TYPE (xarg))))\n     {\n-      error (invalid_op_diag);\n+      if (complain & tf_error)\n+\terror (invalid_op_diag);\n       return error_mark_node;\n     }\n \n@@ -6028,7 +6043,8 @@ cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n \n   if (type_unknown_p (rhs))\n     {\n-      error (\"no context to resolve type of %qE\", rhs);\n+      if (complain & tf_error)\n+\terror (\"no context to resolve type of %qE\", rhs);\n       return error_mark_node;\n     }\n   \n@@ -7577,8 +7593,13 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p,\n       if (!force\n \t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn,\n \t\t\t       LOOKUP_NORMAL, complain))\n-\terror (\"invalid conversion to type %qT from type %qT\",\n-\t       to_type, pfn_type);\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"invalid conversion to type %qT from type %qT\",\n+\t\t   to_type, pfn_type);\n+\t  else\n+\t    return error_mark_node;\n+\t}\n \n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n \t\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),"}]}