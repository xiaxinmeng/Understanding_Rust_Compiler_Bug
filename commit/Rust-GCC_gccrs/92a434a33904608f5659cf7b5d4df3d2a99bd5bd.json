{"sha": "92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJhNDM0YTMzOTA0NjA4ZjU2NTljZjdiNWQ0ZGYzZDJhOTliZDViZA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-23T16:22:12Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-24T11:36:08Z"}, "message": "Add support for nested functions\n\nWe missed that stmts in rust can be items like functions. This adds support\nfor resolution and compilation of nested functions. Rust allows nested\nfunctions which are distinct to closures. Nested functions are not allowed\nto encapsulate the enclosing scope so they can be extracted as normal functions.", "tree": {"sha": "02daa3d23d04cb9c950b15d5a7a94f171e1241db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02daa3d23d04cb9c950b15d5a7a94f171e1241db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23e748d7a6855ce132299cfef9692ee9c681de59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23e748d7a6855ce132299cfef9692ee9c681de59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23e748d7a6855ce132299cfef9692ee9c681de59"}], "stats": {"total": 373, "additions": 299, "deletions": 74}, "files": [{"sha": "c346af596262fa4bde935639b4897b42b7345bb9", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -210,6 +210,9 @@ class HIRCompileBase : public HIR::HIRVisitor\n   void compile_function_body (Bfunction *fndecl,\n \t\t\t      std::unique_ptr<HIR::BlockExpr> &function_body,\n \t\t\t      bool has_return_type);\n+\n+  bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+\t\t\t\t std::vector<Bvariable *> &locals);\n };\n \n } // namespace Compile"}, {"sha": "70f76b7d873a0c4344e08e99fe1a5bc40f59b375", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -183,26 +183,10 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-      Resolver::Definition d;\n-      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-      rust_assert (ok);\n-\n-      HIR::Stmt *decl = nullptr;\n-      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-      rust_assert (ok);\n-\n-      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-      locals.push_back (compiled);\n-\n-      return true;\n-    });\n-\n-    bool toplevel_item\n-      = function.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n-    Bblock *enclosing_scope\n-      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n+    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    rust_assert (ok);\n \n+    Bblock *enclosing_scope = NULL;\n     HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n@@ -409,26 +393,10 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-      Resolver::Definition d;\n-      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-      rust_assert (ok);\n-\n-      HIR::Stmt *decl = nullptr;\n-      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-      rust_assert (ok);\n-\n-      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-      locals.push_back (compiled);\n-\n-      return true;\n-    });\n-\n-    bool toplevel_item\n-      = method.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n-    Bblock *enclosing_scope\n-      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n+    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    rust_assert (ok);\n \n+    Bblock *enclosing_scope = NULL;\n     HIR::BlockExpr *function_body = method.get_function_body ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();"}, {"sha": "eacfda90a79caf7b34a004fd1ebc2c6224ca7e2c", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -213,26 +213,10 @@ class CompileItem : public HIRCompileBase\n       }\n \n     std::vector<Bvariable *> locals;\n-    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-      Resolver::Definition d;\n-      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-      rust_assert (ok);\n-\n-      HIR::Stmt *decl = nullptr;\n-      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-      rust_assert (ok);\n-\n-      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-      locals.push_back (compiled);\n-\n-      return true;\n-    });\n-\n-    bool toplevel_item\n-      = function.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n-    Bblock *enclosing_scope\n-      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n+    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+    rust_assert (ok);\n \n+    Bblock *enclosing_scope = NULL;\n     HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();"}, {"sha": "5ffd11a422c88c4b17bf9625681a478899a79533", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -212,20 +212,8 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n     }\n \n   std::vector<Bvariable *> locals;\n-  rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-    Resolver::Definition d;\n-    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-    rust_assert (ok);\n-\n-    HIR::Stmt *decl = nullptr;\n-    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-    rust_assert (ok);\n-\n-    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-    locals.push_back (compiled);\n-\n-    return true;\n-  });\n+  bool ok = compile_locals_for_block (*rib, fndecl, locals);\n+  rust_assert (ok);\n \n   Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n   Bblock *new_block\n@@ -415,6 +403,41 @@ HIRCompileBase::compile_function_body (\n     }\n }\n \n+bool\n+HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+\t\t\t\t\t  std::vector<Bvariable *> &locals)\n+{\n+  rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n+    Resolver::Definition d;\n+    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+    rust_assert (ok);\n+\n+    HIR::Stmt *decl = nullptr;\n+    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+    rust_assert (ok);\n+\n+    // if its a function we extract this out side of this fn context\n+    // and it is not a local to this function\n+    bool is_item = ctx->get_mappings ()->lookup_hir_item (\n+\t\t     decl->get_mappings ().get_crate_num (),\n+\t\t     decl->get_mappings ().get_hirid ())\n+\t\t   != nullptr;\n+    if (is_item)\n+      {\n+\tHIR::Item *item = static_cast<HIR::Item *> (decl);\n+\tCompileItem::compile (item, ctx, true);\n+\treturn true;\n+      }\n+\n+    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+    locals.push_back (compiled);\n+\n+    return true;\n+  });\n+\n+  return true;\n+}\n+\n // Mr Mangle time\n \n static const std::string kMangledSymbolPrefix = \"_ZN\";"}, {"sha": "1dd8a10425ed231f4f786c174d21538ba54dc1e2", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -230,6 +230,91 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t       empty.get_locus ());\n   }\n \n+  void visit (AST::Function &function) override\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // need\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (function.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (function.get_generic_params ());\n+      }\n+\n+    Identifier function_name = function.get_function_name ();\n+    Location locus = function.get_locus ();\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t    : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> function_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    mappings->insert_location (crate_num,\n+\t\t\t       function_body->get_mappings ().get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    auto fn\n+      = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (function_body),\n+\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       fn);\n+    mappings->insert_hir_stmt (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       fn);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : fn->get_function_params ())\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n+\n+    translated = fn;\n+  }\n+\n private:\n   ASTLoweringStmt () : translated (nullptr), terminated (false) {}\n "}, {"sha": "e68e7b93f3f157ceb3b0bfe4eeb5475c07f80136", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -129,6 +129,61 @@ class ResolveStmt : public ResolverBase\n     resolver->get_type_scope ().pop ();\n   }\n \n+  void visit (AST::Function &function) override\n+  {\n+    auto path = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (function.get_node_id (),\n+\t\t\t\t     Definition{function.get_node_id (),\n+\t\t\t\t\t\tfunction.get_node_id ()});\n+\n+    NodeId scope_node_id = function.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (),\n+\t\t       function.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // resolve the function body\n+    ResolveExpr::go (function.get_definition ().get (),\n+\t\t     function.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n private:\n   ResolveStmt (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "fae3f77930baec11b92803f2c7abbd32b43d00fa", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -499,9 +499,8 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n   else\n     {\n       rust_error_at (expr->get_locus (),\n-\t\t     \"unknown root segment in path %s lookup %s\",\n-\t\t     expr->as_string ().c_str (),\n-\t\t     root_ident_seg.as_string ().c_str ());\n+\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t     expr->as_string ().c_str ());\n       return;\n     }\n "}, {"sha": "3655d968dfecfc24b9fc36601a4fbbef14056a56", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -216,6 +216,86 @@ class TypeCheckStmt : public TypeCheckBase\n     infered = type;\n   }\n \n+  void visit (HIR::Function &function) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic_param : function.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    TyTy::BaseType *ret_type = nullptr;\n+    if (!function.has_function_return_type ())\n+      ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n+    else\n+      {\n+\tauto resolved\n+\t  = TypeCheckType::Resolve (function.get_return_type ().get ());\n+\tif (resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_locus (),\n+\t\t\t   \"failed to resolve return type\");\n+\t    return;\n+\t  }\n+\n+\tret_type = resolved->clone ();\n+\tret_type->set_ref (\n+\t  function.get_return_type ()->get_mappings ().get_hirid ());\n+      }\n+\n+    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\t// get the name as well required for later on\n+\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t       param_tyty));\n+\n+\tcontext->insert_type (param.get_mappings (), param_tyty);\n+      }\n+\n+    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t    function.get_function_name (), false,\n+\t\t\t\t    std::move (params), ret_type,\n+\t\t\t\t    std::move (substitutions));\n+    context->insert_type (function.get_mappings (), fnType);\n+\n+    TyTy::FnType *resolved_fn_type = fnType;\n+    auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+    context->push_return_type (expected_ret_tyty);\n+\n+    auto block_expr_ty\n+      = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n+\n+    context->pop_return_type ();\n+\n+    if (block_expr_ty->get_kind () != TyTy::NEVER)\n+      expected_ret_tyty->unify (block_expr_ty);\n+\n+    infered = fnType;\n+  }\n+\n private:\n   TypeCheckStmt (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)"}, {"sha": "4a96f9ff1403278239689b580b4664dd5c60c182", "filename": "gcc/testsuite/rust/compile/lookup_err1.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Ftestsuite%2Frust%2Fcompile%2Flookup_err1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Ftestsuite%2Frust%2Fcompile%2Flookup_err1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Flookup_err1.rs?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -0,0 +1,7 @@\n+fn test() {\n+    fn nested() {}\n+}\n+\n+fn main() {\n+    nested(); // { dg-error \"Cannot find path .nested. in this scope\" }\n+}"}, {"sha": "075b5dba8e049ba22f9383ca44ecc45aefc7fc29", "filename": "gcc/testsuite/rust/compile/torture/nested_fn1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fnested_fn1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fnested_fn1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fnested_fn1.rs?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -0,0 +1,10 @@\n+pub fn main() {\n+    let a = 123;\n+\n+    fn test(x: i32) -> i32 {\n+        x + 456\n+    }\n+\n+    let b;\n+    b = test(a);\n+}"}, {"sha": "7040c862e75e025689a4376bf16b4686b3ed5be9", "filename": "gcc/testsuite/rust/compile/torture/nested_fn2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fnested_fn2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a434a33904608f5659cf7b5d4df3d2a99bd5bd/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fnested_fn2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fnested_fn2.rs?ref=92a434a33904608f5659cf7b5d4df3d2a99bd5bd", "patch": "@@ -0,0 +1,11 @@\n+pub fn main() {\n+    fn test<T>(x: T) -> T {\n+        x\n+    }\n+\n+    let mut a = 123;\n+    a = test(a);\n+\n+    let mut b = 456f32;\n+    b = test(b);\n+}"}]}