{"sha": "8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMwYzgzZmViMDRkNzQ4NmNjZjljYmU4NmRjZDU2NjhmMGEyMWVmOQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-11-06T20:21:13Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-11-10T20:08:06Z"}, "message": "c++: Improve static_assert diagnostic [PR97518]\n\nCurrently, when a static_assert fails, we only say \"static assertion failed\".\nIt would be more useful if we could also print the expression that\nevaluated to false; this is especially useful when the condition uses\ntemplate parameters.  Consider the motivating example, in which we have\nthis line:\n\n  static_assert(is_same<X, Y>::value);\n\nif this fails, the user has to play dirty games to get the compiler to\nprint the template arguments.  With this patch, we say:\n\n  error: static assertion failed\n  note: 'is_same<int*, int>::value' evaluates to false\n\nwhich I think is much better.  However, always printing the condition that\nevaluated to 'false' wouldn't be very useful: e.g. noexcept(fn) is\nalways parsed to true/false, so we would say \"'false' evaluates to false\"\nwhich doesn't help.  So I wound up only printing the condition when it was\ninstantiation-dependent, that is, we called finish_static_assert from\ntsubst_expr.\n\nMoreover, this patch also improves the diagnostic when the condition\nconsists of a logical AND.  Say you have something like this:\n\n  static_assert(fn1() && fn2() && fn3() && fn4() && fn5());\n\nwhere fn4() evaluates to false and the other ones to true.  Highlighting\nthe whole thing is not that helpful because it won't say which clause\nevaluated to false.  With the find_failing_clause tweak in this patch\nwe emit:\n\n  error: static assertion failed\n    6 | static_assert(fn1() && fn2() && fn3() && fn4() && fn5());\n      |                                          ~~~^~\n\nso you know right away what's going on.  Unfortunately, when you combine\nboth things, that is, have an instantiation-dependent expr and && in\na static_assert, we can't yet quite point to the clause that failed.  It\nis because when we tsubstitute something like is_same<X, Y>::value, we\ngenerate a VAR_DECL that doesn't have any location.  It would be awesome\nif we could wrap it with a location wrapper, but I didn't see anything\nobvious.\n\nIn passing, I've cleaned up some things:\n* use iloc_sentinel when appropriate,\n* it's nicer to call contextual_conv_bool instead of the rather verbose\n  perform_implicit_conversion_flags,\n* no need to check for INTEGER_CST before calling integer_zerop.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97518\n\t* cp-tree.h (finish_static_assert): Adjust declaration.\n\t* parser.c (cp_parser_static_assert): Pass false to\n\tfinish_static_assert.\n\t* pt.c (tsubst_expr): Pass true to finish_static_assert.\n\t* semantics.c (find_failing_clause_r): New function.\n\t(find_failing_clause): New function.\n\t(finish_static_assert): Add a bool parameter.  Use\n\tiloc_sentinel.  Call contextual_conv_bool instead of\n\tperform_implicit_conversion_flags.  Don't check for INTEGER_CST before\n\tcalling integer_zerop.  Call find_failing_clause and maybe use its\n\tlocation.  Print the original condition or the failing clause if\n\tSHOW_EXPR_P.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97518\n\t* g++.dg/diagnostic/pr87386.C: Adjust expected output.\n\t* g++.dg/diagnostic/static_assert1.C: New test.\n\t* g++.dg/diagnostic/static_assert2.C: New test.\n\nlibcc1/ChangeLog:\n\n\tPR c++/97518\n\t* libcp1plugin.cc (plugin_add_static_assert): Pass false to\n\tfinish_static_assert.", "tree": {"sha": "83991e65e0c54d69e82e832bffd8031f93483356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83991e65e0c54d69e82e832bffd8031f93483356"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a210d404d08e363af4b2e2a60986c3cb08f8ebc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a210d404d08e363af4b2e2a60986c3cb08f8ebc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a210d404d08e363af4b2e2a60986c3cb08f8ebc5"}], "stats": {"total": 186, "additions": 167, "deletions": 19}, "files": [{"sha": "230a1525c637835fe1670f7bd08d0b25bc883828", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -7234,7 +7234,7 @@ extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t bool, bool);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n-                                                 bool);\n+\t\t\t\t\t\t bool, bool);\n extern tree finish_decltype_type                (tree, bool, tsubst_flags_t);\n extern tree finish_trait_expr\t\t\t(location_t, enum cp_trait_kind, tree, tree);\n extern tree build_lambda_expr                   (void);"}, {"sha": "363228123108d0572a25fd8456b0fe97de6fa642", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -14886,7 +14886,8 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n \n   /* Complete the static assertion, which may mean either processing\n      the static assert now or saving it for template instantiation.  */\n-  finish_static_assert (condition, message, assert_loc, member_p);\n+  finish_static_assert (condition, message, assert_loc, member_p,\n+\t\t\t/*show_expr_p=*/false);\n }\n \n /* Parse the expression in decltype ( expression ).  */"}, {"sha": "6ba114c9da3350ef8cede7ee123ae95a6cee2611", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -18492,8 +18492,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \ttree condition;\n \n \t++c_inhibit_evaluation_warnings;\n-        condition = \n-          tsubst_expr (STATIC_ASSERT_CONDITION (t), \n+\tcondition =\n+\t  tsubst_expr (STATIC_ASSERT_CONDITION (t),\n                        args,\n                        complain, in_decl,\n                        /*integral_constant_expression_p=*/true);\n@@ -18502,7 +18502,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n         finish_static_assert (condition,\n                               STATIC_ASSERT_MESSAGE (t),\n                               STATIC_ASSERT_SOURCE_LOCATION (t),\n-                              /*member_p=*/false);\n+\t\t\t      /*member_p=*/false, /*show_expr_p=*/true);\n       }\n       break;\n "}, {"sha": "df698d51dfe3660ffdfa13f63ae3e2a991e66ef7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -9827,13 +9827,53 @@ init_cp_semantics (void)\n {\n }\n \f\n+\n+/* If we have a condition in conjunctive normal form (CNF), find the first\n+   failing clause.  In other words, given an expression like\n+\n+     true && true && false && true && false\n+\n+   return the first 'false'.  EXPR is the expression.  */\n+\n+static tree\n+find_failing_clause_r (tree expr)\n+{\n+  if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n+    {\n+      /* First check the left side...  */\n+      tree e = find_failing_clause_r (TREE_OPERAND (expr, 0));\n+      if (e == NULL_TREE)\n+\t/* ...if we didn't find a false clause, check the right side.  */\n+\te = find_failing_clause_r (TREE_OPERAND (expr, 1));\n+      return e;\n+    }\n+  tree e = contextual_conv_bool (expr, tf_none);\n+  e = fold_non_dependent_expr (e, tf_none, /*manifestly_const_eval=*/true);\n+  if (integer_zerop (e))\n+    /* This is the failing clause.  */\n+    return expr;\n+  return NULL_TREE;\n+}\n+\n+/* Wrapper for find_failing_clause_r.  */\n+\n+static tree\n+find_failing_clause (tree expr)\n+{\n+  if (TREE_CODE (expr) != TRUTH_ANDIF_EXPR)\n+    return NULL_TREE;\n+  return find_failing_clause_r (expr);\n+}\n+\n /* Build a STATIC_ASSERT for a static assertion with the condition\n    CONDITION and the message text MESSAGE.  LOCATION is the location\n    of the static assertion in the source code.  When MEMBER_P, this\n-   static assertion is a member of a class.  */\n+   static assertion is a member of a class.  If SHOW_EXPR_P is true,\n+   print the condition (because it was instantiation-dependent).  */\n+\n void\n finish_static_assert (tree condition, tree message, location_t location,\n-                      bool member_p)\n+\t\t      bool member_p, bool show_expr_p)\n {\n   tsubst_flags_t complain = tf_warning_or_error;\n \n@@ -9871,8 +9911,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n   tree orig_condition = condition;\n \n   /* Fold the expression and convert it to a boolean value. */\n-  condition = perform_implicit_conversion_flags (boolean_type_node, condition,\n-\t\t\t\t\t\t complain, LOOKUP_NORMAL);\n+  condition = contextual_conv_bool (condition, complain);\n   condition = fold_non_dependent_expr (condition, complain,\n \t\t\t\t       /*manifestly_const_eval=*/true);\n \n@@ -9881,21 +9920,32 @@ finish_static_assert (tree condition, tree message, location_t location,\n     ;\n   else\n     {\n-      location_t saved_loc = input_location;\n+      iloc_sentinel ils (location);\n \n-      input_location = location;\n-      if (TREE_CODE (condition) == INTEGER_CST\n-          && integer_zerop (condition))\n+      if (integer_zerop (condition))\n \t{\n \t  int sz = TREE_INT_CST_LOW (TYPE_SIZE_UNIT\n \t\t\t\t     (TREE_TYPE (TREE_TYPE (message))));\n \t  int len = TREE_STRING_LENGTH (message) / sz - 1;\n+\n+\t  /* See if we can find which clause was failing (for logical AND).  */\n+\t  tree bad = find_failing_clause (orig_condition);\n+\t  /* If not, or its location is unusable, fall back to the previous\n+\t     location.  */\n+\t  location_t cloc = location;\n+\t  if (cp_expr_location (bad) != UNKNOWN_LOCATION)\n+\t    cloc = cp_expr_location (bad);\n+\n           /* Report the error. */\n \t  if (len == 0)\n-            error (\"static assertion failed\");\n+\t    error_at (cloc, \"static assertion failed\");\n \t  else\n-            error (\"static assertion failed: %s\",\n-\t\t   TREE_STRING_POINTER (message));\n+\t    error_at (cloc, \"static assertion failed: %s\",\n+\t\t      TREE_STRING_POINTER (message));\n+\t  if (show_expr_p)\n+\t    inform (cloc, \"%qE evaluates to false\",\n+\t\t    /* Nobody wants to see the artificial (bool) cast.  */\n+\t\t    (bad ? tree_strip_nop_conversions (bad) : orig_condition));\n \n \t  /* Actually explain the failure if this is a concept check or a\n \t     requires-expression.  */\n@@ -9909,7 +9959,6 @@ finish_static_assert (tree condition, tree message, location_t location,\n \t  if (require_rvalue_constant_expression (condition))\n \t    cxx_constant_value (condition);\n \t}\n-      input_location = saved_loc;\n     }\n }\n \f"}, {"sha": "679a5177f64a554bbd27e064c2235b717fe36d3d", "filename": "gcc/testsuite/g++.dg/diagnostic/pr87386.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr87386.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr87386.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fpr87386.C?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -14,5 +14,5 @@ static_assert (foo::test<int>::value, \"foo\");\t\t// { dg-error \"static assertion f\n static_assert (foo::test<int>::value && true, \"bar\");\t// { dg-error \"static assertion failed: bar\" }\n /* { dg-begin-multiline-output \"\" }\n  static_assert (foo::test<int>::value && true, \"bar\");\n-                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n+                ~~~~~~~~~~~~~~~~^~~~~\n    { dg-end-multiline-output \"\" } */"}, {"sha": "fecf3cc51a09679033878b38ba304e6f6d8ee6c4", "filename": "gcc/testsuite/g++.dg/diagnostic/static_assert1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert1.C?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/97518\n+// { dg-do compile { target c++17 } }\n+\n+template <typename T, typename U> struct is_same { static constexpr bool value = false; };\n+template <typename T> struct is_same<T, T> { static constexpr bool value = true; };\n+\n+template <typename T> using some_metafunction_t = T;\n+\n+template <typename T>\n+void foo(T ) {\n+    using X = T*;\n+    using Y = some_metafunction_t<T>;\n+\n+    static_assert(is_same<X, Y>::value); // { dg-error \"static assertion failed\" }\n+    // { dg-message {.is_same<int\\*, int>::value. evaluates to false} \"\" { target *-*-* } .-1 }\n+    static_assert(is_same<X, Y>::value, \"foo\"); // { dg-error \"static assertion failed: foo\" }\n+    // { dg-message {.is_same<int\\*, int>::value. evaluates to false} \"\" { target *-*-* } .-1 }\n+    static_assert(is_same<X, X>::value && is_same<X, Y>::value); // { dg-error \"static assertion failed\" }\n+    // { dg-message {.is_same<int\\*, int>::value. evaluates to false} \"\" { target *-*-* } .-1 }\n+    static_assert(is_same<X, Y>::value && is_same<X, X>::value); // { dg-error \"static assertion failed\" }\n+    // { dg-message {.is_same<int\\*, int>::value. evaluates to false} \"\" { target *-*-* } .-1 }\n+    static_assert(is_same<X, X>::value\n+\t\t  && is_same<Y, Y>::value\n+\t\t  && is_same<X, Y>::value); // { dg-error \"static assertion failed\" }\n+    // { dg-message {.is_same<int\\*, int>::value. evaluates to false} \"\" { target *-*-* } .-1 }\n+}\n+\n+void bar() {\n+    foo(0);\n+}"}, {"sha": "542697f99dec086dde29ea7ca57c9e9d6b200ee9", "filename": "gcc/testsuite/g++.dg/diagnostic/static_assert2.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert2.C?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -0,0 +1,68 @@\n+// PR c++/97518\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+constexpr bool yes () { return true; }\n+constexpr bool no () { return false; }\n+constexpr bool yay = true;\n+constexpr bool nay = false;\n+\n+void\n+bar ()\n+{\n+  static_assert (true && true && no(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (true && true && no(), \"\");\n+                                  ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert (yay && nay, \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (yay && nay, \"\");\n+                         ^~~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert (yes() && no(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (yes() && no(), \"\");\n+                           ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert (no() && yes(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (no() && yes(), \"\");\n+                  ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert (no() && no() && yes(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (no() && no() && yes(), \"\");\n+                  ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert (yes() && yes() && yes () && no() && yes(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (yes() && yes() && yes () && no() && yes(), \"\");\n+                                              ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert (yes() && yes() && yes () && (no() && yes()), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert (yes() && yes() && yes () && (no() && yes()), \"\");\n+                                               ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert ((yes() && no()) && no(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert ((yes() && no()) && no(), \"\");\n+                            ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert ((yes() && no()) && no(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert ((yes() && no()) && no(), \"\");\n+                            ~~^~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert ((no() || no()) && yes(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert ((no() || no()) && yes(), \"\");\n+                  ~~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  static_assert ((yes() || no()) && no(), \"\"); // { dg-error \"static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert ((yes() || no()) && no(), \"\");\n+                                     ~~^~\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "67a235f90953ddd23bde789219e35467ee78cb62", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=8c0c83feb04d7486ccf9cbe86dcd5668f0a21ef9", "patch": "@@ -3642,7 +3642,7 @@ plugin_add_static_assert (cc1_plugin::connection *self,\n \n   bool member_p = at_class_scope_p ();\n \n-  finish_static_assert (condition, message, loc, member_p);\n+  finish_static_assert (condition, message, loc, member_p, false);\n \n   return 1;\n }"}]}