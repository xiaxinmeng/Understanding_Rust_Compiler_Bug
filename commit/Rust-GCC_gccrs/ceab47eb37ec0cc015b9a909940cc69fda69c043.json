{"sha": "ceab47eb37ec0cc015b9a909940cc69fda69c043", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhYjQ3ZWIzN2VjMGNjMDE1YjlhOTA5OTQwY2M2OWZkYTY5YzA0Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-19T14:51:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-19T14:51:38Z"}, "message": "call.c (compare_qual): Remove.\n\n\t* call.c (compare_qual): Remove.\n\t(is_subseq): Tweak.\n\t(is_properly_derived_from): New function.\n\t(maybe_handle_ref_bind): Likewise.\n\t(maybe_handle_implicit_object): Likewise.\n\t(compare_ics): Modify substantially to bring into conformance with\n\tthe standard.\n\t* cp-tree.h (TYPE_PTRMEMFUNC_OBJECT_TYPE): New macro.\n\t(comp_cv_qualification): Declare.\n\t(comp_cv_qual_signature): Likewise.\n\t* typeck.c (comp_cv_qualification): Likewise.\n\t(comp_cv_qual_signature): Likewise.\n\nFrom-SVN: r19880", "tree": {"sha": "fe4cecea6b558a7d39d252c8a45348d30e31a189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe4cecea6b558a7d39d252c8a45348d30e31a189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceab47eb37ec0cc015b9a909940cc69fda69c043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceab47eb37ec0cc015b9a909940cc69fda69c043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceab47eb37ec0cc015b9a909940cc69fda69c043", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceab47eb37ec0cc015b9a909940cc69fda69c043/comments", "author": null, "committer": null, "parents": [{"sha": "06033860a75f5fbe45d6df0269b050a2e7dfa086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06033860a75f5fbe45d6df0269b050a2e7dfa086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06033860a75f5fbe45d6df0269b050a2e7dfa086"}], "stats": {"total": 748, "additions": 517, "deletions": 231}, "files": [{"sha": "4050467066685e47b74f84a816d9f6c3eb80f513", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -1,3 +1,18 @@\n+Tue May 19 14:50:27 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* call.c (compare_qual): Remove.\n+\t(is_subseq): Tweak.\n+\t(is_properly_derived_from): New function.\n+\t(maybe_handle_ref_bind): Likewise.\n+\t(maybe_handle_implicit_object): Likewise.\n+\t(compare_ics): Modify substantially to bring into conformance with\n+\tthe standard.\n+\t* cp-tree.h (TYPE_PTRMEMFUNC_OBJECT_TYPE): New macro.\n+\t(comp_cv_qualification): Declare.\n+\t(comp_cv_qual_signature): Likewise.\n+\t* typeck.c (comp_cv_qualification): Likewise.\n+\t(comp_cv_qual_signature): Likewise.\n+\n Tue May 19 10:05:02 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (parse.o): Depend on toplev.h."}, {"sha": "67795ab9bb2f5b20c0a250175614b518a3779e6f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 376, "deletions": 220, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -45,7 +45,6 @@ static tree build_field_call PROTO((tree, tree, tree, tree));\n static tree find_scoped_type PROTO((tree, tree, tree));\n static struct z_candidate * tourney PROTO((struct z_candidate *));\n static int joust PROTO((struct z_candidate *, struct z_candidate *, int));\n-static int compare_qual PROTO((tree, tree));\n static int compare_ics PROTO((tree, tree));\n static tree build_over_call PROTO((struct z_candidate *, tree, int));\n static tree convert_default_arg PROTO((tree, tree));\n@@ -89,6 +88,9 @@ static tree strip_top_quals PROTO((tree));\n static tree non_reference PROTO((tree));\n static tree build_conv PROTO((enum tree_code, tree, tree));\n static int is_subseq PROTO((tree, tree));\n+static int is_properly_derived_from PROTO((tree, tree));\n+static int maybe_handle_ref_bind PROTO((tree*, tree*));\n+static void maybe_handle_implicit_object PROTO((tree*));\n \n tree\n build_vfield_ref (datum, type)\n@@ -3658,136 +3660,214 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n      flags);\n }\n \n-/* Compare two implicit conversion sequences that differ only in their\n-   qualification conversion.  Subroutine of compare_ics.  */\n+/* Returns non-zero iff standard conversion sequence ICS1 is a proper\n+   subsequence of ICS2.  */\n \n static int\n-compare_qual (ics1, ics2)\n+is_subseq (ics1, ics2)\n      tree ics1, ics2;\n {\n-  tree to1 = TREE_TYPE (ics1);\n-  tree to2 = TREE_TYPE (ics2);\n-\n-  if (TYPE_PTRMEMFUNC_P (to1))\n-    to1 = TYPE_PTRMEMFUNC_FN_TYPE (to1);\n-  if (TYPE_PTRMEMFUNC_P (to2))\n-    to2 = TYPE_PTRMEMFUNC_FN_TYPE (to2);\n+  /* We can assume that a conversion of the same code\n+     between the same types indicates a subsequence since we only get\n+     here if the types we are converting from are the same.  */\n \n-  to1 = TREE_TYPE (to1);\n-  to2 = TREE_TYPE (to2);\n+  while (TREE_CODE (ics1) == RVALUE_CONV\n+\t || TREE_CODE (ics1) == LVALUE_CONV)\n+    ics1 = TREE_OPERAND (ics1, 0);\n \n-  if (TREE_CODE (to1) == OFFSET_TYPE)\n+  while (1)\n     {\n-      to1 = TREE_TYPE (to1);\n-      to2 = TREE_TYPE (to2);\n-    }\n-\n-  if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n-      && TYPE_VOLATILE (to1) > TYPE_VOLATILE (to2))\n-    return -1;\n-  else if (TYPE_READONLY (to1) > TYPE_READONLY (to2)\n-\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n-    return -1;\n-  else if (TYPE_READONLY (to1) <= TYPE_READONLY (to2)\n-\t   && TYPE_VOLATILE (to1) < TYPE_VOLATILE (to2))\n-    return 1;\n-  else if (TYPE_READONLY (to1) < TYPE_READONLY (to2)\n-\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n-    return 1;\n-  return 0;\n-}\n+      while (TREE_CODE (ics2) == RVALUE_CONV\n+\t  || TREE_CODE (ics2) == LVALUE_CONV)\n+\tics2 = TREE_OPERAND (ics2, 0);\n \n-/* Determine whether standard conversion sequence ICS1 is a proper\n-   subsequence of ICS2.  We assume that a conversion of the same code\n-   between the same types indicates a subsequence.  */\n+      if (TREE_CODE (ics2) == USER_CONV\n+\t  || TREE_CODE (ics2) == AMBIG_CONV\n+\t  || TREE_CODE (ics2) == IDENTITY_CONV)\n+\t/* At this point, ICS1 cannot be a proper subsequence of\n+\t   ICS2.  We can get a USER_CONV when we are comparing the\n+\t   second standard conversion sequence of two user conversion\n+\t   sequences.  */\n+\treturn 0;\n \n-static int\n-is_subseq (ics1, ics2)\n-     tree ics1, ics2;\n-{\n-  /* Do not consider lvalue transformations here.  */\n-  if (TREE_CODE (ics2) == RVALUE_CONV\n-      || TREE_CODE (ics2) == LVALUE_CONV)\n-    return 0;\n+      ics2 = TREE_OPERAND (ics2, 0);\n \n-  for (;; ics2 = TREE_OPERAND (ics2, 0))\n-    {\n       if (TREE_CODE (ics2) == TREE_CODE (ics1)\n \t  && comptypes (TREE_TYPE (ics2), TREE_TYPE (ics1), 1)\n \t  && comptypes (TREE_TYPE (TREE_OPERAND (ics2, 0)),\n \t\t\tTREE_TYPE (TREE_OPERAND (ics1, 0)), 1))\n \treturn 1;\n-\n-      if (TREE_CODE (ics2) == USER_CONV\n-\t  || TREE_CODE (ics2) == AMBIG_CONV\n-\t  || TREE_CODE (ics2) == IDENTITY_CONV)\n-\treturn 0;\n     }\n }\n \n-/* Compare two implicit conversion sequences according to the rules set out in\n-   [over.ics.rank].  Return values:\n-\n-      1: ics1 is better than ics2\n-     -1: ics2 is better than ics1\n-      0: ics1 and ics2 are indistinguishable */\n+/* Returns non-zero iff DERIVED is derived from BASE.  The inputs may\n+   be any _TYPE nodes.  */\n \n static int\n-compare_ics (ics1, ics2)\n-     tree ics1, ics2;\n+is_properly_derived_from (derived, base)\n+     tree derived;\n+     tree base;\n {\n-  tree main1, main2;\n+  if (!IS_AGGR_TYPE_CODE (TREE_CODE (derived))\n+      || !IS_AGGR_TYPE_CODE (TREE_CODE (base)))\n+    return 0;\n \n-  if (TREE_CODE (ics1) == QUAL_CONV)\n-    main1 = TREE_OPERAND (ics1, 0);\n-  else\n-    main1 = ics1;\n+  /* We only allow proper derivation here.  The DERIVED_FROM_P macro\n+     considers every class derived from itself.  */\n+  return (!comptypes (TYPE_MAIN_VARIANT (derived),\n+\t\t      TYPE_MAIN_VARIANT (base), 1)\n+\t  && DERIVED_FROM_P (base, derived));\n+}\n \n-  if (TREE_CODE (ics2) == QUAL_CONV)\n-    main2 = TREE_OPERAND (ics2, 0);\n-  else\n-    main2 = ics2;\n+/* We build the ICS for an implicit object parameter as a pointer\n+   conversion sequence.  However, such a sequence should be compared\n+   as if it were a reference conversion sequence.  If ICS is the\n+   implicit conversion sequence for an implicit object parameter,\n+   modify it accordingly.  */\n \n-  /* Conversions for `this' are PTR_CONVs, but we compare them as though\n-     they were REF_BINDs.  */\n-  if (ICS_THIS_FLAG (ics1))\n+static void\n+maybe_handle_implicit_object (ics)\n+     tree* ics;\n+{\n+  if (ICS_THIS_FLAG (*ics))\n     {\n-      tree t = main1;\n+      /* [over.match.funcs]\n+\t \n+\t For non-static member functions, the type of the\n+\t implicit object parameter is \"reference to cv X\"\n+\t where X is the class of which the function is a\n+\t member and cv is the cv-qualification on the member\n+\t function declaration.  */\n+      tree t = *ics;\n       if (TREE_CODE (t) == PTR_CONV)\n \tt = TREE_OPERAND (t, 0);\n       t = build1 (IDENTITY_CONV, TREE_TYPE (TREE_TYPE (t)), NULL_TREE);\n-      t = build_conv (REF_BIND, TREE_TYPE (ics1), t);\n-      ICS_STD_RANK (t) = ICS_STD_RANK (main1);\n-      main1 = ics1 = t;\n+      t = build_conv (REF_BIND, TREE_TYPE (*ics), t);\n+      ICS_STD_RANK (t) = ICS_STD_RANK (*ics);\n+      *ics = t;\n     }\n-  if (ICS_THIS_FLAG (ics2))\n+}\n+\n+/* If ICS is a REF_BIND, modify it appropriately, set ORIG_TO_TYPE\n+   to the type the reference originally referred to, and return 1.\n+   Otherwise, return 0.  */\n+\n+static int\n+maybe_handle_ref_bind (ics, reference_type)\n+     tree* ics;\n+     tree* reference_type;\n+{\n+  if (TREE_CODE (*ics) == REF_BIND)\n     {\n-      tree t = main2;\n-      if (TREE_CODE (t) == PTR_CONV)\n-\tt = TREE_OPERAND (t, 0);\n-      t = build1 (IDENTITY_CONV, TREE_TYPE (TREE_TYPE (t)), NULL_TREE);\n-      t = build_conv (REF_BIND, TREE_TYPE (ics2), t);\n-      ICS_STD_RANK (t) = ICS_STD_RANK (main2);\n-      main2 = ics2 = t;\n+      /* [over.ics.rank] \n+\t \n+\t When a parameter of reference type binds directly\n+\t (_dcl.init.ref_) to an argument expression, the implicit\n+\t conversion sequence is the identity conversion, unless the\n+\t argument expression has a type that is a derived class of the\n+\t parameter type, in which case the implicit conversion\n+\t sequence is a derived-to-base Conversion.\n+\t \n+\t If the parameter binds directly to the result of applying a\n+\t conversion function to the argument expression, the implicit\n+\t conversion sequence is a user-defined conversion sequence\n+\t (_over.ics.user_), with the second standard conversion\n+\t sequence either an identity conversion or, if the conversion\n+\t function returns an entity of a type that is a derived class\n+\t of the parameter type, a derived-to-base Conversion.\n+\t \n+\t When a parameter of reference type is not bound directly to\n+\t an argument expression, the conversion sequence is the one\n+\t required to convert the argument expression to the underlying\n+\t type of the reference according to _over.best.ics_.\n+\t Conceptually, this conversion sequence corresponds to\n+\t copy-initializing a temporary of the underlying type with the\n+\t argument expression.  Any difference in top-level\n+\t cv-qualification is subsumed by the initialization itself and\n+\t does not constitute a conversion.  */\n+\n+      *reference_type = TREE_TYPE (TREE_TYPE (*ics));\n+      *ics = TREE_OPERAND (*ics, 0);\n+      if (TREE_CODE (*ics) == IDENTITY_CONV\n+\t  && is_properly_derived_from (TREE_TYPE (*ics), *reference_type))\n+\t*ics = build_conv (BASE_CONV, *reference_type, *ics);\n+      return 1;\n     }\n+  \n+  return 0;\n+}\n \n+/* Compare two implicit conversion sequences according to the rules set out in\n+   [over.ics.rank].  Return values:\n+\n+      1: ics1 is better than ics2\n+     -1: ics2 is better than ics1\n+      0: ics1 and ics2 are indistinguishable */\n+\n+static int\n+compare_ics (ics1, ics2)\n+     tree ics1, ics2;\n+{\n+  tree from_type1;\n+  tree from_type2;\n+  tree to_type1;\n+  tree to_type2;\n+  tree deref_from_type1 = NULL_TREE;\n+  tree deref_from_type2;\n+  tree deref_to_type1;\n+  tree deref_to_type2;\n+\n+  /* REF_BINDING is non-zero if the result of the conversion sequence\n+     is a reference type.   In that case REFERENCE_TYPE is the\n+     reference type.  */\n+  int ref_binding1;\n+  int ref_binding2;\n+  tree reference_type1;\n+  tree reference_type2;\n+\n+  /* Handle implicit object parameters.  */\n+  maybe_handle_implicit_object (&ics1);\n+  maybe_handle_implicit_object (&ics2);\n+\n+  /* Handle reference parameters.  */\n+  ref_binding1 = maybe_handle_ref_bind (&ics1, &reference_type1);\n+  ref_binding2 = maybe_handle_ref_bind (&ics2, &reference_type2);\n+\n+  /* [over.ics.rank]\n+\n+     When  comparing  the  basic forms of implicit conversion sequences (as\n+     defined in _over.best.ics_)\n+\n+     --a standard conversion sequence (_over.ics.scs_) is a better\n+       conversion sequence than a user-defined conversion sequence\n+       or an ellipsis conversion sequence, and\n+     \n+     --a user-defined conversion sequence (_over.ics.user_) is a\n+       better conversion sequence than an ellipsis conversion sequence\n+       (_over.ics.ellipsis_).  */\n   if (ICS_RANK (ics1) > ICS_RANK (ics2))\n     return -1;\n   else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n     return 1;\n \n   if (ICS_RANK (ics1) == BAD_RANK)\n     {\n+      /* Both ICS are bad.  We try to make a decision based on what\n+\t would have happenned if they'd been good.  */\n       if (ICS_USER_FLAG (ics1) > ICS_USER_FLAG (ics2)\n \t  || ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n \treturn -1;\n       else if (ICS_USER_FLAG (ics1) < ICS_USER_FLAG (ics2)\n \t       || ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n \treturn 1;\n \n-      /* else fall through */\n+      /* We couldn't make up our minds; try to figure it out below.  */\n     }\n \n+  if (ICS_ELLIPSIS_FLAG (ics1))\n+    /* Both conversions are ellipsis conversions.  */\n+    return 0;\n+\n   /* User-defined  conversion sequence U1 is a better conversion sequence\n      than another user-defined conversion sequence U2 if they contain the\n      same user-defined conversion operator or constructor and if the sec-\n@@ -3807,175 +3887,251 @@ compare_ics (ics1, ics2)\n \n       if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n \treturn 0;\n-      else if (ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n-\treturn -1;\n-      else if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n-\treturn 1;\n \n-      /* else fall through */\n+      /* We can just fall through here, after setting up\n+\t FROM_TYPE1 and FROM_TYPE2.  */\n+      from_type1 = TREE_TYPE (t1);\n+      from_type2 = TREE_TYPE (t2);\n     }\n+  else\n+    {\n+      /* We're dealing with two standard conversion sequences. \n \n-#if 0 /* Handled by ranking */\n-  /* A conversion that is not a conversion of a pointer,  or  pointer  to\n-     member,  to  bool  is  better than another conversion that is such a\n-     conversion.  */\n-#endif\n+\t [over.ics.rank]\n+\t \n+\t Standard conversion sequence S1 is a better conversion\n+\t sequence than standard conversion sequence S2 if\n+     \n+\t --S1 is a proper subsequence of S2 (comparing the conversion\n+\t   sequences in the canonical form defined by _over.ics.scs_,\n+\t   excluding any Lvalue Transformation; the identity\n+\t   conversion sequence is considered to be a subsequence of\n+\t   any non-identity conversion sequence */\n+      \n+      from_type1 = ics1;\n+      while (TREE_CODE (from_type1) != IDENTITY_CONV)\n+\tfrom_type1 = TREE_OPERAND (from_type1, 0);\n+      from_type1 = TREE_TYPE (from_type1);\n+      \n+      from_type2 = ics2;\n+      while (TREE_CODE (from_type2) != IDENTITY_CONV)\n+\tfrom_type2 = TREE_OPERAND (from_type2, 0);\n+      from_type2 = TREE_TYPE (from_type2);\n+    }\n \n-  if (TREE_CODE (main1) != TREE_CODE (main2))\n+  if (comptypes (from_type1, from_type2, 1))\n     {\n-      /* ...if S1  is  a  proper  subsequence  of  S2  */\n-      if (is_subseq (main1, main2))\n+      if (is_subseq (ics1, ics2))\n \treturn 1;\n-      if (is_subseq (main2, main1))\n+      if (is_subseq (ics2, ics1))\n \treturn -1;\n-      return 0;\n     }\n+  else\n+    /* One sequence cannot be a subsequence of the other; they don't\n+       start with the same type.  This can happen when comparing the\n+       second standard conversion sequence in two user-defined\n+       conversion sequences.  */\n+    ;\n \n-  if (TREE_CODE (main1) == PTR_CONV || TREE_CODE (main1) == PMEM_CONV\n-      || TREE_CODE (main1) == REF_BIND || TREE_CODE (main1) == BASE_CONV)\n-    {\n-      tree to1 = TREE_TYPE (main1);\n-      tree from1 = TREE_TYPE (TREE_OPERAND (main1, 0));\n-      tree to2 = TREE_TYPE (main2);\n-      tree from2 = TREE_TYPE (TREE_OPERAND (main2, 0));\n-      int distf, distt;\n-\n-      /* Standard conversion sequence S1 is a better conversion sequence than\n-\t standard conversion sequence S2 if...\n-\n-\t S1 and S2 differ only in their qualification conversion  and  they\n-\t yield types identical except for cv-qualifiers and S2 adds all the\n-\t qualifiers that S1 adds (and in the same places) and S2  adds  yet\n-\t more  cv-qualifiers  than  S1,  or the similar case with reference\n-\t binding15).  */\n-      if (TREE_CODE (main1) == REF_BIND)\n-\t{\n-\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (to1))\n-\t      == TYPE_MAIN_VARIANT (TREE_TYPE (to2)))\n-\t    return compare_qual (ics1, ics2);\n-\t}\n-      else if (TREE_CODE (main1) != BASE_CONV && from1 == from2 && to1 == to2)\n-\treturn compare_qual (ics1, ics2);\n-\t\n-      if (TYPE_PTRMEMFUNC_P (to1))\n-\t{\n-\t  to1 = TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (to1)));\n-\t  from1 = TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (from1)));\n-\t}\n-      else if (TREE_CODE (main1) != BASE_CONV)\n-\t{\n-\t  to1 = TREE_TYPE (to1);\n-\t  if (TREE_CODE (main1) != REF_BIND)\n-\t    from1 = TREE_TYPE (from1);\n+  /* [over.ics.rank]\n \n-\t  if (TREE_CODE (to1) == OFFSET_TYPE)\n-\t    {\n-\t      to1 = TYPE_OFFSET_BASETYPE (to1);\n-\t      from1 = TYPE_OFFSET_BASETYPE (from1);\n-\t    }\n-\t}\n+     Or, if not that,\n \n-      if (TYPE_PTRMEMFUNC_P (to2))\n-\t{\n-\t  to2 = TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (to2)));\n-\t  from2 = TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (from2)));\n-\t}\n-      else if (TREE_CODE (main1) != BASE_CONV)\n-\t{\n-\t  to2 = TREE_TYPE (to2);\n-\t  if (TREE_CODE (main1) != REF_BIND)\n-\t    from2 = TREE_TYPE (from2);\n+     --the rank of S1 is better than the rank of S2 (by the rules\n+       defined below):\n \n-\t  if (TREE_CODE (to2) == OFFSET_TYPE)\n-\t    {\n-\t      to2 = TYPE_OFFSET_BASETYPE (to2);\n-\t      from2 = TYPE_OFFSET_BASETYPE (from2);\n-\t    }\n-\t}\n+    Standard conversion sequences are ordered by their ranks: an Exact\n+    Match is a better conversion than a Promotion, which is a better\n+    conversion than a Conversion.\n \n-      if (! (IS_AGGR_TYPE (from1) && IS_AGGR_TYPE (from2)))\n-\treturn 0;\n+    Two conversion sequences with the same rank are indistinguishable\n+    unless one of the following rules applies:\n \n-      /* The sense of pmem conversions is reversed from that of the other\n-\t conversions.  */\n-      if (TREE_CODE (main1) == PMEM_CONV)\n-\t{\n-\t  tree t = from1; from1 = from2; from2 = t;\n-\t  t = to1; to1 = to2; to2 = t;\n-\t}\n+    --A conversion that is not a conversion of a pointer, or pointer\n+      to member, to bool is better than another conversion that is such\n+      a conversion.  \n \n-      distf = get_base_distance (from1, from2, 0, 0);\n-      if (distf == -1)\n-\t{\n-\t  distf = -get_base_distance (from2, from1, 0, 0);\n-\t  if (distf == 1)\n-\t    return 0;\n-\t}\n+    The ICS_STD_RANK automatically handles the pointer-to-bool rule,\n+    so that we do not have to check it explicitly.  */\n+  if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+    return 1;\n+  else if (ICS_STD_RANK (ics2) < ICS_STD_RANK (ics1))\n+    return -1;\n+\n+  to_type1 = TREE_TYPE (ics1);\n+  to_type2 = TREE_TYPE (ics2);\n \n-      /* If class B is derived directly or indirectly from class A,\n-\t conver- sion of B* to A* is better than conversion of B* to\n-\t void*, and conversion of A* to void* is better than\n-\t conversion of B* to void*.  */\n+  if (TYPE_PTR_P (from_type1)\n+      && TYPE_PTR_P (from_type2)\n+      && TYPE_PTR_P (to_type1)\n+      && TYPE_PTR_P (to_type2))\n+    {\n+      deref_from_type1 = TREE_TYPE (from_type1);\n+      deref_from_type2 = TREE_TYPE (from_type2);\n+      deref_to_type1 = TREE_TYPE (to_type1);\n+      deref_to_type2 = TREE_TYPE (to_type2);\n+    }\n+  /* The rules for pointers to members A::* are just like the rules\n+     for pointers A*, except opposite: if B is derived from A then\n+     A::* converts to B::*, not vice versa.  For that reason, we\n+     switch the from_ and to_ variables here.  */\n+  else if (TYPE_PTRMEM_P (from_type1)\n+\t   && TYPE_PTRMEM_P (from_type2)\n+\t   && TYPE_PTRMEM_P (to_type1)\n+\t   && TYPE_PTRMEM_P (to_type2))\n+    {\n+      deref_to_type1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (from_type1));\n+      deref_to_type2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (from_type2));\n+      deref_from_type1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (to_type1));\n+      deref_from_type2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (to_type2));\n+    }\n+  else if (TYPE_PTRMEMFUNC_P (from_type1)\n+\t   && TYPE_PTRMEMFUNC_P (from_type2)\n+\t   && TYPE_PTRMEMFUNC_P (to_type1)\n+\t   && TYPE_PTRMEMFUNC_P (to_type2))\n+    {\n+      deref_to_type1 = TYPE_PTRMEMFUNC_OBJECT_TYPE (from_type1);\n+      deref_to_type2 = TYPE_PTRMEMFUNC_OBJECT_TYPE (from_type2);\n+      deref_from_type1 = TYPE_PTRMEMFUNC_OBJECT_TYPE (to_type1);\n+      deref_from_type2 = TYPE_PTRMEMFUNC_OBJECT_TYPE (to_type2);\n+    }\n \n-      if (TREE_CODE (to1) == VOID_TYPE && TREE_CODE (to2) == VOID_TYPE)\n+  if (deref_from_type1 != NULL_TREE\n+      && IS_AGGR_TYPE_CODE (TREE_CODE (deref_from_type1))\n+      && IS_AGGR_TYPE_CODE (TREE_CODE (deref_from_type2)))\n+    {\n+      /* This was one of the pointer or pointer-like conversions.  \n+\n+\t [over.ics.rank]\n+\t \n+\t --If class B is derived directly or indirectly from class A,\n+\t   conversion of B* to A* is better than conversion of B* to\n+\t   void*, and conversion of A* to void* is better than\n+\t   conversion of B* to void*.  */\n+      if (TREE_CODE (deref_to_type1) == VOID_TYPE\n+\t  && TREE_CODE (deref_to_type2) == VOID_TYPE)\n \t{\n-\t  if (distf > 0)\n-\t    return 1;\n-\t  else if (distf < 0)\n+\t  if (is_properly_derived_from (deref_from_type1,\n+\t\t\t\t\tderef_from_type2))\n \t    return -1;\n+\t  else if (is_properly_derived_from (deref_from_type2,\n+\t\t\t\t\t     deref_from_type1))\n+\t    return 1;\n \t}\n-      else if (TREE_CODE (to2) == VOID_TYPE && IS_AGGR_TYPE (to1)\n-\t       && DERIVED_FROM_P (to1, from1))\n-\treturn 1;\n-      else if (TREE_CODE (to1) == VOID_TYPE && IS_AGGR_TYPE (to2)\n-\t       && DERIVED_FROM_P (to2, from2))\n-\treturn -1;\n-\n-      if (! (IS_AGGR_TYPE (to1) && IS_AGGR_TYPE (to2)))\n-\treturn 0;\n-\n-      /* If  class B is derived directly or indirectly from class A and class\n-\t C is derived directly or indirectly from B */\n-\n-      distt = get_base_distance (to1, to2, 0, 0);\n-      if (distt == -1)\n+      else if (TREE_CODE (deref_to_type1) == VOID_TYPE\n+\t       || TREE_CODE (deref_to_type2) == VOID_TYPE)\n \t{\n-\t  distt = -get_base_distance (to2, to1, 0, 0);\n-\t  if (distt == 1)\n-\t    return 0;\n+\t  if (comptypes (deref_from_type1, deref_from_type2, 1))\n+\t    {\n+\t      if (TREE_CODE (deref_to_type2) == VOID_TYPE)\n+\t\t{\n+\t\t  if (is_properly_derived_from (deref_from_type1,\n+\t\t\t\t\t\tderef_to_type1))\n+\t\t    return 1;\n+\t\t}\n+\t      /* We know that DEREF_TO_TYPE1 is `void' here.  */\n+\t      else if (is_properly_derived_from (deref_from_type1,\n+\t\t\t\t\t\t deref_to_type2))\n+\t\treturn -1;\n+\t    }\n \t}\n-\n-      /* --conversion of C* to B* is better than conversion of C* to A*, */\n-      if (distf == 0)\n+      else if (IS_AGGR_TYPE_CODE (TREE_CODE (deref_to_type1))\n+\t       && IS_AGGR_TYPE_CODE (TREE_CODE (deref_to_type2)))\n \t{\n-\t  if (distt > 0)\n-\t    return -1;\n-\t  else if (distt < 0)\n-\t    return 1;\n+\t  /* [over.ics.rank]\n+\n+\t     --If class B is derived directly or indirectly from class A\n+\t       and class C is derived directly or indirectly from B,\n+\t     \n+\t     --conversion of C* to B* is better than conversion of C* to\n+\t       A*, \n+\t     \n+\t     --conversion of B* to A* is better than conversion of C* to\n+\t       A*  */\n+\t  if (comptypes (deref_from_type1, deref_from_type2, 1))\n+\t    {\n+\t      if (is_properly_derived_from (deref_to_type1,\n+\t\t\t\t\t    deref_to_type2))\n+\t\treturn 1;\n+\t      else if (is_properly_derived_from (deref_to_type2,\n+\t\t\t\t\t\t deref_to_type1))\n+\t\treturn -1;\n+\t    }\n+\t  else if (comptypes (deref_to_type1, deref_to_type2, 1))\n+\t    {\n+\t      if (is_properly_derived_from (deref_from_type2,\n+\t\t\t\t\t    deref_from_type1))\n+\t\treturn 1;\n+\t      else if (is_properly_derived_from (deref_from_type1,\n+\t\t\t\t\t\t deref_from_type2))\n+\t\treturn -1;\n+\t    }\n \t}\n-      /* --conversion of B* to A* is better than conversion of C* to A*, */\n-      else if (distt == 0)\n+    }\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (from_type1))\n+\t   && comptypes (from_type1, from_type2, 1))\n+    {\n+      /* [over.ics.rank]\n+\t \n+\t --binding of an expression of type C to a reference of type\n+\t   B& is better than binding an expression of type C to a\n+\t   reference of type A&\n+\n+\t --conversion of C to B is better than conversion of C to A,  */\n+      if (is_properly_derived_from (from_type1, to_type1)\n+\t  && is_properly_derived_from (from_type1, to_type2))\n \t{\n-\t  if (distf > 0)\n+\t  if (is_properly_derived_from (to_type1, to_type2))\n \t    return 1;\n-\t  else if (distf < 0)\n+\t  else if (is_properly_derived_from (to_type2, to_type1))\n \t    return -1;\n \t}\n     }\n-  else if (TREE_CODE (TREE_TYPE (main1)) == POINTER_TYPE\n-\t   || TYPE_PTRMEMFUNC_P (TREE_TYPE (main1)))\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (to_type1))\n+\t   && comptypes (to_type1, to_type2, 1))\n     {\n-      if (TREE_TYPE (main1) == TREE_TYPE (main2))\n-\treturn compare_qual (ics1, ics2);\n-\n-#if 0 /* This is now handled by making identity better than anything else.  */\n-      /* existing practice, not WP-endorsed: const char * -> const char *\n-\t is better than char * -> const char *.  (jason 6/29/96) */\n-      if (TREE_TYPE (ics1) == TREE_TYPE (ics2))\n-\treturn -compare_qual (main1, main2);\n-#endif\n+      /* [over.ics.rank]\n+\n+\t --binding of an expression of type B to a reference of type\n+\t   A& is better than binding an expression of type C to a\n+\t   reference of type A&, \n+\n+\t --onversion of B to A is better than conversion of C to A  */\n+      if (is_properly_derived_from (from_type1, to_type1)\n+\t  && is_properly_derived_from (from_type2, to_type1))\n+\t{\n+\t  if (is_properly_derived_from (from_type2, from_type1))\n+\t    return 1;\n+\t  else if (is_properly_derived_from (from_type1, from_type2))\n+\t    return -1;\n+\t}\n     }\n \n+  /* [over.ics.rank]\n+\n+     --S1 and S2 differ only in their qualification conversion and  yield\n+       similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-\n+       qualification signature of type T1 is a proper subset of  the  cv-\n+       qualification signature of type T2  */\n+  if (TREE_CODE (ics1) == QUAL_CONV \n+      && TREE_CODE (ics2) == QUAL_CONV\n+      && comptypes (from_type1, from_type2, 1))\n+    return comp_cv_qual_signature (to_type1, to_type2);\n+\n+  /* [over.ics.rank]\n+     \n+     --S1 and S2 are reference bindings (_dcl.init.ref_), and the\n+     types to which the references refer are the same type except for\n+     top-level cv-qualifiers, and the type to which the reference\n+     initialized by S2 refers is more cv-qualified than the type to\n+     which the reference initialized by S1 refers */\n+      \n+  if (ref_binding1 && ref_binding2\n+      && comptypes (TYPE_MAIN_VARIANT (to_type1),\n+\t\t    TYPE_MAIN_VARIANT (to_type2), 1))\n+    return comp_cv_qualification (reference_type2, reference_type1);\n+\n+  /* Neither conversion sequence is better than the other.  */\n   return 0;\n }\n "}, {"sha": "8679f58052a21a7461d7e27684684eb734da44c3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -1362,6 +1362,11 @@ extern int flag_new_for_scope;\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n #define TYPE_PTRMEMFUNC_FN_TYPE(NODE) (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (NODE)))))))\n+\n+/* Returns `A' for a type like `int (A::*)(double)' */\n+#define TYPE_PTRMEMFUNC_OBJECT_TYPE(NODE) \\\n+  TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (NODE)))\n+\n /* These are use to manipulate the canonical RECORD_TYPE from the\n    hashed POINTER_TYPE, and can only be used on the POINTER_TYPE.  */\n #define TYPE_GET_PTRMEMFUNC_TYPE(NODE) ((tree)TYPE_LANG_SPECIFIC(NODE))\n@@ -2770,6 +2775,8 @@ extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n extern int compparms\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n+extern int comp_cv_qualification                PROTO((tree, tree));\n+extern int comp_cv_qual_signature               PROTO((tree, tree));\n extern int self_promoting_args_p\t\tPROTO((tree));\n extern tree unsigned_type\t\t\tPROTO((tree));\n extern tree signed_type\t\t\t\tPROTO((tree));"}, {"sha": "de5c3b34f43931c202ae3658c5b5fbcaac0de207", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 71, "deletions": 11, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -1048,6 +1048,46 @@ comp_target_types (ttl, ttr, nptrs)\n   return 0;\n }\n \n+/* Returns 1 if TYPE1 is more cv-qualified than TYPE2, -1 if TYPE2 is\n+   more cv-qualified that TYPE1, and 0 otherwise.  */\n+\n+int\n+comp_cv_qualification (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  if (TYPE_READONLY (type1) == TYPE_READONLY (type2)\n+      && TYPE_VOLATILE (type1) == TYPE_VOLATILE (type2))\n+    return 0;\n+\n+  if (TYPE_READONLY (type1) >= TYPE_READONLY (type2)\n+      && TYPE_VOLATILE (type1) >= TYPE_VOLATILE (type2))\n+    return 1;\n+\n+  if (TYPE_READONLY (type2) >= TYPE_READONLY (type1)\n+      && TYPE_VOLATILE (type2) >= TYPE_VOLATILE (type1))\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Returns 1 if the cv-qualification signature of TYPE1 is a proper\n+   subset of the cv-qualification signature of TYPE2, and the types\n+   are similar.  Returns -1 if the other way 'round, and 0 otherwise.  */\n+\n+int\n+comp_cv_qual_signature (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  if (comp_ptr_ttypes_real (type2, type1, -1))\n+    return 1;\n+  else if (comp_ptr_ttypes_real (type1, type2, -1))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n /* If two types share a common base type, return that basetype.\n    If there is not a unique most-derived base type, this function\n    returns ERROR_MARK_NODE.  */\n@@ -7409,14 +7449,21 @@ c_expand_start_case (exp)\n   return exp;\n }\n \n-/* CONSTP remembers whether or not all the intervening pointers in the `to'\n-   type have been const.  */\n+/* Returns non-zero if the pointer-type FROM can be converted to the\n+   pointer-type TO via a qualification conversion.  If CONSTP is -1,\n+   then we return non-zero if the pointers are similar, and the\n+   cv-qualification signature of FROM is a proper subset of that of TO.\n+\n+   If CONSTP is positive, then all outer pointers have been\n+   const-qualified.  */\n \n static int\n comp_ptr_ttypes_real (to, from, constp)\n      tree to, from;\n      int constp;\n {\n+  int to_more_cv_qualified = 0;\n+\n   for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n     {\n       if (TREE_CODE (to) != TREE_CODE (from))\n@@ -7431,19 +7478,32 @@ comp_ptr_ttypes_real (to, from, constp)\n \t so the usual checks are not appropriate.  */\n       if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n \t{\n-\t  if (TYPE_READONLY (from) > TYPE_READONLY (to)\n-\t      || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n-\t    return 0;\n+\t  switch (comp_cv_qualification (from, to))\n+\t    {\n+\t    case 1:\n+\t      /* FROM is more cv-qualified than TO.  */\n+\t      return 0;\n \n-\t  if (! constp\n-\t      && (TYPE_READONLY (to) > TYPE_READONLY (from)\n-\t\t  || TYPE_VOLATILE (to) > TYPE_READONLY (from)))\n-\t    return 0;\n-\t  constp &= TYPE_READONLY (to);\n+\t    case -1:\n+\t      /* TO is more cv-qualified than FROM.  */\n+\t      if (constp == 0)\n+\t\treturn 0;\n+\t      else \n+\t\t++to_more_cv_qualified;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  if (constp > 0)\n+\t    constp &= TYPE_READONLY (to);\n \t}\n \n       if (TREE_CODE (to) != POINTER_TYPE)\n-\treturn comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1);\n+\treturn \n+\t  comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1)\n+\t  && (constp >= 0 || to_more_cv_qualified);\n     }\n }\n "}, {"sha": "fc1d5c09d614f9dac5040684c15f2c529a2b0690", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload3.C?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -0,0 +1,16 @@\n+// Build don't run:\n+\n+void f(const int *);\n+void f(int *) {}\n+\n+void f2(const volatile int *);\n+void f2(volatile int *) {}\n+\n+int i;\n+\n+int main()\n+{\n+  f(&i);\n+  f2(&i);\n+}\n+          "}, {"sha": "22478531b95f69c2f29e1bf3ecf02410b8c55c1e", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload4.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload4.C?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -0,0 +1,10 @@\n+// Build don't run:\n+\n+void f(int* const volatile * const * const*);\n+void f(int* const * const * const*) {}\n+\n+int main()\n+{\n+  int*** ip;\n+  f(&ip);\n+}"}, {"sha": "5f5e11f9dd1ef621b77fd5f3355f057b26f6c123", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceab47eb37ec0cc015b9a909940cc69fda69c043/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload5.C?ref=ceab47eb37ec0cc015b9a909940cc69fda69c043", "patch": "@@ -0,0 +1,22 @@\n+// Build don't run:\n+\n+struct S {};\n+\n+struct T : public S {};\n+\n+struct U : public T {};\n+\n+void f(int T::*) {}\n+void f(int U::*);\n+\n+void g(void (T::*)(int)) {}\n+void g(void (U::*)(int));\n+\n+int main()\n+{\n+  int S::*ip;\n+  void (S::*fp)(int);\n+\n+  f(ip);\n+  g(fp);\n+}"}]}