{"sha": "8004841847ed40f95b693fcaf390a256b3224b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwNDg0MTg0N2VkNDBmOTViNjkzZmNhZjM5MGEyNTZiMzIyNGI1Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-07T22:21:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-07T22:21:30Z"}, "message": "cp-tree.h (begin_new_placement): Remove.\n\n\t* cp-tree.h (begin_new_placement): Remove.\n\t(finish_new_placement): Likewise.\n\t* class.c (finish_struct_1): Don't suspend_momentary or\n\tresume_momentary.\n\t* decl.c (grokdeclarator): Likewise.\n\t(maybe_build_cleanup_1): Likewise.\n\t* except.c (push_eh_cleanup): Likewise.\n\t(build_terminate_handler): Likewise.\n\t* init.c (build_new_1): Likewise.\n\t* parse.y (parse_decl): Change prototype.\n\t(initdecls, notype_initdecls, initdcl): Don't return int.\n\t(initdcl0, notype_initdcl0, initdcl0_innards): Likewise.\n\t(.begin_new_placement): Remove.\n\t(.finish_new_placement): Likewise.\n\t(nonmomentary_expr): Likewise.\n\t(suspend_mom): Likewise.\n\t(condition): Don't suspend_momentary, resume_momentary, or keep\n\ttrack of need to resume.\n\t(unary_expr): Likewise.\n\t(new_placement): Likewise.\n\t(decl): Likewise.\n\t(structsp): Likewise.\n\t(new_type_id): Likewise.\n\t(maybe_parmlist): Likewise.\n\t(direct_after_type_declaration): Likewise.\n\t(direct_new_declarator): Likewise.\n\t(direct_abstract_declaration): Likewise.\n\t* parse.c: Regenerated.\n\t* pt.c (tsubst_expr): Don't suspend_momentary or resume_momentary.\n\t* semantics.c (begin_new_placement): Remove.\n\t(finish_new_placement): Likewise.\n\nFrom-SVN: r30443", "tree": {"sha": "5169d7c628f1f5ce200375b0e83b397e601d764d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5169d7c628f1f5ce200375b0e83b397e601d764d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8004841847ed40f95b693fcaf390a256b3224b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8004841847ed40f95b693fcaf390a256b3224b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8004841847ed40f95b693fcaf390a256b3224b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8004841847ed40f95b693fcaf390a256b3224b5b/comments", "author": null, "committer": null, "parents": [{"sha": "1aecd750bbe6d98ff7fa31f2462a912215afeb04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aecd750bbe6d98ff7fa31f2462a912215afeb04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aecd750bbe6d98ff7fa31f2462a912215afeb04"}], "stats": {"total": 9262, "additions": 4586, "deletions": 4676}, "files": [{"sha": "59fc610f804cf051bbccff8cd6c1bd1e894005fe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -1,3 +1,37 @@\n+1999-11-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (begin_new_placement): Remove.\n+\t(finish_new_placement): Likewise.\n+\t* class.c (finish_struct_1): Don't suspend_momentary or\n+\tresume_momentary.\n+\t* decl.c (grokdeclarator): Likewise.\n+\t(maybe_build_cleanup_1): Likewise.\n+\t* except.c (push_eh_cleanup): Likewise.\n+\t(build_terminate_handler): Likewise.\n+\t* init.c (build_new_1): Likewise.\n+\t* parse.y (parse_decl): Change prototype.\n+\t(initdecls, notype_initdecls, initdcl): Don't return int.\n+\t(initdcl0, notype_initdcl0, initdcl0_innards): Likewise.\n+\t(.begin_new_placement): Remove.\n+\t(.finish_new_placement): Likewise.\n+\t(nonmomentary_expr): Likewise.\n+\t(suspend_mom): Likewise.\n+\t(condition): Don't suspend_momentary, resume_momentary, or keep\n+\ttrack of need to resume.\n+\t(unary_expr): Likewise.\n+\t(new_placement): Likewise.\n+\t(decl): Likewise.\n+\t(structsp): Likewise.\n+\t(new_type_id): Likewise.\n+\t(maybe_parmlist): Likewise.\n+\t(direct_after_type_declaration): Likewise.\n+\t(direct_new_declarator): Likewise.\n+\t(direct_abstract_declaration): Likewise.\n+\t* parse.c: Regenerated.\n+\t* pt.c (tsubst_expr): Don't suspend_momentary or resume_momentary.\n+\t* semantics.c (begin_new_placement): Remove.\n+\t(finish_new_placement): Likewise.\n+\t\n 1999-11-05  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* cp-tree.h (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK): New macro."}, {"sha": "a1ac9cd6755b283c908a372fb94c48edd331174c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -3377,7 +3377,6 @@ void\n finish_struct_1 (t)\n      tree t;\n {\n-  int old;\n   tree fields = TYPE_FIELDS (t);\n   tree x, last_x, method_vec;\n   int has_virtual;\n@@ -3427,8 +3426,6 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n-  old = suspend_momentary ();\n-\n   /* Install struct as DECL_FIELD_CONTEXT of each field decl.\n      Also process specified field sizes.\n      Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.\n@@ -4183,8 +4180,6 @@ finish_struct_1 (t)\n     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);\n #endif\n \n-  resume_momentary (old);\n-\n   if (warn_overloaded_virtual)\n     warn_hidden (t);\n "}, {"sha": "d362b41fc370ed0f537179020e2a3b75692fe7e8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -3894,8 +3894,6 @@ extern tree finish_qualified_call_expr          PROTO ((tree, tree));\n extern tree finish_label_address_expr           PROTO((tree));\n extern tree finish_unary_op_expr                PROTO((enum tree_code, tree));\n extern tree finish_id_expr                      PROTO((tree));\n-extern int  begin_new_placement                 PROTO((void));\n-extern tree finish_new_placement                PROTO((tree, int));\n extern int begin_function_definition            PROTO((tree, tree));\n extern tree begin_constructor_declarator        PROTO((tree, tree));\n extern tree finish_declarator                   PROTO((tree, tree, tree, tree, int));"}, {"sha": "71c30fa45dce2c73f4aaac169497cb2f822dcf42", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -9845,13 +9845,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    if (size)\n \t      {\n-\t\t/* Must suspend_momentary here because the index\n-\t\t   type may need to live until the end of the function.\n-\t\t   For example, it is used in the declaration of a\n-\t\t   variable which requires destructing at the end of\n-\t\t   the function; then build_vec_delete will need this\n-\t\t   value.  */\n-\t\tint yes = suspend_momentary ();\n \t\t/* Might be a cast. */\n \t\tif (TREE_CODE (size) == NOP_EXPR\n \t\t    && TREE_TYPE (size) == TREE_TYPE (TREE_OPERAND (size, 0)))\n@@ -9934,11 +9927,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  }\n \n \t\titype = build_index_type (itype);\n-\n-\t      dont_grok_size:\n-\t\tresume_momentary (yes);\n \t      }\n \n+\t  dont_grok_size:\n \t    type = build_cplus_array_type (type, itype);\n \t    ctype = NULL_TREE;\n \t  }\n@@ -14055,12 +14046,9 @@ maybe_build_cleanup_1 (decl, auto_delete)\n   tree type = TREE_TYPE (decl);\n   if (type != error_mark_node && TYPE_NEEDS_DESTRUCTOR (type))\n     {\n-      int temp = 0, flags = LOOKUP_NORMAL|LOOKUP_DESTRUCTOR;\n+      int flags = LOOKUP_NORMAL|LOOKUP_DESTRUCTOR;\n       tree rval;\n \n-      if (TREE_CODE (decl) != PARM_DECL)\n-\ttemp = suspend_momentary ();\n-\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \trval = decl;\n       else\n@@ -14081,9 +14069,6 @@ maybe_build_cleanup_1 (decl, auto_delete)\n \trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n \t\t\t\t\t       build_expr_list (NULL_TREE, build_vbase_delete (type, decl))));\n \n-      if (TREE_CODE (decl) != PARM_DECL)\n-\tresume_momentary (temp);\n-\n       return rval;\n     }\n   return 0;"}, {"sha": "d2ffbfe103ffd9e4c7b0044faf7a683c034ee496", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -440,12 +440,7 @@ do_pop_exception ()\n static void\n push_eh_cleanup ()\n {\n-  int yes;\n-\n-  yes = suspend_momentary ();\n-  /* All cleanups must last longer than normal.  */\n   finish_decl_cleanup (NULL_TREE, do_pop_exception ());\n-  resume_momentary (yes);\n }\n \n /* Build up a call to terminate on the function obstack, for use as an\n@@ -454,10 +449,7 @@ push_eh_cleanup ()\n static tree\n build_terminate_handler ()\n {\n-  int yes = suspend_momentary ();\n-  tree term = build_function_call (terminate_node, NULL_TREE);\n-  resume_momentary (yes);\n-  return term;\n+  return build_function_call (terminate_node, NULL_TREE);\n }\n \n /* Initialize the catch parameter DECL.  */"}, {"sha": "07c45f46cb6912aaf30ea3a912ca535a29d18bc9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -2193,20 +2193,10 @@ build_new_1 (exp)\n     }\n   else\n     {\n-      int susp = 0;\n-\n-      if (flag_exceptions)\n-\t/* We will use RVAL when generating an exception handler for\n-\t   this new-expression, so we must save it.  */\n-\tsusp = suspend_momentary ();\n-\n       rval = build_op_new_call\n \t(code, true_type, tree_cons (NULL_TREE, size, placement),\n \t LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL));\n       rval = cp_convert (build_pointer_type (true_type), rval);\n-\n-      if (flag_exceptions)\n-\tresume_momentary (susp);\n     }\n \n   /*        unless an allocation function is declared with an empty  excep-\n@@ -2369,9 +2359,6 @@ build_new_1 (exp)\n \t  tree cleanup, fn = NULL_TREE;\n \t  int flags = LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL);\n \n-\t  /* All cleanups must last longer than normal.  */\n-\t  int yes = suspend_momentary ();\n-\n \t  /* The Standard is unclear here, but the right thing to do\n              is to use the same method for finding deallocation\n              functions that we use for finding allocation functions.  */\n@@ -2384,8 +2371,6 @@ build_new_1 (exp)\n \n \t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags, fn);\n \n-\t  resume_momentary (yes);\n-\n \t  /* Ack!  First we allocate the memory.  Then we set our sentry\n \t     variable to true, and expand a cleanup that deletes the memory\n \t     if sentry is true.  Then we run the constructor and store the\n@@ -2398,11 +2383,9 @@ build_new_1 (exp)\n \t      begin = get_target_expr (boolean_true_node);\n \t      sentry = TREE_OPERAND (begin, 0);\n \n-\t      yes = suspend_momentary ();\n \t      TREE_OPERAND (begin, 2)\n \t\t= build (COND_EXPR, void_type_node, sentry,\n \t\t\t cleanup, void_zero_node);\n-\t      resume_momentary (yes);\n \n \t      rval = get_target_expr (rval);\n "}, {"sha": "97c4ee9f3b05fa8b5e5e2ab088c3d8eb6716ffd5", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4502, "deletions": 4501, "changes": 9003, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b"}, {"sha": "a988ef365f48f2fc6d5d89be6d16b2ace5ca5fdf", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 47, "deletions": 97, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -63,7 +63,7 @@ extern int end_of_file;\n static const char *cond_stmt_keyword;\n \n static tree empty_parms PROTO((void));\n-static int parse_decl PROTO((tree, tree, tree, int, tree *));\n+static void parse_decl PROTO((tree, tree, tree, int, tree *));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n@@ -199,7 +199,6 @@ empty_parms ()\n %type <ttype> reserved_typespecquals\n %type <ttype> declmods \n %type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier\n-%type <itype> initdecls notype_initdecls initdcl\t/* C++ modification */\n %type <ttype> init initlist maybeasm maybe_init defarg defarg1\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n@@ -257,10 +256,10 @@ empty_parms ()\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> operator_name\n %type <ttype> object aggr\n-%type <itype> new delete .begin_new_placement\n+%type <itype> new delete\n /* %type <ttype> primary_no_id */\n-%type <ttype> nonmomentary_expr maybe_parmlist\n-%type <itype> initdcl0 notype_initdcl0 member_init_list initdcl0_innards\n+%type <ttype> maybe_parmlist\n+%type <itype> member_init_list\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm template_template_parm\n %type <code>  template_close_bracket\n@@ -316,16 +315,14 @@ static tree current_enum_type;\n extern void yyprint\t\t\tPROTO((FILE *, int, YYSTYPE));\n extern tree combine_strings\t\tPROTO((tree));\n \n-static int\n+static void\n parse_decl (declarator, specs_attrs, attributes, initialized, decl)\n   tree declarator;\n   tree specs_attrs;\n   tree attributes;\n   int initialized;\n   tree* decl;\n {\n-  int  sm;\n-\n   split_specs_attrs (specs_attrs, &current_declspecs, &prefix_attributes);\n   if (current_declspecs\n       && TREE_CODE (current_declspecs) != TREE_LIST)\n@@ -337,10 +334,8 @@ parse_decl (declarator, specs_attrs, attributes, initialized, decl)\n \t\t\t\t\t  current_declspecs);\n       used_extern_spec = 1;\n     }\n-  sm = suspend_momentary ();\n   *decl = start_decl (declarator, current_declspecs, initialized,\n \t\t      attributes, prefix_attributes);\n-  return sm;\n }\n \n void\n@@ -1033,14 +1028,12 @@ condition:\n \t\t    }\n \t\t  }\n \t\t  current_declspecs = $1.t;\n-\t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1,\n \t\t\t\t\t  $4, /*prefix_attributes*/ NULL_TREE);\n \t\t}\n \t  init\n \t\t{ \n \t\t  cp_finish_decl ($<ttype>6, $7, $4, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  resume_momentary ($<itype>5);\n \t\t  $$ = convert_from_reference ($<ttype>6); \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n \t\t    cp_error (\"definition of array `%#D' in condition\", $$); \n@@ -1128,32 +1121,20 @@ unary_expr:\n \t| new new_placement new_type_id new_initializer\n \t\t{ $$ = build_new ($2, $3.t, $4, $1); \n \t\t  check_for_new_type (\"new\", $3); }\n-        /* The .begin_new_placement in the following rules is\n-\t   necessary to avoid shift/reduce conflicts that lead to\n-\t   mis-parsing some expressions.  Of course, these constructs\n-\t   are not really new-placement and it is bogus to call\n-\t   begin_new_placement.  But, the parser cannot always tell at this\n-\t   point whether the next thing is an expression or a type-id,\n-\t   so there is nothing we can do.  Fortunately,\n-\t   begin_new_placement does nothing harmful.  When we rewrite\n-\t   the parser, this lossage should be removed, of course.  */\n-\t| new '(' .begin_new_placement type_id .finish_new_placement\n+\t| new '(' type_id ')'\n             %prec EMPTY\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($4.t),\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t),\n \t\t\t\t  NULL_TREE, $1); \n+\t\t  check_for_new_type (\"new\", $3); }\n+\t| new '(' type_id ')' new_initializer\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); \n+\t\t  check_for_new_type (\"new\", $3); }\n+\t| new new_placement '(' type_id ')' %prec EMPTY\n+\t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); \n \t\t  check_for_new_type (\"new\", $4); }\n-\t| new '(' .begin_new_placement type_id .finish_new_placement\n-            new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($4.t), $6, $1); \n+\t| new new_placement '(' type_id ')' new_initializer\n+\t\t{ $$ = build_new ($2, groktypename($4.t), $6, $1); \n \t\t  check_for_new_type (\"new\", $4); }\n-\t| new new_placement '(' .begin_new_placement type_id\n-\t    .finish_new_placement   %prec EMPTY\n-\t\t{ $$ = build_new ($2, groktypename($5.t), NULL_TREE, $1); \n-\t\t  check_for_new_type (\"new\", $5); }\n-\t| new new_placement '(' .begin_new_placement type_id\n-\t    .finish_new_placement  new_initializer\n-\t\t{ $$ = build_new ($2, groktypename($5.t), $7, $1); \n-\t\t  check_for_new_type (\"new\", $5); }\n \n \t| delete cast_expr  %prec UNARY\n \t\t{ $$ = delete_sanity ($2, NULL_TREE, 0, $1); }\n@@ -1174,24 +1155,12 @@ unary_expr:\n \t\t  check_for_new_type (\"__builtin_va_arg\", $5); }\n \t;\n \n-        /* Note this rule is not suitable for use in new_placement\n-\t   since it uses NULL_TREE as the argument to\n-\t   finish_new_placement.  This rule serves only to avoid\n-\t   reduce/reduce conflicts in unary_expr.  See the comments\n-\t   there on the use of begin/finish_new_placement.  */\n-.finish_new_placement:\n-\t  ')'\n-                { finish_new_placement (NULL_TREE, $<itype>-1); }\n-\n-.begin_new_placement:\n-                { $$ = begin_new_placement (); }\n-\n new_placement:\n-\t  '(' .begin_new_placement nonnull_exprlist ')'\n-                { $$ = finish_new_placement ($3, $2); }\n-\t| '{' .begin_new_placement nonnull_exprlist '}'\n+\t  '(' nonnull_exprlist ')'\n+                { $$ = $2; }\n+\t| '{' nonnull_exprlist '}'\n                 { cp_pedwarn (\"old style placement syntax, use () instead\");\n-\t\t  $$ = finish_new_placement ($3, $2); }\n+\t\t  $$ = $2; }\n \t;\n \n new_initializer:\n@@ -1638,17 +1607,15 @@ object:\n decl:\n \t  typespec initdecls ';'\n \t\t{\n-\t\t  resume_momentary ($2);\n \t\t  if ($1.t && IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n \t\t    note_got_semicolon ($1.t);\n \t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n-\t\t  resume_momentary ($2);\n \t\t  note_list_got_semicolon ($1.t);\n \t\t}\n \t| declmods notype_initdecls ';'\n-\t\t{ resume_momentary ($2); }\n+                {}\n \t| typed_declspecs ';'\n \t\t{\n \t\t  shadow_tag ($1.t);\n@@ -1915,27 +1882,26 @@ initdcl:\n \t   we need that reduce so we prefer fn.def1 when appropriate.  */\n initdcl0_innards:\n \t  maybe_attribute '='\n-\t\t{ $<itype>2 = parse_decl ($<ttype>-1, $<ttype>-2, \n-\t\t\t\t\t   $1, 1, &$<ttype>$); }\n+\t\t{ parse_decl ($<ttype>-1, $<ttype>-2, $1, 1, &$<ttype>$); }\n           /* Note how the declaration of the variable is in effect\n \t     while its init is parsed! */ \n \t  init\n \t\t{ cp_finish_decl ($<ttype>3, $4, $<ttype>0, 1,\n-\t\t\t\t  LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>2; }\n+\t\t\t\t  LOOKUP_ONLYCONVERTING); }\n \t| maybe_attribute\n \t\t{ tree d;\n-\t\t  $$ = parse_decl ($<ttype>-1, $<ttype>-2, $1, 0, &d);\n+\t\t  parse_decl ($<ttype>-1, $<ttype>-2, $1, 0, &d);\n \t\t  cp_finish_decl (d, NULL_TREE, $<ttype>0, 1, 0); }\n   \t;\n   \n initdcl0:\n \t  declarator maybeasm initdcl0_innards\n-            { $$ = $3; }\n-  \n+                {}\n+\t;\n+\n notype_initdcl0:\n           notype_declarator maybeasm initdcl0_innards\n-            { $$ = $3; }\n+                {}\n         ;\n   \n nomods_initdcl0:\n@@ -2097,26 +2063,22 @@ pending_defargs:\n \n structsp:\n \t  ENUM identifier '{'\n-\t\t{ $<itype>3 = suspend_momentary ();\n-\t\t  $<ttype>$ = current_enum_type;\n+\t\t{ $<ttype>$ = current_enum_type;\n \t\t  current_enum_type = start_enum ($2); }\n \t  enumlist_opt '}'\n \t\t{ TYPE_VALUES (current_enum_type) = $5;\n \t\t  $$.t = finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n \t\t  current_enum_type = $<ttype>4;\n-\t\t  resume_momentary ((int) $<itype>3);\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{'\n-\t\t{ $<itype>2 = suspend_momentary ();\n-\t\t  $<ttype>$ = current_enum_type;\n+\t\t{ $<ttype>$ = current_enum_type;\n \t\t  current_enum_type = start_enum (make_anon_name ()); }\n \t  enumlist_opt '}'\n                 { TYPE_VALUES (current_enum_type) = $4;\n \t\t  $$.t = finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n \t\t  current_enum_type = $<ttype>3;\n-\t\t  resume_momentary ((int) $<itype>1);\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM identifier\n \t\t{ $$.t = xref_tag (enum_type_node, $2, 1); \n@@ -2649,16 +2611,14 @@ new_type_id:\n \t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t/* GNU extension to allow arrays of arbitrary types with\n-\t   non-constant dimension.  For the use of begin_new_placement\n-\t   here, see the comments in unary_expr above.  */\n-\t| '(' .begin_new_placement type_id .finish_new_placement\n-\t      '[' expr ']'\n+\t   non-constant dimension.  */\n+\t| '(' type_id ')' '[' expr ']'\n \t\t{\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n-\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($3.t), $6);\n-\t\t  $$.t = build_decl_list (TREE_PURPOSE ($3.t), $$.t);\n-\t\t  $$.new_type_flag = $3.new_type_flag;\n+\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);\n+\t\t  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);\n+\t\t  $$.new_type_flag = $2.new_type_flag;\n \t\t}\n \t;\n \n@@ -2681,26 +2641,16 @@ nonempty_cv_qualifiers:\n /* These rules must follow the rules for function declarations\n    and component declarations.  That way, longer rules are preferred.  */\n \n-suspend_mom:\n-\t  /* empty */\n-\t\t{ $<itype>$ = suspend_momentary (); } \n-\n-/* An expression which will not live on the momentary obstack.  */\n-nonmomentary_expr:\n-\t  suspend_mom expr\n-\t\t{ resume_momentary ((int) $<itype>1); $$ = $2; }\n-\t;\n-\n /* An expression which will not live on the momentary obstack.  */\n maybe_parmlist:\n-\t  suspend_mom '(' nonnull_exprlist ')'\n-\t\t{ resume_momentary ((int) $<itype>1); $$ = $3; }\n-\t| suspend_mom '(' parmlist ')'\n-\t\t{ resume_momentary ((int) $<itype>1); $$ = $3; }\n-\t| suspend_mom LEFT_RIGHT\n-\t\t{ resume_momentary ((int) $<itype>1); $$ = empty_parms (); }\n-\t| suspend_mom '(' error ')'\n-\t\t{ resume_momentary ((int) $<itype>1); $$ = NULL_TREE; }\n+\t  '(' nonnull_exprlist ')'\n+\t\t{ $$ = $2; }\n+\t| '(' parmlist ')'\n+\t\t{ $$ = $2; }\n+\t| LEFT_RIGHT\n+\t\t{ $$ = empty_parms (); }\n+\t| '(' error ')'\n+\t\t{ $$ = NULL_TREE; }\n \t;\n \n /* A declarator that is allowed only after an explicit typespec.  */\n@@ -2735,7 +2685,7 @@ after_type_declarator:\n direct_after_type_declarator:\n \t  direct_after_type_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'\n \t\t{ $$ = make_call_declarator ($$, $2, $3, $4); }\n-\t| direct_after_type_declarator '[' nonmomentary_expr ']'\n+\t| direct_after_type_declarator '[' expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_after_type_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n@@ -2831,7 +2781,7 @@ complex_direct_notype_declarator:\n \t\t{ $$ = make_call_declarator ($$, $2, $3, $4); }\n \t| '(' complex_notype_declarator ')'\n \t\t{ $$ = $2; }\n-\t| direct_notype_declarator '[' nonmomentary_expr ']'\n+\t| direct_notype_declarator '[' expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_notype_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n@@ -3074,7 +3024,7 @@ new_declarator:\n direct_new_declarator:\n \t  '[' expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }\n-\t| direct_new_declarator '[' nonmomentary_expr ']'\n+\t| direct_new_declarator '[' expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t;\n \n@@ -3126,7 +3076,7 @@ direct_abstract_declarator:\n \t\t{ $$ = make_call_declarator ($$, $3, $5, $6); }\n \t| direct_abstract_declarator LEFT_RIGHT cv_qualifiers exception_specification_opt  %prec '.'\n \t\t{ $$ = make_call_declarator ($$, empty_parms (), $3, $4); }\n-\t| direct_abstract_declarator '[' nonmomentary_expr ']'  %prec '.'\n+\t| direct_abstract_declarator '[' expr ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_abstract_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n@@ -3136,7 +3086,7 @@ direct_abstract_declarator:\n \t\t{ set_quals_and_spec ($$, $2, $3); }\n \t| fcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'\n \t\t{ set_quals_and_spec ($$, $2, $3); }\n-\t| '[' nonmomentary_expr ']'  %prec '.'\n+\t| '[' expr ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }\n \t| '[' ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, NULL_TREE); }"}, {"sha": "2c4fd3eb64198ef8ae07603af3fbf5df39fe2b5e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -7097,7 +7097,6 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case DECL_STMT:\n       {\n-\tint i = suspend_momentary ();\n \ttree decl;\n \ttree init;\n \n@@ -7122,7 +7121,6 @@ tsubst_expr (t, args, complain, in_decl)\n \t    maybe_push_decl (decl);\n \t    cp_finish_decl (decl, init, NULL_TREE, 0, 0);\n \t  }\n-\tresume_momentary (i);\n \treturn decl;\n       }\n "}, {"sha": "f9e6dd172115b1e6c4205413ddbb65adc9101b65", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8004841847ed40f95b693fcaf390a256b3224b5b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8004841847ed40f95b693fcaf390a256b3224b5b", "patch": "@@ -1619,32 +1619,6 @@ finish_id_expr (expr)\n   return expr;\n }\n \n-/* Begin a new-placement.  */\n-\n-int\n-begin_new_placement ()\n-{\n-  /* The arguments to a placement new might be passed to a\n-     deallocation function, in the event that the allocation throws an\n-     exception.  Since we don't expand exception handlers until the\n-     end of a function, we must make sure the arguments stay around\n-     that long.  */\n-  return suspend_momentary ();\n-}\n-\n-/* Finish a new-placement.  The ARGS are the placement arguments.  The\n-   COOKIE is the value returned by the previous call to\n-   begin_new_placement.  */\n-\n-tree\n-finish_new_placement (args, cookie)\n-     tree args;\n-     int cookie;\n-{\n-  resume_momentary (cookie);\n-  return args;\n-}\n-\n /* Begin a function defniition declared with DECL_SPECS and\n    DECLARATOR.  Returns non-zero if the function-declaration is\n    legal.  */"}]}