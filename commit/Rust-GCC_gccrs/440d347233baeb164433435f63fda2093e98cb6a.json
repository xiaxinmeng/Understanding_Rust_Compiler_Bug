{"sha": "440d347233baeb164433435f63fda2093e98cb6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQwZDM0NzIzM2JhZWIxNjQ0MzM0MzVmNjNmZGEyMDkzZTk4Y2I2YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-10-05T09:37:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-10-05T09:37:25Z"}, "message": "re PR tree-optimization/54810 (VRP doesn't handle comparison of narrowing cast like comparison of BIT_AND_EXPR)\n\n\tPR tree-optimization/54810\n\t* tree-vrp.c (register_edge_assert_for_2): Handle\n\tNAME = (unsigned) NAME2; if (NAME cmp CST) for\n\tnarrowing casts to unsigned integral type like\n\tNAME = NAME2 & CST2; if (NAME cmp CST) where CST2\n\tis the max value of the unsigned integral type.\n\n\t* gcc.dg/tree-ssa/vrp85.c: New test.\n\nFrom-SVN: r192115", "tree": {"sha": "53aad70f269552ef0dbc7184a9b6589dc2ac08d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53aad70f269552ef0dbc7184a9b6589dc2ac08d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/440d347233baeb164433435f63fda2093e98cb6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/440d347233baeb164433435f63fda2093e98cb6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/440d347233baeb164433435f63fda2093e98cb6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/440d347233baeb164433435f63fda2093e98cb6a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e3e4fe8749caf4f90f41910458d094bc4519f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3e4fe8749caf4f90f41910458d094bc4519f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3e4fe8749caf4f90f41910458d094bc4519f69"}], "stats": {"total": 137, "additions": 106, "deletions": 31}, "files": [{"sha": "dbbe1187c1ed2e5564364da8fdb2d544d29ff347", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440d347233baeb164433435f63fda2093e98cb6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440d347233baeb164433435f63fda2093e98cb6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=440d347233baeb164433435f63fda2093e98cb6a", "patch": "@@ -1,3 +1,12 @@\n+2012-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/54810\n+\t* tree-vrp.c (register_edge_assert_for_2): Handle\n+\tNAME = (unsigned) NAME2; if (NAME cmp CST) for\n+\tnarrowing casts to unsigned integral type like\n+\tNAME = NAME2 & CST2; if (NAME cmp CST) where CST2\n+\tis the max value of the unsigned integral type.\n+\n 2012-10-04  Jeff Law  <law@redhat.com>\n \n \t* PR target/50356"}, {"sha": "84d7e86e83f3ab963fe29e4a1aaaf7036841f209", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440d347233baeb164433435f63fda2093e98cb6a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440d347233baeb164433435f63fda2093e98cb6a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=440d347233baeb164433435f63fda2093e98cb6a", "patch": "@@ -1,3 +1,8 @@\n+2012-10-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/54810\n+\t* gcc.dg/tree-ssa/vrp85.c: New test.\n+\n 2012-10-04  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* gcc.dg/ucnid-7.c: Skip on AIX."}, {"sha": "ad2b38d02c1c53b5df79e6624bdcbd85b54f3027", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp85.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440d347233baeb164433435f63fda2093e98cb6a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp85.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440d347233baeb164433435f63fda2093e98cb6a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp85.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp85.c?ref=440d347233baeb164433435f63fda2093e98cb6a", "patch": "@@ -0,0 +1,40 @@\n+/* PR tree-optimization/54810 */\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+extern void link_error (void);\n+\n+#define T(n, ntype, wtype) \\\n+void\t\t\t\t\\\n+f##n (wtype s)\t\t\t\\\n+{\t\t\t\t\\\n+  if ((ntype) s == 0)\t\t\\\n+    return;\t\t\t\\\n+  if (s == 0)\t\t\t\\\n+    link_error ();\t\t\\\n+}\n+\n+T(1, unsigned char, unsigned char)\n+T(2, unsigned char, unsigned short)\n+T(3, unsigned char, unsigned int)\n+T(4, unsigned char, unsigned long int)\n+T(5, unsigned char, unsigned long long int)\n+T(6, unsigned short int, unsigned short int)\n+T(7, unsigned short int, unsigned int)\n+T(8, unsigned short int, unsigned long int)\n+T(9, unsigned short int, unsigned long long int)\n+T(10, unsigned int, unsigned int)\n+T(11, unsigned int, unsigned long int)\n+T(12, unsigned int, unsigned long long int)\n+T(13, unsigned long int, unsigned long int)\n+T(14, unsigned long int, unsigned long long int)\n+T(15, unsigned long long int, unsigned long long int)\n+\n+int\n+main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"link_error\" \"vrp1\"} } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "de3eb2c6a98de073c181edfd3ae327937e4ca51b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/440d347233baeb164433435f63fda2093e98cb6a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/440d347233baeb164433435f63fda2093e98cb6a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=440d347233baeb164433435f63fda2093e98cb6a", "patch": "@@ -4712,6 +4712,11 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n       tree val2 = NULL_TREE;\n       double_int mask = double_int_zero;\n       unsigned int prec = TYPE_PRECISION (TREE_TYPE (val));\n+      unsigned int nprec = prec;\n+      enum tree_code rhs_code = ERROR_MARK;\n+\n+      if (is_gimple_assign (def_stmt))\n+\trhs_code = gimple_assign_rhs_code (def_stmt);\n \n       /* Add asserts for NAME cmp CST and NAME being defined\n \t as NAME = (int) NAME2.  */\n@@ -4721,7 +4726,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t  && gimple_assign_cast_p (def_stmt))\n \t{\n \t  name2 = gimple_assign_rhs1 (def_stmt);\n-\t  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n+\t  if (CONVERT_EXPR_CODE_P (rhs_code)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t      && TYPE_UNSIGNED (TREE_TYPE (name2))\n \t      && prec == TYPE_PRECISION (TREE_TYPE (name2))\n@@ -4767,8 +4772,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t NAME = NAME2 >> CST2.\n \n \t Extract CST2 from the right shift.  */\n-      if (is_gimple_assign (def_stmt)\n-\t  && gimple_assign_rhs_code (def_stmt) == RSHIFT_EXPR)\n+      if (rhs_code == RSHIFT_EXPR)\n \t{\n \t  name2 = gimple_assign_rhs1 (def_stmt);\n \t  cst2 = gimple_assign_rhs2 (def_stmt);\n@@ -4840,21 +4844,37 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n       /* Add asserts for NAME cmp CST and NAME being defined as\n \t NAME = NAME2 & CST2.\n \n-\t Extract CST2 from the and.  */\n+\t Extract CST2 from the and.\n+\n+\t Also handle\n+\t NAME = (unsigned) NAME2;\n+\t casts where NAME's type is unsigned and has smaller precision\n+\t than NAME2's type as if it was NAME = NAME2 & MASK.  */\n       names[0] = NULL_TREE;\n       names[1] = NULL_TREE;\n       cst2 = NULL_TREE;\n-      if (is_gimple_assign (def_stmt)\n-\t  && gimple_assign_rhs_code (def_stmt) == BIT_AND_EXPR)\n+      if (rhs_code == BIT_AND_EXPR\n+\t  || (CONVERT_EXPR_CODE_P (rhs_code)\n+\t      && TREE_CODE (TREE_TYPE (val)) == INTEGER_TYPE\n+\t      && TYPE_UNSIGNED (TREE_TYPE (val))\n+\t      && TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))\n+\t\t > prec\n+\t      && !retval))\n \t{\n \t  name2 = gimple_assign_rhs1 (def_stmt);\n-\t  cst2 = gimple_assign_rhs2 (def_stmt);\n+\t  if (rhs_code == BIT_AND_EXPR)\n+\t    cst2 = gimple_assign_rhs2 (def_stmt);\n+\t  else\n+\t    {\n+\t      cst2 = TYPE_MAX_VALUE (TREE_TYPE (val));\n+\t      nprec = TYPE_PRECISION (TREE_TYPE (name2));\n+\t    }\n \t  if (TREE_CODE (name2) == SSA_NAME\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t      && TREE_CODE (cst2) == INTEGER_CST\n \t      && !integer_zerop (cst2)\n-\t      && prec <= HOST_BITS_PER_DOUBLE_INT\n-\t      && (prec > 1\n+\t      && nprec <= HOST_BITS_PER_DOUBLE_INT\n+\t      && (nprec > 1\n \t\t  || TYPE_UNSIGNED (TREE_TYPE (val))))\n \t    {\n \t      gimple def_stmt2 = SSA_NAME_DEF_STMT (name2);\n@@ -4881,20 +4901,20 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t  bool valid_p = false, valn = false, cst2n = false;\n \t  enum tree_code ccode = comp_code;\n \n-\t  valv = tree_to_double_int (val).zext (prec);\n-\t  cst2v = tree_to_double_int (cst2).zext (prec);\n+\t  valv = tree_to_double_int (val).zext (nprec);\n+\t  cst2v = tree_to_double_int (cst2).zext (nprec);\n \t  if (!TYPE_UNSIGNED (TREE_TYPE (val)))\n \t    {\n-\t      valn = valv.sext (prec).is_negative ();\n-\t      cst2n = cst2v.sext (prec).is_negative ();\n+\t      valn = valv.sext (nprec).is_negative ();\n+\t      cst2n = cst2v.sext (nprec).is_negative ();\n \t    }\n \t  /* If CST2 doesn't have most significant bit set,\n \t     but VAL is negative, we have comparison like\n \t     if ((x & 0x123) > -4) (always true).  Just give up.  */\n \t  if (!cst2n && valn)\n \t    ccode = ERROR_MARK;\n \t  if (cst2n)\n-\t    sgnbit = double_int_one.llshift (prec - 1, prec).zext (prec);\n+\t    sgnbit = double_int_one.llshift (nprec - 1, nprec).zext (nprec);\n \t  else\n \t    sgnbit = double_int_zero;\n \t  minv = valv & cst2v;\n@@ -4906,12 +4926,12 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t have folded the comparison into false) and\n \t\t maximum unsigned value is VAL | ~CST2.  */\n \t      maxv = valv | ~cst2v;\n-\t      maxv = maxv.zext (prec);\n+\t      maxv = maxv.zext (nprec);\n \t      valid_p = true;\n \t      break;\n \t    case NE_EXPR:\n \t      tem = valv | ~cst2v;\n-\t      tem = tem.zext (prec);\n+\t      tem = tem.zext (nprec);\n \t      /* If VAL is 0, handle (X & CST2) != 0 as (X & CST2) > 0U.  */\n \t      if (valv.is_zero ())\n \t\t{\n@@ -4921,16 +4941,17 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t}\n \t      /* If (VAL | ~CST2) is all ones, handle it as\n \t\t (X & CST2) < VAL.  */\n-\t      if (tem == double_int::mask (prec))\n+\t      if (tem == double_int::mask (nprec))\n \t\t{\n \t\t  cst2n = false;\n \t\t  valn = false;\n \t\t  sgnbit = double_int_zero;\n \t\t  goto lt_expr;\n \t\t}\n \t      if (!cst2n\n-\t\t  && cst2v.sext (prec).is_negative ())\n-\t\tsgnbit = double_int_one.llshift (prec - 1, prec).zext (prec);\n+\t\t  && cst2v.sext (nprec).is_negative ())\n+\t\tsgnbit\n+\t\t  = double_int_one.llshift (nprec - 1, nprec).zext (nprec);\n \t      if (!sgnbit.is_zero ())\n \t\t{\n \t\t  if (valv == sgnbit)\n@@ -4939,7 +4960,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t      valn = true;\n \t\t      goto gt_expr;\n \t\t    }\n-\t\t  if (tem == double_int::mask (prec - 1))\n+\t\t  if (tem == double_int::mask (nprec - 1))\n \t\t    {\n \t\t      cst2n = true;\n \t\t      goto lt_expr;\n@@ -4958,22 +4979,22 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t{\n \t\t  /* If (VAL & CST2) != VAL, X & CST2 can't be equal to\n \t\t     VAL.  */\n-\t\t  minv = masked_increment (valv, cst2v, sgnbit, prec);\n+\t\t  minv = masked_increment (valv, cst2v, sgnbit, nprec);\n \t\t  if (minv == valv)\n \t\t    break;\n \t\t}\n-\t      maxv = double_int::mask (prec - (cst2n ? 1 : 0));\n+\t      maxv = double_int::mask (nprec - (cst2n ? 1 : 0));\n \t      valid_p = true;\n \t      break;\n \t    case GT_EXPR:\n \t    gt_expr:\n \t      /* Find out smallest MINV where MINV > VAL\n \t\t && (MINV & CST2) == MINV, if any.  If VAL is signed and\n-\t\t CST2 has MSB set, compute it biased by 1 << (prec - 1).  */\n-\t      minv = masked_increment (valv, cst2v, sgnbit, prec);\n+\t\t CST2 has MSB set, compute it biased by 1 << (nprec - 1).  */\n+\t      minv = masked_increment (valv, cst2v, sgnbit, nprec);\n \t      if (minv == valv)\n \t\tbreak;\n-\t      maxv = double_int::mask (prec - (cst2n ? 1 : 0));\n+\t      maxv = double_int::mask (nprec - (cst2n ? 1 : 0));\n \t      valid_p = true;\n \t      break;\n \t    case LE_EXPR:\n@@ -4989,13 +5010,13 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\tmaxv = valv;\n \t      else\n \t\t{\n-\t\t  maxv = masked_increment (valv, cst2v, sgnbit, prec);\n+\t\t  maxv = masked_increment (valv, cst2v, sgnbit, nprec);\n \t\t  if (maxv == valv)\n \t\t    break;\n \t\t  maxv -= double_int_one;\n \t\t}\n \t      maxv |= ~cst2v;\n-\t      maxv = maxv.zext (prec);\n+\t      maxv = maxv.zext (nprec);\n \t      minv = sgnbit;\n \t      valid_p = true;\n \t      break;\n@@ -5017,21 +5038,21 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t}\n \t      else\n \t\t{\n-\t\t  maxv = masked_increment (valv, cst2v, sgnbit, prec);\n+\t\t  maxv = masked_increment (valv, cst2v, sgnbit, nprec);\n \t\t  if (maxv == valv)\n \t\t    break;\n \t\t}\n \t      maxv -= double_int_one;\n \t      maxv |= ~cst2v;\n-\t      maxv = maxv.zext (prec);\n+\t      maxv = maxv.zext (nprec);\n \t      minv = sgnbit;\n \t      valid_p = true;\n \t      break;\n \t    default:\n \t      break;\n \t    }\n \t  if (valid_p\n-\t      && (maxv - minv).zext (prec) != double_int::mask (prec))\n+\t      && (maxv - minv).zext (nprec) != double_int::mask (nprec))\n \t    {\n \t      tree tmp, new_val, type;\n \t      int i;\n@@ -5044,7 +5065,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t    type = TREE_TYPE (names[i]);\n \t\t    if (!TYPE_UNSIGNED (type))\n \t\t      {\n-\t\t\ttype = build_nonstandard_integer_type (prec, 1);\n+\t\t\ttype = build_nonstandard_integer_type (nprec, 1);\n \t\t\ttmp = build1 (NOP_EXPR, type, names[i]);\n \t\t      }\n \t\t    if (!minv.is_zero ())"}]}