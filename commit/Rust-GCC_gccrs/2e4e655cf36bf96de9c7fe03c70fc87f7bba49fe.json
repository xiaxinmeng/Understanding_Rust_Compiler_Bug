{"sha": "2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU0ZTY1NWNmMzZiZjk2ZGU5YzdmZTAzYzcwZmM4N2Y3YmJhNDlmZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-11-01T20:46:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-11-01T20:46:04Z"}, "message": "re PR go/67968 (go1: internal compiler error: in write_specific_type_functions, at go/gofrontend/types.cc:1812)\n\n\tPR go/67968\n    compiler: Traverse types of call expressions.\n    \n    https://gcc.gnu.org/PR67968 provides a test case that causes a gccgo\n    crash on valid code.  The compiler failed to build the hash and equality\n    functions required for a type descriptor.  The descriptor is for an\n    unnamed type that is being returned by a function imported from a\n    different package.  The unnamed type is being implicitly converted to an\n    interface type by a return statement.  The fix is to ensure that the\n    type of a call expression is always traversed.\n    \n    Test case sent out for the master testsuite as\n    https://golang.org/cl/16532 .\n\nFrom-SVN: r229642", "tree": {"sha": "54acec5a01c9df5afe8a59e27d41dcf20bdccfcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54acec5a01c9df5afe8a59e27d41dcf20bdccfcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe/comments", "author": null, "committer": null, "parents": [{"sha": "2bbee501a329d2c153ccb49fc6a5494c536277e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbee501a329d2c153ccb49fc6a5494c536277e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bbee501a329d2c153ccb49fc6a5494c536277e8"}], "stats": {"total": 12, "additions": 11, "deletions": 1}, "files": [{"sha": "e30927f6998b796a0ef25161f90843717243b743", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe", "patch": "@@ -1,4 +1,4 @@\n-1c1f226662a6c84eae83f8aaec3d4503e70be843\n+65ff1d5fb581717229e5c02796d719671a1e8628\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9037f0f2f806c4b31e8576475e20f53d8fa6c71e", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=2e4e655cf36bf96de9c7fe03c70fc87f7bba49fe", "patch": "@@ -8608,6 +8608,16 @@ Builtin_call_expression::do_export(Export* exp) const\n int\n Call_expression::do_traverse(Traverse* traverse)\n {\n+  // If we are calling a function in a different package that returns\n+  // an unnamed type, this may be the only chance we get to traverse\n+  // that type.  We don't traverse this->type_ because it may be a\n+  // Call_multiple_result_type that will just lead back here.\n+  if (this->type_ != NULL && !this->type_->is_error_type())\n+    {\n+      Function_type *fntype = this->get_function_type();\n+      if (fntype != NULL && Type::traverse(fntype, traverse) == TRAVERSE_EXIT)\n+\treturn TRAVERSE_EXIT;\n+    }\n   if (Expression::traverse(&this->fn_, traverse) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n   if (this->args_ != NULL)"}]}