{"sha": "d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRlYTQ2MjI0NWNkOWQ5NjdkY2U4MDViOGI5N2ZmZTEwZWUzMGMzZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2008-08-05T17:24:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2008-08-05T17:24:37Z"}, "message": "Makefile.in (c-cppbuiltin.o): Depend on debug.h.\n\n        * Makefile.in (c-cppbuiltin.o): Depend on debug.h.\n        * c-cppbuiltin.c (c_cpp_builtins): Define __GCC_HAVE_DWARF2_CFI_ASM.\n        * doc/cpp.texi (__GCC_HAVE_DWARF2_CFI_ASM): Document it.\n        * common.opt (fdwarf2-cfi-asm): New.\n        * configure.ac (HAVE_GAS_CFI_DIRECTIVE): New.\n        * config.in, configure: Rebuild.\n        * dwarf2asm.c (dw2_asm_output_data_raw): New.\n        (dw2_asm_output_data_uleb128_raw, dw2_asm_output_data_sleb128_raw): New.\n        (dw2_force_const_mem): Externalize.\n        * dwarf2asm.h: Update.\n        * dwarf2out.c (dwarf2out_cfi_label): If flag_dwarf2_cfi_asm, don't\n        generate a real label.\n        (output_cfi_directive): New.\n        (add_fde_cfi): If flag_dwarf2_cfi_asm, use it.\n        (output_call_frame_info): Do nothing if flag_dwarf2_cfi_asm.\n        (dwarf2out_begin_prologue): Emit .cfi_startproc, .cfi_personality,\n        and .cfi_lsda.\n        (dwarf2out_end_epilogue): Emit .cfi_endproc.\n        (output_loc_operands_raw, output_loc_sequence_raw): New.\n        (output_cfa_loc_raw): New.\n\nFrom-SVN: r138733", "tree": {"sha": "7b5f0b07219e5a80c5cc9a52c95fd7029c3149d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b5f0b07219e5a80c5cc9a52c95fd7029c3149d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/comments", "author": null, "committer": null, "parents": [{"sha": "cdaf871beb36eccc5e2d92a99ddea84060de5304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdaf871beb36eccc5e2d92a99ddea84060de5304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdaf871beb36eccc5e2d92a99ddea84060de5304"}], "stats": {"total": 529, "additions": 519, "deletions": 10}, "files": [{"sha": "7884fa833b6e96e9f2c41ee635537c9b33b58ab3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -1,3 +1,26 @@\n+2008-08-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (c-cppbuiltin.o): Depend on debug.h.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Define __GCC_HAVE_DWARF2_CFI_ASM.\n+\t* doc/cpp.texi (__GCC_HAVE_DWARF2_CFI_ASM): Document it.\n+\t* common.opt (fdwarf2-cfi-asm): New.\n+\t* configure.ac (HAVE_GAS_CFI_DIRECTIVE): New.\n+\t* config.in, configure: Rebuild.\n+\t* dwarf2asm.c (dw2_asm_output_data_raw): New.\n+\t(dw2_asm_output_data_uleb128_raw, dw2_asm_output_data_sleb128_raw): New.\n+\t(dw2_force_const_mem): Externalize.\n+\t* dwarf2asm.h: Update.\n+\t* dwarf2out.c (dwarf2out_cfi_label): If flag_dwarf2_cfi_asm, don't\n+\tgenerate a real label.\n+\t(output_cfi_directive): New.\n+\t(add_fde_cfi): If flag_dwarf2_cfi_asm, use it.\n+\t(output_call_frame_info): Do nothing if flag_dwarf2_cfi_asm.\n+\t(dwarf2out_begin_prologue): Emit .cfi_startproc, .cfi_personality,\n+\tand .cfi_lsda.\n+\t(dwarf2out_end_epilogue): Emit .cfi_endproc.\n+\t(output_loc_operands_raw, output_loc_sequence_raw): New.\n+\t(output_cfa_loc_raw): New.\n+\t\n 2008-08-05  Paul Brook  <paul@codesourcery.com>\n \n \t* doc/invoke.texi: Document new ARM -mfpu= and -mcpu= options."}, {"sha": "1c22966d9d9ca4365b711df4ca373a04200d0974", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -1870,8 +1870,9 @@ c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n \t\t$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n \n c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-\t$(TREE_H) version.h $(C_COMMON_H) $(C_PRAGMA_H) $(FLAGS_H) $(TOPLEV_H) \\\n-\toutput.h except.h $(REAL_H) $(TARGET_H) $(TM_P_H) $(BASEVER)\n+\t$(TREE_H) version.h $(C_COMMON_H) $(C_PRAGMA_H) $(FLAGS_H) \\\n+\t$(TOPLEV_H) output.h except.h $(REAL_H) $(TARGET_H) $(TM_P_H) \\\n+\t$(BASEVER) debug.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) -DBASEVER=$(BASEVER_s) \\\n \t\t$< $(OUTPUT_OPTION)\n "}, {"sha": "01f92155fd66df9d18d60474073e8d83a33ace5a", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-pragma.h\"\n #include \"output.h\"\n #include \"except.h\"\t\t/* For USING_SJLJ_EXCEPTIONS.  */\n+#include \"debug.h\"\t\t/* For dwarf2out_do_frame.  */\n #include \"toplev.h\"\n #include \"tm_p.h\"\t\t/* Target prototypes.  */\n #include \"target.h\"\n@@ -691,6 +692,11 @@ c_cpp_builtins (cpp_reader *pfile)\n     cpp_define (pfile, \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16\");\n #endif\n \n+#ifdef DWARF2_UNWIND_INFO\n+  if (flag_dwarf2_cfi_asm && dwarf2out_do_frame ())\n+    cpp_define (pfile, \"__GCC_HAVE_DWARF2_CFI_ASM\");\n+#endif\n+\n   /* Make the choice of ObjC runtime visible to source code.  */\n   if (c_dialect_objc () && flag_next_runtime)\n     cpp_define (pfile, \"__NEXT_RUNTIME__\");"}, {"sha": "02bdef255886e7a13a8cd62e6036e3faaad5054c", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -459,6 +459,10 @@ fdump-unnumbered\n Common Report Var(flag_dump_unnumbered) VarExists\n Suppress output of instruction numbers, line number notes and addresses in debugging dumps\n \n+fdwarf2-cfi-asm\n+Common Report Var(flag_dwarf2_cfi_asm) Init(HAVE_GAS_CFI_DIRECTIVE)\n+Enable CFI tables via GAS assembler directives.\n+\n fearly-inlining\n Common Report Var(flag_early_inlining) Init(1) Optimization\n Perform early inlining"}, {"sha": "47ec2ab2fe204bbed87747bcba1e752e65361800", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -821,6 +821,12 @@\n #endif\n \n \n+/* Define 0/1 if your assembler supports CFI directives. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GAS_CFI_DIRECTIVE\n+#endif\n+\n+\n /* Define if your assembler uses the new HImode fild and fist notation. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_GAS_FILDS_FISTS"}, {"sha": "d1996bb7b4bd10268de68e886a6ff18875f9db41", "filename": "gcc/configure", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -20832,6 +20832,50 @@ _ACEOF\n \n fi\n \n+# Check if we have assembler support for unwind directives.\n+echo \"$as_me:$LINENO: checking assembler for cfi directives\" >&5\n+echo $ECHO_N \"checking assembler for cfi directives... $ECHO_C\" >&6\n+if test \"${gcc_cv_as_cfi_directive+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  gcc_cv_as_cfi_directive=no\n+    if test $in_tree_gas = yes; then\n+    if test $in_tree_gas_is_elf = yes \\\n+  && test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 17 \\) \\* 1000 + 0`\n+  then gcc_cv_as_cfi_directive=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    echo '\t.text\n+\t.cfi_startproc\n+\t.cfi_offset 0, 0\n+\t.cfi_same_value 1\n+\t.cfi_def_cfa 1, 2\n+\t.cfi_escape 1, 2, 3, 4, 5\n+\t.cfi_endproc' > conftest.s\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }\n+    then\n+\tgcc_cv_as_cfi_directive=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+echo \"$as_me:$LINENO: result: $gcc_cv_as_cfi_directive\" >&5\n+echo \"${ECHO_T}$gcc_cv_as_cfi_directive\" >&6\n+\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_GAS_CFI_DIRECTIVE `if test $gcc_cv_as_cfi_directive = yes; then echo 1; else echo 0; fi`\n+_ACEOF\n+\n+\n # GAS versions up to and including 2.11.0 may mis-optimize\n # .eh_frame data.\n echo \"$as_me:$LINENO: checking assembler for eh_frame optimization\" >&5"}, {"sha": "4f7fc325330003c834f6fe5b045f6a2d26a3f52a", "filename": "gcc/configure.ac", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -2180,6 +2180,20 @@ changequote([,])dnl\n   [AC_DEFINE(HAVE_AS_LEB128, 1,\n     [Define if your assembler supports .sleb128 and .uleb128.])])\n \n+# Check if we have assembler support for unwind directives.\n+gcc_GAS_CHECK_FEATURE([cfi directives], gcc_cv_as_cfi_directive,\n+  [elf,2,17,0],,\n+[\t.text\n+\t.cfi_startproc\n+\t.cfi_offset 0, 0\n+\t.cfi_same_value 1\n+\t.cfi_def_cfa 1, 2\n+\t.cfi_escape 1, 2, 3, 4, 5\n+\t.cfi_endproc])\n+AC_DEFINE_UNQUOTED(HAVE_GAS_CFI_DIRECTIVE,\n+  [`if test $gcc_cv_as_cfi_directive = yes; then echo 1; else echo 0; fi`],\n+[Define 0/1 if your assembler supports CFI directives.])\n+\n # GAS versions up to and including 2.11.0 may mis-optimize\n # .eh_frame data.\n gcc_GAS_CHECK_FEATURE(eh_frame optimization, gcc_cv_as_eh_frame,"}, {"sha": "0eaece14d456fab27236fe7bd0678b76b1138372", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -2239,6 +2239,10 @@ If GCC cannot determine the current date, it will emit a warning message\n These macros are defined when the target processor supports atomic compare\n and swap operations on operands 1, 2, 4, 8 or 16 bytes in length, respectively.\n \n+@item __GCC_HAVE_DWARF2_CFI_ASM\n+This macro is defined when the compiler is emitting Dwarf2 CFI directives\n+to the assembler.  When this is defined, it is possible to emit those same\n+directives in inline assembly.\n @end table\n \n @node System-specific Predefined Macros"}, {"sha": "9ae94200f188e14303a98022bc530de4993bde10", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -62,6 +62,34 @@ dw2_assemble_integer (int size, rtx x)\n }\n \n \n+/* Output a value of a given size in target byte order.  */\n+\n+void\n+dw2_asm_output_data_raw (int size, unsigned HOST_WIDE_INT value)\n+{\n+  unsigned char bytes[8];\n+  int i;\n+\n+  for (i = 0; i < 8; ++i)\n+    {\n+      bytes[i] = value & 0xff;\n+      value >>= 8;\n+    }\n+\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      for (i = size - 1; i > 0; --i)\n+\tfprintf (asm_out_file, \"0x%x,\", bytes[i]);\n+      fprintf (asm_out_file, \"0x%x\", bytes[0]);\n+    }\n+  else\n+    {\n+      for (i = 0; i < size - 1; ++i)\n+\tfprintf (asm_out_file, \"0x%x,\", bytes[i]);\n+      fprintf (asm_out_file, \"0x%x\", bytes[i]);\n+    }\n+}\n+\n /* Output an immediate constant in a given SIZE in bytes.  */\n \n void\n@@ -505,6 +533,26 @@ eh_data_format_name (int format)\n #endif\n }\n \n+/* Output an unsigned LEB128 quantity, but only the byte values.  */\n+\n+void\n+dw2_asm_output_data_uleb128_raw (unsigned HOST_WIDE_INT value)\n+{\n+  while (1)\n+    {\n+      int byte = (value & 0x7f);\n+      value >>= 7;\n+      if (value != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+\n+      fprintf (asm_out_file, \"0x%x\", byte);\n+      if (value == 0)\n+\tbreak;\n+      fputc (',', asm_out_file);\n+    }\n+}\n+\n /* Output an unsigned LEB128 quantity.  */\n \n void\n@@ -566,6 +614,29 @@ dw2_asm_output_data_uleb128 (unsigned HOST_WIDE_INT value,\n   va_end (ap);\n }\n \n+/* Output an signed LEB128 quantity, but only the byte values.  */\n+\n+void\n+dw2_asm_output_data_sleb128_raw (HOST_WIDE_INT value)\n+{\n+  int byte, more;\n+\n+  while (1)\n+    {\n+      byte = (value & 0x7f);\n+      value >>= 7;\n+      more = !((value == 0 && (byte & 0x40) == 0)\n+\t\t|| (value == -1 && (byte & 0x40) != 0));\n+      if (more)\n+\tbyte |= 0x80;\n+\n+      fprintf (asm_out_file, \"0x%x\", byte);\n+      if (!more)\n+\tbreak;\n+      fputc (',', asm_out_file);\n+    }\n+}\n+\n /* Output a signed LEB128 quantity.  */\n \n void\n@@ -689,7 +760,6 @@ dw2_asm_output_delta_sleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n }\n #endif /* 0 */\n \f\n-static rtx dw2_force_const_mem (rtx, bool);\n static int dw2_output_indirect_constant_1 (splay_tree_node, void *);\n \n static GTY((param1_is (char *), param2_is (tree))) splay_tree indirect_pool;\n@@ -733,7 +803,7 @@ splay_tree_compare_strings (splay_tree_key k1, splay_tree_key k2)\n    \"near\" the function in any interesting sense.  IS_PUBLIC controls whether\n    the symbol can be shared across the entire application (or DSO).  */\n \n-static rtx\n+rtx\n dw2_force_const_mem (rtx x, bool is_public)\n {\n   splay_tree_node node;"}, {"sha": "70fbd4c4400052d96d0866d8804e8dfd6e45733d", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void dw2_assemble_integer (int, rtx);\n \n+extern void dw2_asm_output_data_raw (int, unsigned HOST_WIDE_INT);\n+\n extern void dw2_asm_output_data (int, unsigned HOST_WIDE_INT,\n \t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n@@ -46,10 +48,14 @@ extern void dw2_asm_output_nstring (const char *, size_t,\n \t\t\t\t    const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_3;\n \n+extern void dw2_asm_output_data_uleb128_raw (unsigned HOST_WIDE_INT);\n+\n extern void dw2_asm_output_data_uleb128\t(unsigned HOST_WIDE_INT,\n \t\t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_2;\n \n+extern void dw2_asm_output_data_sleb128_raw (HOST_WIDE_INT);\n+\n extern void dw2_asm_output_data_sleb128\t(HOST_WIDE_INT,\n \t\t\t\t\t const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_2;\n@@ -63,6 +69,7 @@ extern int size_of_sleb128 (HOST_WIDE_INT);\n extern int size_of_encoded_value (int);\n extern const char *eh_data_format_name (int);\n \n+extern rtx dw2_force_const_mem (rtx, bool);\n extern void dw2_output_indirect_constants (void);\n \n /* These are currently unused.  */"}, {"sha": "ad09949cc156d76bbf05b05e01ae0fa1793eed9d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 336, "deletions": 6, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ea462245cd9d967dce805b8b97ffe10ee30c3e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d4ea462245cd9d967dce805b8b97ffe10ee30c3e", "patch": "@@ -384,6 +384,7 @@ static void initial_return_save (rtx);\n #endif\n static HOST_WIDE_INT stack_adjust_offset (const_rtx);\n static void output_cfi (dw_cfi_ref, dw_fde_ref, int);\n+static void output_cfi_directive (dw_cfi_ref);\n static void output_call_frame_info (int);\n static void dwarf2out_note_section_used (void);\n static void dwarf2out_stack_adjust (rtx, bool);\n@@ -394,6 +395,7 @@ static void dwarf2out_frame_debug_expr (rtx, const char *);\n \n /* Support for complex CFA locations.  */\n static void output_cfa_loc (dw_cfi_ref);\n+static void output_cfa_loc_raw (dw_cfi_ref);\n static void get_cfa_from_loc_descr (dw_cfa_location *,\n \t\t\t\t    struct dw_loc_descr_struct *);\n static struct dw_loc_descr_struct *build_cfa_loc\n@@ -665,8 +667,19 @@ dwarf2out_cfi_label (void)\n {\n   static char label[20];\n \n-  ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", dwarf2out_cfi_label_num++);\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n+  if (flag_dwarf2_cfi_asm)\n+    {\n+      /* In this case, we will be emitting the asm directive instead of\n+\t the label, so just return a placeholder to keep the rest of the\n+\t interfaces happy.  */\n+      strcpy (label, \"<do not output>\");\n+    }\n+  else\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", dwarf2out_cfi_label_num++);\n+      ASM_OUTPUT_LABEL (asm_out_file, label);\n+    }\n+\n   return label;\n }\n \n@@ -676,7 +689,25 @@ dwarf2out_cfi_label (void)\n static void\n add_fde_cfi (const char *label, dw_cfi_ref cfi)\n {\n-  if (label)\n+  dw_cfi_ref *list_head = &cie_cfi_head;\n+\n+  if (flag_dwarf2_cfi_asm)\n+    {\n+      if (label)\n+\t{\n+\t  output_cfi_directive (cfi);\n+\n+\t  /* We still have to add the cfi to the list so that\n+\t     lookup_cfa works later on.  */\n+\t  list_head = &current_fde ()->dw_fde_cfi;\n+\t}\n+      /* ??? If this is a CFI for the CIE, we don't emit.  This\n+\t assumes that the standard CIE contents that the assembler\n+\t uses matches the standard CIE contents that the compiler\n+\t uses.  This is probably a bad assumption.  I'm not quite\n+\t sure how to address this for now.  */\n+    }\n+  else if (label)\n     {\n       dw_fde_ref fde = current_fde ();\n \n@@ -705,11 +736,10 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \t  fde->dw_fde_current_label = label;\n \t}\n \n-      add_cfi (&fde->dw_fde_cfi, cfi);\n+      list_head = &fde->dw_fde_cfi;\n     }\n \n-  else\n-    add_cfi (&cie_cfi_head, cfi);\n+  add_cfi (list_head, cfi);\n }\n \n /* Subroutine of lookup_cfa.  */\n@@ -2619,6 +2649,100 @@ output_cfi (dw_cfi_ref cfi, dw_fde_ref fde, int for_eh)\n     }\n }\n \n+/* Similar, but do it via assembler directives instead.  */\n+\n+static void\n+output_cfi_directive (dw_cfi_ref cfi)\n+{\n+  unsigned long r, r2;\n+\n+  switch (cfi->dw_cfi_opc)\n+    {\n+    case DW_CFA_advance_loc:\n+    case DW_CFA_advance_loc1:\n+    case DW_CFA_advance_loc2:\n+    case DW_CFA_advance_loc4:\n+    case DW_CFA_MIPS_advance_loc8:\n+    case DW_CFA_set_loc:\n+      /* Should only be created by add_fde_cfi in a code path not\n+\t followed when emitting via directives.  The assembler is\n+\t going to take care of this for us.  */\n+      gcc_unreachable ();\n+\n+    case DW_CFA_offset:\n+    case DW_CFA_offset_extended:\n+    case DW_CFA_offset_extended_sf:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_offset %lu, \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       r, cfi->dw_cfi_oprnd2.dw_cfi_offset * DWARF_CIE_DATA_ALIGNMENT);\n+      break;\n+\n+    case DW_CFA_restore:\n+    case DW_CFA_restore_extended:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_restore %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_undefined:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_undefined %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_same_value:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_same_value %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_def_cfa:\n+    case DW_CFA_def_cfa_sf:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_def_cfa %lu, \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       r, cfi->dw_cfi_oprnd2.dw_cfi_offset);\n+      break;\n+\n+    case DW_CFA_def_cfa_register:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_def_cfa_register %lu\\n\", r);\n+      break;\n+\n+    case DW_CFA_register:\n+      r = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, 0);\n+      r2 = DWARF2_FRAME_REG_OUT (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, 0);\n+      fprintf (asm_out_file, \"\\t.cfi_register %lu, %lu\\n\", r, r2);\n+      break;\n+\n+    case DW_CFA_def_cfa_offset:\n+    case DW_CFA_def_cfa_offset_sf:\n+      fprintf (asm_out_file, \"\\t.cfi_def_cfa_offset \"\n+\t       HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+      break;\n+\n+    case DW_CFA_GNU_args_size:\n+      fprintf (asm_out_file, \"\\t.cfi_escape 0x%x,\", DW_CFA_GNU_args_size);\n+      dw2_asm_output_data_uleb128_raw (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+      if (flag_debug_asm)\n+\tfprintf (asm_out_file, \"\\t%s args_size \"HOST_WIDE_INT_PRINT_DEC,\n+\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_offset);\n+      fputc ('\\n', asm_out_file);\n+      break;\n+\n+    case DW_CFA_GNU_window_save:\n+      fprintf (asm_out_file, \"\\t.cfi_window_save\\n\");\n+      break;\n+\n+    case DW_CFA_def_cfa_expression:\n+    case DW_CFA_expression:\n+      fprintf (asm_out_file, \"\\t.cfi_escape 0x%x,\", cfi->dw_cfi_opc);\n+      output_cfa_loc_raw (cfi);\n+      fputc ('\\n', asm_out_file);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Output the call frame information used to record information\n    that relates to calculating the frame pointer, and records the\n    location of saved registers.  */\n@@ -2642,6 +2766,10 @@ output_call_frame_info (int for_eh)\n   if (fde_table_in_use == 0)\n     return;\n \n+  /* Nothing to do if the assembler's doing it all.  */\n+  if (flag_dwarf2_cfi_asm)\n+    return;\n+\n   /* If we make FDEs linkonce, we may have to emit an empty label for\n      an FDE that wouldn't otherwise be emitted.  We want to avoid\n      having an FDE kept around when the function it refers to is\n@@ -3058,6 +3186,49 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   if (file)\n     dwarf2out_source_line (line, file);\n #endif\n+\n+  if (flag_dwarf2_cfi_asm)\n+    {\n+      int enc;\n+      rtx ref;\n+\n+      fprintf (asm_out_file, \"\\t.cfi_startproc\\n\");\n+\n+      if (eh_personality_libfunc)\n+\t{\n+\t  enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1); \n+\t  ref = eh_personality_libfunc;\n+\n+\t  /* ??? The GAS support isn't entirely consistent.  We have to\n+\t     handle indirect support ourselves, but PC-relative is done\n+\t     in the assembler.  Further, the assembler can't handle any\n+\t     of the weirder relocation types.  */\n+\t  if (enc & DW_EH_PE_indirect)\n+\t    ref = dw2_force_const_mem (ref, true);\n+\n+\t  fprintf (asm_out_file, \"\\t.cfi_personality 0x%x,\", enc);\n+\t  output_addr_const (asm_out_file, ref);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+\n+      if (crtl->uses_eh_lsda)\n+\t{\n+\t  char lab[20];\n+\n+\t  enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);\n+\t  ASM_GENERATE_INTERNAL_LABEL (lab, \"LLSDA\",\n+\t\t\t\t       current_function_funcdef_no);\n+\t  ref = gen_rtx_SYMBOL_REF (Pmode, lab);\n+\t  SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;\n+\n+\t  if (enc & DW_EH_PE_indirect)\n+\t    ref = dw2_force_const_mem (ref, true);\n+\n+\t  fprintf (asm_out_file, \"\\t.cfi_lsda 0x%x,\", enc);\n+\t  output_addr_const (asm_out_file, ref);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+    }\n }\n \n /* Output a marker (i.e. a label) for the absolute end of the generated code\n@@ -3071,6 +3242,9 @@ dwarf2out_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,\n   dw_fde_ref fde;\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n+  if (flag_dwarf2_cfi_asm)\n+    fprintf (asm_out_file, \"\\t.cfi_endproc\\n\");\n+\n   /* Output a label to mark the endpoint of the code generated for this\n      function.  */\n   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,\n@@ -3931,6 +4105,141 @@ output_loc_sequence (dw_loc_descr_ref loc)\n     }\n }\n \n+/* Output location description stack opcode's operands (if any).\n+   The output is single bytes on a line, suitable for .cfi_escape.  */\n+\n+static void\n+output_loc_operands_raw (dw_loc_descr_ref loc)\n+{\n+  dw_val_ref val1 = &loc->dw_loc_oprnd1;\n+  dw_val_ref val2 = &loc->dw_loc_oprnd2;\n+\n+  switch (loc->dw_loc_opc)\n+    {\n+    case DW_OP_addr:\n+      /* We cannot output addresses in .cfi_escape, only bytes.  */\n+      gcc_unreachable ();\n+\n+    case DW_OP_const1u:\n+    case DW_OP_const1s:\n+    case DW_OP_pick:\n+    case DW_OP_deref_size:\n+    case DW_OP_xderef_size:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_raw (1, val1->v.val_int);\n+      break;\n+\n+    case DW_OP_const2u:\n+    case DW_OP_const2s:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_raw (2, val1->v.val_int);\n+      break;\n+\n+    case DW_OP_const4u:\n+    case DW_OP_const4s:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_raw (4, val1->v.val_int);\n+      break;\n+\n+    case DW_OP_const8u:\n+    case DW_OP_const8s:\n+      gcc_assert (HOST_BITS_PER_LONG >= 64);\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_raw (8, val1->v.val_int);\n+      break;\n+\n+    case DW_OP_skip:\n+    case DW_OP_bra:\n+      {\n+\tint offset;\n+\n+\tgcc_assert (val1->val_class == dw_val_class_loc);\n+\toffset = val1->v.val_loc->dw_loc_addr - (loc->dw_loc_addr + 3);\n+\n+        fputc (',', asm_out_file);\n+\tdw2_asm_output_data_raw (2, offset);\n+      }\n+      break;\n+\n+    case DW_OP_constu:\n+    case DW_OP_plus_uconst:\n+    case DW_OP_regx:\n+    case DW_OP_piece:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_uleb128_raw (val1->v.val_unsigned);\n+      break;\n+\n+    case DW_OP_consts:\n+    case DW_OP_breg0:\n+    case DW_OP_breg1:\n+    case DW_OP_breg2:\n+    case DW_OP_breg3:\n+    case DW_OP_breg4:\n+    case DW_OP_breg5:\n+    case DW_OP_breg6:\n+    case DW_OP_breg7:\n+    case DW_OP_breg8:\n+    case DW_OP_breg9:\n+    case DW_OP_breg10:\n+    case DW_OP_breg11:\n+    case DW_OP_breg12:\n+    case DW_OP_breg13:\n+    case DW_OP_breg14:\n+    case DW_OP_breg15:\n+    case DW_OP_breg16:\n+    case DW_OP_breg17:\n+    case DW_OP_breg18:\n+    case DW_OP_breg19:\n+    case DW_OP_breg20:\n+    case DW_OP_breg21:\n+    case DW_OP_breg22:\n+    case DW_OP_breg23:\n+    case DW_OP_breg24:\n+    case DW_OP_breg25:\n+    case DW_OP_breg26:\n+    case DW_OP_breg27:\n+    case DW_OP_breg28:\n+    case DW_OP_breg29:\n+    case DW_OP_breg30:\n+    case DW_OP_breg31:\n+    case DW_OP_fbreg:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_sleb128_raw (val1->v.val_int);\n+      break;\n+\n+    case DW_OP_bregx:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_uleb128_raw (val1->v.val_unsigned);\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_sleb128_raw (val2->v.val_int);\n+      break;\n+\n+    case INTERNAL_DW_OP_tls_addr:\n+      gcc_unreachable ();\n+\n+    default:\n+      /* Other codes have no operands.  */\n+      break;\n+    }\n+}\n+\n+static void\n+output_loc_sequence_raw (dw_loc_descr_ref loc)\n+{\n+  while (1)\n+    {\n+      /* Output the opcode.  */\n+      fprintf (asm_out_file, \"0x%x\", loc->dw_loc_opc);\n+      output_loc_operands_raw (loc);\n+\n+      if (!loc->dw_loc_next)\n+\tbreak;\n+      loc = loc->dw_loc_next;\n+\n+      fputc (',', asm_out_file);\n+    }\n+}\n+\n /* This routine will generate the correct assembly data for a location\n    description based on a cfi entry with a complex address.  */\n \n@@ -3952,6 +4261,27 @@ output_cfa_loc (dw_cfi_ref cfi)\n   output_loc_sequence (loc);\n }\n \n+/* Similar, but used for .cfi_escape.  */\n+\n+static void\n+output_cfa_loc_raw (dw_cfi_ref cfi)\n+{\n+  dw_loc_descr_ref loc;\n+  unsigned long size;\n+\n+  if (cfi->dw_cfi_opc == DW_CFA_expression)\n+    fprintf (asm_out_file, \"0x%x,\", cfi->dw_cfi_oprnd2.dw_cfi_reg_num);\n+\n+  /* Output the size of the block.  */\n+  loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n+  size = size_of_locs (loc);\n+  dw2_asm_output_data_uleb128_raw (size);\n+  fputc (',', asm_out_file);\n+\n+  /* Now output the operations themselves.  */\n+  output_loc_sequence_raw (loc);\n+}\n+\n /* This function builds a dwarf location descriptor sequence from a\n    dw_cfa_location, adding the given OFFSET to the result of the\n    expression.  */"}]}