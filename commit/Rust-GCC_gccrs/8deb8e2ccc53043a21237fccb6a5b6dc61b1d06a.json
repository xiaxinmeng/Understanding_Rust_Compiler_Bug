{"sha": "8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRlYjhlMmNjYzUzMDQzYTIxMjM3ZmNjYjZhNWI2ZGM2MWIxZDA2YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-25T23:17:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-25T23:17:35Z"}, "message": "loop.c (n_times_set, [...]): Convert to varrays.\n\n\t* loop.c (n_times_set, n_times_used, may_not_optimize,\n\treg_single_usage): Convert to varrays.  All uses changed.\n\t(insert_loop_mem): Return a value.\n\t(scan_loop): Tweak AVOID_CC_MODE_COPIES code.\n\t(load_mems_and_recount_loop_regs_set): Likewise.  Grow the arrays, if\n\tnecessary.\n\nFrom-SVN: r21986", "tree": {"sha": "5be691585a8373751baea9d2dbec3a59a20d4d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5be691585a8373751baea9d2dbec3a59a20d4d83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a/comments", "author": null, "committer": null, "parents": [{"sha": "6e1488073b14ec9a7bfdfeda8099dd8dc40cf8ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1488073b14ec9a7bfdfeda8099dd8dc40cf8ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1488073b14ec9a7bfdfeda8099dd8dc40cf8ea"}], "stats": {"total": 233, "additions": 136, "deletions": 97}, "files": [{"sha": "681ab6173cd51e6b625dd9b117c67e4d68f512ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a", "patch": "@@ -1,3 +1,12 @@\n+Tue Aug 25 10:57:41 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* loop.c (n_times_set, n_times_used, may_not_optimize,\n+\treg_single_usage): Convert to varrays.  All uses changed.\n+\t(insert_loop_mem): Return a value.\n+\t(scan_loop): Tweak AVOID_CC_MODE_COPIES code.\n+\t(load_mems_and_recount_loop_regs_set): Likewise.  Grow the arrays, if\n+\tnecessary.\n+\n Tue Aug 25 23:57:12 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* From Alexandre:"}, {"sha": "33f3454ae5bccc286aa40fe1cbb19a32aa20d394", "filename": "gcc/loop.c", "status": "modified", "additions": 127, "deletions": 97, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8deb8e2ccc53043a21237fccb6a5b6dc61b1d06a", "patch": "@@ -168,18 +168,18 @@ static rtx loop_continue;\n    Therefore, at all times, == 0 indicates an invariant register;\n    < 0 a conditionally invariant one.  */\n \n-static int *n_times_set;\n+static varray_type n_times_set;\n \n /* Original value of n_times_set; same except that this value\n    is not set negative for a reg whose sets have been made candidates\n    and not set to 0 for a reg that is moved.  */\n \n-static int *n_times_used;\n+static varray_type n_times_used;\n \n /* Index by register number, 1 indicates that the register\n    cannot be moved or strength reduced.  */\n \n-static char *may_not_optimize;\n+static varray_type may_not_optimize;\n \n /* Nonzero means reg N has already been moved out of one loop.\n    This reduces the desire to move it out of another.  */\n@@ -306,7 +306,8 @@ static int reg_in_basic_block_p PROTO((rtx, rtx));\n static int consec_sets_invariant_p PROTO((rtx, int, rtx));\n static rtx libcall_other_reg PROTO((rtx, rtx));\n static int labels_in_range_p PROTO((rtx, int));\n-static void count_loop_regs_set PROTO((rtx, rtx, char *, rtx *, int *, int));\n+static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n+\t\t\t\t       int *, int)); \n static void note_addr_stored PROTO((rtx, rtx));\n static int loop_reg_used_before_p PROTO((rtx, rtx, rtx, rtx, rtx));\n static void scan_loop PROTO((rtx, rtx, int));\n@@ -324,7 +325,7 @@ static void add_label_notes PROTO((rtx, rtx));\n static void move_movables PROTO((struct movable *, int, int, rtx, rtx, int));\n static int count_nonfixed_reads PROTO((rtx));\n static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, int));\n-static void find_single_use_in_loop PROTO((rtx, rtx, rtx *));\n+static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, int, int));\n@@ -348,7 +349,8 @@ static void record_initial PROTO((rtx, rtx));\n static void update_reg_last_use PROTO((rtx, rtx));\n static rtx next_insn_in_loop PROTO((rtx, rtx, rtx, rtx));\n static void load_mems_and_recount_loop_regs_set PROTO((rtx, rtx, rtx,\n-\t\t\t\t\t\t       rtx, rtx *, int *));\n+\t\t\t\t\t\t       rtx, varray_type, \n+\t\t\t\t\t\t       int *));\n static void load_mems PROTO((rtx, rtx, rtx, rtx));\n static int insert_loop_mem PROTO((rtx *, void *));\n static int replace_loop_mem PROTO((rtx *, void *));\n@@ -678,7 +680,7 @@ scan_loop (loop_start, end, unroll_p)\n   /* If we have calls, contains the insn in which a register was used\n      if it was used exactly once; contains const0_rtx if it was used more\n      than once.  */\n-  rtx *reg_single_usage = 0;\n+  varray_type reg_single_usage = 0;\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n   int nregs;\n@@ -757,40 +759,42 @@ scan_loop (loop_start, end, unroll_p)\n     }\n \n   /* Count number of times each reg is set during this loop.\n-     Set may_not_optimize[I] if it is not safe to move out\n+     Set VARRAY_CHAR (may_not_optimize, I) if it is not safe to move out\n      the setting of register I.  If this loop has calls, set\n-     reg_single_usage[I].  */\n+     VARRAY_RTX (reg_single_usage, I).  */\n   \n   /* Allocate extra space for REGS that might be created by\n-     load_mems and move_movables.  */\n-  nregs = max_reg_num () + loop_mems_idx + 100;\n-  n_times_set = (int *) alloca (nregs * sizeof (int));\n-  n_times_used = (int *) alloca (nregs * sizeof (int));\n-  may_not_optimize = (char *) alloca (nregs);\n-  bzero ((char *) n_times_set, nregs * sizeof (int));\n-  bzero (may_not_optimize, nregs);\n+     load_mems.  We allocate a little extra slop as well, in the hopes\n+     that even after the moving of movables creates some new registers\n+     we won't have to reallocate these arrays.  However, we do grow\n+     the arrays, if necessary, in load_mems_recount_loop_regs_set.  */\n+  nregs = max_reg_num () + loop_mems_idx + 16;\n+  VARRAY_INT_INIT (n_times_set, nregs, \"n_times_set\");\n+  VARRAY_INT_INIT (n_times_used, nregs, \"n_times_used\");\n+  VARRAY_CHAR_INIT (may_not_optimize, nregs, \"may_not_optimize\");\n \n   if (loop_has_call)\n-    {\n-      reg_single_usage = (rtx *) alloca (nregs * sizeof (rtx));\n-      bzero ((char *) reg_single_usage, nregs * sizeof (rtx));\n-    }\n+    VARRAY_RTX_INIT (reg_single_usage, nregs, \"reg_single_usage\");\n \n   count_loop_regs_set (loop_top ? loop_top : loop_start, end,\n \t\t       may_not_optimize, reg_single_usage, &insn_count, nregs);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    may_not_optimize[i] = 1, n_times_set[i] = 1;\n+    {\n+      VARRAY_CHAR (may_not_optimize, i) = 1;\n+      VARRAY_INT (n_times_set, i) = 1;\n+    }\n \n #ifdef AVOID_CCMODE_COPIES\n   /* Don't try to move insns which set CC registers if we should not\n      create CCmode register copies.  */\n-  for (i = FIRST_PSEUDO_REGISTER; i < nregs - loop_mems_idx; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_reg_num (); i++)\n     if (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-      may_not_optimize[i] = 1;\n+      VARRAY_CHAR (may_not_optimize, i) = 1;\n #endif\n \n-  bcopy ((char *) n_times_set, (char *) n_times_used, nregs * sizeof (int));\n+  bcopy ((char *) &n_times_set->data, \n+\t (char *) &n_times_used->data, nregs * sizeof (int));\n \n   if (loop_dump_stream)\n     {\n@@ -828,7 +832,7 @@ scan_loop (loop_start, end, unroll_p)\n       if (GET_CODE (p) == INSN\n \t  && (set = single_set (p))\n \t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && ! may_not_optimize[REGNO (SET_DEST (set))])\n+\t  && ! VARRAY_CHAR (may_not_optimize, REGNO (SET_DEST (set))))\n \t{\n \t  int tem1 = 0;\n \t  int tem2 = 0;\n@@ -884,11 +888,13 @@ scan_loop (loop_start, end, unroll_p)\n \t  else if ((tem = invariant_p (src))\n \t\t   && (dependencies == 0\n \t\t       || (tem2 = invariant_p (dependencies)) != 0)\n-\t\t   && (n_times_set[REGNO (SET_DEST (set))] == 1\n+\t\t   && (VARRAY_INT (n_times_set, \n+\t\t\t\t   REGNO (SET_DEST (set))) == 1\n \t\t       || (tem1\n-\t\t\t   = consec_sets_invariant_p (SET_DEST (set),\n-\t\t\t\t\t\t      n_times_set[REGNO (SET_DEST (set))],\n-\t\t\t\t\t\t      p)))\n+\t\t\t   = consec_sets_invariant_p \n+\t\t\t   (SET_DEST (set),\n+\t\t\t    VARRAY_INT (n_times_set, REGNO (SET_DEST (set))),\n+\t\t\t    p)))\n \t\t   /* If the insn can cause a trap (such as divide by zero),\n \t\t      can't move it unless it's guaranteed to be executed\n \t\t      once loop is entered.  Even a function call might\n@@ -914,12 +920,12 @@ scan_loop (loop_start, end, unroll_p)\n \t\t Don't do this if P has a REG_RETVAL note or if we have\n \t\t SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n \n-\t      if (reg_single_usage && reg_single_usage[regno] != 0\n-\t\t  && reg_single_usage[regno] != const0_rtx\n+\t      if (reg_single_usage && VARRAY_RTX (reg_single_usage, regno) != 0\n+\t\t  && VARRAY_RTX (reg_single_usage, regno) != const0_rtx\n \t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n \t\t  && (REGNO_LAST_UID (regno)\n-\t\t      == INSN_UID (reg_single_usage[regno]))\n-\t\t  && n_times_set[REGNO (SET_DEST (set))] == 1\n+\t\t      == INSN_UID (VARRAY_RTX (reg_single_usage, regno)))\n+\t\t  && VARRAY_INT (n_times_set, regno) == 1\n \t\t  && ! side_effects_p (SET_SRC (set))\n \t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n \t\t  && (! SMALL_REGISTER_CLASSES\n@@ -929,22 +935,25 @@ scan_loop (loop_start, end, unroll_p)\n \t\t     a call-clobbered register and the life of REGNO\n \t\t     might span a call.  */\n \t\t  && ! modified_between_p (SET_SRC (set), p,\n-\t\t\t\t\t   reg_single_usage[regno])\n-\t\t  && no_labels_between_p (p, reg_single_usage[regno])\n+\t\t\t\t\t   VARRAY_RTX\n+\t\t\t\t\t   (reg_single_usage, regno)) \n+\t\t  && no_labels_between_p (p, VARRAY_RTX (reg_single_usage, regno))\n \t\t  && validate_replace_rtx (SET_DEST (set), SET_SRC (set),\n-\t\t\t\t\t   reg_single_usage[regno]))\n+\t\t\t\t\t   VARRAY_RTX\n+\t\t\t\t\t   (reg_single_usage, regno))) \n \t\t{\n \t\t  /* Replace any usage in a REG_EQUAL note.  Must copy the\n \t\t     new source, so that we don't get rtx sharing between the\n \t\t     SET_SOURCE and REG_NOTES of insn p.  */\n-\t\t  REG_NOTES (reg_single_usage[regno])\n-\t\t    = replace_rtx (REG_NOTES (reg_single_usage[regno]),\n+\t\t  REG_NOTES (VARRAY_RTX (reg_single_usage, regno))\n+\t\t    = replace_rtx (REG_NOTES (VARRAY_RTX\n+\t\t\t\t\t      (reg_single_usage, regno)), \n \t\t\t\t   SET_DEST (set), copy_rtx (SET_SRC (set)));\n \t\t\t\t   \n \t\t  PUT_CODE (p, NOTE);\n \t\t  NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (p) = 0;\n-\t\t  n_times_set[regno] = 0;\n+\t\t  VARRAY_INT (n_times_set, regno) = 0;\n \t\t  continue;\n \t\t}\n \n@@ -955,7 +964,8 @@ scan_loop (loop_start, end, unroll_p)\n \t      m->dependencies = dependencies;\n \t      m->set_dest = SET_DEST (set);\n \t      m->force = 0;\n-\t      m->consec = n_times_set[REGNO (SET_DEST (set))] - 1;\n+\t      m->consec = VARRAY_INT (n_times_set, \n+\t\t\t\t      REGNO (SET_DEST (set))) - 1;\n \t      m->done = 0;\n \t      m->forces = 0;\n \t      m->partial = 0;\n@@ -972,10 +982,10 @@ scan_loop (loop_start, end, unroll_p)\n \t      m->match = 0;\n \t      m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t     - uid_luid[REGNO_FIRST_UID (regno)]);\n-\t      m->savings = n_times_used[regno];\n+\t      m->savings = VARRAY_INT (n_times_used, regno);\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n-\t      n_times_set[regno] = move_insn ? -2 : -1;\n+\t      VARRAY_INT (n_times_set, regno) = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n \t      if (movables == 0)\n \t\tmovables = m;\n@@ -1034,7 +1044,7 @@ scan_loop (loop_start, end, unroll_p)\n \t\t   && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n \t    {\n \t      register int regno = REGNO (SET_DEST (set));\n-\t      if (n_times_set[regno] == 2)\n+\t      if (VARRAY_INT (n_times_set, regno) == 2)\n \t\t{\n \t\t  register struct movable *m;\n \t\t  m = (struct movable *) alloca (sizeof (struct movable));\n@@ -1084,7 +1094,7 @@ scan_loop (loop_start, end, unroll_p)\n \t\t  m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t\t - uid_luid[REGNO_FIRST_UID (regno)]);\n \t\t  m->savings = 1;\n-\t\t  n_times_set[regno] = -1;\n+\t\t  VARRAY_INT (n_times_set, regno) = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n \t\t  if (movables == 0)\n \t\t    movables = m;\n@@ -1161,8 +1171,8 @@ scan_loop (loop_start, end, unroll_p)\n   /* Now candidates that still are negative are those not moved.\n      Change n_times_set to indicate that those are not actually invariant.  */\n   for (i = 0; i < nregs; i++)\n-    if (n_times_set[i] < 0)\n-      n_times_set[i] = n_times_used[i];\n+    if (VARRAY_INT (n_times_set, i) < 0)\n+      VARRAY_INT (n_times_set, i) = VARRAY_INT (n_times_used, i);\n \n   /* Now that we've moved some things out of the loop, we able to\n      hoist even more memory references.  There's no need to pass\n@@ -1177,6 +1187,11 @@ scan_loop (loop_start, end, unroll_p)\n       strength_reduce (scan_start, end, loop_top,\n \t\t       insn_count, loop_start, end, unroll_p);\n     }\n+\n+  VARRAY_FREE (n_times_set);\n+  VARRAY_FREE (n_times_used);\n+  VARRAY_FREE (may_not_optimize);\n+  VARRAY_FREE (reg_single_usage);\n }\n \f\n /* Add elements to *OUTPUT to record all the pseudo-regs\n@@ -1450,7 +1465,7 @@ combine_movables (movables, nregs)\n   /* Perhaps testing m->consec_sets would be more appropriate here?  */\n \n   for (m = movables; m; m = m->next)\n-    if (m->match == 0 && n_times_used[m->regno] == 1 && !m->partial)\n+    if (m->match == 0 && VARRAY_INT (n_times_used, m->regno) == 1 && !m->partial)\n       {\n \tregister struct movable *m1;\n \tint regno = m->regno;\n@@ -1461,7 +1476,7 @@ combine_movables (movables, nregs)\n \t/* We want later insns to match the first one.  Don't make the first\n \t   one match any later ones.  So start this loop at m->next.  */\n \tfor (m1 = m->next; m1; m1 = m1->next)\n-\t  if (m != m1 && m1->match == 0 && n_times_used[m1->regno] == 1\n+\t  if (m != m1 && m1->match == 0 && VARRAY_INT (n_times_used, m1->regno) == 1\n \t      /* A reg used outside the loop mustn't be eliminated.  */\n \t      && !m1->global\n \t      /* A reg used for zero-extending mustn't be eliminated.  */\n@@ -1598,15 +1613,15 @@ rtx_equal_for_loop_p (x, y, movables)\n \n   /* If we have a register and a constant, they may sometimes be\n      equal.  */\n-  if (GET_CODE (x) == REG && n_times_set[REGNO (x)] == -2\n+  if (GET_CODE (x) == REG && VARRAY_INT (n_times_set, REGNO (x)) == -2\n       && CONSTANT_P (y))\n     {\n       for (m = movables; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (x)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n-  else if (GET_CODE (y) == REG && n_times_set[REGNO (y)] == -2\n+  else if (GET_CODE (y) == REG && VARRAY_INT (n_times_set, REGNO (y)) == -2\n \t   && CONSTANT_P (x))\n     {\n       for (m = movables; m; m = m->next)\n@@ -1837,7 +1852,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t      || flag_move_all_movables\n \t      || (threshold * savings * m->lifetime) >= insn_count\n \t      || (m->forces && m->forces->done\n-\t\t  && n_times_used[m->forces->regno] == 1))\n+\t\t  && VARRAY_INT (n_times_used, m->forces->regno) == 1))\n \t    {\n \t      int count;\n \t      register struct movable *m1;\n@@ -2128,7 +2143,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \n \t      /* The reg set here is now invariant.  */\n \t      if (! m->partial)\n-\t\tn_times_set[regno] = 0;\n+\t\tVARRAY_INT (n_times_set, regno) = 0;\n \n \t      m->done = 1;\n \n@@ -2185,7 +2200,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t      /* The reg merged here is now invariant,\n \t\t\t if the reg it matches is invariant.  */\n \t\t      if (! m->partial)\n-\t\t\tn_times_set[m1->regno] = 0;\n+\t\t\tVARRAY_INT (n_times_set, m1->regno) = 0;\n \t\t    }\n \t    }\n \t  else if (loop_dump_stream)\n@@ -3087,10 +3102,10 @@ invariant_p (x)\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n-      if (n_times_set[REGNO (x)] < 0)\n+      if (VARRAY_INT (n_times_set, REGNO (x)) < 0)\n \treturn 2;\n \n-      return n_times_set[REGNO (x)] == 0;\n+      return VARRAY_INT (n_times_set, REGNO (x)) == 0;\n \n     case MEM:\n       /* Volatile memory references must be rejected.  Do this before\n@@ -3178,15 +3193,15 @@ consec_sets_invariant_p (reg, n_sets, insn)\n   rtx temp;\n   /* Number of sets we have to insist on finding after INSN.  */\n   int count = n_sets - 1;\n-  int old = n_times_set[regno];\n+  int old = VARRAY_INT (n_times_set, regno);\n   int value = 0;\n   int this;\n \n   /* If N_SETS hit the limit, we can't rely on its value.  */\n   if (n_sets == 127)\n     return 0;\n \n-  n_times_set[regno] = 0;\n+  VARRAY_INT (n_times_set, regno) = 0;\n \n   while (count > 0)\n     {\n@@ -3225,12 +3240,12 @@ consec_sets_invariant_p (reg, n_sets, insn)\n \tcount--;\n       else if (code != NOTE)\n \t{\n-\t  n_times_set[regno] = old;\n+\t  VARRAY_INT (n_times_set, regno) = old;\n \t  return 0;\n \t}\n     }\n \n-  n_times_set[regno] = old;\n+  VARRAY_INT (n_times_set, regno) = old;\n   /* If invariant_p ever returned 2, we return 2.  */\n   return 1 + (value & 2);\n }\n@@ -3276,15 +3291,16 @@ static void\n find_single_use_in_loop (insn, x, usage)\n      rtx insn;\n      rtx x;\n-     rtx *usage;\n+     varray_type usage;\n {\n   enum rtx_code code = GET_CODE (x);\n   char *fmt = GET_RTX_FORMAT (code);\n   int i, j;\n \n   if (code == REG)\n-    usage[REGNO (x)]\n-      = (usage[REGNO (x)] != 0 && usage[REGNO (x)] != insn)\n+    VARRAY_RTX (usage, REGNO (x))\n+      = (VARRAY_RTX (usage, REGNO (x)) != 0 \n+\t && VARRAY_RTX (usage, REGNO (x)) != insn)\n \t? const0_rtx : insn;\n \n   else if (code == SET)\n@@ -3327,8 +3343,8 @@ find_single_use_in_loop (insn, x, usage)\n static void\n count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n      register rtx from, to;\n-     char *may_not_move;\n-     rtx *single_usage;\n+     varray_type may_not_move;\n+     varray_type single_usage;\n      int *count_ptr;\n      int nregs;\n {\n@@ -3358,7 +3374,7 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t      && GET_CODE (XEXP (PATTERN (insn), 0)) == REG)\n \t    /* Don't move a reg that has an explicit clobber.\n \t       We might do so sometimes, but it's not worth the pain.  */\n-\t    may_not_move[REGNO (XEXP (PATTERN (insn), 0))] = 1;\n+\t    VARRAY_CHAR (may_not_move, REGNO (XEXP (PATTERN (insn), 0))) = 1;\n \n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n@@ -3376,16 +3392,17 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t\t     in current basic block, and it was set before,\n \t\t     it must be set in two basic blocks, so it cannot\n \t\t     be moved out of the loop.  */\n-\t\t  if (n_times_set[regno] > 0 && last_set[regno] == 0)\n-\t\t    may_not_move[regno] = 1;\n+\t\t  if (VARRAY_INT (n_times_set, regno) > 0\n+\t\t      && last_set[regno] == 0)\n+\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n \t\t  /* If this is not first setting in current basic block,\n \t\t     see if reg was used in between previous one and this.\n \t\t     If so, neither one can be moved.  */\n \t\t  if (last_set[regno] != 0\n \t\t      && reg_used_between_p (dest, last_set[regno], insn))\n-\t\t    may_not_move[regno] = 1;\n-\t\t  if (n_times_set[regno] < 127)\n-\t\t    ++n_times_set[regno];\n+\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n+\t\t  if (VARRAY_INT (n_times_set, regno) < 127)\n+\t\t    ++VARRAY_INT (n_times_set, regno);\n \t\t  last_set[regno] = insn;\n \t\t}\n \t    }\n@@ -3398,7 +3415,7 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t\t  if (GET_CODE (x) == CLOBBER && GET_CODE (XEXP (x, 0)) == REG)\n \t\t    /* Don't move a reg that has an explicit clobber.\n \t\t       It's not worth the pain to try to do it correctly.  */\n-\t\t    may_not_move[REGNO (XEXP (x, 0))] = 1;\n+\t\t    VARRAY_CHAR (may_not_move, REGNO (XEXP (x, 0))) = 1;\n \n \t\t  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n \t\t    {\n@@ -3411,13 +3428,14 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n \t\t      if (GET_CODE (dest) == REG)\n \t\t\t{\n \t\t\t  register int regno = REGNO (dest);\n-\t\t\t  if (n_times_set[regno] > 0 && last_set[regno] == 0)\n-\t\t\t    may_not_move[regno] = 1;\n+\t\t\t  if (VARRAY_INT (n_times_set, regno) > 0 \n+\t\t\t      && last_set[regno] == 0)\n+\t\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n \t\t\t  if (last_set[regno] != 0\n \t\t\t      && reg_used_between_p (dest, last_set[regno], insn))\n-\t\t\t    may_not_move[regno] = 1;\n-\t\t\t  if (n_times_set[regno] < 127)\n-\t\t\t    ++n_times_set[regno];\n+\t\t\t    VARRAY_CHAR (may_not_move, regno) = 1;\n+\t\t\t  if (VARRAY_INT (n_times_set, regno) < 127)\n+\t\t\t    ++VARRAY_INT (n_times_set, regno);\n \t\t\t  last_set[regno] = insn;\n \t\t\t}\n \t\t    }\n@@ -3745,7 +3763,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       if (reg_iv_type[bl->regno] != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n-\t  || n_times_set[bl->regno] != bl->biv_count\n+\t  || VARRAY_INT (n_times_set, bl->regno) != bl->biv_count\n \t  /* If never incremented, it is invariant that we decided not to\n \t     move.  So leave it alone.  */\n \t  || ! bl->incremented)\n@@ -3906,7 +3924,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       if (GET_CODE (p) == INSN\n \t  && (set = single_set (p))\n \t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && ! may_not_optimize[REGNO (SET_DEST (set))])\n+\t  && ! VARRAY_CHAR (may_not_optimize, REGNO (SET_DEST (set))))\n \t{\n \t  rtx src_reg;\n \t  rtx add_val;\n@@ -3932,7 +3950,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t      /* Don't recognize a BASIC_INDUCT_VAR here.  */\n \t      && dest_reg != src_reg\n \t      /* This must be the only place where the register is set.  */\n-\t      && (n_times_set[REGNO (dest_reg)] == 1\n+\t      && (VARRAY_INT (n_times_set, REGNO (dest_reg)) == 1\n \t\t  /* or all sets must be consecutive and make a giv.  */\n \t\t  || (benefit = consec_sets_giv (benefit, p,\n \t\t\t\t\t\t src_reg, dest_reg,\n@@ -3948,7 +3966,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\tbenefit += libcall_benefit (p);\n \n \t      /* Skip the consecutive insns, if there are any.  */\n-\t      for (count = n_times_set[REGNO (dest_reg)] - 1;\n+\t      for (count = VARRAY_INT (n_times_set, REGNO (dest_reg)) - 1;\n \t\t   count > 0; count--)\n \t\t{\n \t\t  /* If first insn of libcall sequence, skip to end.\n@@ -4890,7 +4908,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n       v->lifetime = (uid_luid[REGNO_LAST_UID (REGNO (dest_reg))]\n \t\t     - uid_luid[REGNO_FIRST_UID (REGNO (dest_reg))]);\n \n-      v->times_used = n_times_used[REGNO (dest_reg)];\n+      v->times_used = VARRAY_INT (n_times_used, REGNO (dest_reg));\n \n       /* If the lifetime is zero, it means that this register is\n \t really a dead store.  So mark this as a giv that can be\n@@ -6050,7 +6068,7 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n   reg_iv_type[REGNO (dest_reg)] = GENERAL_INDUCT;\n   reg_iv_info[REGNO (dest_reg)] = v;\n \n-  count = n_times_set[REGNO (dest_reg)] - 1;\n+  count = VARRAY_INT (n_times_set, REGNO (dest_reg)) - 1;\n \n   while (count > 0)\n     {\n@@ -6322,12 +6340,12 @@ combine_givs_used_once (g1, g2)\n      struct induction *g1, *g2;\n {\n   if (g1->giv_type == DEST_REG\n-      && n_times_used[REGNO (g1->dest_reg)] == 1\n+      && VARRAY_INT (n_times_used, REGNO (g1->dest_reg)) == 1\n       && reg_mentioned_p (g1->dest_reg, PATTERN (g2->insn)))\n     return -1;\n \n   if (g2->giv_type == DEST_REG\n-      && n_times_used[REGNO (g2->dest_reg)] == 1\n+      && VARRAY_INT (n_times_used, REGNO (g2->dest_reg)) == 1\n       && reg_mentioned_p (g2->dest_reg, PATTERN (g1->insn)))\n     return 1;\n \n@@ -8398,6 +8416,8 @@ insert_loop_mem (mem, data)\n   loop_mems[loop_mems_idx].optimize = (GET_MODE (m) != BLKmode);\n   loop_mems[loop_mems_idx].reg = NULL_RTX;\n   ++loop_mems_idx;\n+\n+  return 0;\n }\n \n /* Like load_mems, but also ensures that N_TIMES_SET,\n@@ -8411,7 +8431,7 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n      rtx end;\n      rtx loop_top;\n      rtx start;\n-     rtx *reg_single_usage;\n+     varray_type reg_single_usage;\n      int *insn_count;\n {\n   int nregs = max_reg_num ();\n@@ -8428,32 +8448,42 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n       old_nregs = nregs;\n       nregs = max_reg_num ();\n \n-      /* Note that we assume here that enough room was allocated in\n-\t the various arrays to accomodate the extra registers created\n-\t by load_mems.  */\n-      bzero ((char *) n_times_set, nregs * sizeof (int));\n-      bzero (may_not_optimize, nregs);\n-      if (loop_has_call && reg_single_usage)\n-\tbzero ((char *) reg_single_usage, nregs * sizeof (rtx));\n+      if (nregs > n_times_set->num_elements)\n+\t{\n+\t  /* Grow all the arrays.  */\n+\t  VARRAY_GROW (n_times_set, nregs);\n+\t  VARRAY_GROW (n_times_used, nregs);\n+\t  VARRAY_GROW (may_not_optimize, nregs);\n+\t  if (reg_single_usage)\n+\t    VARRAY_GROW (reg_single_usage, nregs);\n+\t}\n+      /* Clear the arrays */\n+      bzero ((char *) &n_times_set->data, nregs * sizeof (int));\n+      bzero ((char *) &may_not_optimize->data, nregs * sizeof (char));\n+      if (reg_single_usage)\n+\tbzero ((char *) &reg_single_usage->data, nregs * sizeof (rtx));\n \n       count_loop_regs_set (loop_top ? loop_top : start, end,\n \t\t\t   may_not_optimize, reg_single_usage,\n \t\t\t   insn_count, nregs); \n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tmay_not_optimize[i] = 1, n_times_set[i] = 1;\n+\t{\n+\t  VARRAY_CHAR (may_not_optimize, i) = 1;\n+\t  VARRAY_INT (n_times_set, i) = 1;\n+\t}\n       \n #ifdef AVOID_CCMODE_COPIES\n       /* Don't try to move insns which set CC registers if we should not\n \t create CCmode register copies.  */\n-      for (i = FIRST_PSEUDO_REGISTER; i < nregs - loop_mems_idx; i++)\n+      for (i = FIRST_PSEUDO_REGISTER; i < max_reg_num (); i++)\n \tif (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n-\t  may_not_optimize[i] = 1;\n+\t  VARRAY_CHAR (may_not_optimize, i) = 1;\n #endif\n \n       /* Set n_times_used for the new registers.  */\n-      bcopy ((char *) (n_times_set + old_nregs),\n-\t     (char *) (n_times_used + old_nregs),\n+      bcopy ((char *) (&n_times_set->data.i[0] + old_nregs),\n+\t     (char *) (&n_times_used->data.i[0] + old_nregs),\n \t     (nregs - old_nregs) * sizeof (int));\n     }\n }"}]}