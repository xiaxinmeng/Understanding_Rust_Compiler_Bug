{"sha": "f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBhYzE4Yjc5OTMxYTA3NGI1YmM4OGUwYjY0ZWE4ZWY4NGU0MDk0MQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-09-23T14:26:47Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-09-23T14:26:47Z"}, "message": "re PR fortran/37588 (GENERIC type-bound procedure is not resolved)\n\n2008-09-23  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37588\n\t* gfortran.h (gfc_compare_actual_formal): Removed, made private.\n\t(gfc_arglist_matches_symbol): New method.\n\t* interface.c (compare_actual_formal): Made static.\n\t(gfc_procedure_use): Use new name of compare_actual_formal.\n\t(gfc_arglist_matches_symbol): New method.\n\t(gfc_search_interface): Moved code partially to new\n\tgfc_arglist_matches_symbol.\n\t* resolve.c (resolve_typebound_generic_call): Resolve actual arglist\n\tbefore checking against formal and use new gfc_arglist_matches_symbol\n\tfor checking.\n\t(resolve_compcall): Set type-spec of generated expression.\n\n2008-09-23  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37588\n\t* gfortran.dg/typebound_generic_4.f03: New test.\n\t* gfortran.dg/typebound_generic_5.f03: New test.\n\nFrom-SVN: r140594", "tree": {"sha": "c7feacbab392296b48eedf075c4af711194f8b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7feacbab392296b48eedf075c4af711194f8b63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0580031a7919f8e1401db1c2e6515e1682eaaa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0580031a7919f8e1401db1c2e6515e1682eaaa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0580031a7919f8e1401db1c2e6515e1682eaaa7"}], "stats": {"total": 188, "additions": 168, "deletions": 20}, "files": [{"sha": "1210d393efcf30099756e8ee387a4968ba2ea80d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -1,3 +1,18 @@\n+2008-09-23  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37588\n+\t* gfortran.h (gfc_compare_actual_formal): Removed, made private.\n+\t(gfc_arglist_matches_symbol): New method.\n+\t* interface.c (compare_actual_formal): Made static.\n+\t(gfc_procedure_use): Use new name of compare_actual_formal.\n+\t(gfc_arglist_matches_symbol): New method.\n+\t(gfc_search_interface): Moved code partially to new\n+\tgfc_arglist_matches_symbol.\n+\t* resolve.c (resolve_typebound_generic_call): Resolve actual arglist\n+\tbefore checking against formal and use new gfc_arglist_matches_symbol\n+\tfor checking.\n+\t(resolve_compcall): Set type-spec of generated expression.\n+\n 2008-09-23  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37580"}, {"sha": "4e9959ea5bbf8deb6d62c28ce1de6876cbdaf991", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -2517,8 +2517,7 @@ gfc_try gfc_add_interface (gfc_symbol *);\n gfc_interface *gfc_current_interface_head (void);\n void gfc_set_current_interface_head (gfc_interface *);\n gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n-int gfc_compare_actual_formal (gfc_actual_arglist**, gfc_formal_arglist*,\n-      \t\t\t       int, int, locus*);\n+bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "17f703312860ade1cc39b08cec5e063822fbf93e", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -1818,9 +1818,9 @@ has_vector_subscript (gfc_expr *e)\n    errors when things don't match instead of just returning the status\n    code.  */\n \n-int\n-gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n-      \t\t\t   int ranks_must_agree, int is_elemental, locus *where)\n+static int\n+compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n+\t \t       int ranks_must_agree, int is_elemental, locus *where)\n {\n   gfc_actual_arglist **new_arg, *a, *actual, temp;\n   gfc_formal_arglist *f;\n@@ -2448,8 +2448,7 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n       return;\n     }\n \n-  if (!gfc_compare_actual_formal (ap, sym->formal, 0,\n-\t\t  \t\t  sym->attr.elemental, where))\n+  if (!compare_actual_formal (ap, sym->formal, 0, sym->attr.elemental, where))\n     return;\n \n   check_intents (sym->formal, *ap);\n@@ -2458,6 +2457,30 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n }\n \n \n+/* Try if an actual argument list matches the formal list of a symbol,\n+   respecting the symbol's attributes like ELEMENTAL.  This is used for\n+   GENERIC resolution.  */\n+\n+bool\n+gfc_arglist_matches_symbol (gfc_actual_arglist** args, gfc_symbol* sym)\n+{\n+  bool r;\n+\n+  gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n+\n+  r = !sym->attr.elemental;\n+  if (compare_actual_formal (args, sym->formal, r, !r, NULL))\n+    {\n+      check_intents (sym->formal, *args);\n+      if (gfc_option.warn_aliasing)\n+\tcheck_some_aliasing (sym->formal, *args);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Given an interface pointer and an actual argument list, search for\n    a formal argument list that matches the actual.  If found, returns\n    a pointer to the symbol of the correct interface.  Returns NULL if\n@@ -2467,24 +2490,15 @@ gfc_symbol *\n gfc_search_interface (gfc_interface *intr, int sub_flag,\n \t\t      gfc_actual_arglist **ap)\n {\n-  int r;\n-\n   for (; intr; intr = intr->next)\n     {\n       if (sub_flag && intr->sym->attr.function)\n \tcontinue;\n       if (!sub_flag && intr->sym->attr.subroutine)\n \tcontinue;\n \n-      r = !intr->sym->attr.elemental;\n-\n-      if (gfc_compare_actual_formal (ap, intr->sym->formal, r, !r, NULL))\n-\t{\n-\t  check_intents (intr->sym->formal, *ap);\n-\t  if (gfc_option.warn_aliasing)\n-\t    check_some_aliasing (intr->sym->formal, *ap);\n-\t  return intr->sym;\n-\t}\n+      if (gfc_arglist_matches_symbol (ap, intr->sym))\n+\treturn intr->sym;\n     }\n \n   return NULL;"}, {"sha": "d682e10dd5aafe78331713bb4eb6c582558260f4", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -4510,10 +4510,11 @@ resolve_typebound_generic_call (gfc_expr* e)\n \n \t      args = update_arglist_pass (args, po, g->specific->pass_arg_num);\n \t    }\n+\t  resolve_actual_arglist (args, target->attr.proc,\n+\t\t\t\t  is_external_proc (target) && !target->formal);\n \n \t  /* Check if this arglist matches the formal.  */\n-\t  matches = gfc_compare_actual_formal (&args, target->formal, 1,\n-\t\t\t\t\t       target->attr.elemental, NULL);\n+\t  matches = gfc_arglist_matches_symbol (&args, target);\n \n \t  /* Clean up and break out of the loop if we've found it.  */\n \t  gfc_free_actual_arglist (args);\n@@ -4606,6 +4607,7 @@ resolve_compcall (gfc_expr* e)\n   e->value.function.isym = NULL;\n   e->value.function.esym = NULL;\n   e->symtree = target;\n+  e->ts = target->n.sym->ts;\n   e->expr_type = EXPR_FUNCTION;\n \n   return gfc_resolve_expr (e);"}, {"sha": "e3215bdf053ead9ef423f451801a457643396570", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -1,3 +1,9 @@\n+2008-09-23  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37588\n+\t* gfortran.dg/typebound_generic_4.f03: New test.\n+\t* gfortran.dg/typebound_generic_5.f03: New test.\n+\n 2008-09-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/pragma-init-fini.c: Use dg-warning in lieu of dg-error."}, {"sha": "edd62be0ccfa3e0fc37a36ad6c28a864e3d81d53", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_4.f03", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_4.f03?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do run }\n+\n+! FIXME: Remove -w once the TYPE/CLASS issue is resolved\n+! { dg-options \"-w\" }\n+\n+! PR fortran/37588\n+! This test used to not resolve the GENERIC binding.\n+\n+! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+\n+module bar_mod\n+\n+  type foo\n+    integer :: i\n+    \n+  contains\n+    procedure, pass(a) :: foo_v => foo_v_inner    \n+    procedure, pass(a) :: foo_m => foo_m_inner    \n+    generic, public    :: foo => foo_v, foo_m\n+  end type foo\n+  \n+  private foo_v_inner, foo_m_inner\n+\n+contains\n+  \n+  subroutine foo_v_inner(x,a)\n+    real :: x(:)\n+    type(foo) :: a\n+    \n+    a%i = int(x(1))\n+    WRITE (*,*) \"Vector\"\n+  end subroutine foo_v_inner\n+  \n+  subroutine foo_m_inner(x,a)\n+    real :: x(:,:)\n+    type(foo) :: a\n+    \n+    a%i = int(x(1,1))\n+    WRITE (*,*) \"Matrix\"\n+  end subroutine foo_m_inner\n+end module bar_mod\n+\n+program foobar\n+  use bar_mod\n+  type(foo) :: dat\n+  real :: x1(10), x2(10,10)\n+\n+  x1=1\n+  x2=2\n+ \n+  call dat%foo(x1)\n+  call dat%foo(x2)\n+\n+end program foobar\n+\n+! { dg-output \"Vector.*Matrix\" }\n+! { dg-final { cleanup-modules \"bar_mod\" } }"}, {"sha": "3fd94b154fb286a09af2345aa13cff56940993eb", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_5.f03", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ac18b79931a074b5bc88e0b64ea8ef84e40941/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_5.f03?ref=f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+\n+! Check that generic bindings targetting ELEMENTAL procedures work.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE :: t\n+  CONTAINS\n+    PROCEDURE, NOPASS :: double\n+    PROCEDURE, NOPASS :: double_here\n+    GENERIC :: double_it => double\n+    GENERIC :: double_inplace => double_here\n+  END TYPE t\n+\n+CONTAINS\n+\n+  ELEMENTAL INTEGER FUNCTION double (val)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(IN) :: val\n+    double = 2 * val\n+  END FUNCTION double\n+\n+  ELEMENTAL SUBROUTINE double_here (val)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(INOUT) :: val\n+    val = 2 * val\n+  END SUBROUTINE double_here\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m\n+  IMPLICIT NONE\n+\n+  TYPE(t) :: obj\n+  INTEGER :: arr(42), arr2(42), arr3(42), arr4(42)\n+  INTEGER :: i\n+\n+  arr = (/ (i, i = 1, 42) /)\n+\n+  arr2 = obj%double (arr)\n+  arr3 = obj%double_it (arr)\n+\n+  arr4 = arr\n+  CALL obj%double_inplace (arr4)\n+\n+  IF (ANY (arr2 /= 2 * arr) .OR. &\n+      ANY (arr3 /= 2 * arr) .OR. &\n+      ANY (arr4 /= 2 * arr)) THEN\n+    CALL abort ()\n+  END IF\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}