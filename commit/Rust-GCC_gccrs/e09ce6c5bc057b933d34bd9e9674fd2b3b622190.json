{"sha": "e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5Y2U2YzViYzA1N2I5MzNkMzRiZDllOTY3NGZkMmIzYjYyMjE5MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-19T04:23:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-19T04:23:00Z"}, "message": "Use backend interface for variables.\n\n\t* go-gcc.cc: Include \"go-c.h\".\n\t(class Bvariable): Define.\n\t(Gcc_backend::init_statement): New function.\n\t(Gcc_backend::global_variable): New function.\n\t(Gcc_backend::global_variable_set_init): New function.\n\t(Gcc_backend::local_variable): New function.\n\t(Gcc_backend::parameter_variable): New function.\n\t(tree_to_type, var_to_tree): New functions.\n\t* Make-lang.in (go/go-gcc.o): Depend on $(GO_C_H).\n\t* (go/gogo-tree.o): Depend on go/gofrontend/backend.h.\n\nFrom-SVN: r172693", "tree": {"sha": "fcc6b62b2ebb24bc22dd9b8f2c00e47b06854246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcc6b62b2ebb24bc22dd9b8f2c00e47b06854246"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/comments", "author": null, "committer": null, "parents": [{"sha": "61bd5ad845cd20d5afcb2ce4595d276246064c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61bd5ad845cd20d5afcb2ce4595d276246064c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61bd5ad845cd20d5afcb2ce4595d276246064c77"}], "stats": {"total": 794, "additions": 532, "deletions": 262}, "files": [{"sha": "141728ba7dc34685b1aab1c274356060c0881375", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -1,3 +1,16 @@\n+2011-04-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc: Include \"go-c.h\".\n+\t(class Bvariable): Define.\n+\t(Gcc_backend::init_statement): New function.\n+\t(Gcc_backend::global_variable): New function.\n+\t(Gcc_backend::global_variable_set_init): New function.\n+\t(Gcc_backend::local_variable): New function.\n+\t(Gcc_backend::parameter_variable): New function.\n+\t(tree_to_type, var_to_tree): New functions.\n+\t* Make-lang.in (go/go-gcc.o): Depend on $(GO_C_H).\n+\t* (go/gogo-tree.o): Depend on go/gofrontend/backend.h.\n+\n 2011-04-15  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::compound_statement): New function."}, {"sha": "c0b279d35137ce17f48400c29819aed4c9c11ce4", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -239,7 +239,7 @@ go/go-lang.o: go/go-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n GOINCLUDES = -I $(srcdir)/go -I $(srcdir)/go/gofrontend\n \n go/go-gcc.o: go/go-gcc.cc $(GO_SYSTEM_H) $(TREE_H) tree-iterator.h \\\n-\t\t$(GIMPLE_H) $(GO_GOGO_H) go/gofrontend/backend.h\n+\t\t$(GIMPLE_H) $(GO_C_H) $(GO_GOGO_H) go/gofrontend/backend.h\n \t$(CXX) -c $(GOINCLUDES) $(ALL_CPPFLAGS) $(ALL_CXXFLAGS) $< $(OUTPUT_OPTION)\n \n go/%.o: go/gofrontend/%.cc\n@@ -262,7 +262,8 @@ go/go-dump.o: go/gofrontend/go-dump.cc $(GO_SYSTEM_H) $(GO_C_H) \\\n go/gogo-tree.o: go/gofrontend/gogo-tree.cc $(GO_SYSTEM_H) $(TOPLEV_H) \\\n \t$(TREE_H) $(GIMPLE_H) tree-iterator.h $(CGRAPH_H) langhooks.h \\\n \tconvert.h output.h $(DIAGNOSTIC_H) $(GO_TYPES_H) \\\n-\t$(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) $(GO_RUNTIME_H) $(GO_GOGO_H)\n+\t$(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) $(GO_RUNTIME_H) \\\n+\tgo/gofrontend/backend.h $(GO_GOGO_H)\n go/gogo.o: go/gofrontend/gogo.cc $(GO_SYSTEM_H) $(GO_C_H) \\\n \tgo/gofrontend/go-dump.h $(GO_LEX_H) $(GO_TYPES_H) $(GO_STATEMENTS_H) \\\n \t$(GO_EXPRESSIONS_H) go/gofrontend/dataflow.h $(GO_RUNTIME_H) \\"}, {"sha": "e4f4cfcd9515de672f2a306facc08768d554a60c", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -37,6 +37,8 @@ extern \"C\"\n }\n #endif\n \n+#include \"go-c.h\"\n+\n #include \"gogo.h\"\n #include \"backend.h\"\n \n@@ -90,6 +92,14 @@ class Bfunction : public Gcc_tree\n   { }\n };\n \n+class Bvariable : public Gcc_tree\n+{\n+ public:\n+  Bvariable(tree t)\n+    : Gcc_tree(t)\n+  { }\n+};\n+\n class Blabel : public Gcc_tree\n {\n  public:\n@@ -173,6 +183,9 @@ class Gcc_backend : public Backend\n   Bstatement*\n   expression_statement(Bexpression*);\n \n+  Bstatement*\n+  init_statement(Bvariable* var, Bexpression* init);\n+\n   Bstatement*\n   assignment_statement(Bexpression* lhs, Bexpression* rhs, source_location);\n \n@@ -196,6 +209,32 @@ class Gcc_backend : public Backend\n   Bstatement*\n   statement_list(const std::vector<Bstatement*>&);\n \n+  // Variables.\n+\n+  Bvariable*\n+  error_variable()\n+  { return new Bvariable(error_mark_node); }\n+\n+  Bvariable*\n+  global_variable(const std::string& package_name,\n+\t\t  const std::string& unique_prefix,\n+\t\t  const std::string& name,\n+\t\t  Btype* btype,\n+\t\t  bool is_external,\n+\t\t  bool is_hidden,\n+\t\t  source_location location);\n+\n+  void\n+  global_variable_set_init(Bvariable*, Bexpression*);\n+\n+  Bvariable*\n+  local_variable(Bfunction*, const std::string& name, Btype* type,\n+\t\t source_location);\n+\n+  Bvariable*\n+  parameter_variable(Bfunction*, const std::string& name, Btype* type,\n+\t\t     source_location);\n+\n   // Labels.\n \n   Blabel*\n@@ -238,6 +277,21 @@ Gcc_backend::expression_statement(Bexpression* expr)\n   return this->make_statement(expr->get_tree());\n }\n \n+// Variable initialization.\n+\n+Bstatement*\n+Gcc_backend::init_statement(Bvariable* var, Bexpression* init)\n+{\n+  tree var_tree = var->get_tree();\n+  tree init_tree = init->get_tree();\n+  if (var_tree == error_mark_node || init_tree == error_mark_node)\n+    return this->error_statement();\n+  gcc_assert(TREE_CODE(var_tree) == VAR_DECL);\n+  DECL_INITIAL(var_tree) = init_tree;\n+  return this->make_statement(build1_loc(DECL_SOURCE_LOCATION(var_tree),\n+\t\t\t\t\t DECL_EXPR, void_type_node, var_tree));\n+}\n+\n // Assignment.\n \n Bstatement*\n@@ -427,6 +481,99 @@ Gcc_backend::statement_list(const std::vector<Bstatement*>& statements)\n   return this->make_statement(stmt_list);\n }\n \n+// Make a global variable.\n+\n+Bvariable*\n+Gcc_backend::global_variable(const std::string& package_name,\n+\t\t\t     const std::string& unique_prefix,\n+\t\t\t     const std::string& name,\n+\t\t\t     Btype* btype,\n+\t\t\t     bool is_external,\n+\t\t\t     bool is_hidden,\n+\t\t\t     source_location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+\n+  std::string var_name(package_name);\n+  var_name.push_back('.');\n+  var_name.append(name);\n+  tree decl = build_decl(location, VAR_DECL,\n+\t\t\t get_identifier_from_string(var_name),\n+\t\t\t type_tree);\n+  if (is_external)\n+    DECL_EXTERNAL(decl) = 1;\n+  else\n+    TREE_STATIC(decl) = 1;\n+  if (!is_hidden)\n+    {\n+      TREE_PUBLIC(decl) = 1;\n+\n+      std::string asm_name(unique_prefix);\n+      asm_name.push_back('.');\n+      asm_name.append(var_name);\n+      SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(asm_name));\n+    }\n+  TREE_USED(decl) = 1;\n+\n+  go_preserve_from_gc(decl);\n+\n+  return new Bvariable(decl);\n+}\n+\n+// Set the initial value of a global variable.\n+\n+void\n+Gcc_backend::global_variable_set_init(Bvariable* var, Bexpression* expr)\n+{\n+  tree expr_tree = expr->get_tree();\n+  if (expr_tree == error_mark_node)\n+    return;\n+  gcc_assert(TREE_CONSTANT(expr_tree));\n+  tree var_decl = var->get_tree();\n+  if (var_decl == error_mark_node)\n+    return;\n+  DECL_INITIAL(var_decl) = expr_tree;\n+}\n+\n+// Make a local variable.\n+\n+Bvariable*\n+Gcc_backend::local_variable(Bfunction* function, const std::string& name,\n+\t\t\t    Btype* btype, source_location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+  tree decl = build_decl(location, VAR_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t type_tree);\n+  DECL_CONTEXT(decl) = function->get_tree();\n+  TREE_USED(decl) = 1;\n+  go_preserve_from_gc(decl);\n+  return new Bvariable(decl);\n+}\n+\n+// Make a function parameter variable.\n+\n+Bvariable*\n+Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n+\t\t\t\tBtype* btype, source_location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+  tree decl = build_decl(location, PARM_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t type_tree);\n+  DECL_CONTEXT(decl) = function->get_tree();\n+  DECL_ARG_TYPE(decl) = type_tree;\n+  TREE_USED(decl) = 1;\n+  go_preserve_from_gc(decl);\n+  return new Bvariable(decl);\n+}\n+\n // Make a label.\n \n Blabel*\n@@ -494,6 +641,12 @@ go_get_backend()\n // FIXME: Temporary functions while converting to the new backend\n // interface.\n \n+Btype*\n+tree_to_type(tree t)\n+{\n+  return new Btype(t);\n+}\n+\n Bexpression*\n tree_to_expr(tree t)\n {\n@@ -523,3 +676,9 @@ stat_to_tree(Bstatement* bs)\n {\n   return bs->get_tree();\n }\n+\n+tree\n+var_to_tree(Bvariable* bv)\n+{\n+  return bv->get_tree();\n+}"}, {"sha": "3e4c6291fd62d8a6d7677ffc2257b88cabde3b09", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -27,6 +27,9 @@ class Bstatement;\n // The backend representation of a function definition.\n class Bfunction;\n \n+// The backend representation of a variable.\n+class Bvariable;\n+\n // The backend representation of a label.\n class Blabel;\n \n@@ -117,6 +120,12 @@ class Backend\n   virtual Bstatement*\n   expression_statement(Bexpression*) = 0;\n \n+  // Create a variable initialization statement.  This initializes a\n+  // local variable at the point in the program flow where it is\n+  // declared.\n+  virtual Bstatement*\n+  init_statement(Bvariable* var, Bexpression* init) = 0;\n+\n   // Create an assignment statement.\n   virtual Bstatement*\n   assignment_statement(Bexpression* lhs, Bexpression* rhs,\n@@ -154,6 +163,57 @@ class Backend\n   virtual Bstatement*\n   statement_list(const std::vector<Bstatement*>&) = 0;\n \n+  // Variables.\n+\n+  // Create an error variable.  This is used for cases which should\n+  // not occur in a correct program, in order to keep the compilation\n+  // going without crashing.\n+  virtual Bvariable*\n+  error_variable() = 0;\n+\n+  // Create a global variable.  PACKAGE_NAME is the name of the\n+  // package where the variable is defined.  UNIQUE_PREFIX is the\n+  // prefix for that package, from the -fgo-prefix option.  NAME is\n+  // the name of the variable.  BTYPE is the type of the variable.\n+  // IS_EXTERNAL is true if the variable is defined in some other\n+  // package.  IS_HIDDEN is true if the variable is not exported (name\n+  // begins with a lower case letter).  LOCATION is where the variable\n+  // was defined.\n+  virtual Bvariable*\n+  global_variable(const std::string& package_name,\n+\t\t  const std::string& unique_prefix,\n+\t\t  const std::string& name,\n+\t\t  Btype* btype,\n+\t\t  bool is_external,\n+\t\t  bool is_hidden,\n+\t\t  source_location location) = 0;\n+\n+  // A global variable will 1) be initialized to zero, or 2) be\n+  // initialized to a constant value, or 3) be initialized in the init\n+  // function.  In case 2, the frontend will call\n+  // global_variable_set_init to set the initial value.  If this is\n+  // not called, the backend should initialize a global variable to 0.\n+  // The init function may then assign a value to it.\n+  virtual void\n+  global_variable_set_init(Bvariable*, Bexpression*) = 0;\n+\n+  // Create a local variable.  The frontend will create the local\n+  // variables first, and then create the block which contains them.\n+  // FUNCTION is the function in which the variable is defined.  NAME\n+  // is the name of the variable.  TYPE is the type.  LOCATION is\n+  // where the variable is defined.  For each local variable the\n+  // frontend will call init_statement to set the initial value.\n+  virtual Bvariable*\n+  local_variable(Bfunction* function, const std::string& name, Btype* type,\n+\t\t source_location location) = 0;\n+\n+  // Create a function parameter.  This is an incoming parameter, not\n+  // a result parameter (result parameters are treated as local\n+  // variables).  The arguments are as for local_variable.\n+  virtual Bvariable*\n+  parameter_variable(Bfunction* function, const std::string& name,\n+\t\t     Btype* type, source_location location) = 0;\n+\n   // Labels.\n   \n   // Create a new label.  NAME will be empty if this is a label\n@@ -186,10 +246,12 @@ extern Backend* go_get_backend();\n // FIXME: Temporary helper functions while converting to new backend\n // interface.\n \n+extern Btype* tree_to_type(tree);\n extern Bexpression* tree_to_expr(tree);\n extern Bstatement* tree_to_stat(tree);\n extern Bfunction* tree_to_function(tree);\n extern tree expr_to_tree(Bexpression*);\n extern tree stat_to_tree(Bstatement*);\n+extern tree var_to_tree(Bvariable*);\n \n #endif // !defined(GO_BACKEND_H)"}, {"sha": "9adcbc33b6559f3cbc8ea034f4957d8c1c25bfcd", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -972,7 +972,24 @@ Var_expression::do_address_taken(bool escapes)\n tree\n Var_expression::do_get_tree(Translate_context* context)\n {\n-  return this->variable_->get_tree(context->gogo(), context->function());\n+  Bvariable* bvar = this->variable_->get_backend_variable(context->gogo(),\n+\t\t\t\t\t\t\t  context->function());\n+  tree ret = var_to_tree(bvar);\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n+  bool is_in_heap;\n+  if (this->variable_->is_variable())\n+    is_in_heap = this->variable_->var_value()->is_in_heap();\n+  else if (this->variable_->is_result_variable())\n+    is_in_heap = this->variable_->result_var_value()->is_in_heap();\n+  else\n+    gcc_unreachable();\n+  if (is_in_heap)\n+    {\n+      ret = build_fold_indirect_ref_loc(this->location(), ret);\n+      TREE_THIS_NOTRAP(ret) = 1;\n+    }\n+  return ret;\n }\n \n // Make a reference to a variable in an expression."}, {"sha": "a59076e8257ba43cc61019db22106b49c36e136d", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 102, "deletions": 224, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -32,6 +32,7 @@ extern \"C\"\n #include \"expressions.h\"\n #include \"statements.h\"\n #include \"runtime.h\"\n+#include \"backend.h\"\n #include \"gogo.h\"\n \n // Whether we have seen any errors.\n@@ -277,7 +278,8 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n       constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n       tree field = TYPE_FIELDS(root_type);\n       elt->index = field;\n-      tree decl = (*p)->get_tree(this, NULL);\n+      Bvariable* bvar = (*p)->get_backend_variable(this, NULL);\n+      tree decl = var_to_tree(bvar);\n       gcc_assert(TREE_CODE(decl) == VAR_DECL);\n       elt->value = build_fold_addr_expr(decl);\n \n@@ -704,24 +706,31 @@ Gogo::write_globals()\n \t    }\n \t}\n \n-      vec[i] = no->get_tree(this, NULL);\n-\n-      if (vec[i] == error_mark_node)\n+      if (!no->is_variable())\n \t{\n-\t  gcc_assert(saw_errors());\n-\t  --i;\n-\t  --count;\n-\t  continue;\n+\t  vec[i] = no->get_tree(this, NULL);\n+\t  if (vec[i] == error_mark_node)\n+\t    {\n+\t      gcc_assert(saw_errors());\n+\t      --i;\n+\t      --count;\n+\t      continue;\n+\t    }\n \t}\n-\n-      // If a variable is initialized to a non-constant value, do the\n-      // initialization in an initialization function.\n-      if (TREE_CODE(vec[i]) == VAR_DECL)\n+      else\n \t{\n-\t  gcc_assert(no->is_variable());\n+\t  Bvariable* var = no->get_backend_variable(this, NULL);\n+\t  vec[i] = var_to_tree(var);\n+\t  if (vec[i] == error_mark_node)\n+\t    {\n+\t      gcc_assert(saw_errors());\n+\t      --i;\n+\t      --count;\n+\t      continue;\n+\t    }\n \n-\t  // Check for a sink variable, which may be used to run\n-\t  // an initializer purely for its side effects.\n+\t  // Check for a sink variable, which may be used to run an\n+\t  // initializer purely for its side effects.\n \t  bool is_sink = no->name()[0] == '_' && no->name()[1] == '.';\n \n \t  tree var_init_tree = NULL_TREE;\n@@ -733,7 +742,8 @@ Gogo::write_globals()\n \t      else if (init == NULL_TREE)\n \t\t;\n \t      else if (TREE_CONSTANT(init))\n-\t\tDECL_INITIAL(vec[i]) = init;\n+\t\tthis->backend()->global_variable_set_init(var,\n+\t\t\t\t\t\t\t  tree_to_expr(init));\n \t      else if (is_sink)\n \t\tvar_init_tree = init;\n \t      else\n@@ -828,16 +838,15 @@ Gogo::write_globals()\n tree\n Named_object::get_id(Gogo* gogo)\n {\n+  gcc_assert(!this->is_variable() && !this->is_result_variable());\n   std::string decl_name;\n   if (this->is_function_declaration()\n       && !this->func_declaration_value()->asm_name().empty())\n     decl_name = this->func_declaration_value()->asm_name();\n-  else if ((this->is_variable() && !this->var_value()->is_global())\n-\t   || (this->is_type()\n-\t       && this->type_value()->location() == BUILTINS_LOCATION))\n+  else if (this->is_type()\n+\t   && this->type_value()->location() == BUILTINS_LOCATION)\n     {\n-      // We don't need the package name for local variables or builtin\n-      // types.\n+      // We don't need the package name for builtin types.\n       decl_name = Gogo::unpack_hidden_name(this->name_);\n     }\n   else\n@@ -878,22 +887,7 @@ tree\n Named_object::get_tree(Gogo* gogo, Named_object* function)\n {\n   if (this->tree_ != NULL_TREE)\n-    {\n-      // If this is a variable whose address is taken, we must rebuild\n-      // the INDIRECT_REF each time to avoid invalid sharing.\n-      tree ret = this->tree_;\n-      if (((this->classification_ == NAMED_OBJECT_VAR\n-\t    && this->var_value()->is_in_heap())\n-\t   || (this->classification_ == NAMED_OBJECT_RESULT_VAR\n-\t       && this->result_var_value()->is_in_heap()))\n-\t  && ret != error_mark_node)\n-\t{\n-\t  gcc_assert(TREE_CODE(ret) == INDIRECT_REF);\n-\t  ret = build_fold_indirect_ref(TREE_OPERAND(ret, 0));\n-\t  TREE_THIS_NOTRAP(ret) = 1;\n-\t}\n-      return ret;\n-    }\n+    return this->tree_;\n \n   tree name;\n   if (this->classification_ == NAMED_OBJECT_TYPE)\n@@ -976,117 +970,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n       return error_mark_node;\n \n     case NAMED_OBJECT_VAR:\n-      {\n-\tVariable* var = this->u_.var_value;\n-\tType* type = var->type();\n-\tif (type->is_error_type()\n-\t    || (type->is_undefined()\n-\t\t&& (!var->is_global() || this->package() == NULL)))\n-\t  {\n-\t    // Force the error for an undefined type, just in case.\n-\t    type->base();\n-\t    decl = error_mark_node;\n-\t  }\n-\telse\n-\t  {\n-\t    tree var_type = type->get_tree(gogo);\n-\t    bool is_parameter = var->is_parameter();\n-\t    if (var->is_receiver() && type->points_to() == NULL)\n-\t      is_parameter = false;\n-\t    if (var->is_in_heap())\n-\t      {\n-\t\tis_parameter = false;\n-\t\tvar_type = build_pointer_type(var_type);\n-\t      }\n-\t    decl = build_decl(var->location(),\n-\t\t\t      is_parameter ? PARM_DECL : VAR_DECL,\n-\t\t\t      name, var_type);\n-\t    if (!var->is_global())\n-\t      {\n-\t\ttree fnid = function->get_id(gogo);\n-\t\ttree fndecl = function->func_value()->get_or_make_decl(gogo,\n-\t\t\t\t\t\t\t\t       function,\n-\t\t\t\t\t\t\t\t       fnid);\n-\t\tDECL_CONTEXT(decl) = fndecl;\n-\t      }\n-\t    if (is_parameter)\n-\t      DECL_ARG_TYPE(decl) = TREE_TYPE(decl);\n-\n-\t    if (var->is_global())\n-\t      {\n-\t\tconst Package* package = this->package();\n-\t\tif (package == NULL)\n-\t\t  TREE_STATIC(decl) = 1;\n-\t\telse\n-\t\t  DECL_EXTERNAL(decl) = 1;\n-\t\tif (!Gogo::is_hidden_name(this->name_))\n-\t\t  {\n-\t\t    TREE_PUBLIC(decl) = 1;\n-\t\t    std::string asm_name = (package == NULL\n-\t\t\t\t\t    ? gogo->unique_prefix()\n-\t\t\t\t\t    : package->unique_prefix());\n-\t\t    asm_name.append(1, '.');\n-\t\t    asm_name.append(IDENTIFIER_POINTER(name),\n-\t\t\t\t    IDENTIFIER_LENGTH(name));\n-\t\t    tree asm_id = get_identifier_from_string(asm_name);\n-\t\t    SET_DECL_ASSEMBLER_NAME(decl, asm_id);\n-\t\t  }\n-\t      }\n-\n-\t    // FIXME: We should only set this for variables which are\n-\t    // actually used somewhere.\n-\t    TREE_USED(decl) = 1;\n-\t  }\n-      }\n-      break;\n-\n     case NAMED_OBJECT_RESULT_VAR:\n-      {\n-\tResult_variable* result = this->u_.result_var_value;\n-\tType* type = result->type();\n-\tif (type->is_error())\n-\t  decl = error_mark_node;\n-\telse\n-\t  {\n-\t    gcc_assert(result->function() == function->func_value());\n-\t    source_location loc = function->location();\n-\t    tree result_type = type->get_tree(gogo);\n-\t    tree init;\n-\t    if (!result->is_in_heap())\n-\t      init = type->get_init_tree(gogo, false);\n-\t    else\n-\t      {\n-\t\ttree space = gogo->allocate_memory(type,\n-\t\t\t\t\t\t   TYPE_SIZE_UNIT(result_type),\n-\t\t\t\t\t\t   loc);\n-\t\tresult_type = build_pointer_type(result_type);\n-\t\ttree subinit = type->get_init_tree(gogo, true);\n-\t\tif (subinit == NULL_TREE)\n-\t\t  init = fold_convert_loc(loc, result_type, space);\n-\t\telse\n-\t\t  {\n-\t\t    space = save_expr(space);\n-\t\t    space = fold_convert_loc(loc, result_type, space);\n-\t\t    tree spaceref = build_fold_indirect_ref_loc(loc, space);\n-\t\t    TREE_THIS_NOTRAP(spaceref) = 1;\n-\t\t    tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n-\t\t\t\t\t       spaceref, subinit);\n-\t\t    init = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(space),\n-\t\t\t\t\t   set, space);\n-\t\t  }\n-\t      }\n-\t    decl = build_decl(loc, VAR_DECL, name, result_type);\n-\t    tree fnid = function->get_id(gogo);\n-\t    tree fndecl = function->func_value()->get_or_make_decl(gogo,\n-\t\t\t\t\t\t\t\t   function,\n-\t\t\t\t\t\t\t\t   fnid);\n-\t    DECL_CONTEXT(decl) = fndecl;\n-\t    DECL_INITIAL(decl) = init;\n-\t    TREE_USED(decl) = 1;\n-\t  }\n-      }\n-      break;\n-\n     case NAMED_OBJECT_SINK:\n       gcc_unreachable();\n \n@@ -1129,20 +1013,6 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \n   tree ret = decl;\n \n-  // If this is a local variable whose address is taken, then we\n-  // actually store it in the heap.  For uses of the variable we need\n-  // to return a reference to that heap location.\n-  if (((this->classification_ == NAMED_OBJECT_VAR\n-\t&& this->var_value()->is_in_heap())\n-       || (this->classification_ == NAMED_OBJECT_RESULT_VAR\n-\t   && this->result_var_value()->is_in_heap()))\n-      && ret != error_mark_node)\n-    {\n-      gcc_assert(POINTER_TYPE_P(TREE_TYPE(ret)));\n-      ret = build_fold_indirect_ref(ret);\n-      TREE_THIS_NOTRAP(ret) = 1;\n-    }\n-\n   this->tree_ = ret;\n \n   if (ret != error_mark_node)\n@@ -1162,7 +1032,9 @@ Variable::get_init_tree(Gogo* gogo, Named_object* function)\n   if (this->init_ == NULL)\n     {\n       gcc_assert(!this->is_parameter_);\n-      return this->type_->get_init_tree(gogo, this->is_global_);\n+      return this->type_->get_init_tree(gogo,\n+\t\t\t\t\t(this->is_global_\n+\t\t\t\t\t || this->is_in_heap()));\n     }\n   else\n     {\n@@ -1301,7 +1173,9 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t    {\n \t      push_struct_function(decl);\n \n-\t      tree closure_decl = this->closure_var_->get_tree(gogo, no);\n+\t      Bvariable* bvar = this->closure_var_->get_backend_variable(gogo,\n+\t\t\t\t\t\t\t\t\t no);\n+\t      tree closure_decl = var_to_tree(bvar);\n \t      if (closure_decl == error_mark_node)\n \t\tthis->fndecl_ = error_mark_node;\n \t      else\n@@ -1384,26 +1258,15 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n {\n   if (var_decl == error_mark_node)\n     return error_mark_node;\n-  // If the function takes the address of a receiver which is passed\n-  // by value, then we will have an INDIRECT_REF here.  We need to get\n-  // the real variable.\n+  gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+  tree val_type = TREE_TYPE(var_decl);\n   bool is_in_heap = no->var_value()->is_in_heap();\n-  tree val_type;\n-  if (TREE_CODE(var_decl) != INDIRECT_REF)\n-    {\n-      gcc_assert(!is_in_heap);\n-      val_type = TREE_TYPE(var_decl);\n-    }\n-  else\n+  if (is_in_heap)\n     {\n-      gcc_assert(is_in_heap);\n-      var_decl = TREE_OPERAND(var_decl, 0);\n-      if (var_decl == error_mark_node)\n-\treturn error_mark_node;\n-      gcc_assert(POINTER_TYPE_P(TREE_TYPE(var_decl)));\n-      val_type = TREE_TYPE(TREE_TYPE(var_decl));\n+      gcc_assert(POINTER_TYPE_P(val_type));\n+      val_type = TREE_TYPE(val_type);\n     }\n-  gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+\n   source_location loc = DECL_SOURCE_LOCATION(var_decl);\n   std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n   name += \".pointer\";\n@@ -1456,14 +1319,8 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n // indirection.\n \n tree\n-Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree ref)\n+Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n {\n-  if (ref == error_mark_node)\n-    return error_mark_node;\n-\n-  gcc_assert(TREE_CODE(ref) == INDIRECT_REF);\n-\n-  tree var_decl = TREE_OPERAND(ref, 0);\n   if (var_decl == error_mark_node)\n     return error_mark_node;\n   gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n@@ -1514,7 +1371,8 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n     {\n       if ((*p)->is_variable() && (*p)->var_value()->is_parameter())\n \t{\n-\t  *pp = (*p)->get_tree(gogo, named_function);\n+\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n+\t  *pp = var_to_tree(bvar);\n \n \t  // We always pass the receiver to a method as a pointer.  If\n \t  // the receiver is declared as a non-pointer type, then we\n@@ -1524,8 +1382,6 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t    {\n \t      tree parm_decl = this->make_receiver_parm_decl(gogo, *p, *pp);\n \t      tree var = *pp;\n-\t      if (TREE_CODE(var) == INDIRECT_REF)\n-\t\tvar = TREE_OPERAND(var, 0);\n \t      if (var != error_mark_node)\n \t\t{\n \t\t  gcc_assert(TREE_CODE(var) == VAR_DECL);\n@@ -1539,16 +1395,12 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t      // If we take the address of a parameter, then we need\n \t      // to copy it into the heap.\n \t      tree parm_decl = this->copy_parm_to_heap(gogo, *p, *pp);\n-\t      if (*pp != error_mark_node)\n+\t      tree var = *pp;\n+\t      if (var != error_mark_node)\n \t\t{\n-\t\t  gcc_assert(TREE_CODE(*pp) == INDIRECT_REF);\n-\t\t  tree var_decl = TREE_OPERAND(*pp, 0);\n-\t\t  if (var_decl != error_mark_node)\n-\t\t    {\n-\t\t      gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n-\t\t      DECL_CHAIN(var_decl) = declare_vars;\n-\t\t      declare_vars = var_decl;\n-\t\t    }\n+\t\t  gcc_assert(TREE_CODE(var) == VAR_DECL);\n+\t\t  DECL_CHAIN(var) = declare_vars;\n+\t\t  declare_vars = var;\n \t\t}\n \t      *pp = parm_decl;\n \t    }\n@@ -1561,16 +1413,41 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t}\n       else if ((*p)->is_result_variable())\n \t{\n-\t  tree var_decl = (*p)->get_tree(gogo, named_function);\n-\t  if (var_decl != error_mark_node\n-\t      && (*p)->result_var_value()->is_in_heap())\n+\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n+\t  tree var_decl = var_to_tree(bvar);\n+\n+\t  Type* type = (*p)->result_var_value()->type();\n+\t  tree init;\n+\t  if (!(*p)->result_var_value()->is_in_heap())\n+\t    init = type->get_init_tree(gogo, false);\n+\t  else\n \t    {\n-\t      gcc_assert(TREE_CODE(var_decl) == INDIRECT_REF);\n-\t      var_decl = TREE_OPERAND(var_decl, 0);\n+\t      source_location loc = (*p)->location();\n+\t      tree type_tree = type->get_tree(gogo);\n+\t      tree space = gogo->allocate_memory(type,\n+\t\t\t\t\t\t TYPE_SIZE_UNIT(type_tree),\n+\t\t\t\t\t\t loc);\n+\t      tree ptr_type_tree = build_pointer_type(type_tree);\n+\t      tree subinit = type->get_init_tree(gogo, true);\n+\t      if (subinit == NULL_TREE)\n+\t\tinit = fold_convert_loc(loc, ptr_type_tree, space);\n+\t      else\n+\t\t{\n+\t\t  space = save_expr(space);\n+\t\t  space = fold_convert_loc(loc, ptr_type_tree, space);\n+\t\t  tree spaceref = build_fold_indirect_ref_loc(loc, space);\n+\t\t  TREE_THIS_NOTRAP(spaceref) = 1;\n+\t\t  tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n+\t\t\t\t\t     spaceref, subinit);\n+\t\t  init = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(space),\n+\t\t\t\t\t set, space);\n+\t\t}\n \t    }\n+\n \t  if (var_decl != error_mark_node)\n \t    {\n \t      gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+\t      DECL_INITIAL(var_decl) = init;\n \t      DECL_CHAIN(var_decl) = declare_vars;\n \t      declare_vars = var_decl;\n \t    }\n@@ -1769,7 +1646,15 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n \n   tree retval;\n   if (results->size() == 1)\n-    return this->results_->front()->get_tree(gogo, named_function);\n+    {\n+      Bvariable* bvar =\n+\tthis->results_->front()->get_backend_variable(gogo,\n+\t\t\t\t\t\t      named_function);\n+      tree ret = var_to_tree(bvar);\n+      if (this->results_->front()->result_var_value()->is_in_heap())\n+\tret = build_fold_indirect_ref_loc(location, ret);\n+      return ret;\n+    }\n   else\n     {\n       tree rettype = TREE_TYPE(DECL_RESULT(this->fndecl_));\n@@ -1781,8 +1666,11 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n \t   ++pr, ++index, field = DECL_CHAIN(field))\n \t{\n \t  gcc_assert(field != NULL);\n-\t  tree val;\n-\t  val = (*this->results_)[index]->get_tree(gogo, named_function);\n+\t  Named_object* no = (*this->results_)[index];\n+\t  Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n+\t  tree val = var_to_tree(bvar);\n+\t  if (no->result_var_value()->is_in_heap())\n+\t    val = build_fold_indirect_ref_loc(location, val);\n \t  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n \t\t\t\t     build3(COMPONENT_REF, TREE_TYPE(field),\n \t\t\t\t\t    retval, field, NULL_TREE),\n@@ -1847,28 +1735,18 @@ Block::get_tree(Translate_context* context)\n        pv != this->bindings_->end_definitions();\n        ++pv)\n     {\n-      if ((!(*pv)->is_variable() || !(*pv)->var_value()->is_parameter())\n-\t  && !(*pv)->is_result_variable()\n-\t  && !(*pv)->is_const())\n+      if ((*pv)->is_variable() && !(*pv)->var_value()->is_parameter())\n \t{\n-\t  tree var = (*pv)->get_tree(gogo, context->function());\n-\t  if (var != error_mark_node && TREE_TYPE(var) != error_mark_node)\n-\t    {\n-\t      if ((*pv)->is_variable() && (*pv)->var_value()->is_in_heap())\n-\t\t{\n-\t\t  gcc_assert(TREE_CODE(var) == INDIRECT_REF);\n-\t\t  var = TREE_OPERAND(var, 0);\n-\t\t  gcc_assert(TREE_CODE(var) == VAR_DECL);\n-\t\t}\n-\t      *pp = var;\n-\t      pp = &DECL_CHAIN(*pp);\n-\t    }\n+\t  Bvariable* var = (*pv)->get_backend_variable(gogo,\n+\t\t\t\t\t\t       context->function());\n+\t  *pp = var_to_tree(var);\n+\t  if (*pp != error_mark_node)\n+\t    pp = &DECL_CHAIN(*pp);\n \t}\n     }\n   *pp = NULL_TREE;\n \n-  Translate_context subcontext(context->gogo(), context->function(),\n-\t\t\t       this, block);\n+  Translate_context subcontext(gogo, context->function(), this, block);\n \n   tree statements = NULL_TREE;\n "}, {"sha": "8f0d3288694dd26e6635bb5bc87b4f77a8915aaf", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 106, "deletions": 3, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -2659,7 +2659,8 @@ Function::create_result_variables(Gogo* gogo)\n \t  ++result_counter;\n \t  name = gogo->pack_hidden_name(buf, false);\n \t}\n-      Result_variable* result = new Result_variable(p->type(), this, index);\n+      Result_variable* result = new Result_variable(p->type(), this, index,\n+\t\t\t\t\t\t    p->location());\n       Named_object* no = block->bindings()->add_result_variable(name, result);\n       if (no->is_result_variable())\n \tthis->results_->push_back(no);\n@@ -3290,7 +3291,7 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n \t\t   bool is_parameter, bool is_receiver,\n \t\t   source_location location)\n   : type_(type), init_(init), preinit_(NULL), location_(location),\n-    is_global_(is_global), is_parameter_(is_parameter),\n+    backend_(NULL), is_global_(is_global), is_parameter_(is_parameter),\n     is_receiver_(is_receiver), is_varargs_parameter_(false),\n     is_address_taken_(false), seen_(false), init_is_lowered_(false),\n     type_from_init_tuple_(false), type_from_range_index_(false),\n@@ -3636,6 +3637,93 @@ Variable::import_var(Import* imp, std::string* pname, Type** ptype)\n   imp->require_c_string(\";\\n\");\n }\n \n+// Convert a variable to the backend representation.\n+\n+Bvariable*\n+Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n+\t\t\t       const Package* package, const std::string& name)\n+{\n+  if (this->backend_ == NULL)\n+    {\n+      Backend* backend = gogo->backend();\n+      Type* type = this->type_;\n+      if (type->is_error_type()\n+\t  || (type->is_undefined()\n+\t      && (!this->is_global_ || package == NULL)))\n+\tthis->backend_ = backend->error_variable();\n+      else\n+\t{\n+\t  bool is_parameter = this->is_parameter_;\n+\t  if (this->is_receiver_ && type->points_to() == NULL)\n+\t    is_parameter = false;\n+\t  if (this->is_in_heap())\n+\t    {\n+\t      is_parameter = false;\n+\t      type = Type::make_pointer_type(type);\n+\t    }\n+\n+\t  std::string n = Gogo::unpack_hidden_name(name);\n+\t  Btype* btype = tree_to_type(type->get_tree(gogo));\n+\n+\t  Bvariable* bvar;\n+\t  if (this->is_global_)\n+\t    bvar = backend->global_variable((package == NULL\n+\t\t\t\t\t     ? gogo->package_name()\n+\t\t\t\t\t     : package->name()),\n+\t\t\t\t\t    (package == NULL\n+\t\t\t\t\t     ? gogo->unique_prefix()\n+\t\t\t\t\t     : package->unique_prefix()),\n+\t\t\t\t\t    n,\n+\t\t\t\t\t    btype,\n+\t\t\t\t\t    package != NULL,\n+\t\t\t\t\t    Gogo::is_hidden_name(name),\n+\t\t\t\t\t    this->location_);\n+\t  else\n+\t    {\n+\t      tree fndecl = function->func_value()->get_decl();\n+\t      Bfunction* bfunction = tree_to_function(fndecl);\n+\t      if (is_parameter)\n+\t\tbvar = backend->parameter_variable(bfunction, n, btype,\n+\t\t\t\t\t\t   this->location_);\n+\t      else\n+\t\tbvar = backend->local_variable(bfunction, n, btype,\n+\t\t\t\t\t       this->location_);\n+\t    }\n+\t  this->backend_ = bvar;\n+\t}\n+    }\n+  return this->backend_;\n+}\n+\n+// Class Result_variable.\n+\n+// Convert a result variable to the backend representation.\n+\n+Bvariable*\n+Result_variable::get_backend_variable(Gogo* gogo, Named_object* function,\n+\t\t\t\t      const std::string& name)\n+{\n+  if (this->backend_ == NULL)\n+    {\n+      Backend* backend = gogo->backend();\n+      Type* type = this->type_;\n+      if (type->is_error())\n+\tthis->backend_ = backend->error_variable();\n+      else\n+\t{\n+\t  if (this->is_in_heap())\n+\t    type = Type::make_pointer_type(type);\n+\t  Btype* btype = tree_to_type(type->get_tree(gogo));\n+\t  tree fndecl = function->func_value()->get_decl();\n+\t  Bfunction* bfunction = tree_to_function(fndecl);\n+\t  std::string n = Gogo::unpack_hidden_name(name);\n+\t  this->backend_ = backend->local_variable(bfunction, n, btype,\n+\t\t\t\t\t\t   this->location_);\n+\t}\n+    }\n+  return this->backend_;\n+}\n+\n // Class Named_constant.\n \n // Traverse the initializer expression.\n@@ -3997,7 +4085,7 @@ Named_object::location() const\n       return this->var_value()->location();\n \n     case NAMED_OBJECT_RESULT_VAR:\n-      return this->result_var_value()->function()->location();\n+      return this->result_var_value()->location();\n \n     case NAMED_OBJECT_SINK:\n       gcc_unreachable();\n@@ -4057,6 +4145,21 @@ Named_object::export_named_object(Export* exp) const\n     }\n }\n \n+// Convert a variable to the backend representation.\n+\n+Bvariable*\n+Named_object::get_backend_variable(Gogo* gogo, Named_object* function)\n+{\n+  if (this->classification_ == NAMED_OBJECT_VAR)\n+    return this->var_value()->get_backend_variable(gogo, function,\n+\t\t\t\t\t\t   this->package_, this->name_);\n+  else if (this->classification_ == NAMED_OBJECT_RESULT_VAR)\n+    return this->result_var_value()->get_backend_variable(gogo, function,\n+\t\t\t\t\t\t\t  this->name_);\n+  else\n+    gcc_unreachable();\n+}\n+\n // Class Bindings.\n \n Bindings::Bindings(Bindings* enclosing)"}, {"sha": "cb6501e38cef8eea53aff40eff024b3ffacf192f", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -43,6 +43,7 @@ class Export;\n class Import;\n class Bexpression;\n class Bstatement;\n+class Bvariable;\n class Blabel;\n \n // This file declares the basic classes used to hold the internal\n@@ -1270,6 +1271,11 @@ class Variable\n   set_address_taken()\n   { this->is_address_taken_ = true; }\n \n+  // Get the backend representation of the variable.\n+  Bvariable*\n+  get_backend_variable(Gogo*, Named_object*, const Package*,\n+\t\t       const std::string&);\n+\n   // Get the initial value of the variable as a tree.  This may only\n   // be called if has_pre_init() returns false.\n   tree\n@@ -1312,6 +1318,8 @@ class Variable\n   Block* preinit_;\n   // Location of variable definition.\n   source_location location_;\n+  // Backend representation.\n+  Bvariable* backend_;\n   // Whether this is a global variable.\n   bool is_global_ : 1;\n   // Whether this is a function parameter.\n@@ -1346,9 +1354,10 @@ class Variable\n class Result_variable\n {\n  public:\n-  Result_variable(Type* type, Function* function, int index)\n-    : type_(type), function_(function), index_(index),\n-      is_address_taken_(false)\n+  Result_variable(Type* type, Function* function, int index,\n+\t\t  source_location location)\n+    : type_(type), function_(function), index_(index), location_(location),\n+      backend_(NULL), is_address_taken_(false)\n   { }\n \n   // Get the type of the result variable.\n@@ -1366,6 +1375,11 @@ class Result_variable\n   index() const\n   { return this->index_; }\n \n+  // The location of the variable definition.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n   // Whether this variable's address is taken.\n   bool\n   is_address_taken() const\n@@ -1387,13 +1401,21 @@ class Result_variable\n   set_function(Function* function)\n   { this->function_ = function; }\n \n+  // Get the backend representation of the variable.\n+  Bvariable*\n+  get_backend_variable(Gogo*, Named_object*, const std::string&);\n+\n  private:\n   // Type of result variable.\n   Type* type_;\n   // Function with which this is associated.\n   Function* function_;\n   // Index in list of results.\n   int index_;\n+  // Where the result variable is defined.\n+  source_location location_;\n+  // Backend representation.\n+  Bvariable* backend_;\n   // Whether something takes the address of this variable.\n   bool is_address_taken_;\n };\n@@ -1868,6 +1890,10 @@ class Named_object\n   source_location\n   location() const;\n \n+  // Convert a variable to the backend representation.\n+  Bvariable*\n+  get_backend_variable(Gogo*, Named_object* function);\n+\n   // Return a tree for the external identifier for this object.\n   tree\n   get_id(Gogo*);"}, {"sha": "fde3f62e3fca76f8d4248b9095a5bc169e2bfd50", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ce6c5bc057b933d34bd9e9674fd2b3b622190/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=e09ce6c5bc057b933d34bd9e9674fd2b3b622190", "patch": "@@ -251,37 +251,46 @@ Variable_declaration_statement::do_traverse_assignments(\n tree\n Variable_declaration_statement::do_get_tree(Translate_context* context)\n {\n-  tree val = this->var_->get_tree(context->gogo(), context->function());\n-  if (val == error_mark_node || TREE_TYPE(val) == error_mark_node)\n-    return error_mark_node;\n-  Variable* variable = this->var_->var_value();\n-\n-  tree init = variable->get_init_tree(context->gogo(), context->function());\n-  if (init == error_mark_node)\n-    return error_mark_node;\n-\n-  // If this variable lives on the heap, we need to allocate it now.\n-  if (!variable->is_in_heap())\n+  Variable* var = this->var_->var_value();\n+  Bvariable* bvar = this->var_->get_backend_variable(context->gogo(),\n+\t\t\t\t\t\t     context->function());\n+  tree init = var->get_init_tree(context->gogo(), context->function());\n+  Bexpression* binit = init == NULL_TREE ? NULL : tree_to_expr(init);\n+  Bstatement* ret;\n+  if (!var->is_in_heap())\n     {\n-      DECL_INITIAL(val) = init;\n-      return this->build_stmt_1(DECL_EXPR, val);\n+      gcc_assert(binit != NULL);\n+      ret = context->backend()->init_statement(bvar, binit);\n     }\n   else\n     {\n-      gcc_assert(TREE_CODE(val) == INDIRECT_REF);\n-      tree decl = TREE_OPERAND(val, 0);\n-      gcc_assert(TREE_CODE(decl) == VAR_DECL);\n-      tree type = TREE_TYPE(decl);\n-      gcc_assert(POINTER_TYPE_P(type));\n-      tree size = TYPE_SIZE_UNIT(TREE_TYPE(type));\n-      tree space = context->gogo()->allocate_memory(variable->type(), size,\n-\t\t\t\t\t\t    this->location());\n-      space = fold_convert(TREE_TYPE(decl), space);\n-      DECL_INITIAL(decl) = space;\n-      return build2(COMPOUND_EXPR, void_type_node,\n-\t\t    this->build_stmt_1(DECL_EXPR, decl),\n-\t\t    build2(MODIFY_EXPR, void_type_node, val, init));\n+      // Something takes the address of this variable, so the value is\n+      // stored in the heap.  Initialize it to newly allocated memory\n+      // space, and assign the initial value to the new space.\n+      source_location loc = this->location();\n+      tree decl = var_to_tree(bvar);\n+      tree decl_type = TREE_TYPE(decl);\n+      gcc_assert(POINTER_TYPE_P(decl_type));\n+      tree size = TYPE_SIZE_UNIT(TREE_TYPE(decl_type));\n+      tree space = context->gogo()->allocate_memory(var->type(), size, loc);\n+      if (binit != NULL)\n+\tspace = save_expr(space);\n+      space = fold_convert_loc(loc, decl_type, space);\n+      Bstatement* s1 = context->backend()->init_statement(bvar,\n+\t\t\t\t\t\t\t  tree_to_expr(space));\n+      if (binit == NULL)\n+\tret = s1;\n+      else\n+\t{\n+\t  tree indir = build_fold_indirect_ref_loc(loc, space);\n+\t  Bexpression* bindir = tree_to_expr(indir);\n+\t  Bstatement* s2 = context->backend()->assignment_statement(bindir,\n+\t\t\t\t\t\t\t\t    binit,\n+\t\t\t\t\t\t\t\t    loc);\n+\t  ret = context->backend()->compound_statement(s1, s2);\n+\t}\n     }\n+  return stat_to_tree(ret);\n }\n \n // Make a variable declaration.\n@@ -2421,6 +2430,8 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing)\n tree\n Return_statement::do_get_tree(Translate_context* context)\n {\n+  source_location loc = this->location();\n+\n   Function* function = context->function()->func_value();\n   tree fndecl = function->get_decl();\n \n@@ -2433,14 +2444,14 @@ Return_statement::do_get_tree(Translate_context* context)\n \t   p != results->end();\n \t   p++)\n \t{\n-\t  tree rv = (*p)->get_tree(context->gogo(), context->function());\n-\t  retvals.push_back(tree_to_expr(rv));\n+\t  Expression* vr = Expression::make_var_reference(*p, loc);\n+\t  retvals.push_back(tree_to_expr(vr->get_tree(context)));\n \t}\n     }\n \n   Bstatement* ret;\n   ret = context->backend()->return_statement(tree_to_function(fndecl),\n-\t\t\t\t\t     retvals, this->location());\n+\t\t\t\t\t     retvals, loc);\n   return stat_to_tree(ret);\n }\n "}]}