{"sha": "39b1a0588feb025b361cafcce5a63cb85cd94ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzliMWEwNTg4ZmViMDI1YjM2MWNhZmNjZTVhNjNjYjg1Y2Q5NGVlMQ==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "1999-05-18T18:02:01Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "1999-05-18T18:02:01Z"}, "message": "Makefile.am (ordinary_java_source_files): Added DatagramPacket.java...\n\n\t* Makefile.am (ordinary_java_source_files): Added DatagramPacket.java,\n\tDatagramSocket.java, DatagramSocketImpl.java, MulticastSocket.java,\n\tPlainDatagramSocketImpl.java, and SocketOptions.java.\n\t(nat_source_files): Added natPlainDatagramSocketImpl.cc.\n\t* Makefile.in: Rebuilt.\n\t* java/net/DatagramPacket.java: New file.\n\t* java/net/DatagramSocket.java: New file.\n\t* java/net/DatagramSocketImpl.java: New file.\n\t* java/net/MulticastSocket.java: New file.\n\t* java/net/PlainDatagramSocketImpl.java: New file.\n\t* java/net/SocketOptions.java: New file.\n\t* java/net/natPlainDatagramSocketImpl.cc: New file.\n\nFrom-SVN: r26997", "tree": {"sha": "cffa67a526e3759bfc1898f73adcbdd86c134867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cffa67a526e3759bfc1898f73adcbdd86c134867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39b1a0588feb025b361cafcce5a63cb85cd94ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b1a0588feb025b361cafcce5a63cb85cd94ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39b1a0588feb025b361cafcce5a63cb85cd94ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b1a0588feb025b361cafcce5a63cb85cd94ee1/comments", "author": null, "committer": null, "parents": [{"sha": "0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffac8322f8825c0d696d9c700b0d0f1a395d11a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ffac8322f8825c0d696d9c700b0d0f1a395d11a"}], "stats": {"total": 853, "additions": 848, "deletions": 5}, "files": [{"sha": "8a24d83c8e31e918e0770ffac1d1b6c95263bbdf", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -1,3 +1,19 @@\n+1999-05-18  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* Makefile.am (ordinary_java_source_files): Added DatagramPacket.java,\n+\tDatagramSocket.java, DatagramSocketImpl.java, MulticastSocket.java,\n+\tPlainDatagramSocketImpl.java, and SocketOptions.java.\n+\t(nat_source_files): Added natPlainDatagramSocketImpl.cc.\n+\t* Makefile.in: Rebuilt.\n+\n+\t* java/net/DatagramPacket.java: New file.\n+\t* java/net/DatagramSocket.java: New file.\n+\t* java/net/DatagramSocketImpl.java: New file.\n+\t* java/net/MulticastSocket.java: New file.\n+\t* java/net/PlainDatagramSocketImpl.java: New file.\n+\t* java/net/SocketOptions.java: New file.\n+\t* java/net/natPlainDatagramSocketImpl.cc: New file.\n+\n 1999-05-18  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/util/zip/ZipOutputStream.java (level): Initial value is"}, {"sha": "88260d2f44cb88c6b6fd95740e15044d4d6008d7", "filename": "libjava/Makefile.am", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -584,18 +584,24 @@ java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n java/net/ContentHandlerFactory.java \\\n+java/net/DatagramPacket.java \\\n+java/net/DatagramSocket.java \\\n+java/net/DatagramSocketImpl.java \\\n java/net/FileNameMap.java \\\n java/net/HttpURLConnection.java \\\n java/net/InetAddress.java \\\n java/net/MalformedURLException.java \\\n+java/net/MulticastSocket.java \\\n java/net/NoRouteToHostException.java \\\n+java/net/PlainDatagramSocketImpl.java \\\n java/net/PlainSocketImpl.java \\\n java/net/ProtocolException.java\t\\\n java/net/ServerSocket.java \\\n java/net/Socket.java \\\n java/net/SocketException.java \\\n java/net/SocketImpl.java \\\n java/net/SocketImplFactory.java\t\\\n+java/net/SocketOptions.java \\\n java/net/URL.java \\\n java/net/URLConnection.java \\\n java/net/URLDecoder.java \\\n@@ -718,6 +724,7 @@ java/lang/reflect/natArray.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n java/net/natInetAddress.cc \\\n+java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natDate.cc \\"}, {"sha": "e22c69b0105dd514bdf1208a67876570b8a1c71c", "filename": "libjava/Makefile.in", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -435,18 +435,24 @@ java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n java/net/ContentHandlerFactory.java \\\n+java/net/DatagramPacket.java \\\n+java/net/DatagramSocket.java \\\n+java/net/DatagramSocketImpl.java \\\n java/net/FileNameMap.java \\\n java/net/HttpURLConnection.java \\\n java/net/InetAddress.java \\\n java/net/MalformedURLException.java \\\n+java/net/MulticastSocket.java \\\n java/net/NoRouteToHostException.java \\\n+java/net/PlainDatagramSocketImpl.java \\\n java/net/PlainSocketImpl.java \\\n java/net/ProtocolException.java\t\\\n java/net/ServerSocket.java \\\n java/net/Socket.java \\\n java/net/SocketException.java \\\n java/net/SocketImpl.java \\\n java/net/SocketImplFactory.java\t\\\n+java/net/SocketOptions.java \\\n java/net/URL.java \\\n java/net/URLConnection.java \\\n java/net/URLDecoder.java \\\n@@ -569,6 +575,7 @@ java/lang/reflect/natArray.cc \\\n java/lang/reflect/natField.cc \\\n java/lang/reflect/natMethod.cc \\\n java/net/natInetAddress.cc \\\n+java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natDate.cc \\\n@@ -800,15 +807,19 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/w_remainder.P .deps/java/lang/w_sqrt.P \\\n .deps/java/net/BindException.P .deps/java/net/ConnectException.P \\\n .deps/java/net/ContentHandler.P .deps/java/net/ContentHandlerFactory.P \\\n-.deps/java/net/FileNameMap.P .deps/java/net/HttpURLConnection.P \\\n-.deps/java/net/InetAddress.P .deps/java/net/MalformedURLException.P \\\n+.deps/java/net/DatagramPacket.P .deps/java/net/DatagramSocket.P \\\n+.deps/java/net/DatagramSocketImpl.P .deps/java/net/FileNameMap.P \\\n+.deps/java/net/HttpURLConnection.P .deps/java/net/InetAddress.P \\\n+.deps/java/net/MalformedURLException.P .deps/java/net/MulticastSocket.P \\\n .deps/java/net/NoRouteToHostException.P \\\n+.deps/java/net/PlainDatagramSocketImpl.P \\\n .deps/java/net/PlainSocketImpl.P .deps/java/net/ProtocolException.P \\\n .deps/java/net/ServerSocket.P .deps/java/net/Socket.P \\\n .deps/java/net/SocketException.P .deps/java/net/SocketImpl.P \\\n-.deps/java/net/SocketImplFactory.P .deps/java/net/URL.P \\\n-.deps/java/net/URLConnection.P .deps/java/net/URLDecoder.P \\\n-.deps/java/net/URLEncoder.P .deps/java/net/URLStreamHandler.P \\\n+.deps/java/net/SocketImplFactory.P .deps/java/net/SocketOptions.P \\\n+.deps/java/net/URL.P .deps/java/net/URLConnection.P \\\n+.deps/java/net/URLDecoder.P .deps/java/net/URLEncoder.P \\\n+.deps/java/net/URLStreamHandler.P \\\n .deps/java/net/URLStreamHandlerFactory.P \\\n .deps/java/net/UnknownHostException.P \\\n .deps/java/net/UnknownServiceException.P \\"}, {"sha": "72b7bbdd4bb2eb4d54864ae8fea314d7edfe3548", "filename": "libjava/java/net/DatagramPacket.java", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FDatagramPacket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FDatagramPacket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramPacket.java?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,175 @@\n+// DatagramPacket.java - Represents packets in a connectionless protocol.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.net;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date April 28, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public final class DatagramPacket\n+{\n+  private byte[] buffer;\n+  private int offset;\n+  private int length;\n+  private InetAddress address;\n+  private int port;\n+\n+  // JDK1.2\n+  public DatagramPacket(byte[] buf, int offset, int length)\n+  {\n+    // FIXME: We can't currently rely on NullPointerException being\n+    // thrown when we invoke a method on a null object.\n+    if (buf == null)\n+      throw new NullPointerException(\"Null buffer\");\n+    if (offset < 0)\n+      throw new IllegalArgumentException(\"Invalid offset: \" + offset);\n+    if (length < 0)\n+      throw new IllegalArgumentException(\"Invalid length: \" + length);\n+    if (offset + length > buf.length)\n+      throw new IllegalArgumentException(\"Potential buffer overflow - offset: \"\n+\t\t\t+ offset + \" length: \" + length);\n+\n+    buffer = buf;\n+    this.offset = offset;\n+    this.length = length;\n+    this.address = null;\n+    this.port = -1;\n+  }\n+\n+  public DatagramPacket(byte[] buf, int length)\n+  {\n+    this(buf, 0, length);\n+  }\n+\n+  // JDK1.2\n+  public DatagramPacket(byte[] buf, int offset, int length,\n+\tInetAddress address, int port)\n+  {\n+    // FIXME: We can't currently rely on NullPointerException being\n+    // thrown when we invoke a method on a null object.\n+    if (buf == null)\n+      throw new NullPointerException(\"Null buffer\");\n+    if (offset < 0)\n+      throw new IllegalArgumentException(\"Invalid offset: \" + offset);\n+    if (length < 0)\n+      throw new IllegalArgumentException(\"Invalid length: \" + length);\n+    if (offset + length > buf.length)\n+      throw new IllegalArgumentException(\"Potential buffer overflow - offset: \"\n+\t\t\t+ offset + \" length: \" + length);\n+    if (port < 0 || port > 65535)\n+      throw new IllegalArgumentException(\"Invalid port: \" + port);\n+    if (address == null)\n+      throw new NullPointerException(\"Null address\");\n+\n+    buffer = buf;\n+    this.offset = offset;\n+    this.length = length;\n+    this.address = address;\n+    this.port = port;\n+  }\n+\n+  public DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n+  {\n+    this(buf, 0, length, address, port);\n+  }\n+\n+  public synchronized InetAddress getAddress()\n+  {\n+    return address;\n+  }\n+\n+  public synchronized int getPort()\n+  {\n+    return port;\n+  }\n+\n+  public synchronized byte[] getData()\n+  {\n+    return buffer;\n+  }\n+\n+  // JDK1.2\n+  public synchronized int getOffset()\n+  {\n+    return offset;\n+  }\n+\n+  public synchronized int getLength()\n+  {\n+    return length;\n+  }\n+\n+  public synchronized void setAddress(InetAddress iaddr)\n+  {\n+    if (iaddr == null)\n+      throw new NullPointerException(\"Null address\");\n+\n+    address = iaddr;\n+  }\n+\n+  public synchronized void setPort(int iport)\n+  {\n+    if (iport < 0 || iport > 65535)\n+      throw new IllegalArgumentException(\"Invalid port: \" + iport);\n+\n+    port = iport;\n+  }\n+\n+  public synchronized void setData(byte[] buf)\n+  {\n+    // This form of setData requires setLength to be called separately\n+    // and subsequently.\n+    if (buf == null)\n+      throw new NullPointerException(\"Null buffer\");\n+\n+    buffer = buf;\n+  }\n+\n+  // JDK1.2\n+  public synchronized void setData(byte[] buf, int offset, int length)\n+  {\n+    // This form of setData must be used if offset is to be changed.\n+\n+    // FIXME: We can't currently rely on NullPointerException being\n+    // thrown when we invoke a method on a null object.\n+    if (buf == null)\n+      throw new NullPointerException(\"Null buffer\");\n+    if (offset < 0)\n+      throw new IllegalArgumentException(\"Invalid offset: \" + offset);\n+    if (length < 0)\n+      throw new IllegalArgumentException(\"Invalid length: \" + length);\n+    if (offset + length > buf.length)\n+      throw new IllegalArgumentException(\"Potential buffer overflow - offset: \"\n+\t\t\t+ offset + \" length: \" + length);\n+\n+    buffer = buf;\n+    this.offset = offset;\n+    this.length = length;\n+  }\n+\n+  public synchronized void setLength(int length)\n+  {\n+    if (length < 0)\n+      throw new IllegalArgumentException(\"Invalid length: \" + length);\n+    if (offset + length > buffer.length)\n+      throw new IllegalArgumentException(\"Potential buffer overflow - offset: \"\n+\t\t\t+ offset + \" length: \" + length);\n+\n+    this.length = length;\n+  }\n+}"}, {"sha": "e82681a7f61dc27379835625c1c03d85eced8dce", "filename": "libjava/java/net/DatagramSocket.java", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,160 @@\n+// DatagramSocket.java\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.net;\n+import java.io.IOException;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date May 3, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class DatagramSocket\n+{\n+  DatagramSocketImpl impl;\n+  // FIXME: Shouldn't this be determined by getsockname() instead?\n+  InetAddress laddr;\n+\n+  public DatagramSocket() throws SocketException\n+  {\n+    this(0, null);\n+  }\n+\n+  public DatagramSocket(int port) throws SocketException\n+  {\n+    this(port, null);\n+  }\n+\n+  public DatagramSocket(int port, InetAddress laddr) throws SocketException\n+  {\n+    if (port < 0 || port > 65535)\n+      throw new IllegalArgumentException(\"Invalid port: \" + port);\n+\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkListen(port);\n+\n+    String propVal = System.getProperty(\"impl.prefix\");\n+    if (propVal == null || propVal.equals(\"\"))\n+      propVal = \"Plain\";\n+    impl = (DatagramSocketImpl) Class.forName(\"java.net.\" + propVal +\n+\t\t\t\t\t\"DatagramSocketImpl\").newInstance();\n+    impl.create();\n+    // TBD: if this is right then the same should be done in Socket().\n+    try\n+    {\n+      impl.bind(port, laddr == null ? InetAddress.getLocalHost() : laddr);\n+    }\n+    catch (UnknownHostException e)\n+    {\n+      throw new BindException(e.getMessage());\n+    }\n+    this.laddr = laddr;\n+  }\n+\n+  public void close()\n+  {\n+    impl.close();\n+  }\n+\n+  public InetAddress getLocalAddress()\n+  {\n+    return laddr;\n+  }\n+\n+  public int getLocalPort()\n+  {\n+    return impl.getLocalPort();\n+  }\n+\n+  public synchronized int getSoTimeout() throws SocketException\n+  {\n+    // FIXME: TODO - DatagramSocket.getSoTimeout\n+     throw new SocketException(\"DatagramSocket.getSoTimeout - not yet implemented\");\n+  }\n+\n+  public synchronized void receive(DatagramPacket p) throws IOException\n+  {\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkAccept(p.getAddress().getHostAddress(), p.getPort());\n+\n+    impl.receive(p);\n+  }\n+\n+  public void send(DatagramPacket p) throws IOException\n+  {\n+    // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      {\n+\tInetAddress addr = p.getAddress();\n+\tif (addr.isMulticastAddress())\n+\t  s.checkMulticast(addr);\n+\telse\n+\t  s.checkConnect(addr.getHostAddress(), p.getPort());\n+      }\n+\n+    // FIXME: if this is a subclass of MulticastSocket, use getTTL for TTL val.\n+    impl.send(p);\n+  }\n+\n+  public synchronized void setSoTimeout(int timeout) throws SocketException\n+  {\n+    // FIXME: TODO - DatagramSocket.setSoTimeout\n+    throw new SocketException(\"DatagramSocket.setSoTimeout - not yet implemented\");\n+  }\n+\n+  // JDK1.2\n+  // public void connect(InetAddress address, int port)\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public void disconnect()\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public InetAddress getInetAddress()\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public int getPort()\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public int getReceiveBufferSize() throws SocketException\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public int getSendBufferSize() throws SocketException\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public void setReceiveBufferSize(int size) throws SocketException\n+  // {\n+  // }\n+\n+  // JDK1.2\n+  // public void setSendBufferSize(int size) throws SocketException\n+  // {\n+  // }\n+}"}, {"sha": "2ab8c2a2fc4b7b4ddcc48d129f82a82906fa6322", "filename": "libjava/java/net/DatagramSocketImpl.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,60 @@\n+// DatagramSocketImpl.java - Abstract datagram socket implementation.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.net;\n+import java.io.IOException;\n+import java.io.FileDescriptor;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date May 3, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Believed complete and correct.\n+ */\n+\n+// JDK1.2: needs to implement SocketOptions.\n+// JDK1.2: public abstract class DatagramSocketImpl implements SocketOptions\n+public abstract class DatagramSocketImpl\n+{\n+  protected int localport;\n+  protected FileDescriptor fd;\n+\n+  public DatagramSocketImpl()\n+  {\n+  }\n+\n+  protected abstract void bind(int lport, InetAddress laddr)\n+  \tthrows SocketException;\n+  protected abstract void close();\n+  protected abstract void create() throws SocketException;\n+  protected abstract int peek(InetAddress i) throws IOException;\n+  protected abstract void send(DatagramPacket p) throws IOException;\n+  protected abstract void receive(DatagramPacket p) throws IOException;\n+  protected abstract void setTTL(byte ttl) throws IOException;\n+  protected abstract byte getTTL() throws IOException;\n+  protected abstract void setTimeToLive(int ttl) throws IOException;\n+  protected abstract int getTimeToLive() throws IOException;\n+  protected abstract void join(InetAddress inetaddr) throws IOException;\n+  protected abstract void leave(InetAddress inetaddr) throws IOException;\n+\n+  protected FileDescriptor getFileDescriptor()\n+  {\n+    return fd;\n+  }\n+\n+  protected int getLocalPort()\n+  {\n+    return localport;\n+  }\n+}"}, {"sha": "1cb01c125ce837d30e82737d396742c4e90e6074", "filename": "libjava/java/net/MulticastSocket.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,91 @@\n+// MulticastSocket.java\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.net;\n+import java.io.IOException;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date May 18, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public class MulticastSocket extends DatagramSocket\n+{\n+  // FIXME: the local addr bound to the multicast socket can be reused;\n+  // unlike unicast sockets.  see p.1159 JCL book.\n+\n+  public MulticastSocket() throws IOException\n+  {\n+    super(0, null);\n+  }\n+\n+  public MulticastSocket(int port) throws IOException\n+  {\n+    super(port, null);\n+  }\n+\n+  public InetAddress getInterface() throws SocketException\n+  {\n+    // FIXME: TODO - MulticastSocket.getInterface\n+    throw new SocketException(\"MulticastSocket.getInterface - not yet implemented\");\n+  }\n+\n+  // Deprecated in JDK1.2\n+  public byte getTTL() throws IOException\n+  {\n+    return impl.getTTL();\n+  }\n+\n+  // JDK1.2\n+  public int getTimeToLive() throws IOException\n+  {\n+    return impl.getTimeToLive();\n+  }\n+\n+  public void setInterface(InetAddress inf) throws SocketException\n+  {\n+    // FIXME: TODO - MulticastSocket.setInterface\n+    throw new SocketException(\"MulticastSocket.setInterface - not yet implemented\");\n+  }\n+\n+  // Deprecated in JDK1.2\n+  public void setTTL(byte ttl) throws IOException\n+  {\n+    impl.setTTL(ttl);\n+  }\n+\n+  // JDK1.2\n+  public void setTimeToLive(int ttl) throws IOException\n+  {\n+    impl.setTimeToLive(ttl);\n+  }\n+\n+  public void joinGroup(InetAddress mcastaddr) throws IOException\n+  {\n+    impl.join(mcastaddr);\n+  }\n+\n+  public void leaveGroup(InetAddress mcastaddr) throws IOException\n+  {\n+    impl.leave(mcastaddr);\n+  }\n+\n+  public void send(DatagramPacket p, byte ttl) throws IOException\n+  {\n+    // FIXME:  use ttl instead of getTTL() for time to live.\n+    impl.send(p);\n+  }\n+}"}, {"sha": "7628c5087e37ca900be0184984bd35922f36b589", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,56 @@\n+// PlainDatagramSocketImpl.java - Implementation of DatagramSocketImpl.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.net;\n+import java.io.IOException;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date May 3, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification, as well\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * Status:  Believed complete and correct.\n+ */\n+\n+class PlainDatagramSocketImpl extends DatagramSocketImpl\n+{\n+  int fnum = -1;\n+  InetAddress address;\t// TBD: DatagramSocket.getLocalAddress()?\n+\n+  // FIXME: Probably should have bind (and create?) calls from DatagramSocket\n+  // constuctor.  If so, then same change should be made to the corresponding\n+  // Socket (non-datagram) classes.  This allows the implementation more\n+  // compleete control over how the socket is set up and used (e.g. connect,\n+  // setting options, etc.).\n+  public PlainDatagramSocketImpl()\n+  {\n+  }\n+\n+  protected native void bind(int lport, InetAddress laddr)\n+\tthrows SocketException;\n+  protected native void create() throws SocketException;\n+  protected native int peek(InetAddress i) throws IOException;\n+  protected native void setTTL(byte ttl) throws IOException;\n+  protected native byte getTTL() throws IOException;\n+  protected native void setTimeToLive(int ttl) throws IOException;\n+  protected native int getTimeToLive() throws IOException;\n+  protected native void join(InetAddress inetaddr) throws IOException;\n+  protected native void leave(InetAddress inetaddr) throws IOException;\n+  protected native void send(DatagramPacket p) throws IOException;\n+  protected native void receive(DatagramPacket p) throws IOException;\n+\n+  protected void close() throws IOException\n+  {\n+    fd.close();\n+  }\n+}"}, {"sha": "40f7649aa605d66ecaeb254fab17e717e7ee168d", "filename": "libjava/java/net/SocketOptions.java", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FSocketOptions.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FSocketOptions.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketOptions.java?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,40 @@\n+// SocketOptions.java - Interface for get/set socket options.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.net;\n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date May 3, 1999.\n+ */\n+\n+/**\n+ * Written using on-line Java Platform 1.2 API Specification.\n+ * Status:  Believed complete and correct.\n+ */\n+\n+public abstract interface SocketOptions\n+{\n+  public static final int TCP_NODELAY = 0x1;\n+  public static final int SO_BINDADDR = 0xF;\n+  public static final int SO_REUSEADDR = 0x4;\n+  public static final int IP_MULTICAST_IF = 0x10;\n+  public static final int SO_LINGER = 0x80;\n+  public static final int SO_TIMEOUT = 0x1006;\n+\n+// JDK1.2\n+  public static final int SO_SNDBUF = 0x1001;\n+\n+// JDK1.2\n+  public static final int SO_RCVBUF = 0x1002;\n+\n+  public void setOption(int optID, Object value) throws SocketException;\n+  public Object getOption(int optID) throws SocketException;\n+}"}, {"sha": "1bdcdd59ae0c14527f31ad765b4f23dee668688f", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b1a0588feb025b361cafcce5a63cb85cd94ee1/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=39b1a0588feb025b361cafcce5a63cb85cd94ee1", "patch": "@@ -0,0 +1,227 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <cni.h>\n+#include <java/io/IOException.h>\n+#include <java/io/FileDescriptor.h>\n+#include <java/net/BindException.h>\n+#include <java/net/SocketException.h>\n+#include <java/net/PlainDatagramSocketImpl.h>\n+#include <java/net/InetAddress.h>\n+#include <java/net/DatagramPacket.h>\n+\n+#ifndef HAVE_SOCKLEN_T\n+typedef int socklen_t;\n+#endif\n+\n+union SockAddr\n+{\n+  struct sockaddr_in address;\n+#ifdef HAVE_INET6\n+  struct sockaddr_in6 address6;\n+#endif\n+};\n+\n+// FIXME: routines here and/or in natPlainSocketImpl.cc could throw\n+// NoRouteToHostException; also consider UnknownHostException, ConnectException.\n+\n+void\n+java::net::PlainDatagramSocketImpl::create ()\n+{\n+  int sock = ::socket (AF_INET, SOCK_DGRAM, 0);\n+  if (sock < 0)\n+    {\n+      char msg[100];\n+      char* strerr = strerror (errno);\n+      sprintf (msg, \"DatagramSocketImpl.create: %.*s\", 80, strerr);\n+      JvThrow (new java::net::SocketException (JvNewStringUTF (msg)));\n+    }\n+  fnum = sock;\n+  fd = new java::io::FileDescriptor (sock);\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::bind (jint lport,\n+  java::net::InetAddress *host)\n+{\n+  union SockAddr u;\n+  jbyteArray haddress = host->address;\n+  jbyte *bytes = elements (haddress);\n+  int len = haddress->length;\n+  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+  if (len == 4)\n+    {\n+      u.address.sin_family = AF_INET;\n+      memcpy (&u.address.sin_addr, bytes, len);\n+      len = sizeof (struct sockaddr_in);\n+      u.address.sin_port = htons (lport);\n+    }\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    {\n+      u.address6.sin6_family = AF_INET6;\n+      memcpy (&u.address6.sin6_addr, bytes, len);\n+      len = sizeof (struct sockaddr_in6);\n+      u.address6.sin6_port = htons (lport);\n+    }\n+#endif\n+  else\n+    goto error;\n+  if (::bind (fnum, ptr, len) == 0)\n+    {\n+      address = host;\n+      localport = lport;\n+      return;\n+    }\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.bind: %.*s\", 80, strerr);\n+  JvThrow (new java::net::BindException (JvNewStringUTF (msg)));\n+}\n+\n+jint\n+java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n+{\n+  // FIXME: TODO - PlainDatagramSocketImpl::peek\n+  // throws IOException;\n+  return 0;\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *p)\n+{\n+  // FIXME: Deal with Multicast and if the socket is connected.\n+  jint rport = p->getPort();\n+  union SockAddr u;\n+  jbyteArray haddress = p->getAddress()->address;\n+  jbyte *bytes = elements (haddress);\n+  int len = haddress->length;\n+  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+  jbyte *dbytes = elements (p->getData());\n+  if (len == 4)\n+    {\n+      u.address.sin_family = AF_INET;\n+      memcpy (&u.address.sin_addr, bytes, len);\n+      len = sizeof (struct sockaddr_in);\n+      u.address.sin_port = htons (rport);\n+    }\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    {\n+      u.address6.sin6_family = AF_INET6;\n+      memcpy (&u.address6.sin6_addr, bytes, len);\n+      len = sizeof (struct sockaddr_in6);\n+      u.address6.sin6_port = htons (rport);\n+    }\n+#endif\n+  else\n+    goto error;\n+  if (::sendto (fnum, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n+    return;\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.send: %.*s\", 80, strerr);\n+  JvThrow (new java::io::IOException (JvNewStringUTF (msg)));\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n+{\n+  // FIXME: Deal with Multicast and if the socket is connected.\n+  union SockAddr u;\n+  socklen_t addrlen = sizeof(u);\n+  jbyte *dbytes = elements (p->getData());\n+  ssize_t retlen =\n+    ::recvfrom (fnum, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n+      &addrlen);\n+  if (retlen < 0)\n+    goto error;\n+  // FIXME: Deal with Multicast addressing and if the socket is connected.\n+  jbyteArray raddr;\n+  jint rport;\n+  if (u.address.sin_family == AF_INET)\n+    {\n+      raddr = JvNewByteArray (4);\n+      memcpy (elements (raddr), &u.address.sin_addr, 4);\n+      rport = ntohs (u.address.sin_port);\n+    }\n+#ifdef HAVE_INET6\n+  else if (u.address.sin_family == AF_INET6)\n+    {\n+      raddr = JvNewByteArray (16);\n+      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n+      rport = ntohs (u.address6.sin6_port);\n+    }\n+#endif\n+  else\n+    goto error;\n+  // FIXME: Multicast:  s->address = new InetAddress (raddr, NULL);\n+  p->setPort (rport);\n+  p->setLength ((jint) retlen);\n+  return;\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.receive: %.*s\", 80, strerr);\n+  JvThrow (new java::io::IOException (JvNewStringUTF (msg)));\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::setTTL (jbyte ttl)\n+{\n+  // FIXME: TODO - :PlainDatagramSocketImpl::setTTL\n+  // throws IOException;\n+}\n+\n+jbyte\n+java::net::PlainDatagramSocketImpl::getTTL ()\n+{\n+  // FIXME: TODO - PlainDatagramSocketImpl::getTTL\n+  // throws IOException;\n+  return 0;\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n+{\n+  // throws IOException;\n+  // FIXME: TODO - PlainDatagramSocketImpl::setTimeToLive\n+}\n+\n+jint\n+java::net::PlainDatagramSocketImpl::getTimeToLive ()\n+{\n+  // throws IOException;\n+  // FIXME: TODO - PlainDatagramSocketImpl::getTimeToLive\n+  return 0;\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::join (java::net::InetAddress *inetaddr)\n+{\n+  // throws IOException;\n+  // FIXME: TODO - PlainDatagramSocketImpl::join\n+}\n+\n+void\n+java::net::PlainDatagramSocketImpl::leave (java::net::InetAddress *inetaddr)\n+{\n+  // throws IOException;\n+  // FIXME: TODO - PlainDatagramSocketImpl::leave\n+}"}]}