{"sha": "5bb51e1d55ed5448130dd532ffa01c15bc77e113", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiNTFlMWQ1NWVkNTQ0ODEzMGRkNTMyZmZhMDFjMTViYzc3ZTExMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2006-09-04T19:33:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-09-04T19:33:24Z"}, "message": "re PR rtl-optimization/27616 (Infinite loop at -O1 and above in RTL CSE)\n\n\tPR rtl-optimization/27616\n\t* cse.c (table_size): New static variable.\n\t(new_basic_block): Initialize it to 0.\n\t(remove_from_table): Decrement it.\n\t(insert): Increment it.\n\t(fold_rtx_mem_1): New function, renamed from fold_rtx_mem.\n\t(fold_rtx_mem): Enforce a cap on the recursion depth.  Call\n\tfold_rtx_mem_1 if under the cap.\n\t(fold_rtx) <RTX_COMM_ARITH>: In the associative case, delay a little\n\tthe lookup of the equivalent expression and test for equality of the\n\tfirst operand of the equivalent expression before in turn looking up\n\tan equivalent constant for the second operand.\n\nFrom-SVN: r116683", "tree": {"sha": "ce136ce4de60baf3887aab1aea174d9a6a8969d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce136ce4de60baf3887aab1aea174d9a6a8969d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bb51e1d55ed5448130dd532ffa01c15bc77e113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb51e1d55ed5448130dd532ffa01c15bc77e113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb51e1d55ed5448130dd532ffa01c15bc77e113", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb51e1d55ed5448130dd532ffa01c15bc77e113/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "afe08db5e6eca5919176811710d7fc74f354b7e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe08db5e6eca5919176811710d7fc74f354b7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe08db5e6eca5919176811710d7fc74f354b7e6"}], "stats": {"total": 117, "additions": 109, "deletions": 8}, "files": [{"sha": "c690c09f6ae9fccdad36f94671fb62bf5c658e38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bb51e1d55ed5448130dd532ffa01c15bc77e113", "patch": "@@ -1,3 +1,18 @@\n+2006-09-04  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/27616\n+\t* cse.c (table_size): New static variable.\n+\t(new_basic_block): Initialize it to 0.\n+\t(remove_from_table): Decrement it.\n+\t(insert): Increment it.\n+\t(fold_rtx_mem_1): New function, renamed from fold_rtx_mem.\n+\t(fold_rtx_mem): Enforce a cap on the recursion depth.  Call\n+\tfold_rtx_mem_1 if under the cap.\n+\t(fold_rtx) <RTX_COMM_ARITH>: In the associative case, delay a little\n+\tthe lookup of the equivalent expression and test for equality of the\n+\tfirst operand of the equivalent expression before in turn looking up\n+\tan equivalent constant for the second operand.\n+\n 2006-09-02  Geoffrey Keating  <geoffk@apple.com>\n \n \tRevert this change:"}, {"sha": "0304d6f763f1435bc0f82216b112ff6312cc4967", "filename": "gcc/cse.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5bb51e1d55ed5448130dd532ffa01c15bc77e113", "patch": "@@ -528,6 +528,10 @@ struct table_elt\n \n static struct table_elt *table[HASH_SIZE];\n \n+/* Number of elements in the hash table.  */\n+\n+static unsigned int table_size;\n+\n /* Chain of `struct table_elt's made so far for this function\n    but currently removed from the table.  */\n \n@@ -961,6 +965,8 @@ new_basic_block (void)\n \t}\n     }\n \n+  table_size = 0;\n+\n #ifdef HAVE_cc0\n   prev_insn = 0;\n   prev_insn_cc0 = 0;\n@@ -1371,6 +1377,8 @@ remove_from_table (struct table_elt *elt, unsigned int hash)\n   /* Now add it to the free element chain.  */\n   elt->next_same_hash = free_element_chain;\n   free_element_chain = elt;\n+\n+  table_size--;\n }\n \n /* Look up X in the hash table and return its table element,\n@@ -1648,6 +1656,8 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \t}\n     }\n \n+  table_size++;\n+\n   return elt;\n }\n \f\n@@ -3432,10 +3442,10 @@ fold_rtx_subreg (rtx x, rtx insn)\n   return x;\n }\n \n-/* Fold MEM.  */\n+/* Fold MEM.  Not to be called directly, see fold_rtx_mem instead.  */\n \n static rtx\n-fold_rtx_mem (rtx x, rtx insn)\n+fold_rtx_mem_1 (rtx x, rtx insn)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx new;\n@@ -3598,6 +3608,51 @@ fold_rtx_mem (rtx x, rtx insn)\n   }\n }\n \n+/* Fold MEM.  */\n+\n+static rtx\n+fold_rtx_mem (rtx x, rtx insn)\n+{\n+  /* To avoid infinite oscillations between fold_rtx and fold_rtx_mem,\n+     refuse to allow recursion of the latter past n levels.  This can\n+     happen because fold_rtx_mem will try to fold the address of the\n+     memory reference it is passed, i.e. conceptually throwing away\n+     the MEM and reinjecting the bare address into fold_rtx.  As a\n+     result, patterns like\n+\n+       set (reg1)\n+\t   (plus (reg)\n+\t\t (mem (plus (reg2) (const_int))))\n+\n+       set (reg2)\n+\t   (plus (reg)\n+\t\t (mem (plus (reg1) (const_int))))\n+\n+     will defeat any \"first-order\" short-circuit put in either\n+     function to prevent these infinite oscillations.\n+\n+     The heuristics for determining n is as follows: since each time\n+     it is invoked fold_rtx_mem throws away a MEM, and since MEMs\n+     are generically not nested, we assume that each invocation of\n+     fold_rtx_mem corresponds to a new \"top-level\" operand, i.e.\n+     the source or the destination of a SET.  So fold_rtx_mem is\n+     bound to stop or cycle before n recursions, n being the number\n+     of expressions recorded in the hash table.  We also leave some\n+     play to account for the initial steps.  */\n+\n+  static unsigned int depth;\n+  rtx ret;\n+\n+  if (depth > 3 + table_size)\n+    return x;\n+\n+  depth++;\n+  ret = fold_rtx_mem_1 (x, insn);\n+  depth--;\n+\n+  return ret;\n+}\n+\n /* If X is a nontrivial arithmetic operation on an argument\n    for which a constant value can be determined, return\n    the result of operating on that value, as a constant.\n@@ -4262,10 +4317,8 @@ fold_rtx (rtx x, rtx insn)\n \t    {\n \t      int is_shift\n \t\t= (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT);\n-\t      rtx y = lookup_as_function (folded_arg0, code);\n-\t      rtx inner_const;\n+\t      rtx y, inner_const, new_const;\n \t      enum rtx_code associate_code;\n-\t      rtx new_const;\n \n \t      if (is_shift\n \t\t  && (INTVAL (const_arg1) >= GET_MODE_BITSIZE (mode)\n@@ -4278,11 +4331,9 @@ fold_rtx (rtx x, rtx insn)\n \t\t    break;\n \t\t}\n \n+\t      y = lookup_as_function (folded_arg0, code);\n \t      if (y == 0)\n \t\tbreak;\n-\t      inner_const = equiv_constant (fold_rtx (XEXP (y, 1), 0));\n-\t      if (!inner_const || GET_CODE (inner_const) != CONST_INT)\n-\t\tbreak;\n \n \t      /* If we have compiled a statement like\n \t\t \"if (x == (x & mask1))\", and now are looking at\n@@ -4292,6 +4343,10 @@ fold_rtx (rtx x, rtx insn)\n \t      if (XEXP (y, 0) == folded_arg0)\n \t\tbreak;\n \n+\t      inner_const = equiv_constant (fold_rtx (XEXP (y, 1), 0));\n+\t      if (!inner_const || GET_CODE (inner_const) != CONST_INT)\n+\t\tbreak;\n+\n \t      /* Don't associate these operations if they are a PLUS with the\n \t\t same constant and it is a power of two.  These might be doable\n \t\t with a pre- or post-increment.  Similarly for two subtracts of"}, {"sha": "df6d0f9b6ac36b200eba210e21969d6564753dcb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5bb51e1d55ed5448130dd532ffa01c15bc77e113", "patch": "@@ -1,3 +1,7 @@\n+2006-09-04  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.c-torture/compile/20060904-1.c: New test.\n+\n 2006-09-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/23287 Revert my 2006-09-01 patch"}, {"sha": "f9f768664857176462756dbf1ad36fc7685bada8", "filename": "gcc/testsuite/gcc.c-torture/compile/20060904-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060904-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb51e1d55ed5448130dd532ffa01c15bc77e113/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060904-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060904-1.c?ref=5bb51e1d55ed5448130dd532ffa01c15bc77e113", "patch": "@@ -0,0 +1,27 @@\n+/* PR rtl-optimization/27616 */\n+/* Reported by Lee Ji Hwan <moonz@kaist.ac.kr> */\n+/* Testcase by Andrew Pinski <pinskia@gcc.gnu.org> */\n+\n+struct chunk_s\n+{\n+  unsigned int size;\n+  int offset_next;\n+};\n+\n+typedef struct chunk_s chunk_t;\n+\n+void foo(chunk_t *first)\n+{\n+  chunk_t *cur;\n+  char *first0;\n+\n+  do {\n+    first0 = (char *) first;\n+    cur = (chunk_t *) (first0 + first->offset_next);\n+    if ((chunk_t *) (first0 + cur->offset_next) != first)\n+      return ;\n+\n+    first->offset_next = 0;\n+\n+  } while (cur->size != 0);\n+}"}]}