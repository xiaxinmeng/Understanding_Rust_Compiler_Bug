{"sha": "5c23c401723bd1c663709d2ae3493bbeee02f9d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMyM2M0MDE3MjNiZDFjNjYzNzA5ZDJhZTM0OTNiYmVlZTAyZjlkMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-08T21:45:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-08T21:45:38Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r422", "tree": {"sha": "955c21bf02427414034ee6f0d87515e833a4d3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/955c21bf02427414034ee6f0d87515e833a4d3e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c23c401723bd1c663709d2ae3493bbeee02f9d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c23c401723bd1c663709d2ae3493bbeee02f9d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c23c401723bd1c663709d2ae3493bbeee02f9d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c23c401723bd1c663709d2ae3493bbeee02f9d1/comments", "author": null, "committer": null, "parents": [{"sha": "82bb2b597d775a92172cc4d3832345a262fe8ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82bb2b597d775a92172cc4d3832345a262fe8ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82bb2b597d775a92172cc4d3832345a262fe8ce5"}], "stats": {"total": 79, "additions": 55, "deletions": 24}, "files": [{"sha": "3d4683b1275c831f4a837c8e0a6b35b1843d4989", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5c23c401723bd1c663709d2ae3493bbeee02f9d1", "patch": "@@ -1018,6 +1018,17 @@ print_operand (file, x, code)\n       RS6000_OUTPUT_BASENAME (file, XSTR (x, 0));\n       return;\n \n+    case 'A':\n+      /* If X is a constant integer whose low-order 5 bits are zero,\n+\t write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug\n+\t in the RS/6000 assembler where \"sri\" with a zero shift count\n+\t write a trash instruction.  */\n+      if (GET_CODE (x) != CONST_INT && (INTVAL (x) & 31) == 0)\n+\tfprintf (file, \"l\");\n+      else\n+\tfprintf (file, \"r\");\n+      return;\n+\n     case 0:\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);"}, {"sha": "167363bdd2fc754e9739b126b5dfee2549e9a9ee", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=5c23c401723bd1c663709d2ae3493bbeee02f9d1", "patch": "@@ -22,7 +22,7 @@\n \f\n ;; Define an insn type attribute.  This is used in function unit delay\n ;; computations.\n-(define_attr \"type\" \"load,integer,fp,compare,delayed_compare,fpcompare\"\n+(define_attr \"type\" \"load,integer,fp,compare,delayed_compare,fpcompare,mtlr\"\n   (const_string \"integer\"))\n \n ;; Memory delivers its result in two cycles.\n@@ -40,6 +40,9 @@\n \n ;; Floating-point comparisons take eight cycles.\n (define_function_unit \"compare\" 1 0 (eq_attr \"type\" \"fpcompare\") 8 0)\n+\n+;; Branches on LR cannot be done until five cycles after LR is set.\n+(define_function_unit \"branch\" 1 0 (eq_attr \"type\" \"mtlr\") 5 0)\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -328,7 +331,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n \t(if_then_else:SI (gt (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n-\t\t\t     (match_operand:SI 2 \"reg_or_short_operand\" \"r\"))\n+\t\t\t     (match_operand:SI 2 \"reg_or_short_operand\" \"rI\"))\n \t\t\t (const_int 0)\n \t\t\t (minus:SI (match_dup 2) (match_dup 1))))]\n   \"\"\n@@ -338,7 +341,7 @@\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n \t(compare:CC\n \t (if_then_else:SI (gt (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n-\t\t\t      (match_operand:SI 2 \"reg_or_short_operand\" \"r\"))\n+\t\t\t      (match_operand:SI 2 \"reg_or_short_operand\" \"rI\"))\n \t\t\t  (const_int 0)\n \t\t\t  (minus:SI (match_dup 2) (match_dup 1)))\n \t (const_int 0)))\n@@ -351,7 +354,7 @@\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n \t(compare:CC\n \t (if_then_else:SI (gt (match_operand:SI 1 \"gen_reg_operand\" \"r\")\n-\t\t\t      (match_operand:SI 2 \"reg_or_short_operand\" \"r\"))\n+\t\t\t      (match_operand:SI 2 \"reg_or_short_operand\" \"rI\"))\n \t\t\t  (const_int 0)\n \t\t\t  (minus:SI (match_dup 2) (match_dup 1)))\n \t (const_int 0)))\n@@ -1277,6 +1280,8 @@\n   \"rlinm. %0,%h1,%h2,%m3,%M3\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n+;; The RS/6000 assembler mis-handles \"sri x,x,0\", so write that case as\n+;; \"sli x,x,0\".\n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"gen_reg_operand\" \"r,r\")\n@@ -1285,7 +1290,7 @@\n   \"\"\n   \"@\n   sre %0,%1,%2\n-  sri %0,%1,%h2\")\n+  s%A2i %0,%1,%h2\")\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x\")\n@@ -1297,7 +1302,7 @@\n   \"\"\n   \"@\n   sre. %3,%1,%2\n-  sri. %3,%1,%h2\"\n+  s%A2i. %3,%1,%h2\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n (define_insn \"\"\n@@ -1311,7 +1316,7 @@\n   \"\"\n   \"@\n   sre. %0,%1,%2\n-  sri. %0,%1,%h2\"\n+  s%A2i. %0,%1,%h2\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n (define_insn \"\"\n@@ -1936,19 +1941,19 @@\n    sli %0,%L1,%h2\\;cal %L0,0(0)\n    sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\n    sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\n-   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2 \")\n+   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\")\n \n (define_insn \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=r,r,r,&r\")\n+  [(set (match_operand:DI 0 \"gen_reg_operand\" \"=&r,r,r,&r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"gen_reg_operand\" \"r,r,0,r\")\n \t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"M,i,r,r\")))\n    (clobber (match_scratch:SI 3 \"=X,q,q,q\"))]\n   \"\"\n   \"@\n-   cal %0,0(0)\\;sri %L0,%1,%h2\n-   sr%I2q %L0,%L1,%2\\;srl%I2q %0,%1,%2\n-   sr%I2q %L0,%L1,%2\\;srl%I2q %0,%1,%2\n-   sr%I2q %L0,%L1,%2\\;srl%I2q %0,%1,%2 \")\n+   cal %0,0(0)\\;s%A2i %L0,%1,%h2\n+   s%A2%I2q %L0,%L1,%2\\;srl%I2q %0,%1,%2\n+   s%A2%I2q %L0,%L1,%2\\;srl%I2q %0,%1,%2\n+   s%A2%I2q %L0,%L1,%2\\;srl%I2q %0,%1,%2\")\n \n ;; Shift by a variable amount is too complex to be worth open-coding.  We\n ;; just handle shifts by constants.\n@@ -2007,8 +2012,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,*h\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,m,r,I,J,*h,r\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,*c*q,*l\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,m,r,I,J,*h,r,r\"))]\n   \"gen_reg_operand (operands[0], SImode)\n    || gen_reg_operand (operands[1], SImode)\"\n   \"@\n@@ -2018,8 +2023,9 @@\n    cal %0,%1(0)\n    cau %0,0,%u1\n    mf%1 %0\n+   mt%0 %1\n    mt%0 %1\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"*,load,*,*,*,*,*,mtlr\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")"}, {"sha": "05b114335c088c6d98f4c001b308d242f2d76913", "filename": "gcc/integrate.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=5c23c401723bd1c663709d2ae3493bbeee02f9d1", "patch": "@@ -1775,14 +1775,14 @@ copy_rtx_and_substitute (orig, map)\n \t      rounded = CEIL_ROUND (size, BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n \t      loc = plus_constant (loc, rounded);\n #endif\n-\t      map->reg_map[regno] = force_operand (loc, 0);\n-\t      map->const_equiv_map[regno] = loc;\n-\t      map->const_age_map[regno] = CONST_AGE_PARM;\n+\t      map->reg_map[regno] = temp = force_operand (loc, 0);\n+\t      map->const_equiv_map[REGNO (temp)] = loc;\n+\t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n \n \t      seq = gen_sequence ();\n \t      end_sequence ();\n \t      emit_insn_after (seq, map->insns_at_start);\n-\t      return map->reg_map[regno];\n+\t      return temp;\n \t    }\n \t  else if (regno == VIRTUAL_INCOMING_ARGS_REGNUM)\n \t    {\n@@ -1794,14 +1794,14 @@ copy_rtx_and_substitute (orig, map)\n \t      start_sequence ();\n \t      loc = assign_stack_temp (BLKmode, size, 1);\n \t      loc = XEXP (loc, 0);\n-\t      map->reg_map[regno] = force_operand (loc, 0);\n-\t      map->const_equiv_map[regno] = loc;\n-\t      map->const_age_map[regno] = CONST_AGE_PARM;\n+\t      map->reg_map[regno] = temp = force_operand (loc, 0);\n+\t      map->const_equiv_map[REGNO (temp)] = loc;\n+\t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n \n \t      seq = gen_sequence ();\n \t      end_sequence ();\n \t      emit_insn_after (seq, map->insns_at_start);\n-\t      return map->reg_map[regno];\n+\t      return temp;\n \t    }\n \t  else if (REG_FUNCTION_VALUE_P (orig))\n \t    {"}, {"sha": "c6f46b176d4f71cbd7a0a104522c533ebcfa4d14", "filename": "gcc/reload1.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c23c401723bd1c663709d2ae3493bbeee02f9d1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5c23c401723bd1c663709d2ae3493bbeee02f9d1", "patch": "@@ -1367,6 +1367,20 @@ reload (first, global, dumpfile)\n \t    }\n \t}\n \n+      /* See if anything that happened changes which eliminations are valid.\n+\t For example, on the Sparc, whether or not the frame pointer can\n+\t be eliminated can depend on what registers have been used.  We need\n+\t not check some conditions again (such as flag_omit_frame_pointer)\n+\t since they can't have changed.  */\n+\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif ((ep->from == FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED)\n+#ifdef ELIMINABLE_REGS\n+\t    || ! CAN_ELIMINATE (ep->from, ep->to)\n+#endif\n+\t    )\n+\t  ep->can_eliminate = 0;\n+\n       /* Look for the case where we have discovered that we can't replace\n \t register A with register B and that means that we will now be\n \t trying to replace register A with register C.  This means we can"}]}