{"sha": "43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlYTY1MDI1ZmUwMGVhNzhiYmJjMmNlN2M0YjFlOGY2ZTc1OGQ5Yg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-04-14T09:24:34Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-04-14T09:24:34Z"}, "message": "avr.c: (\"insn-codes.h\"...\n\n\n\t* config/avr/avr.c: (\"insn-codes.h\", \"optabs.h\", \"langhooks.h\"):\n\tNew Includes\n\t(avr_init_builtins, avr_expand_builtin,\n\tavr_expand_delay_cycles, avr_expand_unop_builtin,\n\tavr_expand_binop_builtin ): New functions.\n\t(avr_builtin_id): New enum\n\t(struct avr_builtin_description): New struct\n\t(bdesc_1arg, bdesc_2arg): New arrays describing some RTL builtins.\n\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): Define.\n\t\n\t* config/avr/avr.md (UNSPEC_FMUL, UNSPEC_FMULS, UNSPEC_FMULSU,\n\tUNSPECV_ENABLE_IRQS, UNSPECV_NOP, UNSPECV_SLEEP, UNSPECV_WDR, \n\tUNSPECV_DELAY_CYCLES): new enumeration values\n\t(UNSPEC_SEI, UNSPEC_CLI): Remove enumeration values\n\t(\"enable_interrupt\"): Use UNSPECV_ENABLE_IRQS\n\t(\"disable_interrupt\"): Use UNSPECV_ENABLE_IRQS\n\t(\"*rotlqi3_4\"): rename insn to \"rotlqi3_4\"\n\t(\"delay_cycles_1\", \"delay_cycles_2\", \"delay_cycles_3\",\n\t\"delay_cycles_4\", \"nopv\", \"sleep\", \"wdr\", \"fmul\", \"fmuls\",\n\t\"fmulsu\"): New insns\n\t\n\t* config/avr/avr-c.c: fix line endings\n\t(avr_cpu_cpp_builtins): New builtin defines: __BUILTIN_AVR_NOP,\n\t__BUILTIN_AVR_SEI, __BUILTIN_AVR_CLI, __BUILTIN_AVR_WDR,\n\t__BUILTIN_AVR_SLEEP, __BUILTIN_AVR_SWAP,\n\t__BUILTIN_AVR_DELAY_CYCLES, __BUILTIN_AVR_FMUL,\n\t__BUILTIN_AVR_FMULS, __BUILTIN_AVR_FMULSU.\n\t\n\t* doc/extend.texi (AVR Built-in Functions): New node\n\t(Target Builtins): Add documentation of AVR\n\tbuilt-in functions.\n\n\nCo-Authored-By: Eric Weddington <eric.weddington@atmel.com>\nCo-Authored-By: Georg-Johann Lay <avr@gjlay.de>\n\nFrom-SVN: r172416", "tree": {"sha": "5490af92bda644c89eb84d5abad156f8a08034a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5490af92bda644c89eb84d5abad156f8a08034a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a9b55f326aa8e8df001bc6574b5ac2499698619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9b55f326aa8e8df001bc6574b5ac2499698619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9b55f326aa8e8df001bc6574b5ac2499698619"}], "stats": {"total": 786, "additions": 680, "deletions": 106}, "files": [{"sha": "6d0c01a20414259e66334832b6aa3481b42e5f7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "patch": "@@ -1,3 +1,39 @@\n+2011-04-14  Anatoly Sokolov  <aesok@post.ru>\n+            Eric Weddington  <eric.weddington@atmel.com>\n+            Georg-Johann Lay <avr@gjlay.de> \n+\t\n+\t* config/avr/avr.c: (\"insn-codes.h\", \"optabs.h\", \"langhooks.h\"):\n+\tNew Includes\n+\t(avr_init_builtins, avr_expand_builtin,\n+\tavr_expand_delay_cycles, avr_expand_unop_builtin,\n+\tavr_expand_binop_builtin ): New functions.\n+\t(avr_builtin_id): New enum\n+\t(struct avr_builtin_description): New struct\n+\t(bdesc_1arg, bdesc_2arg): New arrays describing some RTL builtins.\n+\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): Define.\n+\t\n+\t* config/avr/avr.md (UNSPEC_FMUL, UNSPEC_FMULS, UNSPEC_FMULSU,\n+\tUNSPECV_ENABLE_IRQS, UNSPECV_NOP, UNSPECV_SLEEP, UNSPECV_WDR, \n+\tUNSPECV_DELAY_CYCLES): new enumeration values\n+\t(UNSPEC_SEI, UNSPEC_CLI): Remove enumeration values\n+\t(\"enable_interrupt\"): Use UNSPECV_ENABLE_IRQS\n+\t(\"disable_interrupt\"): Use UNSPECV_ENABLE_IRQS\n+\t(\"*rotlqi3_4\"): rename insn to \"rotlqi3_4\"\n+\t(\"delay_cycles_1\", \"delay_cycles_2\", \"delay_cycles_3\",\n+\t\"delay_cycles_4\", \"nopv\", \"sleep\", \"wdr\", \"fmul\", \"fmuls\",\n+\t\"fmulsu\"): New insns\n+\t\n+\t* config/avr/avr-c.c: fix line endings\n+\t(avr_cpu_cpp_builtins): New builtin defines: __BUILTIN_AVR_NOP,\n+\t__BUILTIN_AVR_SEI, __BUILTIN_AVR_CLI, __BUILTIN_AVR_WDR,\n+\t__BUILTIN_AVR_SLEEP, __BUILTIN_AVR_SWAP,\n+\t__BUILTIN_AVR_DELAY_CYCLES, __BUILTIN_AVR_FMUL,\n+\t__BUILTIN_AVR_FMULS, __BUILTIN_AVR_FMULSU.\n+\t\n+\t* doc/extend.texi (AVR Built-in Functions): New node\n+\t(Target Builtins): Add documentation of AVR\n+\tbuilt-in functions.\n+\n 2011-04-14  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/44643"}, {"sha": "ec314d2a1399a2107df07c2e340d5eab0c98aa15", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 103, "deletions": 85, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "patch": "@@ -1,85 +1,103 @@\n-/* Copyright (C) 2009, 2010\r\n-   Free Software Foundation, Inc.\r\n-   Contributed by Anatoly Sokolov (aesok@post.ru)\r\n-\r\n-   This file is part of GCC.\r\n-\r\n-   GCC is free software; you can redistribute it and/or modify\r\n-   it under the terms of the GNU General Public License as published by\r\n-   the Free Software Foundation; either version 3, or (at your option)\r\n-   any later version.\r\n-   \r\n-   GCC is distributed in the hope that it will be useful,\r\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n-   GNU General Public License for more details.\r\n-   \r\n-   You should have received a copy of the GNU General Public License\r\n-   along with GCC; see the file COPYING3.  If not see\r\n-   <http://www.gnu.org/licenses/>.  */\r\n-\r\n-\r\n-#include \"config.h\"\r\n-#include \"system.h\"\r\n-#include \"coretypes.h\"\r\n-#include \"tm.h\"\r\n-#include \"tm_p.h\"\r\n-#include \"cpplib.h\"\r\n-#include \"tree.h\"\r\n-#include \"c-family/c-common.h\"\r\n-\r\n-/* Not included in avr.c since this requires C front end.  */\r\n-\r\n-/* Worker function for TARGET_CPU_CPP_BUILTINS.  */\r\n-\r\n-void\r\n-avr_cpu_cpp_builtins (struct cpp_reader *pfile)\r\n-{\r\n-  builtin_define_std (\"AVR\");\r\n-\r\n-  if (avr_current_arch->macro)\r\n-    cpp_define (pfile, avr_current_arch->macro);\r\n-  if (avr_extra_arch_macro)\r\n-    cpp_define (pfile, avr_extra_arch_macro);\r\n-  if (avr_current_arch->have_elpm)\r\n-    cpp_define (pfile, \"__AVR_HAVE_RAMPZ__\");\r\n-  if (avr_current_arch->have_elpm)\r\n-    cpp_define (pfile, \"__AVR_HAVE_ELPM__\");\r\n-  if (avr_current_arch->have_elpmx)\r\n-    cpp_define (pfile, \"__AVR_HAVE_ELPMX__\");\r\n-  if (avr_current_arch->have_movw_lpmx)\r\n-    {\r\n-      cpp_define (pfile, \"__AVR_HAVE_MOVW__\");\r\n-      cpp_define (pfile, \"__AVR_HAVE_LPMX__\");\r\n-    }\r\n-  if (avr_current_arch->asm_only)\r\n-    cpp_define (pfile, \"__AVR_ASM_ONLY__\");\r\n-  if (avr_current_arch->have_mul)\r\n-    {\r\n-      cpp_define (pfile, \"__AVR_ENHANCED__\");\r\n-      cpp_define (pfile, \"__AVR_HAVE_MUL__\");\r\n-    }\r\n-  if (avr_current_arch->have_jmp_call)\r\n-    {\r\n-      cpp_define (pfile, \"__AVR_MEGA__\");\r\n-      cpp_define (pfile, \"__AVR_HAVE_JMP_CALL__\");\r\n-    }\r\n-  if (avr_current_arch->have_eijmp_eicall)\r\n-    {\r\n-      cpp_define (pfile, \"__AVR_HAVE_EIJMP_EICALL__\");\r\n-      cpp_define (pfile, \"__AVR_3_BYTE_PC__\");\r\n-    }\r\n-  else\r\n-    {\r\n-      cpp_define (pfile, \"__AVR_2_BYTE_PC__\");\r\n-    }\r\n-\r\n-  if (avr_current_device->short_sp)\r\n-    cpp_define (pfile, \"__AVR_HAVE_8BIT_SP__\");\r\n-  else\r\n-    cpp_define (pfile, \"__AVR_HAVE_16BIT_SP__\");\r\n-\r\n-  if (TARGET_NO_INTERRUPTS)\r\n-    cpp_define (pfile, \"__NO_INTERRUPTS__\");\r\n-}\r\n-\r\n+/* Copyright (C) 2009, 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Anatoly Sokolov (aesok@post.ru)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+   \n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tm_p.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-common.h\"\n+\n+/* Not included in avr.c since this requires C front end.  */\n+\n+/* Worker function for TARGET_CPU_CPP_BUILTINS.  */\n+\n+void\n+avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n+{\n+  builtin_define_std (\"AVR\");\n+\n+  if (avr_current_arch->macro)\n+    cpp_define (pfile, avr_current_arch->macro);\n+  if (avr_extra_arch_macro)\n+    cpp_define (pfile, avr_extra_arch_macro);\n+  if (avr_current_arch->have_elpm)\n+    cpp_define (pfile, \"__AVR_HAVE_RAMPZ__\");\n+  if (avr_current_arch->have_elpm)\n+    cpp_define (pfile, \"__AVR_HAVE_ELPM__\");\n+  if (avr_current_arch->have_elpmx)\n+    cpp_define (pfile, \"__AVR_HAVE_ELPMX__\");\n+  if (avr_current_arch->have_movw_lpmx)\n+    {\n+      cpp_define (pfile, \"__AVR_HAVE_MOVW__\");\n+      cpp_define (pfile, \"__AVR_HAVE_LPMX__\");\n+    }\n+  if (avr_current_arch->asm_only)\n+    cpp_define (pfile, \"__AVR_ASM_ONLY__\");\n+  if (avr_current_arch->have_mul)\n+    {\n+      cpp_define (pfile, \"__AVR_ENHANCED__\");\n+      cpp_define (pfile, \"__AVR_HAVE_MUL__\");\n+    }\n+  if (avr_current_arch->have_jmp_call)\n+    {\n+      cpp_define (pfile, \"__AVR_MEGA__\");\n+      cpp_define (pfile, \"__AVR_HAVE_JMP_CALL__\");\n+    }\n+  if (avr_current_arch->have_eijmp_eicall)\n+    {\n+      cpp_define (pfile, \"__AVR_HAVE_EIJMP_EICALL__\");\n+      cpp_define (pfile, \"__AVR_3_BYTE_PC__\");\n+    }\n+  else\n+    {\n+      cpp_define (pfile, \"__AVR_2_BYTE_PC__\");\n+    }\n+\n+  if (avr_current_device->short_sp)\n+    cpp_define (pfile, \"__AVR_HAVE_8BIT_SP__\");\n+  else\n+    cpp_define (pfile, \"__AVR_HAVE_16BIT_SP__\");\n+\n+  if (TARGET_NO_INTERRUPTS)\n+    cpp_define (pfile, \"__NO_INTERRUPTS__\");\n+\n+  /* Define builtin macros so that the user can\n+     easily query if or if not a specific builtin\n+     is available. */\n+\n+  cpp_define (pfile, \"__BUILTIN_AVR_NOP\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_SEI\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_CLI\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_WDR\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_SLEEP\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_SWAP\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_DELAY_CYCLES\");\n+\n+  if (AVR_HAVE_MUL)\n+    {\n+      cpp_define (pfile, \"__BUILTIN_AVR_FMUL\");\n+      cpp_define (pfile, \"__BUILTIN_AVR_FMULS\");\n+      cpp_define (pfile, \"__BUILTIN_AVR_FMULSU\");\n+    }\n+}"}, {"sha": "500a5b287aee0916cb78d85fcc00f2ade7532f4d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "patch": "@@ -29,6 +29,7 @@\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n #include \"flags.h\"\n #include \"reload.h\"\n #include \"tree.h\"\n@@ -38,7 +39,9 @@\n #include \"obstack.h\"\n #include \"function.h\"\n #include \"recog.h\"\n+#include \"optabs.h\"\n #include \"ggc.h\"\n+#include \"langhooks.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -91,6 +94,8 @@ static bool avr_rtx_costs (rtx, int, int, int *, bool);\n static int avr_address_cost (rtx, bool);\n static bool avr_return_in_memory (const_tree, const_tree);\n static struct machine_function * avr_init_machine_status (void);\n+static void avr_init_builtins (void);\n+static rtx avr_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static rtx avr_builtin_setjmp_frame_value (void);\n static bool avr_hard_regno_scratch_ok (unsigned int);\n static unsigned int avr_case_values_threshold (void);\n@@ -253,6 +258,13 @@ static const struct default_options avr_option_optimization_table[] =\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL avr_function_ok_for_sibcall\n \n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS avr_init_builtins\n+\n+#undef TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN avr_expand_builtin\n+\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n static void\n@@ -6432,4 +6444,331 @@ unsigned int avr_case_values_threshold (void)\n   return (!AVR_HAVE_JMP_CALL || TARGET_CALL_PROLOGUES) ? 8 : 17;\n }\n \n+/* Helper for __builtin_avr_delay_cycles */\n+\n+static void\n+avr_expand_delay_cycles (rtx operands0)\n+{\n+  unsigned HOST_WIDE_INT cycles = UINTVAL (operands0);\n+  unsigned HOST_WIDE_INT cycles_used;\n+  unsigned HOST_WIDE_INT loop_count;\n+  \n+  if (IN_RANGE (cycles, 83886082, 0xFFFFFFFF))\n+    {\n+      loop_count = ((cycles - 9) / 6) + 1;\n+      cycles_used = ((loop_count - 1) * 6) + 9;\n+      emit_insn (gen_delay_cycles_4 (gen_int_mode (loop_count, SImode)));\n+      cycles -= cycles_used;\n+    }\n+  \n+  if (IN_RANGE (cycles, 262145, 83886081))\n+    {\n+      loop_count = ((cycles - 7) / 5) + 1;\n+      if (loop_count > 0xFFFFFF)\n+        loop_count = 0xFFFFFF;\n+      cycles_used = ((loop_count - 1) * 5) + 7;\n+      emit_insn (gen_delay_cycles_3 (gen_int_mode (loop_count, SImode)));\n+      cycles -= cycles_used;\n+    }\n+  \n+  if (IN_RANGE (cycles, 768, 262144))\n+    {\n+      loop_count = ((cycles - 5) / 4) + 1;\n+      if (loop_count > 0xFFFF)\n+        loop_count = 0xFFFF;\n+      cycles_used = ((loop_count - 1) * 4) + 5;\n+      emit_insn (gen_delay_cycles_2 (gen_int_mode (loop_count, HImode)));\n+      cycles -= cycles_used;\n+    }\n+  \n+  if (IN_RANGE (cycles, 6, 767))\n+    {\n+      loop_count = cycles / 3;\n+      if (loop_count > 255) \n+        loop_count = 255;\n+      cycles_used = loop_count * 3;\n+      emit_insn (gen_delay_cycles_1 (gen_int_mode (loop_count, QImode)));\n+      cycles -= cycles_used;\n+      }\n+  \n+  while (cycles >= 2)\n+    {\n+      emit_insn (gen_nopv (GEN_INT(2)));\n+      cycles -= 2;\n+    }\n+\n+  if (cycles == 1)\n+    {\n+      emit_insn (gen_nopv (GEN_INT(1)));\n+      cycles--;\n+    }\n+}\n+\n+/* IDs for all the AVR builtins.  */\n+\n+enum avr_builtin_id\n+  {\n+    AVR_BUILTIN_NOP,\n+    AVR_BUILTIN_SEI,\n+    AVR_BUILTIN_CLI,\n+    AVR_BUILTIN_WDR,\n+    AVR_BUILTIN_SLEEP,\n+    AVR_BUILTIN_SWAP,\n+    AVR_BUILTIN_FMUL,\n+    AVR_BUILTIN_FMULS,\n+    AVR_BUILTIN_FMULSU,\n+    AVR_BUILTIN_DELAY_CYCLES\n+  };\n+\n+#define DEF_BUILTIN(NAME, TYPE, CODE)                                   \\\n+  do                                                                    \\\n+    {                                                                   \\\n+      add_builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD,        \\\n+                            NULL, NULL_TREE);                           \\\n+    } while (0)\n+\n+\n+/* Implement `TARGET_INIT_BUILTINS' */\n+/* Set up all builtin functions for this target.  */\n+\n+static void\n+avr_init_builtins (void)\n+{\n+  tree void_ftype_void\n+    = build_function_type (void_type_node, void_list_node);\n+  tree uchar_ftype_uchar\n+    = build_function_type_list (unsigned_char_type_node, \n+                                unsigned_char_type_node,\n+                                NULL_TREE);\n+  tree uint_ftype_uchar_uchar\n+    = build_function_type_list (unsigned_type_node, \n+                                unsigned_char_type_node,\n+                                unsigned_char_type_node, \n+                                NULL_TREE);\n+  tree int_ftype_char_char\n+    = build_function_type_list (integer_type_node, \n+                                char_type_node,\n+                                char_type_node, \n+                                NULL_TREE);\n+  tree int_ftype_char_uchar\n+    = build_function_type_list (integer_type_node, \n+                                char_type_node,\n+                                unsigned_char_type_node, \n+                                NULL_TREE);\n+  tree void_ftype_ulong\n+    = build_function_type_list (void_type_node, \n+                                long_unsigned_type_node,\n+                                NULL_TREE);\n+\n+  DEF_BUILTIN (\"__builtin_avr_nop\", void_ftype_void, AVR_BUILTIN_NOP);\n+  DEF_BUILTIN (\"__builtin_avr_sei\", void_ftype_void, AVR_BUILTIN_SEI);\n+  DEF_BUILTIN (\"__builtin_avr_cli\", void_ftype_void, AVR_BUILTIN_CLI);\n+  DEF_BUILTIN (\"__builtin_avr_wdr\", void_ftype_void, AVR_BUILTIN_WDR);\n+  DEF_BUILTIN (\"__builtin_avr_sleep\", void_ftype_void, AVR_BUILTIN_SLEEP);\n+  DEF_BUILTIN (\"__builtin_avr_swap\", uchar_ftype_uchar, AVR_BUILTIN_SWAP);\n+  DEF_BUILTIN (\"__builtin_avr_delay_cycles\", void_ftype_ulong, \n+               AVR_BUILTIN_DELAY_CYCLES);\n+\n+  if (AVR_HAVE_MUL)\n+    {\n+      /* FIXME: If !AVR_HAVE_MUL, make respective functions available\n+         in libgcc. For fmul and fmuls this is straight forward with\n+         upcoming fixed point support. */\n+      \n+      DEF_BUILTIN (\"__builtin_avr_fmul\", uint_ftype_uchar_uchar, \n+                   AVR_BUILTIN_FMUL);\n+      DEF_BUILTIN (\"__builtin_avr_fmuls\", int_ftype_char_char, \n+                   AVR_BUILTIN_FMULS);\n+      DEF_BUILTIN (\"__builtin_avr_fmulsu\", int_ftype_char_uchar, \n+                   AVR_BUILTIN_FMULSU);\n+    }\n+}\n+\n+#undef DEF_BUILTIN\n+\n+struct avr_builtin_description\n+{\n+  const enum insn_code icode;\n+  const char *const name;\n+  const enum avr_builtin_id id;\n+};\n+\n+static const struct avr_builtin_description\n+bdesc_1arg[] =\n+  {\n+    { CODE_FOR_rotlqi3_4, \"__builtin_avr_swap\", AVR_BUILTIN_SWAP }\n+  };\n+\n+static const struct avr_builtin_description\n+bdesc_2arg[] =\n+  {\n+    { CODE_FOR_fmul, \"__builtin_avr_fmul\", AVR_BUILTIN_FMUL },\n+    { CODE_FOR_fmuls, \"__builtin_avr_fmuls\", AVR_BUILTIN_FMULS },\n+    { CODE_FOR_fmulsu, \"__builtin_avr_fmulsu\", AVR_BUILTIN_FMULSU }\n+  };\n+\n+/* Subroutine of avr_expand_builtin to take care of unop insns.  */\n+\n+static rtx\n+avr_expand_unop_builtin (enum insn_code icode, tree exp,\n+                         rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode op0mode = GET_MODE (op0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    {\n+      target = gen_reg_rtx (tmode);\n+    }\n+\n+  if (op0mode == SImode && mode0 == HImode)\n+    {\n+      op0mode = HImode;\n+      op0 = gen_lowpart (HImode, op0);\n+    }\n+  \n+  gcc_assert (op0mode == mode0 || op0mode == VOIDmode);\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+\n+  pat = GEN_FCN (icode) (target, op0);\n+  if (! pat)\n+    return 0;\n+  \n+  emit_insn (pat);\n+  \n+  return target;\n+}\n+\n+\n+/* Subroutine of avr_expand_builtin to take care of binop insns.  */\n+\n+static rtx\n+avr_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode op0mode = GET_MODE (op0);\n+  enum machine_mode op1mode = GET_MODE (op1);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    {\n+      target = gen_reg_rtx (tmode);\n+    }\n+\n+  if ((op0mode == SImode || op0mode == VOIDmode) && mode0 == HImode)\n+    {\n+      op0mode = HImode;\n+      op0 = gen_lowpart (HImode, op0);\n+    }\n+  \n+  if ((op1mode == SImode || op1mode == VOIDmode) && mode1 == HImode)\n+    {\n+      op1mode = HImode;\n+      op1 = gen_lowpart (HImode, op1);\n+    }\n+  \n+  /* In case the insn wants input operands in modes different from\n+     the result, abort.  */\n+  \n+  gcc_assert ((op0mode == mode0 || op0mode == VOIDmode)\n+              && (op1mode == mode1 || op1mode == VOIDmode));\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  \n+  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  pat = GEN_FCN (icode) (target, op0, op1);\n+  \n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+avr_expand_builtin (tree exp, rtx target,\n+                    rtx subtarget ATTRIBUTE_UNUSED,\n+                    enum machine_mode mode ATTRIBUTE_UNUSED,\n+                    int ignore ATTRIBUTE_UNUSED)\n+{\n+  size_t i;\n+  const struct avr_builtin_description *d;\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  unsigned int id = DECL_FUNCTION_CODE (fndecl);\n+  tree arg0;\n+  rtx op0;\n+\n+  switch (id)\n+    {\n+    case AVR_BUILTIN_NOP:\n+      emit_insn (gen_nopv (GEN_INT(1)));\n+      return 0;\n+      \n+    case AVR_BUILTIN_SEI:\n+      emit_insn (gen_enable_interrupt ());\n+      return 0;\n+      \n+    case AVR_BUILTIN_CLI:\n+      emit_insn (gen_disable_interrupt ());\n+      return 0;\n+      \n+    case AVR_BUILTIN_WDR:\n+      emit_insn (gen_wdr ());\n+      return 0;\n+      \n+    case AVR_BUILTIN_SLEEP:\n+      emit_insn (gen_sleep ());\n+      return 0;\n+      \n+    case AVR_BUILTIN_DELAY_CYCLES:\n+      {\n+        arg0 = CALL_EXPR_ARG (exp, 0);\n+        op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+\n+        if (! CONST_INT_P (op0))\n+          error (\"__builtin_avr_delay_cycles expects a compile time integer constant.\");\n+\n+        avr_expand_delay_cycles (op0);\n+        return 0;\n+      }\n+    }\n+\n+  for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n+    if (d->id == id)\n+      return avr_expand_unop_builtin (d->icode, exp, target);\n+\n+  for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n+    if (d->id == id)\n+      return avr_expand_binop_builtin (d->icode, exp, target);\n+\n+  gcc_unreachable ();\n+}\n+\n+\n #include \"gt-avr.h\""}, {"sha": "86e052aa08acb0d5a06ad3ffd529889d83acbf22", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 163, "deletions": 21, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "patch": "@@ -35,9 +35,6 @@\n ;;  ~  Output 'r' if not AVR_HAVE_JMP_CALL.\n ;;  !  Output 'e' if AVR_HAVE_EIJMP_EICALL.\n \n-;; UNSPEC usage:\n-;;  0  Length of a string, see \"strlenhi\".\n-;;  1  Jump by register pair Z or by table addressed by Z, see \"casesi\".\n \n (define_constants\n   [(REG_X\t26)\n@@ -50,17 +47,29 @@\n    \n    (SREG_ADDR   0x5F)\n    (RAMPZ_ADDR  0x5B)\n-   \n-   (UNSPEC_STRLEN\t0)\n-   (UNSPEC_INDEX_JMP\t1)\n-   (UNSPEC_SEI\t\t2)\n-   (UNSPEC_CLI\t\t3)\n-\n-   (UNSPECV_PROLOGUE_SAVES\t0)\n-   (UNSPECV_EPILOGUE_RESTORES\t1)\n-   (UNSPECV_WRITE_SP_IRQ_ON\t2)\n-   (UNSPECV_WRITE_SP_IRQ_OFF\t3)\n-   (UNSPECV_GOTO_RECEIVER\t4)])\n+   ])\n+\n+(define_c_enum \"unspec\"\n+  [UNSPEC_STRLEN\n+   UNSPEC_INDEX_JMP\n+   UNSPEC_FMUL\n+   UNSPEC_FMULS\n+   UNSPEC_FMULSU\n+   ])\n+\n+(define_c_enum \"unspecv\"\n+  [UNSPECV_PROLOGUE_SAVES\n+   UNSPECV_EPILOGUE_RESTORES\n+   UNSPECV_WRITE_SP_IRQ_ON\n+   UNSPECV_WRITE_SP_IRQ_OFF\n+   UNSPECV_GOTO_RECEIVER\n+   UNSPECV_ENABLE_IRQS\n+   UNSPECV_NOP\n+   UNSPECV_SLEEP\n+   UNSPECV_WDR\n+   UNSPECV_DELAY_CYCLES\n+   ])\n+    \n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -1489,7 +1498,7 @@\n     FAIL;\n }\")\n \n-(define_insn \"*rotlqi3_4\"\n+(define_insn \"rotlqi3_4\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(rotate:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t   (const_int 4)))]\n@@ -3130,21 +3139,19 @@\n \n ;; Enable Interrupts\n (define_insn \"enable_interrupt\"\n-  [(unspec [(const_int 0)] UNSPEC_SEI)]\n+  [(unspec_volatile [(const_int 1)] UNSPECV_ENABLE_IRQS)]\n   \"\"\n   \"sei\"\n   [(set_attr \"length\" \"1\")\n-  (set_attr \"cc\" \"none\")\n-  ])\n+   (set_attr \"cc\" \"none\")])\n \n ;; Disable Interrupts\n (define_insn \"disable_interrupt\"\n-  [(unspec [(const_int 0)] UNSPEC_CLI)]\n+  [(unspec_volatile [(const_int 0)] UNSPECV_ENABLE_IRQS)]\n   \"\"\n   \"cli\"\n   [(set_attr \"length\" \"1\")\n-  (set_attr \"cc\" \"none\")\n-  ])\n+   (set_attr \"cc\" \"none\")])\n \n ;;  Library prologue saves\n (define_insn \"call_prologue_saves\"\n@@ -3246,3 +3253,138 @@\n     expand_epilogue (true /* sibcall_p */);\n     DONE;\n   })\n+\n+;; Some instructions resp. instruction sequences available\n+;; via builtins.\n+\n+(define_insn \"delay_cycles_1\"\n+  [(unspec_volatile [(match_operand:QI 0 \"const_int_operand\" \"n\")\n+                     (const_int 1)]\n+                    UNSPECV_DELAY_CYCLES)\n+   (clobber (match_scratch:QI 1 \"=&d\"))]\n+  \"\"\n+  \"ldi %1,lo8(%0)\n+\t1: dec %1\n+\tbrne 1b\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"delay_cycles_2\"\n+  [(unspec_volatile [(match_operand:HI 0 \"const_int_operand\" \"n\")\n+                     (const_int 2)]\n+                    UNSPECV_DELAY_CYCLES)\n+   (clobber (match_scratch:HI 1 \"=&w\"))]\n+  \"\"\n+  \"ldi %A1,lo8(%0)\n+\tldi %B1,hi8(%0)\n+\t1: sbiw %A1,1\n+\tbrne 1b\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"delay_cycles_3\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"n\")\n+                     (const_int 3)]\n+                    UNSPECV_DELAY_CYCLES)\n+   (clobber (match_scratch:QI 1 \"=&d\"))\n+   (clobber (match_scratch:QI 2 \"=&d\"))\n+   (clobber (match_scratch:QI 3 \"=&d\"))]\n+  \"\"\n+  \"ldi %1,lo8(%0)\n+\tldi %2,hi8(%0)\n+\tldi %3,hlo8(%0)\n+\t1: subi %1,1\n+\tsbci %2,0\n+\tsbci %3,0\n+\tbrne 1b\"\n+  [(set_attr \"length\" \"7\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"delay_cycles_4\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"n\")\n+                     (const_int 4)]\n+                    UNSPECV_DELAY_CYCLES)\n+   (clobber (match_scratch:QI 1 \"=&d\"))\n+   (clobber (match_scratch:QI 2 \"=&d\"))\n+   (clobber (match_scratch:QI 3 \"=&d\"))\n+   (clobber (match_scratch:QI 4 \"=&d\"))]\n+  \"\"\n+  \"ldi %1,lo8(%0)\n+\tldi %2,hi8(%0)\n+\tldi %3,hlo8(%0)\n+\tldi %4,hhi8(%0)\n+\t1: subi %1,1\n+\tsbci %2,0\n+\tsbci %3,0\n+\tsbci %4,0\n+\tbrne 1b\"\n+  [(set_attr \"length\" \"9\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; CPU instructions\n+\n+;; NOP taking 1 or 2 Ticks \n+(define_insn \"nopv\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"P,K\")] \n+                    UNSPECV_NOP)]\n+  \"\"\n+  \"@\n+\tnop\n+\trjmp .\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"none\")])\n+\n+;; SLEEP\n+(define_insn \"sleep\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SLEEP)]\n+  \"\"\n+  \"sleep\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"none\")])\n+ \n+;; WDR\n+(define_insn \"wdr\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_WDR)]\n+  \"\"\n+  \"wdr\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"cc\" \"none\")])\n+  \n+;; FMUL\n+(define_insn \"fmul\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (unspec:HI [(match_operand:QI 1 \"register_operand\" \"a\")\n+                    (match_operand:QI 2 \"register_operand\" \"a\")]\n+                   UNSPEC_FMUL))]\n+  \"AVR_HAVE_MUL\"\n+  \"fmul %1,%2\n+\tmovw %0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; FMULS\n+(define_insn \"fmuls\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (unspec:HI [(match_operand:QI 1 \"register_operand\" \"a\")\n+                    (match_operand:QI 2 \"register_operand\" \"a\")]\n+                   UNSPEC_FMULS))]\n+  \"AVR_HAVE_MUL\"\n+  \"fmuls %1,%2\n+\tmovw %0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; FMULSU\n+(define_insn \"fmulsu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (unspec:HI [(match_operand:QI 1 \"register_operand\" \"a\")\n+                    (match_operand:QI 2 \"register_operand\" \"a\")]\n+                   UNSPEC_FMULSU))]\n+  \"AVR_HAVE_MUL\"\n+  \"fmulsu %1,%2\n+\tmovw %0,r0\n+\tclr __zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])"}, {"sha": "67a4b1f8583fdcdae4c7178f75cd31f01c5215c0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=43ea65025fe00ea78bbbc2ce7c4b1e8f6e758d9b", "patch": "@@ -7924,6 +7924,7 @@ instructions, but allow the compiler to schedule those calls.\n * Alpha Built-in Functions::\n * ARM iWMMXt Built-in Functions::\n * ARM NEON Intrinsics::\n+* AVR Built-in Functions::\n * Blackfin Built-in Functions::\n * FR-V Built-in Functions::\n * X86 Built-in Functions::\n@@ -8175,6 +8176,44 @@ when the @option{-mfpu=neon} switch is used:\n \n @include arm-neon-intrinsics.texi\n \n+@node AVR Built-in Functions\n+@subsection AVR Built-in Functions\n+\n+For each built-in function for AVR, there is an equally named,\n+uppercase built-in macro defined. That way users can easily query if\n+or if not a specific built-in is implemented or not. For example, if\n+@code{__builtin_avr_nop} is available the macro\n+@code{__BUILTIN_AVR_NOP} is defined to @code{1} and undefined otherwise.\n+\n+The following built-in functions map to the respective machine\n+instruction, i.e. @code{nop}, @code{sei}, @code{cli}, @code{sleep},\n+@code{wdr}, @code{swap}, @code{fmul}, @code{fmuls}\n+resp. @code{fmulsu}. The latter three are only available if the AVR\n+device actually supports multiplication.\n+\n+@smallexample\n+void __builtin_avr_nop (void)\n+void __builtin_avr_sei (void)\n+void __builtin_avr_cli (void)\n+void __builtin_avr_sleep (void)\n+void __builtin_avr_wdr (void)\n+unsigned char __builtin_avr_swap (unsigned char)\n+unsigned int __builtin_avr_fmul (unsigned char, unsigned char)\n+int __builtin_avr_fmuls (char, char)\n+int __builtin_avr_fmulsu (char, unsigned char)\n+@end smallexample\n+\n+In order to delay execution for a specific number of cycles, GCC\n+implements\n+@smallexample\n+void __builtin_avr_delay_cycles (unsigned long ticks)\n+@end smallexample\n+\n+@code{ticks} is the number of ticks to delay execution. Note that this\n+built-in does not take into account the effect of interrupts which\n+might increase delay time. @code{ticks} must be a compile time\n+integer constant; delays with a variable number of cycles are not supported.\n+\n @node Blackfin Built-in Functions\n @subsection Blackfin Built-in Functions\n "}]}