{"sha": "e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhMmY3MDU5OTZkOWY5ZTk4MjMxYzBjY2FhOWNjNDBlZTI2NDk3Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-05-02T13:55:35Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-02T13:55:35Z"}, "message": "combine.c: Fix comment formatting.\n\n\t* combine.c: Fix comment formatting.\n\t* expr.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* stmt.c: Likewise.\n\t* tree.h: Likewise.\n\nFrom-SVN: r53044", "tree": {"sha": "309ff5ee9c13a1484440448d5a366e642c796c96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/309ff5ee9c13a1484440448d5a366e642c796c96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/comments", "author": null, "committer": null, "parents": [{"sha": "38e23049b7b5ea8f84ce8363d1a13883c71a1edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e23049b7b5ea8f84ce8363d1a13883c71a1edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e23049b7b5ea8f84ce8363d1a13883c71a1edc"}], "stats": {"total": 50, "additions": 29, "deletions": 21}, "files": [{"sha": "0729db8c8706fdd9caa968905e6bb8d347eaca39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "patch": "@@ -1,3 +1,11 @@\n+2002-05-02  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* combine.c: Fix comment formatting.\n+\t* expr.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* tree.h: Likewise.\n+\n 2002-05-02  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* doc/install.texi: State GNAT version requirements."}, {"sha": "f3d43c49509cb0986e348282aa58d259eca3d587", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "patch": "@@ -5600,7 +5600,7 @@ expand_compound_operation (x)\n \n       len = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)));\n       /* If the inner object has VOIDmode (the only way this can happen\n-\t is if it is a ASM_OPERANDS), we can't do anything since we don't\n+\t is if it is an ASM_OPERANDS), we can't do anything since we don't\n \t know how much masking to do.  */\n       if (len == 0)\n \treturn x;\n@@ -7076,7 +7076,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t    }\n \t}\n \n-      /* If MASK is 1, convert this to a LSHIFTRT.  This can be done\n+      /* If MASK is 1, convert this to an LSHIFTRT.  This can be done\n \t even if the shift count isn't a constant.  */\n       if (mask == 1)\n \tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0), XEXP (x, 1));\n@@ -7884,7 +7884,7 @@ simplify_and_const_int (x, mode, varop, constop)\n     return const0_rtx;\n \n   /* If VAROP is a NEG of something known to be zero or 1 and CONSTOP is\n-     a power of two, we can replace this with a ASHIFT.  */\n+     a power of two, we can replace this with an ASHIFT.  */\n   if (GET_CODE (varop) == NEG && nonzero_bits (XEXP (varop, 0), mode) == 1\n       && (i = exact_log2 (constop)) >= 0)\n     return simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (varop, 0), i);\n@@ -9054,8 +9054,8 @@ simplify_shift_const (x, code, result_mode, varop, orig_count)\n \n       /* We simplify the tests below and elsewhere by converting\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n-\t `make_compound_operation' will convert it to a ASHIFTRT for\n-\t those machines (such as VAX) that don't have a LSHIFTRT.  */\n+\t `make_compound_operation' will convert it to an ASHIFTRT for\n+\t those machines (such as VAX) that don't have an LSHIFTRT.  */\n       if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && code == ASHIFTRT\n \t  && ((nonzero_bits (varop, shift_mode)\n@@ -9228,7 +9228,7 @@ simplify_shift_const (x, code, result_mode, varop, orig_count)\n \n \t      /* If this was (ashiftrt (ashift foo C1) C2) and FOO has more\n \t\t than C1 high-order bits equal to the sign bit, we can convert\n-\t\t this to either an ASHIFT or a ASHIFTRT depending on the\n+\t\t this to either an ASHIFT or an ASHIFTRT depending on the\n \t\t two counts.\n \n \t\t We cannot do this if VAROP's mode is not SHIFT_MODE.  */\n@@ -9628,7 +9628,7 @@ simplify_shift_const (x, code, result_mode, varop, orig_count)\n     x = simplify_shift_const (x, code, shift_mode, XEXP (x, 0),\n \t\t\t      INTVAL (XEXP (x, 1)));\n \n-  /* If we were doing a LSHIFTRT in a wider mode than it was originally,\n+  /* If we were doing an LSHIFTRT in a wider mode than it was originally,\n      turn off all the bits that the shift would have turned off.  */\n   if (orig_code == LSHIFTRT && result_mode != shift_mode)\n     x = simplify_and_const_int (NULL_RTX, shift_mode, x,"}, {"sha": "46cf042ecb546e6fcd0fbac01bf45ed22d2cd42e", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "patch": "@@ -8906,7 +8906,7 @@ is_aligning_offset (offset, exp)\n \t\t      == TREE_TYPE (exp)))));\n }\n \f\n-/* Return the tree node if a ARG corresponds to a string constant or zero\n+/* Return the tree node if an ARG corresponds to a string constant or zero\n    if it doesn't.  If we return non-zero, set *PTR_OFFSET to the offset\n    in bytes within the string that ARG is accessing.  The type of the\n    offset will be `sizetype'.  */"}, {"sha": "dcb99aa10fb754714894e241832a221a6bfced9e", "filename": "gcc/genautomata.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "patch": "@@ -1134,7 +1134,7 @@ struct ainsn\n   /* The following member has nonzero value if there is arc from state of\n      the automaton marked by the ainsn.  */\n   char arc_exists_p;\n-  /* Cyclic list of insns of a equivalence class is formed with the\n+  /* Cyclic list of insns of an equivalence class is formed with the\n      aid of the following field.  */\n   ainsn_t next_equiv_class_insn;\n   /* The following field value is nonzero if the insn declaration is\n@@ -1268,7 +1268,7 @@ check_name (name, pos)\n    following.  */\n static vla_ptr_t decls;\n \n-/* Given a pointer to a (char *) and a separator, return a alloc'ed\n+/* Given a pointer to a (char *) and a separator, return an alloc'ed\n    string containing the next separated element, taking parentheses\n    into account if PAR_FLAG has nonzero value.  Advance the pointer to\n    after the string scanned, or the end-of-string.  Return NULL if at\n@@ -1471,7 +1471,7 @@ gen_bypass (def)\n       }\n }\n \n-/* Process a EXCLUSION_SET.  \n+/* Process an EXCLUSION_SET.  \n \n    This gives information about a cpu unit conflicts.  We fill a\n    struct unit_rel_decl (excl) with information used later by\n@@ -1550,7 +1550,7 @@ gen_presence_set (def)\n   num_dfa_decls++;\n }\n \n-/* Process a ABSENCE_SET.  \n+/* Process an ABSENCE_SET.  \n \n    This gives information about a cpu unit reservation requirements.\n    We fill a struct unit_rel_decl (absence) with information used\n@@ -1618,7 +1618,7 @@ gen_automaton (def)\n     }\n }\n \n-/* Process a AUTOMATA_OPTION.  \n+/* Process an AUTOMATA_OPTION.  \n \n    This gives information how to generate finite state automaton used\n    for recognizing pipeline hazards.  */\n@@ -1859,7 +1859,7 @@ string_hash (string)\n    Key of the table elements is name of given automaton.  Rememeber\n    that automaton names have own space.  */\n \n-/* The function evaluates hash value of a automaton declaration.  The\n+/* The function evaluates hash value of an automaton declaration.  The\n    function is used by abstract data `hashtab'.  The function returns\n    hash value (0..UINT_MAX) of given automaton declaration.  */\n static unsigned\n@@ -1961,7 +1961,7 @@ finish_automaton_decl_table ()\n    define_insn_reservation).  Rememeber that insn names have own\n    space.  */\n \n-/* The function evaluates hash value of a insn declaration.  The\n+/* The function evaluates hash value of an insn declaration.  The\n    function is used by abstract data `hashtab'.  The function returns\n    hash value (0..UINT_MAX) of given insn declaration.  */\n static unsigned"}, {"sha": "42a9659ade6970c1e1e2c691bee6f8f42e4f6065", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "patch": "@@ -204,7 +204,7 @@ struct nesting\n \t  struct label_chain *label_chain;\n \t  /* Number of function calls seen, as of start of this block.  */\n \t  int n_function_calls;\n-\t  /* Nonzero if this is associated with a EH region.  */\n+\t  /* Nonzero if this is associated with an EH region.  */\n \t  int exception_region;\n \t  /* The saved target_temp_slot_level from our outer block.\n \t     We may reset target_temp_slot_level to be the level of\n@@ -5170,7 +5170,7 @@ check_for_full_enumeration_handling (type)\n \n       /* The time complexity of this code is normally O(N), where\n \t N being the number of members in the enumerated type.\n-\t However, if type is a ENUMERAL_TYPE whose values do not\n+\t However, if type is an ENUMERAL_TYPE whose values do not\n \t increase monotonically, O(N*log(N)) time may be needed.  */\n \n       mark_seen_cases (type, cases_seen, size, sparseness);"}, {"sha": "b7a45e77938970f5bfed29a901ac5c2480fbb061", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a2f705996d9f9e98231c0ccaa9cc40ee264976/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e0a2f705996d9f9e98231c0ccaa9cc40ee264976", "patch": "@@ -667,7 +667,7 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n \n #define TREE_BOUNDED(NODE) ((NODE)->common.bounded_flag)\n \n-/* Nonzero in a IDENTIFIER_NODE if the use of the name is defined as a\n+/* Nonzero in an IDENTIFIER_NODE if the use of the name is defined as a\n    deprecated feature by __attribute__((deprecated)).  */\n #define TREE_DEPRECATED(NODE) ((NODE)->common.deprecated_flag)\n \n@@ -852,15 +852,15 @@ struct tree_vec\n #define LABELED_BLOCK_BODY(NODE) \\\n   TREE_OPERAND (LABELED_BLOCK_EXPR_CHECK (NODE), 1)\n \n-/* In a EXIT_BLOCK_EXPR node.  */\n+/* In an EXIT_BLOCK_EXPR node.  */\n #define EXIT_BLOCK_LABELED_BLOCK(NODE) \\\n   TREE_OPERAND (EXIT_BLOCK_EXPR_CHECK (NODE), 0)\n #define EXIT_BLOCK_RETURN(NODE) TREE_OPERAND (EXIT_BLOCK_EXPR_CHECK (NODE), 1)\n \n /* In a LOOP_EXPR node.  */\n #define LOOP_EXPR_BODY(NODE) TREE_OPERAND (LOOP_EXPR_CHECK (NODE), 0)\n \n-/* In a EXPR_WITH_FILE_LOCATION node.  */\n+/* In an EXPR_WITH_FILE_LOCATION node.  */\n #define EXPR_WFL_EMIT_LINE_NOTE(NODE) \\\n   (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->common.public_flag)\n #define EXPR_WFL_NODE(NODE) \\\n@@ -1324,7 +1324,7 @@ struct tree_type\n    base.  The actual contents are language-dependent.  Under the old\n    ABI, the C++ front-end uses a FIELD_DECL whose contents are a\n    pointer to the virtual base; under the new ABI this field is\n-   instead a INTEGER_CST giving an offset into the vtable where the\n+   instead an INTEGER_CST giving an offset into the vtable where the\n    offset to the virtual base can be found.  */\n #define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT (NODE, 5)\n "}]}