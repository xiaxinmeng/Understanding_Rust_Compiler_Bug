{"sha": "c782c2fed844c4e6e1ea4944866e166ae69fcae2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc4MmMyZmVkODQ0YzRlNmUxZWE0OTQ0ODY2ZTE2NmFlNjlmY2FlMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-08-26T23:51:14Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-08-26T23:51:14Z"}, "message": "tree.h (CASE_LOW_SEEN, [...]): New macros for manipulating temporary visit flags on CASE_LABEL_EXPRs.\n\n\n\t* tree.h (CASE_LOW_SEEN, CASE_HIGH_SEEN): New macros for manipulating\n\ttemporary visit flags on CASE_LABEL_EXPRs.\n\t* c-common.c (match_case_to_enum): Add function comment.  Avoid\n\tO(N) loop, by looking up both CASE_LOW_SEEN and CASE_HIGH_SEEN.\n\t(c_do_switch_warnings):  Reorganize to record CASE_LOW_SEEN and\n\tCASE_HIGH_SEEN for enumerated types.  If the switch expression is\n\ta constant, only warn if that constant value isn't handled.\n\n\t* gcc.dg/Wswitch-enum-2.c: New test case.\n\t* gcc.dg/Wswitch-enum-3.c: Likewise.\n\nFrom-SVN: r116481", "tree": {"sha": "69dba2343ca72d778fac60a1c90248608167d71f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69dba2343ca72d778fac60a1c90248608167d71f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c782c2fed844c4e6e1ea4944866e166ae69fcae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c782c2fed844c4e6e1ea4944866e166ae69fcae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c782c2fed844c4e6e1ea4944866e166ae69fcae2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c782c2fed844c4e6e1ea4944866e166ae69fcae2/comments", "author": null, "committer": null, "parents": [{"sha": "52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ccd5770a6d24a8b13e51817d4f1ba38b8528c6"}], "stats": {"total": 210, "additions": 137, "deletions": 73}, "files": [{"sha": "e55f6c94777a663fda33d990e7302d046f4c1524", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c782c2fed844c4e6e1ea4944866e166ae69fcae2", "patch": "@@ -1,3 +1,13 @@\n+2006-08-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree.h (CASE_LOW_SEEN, CASE_HIGH_SEEN): New macros for manipulating\n+\ttemporary visit flags on CASE_LABEL_EXPRs.\n+\t* c-common.c (match_case_to_enum): Add function comment.  Avoid\n+\tO(N) loop, by looking up both CASE_LOW_SEEN and CASE_HIGH_SEEN.\n+\t(c_do_switch_warnings):  Reorganize to record CASE_LOW_SEEN and\n+\tCASE_HIGH_SEEN for enumerated types.  If the switch expression is\n+\ta constant, only warn if that constant value isn't handled.\n+\n 2006-08-26  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c++/24009"}, {"sha": "62d5261e5f79003392eddb18ad511b812f086659", "filename": "gcc/c-common.c", "status": "modified", "additions": 74, "deletions": 73, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c782c2fed844c4e6e1ea4944866e166ae69fcae2", "patch": "@@ -3797,6 +3797,9 @@ match_case_to_enum_1 (tree key, tree type, tree label)\n \t     CASE_LABEL (label), buf, type);\n }\n \n+/* Subroutine of c_do_switch_warnings, called via splay_tree_foreach.\n+   Used to verify that case values match up with enumerator values.  */\n+\n static int\n match_case_to_enum (splay_tree_node node, void *data)\n {\n@@ -3807,26 +3810,22 @@ match_case_to_enum (splay_tree_node node, void *data)\n   if (!CASE_LOW (label))\n     return 0;\n \n-  /* If TREE_ADDRESSABLE is not set, that means CASE_LOW did not appear\n+  /* If CASE_LOW_SEEN is not set, that means CASE_LOW did not appear\n      when we did our enum->case scan.  Reset our scratch bit after.  */\n-  if (!TREE_ADDRESSABLE (label))\n+  if (!CASE_LOW_SEEN (label))\n     match_case_to_enum_1 (CASE_LOW (label), type, label);\n   else\n-    TREE_ADDRESSABLE (label) = 0;\n+    CASE_LOW_SEEN (label) = 0;\n \n-  /* If CASE_HIGH is non-null, we have a range.  Here we must search.\n-     Note that the old code in stmt.c did not check for the values in\n-     the range either, just the endpoints.  */\n+  /* If CASE_HIGH is non-null, we have a range.  If CASE_HIGH_SEEN is\n+     not set, that means that CASE_HIGH did not appear when we did our\n+     enum->case scan.  Reset our scratch bit after.  */\n   if (CASE_HIGH (label))\n     {\n-      tree chain, key = CASE_HIGH (label);\n-\n-      for (chain = TYPE_VALUES (type);\n-\t   chain && !tree_int_cst_equal (key, TREE_VALUE (chain));\n-\t   chain = TREE_CHAIN (chain))\n-\tcontinue;\n-      if (!chain)\n-\tmatch_case_to_enum_1 (key, type, label);\n+      if (!CASE_HIGH_SEEN (label))\n+\tmatch_case_to_enum_1 (CASE_HIGH (label), type, label);\n+      else\n+\tCASE_HIGH_SEEN (label) = 0;\n     }\n \n   return 0;\n@@ -3844,6 +3843,8 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n \t\t      tree type, tree cond)\n {\n   splay_tree_node default_node;\n+  splay_tree_node node;\n+  tree chain;\n \n   if (!warn_switch && !warn_switch_enum && !warn_switch_default)\n     return;\n@@ -3853,79 +3854,79 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n     warning (OPT_Wswitch_default, \"%Hswitch missing default case\",\n \t     &switch_location);\n \n+  /* From here on, we only care about about enumerated types.  */\n+  if (!type || TREE_CODE (type) != ENUMERAL_TYPE)\n+    return;\n+\n   /* If the switch expression was an enumerated type, check that\n      exactly all enumeration literals are covered by the cases.\n      The check is made when -Wswitch was specified and there is no\n      default case, or when -Wswitch-enum was specified.  */\n-  if (((warn_switch && !default_node) || warn_switch_enum)\n-      && type && TREE_CODE (type) == ENUMERAL_TYPE\n-      && TREE_CODE (cond) != INTEGER_CST)\n-    {\n-      tree chain;\n \n-      /* The time complexity here is O(N*lg(N)) worst case, but for the\n-\t common case of monotonically increasing enumerators, it is\n-\t O(N), since the nature of the splay tree will keep the next\n-\t element adjacent to the root at all times.  */\n+  if (!warn_switch_enum\n+      && !(warn_switch && !default_node))\n+    return;\n+\n+  /* Clearing COND if it is not an integer constant simplifies\n+     the tests inside the loop below.  */\n+  if (TREE_CODE (cond) != INTEGER_CST)\n+    cond = NULL_TREE;\n+\n+  /* The time complexity here is O(N*lg(N)) worst case, but for the\n+      common case of monotonically increasing enumerators, it is\n+      O(N), since the nature of the splay tree will keep the next\n+      element adjacent to the root at all times.  */\n \n-      for (chain = TYPE_VALUES (type); chain; chain = TREE_CHAIN (chain))\n+  for (chain = TYPE_VALUES (type); chain; chain = TREE_CHAIN (chain))\n+    {\n+      tree value = TREE_VALUE (chain);\n+      node = splay_tree_lookup (cases, (splay_tree_key) value);\n+      if (node)\n \t{\n-\t  splay_tree_node node\n-\t    = splay_tree_lookup (cases, (splay_tree_key) TREE_VALUE (chain));\n-\t  if (!node)\n-\t    {\n-\t      tree low_value = TREE_VALUE (chain);\n-\t      splay_tree_node low_bound;\n-\t      splay_tree_node high_bound;\n-\t      /* Even though there wasn't an exact match, there might be a\n-\t\t case range which includes the enumator's value.  */\n-\t      low_bound = splay_tree_predecessor (cases,\n-\t\t\t\t\t\t  (splay_tree_key) low_value);\n-\t      high_bound = splay_tree_successor (cases,\n-\t\t\t\t\t\t (splay_tree_key) low_value);\n-\n-\t      /* It is smaller than the LOW_VALUE, so there is no need to check\n-\t\t unless the LOW_BOUND is in fact itself a case range.  */\n-\t      if (low_bound\n-\t\t  && CASE_HIGH ((tree) low_bound->value)\n-\t\t  && tree_int_cst_compare (CASE_HIGH ((tree) low_bound->value),\n-\t\t\t\t\t    low_value) >= 0)\n-\t\tnode = low_bound;\n-\t      /* The low end of that range is bigger than the current value. */\n-\t      else if (high_bound\n-\t\t       && (tree_int_cst_compare ((tree) high_bound->key,\n-\t\t\t\t\t\t low_value)\n-\t\t\t   <= 0))\n-\t\tnode = high_bound;\n-\t    }\n-\t  if (node)\n-\t    {\n-\t      /* Mark the CASE_LOW part of the case entry as seen, so\n-\t\t that we save time later.  Choose TREE_ADDRESSABLE\n-\t\t randomly as a bit that won't have been set to-date.  */\n-\t      tree label = (tree) node->value;\n-\t      TREE_ADDRESSABLE (label) = 1;\n-\t    }\n-\t  else\n+\t  /* Mark the CASE_LOW part of the case entry as seen.  */\n+\t  tree label = (tree) node->value;\n+\t  CASE_LOW_SEEN (label) = 1;\n+\t  continue;\n+\t}\n+\n+      /* Even though there wasn't an exact match, there might be a\n+\t case range which includes the enumator's value.  */\n+      node = splay_tree_predecessor (cases, (splay_tree_key) value);\n+      if (node && CASE_HIGH ((tree) node->value))\n+\t{\n+\t  tree label = (tree) node->value;\n+\t  int cmp = tree_int_cst_compare (CASE_HIGH (label), value);\n+\t  if (cmp >= 0)\n \t    {\n-\t      /* Warn if there are enumerators that don't correspond to\n-\t\t case expressions.  */\n-\t      warning (0, \"%Henumeration value %qE not handled in switch\",\n-\t\t       &switch_location, TREE_PURPOSE (chain));\n+\t      /* If we match the upper bound exactly, mark the CASE_HIGH\n+\t\t part of the case entry as seen.  */\n+\t      if (cmp == 0)\n+\t\tCASE_HIGH_SEEN (label) = 1;\n+\t      continue;\n \t    }\n \t}\n \n-      /* Warn if there are case expressions that don't correspond to\n-\t enumerators.  This can occur since C and C++ don't enforce\n-\t type-checking of assignments to enumeration variables.\n+      /* We've now determined that this enumerated literal isn't\n+\t handled by the case labels of the switch statement.  */\n \n-\t The time complexity here is O(N**2) worst case, since we've\n-\t not sorted the enumeration values.  However, in the absence\n-\t of case ranges this is O(N), since all single cases that\n-\t corresponded to enumerations have been marked above.  */\n+      /* If the switch expression is a constant, we only really care\n+\t about whether that constant is handled by the switch.  */\n+      if (cond && tree_int_cst_compare (cond, value))\n+\tcontinue;\n \n-      splay_tree_foreach (cases, match_case_to_enum, type);\n+      warning (0, \"%Henumeration value %qE not handled in switch\",\n+\t       &switch_location, TREE_PURPOSE (chain));\n     }\n+\n+  /* Warn if there are case expressions that don't correspond to\n+     enumerators.  This can occur since C and C++ don't enforce\n+     type-checking of assignments to enumeration variables.\n+\n+     The time complexity here is now always O(N) worst case, since\n+     we should have marked both the lower bound and upper bound of\n+     every disjoint case label, with CASE_LOW_SEEN and CASE_HIGH_SEEN\n+     above.  This scan also resets those fields.  */\n+  splay_tree_foreach (cases, match_case_to_enum, type);\n }\n \n /* Finish an expression taking the address of LABEL (an"}, {"sha": "c6a3dc352842b36fe0a69409a41c20e62644674f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c782c2fed844c4e6e1ea4944866e166ae69fcae2", "patch": "@@ -1,3 +1,8 @@\n+2006-08-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/Wswitch-enum-2.c: New test case.\n+\t* gcc.dg/Wswitch-enum-3.c: Likewise.\n+\n 2006-08-26  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.c-torture/compile/20060826-1.c: New testcase."}, {"sha": "6b5ca1d307d15a1d4e2e28dda05880d84736a005", "filename": "gcc/testsuite/gcc.dg/Wswitch-enum-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum-2.c?ref=c782c2fed844c4e6e1ea4944866e166ae69fcae2", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wswitch-enum\" } */\n+\n+typedef enum { a = 2 } T;\n+\n+int main()\n+{\n+    T x = a;\n+    switch(x)\n+    {\n+    case a ... 3: /* { dg-warning \"case value '3' not in enumerated\" \"3\" } */\n+        break;\n+    }\n+    switch(x)\n+    {\n+    case 1 ... a: /* { dg-warning \"case value '1' not in enumerated\" \"1\" } */\n+        break;\n+    }\n+    return 0;\n+}\n+"}, {"sha": "98db4d578f151544e9d568fe088337c08ac25063", "filename": "gcc/testsuite/gcc.dg/Wswitch-enum-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum-3.c?ref=c782c2fed844c4e6e1ea4944866e166ae69fcae2", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wswitch-enum\" } */\n+\n+typedef enum { a = 2 } T;\n+\n+int main()\n+{\n+    switch((T)a) /* { dg-warning \"enumeration value 'a' not handled\" \"a\" } */\n+    {\n+    case 1: /* { dg-warning \"case value '1' not in enumerated\" \"1\" } */\n+        break;\n+    }\n+    return 0;\n+}\n+"}, {"sha": "72a8e46bd033866493d4d0f65c2aee1fe937aed6", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c782c2fed844c4e6e1ea4944866e166ae69fcae2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c782c2fed844c4e6e1ea4944866e166ae69fcae2", "patch": "@@ -395,6 +395,7 @@ struct tree_common GTY(())\n \t   In a STMT_EXPR, it means we want the result of the enclosed\n \t   expression.\n        CALL_EXPR_TAILCALL in CALL_EXPR\n+       CASE_LOW_SEEN in CASE_LABEL_EXPR\n \n    static_flag:\n \n@@ -413,6 +414,7 @@ struct tree_common GTY(())\n        EH_FILTER_MUST_NOT_THROW in EH_FILTER_EXPR\n        TYPE_REF_CAN_ALIAS_ALL in\n            POINTER_TYPE, REFERENCE_TYPE\n+       CASE_HIGH_SEEN in CASE_LABEL_EXPR\n \n    public_flag:\n \n@@ -1024,6 +1026,11 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    call optimizations.  */\n #define CALL_EXPR_TAILCALL(NODE) (CALL_EXPR_CHECK(NODE)->common.addressable_flag)\n \n+/* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the\n+   CASE_LOW operand has been processed.  */\n+#define CASE_LOW_SEEN(NODE) \\\n+  (CASE_LABEL_EXPR_CHECK (NODE)->common.addressable_flag)\n+\n /* In a VAR_DECL, nonzero means allocate static storage.\n    In a FUNCTION_DECL, nonzero if function has been defined.\n    In a CONSTRUCTOR, nonzero means allocate static storage.\n@@ -1037,6 +1044,11 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n    of its scope.  */\n #define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)\n \n+/* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the\n+   CASE_HIGH operand has been processed.  */\n+#define CASE_HIGH_SEEN(NODE) \\\n+  (CASE_LABEL_EXPR_CHECK (NODE)->common.static_flag)\n+\n /* In an expr node (usually a conversion) this means the node was made\n    implicitly and should not lead to any sort of warning.  In a decl node,\n    warnings concerning the decl should be suppressed.  This is used at"}]}