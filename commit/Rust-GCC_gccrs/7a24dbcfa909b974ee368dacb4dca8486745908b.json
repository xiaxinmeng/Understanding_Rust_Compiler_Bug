{"sha": "7a24dbcfa909b974ee368dacb4dca8486745908b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyNGRiY2ZhOTA5Yjk3NGVlMzY4ZGFjYjRkY2E4NDg2NzQ1OTA4Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-03-29T22:32:08Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-03-29T22:32:08Z"}, "message": "(i960_function_prologue): When profiling, don't use those registers clobbered around an mcount call.\n\n(i960_function_prologue): When profiling, don't use those\nregisters clobbered around an mcount call.\n(output_function_profiler): New function.\n\nFrom-SVN: r3916", "tree": {"sha": "f958f415c5bd1b0ab9d056e58a6e59f0aa8a14d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f958f415c5bd1b0ab9d056e58a6e59f0aa8a14d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a24dbcfa909b974ee368dacb4dca8486745908b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a24dbcfa909b974ee368dacb4dca8486745908b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a24dbcfa909b974ee368dacb4dca8486745908b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a24dbcfa909b974ee368dacb4dca8486745908b/comments", "author": null, "committer": null, "parents": [{"sha": "77545d45a37ae31d6749dd80ed71362081579697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77545d45a37ae31d6749dd80ed71362081579697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77545d45a37ae31d6749dd80ed71362081579697"}], "stats": {"total": 89, "additions": 89, "deletions": 0}, "files": [{"sha": "8373b80192d1f660737bf351caf4f164bbabf627", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a24dbcfa909b974ee368dacb4dca8486745908b/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a24dbcfa909b974ee368dacb4dca8486745908b/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=7a24dbcfa909b974ee368dacb4dca8486745908b", "patch": "@@ -999,6 +999,18 @@ i960_function_prologue (file, size)\n \n   epilogue_string[0] = '\\0';\n \n+  if (profile_flag || profile_block_flag)\n+    {\n+      /* When profiling, we may use registers 20 to 27 to save arguments, so\n+\t they can't be used here for saving globals.  J is the number of\n+\t argument registers the mcount call will save.  */\n+      for (j = 7; j >= 0 && ! regs_ever_live[j]; j--)\n+\t;\n+\n+      for (i = 20; i <= j + 20; i++)\n+\tregs[i] = -1;\n+    }\n+\n   /* First look for local registers to save globals in.  */\n   for (i = 0; i < 16; i++)\n     {\n@@ -1134,6 +1146,83 @@ i960_function_prologue (file, size)\n   fprintf (file, \"\\t#End Prologue#\\n\");\n }\n \n+/* Output code for the function profiler.  */\n+\n+void\n+output_function_profiler (file, labelno)\n+     FILE *file;\n+     int labelno;\n+{\n+  /* The last used parameter register.  */\n+  int last_parm_reg;\n+  int i, j, increment;\n+\n+  /* Figure out the last used parameter register.  The proper thing to do\n+     is to walk incoming args of the function.  A function might have live\n+     parameter registers even if it has no incoming args.  Note that we\n+     don't have to save parameter registers g8 to g11 because they are\n+     call preserved.  */\n+\n+  /* See also output_function_prologue, which tries to use local registers\n+     for preserved call-saved global registers.  */\n+\n+  for (last_parm_reg = 7;\n+       last_parm_reg >= 0 && ! regs_ever_live[last_parm_reg];\n+       last_parm_reg--)\n+    ;\n+\n+  /* Save parameter registers in regs r4 (20) to r11 (27).  */\n+\n+  for (i = 0, j = 4; i <= last_parm_reg; i += increment, j += increment)\n+    {\n+      if (i % 4 == 0 && (last_parm_reg - i) >= 3)\n+\tincrement = 4;\n+      else if (i % 4 == 0 && (last_parm_reg - i) >= 2)\n+\tincrement = 3;\n+      else if (i % 2 == 0 && (last_parm_reg - i) >= 1)\n+\tincrement = 2;\n+      else\n+\tincrement = 1;\n+\n+      fprintf (file, \"\\tmov%s\tg%d,r%d\\n\",\n+\t       (increment == 4 ? \"q\" : increment == 3 ? \"t\"\n+\t\t: increment == 2 ? \"l\": \"\"), i, j);\n+      }\n+\n+  /* If this function uses the arg pointer, then save it in r3 and then\n+     set it to zero.  */\n+\n+  if (current_function_args_size != 0)\n+    fprintf (file, \"\\tmov\tg14,r3\\n\\tmov\t0,g14\");\n+\n+  /* Load location address into g0 and call mcount.  */\n+\n+  fprintf (file, \"\\tlda\\tLP%d,g0\\n\\tcallx\\tmcount\\n\", labelno);\n+\n+  /* If this function uses the arg pointer, restore it.  */\n+\n+  if (current_function_args_size != 0)\n+    fprintf (file, \"\\tmov\tr3,g14\");\n+\n+  /* Restore parameter registers.  */\n+\n+  for (i = 0, j = 4; i <= last_parm_reg; i += increment, j += increment)\n+    {\n+      if (i % 4 == 0 && (last_parm_reg - i) >= 3)\n+\tincrement = 4;\n+      else if (i % 4 == 0 && (last_parm_reg - i) >= 2)\n+\tincrement = 3;\n+      else if (i % 2 == 0 && (last_parm_reg - i) >= 1)\n+\tincrement = 2;\n+      else\n+\tincrement = 1;\n+\n+      fprintf (file, \"\\tmov%s\tr%d,g%d\\n\",\n+\t       (increment == 4 ? \"q\" : increment == 3 ? \"t\"\n+\t\t: increment == 2 ? \"l\": \"\"), j, i);\n+    }\n+}\n+\n /* Output code for the function epilogue.  */\n \n void"}]}