{"sha": "d327457f172ab91732d0789bf925c7510f5e1015", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyNzQ1N2YxNzJhYjkxNzMyZDA3ODliZjkyNWM3NTEwZjVlMTAxNQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2012-11-05T15:18:10Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2012-11-05T15:18:10Z"}, "message": "md.texi (Defining Attributes): Document that we are defining HAVE_ATTR_name macors as 1 for defined attributes...\n\n\t* doc/md.texi (Defining Attributes): Document that we are defining\n\tHAVE_ATTR_name macors as 1 for defined attributes, and as 0\n\tfor undefined special attributes.\n\t* final.c (asm_insn_count, align_fuzz): Always define.\n\t(insn_current_reference_address): Likewise.\n\t(init_insn_lengths): Use if (HAVE_ATTR_length) instead of\n\t#ifdef HAVE_ATTR_length.\n\t(get_attr_length_1, shorten_branches, final): Likewise.\n\t(final_scan_insn, output_asm_name): Likewise.\n\t* genattr.c (gen_attr): Define HAVE_ATTR_name macros for\n\tdefined attributes as 1.\n\tRemove ancient get_attr_alternative compatibility code.\n\tFor special purpose attributes not provided, define HAVE_ATTR_name\n\tas 0.\n\tIn case no length attribute is given, provide stub definitions\n\tfor insn_*_length* functions, and also include insn-addr.h.\n\tIn case no enabled attribute is given, provide stub definition.\n\t* genattrtab.c (write_length_unit_log): Always write a definition.\n\t* hooks.c (hook_int_rtx_1, hook_int_rtx_unreachable): New functions.\n\t* hooks.h (hook_int_rtx_1, hook_int_rtx_unreachable): Declare.\n\t* lra-int.h (struct lra_insn_recog_data): Make member\n\talternative_enabled_p unconditional.\n\t* lra.c (free_insn_recog_data): Use if (HAVE_ATTR_length) instead of\n\t#ifdef HAVE_ATTR_length.\n\t(lra_set_insn_recog_data): Likewise.  Make initialization of\n\talternative_enabled_p unconditional.\n\t(lra_update_insn_recog_data): Use #if instead of #ifdef for\n\tHAVE_ATTR_enabled.\n\t* recog.c [!HAVE_ATTR_enabled] (get_attr_enabled): Don't define.\n\t(extract_insn): Check HAVE_ATTR_enabled.\n\t(gate_handle_split_before_regstack): Use #if instead of\n\t#if defined for HAVE_ATTR_length.\n\nFrom-SVN: r193168", "tree": {"sha": "8e0a8f071bd365a15434d0e94b091fe7d57014a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0a8f071bd365a15434d0e94b091fe7d57014a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d327457f172ab91732d0789bf925c7510f5e1015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d327457f172ab91732d0789bf925c7510f5e1015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d327457f172ab91732d0789bf925c7510f5e1015", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d327457f172ab91732d0789bf925c7510f5e1015/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1539ccbf52c4a95c63fc3fb3efe9bf78f85f6158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1539ccbf52c4a95c63fc3fb3efe9bf78f85f6158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1539ccbf52c4a95c63fc3fb3efe9bf78f85f6158"}], "stats": {"total": 244, "additions": 141, "deletions": 103}, "files": [{"sha": "1b8a1082d40cc8d5639db87c5b02a945c3ab3995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -1,3 +1,38 @@\n+2012-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* doc/md.texi (Defining Attributes): Document that we are defining\n+\tHAVE_ATTR_name macors as 1 for defined attributes, and as 0\n+\tfor undefined special attributes.\n+\t* final.c (asm_insn_count, align_fuzz): Always define.\n+\t(insn_current_reference_address): Likewise.\n+\t(init_insn_lengths): Use if (HAVE_ATTR_length) instead of\n+\t#ifdef HAVE_ATTR_length.\n+\t(get_attr_length_1, shorten_branches, final): Likewise.\n+\t(final_scan_insn, output_asm_name): Likewise.\n+\t* genattr.c (gen_attr): Define HAVE_ATTR_name macros for\n+\tdefined attributes as 1.\n+\tRemove ancient get_attr_alternative compatibility code.\n+\tFor special purpose attributes not provided, define HAVE_ATTR_name\n+\tas 0.\n+\tIn case no length attribute is given, provide stub definitions\n+\tfor insn_*_length* functions, and also include insn-addr.h.\n+\tIn case no enabled attribute is given, provide stub definition.\n+\t* genattrtab.c (write_length_unit_log): Always write a definition.\n+\t* hooks.c (hook_int_rtx_1, hook_int_rtx_unreachable): New functions.\n+\t* hooks.h (hook_int_rtx_1, hook_int_rtx_unreachable): Declare.\n+\t* lra-int.h (struct lra_insn_recog_data): Make member\n+\talternative_enabled_p unconditional.\n+\t* lra.c (free_insn_recog_data): Use if (HAVE_ATTR_length) instead of\n+\t#ifdef HAVE_ATTR_length.\n+\t(lra_set_insn_recog_data): Likewise.  Make initialization of\n+\talternative_enabled_p unconditional.\n+\t(lra_update_insn_recog_data): Use #if instead of #ifdef for\n+\tHAVE_ATTR_enabled.\n+\t* recog.c [!HAVE_ATTR_enabled] (get_attr_enabled): Don't define.\n+\t(extract_insn): Check HAVE_ATTR_enabled.\n+\t(gate_handle_split_before_regstack): Use #if instead of\n+\t#if defined for HAVE_ATTR_length.\n+\n 2012-11-05  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline.c (compute_uninlined_call_time,"}, {"sha": "6aa2374bcd082a7315a86683397844cbb48ccd27", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -7566,7 +7566,7 @@ For example, if the following is present in the @file{md} file:\n the following lines will be written to the file @file{insn-attr.h}.\n \n @smallexample\n-#define HAVE_ATTR_type\n+#define HAVE_ATTR_type 1\n enum attr_type @{TYPE_BRANCH, TYPE_FP, TYPE_LOAD,\n                  TYPE_STORE, TYPE_ARITH@};\n extern enum attr_type get_attr_type ();\n@@ -7591,6 +7591,10 @@ alternatives of an insn definition from being used during code\n generation. @xref{Disable Insn Alternatives}.\n @end table\n \n+For each of these special attributes, the corresponding\n+@samp{HAVE_ATTR_@var{name}} @samp{#define} is also written when the\n+attribute is not defined; in that case, it is defined as @samp{0}.\n+\n @findex define_enum_attr\n @anchor{define_enum_attr}\n Another way of defining an attribute is to use:"}, {"sha": "81a679d63fd26e83140637e3550002baf0764fb5", "filename": "gcc/final.c", "status": "modified", "additions": 28, "deletions": 45, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -204,9 +204,7 @@ rtx current_insn_predicate;\n /* True if printing into -fdump-final-insns= dump.  */   \n bool final_insns_dump_p;\n \n-#ifdef HAVE_ATTR_length\n static int asm_insn_count (rtx);\n-#endif\n static void profile_function (FILE *);\n static void profile_after_prologue (FILE *);\n static bool notice_source_line (rtx, bool *);\n@@ -224,9 +222,7 @@ static int alter_cond (rtx);\n #ifndef ADDR_VEC_ALIGN\n static int final_addr_vec_align (rtx);\n #endif\n-#ifdef HAVE_ATTR_length\n static int align_fuzz (rtx, rtx, int, unsigned);\n-#endif\n \f\n /* Initialize data in final at the beginning of a compilation.  */\n \n@@ -362,9 +358,8 @@ init_insn_lengths (void)\n       insn_lengths = 0;\n       insn_lengths_max_uid = 0;\n     }\n-#ifdef HAVE_ATTR_length\n-  INSN_ADDRESSES_FREE ();\n-#endif\n+  if (HAVE_ATTR_length)\n+    INSN_ADDRESSES_FREE ();\n   if (uid_align)\n     {\n       free (uid_align);\n@@ -376,14 +371,15 @@ init_insn_lengths (void)\n    get its actual length.  Otherwise, use FALLBACK_FN to calculate the\n    length.  */\n static inline int\n-get_attr_length_1 (rtx insn ATTRIBUTE_UNUSED,\n-\t\t   int (*fallback_fn) (rtx) ATTRIBUTE_UNUSED)\n+get_attr_length_1 (rtx insn, int (*fallback_fn) (rtx))\n {\n-#ifdef HAVE_ATTR_length\n   rtx body;\n   int i;\n   int length = 0;\n \n+  if (!HAVE_ATTR_length)\n+    return 0;\n+\n   if (insn_lengths_max_uid > INSN_UID (insn))\n     return insn_lengths[INSN_UID (insn)];\n   else\n@@ -432,11 +428,6 @@ get_attr_length_1 (rtx insn ATTRIBUTE_UNUSED,\n   ADJUST_INSN_LENGTH (insn, length);\n #endif\n   return length;\n-#else /* not HAVE_ATTR_length */\n-  return 0;\n-#define insn_default_length 0\n-#define insn_min_length 0\n-#endif /* not HAVE_ATTR_length */\n }\n \n /* Obtain the current length of an insn.  If branch shortening has been done,\n@@ -583,7 +574,6 @@ label_to_max_skip (rtx label)\n   return 0;\n }\n \n-#ifdef HAVE_ATTR_length\n /* The differences in addresses\n    between a branch and its target might grow or shrink depending on\n    the alignment the start insn of the range (the branch for a forward\n@@ -686,7 +676,6 @@ insn_current_reference_address (rtx branch)\n \t      + align_fuzz (dest, seq, length_unit_log, ~0));\n     }\n }\n-#endif /* HAVE_ATTR_length */\n \f\n /* Compute branch alignments based on frequency information in the\n    CFG.  */\n@@ -851,14 +840,13 @@ struct rtl_opt_pass pass_compute_alignments =\n    slots.  */\n \n void\n-shorten_branches (rtx first ATTRIBUTE_UNUSED)\n+shorten_branches (rtx first)\n {\n   rtx insn;\n   int max_uid;\n   int i;\n   int max_log;\n   int max_skip;\n-#ifdef HAVE_ATTR_length\n #define MAX_CODE_ALIGN 16\n   rtx seq;\n   int something_changed = 1;\n@@ -867,8 +855,6 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n   int uid;\n   rtx align_tab[MAX_CODE_ALIGN];\n \n-#endif\n-\n   /* Compute maximum UID and allocate label_align / uid_shuid.  */\n   max_uid = get_max_uid ();\n \n@@ -975,7 +961,8 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t      }\n \t}\n     }\n-#ifdef HAVE_ATTR_length\n+  if (!HAVE_ATTR_length)\n+    return;\n \n   /* Allocate the rest of the arrays.  */\n   insn_lengths = XNEWVEC (int, max_uid);\n@@ -1421,11 +1408,8 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n     }\n \n   free (varying_length);\n-\n-#endif /* HAVE_ATTR_length */\n }\n \n-#ifdef HAVE_ATTR_length\n /* Given the body of an INSN known to be generated by an ASM statement, return\n    the number of machine instructions likely to be generated for this insn.\n    This is used to compute its length.  */\n@@ -1442,7 +1426,6 @@ asm_insn_count (rtx body)\n \n   return asm_str_count (templ);\n }\n-#endif\n \n /* Return the number of machine instructions likely to be generated for the\n    inline-asm template. */\n@@ -1903,17 +1886,18 @@ final (rtx first, FILE *file, int optimize_p)\n   /* Output the insns.  */\n   for (insn = first; insn;)\n     {\n-#ifdef HAVE_ATTR_length\n-      if ((unsigned) INSN_UID (insn) >= INSN_ADDRESSES_SIZE ())\n+      if (HAVE_ATTR_length)\n \t{\n-\t  /* This can be triggered by bugs elsewhere in the compiler if\n-\t     new insns are created after init_insn_lengths is called.  */\n-\t  gcc_assert (NOTE_P (insn));\n-\t  insn_current_address = -1;\n+\t  if ((unsigned) INSN_UID (insn) >= INSN_ADDRESSES_SIZE ())\n+\t    {\n+\t      /* This can be triggered by bugs elsewhere in the compiler if\n+\t\t new insns are created after init_insn_lengths is called.  */\n+\t      gcc_assert (NOTE_P (insn));\n+\t      insn_current_address = -1;\n+\t    }\n+\t  else\n+\t    insn_current_address = INSN_ADDRESSES (INSN_UID (insn));\n \t}\n-      else\n-\tinsn_current_address = INSN_ADDRESSES (INSN_UID (insn));\n-#endif /* HAVE_ATTR_length */\n \n       dump_basic_block_info (file, insn, start_to_bb, end_to_bb,\n                              bb_map_size, &bb_seqn);\n@@ -2854,12 +2838,10 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    if (new_rtx == insn && PATTERN (new_rtx) == body)\n \t      fatal_insn (\"could not split insn\", insn);\n \n-#ifdef HAVE_ATTR_length\n-\t    /* This instruction should have been split in shorten_branches,\n-\t       to ensure that we would have valid length info for the\n-\t       splitees.  */\n-\t    gcc_unreachable ();\n-#endif\n+\t    /* If we have a length attribute, this instruction should have\n+\t       been split in shorten_branches, to ensure that we would have\n+\t       valid length info for the splitees.  */\n+\t    gcc_assert (!HAVE_ATTR_length);\n \n \t    return new_rtx;\n \t  }\n@@ -3293,10 +3275,11 @@ output_asm_name (void)\n \t       insn_data[num].name);\n       if (insn_data[num].n_alternatives > 1)\n \tfprintf (asm_out_file, \"/%d\", which_alternative + 1);\n-#ifdef HAVE_ATTR_length\n-      fprintf (asm_out_file, \"\\t[length = %d]\",\n-\t       get_attr_length (debug_insn));\n-#endif\n+\n+      if (HAVE_ATTR_length)\n+\tfprintf (asm_out_file, \"\\t[length = %d]\",\n+\t\t get_attr_length (debug_insn));\n+\n       /* Clear this so only the first assembler insn\n \t of any rtl insn will get the special comment for -dp.  */\n       debug_insn = 0;"}, {"sha": "bb5cf9688a044eb628194298d808316079bd84f6", "filename": "gcc/genattr.c", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -44,7 +44,7 @@ gen_attr (rtx attr)\n   if (is_const)\n     VEC_safe_push (rtx, heap, const_attrs, attr);\n \n-  printf (\"#define HAVE_ATTR_%s\\n\", XSTR (attr, 0));\n+  printf (\"#define HAVE_ATTR_%s 1\\n\", XSTR (attr, 0));\n \n   /* If numeric attribute, don't need to write an enum.  */\n   if (GET_CODE (attr) == DEFINE_ENUM_ATTR)\n@@ -159,12 +159,6 @@ main (int argc, char **argv)\n \n   puts (\"#include \\\"insn-attr-common.h\\\"\\n\");\n \n-  /* For compatibility, define the attribute `alternative', which is just\n-     a reference to the variable `which_alternative'.  */\n-\n-  puts (\"#define HAVE_ATTR_alternative\");\n-  puts (\"#define get_attr_alternative(insn) which_alternative\");\n-\n   /* Read the machine description.  */\n \n   while (1)\n@@ -342,6 +336,29 @@ main (int argc, char **argv)\n       printf (\"typedef void *state_t;\\n\\n\");\n     }\n \n+  /* Special-purpose atributes should be tested with if, not #ifdef.  */\n+  const char * const special_attrs[] = { \"length\", \"enabled\", 0 };\n+  for (const char * const *p = special_attrs; *p; p++)\n+    {\n+      printf (\"#ifndef HAVE_ATTR_%s\\n\"\n+\t      \"#define HAVE_ATTR_%s 0\\n\"\n+\t      \"#endif\\n\", *p, *p);\n+    }\n+  /* We make an exception here to provide stub definitions for\n+     insn_*_length* / get_attr_enabled functions.  */\n+  puts (\"#if !HAVE_ATTR_length\\n\"\n+\t\"extern int hook_int_rtx_unreachable (rtx);\\n\"\n+\t\"#define insn_default_length hook_int_rtx_unreachable\\n\"\n+\t\"#define insn_min_length hook_int_rtx_unreachable\\n\"\n+\t\"#define insn_variable_length_p hook_int_rtx_unreachable\\n\"\n+\t\"#define insn_current_length hook_int_rtx_unreachable\\n\"\n+\t\"#include \\\"insn-addr.h\\\"\\n\"\n+\t\"#endif\\n\"\n+\t\"#if !HAVE_ATTR_enabled\\n\"\n+\t\"extern int hook_int_rtx_1 (rtx);\\n\"\n+\t\"#define get_attr_enabled hook_int_rtx_1\\n\"\n+\t\"#endif\\n\");\n+\n   /* Output flag masks for use by reorg.\n \n      Flags are used to hold branch direction for use by eligible_for_...  */"}, {"sha": "cef7d4061913767c063c936ebddd770f29cdd37e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -1636,14 +1636,15 @@ write_length_unit_log (FILE *outf)\n   unsigned int length_unit_log, length_or;\n   int unknown = 0;\n \n-  if (length_attr == 0)\n-    return;\n-  length_or = or_attr_value (length_attr->default_val->value, &unknown);\n-  for (av = length_attr->first_value; av; av = av->next)\n-    for (ie = av->first_insn; ie; ie = ie->next)\n-      length_or |= or_attr_value (av->value, &unknown);\n+  if (length_attr)\n+    {\n+      length_or = or_attr_value (length_attr->default_val->value, &unknown);\n+      for (av = length_attr->first_value; av; av = av->next)\n+\tfor (ie = av->first_insn; ie; ie = ie->next)\n+\t  length_or |= or_attr_value (av->value, &unknown);\n+    }\n \n-  if (unknown)\n+  if (length_attr == NULL || unknown)\n     length_unit_log = 0;\n   else\n     {"}, {"sha": "6bd9876b91f423abdc6267110b2774c8ca960e73", "filename": "gcc/hooks.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -202,6 +202,18 @@ hook_int_rtx_0 (rtx a ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n+int\n+hook_int_rtx_1 (rtx)\n+{\n+  return 1;\n+}\n+\n+int\n+hook_int_rtx_unreachable (rtx)\n+{\n+  gcc_unreachable ();\n+}\n+\n int\n hook_int_rtx_bool_0 (rtx a ATTRIBUTE_UNUSED, bool b ATTRIBUTE_UNUSED)\n {"}, {"sha": "7900a6f287ad37feac9e1832c286a2270ff6ffb9", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -75,6 +75,8 @@ extern int hook_int_uint_mode_1 (unsigned int, enum machine_mode);\n extern int hook_int_const_tree_0 (const_tree);\n extern int hook_int_const_tree_const_tree_1 (const_tree, const_tree);\n extern int hook_int_rtx_0 (rtx);\n+extern int hook_int_rtx_1 (rtx);\n+extern int hook_int_rtx_unreachable (rtx);\n extern int hook_int_rtx_bool_0 (rtx, bool);\n extern int hook_int_rtx_mode_as_bool_0 (rtx, enum machine_mode, addr_space_t,\n \t\t\t\t\tbool);"}, {"sha": "abb6d7176bf0ec3cc212e60b89269ae040584de4", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -227,10 +227,8 @@ struct lra_insn_recog_data\n      value can be NULL or points to array of the hard register numbers\n      ending with a negative value.  */\n   int *arg_hard_regs;\n-#ifdef HAVE_ATTR_enabled\n   /* Alternative enabled for the insn.\tNULL for debug insns.  */\n   bool *alternative_enabled_p;\n-#endif\n   /* The alternative should be used for the insn, -1 if invalid, or we\n      should try to use any alternative, or the insn is a debug\n      insn.  */"}, {"sha": "0705ad79f929210dcc833cb817f7cdddb3bc058c", "filename": "gcc/lra.c", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -671,10 +671,8 @@ free_insn_recog_data (lra_insn_recog_data_t data)\n     free (data->dup_loc);\n   if (data->arg_hard_regs != NULL)\n     free (data->arg_hard_regs);\n-#ifdef HAVE_ATTR_enabled\n-  if (data->alternative_enabled_p != NULL)\n+  if (HAVE_ATTR_enabled && data->alternative_enabled_p != NULL)\n     free (data->alternative_enabled_p);\n-#endif\n   if (data->icode < 0 && NONDEBUG_INSN_P (data->insn))\n     {\n       if (data->insn_static_data->operand_alternative != NULL)\n@@ -1020,9 +1018,7 @@ lra_set_insn_recog_data (rtx insn)\n       data->insn_static_data = &debug_insn_static_data;\n       data->dup_loc = NULL;\n       data->arg_hard_regs = NULL;\n-#ifdef HAVE_ATTR_enabled\n       data->alternative_enabled_p = NULL;\n-#endif\n       data->operand_loc = XNEWVEC (rtx *, 1);\n       data->operand_loc[0] = &INSN_VAR_LOCATION_LOC (insn);\n       return data;\n@@ -1075,9 +1071,7 @@ lra_set_insn_recog_data (rtx insn)\n \t  = (insn_static_data->operand[i].constraint[0] == '=' ? OP_OUT\n \t     : insn_static_data->operand[i].constraint[0] == '+' ? OP_INOUT\n \t     : OP_IN);\n-#ifdef HAVE_ATTR_enabled\n       data->alternative_enabled_p = NULL;\n-#endif\n     }\n   else\n     {\n@@ -1104,28 +1098,27 @@ lra_set_insn_recog_data (rtx insn)\n \t  memcpy (locs, recog_data.dup_loc, n * sizeof (rtx *));\n \t}\n       data->dup_loc = locs;\n-#ifdef HAVE_ATTR_enabled\n-      {\n-\tbool *bp;\n-\n-\tn = insn_static_data->n_alternatives;\n-\tlra_assert (n >= 0);\n-\tdata->alternative_enabled_p = bp = XNEWVEC (bool, n);\n-\t/* Cache the insn because we don't want to call extract_insn\n-\t   from get_attr_enabled as extract_insn modifies\n-\t   which_alternative.  The attribute enabled should not depend\n-\t   on insn operands, operand modes, operand types, and operand\n-\t   constraints.\t It should depend on the architecture.\tIf it\n-\t   is not true, we should rewrite this file code to use\n-\t   extract_insn instead of less expensive insn_extract.\t */\n-\trecog_data.insn = insn;\n-\tfor (i = 0; i < n; i++)\n-\t  {\n-\t    which_alternative = i;\n-\t    bp[i] = get_attr_enabled (insn);\n-\t  }\n-      }\n-#endif\n+      if (HAVE_ATTR_enabled)\n+\t{\n+\t  bool *bp;\n+\n+\t  n = insn_static_data->n_alternatives;\n+\t  lra_assert (n >= 0);\n+\t  data->alternative_enabled_p = bp = XNEWVEC (bool, n);\n+\t  /* Cache the insn because we don't want to call extract_insn\n+\t     from get_attr_enabled as extract_insn modifies\n+\t     which_alternative.  The attribute enabled should not depend\n+\t     on insn operands, operand modes, operand types, and operand\n+\t     constraints.  It should depend on the architecture.  If it\n+\t     is not true, we should rewrite this file code to use\n+\t     extract_insn instead of less expensive insn_extract.  */\n+\t  recog_data.insn = insn;\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      which_alternative = i;\n+\t      bp[i] = get_attr_enabled (insn);\n+\t    }\n+\t}\n     }\n   if (GET_CODE (PATTERN (insn)) == CLOBBER || GET_CODE (PATTERN (insn)) == USE)\n     insn_static_data->hard_regs = NULL;\n@@ -1305,7 +1298,7 @@ lra_update_insn_recog_data (rtx insn)\n       n = insn_static_data->n_dups;\n       if (n != 0)\n \tmemcpy (data->dup_loc, recog_data.dup_loc, n * sizeof (rtx *));\n-#ifdef HAVE_ATTR_enabled\n+#if HAVE_ATTR_enabled\n #ifdef ENABLE_CHECKING\n       {\n \tint i;"}, {"sha": "8206f5eace9c6ac354a17c5857e89eec5812d16a", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d327457f172ab91732d0789bf925c7510f5e1015/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d327457f172ab91732d0789bf925c7510f5e1015", "patch": "@@ -57,14 +57,6 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n #endif\n \n-#ifndef HAVE_ATTR_enabled\n-static inline bool\n-get_attr_enabled (rtx insn ATTRIBUTE_UNUSED)\n-{\n-  return true;\n-}\n-#endif\n-\n static void validate_replace_rtx_1 (rtx *, rtx, rtx, rtx, bool);\n static void validate_replace_src_1 (rtx *, void *);\n static rtx split_insn (rtx);\n@@ -2172,7 +2164,8 @@ extract_insn (rtx insn)\n       for (i = 0; i < recog_data.n_alternatives; i++)\n \t{\n \t  which_alternative = i;\n-\t  recog_data.alternative_enabled_p[i] = get_attr_enabled (insn);\n+\t  recog_data.alternative_enabled_p[i]\n+\t    = HAVE_ATTR_enabled ? get_attr_enabled (insn) : 0;\n \t}\n     }\n \n@@ -3819,7 +3812,7 @@ struct rtl_opt_pass pass_split_after_reload =\n static bool\n gate_handle_split_before_regstack (void)\n {\n-#if defined (HAVE_ATTR_length) && defined (STACK_REGS)\n+#if HAVE_ATTR_length && defined (STACK_REGS)\n   /* If flow2 creates new instructions which need splitting\n      and scheduling after reload is not done, they might not be\n      split until final which doesn't allow splitting\n@@ -3905,7 +3898,7 @@ struct rtl_opt_pass pass_split_before_sched2 =\n static bool\n gate_do_final_split (void)\n {\n-#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n+#if HAVE_ATTR_length && !defined (STACK_REGS)\n   return 1;\n #else\n   return 0;"}]}