{"sha": "6737facbb3c53a1f0158b05e4116c161ed9bc319", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjczN2ZhY2JiM2M1M2ExZjAxNThiMDVlNDExNmMxNjFlZDliYzMxOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-10T13:07:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-10T13:07:54Z"}, "message": "Don't use permutes for single-element accesses (PR83753)\n\nAfter cunrolling the inner loop, the remaining loop in the testcase\nhas a single 32-bit access and a group of 64-bit accesses.  We first\ntry to vectorise at 128 bits (VF 4), but decide not to for cost reasons.\nWe then try with 64 bits (VF 2) instead.  This means that the group\nof 64-bit accesses uses a single-element vector, which is deliberately\nsupported as of r251538.  We then try to create \"permutes\" for these\nsingle-element vectors and fall foul of:\n\n\t      for (i = 0; i < 6; i++)\n\t\tsel[i] += exact_div (nelt, 2);\n\nin vect_grouped_store_supported, since nelt==1.\n\nMaybe we shouldn't even be trying to vectorise statements in the\nsingle-element case, and instead just copy the scalar statement\nfor each member of the group.  But until then, this patch treats\nnon-strided grouped accesses as VMAT_CONTIGUOUS if no permutation\nis necessary.\n\n2018-01-10  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/83753\n\t* tree-vect-stmts.c (get_group_load_store_type): Use VMAT_CONTIGUOUS\n\tfor non-strided grouped accesses if the number of elements is 1.\n\ngcc/testsuite/\n\tPR tree-optimization/83753\n\t* gcc.dg/torture/pr83753.c: New test.\n\nFrom-SVN: r256427", "tree": {"sha": "62ede51cd79130de6eb2ad0e1b0127c441143c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62ede51cd79130de6eb2ad0e1b0127c441143c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6737facbb3c53a1f0158b05e4116c161ed9bc319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6737facbb3c53a1f0158b05e4116c161ed9bc319", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6737facbb3c53a1f0158b05e4116c161ed9bc319", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6737facbb3c53a1f0158b05e4116c161ed9bc319/comments", "author": null, "committer": null, "parents": [{"sha": "e10e60cb6e6837eb0335fa1affa8aef71b21ecbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10e60cb6e6837eb0335fa1affa8aef71b21ecbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10e60cb6e6837eb0335fa1affa8aef71b21ecbf"}], "stats": {"total": 44, "additions": 40, "deletions": 4}, "files": [{"sha": "f0e9e5948a271e314880dc2f5f8b6fcbcab51214", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6737facbb3c53a1f0158b05e4116c161ed9bc319", "patch": "@@ -1,3 +1,9 @@\n+2018-01-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/83753\n+\t* tree-vect-stmts.c (get_group_load_store_type): Use VMAT_CONTIGUOUS\n+\tfor non-strided grouped accesses if the number of elements is 1.\n+\n 2018-01-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR target/81616"}, {"sha": "2fda0178a978b9a891bada539cd5f0b9b2356932", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6737facbb3c53a1f0158b05e4116c161ed9bc319", "patch": "@@ -1,3 +1,8 @@\n+2018-01-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/83753\n+\t* gcc.dg/torture/pr83753.c: New test.\n+\n 2018-01-09  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.target/i386/avx2-gather-1.c: Add -march."}, {"sha": "54aafc0b32156896ca43f6a1c0a789482f94a190", "filename": "gcc/testsuite/gcc.dg/torture/pr83753.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr83753.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr83753.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr83753.c?ref=6737facbb3c53a1f0158b05e4116c161ed9bc319", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=xgene1\" { target aarch64*-*-* } } */\n+\n+typedef struct {\n+  int m1[10];\n+  double m2[10][8];\n+} blah;\n+\n+void\n+foo (blah *info) {\n+  int i, d;\n+\n+  for (d=0; d<10; d++) {\n+    info->m1[d] = 0;\n+    info->m2[d][0] = 1;\n+    for (i=1; i<8; i++)\n+      info->m2[d][i] = 2;\n+  }\n+}"}, {"sha": "819a981d57aa5942258cbc8c621cc16583347903", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6737facbb3c53a1f0158b05e4116c161ed9bc319/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6737facbb3c53a1f0158b05e4116c161ed9bc319", "patch": "@@ -1849,10 +1849,16 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t  && (can_overrun_p || !would_overrun_p)\n \t  && compare_step_with_zero (stmt) > 0)\n \t{\n-\t  /* First try using LOAD/STORE_LANES.  */\n-\t  if (vls_type == VLS_LOAD\n-\t      ? vect_load_lanes_supported (vectype, group_size)\n-\t      : vect_store_lanes_supported (vectype, group_size))\n+\t  /* First cope with the degenerate case of a single-element\n+\t     vector.  */\n+\t  if (known_eq (TYPE_VECTOR_SUBPARTS (vectype), 1U))\n+\t    *memory_access_type = VMAT_CONTIGUOUS;\n+\n+\t  /* Otherwise try using LOAD/STORE_LANES.  */\n+\t  if (*memory_access_type == VMAT_ELEMENTWISE\n+\t      && (vls_type == VLS_LOAD\n+\t\t  ? vect_load_lanes_supported (vectype, group_size)\n+\t\t  : vect_store_lanes_supported (vectype, group_size)))\n \t    {\n \t      *memory_access_type = VMAT_LOAD_STORE_LANES;\n \t      overrun_p = would_overrun_p;"}]}