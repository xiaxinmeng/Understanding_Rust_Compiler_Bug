{"sha": "64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRjNmUzNjczYTllZGRmMTY4ZmJlOGQ1Y2ZhYjcwZjU1ZmVhMDhmOA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2019-12-18T07:14:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-18T07:14:54Z"}, "message": "[Ada] AI12-0282: shared variable control aspects on formal types\n\n2019-12-18  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* par-ch12.adb (P_Formal_Derived_Type_Definition): In Ada_2020\n\tthe keyword WITH can indicate the start of aspect specifications\n\tand not a private type extension.\n\t* sem_ch12.adb (Analyze_Formal_Type): Indicate that it is a\n\tfirst subtype.\n\t(Instantiate_Type): New procedure\n\tCheck_Shared_Variable_Control_Aspects to verify matching rules\n\tbetween formal and actual types. Note that an array type with\n\taspect Atomic_Components is considered compatible with an array\n\ttype whose component type is Atomic, even though the array types\n\tdo not carry the same aspect.\n\t* sem_ch13.adb (Analyze_One_Aspect): Allow shared variable\n\tcontrol aspects to appear on formal types.\n\t(Rep_Item_Too_Early): Exclude aspects on formal types.\n\t* sem_prag.adb (Mark_Type): Handle properly pragmas that come\n\tfrom aspects on formal types.\n\t(Analyze_Pragma, case Atomic_Components): Handle formal types.\n\nFrom-SVN: r279512", "tree": {"sha": "60d308f2111b2998bf13f5ee7dd243a0cc1d958b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60d308f2111b2998bf13f5ee7dd243a0cc1d958b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b0451b77242d8071aa3c2b077deb84c17170223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0451b77242d8071aa3c2b077deb84c17170223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b0451b77242d8071aa3c2b077deb84c17170223"}], "stats": {"total": 189, "additions": 172, "deletions": 17}, "files": [{"sha": "fd3d0be0edd32ad617731a7d6904f52c675de4b1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "patch": "@@ -1,3 +1,23 @@\n+2019-12-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch12.adb (P_Formal_Derived_Type_Definition): In Ada_2020\n+\tthe keyword WITH can indicate the start of aspect specifications\n+\tand not a private type extension.\n+\t* sem_ch12.adb (Analyze_Formal_Type): Indicate that it is a\n+\tfirst subtype.\n+\t(Instantiate_Type): New procedure\n+\tCheck_Shared_Variable_Control_Aspects to verify matching rules\n+\tbetween formal and actual types. Note that an array type with\n+\taspect Atomic_Components is considered compatible with an array\n+\ttype whose component type is Atomic, even though the array types\n+\tdo not carry the same aspect.\n+\t* sem_ch13.adb (Analyze_One_Aspect): Allow shared variable\n+\tcontrol aspects to appear on formal types.\n+\t(Rep_Item_Too_Early): Exclude aspects on formal types.\n+\t* sem_prag.adb (Mark_Type): Handle properly pragmas that come\n+\tfrom aspects on formal types.\n+\t(Analyze_Pragma, case Atomic_Components): Handle formal types.\n+\n 2019-12-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cstand.adb (Create_Standard): Remove duplicate line and"}, {"sha": "0ecac2e7ccef8677d94ae7a5a485b6dfebf9c90d", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "patch": "@@ -971,9 +971,16 @@ package body Ch12 is\n       end if;\n \n       if Token = Tok_With then\n-         Scan; -- past WITH\n-         Set_Private_Present (Def_Node, True);\n-         T_Private;\n+\n+         if Ada_Version >= Ada_2020 and Token /= Tok_Private then\n+            --  Formal type has aspect specifications, parsed later.\n+            return Def_Node;\n+\n+         else\n+            Scan; -- past WITH\n+            Set_Private_Present (Def_Node, True);\n+            T_Private;\n+         end if;\n \n       elsif Token = Tok_Tagged then\n          Scan;"}, {"sha": "dc3a3c254466ccbbd65e2c3152ef3b2ec734ead3", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "patch": "@@ -3410,7 +3410,11 @@ package body Sem_Ch12 is\n             raise Program_Error;\n       end case;\n \n+      --  A formal type declaration declares a type and its first\n+      --  subtype.\n+\n       Set_Is_Generic_Type (T);\n+      Set_Is_First_Subtype (T);\n \n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, T);\n@@ -12178,6 +12182,10 @@ package body Sem_Ch12 is\n       Loc        : Source_Ptr;\n       Subt       : Entity_Id;\n \n+      procedure Check_Shared_Variable_Control_Aspects;\n+      --  Ada_2020: Verify that shared variable control aspects (RM C.6)\n+      --  that may be specified for a formal type are obeyed by the actual.\n+\n       procedure Diagnose_Predicated_Actual;\n       --  There are a number of constructs in which a discrete type with\n       --  predicates is illegal, e.g. as an index in an array type declaration.\n@@ -12202,6 +12210,79 @@ package body Sem_Ch12 is\n       --  Check that base types are the same and that the subtypes match\n       --  statically. Used in several of the above.\n \n+      --------------------------------------------\n+      --  Check_Shared_Variable_Control_Aspects --\n+      --------------------------------------------\n+\n+      --  Ada_2020: Verify that shared variable control aspects (RM C.6)\n+      --  that may be specified for the formal are obeyed by the actual.\n+\n+      procedure Check_Shared_Variable_Control_Aspects is\n+      begin\n+         if Ada_Version >= Ada_2020 then\n+            if Is_Atomic (A_Gen_T) and then not Is_Atomic (Act_T) then\n+               Error_Msg_NE\n+                  (\"actual for& must be an atomic type\", Actual, A_Gen_T);\n+            end if;\n+\n+            if Is_Volatile (A_Gen_T) and then not Is_Volatile (Act_T) then\n+               Error_Msg_NE\n+                  (\"actual for& must be a Volatile type\", Actual, A_Gen_T);\n+            end if;\n+\n+            if\n+              Is_Independent (A_Gen_T) and then not Is_Independent (Act_T)\n+            then\n+               Error_Msg_NE\n+                 (\"actual for& must be an Independent type\", Actual, A_Gen_T);\n+            end if;\n+\n+            --  We assume that an array type whose atomic component type\n+            --  is Atomic is equivalent to an array type with the explicit\n+            --  aspect Has_Atomic_Components. This is a reasonable inference\n+            --  from the intent of AI12-0282, and makes it legal to use an\n+            --  actual that does not have the identical aspect as the formal.\n+\n+            if Has_Atomic_Components (A_Gen_T)\n+               and then not Has_Atomic_Components (Act_T)\n+            then\n+               if Is_Array_Type (Act_T)\n+                 and then Is_Atomic (Component_Type (Act_T))\n+               then\n+                  null;\n+\n+               else\n+                  Error_Msg_NE\n+                    (\"actual for& must have atomic components\",\n+                       Actual, A_Gen_T);\n+               end if;\n+            end if;\n+\n+            if Has_Independent_Components (A_Gen_T)\n+               and then not Has_Independent_Components (Act_T)\n+            then\n+               Error_Msg_NE\n+                 (\"actual for& must have independent components\",\n+                    Actual, A_Gen_T);\n+            end if;\n+\n+            if Has_Volatile_Components (A_Gen_T)\n+               and then not Has_Volatile_Components (Act_T)\n+            then\n+               if Is_Array_Type (Act_T)\n+                 and then Is_Volatile (Component_Type (Act_T))\n+               then\n+                  null;\n+\n+               else\n+                  Error_Msg_NE\n+                    (\"actual for& must have volatile components\",\n+                       Actual, A_Gen_T);\n+               end if;\n+            end if;\n+         end if;\n+      end Check_Shared_Variable_Control_Aspects;\n+\n       ---------------------------------\n       --  Diagnose_Predicated_Actual --\n       ---------------------------------\n@@ -12820,12 +12901,21 @@ package body Sem_Ch12 is\n          --  Perform atomic/volatile checks (RM C.6(12)). Note that AI05-0218-1\n          --  removes the second instance of the phrase \"or allow pass by copy\".\n \n-         if Is_Atomic (Act_T) and then not Is_Atomic (Ancestor) then\n+         --  In Ada_2020 the aspect may be specified explicitly for the formal\n+         --  regardless of whether an ancestor obeys it.\n+\n+         if Is_Atomic (Act_T)\n+             and then not Is_Atomic (Ancestor)\n+             and then not Is_Atomic (A_Gen_T)\n+         then\n             Error_Msg_N\n               (\"cannot have atomic actual type for non-atomic formal type\",\n                Actual);\n \n-         elsif Is_Volatile (Act_T) and then not Is_Volatile (Ancestor) then\n+         elsif Is_Volatile (Act_T)\n+           and then not Is_Volatile (Ancestor)\n+           and then not Is_Volatile (A_Gen_T)\n+         then\n             Error_Msg_N\n               (\"cannot have volatile actual type for non-volatile formal type\",\n                Actual);\n@@ -13504,6 +13594,8 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n+      Check_Shared_Variable_Control_Aspects;\n+\n       if Error_Posted (Act_T) then\n          null;\n       else"}, {"sha": "5944ba5453d254141d28b07824b36243e3efc4ee", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "patch": "@@ -2131,12 +2131,27 @@ package body Sem_Ch13 is\n                      Aspect);\n                end if;\n \n-               --  Not allowed for formal type declarations\n+               --  Not allowed for formal type declarations in previous\n+               --  versions of the language. Allowed for them only for\n+               --  shared variable control aspects.\n \n                if Nkind (N) = N_Formal_Type_Declaration then\n-                  Error_Msg_N\n-                    (\"aspect % not allowed for formal type declaration\",\n-                     Aspect);\n+                  if Ada_Version < Ada_2020 then\n+                     Error_Msg_N\n+                       (\"aspect % not allowed for formal type declaration\",\n+                        Aspect);\n+\n+                  elsif A_Id /= Aspect_Atomic\n+                     and then A_Id /= Aspect_Volatile\n+                     and then A_Id /= Aspect_Independent\n+                     and then A_Id /= Aspect_Atomic_Components\n+                     and then A_Id /= Aspect_Independent_Components\n+                     and then A_Id /= Aspect_Volatile_Components\n+                  then\n+                     Error_Msg_N\n+                       (\"aspect % not allowed for formal type declaration\",\n+                        Aspect);\n+                  end if;\n                end if;\n             end if;\n \n@@ -12837,8 +12852,13 @@ package body Sem_Ch13 is\n         and then (Nkind (N) /= N_Pragma\n                    or else Get_Pragma_Id (N) /= Pragma_Convention)\n       then\n-         Error_Msg_N (\"representation item not allowed for generic type\", N);\n-         return True;\n+         if Ada_Version < Ada_2020 then\n+            Error_Msg_N\n+              (\"representation item not allowed for generic type\", N);\n+            return True;\n+         else\n+            return False;\n+         end if;\n       end if;\n \n       --  Otherwise check for incomplete type"}, {"sha": "2369d64f732f7e63ea7218f9f73be0abb853189a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c6e3673a9eddf168fbe8d5cfab70f55fea08f8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=64c6e3673a9eddf168fbe8d5cfab70f55fea08f8", "patch": "@@ -7562,24 +7562,33 @@ package body Sem_Prag is\n             --  Attribute belongs on the base type. If the view of the type is\n             --  currently private, it also belongs on the underlying type.\n \n+            --  In Ada_2020, the pragma can apply to a formal type, for which\n+            --  there may be no underlying type.\n+\n             if Prag_Id = Pragma_Atomic\n               or else Prag_Id = Pragma_Shared\n               or else Prag_Id = Pragma_Volatile_Full_Access\n             then\n                Set_Atomic_VFA (Ent);\n                Set_Atomic_VFA (Base_Type (Ent));\n-               Set_Atomic_VFA (Underlying_Type (Ent));\n+\n+               if not Is_Generic_Type (Ent) then\n+                  Set_Atomic_VFA (Underlying_Type (Ent));\n+               end if;\n             end if;\n \n             --  Atomic/Shared/Volatile_Full_Access imply Independent\n \n             if Prag_Id /= Pragma_Volatile then\n                Set_Is_Independent (Ent);\n                Set_Is_Independent (Base_Type (Ent));\n-               Set_Is_Independent (Underlying_Type (Ent));\n \n-               if Prag_Id = Pragma_Independent then\n-                  Record_Independence_Check (N, Base_Type (Ent));\n+               if not Is_Generic_Type (Ent) then\n+                  Set_Is_Independent (Underlying_Type (Ent));\n+\n+                  if Prag_Id = Pragma_Independent then\n+                     Record_Independence_Check (N, Base_Type (Ent));\n+                  end if;\n                end if;\n             end if;\n \n@@ -7588,10 +7597,13 @@ package body Sem_Prag is\n             if Prag_Id /= Pragma_Independent then\n                Set_Is_Volatile (Ent);\n                Set_Is_Volatile (Base_Type (Ent));\n-               Set_Is_Volatile (Underlying_Type (Ent));\n+\n+               if not Is_Generic_Type (Ent) then\n+                  Set_Is_Volatile (Underlying_Type (Ent));\n+                  Set_Treat_As_Volatile (Underlying_Type (Ent));\n+               end if;\n \n                Set_Treat_As_Volatile (Ent);\n-               Set_Treat_As_Volatile (Underlying_Type (Ent));\n             end if;\n \n             --  Apply Volatile to the composite type's individual components,\n@@ -14076,6 +14088,9 @@ package body Sem_Prag is\n                              Ekind (E) = E_Variable)\n                    and then Nkind (Object_Definition (D)) =\n                                        N_Constrained_Array_Definition)\n+              or else\n+                 (Ada_Version >= Ada_2020\n+                   and then Nkind (D) = N_Formal_Type_Declaration)\n             then\n                --  The flag is set on the base type, or on the object\n \n@@ -14090,6 +14105,7 @@ package body Sem_Prag is\n                      Check_Atomic_VFA\n                        (Component_Type (Etype (E)), VFA => False);\n                   end if;\n+\n                   Set_Has_Atomic_Components (E);\n                   Set_Has_Independent_Components (E);\n                end if;"}]}