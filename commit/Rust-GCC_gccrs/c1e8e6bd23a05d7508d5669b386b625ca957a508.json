{"sha": "c1e8e6bd23a05d7508d5669b386b625ca957a508", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlOGU2YmQyM2EwNWQ3NTA4ZDU2NjliMzg2YjYyNWNhOTU3YTUwOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-03-04T22:37:57Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-03-04T22:37:57Z"}, "message": "(machine_dependent_reorg): In TARGET_RELAX code...\n\n(machine_dependent_reorg): In TARGET_RELAX code, when scan\nforward from LINK, fail if pass a CODE_LABEL before finding INSN.\nFail if SCAN not INSN is a JUMP_INSN.\n\nFrom-SVN: r11419", "tree": {"sha": "d1443d65bb8eeadc918357325fd6c027cc18b359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1443d65bb8eeadc918357325fd6c027cc18b359"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1e8e6bd23a05d7508d5669b386b625ca957a508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e8e6bd23a05d7508d5669b386b625ca957a508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e8e6bd23a05d7508d5669b386b625ca957a508", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e8e6bd23a05d7508d5669b386b625ca957a508/comments", "author": null, "committer": null, "parents": [{"sha": "f2d82a9550c96f44251d01aec06b2cf589b4054d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d82a9550c96f44251d01aec06b2cf589b4054d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d82a9550c96f44251d01aec06b2cf589b4054d"}], "stats": {"total": 22, "additions": 16, "deletions": 6}, "files": [{"sha": "b561de7f774f26aef53b74aee90e8f28700a05d4", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e8e6bd23a05d7508d5669b386b625ca957a508/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e8e6bd23a05d7508d5669b386b625ca957a508/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c1e8e6bd23a05d7508d5669b386b625ca957a508", "patch": "@@ -1548,23 +1548,33 @@ machine_dependent_reorg (first)\n              make sure that the only insns which use REG are\n              themselves function calls.  */\n \n+\t  /* ??? This doesn't work for call targets that were allocated\n+\t     by reload, since there may not be a REG_DEAD note for the\n+\t     register.  */\n+\n \t  dies = NULL_RTX;\n \t  for (scan = NEXT_INSN (link); scan; scan = NEXT_INSN (scan))\n \t    {\n \t      rtx scanset;\n \n+\t      /* Don't try to trace forward past a CODE_LABEL if we haven't\n+\t\t seen INSN yet.  Ordinarily, we will only find the setting insn\n+\t\t in LOG_LINKS if it is in the same basic block.  However,\n+\t\t cross-jumping can insert code labels in between the load and\n+\t\t the call, and can result in situations where a single call\n+\t\t insn may have two targets depending on where we came from.  */\n+\n+\t      if (GET_CODE (scan) == CODE_LABEL && ! foundinsn)\n+\t\tbreak;\n+\n \t      if (GET_RTX_CLASS (GET_CODE (scan)) != 'i')\n \t\tcontinue;\n \n \t      /* Don't try to trace forward past a JUMP.  To optimize\n                  safely, we would have to check that all the\n-                 instructions at the jump destination did not use REG.\n-                 It should be safe to trace past a CODE_LABEL, because\n-                 we will only find the setting insn in LOG_LINKS if it\n-                 is in the same basic block (so probably we should\n-                 never find a CODE_LABEL anyhow).  */\n+                 instructions at the jump destination did not use REG.  */\n \n-\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t      if (GET_CODE (scan) == JUMP_INSN)\n \t\tbreak;\n \n \t      if (! reg_mentioned_p (reg, scan))"}]}