{"sha": "942c4b32b0553378f843e606bb56c417acbdc4be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQyYzRiMzJiMDU1MzM3OGY4NDNlNjA2YmI1NmM0MTdhY2JkYzRiZQ==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2019-11-15T03:09:19Z"}, "committer": {"name": "Thomas Rodgers", "email": "rodgertq@gcc.gnu.org", "date": "2019-11-15T03:09:19Z"}, "message": "Support for jthread and stop_token\n\n        * include/Makefile.am: Add <stop_token> header.\n        * include/Makefile.in: Regenerate.\n        * include/std/condition_variable: Add overloads for stop_token support\n        to condition_variable_any.\n        * include/std/stop_token: New file.\n        * include/std/thread: Add jthread type.\n        * include/std/version (__cpp_lib_jthread): New value.\n        * testsuite/30_threads/condition_variable_any/stop_token/1.cc: New test.\n        * testsuite/30_threads/condition_variable_any/stop_token/2.cc: New test.\n        * testsuite/30_threads/condition_variable_any/stop_token/wait_on.cc: New test.\n        * testsuite/30_threads/jthread/1.cc: New test.\n        * testsuite/30_threads/jthread/2.cc: New test.\n        * testsuite/30_threads/jthread/jthread.cc: New test.\n        * testsuite/30_threads/stop_token/1.cc: New test.\n        * testsuite/30_threads/stop_token/2.cc: New test.\n        * testsuite/30_threads/stop_token/stop_token.cc: New test.\n\nFrom-SVN: r278274", "tree": {"sha": "41fec04827f82dc4850fc993c2d0958d8a12fb02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41fec04827f82dc4850fc993c2d0958d8a12fb02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/942c4b32b0553378f843e606bb56c417acbdc4be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942c4b32b0553378f843e606bb56c417acbdc4be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/942c4b32b0553378f843e606bb56c417acbdc4be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942c4b32b0553378f843e606bb56c417acbdc4be/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8aea5e37d12e09fef68b854a190f71d6b39e11f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8aea5e37d12e09fef68b854a190f71d6b39e11f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8aea5e37d12e09fef68b854a190f71d6b39e11f"}], "stats": {"total": 1197, "additions": 1197, "deletions": 0}, "files": [{"sha": "973dec2daba95c94164e3bc3ace7bd50f3442d1a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -1,3 +1,22 @@\n+2019-11-14  Thomas Rodgers  <trodgers@redhat.com>\n+\n+\t* include/Makefile.am: Add <stop_token> header.\n+        * include/Makefile.in: Regenerate.\n+\t* include/std/condition_variable: Add overloads for stop_token support\n+\tto condition_variable_any.\n+\t* include/std/stop_token: New file.\n+\t* include/std/thread: Add jthread type.\n+\t* include/std/version (__cpp_lib_jthread): New value.\n+\t* testsuite/30_threads/condition_variable_any/stop_token/1.cc: New test.\n+\t* testsuite/30_threads/condition_variable_any/stop_token/2.cc: New test.\n+\t* testsuite/30_threads/condition_variable_any/stop_token/wait_on.cc: New test.\n+\t* testsuite/30_threads/jthread/1.cc: New test.\n+\t* testsuite/30_threads/jthread/2.cc: New test.\n+\t* testsuite/30_threads/jthread/jthread.cc: New test.\n+\t* testsuite/30_threads/stop_token/1.cc: New test.\n+\t* testsuite/30_threads/stop_token/2.cc: New test.\n+\t* testsuite/30_threads/stop_token/stop_token.cc: New test.\n+\n 2019-11-14  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tImplement the <array> part of C++20 p1032 Misc constexpr bits."}, {"sha": "6300de9e96d2f7ce69a974f7b91353a20d182b5c", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -74,6 +74,7 @@ std_headers = \\\n \t${std_srcdir}/sstream \\\n \t${std_srcdir}/stack \\\n \t${std_srcdir}/stdexcept \\\n+\t${std_srcdir}/stop_token \\\n \t${std_srcdir}/streambuf \\\n \t${std_srcdir}/string \\\n \t${std_srcdir}/string_view \\"}, {"sha": "ae4a493ea65829277453431cc087bad2a5d4409e", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -418,6 +418,7 @@ std_headers = \\\n \t${std_srcdir}/sstream \\\n \t${std_srcdir}/stack \\\n \t${std_srcdir}/stdexcept \\\n+\t${std_srcdir}/stop_token \\\n \t${std_srcdir}/streambuf \\\n \t${std_srcdir}/string \\\n \t${std_srcdir}/string_view \\"}, {"sha": "8887cee29fa2b10d72795c3a026c9af9c7169aa0", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -36,6 +36,7 @@\n #else\n \n #include <chrono>\n+\n #include <bits/std_mutex.h>\n #include <bits/unique_lock.h>\n #include <ext/concurrence.h>\n@@ -45,6 +46,11 @@\n #include <bits/shared_ptr.h>\n #include <bits/cxxabi_forced.h>\n \n+#if __cplusplus > 201703L\n+#define __cpp_lib_jthread 201907L\n+#include <stop_token>\n+#endif\n+\n #if defined(_GLIBCXX_HAS_GTHREADS)\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -360,6 +366,84 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait_for(_Lock& __lock,\n \t       const chrono::duration<_Rep, _Period>& __rtime, _Predicate __p)\n       { return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p)); }\n+\n+#ifdef __cpp_lib_jthread\n+    template <class _Lock, class _Predicate>\n+    bool wait_on(_Lock& __lock,\n+                 stop_token __stoken,\n+                 _Predicate __p)\n+    {\n+      if (__stoken.stop_requested())\n+        {\n+          return __p();\n+        }\n+ \n+      std::stop_callback __cb(__stoken, [this] { notify_all(); });\n+      shared_ptr<mutex> __mutex = _M_mutex;\n+      while (!__p())\n+        {\n+          unique_lock<mutex> __my_lock(*__mutex);\n+          if (__stoken.stop_requested())\n+            {\n+              return false;\n+            }\n+          // *__mutex must be unlocked before re-locking __lock so move\n+          // ownership of *__mutex lock to an object with shorter lifetime.\n+          _Unlock<_Lock> __unlock(__lock);\n+          unique_lock<mutex> __my_lock2(std::move(__my_lock));\n+          _M_cond.wait(__my_lock2);\n+        }\n+      return true;\n+    }\n+\n+    template <class _Lock, class _Clock, class _Duration, class _Predicate>\n+    bool wait_on_until(_Lock& __lock,\n+                       stop_token __stoken,\n+                       const chrono::time_point<_Clock, _Duration>& __abs_time,\n+                       _Predicate __p)\n+    {\n+      if (__stoken.stop_requested())\n+        {\n+          return __p();\n+        }\n+\n+      std::stop_callback __cb(__stoken, [this] { notify_all(); });\n+      shared_ptr<mutex> __mutex = _M_mutex;\n+      while (!__p())\n+        {\n+          bool __stop;\n+          {\n+            unique_lock<mutex> __my_lock(*__mutex);\n+            if (__stoken.stop_requested())\n+              {\n+                return false;\n+              }\n+            _Unlock<_Lock> __u(__lock);\n+            unique_lock<mutex> __my_lock2(std::move(__my_lock));\n+            const auto __status = _M_cond.wait_until(__my_lock2, __abs_time);\n+            __stop = (__status == std::cv_status::timeout) || __stoken.stop_requested();\n+          }\n+          if (__stop)\n+            {\n+              return __p();\n+            }\n+        }\n+      return true;\n+    }\n+\n+    template <class _Lock, class _Rep, class _Period, class _Predicate>\n+    bool wait_on_for(_Lock& __lock,\n+                     stop_token __stoken,\n+                     const chrono::duration<_Rep, _Period>& __rel_time,\n+                     _Predicate __p)\n+    {\n+      auto __abst = std::chrono::steady_clock::now() + __rel_time;\n+      return wait_on_until(__lock,\n+                           std::move(__stoken),\n+                           __abst,\n+                           std::move(__p));\n+    }\n+#endif\n   };\n \n   } // end inline namespace"}, {"sha": "af64018bb0e34b02006216542b84fbce57af30fa", "filename": "libstdc++-v3/include/std/stop_token", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,370 @@\n+// <stop_token> -*- C++ -*-\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/stop_token\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_STOP_TOKEN\n+#define _GLIBCXX_STOP_TOKEN\n+\n+#if __cplusplus > 201703L\n+\n+#include <type_traits>\n+#include <memory>\n+#include <mutex>\n+#include <atomic>\n+\n+#define __cpp_lib_jthread 201907L\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  class stop_source;\n+  template<typename _Callback>\n+  class stop_callback;\n+\n+  struct nostopstate_t { explicit nostopstate_t() = default; };\n+  inline constexpr nostopstate_t nostopstate();\n+\n+  class stop_token\n+  {\n+  public:\n+    stop_token() noexcept = default;\n+\n+    stop_token(const stop_token& __other) noexcept = default;\n+    stop_token(stop_token&& __other) noexcept = default;\n+\n+    ~stop_token() = default;\n+\n+    stop_token&\n+    operator=(const stop_token& __rhs) noexcept = default;\n+\n+    stop_token&\n+    operator=(stop_token&& __rhs) noexcept;\n+\n+    [[nodiscard]]\n+    bool\n+    stop_possible() const noexcept\n+    {\n+      return static_cast<bool>(_M_state);\n+    }\n+\n+    [[nodiscard]]\n+    bool\n+    stop_requested() const noexcept\n+    {\n+      return stop_possible() && _M_state->_M_stop_requested();\n+    }\n+\n+    [[nodiscard]]\n+    friend bool\n+    operator==(const stop_token& __a, const stop_token& __b)\n+    {\n+      return __a._M_state == __b._M_state;\n+    }\n+\n+    [[nodiscard]]\n+    friend bool\n+    operator!=(const stop_token& __a, const stop_token& __b)\n+    {\n+      return __a._M_state == __b._M_state;\n+    }\n+\n+  private:\n+    friend stop_source;\n+    template<typename _Callback>\n+    friend class stop_callback;\n+\n+    struct _Stop_cb {\n+      void(*_M_callback)(_Stop_cb*);\n+      _Stop_cb* _M_prev = nullptr;\n+      _Stop_cb* _M_next = nullptr;\n+\n+      template<typename _Cb>\n+      _Stop_cb(_Cb&& __cb)\n+        : _M_callback(std::move(__cb))\n+      { }\n+\n+      bool\n+      _M_linked() const\n+      {\n+        return (_M_prev != nullptr)\n+          || (_M_next != nullptr);\n+      }\n+\n+      static void\n+      _S_execute(_Stop_cb* __cb) noexcept\n+      {\n+        __cb->_M_callback(__cb);\n+        __cb->_M_prev = __cb->_M_next = nullptr;\n+      }\n+    };\n+\n+    struct _Stop_state_t {\n+      std::atomic<bool> _M_stopped;\n+      std::mutex _M_mtx;\n+      _Stop_cb* _M_head = nullptr;\n+\n+      _Stop_state_t()\n+        : _M_stopped{false}\n+      { }\n+\n+      bool\n+      _M_stop_requested()\n+      {\n+        return _M_stopped;\n+      }\n+\n+      bool\n+      _M_request_stop()\n+      {\n+        bool __stopped = false;\n+        if (_M_stopped.compare_exchange_strong(__stopped, true))\n+          {\n+            std::unique_lock<std::mutex> __lck{_M_mtx};\n+            while (_M_head)\n+              {\n+                auto __p = _M_head;\n+                _M_head = _M_head->_M_next;\n+                _Stop_cb::_S_execute(__p);\n+              }\n+            return true;\n+          }\n+        return false;\n+      }\n+\n+      bool\n+      _M_register_callback(_Stop_cb* __cb)\n+      {\n+        std::unique_lock<std::mutex> __lck{_M_mtx};\n+        if (_M_stopped)\n+          return false;\n+\n+        __cb->_M_next = _M_head;\n+        if (_M_head)\n+          {\n+            _M_head->_M_prev = __cb;\n+          }\n+        _M_head = __cb;\n+         return true;\n+      }\n+\n+      void\n+      _M_remove_callback(_Stop_cb* __cb)\n+      {\n+        std::unique_lock<std::mutex> __lck{_M_mtx};\n+        if (__cb == _M_head)\n+          {\n+            _M_head = _M_head->_M_next;\n+            if (_M_head)\n+              {\n+                _M_head->_M_prev = nullptr;\n+              }\n+          }\n+        else if (!__cb->_M_linked())\n+          {\n+            return;\n+          }\n+        else\n+          {\n+            __cb->_M_prev->_M_next = __cb->_M_next;\n+            if (__cb->_M_next)\n+              {\n+                __cb->_M_next->_M_prev = __cb->_M_prev;\n+              }\n+          }\n+      }\n+    };\n+\n+    using _Stop_state = std::shared_ptr<_Stop_state_t>;\n+    _Stop_state _M_state;\n+\n+    explicit stop_token(_Stop_state __state)\n+      : _M_state{std::move(__state)}\n+    { }\n+  };\n+\n+  class stop_source {\n+    using _Stop_state_t = stop_token::_Stop_state_t;\n+    using _Stop_state = stop_token::_Stop_state;\n+\n+  public:\n+    stop_source()\n+      : _M_state(std::make_shared<_Stop_state_t>())\n+    { }\n+\n+    explicit stop_source(std::nostopstate_t) noexcept\n+    { }\n+\n+    stop_source(const stop_source& __other) noexcept\n+      : _M_state(__other._M_state)\n+    { }\n+\n+    stop_source(stop_source&& __other) noexcept\n+      : _M_state(std::move(__other._M_state))\n+    { }\n+\n+    stop_source&\n+    operator=(const stop_source& __rhs) noexcept\n+    {\n+      if (_M_state != __rhs._M_state)\n+        _M_state = __rhs._M_state;\n+      return *this;\n+    }\n+\n+    stop_source&\n+    operator=(stop_source&& __rhs) noexcept\n+    {\n+      std::swap(_M_state, __rhs._M_state);\n+      return *this;\n+    }\n+\n+    [[nodiscard]]\n+    bool\n+    stop_possible() const noexcept\n+    {\n+      return static_cast<bool>(_M_state);\n+    }\n+\n+    [[nodiscard]]\n+    bool\n+    stop_requested() const noexcept\n+    {\n+      return stop_possible() && _M_state->_M_stop_requested();\n+    }\n+\n+    bool\n+    request_stop() const noexcept\n+    {\n+      if (stop_possible())\n+        return _M_state->_M_request_stop();\n+      return false;\n+    }\n+\n+    [[nodiscard]]\n+    stop_token\n+    get_token() const noexcept\n+    {\n+      return stop_token{_M_state};\n+    }\n+\n+    void\n+    swap(stop_source& __other) noexcept\n+    {\n+      std::swap(_M_state, __other._M_state);\n+    }\n+\n+    [[nodiscard]]\n+    friend bool\n+    operator==(const stop_source& __a, const stop_source& __b) noexcept\n+    {\n+      return __a._M_state == __b._M_state;\n+    }\n+\n+    [[nodiscard]]\n+    friend bool\n+    operator!=(const stop_source& __a, const stop_source& __b) noexcept\n+    {\n+      return __a._M_state != __b._M_state;\n+    }\n+\n+  private:\n+    _Stop_state _M_state;\n+  };\n+\n+  template<typename _Callback>\n+    class [[nodiscard]] stop_callback\n+      : private stop_token::_Stop_cb\n+    {\n+      using _Stop_cb = stop_token::_Stop_cb;\n+      using _Stop_state = stop_token::_Stop_state;\n+    public:\n+      using callback_type = _Callback;\n+\n+      template<typename _Cb,\n+               std::enable_if_t<std::is_constructible_v<_Callback, _Cb>, int> = 0>\n+        explicit stop_callback(const stop_token& __token, _Cb&& __cb)\n+        noexcept(std::is_nothrow_constructible_v<_Callback, _Cb>)\n+        : _Stop_cb([](_Stop_cb* __that) noexcept\n+                   {\n+                     static_cast<stop_callback*>(__that)->_M_execute();\n+                   }),\n+        _M_cb(std::move(__cb))\n+        {\n+          auto res = __token._M_state->_M_register_callback(this);\n+          if (__token._M_state && res)\n+            {\n+              _M_state = __token._M_state;\n+            }\n+        }\n+\n+      template<typename _Cb,\n+               std::enable_if_t<std::is_constructible_v<_Callback, _Cb>, int> = 0>\n+        explicit stop_callback(stop_token&& __token, _Cb&& __cb)\n+        noexcept(std::is_nothrow_constructible_v<_Callback, _Cb>)\n+        : _Stop_cb([](_Stop_cb* __that) noexcept\n+                   {\n+                     static_cast<stop_callback*>(__that)->_M_execute();\n+                   }),\n+          _M_cb(std::move(__cb))\n+          {\n+            if (__token._M_state && __token._M_state->_M_register_callback(this))\n+              {\n+                std::swap(_M_state, __token._M_state);\n+              }\n+          }\n+\n+      ~stop_callback()\n+        {\n+          if (_M_state)\n+            {\n+              _M_state->_M_remove_callback(this);\n+            }\n+        }\n+\n+      stop_callback(const stop_callback&) = delete;\n+      stop_callback& operator=(const stop_callback&) = delete;\n+      stop_callback(stop_callback&&) = delete;\n+      stop_callback& operator=(stop_callback&&) = delete;\n+\n+    private:\n+      _Callback _M_cb;\n+      _Stop_state _M_state = nullptr;\n+\n+      void\n+        _M_execute() noexcept\n+      {\n+        _M_cb();\n+      }\n+    };\n+\n+  template<typename _Callback>\n+    stop_callback(stop_token, _Callback) -> stop_callback<_Callback>;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // __cplusplus >= 201703L\n+#endif // _GLIBCXX_STOP_TOKEN"}, {"sha": "93afa766d181f71397a1c4a41aecba23fe6e747c", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -39,6 +39,13 @@\n #include <memory>\n #include <tuple>\n #include <cerrno>\n+\n+#if __cplusplus > 201703L\n+#define __cpp_lib_jthread 201907L\n+#include <functional>\n+#include <stop_token>\n+#endif\n+\n #include <bits/functexcept.h>\n #include <bits/functional_hash.h>\n #include <bits/invoke.h>\n@@ -409,6 +416,124 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // @} group threads\n \n+#ifdef __cpp_lib_jthread\n+\n+  class jthread\n+  {\n+  public:\n+    using id = std::thread::id;\n+    using native_handle_type = std::thread::native_handle_type;\n+\n+    jthread() noexcept\n+    : _M_stop_source{ nostopstate_t{ } }\n+    { }\n+\n+    template<typename _Callable, typename... _Args,\n+             typename = std::enable_if_t<!std::is_same_v<std::decay_t<_Callable>, jthread>>>\n+    explicit\n+    jthread(_Callable&& __f, _Args&&... __args)\n+      : _M_thread{[](stop_token __token, auto&& __cb, auto&&... __args)\n+                  {\n+                    if constexpr(std::is_invocable_v<_Callable, stop_token, _Args...>)\n+                      {\n+                        std::invoke(std::forward<decltype(__cb)>(__cb),\n+                                    std::move(__token),\n+                                    std::forward<decltype(__args)>(__args)...);\n+                      }\n+                    else\n+                      {\n+                        std::invoke(std::forward<decltype(__cb)>(__cb),\n+                                    std::forward<decltype(__args)>(__args)...);\n+                      }\n+                  },\n+                  _M_stop_source.get_token(),\n+                  std::forward<_Callable>(__f),\n+                  std::forward<_Args>(__args)...}\n+    { }\n+\n+    jthread(const jthread&) = delete;\n+    jthread(jthread&&) noexcept = default;\n+\n+    ~jthread()\n+    {\n+      if (joinable())\n+        {\n+          request_stop();\n+          join();\n+        }\n+    }\n+\n+    jthread&\n+    operator=(const jthread&) = delete;\n+\n+    jthread&\n+    operator=(jthread&&) noexcept = default;\n+\n+    void\n+    swap(jthread& __other) noexcept\n+    {\n+      std::swap(_M_stop_source, __other._M_stop_source);\n+      std::swap(_M_thread, __other._M_thread);\n+    }\n+\n+    bool\n+    joinable() const noexcept\n+    {\n+      return _M_thread.joinable();\n+    }\n+\n+    void\n+    join()\n+    {\n+      _M_thread.join();\n+    }\n+\n+    void\n+    detach()\n+    {\n+      _M_thread.detach();\n+    }\n+\n+    id\n+    get_id() const noexcept\n+    {\n+      _M_thread.get_id();\n+    }\n+\n+    native_handle_type\n+    native_handle()\n+    {\n+      return _M_thread.native_handle();\n+    }\n+\n+    static unsigned\n+    hardware_concurrency() noexcept\n+    {\n+      return std::thread::hardware_concurrency();\n+    }\n+\n+    [[nodiscard]] stop_source\n+    get_stop_source() noexcept\n+    {\n+      return _M_stop_source;\n+    }\n+\n+    [[nodiscard]] stop_token\n+    get_stop_token() const noexcept\n+    {\n+      return _M_stop_source.get_token();\n+    }\n+\n+    bool request_stop() noexcept\n+    {\n+      return get_stop_source().request_stop();\n+    }\n+\n+  private:\n+    stop_source _M_stop_source;\n+    std::thread _M_thread;\n+  };\n+#endif // __cpp_lib_jthread\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "278074289036ecdf45db8025e0f794bd522407f3", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -187,6 +187,7 @@\n #define __cpp_lib_list_remove_return_type 201806L\n #define __cpp_lib_math_constants 201907L\n #define __cpp_lib_span 201902L\n+#define __cpp_lib_jthread 201907L\n #if __cpp_impl_three_way_comparison >= 201907L\n # define __cpp_lib_three_way_comparison 201711L\n #endif"}, {"sha": "c1f4b5849ac7ee380e54cdc482db759aa86a881c", "filename": "libstdc++-v3/testsuite/30_threads/condition_variable_any/stop_token/1.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2F1.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <condition_variable>\n+\n+#ifndef __cpp_lib_jthread\n+# error \"Feature-test macro for jthread missing in <condition_variable>\"\n+#elif __cpp_lib_jthread != 201907L\n+# error \"Feature-test macro for jthread has wrong value in <condition_variable>\"\n+#endif"}, {"sha": "621965c89102ff0d3a15a3c39522c254e20396e9", "filename": "libstdc++-v3/testsuite/30_threads/condition_variable_any/stop_token/2.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2F2.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_jthread\n+# error \"Feature-test macro for jthread missing in <version>\"\n+#elif __cpp_lib_jthread != 201907L\n+# error \"Feature-test macro for jthread has wrong value in <version>\"\n+#endif"}, {"sha": "212fc949b3fb5a3a503286eb561a1774bde7f47f", "filename": "libstdc++-v3/testsuite/30_threads/condition_variable_any/stop_token/wait_on.cc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2Fwait_on.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2Fwait_on.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable_any%2Fstop_token%2Fwait_on.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,136 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run }\n+// { dg-require-effective-target c++2a }\n+// { dg-require-effective-target pthread }\n+\n+#include <condition_variable>\n+#include <thread>\n+#include <mutex>\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+using namespace::std::literals;\n+\n+void test_wait_on_stop()\n+{\n+  bool ready = false;\n+  std::mutex mtx;\n+  std::condition_variable_any cv;\n+\n+  std::stop_source src;\n+\n+  auto tok = src.get_token();\n+  std::thread t([&ready, &mtx, &cv, tok]\n+                {\n+                  std::unique_lock lck(mtx);\n+                  auto res = cv.wait_on(lck, tok, [&ready] { return ready; });\n+                  if (!res)\n+                    {\n+                      VERIFY(tok.stop_requested());\n+                    }\n+                });\n+\n+  std::this_thread::sleep_for(0.5s);\n+  VERIFY(!src.stop_requested());\n+  src.request_stop();\n+  t.join();\n+  VERIFY(src.stop_requested());\n+}\n+\n+void test_wait_on_until(bool ck = true)\n+{\n+  bool ready = false;\n+  std::mutex mtx;\n+  std::condition_variable_any cv;\n+\n+  std::stop_source src;\n+\n+  auto abst = std::chrono::steady_clock::now() + 1.0s;\n+  auto tok = src.get_token();\n+  std::thread t([ck, &ready, &mtx, &cv, abst, tok]\n+                {\n+                  std::unique_lock lck(mtx);\n+                  auto res = cv.wait_on_until(lck, tok, abst, [&ready] { return ready; });\n+                  if (!res && ck)\n+                    {\n+                      VERIFY(tok.stop_requested());\n+                    }\n+                });\n+\n+  if (ck)\n+    {\n+      std::this_thread::sleep_for(0.5s);\n+      VERIFY(!src.stop_requested());\n+      src.request_stop();\n+      t.join();\n+      VERIFY(src.stop_requested());\n+    }\n+  else\n+    {\n+      std::this_thread::sleep_for(1.5s);\n+      t.join();\n+      VERIFY(!src.stop_requested());\n+    }\n+}\n+\n+void test_wait_on_for(bool ck = true)\n+{\n+  bool ready = false;\n+  std::mutex mtx;\n+  std::condition_variable_any cv;\n+\n+  std::stop_source src;\n+\n+  auto tok = src.get_token();\n+  std::thread t([ck, &ready, &mtx, &cv, tok]\n+                {\n+                  std::unique_lock lck(mtx);\n+                  auto res = cv.wait_on_for(lck, tok, 1.0s, [&ready] { return ready; });\n+                  if (!res && ck)\n+                    {\n+                      VERIFY(tok.stop_requested());\n+                    }\n+                });\n+\n+  if (ck)\n+    {\n+      std::this_thread::sleep_for(0.5s);\n+      VERIFY(!src.stop_requested());\n+      src.request_stop();\n+      t.join();\n+      VERIFY(src.stop_requested());\n+    }\n+  else\n+    {\n+      std::this_thread::sleep_for(1.5s);\n+      t.join();\n+      VERIFY(!src.stop_requested());\n+    };\n+}\n+\n+int main()\n+{\n+  test_wait_on_stop();\n+  test_wait_on_until(false);\n+  test_wait_on_until();\n+  test_wait_on_for();\n+  test_wait_on_for(false);\n+  return 0;\n+}"}, {"sha": "1fb5650dbc6d83f0c6b9ad398623b9fd91d8555b", "filename": "libstdc++-v3/testsuite/30_threads/jthread/1.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F1.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <thread>\n+\n+#ifndef __cpp_lib_jthread\n+# error \"Feature-test macro for jthread missing in <thread>\"\n+#elif __cpp_lib_jthread != 201907L\n+# error \"Feature-test macro for jthread has wrong value in <thread>\"\n+#endif"}, {"sha": "621965c89102ff0d3a15a3c39522c254e20396e9", "filename": "libstdc++-v3/testsuite/30_threads/jthread/2.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F2.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_jthread\n+# error \"Feature-test macro for jthread missing in <version>\"\n+#elif __cpp_lib_jthread != 201907L\n+# error \"Feature-test macro for jthread has wrong value in <version>\"\n+#endif"}, {"sha": "c29db21216789f89b3f4b0bb1efb3e44e69949c6", "filename": "libstdc++-v3/testsuite/30_threads/jthread/jthread.cc", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2Fjthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2Fjthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2Fjthread.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,198 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <thread>\n+#include <chrono>\n+#include <cassert>\n+#include <atomic>\n+\n+using namespace::std::literals;\n+\n+//------------------------------------------------------\n+\n+void test_no_stop_token()\n+{\n+  // test the basic jthread API (not taking stop_token arg)\n+\n+  assert(std::jthread::hardware_concurrency() == std::thread::hardware_concurrency()); \n+  std::stop_token stoken;\n+  assert(!stoken.stop_possible());\n+  {\n+    std::jthread::id t1ID{std::this_thread::get_id()};\n+    std::atomic<bool> t1AllSet{false};\n+    std::jthread t1([&t1ID, &t1AllSet] {\n+                   t1ID = std::this_thread::get_id();\n+                   t1AllSet.store(true);\n+                   for (int c='9'; c>='0'; --c) {\n+                      std::this_thread::sleep_for(222ms);\n+                   }\n+                 });\n+    for (int i=0; !t1AllSet.load(); ++i) {\n+      std::this_thread::sleep_for(10ms);\n+    }\n+    assert(t1.joinable());\n+    assert(t1ID == t1.get_id());\n+    stoken = t1.get_stop_token();\n+    assert(!stoken.stop_requested());\n+  } \n+  assert(stoken.stop_requested());\n+}\n+\n+//------------------------------------------------------\n+\n+void test_stop_token()\n+{\n+  // test the basic thread API (taking stop_token arg)\n+\n+  std::stop_source ssource;\n+  std::stop_source origsource;\n+  assert(ssource.stop_possible());\n+  assert(!ssource.stop_requested());\n+  {\n+    std::jthread::id t1ID{std::this_thread::get_id()};\n+    std::atomic<bool> t1AllSet{false};\n+    std::atomic<bool> t1done{false};\n+    std::jthread t1([&t1ID, &t1AllSet, &t1done] (std::stop_token st) {\n+                       // check some values of the started thread:\n+                       t1ID = std::this_thread::get_id();\n+                       t1AllSet.store(true);\n+                       for (int i=0; !st.stop_requested(); ++i) {\n+                          std::this_thread::sleep_for(100ms);\n+                       }\n+                       t1done.store(true);\n+                     },\n+                     ssource.get_token());\n+    for (int i=0; !t1AllSet.load(); ++i) {\n+      std::this_thread::sleep_for(10ms);\n+    }\n+    // and check all values:\n+    assert(t1.joinable());\n+    assert(t1ID == t1.get_id());\n+\n+    std::this_thread::sleep_for(470ms);\n+    origsource = std::move(ssource);\n+    ssource = t1.get_stop_source();\n+    assert(!ssource.stop_requested());\n+    auto ret = ssource.request_stop();\n+    assert(ret);\n+    ret = ssource.request_stop();\n+    assert(!ret);\n+    assert(ssource.stop_requested());\n+    assert(!t1done.load());\n+    assert(!origsource.stop_requested());\n+\n+    std::this_thread::sleep_for(470ms);\n+    origsource.request_stop();\n+  } \n+  assert(origsource.stop_requested());\n+  assert(ssource.stop_requested());\n+}\n+\n+//------------------------------------------------------\n+\n+void test_join()\n+{\n+  std::stop_source ssource;\n+  assert(ssource.stop_possible());\n+  {\n+    std::jthread t1([](std::stop_token stoken) {\n+                      for (int i=0; !stoken.stop_requested(); ++i) {\n+                         std::this_thread::sleep_for(100ms);\n+                      }\n+                 });\n+    ssource = t1.get_stop_source();\n+    std::jthread t2([ssource] () mutable {\n+                     for (int i=0; i < 10; ++i) {\n+                       std::this_thread::sleep_for(70ms);\n+                     }\n+                     ssource.request_stop();\n+                   });\n+    // wait for all thread to finish:\n+    t2.join();\n+    assert(!t2.joinable());\n+    assert(t1.joinable());\n+    t1.join();\n+    assert(!t1.joinable());\n+  }\n+}\n+\n+//------------------------------------------------------\n+\n+void test_detach()\n+{\n+  std::stop_source ssource;\n+  assert(ssource.stop_possible());\n+  std::atomic<bool> t1FinallyInterrupted{false};\n+  {\n+    std::jthread t0;\n+    std::jthread::id t1ID{std::this_thread::get_id()};\n+    bool t1IsInterrupted;\n+    std::stop_token t1InterruptToken;\n+    std::atomic<bool> t1AllSet{false};\n+    std::jthread t1([&t1ID, &t1IsInterrupted, &t1InterruptToken, &t1AllSet, &t1FinallyInterrupted]\n+                    (std::stop_token stoken) {\n+                   // check some values of the started thread:\n+                   t1ID = std::this_thread::get_id();\n+                   t1InterruptToken = stoken;\n+                   t1IsInterrupted = stoken.stop_requested();\n+                   assert(stoken.stop_possible());\n+                   assert(!stoken.stop_requested());\n+                   t1AllSet.store(true);\n+                   for (int i=0; !stoken.stop_requested(); ++i) {\n+                      std::this_thread::sleep_for(100ms);\n+                   }\n+                   t1FinallyInterrupted.store(true);\n+                 });\n+    for (int i=0; !t1AllSet.load(); ++i) {\n+      std::this_thread::sleep_for(10ms);\n+    }\n+    assert(!t0.joinable());\n+    assert(t1.joinable());\n+    assert(t1ID == t1.get_id());\n+    assert(t1IsInterrupted == false);\n+    assert(t1InterruptToken == t1.get_stop_source().get_token());\n+    ssource = t1.get_stop_source();\n+    assert(t1InterruptToken.stop_possible());\n+    assert(!t1InterruptToken.stop_requested());\n+    t1.detach();\n+    assert(!t1.joinable());\n+  }\n+\n+  assert(!t1FinallyInterrupted.load());\n+  ssource.request_stop();\n+  assert(ssource.stop_requested());\n+  for (int i=0; !t1FinallyInterrupted.load() && i < 100; ++i) {\n+    std::this_thread::sleep_for(100ms);\n+  }\n+  assert(t1FinallyInterrupted.load());\n+}\n+\n+int main()\n+{\n+  std::set_terminate([](){\n+                       assert(false);\n+                     });\n+\n+  test_no_stop_token();\n+  test_stop_token();\n+  test_join();\n+  test_detach();\n+}\n+"}, {"sha": "4c0e7a33d2511c987e56244d12309686e9a0550d", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/1.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2F1.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <stop_token>\n+\n+#ifndef __cpp_lib_jthread\n+# error \"Feature-test macro for jthread missing in <stop_token>\"\n+#elif __cpp_lib_jthread != 201907L\n+# error \"Feature-test macro for jthread has wrong value in <stop_token>\"\n+#endif"}, {"sha": "621965c89102ff0d3a15a3c39522c254e20396e9", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/2.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2F2.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_jthread\n+# error \"Feature-test macro for jthread missing in <version>\"\n+#elif __cpp_lib_jthread != 201907L\n+# error \"Feature-test macro for jthread has wrong value in <version>\"\n+#endif"}, {"sha": "37d79e8a64e953e8fd73c73363d542e2a7b5779c", "filename": "libstdc++-v3/testsuite/30_threads/stop_token/stop_token.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942c4b32b0553378f843e606bb56c417acbdc4be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fstop_token%2Fstop_token.cc?ref=942c4b32b0553378f843e606bb56c417acbdc4be", "patch": "@@ -0,0 +1,100 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -pthread\" }\n+// { dg-do run }\n+// { dg-require-effective-target c++2a }\n+// { dg-require-effective-target pthread }\n+\n+#include <stop_token>\n+#include <iostream>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // create stop_source\n+  std::stop_source ssrc;\n+  VERIFY(ssrc.stop_possible());\n+  VERIFY(!ssrc.stop_requested());\n+\n+  // create stop_token from stop_source\n+  std::stop_token stok{ssrc.get_token()};\n+  VERIFY(ssrc.stop_possible());\n+  VERIFY(!ssrc.stop_requested());\n+  VERIFY(stok.stop_possible());\n+  VERIFY(!stok.stop_requested());\n+\n+  // register callback\n+  bool cb1called{false};\n+  auto cb1 = [&]{\n+               std::cout << \"cb1\" << std::endl;\n+               cb1called = true;\n+             };\n+  {\n+    std::stop_callback scb1{stok, cb1};\n+    VERIFY(ssrc.stop_possible());\n+    VERIFY(!ssrc.stop_requested());\n+    VERIFY(stok.stop_possible());\n+    VERIFY(!stok.stop_requested());\n+    VERIFY(!cb1called);\n+  } // unregister callback\n+\n+  // register another callback\n+  bool cb2called{false};\n+  auto cb2 = [&]{\n+               VERIFY(stok.stop_requested());\n+               cb2called = true;\n+             };\n+  std::stop_callback scb2a{stok, cb2}; // copies cb2\n+  //  std::stop_callback scb2b{stok, std::move(cb2)};\n+  VERIFY(ssrc.stop_possible());\n+  VERIFY(!ssrc.stop_requested());\n+  VERIFY(stok.stop_possible());\n+  VERIFY(!stok.stop_requested());\n+  VERIFY(!cb1called);\n+  VERIFY(!cb2called);\n+\n+  // request stop\n+  auto b = ssrc.request_stop();\n+  VERIFY(b);\n+  VERIFY(ssrc.stop_possible());\n+  VERIFY(ssrc.stop_requested());\n+  VERIFY(stok.stop_possible());\n+  VERIFY(stok.stop_requested());\n+  VERIFY(!cb1called);\n+  VERIFY(cb2called);\n+\n+  b = ssrc.request_stop();\n+  VERIFY(!b);\n+\n+  // TODO verify the standard requires this\n+#if 0\n+  // register another callback\n+  bool cb3called{false};\n+  std::stop_callback scb3{stok, [&]\n+                                {\n+                                  cb3called = true;\n+                                }};\n+  VERIFY(ssrc.stop_possible());\n+  VERIFY(ssrc.stop_requested());\n+  VERIFY(stok.stop_possible());\n+  VERIFY(stok.stop_requested());\n+  VERIFY(!cb1called);\n+  VERIFY(cb2called);\n+  VERIFY(cb3called);\n+#endif\n+}"}]}