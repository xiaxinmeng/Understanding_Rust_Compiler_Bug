{"sha": "3d66e153b40ed000af30a9e569a05f34d5d576aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2NmUxNTNiNDBlZDAwMGFmMzBhOWU1NjlhMDVmMzRkNWQ1NzZhYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-03T15:53:04Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-04T15:48:50Z"}, "message": "analyzer: fix ICE on non-lvalue in prune_for_sm_diagnostic [PR93993]\n\nPR analyzer/93993 reports another ICE within\ndiagnostic_manager::prune_for_sm_diagnostic in which the expression\nof interest becomes a non-lvalue (similar to PR 93544, PR 93647, and\nPR 93950), due to attempting to get an lvalue for a non-lvalue with a\nNULL context, leading to an ICE when the failure is reported to\nmake_region_for_unexpected_tree_code.  The tree in question is\nan ADDR_EXPR of a VAR_DECL, due to:\n  event 11: switching var of interest from \u2018tm\u2019 in callee to \u2018&qb\u2019 in caller\n\nThis patch adds more bulletproofing to the routine by introducing\na tentative_region_model_context class that can be passed in such\ncircumstances which records that an error occurred, and then\nchecking to see if an error was recorded, thus avoiding the ICE.\nThis is papering over the problem, but a better solution seems more\nlike stage 1 material.\n\nThe patch also refactors the error-checking for CONSTANT_CLASS_P.\n\nThe testcase pr93993.f90 has a false positive:\n\n pr93993.f90:19:0:\n\n    19 |     allocate (tm) ! { dg-warning \"dereference of possibly-NULL\" }\n       |\n Warning: dereference of possibly-NULL \u2018_6\u2019 [CWE-690] [-Wanalyzer-possible-null-dereference]\n\nwhich appears to be a pre-existing bug affecting any allocate call in\nFortran, which I will fix in a followup.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/93993\n\t* checker-path.h (state_change_event::get_lvalue): Add ctxt param\n\tand pass it to region_model::get_value call.\n\t* diagnostic-manager.cc (get_any_origin): Pass a\n\ttentative_region_model_context to the calls to get_lvalue and reject\n\tthe comparison if errors occur.\n\t(can_be_expr_of_interest_p): New function.\n\t(diagnostic_manager::prune_for_sm_diagnostic): Replace checks for\n\tCONSTANT_CLASS_P with calls to update_for_unsuitable_sm_exprs.\n\tPass a tentative_region_model_context to the calls to\n\tstate_change_event::get_lvalue and reject the comparison if errors\n\toccur.\n\t(diagnostic_manager::update_for_unsuitable_sm_exprs): New.\n\t* diagnostic-manager.h\n\t(diagnostic_manager::update_for_unsuitable_sm_exprs): New decl.\n\t* region-model.h (class tentative_region_model_context): New class.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/93993\n\t* gfortran.dg/analyzer/pr93993.f90: New test.", "tree": {"sha": "324fcb1c3d3fa645fbd55481172b5fd2b0f3202a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/324fcb1c3d3fa645fbd55481172b5fd2b0f3202a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d66e153b40ed000af30a9e569a05f34d5d576aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d66e153b40ed000af30a9e569a05f34d5d576aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d66e153b40ed000af30a9e569a05f34d5d576aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d66e153b40ed000af30a9e569a05f34d5d576aa/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13e3ba14eccc0b1ccf1ba9de90443ec7e524f2a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e3ba14eccc0b1ccf1ba9de90443ec7e524f2a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13e3ba14eccc0b1ccf1ba9de90443ec7e524f2a6"}], "stats": {"total": 200, "additions": 166, "deletions": 34}, "files": [{"sha": "4f3e08e4dc47ce31c310010af71daf2e5c385d44", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -1,3 +1,22 @@\n+2020-03-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93993\n+\t* checker-path.h (state_change_event::get_lvalue): Add ctxt param\n+\tand pass it to region_model::get_value call.\n+\t* diagnostic-manager.cc (get_any_origin): Pass a\n+\ttentative_region_model_context to the calls to get_lvalue and reject\n+\tthe comparison if errors occur.\n+\t(can_be_expr_of_interest_p): New function.\n+\t(diagnostic_manager::prune_for_sm_diagnostic): Replace checks for\n+\tCONSTANT_CLASS_P with calls to update_for_unsuitable_sm_exprs.\n+\tPass a tentative_region_model_context to the calls to\n+\tstate_change_event::get_lvalue and reject the comparison if errors\n+\toccur.\n+\t(diagnostic_manager::update_for_unsuitable_sm_exprs): New.\n+\t* diagnostic-manager.h\n+\t(diagnostic_manager::update_for_unsuitable_sm_exprs): New decl.\n+\t* region-model.h (class tentative_region_model_context): New class.\n+\n 2020-03-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* engine.cc (worklist::worklist): Remove unused field m_eg."}, {"sha": "2eead25f058b5bc2a69476dca9484911ba0e0117", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -201,9 +201,9 @@ class state_change_event : public checker_event\n \n   label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n \n-  region_id get_lvalue (tree expr) const\n+  region_id get_lvalue (tree expr, region_model_context *ctxt) const\n   {\n-    return m_dst_state.m_region_model->get_lvalue (expr, NULL);\n+    return m_dst_state.m_region_model->get_lvalue (expr, ctxt);\n   }\n \n   const supernode *m_node;"}, {"sha": "1b2c3ce68fa74221eb26a9241cb2aa82a2d5378b", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -574,9 +574,14 @@ get_any_origin (const gimple *stmt,\n   if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n     {\n       tree lhs = gimple_assign_lhs (assign);\n-      /* Use region IDs to compare lhs with DST_REP.  */\n-      if (dst_state.m_region_model->get_lvalue (lhs, NULL)\n-\t  == dst_state.m_region_model->get_lvalue (dst_rep, NULL))\n+      /* Use region IDs to compare lhs with DST_REP, bulletproofing against\n+\t cases where they can't have lvalues by using\n+\t tentative_region_model_context.  */\n+      tentative_region_model_context ctxt;\n+      region_id lhs_rid = dst_state.m_region_model->get_lvalue (lhs, &ctxt);\n+      region_id dst_rep_rid\n+\t= dst_state.m_region_model->get_lvalue (dst_rep, &ctxt);\n+      if (lhs_rid == dst_rep_rid && !ctxt.had_errors_p ())\n \t{\n \t  tree rhs1 = gimple_assign_rhs1 (assign);\n \t  enum tree_code op = gimple_assign_rhs_code (assign);\n@@ -1059,6 +1064,25 @@ diagnostic_manager::prune_path (checker_path *path,\n   path->maybe_log (get_logger (), \"pruned\");\n }\n \n+/* A cheap test to determine if EXPR can be the expression of interest in\n+   an sm-diagnostic, so that we can reject cases where we have a non-lvalue.\n+   We don't have always have a model when calling this, so we can't use\n+   tentative_region_model_context, so there can be false positives.  */\n+\n+static bool\n+can_be_expr_of_interest_p (tree expr)\n+{\n+  if (!expr)\n+    return false;\n+\n+  /* Reject constants.  */\n+  if (CONSTANT_CLASS_P (expr))\n+    return false;\n+\n+  /* Otherwise assume that it can be an lvalue.  */\n+  return true;\n+}\n+\n /* First pass of diagnostic_manager::prune_path: apply verbosity level,\n    pruning unrelated state change events.\n \n@@ -1081,11 +1105,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t\t\t\t     tree var,\n \t\t\t\t\t     state_machine::state_t state) const\n {\n-  /* If we have a constant (such as NULL), assume its state is also\n-     constant, so as not to attempt to get its lvalue whilst tracking the\n-     origin of the state.  */\n-  if (var && CONSTANT_CLASS_P (var))\n-    var = NULL_TREE;\n+  update_for_unsuitable_sm_exprs (&var);\n \n   int idx = path->num_events () - 1;\n   while (idx >= 0 && idx < (signed)path->num_events ())\n@@ -1105,7 +1125,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t  else\n \t    log (\"considering event %i\", idx);\n \t}\n-      gcc_assert (var == NULL || !CONSTANT_CLASS_P (var));\n+      gcc_assert (var == NULL || can_be_expr_of_interest_p (var));\n       switch (base_event->m_kind)\n \t{\n \tdefault:\n@@ -1157,19 +1177,21 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \tcase EK_STATE_CHANGE:\n \t  {\n \t    state_change_event *state_change = (state_change_event *)base_event;\n-\t    if (state_change->get_lvalue (state_change->m_var)\n-\t\t== state_change->get_lvalue (var))\n+\t    /* Use region IDs to compare var with the state_change's m_var,\n+\t       bulletproofing against cases where they can't have lvalues by\n+\t       using tentative_region_model_context.  */\n+\t    tentative_region_model_context ctxt;\n+\t    region_id state_var_rid\n+\t      = state_change->get_lvalue (state_change->m_var, &ctxt);\n+\t    region_id var_rid = state_change->get_lvalue (var, &ctxt);\n+\t    if (state_var_rid == var_rid && !ctxt.had_errors_p ())\n \t      {\n \t\tif (state_change->m_origin)\n \t\t  {\n \t\t    log (\"event %i: switching var of interest from %qE to %qE\",\n \t\t\t idx, var, state_change->m_origin);\n \t\t    var = state_change->m_origin;\n-\t\t    if (var && CONSTANT_CLASS_P (var))\n-\t\t      {\n-\t\t\tlog (\"new var is a constant; setting var to NULL\");\n-\t\t\tvar = NULL_TREE;\n-\t\t      }\n+\t\t    update_for_unsuitable_sm_exprs (&var);\n \t\t  }\n \t\tlog (\"event %i: switching state of interest from %qs to %qs\",\n \t\t     idx, sm->get_state_name (state_change->m_to),\n@@ -1185,6 +1207,8 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\telse\n \t\t  log (\"filtering event %i: state change to %qE\",\n \t\t       idx, state_change->m_var);\n+\t\tif (ctxt.had_errors_p ())\n+\t\t  log (\"context had errors\");\n \t\tpath->delete_event (idx);\n \t      }\n \t  }\n@@ -1218,12 +1242,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t      /* If we've chosen a bad exploded_path, then the\n \t\t\t phi arg might be a constant.  Fail gracefully for\n \t\t\t this case.  */\n-\t\t      if (CONSTANT_CLASS_P (var))\n-\t\t\t{\n-\t\t\t  log (\"new var is a constant (bad path?);\"\n-\t\t\t       \" setting var to NULL\");\n-\t\t\t  var = NULL;\n-\t\t\t}\n+\t\t      update_for_unsuitable_sm_exprs (&var);\n \t\t    }\n \t\t}\n \n@@ -1266,11 +1285,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\tvar = caller_var;\n \t\tif (expr.param_p ())\n \t\t  event->record_critical_state (var, state);\n-\t\tif (var && CONSTANT_CLASS_P (var))\n-\t\t  {\n-\t\t    log (\"new var is a constant; setting var to NULL\");\n-\t\t    var = NULL_TREE;\n-\t\t  }\n+\t\tupdate_for_unsuitable_sm_exprs (&var);\n \t      }\n \t  }\n \t  break;\n@@ -1296,11 +1311,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t    var = callee_var;\n \t\t    if (expr.return_value_p ())\n \t\t      event->record_critical_state (var, state);\n-\t\t    if (var && CONSTANT_CLASS_P (var))\n-\t\t      {\n-\t\t\tlog (\"new var is a constant; setting var to NULL\");\n-\t\t\tvar = NULL_TREE;\n-\t\t      }\n+\t\t    update_for_unsuitable_sm_exprs (&var);\n \t\t  }\n \t      }\n \t  }\n@@ -1321,6 +1332,21 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n     }\n }\n \n+/* Subroutine of diagnostic_manager::prune_for_sm_diagnostic.\n+   If *EXPR is not suitable to be the expression of interest in\n+   an sm-diagnostic, set *EXPR to NULL and log.  */\n+\n+void\n+diagnostic_manager::update_for_unsuitable_sm_exprs (tree *expr) const\n+{\n+  gcc_assert (expr);\n+  if (*expr && !can_be_expr_of_interest_p (*expr))\n+    {\n+      log (\"new var %qE is unsuitable; setting var to NULL\", *expr);\n+      *expr = NULL_TREE;\n+    }\n+}\n+\n /* Second pass of diagnostic_manager::prune_path: remove redundant\n    interprocedural information.\n "}, {"sha": "1c7bc7462afcc458fa51bd9c7bc399612ab10b0f", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -126,6 +126,7 @@ class diagnostic_manager : public log_user\n \t\t\t\tconst state_machine *sm,\n \t\t\t\ttree var,\n \t\t\t\tstate_machine::state_t state) const;\n+  void update_for_unsuitable_sm_exprs (tree *expr) const;\n   void prune_interproc_events (checker_path *path) const;\n   void finish_pruning (checker_path *path) const;\n "}, {"sha": "f3cf45566d1180db962dc6d2c1724fbebb492e07", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -1955,6 +1955,54 @@ class region_model_context\n \t\t\t\t\tconst dump_location_t &loc) = 0;\n };\n \n+/* A subclass of region_model_context for determining if operations fail\n+   e.g. \"can we generate a region for the lvalue of EXPR?\".  */\n+\n+class tentative_region_model_context : public region_model_context\n+{\n+public:\n+  tentative_region_model_context () : m_num_unexpected_codes (0) {}\n+\n+  void warn (pending_diagnostic *) FINAL OVERRIDE {}\n+  void remap_svalue_ids (const svalue_id_map &) FINAL OVERRIDE {}\n+  int on_svalue_purge (svalue_id, const svalue_id_map &) FINAL OVERRIDE\n+  {\n+    return 0;\n+  }\n+  logger *get_logger () FINAL OVERRIDE { return NULL; }\n+  void on_inherited_svalue (svalue_id parent_sid ATTRIBUTE_UNUSED,\n+\t\t\t    svalue_id child_sid  ATTRIBUTE_UNUSED)\n+    FINAL OVERRIDE\n+  {\n+  }\n+  void on_cast (svalue_id src_sid ATTRIBUTE_UNUSED,\n+\t\tsvalue_id dst_sid ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+  void on_condition (tree lhs ATTRIBUTE_UNUSED,\n+\t\t     enum tree_code op ATTRIBUTE_UNUSED,\n+\t\t     tree rhs ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+  void on_unknown_change (svalue_id sid ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+  void on_phi (const gphi *phi ATTRIBUTE_UNUSED,\n+\t       tree rhs ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+  void on_unexpected_tree_code (tree, const dump_location_t &)\n+    FINAL OVERRIDE\n+  {\n+    m_num_unexpected_codes++;\n+  }\n+\n+  bool had_errors_p () const { return m_num_unexpected_codes > 0; }\n+\n+private:\n+  int m_num_unexpected_codes;\n+};\n+\n /* A bundle of data for use when attempting to merge two region_model\n    instances to make a third.  */\n "}, {"sha": "d44d3c7cbe50a9b6897bd47929e48f63288868bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -1,3 +1,8 @@\n+2020-03-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/93993\n+\t* gfortran.dg/analyzer/pr93993.f90: New test.\n+\n 2020-03-04  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.target/i386/pr91623.c: Add -fcommon in order"}, {"sha": "8d5261c0eb904d882de952fdf1269cdf2c9e3667", "filename": "gcc/testsuite/gfortran.dg/analyzer/pr93993.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr93993.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d66e153b40ed000af30a9e569a05f34d5d576aa/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr93993.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr93993.f90?ref=3d66e153b40ed000af30a9e569a05f34d5d576aa", "patch": "@@ -0,0 +1,33 @@\n+module np\n+  implicit none\n+  integer, parameter :: za = selected_real_kind(15, 307)\n+end module np\n+\n+module gg\n+  use np\n+\n+  type et(real_kind)\n+    integer, kind :: real_kind\n+  end type et\n+\n+contains\n+\n+  function hv (tm) result(ce)\n+    type (et(real_kind=za)), allocatable, target :: tm\n+    type (et(real_kind=za)), pointer :: ce\n+\n+    allocate (tm) ! { dg-bogus \"dereference of possibly-NULL\" \"\" { xfail *-*-* } }\n+    ce => tm\n+  end function hv ! { dg-warning \"leak of 'tm'\" }\n+\n+end module gg\n+\n+program a5\n+  use np\n+  use gg\n+  implicit none\n+  type (et(real_kind=za)), allocatable :: qb\n+  type (et(real_kind=za)), pointer :: vt\n+\n+  vt => hv (qb)\n+end program a5"}]}