{"sha": "a5ac359a6d661735a213b7b6b8436e615e768788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVhYzM1OWE2ZDY2MTczNWEyMTNiN2I2Yjg0MzZlNjE1ZTc2ODc4OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-22T23:30:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-22T23:30:22Z"}, "message": "fold-const.c (force_fit_type): Handle OFFSET_TYPE.\n\n\t* fold-const.c (force_fit_type): Handle OFFSET_TYPE.\n\t* varasam.c (output_constant): Likewise.\n\n2003-07-22  Mark Mitchell  <mark@codesourcery.com>\n\n\tEliminate use of POINTER_TYPE for pointers-to-members.\n\t* call.c (standard_conversion): Rework pointer-to-member handling.\n\tAdd comments.\n\t(add_builtin_candidate): Likewise.\n\t(resolve_scoped_fn_name): Remove.\n\t(build_conditional_expr): Rework pointer-to-member handling.\n\t(compare_ics): Likewise.\n\t* class.c (check_field_decls): Use TYPE_PTR_P.\n\t* cp-lang.c (cp_var_mod_type_p): Rework pointer-to-member\n\thandling.\n\t* cp-tree.h (SCALAR_TYPE_P): Use TYPE_PTR_TO_MEMBER_P.\n\t(TYPE_PTRMEM_P): Add comment.\n\t(TYPE_PTR_P): Simplify.\n\t(TYPE_PTROB_P): Correct definition.\n\t(TYPE_PTR_TO_MEMBER_P): New macro.\n\t(TYPE_PTRMEM_CLASS_TYPE): Adjust.\n\t(TYPE_PTRMEM_POINTED_TO_TYPE): Likewise.\n\t(resolved_scoped_fn_name): Remove declaration.\n\t(build_offset_ref): Change prototype.\n\t(resolve_offset_ref): Remove.\n\t(comp_target_types): Remove.\n\t* cvt.c (cp_convert_to_pointer): Rework pointer-to-member\n\thandling.\n\t(convert_to_reference): Use can_convert.\n\t(ocp_convert): Improve error handling.  Rework pointer-to-member\n\thandling.\n\t(perform_qualification_conversions): Rework pointer-to-member\n\thandling.\n\t* decl.c (build_ptrmem_type): Handle functions too.\n\t(create_array_type_for_decl): Remove OFFSET_TYPE error message.\n\t(grokdeclarator): Use OFFSET_TYPE for pointers to data members.\n\t(grokparms): Remove OFFSET_TYPE error message.\n\t* dump.c (cp_dump_tree): Rework pointer-to-member handling.\n\t* error.c (dump_type_prefix): Likewise.\n\t* expr.c (cplus_expand_constant): Use build_nop.\n\t* init.c (build_offset_ref): Add address_p parameter.  Fold in\n\tnecessary bits from resolve_offset_ref.\n\t(resolve_offset_ref): Remove.\n\t* parser.c (cp_parser_postfix_expression): Remove special case\n\tcode for OFFSET_TYPE.\n\t* pt.c (convert_nontype_argument): Rework pointer-to-member\n\thandling.\n\t(convert_template_argument): Likewise.\n\t(unify): Likewise.\n\t(invalid_nontype_parm_type_p): Likewise.\n\t(dependent_type_p_r): Likewise.\n\t* rtti.c (get_tinfo_decl): Remove OFFSET_TYPE special case.\n\t(target_incomplete_p_): Rework pointer-to-member\n\thandling.\n\t(get_pseudo_ti_init): Likewise.\n\t(get_pseudo_ti_desc): Likewise.\n\t* semantics.c (finish_qualified_id_expr): Adjust call to\n\tbuild_offset_ref.  Remove use of resolve_offset_ref.\n\t* tree.c (pod_type_p): Use TYPE_PTR_TO_MEMBER_P.\n\t* typeck.c (target_type): Use TYPE_PTRMEM_P.\n\t(type_unknown_p): Remove obsolete code about the time before\n\tnon-dependent expressions were handled correctly.\n\t(qualify_type_recursive): Remove.\n\t(composite_pointer_type_r): New function.\n\t(composite_pointer_type): Use it.\n\t(merge_types): Remove dead comments.\n\t(comp_cv_target_types): Remove.\n\t(comp_target_types): Likewise.\n\t(comp_target_parms): Likewise.\n\t(cxx_sizeof_or_alignof_type): Remove OFFSET_TYPE error.\n\t(build_indirect_ref): Use TYPE_PTR_TO_MEMBER_P.\n\t(build_binary_op): Do not use of comp_target_types.\n\t(pointer_diff): Remove OFFSET_TYPE case.\n\t(build_unary_op): Adjust pointer-to-member handling.\n\t(unary_complex_lvalue): Likewise.\n\t(check_for_casting_away_constness): Add description parameter.\n\t(build_static_cast): Pass it.\n\t(build_reinterpret_cast): Use check_for_casting_away_constness.\n\t(build_const_cast): Adjust pointer-to-member handling.\n\t(build_c_cast): Likewise.\n\t(convert_for_assignment): Remove OFFSET_TYPE error message.\n\t(comp_ptr_ttypes_real): Adjust pointer-to-member handling.\n\t(comp_ptr_ttypes_reinterpret): Remove.\n\t(casts_away_constness_r): Adjust pointer-to-member handling.\n\t(casts_away_constness): Liekwise.\n\t(strip_all_pointer_quals): Remove.\n\t* typeck2.c (digest_init): Adjust pointer-to-member handling.\n\t(build_m_component_ref): Likewise.\n\nFrom-SVN: r69691", "tree": {"sha": "74afcc9943903e84e906ee02eba4d464f77fe58b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74afcc9943903e84e906ee02eba4d464f77fe58b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5ac359a6d661735a213b7b6b8436e615e768788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ac359a6d661735a213b7b6b8436e615e768788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5ac359a6d661735a213b7b6b8436e615e768788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ac359a6d661735a213b7b6b8436e615e768788/comments", "author": null, "committer": null, "parents": [{"sha": "938d968ed373057812cd43a9b420399fb65f6c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938d968ed373057812cd43a9b420399fb65f6c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/938d968ed373057812cd43a9b420399fb65f6c0b"}], "stats": {"total": 1563, "additions": 614, "deletions": 949}, "files": [{"sha": "74f3eea3844a0b7ff634f8641112e5683df84603", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -1,3 +1,8 @@\n+2003-07-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* fold-const.c (force_fit_type): Handle OFFSET_TYPE.\n+\t* varasam.c (output_constant): Likewise.\n+\n 2003-07-22  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* alias.c: Fix comment formatting."}, {"sha": "982799147532ac0dbf2019fe6cde2843c724e452", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -1,3 +1,89 @@\n+2003-07-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tEliminate use of POINTER_TYPE for pointers-to-members.\n+\t* call.c (standard_conversion): Rework pointer-to-member handling.\n+\tAdd comments.\n+\t(add_builtin_candidate): Likewise.\n+\t(resolve_scoped_fn_name): Remove.\n+\t(build_conditional_expr): Rework pointer-to-member handling.\n+\t(compare_ics): Likewise.\n+\t* class.c (check_field_decls): Use TYPE_PTR_P.\n+\t* cp-lang.c (cp_var_mod_type_p): Rework pointer-to-member\n+\thandling.\n+\t* cp-tree.h (SCALAR_TYPE_P): Use TYPE_PTR_TO_MEMBER_P.\n+\t(TYPE_PTRMEM_P): Add comment.\n+\t(TYPE_PTR_P): Simplify.\n+\t(TYPE_PTROB_P): Correct definition.\n+\t(TYPE_PTR_TO_MEMBER_P): New macro.\n+\t(TYPE_PTRMEM_CLASS_TYPE): Adjust.\n+\t(TYPE_PTRMEM_POINTED_TO_TYPE): Likewise.\n+\t(resolved_scoped_fn_name): Remove declaration.\n+\t(build_offset_ref): Change prototype.\n+\t(resolve_offset_ref): Remove.\n+\t(comp_target_types): Remove.\n+\t* cvt.c (cp_convert_to_pointer): Rework pointer-to-member\n+\thandling.\n+\t(convert_to_reference): Use can_convert.\n+\t(ocp_convert): Improve error handling.  Rework pointer-to-member\n+\thandling.\n+\t(perform_qualification_conversions): Rework pointer-to-member\n+\thandling.\n+\t* decl.c (build_ptrmem_type): Handle functions too.\n+\t(create_array_type_for_decl): Remove OFFSET_TYPE error message.\n+\t(grokdeclarator): Use OFFSET_TYPE for pointers to data members.\n+\t(grokparms): Remove OFFSET_TYPE error message.\n+\t* dump.c (cp_dump_tree): Rework pointer-to-member handling.\n+\t* error.c (dump_type_prefix): Likewise.\n+\t* expr.c (cplus_expand_constant): Use build_nop.\n+\t* init.c (build_offset_ref): Add address_p parameter.  Fold in\n+\tnecessary bits from resolve_offset_ref.\n+\t(resolve_offset_ref): Remove.\n+\t* parser.c (cp_parser_postfix_expression): Remove special case\n+\tcode for OFFSET_TYPE.\n+\t* pt.c (convert_nontype_argument): Rework pointer-to-member\n+\thandling.\n+\t(convert_template_argument): Likewise.\n+\t(unify): Likewise.\n+\t(invalid_nontype_parm_type_p): Likewise.\n+\t(dependent_type_p_r): Likewise.\n+\t* rtti.c (get_tinfo_decl): Remove OFFSET_TYPE special case.\n+\t(target_incomplete_p_): Rework pointer-to-member\n+\thandling.\n+\t(get_pseudo_ti_init): Likewise.\n+\t(get_pseudo_ti_desc): Likewise.\n+\t* semantics.c (finish_qualified_id_expr): Adjust call to\n+\tbuild_offset_ref.  Remove use of resolve_offset_ref.\n+\t* tree.c (pod_type_p): Use TYPE_PTR_TO_MEMBER_P.\n+\t* typeck.c (target_type): Use TYPE_PTRMEM_P.\n+\t(type_unknown_p): Remove obsolete code about the time before\n+\tnon-dependent expressions were handled correctly.\n+\t(qualify_type_recursive): Remove.\n+\t(composite_pointer_type_r): New function.\n+\t(composite_pointer_type): Use it.\n+\t(merge_types): Remove dead comments.\n+\t(comp_cv_target_types): Remove.\n+\t(comp_target_types): Likewise.\n+\t(comp_target_parms): Likewise.\n+\t(cxx_sizeof_or_alignof_type): Remove OFFSET_TYPE error.\n+\t(build_indirect_ref): Use TYPE_PTR_TO_MEMBER_P.\n+\t(build_binary_op): Do not use of comp_target_types.\n+\t(pointer_diff): Remove OFFSET_TYPE case.\n+\t(build_unary_op): Adjust pointer-to-member handling.\n+\t(unary_complex_lvalue): Likewise.\n+\t(check_for_casting_away_constness): Add description parameter.\n+\t(build_static_cast): Pass it.\n+\t(build_reinterpret_cast): Use check_for_casting_away_constness.\n+\t(build_const_cast): Adjust pointer-to-member handling.\n+\t(build_c_cast): Likewise.\n+\t(convert_for_assignment): Remove OFFSET_TYPE error message.\n+\t(comp_ptr_ttypes_real): Adjust pointer-to-member handling.\n+\t(comp_ptr_ttypes_reinterpret): Remove.\n+\t(casts_away_constness_r): Adjust pointer-to-member handling.\n+\t(casts_away_constness): Liekwise.\n+\t(strip_all_pointer_quals): Remove.\n+\t* typeck2.c (digest_init): Adjust pointer-to-member handling.\n+\t(build_m_component_ref): Likewise.\n+\t\n 2003-07-22  Wolfgang Bangerth  <bangerth@dealii.org>\n \n \t* lex.c (unqualified_fn_lookup_error): Mention that the error"}, {"sha": "cbfc5c389d4f76971d5d7bc4c343efb4d489b9e7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 73, "deletions": 139, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -642,11 +642,9 @@ standard_conversion (tree to, tree from, tree expr)\n   if (same_type_p (from, to))\n     return conv;\n \n-  if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n+  if ((tcode == POINTER_TYPE || TYPE_PTR_TO_MEMBER_P (to))\n       && expr && null_ptr_cst_p (expr))\n-    {\n-      conv = build_conv (STD_CONV, to, conv);\n-    }\n+    conv = build_conv (STD_CONV, to, conv);\n   else if ((tcode == INTEGER_TYPE && fcode == POINTER_TYPE)\n \t   || (tcode == POINTER_TYPE && fcode == INTEGER_TYPE))\n     {\n@@ -663,33 +661,37 @@ standard_conversion (tree to, tree from, tree expr)\n       conv = build_conv (STD_CONV, to, conv);\n       ICS_BAD_FLAG (conv) = 1;\n     }\n-  else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n+  else if ((tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n+\t   || (TYPE_PTRMEM_P (to) && TYPE_PTRMEM_P (from)))\n     {\n-      enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n-      enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n+      tree to_pointee;\n+      tree from_pointee;\n \n-      if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (from),\n-\t\t\t\t\t\t     TREE_TYPE (to)))\n+      if (tcode == POINTER_TYPE\n+\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (from),\n+\t\t\t\t\t\t\tTREE_TYPE (to)))\n \t;\n-      else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n-\t       && ufcode != FUNCTION_TYPE)\n+      else if (VOID_TYPE_P (TREE_TYPE (to))\n+\t       && !TYPE_PTRMEM_P (from)\n+\t       && TREE_CODE (TREE_TYPE (from)) != FUNCTION_TYPE)\n \t{\n \t  from = build_pointer_type\n \t    (cp_build_qualified_type (void_type_node, \n \t\t\t\t      cp_type_quals (TREE_TYPE (from))));\n \t  conv = build_conv (PTR_CONV, from, conv);\n \t}\n-      else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n+      else if (TYPE_PTRMEM_P (from))\n \t{\n-\t  tree fbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (from));\n-\t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n+\t  tree fbase = TYPE_PTRMEM_CLASS_TYPE (from);\n+\t  tree tbase = TYPE_PTRMEM_CLASS_TYPE (to);\n \n \t  if (DERIVED_FROM_P (fbase, tbase)\n \t      && (same_type_ignoring_top_level_qualifiers_p\n-\t\t  (TREE_TYPE (TREE_TYPE (from)),\n-\t\t   TREE_TYPE (TREE_TYPE (to)))))\n+\t\t  (TYPE_PTRMEM_POINTED_TO_TYPE (from),\n+\t\t   TYPE_PTRMEM_POINTED_TO_TYPE (to))))\n \t    {\n-\t      from = build_ptrmem_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n+\t      from = build_ptrmem_type (tbase, \n+\t\t\t\t\tTYPE_PTRMEM_POINTED_TO_TYPE (from));\n \t      conv = build_conv (PMEM_CONV, from, conv);\n \t    }\n \t}\n@@ -706,14 +708,25 @@ standard_conversion (tree to, tree from, tree expr)\n \t    }\n \t}\n \n+      if (tcode == POINTER_TYPE)\n+\t{\n+\t  to_pointee = TREE_TYPE (to);\n+\t  from_pointee = TREE_TYPE (from);\n+\t}\n+      else\n+\t{\n+\t  to_pointee = to;\n+\t  from_pointee = from;\n+\t}\n+\n       if (same_type_p (from, to))\n \t/* OK */;\n-      else if (comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n+      else if (comp_ptr_ttypes (to_pointee, from_pointee))\n \tconv = build_conv (QUAL_CONV, to, conv);\n       else if (expr && string_conv_p (to, expr, 0))\n \t/* converting from string constant to char *.  */\n \tconv = build_conv (QUAL_CONV, to, conv);\n-      else if (ptr_reasonably_similar (TREE_TYPE (to), TREE_TYPE (from)))\n+      else if (ptr_reasonably_similar (to_pointee, from_pointee))\n \t{\n \t  conv = build_conv (PTR_CONV, to, conv);\n \t  ICS_BAD_FLAG (conv) = 1;\n@@ -745,14 +758,25 @@ standard_conversion (tree to, tree from, tree expr)\n     }\n   else if (tcode == BOOLEAN_TYPE)\n     {\n-      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE\n-\t     || fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)))\n-\treturn 0;\n+      /* [conv.bool]\n \n-      conv = build_conv (STD_CONV, to, conv);\n-      if (fcode == POINTER_TYPE\n-\t  || (TYPE_PTRMEMFUNC_P (from) && ICS_STD_RANK (conv) < PBOOL_RANK))\n-\tICS_STD_RANK (conv) = PBOOL_RANK;\n+          An rvalue of arithmetic, enumeration, pointer, or pointer to\n+\t  member type can be converted to an rvalue of type bool.  */\n+      if (ARITHMETIC_TYPE_P (from)\n+\t  || fcode == ENUMERAL_TYPE\n+\t  || fcode == POINTER_TYPE\n+\t  || TYPE_PTR_TO_MEMBER_P (from))\n+\t{\n+\t  conv = build_conv (STD_CONV, to, conv);\n+\t  if (fcode == POINTER_TYPE\n+\t      || TYPE_PTRMEM_P (from)\n+\t      || (TYPE_PTRMEMFUNC_P (from) \n+\t\t  && ICS_STD_RANK (conv) < PBOOL_RANK))\n+\t    ICS_STD_RANK (conv) = PBOOL_RANK;\n+\t  return conv;\n+\t}\n+      \n+      return NULL_TREE;\n     }\n   /* We don't check for ENUMERAL_TYPE here because there are no standard\n      conversions to enum type.  */\n@@ -1592,8 +1616,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     T       operator-(T);  */\n \n     case CONVERT_EXPR: /* unary + */\n-      if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type1)) != OFFSET_TYPE)\n+      if (TREE_CODE (type1) == POINTER_TYPE)\n \tbreak;\n     case NEGATE_EXPR:\n       if (ARITHMETIC_TYPE_P (type1))\n@@ -1618,12 +1641,10 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \n     case MEMBER_REF:\n       if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && (TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2)))\n+\t  && TYPE_PTR_TO_MEMBER_P (type2))\n \t{\n \t  tree c1 = TREE_TYPE (type1);\n-\t  tree c2 = (TYPE_PTRMEMFUNC_P (type2)\n-\t\t     ? TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (type2)))\n-\t\t     : TYPE_OFFSET_BASETYPE (TREE_TYPE (type2)));\n+\t  tree c2 = TYPE_PTRMEM_CLASS_TYPE (type2);\n \n \t  if (IS_AGGR_TYPE (c1) && DERIVED_FROM_P (c2, c1)\n \t      && (TYPE_PTRMEMFUNC_P (type2)\n@@ -1693,14 +1714,12 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n \t  || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2)))\n \tbreak;\n-      if ((TYPE_PTRMEMFUNC_P (type1) || TYPE_PTRMEM_P (type1))\n-\t  && null_ptr_cst_p (args[1]))\n+      if (TYPE_PTR_TO_MEMBER_P (type1) && null_ptr_cst_p (args[1]))\n \t{\n \t  type2 = type1;\n \t  break;\n \t}\n-      if ((TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2))\n-\t  && null_ptr_cst_p (args[0]))\n+      if (TYPE_PTR_TO_MEMBER_P (type2) && null_ptr_cst_p (args[0]))\n \t{\n \t  type1 = type2;\n \t  break;\n@@ -1871,12 +1890,8 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \tbreak;\n \n       /* Otherwise, the types should be pointers.  */\n-      if (!(TREE_CODE (type1) == POINTER_TYPE\n-\t    || TYPE_PTRMEM_P (type1)\n-\t    || TYPE_PTRMEMFUNC_P (type1))\n-\t  || !(TREE_CODE (type2) == POINTER_TYPE\n-\t       || TYPE_PTRMEM_P (type2)\n-\t       || TYPE_PTRMEMFUNC_P (type2)))\n+      if (!(TYPE_PTR_P (type1) || TYPE_PTR_TO_MEMBER_P (type1))\n+\t  || !(TYPE_PTR_P (type2) || TYPE_PTR_TO_MEMBER_P (type2)))\n \treturn;\n       \n       /* We don't check that the two types are the same; the logic\n@@ -1894,8 +1909,8 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n   if (type2 && !same_type_p (type1, type2)\n       && TREE_CODE (type1) == TREE_CODE (type2)\n       && (TREE_CODE (type1) == REFERENCE_TYPE\n-\t  || (TREE_CODE (type1) == POINTER_TYPE\n-\t      && TYPE_PTRMEM_P (type1) == TYPE_PTRMEM_P (type2))\n+\t  || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+\t  || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n \t  || TYPE_PTRMEMFUNC_P (type1)\n \t  || IS_AGGR_TYPE (type1)\n \t  || TREE_CODE (type1) == ENUMERAL_TYPE))\n@@ -2605,76 +2620,6 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n   return NULL_TREE;\n }\n \n-/* Find the possibly overloaded set of functions corresponding to a\n-   call of the form SCOPE::NAME (...). NAME might be a\n-   TEMPLATE_ID_EXPR, OVERLOAD, _DECL, or IDENTIFIER_NODE.  */\n-\n-tree\n-resolve_scoped_fn_name (tree scope, tree name)\n-{\n-  tree fn = NULL_TREE;\n-  tree template_args = NULL_TREE;\n-  bool is_template_id = TREE_CODE (name) == TEMPLATE_ID_EXPR;\n-  \n-  if (is_template_id)\n-    {\n-      template_args = TREE_OPERAND (name, 1);\n-      name = TREE_OPERAND (name, 0);\n-    }\n-  if (TREE_CODE (name) == OVERLOAD)\n-    name = DECL_NAME (get_first_fn (name));\n-  \n-  if (TREE_CODE (scope) == NAMESPACE_DECL)\n-    fn = lookup_namespace_name (scope, name);\n-  else if (!CLASS_TYPE_P (scope))\n-    {\n-      error (\"`%T' is not a class type\", scope);\n-      return error_mark_node;\n-    }\n-  else\n-    {\n-      if (!TYPE_BEING_DEFINED (scope)\n-\t  && !COMPLETE_TYPE_P (complete_type (scope)))\n-\t{\n-\t  error (\"incomplete type '%T' cannot be used to name a scope\",\n-\t\t scope);\n-\t  return error_mark_node;\n-\t}\n-      \n-      if (BASELINK_P (name))\n-\tfn = name;\n-      else\n-\tfn = lookup_member (scope, name, /*protect=*/1, /*want_type=*/false);\n-      if (fn && current_class_type)\n-\tfn = (adjust_result_of_qualified_name_lookup \n-\t      (fn, scope, current_class_type));\n-\n-      /* It might be the name of a function pointer member.  */\n-      if (fn && TREE_CODE (fn) == FIELD_DECL)\n-\tfn = finish_non_static_data_member (fn, current_class_ref, scope);\n-    }\n-  \n-  if (!fn)\n-    {\n-      error (\"'%D' has no member named '%E'\", scope, name);\n-      return error_mark_node;\n-    }\n-  if (is_template_id)\n-    {\n-      tree fns = fn;\n-\n-      if (BASELINK_P (fn))\n-\tfns = BASELINK_FUNCTIONS (fns);\n-      fns = build_nt (TEMPLATE_ID_EXPR, fns, template_args);\n-      if (BASELINK_P (fn))\n-\tBASELINK_FUNCTIONS (fn) = fns;\n-      else\n-\tfn = fns;\n-    }\n-  \n-  return fn;\n-}\n-\n /* Do any initial processing on the arguments to a function call.  */\n \n static tree\n@@ -3379,15 +3324,12 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n        cv-qualification of either the second or the third operand.\n        The result is of the common type.  */\n   else if ((null_ptr_cst_p (arg2) \n-\t    && (TYPE_PTR_P (arg3_type) || TYPE_PTRMEM_P (arg3_type)\n-\t\t|| TYPE_PTRMEMFUNC_P (arg3_type)))\n+\t    && (TYPE_PTR_P (arg3_type) || TYPE_PTR_TO_MEMBER_P (arg3_type)))\n \t   || (null_ptr_cst_p (arg3) \n-\t       && (TYPE_PTR_P (arg2_type) || TYPE_PTRMEM_P (arg2_type)\n-\t\t|| TYPE_PTRMEMFUNC_P (arg2_type)))\n+\t       && (TYPE_PTR_P (arg2_type) || TYPE_PTR_TO_MEMBER_P (arg2_type)))\n \t   || (TYPE_PTR_P (arg2_type) && TYPE_PTR_P (arg3_type))\n \t   || (TYPE_PTRMEM_P (arg2_type) && TYPE_PTRMEM_P (arg3_type))\n-\t   || (TYPE_PTRMEMFUNC_P (arg2_type) \n-\t       && TYPE_PTRMEMFUNC_P (arg3_type)))\n+\t   || (TYPE_PTRMEMFUNC_P (arg2_type) && TYPE_PTRMEMFUNC_P (arg3_type)))\n     {\n       result_type = composite_pointer_type (arg2_type, arg3_type, arg2,\n \t\t\t\t\t    arg3, \"conditional expression\");\n@@ -5401,25 +5343,17 @@ compare_ics (tree ics1, tree ics2)\n      for pointers A*, except opposite: if B is derived from A then\n      A::* converts to B::*, not vice versa.  For that reason, we\n      switch the from_ and to_ variables here.  */\n-  else if (TYPE_PTRMEM_P (from_type1)\n-\t   && TYPE_PTRMEM_P (from_type2)\n-\t   && TYPE_PTRMEM_P (to_type1)\n-\t   && TYPE_PTRMEM_P (to_type2))\n-    {\n-      deref_to_type1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (from_type1));\n-      deref_to_type2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (from_type2));\n-      deref_from_type1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (to_type1));\n-      deref_from_type2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (to_type2));\n-    }\n-  else if (TYPE_PTRMEMFUNC_P (from_type1)\n-\t   && TYPE_PTRMEMFUNC_P (from_type2)\n-\t   && TYPE_PTRMEMFUNC_P (to_type1)\n-\t   && TYPE_PTRMEMFUNC_P (to_type2))\n-    {\n-      deref_to_type1 = TYPE_PTRMEMFUNC_OBJECT_TYPE (from_type1);\n-      deref_to_type2 = TYPE_PTRMEMFUNC_OBJECT_TYPE (from_type2);\n-      deref_from_type1 = TYPE_PTRMEMFUNC_OBJECT_TYPE (to_type1);\n-      deref_from_type2 = TYPE_PTRMEMFUNC_OBJECT_TYPE (to_type2);\n+  else if ((TYPE_PTRMEM_P (from_type1) && TYPE_PTRMEM_P (from_type2)\n+\t    && TYPE_PTRMEM_P (to_type1) && TYPE_PTRMEM_P (to_type2))\n+\t   || (TYPE_PTRMEMFUNC_P (from_type1)\n+\t       && TYPE_PTRMEMFUNC_P (from_type2)\n+\t       && TYPE_PTRMEMFUNC_P (to_type1)\n+\t       && TYPE_PTRMEMFUNC_P (to_type2)))\n+    {\n+      deref_to_type1 = TYPE_PTRMEM_CLASS_TYPE (from_type1);\n+      deref_to_type2 = TYPE_PTRMEM_CLASS_TYPE (from_type2);\n+      deref_from_type1 = TYPE_PTRMEM_CLASS_TYPE (to_type1);\n+      deref_from_type2 = TYPE_PTRMEM_CLASS_TYPE (to_type2);\n     }\n \n   if (deref_from_type1 != NULL_TREE"}, {"sha": "4c46d1c9c66aceb70f3fbe0b1bd3b4a145cce1ae", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -3078,7 +3078,7 @@ check_field_decls (tree t, tree *access_decls,\n \n       type = strip_array_types (type);\n       \n-      if (TREE_CODE (type) == POINTER_TYPE)\n+      if (TYPE_PTR_P (type))\n \thas_pointers = 1;\n \n       if (DECL_MUTABLE_P (x) || TYPE_HAS_MUTABLE_P (type))"}, {"sha": "adf670596d4510c26e5ac5ff6bc957f26b59eb55", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -364,7 +364,7 @@ cp_var_mod_type_p (tree type)\n {\n   /* If TYPE is a pointer-to-member, it is variably modified if either\n      the class or the member are variably modified.  */\n-  if (TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n+  if (TYPE_PTR_TO_MEMBER_P (type))\n     return (variably_modified_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n \t    || variably_modified_type_p (TYPE_PTRMEM_POINTED_TO_TYPE (type)));\n "}, {"sha": "b46675272871fb63ece42f9345a4e205997f79a2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -2421,8 +2421,7 @@ struct lang_decl GTY(())\n   (ARITHMETIC_TYPE_P (TYPE)\t\t\t\\\n    || TREE_CODE (TYPE) == ENUMERAL_TYPE\t\t\\\n    || TYPE_PTR_P (TYPE)\t\t\t\t\\\n-   || TYPE_PTRMEM_P (TYPE)\t\t\t\\\n-   || TYPE_PTRMEMFUNC_P (TYPE))\n+   || TYPE_PTR_TO_MEMBER_P (TYPE))\n \n /* [dcl.init.aggr]\n \n@@ -2508,14 +2507,15 @@ struct lang_decl GTY(())\n #define TYPE_HAS_TRIVIAL_ASSIGN_REF(NODE) \\\n   (TYPE_HAS_ASSIGN_REF (NODE) && ! TYPE_HAS_COMPLEX_ASSIGN_REF (NODE))\n \n-#define TYPE_PTRMEM_P(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) == OFFSET_TYPE)\n-#define TYPE_PTR_P(NODE)\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != OFFSET_TYPE)\n-#define TYPE_PTROB_P(NODE)\t\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n+/* Returns true if NODE is a pointer-to-data-member.  */\n+#define TYPE_PTRMEM_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == OFFSET_TYPE)\n+#define TYPE_PTR_P(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE)\n+#define TYPE_PTROB_P(NODE)\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) \t\t\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != METHOD_TYPE\t\\\n    && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n #define TYPE_PTROBV_P(NODE)\t\t\t\t\t\t\\\n   (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE)\n@@ -2536,6 +2536,10 @@ struct lang_decl GTY(())\n #define TYPE_PTRMEMFUNC_FLAG(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->ptrmemfunc_flag)\n \n+/* Returns true if NODE is a pointer-to-member.  */\n+#define TYPE_PTR_TO_MEMBER_P(NODE) \\\n+  (TYPE_PTRMEM_P (NODE) || TYPE_PTRMEMFUNC_P (NODE))\n+\n /* Indicates when overload resolution may resolve to a pointer to\n    member function. [expr.unary.op]/3 */\n #define PTRMEM_OK_P(NODE) TREE_LANG_FLAG_0 (NODE)\n@@ -2574,13 +2578,13 @@ struct lang_decl GTY(())\n    type `const X*'.  */\n #define TYPE_PTRMEM_CLASS_TYPE(NODE)\t\t\t\\\n   (TYPE_PTRMEM_P (NODE)\t\t\t\t\t\\\n-   ? TYPE_OFFSET_BASETYPE (TREE_TYPE (NODE))\t\t\\\n+   ? TYPE_OFFSET_BASETYPE (NODE)\t\t\\\n    : TYPE_PTRMEMFUNC_OBJECT_TYPE (NODE))\n \n /* For a pointer-to-member type of the form `T X::*', this is `T'.  */\n #define TYPE_PTRMEM_POINTED_TO_TYPE(NODE)\t\t\\\n    (TYPE_PTRMEM_P (NODE)\t\t\t\t\\\n-    ? TREE_TYPE (TREE_TYPE (NODE))\t\t\t\\\n+    ? TREE_TYPE (NODE)\t\t\t\t\t\\\n     : TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (NODE)))\n \n /* For a pointer-to-member constant `X::Y' this is the RECORD_TYPE for\n@@ -3527,7 +3531,6 @@ extern tree build_method_call (tree, tree, tree, tree, int);\n extern bool null_ptr_cst_p (tree);\n extern bool sufficient_parms_p (tree);\n extern tree type_decays_to (tree);\n-extern tree resolve_scoped_fn_name (tree, tree);\n extern tree build_user_type_conversion (tree, tree, int);\n extern tree build_new_function_call (tree, tree);\n extern tree build_operator_new_call (tree, tree, tree *, tree *);\n@@ -3876,8 +3879,7 @@ extern int is_aggr_type\t\t\t\t(tree, int);\n extern tree get_aggr_from_typedef\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init       \t\t(tree, tree, bool);\n-extern tree build_offset_ref\t\t\t(tree, tree);\n-extern tree resolve_offset_ref\t\t\t(tree);\n+extern tree build_offset_ref\t\t\t(tree, tree, bool);\n extern tree build_new\t\t\t\t(tree, tree, tree, int);\n extern tree build_vec_init\t\t\t(tree, tree, tree, int);\n extern tree build_x_delete\t\t\t(tree, int, tree);\n@@ -4272,7 +4274,6 @@ extern tree commonparms\t\t\t\t(tree, tree);\n extern tree original_type\t\t\t(tree);\n extern bool comp_except_specs\t\t\t(tree, tree, bool);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n-extern int comp_target_types\t\t\t(tree, tree, int);\n extern bool compparms\t\t\t\t(tree, tree);\n extern int comp_cv_qualification                (tree, tree);\n extern int comp_cv_qual_signature               (tree, tree);"}, {"sha": "2cdf39535349221ecd2c2e8a4a8400d4afe3c755", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 68, "deletions": 70, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -180,55 +180,57 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t    }\n \t}\n \n-      if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+      if (TYPE_PTRMEMFUNC_P (type))\n \t{\n-\t  tree b1; \n-\t  tree b2;\n-\t  tree binfo;\n-\t  enum tree_code code = PLUS_EXPR;\n-\t  base_kind bk;\n+\t  error (\"cannot convert `%E' from type `%T' to type `%T'\",\n+\t\t    expr, intype, type);\n+\t  return error_mark_node;\n+\t}\n \n-\t  b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n-\t  b2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (intype));\n-\t  binfo = lookup_base (b1, b2, ba_check, &bk);\n-\t  if (!binfo)\n-\t    {\n-\t      binfo = lookup_base (b2, b1, ba_check, &bk);\n-\t      code = MINUS_EXPR;\n-\t    }\n-\t  if (binfo == error_mark_node)\n-\t    return error_mark_node;\n+      return build_nop (type, expr);\n+    }\n+  else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+    {\n+      tree b1; \n+      tree b2;\n+      tree binfo;\n+      enum tree_code code = PLUS_EXPR;\n+      base_kind bk;\n+\n+      b1 = TYPE_PTRMEM_CLASS_TYPE (type);\n+      b2 = TYPE_PTRMEM_CLASS_TYPE (intype);\n+      binfo = lookup_base (b1, b2, ba_check, &bk);\n+      if (!binfo)\n+\t{\n+\t  binfo = lookup_base (b2, b1, ba_check, &bk);\n+\t  code = MINUS_EXPR;\n+\t}\n+      if (binfo == error_mark_node)\n+\treturn error_mark_node;\n \n-          if (bk == bk_via_virtual)\n+      if (bk == bk_via_virtual)\n+\t{\n+\t  if (force)\n+\t    warning (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n+\t\t     intype, type);\n+\t  else\n \t    {\n-\t      if (force)\n-\t        warning (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n-\t                    TREE_TYPE (intype), TREE_TYPE (type));\n-              else\n-                {\n-\t\t  error (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n-\t\t\t    TREE_TYPE (intype), TREE_TYPE (type));\n-\t          return error_mark_node;\n-\t        }\n-\t      /* This is a reinterpret cast, whose result is unspecified.\n-\t         We choose to do nothing.  */\n-\t      return build1 (NOP_EXPR, type, expr);\n+\t      error (\"pointer to member cast from `%T' to `%T' is via virtual base\",\n+\t\t     intype, type);\n+\t      return error_mark_node;\n \t    }\n-\t      \n-\t  if (TREE_CODE (expr) == PTRMEM_CST)\n-\t    expr = cplus_expand_constant (expr);\n-\n-\t  if (binfo)\n-\t    expr = size_binop (code, convert (sizetype, expr),\n-\t\t\t       BINFO_OFFSET (binfo));\n-\t}\n-      else if (TYPE_PTRMEMFUNC_P (type))\n-\t{\n-\t  error (\"cannot convert `%E' from type `%T' to type `%T'\",\n-\t\t    expr, intype, type);\n-\t  return error_mark_node;\n+\t  /* This is a reinterpret cast, whose result is unspecified.\n+\t     We choose to do nothing.  */\n+\t  return build1 (NOP_EXPR, type, expr);\n \t}\n \n+      if (TREE_CODE (expr) == PTRMEM_CST)\n+\texpr = cplus_expand_constant (expr);\n+\n+      if (binfo && !integer_zerop (BINFO_OFFSET (binfo)))\n+\texpr = size_binop (code, \n+\t\t\t   build_nop (sizetype, expr),\n+\t\t\t   BINFO_OFFSET (binfo));\n       return build_nop (type, expr);\n     }\n   else if (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype))\n@@ -253,8 +255,6 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       return error_mark_node;\n     }\n \n-  my_friendly_assert (form != OFFSET_TYPE, 186);\n-\n   if (integer_zerop (expr))\n     {\n       if (TYPE_PTRMEMFUNC_P (type))\n@@ -271,8 +271,7 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       force_fit_type (expr, 0);\n       return expr;\n     }\n-  else if ((TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n-\t   && INTEGRAL_CODE_P (form))\n+  else if (TYPE_PTR_TO_MEMBER_P (type) && INTEGRAL_CODE_P (form))\n     {\n       error (\"invalid conversion from '%T' to '%T'\", intype, type);\n       return error_mark_node;\n@@ -454,7 +453,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   register tree intype;\n   tree rval = NULL_TREE;\n   tree rval_as_conversion = NULL_TREE;\n-  int i;\n+  bool can_convert_intype_to_type;\n \n   if (TREE_CODE (type) == FUNCTION_TYPE \n       && TREE_TYPE (expr) == unknown_type_node)\n@@ -473,9 +472,9 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n   intype = TYPE_MAIN_VARIANT (intype);\n \n-  i = comp_target_types (type, intype, 0);\n-\n-  if (i <= 0 && (convtype & CONV_IMPLICIT) && IS_AGGR_TYPE (intype)\n+  can_convert_intype_to_type = can_convert (type, intype);\n+  if (!can_convert_intype_to_type\n+      && (convtype & CONV_IMPLICIT) && IS_AGGR_TYPE (intype)\n       && ! (flags & LOOKUP_NO_CONVERSION))\n     {\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n@@ -489,12 +488,12 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t  expr = rval_as_conversion;\n \t  rval_as_conversion = NULL_TREE;\n \t  intype = type;\n-\t  i = 1;\n+\t  can_convert_intype_to_type = 1;\n \t}\n     }\n \n-  if (((convtype & CONV_STATIC) && i == -1)\n-      || ((convtype & CONV_IMPLICIT) && i == 1))\n+  if (((convtype & CONV_STATIC) && can_convert (intype, type))\n+      || ((convtype & CONV_IMPLICIT) && can_convert_intype_to_type))\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n@@ -550,8 +549,6 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       return rval;\n     }\n \n-  my_friendly_assert (TREE_CODE (intype) != OFFSET_TYPE, 189);\n-\n   if (flags & LOOKUP_COMPLAIN)\n     error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n \n@@ -618,8 +615,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n \n-  if (e == error_mark_node\n-      || TREE_TYPE (e) == error_mark_node)\n+  if (error_operand_p (e) || type == error_mark_node)\n     return error_mark_node;\n \n   complete_type (type);\n@@ -671,13 +667,6 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       return e;\n     }\n \n-  /* Just convert to the type of the member.  */\n-  if (code == OFFSET_TYPE)\n-    {\n-      type = TREE_TYPE (type);\n-      code = TREE_CODE (type);\n-    }\n-\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (e);\n@@ -721,8 +710,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t}\n       return fold (convert_to_integer (type, e));\n     }\n-  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n-      || TYPE_PTRMEMFUNC_P (type))\n+  if (POINTER_TYPE_P (type) || TYPE_PTR_TO_MEMBER_P (type))\n     return fold (cp_convert_to_pointer (type, e, false));\n   if (code == VECTOR_TYPE)\n     return fold (convert_to_vector (type, e));\n@@ -1178,10 +1166,20 @@ type_promotes_to (tree type)\n tree \n perform_qualification_conversions (tree type, tree expr)\n {\n-  if (TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n-      && comp_ptr_ttypes (TREE_TYPE (type), TREE_TYPE (TREE_TYPE (expr))))\n-    return build1 (NOP_EXPR, type, expr);\n+  tree expr_type;\n+\n+  expr_type = TREE_TYPE (expr);\n+\n+  if (TYPE_PTR_P (type) && TYPE_PTR_P (expr_type)\n+      && comp_ptr_ttypes (TREE_TYPE (type), TREE_TYPE (expr_type)))\n+    return build_nop (type, expr);\n+  else if (TYPE_PTR_TO_MEMBER_P (type)\n+\t   && TYPE_PTR_TO_MEMBER_P (expr_type)\n+\t   && same_type_p (TYPE_PTRMEM_CLASS_TYPE (type),\n+\t\t\t   TYPE_PTRMEM_CLASS_TYPE (expr_type))\n+\t   && comp_ptr_ttypes (TYPE_PTRMEM_POINTED_TO_TYPE (type),\n+\t\t\t       TYPE_PTRMEM_POINTED_TO_TYPE (expr_type)))\n+    return build_nop (type, expr);\n   else\n     return error_mark_node;\n }"}, {"sha": "7f36c99e28aca7b759702fdcc7790a7686e733ae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -9284,7 +9284,26 @@ build_ptrmemfunc_type (tree type)\n tree\n build_ptrmem_type (tree class_type, tree member_type)\n {\n-  return build_pointer_type (build_offset_type (class_type, member_type));\n+  if (TREE_CODE (member_type) == METHOD_TYPE)\n+    {\n+      tree arg_types;\n+\n+      arg_types = TYPE_ARG_TYPES (member_type);\n+      class_type = (cp_build_qualified_type \n+\t\t    (class_type,\n+\t\t     cp_type_quals (TREE_TYPE (TREE_VALUE (arg_types)))));\n+      member_type \n+\t= build_cplus_method_type (class_type, \n+\t\t\t\t   TREE_TYPE (member_type),\n+\t\t\t\t   TREE_CHAIN (arg_types));\n+      return build_ptrmemfunc_type (build_pointer_type (member_type));\n+    }\n+  else\n+    {\n+      my_friendly_assert (TREE_CODE (member_type) != FUNCTION_TYPE,\n+\t\t\t  20030716);\n+      return build_offset_type (class_type, member_type);\n+    }\n }\n \n /* DECL is a VAR_DECL defined in-class, whose TYPE is also given.\n@@ -9521,10 +9540,6 @@ create_array_type_for_decl (tree name, tree type, tree size)\n       error_msg = \"array of references\";\n       break;\n \n-    case OFFSET_TYPE:\n-      error_msg = \"array of data members\";\n-      break;\n-\n     case METHOD_TYPE:\n       error_msg = \"array of function members\";\n       break;\n@@ -11360,8 +11375,6 @@ grokdeclarator (tree declarator,\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE)\n \ttype = build_pointer_type (type);\n-      else if (TREE_CODE (type) == OFFSET_TYPE)\n-\ttype = build_pointer_type (type);\n     }\n \n   {\n@@ -11991,12 +12004,6 @@ grokparms (tree first_parm)\n \t      type = build_pointer_type (type);\n \t      TREE_TYPE (decl) = type;\n \t    }\n-\t  else if (TREE_CODE (type) == OFFSET_TYPE)\n-\t    {\n-\t      error (\"parameter `%D' invalidly declared offset type\", decl);\n-\t      type = build_pointer_type (type);\n-\t      TREE_TYPE (decl) = type;\n-\t    }\n \t  else if (abstract_virtuals_error (decl, type))\n \t    any_error = 1;  /* Seems like a good idea.  */\n \t  else if (POINTER_TYPE_P (type))"}, {"sha": "b48f25b7752bf0af510776adc763b39bfbe2f5d2", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -237,26 +237,23 @@ cp_dump_tree (void* dump_info, tree t)\n \t}\n       break;\n \n-    case POINTER_TYPE:\n-      if (TYPE_PTRMEM_P (t))\n-\t{\n-\t  dump_string (di, \"ptrmem\");\n-\t  dump_child (\"ptd\", TYPE_PTRMEM_POINTED_TO_TYPE (t));\n-\t  dump_child (\"cls\", TYPE_PTRMEM_CLASS_TYPE (t));\n-\t  return true;\n-\t}\n-      break;\n+    case OFFSET_TYPE:\n+      dump_string (di, \"ptrmem\");\n+      dump_child (\"ptd\", TYPE_PTRMEM_POINTED_TO_TYPE (t));\n+      dump_child (\"cls\", TYPE_PTRMEM_CLASS_TYPE (t));\n+      return true;\n \n     case RECORD_TYPE:\n-    case UNION_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \t{\n \t  dump_string (di, \"ptrmem\");\n \t  dump_child (\"ptd\", TYPE_PTRMEM_POINTED_TO_TYPE (t));\n \t  dump_child (\"cls\", TYPE_PTRMEM_CLASS_TYPE (t));\n \t  return true;\n \t}\n+      /* Fall through.  */\n \n+    case UNION_TYPE:\n       /* Is it a type used as a base? */\n       if (TYPE_CONTEXT (t) && TREE_CODE (TYPE_CONTEXT (t)) == TREE_CODE (t)\n \t  && CLASSTYPE_AS_BASE (TYPE_CONTEXT (t)) == t)"}, {"sha": "11a548bd1fe80994f1c7de02be2b6270c0387235", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -587,19 +587,14 @@ dump_type_prefix (tree t, int flags)\n \ttree sub = TREE_TYPE (t);\n \n \tpadding = dump_type_prefix (sub, flags);\n-\t/* A tree for a member pointer looks like pointer to offset,\n-\t   so let the OFFSET_TYPE case handle it.  */\n-\tif (!TYPE_PTRMEM_P (t))\n+\tif (TREE_CODE (sub) == ARRAY_TYPE)\n \t  {\n-\t    if (TREE_CODE (sub) == ARRAY_TYPE)\n-              {\n-                output_add_space (scratch_buffer);\n-                print_left_paren (scratch_buffer);\n-              }\n-            output_add_character\n-              (scratch_buffer, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n-\t    padding = dump_qualifiers (t, before);\n+\t    output_add_space (scratch_buffer);\n+\t    print_left_paren (scratch_buffer);\n \t  }\n+\toutput_add_character\n+\t  (scratch_buffer, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n+\tpadding = dump_qualifiers (t, before);\n       }\n       break;\n "}, {"sha": "630f0789073abc2a1e284daff5739121fc8425ba", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -51,11 +51,8 @@ cplus_expand_constant (tree cst)\n \tmember = PTRMEM_CST_MEMBER (cst);\n \n \tif (TREE_CODE (member) == FIELD_DECL) \n-\t  {\n-\t    /* Find the offset for the field.  */\n-\t    tree offset = byte_position (member);\n-\t    cst = fold (build1 (NOP_EXPR, type, offset));\n-\t  }\n+\t  /* Find the offset for the field.  */\n+\t  cst = fold (build_nop (type, byte_position (member)));\n \telse\n \t  {\n \t    tree delta;"}, {"sha": "fc10a24940b7ed5e494ca7346337f373fb4b145a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 74, "deletions": 89, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -1337,18 +1337,19 @@ get_type_value (tree name)\n     return NULL_TREE;\n }\n \n-/* Build a reference to a member of an aggregate.  This is not a\n-   C++ `&', but really something which can have its address taken,\n-   and then act as a pointer to member, for example TYPE :: FIELD\n-   can have its address taken by saying & TYPE :: FIELD.\n+/* Build a reference to a member of an aggregate.  This is not a C++\n+   `&', but really something which can have its address taken, and\n+   then act as a pointer to member, for example TYPE :: FIELD can have\n+   its address taken by saying & TYPE :: FIELD.  ADDRESS_P is true if\n+   this expression is the operand of \"&\".\n \n    @@ Prints out lousy diagnostics for operator <typename>\n    @@ fields.\n \n    @@ This function should be rewritten and placed in search.c.  */\n \n tree\n-build_offset_ref (tree type, tree name)\n+build_offset_ref (tree type, tree name, bool address_p)\n {\n   tree decl;\n   tree member;\n@@ -1435,8 +1436,33 @@ build_offset_ref (tree type, tree name)\n \treturn error_mark_node;\n     }\n \n+  if (!member)\n+    {\n+      error (\"`%D' is not a member of type `%T'\", name, type);\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (member) == TYPE_DECL)\n+    {\n+      TREE_USED (member) = 1;\n+      return member;\n+    }\n+  /* static class members and class-specific enum\n+     values can be returned without further ado.  */\n+  if (TREE_CODE (member) == VAR_DECL || TREE_CODE (member) == CONST_DECL)\n+    {\n+      mark_used (member);\n+      return convert_from_reference (member);\n+    }\n+\n+  if (TREE_CODE (member) == FIELD_DECL && DECL_C_BIT_FIELD (member))\n+    {\n+      error (\"invalid pointer to bit-field `%D'\", member);\n+      return error_mark_node;\n+    }\n+\n   /* A lot of this logic is now handled in lookup_member.  */\n-  if (member && BASELINK_P (member))\n+  if (BASELINK_P (member))\n     {\n       /* Go from the TREE_BASELINK to the member function info.  */\n       tree fnfields = member;\n@@ -1475,104 +1501,63 @@ build_offset_ref (tree type, tree name)\n \t  mark_used (t);\n \t  if (DECL_STATIC_FUNCTION_P (t))\n \t    return t;\n-\t  t = build (OFFSET_REF, TREE_TYPE (t), decl, t);\n-\t  PTRMEM_OK_P (t) = 1;\n-\t  return t;\n+\t  member = t;\n+\t}\n+      else\n+\t{\n+\t  TREE_TYPE (fnfields) = unknown_type_node;\n+\t  member = fnfields;\n \t}\n-\n-      TREE_TYPE (fnfields) = unknown_type_node;\n-      \n-      t = build (OFFSET_REF, unknown_type_node, decl, fnfields);\n-      PTRMEM_OK_P (t) = 1;\n-      return t;\n     }\n \n-  if (member == NULL_TREE)\n+  if (!address_p)\n     {\n-      error (\"`%D' is not a member of type `%T'\", name, type);\n-      return error_mark_node;\n-    }\n+      /* If MEMBER is non-static, then the program has fallen afoul of\n+\t [expr.prim]:\n \n-  if (TREE_CODE (member) == TYPE_DECL)\n-    {\n-      TREE_USED (member) = 1;\n-      return member;\n-    }\n-  /* static class members and class-specific enum\n-     values can be returned without further ado.  */\n-  if (TREE_CODE (member) == VAR_DECL || TREE_CODE (member) == CONST_DECL)\n-    {\n-      mark_used (member);\n-      return convert_from_reference (member);\n-    }\n+\t   An id-expression that denotes a nonstatic data member or\n+\t   nonstatic member function of a class can only be used:\n \n-  if (TREE_CODE (member) == FIELD_DECL && DECL_C_BIT_FIELD (member))\n-    {\n-      error (\"invalid pointer to bit-field `%D'\", member);\n-      return error_mark_node;\n-    }\n+\t   -- as part of a class member access (_expr.ref_) in which the\n+\t   object-expression refers to the member's class or a class\n+\t   derived from that class, or\n \n-  /* static class functions too.  */\n-  if (TREE_CODE (member) == FUNCTION_DECL\n-      && TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE)\n-    abort ();\n+\t   -- to form a pointer to member (_expr.unary.op_), or\n+\n+\t   -- in the body of a nonstatic member function of that class or\n+\t   of a class derived from that class (_class.mfct.nonstatic_), or\n+\n+\t   -- in a mem-initializer for a constructor for that class or for\n+\t   a class derived from that class (_class.base.init_).  */\n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (member))\n+\t{\n+\t  /* In Microsoft mode, treat a non-static member function as if\n+\t     it were a pointer-to-member.  */\n+\t  if (flag_ms_extensions)\n+\t    {\n+\t      member = build (OFFSET_REF, TREE_TYPE (member), decl, member);\n+\t      PTRMEM_OK_P (member) = 1;\n+\t      return build_unary_op (ADDR_EXPR, member, 0);\n+\t    }\n+\t  error (\"invalid use of non-static member function `%D'\", member);\n+\t  return error_mark_node;\n+\t}\n+      else if (TREE_CODE (member) == FIELD_DECL)\n+\t{\n+\t  error (\"invalid use of non-static data member `%D'\", member);\n+\t  return error_mark_node;\n+\t}\n+      return member;\n+    }\n \n   /* In member functions, the form `type::name' is no longer\n      equivalent to `this->type::name', at least not until\n      resolve_offset_ref.  */\n-  member = build (OFFSET_REF, build_offset_type (type, TREE_TYPE (member)), \n-\t\t  decl, member);\n+  member = build (OFFSET_REF, TREE_TYPE (member), decl, member);\n   PTRMEM_OK_P (member) = 1;\n   return member;\n }\n \n-/* If a OFFSET_REF made it through to here, then it did\n-   not have its address taken.  */\n-\n-tree\n-resolve_offset_ref (tree exp)\n-{\n-  tree member;\n-\n-  my_friendly_assert (TREE_CODE (exp) == OFFSET_REF, 20030703);\n-\n-  member = TREE_OPERAND (exp, 1);\n-\n-  /* If MEMBER is non-static, then the program has fallen afoul of\n-     [expr.prim]:\n-\n-       An id-expression that denotes a nonstatic data member or\n-       nonstatic member function of a class can only be used:\n-\n-       -- as part of a class member access (_expr.ref_) in which the\n-       object-expression refers to the member's class or a class\n-       derived from that class, or\n-\n-       -- to form a pointer to member (_expr.unary.op_), or\n-\n-       -- in the body of a nonstatic member function of that class or\n-       of a class derived from that class (_class.mfct.nonstatic_), or\n-\n-       -- in a mem-initializer for a constructor for that class or for\n-       a class derived from that class (_class.base.init_).  */\n-  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (member))\n-    {\n-      /* In Microsoft mode, treat a non-static member function as if\n-\t it were a pointer-to-member.  */\n-      if (flag_ms_extensions)\n-\treturn build_unary_op (ADDR_EXPR, exp, 0);\n-      error (\"invalid use of non-static member function `%D'\", member);\n-      return error_mark_node;\n-    }\n-  else if (TREE_CODE (member) == FIELD_DECL)\n-    {\n-      error (\"invalid use of non-static data member `%D'\", member);\n-      return error_mark_node;\n-    }\n-\n-  return member;\n-}\n-\n /* If DECL is a `const' declaration, and its value is a known\n    constant, then return that value.  */\n "}, {"sha": "3cef2e2257f755723ad8ac6607023bbf5ff43d46", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -3581,17 +3581,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t   it does not.  Therefore, we have to manually obtain\n \t\t   the underlying type here.  */\n \t\tscope = non_reference (scope);\n-\t\t/* If the SCOPE is an OFFSET_TYPE, then we grab the\n-\t\t   type of the field.  We get an OFFSET_TYPE for\n-\t\t   something like:\n-\n-\t\t     S::T.a ...\n-\n-\t\t   Probably, we should not get an OFFSET_TYPE here;\n-\t\t   that transformation should be made only if `&S::T'\n-\t\t   is written.  */\n-\t\tif (TREE_CODE (scope) == OFFSET_TYPE)\n-\t\t  scope = TREE_TYPE (scope);\n \t\t/* The type of the POSTFIX_EXPRESSION must be\n \t\t   complete.  */\n \t\tscope = complete_type_or_else (scope, NULL_TREE);"}, {"sha": "61d54b9efe2f2cc7a91ed0633ec81c200f1c7faa", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 47, "deletions": 67, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -3004,8 +3004,7 @@ convert_nontype_argument (tree type, tree expr)\n        Check this first since if expr_type is the unknown_type_node\n        we would otherwise complain below.  */\n     ;\n-  else if (TYPE_PTRMEM_P (expr_type)\n-\t   || TYPE_PTRMEMFUNC_P (expr_type))\n+  else if (TYPE_PTR_TO_MEMBER_P (expr_type))\n     {\n       if (TREE_CODE (expr) != PTRMEM_CST)\n \tgoto bad_argument;\n@@ -3038,8 +3037,7 @@ convert_nontype_argument (tree type, tree expr)\n \t\t  else\n \t\t    error (\"it must be the address of an object with external linkage\");\n \t\t}\n-\t      else if (TYPE_PTRMEM_P (expr_type)\n-\t\t       || TYPE_PTRMEMFUNC_P (expr_type))\n+\t      else if (TYPE_PTR_TO_MEMBER_P (expr_type))\n \t\terror (\"it must be a pointer-to-member of the form `&X::Y'\");\n \n \t      return NULL_TREE;\n@@ -3070,9 +3068,7 @@ convert_nontype_argument (tree type, tree expr)\n \t  return error_mark_node;\n \t}\n     }\n-  else if (INTEGRAL_TYPE_P (expr_type) \n-\t   || TYPE_PTRMEM_P (expr_type) \n-\t   || TYPE_PTRMEMFUNC_P (expr_type))\n+  else if (INTEGRAL_TYPE_P (expr_type) || TYPE_PTR_TO_MEMBER_P (expr_type))\n     {\n       if (! TREE_CONSTANT (expr))\n \t{\n@@ -3117,31 +3113,32 @@ convert_nontype_argument (tree type, tree expr)\n \tgoto non_constant;\n       \n       return expr;\n-\t\n+\n+    case OFFSET_TYPE:\n+      {\n+\ttree e;\n+\n+\t/* For a non-type template-parameter of type pointer to data\n+\t   member, qualification conversions (_conv.qual_) are\n+\t   applied.  */\n+\te = perform_qualification_conversions (type, expr);\n+\tif (TREE_CODE (e) == NOP_EXPR)\n+\t  /* The call to perform_qualification_conversions will\n+\t     insert a NOP_EXPR over EXPR to do express conversion,\n+\t     if necessary.  But, that will confuse us if we use\n+\t     this (converted) template parameter to instantiate\n+\t     another template; then the thing will not look like a\n+\t     valid template argument.  So, just make a new\n+\t     constant, of the appropriate type.  */\n+\t  e = make_ptrmem_cst (type, PTRMEM_CST_MEMBER (expr));\n+\treturn e;\n+      }\n+\n     case POINTER_TYPE:\n       {\n \ttree type_pointed_to = TREE_TYPE (type);\n  \n-\tif (TYPE_PTRMEM_P (type))\n-\t  {\n-\t    tree e;\n-\n-\t    /* For a non-type template-parameter of type pointer to data\n-\t       member, qualification conversions (_conv.qual_) are\n-\t       applied.  */\n-\t    e = perform_qualification_conversions (type, expr);\n-\t    if (TREE_CODE (e) == NOP_EXPR)\n-\t      /* The call to perform_qualification_conversions will\n-\t\t insert a NOP_EXPR over EXPR to do express conversion,\n-\t\t if necessary.  But, that will confuse us if we use\n-\t\t this (converted) template parameter to instantiate\n-\t\t another template; then the thing will not look like a\n-\t\t valid template argument.  So, just make a new\n-\t\t constant, of the appropriate type.  */\n-\t      e = make_ptrmem_cst (type, PTRMEM_CST_MEMBER (expr));\n-\t    return e;\n-\t  }\n-\telse if (TREE_CODE (type_pointed_to) == FUNCTION_TYPE)\n+\tif (TREE_CODE (type_pointed_to) == FUNCTION_TYPE)\n \t  { \n \t    /* For a non-type template-parameter of type pointer to\n \t       function, only the function-to-pointer conversion\n@@ -3421,8 +3418,7 @@ convert_template_argument (tree parm,\n   inner_args = INNERMOST_TEMPLATE_ARGS (args);\n \n   if (TREE_CODE (arg) == TREE_LIST \n-      && TREE_TYPE (arg) != NULL_TREE\n-      && TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n+      && TREE_CODE (TREE_VALUE (arg)) == OFFSET_REF)\n     {  \n       /* The template argument was the name of some\n \t member function.  That's usually\n@@ -6815,21 +6811,26 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  }\n \tmy_friendly_assert (TREE_CODE (type) != METHOD_TYPE, 20011231);\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n-\t  /* This is really a method type. The cv qualifiers of the\n-\t     this pointer should _not_ be determined by the cv\n-\t     qualifiers of the class type.  They should be held\n-\t     somewhere in the FUNCTION_TYPE, but we don't do that at\n-\t     the moment.  Consider\n-\t        typedef void (Func) () const;\n-\n-\t\ttemplate <typename T1> void Foo (Func T1::*);\n-\n-\t      */\n-\t  return build_cplus_method_type (TYPE_MAIN_VARIANT (r),\n-\t\t\t\t\t  TREE_TYPE (type),\n-\t\t\t\t\t  TYPE_ARG_TYPES (type));\n+\t  {\n+\t    /* This is really a method type. The cv qualifiers of the\n+\t       this pointer should _not_ be determined by the cv\n+\t       qualifiers of the class type.  They should be held\n+\t       somewhere in the FUNCTION_TYPE, but we don't do that at\n+\t       the moment.  Consider\n+\t\t  typedef void (Func) () const;\n+\n+\t\t  template <typename T1> void Foo (Func T1::*);\n+\n+\t\t*/\n+\t    tree method_type;\n+\n+\t    method_type = build_cplus_method_type (TYPE_MAIN_VARIANT (r),\n+\t\t\t\t\t\t   TREE_TYPE (type),\n+\t\t\t\t\t\t   TYPE_ARG_TYPES (type));\n+\t    return build_ptrmemfunc_type (build_pointer_type (method_type));\n+\t  }\n \telse\n-\t  return build_offset_type (r, type);\n+\t  return build_ptrmem_type (r, type);\n       }\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n@@ -9511,12 +9512,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t}\n       else\n \t{\n-\t  /* If ARG is an offset type, we're trying to unify '*T' with\n-\t     'U C::*', which is ill-formed. See the comment in the\n-\t     POINTER_TYPE case about this ugliness.  */\n-\t  if (TREE_CODE (arg) == OFFSET_TYPE)\n-\t    return 1;\n-\t  \n \t  /* If PARM is `const T' and ARG is only `int', we don't have\n \t     a match unless we are allowing additional qualification.\n \t     If ARG is `const int' and PARM is just `T' that's OK;\n@@ -9617,18 +9612,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t     level of pointers.  */\n \t  strict |= (strict_in & UNIFY_ALLOW_DERIVED);\n \n-\tif (TREE_CODE (TREE_TYPE (parm)) == OFFSET_TYPE\n-\t    && TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n-\t  {\n-\t    /* Avoid getting confused about cv-quals; don't recurse here.\n-\t       Pointers to members should really be just OFFSET_TYPE, not\n-\t       this two-level nonsense...  */\n-\n-\t    parm = TREE_TYPE (parm);\n-\t    arg = TREE_TYPE (arg);\n-\t    goto offset;\n-\t  }\n-\n \treturn unify (tparms, targs, TREE_TYPE (parm), \n \t\t      TREE_TYPE (arg), strict);\n       }\n@@ -9782,7 +9765,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t\t\t    DEDUCE_EXACT, 0, -1);\n \n     case OFFSET_TYPE:\n-    offset:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n@@ -11286,9 +11268,7 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n     return 0;\n   else if (POINTER_TYPE_P (type))\n     return 0;\n-  else if (TYPE_PTRMEM_P (type))\n-    return 0;\n-  else if (TYPE_PTRMEMFUNC_P (type))\n+  else if (TYPE_PTR_TO_MEMBER_P (type))\n     return 0;\n   else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     return 0;\n@@ -11325,7 +11305,7 @@ dependent_type_p_r (tree type)\n         dependent.  */\n   type = TYPE_MAIN_VARIANT (type);\n   /* -- a compound type constructed from any dependent type.  */\n-  if (TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n+  if (TYPE_PTR_TO_MEMBER_P (type))\n     return (dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n \t    || dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE \n \t\t\t\t\t   (type)));"}, {"sha": "fdad47d9cc4ef05abde8c13c0c6be59ccd93a51e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -331,8 +331,6 @@ get_tinfo_decl (tree type)\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (type) == OFFSET_TYPE)\n-    type = TREE_TYPE (type);\n   if (TREE_CODE (type) == METHOD_TYPE)\n     type = build_function_type (TREE_TYPE (type),\n \t\t\t\tTREE_CHAIN (TYPE_ARG_TYPES (type)));\n@@ -715,19 +713,17 @@ qualifier_flags (tree type)\n static bool\n target_incomplete_p (tree type)\n {\n-  while (TREE_CODE (type) == POINTER_TYPE)\n+  while (true)\n     if (TYPE_PTRMEM_P (type))\n       {\n-        if (!COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)))\n-          return true;\n-        type = TYPE_PTRMEM_POINTED_TO_TYPE (type);\n+\tif (!COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)))\n+\t  return true;\n+\ttype = TYPE_PTRMEM_POINTED_TO_TYPE (type);\n       }\n-    else\n+    else if (TREE_CODE (type) == POINTER_TYPE)\n       type = TREE_TYPE (type);\n-  if (!COMPLETE_OR_VOID_TYPE_P (type))\n-    return true;\n-  \n-  return false;\n+    else\n+      return !COMPLETE_OR_VOID_TYPE_P (type);\n }\n \n /* Return a CONSTRUCTOR for the common part of the type_info objects. This\n@@ -999,12 +995,10 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n   my_friendly_assert (at_eof, 20021120);\n   switch (TREE_CODE (type))\n     {\n+    case OFFSET_TYPE:\n+      return ptm_initializer (var_desc, type, non_public_p);\n     case POINTER_TYPE:\n-      if (TYPE_PTRMEM_P (type))\n-\treturn ptm_initializer (var_desc, type, non_public_p);\n-      else\n-\treturn ptr_initializer (var_desc, type, non_public_p);\n-      break;\n+      return ptr_initializer (var_desc, type, non_public_p);\n     case ENUMERAL_TYPE:\n       return generic_initializer (var_desc, type);\n       break;\n@@ -1164,8 +1158,10 @@ get_pseudo_ti_desc (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n+    case OFFSET_TYPE:\n+      return ptm_desc_type_node;\n     case POINTER_TYPE:\n-      return TYPE_PTRMEM_P (type) ? ptm_desc_type_node : ptr_desc_type_node;\n+      return ptr_desc_type_node;\n     case ENUMERAL_TYPE:\n       return enum_desc_type_node;\n     case FUNCTION_TYPE:"}, {"sha": "102653a338eb5e0bfbab2118746e7a30f69108be", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -1367,7 +1367,8 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n     {\n       if (TREE_CODE (expr) == SCOPE_REF)\n \texpr = TREE_OPERAND (expr, 1);\n-      expr = build_offset_ref (qualifying_class, expr);\n+      expr = build_offset_ref (qualifying_class, expr, \n+\t\t\t       /*address_p=*/true);\n       return expr;\n     }\n \n@@ -1396,13 +1397,9 @@ finish_qualified_id_expr (tree qualifying_class, tree expr, bool done,\n \t\t BASELINK_ACCESS_BINFO (expr),\n \t\t /*preserve_reference=*/false));\n       else if (done)\n-\t{\n-\t  /* The expression is a qualified name whose address is not\n-\t     being taken.  */\n-\t  expr = build_offset_ref (qualifying_class, expr);\n-\t  if (TREE_CODE (expr) == OFFSET_REF)\n-\t    expr = resolve_offset_ref (expr);\n-\t}\n+\t/* The expression is a qualified name whose address is not\n+\t   being taken.  */\n+\texpr = build_offset_ref (qualifying_class, expr, /*address_p=*/false);\n     }\n \n   return expr;"}, {"sha": "0fcba63bbf1f6e665979bb225d52a00409ea8a97", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -1775,10 +1775,8 @@ pod_type_p (tree t)\n     return 1;\n   if (TYPE_PTR_P (t))\n     return 1; /* pointer to non-member */\n-  if (TYPE_PTRMEM_P (t))\n-    return 1; /* pointer to member object */\n-  if (TYPE_PTRMEMFUNC_P (t))\n-    return 1; /* pointer to member function */\n+  if (TYPE_PTR_TO_MEMBER_P (t))\n+    return 1; /* pointer to member */\n   \n   if (! CLASS_TYPE_P (t))\n     return 0; /* other non-class type (reference or function) */"}, {"sha": "0356cb7aada97dab2f893f72bf0ea38737c40fdf", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 176, "deletions": 479, "changes": 655, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -48,22 +48,17 @@ Boston, MA 02111-1307, USA.  */\n static tree convert_for_assignment (tree, tree, const char *, tree, int);\n static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n static tree rationalize_conditional_expr (enum tree_code, tree);\n-static int comp_target_parms (tree, tree);\n static int comp_ptr_ttypes_real (tree, tree, int);\n static int comp_ptr_ttypes_const (tree, tree);\n-static int comp_ptr_ttypes_reinterpret (tree, tree);\n static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (tree, tree, bool);\n static tree common_base_type (tree, tree);\n static tree lookup_anon_field (tree, tree);\n static tree pointer_diff (tree, tree, tree);\n-static tree qualify_type_recursive (tree, tree);\n static tree get_delta_difference (tree, tree, int);\n-static int comp_cv_target_types (tree, tree, int);\n static void casts_away_constness_r (tree *, tree *);\n static bool casts_away_constness (tree, tree);\n static void maybe_warn_about_returning_address_of_local (tree);\n-static tree strip_all_pointer_quals (tree);\n static tree lookup_destructor (tree, tree, tree);\n \n /* Return the target type of TYPE, which means return T for:\n@@ -77,7 +72,7 @@ target_type (tree type)\n \t || TREE_CODE (type) == ARRAY_TYPE\n \t || TREE_CODE (type) == FUNCTION_TYPE\n \t || TREE_CODE (type) == METHOD_TYPE\n-\t || TREE_CODE (type) == OFFSET_TYPE)\n+\t || TYPE_PTRMEM_P (type))\n     type = TREE_TYPE (type);\n   return type;\n }\n@@ -169,56 +164,9 @@ type_unknown_p (tree exp)\n {\n   return (TREE_CODE (exp) == OVERLOAD\n           || TREE_CODE (exp) == TREE_LIST\n-\t  || TREE_TYPE (exp) == unknown_type_node\n-\t  /* Until we get the type of non type-dependent expressions\n-\t     correct, we can have non-type dependent expressions with\n-\t     no type.  */\n-\t  || (TREE_TYPE (exp)\n-\t      && TREE_CODE (TREE_TYPE (exp)) == OFFSET_TYPE\n-\t      && TREE_TYPE (TREE_TYPE (exp)) == unknown_type_node));\n+\t  || TREE_TYPE (exp) == unknown_type_node);\n }\n \n-/* Return a pointer or pointer to member type similar to T1, with a\n-   cv-qualification signature that is the union of the cv-qualification\n-   signatures of T1 and T2: [expr.rel], [expr.eq].  */\n-\n-static tree\n-qualify_type_recursive (tree t1, tree t2)\n-{\n-  if ((TYPE_PTR_P (t1) && TYPE_PTR_P (t2))\n-      || (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2)))\n-    {\n-      tree tt1;\n-      tree tt2;\n-      tree b1;\n-      int type_quals;\n-      tree tgt;\n-      tree attributes = (*targetm.merge_type_attributes) (t1, t2);\n-\n-      if (TYPE_PTRMEM_P (t1))\n-\t{\n-\t  b1 = TYPE_PTRMEM_CLASS_TYPE (t1);\n-\t  tt1 = TYPE_PTRMEM_POINTED_TO_TYPE (t1);\n-\t  tt2 = TYPE_PTRMEM_POINTED_TO_TYPE (t2);\n-\t}\n-      else\n-\t{\n-\t  b1 = NULL_TREE;\n-\t  tt1 = TREE_TYPE (t1);\n-\t  tt2 = TREE_TYPE (t2);\n-\t}\n-\n-      type_quals = (cp_type_quals (tt1) | cp_type_quals (tt2));\n-      tgt = qualify_type_recursive (tt1, tt2);\n-      tgt = cp_build_qualified_type (tgt, type_quals);\n-      if (b1)\n-\tt1 = build_ptrmem_type (b1, tgt);\n-      else\n-\tt1 = build_pointer_type (tgt);\n-      t1 = build_type_attribute_variant (t1, attributes);\n-    }\n-  return t1;\n-}\n \f\n /* Return the common type of two parameter lists.\n    We assume that comptypes has already been done and returned 1;\n@@ -447,16 +395,85 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n     }\n }\n \n+/* Subroutine of composite_pointer_type to implement the recursive\n+   case.  See that function for documentation fo the parameters.  */\n+\n+static tree\n+composite_pointer_type_r (tree t1, tree t2, const char* location)\n+{\n+  tree pointee1;\n+  tree pointee2;\n+  tree result_type;\n+  tree attributes;\n+\n+  /* Determine the types pointed to by T1 and T2.  */\n+  if (TREE_CODE (t1) == POINTER_TYPE)\n+    {\n+      pointee1 = TREE_TYPE (t1);\n+      pointee2 = TREE_TYPE (t2);\n+    }\n+  else\n+    {\n+      pointee1 = TYPE_PTRMEM_POINTED_TO_TYPE (t1);\n+      pointee2 = TYPE_PTRMEM_POINTED_TO_TYPE (t2);\n+    }\n+\n+  /* [expr.rel]\n+\n+     Otherwise, the composite pointer type is a pointer type\n+     similar (_conv.qual_) to the type of one of the operands,\n+     with a cv-qualification signature (_conv.qual_) that is the\n+     union of the cv-qualification signatures of the operand\n+     types.  */\n+  if (same_type_ignoring_top_level_qualifiers_p (pointee1, pointee2))\n+    result_type = pointee1;\n+  else if ((TREE_CODE (pointee1) == POINTER_TYPE\n+\t    && TREE_CODE (pointee2) == POINTER_TYPE)\n+\t   || (TYPE_PTR_TO_MEMBER_P (pointee1)\n+\t       && TYPE_PTR_TO_MEMBER_P (pointee2)))\n+    result_type = composite_pointer_type_r (pointee1, pointee2, location);\n+  else\n+    {\n+      pedwarn (\"%s between distinct pointer types `%T' and `%T' \"\n+\t       \"lacks a cast\",\n+\t       location, t1, t2);\n+      result_type = void_type_node;\n+    }\n+  result_type = cp_build_qualified_type (result_type,\n+\t\t\t\t\t (cp_type_quals (pointee1)\n+\t\t\t\t\t  | cp_type_quals (pointee2)));\n+  result_type = build_pointer_type (result_type);\n+  /* If the original types were pointers to members, so is the\n+     result.  */\n+  if (TYPE_PTR_TO_MEMBER_P (t1))\n+    {\n+      if (!same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n+\t\t\tTYPE_PTRMEM_CLASS_TYPE (t2)))\n+\tpedwarn (\"%s between distinct pointer types `%T' and `%T' \"\n+\t\t \"lacks a cast\",\n+\t\t location, t1, t2);\n+      result_type = build_ptrmem_type (TYPE_PTRMEM_CLASS_TYPE (t1),\n+\t\t\t\t       result_type);\n+    }\n+\n+  /* Merge the attributes.  */\n+  attributes = (*targetm.merge_type_attributes) (t1, t2);\n+  return build_type_attribute_variant (result_type, attributes);\n+}\n+\n /* Return the composite pointer type (see [expr.rel]) for T1 and T2.\n    ARG1 and ARG2 are the values with those types.  The LOCATION is a\n-   string describing the current location, in case an error occurs.  */\n+   string describing the current location, in case an error occurs. \n+\n+   This routine also implements the computation of a common type for\n+   pointers-to-members as per [expr.eq].  */\n \n tree \n composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \t\t\tconst char* location)\n {\n-  tree result_type;\n-  tree attributes;\n+  tree class1;\n+  tree class2;\n \n   /* [expr.rel]\n \n@@ -467,16 +484,6 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n   if (null_ptr_cst_p (arg2))\n     return t1;\n  \n-  /* Deal with pointer-to-member functions in the same way as we deal\n-     with pointers to functions.  */\n-  if (TYPE_PTRMEMFUNC_P (t1))\n-    t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n-  if (TYPE_PTRMEMFUNC_P (t2))\n-    t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n-  \n-  /* Merge the attributes.  */\n-  attributes = (*targetm.merge_type_attributes) (t1, t2);\n-\n   /* We have:\n \n        [expr.rel]\n@@ -487,45 +494,78 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n        and cv2.\n \n     If either type is a pointer to void, make sure it is T1.  */\n-  if (VOID_TYPE_P (TREE_TYPE (t2)))\n+  if (TREE_CODE (t2) == POINTER_TYPE && VOID_TYPE_P (TREE_TYPE (t2)))\n     {\n       tree t;\n       t = t1;\n       t1 = t2;\n       t2 = t;\n     }\n+\n   /* Now, if T1 is a pointer to void, merge the qualifiers.  */\n-  if (VOID_TYPE_P (TREE_TYPE (t1)))\n+  if (TREE_CODE (t1) == POINTER_TYPE && VOID_TYPE_P (TREE_TYPE (t1)))\n     {\n+      tree attributes;\n+      tree result_type;\n+\n       if (pedantic && TYPE_PTRFN_P (t2))\n \tpedwarn (\"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function\", location);\n-      t1 = TREE_TYPE (t1);\n-      t2 = TREE_TYPE (t2);\n-      result_type = cp_build_qualified_type (void_type_node,\n-\t\t\t\t\t     (cp_type_quals (t1)\n-\t\t\t\t\t      | cp_type_quals (t2)));\n+      result_type \n+\t= cp_build_qualified_type (void_type_node,\n+\t\t\t\t   (cp_type_quals (TREE_TYPE (t1))\n+\t\t\t\t    | cp_type_quals (TREE_TYPE (t2))));\n       result_type = build_pointer_type (result_type);\n+      /* Merge the attributes.  */\n+      attributes = (*targetm.merge_type_attributes) (t1, t2);\n+      return build_type_attribute_variant (result_type, attributes);\n+    }\n+\n+  /* [expr.eq] permits the application of a pointer conversion to\n+     bring the pointers to a common type.  */\n+  if (TREE_CODE (t1) == POINTER_TYPE && TREE_CODE (t2) == POINTER_TYPE\n+      && CLASS_TYPE_P (TREE_TYPE (t1))\n+      && CLASS_TYPE_P (TREE_TYPE (t2))\n+      && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (t1),\n+\t\t\t\t\t\t     TREE_TYPE (t2)))\n+    {\n+      class1 = TREE_TYPE (t1);\n+      class2 = TREE_TYPE (t2);\n+\n+      if (DERIVED_FROM_P (class1, class2))\n+\tt2 = (build_pointer_type \n+\t      (cp_build_qualified_type (class1, TYPE_QUALS (class2))));\n+      else if (DERIVED_FROM_P (class2, class1))\n+\tt1 = (build_pointer_type \n+\t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n+      else\n+\t{\n+\t  error (\"%s between distinct pointer types `%T' and `%T' \"\n+\t\t \"lacks a cast\", location, t1, t2);\n+\t  return error_mark_node;\n+\t}\n     }\n-  else\n+  /* [expr.eq] permits the application of a pointer-to-member\n+     conversion to change the class type of one of the types.  */\n+  else if (TYPE_PTR_TO_MEMBER_P (t1)\n+\t   && !same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n+\t\t\t    TYPE_PTRMEM_CLASS_TYPE (t2)))\n     {\n-      tree full1 = qualify_type_recursive (t1, t2);\n-      tree full2 = qualify_type_recursive (t2, t1);\n+      class1 = TYPE_PTRMEM_CLASS_TYPE (t1);\n+      class2 = TYPE_PTRMEM_CLASS_TYPE (t2);\n \n-      int val = comp_target_types (full1, full2, 1);\n-\n-      if (val > 0)\n-\tresult_type = full1;\n-      else if (val < 0)\n-\tresult_type = full2;\n+      if (DERIVED_FROM_P (class1, class2))\n+\tt1 = build_ptrmem_type (class2, TYPE_PTRMEM_POINTED_TO_TYPE (t1));\n+      else if (DERIVED_FROM_P (class2, class1))\n+\tt2 = build_ptrmem_type (class1, TYPE_PTRMEM_POINTED_TO_TYPE (t2));\n       else\n \t{\n-\t  pedwarn (\"%s between distinct pointer types `%T' and `%T' lacks a cast\",\n-\t\t      location, t1, t2);\n-\t  result_type = ptr_type_node;\n+\t  error (\"%s between distinct pointer-to-member types `%T' and `%T' \"\n+\t\t \"lacks a cast\", location, t1, t2);\n+\t  return error_mark_node;\n \t}\n     }\n \n-  return build_type_attribute_variant (result_type, attributes);\n+  return composite_pointer_type_r (t1, t2, location);\n }\n \n /* Return the merged type of two types.\n@@ -557,8 +597,6 @@ merge_types (tree t1, tree t2)\n   /* Merge the attributes.  */\n   attributes = (*targetm.merge_type_attributes) (t1, t2);\n \n-  /* Treat an enum type as the unsigned integer type of the same width.  */\n-\n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n   if (TYPE_PTRMEMFUNC_P (t2))\n@@ -706,7 +744,6 @@ common_type (tree t1, tree t2)\n \t   || (TYPE_PTRMEMFUNC_P (t1) && TYPE_PTRMEMFUNC_P (t2)))\n     return composite_pointer_type (t1, t2, error_mark_node, error_mark_node,\n \t\t\t\t   \"conversion\");\n-\n   else\n     abort ();\n }\n@@ -995,206 +1032,6 @@ comptypes (tree t1, tree t2, int strict)\n   return false;\n }\n \n-/* Subroutine of comp_target-types.  Make sure that the cv-quals change\n-   only in the same direction as the target type.  */\n-\n-static int\n-comp_cv_target_types (tree ttl, tree ttr, int nptrs)\n-{\n-  int t;\n-\n-  if (!at_least_as_qualified_p (ttl, ttr)\n-      && !at_least_as_qualified_p (ttr, ttl))\n-    /* The qualifications are incomparable.  */\n-    return 0;\n-\n-  if (TYPE_MAIN_VARIANT (ttl) == TYPE_MAIN_VARIANT (ttr))\n-    return more_qualified_p (ttr, ttl) ? -1 : 1;\n-\n-  t = comp_target_types (ttl, ttr, nptrs);\n-  if ((t == 1 && at_least_as_qualified_p (ttl, ttr)) \n-      || (t == -1 && at_least_as_qualified_p (ttr, ttl)))\n-    return t;\n-\n-  return 0;\n-}\n-\n-/* Return 1 or -1 if TTL and TTR are pointers to types that are equivalent,\n-   ignoring their qualifiers, 0 if not. Return 1 means that TTR can be\n-   converted to TTL. Return -1 means that TTL can be converted to TTR but\n-   not vice versa.\n-\n-   NPTRS is the number of pointers we can strip off and keep cool.\n-   This is used to permit (for aggr A, aggr B) A, B* to convert to A*,\n-   but to not permit B** to convert to A**.\n-\n-   This should go away.  Callers should use can_convert or something\n-   similar instead.  (jason 17 Apr 1997)  */\n-\n-int\n-comp_target_types (tree ttl, tree ttr, int nptrs)\n-{\n-  ttl = TYPE_MAIN_VARIANT (ttl);\n-  ttr = TYPE_MAIN_VARIANT (ttr);\n-  if (same_type_p (ttl, ttr))\n-    return 1;\n-\n-  if (TREE_CODE (ttr) != TREE_CODE (ttl))\n-    return 0;\n-\n-  if ((TREE_CODE (ttr) == POINTER_TYPE\n-       || TREE_CODE (ttr) == REFERENCE_TYPE)\n-      /* If we get a pointer with nptrs == 0, we don't allow any tweaking\n-\t of the type pointed to.  This is necessary for reference init\n-\t semantics.  We won't get here from a previous call with nptrs == 1;\n-\t for multi-level pointers we end up in comp_ptr_ttypes.  */\n-      && nptrs > 0)\n-    {\n-      int is_ptr = TREE_CODE (ttr) == POINTER_TYPE;\n-\n-      ttl = TREE_TYPE (ttl);\n-      ttr = TREE_TYPE (ttr);\n-\n-      if (is_ptr)\n-\t{\n-\t  if (TREE_CODE (ttl) == UNKNOWN_TYPE\n-\t      || TREE_CODE (ttr) == UNKNOWN_TYPE)\n-\t    return 1;\n-\t  else if (TREE_CODE (ttl) == VOID_TYPE\n-\t\t   && TREE_CODE (ttr) != FUNCTION_TYPE\n-\t\t   && TREE_CODE (ttr) != METHOD_TYPE\n-\t\t   && TREE_CODE (ttr) != OFFSET_TYPE)\n-\t    return 1;\n-\t  else if (TREE_CODE (ttr) == VOID_TYPE\n-\t\t   && TREE_CODE (ttl) != FUNCTION_TYPE\n-\t\t   && TREE_CODE (ttl) != METHOD_TYPE\n-\t\t   && TREE_CODE (ttl) != OFFSET_TYPE)\n-\t    return -1;\n-\t  else if (TREE_CODE (ttl) == POINTER_TYPE\n-\t\t   || TREE_CODE (ttl) == ARRAY_TYPE)\n-\t    {\n-\t      if (comp_ptr_ttypes (ttl, ttr))\n-\t\treturn 1;\n-\t      else if (comp_ptr_ttypes (ttr, ttl))\n-\t\treturn -1;\n-\t      return 0;\n-\t    }\n-\t}\n-\n-      /* Const and volatile mean something different for function types,\n-\t so the usual checks are not appropriate.  */\n-      if (TREE_CODE (ttl) == FUNCTION_TYPE || TREE_CODE (ttl) == METHOD_TYPE)\n-\treturn comp_target_types (ttl, ttr, nptrs - 1);\n-\n-      return comp_cv_target_types (ttl, ttr, nptrs - 1);\n-    }\n-\n-  my_friendly_assert (TREE_CODE (ttr) != ARRAY_TYPE, 20030617);\n-  if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n-    {\n-      tree argsl, argsr;\n-      int saw_contra = 0;\n-\n-      if (pedantic)\n-\t{\n-\t  if (!same_type_p (TREE_TYPE (ttl), TREE_TYPE (ttr)))\n-\t    return 0;\n-\t}\n-      else\n-\t{\n-\t  switch (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n-\t    {\n-\t    case 0:\n-\t      return 0;\n-\t    case -1:\n-\t      saw_contra = 1;\n-\t    }\n-\t}\n-\n-      argsl = TYPE_ARG_TYPES (ttl);\n-      argsr = TYPE_ARG_TYPES (ttr);\n-\n-      /* Compare 'this' here, not in comp_target_parms.  */\n-      if (TREE_CODE (ttr) == METHOD_TYPE)\n-\t{\n-\t  tree tl = TYPE_METHOD_BASETYPE (ttl);\n-\t  tree tr = TYPE_METHOD_BASETYPE (ttr);\n-\n-\t  if (!same_or_base_type_p (tr, tl))\n-\t    {\n-\t      if (same_or_base_type_p (tl, tr))\n-\t\tsaw_contra = 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\n-\t  argsl = TREE_CHAIN (argsl);\n-\t  argsr = TREE_CHAIN (argsr);\n-\t}\n-\n-\tswitch (comp_target_parms (argsl, argsr))\n-\t  {\n-\t  case 0:\n-\t    return 0;\n-\t  case -1:\n-\t    saw_contra = 1;\n-\t  }\n-\n-\treturn saw_contra ? -1 : 1;\n-    }\n-  /* for C++ */\n-  else if (TREE_CODE (ttr) == OFFSET_TYPE)\n-    {\n-      int base;\n-\n-      /* Contravariance: we can assign a pointer to base member to a pointer\n-\t to derived member.  Note difference from simple pointer case, where\n-\t we can pass a pointer to derived to a pointer to base.  */\n-      if (same_or_base_type_p (TYPE_OFFSET_BASETYPE (ttr),\n-\t\t\t       TYPE_OFFSET_BASETYPE (ttl)))\n-\tbase = 1;\n-      else if (same_or_base_type_p (TYPE_OFFSET_BASETYPE (ttl),\n-\t\t\t\t    TYPE_OFFSET_BASETYPE (ttr)))\n-\t{\n-\t  tree tmp = ttl;\n-\t  ttl = ttr;\n-\t  ttr = tmp;\n-\t  base = -1;\n-\t}\n-      else\n-\treturn 0;\n-\n-      ttl = TREE_TYPE (ttl);\n-      ttr = TREE_TYPE (ttr);\n-\n-      if (TREE_CODE (ttl) == POINTER_TYPE\n-\t  || TREE_CODE (ttl) == ARRAY_TYPE)\n-\t{\n-\t  if (comp_ptr_ttypes (ttl, ttr))\n-\t    return base;\n-\t  return 0;\n-\t}\n-      else\n-\t{\n-\t  if (comp_cv_target_types (ttl, ttr, nptrs) == 1)\n-\t    return base;\n-\t  return 0;\n-\t}\n-    }\n-  else if (IS_AGGR_TYPE (ttl))\n-    {\n-      if (nptrs < 0)\n-\treturn 0;\n-      if (same_or_base_type_p (ttl, ttr))\n-\treturn 1;\n-      if (same_or_base_type_p (ttr, ttl))\n-\treturn -1;\n-      return 0;\n-    }\n-\n-  return 0;\n-}\n-\n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n \n bool\n@@ -1333,80 +1170,6 @@ compparms (tree parms1, tree parms2)\n   return true;\n }\n \n-/* This really wants return whether or not parameter type lists\n-   would make their owning functions assignment compatible or not.\n-\n-   The return value is like for comp_target_types.\n-\n-   This should go away, possibly with the exception of the empty parmlist\n-   conversion; there are no conversions between function types in C++.\n-   (jason 17 Apr 1997)  */\n-\n-static int\n-comp_target_parms (tree parms1, tree parms2)\n-{\n-  register tree t1 = parms1, t2 = parms2;\n-  int warn_contravariance = 0;\n-\n-  /* In C, an unspecified parmlist matches any specified parmlist\n-     whose argument types don't need default promotions.  This is not\n-     true for C++, but let's do it anyway for unfixed headers.  */\n-\n-  if (t1 == 0 && t2 != 0)\n-    {\n-      pedwarn (\"ISO C++ prohibits conversion from `%#T' to `(...)'\",\n-\t\t  parms2);\n-      return self_promoting_args_p (t2);\n-    }\n-  if (t2 == 0)\n-    return self_promoting_args_p (t1);\n-\n-  for (; t1 || t2; t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n-    {\n-      tree p1, p2;\n-\n-      /* If one parmlist is shorter than the other, they fail to match.  */\n-      if (!t1 || !t2)\n-\treturn 0;\n-      p1 = TREE_VALUE (t1);\n-      p2 = TREE_VALUE (t2);\n-      if (same_type_p (p1, p2))\n-\tcontinue;\n-\n-      if (pedantic)\n-\treturn 0;\n-\n-      if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n-\t  || (TREE_CODE (p1) == REFERENCE_TYPE\n-\t      && TREE_CODE (p2) == REFERENCE_TYPE))\n-\t{\n-\t  /* The following is wrong for contravariance,\n-\t     but many programs depend on it.  */\n-\t  if (TREE_TYPE (p1) == void_type_node)\n-\t    continue;\n-\t  if (TREE_TYPE (p2) == void_type_node)\n-\t    {\n-\t      warn_contravariance = 1;\n-\t      continue;\n-\t    }\n-\t  if (IS_AGGR_TYPE (TREE_TYPE (p1))\n-\t      && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (p1),\n-\t\t\t\t\t\t\t     TREE_TYPE (p2)))\n-\t    return 0;\n-\t}\n-      /* Note backwards order due to contravariance.  */\n-      if (comp_target_types (p2, p1, 1) <= 0)\n-\t{\n-\t  if (comp_target_types (p1, p2, 1) > 0)\n-\t    {\n-\t      warn_contravariance = 1;\n-\t      continue;\n-\t    }\n-\t  return 0;\n-\t}\n-    }\n-  return warn_contravariance ? -1 : 1;\n-}\n \f\n tree\n cxx_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n@@ -1430,12 +1193,6 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n \tpedwarn (\"invalid application of `%s' to a member function\", op_name);\n       value = size_one_node;\n     }\n-  else if (type_code == OFFSET_TYPE)\n-    {\n-      if (complain)\n-\terror (\"invalid application of `%s' to non-static member\", op_name);\n-      value = size_zero_node;\n-    }\n   else\n     value = c_sizeof_or_alignof_type (complete_type (type), op, complain);\n \n@@ -2277,7 +2034,7 @@ build_indirect_ref (tree ptr, const char *errorstring)\n     }\n   /* `pointer' won't be an error_mark_node if we were given a\n      pointer to member, so it's cool to check for this here.  */\n-  else if (TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n+  else if (TYPE_PTR_TO_MEMBER_P (type))\n     error (\"invalid use of `%s' on pointer to member\", errorstring);\n   else if (pointer != error_mark_node)\n     {\n@@ -3010,7 +2767,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       /* Subtraction of two similar pointers.\n \t We must subtract them as integers, then divide by object size.  */\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n-\t  && comp_target_types (type0, type1, 1))\n+\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (type0),\n+\t\t\t\t\t\t\tTREE_TYPE (type1)))\n \treturn pointer_diff (op0, op1, common_type (type0, type1));\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n@@ -3172,12 +2930,15 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n \t      || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n-      else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n+      else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n+\t       || (TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)))\n \tresult_type = composite_pointer_type (type0, type1, op0, op1,\n \t\t\t\t\t      \"comparison\");\n-      else if (code0 == POINTER_TYPE && null_ptr_cst_p (op1))\n+      else if ((code0 == POINTER_TYPE || TYPE_PTRMEM_P (type0))\n+\t       && null_ptr_cst_p (op1))\n \tresult_type = type0;\n-      else if (code1 == POINTER_TYPE && null_ptr_cst_p (op0))\n+      else if ((code1 == POINTER_TYPE || TYPE_PTRMEM_P (type1))\n+\t       && null_ptr_cst_p (op0))\n \tresult_type = type1;\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -3656,8 +3417,6 @@ pointer_diff (register tree op0, register tree op1, register tree ptrtype)\n \tpedwarn (\"ISO C++ forbids using pointer to a function in subtraction\");\n       if (TREE_CODE (target_type) == METHOD_TYPE)\n \tpedwarn (\"ISO C++ forbids using pointer to a method in subtraction\");\n-      if (TREE_CODE (target_type) == OFFSET_TYPE)\n-\tpedwarn (\"ISO C++ forbids using pointer to a member in subtraction\");\n     }\n \n   /* First do the subtraction as integers;\n@@ -3671,12 +3430,9 @@ pointer_diff (register tree op0, register tree op1, register tree ptrtype)\n   if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n     error (\"invalid use of a pointer to an incomplete type in pointer arithmetic\");\n \n-  op1 = ((TREE_CODE (target_type) == VOID_TYPE\n-\t  || TREE_CODE (target_type) == FUNCTION_TYPE\n-\t  || TREE_CODE (target_type) == METHOD_TYPE\n-\t  || TREE_CODE (target_type) == OFFSET_TYPE)\n-\t ? integer_one_node\n-\t : size_in_bytes (target_type));\n+  op1 = (TYPE_PTROB_P (ptrtype) \n+\t ? size_in_bytes (target_type)\n+\t : integer_one_node);\n \n   /* Do the division.  */\n \n@@ -3999,7 +3755,6 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n \tif (TREE_CODE (argtype) == POINTER_TYPE)\n \t  {\n-\t    enum tree_code tmp = TREE_CODE (TREE_TYPE (argtype));\n \t    tree type = complete_type (TREE_TYPE (argtype));\n \t    \n \t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n@@ -4008,8 +3763,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t  || code == POSTINCREMENT_EXPR)\n \t\t\t ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n \t    else if ((pedantic || warn_pointer_arith)\n-\t\t     && (tmp == FUNCTION_TYPE || tmp == METHOD_TYPE\n-\t\t\t || tmp == VOID_TYPE || tmp == OFFSET_TYPE))\n+\t\t     && !TYPE_PTROB_P (argtype))\n \t      pedwarn (\"ISO C++ forbids %sing a pointer of type `%T'\",\n \t\t\t  ((code == PREINCREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)\n@@ -4072,13 +3826,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\terror (\"invalid use of `--' on bool variable `%D'\", arg);\n \t\treturn error_mark_node;\n \t      }\n-#if 0\n-\t    /* This will only work if someone can convince Kenner to accept\n-\t       my patch to expand_increment. (jason)  */\n-\t    val = build (code, TREE_TYPE (arg), arg, inc);\n-#else\n \t    val = boolean_increment (code, arg);\n-#endif\n \t  }\n \telse\n \t  val = build (code, TREE_TYPE (arg), arg, inc);\n@@ -4092,6 +3840,10 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t regardless of NOCONVERT.  */\n \n       argtype = lvalue_type (arg);\n+\n+      if (TREE_CODE (arg) == OFFSET_REF)\n+\tgoto offset_ref;\n+\n       if (TREE_CODE (argtype) == REFERENCE_TYPE)\n \t{\n \t  arg = build1\n@@ -4183,9 +3935,10 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t \"  Say `&%T::%D'\",\n \t\t\t base, name);\n \t    }\n-\t  arg = build_offset_ref (base, name);\n+\t  arg = build_offset_ref (base, name, /*address_p=*/true);\n         }\n-        \n+\n+    offset_ref:        \n       if (type_unknown_p (arg))\n \treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n \t\n@@ -4338,11 +4091,8 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n \n   if (TREE_CODE (TREE_TYPE (arg)) == FUNCTION_TYPE\n       || TREE_CODE (TREE_TYPE (arg)) == METHOD_TYPE\n-      || TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n+      || TREE_CODE (arg) == OFFSET_REF)\n     {\n-      /* The representation of something of type OFFSET_TYPE\n-\t is really the representation of a pointer to it.\n-\t Here give the representation its true type.  */\n       tree t;\n \n       my_friendly_assert (TREE_CODE (arg) != SCOPE_REF, 313);\n@@ -4599,14 +4349,16 @@ build_compound_expr (tree list)\n }\n \n /* Issue an error message if casting from SRC_TYPE to DEST_TYPE casts\n-   away constness.  */\n+   away constness.  DESCRIPTION explains what operation is taking\n+   place.  */\n \n static void\n-check_for_casting_away_constness (tree src_type, tree dest_type)\n+check_for_casting_away_constness (tree src_type, tree dest_type,\n+\t\t\t\t  const char *description)\n {\n   if (casts_away_constness (src_type, dest_type))\n-    error (\"static_cast from type `%T' to type `%T' casts away constness\",\n-\t   src_type, dest_type);\n+    error (\"%s from type `%T' to type `%T' casts away constness\",\n+\t   description, src_type, dest_type);\n }\n \n /* Return an expression representing static_cast<TYPE>(EXPR).  */\n@@ -4726,7 +4478,7 @@ build_static_cast (tree type, tree expr)\n     {\n       tree base;\n \n-      check_for_casting_away_constness (intype, type);\n+      check_for_casting_away_constness (intype, type, \"static_cast\");\n       base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype), \n \t\t\t  ba_check | ba_quiet, NULL);\n       return build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false);\n@@ -4758,15 +4510,18 @@ build_static_cast (tree type, tree expr)\n \t}\n       if (can_convert (t1, t2))\n \t{\n-\t  check_for_casting_away_constness (intype, type);\n+\t  check_for_casting_away_constness (intype, type, \"static_cast\");\n \t  if (TYPE_PTRMEM_P (type))\n \t    {\n+\t      tree delta;\n+\n \t      if (TREE_CODE (expr) == PTRMEM_CST)\n \t\texpr = cplus_expand_constant (expr);\n-\t      expr = cp_build_binary_op (PLUS_EXPR, \n-\t\t\t\t\t cp_convert (ptrdiff_type_node, expr),\n-\t\t\t\t\t get_delta_difference (c1, c2, \n-\t\t\t\t\t\t\t       /*force=*/1));\n+\t      delta = get_delta_difference (c1, c2, /*force=*/1);\n+\t      if (!integer_zerop (delta))\n+\t\texpr = cp_build_binary_op (PLUS_EXPR, \n+\t\t\t\t\t   build_nop (ptrdiff_type_node, expr),\n+\t\t\t\t\t   delta);\n \t      return build_nop (type, expr);\n \t    }\n \t  else\n@@ -4785,7 +4540,7 @@ build_static_cast (tree type, tree expr)\n       && VOID_TYPE_P (TREE_TYPE (intype))\n       && TYPE_PTROB_P (type))\n     {\n-      check_for_casting_away_constness (intype, type);\n+      check_for_casting_away_constness (intype, type, \"static_cast\");\n       return build_nop (type, expr);\n     }\n \n@@ -4856,10 +4611,7 @@ build_reinterpret_cast (tree type, tree expr)\n   else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n-      if (! comp_ptr_ttypes_reinterpret (TREE_TYPE (type), TREE_TYPE (intype)))\n-\tpedwarn (\"reinterpret_cast from `%T' to `%T' casts away const (or volatile)\",\n-\t\t    intype, type);\n-\n+      check_for_casting_away_constness (intype, type, \"reinterpret_cast\");\n       expr = decl_constant_value (expr);\n       return fold (build1 (NOP_EXPR, type, expr));\n     }\n@@ -4932,8 +4684,9 @@ build_const_cast (tree type, tree expr)\n \t  return convert_from_reference (expr);\n \t}\n     }\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && TREE_CODE (intype) == POINTER_TYPE\n+  else if (((TREE_CODE (type) == POINTER_TYPE\n+\t     && TREE_CODE (intype) == POINTER_TYPE)\n+\t    || (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype)))\n \t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n     return cp_convert (type, expr);\n \n@@ -5048,11 +4801,11 @@ build_c_cast (tree type, tree expr)\n                 otype, type);\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n-      && TREE_CODE (otype) == POINTER_TYPE\n+      && TYPE_PTR_P (otype)\n       && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n     warning (\"cast from pointer to integer of different size\");\n \n-  if (TREE_CODE (type) == POINTER_TYPE\n+  if (TYPE_PTR_P (type)\n       && TREE_CODE (otype) == INTEGER_TYPE\n       && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n       /* Don't warn about converting any constant.  */\n@@ -5785,13 +5538,9 @@ static tree\n convert_for_assignment (tree type, tree rhs,\n \t\t\tconst char *errtype, tree fndecl, int parmnum)\n {\n-  register enum tree_code codel = TREE_CODE (type);\n   register tree rhstype;\n   register enum tree_code coder;\n \n-  if (codel == OFFSET_TYPE)\n-    abort ();\n-\n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n@@ -6266,7 +6015,7 @@ check_return_expr (tree retval)\n static int\n comp_ptr_ttypes_real (tree to, tree from, int constp)\n {\n-  int to_more_cv_qualified = 0;\n+  bool to_more_cv_qualified = false;\n \n   for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n     {\n@@ -6289,8 +6038,7 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n \t    {\n \t      if (constp == 0)\n \t\treturn 0;\n-\t      else\n-\t\t++to_more_cv_qualified;\n+\t      to_more_cv_qualified = true;\n \t    }\n \n \t  if (constp > 0)\n@@ -6369,40 +6117,6 @@ comp_ptr_ttypes_const (tree to, tree from)\n     }\n }\n \n-/* Like comp_ptr_ttypes, for reinterpret_cast.  */\n-\n-static int\n-comp_ptr_ttypes_reinterpret (tree to, tree from)\n-{\n-  int constp = 1;\n-\n-  for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n-    {\n-      if (TREE_CODE (from) == OFFSET_TYPE)\n-\tfrom = TREE_TYPE (from);\n-      if (TREE_CODE (to) == OFFSET_TYPE)\n-\tto = TREE_TYPE (to);\n-\n-      /* Const and volatile mean something different for function types,\n-\t so the usual checks are not appropriate.  */\n-      if (TREE_CODE (from) != FUNCTION_TYPE && TREE_CODE (from) != METHOD_TYPE\n-\t  && TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n-\t{\n-\t  if (!at_least_as_qualified_p (to, from))\n-\t    return 0;\n-\n-\t  if (! constp\n-\t      && !at_least_as_qualified_p (from, to))\n-\t    return 0;\n-\t  constp &= TYPE_READONLY (to);\n-\t}\n-\n-      if (TREE_CODE (from) != POINTER_TYPE\n-\t  || TREE_CODE (to) != POINTER_TYPE)\n-\treturn 1;\n-    }\n-}\n-\n /* Returns the type qualifiers for this type, including the qualifiers on the\n    elements for an array type.  */\n \n@@ -6442,9 +6156,9 @@ casts_away_constness_r (tree *t1, tree *t2)\n      pointer to member level is ignored when determining if a const\n      cv-qualifier has been cast away.  */\n   if (TYPE_PTRMEM_P (*t1))\n-    *t1 = build_pointer_type (TREE_TYPE (TREE_TYPE (*t1)));\n+    *t1 = build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (*t1));\n   if (TYPE_PTRMEM_P (*t2))\n-    *t2 = build_pointer_type (TREE_TYPE (TREE_TYPE (*t2)));\n+    *t2 = build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (*t2));\n \n   /* [expr.const.cast]\n \n@@ -6513,8 +6227,8 @@ casts_away_constness (tree t1, tree t2)\n        \"pointer to T1\" to the type \"pointer to T2\" casts away\n        constness.  */\n     return casts_away_constness\n-      (build_pointer_type (TREE_TYPE (TREE_TYPE (t1))),\n-       build_pointer_type (TREE_TYPE (TREE_TYPE (t2))));\n+      (build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (t1)),\n+       build_pointer_type (TYPE_PTRMEM_POINTED_TO_TYPE (t2)));\n \n   /* Casting away constness is only something that makes sense for\n      pointer or reference types.  */\n@@ -6532,23 +6246,6 @@ casts_away_constness (tree t1, tree t2)\n   return false;\n }\n \n-/* Returns TYPE with its cv qualifiers removed\n-   TYPE is T cv* .. *cv where T is not a pointer type,\n-   returns T * .. *. (If T is an array type, then the cv qualifiers\n-   above are those of the array members.)  */\n-\n-static tree\n-strip_all_pointer_quals (tree type)\n-{\n-  if (TREE_CODE (type) == POINTER_TYPE)\n-    return build_pointer_type (strip_all_pointer_quals (TREE_TYPE (type)));\n-  else if (TREE_CODE (type) == OFFSET_TYPE)\n-    return build_offset_type (TYPE_OFFSET_BASETYPE (type),\n-\t\t\t      strip_all_pointer_quals (TREE_TYPE (type)));\n-  else\n-    return TYPE_MAIN_VARIANT (type);\n-}\n-\n /* If T is a REFERENCE_TYPE return the type to which T refers.\n    Otherwise, return T itself.  */\n "}, {"sha": "8d1209c998c8cdcec01e6fb81e051ebeb05231bd", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -506,7 +506,7 @@ digest_init (tree type, tree init, tree* tail)\n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n       || code == ENUMERAL_TYPE || code == REFERENCE_TYPE\n       || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n-      || TYPE_PTRMEMFUNC_P (type))\n+      || TYPE_PTR_TO_MEMBER_P (type))\n     {\n       if (raw_constructor)\n \t{\n@@ -1070,8 +1070,7 @@ build_m_component_ref (tree datum, tree component)\n     return error_mark_node;\n \n   ptrmem_type = TREE_TYPE (component);\n-  if (!TYPE_PTRMEM_P (ptrmem_type) \n-      && !TYPE_PTRMEMFUNC_P (ptrmem_type))\n+  if (!TYPE_PTR_TO_MEMBER_P (ptrmem_type))\n     {\n       error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", \n \t     component, ptrmem_type);\n@@ -1107,10 +1106,12 @@ build_m_component_ref (tree datum, tree component)\n       type = cp_build_qualified_type (type,\n \t\t\t\t      (cp_type_quals (type)  \n \t\t\t\t       | cp_type_quals (TREE_TYPE (datum))));\n-\n-      datum = build_base_path (PLUS_EXPR, build_address (datum), binfo, 1);\n-      component = cp_convert (ptrdiff_type_node, component);\n-      datum = build (PLUS_EXPR, build_pointer_type (type), datum, component);\n+      /* Build an expression for \"object + offset\" where offset is the\n+\t value stored in the pointer-to-data-member.  */\n+      datum = build (PLUS_EXPR, build_pointer_type (type),\n+\t\t     build_base_path (PLUS_EXPR, build_address (datum), \n+\t\t\t\t      binfo, 1),\n+\t\t     build_nop (ptrdiff_type_node, component));\n       return build_indirect_ref (datum, 0);\n     }\n   else"}, {"sha": "114aaae44c8a1992b2ef954e3e3c395c5724f918", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -193,7 +193,8 @@ force_fit_type (tree t, int overflow)\n   low = TREE_INT_CST_LOW (t);\n   high = TREE_INT_CST_HIGH (t);\n \n-  if (POINTER_TYPE_P (TREE_TYPE (t)))\n+  if (POINTER_TYPE_P (TREE_TYPE (t))\n+      || TREE_CODE (TREE_TYPE (t)) == OFFSET_TYPE)\n     prec = POINTER_SIZE;\n   else\n     prec = TYPE_PRECISION (TREE_TYPE (t));"}, {"sha": "847cf7719f9007ced7b92288854d1019fd194b7b", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ac359a6d661735a213b7b6b8436e615e768788/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a5ac359a6d661735a213b7b6b8436e615e768788", "patch": "@@ -3695,6 +3695,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n     case ENUMERAL_TYPE:\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n       if (! assemble_integer (expand_expr (exp, NULL_RTX, VOIDmode,\n \t\t\t\t\t   EXPAND_INITIALIZER),\n \t\t\t      size, align, 0))"}]}