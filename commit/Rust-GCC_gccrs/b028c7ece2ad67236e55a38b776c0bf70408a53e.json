{"sha": "b028c7ece2ad67236e55a38b776c0bf70408a53e", "node_id": "C_kwDOANBUbNoAKGIwMjhjN2VjZTJhZDY3MjM2ZTU1YTM4Yjc3NmMwYmY3MDQwOGE1M2U", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-06-14T11:11:38Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-06-14T15:30:31Z"}, "message": "gccrs: we can't check the bounds involving empty placeholder types\n\nWe use placeholders for assoicated types on traits but if we are unifying\ntypes against a placeholder its not possible to check the bounds as the\nplaceholder does not have enough information yet at this point to determine\nif bounds will or won't be satisfied. That check will occur when associated\ntypes and generics are setup.\n\nFixes #2036\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-unify.cc (UnifyRules::go): dont check bounds on placeholders\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-2036.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "75df66e6a72f5e4d0dc0c0c811ad88239eb1827e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75df66e6a72f5e4d0dc0c0c811ad88239eb1827e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b028c7ece2ad67236e55a38b776c0bf70408a53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b028c7ece2ad67236e55a38b776c0bf70408a53e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b028c7ece2ad67236e55a38b776c0bf70408a53e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b028c7ece2ad67236e55a38b776c0bf70408a53e/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1e10de0014401a1e31ba87003cdcf157439cae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e10de0014401a1e31ba87003cdcf157439cae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e10de0014401a1e31ba87003cdcf157439cae3"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "ea1b58278ae981d4c9b7581a057a2424e7c2af12", "filename": "gcc/rust/typecheck/rust-unify.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b028c7ece2ad67236e55a38b776c0bf70408a53e/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b028c7ece2ad67236e55a38b776c0bf70408a53e/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-unify.cc?ref=b028c7ece2ad67236e55a38b776c0bf70408a53e", "patch": "@@ -151,7 +151,11 @@ UnifyRules::go ()\n \t      rtype->debug_str ().c_str ());\n \n   // check bounds\n-  bool should_check_bounds = !ltype->is_equal (*rtype);\n+  bool ltype_is_placeholder = ltype->get_kind () == TyTy::TypeKind::PLACEHOLDER;\n+  bool rtype_is_placeholder = rtype->get_kind () == TyTy::TypeKind::PLACEHOLDER;\n+  bool types_equal = ltype->is_equal (*rtype);\n+  bool should_check_bounds\n+    = !types_equal && !(ltype_is_placeholder || rtype_is_placeholder);\n   if (should_check_bounds)\n     {\n       if (ltype->num_specified_bounds () > 0)"}, {"sha": "d1459752ea515e05a25d6080289c19bcf20f8fdb", "filename": "gcc/testsuite/rust/compile/issue-2036.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b028c7ece2ad67236e55a38b776c0bf70408a53e/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2036.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b028c7ece2ad67236e55a38b776c0bf70408a53e/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2036.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2036.rs?ref=b028c7ece2ad67236e55a38b776c0bf70408a53e", "patch": "@@ -0,0 +1,36 @@\n+trait Hash<H> {\n+    fn hash2(&self, hasher: &H) -> u64;\n+}\n+\n+trait Stream {\n+    fn input(&mut self, bytes: &[u8]);\n+    fn result(&self) -> u64;\n+}\n+\n+trait StreamHasher {\n+    type S: Stream;\n+    fn stream(&self) -> Self::S;\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+\n+trait StreamHash<H: StreamHasher>: Hash<H> {\n+    fn input_stream(&self, stream: &mut H::S);\n+}\n+\n+impl<H: StreamHasher> Hash<H> for u8 {\n+    fn hash2(&self, hasher: &H) -> u64 {\n+        let mut stream = hasher.stream();\n+        self.input_stream(&mut stream);\n+        // { dg-error \"type annotations needed\" \"\" { target *-*-* } .-1 }\n+        Stream::result(&stream)\n+    }\n+}\n+\n+impl<H: StreamHasher> StreamHash<H> for u8 {\n+    fn input_stream(&self, stream: &mut H::S) {\n+        Stream::input(stream, &[*self]);\n+    }\n+}\n+\n+fn main() {}"}]}