{"sha": "4e95268d59d17d5d58d60f2067a79a215d65db73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU5NTI2OGQ1OWQxN2Q1ZDU4ZDYwZjIwNjdhNzlhMjE1ZDY1ZGI3Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-06-16T06:08:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-06-16T06:08:49Z"}, "message": "re PR c++/27689 (function template incorrectly selected as candidate)\n\n\tPR c++/27689\n\t* cp-tree.h (CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P): New\n\tmacro.\n\t* pt.c (unify): Use it.\n\tPR c++/27689\n\t* g++.dg/template/ttp18.C: New test.\n\t* g++.dg/template/ttp19.C: Likewise.\n\nFrom-SVN: r114703", "tree": {"sha": "2cd5e1744fea5e85f23366a250ecce719577ca85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cd5e1744fea5e85f23366a250ecce719577ca85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e95268d59d17d5d58d60f2067a79a215d65db73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e95268d59d17d5d58d60f2067a79a215d65db73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e95268d59d17d5d58d60f2067a79a215d65db73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e95268d59d17d5d58d60f2067a79a215d65db73/comments", "author": null, "committer": null, "parents": [{"sha": "2954333afc6cbb12f5628368b5f557a5730d1242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2954333afc6cbb12f5628368b5f557a5730d1242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2954333afc6cbb12f5628368b5f557a5730d1242"}], "stats": {"total": 104, "additions": 77, "deletions": 27}, "files": [{"sha": "bb1ea7f9ffc45115cf4493717d887c3c14d1ba23", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4e95268d59d17d5d58d60f2067a79a215d65db73", "patch": "@@ -1,5 +1,10 @@\n 2006-06-15  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/27689\n+\t* cp-tree.h (CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P): New\n+\tmacro.\n+\t* pt.c (unify): Use it.\n+\n \tPR c++/27666\n \t* call.c (build_conditional_expr): Robustify.\n "}, {"sha": "e9f28a6f6e4e65aa13c5f04d4708cb8d994c9570", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4e95268d59d17d5d58d60f2067a79a215d65db73", "patch": "@@ -1117,14 +1117,6 @@ struct lang_type GTY(())\n \n #endif /* ENABLE_TREE_CHECKING */\n \n-/* Indicates whether or not (and how) a template was expanded for this class.\n-     0=no information yet/non-template class\n-     1=implicit template instantiation\n-     2=explicit template specialization\n-     3=explicit template instantiation  */\n-#define CLASSTYPE_USE_TEMPLATE(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->use_template)\n-\n /* Fields used for storing information before the class is defined.\n    After the class is defined, these fields hold other information.  */\n \n@@ -2096,23 +2088,24 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n   (DECL_LANG_SPECIFIC (DECL)->decl_flags.deferred)\n \n /* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL or\n-   TEMPLATE_DECL, the entity is a template specialization.  In that\n-   case, DECL_TEMPLATE_INFO is a TREE_LIST, whose TREE_PURPOSE is the\n-   TEMPLATE_DECL of which this entity is a specialization.  The TREE_\n-   TREE_VALUE is the template arguments used to specialize the\n-   template.\n-\n-   In general, DECL_TEMPLATE_INFO is non-NULL only if\n-   DECL_USE_TEMPLATE is nonzero.  However, for friends, we sometimes\n-   have DECL_TEMPLATE_INFO even when DECL_USE_TEMPLATE is zero.\n+   TEMPLATE_DECL, the entity is either a template specialization (if\n+   DECL_USE_TEMPLATE is non-zero) or the abstract instance of the\n+   template itself.\n+\n+   In either case, DECL_TEMPLATE_INFO is a TREE_LIST, whose\n+   TREE_PURPOSE is the TEMPLATE_DECL of which this entity is a\n+   specialization or abstract instance.  The TREE_VALUE is the\n+   template arguments used to specialize the template.\n+   \n    Consider:\n \n       template <typename T> struct S { friend void f(T) {} };\n \n    In this case, S<int>::f is, from the point of view of the compiler,\n    an instantiation of a template -- but, from the point of view of\n    the language, each instantiation of S results in a wholly unrelated\n-   global function f.  */\n+   global function f.  In this case, DECL_TEMPLATE_INFO for S<int>::f\n+   will be non-NULL, but DECL_USE_TEMPLATE will be zero.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n   (DECL_LANG_SPECIFIC (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK (NODE)) \\\n    ->decl_flags.u.template_info)\n@@ -2240,6 +2233,16 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    are always the full set of arguments required to instantiate this\n    declaration from the most general template specialized here.  */\n #define DECL_TI_ARGS(NODE)\t    TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n+\n+/* The TEMPLATE_DECL associated with NODE, a class type.  Even if NODE\n+   will be generated from a partial specialization, the TEMPLATE_DECL\n+   referred to here will be the original template.  For example,\n+   given:\n+\n+      template <typename T> struct S {};\n+      template <typename T> struct S<T*> {};\n+      \n+   the CLASSTPYE_TI_TEMPLATE for S<int*> will be S, not the S<T*>.  */\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n \n@@ -2252,7 +2255,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n \t\t\t\t      (CLASSTYPE_TI_TEMPLATE ((TYPE))))) \\\n    : (TYPE))\n \n-/* Like DECL_TI_TEMPLATE, but for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n+/* Like CLASS_TI_TEMPLATE, but also works for ENUMERAL_TYPEs.  */\n #define TYPE_TI_TEMPLATE(NODE)\t\t\t\\\n   (TI_TEMPLATE (TYPE_TEMPLATE_INFO (NODE)))\n \n@@ -2845,17 +2848,38 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n /* Returns nonzero if NODE is a primary template.  */\n #define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == (NODE))\n \n-/* Indicates whether or not (and how) a template was expanded for this\n-   FUNCTION_DECL or VAR_DECL.\n-     0=normal declaration, e.g. int min (int, int);\n-     1=implicit template instantiation\n-     2=explicit template specialization, e.g. int min<int> (int, int);\n-     3=explicit template instantiation, e.g. template int min<int> (int, int);\n+/* Non-zero iff NODE is a specialization of a template.  The value\n+   indicates the type of specializations:\n+\n+     1=implicit instantiation\n+     2=explicit specialization, e.g. int min<int> (int, int);\n+     3=explicit instantiation, e.g. template int min<int> (int, int);\n \n-   If DECL_USE_TEMPLATE is nonzero, then DECL_TEMPLATE_INFO will also\n+   Note that NODE will be marked as a specialization even if the\n+   template it is instantiating is not a primary template.  For\n+   example, given:\n+\n+     template <typename T> struct O { \n+       void f();\n+       struct I {}; \n+     };\n+    \n+   both O<int>::f and O<int>::I will be marked as instantiations.\n+\n+   If DECL_USE_TEMPLATE is non-zero, then DECL_TEMPLATE_INFO will also\n    be non-NULL.  */\n #define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.use_template)\n \n+/* Like DECL_USE_TEMPLATE, but for class types.  */\n+#define CLASSTYPE_USE_TEMPLATE(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->use_template)\n+\n+/* True if NODE is a specialization of a primary template.  */\n+#define CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P(NODE)\t\\\n+  (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n+   && CLASSTYPE_USE_TEMPLATE (NODE)\t\t\t\t\\\n+   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (arg)))  \n+\n #define DECL_TEMPLATE_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) & 1)\n #define CLASSTYPE_TEMPLATE_INSTANTIATION(NODE) \\\n   (CLASSTYPE_USE_TEMPLATE (NODE) & 1)"}, {"sha": "79183f55ed0ae0f76fab868d01c52471010e83b8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4e95268d59d17d5d58d60f2067a79a215d65db73", "patch": "@@ -10166,7 +10166,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  /* ARG must be constructed from a template class or a template\n \t     template parameter.  */\n \t  if (TREE_CODE (arg) != BOUND_TEMPLATE_TEMPLATE_PARM\n-\t      && (TREE_CODE (arg) != RECORD_TYPE || !CLASSTYPE_TEMPLATE_INFO (arg)))\n+\t      && !CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P (arg))\n \t    return 1;\n \n \t  {"}, {"sha": "313a39f158581c1adf82ddf6397a67cedcfb1d55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e95268d59d17d5d58d60f2067a79a215d65db73", "patch": "@@ -1,5 +1,9 @@\n 2006-06-15  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/27689\n+\t* g++.dg/template/ttp18.C: New test.\n+\t* g++.dg/template/ttp19.C: Likewise.\n+\n \tPR c++/27666\n \t* g++.dg/expr/cond9.C: New test.\n "}, {"sha": "095c07fb9270e324ad9c12a48f3e381b953ba195", "filename": "gcc/testsuite/g++.dg/template/ttp18.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp18.C?ref=4e95268d59d17d5d58d60f2067a79a215d65db73", "patch": "@@ -0,0 +1,10 @@\n+template <template <typename> class T>\n+void f(T<int>) {}\n+\n+template <typename T>\n+union U {};\n+\n+void g() {\n+  f(U<int>());\n+}\n+"}, {"sha": "12a37c9cd59b6996aae989506df411c8f0b8f4fb", "filename": "gcc/testsuite/g++.dg/template/ttp19.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e95268d59d17d5d58d60f2067a79a215d65db73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp19.C?ref=4e95268d59d17d5d58d60f2067a79a215d65db73", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/27689\n+\n+void f (...);\n+template <template <typename> class F, typename T> void f (F<T>);\n+template <typename> struct foo { struct bar {}; };\n+void g (foo<int>::bar x) { f(x); }\n+"}]}