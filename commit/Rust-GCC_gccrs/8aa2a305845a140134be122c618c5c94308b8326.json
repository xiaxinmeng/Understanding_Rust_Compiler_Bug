{"sha": "8aa2a305845a140134be122c618c5c94308b8326", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhMmEzMDU4NDVhMTQwMTM0YmUxMjJjNjE4YzVjOTQzMDhiODMyNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-04-21T01:19:27Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-04-21T01:19:27Z"}, "message": "Completely rewritten.\n\nFrom-SVN: r9423", "tree": {"sha": "de969837cc8dacb1251b2a1cfb88fc0e40f48039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de969837cc8dacb1251b2a1cfb88fc0e40f48039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aa2a305845a140134be122c618c5c94308b8326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa2a305845a140134be122c618c5c94308b8326", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aa2a305845a140134be122c618c5c94308b8326", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa2a305845a140134be122c618c5c94308b8326/comments", "author": null, "committer": null, "parents": [{"sha": "058f9bb58602e8703949104ff75f86af9a4f354f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058f9bb58602e8703949104ff75f86af9a4f354f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058f9bb58602e8703949104ff75f86af9a4f354f"}], "stats": {"total": 1933, "additions": 708, "deletions": 1225}, "files": [{"sha": "813d29a280a87359670b97e9978f36eb01d43e86", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 708, "deletions": 1225, "changes": 1933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa2a305845a140134be122c618c5c94308b8326/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa2a305845a140134be122c618c5c94308b8326/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8aa2a305845a140134be122c618c5c94308b8326", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for Hitachi Super-H.\n-   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n \n@@ -17,42 +17,41 @@\n    along with GNU CC; see the file COPYING.  If not, write to\n    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-/* Contributed by Steve Chamberlain (sac@cygnus.com).  */\n+/* Contributed by Steve Chamberlain (sac@cygnus.com).\n+   Improved by Jim Wilson (wilson@cygnus.com).  */\n \n-#include <stdio.h>\n-#include \"assert.h\"\n #include \"config.h\"\n+\n+#include <stdio.h>\n+\n #include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-flags.h\"\n #include \"tree.h\"\n-#include \"output.h\"\n-\n-#include \"insn-attr.h\"\n #include \"flags.h\"\n-#include \"obstack.h\"\n+#include \"insn-flags.h\"\n #include \"expr.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"output.h\"\n \n #define MSW (TARGET_LITTLE_ENDIAN ? 1 : 0)\n #define LSW (TARGET_LITTLE_ENDIAN ? 0 : 1)\n \n+/* This is set by #pragma interrupt and #pragma trapa, and causes gcc to\n+   output code for the next function appropriate for an interrupt handler.  */\n int pragma_interrupt;\n-int pragma_trapa;\n \n+/* This is set by #pragma trapa, and is similar to the above, except that\n+   the compiler doesn't emit code to preserve all registers.  */\n+static int pragma_trapa;\n+\n+/* This is used for communication between SETUP_INCOMING_VARARGS and\n+   sh_expand_prologue.  */\n int current_function_anonymous_args;\n \n+/* Global variables from toplev.c and final.c that are used within, but\n+   not declared in any header file.  */\n extern char *version_string;\n-\n-static rtx shiftsyms[32];\n-\n-char *max_si;\n-char *max_hi;\n-int  max_count_si;\n-int  max_count_hi;\n+extern int *insn_addresses;\n \n /* Global variables for machine-dependent things. */\n \n@@ -91,168 +90,6 @@ enum reg_class reg_class_from_letter[] =\n   /* u */ NO_REGS, /* v */ NO_REGS, /* w */ NO_REGS, /* x */ MAC_REGS,\n   /* y */ NO_REGS, /* z */ R0_REGS\n };\n-\n-/* Value is 1 if register/mode pair is acceptable on SH.  Even\n-   registers can hold DIs and DF values. The rest can only hold\n-   SI's efficiently.  */\n-\n-#define REG_ODD \\\n- (  (1 << (int) QImode)  | (1 << (int) HImode) | (1 << (int) SImode)\t\\\n-  | (1 << (int) QFmode)  | (1 << (int) HFmode) | (1 << (int) SFmode)\t\\\n-  | (1 << (int) CQImode) | (1 << (int) CHImode)| (1<< (int)DFmode) | (1<<(int)DImode))\n-\n-#define REG_EVEN \\\n-  (REG_ODD | (1 << (int) CSImode) | (1 << (int) SCmode))\n-\n-#define SI_ONLY (1<<(int)SImode)\n-\n-int hard_regno_mode_ok[] =\n-{\n-  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n-  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n-  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n-  REG_EVEN, REG_ODD, REG_EVEN, REG_ODD,\n-  REG, 0, SI_ONLY, SI_ONLY,\n-  SI_ONLY, SI_ONLY\n-};\n-\n-/* Local label counter, used for constants in the pool and inside\n-   pattern branches.  */\n-static int lf = 100;\n-\n-\n-/* Number of bytes pushed for anonymous args, used to pass information\n-   between expand_prologue and expand_epilogue.  */\n-static int extra_push;\n-\f\n-void\n-push (rn)\n-     int rn;\n-{\n-  rtx x ;\n-  x=  emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n-  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n-\t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n-}\n-\n-void\n-pop (rn)\n-     int rn;\n-{\n-  rtx x;\n-  x =  emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n-  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n-\t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n-}\n-\n-/* Adjust the stack and return the number of bytes taken to do it.  */\n-static rtx lastreg;\n-int lastval;\n-static void\n-output_stack_adjust (size)\n-     int size;\n-{\n-  if (size)\n-    {\n-      rtx val = GEN_INT (size);\n-      rtx insn;\n-\n-      if (!CONST_OK_FOR_I (size))\n-\t{\n-\t  lastreg = gen_rtx (REG, SImode, 3);\n-\t  lastval = size;\n-\t  emit_insn (gen_movsi (lastreg, val));\n-\t  val = lastreg;\n-\n-\t}\n-\n-      insn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n-      emit_insn (insn);\n-    }\n-}\n-\n-\n-/* Generate code to push the regs specified in the mask, and return\n-   the number of bytes the insns take.  */\n-\n-static void\n-push_regs (mask)\n-     int mask;\n-{\n-  int i;\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (mask & (1 << i))\n-\t{\n-\t  push (i);\n-\t}\n-    }\n-}\n-\n-\n-/* Print an instruction which would have gone into a delay slot after\n-   another instruction, but couldn't because the other instruction expanded\n-   into a sequence where putting the slot insn at the end wouldn't work.  */\n-\n-static void\n-print_slot (insn)\n-     rtx insn;\n-{\n-  final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file, optimize, 0, 1);\n-\n-  INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n-}\n-\n-\n-/* Work out the registers which need to be saved, both as a mask and a\n-   count.\n-\n-   If doing a pragma interrupt function, then push all regs used by the function,\n-   and if we call another function (we can tell by looking at PR), make sure that all the\n-   regs it clobbers are safe too.  */\n-static int\n-calc_live_regs (count_ptr)\n-     int *count_ptr;\n-{\n-  int reg;\n-  int live_regs_mask = 0;\n-  int count = 0;\n-  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n-    {\n-      if (reg == ARG_POINTER_REGNUM)\n-\tcontinue;\n-      if (reg == T_REG)\n-\tcontinue;\n-      if (reg == GBR_REG)\n-\tcontinue;\n-\n-      if (pragma_interrupt && !pragma_trapa)\n-\t{\n-\t  /* Need to save all the regs ever live.  */\n-\t  if ((regs_ever_live[reg]\n-\t       || (call_used_regs[reg] && regs_ever_live[PR_REG]))\n-\t      && reg != 15)\n-\t    {\n-\t      live_regs_mask |= 1 << reg;\n-\t      count++;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Only push those regs which are used and need to be saved.  */\n-\t  if (regs_ever_live[reg] && !call_used_regs[reg])\n-\t    {\n-\t      count++;\n-\t      live_regs_mask |= (1 << reg);\n-\t    }\n-\t}\n-    }\n-\n-\n-  *count_ptr = count;\n-  return live_regs_mask;\n-}\n \f\n /* Print the operand address in x to the stream.  */\n \n@@ -266,40 +103,31 @@ print_operand_address (stream, x)\n     case REG:\n       fprintf (stream, \"@%s\", reg_names[REGNO (x)]);\n       break;\n+\n     case PLUS:\n       {\n \trtx base = XEXP (x, 0);\n \trtx index = XEXP (x, 1);\n \n-\tif (GET_CODE (base) != REG)\n-\t  {\n-\t    /* Ensure that BASE is a register (one of them must be).  */\n-\t    rtx temp = base;\n-\t    base = index;\n-\t    index = temp;\n-\t  }\n-\n \tswitch (GET_CODE (index))\n \t  {\n \t  case CONST_INT:\n-\t    fprintf (stream, \"@(%d,%s)\",\n-\t\t     INTVAL (index),\n+\t    fprintf (stream, \"@(%d,%s)\", INTVAL (index),\n \t\t     reg_names[REGNO (base)]);\n \t    break;\n \n \t  case REG:\n \t    fprintf (stream, \"@(r0,%s)\",\n \t\t     reg_names[MAX (REGNO (base), REGNO (index))]);\n-\n \t    break;\n \n \t  default:\n \t    debug_rtx (x);\n \t    abort ();\n \t  }\n       }\n-\n       break;\n+\n     case PRE_DEC:\n       fprintf (stream, \"@-%s\", reg_names[REGNO (XEXP (x, 0))]);\n       break;\n@@ -318,14 +146,12 @@ print_operand_address (stream, x)\n    according to modifier code.\n \n    '.'  print a .s if insn needs delay slot\n-   '#'  output a nop if there is nothing to put in the delay slot\n    '@'  print rte or rts depending upon pragma interruptness\n+   '#'  output a nop if there is nothing to put in the delay slot\n+   'O'  print a constant without the #\n    'R'  print the LSW of a dp value - changes if in little endian\n-   'T'  print the next word of a dp value - same as 'R' in big endian mode.\n    'S'  print the MSW of a dp value - changes if in little endian\n-   'O'  print a constant without the #\n-   'M'  print a constant as its negative\n-   'N'  print insides of a @++ or @-- o  */\n+   'T'  print the next word of a dp value - same as 'R' in big endian mode.  */\n \n void\n print_operand (stream, x, code)\n@@ -348,30 +174,16 @@ print_operand (stream, x, code)\n     case '#':\n       /* Output a nop if there's nothing in the delay slot.  */\n       if (dbr_sequence_length () == 0)\n-\t{\n-\t  fprintf (stream, \"\\n\\tnop\");\n-\t}\n+\tfprintf (stream, \"\\n\\tnop\");\n       break;\n     case 'O':\n       output_addr_const (stream, x);\n       break;\n-    case 'M':\n-      fprintf (asm_out_file, \"#%d\", -INTVAL (x));\n-      break;\n-    case 'N':\n-      fputs (reg_names[REGNO (XEXP (XEXP (x, 0), 0))], (stream));\n-      break;\n     case 'R':\n-      /* LSW of a double.  */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase REG:\n-\t  fputs (reg_names[REGNO (x) + LSW], (stream));\n-\t  break;\n-\tcase MEM:\n-\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x, LSW *4), 0));\n-\t  break;\n-\t}\n+      fputs (reg_names[REGNO (x) + LSW], (stream));\n+      break;\n+    case 'S':\n+      fputs (reg_names[REGNO (x) + MSW], (stream));\n       break;\n     case 'T':\n       /* Next word of a double.  */\n@@ -381,19 +193,8 @@ print_operand (stream, x, code)\n \t  fputs (reg_names[REGNO (x) + 1], (stream));\n \t  break;\n \tcase MEM:\n-\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x,1 *4), 0));\n-\t  break;\n-\t}\n-      break;\n-    case 'S':\n-      /* MSW of a double.  */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase REG:\n-\t  fputs (reg_names[REGNO (x) + MSW], (stream));\n-\t  break;\n-\tcase MEM:\n-\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x, MSW *4), 0));\n+\t  print_operand_address (stream,\n+\t\t\t\t XEXP (adj_offsettable_operand (x, 4), 0));\n \t  break;\n \t}\n       break;\n@@ -415,154 +216,6 @@ print_operand (stream, x, code)\n     }\n }\n \f\n-static int\n-sextb (x)\n-  int x;\n-{\n-  x &= 0xff;\n-  if (x > 127)\n-    {\n-      x = -256 + x;\n-    }\n-  return x;\n-}\n-\n-\n-\n-/* Take a move with integer constant source in OPERANDS, see if it can be generated by\n-   devious shifting.  If so, generate the instruction sequence and return 1, otherwise\n-   return 0.\n-\n-    OPERANDS[0] Destination register\n-    OPERANDS[1] Source constant\n-\n-   00000000 00000000 00000000 0NNNNNNNN simple load\n-   00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n-   00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n-   00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n-   00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n-   N0000000 00000000 00000000 00NNNNNNN load and rotate right\n-\n-   11111111 11111111 11111111 1NNNNNNNN simple load\n-   11111111 11111111 11111111 NNNNNNNN0 load and shift by 1\n-   11111111 11111111 1111111N NNNNNNN00 load and shift by 2\n-   11111111 11111111 1NNNNNNN 000000000 load and shift by 8\n-   11111111 1NNNNNNN 00000000 000000000 load and shift by 16\n-   N1111111 11111111 11111111 11NNNNNNN load and rotate right\n-\n-   00000000 00000000 00000000 1NNNNNNNN load and zero extend byte\n-   00000000 00000000 11111111 1NNNNNNNN load and zero extend word\n-\n-   ??? Can add cases using swap.b and swap.w.\n-   Can add cases using andi to get `1s 1s 1s 0NNNNNN1'.\n-   Can add many more cases for TARGET_CLEN3, but doubt their usefulness.  */\n-\n-/* ??? This function does not do anything useful, because the sequences\n-   it emits are later eliminated by combine.  */\n-\n-static int\n-synth_constant (operands, mode)\n-     rtx operands[];\n-     enum machine_mode mode;\n-{\n-  rtx dst;\n-  int i = INTVAL (operands[1]) & 0xffffffff;\n-\n-  if (CONST_OK_FOR_I (i))\n-    return 0;\n-\n-  if (TARGET_CLEN0 && mode != QImode)\n-    return 0;\n-\n-  if (mode != SImode)\n-    {\n-      if (reload_in_progress)\n-\treturn 0;\n-      dst = gen_reg_rtx (SImode);\n-    }\n-  else\n-    {\n-      dst = operands[0];\n-    }\n-\n-\n-  /* 00000000 00000000 11111111 1NNNNNNNN load and zero extend word.  */\n-  if ((i & 0xffffff80) == 0x0000ff80)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i)));\n-      emit_insn (gen_zero_extendhisi2 (dst, gen_lowpart (HImode, dst)));\n-    }\n-  /* 00000000 00000000 00000000 1NNNNNNNN load and zero extend byte.  */\n-  else if ((i & 0xffffff80) == 0x00000080)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i)));\n-      emit_insn (gen_zero_extendqisi2 (dst, gen_lowpart (QImode, dst)));\n-    }\n-  /* 00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n-     11111111 11111111 11111111 NNNNNNNN0 load and shift by 1.  */\n-  else if ((i & 0xffffff01) == 0\n-\t   || (i & 0xffffff01) == 0xffffff00)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i >> 1)));\n-      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (1)));\n-    }\n-  /* 00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n-     11111111 11111111 1111111N NNNNNNN00 load and shift by 2.  */\n-  else if ((i & 0xfffffe03) == 0\n-\t   || (i & 0xfffffe03) == 0xfffffe00)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i >> 2)));\n-      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (2)));\n-    }\n-  /* 00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n-     11111111 11111111 1NNNNNNN 000000000 load and shift by 8.  */\n-\n-  else if ((i & 0xffff80ff) == 0\n-\t   || (i & 0xffff80ff) == 0xffff8000)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n-      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (8)));\n-    }\n-  /* 00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n-     11111111 1NNNNNNN 00000000 000000000 load and shift by 16.  */\n-  else if ((i & 0xff80ffff) == 0x00000000\n-\t   || (i & 0xff80ffff) == 0xff800000)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i >> 16)));\n-      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (16)));\n-    }\n-  /* 00000000 00000000 0NNNNNNN 0NNNNNNNN load shift 8 and add.  */\n-  else if ((i & 0xffff8080) == 0 && TARGET_CLEN3)\n-    {\n-      emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n-      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (8)));\n-      emit_insn (gen_addsi3 (dst, dst, GEN_INT (i & 0x7f)));\n-    }\n-  else\n-    return 0;\n-\n-  if (mode == DImode)\n-    {\n-      /* Moving from SI to DI, we've got to zero out the high part.  */\n-\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (SUBREG, SImode, operands[0], 0),\n-\t\t\t  dst));\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (SUBREG, SImode, operands[0], 1),\n-\t\t\t  const0_rtx));\n-\n-    }\n-  else if (mode != SImode)\n-    {\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t  gen_rtx (SUBREG, mode, dst, 0)));\n-\n-    }\n-  return 1;\n-}\n-\n-\n /* Emit code to perform a block move.  Choose the best method.\n \n    OPERANDS[0] is the destination.\n@@ -577,240 +230,150 @@ expand_block_move (operands)\n   int align = INTVAL (operands[3]);\n   int constp = (GET_CODE (operands[2]) == CONST_INT);\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n-  enum machine_mode mode;\n-\n-  /* If odd then fail.  */\n-  if (!constp || bytes <= 0)\n-    return 0;\n \n-  /* Don't expand if we'd make the code bigger and we don't want big code.  */\n-\n-  if (bytes > 8 && TARGET_SMALLCODE)\n+  /* If it isn't a constant number of bytes, or if it doesn't have 4 byte\n+     alignment, or if it isn't a multiple of 4 bytes, then fail.  */\n+  if (! constp || align < 4 || (bytes % 4 != 0))\n     return 0;\n \n-  switch (align)\n-    {\n-    case 1:\n-      mode = QImode;\n-      break;\n-    case 2:\n-      mode = HImode;\n-      break;\n-    default:\n-      mode = SImode;\n-      align = 4;\n-    }\n-\n-  if (mode == SImode && constp && bytes < 64 && (bytes % 4 == 0))\n+  if (bytes < 64)\n     {\n       char entry[30];\n       tree entry_name;\n       rtx func_addr_rtx;\n       rtx r4 = gen_rtx (REG, SImode, 4);\n       rtx r5 = gen_rtx (REG, SImode, 5);\n-      sprintf (entry, \"__movstr%s%d\", GET_MODE_NAME (mode), bytes);\n+\n+      sprintf (entry, \"__movstrSI%d\", bytes);\n       entry_name = get_identifier (entry);\n \n-      func_addr_rtx = copy_to_mode_reg (Pmode,\n-\t      gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)));\n+      func_addr_rtx\n+\t= copy_to_mode_reg (Pmode,\n+\t\t\t    gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t\t     IDENTIFIER_POINTER (entry_name)));\n       emit_insn (gen_move_insn (r4, XEXP (operands[0], 0)));\n       emit_insn (gen_move_insn (r5, XEXP (operands[1], 0)));\n       emit_insn (gen_block_move_real (func_addr_rtx));\n       return 1;\n     }\n-  if (mode == SImode && constp && (bytes % 4 == 0))\n+\n+  /* This is the same number of bytes as a memcpy call, but to a different\n+     less common function name, so this will occasionally use more space.  */\n+  if (! TARGET_SMALLCODE)\n     {\n       tree entry_name;\n       rtx func_addr_rtx;\n+      int final_switch, while_loop;\n       rtx r4 = gen_rtx (REG, SImode, 4);\n       rtx r5 = gen_rtx (REG, SImode, 5);\n       rtx r6 = gen_rtx (REG, SImode, 6);\n-      entry_name = get_identifier (\"__movstr\");\n \n-      func_addr_rtx = copy_to_mode_reg (Pmode,\n-\t\t\t\t\tgen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t\t\t  IDENTIFIER_POINTER (entry_name)));\n+      entry_name = get_identifier (\"__movstr\");\n+      func_addr_rtx\n+\t= copy_to_mode_reg (Pmode,\n+\t\t\t    gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t\t     IDENTIFIER_POINTER (entry_name)));\n       emit_insn (gen_move_insn (r4, XEXP (operands[0], 0)));\n       emit_insn (gen_move_insn (r5, XEXP (operands[1], 0)));\n \n-      /* r6 controls the size of the move, 16 is decremented from it\n-\t for each 64 bytes moved, then the -ve bit is used as an index into a\n-\t list of move instructions like this:\n-\n-\t {\n-\t do {\n-\t *dst++ = *src++;\n-\t *dst++ = *src++;\n-\t *dst++ = *src++;\n-\t ..etc.. 16 in all\n-\t *dst++ = *src++;\n-\t *dst++ = *src++;\n-\t size -= 16;\n-\t } while (size > 0);\n-\n-\t switch (size)\n-\t {\n-\t case -15:\n-\t *dst++ = *src++;\n-\t case -14:\n-\t *dst++ = *src++;\n-\t .. etc.. ;\n-\t case -2:\n-\t *dst++ = *src++;\n-\t case -1:\n-\t *dst++ = *src++;\n-\t case 0:\n-\t ;\n-\t }\n-\t }\n-\n-\t eg, a 72 byte move would be set up with size(r6) = 14, for one\n-\t iteration through the big while loop, and a switch of -2 for the\n-\t last part.  */\n+      /* r6 controls the size of the move.  16 is decremented from it\n+\t for each 64 bytes moved.  Then the negative bit left over is used\n+\t as an index into a list of move instructions.  e.g., a 72 byte move\n+\t would be set up with size(r6) = 14, for one iteration through the\n+\t big while loop, and a switch of -2 for the last part.  */\n \n-      {\n-\tint final_switch = 16 - ((bytes / 4) % 16);\n-\tint while_loop = ((bytes / 4) / 16 - 1) * 16;\n-\temit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));\n-\temit_insn (gen_block_lump_real (func_addr_rtx));\n-\treturn 1;\n-      }\n+      final_switch = 16 - ((bytes / 4) % 16);\n+      while_loop = ((bytes / 4) / 16 - 1) * 16;\n+      emit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));\n+      emit_insn (gen_block_lump_real (func_addr_rtx));\n+      return 1;\n     }\n \n   return 0;\n }\n \n /* Prepare operands for a move define_expand; specifically, one of the\n-   operands must be in a register.  Take this chance to remove\n-   addressing modes which can't be coped with very well.  */\n+   operands must be in a register.  */\n \n int\n prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n-  if (!(reload_in_progress || reload_completed)\n-      && ((!register_operand (operands[0], mode)\n-\t   && !register_operand (operands[1], mode))\n-\t  || GET_CODE (operands[1]) == PLUS))\n+  /* Copy the source to a register if both operands aren't registers.  */\n+  if (! reload_in_progress && ! reload_completed\n+      && ! register_operand (operands[0], mode)\n+      && ! register_operand (operands[1], mode))\n+    operands[1] = copy_to_mode_reg (mode, operands[1]);\n+\n+  return 0;\n+}\n+\n+/* Prepare the operands for an scc instruction; make sure that the\n+   compare has been done.  */\n+rtx\n+prepare_scc_operands (code)\n+     enum rtx_code code;\n+{\n+  rtx t_reg = gen_rtx (REG, SImode, T_REG);\n+  enum rtx_code oldcode = code;\n+\n+  /* First need a compare insn.  */\n+  switch (code)\n     {\n-      /* Copy the source to a register.  */\n-      operands[1] = copy_to_mode_reg (mode, operands[1]);\n+    case NE:\n+      /* It isn't possible to handle this case.  */\n+      abort ();\n+    case LT:\n+      code = GT;\n+      break;\n+    case LE:\n+      code = GE;\n+      break;\n+    case LTU:\n+      code = GTU;\n+      break;\n+    case LEU:\n+      code = GEU;\n+      break;\n     }\n-  if ((mode == SImode || mode == HImode || mode == QImode)\n-      && GET_CODE (operands[1]) == CONST_INT)\n+  if (code != oldcode)\n     {\n-      return synth_constant (operands, mode);\n+      rtx tmp = sh_compare_op0;\n+      sh_compare_op0 = sh_compare_op1;\n+      sh_compare_op1 = tmp;\n     }\n-  if (mode == DFmode || mode == DImode)\n-    {\n-      rtx src = operands[1];\n-      rtx dst = operands[0];\n-      rtx insns;\n-\n-      if (src == dst)\n-\t{\n-\t  emit_insn (gen_rtx (SET, VOIDmode, dst, src));\n-\t  return 1;\n-\t}\n \n-      if (GET_CODE (src) == REG &&\n-\t  REGNO (src) >= FIRST_PSEUDO_REGISTER)\n-\treturn 0;\n-\n-      if (GET_CODE (dst) == REG &&\n-\t  REGNO (dst) >= FIRST_PSEUDO_REGISTER)\n-\treturn 0;\n-\n-      if (push_operand (dst, mode))\n-\treturn 0;\n-\n-      if (GET_CODE (src) == CONST_DOUBLE)\n-\tsrc = force_const_mem (DFmode, src);\n-\n-      if (reload_in_progress)\n-\t{\n-\t  if (!(offsettable_memref_p (src) || register_operand (src, mode)))\n-\t    return 0;\n-\t  if (!(offsettable_memref_p (dst) || register_operand (dst,\n-\t\t\t\t\t\t\t\tmode)))\n-\t    return 0;\n-\t}\n-      start_sequence ();\n-      if (GET_CODE (operands[0]) != REG\n-\t  || !refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1, operands[1], 0))\n-\t{\n-\t  emit_move_insn (operand_subword (dst, 0, 1, mode),\n-\t\t\t  operand_subword_force (src, 0, mode));\n-\t  emit_move_insn (operand_subword (dst, 1, 1, mode),\n-\t\t\t  operand_subword_force (src, 1, mode));\n-\t}\n-      else\n-\t{\n-\t  emit_move_insn (operand_subword (dst, 1, 1, mode),\n-\t\t\t  operand_subword_force (src, 1, mode));\n-\t  emit_move_insn (operand_subword (dst, 0, 1, mode),\n-\t\t\t  operand_subword_force (src, 0, mode));\n-\t}\n+  sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n+  if (code != EQ && code != NE\n+      && (sh_compare_op1 != const0_rtx\n+\t  || code == GTU  || code == GEU || code == LTU || code == LEU))\n+    sh_compare_op1 = force_reg (SImode, sh_compare_op1);\n \n-      insns = get_insns ();\n-      end_sequence ();\n+  emit_insn (gen_rtx (SET, VOIDmode, t_reg,\n+\t\t      gen_rtx (code, SImode, sh_compare_op0,\n+\t\t\t       sh_compare_op1)));\n \n-      emit_no_conflict_block (insns, dst, src, 0, src);\n-      return 1;\n-    }\n-\n-  return 0;\n+  return t_reg;\n }\n \n-/* Prepare the operands for an scc instruction; make sure that the\n-   compare has been done.  */\n-rtx\n-prepare_scc_operands (code)\n+/* Called from the md file, set up the operands of a compare instruction.  */\n+\n+void\n+from_compare (operands, code)\n+     rtx *operands;\n      int code;\n {\n-  if (GET_CODE (sh_compare_op0) != REG\n-      || REGNO (sh_compare_op0) != T_REG)\n+  if (code != EQ && code != NE)\n     {\n-      int newcode = code;\n-      /* First need a compare insn.  */\n-      switch (code)\n-\t{\n-\tcase NE:\n-\t  /* It isn't possible to handle this case.  */\n-\t  abort ();\n-\tcase LT:\n-\t  newcode = GT;\n-\t  break;\n-\tcase LE:\n-\t  newcode = GE;\n-\t  break;\n-\tcase LTU:\n-\t  newcode = GTU;\n-\t  break;\n-\tcase LEU:\n-\t  newcode = GEU;\n-\t  break;\n-\t}\n-      if (newcode != code)\n-\t{\n-\t  rtx tmp = sh_compare_op0;\n-\t  sh_compare_op0 = sh_compare_op1;\n-\t  sh_compare_op1 = tmp;\n-\t  code = newcode;\n-\t}\n-\n+      /* Force args into regs, since we can't use constants here.  */\n       sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n-      if (code != EQ && code != NE\n-\t  && (sh_compare_op1 != const0_rtx\n-\t      || code == GTU  || code == GEU || code == LTU || code == LEU))\n+      if (sh_compare_op1 != const0_rtx\n+\t  || code == GTU  || code == GEU || code == LTU || code == LEU)\n \tsh_compare_op1 = force_reg (SImode, sh_compare_op1);\n-\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (REG, SImode, T_REG),\n-\t\t   gen_rtx (code, SImode, sh_compare_op0, sh_compare_op1)));\n     }\n-  return gen_rtx (REG, SImode, T_REG);\n+  operands[1] = sh_compare_op0;\n+  operands[2] = sh_compare_op1;\n }\n \f\n /* Functions to output assembly code.  */\n@@ -831,17 +394,16 @@ output_movedouble (insn, operands, mode)\n \n   if (GET_CODE (dst) == MEM\n       && GET_CODE (XEXP (dst, 0)) == PRE_DEC)\n-    {\n-      return \"mov.l\t%T1,%0\\n\\tmov.l\t%1,%0\";\n-    }\n+    return \"mov.l\t%T1,%0\\n\\tmov.l\t%1,%0\";\n+\n   if (register_operand (dst, mode)\n       && register_operand (src, mode))\n     {\n       if (REGNO (src) == MACH_REG)\n \treturn \"sts\tmach,%S0\\n\\tsts\tmacl,%R0\";\n \n-      /* when mov.d r1,r2 do r2->r3 then r1->r2\n-         when mov.d r1,r0 do r1->r0 then r2->r1  */\n+      /* When mov.d r1,r2 do r2->r3 then r1->r2;\n+         when mov.d r1,r0 do r1->r0 then r2->r1.  */\n \n       if (REGNO (src) + 1 == REGNO (dst))\n \treturn \"mov\t%T1,%T0\\n\\tmov\t%1,%0\";\n@@ -850,124 +412,70 @@ output_movedouble (insn, operands, mode)\n     }\n   else if (GET_CODE (src) == CONST_INT)\n     {\n-      HOST_WIDE_INT val = INTVAL (src);\n-      int rn = REGNO (operands[0]);\n-      int msw = rn + MSW;\n-      int lsw = rn + LSW;\n-      if (val < 0)\n-\t{\n-\t  fprintf (asm_out_file, \"\\tmov\t#-1,r%d\\n\", msw);\n-\t}\n+      if (INTVAL (src) < 0)\n+\toutput_asm_insn (\"mov\t#-1,%S0\", operands);\n       else\n-\t{\n-\t  fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", msw);\n-\t}\n+\toutput_asm_insn (\"mov\t#0,%S0\", operands);\n \n-      fprintf (asm_out_file, \"\\tmov\t#%d,r%d\\n\", val, lsw);\n-      return \"\";\n+      return \"mov\t%1,%R0\";\n     }\n   else if (GET_CODE (src) == MEM)\n     {\n-      int ptrreg1 = -1;\n-      int ptrreg2 = -1;\n+      int ptrreg = -1;\n       int dreg = REGNO (dst);\n       rtx inside = XEXP (src, 0);\n \n       if (GET_CODE (inside) == REG)\n-\t{\n-\t  ptrreg1 = REGNO (inside);\n-\t}\n+\tptrreg = REGNO (inside);\n       else if (GET_CODE (inside) == PLUS)\n \t{\n-\t  rtx lhs = XEXP (inside, 0);\n-\t  rtx rhs = XEXP (inside, 1);\n-\t  if (GET_CODE (lhs) == REG)\n-\t    ptrreg1 = REGNO (lhs);\n-\t  if (GET_CODE (rhs) == REG)\n-\t    ptrreg2 = REGNO (rhs);\n+\t  ptrreg = REGNO (XEXP (inside, 0));\n+\t  /* ??? A r0+REG address shouldn't be possible here, because it isn't\n+\t     an offsettable address.  Unfortunately, offsettable addresses use\n+\t     QImode to check the offset, and a QImode offsettable address\n+\t     requires r0 for the other operand, which is not currently\n+\t     supported, so we can't use the 'o' constraint.\n+\t     Thus we must check for and handle r0+REG addresses here.\n+\t     We punt for now, since this is likely very rare.  */\n+\t  if (GET_CODE (XEXP (inside, 1)) == REG)\n+\t    abort ();\n \t}\n       else if (GET_CODE (inside) == LABEL_REF)\n-\t{\n-\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%T0\";\n-\t}\n+\treturn \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%T0\";\n       else if (GET_CODE (inside) == POST_INC)\n-\t{\n-\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0\";\n-\t}\n+\treturn \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0\";\n       else\n \tabort ();\n \n-      if ((ptrreg1 >= 0 && ptrreg2 >= 0)\n-\t  && (dreg == ptrreg1\n-\t      || dreg == ptrreg2\n-\t      || dreg + 1 == ptrreg1\n-\t      || dreg + 1 == ptrreg2))\n-\t{\n-\t  /* This move clobbers both index registers,\n-\t     calculate the sum in one register.  */\n-\t  fprintf (asm_out_file, \"\tadd\t%s,%s\\n\",\n-\t\t   reg_names[ptrreg2], reg_names[ptrreg1]);\n-\n-\t  if (dreg == ptrreg1)\n-\t    {\n-\t      /* Copy into dreg+1 first.  */\n-\t      fprintf (asm_out_file, \"\tmov.l\t@(4,%s),%s\\n\",\n-\t\t       reg_names[ptrreg1],\n-\t\t       reg_names[dreg + 1]);\n-\n-\t      fprintf (asm_out_file, \"\tmov.l\t@(%s),%s\\n\",\n-\t\t       reg_names[ptrreg1],\n-\t\t       reg_names[dreg]);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Copy into dreg first.  */\n-\t      fprintf (asm_out_file, \"\tmov.l\t@(%s),%s\\n\",\n-\t\t       reg_names[ptrreg1],\n-\t\t       reg_names[dreg]);\n-\n-\t      fprintf (asm_out_file, \"\tmov.l\t@(4,%s),%s\\n\",\n-\t\t       reg_names[ptrreg1],\n-\t\t       reg_names[dreg + 1]);\n-\n-\t    }\n-\t  warning (\"generated complex amode\");\n-\t  return \"\";\n-\t}\n-\n-      /* Work out the safe way to copy.  */\n-      if (dreg == ptrreg1)\n-\t{\n-\t  /* Copy into the second half first.  */\n-\t  return \"mov.l\t%T1,%T0\\n\\tmov.l\t%1,%0\";\n-\t}\n+      /* Work out the safe way to copy.  Copy into the second half first.  */\n+      if (dreg == ptrreg)\n+\treturn \"mov.l\t%T1,%T0\\n\\tmov.l\t%1,%0\";\n     }\n \n   return \"mov.l\t%1,%0\\n\\tmov.l\t%T1,%T0\";\n }\n \n-void\n-function_epilogue (stream, size)\n-     FILE *stream;\n-     int size;\n-{\n-  pragma_interrupt = pragma_trapa = 0;\n-}\n-\n+/* Print an instruction which would have gone into a delay slot after\n+   another instruction, but couldn't because the other instruction expanded\n+   into a sequence where putting the slot insn at the end wouldn't work.  */\n \n-/* Return the text of the branch instruction which matches its length\n-   attribute.\n+static void\n+print_slot (insn)\n+     rtx insn;\n+{\n+  final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file, optimize, 0, 1);\n \n-   This gets tricky if we have an insn in the delay slot of a branch\n-   and the branch needs more than 1 insn to complete.  */\n+  INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n+}\n \n-int pending_const_table;\n+/* We can't tell if we need a register as a scratch for the jump\n+   until after branch shortening, and then it's too late to allocate a\n+   register the 'proper' way.  These instruction sequences are rare\n+   anyway, so to avoid always using a reg up from our limited set, we'll\n+   grab one when we need one on output.  */\n \n- /* We can't tell if we need a register as a scratch for the jump\n-    until after branch shortening, and then it's too late to allocate a\n-    register the 'proper' way.  These instruction sequences are rare\n-    anyway, so to avoid always using a reg up from our limited set, we'll\n-    grab one when we need one on output.  */\n+/* ??? Should fix compiler so that using a clobber scratch in jump\n+   instructions works, and then this will be unnecessary.  */\n \n char *\n output_far_jump (insn, op)\n@@ -976,53 +484,33 @@ output_far_jump (insn, op)\n {\n   rtx thislab = gen_label_rtx ();\n \n+  /* Output the delay slot insn first if any.  */\n   if (dbr_sequence_length ())\n-    {\n-      /* Something to go in what would have been the delay\n-\t slot if this had been a short branch. Make sure the\n-\t reg we use to generate the branch target address\n-\t doesn't conflict.  */\n-\n-      int i;\n-      rtx vec[2];\n-      vec[0] = thislab;\n-\n-      for (i = 0; i < 8; i++)\n-\t{\n-\t  vec[1] = gen_rtx (REG, SImode, i);\n-\t  if (!reg_referenced_p (vec[1],\n-\t\t\t\t PATTERN (XVECEXP (final_sequence, 0, 1))))\n-\t    break;\n-\t}\n-\n-\n-      print_slot (final_sequence);\n-      output_asm_insn (\"mov.l\t%1,@-r15\", vec);\n-      output_asm_insn (\"mov.l\t%O0,%1\", vec);\n-\n-      output_asm_insn (\"jmp\t@%1\", vec);\n-      output_asm_insn (\"mov.l\t@r15+,%1\", vec);\n-    }\n-  else\n-    {\n-      output_asm_insn (\"mov.l\tr13,@-r15\", 0);\n-      output_asm_insn (\"mov.l\t%O0,r13\", &thislab);\n-      output_asm_insn (\"jmp\t@r13\", 0);\n-      output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n-    }\n+    print_slot (final_sequence);\n \n+  output_asm_insn (\"mov.l\tr13,@-r15\", 0);\n+  output_asm_insn (\"mov.l\t%O0,r13\", &thislab);\n+  output_asm_insn (\"jmp\t@r13\", 0);\n+  output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n   output_asm_insn (\".align\t2\", 0);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (thislab));\n   output_asm_insn (\".long\t%O0\", &op);\n   return \"\";\n }\n \n+/* Local label counter, used for constants in the pool and inside\n+   pattern branches.  */\n+\n+static int lf = 100;\n+\n+/* Output code for ordinary branches.  */\n+\n char *\n-output_branch (logic, insn)\n+output_branch (logic, insn, operands)\n      int logic;\n      rtx insn;\n+     rtx *operands;\n {\n-  extern rtx recog_operand[];\n   int label = lf++;\n \n   switch (get_attr_length (insn))\n@@ -1038,180 +526,50 @@ output_branch (logic, insn)\n     case 8:\n       /* Branch in range -4092..+4098 bytes.  */\n       {\n-\trtx oldop = recog_operand[0];\n-\n+\t/* The call to print_slot will clobber the operands.  */\n+\trtx op0 = operands[0];\n \n \tif (final_sequence)\n \t  {\n \t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't',\n \t\t     label);\n-\n \t    print_slot (final_sequence);\n \t  }\n-\n \telse\n-\t  {\n-\t    fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't',\n-\t\t     label);\n-\t  }\n-\trecog_operand[0] = oldop;\n+\t  fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n \n-\toutput_asm_insn (\"bra\t%l0\", recog_operand);\n-\tfprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+\toutput_asm_insn (\"bra\t%l0\", &op0);\n+\tfprintf (asm_out_file, \"\\tnop\\n\");\n \tfprintf (asm_out_file, \"LF%d:\\n\", label);\n       }\n       return \"\";\n \n-    case 16:\n-      /* A branch with an unfilled delay slot.  */\n-    case 18:\n-      /* Branches a long way away.  */\n-      {\n-\trtx oldop = recog_operand[0];\n-\n-\tif (final_sequence)\n-\t  {\n-\t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't', label);\n-\t    print_slot (final_sequence);\n-\n-\t  }\n-\telse\n-\t  {\n-\t    fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n-\t  }\n-\n-\toutput_far_jump (insn, oldop);\n-\tfprintf (asm_out_file, \"LF%d:\\n\", label);\n-\treturn \"\";\n-      }\n-    }\n-  return \"bad\";\n-}\n-\f\n-/* The SH cannot load a large constant into a register, constants have to\n-   come from a pc relative load.  The reference of a pc relative load\n-   instruction must be less than 1k infront of the instruction.  This\n-   means that we often have to dump a constant inside a function, and\n-   generate code to branch around it.\n-\n-   It is important to minimize this, since the branches will slow things\n-   down and make things bigger.\n-\n-   Worst case code looks like:\n-\n-   mov.l L1,rn\n-   bra   L2\n-   nop\n-   align\n-   L1:   .long value\n-   L2:\n-   ..\n-\n-   mov.l L3,rn\n-   bra   L4\n-   nop\n-   align\n-   L3:   .long value\n-   L4:\n-   ..\n-\n-   We fix this by performing a scan before scheduling, which notices which\n-   instructions need to have their operands fetched from the constant table\n-   and builds the table.\n-\n-\n-   The algorithm is:\n-\n-   scan, find an instruction which needs a pcrel move.  Look forward, find the\n-   last barrier which is within MAX_COUNT bytes of the requirement.\n-   If there isn't one, make one.  Process all the instructions between\n-   the find and the barrier.\n-\n-   In the above example, we can tell that L3 is within 1k of L1, so\n-   the first move can be shrunk from the 3 insn+constant sequence into\n-   just 1 insn, and the constant moved to L3 to make:\n-\n-   mov.l        L1,rn\n-   ..\n-   mov.l        L3,rn\n-   bra          L4\n-   nop\n-   align\n-   L3:.long value\n-   L4:.long value\n-\n-   Then the second move becomes the target for the shortening process.  */\n-\n-typedef struct\n-{\n-  rtx value;\t\t\t/* Value in table.  */\n-  rtx label;\t\t\t/* Label of value.  */\n-  enum machine_mode mode;\t/* Mode of value.  */\n-}\n-\n-pool_node;\n-\n-/* The maximum number of constants that can fit into one pool, since\n-   the pc relative range is 0...1020 bytes and constants are at least 4\n-   bytes long.  */\n-\n-#define MAX_POOL_SIZE (1020/4)\n-static pool_node pool_vector[MAX_POOL_SIZE];\n-static int pool_size;\n-\n-/* Add a constant to the pool and return its label.  */\n-\n-static rtx\n-add_constant (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n-{\n-  int i;\n-  rtx lab;\n-  /* First see if we've already got it.  */\n-\n-  for (i = 0; i < pool_size; i++)\n-    {\n-      if (x->code == pool_vector[i].value->code\n-\t  && mode == pool_vector[i].mode)\n-\t{\n-\t  if (x->code == CODE_LABEL)\n-\t    {\n-\t      if (XINT (x, 3) != XINT (pool_vector[i].value, 3))\n-\t\tcontinue;\n-\t    }\n-\t  if (rtx_equal_p (x, pool_vector[i].value))\n-\t    return pool_vector[i].label;\n-\t}\n-    }\n-\n-  /* Need a new one.  */\n-\n-  pool_vector[pool_size].value = x;\n-  lab = gen_label_rtx ();\n-  pool_vector[pool_size].mode = mode;\n-  pool_vector[pool_size].label = lab;\n-  pool_size++;\n-  return lab;\n-}\n+    case 16:\n+      /* A branch with an unfilled delay slot.  */\n+    case 18:\n+      /* Branches a long way away.  */\n+      {\n+\t/* The call to print_slot will clobber the operands.  */\n+\trtx op0 = operands[0];\n \n-/* Dump out interesting debug info.  */\n+\tif (final_sequence)\n+\t  {\n+\t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't',\n+\t\t     label);\n+\t    print_slot (final_sequence);\n+\t  }\n+\telse\n+\t  fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n \n-void\n-final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx *opvec;\n-     int noperands;\n-{\n-  if (target_flags & ISIZE_BIT)\n-    {\n-      extern int *insn_addresses;\n-      fprintf (asm_out_file, \"\\n! at %04x\\n\",\n-\t       insn_addresses[INSN_UID (insn)]);\n+\toutput_far_jump (insn, op0);\n+\tfprintf (asm_out_file, \"LF%d:\\n\", label);\n+\treturn \"\";\n+      }\n     }\n+  return \"bad\";\n }\n \f\n-/* Output to FILE the start of the assembler file.  */\n+/* A copy of the option structure defined in toplev.c.  */\n \n struct option\n {\n@@ -1220,6 +578,9 @@ struct option\n   int on_value;\n };\n \n+/* Output a single output option string NAME to FILE, without generating\n+   lines longer than MAX.  */\n+\n static int\n output_option (file, sep, type, name, indent, pos, max)\n      FILE *file;\n@@ -1238,13 +599,15 @@ output_option (file, sep, type, name, indent, pos, max)\n   return pos + fprintf (file, \"%s%s%s\", sep, type, name);\n }\n \n+/* A copy of the target_switches variable in toplev.c.  */\n+\n static struct\n {\n   char *name;\n   int value;\n-}\n+} m_options[] = TARGET_SWITCHES;\n \n-m_options[] = TARGET_SWITCHES;\n+/* Output all options to the assembly language file.  */\n \n static void\n output_options (file, f_options, f_len, W_options, W_len,\n@@ -1261,7 +624,6 @@ output_options (file, f_options, f_len, W_options, W_len,\n {\n   register int j;\n \n-\n   if (optimize)\n     pos = output_option (file, sep, \"-O\", \"\", indent, pos, max);\n   if (write_symbols != NO_DEBUG)\n@@ -1289,14 +651,11 @@ output_options (file, f_options, f_len, W_options, W_len,\n       pos = output_option (file, sep, \"-m\", m_options[j].name,\n \t\t\t   indent, pos, max);\n \n-\n   fprintf (file, term);\n-  fprintf (file, \"! %d %d\\n\", max_count_si, max_count_hi);\n-\n-  if (TARGET_LITTLE_ENDIAN)\n-    fprintf (file, \"\\t.little\\n\");\n }\n \n+/* Output to FILE the start of the assembler file.  */\n+\n void\n output_file_start (file, f_options, f_len, W_options, W_len)\n      FILE *file;\n@@ -1312,24 +671,27 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n      gcc2_compiled. symbol aren't in the text section.  */\n   data_section ();\n \n-\n   pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) arguments:\", version_string);\n   output_options (file, f_options, f_len, W_options, W_len,\n \t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n+\n+  if (TARGET_LITTLE_ENDIAN)\n+    fprintf (file, \"\\t.little\\n\");\n }\n \f\n /* Actual number of instructions used to make a shift by N.  */\n-char ashiftrt_insns[] =\n+static char ashiftrt_insns[] =\n   { 0,1,2,3,4,5,8,8,8,8,8,8,8,8,8,8,2,3,4,5,8,8,8,8,8,8,8,8,8,8,8,2};\n \n /* Left shift and logical right shift are the same.  */\n-char shift_insns[]    =\n+static char shift_insns[]    =\n   { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,3,3,1,2,2,3,3,4,3,3,2,3,3,4,4,4,3,3};\n+\n /* Individual shift amounts needed to get the above length sequences.\n    One bit right shifts clobber the T bit, so when possible, put one bit\n    shifts in the middle of the sequence, so the ends are eligible for\n    branch delay slots.  */\n-short shift_amounts[32][5] = {\n+static short shift_amounts[32][5] = {\n   {0}, {1}, {2}, {2, 1},\n   {2, 2}, {2, 1, 2}, {2, 2, 2}, {2, 2, 1, 2},\n   {8}, {8, 1}, {8, 2}, {8, 1, 2},\n@@ -1362,48 +724,40 @@ shift_insns_rtx (insn)\n     }\n }\n \n-int\n-shiftinsns (shift, n)\n-enum rtx_code shift;\n-int n;\n-{\n-  switch (shift)\n-    {\n-    case ASHIFTRT:\n-      return ashiftrt_insns[n];\n-    case LSHIFTRT:\n-    case ASHIFT:\n-      return shift_insns[n];\n-    default:\n-      abort();\n-    }\n-}\n-\n /* Return the cost of a shift.  */\n \n int\n-shiftcosts (RTX)\n-     rtx RTX;\n+shiftcosts (x)\n+     rtx x;\n {\n+  int value = INTVAL (XEXP (x, 1));\n+\n   /* If shift by a non constant, then this will be expensive.  */\n-  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n+  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     {\n       return 20;\n     }\n \n   /* Otherwise, return the true cost in instructions.  */\n-  return shiftinsns (GET_CODE (RTX), INTVAL (XEXP (RTX, 1)));\n+  if (GET_CODE (x) == ASHIFTRT)\n+    return ashiftrt_insns[value];\n+  else\n+    return shift_insns[value];\n }\n \n+/* Return the cost of an AND operation.  */\n+\n int\n-andcosts (RTX)\n-     rtx RTX;\n+andcosts (x)\n+     rtx x;\n {\n   int i;\n+\n   /* Anding with a register is a single cycle and instruction.  */\n-  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n+  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     return 1;\n-  i = INTVAL (XEXP (RTX, 1));\n+\n+  i = INTVAL (XEXP (x, 1));\n   /* These constants are single cycle extu.[bw] instructions.  */\n   if (i == 0xff || i == 0xffff)\n     return 1;\n@@ -1422,8 +776,8 @@ andcosts (RTX)\n \n /* Return the cost of a multiply.  */\n int\n-multcosts (RTX)\n-     rtx RTX;\n+multcosts (x)\n+     rtx x;\n {\n   if (TARGET_SH2)\n     {\n@@ -1438,7 +792,7 @@ multcosts (RTX)\n   /* If we're aiming at small code, then just count the number of\n      insns in a multiply call sequence.  */\n   if (TARGET_SMALLCODE)\n-    return 6;\n+    return 5;\n \n   /* Otherwise count all the insns in the routine we'd be calling too.  */\n   return 20;\n@@ -1479,107 +833,212 @@ gen_ashift (type, n, reg)\n     }\n }\n \n+/* Output RTL to split a constant shift into its component SH constant\n+   shift instructions.  */\n+   \n+\n int\n gen_shifty_op (code, operands)\n      int code;\n      rtx *operands;\n {\n-  rtx wrk, t;\n-  char *func;\n   int value = INTVAL (operands[2]);\n+  int max, i;\n \n-  /* ??? All of this code to handle negative shift counts here and elsewhere\n-     looks wrong.  */\n-  if (value < 0)\n-    {\n-      value = -value;\n-      if (code == ASHIFT)\n-\tcode = LSHIFTRT;\n-      else\n-\tcode = ASHIFT;\n-    }\n-\n-  switch (code)\n+  if (value == 31)\n     {\n-      /* ??? This code should be moved elsewhere.  */\n-    case ASHIFTRT:\n-      if (GET_CODE (operands[2]) != CONST_INT)\n-\treturn 0;\n-\n-      wrk = gen_reg_rtx (SImode);\n-\n-      if (value == 31)\n+      if (code == LSHIFTRT)\n \t{\n-\t  emit_insn (gen_ashrsi2_31 (operands[0], operands[1]));\n-\t  return 1;\n+\t  emit_insn (gen_rotlsi3_1 (operands[0], operands[0]));\n+\t  emit_insn (gen_movt (operands[0]));\n+\t  return;\n \t}\n-      else if (value >= 16 && value <= 19)\n+      else if (code == ASHIFT)\n \t{\n-\t  emit_insn (gen_ashrsi2_16 (wrk, operands[1]));\n-\t  value -= 16;\n-\t  while (value --)\n-\t    gen_ashift (ASHIFTRT,1, wrk);\n-\t  emit_move_insn (operands[0], wrk);\n-\t  return 1;\n-\t}\n-      /* Expand a short sequence inline, longer call a magic routine.  */\n-      if (value <= 5)\n-\t{\n-\t  emit_move_insn (wrk, operands[1]);\n-\t  while (value--)\n+\t  /* There is a two instruction sequence for 31 bit left shifts,\n+\t     but it requires r0.  */\n+\t  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 0)\n \t    {\n-\t      gen_ashift (ASHIFTRT, 1, wrk);\n+\t      emit_insn (gen_andsi3 (operands[0], operands[0], const1_rtx));\n+\t      emit_insn (gen_rotlsi3_31 (operands[0], operands[0]));\n+\t      return;\n \t    }\n-\t  emit_move_insn (operands[0], wrk);\n-\t  return 1;\n-\t}\n-      t = gen_reg_rtx (Pmode);\n-      /* Load the value into an arg reg and call a helper.  */\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n-      if (!shiftsyms[value])\n-\t{\n-\t  func = xmalloc (18);\n-\t  sprintf (func, \"__ashiftrt_r4_%d\", value);\n-\t  shiftsyms[value] = gen_rtx (SYMBOL_REF, Pmode, func);\n \t}\n-      emit_move_insn (t, shiftsyms[value]);\n-      emit_insn (gen_ashrsi3_n (GEN_INT (value), t));\n-      emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n-      return 1;\n+    }\n \n-    case ASHIFT:\n-    case LSHIFTRT:\n-      /* ??? There are two instruction sequences for 31 bit shifts,\n-\t but we do not support them currently.  */\n-\t{\n-\t  int max = shiftinsns (code, value);\n-\t  int i;\n-\t  for (i = 0; i < max; i++)\n-\t    gen_ashift (code, shift_amounts[value][i], operands[0]);\n-\t}\n+  max = shift_insns[value];\n+  for (i = 0; i < max; i++)\n+    gen_ashift (code, shift_amounts[value][i], operands[0]);\n+}\n+\n+/* Output RTL for an arithmetic right shift.  */\n+\n+/* ??? Rewrite to use super-optimizer sequences.  */\n+\n+int\n+expand_ashiftrt (operands)\n+     rtx *operands;\n+{\n+  rtx wrk;\n+  char func[18];\n+  tree func_name;\n+  int value;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    return 0;\n+\n+  value = INTVAL (operands[2]);\n+\n+  if (value == 31)\n+    {\n+      emit_insn (gen_ashrsi2_31 (operands[0], operands[1]));\n+      return 1;\n+    }\n+  else if (value >= 16 && value <= 19)\n+    {\n+      wrk = gen_reg_rtx (SImode);\n+      emit_insn (gen_ashrsi2_16 (wrk, operands[1]));\n+      value -= 16;\n+      while (value--)\n+\tgen_ashift (ASHIFTRT, 1, wrk);\n+      emit_move_insn (operands[0], wrk);\n+      return 1;\n     }\n+  /* Expand a short sequence inline, longer call a magic routine.  */\n+  else if (value <= 5)\n+    {\n+      wrk = gen_reg_rtx (SImode);\n+      emit_move_insn (wrk, operands[1]);\n+      while (value--)\n+\tgen_ashift (ASHIFTRT, 1, wrk);\n+      emit_move_insn (operands[0], wrk);\n+      return 1;\n+    }\n+\n+  wrk = gen_reg_rtx (Pmode);\n+\n+  /* Load the value into an arg reg and call a helper.  */\n+  emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n+  sprintf (func, \"__ashiftrt_r4_%d\", value);\n+  func_name = get_identifier (func);\n+  emit_move_insn (wrk, gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t\tIDENTIFIER_POINTER (func_name)));\n+  emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk));\n+  emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n+  return 1;\n }\n+\f\n+/* The SH cannot load a large constant into a register, constants have to\n+   come from a pc relative load.  The reference of a pc relative load\n+   instruction must be less than 1k infront of the instruction.  This\n+   means that we often have to dump a constant inside a function, and\n+   generate code to branch around it.\n \n-/* Dump out any constants accumulated in the final pass -\n-   which will only be labels.  */\n-char *\n-output_jump_label_table ()\n+   It is important to minimize this, since the branches will slow things\n+   down and make things bigger.\n+\n+   Worst case code looks like:\n+\n+   mov.l L1,rn\n+   bra   L2\n+   nop\n+   align\n+   L1:   .long value\n+   L2:\n+   ..\n+\n+   mov.l L3,rn\n+   bra   L4\n+   nop\n+   align\n+   L3:   .long value\n+   L4:\n+   ..\n+\n+   We fix this by performing a scan before scheduling, which notices which\n+   instructions need to have their operands fetched from the constant table\n+   and builds the table.\n+\n+   The algorithm is:\n+\n+   scan, find an instruction which needs a pcrel move.  Look forward, find the\n+   last barrier which is within MAX_COUNT bytes of the requirement.\n+   If there isn't one, make one.  Process all the instructions between\n+   the find and the barrier.\n+\n+   In the above example, we can tell that L3 is within 1k of L1, so\n+   the first move can be shrunk from the 3 insn+constant sequence into\n+   just 1 insn, and the constant moved to L3 to make:\n+\n+   mov.l        L1,rn\n+   ..\n+   mov.l        L3,rn\n+   bra          L4\n+   nop\n+   align\n+   L3:.long value\n+   L4:.long value\n+\n+   Then the second move becomes the target for the shortening process.  */\n+\n+typedef struct\n+{\n+  rtx value;\t\t\t/* Value in table.  */\n+  rtx label;\t\t\t/* Label of value.  */\n+  enum machine_mode mode;\t/* Mode of value.  */\n+} pool_node;\n+\n+/* The maximum number of constants that can fit into one pool, since\n+   the pc relative range is 0...1020 bytes and constants are at least 4\n+   bytes long.  */\n+\n+#define MAX_POOL_SIZE (1020/4)\n+static pool_node pool_vector[MAX_POOL_SIZE];\n+static int pool_size;\n+\n+/* ??? If we need a constant in HImode which is the truncated value of a\n+   constant we need in SImode, we could combine the two entries thus saving\n+   two bytes.  Is this common enough to be worth the effort of implementing\n+   it?  */\n+\n+/* ??? This stuff should be done at the same time that we shorten branches.\n+   As it is now, we must assume that all branches are the maximum size, and\n+   this causes us to almost always output constant pools sooner than\n+   necessary.  */\n+\n+/* Add a constant to the pool and return its label.  */\n+\n+static rtx\n+add_constant (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n {\n   int i;\n-  if (pool_size)\n+  rtx lab;\n+\n+  /* First see if we've already got it.  */\n+  for (i = 0; i < pool_size; i++)\n     {\n-      fprintf (asm_out_file, \"\\t.align 2\\n\");\n-      for (i = 0; i < pool_size; i++)\n+      if (x->code == pool_vector[i].value->code\n+\t  && mode == pool_vector[i].mode)\n \t{\n-\t  pool_node *p = pool_vector + i;\n-\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (p->label));\n-\t  output_asm_insn (\".long\t%O0\", &p->value);\n+\t  if (x->code == CODE_LABEL)\n+\t    {\n+\t      if (XINT (x, 3) != XINT (pool_vector[i].value, 3))\n+\t\tcontinue;\n+\t    }\n+\t  if (rtx_equal_p (x, pool_vector[i].value))\n+\t    return pool_vector[i].label;\n \t}\n-      pool_size = 0;\n     }\n \n-  return \"\";\n+  /* Need a new one.  */\n+  pool_vector[pool_size].value = x;\n+  lab = gen_label_rtx ();\n+  pool_vector[pool_size].mode = mode;\n+  pool_vector[pool_size].label = lab;\n+  pool_size++;\n+  return lab;\n }\n \n /* Output the literal table.  */\n@@ -1591,12 +1050,12 @@ dump_table (scan)\n   int i;\n   int need_align = 1;\n \n-\n   /* Do two passes, first time dump out the HI sized constants.  */\n \n   for (i = 0; i < pool_size; i++)\n     {\n-      pool_node *p = pool_vector + i;\n+      pool_node *p = &pool_vector[i];\n+\n       if (p->mode == HImode)\n \t{\n \t  if (need_align)\n@@ -1608,11 +1067,12 @@ dump_table (scan)\n \t  scan = emit_insn_after (gen_consttable_2 (p->value), scan);\n \t}\n     }\n+\n   need_align = 1;\n \n   for (i = 0; i < pool_size; i++)\n     {\n-      pool_node *p = pool_vector + i;\n+      pool_node *p = &pool_vector[i];\n \n       switch (p->mode)\n \t{\n@@ -1649,50 +1109,44 @@ dump_table (scan)\n   pool_size = 0;\n }\n \n-/* Non zero if the src operand needs to be fixed up.  */\n+/* Return non-zero if constant would be an ok source for a\n+   mov.w instead of a mov.l.  */\n \n static int\n-fixit (src, mode)\n+hi_const (src)\n      rtx src;\n-     enum machine_mode mode;\n {\n-  if (mode == QImode)\n-    return 0;\t\t\t/* QIs never need to be fixed.  */\n-  if (GET_CODE (src) == CONST)\n-    return 1;\n-\n-  if (GET_CODE (src) == SYMBOL_REF)\n-    {\n-      return 1;\n-    }\n-  if (GET_CODE (src) == LABEL_REF)\n-    return 1;\n-  if (GET_CODE (src) == CONST_INT)\n-    {\n-      return !CONST_OK_FOR_I (INTVAL (src));\n-    }\n-  return 0;\n+  return (GET_CODE (src) == CONST_INT\n+\t  && INTVAL (src) >= -32768\n+\t  && INTVAL (src) <= 32767);\n }\n \n-/* Return Non-zero if constant would be an ok source for a\n-   mov.w instead of a mov.l.  */\n-int\n-hi_const (src)\n-     rtx src;\n+/* Non-zero if the insn is a move instruction which needs to be fixed.  */\n+\n+/* ??? For a DImode/DFmode moves, we don't need to fix it if each half of the\n+   CONST_DOUBLE input value is CONST_OK_FOR_I.  For a SFmode move, we don't\n+   need to fix it if the input value is CONST_OK_FOR_I.  */\n+\n+static int\n+broken_move (insn)\n+     rtx insn;\n {\n-  if (GET_CODE (src) == CONST\n-      && GET_CODE (XEXP (src, 0)) == SIGN_EXTEND\n-      && GET_CODE (XEXP (XEXP (src, 0), 0)) == SYMBOL_REF)\n+  if (GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET\n+      /* We can load any 8 bit value if we don't care what the high\n+\t order bits end up as.  */\n+      && GET_MODE (SET_DEST (PATTERN (insn))) != QImode\n+      && CONSTANT_P (SET_SRC (PATTERN (insn)))\n+      && (GET_CODE (SET_SRC (PATTERN (insn))) != CONST_INT\n+\t  || ! CONST_OK_FOR_I (INTVAL (SET_SRC (PATTERN (insn))))))\n     return 1;\n \n-  return (GET_CODE (src) == CONST_INT\n-\t  && INTVAL (src) >= -32768\n-\t  && INTVAL (src) <= 32767);\n+  return 0;\n }\n \n-/* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.\n-   If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from\n-   that one.  */\n+/* Find the last barrier from insn FROM which is close enough to hold the\n+   constant pool.  If we can't find one, then create one near the end of\n+   the range.  */\n \n /* ??? It would be good to put constant pool tables between a case jump and\n    the jump table.  This fails for two reasons.  First, there is no\n@@ -1702,8 +1156,7 @@ hi_const (src)\n    We fix that problem by never outputting the constant pool between a mova\n    and its label.  */\n \n-static\n-rtx\n+static rtx\n find_barrier (from)\n      rtx from;\n {\n@@ -1713,35 +1166,36 @@ find_barrier (from)\n   int found_si = 0;\n   rtx found_barrier = 0;\n   rtx found_mova = 0;\n-  while (from\n-\t && count_si < max_count_si\n-\t && count_hi < max_count_hi)\n+\n+  /* For HImode: range is 510, add 4 because pc counts from address of\n+     second instruction after this one, subtract 2 for the jump instruction\n+     that we may need to emit before the table.  This gives 512.\n+     For SImode: range is 1020, add 4 because pc counts from address of\n+     second instruction after this one, subtract 2 in case pc is 2 byte\n+     aligned, subtract 2 for the jump instruction that we may need to emit\n+     before the table.  This gives 1020.  */\n+  while (from && count_si < 1020 && count_hi < 512)\n     {\n       int inc;\n+\n       if (GET_CODE (from) == BARRIER)\n-\t{\n-\t  found_barrier = from;\n-\t}\n+\tfound_barrier = from;\n+\n       /* Count the length of this insn - we assume that all moves will\n-\t be 2 bytes long, except the DIs.  */\n+\t be 2 bytes long, except the DImode/DFmode movess.  */\n \n-      if (GET_CODE (from) == INSN\n-\t  && GET_CODE (PATTERN (from)) == SET\n-\t  && CONSTANT_P (SET_SRC (PATTERN (from)))\n-\t  && (GET_CODE (SET_SRC (PATTERN (from))) != CONST_INT\n-\t      || ! CONST_OK_FOR_I (INTVAL (SET_SRC (PATTERN (from))))))\n+      if (broken_move (from))\n \t{\n \t  rtx src = SET_SRC (PATTERN (from));\n+\n \t  if (hi_const (src))\n \t    found_hi = 1;\n \t  else\n \t    found_si = 1;\n \t  inc = (GET_MODE_SIZE (GET_MODE (src)) > 4) ? 4 : 2;\n \t}\n       else\n-\t{\n-\t  inc = get_attr_length (from);\n-\t}\n+\tinc = get_attr_length (from);\n \n       if (GET_CODE (from) == INSN\n \t  && GET_CODE (PATTERN (from)) == SET\n@@ -1765,68 +1219,50 @@ find_barrier (from)\n   if (found_mova)\n     from = found_mova;\n \n-  if (!found_barrier)\n+  if (! found_barrier)\n     {\n-      /* We didn't find a barrier in time to\n-\t dump our stuff, so we'll make one.  */\n+      /* We didn't find a barrier in time to dump our stuff,\n+\t so we'll make one.  */\n       rtx label = gen_label_rtx ();\n-      /* Walk back to be just before any jump.  */\n+\n+      /* We went one instruction too far above.  */\n       from = PREV_INSN (from);\n-      while (GET_CODE (from) == JUMP_INSN\n-\t     || GET_CODE (from) == NOTE\n+      /* Walk back to be just before any jump or label.\n+\t Putting it before a label reduces the number of times the branch\n+\t around the constant pool table will be hit.  Putting it before\n+\t a jump makes it more likely that the bra delay slot will be\n+\t filled.  */\n+      while (GET_CODE (from) == JUMP_INSN || GET_CODE (from) == NOTE\n \t     || GET_CODE (from) == CODE_LABEL)\n-\t{\n-\t  from = PREV_INSN (from);\n-\t}\n+\tfrom = PREV_INSN (from);\n+\n       from = emit_jump_insn_after (gen_jump (label), from);\n       JUMP_LABEL (from) = label;\n       found_barrier = emit_barrier_after (from);\n       emit_label_after (label, found_barrier);\n-      return found_barrier;\n     }\n-  return found_barrier;\n-}\n \n-/* Non zero if the insn is a move instruction which needs to be fixed.  */\n-\n-static\n-int\n-broken_move (insn)\n-     rtx insn;\n-{\n-  if (!INSN_DELETED_P (insn)\n-      && GET_CODE (insn) == INSN\n-      && GET_CODE (PATTERN (insn)) == SET)\n-    {\n-      rtx pat = PATTERN (insn);\n-      rtx src = SET_SRC (pat);\n-      rtx dst = SET_DEST (pat);\n-      enum machine_mode mode = GET_MODE (dst);\n-      if (dst == pc_rtx)\n-\treturn 0;\n-      return fixit (src, mode);\n-    }\n-  return 0;\n+  return found_barrier;\n }\n \n-\n-/* Exported to toplev.c\n+/* Exported to toplev.c.\n \n    Scan the function looking for move instructions which have to be changed to\n-   pcrel loads and insert the literal tables.  */\n+   pc-relative loads and insert the literal tables.  */\n \n void\n machine_dependent_reorg (first)\n      rtx first;\n {\n   rtx insn;\n+\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (broken_move (insn))\n \t{\n-\t  /* This is a broken move instruction, scan ahead looking for\n-\t     a barrier to stick the constant table behind.  */\n \t  rtx scan;\n+\t  /* Scan ahead looking for a barrier to stick the constant table\n+\t     behind.  */\n \t  rtx barrier = find_barrier (insn);\n \n \t  /* Now find all the moves between the points and modify them.  */\n@@ -1841,13 +1277,11 @@ machine_dependent_reorg (first)\n \t\t  rtx lab;\n \t\t  rtx newinsn;\n \t\t  rtx newsrc;\n-\t\t  /* This is a broken move instruction, add it to the pool.  */\n \n \t\t  if (mode == SImode && hi_const (src))\n \t\t    {\n-\t\t      /* This is an HI source, clobber the dest to get the\n-\t\t\t mode right too.  */\n \t\t      int offset = 0;\n+\n \t\t      mode = HImode;\n \t\t      while (GET_CODE (dst) == SUBREG)\n \t\t\t{\n@@ -1856,22 +1290,14 @@ machine_dependent_reorg (first)\n \t\t\t}\n \t\t      dst = gen_rtx (REG, HImode, REGNO (dst) + offset);\n \t\t    }\n+\n \t\t  lab = add_constant (src, mode);\n \t\t  newsrc = gen_rtx (MEM, mode,\n \t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, lab));\n+\t\t  RTX_UNCHANGING_P (newsrc) = 1;\n+\t\t  newinsn = emit_insn_after (gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t\t      dst, newsrc), scan);\n \n-\t\t  /* Build a jump insn wrapper around the move instead\n-\t\t     of an ordinary insn, because we want to have room for\n-\t\t     the target label rtx in fld[7], which an ordinary\n-\t\t     insn doesn't have.  */\n-\t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t\t\tdst, newsrc), scan);\n-\t\t  JUMP_LABEL (newinsn) = lab;\n-\n-\t\t  /* But it's still an ordinary insn.  */\n-\t\t  PUT_CODE (newinsn, INSN);\n-\n-\t\t  /* Kill old insn.  */\n \t\t  delete_insn (scan);\n \t\t  scan = newinsn;\n \t\t}\n@@ -1881,37 +1307,53 @@ machine_dependent_reorg (first)\n     }\n }\n \n-/* Called from the md file, set up the operands of a compare instruction.  */\n+/* Dump out instruction addresses, which is useful for debugging the\n+   constant pool table stuff.  */\n+\n+/* ??? This is unnecessary, and probably should be deleted.  This makes\n+   the insn_addresses declaration above unnecessary.  */\n+\n+/* ??? The addresses printed by this routine for insns are nonsense for\n+   insns which are inside of a sequence where none of the inner insns have\n+   variable length.  This is because the second pass of shorten_branches\n+   does not bother to update them.  */\n \n void\n-from_compare (operands, code)\n-     rtx *operands;\n-     int code;\n+final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx *opvec;\n+     int noperands;\n {\n-  if (code != EQ && code != NE)\n-    {\n-      /* Force args into regs, since we can't use constants here.  */\n-      sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n-      if (sh_compare_op1 != const0_rtx\n-\t  || code == GTU  || code == GEU || code == LTU || code == LEU)\n-\tsh_compare_op1 = force_reg (SImode, sh_compare_op1);\n-    }\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n+  if (TARGET_DUMPISIZE)\n+    fprintf (asm_out_file, \"\\n! at %04x\\n\", insn_addresses[INSN_UID (insn)]);\n }\n \n-/* Non-zero if x is EQ or NE.  */\n+/* Dump out any constants accumulated in the final pass.  These will\n+   will only be labels.  */\n \n-int\n-equality_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+char *\n+output_jump_label_table ()\n {\n-  enum rtx_code code = GET_CODE (x);\n-  return (code == EQ || code == NE);\n-}\n+  int i;\n+\n+  if (pool_size)\n+    {\n+      fprintf (asm_out_file, \"\\t.align 2\\n\");\n+      for (i = 0; i < pool_size; i++)\n+\t{\n+\t  pool_node *p = &pool_vector[i];\n+\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (p->label));\n+\t  output_asm_insn (\".long\t%O0\", &p->value);\n+\t}\n+      pool_size = 0;\n+    }\n \n-/* Framefull frame looks like:\n+  return \"\";\n+}\n+\f\n+/* A full frame looks like:\n \n    arg-5\n    arg-4\n@@ -1930,18 +1372,127 @@ equality_operator (x, mode)\n    local-1\n    local-0        <- fp points here.  */\n \n- /* Code to generate prologue and epilogue sequences */\n+/* Number of bytes pushed for anonymous args, used to pass information\n+   between expand_prologue and expand_epilogue.  */\n+\n+static int extra_push;\n+\n+/* Adjust the stack and return the number of bytes taken to do it.  */\n+\n+static void\n+output_stack_adjust (size)\n+     int size;\n+{\n+  if (size)\n+    {\n+      rtx val = GEN_INT (size);\n+      rtx insn;\n+\n+      if (! CONST_OK_FOR_I (size))\n+\t{\n+\t  rtx reg = gen_rtx (REG, SImode, 3);\n+\t  emit_insn (gen_movsi (reg, val));\n+\t  val = reg;\n+\t}\n+\n+      insn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n+      emit_insn (insn);\n+    }\n+}\n+\n+/* Output RTL to push register RN onto the stack.  */\n+\n+static void\n+push (rn)\n+     int rn;\n+{\n+  rtx x;\n+  x = emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n+  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n+\t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n+}\n+\n+/* Output RTL to pop register RN from the stack.  */\n+\n+static void\n+pop (rn)\n+     int rn;\n+{\n+  rtx x;\n+  x = emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n+  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n+\t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n+}\n+\n+/* Generate code to push the regs specified in the mask, and return\n+   the number of bytes the insns take.  */\n+\n+static void\n+push_regs (mask)\n+     int mask;\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (mask & (1 << i))\n+      push (i);\n+}\n+\n+/* Work out the registers which need to be saved, both as a mask and a\n+   count.\n+\n+   If doing a pragma interrupt function, then push all regs used by the\n+   function, and if we call another function (we can tell by looking at PR),\n+   make sure that all the regs it clobbers are safe too.  */\n+\n+static int\n+calc_live_regs (count_ptr)\n+     int *count_ptr;\n+{\n+  int reg;\n+  int live_regs_mask = 0;\n+  int count = 0;\n+\n+  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n+    {\n+      if (pragma_interrupt && ! pragma_trapa)\n+\t{\n+\t  /* Need to save all the regs ever live.  */\n+\t  if ((regs_ever_live[reg]\n+\t       || (call_used_regs[reg] && regs_ever_live[PR_REG]))\n+\t      && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n+\t      && reg != T_REG && reg != GBR_REG)\n+\t    {\n+\t      live_regs_mask |= 1 << reg;\n+\t      count++;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Only push those regs which are used and need to be saved.  */\n+\t  if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t    {\n+\t      live_regs_mask |= (1 << reg);\n+\t      count++;\n+\t    }\n+\t}\n+    }\n+\n+  *count_ptr = count;\n+  return live_regs_mask;\n+}\n+\n+/* Code to generate prologue and epilogue sequences */\n \n void\n sh_expand_prologue ()\n {\n   int live_regs_mask;\n   int d, i;\n-  extern tree current_function_decl;\n   live_regs_mask = calc_live_regs (&d);\n \n   /* We have pretend args if we had an object sent partially in registers\n-     and partially on the stack - eg a large structure.  */\n+     and partially on the stack, e.g. a large structure.  */\n   output_stack_adjust (-current_function_pretend_args_size);\n \n   extra_push = 0;\n@@ -1966,14 +1517,7 @@ sh_expand_prologue ()\n   output_stack_adjust (-get_frame_size ());\n \n   if (frame_pointer_needed)\n-    {\n-      emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n-    }\n-\n-  /* ??? Hack.  Clear out the table set up by gen_shifty_op since this\n-     info does not apply to the next function.  */\n-  for (i = 0; i < 32; i++)\n-    shiftsyms[i] = 0;\n+    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n }\n \n void\n@@ -1985,9 +1529,8 @@ sh_expand_epilogue ()\n   live_regs_mask = calc_live_regs (&d);\n \n   if (frame_pointer_needed)\n-    {\n-      emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n-    }\n+    emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n+\n   output_stack_adjust (get_frame_size ());\n \n   /* Pop all the registers.  */\n@@ -1996,14 +1539,22 @@ sh_expand_epilogue ()\n     {\n       int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n       if (live_regs_mask & (1 << j))\n-\t{\n-\t  pop (j);\n-\t}\n+\tpop (j);\n     }\n \n   output_stack_adjust (extra_push + current_function_pretend_args_size);\n }\n \n+/* Clear variables at function end.  */\n+\n+void\n+function_epilogue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  pragma_interrupt = pragma_trapa = 0;\n+}\n+\n /* Define the offset between two registers, one to be eliminated, and\n    the other its replacement, at the start of a routine.  */\n \n@@ -2020,21 +1571,18 @@ initial_elimination_offset (from, to)\n   total_saved_regs_space = (regs_saved) * 4;\n \n   if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n-    {\n-      return total_saved_regs_space + total_auto_space;\n-    }\n+    return total_saved_regs_space + total_auto_space;\n+\n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    {\n-      return total_saved_regs_space + total_auto_space;\n-    }\n+    return total_saved_regs_space + total_auto_space;\n+\n+  /* Initial gap between fp and sp is 0.  */\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    {\n-      /* Initial gap between fp and sp is 0.  */\n-      return 0;\n-    }\n+    return 0;\n+\n   abort ();\n }\n-\n+\f\n /* Handle machine specific pragmas to be semi-compatible with Hitachi\n    compiler.  */\n \n@@ -2071,40 +1619,25 @@ handle_pragma (file)\n   return c;\n }\n \f\n-/* Insn expand helpers.  */\n+/* Predicates used by the templates.  */\n \n-/* Emit insns to perform a call.  */\n+/* Returns 1 if OP is MACL, MACH or PR.  The input must be a REG rtx.\n+   Used only in general_movsrc_operand.  */\n \n-void\n-expand_acall (isa_retval, operands)\n-     int isa_retval;\n-     rtx *operands;\n+int\n+system_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n {\n-  rtx call;\n-  rtx ret = operands[0];\n-  rtx call_target = operands[isa_retval + 0];\n-  rtx numargs = operands[isa_retval + 1];\n-\n-  if (GET_CODE (call_target) == MEM)\n-    {\n-      call_target = force_reg (Pmode, XEXP (call_target, 0));\n-    }\n-\n-  call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n-\n-  if (isa_retval)\n+  switch (REGNO (op))\n     {\n-      call = gen_rtx (SET, VOIDmode, ret, call);\n+    case PR_REG:\n+    case MACL_REG:\n+    case MACH_REG:\n+      return 1;\n     }\n-\n-  emit_call_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t   gen_rtvec (2,\n-\t\t\t\t      call,\n-\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 17)))));\n-\n+  return 0;\n }\n-\f\n-/* Predicates used by the templates.  */\n \n /* Returns 1 if OP can be source of a simple move operation.\n    Same as general_operand, but a LABEL_REF is valid, PRE_DEC is\n@@ -2125,8 +1658,8 @@ general_movsrc_operand (op, mode)\n \treturn 1;\n \n       if (GET_CODE (inside) == PLUS\n-\t  && GET_CODE (XEXP (inside,0)) == LABEL_REF\n-\t  && GET_CODE (XEXP (inside,1)) == CONST_INT)\n+\t  && GET_CODE (XEXP (inside, 0)) == LABEL_REF\n+\t  && GET_CODE (XEXP (inside, 1)) == CONST_INT)\n \treturn 1;\n \n       /* Only post inc allowed.  */\n@@ -2145,7 +1678,6 @@ general_movsrc_operand (op, mode)\n   return general_operand (op, mode);\n }\n \n-\n /* Returns 1 if OP can be a destination of a move.\n    Same as general_operand, but no preinc allowed.  */\n \n@@ -2164,20 +1696,6 @@ general_movdst_operand (op, mode)\n   return general_operand (op, mode);\n }\n \n-\n-\n-/* Returns 1 if OP is an immediate ok for a byte index.  */\n-\n-int\n-byte_index_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= 0\n-\t  && INTVAL (op) <= 15);\n-}\n-\n /* Returns 1 if OP is a normal arithmetic register.  */\n \n int\n@@ -2197,27 +1715,6 @@ arith_reg_operand (op, mode)\n   return 0;\n }\n \n-/* Returns 1 if OP is MACL, MACH or PR.  */\n-\n-int\n-system_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == REG)\n-    {\n-      switch (REGNO (op))\n-\t{\n-\tcase PR_REG:\n-\tcase MACL_REG:\n-\tcase MACH_REG:\n-\t  return 1;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-\n /* Returns 1 if OP is a valid source operand for an arithmetic insn.  */\n \n int\n@@ -2228,11 +1725,9 @@ arith_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (CONST_OK_FOR_I (INTVAL (op)))\n-\treturn 1;\n-    }\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))\n+    return 1;\n+\n   return 0;\n }\n \n@@ -2246,15 +1741,12 @@ arith_reg_or_0_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (CONST_OK_FOR_N (INTVAL (op)))\n-\treturn 1;\n-    }\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_N (INTVAL (op)))\n+    return 1;\n+\n   return 0;\n }\n \n-\n /* Returns 1 if OP is a valid source operand for a logical operation.  */\n \n int\n@@ -2265,14 +1757,12 @@ logical_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (CONST_OK_FOR_L (INTVAL (op)))\n-\treturn 1;\n-    }\n+  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))\n+    return 1;\n+\n   return 0;\n }\n-\n+\f\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -2295,16 +1785,11 @@ sh_function_arg (cum, mode, type, named)\n {\n   if (named)\n     {\n-      int rr = (ROUND_REG ((cum), (mode)));\n+      int rr = (ROUND_REG (cum, mode));\n \n       if (rr < NPARM_REGS)\n-\t{\n-\t  return (((type) == 0 || !TREE_ADDRESSABLE ((tree) (type)))\n-\t\t  ? gen_rtx (REG, (mode),\n-\t\t\t     (FIRST_PARM_REG + rr))\n-\t\t  : 0);\n-\n-\t}\n+\treturn ((type == 0 || ! TREE_ADDRESSABLE (type))\n+\t\t? gen_rtx (REG, mode, FIRST_PARM_REG + rr) : 0);\n     }\n   return 0;\n }\n@@ -2316,21 +1801,19 @@ sh_function_arg (cum, mode, type, named)\n    needs partial registers on the SH.  */\n \n int\n-sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n-     CUMULATIVE_ARGS CUM;\n-     enum machine_mode MODE;\n-     tree TYPE;\n-     int NAMED;\n+sh_function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n {\n-  if ((CUM) < NPARM_REGS)\n+  if (cum < NPARM_REGS)\n     {\n-      if (((TYPE) == 0 || !TREE_ADDRESSABLE ((tree) (TYPE)))\n-\t  && ((CUM) + ((MODE) == BLKmode\n-\t\t       ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\n-\t\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0))\n-\t{\n-\t  return NPARM_REGS - CUM;\n-\t}\n+      if ((type == 0 || ! TREE_ADDRESSABLE (type))\n+\t  && (cum + (mode == BLKmode\n+\t\t     ? ROUND_ADVANCE (int_size_in_bytes (type))\n+\t\t     : ROUND_ADVANCE (GET_MODE_SIZE (mode))) - NPARM_REGS > 0))\n+\treturn NPARM_REGS - cum;\n     }\n   return 0;\n }"}]}