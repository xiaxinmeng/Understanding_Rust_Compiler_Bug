{"sha": "1271b772038d1e01cfed35ea5c764ceedc9842f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI3MWI3NzIwMzhkMWUwMWNmZWQzNWVhNWM3NjRjZWVkYzk4NDJmOQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-05T14:27:44Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:20Z"}, "message": "Added more trait item stripping\n\nFixed lack of AST:: prepending in rust-parse-impl.h - should prevent compilation error\n\nFixed expr renaming in Method as_string, should prevent compile error\n\nFixed issue with changing location accessibility for AST nodes\n\nFixed rust-compile.cc not using get_locus() instead of .locus", "tree": {"sha": "7a79b1fc23c33a0bb5f7916ac3a8973fb3387ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a79b1fc23c33a0bb5f7916ac3a8973fb3387ed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1271b772038d1e01cfed35ea5c764ceedc9842f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1271b772038d1e01cfed35ea5c764ceedc9842f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1271b772038d1e01cfed35ea5c764ceedc9842f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1271b772038d1e01cfed35ea5c764ceedc9842f9/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69048af1878e95e26b57febb701f884f513c7b93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69048af1878e95e26b57febb701f884f513c7b93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69048af1878e95e26b57febb701f884f513c7b93"}], "stats": {"total": 666, "additions": 498, "deletions": 168}, "files": [{"sha": "aef02ce1d92d43084dad062b94d82b0677a1fdcf", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -161,7 +161,7 @@ TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n   bool ok = scope.LookupType (ident_expr.ident, &type);\n   if (!ok)\n     {\n-      rust_error_at (ident_expr.locus, \"unknown identifier\");\n+      rust_error_at (ident_expr.get_locus (), \"unknown identifier\");\n       return;\n     }\n \n@@ -272,7 +272,7 @@ TypeResolution::visit (AST::LiteralExpr &expr)\n \n   if (type.empty ())\n     {\n-      rust_error_at (expr.locus, \"unknown literal: %s\",\n+      rust_error_at (expr.get_locus (), \"unknown literal: %s\",\n \t\t     expr.literal.as_string ().c_str ());\n       return;\n     }\n@@ -282,7 +282,7 @@ TypeResolution::visit (AST::LiteralExpr &expr)\n   if (ok)\n     typeBuffer.push_back (val);\n   else\n-    rust_error_at (expr.locus, \"unknown literal type: %s\", type.c_str ());\n+    rust_error_at (expr.get_locus (), \"unknown literal type: %s\", type.c_str ());\n }\n \n void\n@@ -318,7 +318,7 @@ TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n   expr.visit_lhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n       return;\n     }\n \n@@ -329,7 +329,7 @@ TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n   expr.visit_rhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n       return;\n     }\n \n@@ -361,7 +361,7 @@ TypeResolution::visit (AST::AssignmentExpr &expr)\n   expr.visit_lhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n       return;\n     }\n \n@@ -372,7 +372,7 @@ TypeResolution::visit (AST::AssignmentExpr &expr)\n   expr.visit_rhs (*this);\n   if (typeBuffer.size () <= before)\n     {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n+      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n       return;\n     }\n \n@@ -583,7 +583,7 @@ TypeResolution::visit (AST::CallExpr &expr)\n   auto numInferedParams = typeBuffer.size () - before;\n   if (numInferedParams != expr.params.size ())\n     {\n-      rust_error_at (expr.locus, \"Failed to infer all parameters\");\n+      rust_error_at (expr.get_locus (), \"Failed to infer all parameters\");\n       return;\n     }\n \n@@ -768,14 +768,14 @@ TypeResolution::visit (AST::Function &function)\n \n   for (auto &param : function.function_params)\n     {\n-      if (!isTypeInScope (param.type.get (), param.locus))\n+      if (!isTypeInScope (param.type.get (), param.get_locus ()))\n \treturn;\n \n       auto before = letPatternBuffer.size ();\n       param.param_name->accept_vis (*this);\n       if (letPatternBuffer.size () <= before)\n \t{\n-\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n+\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n \t  return;\n \t}\n \n@@ -787,7 +787,7 @@ TypeResolution::visit (AST::Function &function)\n   // ensure the return type is resolved\n   if (function.has_function_return_type ())\n     {\n-      if (!isTypeInScope (function.return_type.get (), function.locus))\n+      if (!isTypeInScope (function.return_type.get (), function.get_locus ()))\n \treturn;\n     }\n \n@@ -1006,7 +1006,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n   scope.InsertLocal (stmt.as_string (), &stmt);\n   if (!stmt.has_init_expr () && !stmt.has_type ())\n     {\n-      rust_error_at (stmt.locus,\n+      rust_error_at (stmt.get_locus (),\n \t\t     \"E0282: type annotations or init expression needed\");\n       return;\n     }"}, {"sha": "807122619c6c7445a165289f1a8d74a9b084baaf", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -678,33 +678,23 @@ Method::as_string () const\n   else\n     {\n       for (const auto &param : function_params)\n-\t{\n \t  str += \"\\n  \" + param.as_string ();\n-\t}\n     }\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-    {\n       str += return_type->as_string ();\n-    }\n   else\n-    {\n       str += \"none (void)\";\n-    }\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n       str += where_clause.as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   str += \"\\n Block expr (body): \\n  \";\n-  str += expr->as_string ();\n+  str += function_body->as_string ();\n \n   return str;\n }"}, {"sha": "e0f46ac6acf076339621c4358ca202f04cb21fe5", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -1221,21 +1221,12 @@ class TraitItem\n   // NOTE: all children should have outer attributes\n \n protected:\n-  // Constructor\n-  /*TraitItem(std::vector<Attribute> outer_attrs = std::vector<Attribute>())\n-    : outer_attrs(std::move(outer_attrs)) {}*/\n-\n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n \n public:\n   virtual ~TraitItem () {}\n \n-  // Returns whether TraitItem has outer attributes.\n-  /*bool has_outer_attrs() const {\n-      return !outer_attrs.empty();\n-  }*/\n-\n   // Unique pointer custom clone function\n   std::unique_ptr<TraitItem> clone_trait_item () const\n   {\n@@ -1245,6 +1236,9 @@ class TraitItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n };\n \n /* Abstract base class for items used within an inherent impl block (the impl\n@@ -1267,6 +1261,9 @@ class InherentImplItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n };\n \n // Abstract base class for items used in a trait impl\n@@ -1276,7 +1273,7 @@ class TraitImplItem\n   virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n \n public:\n-  virtual ~TraitImplItem (){};\n+  virtual ~TraitImplItem () {};\n \n   // Unique pointer custom clone function\n   std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n@@ -1287,6 +1284,9 @@ class TraitImplItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n };\n \n // Abstract base class for an item used inside an extern block"}, {"sha": "a56d1b571732fc26be993edc4da41061d9ae8755", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 201, "deletions": 38, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -434,31 +434,45 @@ struct FunctionQualifiers\n // A function parameter\n struct FunctionParam\n {\n+private:\n+  std::vector<Attribute> outer_attrs;\n+  Location locus;\n+\n public:\n   std::unique_ptr<Pattern> param_name;\n   std::unique_ptr<Type> type;\n \n-  Location locus;\n-\n   FunctionParam (std::unique_ptr<Pattern> param_name,\n-\t\t std::unique_ptr<Type> param_type, Location locus)\n-    : param_name (std::move (param_name)), type (std::move (param_type)),\n-      locus (locus)\n+\t\t std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), locus (locus), \n+      param_name (std::move (param_name)), type (std::move (param_type))\n   {}\n \n   // Copy constructor uses clone\n-  FunctionParam (FunctionParam const &other)\n-    : param_name (other.param_name->clone_pattern ()),\n-      type (other.type->clone_type ()), locus (other.locus)\n-  {}\n+  FunctionParam (FunctionParam const &other) : locus (other.locus)\n+  {\n+    // guard to prevent nullptr dereference\n+    if (other.param_name != nullptr)\n+      param_name = other.param_name->clone_pattern ();\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // Overload assignment operator to use clone\n   FunctionParam &operator= (FunctionParam const &other)\n   {\n-    param_name = other.param_name->clone_pattern ();\n-    type = other.type->clone_type ();\n     locus = other.locus;\n \n+    // guard to prevent nullptr dereference\n+    if (other.param_name != nullptr)\n+      param_name = other.param_name->clone_pattern ();\n+    else\n+      param_name = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -472,12 +486,16 @@ struct FunctionParam\n   // Creates an error FunctionParam.\n   static FunctionParam create_error ()\n   {\n-    return FunctionParam (nullptr, nullptr, Location ());\n+    return FunctionParam (nullptr, nullptr, {}, Location ());\n   }\n \n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -596,15 +614,15 @@ class Method : public InherentImplItem, public TraitImplItem\n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::unique_ptr<BlockExpr> expr;\n+  std::unique_ptr<BlockExpr> function_body;\n \n   Location locus;\n \n public:\n   // Returns whether the method is in an error state.\n   bool is_error () const\n   {\n-    return expr == nullptr || method_name.empty () || self_param.is_error ();\n+    return function_body == nullptr || method_name.empty () || self_param.is_error ();\n   }\n \n   // Creates an error state method.\n@@ -614,7 +632,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \t\t   std::vector<std::unique_ptr<GenericParam>> (),\n \t\t   SelfParam::create_error (), std::vector<FunctionParam> (),\n \t\t   nullptr, WhereClause::create_empty (), nullptr,\n-\t\t   Visibility::create_error (), std::vector<Attribute> ());\n+\t\t   Visibility::create_error (), std::vector<Attribute> (), {});\n   }\n \n   // Returns whether the method has generic parameters.\n@@ -638,15 +656,15 @@ class Method : public InherentImplItem, public TraitImplItem\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t  std::vector<Attribute> outer_attrs, Location locus = Location ())\n+\t  std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), vis (std::move (vis)),\n       qualifiers (std::move (qualifiers)),\n       method_name (std::move (method_name)),\n       generic_params (std::move (generic_params)),\n       self_param (std::move (self_param)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), expr (std::move (function_body)),\n+      where_clause (std::move (where_clause)), function_body (std::move (function_body)),\n       locus (locus)\n   {}\n \n@@ -657,10 +675,16 @@ class Method : public InherentImplItem, public TraitImplItem\n     : outer_attrs (other.outer_attrs), vis (other.vis),\n       qualifiers (other.qualifiers), method_name (other.method_name),\n       self_param (other.self_param), function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause), expr (other.expr->clone_block_expr ()),\n-      locus (other.locus)\n+      where_clause (other.where_clause), locus (other.locus)\n   {\n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -675,11 +699,21 @@ class Method : public InherentImplItem, public TraitImplItem\n     qualifiers = other.qualifiers;\n     self_param = other.self_param;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n-    expr = other.expr->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+    else\n+      function_body = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -695,6 +729,10 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if block is null, so base stripping on that.\n+  void mark_for_strip () override { function_body = nullptr; }\n+  bool is_marked_for_strip () const override { return function_body == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2268,9 +2306,12 @@ struct TraitFunctionDecl\n   TraitFunctionDecl (TraitFunctionDecl const &other)\n     : qualifiers (other.qualifiers), function_name (other.function_name),\n       function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n       where_clause (other.where_clause)\n   {\n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2284,9 +2325,14 @@ struct TraitFunctionDecl\n     function_name = other.function_name;\n     qualifiers = other.qualifiers;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n \n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2299,6 +2345,14 @@ struct TraitFunctionDecl\n   TraitFunctionDecl &operator= (TraitFunctionDecl &&other) = default;\n \n   std::string as_string () const;\n+\n+  // Invalid if function name is empty, so base stripping on that.\n+  void mark_for_strip () { function_name = \"\"; }\n+  bool is_marked_for_strip () const { return function_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n };\n \n // Actual trait item function declaration within traits\n@@ -2323,6 +2377,7 @@ class TraitItemFunc : public TraitItem\n   TraitItemFunc (TraitItemFunc const &other)\n     : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n   {\n+    // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n       block_expr = other.block_expr->clone_block_expr ();\n   }\n@@ -2334,8 +2389,12 @@ class TraitItemFunc : public TraitItem\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n     locus = other.locus;\n+\n+    // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n       block_expr = other.block_expr->clone_block_expr ();\n+    else\n+      block_expr = nullptr;\n \n     return *this;\n   }\n@@ -2350,6 +2409,17 @@ class TraitItemFunc : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if trait decl is empty, so base stripping on that.\n+  void mark_for_strip () override { decl.mark_for_strip (); }\n+  bool is_marked_for_strip () const override { return decl.is_marked_for_strip (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<FunctionParam> &get_function_params () { return decl.get_function_params (); }\n+  const std::vector<FunctionParam> &get_function_params () const { return decl.get_function_params (); }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemFunc *clone_trait_item_impl () const override\n@@ -2416,9 +2486,12 @@ struct TraitMethodDecl\n   TraitMethodDecl (TraitMethodDecl const &other)\n     : qualifiers (other.qualifiers), function_name (other.function_name),\n       self_param (other.self_param), function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n       where_clause (other.where_clause)\n   {\n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2433,9 +2506,14 @@ struct TraitMethodDecl\n     qualifiers = other.qualifiers;\n     self_param = other.self_param;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n \n+    // guard to prevent nullptr dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2448,6 +2526,14 @@ struct TraitMethodDecl\n   TraitMethodDecl &operator= (TraitMethodDecl &&other) = default;\n \n   std::string as_string () const;\n+\n+  // Invalid if method name is empty, so base stripping on that.\n+  void mark_for_strip () { function_name = \"\"; }\n+  bool is_marked_for_strip () const { return function_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n };\n \n // Actual trait item method declaration within traits\n@@ -2471,18 +2557,27 @@ class TraitItemMethod : public TraitItem\n   // Copy constructor with clone\n   TraitItemMethod (TraitItemMethod const &other)\n     : outer_attrs (other.outer_attrs), decl (other.decl),\n-      block_expr (other.block_expr->clone_block_expr ()), locus (other.locus)\n-  {}\n+      locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.block_expr != nullptr)\n+      block_expr = other.block_expr->clone_block_expr ();\n+  }\n \n   // Overloaded assignment operator to clone\n   TraitItemMethod &operator= (TraitItemMethod const &other)\n   {\n     TraitItem::operator= (other);\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n-    block_expr = other.block_expr->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.block_expr != nullptr)\n+      block_expr = other.block_expr->clone_block_expr ();\n+    else\n+      block_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2496,6 +2591,17 @@ class TraitItemMethod : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if trait decl is empty, so base stripping on that.\n+  void mark_for_strip () override { decl.mark_for_strip (); }\n+  bool is_marked_for_strip () const override { return decl.is_marked_for_strip (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<FunctionParam> &get_function_params () { return decl.get_function_params (); }\n+  const std::vector<FunctionParam> &get_function_params () const { return decl.get_function_params (); }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemMethod *clone_trait_item_impl () const override\n@@ -2529,21 +2635,37 @@ class TraitItemConst : public TraitItem\n \n   // Copy constructor with clones\n   TraitItemConst (TraitItemConst const &other)\n-    : outer_attrs (other.outer_attrs), name (other.name),\n-      type (other.type->clone_type ()), expr (other.expr->clone_expr ()),\n-      locus (other.locus)\n-  {}\n+    : outer_attrs (other.outer_attrs), name (other.name), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+    \n+    // guard to prevent null dereference (only for error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // Overloaded assignment operator to clone\n   TraitItemConst &operator= (TraitItemConst const &other)\n   {\n     TraitItem::operator= (other);\n     outer_attrs = other.outer_attrs;\n     name = other.name;\n-    type = other.type->clone_type ();\n-    expr = other.expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+    else\n+      expr = nullptr;\n+\n+    // guard to prevent null dereference (only for error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -2557,6 +2679,14 @@ class TraitItemConst : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if type is null, so base stripping on that.\n+  void mark_for_strip () override { type = nullptr; }\n+  bool is_marked_for_strip () const override { return type == nullptr; }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -2625,6 +2755,14 @@ class TraitItemType : public TraitItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { name = \"\"; }\n+  bool is_marked_for_strip () const override { return name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override\n@@ -2651,6 +2789,8 @@ class Trait : public VisItem\n   // bool has_where_clause;\n   WhereClause where_clause;\n \n+  std::vector<Attribute> inner_attrs;\n+\n   // bool has_trait_items;\n   std::vector<std::unique_ptr<TraitItem>> trait_items;\n \n@@ -2671,25 +2811,28 @@ class Trait : public VisItem\n   // Returns whether trait has trait items.\n   bool has_trait_items () const { return !trait_items.empty (); }\n \n+  // Returns whether trait has inner attributes.\n+  bool has_inner_attrs () const { return !inner_attrs.empty (); }\n+\n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n \t std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n \t WhereClause where_clause,\n \t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n-\t std::vector<Attribute> outer_attrs, Location locus)\n+\t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n       type_param_bounds (std::move (type_param_bounds)),\n-      where_clause (std::move (where_clause)),\n+      where_clause (std::move (where_clause)), inner_attrs (std::move (inner_attrs)),\n       trait_items (std::move (trait_items)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   Trait (Trait const &other)\n     : VisItem (other), has_unsafe (other.has_unsafe), name (other.name),\n-      where_clause (other.where_clause), locus (other.locus)\n+      where_clause (other.where_clause), inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -2711,6 +2854,7 @@ class Trait : public VisItem\n     name = other.name;\n     has_unsafe = other.has_unsafe;\n     where_clause = other.where_clause;\n+    inner_attrs = other.inner_attrs;\n     locus = other.locus;\n \n     generic_params.reserve (other.generic_params.size ());\n@@ -2740,6 +2884,13 @@ class Trait : public VisItem\n   void mark_for_strip () override { name = \"\"; }\n   bool is_marked_for_strip () const override { return name.empty (); }\n \n+  // TODO: think of better way to do this\n+  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+\n+  const std::vector<std::unique_ptr<TraitItem>>& get_trait_items () const { return trait_items; }\n+  std::vector<std::unique_ptr<TraitItem>>& get_trait_items () { return trait_items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2783,6 +2934,10 @@ class Impl : public VisItem\n   void mark_for_strip () override { trait_type = nullptr; }\n   bool is_marked_for_strip () const override { return trait_type == nullptr; }\n \n+  // TODO: think of better way to do this\n+  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+\n protected:\n   // Mega-constructor\n   Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -2886,6 +3041,10 @@ class InherentImpl : public Impl\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: think of better way to do this\n+  const std::vector<std::unique_ptr<InherentImplItem>>& get_impl_items () const { return impl_items; }\n+  std::vector<std::unique_ptr<InherentImplItem>>& get_impl_items () { return impl_items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2958,6 +3117,10 @@ class TraitImpl : public Impl\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: think of better way to do this\n+  const std::vector<std::unique_ptr<TraitImplItem>>& get_impl_items () const { return impl_items; }\n+  std::vector<std::unique_ptr<TraitImplItem>>& get_impl_items () { return impl_items; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "af0f45441af9ff9865c9198f987bb57e0f7484ab", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -173,10 +173,10 @@ Compilation::visit (AST::IdentifierExpr &ident_expr)\n   Bvariable *var = NULL;\n   if (!scope.LookupVar (ident_expr.as_string (), &var))\n     {\n-      rust_fatal_error (ident_expr.locus, \"unknown var\");\n+      rust_fatal_error (ident_expr.get_locus (), \"unknown var\");\n       return;\n     }\n-  exprs.push_back (backend->var_expression (var, ident_expr.locus));\n+  exprs.push_back (backend->var_expression (var, ident_expr.get_locus ()));\n }\n \n void\n@@ -199,7 +199,7 @@ Compilation::visit (AST::PathInExpression &path)\n   if (scope.LookupFunction (path.as_string (), &fn))\n     {\n       auto expr\n-\t= backend->function_code_expression (fn, path.get_locus_slow ());\n+\t= backend->function_code_expression (fn, path.get_locus ());\n       exprs.push_back (expr);\n       translatedType = scope.GetFnRetType (fn);\n       return;\n@@ -221,14 +221,14 @@ Compilation::visit (AST::TypePath &path)\n {\n   if (path.segments.size () > 1)\n     {\n-      rust_error_at (path.locus, \"unable to compile multi segment types yet\");\n+      rust_error_at (path.get_locus (), \"unable to compile multi segment types yet\");\n       return;\n     }\n \n   Btype *type = NULL;\n   if (!scope.LookupType (path.as_string (), &type))\n     {\n-      rust_error_at (path.locus, \"unknown type\");\n+      rust_error_at (path.get_locus (), \"unknown type\");\n       return;\n     }\n   translatedType = type;\n@@ -254,16 +254,16 @@ Compilation::visit (AST::LiteralExpr &expr)\n \n     case AST::Literal::FLOAT:\n       compiled\n-\t= compileFloatLiteral (expr.as_string (), expr.get_locus_slow ());\n+\t= compileFloatLiteral (expr.as_string (), expr.get_locus ());\n       break;\n \n     case AST::Literal::INT:\n       compiled\n-\t= compileIntegerLiteral (expr.as_string (), expr.get_locus_slow ());\n+\t= compileIntegerLiteral (expr.as_string (), expr.get_locus ());\n       break;\n \n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"unknown literal\");\n+      rust_fatal_error (expr.get_locus (), \"unknown literal\");\n       return;\n     }\n \n@@ -311,11 +311,11 @@ Compilation::visit (AST::NegationExpr &expr)\n       op = OPERATOR_NOT;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n-  auto unary = backend->unary_expression (op, root, expr.get_locus_slow ());\n+  auto unary = backend->unary_expression (op, root, expr.get_locus ());\n   exprs.push_back (unary);\n }\n \n@@ -372,12 +372,12 @@ Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n       op = OPERATOR_RSHIFT;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n   auto binExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n   exprs.push_back (binExpr);\n }\n \n@@ -422,12 +422,12 @@ Compilation::visit (AST::ComparisonExpr &expr)\n       op = OPERATOR_LE;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n   auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n   exprs.push_back (compExpr);\n }\n \n@@ -460,12 +460,12 @@ Compilation::visit (AST::LazyBooleanExpr &expr)\n       op = OPERATOR_ANDAND;\n       break;\n     default:\n-      rust_fatal_error (expr.get_locus_slow (), \"failed to compile operator\");\n+      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n       return;\n     }\n \n   auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus_slow ());\n+    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n   exprs.push_back (compExpr);\n }\n \n@@ -493,7 +493,7 @@ Compilation::visit (AST::AssignmentExpr &expr)\n     }\n \n   auto s = backend->assignment_statement (scope.GetCurrentFndecl (), lhs, rhs,\n-\t\t\t\t\t  expr.get_locus_slow ());\n+\t\t\t\t\t  expr.get_locus ());\n   scope.AddStatement (s);\n }\n \n@@ -582,14 +582,14 @@ Compilation::visit (AST::StructExprStructFields &expr)\n   AST::StructStruct *decl = NULL;\n   if (!scope.LookupStructDecl (expr.get_struct_name ().as_string (), &decl))\n     {\n-      rust_error_at (expr.get_locus_slow (), \"unknown type\");\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n       return;\n     }\n \n   Btype *structType = NULL;\n   if (!scope.LookupType (expr.get_struct_name ().as_string (), &structType))\n     {\n-      rust_fatal_error (expr.get_locus_slow (), \"unknown type\");\n+      rust_fatal_error (expr.get_locus (), \"unknown type\");\n       return;\n     }\n \n@@ -601,10 +601,10 @@ Compilation::visit (AST::StructExprStructFields &expr)\n   for (auto &field : expr.fields)\n     {\n       Bexpression *value = NULL;\n-      VISIT_POP (expr.get_locus_slow (), field, value, exprs);\n+      VISIT_POP (expr.get_locus (), field, value, exprs);\n       if (value == NULL)\n \t{\n-\t  rust_fatal_error (expr.get_locus_slow (),\n+\t  rust_fatal_error (expr.get_locus (),\n \t\t\t    \"failed to compile value to struct\");\n \t  return;\n \t}\n@@ -614,7 +614,7 @@ Compilation::visit (AST::StructExprStructFields &expr)\n \n   structBuffer.pop_back ();\n   auto cons = backend->constructor_expression (structType, constructor,\n-\t\t\t\t\t       expr.get_locus_slow ());\n+\t\t\t\t\t       expr.get_locus ());\n   exprs.push_back (cons);\n }\n \n@@ -674,7 +674,7 @@ Compilation::visit (AST::CallExpr &expr)\n     }\n \n   auto call = backend->call_expression (scope.GetCurrentFndecl (), fn, args,\n-\t\t\t\t\tNULL, expr.locus);\n+\t\t\t\t\tNULL, expr.get_locus ());\n   exprs.push_back (call);\n }\n \n@@ -751,7 +751,7 @@ Compilation::visit (AST::ReturnExpr &expr)\n   std::vector<Bexpression *> retstmts;\n   retstmts.push_back (ret);\n   auto s = backend->return_statement (scope.GetCurrentFndecl (), retstmts,\n-\t\t\t\t      expr.locus);\n+\t\t\t\t      expr.get_locus ());\n   scope.AddStatement (s);\n }\n \n@@ -791,7 +791,7 @@ Compilation::visit (AST::IfExpr &expr)\n   Bblock *then_block = scope.PopBlock ();\n \n   auto stmt = backend->if_statement (scope.GetCurrentFndecl (), cond,\n-\t\t\t\t     then_block, NULL, expr.get_locus_slow ());\n+\t\t\t\t     then_block, NULL, expr.get_locus ());\n   stmts.push_back (stmt);\n }\n \n@@ -816,7 +816,7 @@ Compilation::visit (AST::IfExprConseqElse &expr)\n \n   auto stmt\n     = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus_slow ());\n+\t\t\t     else_block, expr.get_locus ());\n   stmts.push_back (stmt);\n }\n \n@@ -856,7 +856,7 @@ Compilation::visit (AST::IfExprConseqIf &expr)\n \n   auto stmt\n     = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus_slow ());\n+\t\t\t     else_block, expr.get_locus ());\n   stmts.push_back (stmt);\n }\n \n@@ -956,15 +956,15 @@ Compilation::visit (AST::Function &function)\n       param.type->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n-\t  rust_error_at (param.locus, \"failed to generate type for parameter\");\n+\t  rust_error_at (param.get_locus (), \"failed to generate type for parameter\");\n \t  return;\n \t}\n \n       auto before = patternBuffer.size ();\n       param.param_name->accept_vis (*this);\n       if (patternBuffer.size () <= before)\n \t{\n-\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n+\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n \t  return;\n \t}\n \n@@ -975,7 +975,7 @@ Compilation::visit (AST::Function &function)\n \t  patternBuffer.pop_back ();\n \t  parameters.push_back (\n \t    Backend::Btyped_identifier (paramName.variable_ident,\n-\t\t\t\t\ttranslatedType, param.locus));\n+\t\t\t\t\ttranslatedType, param.get_locus ()));\n \t}\n     }\n \n@@ -986,7 +986,7 @@ Compilation::visit (AST::Function &function)\n       function.return_type->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n-\t  rust_fatal_error (function.locus,\n+\t  rust_fatal_error (function.get_locus (),\n \t\t\t    \"failed to generate type for function\");\n \t  return;\n \t}\n@@ -998,10 +998,10 @@ Compilation::visit (AST::Function &function)\n     }\n \n   Btype *fntype = backend->function_type (receiver, parameters, results, NULL,\n-\t\t\t\t\t  function.locus);\n+\t\t\t\t\t  function.get_locus ());\n   Bfunction *fndecl\n     = backend->function (fntype, function.function_name, \"\" /* asm_name */,\n-\t\t\t 0 /* flags */, function.locus);\n+\t\t\t 0 /* flags */, function.get_locus ());\n \n   scope.InsertFunction (function.function_name, fndecl, returnType);\n   scope.Push ();\n@@ -1020,7 +1020,7 @@ Compilation::visit (AST::Function &function)\n \n   if (!backend->function_set_parameters (fndecl, param_vars))\n     {\n-      rust_error_at (function.locus, \"failed to setup parameter variables\");\n+      rust_error_at (function.get_locus (), \"failed to setup parameter variables\");\n       return;\n     }\n \n@@ -1029,15 +1029,15 @@ Compilation::visit (AST::Function &function)\n     {\n       if (!compileVarDecl (fndecl, decl, vars))\n \t{\n-\t  rust_error_at (decl->locus, \"failed to compile var decl\");\n+\t  rust_error_at (decl->get_locus (), \"failed to compile var decl\");\n \t  return;\n \t}\n     }\n \n   // is null for top level functions - nested functions will have an enclosing\n   // scope\n   Bblock *enclosingScope = NULL;\n-  Location start_location = function.locus;\n+  Location start_location = function.get_locus ();\n   Location end_location;\n   if (function.function_body->statements.size () > 0)\n     {\n@@ -1057,7 +1057,7 @@ Compilation::visit (AST::Function &function)\n       Bstatement *ret_var_stmt = NULL;\n       retDecl = backend->temporary_variable (fndecl, code_block, returnType,\n \t\t\t\t\t     NULL, address_is_taken,\n-\t\t\t\t\t     function.locus, &ret_var_stmt);\n+\t\t\t\t\t     function.get_locus (), &ret_var_stmt);\n       scope.AddStatement (ret_var_stmt);\n     }\n   scope.PushCurrentFunction (function.function_name, fndecl, returnType,\n@@ -1071,7 +1071,7 @@ Compilation::visit (AST::Function &function)\n   auto body = backend->block_statement (code_block);\n   if (!backend->function_set_body (fndecl, body))\n     {\n-      rust_error_at (function.locus, \"failed to set body to function\");\n+      rust_error_at (function.get_locus (), \"failed to set body to function\");\n       return;\n     }\n \n@@ -1096,23 +1096,23 @@ Compilation::visit (AST::StructStruct &struct_item)\n       if (translatedType == NULL)\n \t{\n \t  rust_fatal_error (\n-\t    struct_item.locus /* StructField is mi sing locus */,\n+\t    struct_item.get_locus () /* StructField is mi sing locus */,\n \t    \"failed to compile struct field\");\n \t  return;\n \t}\n \n       fields.push_back (Backend::Btyped_identifier (\n \tfield.field_name, translatedType,\n-\tstruct_item.locus /* StructField is mi sing locus */));\n+\tstruct_item.get_locus () /* StructField is mi sing locus */));\n     }\n \n   auto compiledStruct\n     = backend->placeholder_struct_type (struct_item.struct_name,\n-\t\t\t\t\tstruct_item.locus);\n+\t\t\t\t\tstruct_item.get_locus ());\n   bool ok = backend->set_placeholder_struct_type (compiledStruct, fields);\n   if (!ok)\n     {\n-      rust_fatal_error (struct_item.locus, \"failed to compile struct\");\n+      rust_fatal_error (struct_item.get_locus (), \"failed to compile struct\");\n       return;\n     }\n \n@@ -1304,7 +1304,7 @@ Compilation::visit (AST::LetStmt &stmt)\n       Bvariable *var = NULL;\n       if (!scope.LookupVar (pattern.variable_ident, &var))\n \t{\n-\t  rust_error_at (stmt.locus, \"failed to find var decl for %s\",\n+\t  rust_error_at (stmt.get_locus (), \"failed to find var decl for %s\",\n \t\t\t pattern.variable_ident.c_str ());\n \t  return;\n \t}"}, {"sha": "c7524dc91fdf1c22e798a8b00829f8a3786bbea5", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 165, "deletions": 12, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -105,7 +105,14 @@ namespace Rust {\n         void visit(AST::UseTreeGlob& use_tree) override {}\n         void visit(AST::UseTreeList& use_tree) override {}\n         void visit(AST::UseTreeRebind& use_tree) override {}\n-        void visit(AST::UseDeclaration& use_decl) override {}\n+        void visit(AST::UseDeclaration& use_decl) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(use_decl.get_outer_attrs());\n+            if (expander.fails_cfg(use_decl.get_outer_attrs())) {\n+                use_decl.mark_for_strip();\n+                return;\n+            }\n+        }\n         void visit(AST::Function& function) override {}\n         void visit(AST::TypeAlias& type_alias) override {}\n         void visit(AST::StructStruct& struct_item) override {}\n@@ -117,14 +124,158 @@ namespace Rust {\n         void visit(AST::Enum& enum_item) override {}\n         void visit(AST::Union& union_item) override {}\n         void visit(AST::ConstantItem& const_item) override {}\n-        void visit(AST::StaticItem& static_item) override {}\n-        void visit(AST::TraitItemFunc& item) override {}\n-        void visit(AST::TraitItemMethod& item) override {}\n-        void visit(AST::TraitItemConst& item) override {}\n-        void visit(AST::TraitItemType& item) override {}\n-        void visit(AST::Trait& trait) override {}\n-        void visit(AST::InherentImpl& impl) override {}\n-        void visit(AST::TraitImpl& impl) override {}\n+        void visit(AST::StaticItem& static_item) override {\n+            \n+        }\n+        void visit(AST::TraitItemFunc& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip function parameters if required - this is specifically \n+             * allowed by spec */\n+            auto& params = item.get_function_params();\n+            for (int i = 0; i < params.size(); ) {\n+                auto& param_attrs = params[i].get_outer_attrs ();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg (param_attrs))\n+                    params.erase (params.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::TraitItemMethod& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* assuming you can't strip self param - wouldn't be a method \n+             * anymore. spec allows outer attrs on self param, but doesn't\n+             * specify whether cfg is used. */\n+\n+            /* strip function parameters if required - this is specifically \n+             * allowed by spec */\n+            auto& params = item.get_function_params();\n+            for (int i = 0; i < params.size(); ) {\n+                auto& param_attrs = params[i].get_outer_attrs ();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg (param_attrs))\n+                    params.erase (params.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::TraitItemConst& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+            /* TODO: is there any way to invalidate the expr? Are attributes \n+             * even allowed on it? */\n+        }\n+        void visit(AST::TraitItemType& item) override {\n+            // initial test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::Trait& trait) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(trait.get_outer_attrs());\n+            if (expander.fails_cfg(trait.get_outer_attrs())) {\n+                trait.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip test based on inner attrs\n+            expander.expand_cfg_attrs(trait.get_inner_attrs());\n+            if (expander.fails_cfg(trait.get_inner_attrs())) {\n+                trait.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip trait items if required\n+            auto& trait_items = trait.get_trait_items();\n+            for (int i = 0; i < trait_items.size(); ) {\n+                auto& item = trait_items[i];\n+\n+                // mark for stripping if required\n+                item->accept_vis(*this);\n+\n+                if (item->is_marked_for_strip ())\n+                    trait_items.erase (trait_items.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::InherentImpl& impl) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(impl.get_outer_attrs());\n+            if (expander.fails_cfg(impl.get_outer_attrs())) {\n+                impl.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip test based on inner attrs\n+            expander.expand_cfg_attrs(impl.get_inner_attrs());\n+            if (expander.fails_cfg(impl.get_inner_attrs())) {\n+                impl.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip external items if required\n+            auto& impl_items = impl.get_impl_items();\n+            for (int i = 0; i < impl_items.size(); ) {\n+                auto& item = impl_items[i];\n+\n+                // mark for stripping if required\n+                item->accept_vis(*this);\n+\n+                if (item->is_marked_for_strip ())\n+                    impl_items.erase (impl_items.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::TraitImpl& impl) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(impl.get_outer_attrs());\n+            if (expander.fails_cfg(impl.get_outer_attrs())) {\n+                impl.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip test based on inner attrs\n+            expander.expand_cfg_attrs(impl.get_inner_attrs());\n+            if (expander.fails_cfg(impl.get_inner_attrs())) {\n+                impl.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip external items if required\n+            auto& impl_items = impl.get_impl_items();\n+            for (int i = 0; i < impl_items.size(); ) {\n+                auto& item = impl_items[i];\n+\n+                // mark for stripping if required\n+                item->accept_vis(*this);\n+\n+                if (item->is_marked_for_strip ())\n+                    impl_items.erase (impl_items.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n         void visit(AST::ExternalStaticItem& item) override {\n             // strip test based on outer attrs\n             expander.expand_cfg_attrs(item.get_outer_attrs());\n@@ -144,8 +295,10 @@ namespace Rust {\n             /* strip function parameters if required - this is specifically \n              * allowed by spec */\n             auto& params = item.get_function_params();\n-            for (auto i = 0; i < params.size(); ) {\n-                if (expander.fails_cfg (params[i].get_outer_attrs ()))\n+            for (int i = 0; i < params.size(); ) {\n+                auto& param_attrs = params[i].get_outer_attrs ();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg (param_attrs))\n                     params.erase (params.begin() + i);\n                 else\n                     i++;\n@@ -171,7 +324,7 @@ namespace Rust {\n \n             // strip external items if required\n             auto& extern_items = block.get_extern_items();\n-            for (auto i = 0; i < extern_items.size(); ) {\n+            for (int i = 0; i < extern_items.size(); ) {\n                 auto& item = extern_items[i];\n \n                 // mark for stripping if required"}, {"sha": "1ad997f778bcd9df07b1f55961ebcde00bb27059", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -464,6 +464,7 @@ Parser<ManagedTokenSource>::parse_inner_attributes ()\n \t}\n     }\n \n+  inner_attributes.shrink_to_fit ();\n   return inner_attributes;\n }\n \n@@ -962,6 +963,7 @@ Parser<ManagedTokenSource>::parse_items ()\n \t}\n     }\n \n+  items.shrink_to_fit ();\n   return items;\n }\n \n@@ -1073,6 +1075,7 @@ Parser<ManagedTokenSource>::parse_outer_attributes ()\n \t}\n     }\n \n+  outer_attributes.shrink_to_fit ();\n   return outer_attributes;\n \n   /* TODO: this shares basically all code with parse_inner_attributes except\n@@ -2442,9 +2445,7 @@ Parser<ManagedTokenSource>::parse_function (\n   // parse function parameters (only if next token isn't right paren)\n   std::vector<AST::FunctionParam> function_params;\n   if (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n-    {\n-      function_params = parse_function_params ();\n-    }\n+      function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -2745,6 +2746,7 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \tstd::make_move_iterator(type_params.end()));\n   }*/\n \n+  generic_params.shrink_to_fit ();\n   return generic_params;\n }\n \n@@ -2902,6 +2904,7 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n \tstd::make_move_iterator(type_params.end()));\n   }*/\n \n+  generic_params.shrink_to_fit ();\n   return generic_params;\n }\n \n@@ -3149,6 +3152,7 @@ Parser<ManagedTokenSource>::parse_type_params ()\n       lexer.skip_token ();\n     }\n \n+  type_params.shrink_to_fit ();\n   return type_params;\n }\n \n@@ -3180,6 +3184,7 @@ Parser<ManagedTokenSource>::parse_type_params (EndTokenPred is_end_token)\n       lexer.skip_token ();\n     }\n \n+  type_params.shrink_to_fit ();\n   return type_params;\n   /* TODO: this shares most code with parse_lifetime_params - good place to use\n    * template (i.e. parse_non_ptr_sequence if doable) */\n@@ -3236,24 +3241,24 @@ Parser<ManagedTokenSource>::parse_type_param ()\n \t\t\tstd::move (outer_attr)));\n }\n \n-// Parses regular (i.e. non-generic) parameters in functions or methods.\n+/* Parses regular (i.e. non-generic) parameters in functions or methods. Also \n+ * has end token handling. */\n template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n std::vector<AST::FunctionParam>\n-Parser<ManagedTokenSource>::parse_function_params ()\n+Parser<ManagedTokenSource>::parse_function_params (EndTokenPred is_end_token)\n {\n   std::vector<AST::FunctionParam> params;\n \n-  // HACK: return early if RIGHT_PAREN is found\n-  if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-    {\n+  if (is_end_token (lexer.peek_token ()->get_id ()))\n       return params;\n-    }\n \n   AST::FunctionParam initial_param = parse_function_param ();\n \n   // Return empty parameter list if no parameter there\n-  if (initial_param.is_error ())\n+  if (initial_param.is_error ()) \n     {\n+      // TODO: is this an error?\n       return params;\n     }\n \n@@ -3268,13 +3273,9 @@ Parser<ManagedTokenSource>::parse_function_params ()\n       // skip comma if applies\n       lexer.skip_token ();\n \n-      /* HACK: break if next token is a right (closing) paren - this is not\n-       * strictly true via grammar rule but seems to be true in practice (i.e.\n-       * with trailing comma). */\n-      if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-\t{\n+      // TODO: strictly speaking, shouldn't there be no trailing comma?\n+      if (is_end_token (lexer.peek_token ()->get_id ()))\n \t  break;\n-\t}\n \n       // now, as right paren would break, function param is required\n       AST::FunctionParam param = parse_function_param ();\n@@ -3291,6 +3292,7 @@ Parser<ManagedTokenSource>::parse_function_params ()\n       t = lexer.peek_token ();\n     }\n \n+  params.shrink_to_fit ();\n   return params;\n }\n \n@@ -3300,6 +3302,10 @@ template <typename ManagedTokenSource>\n AST::FunctionParam\n Parser<ManagedTokenSource>::parse_function_param ()\n {\n+  // parse outer attributes if they exist\n+  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+\n+  // TODO: should saved location be at start of outer attributes or pattern?\n   Location locus = lexer.peek_token ()->get_locus ();\n   std::unique_ptr<AST::Pattern> param_pattern = parse_pattern ();\n \n@@ -3324,7 +3330,7 @@ Parser<ManagedTokenSource>::parse_function_param ()\n     }\n \n   return AST::FunctionParam (std::move (param_pattern), std::move (param_type),\n-\t\t\t     locus);\n+\t\t\t     std::move (outer_attrs), locus);\n }\n \n /* Parses a function or method return type syntactical construction. Also\n@@ -3334,9 +3340,8 @@ std::unique_ptr<AST::Type>\n Parser<ManagedTokenSource>::parse_function_return_type ()\n {\n   if (lexer.peek_token ()->get_id () != RETURN_TYPE)\n-    {\n       return nullptr;\n-    }\n+\n   // skip return type, as it now obviously exists\n   lexer.skip_token ();\n \n@@ -3391,6 +3396,7 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n       t = lexer.peek_token ();\n     }\n \n+  where_clause_items.shrink_to_fit ();\n   return AST::WhereClause (std::move (where_clause_items));\n }\n \n@@ -3542,8 +3548,8 @@ Parser<ManagedTokenSource>::parse_type_param_bounds ()\n   return type_param_bounds;\n }\n \n-// Parses type parameter bounds in where clause or generic arguments, with end\n-// token handling.\n+/* Parses type parameter bounds in where clause or generic arguments, with end\n+ * token handling. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n std::vector<std::unique_ptr<AST::TypeParamBound> >\n@@ -4092,6 +4098,7 @@ Parser<ManagedTokenSource>::parse_tuple_fields ()\n       t = lexer.peek_token ();\n     }\n \n+  fields.shrink_to_fit ();\n   return fields;\n \n   // TODO: this shares basically all code with function params and struct fields\n@@ -4196,6 +4203,7 @@ Parser<ManagedTokenSource>::parse_enum_items ()\n       items.push_back (std::move (item));\n     }\n \n+  items.shrink_to_fit ();\n   return items;\n \n   /* TODO: use template if doable (parse_non_ptr_sequence) */\n@@ -4237,6 +4245,7 @@ Parser<ManagedTokenSource>::parse_enum_items (EndTokenPred is_end_tok)\n       items.push_back (std::move (item));\n     }\n \n+  items.shrink_to_fit ();\n   return items;\n \n   /* TODO: use template if doable (parse_non_ptr_sequence) */\n@@ -4530,6 +4539,9 @@ Parser<ManagedTokenSource>::parse_trait (\n       return nullptr;\n     }\n \n+  // parse inner attrs (if they exist)\n+  std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n+\n   // parse trait items\n   std::vector<std::unique_ptr<AST::TraitItem> > trait_items;\n \n@@ -4555,11 +4567,12 @@ Parser<ManagedTokenSource>::parse_trait (\n       return nullptr;\n     }\n \n+  trait_items.shrink_to_fit ();\n   return std::unique_ptr<AST::Trait> (\n     new AST::Trait (std::move (ident), is_unsafe, std::move (generic_params),\n \t\t    std::move (type_param_bounds), std::move (where_clause),\n \t\t    std::move (trait_items), std::move (vis),\n-\t\t    std::move (outer_attrs), locus));\n+\t\t    std::move (outer_attrs), std::move (inner_attrs), locus));\n }\n \n // Parses a trait item used inside traits (not trait, the Item).\n@@ -4613,27 +4626,25 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t    return nullptr;\n \t  }\n \n-\t// now for function vs method disambiguation - method has opening \"self\"\n-\t// param\n+\t/* now for function vs method disambiguation - method has opening \"self\"\n+\t * param */\n \tAST::SelfParam self_param = parse_self_param ();\n-\t// FIXME: ensure that self param doesn't accidently consume tokens for a\n-\t// function\n+\t/* FIXME: ensure that self param doesn't accidently consume tokens for a\n+\t * function */\n \tbool is_method = false;\n \tif (!self_param.is_error ())\n \t  {\n \t    is_method = true;\n \n-\t    // skip comma so function and method regular params can be parsed in\n-\t    // same way\n+\t    /* skip comma so function and method regular params can be parsed in\n+\t     * same way */\n \t    if (lexer.peek_token ()->get_id () == COMMA)\n-\t      {\n \t\tlexer.skip_token ();\n-\t      }\n \t  }\n \n \t// parse trait function params\n \tstd::vector<AST::FunctionParam> function_params\n-\t  = parse_function_params ();\n+\t  = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n \n \tif (!skip_token (RIGHT_PAREN))\n \t  {\n@@ -4914,6 +4925,8 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       // DEBUG\n       fprintf (stderr, \"successfully parsed inherent impl\\n\");\n \n+      impl_items.shrink_to_fit ();\n+\n       return std::unique_ptr<AST::InherentImpl> (new AST::InherentImpl (\n \tstd::move (impl_items), std::move (generic_params), std::move (type),\n \tstd::move (where_clause), std::move (vis), std::move (inner_attrs),\n@@ -4987,6 +5000,8 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       // DEBUG\n       fprintf (stderr, \"successfully parsed trait impl\\n\");\n \n+      impl_items.shrink_to_fit ();\n+\n       return std::unique_ptr<AST::TraitImpl> (\n \tnew AST::TraitImpl (std::move (type_path), is_unsafe, has_exclam,\n \t\t\t    std::move (impl_items), std::move (generic_params),\n@@ -5138,24 +5153,22 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n \n   // now for function vs method disambiguation - method has opening \"self\" param\n   AST::SelfParam self_param = parse_self_param ();\n-  // FIXME: ensure that self param doesn't accidently consume tokens for a\n-  // function one idea is to lookahead up to 4 tokens to see whether self is one\n-  // of them\n+  /* FIXME: ensure that self param doesn't accidently consume tokens for a\n+   * function one idea is to lookahead up to 4 tokens to see whether self is one\n+   * of them */\n   bool is_method = false;\n   if (!self_param.is_error ())\n     {\n       is_method = true;\n \n-      // skip comma so function and method regular params can be parsed in same\n-      // way\n+      /* skip comma so function and method regular params can be parsed in same\n+       * way */\n       if (lexer.peek_token ()->get_id () == COMMA)\n-\t{\n \t  lexer.skip_token ();\n-\t}\n     }\n \n   // parse trait function params\n-  std::vector<AST::FunctionParam> function_params = parse_function_params ();\n+  std::vector<AST::FunctionParam> function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -5400,7 +5413,7 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n   std::vector<AST::FunctionParam> function_params;\n   if (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n     {\n-      function_params = parse_function_params ();\n+      function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n \n       if (function_params.empty ())\n \t{\n@@ -5534,6 +5547,8 @@ Parser<ManagedTokenSource>::parse_extern_block (\n       // skip somewhere\n       return nullptr;\n     }\n+  \n+  extern_items.shrink_to_fit ();\n \n   return std::unique_ptr<AST::ExternBlock> (\n     new AST::ExternBlock (std::move (abi), std::move (extern_items),\n@@ -5689,6 +5704,8 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t    // skip somewhere?\n \t    return nullptr;\n \t  }\n+  \n+  function_params.shrink_to_fit ();\n \n \treturn std::unique_ptr<AST::ExternalFunctionItem> (\n \t  new AST::ExternalFunctionItem (\n@@ -6220,6 +6237,7 @@ Parser<ManagedTokenSource>::parse_type_path_function ()\n   // parse optional return type\n   std::unique_ptr<AST::Type> return_type = parse_function_return_type ();\n \n+  inputs.shrink_to_fit ();\n   return AST::TypePathFunction (std::move (inputs), std::move (return_type));\n }\n \n@@ -6392,6 +6410,8 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n       t = lexer.peek_token ();\n     }\n \n+  segments.shrink_to_fit ();\n+\n   // FIXME: outer attr parsing\n   return AST::QualifiedPathInExpression (std::move (qual_path_type),\n \t\t\t\t\t std::move (segments), locus,\n@@ -6667,7 +6687,7 @@ Parser<ManagedTokenSource>::parse_method ()\n     lexer.skip_token ();\n \n   // parse function parameters\n-  std::vector<AST::FunctionParam> function_params = parse_function_params ();\n+  std::vector<AST::FunctionParam> function_params = parse_function_params ([](TokenId id) { return id == RIGHT_PAREN; });\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n@@ -7066,6 +7086,8 @@ Parser<ManagedTokenSource>::parse_block_expr (\n \n   // grammar allows for empty block expressions\n \n+  stmts.shrink_to_fit ();\n+\n   return std::unique_ptr<AST::BlockExpr> (\n     new AST::BlockExpr (std::move (stmts), std::move (expr),\n \t\t\tstd::move (inner_attrs), std::move (outer_attrs),\n@@ -7154,6 +7176,7 @@ Parser<ManagedTokenSource>::parse_closure_expr (\n \n \t  t = lexer.peek_token ();\n \t}\n+      params.shrink_to_fit ();\n       break;\n     default:\n       rust_error_at (t->get_locus (),"}, {"sha": "5202abf09bdda4765f5eab16da0006c9c8790db2", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1271b772038d1e01cfed35ea5c764ceedc9842f9/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=1271b772038d1e01cfed35ea5c764ceedc9842f9", "patch": "@@ -164,7 +164,8 @@ template <typename ManagedTokenSource> class Parser\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params (EndTokenPred is_end_token);\n   std::unique_ptr<AST::TypeParam> parse_type_param ();\n-  std::vector<AST::FunctionParam> parse_function_params ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::FunctionParam> parse_function_params (EndTokenPred is_end_token);\n   AST::FunctionParam parse_function_param ();\n   std::unique_ptr<AST::Type> parse_function_return_type ();\n   AST::WhereClause parse_where_clause ();"}]}