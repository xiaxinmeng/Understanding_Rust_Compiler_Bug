{"sha": "248d745ac2f805567b7af9379d3023aa52719fe2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4ZDc0NWFjMmY4MDU1NjdiN2FmOTM3OWQzMDIzYWE1MjcxOWZlMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-02-17T12:00:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-02-17T12:00:04Z"}, "message": "re PR libffi/60073 (64-bit libffi.call/cls_double_va.c FAILs after recent modification)\n\n\tPR libffi/60073\n\t* src/sparc/v8.S: Assemble only if !SPARC64.\n\t* src/sparc/v9.S: Remove obsolete comment.\n\t* src/sparc/ffitarget.h (enum ffi_abi): Add FFI_COMPAT_V9.\n\t(V8_ABI_P): New macro.\n\t(V9_ABI_P): Likewise.\n\t(FFI_EXTRA_CIF_FIELDS): Define only if SPARC64.\n\t* src/sparc/ffi.c (ffi_prep_args_v8): Compile only if !SPARC64.\n\t(ffi_prep_args_v9): Compile only if SPARC64.\n\t(ffi_prep_cif_machdep_core): Use V9_ABI_P predicate.\n\t(ffi_prep_cif_machdep): Guard access to nfixedargs field.\n\t(ffi_prep_cif_machdep_var): Likewise.\n\t(ffi_v9_layout_struct): Compile only if SPARC64.\n\t(ffi_call): Deal with FFI_V8PLUS and FFI_COMPAT_V9 and fix warnings.\n\t(ffi_prep_closure_loc): Use V9_ABI_P and V8_ABI_P predicates.\n\t(ffi_closure_sparc_inner_v8): Compile only if !SPARC64.\n\t(ffi_closure_sparc_inner_v9): Compile only if SPARC64.  Guard access\n\tto nfixedargs field.\n\nFrom-SVN: r207822", "tree": {"sha": "e9c8ff8c5a9087761fabdc82c7e4d0f52bf96aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9c8ff8c5a9087761fabdc82c7e4d0f52bf96aea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/248d745ac2f805567b7af9379d3023aa52719fe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248d745ac2f805567b7af9379d3023aa52719fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/248d745ac2f805567b7af9379d3023aa52719fe2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248d745ac2f805567b7af9379d3023aa52719fe2/comments", "author": null, "committer": null, "parents": [{"sha": "583a9919adb8ea6b52d9e758339afaa0034b5d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/583a9919adb8ea6b52d9e758339afaa0034b5d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/583a9919adb8ea6b52d9e758339afaa0034b5d3f"}], "stats": {"total": 444, "additions": 257, "deletions": 187}, "files": [{"sha": "80e94ed77ca1467a81f113ecea0c66da7101271b", "filename": "libffi/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=248d745ac2f805567b7af9379d3023aa52719fe2", "patch": "@@ -1,3 +1,24 @@\n+2014-02-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR libffi/60073\n+\t* src/sparc/v8.S: Assemble only if !SPARC64.\n+\t* src/sparc/v9.S: Remove obsolete comment.\n+\t* src/sparc/ffitarget.h (enum ffi_abi): Add FFI_COMPAT_V9.\n+\t(V8_ABI_P): New macro.\n+\t(V9_ABI_P): Likewise.\n+\t(FFI_EXTRA_CIF_FIELDS): Define only if SPARC64.\n+\t* src/sparc/ffi.c (ffi_prep_args_v8): Compile only if !SPARC64.\n+\t(ffi_prep_args_v9): Compile only if SPARC64.\n+\t(ffi_prep_cif_machdep_core): Use V9_ABI_P predicate.\n+\t(ffi_prep_cif_machdep): Guard access to nfixedargs field.\n+\t(ffi_prep_cif_machdep_var): Likewise.\n+\t(ffi_v9_layout_struct): Compile only if SPARC64.\n+\t(ffi_call): Deal with FFI_V8PLUS and FFI_COMPAT_V9 and fix warnings.\n+\t(ffi_prep_closure_loc): Use V9_ABI_P and V8_ABI_P predicates.\n+\t(ffi_closure_sparc_inner_v8): Compile only if !SPARC64.\n+\t(ffi_closure_sparc_inner_v9): Compile only if SPARC64.  Guard access\n+\tto nfixedargs field.\n+\n 2014-02-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR libffi/60073"}, {"sha": "77e3822065734de20f9fcd62ec9cf372ead614c8", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 218, "deletions": 183, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=248d745ac2f805567b7af9379d3023aa52719fe2", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 2011 Anthony Green\n            Copyright (c) 1996, 2003-2004, 2007-2008 Red Hat, Inc.\n-   \n+\n    SPARC Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -34,93 +34,10 @@\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n-void ffi_prep_args_v8(char *stack, extended_cif *ecif)\n-{\n-  int i;\n-  void **p_argv;\n-  char *argp;\n-  ffi_type **p_arg;\n-\n-  /* Skip 16 words for the window save area */\n-  argp = stack + 16*sizeof(int);\n-\n-  /* This should only really be done when we are returning a structure,\n-     however, it's faster just to do it all the time...\n-\n-  if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT ) */\n-  *(int *) argp = (long)ecif->rvalue;\n-\n-  /* And 1 word for the  structure return value. */\n-  argp += sizeof(int);\n-\n-#ifdef USING_PURIFY\n-  /* Purify will probably complain in our assembly routine, unless we\n-     zero out this memory. */\n-\n-  ((int*)argp)[0] = 0;\n-  ((int*)argp)[1] = 0;\n-  ((int*)argp)[2] = 0;\n-  ((int*)argp)[3] = 0;\n-  ((int*)argp)[4] = 0;\n-  ((int*)argp)[5] = 0;\n-#endif\n-\n-  p_argv = ecif->avalue;\n-\n-  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n-    {\n-      size_t z;\n-\n-\t  if ((*p_arg)->type == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t      || (*p_arg)->type == FFI_TYPE_LONGDOUBLE\n-#endif\n-\t      )\n-\t    {\n-\t      *(unsigned int *) argp = (unsigned long)(* p_argv);\n-\t      z = sizeof(int);\n-\t    }\n-\t  else\n-\t    {\n-\t      z = (*p_arg)->size;\n-\t      if (z < sizeof(int))\n-\t\t{\n-\t\t  z = sizeof(int);\n-\t\t  switch ((*p_arg)->type)\n-\t\t    {\n-\t\t    case FFI_TYPE_SINT8:\n-\t\t      *(signed int *) argp = *(SINT8 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_UINT8:\n-\t\t      *(unsigned int *) argp = *(UINT8 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_SINT16:\n-\t\t      *(signed int *) argp = *(SINT16 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_UINT16:\n-\t\t      *(unsigned int *) argp = *(UINT16 *)(* p_argv);\n-\t\t      break;\n-\n-\t\t    default:\n-\t\t      FFI_ASSERT(0);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  memcpy(argp, *p_argv, z);\n-\t\t}\n-\t    }\n-\t  p_argv++;\n-\t  argp += z;\n-    }\n-  \n-  return;\n-}\n+#ifdef SPARC64\n \n-int ffi_prep_args_v9(char *stack, extended_cif *ecif)\n+int\n+ffi_prep_args_v9(char *stack, extended_cif *ecif)\n {\n   int i, ret = 0;\n   int tmp;\n@@ -248,12 +165,105 @@ int ffi_prep_args_v9(char *stack, extended_cif *ecif)\n   return ret;\n }\n \n+#else\n+\n+void\n+ffi_prep_args_v8(char *stack, extended_cif *ecif)\n+{\n+  int i;\n+  void **p_argv;\n+  char *argp;\n+  ffi_type **p_arg;\n+\n+  /* Skip 16 words for the window save area */\n+  argp = stack + 16*sizeof(int);\n+\n+  /* This should only really be done when we are returning a structure,\n+     however, it's faster just to do it all the time...\n+\n+  if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT ) */\n+  *(int *) argp = (long)ecif->rvalue;\n+\n+  /* And 1 word for the  structure return value. */\n+  argp += sizeof(int);\n+\n+#ifdef USING_PURIFY\n+  /* Purify will probably complain in our assembly routine, unless we\n+     zero out this memory. */\n+\n+  ((int*)argp)[0] = 0;\n+  ((int*)argp)[1] = 0;\n+  ((int*)argp)[2] = 0;\n+  ((int*)argp)[3] = 0;\n+  ((int*)argp)[4] = 0;\n+  ((int*)argp)[5] = 0;\n+#endif\n+\n+  p_argv = ecif->avalue;\n+\n+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n+    {\n+      size_t z;\n+\n+\t  if ((*p_arg)->type == FFI_TYPE_STRUCT\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t      || (*p_arg)->type == FFI_TYPE_LONGDOUBLE\n+#endif\n+\t      )\n+\t    {\n+\t      *(unsigned int *) argp = (unsigned long)(* p_argv);\n+\t      z = sizeof(int);\n+\t    }\n+\t  else\n+\t    {\n+\t      z = (*p_arg)->size;\n+\t      if (z < sizeof(int))\n+\t\t{\n+\t\t  z = sizeof(int);\n+\t\t  switch ((*p_arg)->type)\n+\t\t    {\n+\t\t    case FFI_TYPE_SINT8:\n+\t\t      *(signed int *) argp = *(SINT8 *)(* p_argv);\n+\t\t      break;\n+\t\t      \n+\t\t    case FFI_TYPE_UINT8:\n+\t\t      *(unsigned int *) argp = *(UINT8 *)(* p_argv);\n+\t\t      break;\n+\t\t      \n+\t\t    case FFI_TYPE_SINT16:\n+\t\t      *(signed int *) argp = *(SINT16 *)(* p_argv);\n+\t\t      break;\n+\t\t      \n+\t\t    case FFI_TYPE_UINT16:\n+\t\t      *(unsigned int *) argp = *(UINT16 *)(* p_argv);\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      FFI_ASSERT(0);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  memcpy(argp, *p_argv, z);\n+\t\t}\n+\t    }\n+\t  p_argv++;\n+\t  argp += z;\n+    }\n+  \n+  return;\n+}\n+\n+#endif\n+\n /* Perform machine dependent cif processing */\n-static ffi_status ffi_prep_cif_machdep_core(ffi_cif *cif)\n+\n+static\n+ffi_status ffi_prep_cif_machdep_core(ffi_cif *cif)\n {\n   int wordsize;\n \n-  if (cif->abi != FFI_V9)\n+  if (!V9_ABI_P (cif->abi))\n     {\n       wordsize = 4;\n \n@@ -303,7 +313,7 @@ static ffi_status ffi_prep_cif_machdep_core(ffi_cif *cif)\n       break;\n \n     case FFI_TYPE_STRUCT:\n-      if (cif->abi == FFI_V9 && cif->rtype->size > 32)\n+      if (V9_ABI_P (cif->abi) && cif->rtype->size > 32)\n \tcif->flags = FFI_TYPE_VOID;\n       else\n \tcif->flags = FFI_TYPE_STRUCT;\n@@ -313,15 +323,15 @@ static ffi_status ffi_prep_cif_machdep_core(ffi_cif *cif)\n     case FFI_TYPE_UINT8:\n     case FFI_TYPE_SINT16:\n     case FFI_TYPE_UINT16:\n-      if (cif->abi == FFI_V9)\n+      if (V9_ABI_P (cif->abi))\n \tcif->flags = FFI_TYPE_INT;\n       else\n \tcif->flags = cif->rtype->type;\n       break;\n \n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_UINT64:\n-      if (cif->abi == FFI_V9)\n+      if (V9_ABI_P (cif->abi))\n \tcif->flags = FFI_TYPE_INT;\n       else\n \tcif->flags = FFI_TYPE_SINT64;\n@@ -334,20 +344,31 @@ static ffi_status ffi_prep_cif_machdep_core(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n {\n-  cif->nfixedargs = cif->nargs;\n+#ifdef SPARC64\n+  if (cif->abi != FFI_COMPAT_V9)\n+    cif->nfixedargs = cif->nargs;\n+#endif\n   return ffi_prep_cif_machdep_core (cif);\n }\n \n-ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,\n-\t\t\t\t    unsigned int ntotalargs)\n+ffi_status\n+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,\n+\t\t\t unsigned int ntotalargs)\n {\n-  cif->nfixedargs = nfixedargs;\n+#ifdef SPARC64\n+  if (cif->abi != FFI_COMPAT_V9)\n+    cif->nfixedargs = nfixedargs;\n+#endif\n   return ffi_prep_cif_machdep_core (cif);\n }\n \n-int ffi_v9_layout_struct(ffi_type *arg, int off, char *ret, char *intg, char *flt)\n+#ifdef SPARC64\n+\n+int\n+ffi_v9_layout_struct(ffi_type *arg, int off, char *ret, char *intg, char *flt)\n {\n   ffi_type **ptr = &arg->elements[0];\n \n@@ -380,6 +401,7 @@ int ffi_v9_layout_struct(ffi_type *arg, int off, char *ret, char *intg, char *fl\n   return off;\n }\n \n+#endif\n \n #ifdef SPARC64\n extern int ffi_call_v9(void *, extended_cif *, unsigned, \n@@ -389,33 +411,37 @@ extern int ffi_call_v8(void *, extended_cif *, unsigned,\n \t\t       unsigned, unsigned *, void (*fn)(void));\n #endif\n \n-void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+void\n+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n+#ifdef SPARC64\n   void *rval = rvalue;\n+#endif\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n-\n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n-\n   ecif.rvalue = rvalue;\n+\n+  /* If the return value is a struct and we don't have a return value address,\n+     then we need to make one.  */\n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n+      if (ecif.rvalue == NULL)\n+\tecif.rvalue = alloca(cif->rtype->size);\n+\n+#ifdef SPARC64\n       if (cif->rtype->size <= 32)\n \trval = alloca(64);\n       else\n-\t{\n-\t  rval = NULL;\n-\t  if (rvalue == NULL)\n-\t    ecif.rvalue = alloca(cif->rtype->size);\n-\t}\n+\trval = NULL;\n+#endif\n     }\n \n   switch (cif->abi) \n     {\n     case FFI_V8:\n+    case FFI_V8PLUS:\n #ifdef SPARC64\n       /* We don't yet support calling 32bit code from 64bit */\n       FFI_ASSERT(0);\n@@ -430,7 +456,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n \t  /* behind \"call\", so we alloc some executable space for it. */\n \t  /* l7 is used, we need to make sure v8.S doesn't use %l7.   */\n \t  unsigned int *call_struct = NULL;\n-\t  ffi_closure_alloc(32, &call_struct);\n+\t  ffi_closure_alloc(32, (void **)&call_struct);\n \t  if (call_struct)\n \t    {\n \t      unsigned long f = (unsigned long)fn;\n@@ -450,7 +476,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n \t      /* SPARC v8 requires 5 instructions for flush to be visible */\n \t      asm volatile (\"nop; nop; nop; nop; nop\");\n \t      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n-\t\t\t  cif->flags, rvalue, call_struct);\n+\t\t\t  cif->flags, rvalue, (void (*)(void)) call_struct);\n \t      ffi_closure_free(call_struct);\n \t    }\n \t  else\n@@ -466,12 +492,13 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n \t}\n #endif\n       break;\n+    case FFI_COMPAT_V9:\n     case FFI_V9:\n #ifdef SPARC64\n-      ffi_call_v9(ffi_prep_args_v9, &ecif, cif->bytes,\n-\t\t  cif->flags, rval, fn);\n+      ffi_call_v9(ffi_prep_args_v9, &ecif, cif->bytes, cif->flags, rval, fn);\n       if (rvalue && rval && cif->rtype->type == FFI_TYPE_STRUCT)\n-\tffi_v9_layout_struct(cif->rtype, 0, (char *)rvalue, (char *)rval, ((char *)rval)+32);\n+\tffi_v9_layout_struct(cif->rtype, 0, (char *)rvalue, (char *)rval,\n+\t\t\t     ((char *)rval)+32);\n #else\n       /* And vice versa */\n       FFI_ASSERT(0);\n@@ -502,7 +529,7 @@ ffi_prep_closure_loc (ffi_closure* closure,\n #ifdef SPARC64\n   /* Trampoline address is equal to the closure address.  We take advantage\n      of that to reduce the trampoline size by 8 bytes. */\n-  if (cif->abi != FFI_V9)\n+  if (!V9_ABI_P (cif->abi))\n     return FFI_BAD_ABI;\n   fn = (unsigned long) ffi_closure_v9;\n   tramp[0] = 0x83414000;\t/* rd\t%pc, %g1\t*/\n@@ -512,7 +539,7 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   *((unsigned long *) &tramp[4]) = fn;\n #else\n   unsigned long ctx = (unsigned long) codeloc;\n-  if (cif->abi != FFI_V8)\n+  if (!V8_ABI_P (cif->abi))\n     return FFI_BAD_ABI;\n   fn = (unsigned long) ffi_closure_v8;\n   tramp[0] = 0x03000000 | fn >> 10;\t/* sethi %hi(fn), %g1\t*/\n@@ -537,74 +564,11 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   return FFI_OK;\n }\n \n-int\n-ffi_closure_sparc_inner_v8(ffi_closure *closure,\n-  void *rvalue, unsigned long *gpr, unsigned long *scratch)\n-{\n-  ffi_cif *cif;\n-  ffi_type **arg_types;\n-  void **avalue;\n-  int i, argn;\n-\n-  cif = closure->cif;\n-  arg_types = cif->arg_types;\n-  avalue = alloca(cif->nargs * sizeof(void *));\n-\n-  /* Copy the caller's structure return address so that the closure\n-     returns the data directly to the caller.  */\n-  if (cif->flags == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE  \n-      || cif->flags == FFI_TYPE_LONGDOUBLE\n-#endif\n-     )\n-    rvalue = (void *) gpr[0];\n-\n-  /* Always skip the structure return address.  */\n-  argn = 1;\n-\n-  /* Grab the addresses of the arguments from the stack frame.  */\n-  for (i = 0; i < cif->nargs; i++)\n-    {\n-      if (arg_types[i]->type == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n-#endif\n-         )\n-\t{\n-\t  /* Straight copy of invisible reference.  */\n-\t  avalue[i] = (void *)gpr[argn++];\n-\t}\n-      else if ((arg_types[i]->type == FFI_TYPE_DOUBLE\n-\t       || arg_types[i]->type == FFI_TYPE_SINT64\n-\t       || arg_types[i]->type == FFI_TYPE_UINT64)\n-\t       /* gpr is 8-byte aligned.  */\n-\t       && (argn % 2) != 0)\n-\t{\n-\t  /* Align on a 8-byte boundary.  */\n-\t  scratch[0] = gpr[argn];\n-\t  scratch[1] = gpr[argn+1];\n-\t  avalue[i] = scratch;\n-\t  scratch -= 2;\n-\t  argn += 2;\n-\t}\n-      else\n-\t{\n-\t  /* Always right-justify.  */\n-\t  argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n-\t  avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n-\t}\n-    }\n-\n-  /* Invoke the closure.  */\n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n-\n-  /* Tell ffi_closure_sparc how to perform return type promotions.  */\n-  return cif->rtype->type;\n-}\n+#ifdef SPARC64\n \n int\n-ffi_closure_sparc_inner_v9(ffi_closure *closure,\n-  void *rvalue, unsigned long *gpr, double *fpr)\n+ffi_closure_sparc_inner_v9(ffi_closure *closure, void *rvalue,\n+\t\t\t   unsigned long *gpr, double *fpr)\n {\n   ffi_cif *cif;\n   ffi_type **arg_types;\n@@ -633,7 +597,8 @@ ffi_closure_sparc_inner_v9(ffi_closure *closure,\n     {\n       /* If the function is variadic, FP arguments are passed in FP\n \t registers only if the corresponding parameter is named.  */\n-      const int named = (i < cif->nfixedargs);\n+      const int named\n+\t= (cif->abi == FFI_COMPAT_V9 ? 1 : i < cif->nfixedargs);\n \n       if (arg_types[i]->type == FFI_TYPE_STRUCT)\n \t{\n@@ -653,7 +618,8 @@ ffi_closure_sparc_inner_v9(ffi_closure *closure,\n \t\t\t\t   ? (char *) &fpr[argn]\n \t\t\t\t   : (char *) &gpr[argn]);\n \t      avalue[i] = &gpr[argn];\n-\t      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t      argn\n+\t        += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \t    }\n \t}\n       else\n@@ -686,3 +652,72 @@ ffi_closure_sparc_inner_v9(ffi_closure *closure,\n   /* Tell ffi_closure_sparc how to perform return type promotions.  */\n   return cif->rtype->type;\n }\n+\n+#else\n+\n+int\n+ffi_closure_sparc_inner_v8(ffi_closure *closure, void *rvalue,\n+\t\t\t   unsigned long *gpr, unsigned long *scratch)\n+{\n+  ffi_cif *cif;\n+  ffi_type **arg_types;\n+  void **avalue;\n+  int i, argn;\n+\n+  cif = closure->cif;\n+  arg_types = cif->arg_types;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  /* Copy the caller's structure return address so that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->flags == FFI_TYPE_STRUCT\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE  \n+      || cif->flags == FFI_TYPE_LONGDOUBLE\n+#endif\n+     )\n+    rvalue = (void *) gpr[0];\n+\n+  /* Always skip the structure return address.  */\n+  argn = 1;\n+\n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+      if (arg_types[i]->type == FFI_TYPE_STRUCT\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n+#endif\n+         )\n+\t{\n+\t  /* Straight copy of invisible reference.  */\n+\t  avalue[i] = (void *)gpr[argn++];\n+\t}\n+      else if ((arg_types[i]->type == FFI_TYPE_DOUBLE\n+\t       || arg_types[i]->type == FFI_TYPE_SINT64\n+\t       || arg_types[i]->type == FFI_TYPE_UINT64)\n+\t       /* gpr is 8-byte aligned.  */\n+\t       && (argn % 2) != 0)\n+\t{\n+\t  /* Align on a 8-byte boundary.  */\n+\t  scratch[0] = gpr[argn];\n+\t  scratch[1] = gpr[argn+1];\n+\t  avalue[i] = scratch;\n+\t  scratch -= 2;\n+\t  argn += 2;\n+\t}\n+      else\n+\t{\n+\t  /* Always right-justify.  */\n+\t  argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n+\t}\n+    }\n+\n+  /* Invoke the closure.  */\n+  closure->fun (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_sparc how to perform return type promotions.  */\n+  return cif->rtype->type;\n+}\n+\n+#endif"}, {"sha": "6489ac05fd4eef6008c9f57b8945a44b79b67e1c", "filename": "libffi/src/sparc/ffitarget.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffitarget.h?ref=248d745ac2f805567b7af9379d3023aa52719fe2", "patch": "@@ -48,6 +48,8 @@ typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n   FFI_V8,\n   FFI_V8PLUS,\n+  /* See below for the COMPAT_V9 rationale.  */\n+  FFI_COMPAT_V9,\n   FFI_V9,\n   FFI_LAST_ABI,\n #ifdef SPARC64\n@@ -58,8 +60,19 @@ typedef enum ffi_abi {\n } ffi_abi;\n #endif\n \n+#define V8_ABI_P(abi) ((abi) == FFI_V8 || (abi) == FFI_V8PLUS)\n+#define V9_ABI_P(abi) ((abi) == FFI_COMPAT_V9 || (abi) == FFI_V9)\n+\n #define FFI_TARGET_SPECIFIC_VARIADIC 1\n+\n+/* The support of variadic functions was broken in the original implementation\n+   of the FFI_V9 ABI.  This has been fixed by adding one extra field to the\n+   CIF structure (nfixedargs field), which means that the ABI of libffi itself\n+   has changed.  In order to support applications using the original ABI, we\n+   have renamed FFI_V9 into FFI_COMPAT_V9 and defined a new FFI_V9 value.  */\n+#ifdef SPARC64\n #define FFI_EXTRA_CIF_FIELDS unsigned int nfixedargs\n+#endif\n \n /* ---- Definitions for closures ----------------------------------------- */\n "}, {"sha": "7ec6e1c119432ff06799406f1ff1bf4638b57dea", "filename": "libffi/src/sparc/v8.S", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fv8.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fv8.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv8.S?ref=248d745ac2f805567b7af9379d3023aa52719fe2", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n    v8.S - Copyright (c) 1996, 1997, 2003, 2004, 2008 Red Hat, Inc.\n-   \n+\n    SPARC Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -28,6 +28,8 @@\n #include <fficonfig.h>\n #include <ffi.h>\n \n+#ifndef SPARC64\n+\n #define STACKFRAME 96\t\t/* Minimum stack framesize for SPARC */\n #define ARGS (64+4)\t\t/* Offset of register area in frame */\n \n@@ -307,6 +309,7 @@ done2:\n \t.byte\t0x1f\t! uleb128 0x1f\n \t.align\tWS\n .LLEFDE2:\n+#endif\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "2c97673e351ae5ddaeb517f54706c754c30f33e5", "filename": "libffi/src/sparc/v9.S", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248d745ac2f805567b7af9379d3023aa52719fe2/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=248d745ac2f805567b7af9379d3023aa52719fe2", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n    v9.S - Copyright (c) 2000, 2003, 2004, 2008 Red Hat, Inc.\n-   \n+\n    SPARC 64-bit Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -29,8 +29,6 @@\n #include <ffi.h>\n \n #ifdef SPARC64\n-/* Only compile this in for 64bit builds, because otherwise the object file\n-   will have inproper architecture due to used instructions.  */\n \n #define STACKFRAME 176\t\t/* Minimum stack framesize for SPARC 64-bit */\n #define STACK_BIAS 2047"}]}