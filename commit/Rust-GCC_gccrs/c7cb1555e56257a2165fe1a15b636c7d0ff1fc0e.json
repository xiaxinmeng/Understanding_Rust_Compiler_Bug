{"sha": "c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjYjE1NTVlNTYyNTdhMjE2NWZlMWExNWI2MzZjN2QwZmYxZmMwZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-09-07T18:06:51Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-09-07T18:06:51Z"}, "message": "bfin.md (UNSPEC_VOLATILE_STALL): New constant.\n\n\t* config/bfin/bfin.md (UNSPEC_VOLATILE_STALL): New constant.\n\t(attr \"addrtype\"): New member \"spreg\".\n\tUse it if mem_spfp_address_operand is true for the address.\n\t(attr \"type\"): New entry \"stall\".\n\t(cpu_unit \"load\"): New.\n\t(insn_reservations \"load32\", \"loadp\", \"loadi\"): Add reservation of\n\t\"load\".\n\t(insn_reservation \"loadsp\"): New.\n\t(insn_reservation \"load_stall1\"): New.\n\t(insn_reservation \"load_stall3\"): New.\n\t(stall): New insn.\t\n\t* config/bfin/predicates.md (const1_operand, const3_operand): New.\n\t(mem_p_address_operand): Exclude stack and frame pointer based\n\taddresses.\n\t(mem_spfp_address_operand): New; match them here.\n\t* config/bfin/bfin.c (add_sched_insns_for_speculation): New function.\n\t(bfin_reorg): Call it if scheduling insns.\n\t(bfin_gen_bundles): Remove dummy insns created by\n\tadd_sched_insns_for_speculation.\n\nFrom-SVN: r151486", "tree": {"sha": "44208384bf1e21897531dd9f8d9a5f936ed5f273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44208384bf1e21897531dd9f8d9a5f936ed5f273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/comments", "author": null, "committer": null, "parents": [{"sha": "4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a50e99c6531d1d413e75f19c802ba5fd6ab103a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a50e99c6531d1d413e75f19c802ba5fd6ab103a"}], "stats": {"total": 194, "additions": 179, "deletions": 15}, "files": [{"sha": "cbbe9622a96d0d81e4179661c813d7a9d4b18ff6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "patch": "@@ -1,3 +1,25 @@\n+2009-09-07  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.md (UNSPEC_VOLATILE_STALL): New constant.\n+\t(attr \"addrtype\"): New member \"spreg\".\n+\tUse it if mem_spfp_address_operand is true for the address.\n+\t(attr \"type\"): New entry \"stall\".\n+\t(cpu_unit \"load\"): New.\n+\t(insn_reservations \"load32\", \"loadp\", \"loadi\"): Add reservation of\n+\t\"load\".\n+\t(insn_reservation \"loadsp\"): New.\n+\t(insn_reservation \"load_stall1\"): New.\n+\t(insn_reservation \"load_stall3\"): New.\n+\t(stall): New insn.\t\n+\t* config/bfin/predicates.md (const1_operand, const3_operand): New.\n+\t(mem_p_address_operand): Exclude stack and frame pointer based\n+\taddresses.\n+\t(mem_spfp_address_operand): New; match them here.\n+\t* config/bfin/bfin.c (add_sched_insns_for_speculation): New function.\n+\t(bfin_reorg): Call it if scheduling insns.\n+\t(bfin_gen_bundles): Remove dummy insns created by\n+\tadd_sched_insns_for_speculation.\n+\n 2009-09-07  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/41282"}, {"sha": "0cfb471d2971bea6bbcb672feb6899a6d2084a88", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 82, "deletions": 7, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "patch": "@@ -4784,15 +4784,27 @@ bfin_gen_bundles (void)\n       for (insn = BB_HEAD (bb);; insn = next)\n \t{\n \t  int at_end;\n+\t  rtx delete_this = NULL_RTX;\n+\n \t  if (INSN_P (insn))\n \t    {\n-\t      if (get_attr_type (insn) == TYPE_DSP32)\n-\t\tslot[0] = insn;\n-\t      else if (slot[1] == NULL_RTX)\n-\t\tslot[1] = insn;\n+\t      enum attr_type type = get_attr_type (insn);\n+\n+\t      if (type == TYPE_STALL)\n+\t\t{\n+\t\t  gcc_assert (n_filled == 0);\n+\t\t  delete_this = insn;\n+\t\t}\n \t      else\n-\t\tslot[2] = insn;\n-\t      n_filled++;\n+\t\t{\n+\t\t  if (type == TYPE_DSP32)\n+\t\t    slot[0] = insn;\n+\t\t  else if (slot[1] == NULL_RTX)\n+\t\t    slot[1] = insn;\n+\t\t  else\n+\t\t    slot[2] = insn;\n+\t\t  n_filled++;\n+\t\t}\n \t    }\n \n \t  next = NEXT_INSN (insn);\n@@ -4807,7 +4819,7 @@ bfin_gen_bundles (void)\n \n \t  /* BB_END can change due to emitting extra NOPs, so check here.  */\n \t  at_end = insn == BB_END (bb);\n-\t  if (at_end || GET_MODE (next) == TImode)\n+\t  if (delete_this == NULL_RTX && (at_end || GET_MODE (next) == TImode))\n \t    {\n \t      if ((n_filled < 2\n \t\t   || !gen_one_bundle (slot))\n@@ -4826,6 +4838,8 @@ bfin_gen_bundles (void)\n \t      n_filled = 0;\n \t      slot[0] = slot[1] = slot[2] = NULL_RTX;\n \t    }\n+\t  if (delete_this != NULL_RTX)\n+\t    delete_insn (delete_this);\n \t  if (at_end)\n \t    break;\n \t}\n@@ -5226,6 +5240,65 @@ workaround_speculation (void)\n     }\n }\n \n+/* Called just before the final scheduling pass.  If we need to insert NOPs\n+   later on to work around speculative loads, insert special placeholder\n+   insns that cause loads to be delayed for as many cycles as necessary\n+   (and possible).  This reduces the number of NOPs we need to add.\n+   The dummy insns we generate are later removed by bfin_gen_bundles.  */\n+static void\n+add_sched_insns_for_speculation (void)\n+{\n+  rtx insn;\n+\n+  if (! ENABLE_WA_SPECULATIVE_LOADS && ! ENABLE_WA_SPECULATIVE_SYNCS\n+      && ! ENABLE_WA_INDIRECT_CALLS)\n+    return;\n+\n+  /* First pass: find predicted-false branches; if something after them\n+     needs nops, insert them or change the branch to predict true.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      if (NOTE_P (insn) || BARRIER_P (insn) || LABEL_P (insn))\n+\tcontinue;\n+\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t  || GET_CODE (pat) == ASM_INPUT || GET_CODE (pat) == ADDR_VEC\n+\t  || GET_CODE (pat) == ADDR_DIFF_VEC || asm_noperands (pat) >= 0)\n+\tcontinue;\n+\n+      if (JUMP_P (insn))\n+\t{\n+\t  if (any_condjump_p (insn)\n+\t      && !cbranch_predicted_taken_p (insn))\n+\t    {\n+\t      rtx n = next_real_insn (insn);\n+\t      emit_insn_before (gen_stall (GEN_INT (3)), n);\n+\t    }\n+\t}\n+    }\n+\n+  /* Second pass: for predicted-true branches, see if anything at the\n+     branch destination needs extra nops.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (JUMP_P (insn)\n+\t  && any_condjump_p (insn)\n+\t  && (cbranch_predicted_taken_p (insn)))\n+\t{\n+\t  rtx target = JUMP_LABEL (insn);\n+\t  rtx next = next_real_insn (target);\n+\n+\t  if (GET_CODE (PATTERN (next)) == UNSPEC_VOLATILE\n+\t      && get_attr_type (next) == TYPE_STALL)\n+\t    continue;\n+\t  emit_insn_before (gen_stall (GEN_INT (1)), next);\t  \n+\t}\n+    }\n+}\n+\n /* We use the machine specific reorg pass for emitting CSYNC instructions\n    after conditional branches as needed.\n \n@@ -5259,6 +5332,8 @@ bfin_reorg (void)\n       split_all_insns ();\n       splitting_for_sched = 0;\n \n+      add_sched_insns_for_speculation ();\n+\n       timevar_push (TV_SCHED2);\n       schedule_insns ();\n       timevar_pop (TV_SCHED2);"}, {"sha": "ba93214b3d4450169d89d240e951f288c9616445", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "patch": "@@ -146,7 +146,8 @@\n    (UNSPEC_VOLATILE_SSYNC 2)\n    (UNSPEC_VOLATILE_LOAD_FUNCDESC 3)\n    (UNSPEC_VOLATILE_STORE_EH_HANDLER 4)\n-   (UNSPEC_VOLATILE_DUMMY 5)])\n+   (UNSPEC_VOLATILE_DUMMY 5)\n+   (UNSPEC_VOLATILE_STALL 6)])\n \n (define_constants\n   [(MACFLAG_NONE 0)\n@@ -163,14 +164,18 @@\n    (MACFLAG_IH 11)])\n \n (define_attr \"type\"\n-  \"move,movcc,mvi,mcld,mcst,dsp32,mult,alu0,shft,brcc,br,call,misc,sync,compare,dummy\"\n+  \"move,movcc,mvi,mcld,mcst,dsp32,mult,alu0,shft,brcc,br,call,misc,sync,compare,dummy,stall\"\n   (const_string \"misc\"))\n \n-(define_attr \"addrtype\" \"32bit,preg,ireg\"\n+(define_attr \"addrtype\" \"32bit,preg,spreg,ireg\"\n   (cond [(and (eq_attr \"type\" \"mcld\")\n \t      (and (match_operand 0 \"d_register_operand\" \"\")\n \t\t   (match_operand 1 \"mem_p_address_operand\" \"\")))\n \t   (const_string \"preg\")\n+\t (and (eq_attr \"type\" \"mcld\")\n+\t      (and (match_operand 0 \"d_register_operand\" \"\")\n+\t\t   (match_operand 1 \"mem_spfp_address_operand\" \"\")))\n+\t   (const_string \"spreg\")\n \t (and (eq_attr \"type\" \"mcld\")\n \t      (and (match_operand 0 \"d_register_operand\" \"\")\n \t\t   (match_operand 1 \"mem_i_address_operand\" \"\")))\n@@ -179,6 +184,10 @@\n \t      (and (match_operand 1 \"d_register_operand\" \"\")\n \t\t   (match_operand 0 \"mem_p_address_operand\" \"\")))\n \t   (const_string \"preg\")\n+\t (and (eq_attr \"type\" \"mcst\")\n+\t      (and (match_operand 1 \"d_register_operand\" \"\")\n+\t\t   (match_operand 0 \"mem_spfp_address_operand\" \"\")))\n+\t   (const_string \"spreg\")\n \t (and (eq_attr \"type\" \"mcst\")\n \t      (and (match_operand 1 \"d_register_operand\" \"\")\n \t\t   (match_operand 0 \"mem_i_address_operand\" \"\")))\n@@ -199,6 +208,10 @@\n (define_cpu_unit \"store\" \"bfin\")\n (define_cpu_unit \"pregs\" \"bfin\")\n \n+;; A dummy unit used to delay scheduling of loads after a conditional\n+;; branch.\n+(define_cpu_unit \"load\" \"bfin\")\n+\n (define_reservation \"core\" \"slot0+slot1+slot2\")\n \n (define_insn_reservation \"alu\" 1\n@@ -216,17 +229,22 @@\n (define_insn_reservation \"load32\" 1\n   (and (not (eq_attr \"seq_insns\" \"multi\"))\n        (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"32bit\")))\n-  \"core\")\n+  \"core+load\")\n \n (define_insn_reservation \"loadp\" 1\n   (and (not (eq_attr \"seq_insns\" \"multi\"))\n        (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"preg\")))\n+  \"(slot1|slot2)+pregs+load\")\n+\n+(define_insn_reservation \"loadsp\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"spreg\")))\n   \"(slot1|slot2)+pregs\")\n \n (define_insn_reservation \"loadi\" 1\n   (and (not (eq_attr \"seq_insns\" \"multi\"))\n        (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"ireg\")))\n-  \"(slot1|slot2)\")\n+  \"(slot1|slot2)+load\")\n \n (define_insn_reservation \"store32\" 1\n   (and (not (eq_attr \"seq_insns\" \"multi\"))\n@@ -235,7 +253,8 @@\n \n (define_insn_reservation \"storep\" 1\n   (and (not (eq_attr \"seq_insns\" \"multi\"))\n-       (and (eq_attr \"type\" \"mcst\") (eq_attr \"addrtype\" \"preg\")))\n+       (and (eq_attr \"type\" \"mcst\")\n+\t    (ior (eq_attr \"addrtype\" \"preg\") (eq_attr \"addrtype\" \"spreg\"))))\n   \"(slot1|slot2)+pregs+store\")\n \n (define_insn_reservation \"storei\" 1\n@@ -247,6 +266,16 @@\n   (eq_attr \"seq_insns\" \"multi\")\n   \"core\")\n \n+(define_insn_reservation \"load_stall1\" 1\n+  (and (eq_attr \"type\" \"stall\")\n+       (match_operand 0 \"const1_operand\" \"\"))\n+  \"core+load*2\")\n+\n+(define_insn_reservation \"load_stall3\" 1\n+  (and (eq_attr \"type\" \"stall\")\n+       (match_operand 0 \"const3_operand\" \"\"))\n+  \"core+load*4\")\n+\n (absence_set \"slot0\" \"slot1,slot2\")\n (absence_set \"slot1\" \"slot2\")\n \n@@ -2667,6 +2696,9 @@\n   gcc_unreachable ();\n })\n \n+;; When used at a location where CC contains 1, causes a speculative load\n+;; that is later cancelled.  This is used for certain workarounds in\n+;; interrupt handler prologues.\n (define_insn \"dummy_load\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"a\")\n \t\t     (match_operand 1 \"register_operand\" \"C\")]\n@@ -2677,6 +2709,17 @@\n   (set_attr \"length\" \"4\")\n   (set_attr \"seq_insns\" \"multi\")])\n \n+;; A placeholder insn inserted before the final scheduling pass.  It is used\n+;; to improve scheduling of loads when workarounds for speculative loads are\n+;; needed, by not placing them in the first few cycles after a conditional\n+;; branch.\n+(define_insn \"stall\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"P1P3\")]\n+\t\t    UNSPEC_VOLATILE_STALL)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"stall\")])\n+\n (define_insn \"csync\"\n   [(unspec_volatile [(const_int 0)] UNSPEC_VOLATILE_CSYNC)]\n   \"\""}, {"sha": "37d1372216d6051d9aade365cfb0892880fd768f", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=c7cb1555e56257a2165fe1a15b636c7d0ff1fc0e", "patch": "@@ -59,6 +59,14 @@\n   (and (match_code \"const_int\")\n        (match_test \"op == const0_rtx || op == const1_rtx\")))\n \n+(define_predicate \"const1_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"op == const1_rtx\")))\n+\n+(define_predicate \"const3_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 3\")))\n+\n (define_predicate \"vec_shift_operand\"\n   (ior (and (match_code \"const_int\")\n \t    (match_test \"INTVAL (op) >= -16 && INTVAL (op) < 15\"))\n@@ -180,10 +188,14 @@\n (define_predicate \"bfin_direct_comparison_operator\"\n   (match_code \"eq,lt,le,leu,ltu\"))\n \n-;; The following two are used to compute the addrtype attribute.  They return\n+;; The following three are used to compute the addrtype attribute.  They return\n ;; true if passed a memory address usable for a 16-bit load or store using a\n ;; P or I register, respectively.  If neither matches, we know we have a\n ;; 32-bit instruction.\n+;; We subdivide the P case into normal P registers, and SP/FP.  We can assume\n+;; that speculative loads through SP and FP are no problem, so this has\n+;; an effect on the anomaly workaround code.\n+\n (define_predicate \"mem_p_address_operand\"\n   (match_code \"mem\")\n {\n@@ -193,7 +205,19 @@\n   if (GET_CODE (op) == PLUS || GET_RTX_CLASS (GET_CODE (op)) == RTX_AUTOINC)\n     op = XEXP (op, 0);\n   gcc_assert (REG_P (op));\n-  return PREG_P (op);\n+  return PREG_P (op) && op != stack_pointer_rtx && op != frame_pointer_rtx;\n+})\n+\n+(define_predicate \"mem_spfp_address_operand\"\n+  (match_code \"mem\")\n+{\n+  if (effective_address_32bit_p (op, mode))\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == PLUS || GET_RTX_CLASS (GET_CODE (op)) == RTX_AUTOINC)\n+    op = XEXP (op, 0);\n+  gcc_assert (REG_P (op));\n+  return op == stack_pointer_rtx || op == frame_pointer_rtx;\n })\n \n (define_predicate \"mem_i_address_operand\""}]}