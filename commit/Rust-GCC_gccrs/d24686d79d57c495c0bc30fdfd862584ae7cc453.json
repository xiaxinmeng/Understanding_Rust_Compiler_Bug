{"sha": "d24686d79d57c495c0bc30fdfd862584ae7cc453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI0Njg2ZDc5ZDU3YzQ5NWMwYmMzMGZkZmQ4NjI1ODRhZTdjYzQ1Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-06-21T09:38:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-06-21T09:38:34Z"}, "message": "var-tracking.c (struct shared_hash_def, [...]): New types.\n\n\t* var-tracking.c (struct shared_hash_def, shared_hash): New types.\n\t(dataflow_set): Change vars type from htab_t to shared_hash.\n\t(shared_hash_pool, empty_shared_hash): New variables.\n\t(vars_clear): Removed.\n\t(shared_hash_shared, shared_hash_htab, shared_hash_copy,\n\tshared_hash_find_slot_unshare, shared_hash_find_slot,\n\tshared_hash_find_slot_noinsert, shared_hash_find): New\n\tstatic inlines.\n\t(shared_hash_unshare, shared_hash_destroy): New functions.\n\t(unshare_variable): Unshare set->vars if shared, use\n\tshared_hash_htab.\n\t(vars_copy): Use htab_traverse_noresize instead of htab_traverse.\n\t(get_init_value, find_src_set_src, dump_dataflow_set,\n\tclobber_variable_part, emit_notes_for_differences): Use\n\tshared_hash_htab.\n\t(dataflow_set_init): Remove second argument, set vars to\n\tempty_shared_hash instead of creating a new htab.\n\t(dataflow_set_clear): Call shared_hash_destroy and set vars\n\tto empty_shared_hash instead of calling vars_clear.\n\t(dataflow_set_copy): Don't call vars_copy, instead just share\n\tthe src htab with dst.\n\t(variable_union): Use shared_hash_*, use initially NO_INSERT\n\tlookup if set->vars is shared.  Don't keep slot cleared before\n\tcalling unshare_variable.  Unshare set->vars if needed.\n\tEven ->refcount == 1 vars must be unshared if set->vars is shared\n\tand var needs to be modified.\n\t(variable_canonicalize): New function.\n\t(dataflow_set_union): If dst->vars is empty, just share src->vars\n\twith dst->vars and traverse with variable_canonicalize to canonicalize\n\tand unshare what is needed.\n\t(dataflow_set_different): If old_set and new_set use the same shared\n\thtab, they aren't different.  If number of htab elements is different,\n\thtabs are different.  Use shared_hash_*.\n\t(dataflow_set_destroy): Call shared_hash_destroy instead of\n\thtab_delete.\n\t(compute_bb_dataflow, emit_notes_in_bb, vt_emit_notes): Don't pass\n\tsecond argument to dataflow_set_init.\n\t(vt_initialize): Likewise.  Initialize shared_hash_pool and\n\tempty_shared_hash, move bb in/out initialization afterwards.\n\tUse variable_htab_free instead of NULL as changed_variables del hook.\n\t(variable_was_changed): Change type of second argument to pointer to\n\tdataflow_set.  When inserting var into changed_variables, bump\n\trefcount.  Unshare set->vars if set is shared htab and slot needs to\n\tbe cleared.\n\t(set_variable_part): Use shared_hash_*, use initially NO_INSERT\n\tlookup if set->vars is shared.  Unshare set->vars if needed.\n\tEven ->refcount == 1 vars must be unshared if set->vars is shared\n\tand var needs to be modified.  Adjust variable_was_changed caller.\n\t(delete_variable_part): Use shared_hash_*.  Even ->refcount == 1\n\tvars must be unshared if set->vars is shared and var needs to be\n\tmodified.  Adjust variable_was_changed caller.\n\t(emit_note_insn_var_location): Don't pool_free var.\n\t(emit_notes_for_differences_1): Initialize empty_var->refcount to 0\n\tinstead of 1.\n\t(vt_finalize): Call htab_delete on empty_shared_hash->htab and\n\tfree_alloc_pool on shared_hash_pool.\n\nFrom-SVN: r148760", "tree": {"sha": "3dcc260f9a281cc3291370645240f32ea1085370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dcc260f9a281cc3291370645240f32ea1085370"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d24686d79d57c495c0bc30fdfd862584ae7cc453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d24686d79d57c495c0bc30fdfd862584ae7cc453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d24686d79d57c495c0bc30fdfd862584ae7cc453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d24686d79d57c495c0bc30fdfd862584ae7cc453/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a46f975bee74ff08eb97aac61f2fb81faa2c173f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a46f975bee74ff08eb97aac61f2fb81faa2c173f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a46f975bee74ff08eb97aac61f2fb81faa2c173f"}], "stats": {"total": 429, "additions": 328, "deletions": 101}, "files": [{"sha": "4478145e3807428d7395a05a12a961be4aa4878a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d24686d79d57c495c0bc30fdfd862584ae7cc453/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d24686d79d57c495c0bc30fdfd862584ae7cc453/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d24686d79d57c495c0bc30fdfd862584ae7cc453", "patch": "@@ -1,3 +1,62 @@\n+2009-06-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* var-tracking.c (struct shared_hash_def, shared_hash): New types.\n+\t(dataflow_set): Change vars type from htab_t to shared_hash.\n+\t(shared_hash_pool, empty_shared_hash): New variables.\n+\t(vars_clear): Removed.\n+\t(shared_hash_shared, shared_hash_htab, shared_hash_copy,\n+\tshared_hash_find_slot_unshare, shared_hash_find_slot,\n+\tshared_hash_find_slot_noinsert, shared_hash_find): New\n+\tstatic inlines.\n+\t(shared_hash_unshare, shared_hash_destroy): New functions.\n+\t(unshare_variable): Unshare set->vars if shared, use\n+\tshared_hash_htab.\n+\t(vars_copy): Use htab_traverse_noresize instead of htab_traverse.\n+\t(get_init_value, find_src_set_src, dump_dataflow_set,\n+\tclobber_variable_part, emit_notes_for_differences): Use\n+\tshared_hash_htab.\n+\t(dataflow_set_init): Remove second argument, set vars to\n+\tempty_shared_hash instead of creating a new htab.\n+\t(dataflow_set_clear): Call shared_hash_destroy and set vars\n+\tto empty_shared_hash instead of calling vars_clear.\n+\t(dataflow_set_copy): Don't call vars_copy, instead just share\n+\tthe src htab with dst.\n+\t(variable_union): Use shared_hash_*, use initially NO_INSERT\n+\tlookup if set->vars is shared.  Don't keep slot cleared before\n+\tcalling unshare_variable.  Unshare set->vars if needed.\n+\tEven ->refcount == 1 vars must be unshared if set->vars is shared\n+\tand var needs to be modified.\n+\t(variable_canonicalize): New function.\n+\t(dataflow_set_union): If dst->vars is empty, just share src->vars\n+\twith dst->vars and traverse with variable_canonicalize to canonicalize\n+\tand unshare what is needed.\n+\t(dataflow_set_different): If old_set and new_set use the same shared\n+\thtab, they aren't different.  If number of htab elements is different,\n+\thtabs are different.  Use shared_hash_*.\n+\t(dataflow_set_destroy): Call shared_hash_destroy instead of\n+\thtab_delete.\n+\t(compute_bb_dataflow, emit_notes_in_bb, vt_emit_notes): Don't pass\n+\tsecond argument to dataflow_set_init.\n+\t(vt_initialize): Likewise.  Initialize shared_hash_pool and\n+\tempty_shared_hash, move bb in/out initialization afterwards.\n+\tUse variable_htab_free instead of NULL as changed_variables del hook.\n+\t(variable_was_changed): Change type of second argument to pointer to\n+\tdataflow_set.  When inserting var into changed_variables, bump\n+\trefcount.  Unshare set->vars if set is shared htab and slot needs to\n+\tbe cleared.\n+\t(set_variable_part): Use shared_hash_*, use initially NO_INSERT\n+\tlookup if set->vars is shared.  Unshare set->vars if needed.\n+\tEven ->refcount == 1 vars must be unshared if set->vars is shared\n+\tand var needs to be modified.  Adjust variable_was_changed caller.\n+\t(delete_variable_part): Use shared_hash_*.  Even ->refcount == 1\n+\tvars must be unshared if set->vars is shared and var needs to be\n+\tmodified.  Adjust variable_was_changed caller.\n+\t(emit_note_insn_var_location): Don't pool_free var.\n+\t(emit_notes_for_differences_1): Initialize empty_var->refcount to 0\n+\tinstead of 1.\n+\t(vt_finalize): Call htab_delete on empty_shared_hash->htab and\n+\tfree_alloc_pool on shared_hash_pool.\n+\n 2009-06-20  Anthony Green  <green@moxielogic.com>\n \n \t* config/moxie/sfp-machine.h (__gcc_CMPtype, CMPtype): Define."}, {"sha": "56e50c2c36d4edb1cb46e4b09e40bdeced34244e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 269, "deletions": 101, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d24686d79d57c495c0bc30fdfd862584ae7cc453/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d24686d79d57c495c0bc30fdfd862584ae7cc453/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d24686d79d57c495c0bc30fdfd862584ae7cc453", "patch": "@@ -182,6 +182,17 @@ typedef struct attrs_def\n   HOST_WIDE_INT offset;\n } *attrs;\n \n+/* Structure holding a refcounted hash table.  If refcount > 1,\n+   it must be first unshared before modified.  */\n+typedef struct shared_hash_def\n+{\n+  /* Reference count.  */\n+  int refcount;\n+\n+  /* Actual hash table.  */\n+  htab_t htab;\n+} *shared_hash;\n+\n /* Structure holding the IN or OUT set for a basic block.  */\n typedef struct dataflow_set_def\n {\n@@ -192,7 +203,7 @@ typedef struct dataflow_set_def\n   attrs regs[FIRST_PSEUDO_REGISTER];\n \n   /* Variable locations.  */\n-  htab_t vars;\n+  shared_hash vars;\n } dataflow_set;\n \n /* The structure (one for each basic block) containing the information\n@@ -280,12 +291,18 @@ static alloc_pool var_pool;\n /* Alloc pool for struct location_chain_def.  */\n static alloc_pool loc_chain_pool;\n \n+/* Alloc pool for struct shared_hash_def.  */\n+static alloc_pool shared_hash_pool;\n+\n /* Changed variables, notes will be emitted for them.  */\n static htab_t changed_variables;\n \n /* Shall notes be emitted?  */\n static bool emit_notes;\n \n+/* Empty shared hashtable.  */\n+static shared_hash empty_shared_hash;\n+\n /* Local function prototypes.  */\n static void stack_adjust_offset_pre_post (rtx, HOST_WIDE_INT *,\n \t\t\t\t\t  HOST_WIDE_INT *);\n@@ -305,7 +322,6 @@ static void attrs_list_insert (attrs *, tree, HOST_WIDE_INT, rtx);\n static void attrs_list_copy (attrs *, attrs);\n static void attrs_list_union (attrs *, attrs);\n \n-static void vars_clear (htab_t);\n static variable unshare_variable (dataflow_set *set, variable var, \n \t\t\t\t  enum var_init_status);\n static int vars_copy_1 (void **, void *);\n@@ -321,11 +337,12 @@ static void var_mem_delete_and_set (dataflow_set *, rtx, bool,\n \t\t\t\t    enum var_init_status, rtx);\n static void var_mem_delete (dataflow_set *, rtx, bool);\n \n-static void dataflow_set_init (dataflow_set *, int);\n+static void dataflow_set_init (dataflow_set *);\n static void dataflow_set_clear (dataflow_set *);\n static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n static int variable_union_info_cmp_pos (const void *, const void *);\n static int variable_union (void **, void *);\n+static int variable_canonicalize (void **, void *);\n static void dataflow_set_union (dataflow_set *, dataflow_set *);\n static bool variable_part_different_p (variable_part *, variable_part *);\n static bool variable_different_p (variable, variable, bool);\n@@ -352,7 +369,7 @@ static void dump_vars (htab_t);\n static void dump_dataflow_set (dataflow_set *);\n static void dump_dataflow_sets (void);\n \n-static void variable_was_changed (variable, htab_t);\n+static void variable_was_changed (variable, dataflow_set *);\n static void set_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT, \n \t\t\t       enum var_init_status, rtx);\n static void clobber_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT, \n@@ -742,12 +759,107 @@ attrs_list_union (attrs *dstp, attrs src)\n     }\n }\n \n-/* Delete all variables from hash table VARS.  */\n+/* Shared hashtable support.  */\n+\n+/* Return true if VARS is shared.  */\n+\n+static inline bool\n+shared_hash_shared (shared_hash vars)\n+{\n+  return vars->refcount > 1;\n+}\n+\n+/* Return the hash table for VARS.  */\n+\n+static inline htab_t\n+shared_hash_htab (shared_hash vars)\n+{\n+  return vars->htab;\n+}\n+\n+/* Copy variables into a new hash table.  */\n+\n+static shared_hash\n+shared_hash_unshare (shared_hash vars)\n+{\n+  shared_hash new_vars = (shared_hash) pool_alloc (shared_hash_pool);\n+  gcc_assert (vars->refcount > 1);\n+  new_vars->refcount = 1;\n+  new_vars->htab\n+    = htab_create (htab_elements (vars->htab) + 3, variable_htab_hash,\n+\t\t   variable_htab_eq, variable_htab_free);\n+  vars_copy (new_vars->htab, vars->htab);\n+  vars->refcount--;\n+  return new_vars;\n+}\n+\n+/* Increment reference counter on VARS and return it.  */\n+\n+static inline shared_hash\n+shared_hash_copy (shared_hash vars)\n+{\n+  vars->refcount++;\n+  return vars;\n+}\n+\n+/* Decrement reference counter and destroy hash table if not shared\n+   anymore.  */\n \n static void\n-vars_clear (htab_t vars)\n+shared_hash_destroy (shared_hash vars)\n {\n-  htab_empty (vars);\n+  gcc_assert (vars->refcount > 0);\n+  if (--vars->refcount == 0)\n+    {\n+      htab_delete (vars->htab);\n+      pool_free (shared_hash_pool, vars);\n+    }\n+}\n+\n+/* Unshare *PVARS if shared and return slot for DECL.  If INS is\n+   INSERT, insert it if not already present.  */\n+\n+static inline void **\n+shared_hash_find_slot_unshare (shared_hash *pvars, tree decl,\n+\t\t\t       enum insert_option ins)\n+{\n+  if (shared_hash_shared (*pvars))\n+    *pvars = shared_hash_unshare (*pvars);\n+  return htab_find_slot_with_hash (shared_hash_htab (*pvars), decl,\n+\t\t\t\t   VARIABLE_HASH_VAL (decl), ins);\n+}\n+\n+/* Return slot for DECL, if it is already present in the hash table.\n+   If it is not present, insert it only VARS is not shared, otherwise\n+   return NULL.  */\n+\n+static inline void **\n+shared_hash_find_slot (shared_hash vars, tree decl)\n+{\n+  return htab_find_slot_with_hash (shared_hash_htab (vars), decl,\n+\t\t\t\t   VARIABLE_HASH_VAL (decl),\n+\t\t\t\t   shared_hash_shared (vars)\n+\t\t\t\t   ? NO_INSERT : INSERT);\n+}\n+\n+/* Return slot for DECL only if it is already present in the hash table.  */\n+\n+static inline void **\n+shared_hash_find_slot_noinsert (shared_hash vars, tree decl)\n+{\n+  return htab_find_slot_with_hash (shared_hash_htab (vars), decl,\n+\t\t\t\t   VARIABLE_HASH_VAL (decl), NO_INSERT);\n+}\n+\n+/* Return variable for DECL or NULL if not already present in the hash\n+   table.  */\n+\n+static inline variable\n+shared_hash_find (shared_hash vars, tree decl)\n+{\n+  return (variable)\n+\t htab_find_with_hash (shared_hash_htab (vars), decl,\n+\t\t\t      VARIABLE_HASH_VAL (decl));\n }\n \n /* Return a copy of a variable VAR and insert it to dataflow set SET.  */\n@@ -801,9 +913,7 @@ unshare_variable (dataflow_set *set, variable var,\n \tnew_var->var_part[i].cur_loc = NULL;\n     }\n \n-  slot = htab_find_slot_with_hash (set->vars, new_var->decl,\n-\t\t\t\t   VARIABLE_HASH_VAL (new_var->decl),\n-\t\t\t\t   INSERT);\n+  slot = shared_hash_find_slot_unshare (&set->vars, new_var->decl, INSERT);\n   *slot = new_var;\n   return new_var;\n }\n@@ -834,8 +944,7 @@ vars_copy_1 (void **slot, void *data)\n static void\n vars_copy (htab_t dst, htab_t src)\n {\n-  vars_clear (dst);\n-  htab_traverse (src, vars_copy_1, dst);\n+  htab_traverse_noresize (src, vars_copy_1, dst);\n }\n \n /* Map a decl to its main debug decl.  */\n@@ -874,19 +983,16 @@ var_reg_set (dataflow_set *set, rtx loc, enum var_init_status initialized,\n static enum var_init_status\n get_init_value (dataflow_set *set, rtx loc, tree decl)\n {\n-  void **slot;\n   variable var;\n   int i;\n   enum var_init_status ret_val = VAR_INIT_STATUS_UNKNOWN;\n \n   if (! flag_var_tracking_uninit)\n     return VAR_INIT_STATUS_INITIALIZED;\n \n-  slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n-\t\t\t\t   NO_INSERT);\n-  if (slot)\n+  var = shared_hash_find (set->vars, decl);\n+  if (var)\n     {\n-      var = * (variable *) slot;\n       for (i = 0; i < var->n_var_parts && ret_val == VAR_INIT_STATUS_UNKNOWN; i++)\n \t{\n \t  location_chain nextp;\n@@ -1050,11 +1156,10 @@ var_mem_delete (dataflow_set *set, rtx loc, bool clobber)\n    VARS_SIZE is the initial size of hash table VARS.  */\n \n static void\n-dataflow_set_init (dataflow_set *set, int vars_size)\n+dataflow_set_init (dataflow_set *set)\n {\n   init_attrs_list_set (set->regs);\n-  set->vars = htab_create (vars_size, variable_htab_hash, variable_htab_eq,\n-\t\t\t   variable_htab_free);\n+  set->vars = shared_hash_copy (empty_shared_hash);\n   set->stack_adjust = 0;\n }\n \n@@ -1068,7 +1173,8 @@ dataflow_set_clear (dataflow_set *set)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     attrs_list_clear (&set->regs[i]);\n \n-  vars_clear (set->vars);\n+  shared_hash_destroy (set->vars);\n+  set->vars = shared_hash_copy (empty_shared_hash);\n }\n \n /* Copy the contents of dataflow set SRC to DST.  */\n@@ -1081,7 +1187,8 @@ dataflow_set_copy (dataflow_set *dst, dataflow_set *src)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     attrs_list_copy (&dst->regs[i], src->regs[i]);\n \n-  vars_copy (dst->vars, src->vars);\n+  shared_hash_destroy (dst->vars);\n+  dst->vars = shared_hash_copy (src->vars);\n   dst->stack_adjust = src->stack_adjust;\n }\n \n@@ -1129,15 +1236,14 @@ variable_union_info_cmp_pos (const void *n1, const void *n2)\n static int\n variable_union (void **slot, void *data)\n {\n-  variable src, dst, *dstp;\n+  variable src, dst;\n+  void **dstp;\n   dataflow_set *set = (dataflow_set *) data;\n   int i, j, k;\n \n   src = *(variable *) slot;\n-  dstp = (variable *) htab_find_slot_with_hash (set->vars, src->decl,\n-\t\t\t\t\t\tVARIABLE_HASH_VAL (src->decl),\n-\t\t\t\t\t\tINSERT);\n-  if (!*dstp)\n+  dstp = shared_hash_find_slot (set->vars, src->decl);\n+  if (!dstp || !*dstp)\n     {\n       src->refcount++;\n \n@@ -1162,16 +1268,23 @@ variable_union (void **slot, void *data)\n \t  if (! flag_var_tracking_uninit)\n \t    status = VAR_INIT_STATUS_INITIALIZED;\n \n+\t  if (dstp)\n+\t    *dstp = (void *) src;\n \t  unshare_variable (set, src, status);\n \t}\n       else\n-\t*dstp = src;\n+\t{\n+\t  if (!dstp)\n+\t    dstp = shared_hash_find_slot_unshare (&set->vars, src->decl,\n+\t\t\t\t\t\t  INSERT);\n+\t  *dstp = (void *) src;\n+\t}\n \n       /* Continue traversing the hash table.  */\n       return 1;\n     }\n   else\n-    dst = *dstp;\n+    dst = (variable) *dstp;\n \n   gcc_assert (src->n_var_parts);\n \n@@ -1196,7 +1309,8 @@ variable_union (void **slot, void *data)\n      thus there are at most MAX_VAR_PARTS different offsets.  */\n   gcc_assert (k <= MAX_VAR_PARTS);\n \n-  if (dst->refcount > 1 && dst->n_var_parts != k)\n+  if ((dst->refcount > 1 || shared_hash_shared (set->vars))\n+      && dst->n_var_parts != k)\n     {\n       enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n       \n@@ -1226,7 +1340,7 @@ variable_union (void **slot, void *data)\n \t  /* If DST is shared compare the location chains.\n \t     If they are different we will modify the chain in DST with\n \t     high probability so make a copy of DST.  */\n-\t  if (dst->refcount > 1)\n+\t  if (dst->refcount > 1 || shared_hash_shared (set->vars))\n \t    {\n \t      for (node = src->var_part[i].loc_chain,\n \t\t   node2 = dst->var_part[j].loc_chain; node && node2;\n@@ -1379,6 +1493,46 @@ variable_union (void **slot, void *data)\n   return 1;\n }\n \n+/* Like variable_union, but only used when doing dataflow_set_union\n+   into an empty hashtab.  To allow sharing, dst is initially shared\n+   with src (so all variables are \"copied\" from src to dst hashtab),\n+   so only unshare_variable for variables that need canonicalization\n+   are needed.  */\n+\n+static int\n+variable_canonicalize (void **slot, void *data)\n+{\n+  variable src;\n+  dataflow_set *set = (dataflow_set *) data;\n+  int k;\n+\n+  src = *(variable *) slot;\n+\n+  /* If CUR_LOC of some variable part is not the first element of\n+     the location chain we are going to change it so we have to make\n+     a copy of the variable.  */\n+  for (k = 0; k < src->n_var_parts; k++)\n+    {\n+      gcc_assert (!src->var_part[k].loc_chain == !src->var_part[k].cur_loc);\n+      if (src->var_part[k].loc_chain)\n+\t{\n+\t  gcc_assert (src->var_part[k].cur_loc);\n+\t  if (src->var_part[k].cur_loc != src->var_part[k].loc_chain->loc)\n+\t    break;\n+\t}\n+    }\n+  if (k < src->n_var_parts)\n+    {\n+      enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n+\n+      if (! flag_var_tracking_uninit)\n+\tstatus = VAR_INIT_STATUS_INITIALIZED;\n+\n+      unshare_variable (set, src, status);\n+    }\n+  return 1;\n+}\n+\n /* Compute union of dataflow sets SRC and DST and store it to DST.  */\n \n static void\n@@ -1389,7 +1543,14 @@ dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     attrs_list_union (&dst->regs[i], src->regs[i]);\n \n-  htab_traverse (src->vars, variable_union, dst);\n+  if (dst->vars == empty_shared_hash)\n+    {\n+      shared_hash_destroy (dst->vars);\n+      dst->vars = shared_hash_copy (src->vars);\n+      htab_traverse (shared_hash_htab (src->vars), variable_canonicalize, dst);\n+    }\n+  else\n+    htab_traverse (shared_hash_htab (src->vars), variable_union, dst);\n }\n \n /* Flag whether two dataflow sets being compared contain different data.  */\n@@ -1522,15 +1683,24 @@ dataflow_set_different_2 (void **slot, void *data)\n static bool\n dataflow_set_different (dataflow_set *old_set, dataflow_set *new_set)\n {\n+  if (old_set->vars == new_set->vars)\n+    return false;\n+\n+  if (htab_elements (shared_hash_htab (old_set->vars))\n+      != htab_elements (shared_hash_htab (new_set->vars)))\n+    return true;\n+\n   dataflow_set_different_value = false;\n \n-  htab_traverse (old_set->vars, dataflow_set_different_1, new_set->vars);\n+  htab_traverse (shared_hash_htab (old_set->vars), dataflow_set_different_1,\n+\t\t shared_hash_htab (new_set->vars));\n   if (!dataflow_set_different_value)\n     {\n       /* We have compared the variables which are in both hash tables\n \t so now only check whether there are some variables in NEW_SET->VARS\n \t which are not in OLD_SET->VARS.  */\n-      htab_traverse (new_set->vars, dataflow_set_different_2, old_set->vars);\n+      htab_traverse (shared_hash_htab (new_set->vars), dataflow_set_different_2,\n+\t\t     shared_hash_htab (old_set->vars));\n     }\n   return dataflow_set_different_value;\n }\n@@ -1545,7 +1715,7 @@ dataflow_set_destroy (dataflow_set *set)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     attrs_list_clear (&set->regs[i]);\n \n-  htab_delete (set->vars);\n+  shared_hash_destroy (set->vars);\n   set->vars = NULL;\n }\n \n@@ -1985,7 +2155,6 @@ find_src_set_src (dataflow_set *set, rtx src)\n {\n   tree decl = NULL_TREE;   /* The variable being copied around.          */\n   rtx set_src = NULL_RTX;  /* The value for \"decl\" stored in \"src\".      */\n-  void **slot;\n   variable var;\n   location_chain nextp;\n   int i;\n@@ -1998,12 +2167,9 @@ find_src_set_src (dataflow_set *set, rtx src)\n \n   if (src && decl)\n     {\n-      slot = htab_find_slot_with_hash (set->vars, decl, \n-\t\t\t\t       VARIABLE_HASH_VAL (decl), NO_INSERT);\n-\n-      if (slot)\n+      var = shared_hash_find (set->vars, decl);\n+      if (var)\n \t{\n-\t  var = *(variable *) slot;\n \t  found = false;\n \t  for (i = 0; i < var->n_var_parts && !found; i++)\n \t    for (nextp = var->var_part[i].loc_chain; nextp && !found; \n@@ -2031,7 +2197,7 @@ compute_bb_dataflow (basic_block bb)\n   dataflow_set *in = &VTI (bb)->in;\n   dataflow_set *out = &VTI (bb)->out;\n \n-  dataflow_set_init (&old_out, htab_elements (VTI (bb)->out.vars) + 3);\n+  dataflow_set_init (&old_out);\n   dataflow_set_copy (&old_out, out);\n   dataflow_set_copy (out, in);\n \n@@ -2323,7 +2489,7 @@ dump_dataflow_set (dataflow_set *set)\n \t  dump_attrs_list (set->regs[i]);\n \t}\n     }\n-  dump_vars (set->vars);\n+  dump_vars (shared_hash_htab (set->vars));\n   fprintf (dump_file, \"\\n\");\n }\n \n@@ -2345,10 +2511,10 @@ dump_dataflow_sets (void)\n }\n \n /* Add variable VAR to the hash table of changed variables and\n-   if it has no locations delete it from hash table HTAB.  */\n+   if it has no locations delete it from SET's hash table.  */\n \n static void\n-variable_was_changed (variable var, htab_t htab)\n+variable_was_changed (variable var, dataflow_set *set)\n {\n   hashval_t hash = VARIABLE_HASH_VAL (var->decl);\n \n@@ -2359,36 +2525,39 @@ variable_was_changed (variable var, htab_t htab)\n       slot = (variable *) htab_find_slot_with_hash (changed_variables,\n \t\t\t\t\t\t    var->decl, hash, INSERT);\n \n-      if (htab && var->n_var_parts == 0)\n+      if (set && var->n_var_parts == 0)\n \t{\n \t  variable empty_var;\n-\t  void **old;\n \n \t  empty_var = (variable) pool_alloc (var_pool);\n \t  empty_var->decl = var->decl;\n \t  empty_var->refcount = 1;\n \t  empty_var->n_var_parts = 0;\n \t  *slot = empty_var;\n-\n-\t  old = htab_find_slot_with_hash (htab, var->decl, hash,\n-\t\t\t\t\t  NO_INSERT);\n-\t  if (old)\n-\t    htab_clear_slot (htab, old);\n+\t  goto drop_var;\n \t}\n       else\n \t{\n+\t  var->refcount++;\n \t  *slot = var;\n \t}\n     }\n   else\n     {\n-      gcc_assert (htab);\n+      gcc_assert (set);\n       if (var->n_var_parts == 0)\n \t{\n-\t  void **slot = htab_find_slot_with_hash (htab, var->decl, hash,\n-\t\t\t\t\t\t  NO_INSERT);\n+\t  void **slot;\n+\n+\tdrop_var:\n+\t  slot = shared_hash_find_slot_noinsert (set->vars, var->decl);\n \t  if (slot)\n-\t    htab_clear_slot (htab, slot);\n+\t    {\n+\t      if (shared_hash_shared (set->vars))\n+\t\tslot = shared_hash_find_slot_unshare (&set->vars, var->decl,\n+\t\t\t\t\t\t      NO_INSERT);\n+\t      htab_clear_slot (shared_hash_htab (set->vars), slot);\n+\t    }\n \t}\n     }\n }\n@@ -2438,12 +2607,12 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n   location_chain node, next;\n   location_chain *nextp;\n   variable var;\n-  void **slot;\n-  \n-  slot = htab_find_slot_with_hash (set->vars, decl,\n-\t\t\t\t   VARIABLE_HASH_VAL (decl), INSERT);\n-  if (!*slot)\n+  void **slot = shared_hash_find_slot (set->vars, decl);\n+\n+  if (!slot || !*slot)\n     {\n+      if (!slot)\n+\tslot = shared_hash_find_slot_unshare (&set->vars, decl, INSERT);\n       /* Create new variable information.  */\n       var = (variable) pool_alloc (var_pool);\n       var->decl = decl;\n@@ -2479,13 +2648,12 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n \t      if (set_src != NULL)\n \t\tnode->set_src = set_src;\n \n-\t      *slot = var;\n \t      return;\n \t    }\n \t  else\n \t    {\n \t      /* We have to make a copy of a shared variable.  */\n-\t      if (var->refcount > 1)\n+\t      if (var->refcount > 1 || shared_hash_shared (set->vars))\n \t\tvar = unshare_variable (set, var, initialized);\n \t    }\n \t}\n@@ -2494,7 +2662,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n \t  /* We have not found the location part, new one will be created.  */\n \n \t  /* We have to make a copy of the shared variable.  */\n-\t  if (var->refcount > 1)\n+\t  if (var->refcount > 1 || shared_hash_shared (set->vars))\n \t    var = unshare_variable (set, var, initialized);\n \n \t  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n@@ -2548,7 +2716,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n   if (var->var_part[pos].cur_loc == NULL)\n     {\n       var->var_part[pos].cur_loc = loc;\n-      variable_was_changed (var, set->vars);\n+      variable_was_changed (var, set);\n     }\n }\n \n@@ -2561,16 +2729,14 @@ static void\n clobber_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t       HOST_WIDE_INT offset, rtx set_src)\n {\n-  void **slot;\n+  variable var;\n \n   if (! decl || ! DECL_P (decl))\n     return;\n \n-  slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n-\t\t\t\t   NO_INSERT);\n-  if (slot)\n+  var = shared_hash_find (set->vars, decl);\n+  if (var)\n     {\n-      variable var = (variable) *slot;\n       int pos = find_variable_location_part (var, offset, NULL);\n \n       if (pos >= 0)\n@@ -2627,13 +2793,9 @@ static void\n delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t      HOST_WIDE_INT offset)\n {\n-  void **slot;\n-    \n-  slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n-\t\t\t\t   NO_INSERT);\n-  if (slot)\n+  variable var = shared_hash_find (set->vars, decl);;\n+  if (var)\n     {\n-      variable var = (variable) *slot;\n       int pos = find_variable_location_part (var, offset, NULL);\n \n       if (pos >= 0)\n@@ -2642,7 +2804,7 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t  location_chain *nextp;\n \t  bool changed;\n \n-\t  if (var->refcount > 1)\n+\t  if (var->refcount > 1 || shared_hash_shared (set->vars))\n \t    {\n \t      /* If the variable contains the location part we have to\n \t\t make a copy of the variable.  */\n@@ -2705,7 +2867,7 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t}\n \t    }\n \t  if (changed)\n-\t    variable_was_changed (var, set->vars);\n+\t    variable_was_changed (var, set);\n \t}\n     }\n }\n@@ -2864,14 +3026,6 @@ emit_note_insn_var_location (void **varp, void *data)\n \n   htab_clear_slot (changed_variables, varp);\n \n-  /* When there are no location parts the variable has been already\n-     removed from hash table and a new empty variable was created.\n-     Free the empty variable.  */\n-  if (var->n_var_parts == 0)\n-    {\n-      pool_free (var_pool, var);\n-    }\n-\n   /* Continue traversing the hash table.  */\n   return 1;\n }\n@@ -2910,7 +3064,7 @@ emit_notes_for_differences_1 (void **slot, void *data)\n \n       empty_var = (variable) pool_alloc (var_pool);\n       empty_var->decl = old_var->decl;\n-      empty_var->refcount = 1;\n+      empty_var->refcount = 0;\n       empty_var->n_var_parts = 0;\n       variable_was_changed (empty_var, NULL);\n     }\n@@ -2952,8 +3106,12 @@ static void\n emit_notes_for_differences (rtx insn, dataflow_set *old_set,\n \t\t\t    dataflow_set *new_set)\n {\n-  htab_traverse (old_set->vars, emit_notes_for_differences_1, new_set->vars);\n-  htab_traverse (new_set->vars, emit_notes_for_differences_2, old_set->vars);\n+  htab_traverse (shared_hash_htab (old_set->vars),\n+\t\t emit_notes_for_differences_1,\n+\t\t shared_hash_htab (new_set->vars));\n+  htab_traverse (shared_hash_htab (new_set->vars),\n+\t\t emit_notes_for_differences_2,\n+\t\t shared_hash_htab (old_set->vars));\n   emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n }\n \n@@ -2965,7 +3123,7 @@ emit_notes_in_bb (basic_block bb)\n   int i;\n   dataflow_set set;\n \n-  dataflow_set_init (&set, htab_elements (VTI (bb)->in.vars) + 3);\n+  dataflow_set_init (&set);\n   dataflow_set_copy (&set, &VTI (bb)->in);\n \n   for (i = 0; i < VTI (bb)->n_mos; i++)\n@@ -3098,7 +3256,7 @@ vt_emit_notes (void)\n      delete_variable_part).  */\n   emit_notes = true;\n \n-  dataflow_set_init (&empty, 7);\n+  dataflow_set_init (&empty);\n   last_out = &empty;\n \n   FOR_EACH_BB (bb)\n@@ -3343,23 +3501,31 @@ vt_initialize (void)\n \t}\n     }\n \n-  /* Init the IN and OUT sets.  */\n-  FOR_ALL_BB (bb)\n-    {\n-      VTI (bb)->visited = false;\n-      dataflow_set_init (&VTI (bb)->in, 7);\n-      dataflow_set_init (&VTI (bb)->out, 7);\n-    }\n-\n   attrs_pool = create_alloc_pool (\"attrs_def pool\",\n \t\t\t\t  sizeof (struct attrs_def), 1024);\n   var_pool = create_alloc_pool (\"variable_def pool\",\n \t\t\t\tsizeof (struct variable_def), 64);\n   loc_chain_pool = create_alloc_pool (\"location_chain_def pool\",\n \t\t\t\t      sizeof (struct location_chain_def),\n \t\t\t\t      1024);\n+  shared_hash_pool = create_alloc_pool (\"shared_hash_def pool\",\n+\t\t\t\t\tsizeof (struct shared_hash_def), 256);\n+  empty_shared_hash = (shared_hash) pool_alloc (shared_hash_pool);\n+  empty_shared_hash->refcount = 1;\n+  empty_shared_hash->htab\n+    = htab_create (1, variable_htab_hash, variable_htab_eq,\n+\t\t   variable_htab_free);\n   changed_variables = htab_create (10, variable_htab_hash, variable_htab_eq,\n-\t\t\t\t   NULL);\n+\t\t\t\t   variable_htab_free);\n+\n+  /* Init the IN and OUT sets.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      VTI (bb)->visited = false;\n+      dataflow_set_init (&VTI (bb)->in);\n+      dataflow_set_init (&VTI (bb)->out);\n+    }\n+\n   vt_add_function_parameters ();\n }\n \n@@ -3381,10 +3547,12 @@ vt_finalize (void)\n       dataflow_set_destroy (&VTI (bb)->out);\n     }\n   free_aux_for_blocks ();\n+  htab_delete (empty_shared_hash->htab);\n+  htab_delete (changed_variables);\n   free_alloc_pool (attrs_pool);\n   free_alloc_pool (var_pool);\n   free_alloc_pool (loc_chain_pool);\n-  htab_delete (changed_variables);\n+  free_alloc_pool (shared_hash_pool);\n }\n \n /* The entry point to variable tracking pass.  */"}]}