{"sha": "76b4158b8fee22fd85d98e760cf4d12d7ae50051", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZiNDE1OGI4ZmVlMjJmZDg1ZDk4ZTc2MGNmNGQxMmQ3YWU1MDA1MQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-03T08:16:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-03T08:16:29Z"}, "message": "[Ada] Forced elaboration order in Elaboration order v4.0\n\nThis patch refactors the forced elaboration order functionality,\nreintegrates it in Binde, and impelements it in Bindo.\n\n------------\n-- Source --\n------------\n\n--  server.ads\n\npackage Server is\nend Server;\n\n--  client.ads\n\nwith Server;\n\npackage Client is\nend Client;\n\n--  main.adb\n\nwith Client;\n\nprocedure Main is begin null; end Main;\n\n--  duplicate_1.txt\n\nserver (spec)\nclient (spec)\nserver (spec)\n\n--  error_unit_1.txt\n\nno such unit\nclient (spec)\n\n--  error_unit_2.txt\n\nno such unit\nclient (spec)\n\n--  error_unit_3.txt\n\nno such unit     --  comment\nclient (spec)\n\n--  error_unit_4.txt\n\n         no such unit     --  comment\n\nclient (spec)\n\n--  error_unit_5.txt\n\nno such unit (body)\nclient (spec)\n\n--  error_unit_6.txt\n\n    no such unit (body)\nclient (spec)\n\n--  error_unit_7.txt\n\n    no such unit (body)    --  comment\nclient (spec)\n\n--  error_unit_8.txt\n\n    no such unit (body)--  comment\nclient (spec)\n\n--  error_unit_9.txt\n\n    no such unit--  comment\nclient (spec)\n\n--  no_unit_1.txt\n\n--  no_unit_2.txt\n\n--  no_unit_3.txt\n\n      --  comment\n\n--  no_unit_4.txt\n\n--  no_unit_5.txt\n\n--  no_unit_6.txt\n\n       --  comment\n\n--  no_unit_7.txt\n\n--  no_unit_8.txt\n\n    --  comment\n--  comment\n\n--  ok_unit_1.txt\n\nserver (spec)\nclient (spec)\n\n--  ok_unit_2.txt\n\n    server (spec)\nclient (spec)\n\n--  ok_unit_3.txt\n\n    server (spec)\nclient (spec)\n\n--  ok_unit_4.txt\n\n    server (spec)      --  comment\nclient (spec)\n\n--  ok_unit_5.txt\n\nserver (spec)\nclient (spec)\n\n--  ok_unit_6.txt\n\nserver (spec)\nclient (spec)    --  comment\n\n--  ok_unit_7.txt\n\nserver (spec)\nclient (spec)    --  comment\n\n--  ok_unit_8.txt\n\n    --  comment\n--  comment\n    server (spec)\n\n   --  comment\n--  comment\n\nclient (spec)    --  comment\n\n--  ok_unit_9.txt\n\nserver (spec)--  comment\nclient (spec)\n\n----------------------------\n-- Compilation and output --\n----------------------------\n$ gnatmake -q main.adb\n$ gnatbind -fno_unit_1.txt main.ali\n$ gnatbind -fno_unit_2.txt main.ali\n$ gnatbind -fno_unit_3.txt main.ali\n$ gnatbind -fno_unit_4.txt main.ali\n$ gnatbind -fno_unit_5.txt main.ali\n$ gnatbind -fno_unit_6.txt main.ali\n$ gnatbind -fno_unit_7.txt main.ali\n$ gnatbind -fno_unit_8.txt main.ali\n$ gnatbind -ferror_unit_1.txt main.ali\n$ gnatbind -ferror_unit_2.txt main.ali\n$ gnatbind -ferror_unit_3.txt main.ali\n$ gnatbind -ferror_unit_4.txt main.ali\n$ gnatbind -ferror_unit_5.txt main.ali\n$ gnatbind -ferror_unit_6.txt main.ali\n$ gnatbind -ferror_unit_7.txt main.ali\n$ gnatbind -ferror_unit_8.txt main.ali\n$ gnatbind -ferror_unit_9.txt main.ali\n$ gnatbind -fduplicate_1.txt main.ali\n$ gnatbind -fok_unit_1.txt main.ali\n$ gnatbind -fok_unit_2.txt main.ali\n$ gnatbind -fok_unit_3.txt main.ali\n$ gnatbind -fok_unit_4.txt main.ali\n$ gnatbind -fok_unit_5.txt main.ali\n$ gnatbind -fok_unit_6.txt main.ali\n$ gnatbind -fok_unit_7.txt main.ali\n$ gnatbind -fok_unit_8.txt main.ali\n$ gnatbind -fok_unit_9.txt main.ali\n\"no such unit\": not present; ignored\n\"no such unit\": not present; ignored\n\"no such unit\": not present; ignored\n\"no such unit\": not present; ignored\n\"no such unit%b\": not present; ignored\n\"no such unit%b\": not present; ignored\n\"no such unit%b\": not present; ignored\n\"no such unit%b\": not present; ignored\n\"no such unit\": not present; ignored\nserver (spec) <-- client (spec)\nerror: duplicate_1.txt:3: duplicate unit name \"server (spec)\" from line 1\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\nserver (spec) <-- client (spec)\n\n2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* binde.adb: Remove with clause for System.OS_Lib.\n\t(Force_Elab_Order): Refactor the majority of the code in Butil.\n\tUse the new forced units iterator to obtain unit names.\n\t* bindo-builders.adb: Add with and use clauses for Binderr,\n\tButil, Opt, Output, Types, GNAT, and GNAT.Dynamic_HTables.  Add\n\ta hash table which maps units to line number in the forced\n\telaboration order file.\n\t(Add_Unit): New routine.\n\t(Build_Library_Graph): Create forced edges between pairs of\n\tunits listed in the forced elaboration order file.\n\t(Create_Forced_Edge, Create_Forced_Edges, Destroy_Line_Number,\n\tDuplicate_Unit_Error, Hash_Unit, Internal_Unit_Info,\n\tIs_Duplicate_Unit, Missing_Unit_Info): New routines.\n\t* bindo-graphs.adb (Is_Internal_Unit, Is_Predefined_Unit):\n\tRefactor some of the behavior to Bindo-Units.\n\t* bindo-graphs.ads: Enable the enumeration literal for forced\n\tedges.\n\t* bindo-units.adb, bindo-units.ads (Is_Internal_Unit,\n\tIs_Predefined_Unit): New routines.\n\t* butil.adb: Add with and use clauses for Opt, GNAT, and\n\tSystem.OS_Lib.  Add with clause for Unchecked_Deallocation.\n\t(Has_Next, Iterate_Forced_Units, Next, Parse_Next_Unit_Name,\n\tRead_Forced_Elab_Order_File): New routines.\n\t* butil.ads: Add with and use clauses for Types.  Add new\n\titerator over the units listed in the forced elaboration order\n\tfile.\n\t(Has_Next, Iterate_Forced_Units, Next): New routine.\n\t* namet.adb, namet.ads (Present): New routine.\n\nFrom-SVN: r272987", "tree": {"sha": "40ad2a358112f68898f4d5ef18d7e1cb961308f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40ad2a358112f68898f4d5ef18d7e1cb961308f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76b4158b8fee22fd85d98e760cf4d12d7ae50051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b4158b8fee22fd85d98e760cf4d12d7ae50051", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b4158b8fee22fd85d98e760cf4d12d7ae50051", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b4158b8fee22fd85d98e760cf4d12d7ae50051/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "336878fc11b75f8ac962efd9150151b74685f7fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/336878fc11b75f8ac962efd9150151b74685f7fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/336878fc11b75f8ac962efd9150151b74685f7fb"}], "stats": {"total": 1214, "additions": 976, "deletions": 238}, "files": [{"sha": "8a774fd6310c0f674b87c1027fcd43a7543ba614", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -1,3 +1,34 @@\n+2019-07-03  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* binde.adb: Remove with clause for System.OS_Lib.\n+\t(Force_Elab_Order): Refactor the majority of the code in Butil.\n+\tUse the new forced units iterator to obtain unit names.\n+\t* bindo-builders.adb: Add with and use clauses for Binderr,\n+\tButil, Opt, Output, Types, GNAT, and GNAT.Dynamic_HTables.  Add\n+\ta hash table which maps units to line number in the forced\n+\telaboration order file.\n+\t(Add_Unit): New routine.\n+\t(Build_Library_Graph): Create forced edges between pairs of\n+\tunits listed in the forced elaboration order file.\n+\t(Create_Forced_Edge, Create_Forced_Edges, Destroy_Line_Number,\n+\tDuplicate_Unit_Error, Hash_Unit, Internal_Unit_Info,\n+\tIs_Duplicate_Unit, Missing_Unit_Info): New routines.\n+\t* bindo-graphs.adb (Is_Internal_Unit, Is_Predefined_Unit):\n+\tRefactor some of the behavior to Bindo-Units.\n+\t* bindo-graphs.ads: Enable the enumeration literal for forced\n+\tedges.\n+\t* bindo-units.adb, bindo-units.ads (Is_Internal_Unit,\n+\tIs_Predefined_Unit): New routines.\n+\t* butil.adb: Add with and use clauses for Opt, GNAT, and\n+\tSystem.OS_Lib.  Add with clause for Unchecked_Deallocation.\n+\t(Has_Next, Iterate_Forced_Units, Next, Parse_Next_Unit_Name,\n+\tRead_Forced_Elab_Order_File): New routines.\n+\t* butil.ads: Add with and use clauses for Types.  Add new\n+\titerator over the units listed in the forced elaboration order\n+\tfile.\n+\t(Has_Next, Iterate_Forced_Units, Next): New routine.\n+\t* namet.adb, namet.ads (Present): New routine.\n+\n 2019-07-03  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch3.adb (Access_Definition): The code was creating a"}, {"sha": "5caee491c07c370698258c9e9d0a0ec0d973f59c", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 63, "deletions": 229, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -35,7 +35,6 @@ with Types;   use Types;\n \n with System.Case_Util; use System.Case_Util;\n with System.HTable;\n-with System.OS_Lib;\n \n package body Binde is\n    use Unit_Id_Tables;\n@@ -115,7 +114,7 @@ package body Binde is\n       --  elaborated before After is elaborated.\n \n       Forced,\n-      --  Before and After come from a pair of lines in the forced elaboration\n+      --  Before and After come from a pair of lines in the forced-elaboration-\n       --  order file.\n \n       Elab,\n@@ -382,7 +381,7 @@ package body Binde is\n    --  \"$ must be elaborated before $ ...\" where ... is the reason.\n \n    procedure Force_Elab_Order;\n-   --  Gather dependencies from the forced elaboration order file (-f switch)\n+   --  Gather dependencies from the forced-elaboration-order file (-f switch)\n \n    procedure Gather_Dependencies;\n    --  Compute dependencies, building the Succ and UNR tables\n@@ -1795,30 +1794,13 @@ package body Binde is\n    ----------------------\n \n    procedure Force_Elab_Order is\n-      use System.OS_Lib;\n-      --  There is a lot of fiddly string manipulation below, because we don't\n-      --  want to depend on misc utility packages like Ada.Characters.Handling.\n-\n-      function Get_Line return String;\n-      --  Read the next line from the file content read by Read_File. Strip\n-      --  all leading and trailing blanks. Convert \"(spec)\" or \"(body)\" to\n-      --  \"%s\"/\"%b\". Remove comments (Ada style; \"--\" to end of line).\n-\n-      function Read_File (Name : String) return String_Ptr;\n-      --  Read the entire contents of the named file\n-\n       subtype Header_Num is Unit_Name_Type'Base range 0 .. 2**16 - 1;\n-      type Line_Number is new Nat;\n-      No_Line_Number  : constant Line_Number := 0;\n-      Cur_Line_Number : Line_Number := 0;\n-      --  Current line number in the Force_Elab_Order_File.\n-      --  Incremented by Get_Line. Used in error messages.\n \n       function Hash (N : Unit_Name_Type) return Header_Num;\n \n       package Name_Map is new System.HTable.Simple_HTable\n         (Header_Num => Header_Num,\n-         Element    => Line_Number,\n+         Element    => Logical_Line_Number,\n          No_Element => No_Line_Number,\n          Key        => Unit_Name_Type,\n          Hash       => Hash,\n@@ -1839,234 +1821,86 @@ package body Binde is\n          return (N - Unit_Name_Type'First) mod (Header_Num'Last + 1);\n       end Hash;\n \n-      ---------------\n-      -- Read_File --\n-      ---------------\n-\n-      function Read_File (Name : String) return String_Ptr is\n-\n-         --  All of the following calls should succeed, because we checked the\n-         --  file in Switch.B, but we double check and raise Program_Error on\n-         --  failure, just in case.\n-\n-         F : constant File_Descriptor := Open_Read (Name, Binary);\n-\n-      begin\n-         if F = Invalid_FD then\n-            raise Program_Error;\n-         end if;\n-\n-         declare\n-            Len      : constant Natural    := Natural (File_Length (F));\n-            Result   : constant String_Ptr := new String (1 .. Len);\n-            Len_Read : constant Natural    :=\n-                         Read (F, Result (1)'Address, Len);\n-\n-            Status : Boolean;\n-\n-         begin\n-            if Len_Read /= Len then\n-               raise Program_Error;\n-            end if;\n-\n-            Close (F, Status);\n-\n-            if not Status then\n-               raise Program_Error;\n-            end if;\n-\n-            return Result;\n-         end;\n-      end Read_File;\n-\n-      Cur : Positive   := 1;\n-      S   : String_Ptr := Read_File (Force_Elab_Order_File.all);\n-\n-      --------------\n-      -- Get_Line --\n-      --------------\n-\n-      function Get_Line return String is\n-         First : Positive := Cur;\n-         Last  : Natural;\n-\n-      begin\n-         Cur_Line_Number := Cur_Line_Number + 1;\n-\n-         --  Skip to end of line\n-\n-         while Cur <= S'Last\n-           and then S (Cur) /= ASCII.LF\n-           and then S (Cur) /= ASCII.CR\n-         loop\n-            Cur := Cur + 1;\n-         end loop;\n-\n-         --  Strip leading blanks\n-\n-         while First <= S'Last and then S (First) = ' ' loop\n-            First := First + 1;\n-         end loop;\n-\n-         --  Strip trailing blanks and comment\n+      --  Local variables\n \n-         Last := Cur - 1;\n+      Cur_Line_Number : Logical_Line_Number;\n+      Error           : Boolean := False;\n+      Iter            : Forced_Units_Iterator;\n+      Prev_Unit       : Unit_Id := No_Unit_Id;\n+      Uname           : Unit_Name_Type;\n \n-         for J in First .. Last - 1 loop\n-            if S (J .. J + 1) = \"--\" then\n-               Last := J - 1;\n-               exit;\n-            end if;\n-         end loop;\n-\n-         while Last >= First and then S (Last) = ' ' loop\n-            Last := Last - 1;\n-         end loop;\n+   --  Start of processing for Force_Elab_Order\n \n-         --  Convert \"(spec)\" or \"(body)\" to \"%s\"/\"%b\", strip trailing blanks\n-         --  again.\n+   begin\n+      Iter := Iterate_Forced_Units;\n+      while Has_Next (Iter) loop\n+         Next (Iter, Uname, Cur_Line_Number);\n \n          declare\n-            Body_String : constant String   := \"(body)\";\n-            BL          : constant Positive := Body_String'Length;\n-            Spec_String : constant String   := \"(spec)\";\n-            SL          : constant Positive := Spec_String'Length;\n-\n-            Line : String renames S (First .. Last);\n-\n-            Is_Body : Boolean := False;\n-            Is_Spec : Boolean := False;\n-\n+            Dup : constant Logical_Line_Number := Name_Map.Get (Uname);\n          begin\n-            if Line'Length >= SL\n-              and then Line (Last - SL + 1 .. Last) = Spec_String\n-            then\n-               Is_Spec := True;\n-               Last := Last - SL;\n-            elsif Line'Length >= BL\n-              and then Line (Last - BL + 1 .. Last) = Body_String\n-            then\n-               Is_Body := True;\n-               Last := Last - BL;\n-            end if;\n-\n-            while Last >= First and then S (Last) = ' ' loop\n-               Last := Last - 1;\n-            end loop;\n+            if Dup = No_Line_Number then\n+               Name_Map.Set (Uname, Cur_Line_Number);\n \n-            --  Skip past LF or CR/LF\n+               --  We don't need to give the \"not present\" message in the case\n+               --  of \"duplicate unit\", because we would have already given the\n+               --  \"not present\" message on the first occurrence.\n \n-            if Cur <= S'Last and then S (Cur) = ASCII.CR then\n-               Cur := Cur + 1;\n-            end if;\n-\n-            if Cur <= S'Last and then S (Cur) = ASCII.LF then\n-               Cur := Cur + 1;\n-            end if;\n+               if Get_Name_Table_Int (Uname) = 0\n+                 or else Unit_Id (Get_Name_Table_Int (Uname)) = No_Unit_Id\n+               then\n+                  Error := True;\n+                  if Doing_New then\n+                     Write_Line\n+                       (\"\"\"\" & Get_Name_String (Uname)\n+                        & \"\"\": not present; ignored\");\n+                  end if;\n+               end if;\n \n-            if Is_Spec then\n-               return Line (First .. Last) & \"%s\";\n-            elsif Is_Body then\n-               return Line (First .. Last) & \"%b\";\n             else\n-               return Line;\n+               Error := True;\n+               if Doing_New then\n+                  Error_Msg_Nat_1  := Nat (Cur_Line_Number);\n+                  Error_Msg_Unit_1 := Uname;\n+                  Error_Msg_Nat_2  := Nat (Dup);\n+                  Error_Msg\n+                    (Force_Elab_Order_File.all\n+                     & \":#: duplicate unit name $ from line #\");\n+               end if;\n             end if;\n          end;\n-      end Get_Line;\n \n-      --  Local variables\n-\n-      Empty_Name : constant Unit_Name_Type := Name_Find (\"\");\n-      Prev_Unit  : Unit_Id := No_Unit_Id;\n-\n-   --  Start of processing for Force_Elab_Order\n-\n-   begin\n-      --  Loop through the file content, and build a dependency link for each\n-      --  pair of lines. Ignore lines that should be ignored.\n-\n-      while Cur <= S'Last loop\n-         declare\n-            Uname : constant Unit_Name_Type := Name_Find (Get_Line);\n-            Error : Boolean := False;\n-\n-         begin\n-            if Uname = Empty_Name then\n-               null; -- silently skip blank lines\n-            else\n-               declare\n-                  Dup : constant Line_Number := Name_Map.Get (Uname);\n-               begin\n-                  if Dup = No_Line_Number then\n-                     Name_Map.Set (Uname, Cur_Line_Number);\n-\n-                     --  We don't need to give the \"not present\" message in\n-                     --  the case of \"duplicate unit\", because we would have\n-                     --  already given the \"not present\" message on the\n-                     --  first occurrence.\n-\n-                     if Get_Name_Table_Int (Uname) = 0\n-                       or else Unit_Id (Get_Name_Table_Int (Uname)) =\n-                                 No_Unit_Id\n-                     then\n-                        Error := True;\n-                        if Doing_New then\n-                           Write_Line\n-                             (\"\"\"\" & Get_Name_String (Uname)\n-                              & \"\"\": not present; ignored\");\n-                        end if;\n-                     end if;\n+         if not Error then\n+            declare\n+               Cur_Unit : constant Unit_Id := Unit_Id_Of (Uname);\n+            begin\n+               if Is_Internal_File_Name (Units.Table (Cur_Unit).Sfile) then\n+                  if Doing_New then\n+                     Write_Line\n+                       (\"\"\"\" & Get_Name_String (Uname)\n+                        & \"\"\": predefined unit ignored\");\n+                  end if;\n \n-                  else\n-                     Error := True;\n+               else\n+                  if Prev_Unit /= No_Unit_Id then\n                      if Doing_New then\n-                        Error_Msg_Nat_1  := Nat (Cur_Line_Number);\n-                        Error_Msg_Unit_1 := Uname;\n-                        Error_Msg_Nat_2  := Nat (Dup);\n-                        Error_Msg\n-                          (Force_Elab_Order_File.all\n-                           & \":#: duplicate unit name $ from line #\");\n+                        Write_Unit_Name (Units.Table (Prev_Unit).Uname);\n+                        Write_Str (\" <-- \");\n+                        Write_Unit_Name (Units.Table (Cur_Unit).Uname);\n+                        Write_Eol;\n                      end if;\n-                  end if;\n-               end;\n-\n-               if not Error then\n-                  declare\n-                     Cur_Unit : constant Unit_Id := Unit_Id_Of (Uname);\n-                  begin\n-                     if Is_Internal_File_Name\n-                          (Units.Table (Cur_Unit).Sfile)\n-                     then\n-                        if Doing_New then\n-                           Write_Line\n-                             (\"\"\"\" & Get_Name_String (Uname)\n-                              & \"\"\": predefined unit ignored\");\n-                        end if;\n \n-                     else\n-                        if Prev_Unit /= No_Unit_Id then\n-                           if Doing_New then\n-                              Write_Unit_Name (Units.Table (Prev_Unit).Uname);\n-                              Write_Str (\" <-- \");\n-                              Write_Unit_Name (Units.Table (Cur_Unit).Uname);\n-                              Write_Eol;\n-                           end if;\n-\n-                           Build_Link\n-                             (Before => Prev_Unit,\n-                              After  => Cur_Unit,\n-                              R      => Forced);\n-                        end if;\n+                     Build_Link\n+                       (Before => Prev_Unit,\n+                        After  => Cur_Unit,\n+                        R      => Forced);\n+                  end if;\n \n-                        Prev_Unit := Cur_Unit;\n-                     end if;\n-                  end;\n+                  Prev_Unit := Cur_Unit;\n                end if;\n-            end if;\n-         end;\n+            end;\n+         end if;\n       end loop;\n-\n-      Free (S);\n    end Force_Elab_Order;\n \n    -------------------------"}, {"sha": "c0340c09f1c55ff7a2bfc514b4e4630d34b98552", "filename": "gcc/ada/bindo-builders.adb", "status": "modified", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-builders.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-builders.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-builders.adb?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -23,8 +23,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Binderr; use Binderr;\n+with Butil;   use Butil;\n+with Opt;     use Opt;\n+with Output;  use Output;\n+with Types;   use Types;\n+\n with Bindo.Units; use Bindo.Units;\n \n+with GNAT;                 use GNAT;\n+with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n+\n package body Bindo.Builders is\n \n    -------------------------------\n@@ -214,16 +223,63 @@ package body Bindo.Builders is\n \n    package body Library_Graph_Builders is\n \n+      ---------------------\n+      -- Data structures --\n+      ---------------------\n+\n+      procedure Destroy_Line_Number (Line : in out Logical_Line_Number);\n+      pragma Inline (Destroy_Line_Number);\n+      --  Destroy line number Line\n+\n+      function Hash_Unit (U_Id : Unit_Id) return Bucket_Range_Type;\n+      pragma Inline (Hash_Unit);\n+      --  Obtain the hash value of key U_Id\n+\n+      package UL is new Dynamic_Hash_Tables\n+        (Key_Type              => Unit_Id,\n+         Value_Type            => Logical_Line_Number,\n+         No_Value              => No_Line_Number,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Line_Number,\n+         Hash                  => Hash_Unit);\n+\n       -----------------\n       -- Global data --\n       -----------------\n \n       Lib_Graph : Library_Graph := Library_Graphs.Nil;\n \n+      Unit_To_Line : UL.Dynamic_Hash_Table := UL.Nil;\n+      --  The map of unit name -> line number, used to detect duplicate unit\n+      --  names and report errors.\n+\n       -----------------------\n       -- Local subprograms --\n       -----------------------\n \n+      procedure Add_Unit\n+        (U_Id : Unit_Id;\n+         Line : Logical_Line_Number);\n+      pragma Inline (Add_Unit);\n+      --  Create a relationship between unit U_Id and its declaration line in\n+      --  map Unit_To_Line.\n+\n+      procedure Create_Forced_Edge\n+        (Pred : Unit_Id;\n+         Succ : Unit_Id);\n+      pragma Inline (Create_Forced_Edge);\n+      --  Create a new forced edge between predecessor unit Pred and successor\n+      --  unit Succ.\n+\n+      procedure Create_Forced_Edges;\n+      pragma Inline (Create_Forced_Edges);\n+      --  Inspect the contents of the forced-elaboration-order file, and create\n+      --  specialized edges for each valid pair of units listed within.\n+\n       procedure Create_Spec_And_Body_Edge (U_Id : Unit_Id);\n       pragma Inline (Create_Spec_And_Body_Edge);\n       --  Establish a link between the spec and body of unit U_Id. In certain\n@@ -255,10 +311,46 @@ package body Bindo.Builders is\n       --  some withed unit, and the successor is Succ. The edges are added to\n       --  library graph Lib_Graph.\n \n+      procedure Duplicate_Unit_Error\n+        (U_Id : Unit_Id;\n+         Nam  : Unit_Name_Type;\n+         Line : Logical_Line_Number);\n+      pragma Inline (Duplicate_Unit_Error);\n+      --  Emit an error concerning the duplication of unit U_Id with name Nam\n+      --  that is redeclared in the forced-elaboration-order file at line Line.\n+\n+      procedure Internal_Unit_Info (Nam : Unit_Name_Type);\n+      pragma Inline (Internal_Unit_Info);\n+      --  Emit an information message concerning the omission of an internal\n+      --  unit with name Nam from the creation of forced edges.\n+\n+      function Is_Duplicate_Unit (U_Id : Unit_Id) return Boolean;\n+      pragma Inline (Is_Duplicate_Unit);\n+      --  Determine whether unit U_Id is already recorded in map Unit_To_Line\n+\n       function Is_Significant_With (W_Id : With_Id) return Boolean;\n       pragma Inline (Is_Significant_With);\n       --  Determine whether with W_Id plays a significant role in elaboration\n \n+      procedure Missing_Unit_Info (Nam : Unit_Name_Type);\n+      pragma Inline (Missing_Unit_Info);\n+      --  Emit an information message concerning the omission of an undefined\n+      --  unit found in the forced-elaboration-order file.\n+\n+      --------------\n+      -- Add_Unit --\n+      --------------\n+\n+      procedure Add_Unit\n+        (U_Id : Unit_Id;\n+         Line : Logical_Line_Number)\n+      is\n+      begin\n+         pragma Assert (Present (U_Id));\n+\n+         UL.Put (Unit_To_Line, U_Id, Line);\n+      end Add_Unit;\n+\n       -------------------------\n       -- Build_Library_Graph --\n       -------------------------\n@@ -275,9 +367,96 @@ package body Bindo.Builders is\n          For_Each_Elaborable_Unit (Create_Spec_And_Body_Edge'Access);\n          For_Each_Elaborable_Unit (Create_With_Edges'Access);\n \n+         Create_Forced_Edges;\n+\n          return Lib_Graph;\n       end Build_Library_Graph;\n \n+      ------------------------\n+      -- Create_Forced_Edge --\n+      ------------------------\n+\n+      procedure Create_Forced_Edge\n+        (Pred : Unit_Id;\n+         Succ : Unit_Id)\n+      is\n+         pragma Assert (Present (Pred));\n+         pragma Assert (Present (Succ));\n+\n+         Pred_LGV_Id : constant Library_Graph_Vertex_Id :=\n+                         Corresponding_Vertex (Lib_Graph, Pred);\n+         Succ_LGV_Id : constant Library_Graph_Vertex_Id :=\n+                         Corresponding_Vertex (Lib_Graph, Succ);\n+\n+         pragma Assert (Present (Pred_LGV_Id));\n+         pragma Assert (Present (Succ_LGV_Id));\n+\n+      begin\n+         Write_Unit_Name (Name (Pred));\n+         Write_Str (\" <-- \");\n+         Write_Unit_Name (Name (Succ));\n+         Write_Eol;\n+\n+         Add_Edge\n+           (G    => Lib_Graph,\n+            Pred => Pred_LGV_Id,\n+            Succ => Succ_LGV_Id,\n+            Kind => Forced_Edge);\n+      end Create_Forced_Edge;\n+\n+      -------------------------\n+      -- Create_Forced_Edges --\n+      -------------------------\n+\n+      procedure Create_Forced_Edges is\n+         Curr_Unit : Unit_Id;\n+         Iter      : Forced_Units_Iterator;\n+         Prev_Unit : Unit_Id;\n+         Unit_Line : Logical_Line_Number;\n+         Unit_Name : Unit_Name_Type;\n+\n+      begin\n+         Prev_Unit    := No_Unit_Id;\n+         Unit_To_Line := UL.Create (20);\n+\n+         --  Inspect the contents of the forced-elaboration-order file supplied\n+         --  to the binder using switch -f, and diagnose each unit accordingly.\n+\n+         Iter := Iterate_Forced_Units;\n+         while Has_Next (Iter) loop\n+            Next (Iter, Unit_Name, Unit_Line);\n+            pragma Assert (Present (Unit_Name));\n+\n+            Curr_Unit := Corresponding_Unit (Unit_Name);\n+\n+            if not Present (Curr_Unit) then\n+               Missing_Unit_Info (Unit_Name);\n+\n+            elsif Is_Internal_Unit (Curr_Unit) then\n+               Internal_Unit_Info (Unit_Name);\n+\n+            elsif Is_Duplicate_Unit (Curr_Unit) then\n+               Duplicate_Unit_Error (Curr_Unit, Unit_Name, Unit_Line);\n+\n+            --  Otherwise the unit is a valid candidate for a vertex. Create a\n+            --  forced edge between each pair of units.\n+\n+            else\n+               Add_Unit (Curr_Unit, Unit_Line);\n+\n+               if Present (Prev_Unit) then\n+                  Create_Forced_Edge\n+                    (Pred => Prev_Unit,\n+                     Succ => Curr_Unit);\n+               end if;\n+\n+               Prev_Unit := Curr_Unit;\n+            end if;\n+         end loop;\n+\n+         UL.Destroy (Unit_To_Line);\n+      end Create_Forced_Edges;\n+\n       -------------------------------\n       -- Create_Spec_And_Body_Edge --\n       -------------------------------\n@@ -453,6 +632,75 @@ package body Bindo.Builders is\n          end loop;\n       end Create_With_Edges;\n \n+      ------------------\n+      -- Destroy_Unit --\n+      ------------------\n+\n+      procedure Destroy_Line_Number (Line : in out Logical_Line_Number) is\n+         pragma Unreferenced (Line);\n+      begin\n+         null;\n+      end Destroy_Line_Number;\n+\n+      --------------------------\n+      -- Duplicate_Unit_Error --\n+      --------------------------\n+\n+      procedure Duplicate_Unit_Error\n+        (U_Id : Unit_Id;\n+         Nam  : Unit_Name_Type;\n+         Line : Logical_Line_Number)\n+      is\n+         pragma Assert (Present (U_Id));\n+         pragma Assert (Present (Nam));\n+\n+         Prev_Line : constant Logical_Line_Number :=\n+                       UL.Get (Unit_To_Line, U_Id);\n+\n+      begin\n+         Error_Msg_Nat_1  := Nat (Line);\n+         Error_Msg_Nat_2  := Nat (Prev_Line);\n+         Error_Msg_Unit_1 := Nam;\n+\n+         Error_Msg\n+           (Force_Elab_Order_File.all\n+            & \":#: duplicate unit name $ from line #\");\n+      end Duplicate_Unit_Error;\n+\n+      ---------------\n+      -- Hash_Unit --\n+      ---------------\n+\n+      function Hash_Unit (U_Id : Unit_Id) return Bucket_Range_Type is\n+      begin\n+         pragma Assert (Present (U_Id));\n+\n+         return Bucket_Range_Type (U_Id);\n+      end Hash_Unit;\n+\n+      ------------------------\n+      -- Internal_Unit_Info --\n+      ------------------------\n+\n+      procedure Internal_Unit_Info (Nam : Unit_Name_Type) is\n+      begin\n+         pragma Assert (Present (Nam));\n+\n+         Write_Line\n+           (\"\"\"\" & Get_Name_String (Nam) & \"\"\": predefined unit ignored\");\n+      end Internal_Unit_Info;\n+\n+      -----------------------\n+      -- Is_Duplicate_Unit --\n+      -----------------------\n+\n+      function Is_Duplicate_Unit (U_Id : Unit_Id) return Boolean is\n+      begin\n+         pragma Assert (Present (U_Id));\n+\n+         return UL.Contains (Unit_To_Line, U_Id);\n+      end Is_Duplicate_Unit;\n+\n       -------------------------\n       -- Is_Significant_With --\n       -------------------------\n@@ -483,6 +731,18 @@ package body Bindo.Builders is\n \n          return True;\n       end Is_Significant_With;\n+\n+      -----------------------\n+      -- Missing_Unit_Info --\n+      -----------------------\n+\n+      procedure Missing_Unit_Info (Nam : Unit_Name_Type) is\n+      begin\n+         pragma Assert (Present (Nam));\n+\n+         Write_Line\n+           (\"\"\"\" & Get_Name_String (Nam) & \"\"\": not present; ignored\");\n+      end Missing_Unit_Info;\n    end Library_Graph_Builders;\n \n end Bindo.Builders;"}, {"sha": "b2f458c3b998e97e19b3530118ed78e2212b73ad", "filename": "gcc/ada/bindo-graphs.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.adb?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -2069,10 +2069,8 @@ package body Bindo.Graphs is\n \n          pragma Assert (Present (U_Id));\n \n-         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n-\n       begin\n-         return U_Rec.Internal;\n+         return Is_Internal_Unit (U_Id);\n       end Is_Internal_Unit;\n \n       ------------------------\n@@ -2090,10 +2088,8 @@ package body Bindo.Graphs is\n \n          pragma Assert (Present (U_Id));\n \n-         U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n-\n       begin\n-         return U_Rec.Predefined;\n+         return Is_Predefined_Unit (U_Id);\n       end Is_Predefined_Unit;\n \n       ---------------------------"}, {"sha": "a5dc6ea252f0c163168fc92cd5ea5e090f9917af", "filename": "gcc/ada/bindo-graphs.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.ads?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -573,7 +573,7 @@ package Bindo.Graphs is\n          Elaborate_All_Edge,\n          --  Successor withs Predecessor, and has pragma Elaborate_All for it\n \n---       Forced_Edge,\n+         Forced_Edge,\n          --  Successor is forced to with Predecessor by virtue of an existing\n          --  elaboration order provided in a file.\n "}, {"sha": "de0afb9f27274ec01c3fc252f58fed49a27b5074", "filename": "gcc/ada/bindo-units.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-units.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-units.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-units.adb?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -233,6 +233,32 @@ package body Bindo.Units is\n       return U_Rec.Dynamic_Elab;\n    end Is_Dynamically_Elaborated;\n \n+   ----------------------\n+   -- Is_Internal_Unit --\n+   ----------------------\n+\n+   function Is_Internal_Unit (U_Id : Unit_Id) return Boolean is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.Internal;\n+   end Is_Internal_Unit;\n+\n+   ------------------------\n+   -- Is_Predefined_Unit --\n+   ------------------------\n+\n+   function Is_Predefined_Unit (U_Id : Unit_Id) return Boolean is\n+      pragma Assert (Present (U_Id));\n+\n+      U_Rec : Unit_Record renames ALI.Units.Table (U_Id);\n+\n+   begin\n+      return U_Rec.Predefined;\n+   end Is_Predefined_Unit;\n+\n    ---------------------------------\n    -- Is_Stand_Alone_Library_Unit --\n    ---------------------------------"}, {"sha": "93caadf2d096b79a298aef6b9f4739185d864c61", "filename": "gcc/ada/bindo-units.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-units.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbindo-units.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-units.ads?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -78,6 +78,14 @@ package Bindo.Units is\n    --  Determine whether unit U_Id was compiled using the dynamic elaboration\n    --  model.\n \n+   function Is_Internal_Unit (U_Id : Unit_Id) return Boolean;\n+   pragma Inline (Is_Internal_Unit);\n+   --  Determine whether unit U_Id is internal\n+\n+   function Is_Predefined_Unit (U_Id : Unit_Id) return Boolean;\n+   pragma Inline (Is_Predefined_Unit);\n+   --  Determine whether unit U_Id is predefined\n+\n    function Name (U_Id : Unit_Id) return Unit_Name_Type;\n    pragma Inline (Name);\n    --  Obtain the name of unit U_Id"}, {"sha": "9427ddd8dd175e1875a4cae9dc77d27092a65bbb", "filename": "gcc/ada/butil.adb", "status": "modified", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbutil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbutil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbutil.adb?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -23,10 +23,38 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Opt;    use Opt;\n with Output; use Output;\n+with Unchecked_Deallocation;\n+\n+with GNAT; use GNAT;\n+\n+with System.OS_Lib; use System.OS_Lib;\n \n package body Butil is\n \n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   procedure Parse_Next_Unit_Name (Iter : in out Forced_Units_Iterator);\n+   --  Parse the name of the next available unit accessible through iterator\n+   --  Iter and save it in the iterator.\n+\n+   function Read_Forced_Elab_Order_File return String_Ptr;\n+   --  Read the contents of the forced-elaboration-order file supplied to the\n+   --  binder via switch -f and return them as a string. Return null if the\n+   --  file is not available.\n+\n+   --------------\n+   -- Has_Next --\n+   --------------\n+\n+   function Has_Next (Iter : Forced_Units_Iterator) return Boolean is\n+   begin\n+      return Present (Iter.Unit_Name);\n+   end Has_Next;\n+\n    ----------------------\n    -- Is_Internal_Unit --\n    ----------------------\n@@ -71,6 +99,499 @@ package body Butil is\n         or else (L >  4 and then B (1 ..  5) = \"gnat.\");\n    end Is_Predefined_Unit;\n \n+   --------------------------\n+   -- Iterate_Forced_Units --\n+   --------------------------\n+\n+   function Iterate_Forced_Units return Forced_Units_Iterator is\n+      Iter : Forced_Units_Iterator;\n+\n+   begin\n+      Iter.Order := Read_Forced_Elab_Order_File;\n+      Parse_Next_Unit_Name (Iter);\n+\n+      return Iter;\n+   end Iterate_Forced_Units;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next\n+     (Iter      : in out Forced_Units_Iterator;\n+      Unit_Name : out Unit_Name_Type;\n+      Unit_Line : out Logical_Line_Number)\n+   is\n+   begin\n+      if not Has_Next (Iter) then\n+         raise Iterator_Exhausted;\n+      end if;\n+\n+      Unit_Line := Iter.Unit_Line;\n+      Unit_Name := Iter.Unit_Name;\n+      pragma Assert (Present (Unit_Name));\n+\n+      Parse_Next_Unit_Name (Iter);\n+   end Next;\n+\n+   --------------------------\n+   -- Parse_Next_Unit_Name --\n+   --------------------------\n+\n+   procedure Parse_Next_Unit_Name (Iter : in out Forced_Units_Iterator) is\n+      Body_Suffix : constant String   := \" (body)\";\n+      Body_Type   : constant String   := \"%b\";\n+      Body_Length : constant Positive := Body_Suffix'Length;\n+      Body_Offset : constant Natural  := Body_Length - 1;\n+\n+      Comment_Header : constant String  := \"--\";\n+      Comment_Offset : constant Natural := Comment_Header'Length - 1;\n+\n+      Spec_Suffix : constant String   := \" (spec)\";\n+      Spec_Type   : constant String   := \"%s\";\n+      Spec_Length : constant Positive := Spec_Suffix'Length;\n+      Spec_Offset : constant Natural  := Spec_Length - 1;\n+\n+      Index : Positive            renames Iter.Order_Index;\n+      Line  : Logical_Line_Number renames Iter.Order_Line;\n+      Order : String_Ptr          renames Iter.Order;\n+\n+      function At_Comment return Boolean;\n+      pragma Inline (At_Comment);\n+      --  Determine whether iterator Iter is positioned over the start of a\n+      --  comment.\n+\n+      function At_Terminator return Boolean;\n+      pragma Inline (At_Terminator);\n+      --  Determine whether iterator Iter is positioned over a line terminator\n+      --  character.\n+\n+      function At_Whitespace return Boolean;\n+      pragma Inline (At_Whitespace);\n+      --  Determine whether iterator Iter is positioned over a whitespace\n+      --  character.\n+\n+      function Is_Terminator (C : Character) return Boolean;\n+      pragma Inline (Is_Terminator);\n+      --  Determine whether character C denotes a line terminator\n+\n+      function Is_Whitespace (C : Character) return Boolean;\n+      pragma Inline (Is_Whitespace);\n+      --  Determine whether character C denotes a whitespace\n+\n+      procedure Parse_Unit_Name;\n+      pragma Inline (Parse_Unit_Name);\n+      --  Find and parse the first available unit name\n+\n+      procedure Skip_Comment;\n+      pragma Inline (Skip_Comment);\n+      --  Skip a comment by reaching a line terminator\n+\n+      procedure Skip_Terminator;\n+      pragma Inline (Skip_Terminator);\n+      --  Skip a line terminator and deal with the logical line numbering\n+\n+      procedure Skip_Whitespace;\n+      pragma Inline (Skip_Whitespace);\n+      --  Skip whitespace\n+\n+      function Within_Order\n+        (Low_Offset  : Natural := 0;\n+         High_Offset : Natural := 0) return Boolean;\n+      pragma Inline (Within_Order);\n+      --  Determine whether index of iterator Iter is still within the range of\n+      --  the order string. Low_Offset may be used to inspect the area that is\n+      --  less than the index. High_Offset may be used to inspect the area that\n+      --  is greater than the index.\n+\n+      ----------------\n+      -- At_Comment --\n+      ----------------\n+\n+      function At_Comment return Boolean is\n+      begin\n+         --  The interator is over a comment when the index is positioned over\n+         --  the start of a comment header.\n+         --\n+         --    unit (spec)  --  comment\n+         --                 ^\n+         --                 Index\n+\n+         return\n+           Within_Order (High_Offset => Comment_Offset)\n+             and then Order (Index .. Index + Comment_Offset) = Comment_Header;\n+      end At_Comment;\n+\n+      -------------------\n+      -- At_Terminator --\n+      -------------------\n+\n+      function At_Terminator return Boolean is\n+      begin\n+         return Within_Order and then Is_Terminator (Order (Index));\n+      end At_Terminator;\n+\n+      -------------------\n+      -- At_Whitespace --\n+      -------------------\n+\n+      function At_Whitespace return Boolean is\n+      begin\n+         return Within_Order and then Is_Whitespace (Order (Index));\n+      end At_Whitespace;\n+\n+      -------------------\n+      -- Is_Terminator --\n+      -------------------\n+\n+      function Is_Terminator (C : Character) return Boolean is\n+      begin\n+         --  Carriage return is treated intentionally as whitespace since it\n+         --  appears only on certain targets, while line feed is consistent on\n+         --  all of them.\n+\n+         return C = ASCII.LF;\n+      end Is_Terminator;\n+\n+      -------------------\n+      -- Is_Whitespace --\n+      -------------------\n+\n+      function Is_Whitespace (C : Character) return Boolean is\n+      begin\n+         return\n+           C = ' '\n+             or else C = ASCII.CR   --  carriage return\n+             or else C = ASCII.FF   --  form feed\n+             or else C = ASCII.HT   --  horizontal tab\n+             or else C = ASCII.VT;  --  vertical tab\n+      end Is_Whitespace;\n+\n+      ---------------------\n+      -- Parse_Unit_Name --\n+      ---------------------\n+\n+      procedure Parse_Unit_Name is\n+         pragma Assert (not At_Comment);\n+         pragma Assert (not At_Terminator);\n+         pragma Assert (not At_Whitespace);\n+         pragma Assert (Within_Order);\n+\n+         procedure Find_End_Index_Of_Unit_Name;\n+         pragma Inline (Find_End_Index_Of_Unit_Name);\n+         --  Position the index of iterator Iter at the last character of the\n+         --  first available unit name.\n+\n+         ---------------------------------\n+         -- Find_End_Index_Of_Unit_Name --\n+         ---------------------------------\n+\n+         procedure Find_End_Index_Of_Unit_Name is\n+         begin\n+            --  At this point the index points at the start of a unit name. The\n+            --  unit name may be legal, in which case it appears as:\n+            --\n+            --    unit (body)\n+            --\n+            --  However, it may also be illegal:\n+            --\n+            --    unit without suffix\n+            --    unit with multiple prefixes (spec)\n+            --\n+            --  In order to handle both forms, find the construct following the\n+            --  unit name. This is either a comment, a terminator, or the end\n+            --  of the order:\n+            --\n+            --    unit (body)    --  comment\n+            --    unit without suffix    <terminator>\n+            --    unit with multiple prefixes (spec)<end of order>\n+            --\n+            --  Once the construct is found, truncate the unit name by skipping\n+            --  all white space between the construct and the end of the unit\n+            --  name.\n+\n+            --  Find the construct that follows the unit name\n+\n+            while Within_Order loop\n+               if At_Comment then\n+                  exit;\n+\n+               elsif At_Terminator then\n+                  exit;\n+               end if;\n+\n+               Index := Index + 1;\n+            end loop;\n+\n+            --  Position the index prior to the construct that follows the unit\n+            --  name.\n+\n+            Index := Index - 1;\n+\n+            --  Truncate towards the end of the unit name\n+\n+            while Within_Order loop\n+               if At_Whitespace then\n+                  Index := Index - 1;\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+         end Find_End_Index_Of_Unit_Name;\n+\n+         --  Local variables\n+\n+         Start_Index : constant Positive := Index;\n+\n+         End_Index : Positive;\n+         Is_Body   : Boolean := False;\n+         Is_Spec   : Boolean := False;\n+\n+      --  Start of processing for Parse_Unit_Name\n+\n+      begin\n+         Find_End_Index_Of_Unit_Name;\n+         End_Index := Index;\n+\n+         pragma Assert (Start_Index <= End_Index);\n+\n+         --  At this point the indices are positioned as follows:\n+         --\n+         --              End_Index\n+         --              Index\n+         --              v\n+         --    unit (spec)     --  comment\n+         --    ^\n+         --    Start_Index\n+\n+         --  Rewind the index, skipping over the legal suffixes\n+         --\n+         --    Index     End_Index\n+         --        v     v\n+         --    unit (spec)     --  comment\n+         --    ^\n+         --    Start_Index\n+\n+         if Within_Order (Low_Offset => Body_Offset)\n+           and then Order (Index - Body_Offset .. Index) = Body_Suffix\n+         then\n+            Is_Body := True;\n+            Index   := Index - Body_Length;\n+\n+         elsif Within_Order (Low_Offset => Spec_Offset)\n+           and then Order (Index - Spec_Offset .. Index) = Spec_Suffix\n+         then\n+            Is_Spec := True;\n+            Index   := Index - Spec_Length;\n+         end if;\n+\n+         --  Capture the line where the unit name is defined\n+\n+         Iter.Unit_Line := Line;\n+\n+         --  Transform the unit name to match the format recognized by the\n+         --  name table.\n+\n+         if Is_Body then\n+            Iter.Unit_Name :=\n+              Name_Find (Order (Start_Index .. Index) & Body_Type);\n+\n+         elsif Is_Spec then\n+            Iter.Unit_Name :=\n+              Name_Find (Order (Start_Index .. Index) & Spec_Type);\n+\n+         --  Otherwise the unit name is illegal, so leave it as is\n+\n+         else\n+            Iter.Unit_Name := Name_Find (Order (Start_Index .. Index));\n+         end if;\n+\n+         --  Advance the index past the unit name\n+         --\n+         --      End_IndexIndex\n+         --              vv\n+         --    unit (spec)     --  comment\n+         --    ^\n+         --    Start_Index\n+\n+         Index := End_Index + 1;\n+      end Parse_Unit_Name;\n+\n+      ------------------\n+      -- Skip_Comment --\n+      ------------------\n+\n+      procedure Skip_Comment is\n+      begin\n+         pragma Assert (At_Comment);\n+\n+         while Within_Order loop\n+            if At_Terminator then\n+               exit;\n+            end if;\n+\n+            Index := Index + 1;\n+         end loop;\n+      end Skip_Comment;\n+\n+      ---------------------\n+      -- Skip_Terminator --\n+      ---------------------\n+\n+      procedure Skip_Terminator is\n+      begin\n+         pragma Assert (At_Terminator);\n+\n+         Index := Index + 1;\n+         Line  := Line  + 1;\n+      end Skip_Terminator;\n+\n+      ---------------------\n+      -- Skip_Whitespace --\n+      ---------------------\n+\n+      procedure Skip_Whitespace is\n+      begin\n+         while Within_Order loop\n+            if At_Whitespace then\n+               Index := Index + 1;\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+      end Skip_Whitespace;\n+\n+      ------------------\n+      -- Within_Order --\n+      ------------------\n+\n+      function Within_Order\n+        (Low_Offset  : Natural := 0;\n+         High_Offset : Natural := 0) return Boolean\n+      is\n+      begin\n+         return\n+           Order /= null\n+             and then Index - Low_Offset  >= Order'First\n+             and then Index + High_Offset <= Order'Last;\n+      end Within_Order;\n+\n+   --  Start of processing for Parse_Next_Unit_Name\n+\n+   begin\n+      --  A line in the forced-elaboration-order file has the following\n+      --  grammar:\n+      --\n+      --    LINE ::=\n+      --      [WHITESPACE] UNIT_NAME [WHITESPACE] [COMMENT] TERMINATOR\n+      --\n+      --    WHITESPACE ::=\n+      --      <any whitespace character>\n+      --    | <carriage return>\n+      --\n+      --    UNIT_NAME ::=\n+      --      UNIT_PREFIX [WHITESPACE] UNIT_SUFFIX\n+      --\n+      --    UNIT_PREFIX ::=\n+      --      <any string>\n+      --\n+      --    UNIT_SUFFIX ::=\n+      --      (body)\n+      --    | (spec)\n+      --\n+      --    COMMENT ::=\n+      --      --  <any string>\n+      --\n+      --    TERMINATOR ::=\n+      --      <line feed>\n+      --      <end of file>\n+      --\n+      --  Items in <> brackets are semantic notions\n+\n+      --  Assume that the order has no remaining units\n+\n+      Iter.Unit_Line := No_Line_Number;\n+      Iter.Unit_Name := No_Unit_Name;\n+\n+      --  Try to find the first available unit name from the current position\n+      --  of iteration.\n+\n+      while Within_Order loop\n+         Skip_Whitespace;\n+\n+         if At_Comment then\n+            Skip_Comment;\n+\n+         elsif not Within_Order then\n+            exit;\n+\n+         elsif At_Terminator then\n+            Skip_Terminator;\n+\n+         else\n+            Parse_Unit_Name;\n+            exit;\n+         end if;\n+      end loop;\n+   end Parse_Next_Unit_Name;\n+\n+   ---------------------------------\n+   -- Read_Forced_Elab_Order_File --\n+   ---------------------------------\n+\n+   function Read_Forced_Elab_Order_File return String_Ptr is\n+      procedure Free is new Unchecked_Deallocation (String, String_Ptr);\n+\n+      Descr    : File_Descriptor;\n+      Len      : Natural;\n+      Len_Read : Natural;\n+      Result   : String_Ptr;\n+      Success  : Boolean;\n+\n+   begin\n+      if Force_Elab_Order_File = null then\n+         return null;\n+      end if;\n+\n+      --  Obtain and sanitize a descriptor to the elaboration-order file\n+\n+      Descr := Open_Read (Force_Elab_Order_File.all, Binary);\n+\n+      if Descr = Invalid_FD then\n+         return null;\n+      end if;\n+\n+      --  Determine the size of the file, allocate a result large enough to\n+      --  house its contents, and read it.\n+\n+      Len := Natural (File_Length (Descr));\n+\n+      if Len = 0 then\n+         return null;\n+      end if;\n+\n+      Result   := new String (1 .. Len);\n+      Len_Read := Read (Descr, Result (1)'Address, Len);\n+\n+      --  The read failed to acquire the whole content of the file\n+\n+      if Len_Read /= Len then\n+         Free (Result);\n+         return null;\n+      end if;\n+\n+      Close (Descr, Success);\n+\n+      --  The file failed to close\n+\n+      if not Success then\n+         Free (Result);\n+         return null;\n+      end if;\n+\n+      return Result;\n+   end Read_Forced_Elab_Order_File;\n+\n    ----------------\n    -- Uname_Less --\n    ----------------"}, {"sha": "3ce2f1e6b4060cf49443f3b7924a499d19e4a606", "filename": "gcc/ada/butil.ads", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbutil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fbutil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbutil.ads?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -23,12 +23,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  This package contains utility routines for the binder\n+\n with Namet; use Namet;\n+with Types; use Types;\n \n package Butil is\n \n---  This package contains utility routines for the binder\n-\n    function Is_Predefined_Unit return Boolean;\n    --  Given a unit name stored in Name_Buffer with length in Name_Len,\n    --  returns True if this is the name of a predefined unit or a child of\n@@ -51,4 +52,52 @@ package Butil is\n    --  Output unit name with (body) or (spec) after as required. On return\n    --  Name_Len is set to the number of characters which were output.\n \n+   ---------------\n+   -- Iterators --\n+   ---------------\n+\n+   --  The following type represents an iterator over all units that are\n+   --  specified in the forced-elaboration-order file supplied by the binder\n+   --  via switch -f.\n+\n+   type Forced_Units_Iterator is private;\n+\n+   function Has_Next (Iter : Forced_Units_Iterator) return Boolean;\n+   pragma Inline (Has_Next);\n+   --  Determine whether iterator Iter has more units to examine\n+\n+   function Iterate_Forced_Units return Forced_Units_Iterator;\n+   pragma Inline (Iterate_Forced_Units);\n+   --  Obtain an iterator over all units in the forced-elaboration-order file\n+\n+   procedure Next\n+     (Iter      : in out Forced_Units_Iterator;\n+      Unit_Name : out Unit_Name_Type;\n+      Unit_Line : out Logical_Line_Number);\n+   pragma Inline (Next);\n+   --  Return the current unit referenced by iterator Iter along with the\n+   --  line number it appears on, and advance to the next available unit.\n+\n+private\n+   First_Line_Number : constant Logical_Line_Number := No_Line_Number + 1;\n+\n+   type Forced_Units_Iterator is record\n+      Order : String_Ptr := null;\n+      --  A reference to the contents of the forced-elaboration-order file,\n+      --  read in as a string.\n+\n+      Order_Index : Positive := 1;\n+      --  Index into the order string\n+\n+      Order_Line : Logical_Line_Number := First_Line_Number;\n+      --  Logical line number within the order string\n+\n+      Unit_Line : Logical_Line_Number := No_Line_Number;\n+      --  The logical line number of the current unit name within the order\n+      --  string.\n+\n+      Unit_Name : Unit_Name_Type := No_Unit_Name;\n+      --  The current unit name parsed from the order string\n+   end record;\n+\n end Butil;"}, {"sha": "c5454d40d6939d955aa427f0681e82f260fe93bf", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -1515,6 +1515,15 @@ package body Namet is\n       return Nam /= No_Name;\n    end Present;\n \n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Nam : Unit_Name_Type) return Boolean is\n+   begin\n+      return Nam /= No_Unit_Name;\n+   end Present;\n+\n    ------------------\n    -- Reinitialize --\n    ------------------"}, {"sha": "a54735ae47a62a2928c6447c3d04954d9c6cfc64", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4158b8fee22fd85d98e760cf4d12d7ae50051/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=76b4158b8fee22fd85d98e760cf4d12d7ae50051", "patch": "@@ -658,6 +658,10 @@ package Namet is\n    No_Unit_Name : constant Unit_Name_Type := Unit_Name_Type (No_Name);\n    --  Constant used to indicate no file name present\n \n+   function Present (Nam : Unit_Name_Type) return Boolean;\n+   pragma Inline (Present);\n+   --  Determine whether unit name Nam exists\n+\n    Error_Unit_Name : constant Unit_Name_Type := Unit_Name_Type (Error_Name);\n    --  The special Unit_Name_Type value Error_Unit_Name is used to indicate\n    --  a unit name where some previous processing has found an error."}]}