{"sha": "e77e24291b85bcb1ae1c7c48d8194a66ba642974", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc3ZTI0MjkxYjg1YmNiMWFlMWM3YzQ4ZDgxOTRhNjZiYTY0Mjk3NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:28:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:28:25Z"}, "message": "[multiple changes]\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_prag.adb, a-cofuse.adb, a-cofuse.ads, einfo.adb, sem_prag.adb,\n\tcstand.adb, par-prag.adb, a-cofuve.adb, a-cofuve.ads, a-cofuma.adb,\n\ta-cofuma.ads, a-cofuba.adb, a-cofuba.ads: Minor reformatting.\n\n2017-04-27  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-excmac-gcc.ads, s-excmac-gcc.adb,\n\ts-excmac-arm.ads, s-excmac-arm.adb (New_Occurrence): Rewrite it in\n\tAda95.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Establish_Transient_Scope): Rewrite\n\tthe loop which detects potential enclosing transient scopes. The\n\tloop now terminates much earlier as transient scopes are bounded\n\tby packages and subprograms.\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfdlli.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Cursor): Type is now public so that it can be used in\n\tmodel functions.\n\t(Formal_Model): Ghost package containing\n\tmodel functions that are used in subprogram contracts.\n\t(Current_To_Last): Removed, model functions should be used\n\tinstead.\n\t(First_To_Previous): Removed, model functions should\n\tbe used instead.\n\t(Strict_Equal): Removed, model functions\n\tshould be used instead.\n\t(Append): Default parameter value\n\treplaced by new wrapper to allow more precise contracts.\n\t(Insert): Default parameter value replaced by new wrapper to\n\tallow more precise contracts.\n\t(Delete): Default parameter\n\tvalue replaced by new wrapper to allow more precise contracts.\n\t(Prepend): Default parameter value replaced by new wrapper to\n\tallow more precise contracts.\n\t(Delete_First): Default parameter\n\tvalue replaced by new wrapper to allow more precise contracts.\n\t(Delete_Last): Default parameter value replaced by new wrapper\n\tto allow more precise contracts.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_spark.adb (Expand_SPARK): Perform specialized expansion\n\tfor object declarations.\n\t(Expand_SPARK_N_Object_Declaration): New routine.\n\t* sem_elab.adb (Check_A_Call): Include calls to the\n\tDefault_Initial_Condition procedure of a type under the SPARK\n\telaboration checks umbrella.\n\nFrom-SVN: r247299", "tree": {"sha": "5e080280fd7114ec553325e130b90e1eb5defe4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e080280fd7114ec553325e130b90e1eb5defe4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e77e24291b85bcb1ae1c7c48d8194a66ba642974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e77e24291b85bcb1ae1c7c48d8194a66ba642974", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e77e24291b85bcb1ae1c7c48d8194a66ba642974", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e77e24291b85bcb1ae1c7c48d8194a66ba642974/comments", "author": null, "committer": null, "parents": [{"sha": "7a71a7c4bbb2041be244646acec0b2a363bc9282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a71a7c4bbb2041be244646acec0b2a363bc9282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a71a7c4bbb2041be244646acec0b2a363bc9282"}], "stats": {"total": 2626, "additions": 2135, "deletions": 491}, "files": [{"sha": "c8746dba4331b7372c2e78e070f96ae09755f23a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -1,3 +1,58 @@\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_prag.adb, a-cofuse.adb, a-cofuse.ads, einfo.adb, sem_prag.adb,\n+\tcstand.adb, par-prag.adb, a-cofuve.adb, a-cofuve.ads, a-cofuma.adb,\n+\ta-cofuma.ads, a-cofuba.adb, a-cofuba.ads: Minor reformatting.\n+\n+2017-04-27  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-excmac-gcc.ads, s-excmac-gcc.adb,\n+\ts-excmac-arm.ads, s-excmac-arm.adb (New_Occurrence): Rewrite it in\n+\tAda95.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Establish_Transient_Scope): Rewrite\n+\tthe loop which detects potential enclosing transient scopes. The\n+\tloop now terminates much earlier as transient scopes are bounded\n+\tby packages and subprograms.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfdlli.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Cursor): Type is now public so that it can be used in\n+\tmodel functions.\n+\t(Formal_Model): Ghost package containing\n+\tmodel functions that are used in subprogram contracts.\n+\t(Current_To_Last): Removed, model functions should be used\n+\tinstead.\n+\t(First_To_Previous): Removed, model functions should\n+\tbe used instead.\n+\t(Strict_Equal): Removed, model functions\n+\tshould be used instead.\n+\t(Append): Default parameter value\n+\treplaced by new wrapper to allow more precise contracts.\n+\t(Insert): Default parameter value replaced by new wrapper to\n+\tallow more precise contracts.\n+\t(Delete): Default parameter\n+\tvalue replaced by new wrapper to allow more precise contracts.\n+\t(Prepend): Default parameter value replaced by new wrapper to\n+\tallow more precise contracts.\n+\t(Delete_First): Default parameter\n+\tvalue replaced by new wrapper to allow more precise contracts.\n+\t(Delete_Last): Default parameter value replaced by new wrapper\n+\tto allow more precise contracts.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_spark.adb (Expand_SPARK): Perform specialized expansion\n+\tfor object declarations.\n+\t(Expand_SPARK_N_Object_Declaration): New routine.\n+\t* sem_elab.adb (Check_A_Call): Include calls to the\n+\tDefault_Initial_Condition procedure of a type under the SPARK\n+\telaboration checks umbrella.\n+\n 2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem.adb (Analyze): Diagnose an illegal iterated component"}, {"sha": "52bdc18ea55e01dc1e46ffcd94528690068545a2", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 436, "deletions": 131, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,10 +40,6 @@ is\n       New_Item  : Element_Type;\n       New_Node  : out Count_Type);\n \n-   procedure Allocate\n-     (Container : in out List;\n-      New_Node  : out Count_Type);\n-\n    procedure Free\n      (Container : in out List;\n       X         : Count_Type);\n@@ -109,31 +105,22 @@ is\n       end if;\n    end Allocate;\n \n-   procedure Allocate\n-     (Container : in out List;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-         Container.Free := N (New_Node).Next;\n-\n-      else\n-         New_Node := abs Container.Free;\n-         Container.Free := Container.Free - 1;\n-      end if;\n-   end Allocate;\n-\n    ------------\n    -- Append --\n    ------------\n \n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, 1);\n+   end Append;\n+\n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    is\n    begin\n       Insert (Container, No_Element, New_Item, Count);\n@@ -161,7 +148,7 @@ is\n \n       J := Source.First;\n       while J /= 0 loop\n-         Append (Target, N (J).Element);\n+         Append (Target, N (J).Element, 1);\n          J := N (J).Next;\n       end loop;\n    end Assign;\n@@ -259,44 +246,24 @@ is\n       return P;\n    end Copy;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n-\n-   function Current_To_Last\n-     (Container : List;\n-      Current : Cursor) return List is\n-      Curs : Cursor := First (Container);\n-      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if Current /= No_Element and not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Current.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Current_To_Last;\n-\n    ------------\n    -- Delete --\n    ------------\n \n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor)\n+   is\n+   begin\n+      Delete (Container => Container,\n+              Position  => Position,\n+              Count     => 1);\n+   end Delete;\n+\n    procedure Delete\n      (Container : in out List;\n       Position  : in out Cursor;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    is\n       N : Node_Array renames Container.Nodes;\n       X : Count_Type;\n@@ -357,9 +324,16 @@ is\n    -- Delete_First --\n    ------------------\n \n+   procedure Delete_First (Container : in out List)\n+   is\n+   begin\n+      Delete_First (Container => Container,\n+                    Count     => 1);\n+   end Delete_First;\n+\n    procedure Delete_First\n      (Container : in out List;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    is\n       N : Node_Array renames Container.Nodes;\n       X : Count_Type;\n@@ -391,9 +365,16 @@ is\n    -- Delete_Last --\n    -----------------\n \n+   procedure Delete_Last (Container : in out List)\n+   is\n+   begin\n+      Delete_Last (Container => Container,\n+                   Count     => 1);\n+   end Delete_Last;\n+\n    procedure Delete_Last\n      (Container : in out List;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    is\n       N : Node_Array renames Container.Nodes;\n       X : Count_Type;\n@@ -503,35 +484,355 @@ is\n       end if;\n    end First_Element;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n \n-   function First_To_Previous\n-     (Container : List;\n-      Current   : Cursor) return List\n-   is\n-      Curs : Cursor := Current;\n-      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n+   package body Formal_Model is\n \n-   begin\n-      if Curs = No_Element then\n-         return C;\n+      ----------------------------\n+      -- Lift_Abstraction_Level --\n+      ----------------------------\n \n-      elsif not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n+      procedure Lift_Abstraction_Level (Container : List) is null;\n \n-      else\n-         while Curs.Node /= 0 loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n+      -------------------------\n+      -- M_Elements_Contains --\n+      -------------------------\n+\n+      function M_Elements_Contains\n+        (S   : M.Sequence;\n+         Fst : Positive_Count_Type;\n+         Lst : Count_Type;\n+         E   : Element_Type)\n+         return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if Element (S, I) = E then\n+               return True;\n+            end if;\n+         end loop;\n+         return False;\n+      end M_Elements_Contains;\n+\n+      --------------------\n+      -- M_Elements_Cst --\n+      --------------------\n+\n+      function M_Elements_Cst\n+        (S   : M.Sequence;\n+         Fst : Positive_Count_Type;\n+         Lst : Count_Type;\n+         E   : Element_Type)\n+         return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if Element (S, I) /= E then\n+               return False;\n+            end if;\n          end loop;\n+         return True;\n+      end M_Elements_Cst;\n \n-         return C;\n-      end if;\n-   end First_To_Previous;\n+      ----------------------\n+      -- M_Elements_Equal --\n+      ----------------------\n+\n+      function M_Elements_Equal\n+        (S1, S2   : M.Sequence;\n+         Fst      : Positive_Count_Type;\n+         Lst      : Count_Type)\n+         return Boolean\n+      is\n+      begin\n+         return M_Elements_Shifted (S1, S2, Fst, Lst, 0);\n+      end M_Elements_Equal;\n+\n+      -------------------------\n+      -- M_Elements_Reversed --\n+      -------------------------\n+\n+      function M_Elements_Reversed (S1, S2 : M.Sequence) return Boolean is\n+         L : constant Count_Type := M.Length (S1);\n+      begin\n+         if L /= M.Length (S2) then\n+            return False;\n+         end if;\n+\n+         for I in 1 .. L loop\n+            if Element (S1, I) /= Element (S2, L - I + 1)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Reversed;\n+\n+      ------------------------\n+      -- M_Elements_Shifted --\n+      ------------------------\n+\n+      function M_Elements_Shifted\n+        (S1, S2   : M.Sequence;\n+         Fst      : Positive_Count_Type;\n+         Lst      : Count_Type;\n+         Offset   : Count_Type'Base := 1)\n+         return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if Element (S1, I) /= Element (S2, I + Offset) then\n+               return False;\n+            end if;\n+         end loop;\n+         return True;\n+      end M_Elements_Shifted;\n+\n+      -------------------------\n+      -- M_Elements_Shuffled --\n+      -------------------------\n+\n+      function M_Elements_Shuffle\n+        (S1, S2   : M.Sequence;\n+         Fst      : Positive_Count_Type;\n+         Lst      : Count_Type;\n+         Offset   : Count_Type'Base)\n+         return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            declare\n+               Found : Boolean := False;\n+               J     : Count_Type := Fst;\n+            begin\n+               while not Found and J <= Lst loop\n+                  if Element (S1, I) = Element (S2, J + Offset) then\n+                     Found := True;\n+                  end if;\n+                  J := J + 1;\n+               end loop;\n+\n+               if not Found then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+         return True;\n+      end M_Elements_Shuffle;\n+\n+      ------------------------\n+      -- M_Elements_Swapted --\n+      ------------------------\n+\n+      function M_Elements_Swapped\n+        (S1, S2 : M.Sequence;\n+         X, Y   : Positive_Count_Type)\n+      return Boolean\n+      is\n+      begin\n+         if M.Length (S1) /= M.Length (S2)\n+           or else Element (S1, X) /= Element (S2, Y)\n+           or else Element (S1, Y) /= Element (S2, X)\n+         then\n+            return False;\n+         end if;\n+\n+         for I in 1 .. M.Length (S1) loop\n+            if I /= X and then I /= Y\n+              and then Element (S1, I) /= Element (S2, I)\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end M_Elements_Swapped;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : List) return M.Sequence is\n+         Position : Count_Type := Container.First;\n+         R        : M.Sequence;\n+      begin\n+         --  Can't use First, Next or Element here, since they depend\n+         --  on models for their postconditions\n+         while Position /= 0 loop\n+            R := M.Add (R, Container.Nodes (Position).Element);\n+            Position := Container.Nodes (Position).Next;\n+         end loop;\n+         return R;\n+      end Model;\n+\n+      -----------------------\n+      -- Mapping_preserved --\n+      -----------------------\n+\n+      function Mapping_Preserved\n+        (S1, S2 : M.Sequence;\n+         M1, M2 : P.Map) return Boolean is\n+\n+      begin\n+         for C of M1 loop\n+            if not P.Mem (M2, C)\n+              or else P.Get (M1, C) > M.Length (S1)\n+              or else P.Get (M2, C) > M.Length (S2)\n+              or else M.Get (S1, P.Get (M1, C)) /= M.Get (S2, P.Get (M2, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for C of M2 loop\n+            if not P.Mem (M1, C) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved;\n+\n+      -------------------------\n+      -- P_Positions_Shifted --\n+      -------------------------\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      is\n+      begin\n+         for Cu of Small loop\n+            if not P.Mem (Big, Cu) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for Cu of Big loop\n+            declare\n+               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+            begin\n+               if Pos < Cut then\n+                  if not P.Mem (Small, Cu) or else Pos /= P.Get (Small, Cu)\n+                  then\n+                     return False;\n+                  end if;\n+               elsif Pos >= Cut + Count then\n+                  if not P.Mem (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu) + Count\n+                  then\n+                     return False;\n+                  end if;\n+               else\n+                  if P.Mem (Small, Cu) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+         return True;\n+      end P_Positions_Shifted;\n+\n+      -------------------------\n+      -- P_Positions_Swapped --\n+      -------------------------\n+\n+      function P_Positions_Swapped\n+        (M1, M2 : P.Map;\n+         C1, C2 : Cursor) return Boolean\n+      is\n+      begin\n+         if not P.Mem (M1, C1) or not P.Mem (M1, C2)\n+           or not P.Mem (M2, C1) or not P.Mem (M2, C2)\n+         then\n+            return False;\n+         end if;\n+\n+         if P.Get (M1, C1) /= P.Get (M2, C2)\n+             or P.Get (M1, C2) /= P.Get (M2, C1)\n+         then\n+            return False;\n+         end if;\n+\n+         for C of M1 loop\n+            if not P.Mem (M2, C) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for C of M2 loop\n+            if not P.Mem (M1, C)\n+              or else (C /= C1 and C /= C2 and P.Get (M1, C) /= P.Get (M2, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end P_Positions_Swapped;\n+\n+      ---------------------------\n+      -- P_Positions_Truncated --\n+      ---------------------------\n+\n+      function P_Positions_Truncated\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      is\n+      begin\n+         for Cu of Small loop\n+            if not P.Mem (Big, Cu) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for Cu of Big loop\n+            declare\n+               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+            begin\n+               if Pos < Cut then\n+                  if not P.Mem (Small, Cu) or else Pos /= P.Get (Small, Cu)\n+                  then\n+                     return False;\n+                  end if;\n+               elsif Pos >= Cut + Count then\n+                  return False;\n+               elsif P.Mem (Small, Cu) then\n+                  return False;\n+               end if;\n+            end;\n+         end loop;\n+         return True;\n+      end P_Positions_Truncated;\n+\n+      ---------------\n+      -- Positions --\n+      ---------------\n+\n+      function Positions (Container : List) return P.Map is\n+         Position : Count_Type := Container.First;\n+         R        : P.Map;\n+         I        : Count_Type := 1;\n+      begin\n+         --  Can't use First, Next or Element here, since they depend\n+         --  on models for their postconditions\n+         while Position /= 0 loop\n+            R := P.Add (R, (Node => Position), I);\n+            pragma Assert (P.Length (R) = I);\n+            Position := Container.Nodes (Position).Next;\n+            I := I + 1;\n+         end loop;\n+         return R;\n+      end Positions;\n+\n+   end Formal_Model;\n \n    ----------\n    -- Free --\n@@ -602,6 +903,33 @@ is\n          return True;\n       end Is_Sorted;\n \n+      -----------------------\n+      -- M_Elements_Sorted --\n+      -----------------------\n+\n+      function M_Elements_Sorted (S : M.Sequence) return Boolean is\n+      begin\n+         if M.Length (S) = 0 then\n+            return True;\n+         end if;\n+\n+         declare\n+            E1 : Element_Type := Element (S, 1);\n+         begin\n+            for I in 2 .. M.Length (S) loop\n+               declare\n+                  E2 : constant Element_Type := Element (S, I);\n+               begin\n+                  if E2 < E1 then\n+                     return False;\n+                  end if;\n+                  E1 := E2;\n+               end;\n+            end loop;\n+         end;\n+         return True;\n+      end M_Elements_Sorted;\n+\n       -----------\n       -- Merge --\n       -----------\n@@ -766,7 +1094,7 @@ is\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    is\n       J : Count_Type;\n \n@@ -798,7 +1126,21 @@ is\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      Position  : out Cursor)\n+   is\n+   begin\n+      Insert (Container => Container,\n+              Before    => Before,\n+              New_Item  => New_Item,\n+              Position  => Position,\n+              Count     => 1);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type)\n    is\n       Position : Cursor;\n    begin\n@@ -808,33 +1150,11 @@ is\n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1)\n+      New_Item  : Element_Type)\n    is\n-      J : Count_Type;\n-\n+      Position : Cursor;\n    begin\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n-      end if;\n-\n-      if Count = 0 then\n-         Position := Before;\n-         return;\n-      end if;\n-\n-      if Container.Length > Container.Capacity - Count then\n-         raise Constraint_Error with \"new length exceeds capacity\";\n-      end if;\n-\n-      Allocate (Container, New_Node => J);\n-      Insert_Internal (Container, Before.Node, New_Node => J);\n-      Position := (Node => J);\n-\n-      for Index in 2 .. Count loop\n-         Allocate (Container, New_Node => J);\n-         Insert_Internal (Container, Before.Node, New_Node => J);\n-      end loop;\n+      Insert (Container, Before, New_Item, Position, 1);\n    end Insert;\n \n    ---------------------\n@@ -1044,10 +1364,18 @@ is\n    -- Prepend --\n    -------------\n \n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, 1);\n+   end Prepend;\n+\n    procedure Prepend\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    is\n    begin\n       Insert (Container, First (Container), New_Item, Count);\n@@ -1377,29 +1705,6 @@ is\n       pragma Assert (N (Container.Last).Next = 0);\n    end Splice;\n \n-   ------------------\n-   -- Strict_Equal --\n-   ------------------\n-\n-   function Strict_Equal (Left, Right : List) return Boolean is\n-      CL : Count_Type := Left.First;\n-      CR : Count_Type := Right.First;\n-\n-   begin\n-      while CL /= 0 or CR /= 0 loop\n-         if CL /= CR or else\n-           Left.Nodes (CL).Element /= Right.Nodes (CL).Element\n-         then\n-            return False;\n-         end if;\n-\n-         CL := Left.Nodes (CL).Next;\n-         CR := Right.Nodes (CR).Next;\n-      end loop;\n-\n-      return True;\n-   end Strict_Equal;\n-\n    ----------\n    -- Swap --\n    ----------"}, {"sha": "62cdf52028e0cf8f402b86af6a6b6862ac306353", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 1177, "deletions": 139, "changes": 1316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -29,43 +29,14 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  This spec is derived from Ada.Containers.Bounded_Doubly_Linked_Lists in the\n---  Ada 2012 RM. The modifications are meant to facilitate formal proofs by\n---  making it easier to express properties, and by making the specification of\n---  this unit compatible with SPARK 2014. Note that the API of this unit may be\n---  subject to incompatible changes as SPARK 2014 evolves.\n-\n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    contents of a container: Next, Previous, Query_Element, Has_Element,\n---    Iterate, Reverse_Iterate, Element. This change is motivated by the need\n---    to have cursors which are valid on different containers (typically a\n---    container C and its previous version C'Old) for expressing properties,\n---    which is not possible if cursors encapsulate an access to the underlying\n---    container.\n-\n---    There are three new functions:\n-\n---      function Strict_Equal (Left, Right : List) return Boolean;\n---      function First_To_Previous  (Container : List; Current : Cursor)\n---         return List;\n---      function Current_To_Last (Container : List; Current : Cursor)\n---         return List;\n-\n---    See subprogram specifications that follow for details\n+with Ada.Containers.Functional_Vectors;\n+with Ada.Containers.Functional_Maps;\n \n generic\n    type Element_Type is private;\n-\n-   with function \"=\" (Left, Right : Element_Type)\n-                      return Boolean is <>;\n-\n package Ada.Containers.Formal_Doubly_Linked_Lists with\n-  Pure,\n   SPARK_Mode\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    type List (Capacity : Count_Type) is private with\n@@ -76,269 +47,1342 @@ is\n      Default_Initial_Condition => Is_Empty (List);\n    pragma Preelaborable_Initialization (List);\n \n-   type Cursor is private;\n-   pragma Preelaborable_Initialization (Cursor);\n+   type Cursor is record\n+      Node : Count_Type := 0;\n+   end record;\n+\n+   No_Element : constant Cursor := Cursor'(Node => 0);\n \n    Empty_List : constant List;\n \n-   No_Element : constant Cursor;\n+   function Length (Container : List) return Count_Type with\n+     Global => null,\n+     Post   => Length'Result <= Container.Capacity;\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+      package M is new Ada.Containers.Functional_Vectors\n+        (Index_Type   => Positive_Count_Type,\n+         Element_Type => Element_Type);\n+      function \"=\" (Left, Right : M.Sequence) return Boolean renames M.\"=\";\n+      function \"<\" (Left, Right : M.Sequence) return Boolean renames M.\"<\";\n+      function \"<=\" (Left, Right : M.Sequence) return Boolean renames M.\"<=\";\n+\n+      function M_Elements_Contains\n+        (S   : M.Sequence;\n+         Fst : Positive_Count_Type;\n+         Lst : Count_Type;\n+         E   : Element_Type)\n+      return Boolean\n+      --  E appears in the slice from Fst to Lst in S\n+      with\n+        Global => null,\n+        Pre    => Lst <= M.Length (S),\n+        Post   =>\n+          M_Elements_Contains'Result =\n+            (for some I in Fst .. Lst => Element (S, I) = E);\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Contains);\n+\n+      function M_Elements_Cst\n+        (S   : M.Sequence;\n+         Fst : Positive_Count_Type;\n+         Lst : Count_Type;\n+         E   : Element_Type)\n+      return Boolean\n+      --  Every element of the slice from Fst to Lst in S is E.\n+      with\n+        Global => null,\n+        Pre    => Lst <= M.Length (S),\n+        Post   =>\n+          M_Elements_Cst'Result =\n+            (for all I in Fst .. Lst => Element (S, I) = E);\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Cst);\n+\n+      function M_Elements_Equal\n+        (S1, S2 : M.Sequence;\n+         Fst    : Positive_Count_Type;\n+         Lst    : Count_Type)\n+      return Boolean\n+      --  The slice from Fst to Lst is the same in S1 and S2\n+      with\n+        Global => null,\n+        Pre    => Lst <= M.Length (S1) and Lst <= M.Length (S2),\n+        Post   =>\n+          M_Elements_Equal'Result =\n+            (for all I in Fst .. Lst => Element (S1, I) = Element (S2, I));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Equal);\n+\n+      function M_Elements_Shuffle\n+        (S1, S2 : M.Sequence;\n+         Fst    : Positive_Count_Type;\n+         Lst    : Count_Type;\n+         Offset : Count_Type'Base)\n+      return Boolean\n+      --  The slice from Fst to Lst in S1 contains the same elements than the\n+      --  same slide shifted by Offset in S2\n+      with\n+        Global => null,\n+        Pre    =>\n+          Lst <= M.Length (S1)\n+            and Offset in 1 - Fst .. M.Length (S2) - Lst,\n+        Post   =>\n+          M_Elements_Shuffle'Result =\n+          (for all J in Fst + Offset .. Lst + Offset =>\n+             (for some I in Fst .. Lst =>\n+                    Element (S1, I) = Element (S2, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Shuffle);\n+\n+      function M_Elements_Reversed (S1, S2 : M.Sequence) return Boolean\n+      --  S2 is S1 in reverse order\n+      with\n+        Global => null,\n+        Post   =>\n+          M_Elements_Reversed'Result =\n+              (M.Length (S1) = M.Length (S2)\n+               and (for all I in 1 .. M.Length (S1) =>\n+                   Element (S1, I) = Element (S2, M.Length (S1) - I + 1))\n+               and (for all I in 1 .. M.Length (S1) =>\n+                   Element (S2, I) = Element (S1, M.Length (S1) - I + 1)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n+\n+      function M_Elements_Shifted\n+        (S1, S2   : M.Sequence;\n+         Fst      : Positive_Count_Type;\n+         Lst      : Count_Type;\n+         Offset   : Count_Type'Base := 1)\n+      return Boolean\n+      --  The slice from Fst to Lst in S1 has been shifted by Offset in S2.\n+      with\n+          Global => null,\n+        Pre    =>\n+          Lst <= M.Length (S1)\n+            and Offset in 1 - Fst .. M.Length (S2) - Lst,\n+        Post   =>\n+          M_Elements_Shifted'Result =\n+            ((for all I in Fst .. Lst =>\n+                      Element (S1, I) = Element (S2, I + Offset))\n+             and (for all I in Fst + Offset .. Lst + Offset =>\n+                          Element (S1, I - Offset) = Element (S2, I)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Shifted);\n+\n+      function M_Elements_Swapped\n+        (S1, S2 : M.Sequence;\n+         X, Y   : Positive_Count_Type)\n+      return Boolean\n+      --  Elements stored at X and Y are reversed in S1 and S2\n+      with\n+        Global => null,\n+        Pre    => X <= M.Length (S1) and Y <= M.Length (S1),\n+        Post   =>\n+          M_Elements_Swapped'Result =\n+            (M.Length (S1) = M.Length (S2)\n+             and Element (S1, X) = Element (S2, Y)\n+             and Element (S1, Y) = Element (S2, X)\n+             and\n+               (for all I in 1 .. M.Length (S1) =>\n+                 (if I /= X and I /= Y\n+                    then Element (S1, I) = Element (S2, I))));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n+\n+      package P is new Ada.Containers.Functional_Maps\n+        (Key_Type        => Cursor,\n+         Element_Type    => Positive_Count_Type,\n+         Equivalent_Keys => \"=\");\n+      function \"=\" (Left, Right : P.Map) return Boolean renames P.\"=\";\n+      function \"<=\" (Left, Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      with\n+        Global => null,\n+        Post   =>\n+          P_Positions_Shifted'Result =\n+\n+         --  Big contains all cursors of Small\n+        ((for all I of Small => P.Mem (Big, I))\n+\n+         --  Cursors located before Cut are not moved, cursors located after\n+         --  are shifted by Count.\n+         and\n+           (for all I of Small =>\n+                  (if P.Get (Small, I) < Cut\n+                   then P.Get (Big, I) = P.Get (Small, I)\n+                   else P.Get (Big, I) - Count = P.Get (Small, I)))\n+\n+         --  New cursors of Big (if any) are between Cut and Cut - 1 + Count\n+         and\n+           (for all I of Big =>\n+                 P.Mem (Small, I)\n+              or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n+\n+      function P_Positions_Swapped\n+        (M1, M2 : P.Map;\n+         C1, C2 : Cursor) return Boolean\n+      --  M1 and M2 contain the same cursors, but the positions of C1 and C2\n+      --  are reversed.\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          P_Positions_Swapped'Result =\n+              ((for all C of M1 => P.Mem (M2, C))\n+               and (for all C of M2 => P.Mem (M1, C))\n+               and\n+                 (for all C of M1 =>\n+                    (if C /= C1 and C /= C2\n+                     then P.Get (M1, C) = P.Get (M2, C)))\n+               and P.Mem (M1, C1) and P.Mem (M1, C2)\n+               and P.Get (M1, C1) = P.Get (M2, C2)\n+               and P.Get (M1, C2) = P.Get (M2, C1));\n+\n+      function P_Positions_Truncated\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          P_Positions_Truncated'Result =\n+\n+         --  Big contains all cursors of Small\n+        ((for all I of Small => P.Mem (Big, I))\n+\n+         --  The cursors of Small are all bellow Cut\n+         and (for all I of Small => P.Get (Small, I) < Cut)\n+\n+         --  The cursors have the same position in Big and Small\n+         and (for all I of Small => P.Get (Big, I) = P.Get (Small, I))\n+\n+         --  New cursors of Big (if any) are between Cut and Cut - 1 + Count\n+         and\n+           (for all I of Big =>\n+                P.Mem (Small, I)\n+             or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n+\n+      function Mapping_Preserved\n+        (S1, S2 : M.Sequence;\n+         M1, M2 : P.Map) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+            (if Mapping_Preserved'Result then\n+\n+            --  M1 contains all cursors of M2\n+            (for all I of M2 => P.Mem (M1, I))\n+\n+            --  M2 contains all cursors of M1\n+            and (for all I of M1 => P.Mem (M2, I))\n+\n+            --  Mappings from cursors to elements induced by S1, M1 and S2, M2\n+            --  are the same.\n+            and (for all I of M1 =>\n+                       M.Get (S1, P.Get (M1, I)) = M.Get (S2, P.Get (M2, I))));\n+\n+      function Model (Container : List) return M.Sequence with\n+      --  The highlevel model of a list is a sequence of elements. Cursors are\n+      --  not represented in this model.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => M.Length (Model'Result) = Length (Container);\n+      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Model);\n+\n+      function Positions (Container : List) return P.Map with\n+      --  The Positions map is used to model cursors. It only contains valid\n+      --  cursors and map them to their position in the container.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => not P.Mem (Positions'Result, No_Element)\n+        --  Positions of cursors are smaller than the container's length.\n+        and then\n+          (for all I of Positions'Result =>\n+             P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+               --  No two cursors have the same position. Note that we do not\n+           --  state that there is a cursor in the map for each position,\n+           --  as it is rarely needed.\n+           and then\n+             (for all J of Positions'Result =>\n+                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n+                     then I = J)));\n+\n+      procedure Lift_Abstraction_Level (Container : List) with\n+        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n+        --  assume that we can access to the same elements by iterating over\n+        --  positions or cursors.\n+        --  This information is not generally useful except when switching from\n+        --  a lowlevel, cursor aware view of a container, to a highlevel\n+        --  position based view.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+            (for all Elt of Model (Container) =>\n+               (for some I of Positions (Container) =>\n+                    M.Get (Model (Container), P.Get (Positions (Container), I))\n+                    = Elt));\n+\n+      function Element (S : M.Sequence; I : Count_Type) return Element_Type\n+                     renames M.Get;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  access an element in the model to Element.\n+   end Formal_Model;\n+   use Formal_Model;\n \n    function \"=\" (Left, Right : List) return Boolean with\n-     Global => null;\n-\n-   function Length (Container : List) return Count_Type with\n-     Global => null;\n+     Global => null,\n+     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n \n    function Is_Empty (Container : List) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out List) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0;\n \n    procedure Assign (Target : in out List; Source : List) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   => Model (Target) = Model (Source);\n \n    function Copy (Source : List; Capacity : Count_Type := 0) return List with\n      Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n+     Post   => Model (Copy'Result) = Model (Source)\n+     and Positions (Copy'Result) = Positions (Source)\n+     and (if Capacity = 0 then Copy'Result.Capacity = Source.Capacity\n+          else Copy'Result.Capacity = Capacity);\n \n    function Element\n      (Container : List;\n       Position : Cursor) return Element_Type\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Element'Result =\n+         Element (Model (Container),\n+                  P.Get (Positions (Container), Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out List;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   => Length (Container) = Length (Container)'Old\n+\n+     --  Cursors are preserved.\n+     and Positions (Container)'Old = Positions (Container)\n+\n+     --  The element at the position of Position in Container is replaced by\n+     --  New_Item.\n+     and M.Is_Set (Model (Container)'Old,\n+                   P.Get (Positions (Container), Position),\n+                   New_Item,\n+                   Model (Container));\n \n    procedure Move (Target : in out List; Source : in out List) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   => Model (Target) = Model (Source'Old)\n+     and Length (Source) = 0;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+         Length (Container) < Container.Capacity\n+       and then (Has_Element (Container, Before)\n+                 or else Before = No_Element),\n+     Post           => Length (Container) = Length (Container)'Old + 1,\n+     Contract_Cases =>\n+       (Before = No_Element =>\n+\n+          --  Positions contains a new mapping from the last cursor of\n+          --  Container to its length.\n+          P.Is_Add\n+            (Positions (Container)'Old, Last (Container), Length (Container),\n+             Result => Positions (Container))\n+\n+          --  Model contains a new element New_Item at the end\n+          and M.Is_Add (Model (Container)'Old, New_Item, Model (Container)),\n+        others              =>\n+\n+          --  The elements of Container located before Before are preserved.\n+          M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container)'Old, Before) - 1)\n+\n+          --  Other elements are shifted by 1.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container)'Old, Before),\n+             Lst    => Length (Container)'Old,\n+             Offset => 1)\n+\n+          --  New_Item is stored at the previous position of Before in\n+          --  Container\n+          and Element\n+            (Model (Container), P.Get (Positions (Container)'Old, Before))\n+               = New_Item\n+\n+          --  A new cursor has been inserted at position Before in Container\n+          and P_Positions_Shifted\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut => P.Get (Positions (Container)'Old, Before)));\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    with\n      Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n+       Pre    =>\n+         Length (Container) <= Container.Capacity - Count\n+       and then (Has_Element (Container, Before)\n+                 or else Before = No_Element),\n+     Post           => Length (Container) = Length (Container)'Old + Count,\n+     Contract_Cases =>\n+       (Before = No_Element =>\n+\n+          --  The elements of Container are preserved\n+          M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => Length (Container)'Old)\n+\n+          --  Container contains Count times New_Item at the end\n+          and M_Elements_Cst\n+            (S   => Model (Container),\n+             Fst => Length (Container)'Old + 1,\n+             Lst => Length (Container),\n+             E   => New_Item)\n+\n+          --  A Count cursors have been inserted at the end of Container\n+          and P_Positions_Truncated\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut   => Length (Container)'Old + 1,\n+             Count => Count),\n+        others              =>\n+\n+          --  The elements of Container located before Before are preserved\n+          M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container)'Old, Before) - 1)\n+\n+          --  Other elements are shifted by Count.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container)'Old, Before),\n+             Lst    => Length (Container)'Old,\n+             Offset => Count)\n+\n+          --  Container contains Count times New_Item after position Before\n+          and M_Elements_Cst\n+            (S   => Model (Container),\n+             Fst => P.Get (Positions (Container)'Old, Before),\n+             Lst => P.Get (Positions (Container)'Old, Before) - 1 + Count,\n+             E   => New_Item)\n+\n+          --  Count cursors have been inserted at position Before in Container\n+          and P_Positions_Shifted\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut   => P.Get (Positions (Container)'Old, Before),\n+             Count => Count));\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type := 1)\n+      Position  : out Cursor)\n    with\n      Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n+     Pre    =>\n+         Length (Container) < Container.Capacity\n+       and then (Has_Element (Container, Before)\n+                 or else Before = No_Element),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+          --  Positions is valid in Container and it is located either before\n+          --  Before if it is valid in Container or at the end if it is\n+          --  No_Element.\n+          and P.Mem (Positions (Container), Position)\n+          and (if Before = No_Element\n+               then P.Get (Positions (Container), Position)\n+                  = Length (Container)\n+               else P.Get (Positions (Container), Position)\n+                  = P.Get (Positions (Container)'Old, Before))\n+\n+          --  The elements of Container located before Position are preserved.\n+          and M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container), Position) - 1)\n+\n+          --  Other elements are shifted by 1.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container), Position),\n+             Lst    => Length (Container)'Old,\n+             Offset => 1)\n+\n+          --  New_Item is stored at Position in Container\n+          and Element\n+            (Model (Container), P.Get (Positions (Container), Position))\n+               = New_Item\n+\n+          --  A new cursor has been inserted at position Position in Container\n+          and P_Positions_Shifted\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut => P.Get (Positions (Container), Position));\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n+      New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            =>\n+         Length (Container) <= Container.Capacity - Count\n+       and then (Has_Element (Container, Before)\n+                 or else Before = No_Element),\n+     Post           => Length (Container) = Length (Container)'Old + Count,\n+     Contract_Cases =>\n+       (Count = 0 => Position = Before\n+          and Model (Container) = Model (Container)'Old\n+          and Positions (Container) = Positions (Container)'Old,\n+\n+        others    =>\n+          --  Positions is valid in Container and it is located either before\n+          --  Before if it is valid in Container or at the end if it is\n+          --  No_Element.\n+          P.Mem (Positions (Container), Position)\n+          and (if Before = No_Element\n+               then P.Get (Positions (Container), Position)\n+                  = Length (Container)'Old + 1\n+               else P.Get (Positions (Container), Position)\n+                  = P.Get (Positions (Container)'Old, Before))\n+\n+          --  The elements of Container located before Position are preserved.\n+          and M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container), Position) - 1)\n+\n+          --  Other elements are shifted by Count.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container), Position),\n+             Lst    => Length (Container)'Old,\n+             Offset => Count)\n+\n+          --  Container contains Count times New_Item after position Position\n+          and M_Elements_Cst\n+            (S   => Model (Container),\n+             Fst => P.Get (Positions (Container), Position),\n+             Lst => P.Get (Positions (Container), Position) - 1 + Count,\n+             E   => New_Item)\n+\n+          --  Count cursor have been inserted at Position in Container\n+          and P_Positions_Shifted\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut   => P.Get (Positions (Container), Position),\n+             Count => Count));\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element);\n+     Pre    => Length (Container) < Container.Capacity,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+\n+          --  Elements are shifted by 1\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => 1,\n+             Lst    => Length (Container)'Old,\n+             Offset => 1)\n+\n+          --  New_Item is the first element of Container\n+          and Element (Model (Container), 1) = New_Item\n+\n+          --  A new cursor has been inserted at the beginning of Container\n+          and P_Positions_Shifted\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut => 1);\n \n    procedure Prepend\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Container.Capacity - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+          --  Elements are shifted by Count.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => 1,\n+             Lst    => Length (Container)'Old,\n+             Offset => Count)\n+\n+          --  Container starts with Count times New_Item\n+          and M_Elements_Cst\n+            (S   => Model (Container),\n+             Fst => 1,\n+             Lst => Count,\n+             E   => New_Item)\n+\n+          --  Count cursors have been inserted at the beginning of Container\n+          and P_Positions_Shifted\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut   => 1,\n+             Count => Count);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity;\n+     Pre    => Length (Container) < Container.Capacity,\n+     Post   => Length (Container) = Length (Container)'Old + 1\n+\n+          --  Positions contains a new mapping from the last cursor of\n+          --  Container to its length.\n+          and P.Is_Add\n+            (Positions (Container)'Old, Last (Container), Length (Container),\n+             Result => Positions (Container))\n+\n+          --  Model contains a new element New_Item at the end\n+          and M.Is_Add (Model (Container)'Old, New_Item, Model (Container));\n \n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n+   with\n+     Global => null,\n+     Pre    => Length (Container) <= Container.Capacity - Count,\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + Count\n+\n+          --  The elements of Container are preserved\n+          and Model (Container)'Old <= Model (Container)\n+\n+          --  Container contains Count times New_Item at the end\n+          and M_Elements_Cst\n+            (S   => Model (Container),\n+             Fst => Length (Container)'Old + 1,\n+             Lst => Length (Container),\n+             E   => New_Item)\n+\n+          --  Count cursors have been inserted at the end of Container\n+          and P_Positions_Truncated\n+            (Positions (Container)'Old,\n+             Positions (Container),\n+             Cut   => Length (Container)'Old + 1,\n+             Count => Count);\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor)\n    with\n      Global => null,\n-     Pre    => Length (Container) + Count <= Container.Capacity;\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+          --  Position is set to No_Element\n+          and Position = No_Element\n+\n+          --  The elements of Container located before Position are preserved.\n+          and M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+\n+          --  The elements located after Position are shifted by 1\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container)'Old, Position'Old) + 1,\n+             Lst    => Length (Container)'Old,\n+             Offset => -1)\n+\n+          --  Position has been removed from Container\n+          and P_Positions_Shifted\n+            (Positions (Container),\n+             Positions (Container)'Old,\n+             Cut   => P.Get (Positions (Container)'Old, Position'Old));\n \n    procedure Delete\n      (Container : in out List;\n       Position  : in out Cursor;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Pre            => Has_Element (Container, Position),\n+     Post           =>\n+          Length (Container) in Length (Container)'Old - Count\n+                                        .. Length (Container)'Old\n+\n+          --  Position is set to No_Element\n+          and Position = No_Element\n+\n+          --  The elements of Container located before Position are preserved.\n+          and M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container)'Old, Position'Old) - 1),\n+     Contract_Cases =>\n+\n+       --  All the elements after Position have been erased\n+       (Length (Container) - Count < P.Get (Positions (Container), Position)\n+        =>\n+\n+          Length (Container) =\n+            P.Get (Positions (Container)'Old, Position'Old) - 1\n+\n+          --  At most Count cursors have been removed at the end of Container\n+          and P_Positions_Truncated\n+            (Positions (Container),\n+             Positions (Container)'Old,\n+             Cut   => P.Get (Positions (Container)'Old, Position'Old),\n+             Count => Count),\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+          --  Other elements are shifted by Count\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    =>\n+               P.Get (Positions (Container)'Old, Position'Old) + Count,\n+             Lst    => Length (Container)'Old,\n+             Offset => -Count)\n+\n+          --  Count cursors have been removed from Container at Position\n+          and P_Positions_Shifted\n+            (Positions (Container),\n+             Positions (Container)'Old,\n+             Cut   => P.Get (Positions (Container)'Old, Position'Old),\n+             Count => Count));\n+\n+   procedure Delete_First (Container : in out List)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+          --  The elements of Container are shifted by 1\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => 2,\n+             Lst    => Length (Container)'Old,\n+             Offset => -1)\n+\n+          --  The first cursor of Container has been removed\n+          and P_Positions_Shifted\n+            (Positions (Container),\n+             Positions (Container)'Old,\n+             Cut   => 1);\n \n    procedure Delete_First\n      (Container : in out List;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n+   with\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  All the elements of Container have been erased\n+       (Length (Container) <= Count => Length (Container) = 0,\n+        others =>\n+          Length (Container) = Length (Container)'Old - Count\n+\n+          --  Elements of Container are shifted by Count\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => Count + 1,\n+             Lst    => Length (Container)'Old,\n+             Offset => -Count)\n+\n+          --  The first Count cursors have been removed from Container\n+          and P_Positions_Shifted\n+            (Positions (Container),\n+             Positions (Container)'Old,\n+             Cut   => 1,\n+             Count => Count));\n+\n+   procedure Delete_Last (Container : in out List)\n    with\n-     Global => null;\n+     Global => null,\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+          --  The elements of Container are preserved.\n+          and Model (Container) <= Model (Container)'Old\n+\n+          --  The last cursor of Container has been removed\n+          and P.Is_Add (Positions (Container), Last (Container)'Old,\n+                        Length (Container)'Old, Positions (Container)'Old);\n \n    procedure Delete_Last\n      (Container : in out List;\n-      Count     : Count_Type := 1)\n+      Count     : Count_Type)\n    with\n-     Global => null;\n+     Global => null,\n+     Contract_Cases =>\n+\n+       --  All the elements of Container have been erased\n+       (Length (Container) <= Count => Length (Container) = 0,\n+        others =>\n+\n+          Length (Container) = Length (Container)'Old - Count\n+\n+          --  The elements of Container are preserved.\n+          and Model (Container) <= Model (Container)'Old\n+\n+          --  At most Count cursors have been removed at the end of Container\n+          and P_Positions_Truncated\n+            (Positions (Container),\n+             Positions (Container)'Old,\n+             Cut   => Length (Container) + 1,\n+             Count => Count));\n \n    procedure Reverse_Elements (Container : in out List) with\n-     Global => null;\n+     Global => null,\n+     Post   => M_Elements_Reversed (Model (Container'Old), Model (Container));\n \n    procedure Swap\n      (Container : in out List;\n       I, J      : Cursor)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J);\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n+     Post   =>\n+       M_Elements_Swapped\n+         (Model (Container)'Old, Model (Container),\n+          X => P.Get (Positions (Container)'Old, I),\n+          Y => P.Get (Positions (Container)'Old, J))\n+       and Positions (Container) = Positions (Container)'Old;\n \n    procedure Swap_Links\n      (Container : in out List;\n       I, J      : Cursor)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J);\n+     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n+     Post   =>\n+       M_Elements_Swapped\n+         (Model (Container'Old), Model (Container),\n+          X => P.Get (Positions (Container)'Old, I),\n+          Y => P.Get (Positions (Container)'Old, J))\n+       and P_Positions_Swapped\n+       (Positions (Container)'Old, Positions (Container), I, J);\n \n    procedure Splice\n      (Target : in out List;\n       Before : Cursor;\n       Source : in out List)\n+   --  Target and Source should not be aliased\n    with\n-     Global => null,\n-     Pre    => Length (Source) + Length (Target) <= Target.Capacity\n-                 and then (Has_Element (Target, Before)\n-                            or else Before = No_Element);\n+     Global         => null,\n+     Pre            =>\n+         Length (Source) <= Target.Capacity - Length (Target)\n+         and then (Has_Element (Target, Before)\n+                   or else Before = No_Element),\n+     Post           =>\n+       Length (Source) = 0\n+           and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n+     Contract_Cases =>\n+       (Before = No_Element =>\n+\n+          --  The elements of Target are preserved\n+          M_Elements_Equal\n+            (S1  => Model (Target)'Old,\n+             S2  => Model (Target),\n+             Fst => 1,\n+             Lst => Length (Target)'Old)\n+\n+          --  The elements of Source are appended to target, the order is not\n+          --  specified.\n+          and M_Elements_Shuffle\n+            (S1     => Model (Source)'Old,\n+             S2     => Model (Target),\n+             Fst    => 1,\n+             Lst    => Length (Source)'Old,\n+             Offset => Length (Target)'Old)\n+\n+          --  Cursors have been inserted at the end of Target\n+          and P_Positions_Truncated\n+            (Positions (Target)'Old,\n+             Positions (Target),\n+             Cut   => Length (Target)'Old + 1,\n+             Count => Length (Source)'Old),\n+        others              =>\n+\n+          --  The elements of Target located before Before are preserved\n+          M_Elements_Equal\n+            (S1  => Model (Target)'Old,\n+             S2  => Model (Target),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Target)'Old, Before) - 1)\n+\n+          --  The elements of Source are inserted before Before, the order is\n+          --  not specified.\n+          and M_Elements_Shuffle\n+            (S1     => Model (Source)'Old,\n+             S2     => Model (Target),\n+             Fst    => 1,\n+             Lst    => Length (Source)'Old,\n+             Offset => P.Get (Positions (Target)'Old, Before) - 1)\n+\n+          --  Other elements are shifted by the length of Source\n+          and M_Elements_Shifted\n+            (S1     => Model (Target)'Old,\n+             S2     => Model (Target),\n+             Fst    => P.Get (Positions (Target)'Old, Before),\n+             Lst    => Length (Target)'Old,\n+             Offset => Length (Source)'Old)\n+\n+          --  Cursors have been inserted at position Before in Target\n+          and P_Positions_Shifted\n+            (Positions (Target)'Old,\n+             Positions (Target),\n+             Cut   => P.Get (Positions (Target)'Old, Before),\n+             Count => Length (Source)'Old));\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n       Position : in out Cursor)\n+   --  Target and Source should not be aliased\n    with\n      Global => null,\n-     Pre    => Length (Source) + Length (Target) <= Target.Capacity\n-                 and then (Has_Element (Target, Before)\n-                            or else Before = No_Element)\n-                 and then Has_Element (Source, Position);\n+     Pre    =>\n+         (Has_Element (Target, Before)\n+          or else Before = No_Element)\n+          and then Has_Element (Source, Position)\n+          and then Length (Target) < Target.Capacity,\n+     Post   =>\n+          Length (Target) = Length (Target)'Old + 1\n+          and Length (Source) = Length (Source)'Old - 1\n+\n+          --  The elements of Source located before Position are preserved.\n+          and M_Elements_Equal\n+            (S1  => Model (Source)'Old,\n+             S2  => Model (Source),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Source)'Old, Position'Old) - 1)\n+\n+          --  The elements located after Position are shifted by 1\n+          and M_Elements_Shifted\n+            (S1     => Model (Source)'Old,\n+             S2     => Model (Source),\n+             Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n+             Lst    => Length (Source)'Old,\n+             Offset => -1)\n+\n+          --  Position has been removed from Source\n+          and P_Positions_Shifted\n+            (Positions (Source),\n+             Positions (Source)'Old,\n+             Cut   => P.Get (Positions (Source)'Old, Position'Old))\n+\n+          --  Positions is valid in Target and it is located either before\n+          --  Before if it is valid in Target or at the end if it is\n+          --  No_Element.\n+          and P.Mem (Positions (Target), Position)\n+          and (if Before = No_Element\n+               then P.Get (Positions (Target), Position)\n+                  = Length (Target)\n+               else P.Get (Positions (Target), Position)\n+                  = P.Get (Positions (Target)'Old, Before))\n+\n+          --  The elements of Target located before Position are preserved.\n+          and M_Elements_Equal\n+            (S1  => Model (Target)'Old,\n+             S2  => Model (Target),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Target), Position) - 1)\n+\n+          --  Other elements are shifted by 1.\n+          and M_Elements_Shifted\n+            (S1     => Model (Target)'Old,\n+             S2     => Model (Target),\n+             Fst    => P.Get (Positions (Target), Position),\n+             Lst    => Length (Target)'Old,\n+             Offset => 1)\n+\n+          --  The element located at Position in Source is moved to Target\n+          and Element (Model (Target), P.Get (Positions (Target), Position))\n+            = Element (Model (Source)'Old,\n+                       P.Get (Positions (Source)'Old, Position'Old))\n+\n+          --  A new cursor has been inserted at position Position in Target\n+          and P_Positions_Shifted\n+            (Positions (Target)'Old,\n+             Positions (Target),\n+             Cut => P.Get (Positions (Target), Position));\n \n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : Cursor)\n    with\n-     Global => null,\n-     Pre    => 2 * Length (Container) <= Container.Capacity\n-                 and then (Has_Element (Container, Before)\n-                            or else Before = No_Element)\n-                 and then Has_Element (Container, Position);\n+     Global         => null,\n+     Pre            =>\n+         (Has_Element (Container, Before) or else Before = No_Element)\n+         and then Has_Element (Container, Position),\n+     Post           => Length (Container) = Length (Container)'Old,\n+     Contract_Cases =>\n+       (Before = Position   =>\n+          Model (Container) = Model (Container)'Old\n+        and Positions (Container) = Positions (Container)'Old,\n+\n+        Before = No_Element =>\n+\n+          --  The elements located before Position are preserved\n+          M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => P.Get (Positions (Container)'Old, Position) - 1)\n+\n+          --  The elements located after Position are shifted by 1\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n+             Lst    => Length (Container)'Old,\n+             Offset => -1)\n+\n+          --  The last element of Container is the one that was previously\n+          --  at Position.\n+          and Element (Model (Container), Length (Container))\n+            = Element (Model (Container)'Old,\n+                       P.Get (Positions (Container)'Old, Position))\n+\n+          --  Cursors from Container continue designating the same elements\n+          and Mapping_Preserved\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             M1     => Positions (Container)'Old,\n+             M2     => Positions (Container)),\n+\n+        others              =>\n+\n+          --  The elements located before Position and Before are preserved\n+          M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => 1,\n+             Lst => Count_Type'Min\n+                      (P.Get (Positions (Container)'Old, Position) - 1,\n+                       P.Get (Positions (Container)'Old, Before) - 1))\n+\n+          --  The elements located after Position and Before are preserved\n+          and M_Elements_Equal\n+            (S1  => Model (Container)'Old,\n+             S2  => Model (Container),\n+             Fst => Count_Type'Max\n+                      (P.Get (Positions (Container)'Old, Position) + 1,\n+                       P.Get (Positions (Container)'Old, Before) + 1),\n+             Lst => Length (Container))\n+\n+          --  The elements located after Before and before Position are shifted\n+          --  by 1 to the right.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n+             Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n+             Offset => 1)\n+\n+          --  The elements located after Position and before Before are shifted\n+          --  by 1 to the left.\n+          and M_Elements_Shifted\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n+             Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n+             Offset => -1)\n+\n+          --  The element previously at Position is now before Before\n+          and Element (Model (Container),\n+                       P.Get (Positions (Container)'Old, Before))\n+            = Element (Model (Container)'Old,\n+                       P.Get (Positions (Container)'Old, Position))\n+\n+          --  Cursors from Container continue designating the same elements\n+          and Mapping_Preserved\n+            (S1     => Model (Container)'Old,\n+             S2     => Model (Container),\n+             M1     => Positions (Container)'Old,\n+             M2     => Positions (Container)));\n \n    function First (Container : List) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 => First'Result = No_Element,\n+        others            => Has_Element (Container, First'Result)\n+        and  P.Get (Positions (Container), First'Result) = 1);\n \n    function First_Element (Container : List) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   => First_Element'Result = M.Get (Model (Container), 1);\n \n    function Last (Container : List) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 => Last'Result = No_Element,\n+        others            => Has_Element (Container, Last'Result)\n+        and P.Get (Positions (Container), Last'Result) = Length (Container));\n \n    function Last_Element (Container : List) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   => Last_Element'Result\n+             = M.Get (Model (Container), Length (Container));\n \n    function Next (Container : List; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            => Has_Element (Container, Position)\n+        or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+        or else P.Get (Positions (Container), Position) = Length (Container) =>\n+              Next'Result = No_Element,\n+        others => Has_Element (Container, Next'Result)\n+        and then P.Get (Positions (Container), Next'Result) =\n+          P.Get (Positions (Container), Position) + 1);\n \n    procedure Next (Container : List; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            => Has_Element (Container, Position)\n+        or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+        or else P.Get (Positions (Container), Position) = Length (Container) =>\n+              Position = No_Element,\n+        others => Has_Element (Container, Position)\n+        and then P.Get (Positions (Container), Position) =\n+          P.Get (Positions (Container), Position'Old) + 1);\n \n    function Previous (Container : List; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            => Has_Element (Container, Position)\n+        or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+        or else P.Get (Positions (Container), Position) = 1 =>\n+          Previous'Result = No_Element,\n+        others =>\n+          Has_Element (Container, Previous'Result)\n+        and then P.Get (Positions (Container), Previous'Result) =\n+          P.Get (Positions (Container), Position) - 1);\n \n    procedure Previous (Container : List; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            => Has_Element (Container, Position)\n+        or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+        or else P.Get (Positions (Container), Position) = 1 =>\n+          Position = No_Element,\n+        others =>\n+          Has_Element (Container, Position)\n+        and then P.Get (Positions (Container), Position) =\n+          P.Get (Positions (Container), Position'Old) - 1);\n \n    function Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n    with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+         Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+\n+       --  If Item is not is not contained in Container after Position, Find\n+       --  returns No_Element.\n+       (not M_Elements_Contains\n+          (S   => Model (Container),\n+           Fst => (if Position = No_Element then 1\n+                   else P.Get (Positions (Container), Position)),\n+           Lst => Length (Container),\n+           E   => Item)\n+        =>\n+          Find'Result = No_Element,\n+\n+        --  Otherwise, Find returns a valid cusror in Container\n+        others =>\n+          P.Mem (Positions (Container), Find'Result)\n+\n+        --  The element designated by the result of Find is Item\n+        and Element (Model (Container),\n+                     P.Get (Positions (Container), Find'Result)) = Item\n+\n+        --  The result of Find is located after Position\n+        and (if Position /= No_Element\n+             then P.Get (Positions (Container), Find'Result)\n+               >= P.Get (Positions (Container), Position))\n+\n+        --  It is the first occurence of Item in this slice\n+        and not M_Elements_Contains\n+          (S   => Model (Container),\n+           Fst => (if Position = No_Element then 1\n+                   else P.Get (Positions (Container), Position)),\n+           Lst => P.Get (Positions (Container), Find'Result) - 1,\n+           E   => Item));\n \n    function Reverse_Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n    with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+         Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+\n+       --  If Item is not is not contained in Container before Position, Find\n+       --  returns No_Element.\n+       (not M_Elements_Contains\n+          (S   => Model (Container),\n+           Fst => 1,\n+           Lst => (if Position = No_Element then Length (Container)\n+                   else P.Get (Positions (Container), Position)),\n+           E   => Item)\n+        =>\n+          Reverse_Find'Result = No_Element,\n+\n+        --  Otherwise, Find returns a valid cusror in Container\n+        others =>\n+          P.Mem (Positions (Container), Reverse_Find'Result)\n+\n+        --  The element designated by the result of Find is Item\n+        and Element (Model (Container),\n+                     P.Get (Positions (Container), Reverse_Find'Result)) = Item\n+\n+        --  The result of Find is located before Position\n+        and (if Position /= No_Element\n+             then P.Get (Positions (Container), Reverse_Find'Result)\n+               <= P.Get (Positions (Container), Position))\n+\n+        --  It is the last occurence of Item in this slice\n+        and not M_Elements_Contains\n+          (S   => Model (Container),\n+           Fst => P.Get (Positions (Container), Reverse_Find'Result) + 1,\n+           Lst => (if Position = No_Element then Length (Container)\n+                   else P.Get (Positions (Container), Position)),\n+           E   => Item));\n \n    function Contains\n      (Container : List;\n       Item      : Element_Type) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   => Contains'Result =\n+         M_Elements_Contains\n+          (S   => Model (Container),\n+           Fst => 1,\n+           Lst => Length (Container),\n+           E   => Item);\n \n    function Has_Element (Container : List; Position : Cursor) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   => Has_Element'Result = P.Mem (Positions (Container), Position);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting with SPARK_Mode is\n+      function M_Elements_Sorted (S : M.Sequence) return Boolean with\n+        Ghost,\n+        Global => null,\n+        Post   => M_Elements_Sorted'Result =\n+          (for all I in 1 .. M.Length (S) =>\n+             (for all J in I + 1 .. M.Length (S) =>\n+                  Element (S, I) = Element (S, J)\n+               or Element (S, I) < Element (S, J)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : List) return Boolean with\n-        Global => null;\n+        Global => null,\n+        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n \n       procedure Sort (Container : in out List) with\n-        Global => null;\n+        Global => null,\n+        Post   => Length (Container) = Length (Container)'Old\n+        and M_Elements_Sorted (Model (Container));\n \n       procedure Merge (Target, Source : in out List) with\n-        Global => null;\n-\n+      --  Target and Source should not be aliased\n+        Global => null,\n+        Pre    => Length (Source) <= Target.Capacity - Length (Target),\n+        Post   => Length (Target) = Length (Target)'Old + Length (Source)'Old\n+        and Length (Source) = 0\n+        and (if M_Elements_Sorted (Model (Target)'Old)\n+               and M_Elements_Sorted (Model (Source)'Old)\n+             then M_Elements_Sorted (Model (Target)));\n    end Generic_Sorting;\n \n-   function Strict_Equal (Left, Right : List) return Boolean with\n-     Ghost,\n-     Global => null;\n-   --  Strict_Equal returns True if the containers are physically equal, i.e.\n-   --  they are structurally equal (function \"=\" returns True) and that they\n-   --  have the same set of cursors.\n-\n-   function First_To_Previous (Container : List; Current : Cursor) return List\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-\n-   function Current_To_Last (Container : List; Current : Cursor) return List\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-   --  First_To_Previous returns a container containing all elements preceding\n-   --  Current (excluded) in Container. Current_To_Last returns a container\n-   --  containing all elements following Current (included) in Container.\n-   --  These two new functions can be used to express invariant properties in\n-   --  loops which iterate over containers. First_To_Previous returns the part\n-   --  of the container already scanned and Current_To_Last the part not\n-   --  scanned yet.\n-\n private\n    pragma SPARK_Mode (Off);\n \n@@ -361,12 +1405,6 @@ private\n       Nodes  : Node_Array (1 .. Capacity) := (others => <>);\n    end record;\n \n-   type Cursor is record\n-      Node : Count_Type := 0;\n-   end record;\n-\n    Empty_List : constant List := (0, others => <>);\n \n-   No_Element : constant Cursor := (Node => 0);\n-\n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "02d354edac6f75d0933f8c96b627b77dfecbd57b", "filename": "gcc/ada/a-cofuba.adb", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -35,11 +35,12 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n    function To_Count (Idx : Extended_Index) return Count_Type\n    is (Count_Type\n-         (Extended_Index'Pos (Idx)\n-            - Extended_Index'Pos (Extended_Index'First)));\n+        (Extended_Index'Pos (Idx) -\n+         Extended_Index'Pos (Extended_Index'First)));\n+\n    function To_Index (Position : Count_Type) return Extended_Index\n    is (Extended_Index'Val\n-         (Position + Extended_Index'Pos (Extended_Index'First)));\n+        (Position + Extended_Index'Pos (Extended_Index'First)));\n    --  Conversion functions between Index_Type and Count_Type\n \n    function Find (C : Container; E : access Element_Type) return Count_Type;\n@@ -50,7 +51,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (C1, C2 : Container) return Boolean is\n+   function \"=\" (C1 : Container; C2 : Container) return Boolean is\n    begin\n       if C1.Elements'Length /= C2.Elements'Length then\n          return False;\n@@ -61,20 +62,22 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n             return False;\n          end if;\n       end loop;\n+\n       return True;\n    end \"=\";\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (C1, C2 : Container) return Boolean is\n+   function \"<=\" (C1 : Container; C2 : Container) return Boolean is\n    begin\n       for I in C1.Elements'Range loop\n          if Find (C2, C1.Elements (I)) = 0 then\n             return False;\n          end if;\n       end loop;\n+\n       return True;\n    end \"<=\";\n \n@@ -90,6 +93,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       A : constant Element_Array_Access :=\n             new Element_Array'(1 .. C.Elements'Last + 1 => <>);\n       P : Count_Type := 0;\n+\n    begin\n       for J in 1 .. C.Elements'Last + 1 loop\n          if J /= To_Count (I) then\n@@ -99,6 +103,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n             A (J) := new Element_Type'(E);\n          end if;\n       end loop;\n+\n       return Container'(Elements => A);\n    end Add;\n \n@@ -113,6 +118,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n             return I;\n          end if;\n       end loop;\n+\n       return 0;\n    end Find;\n \n@@ -130,17 +136,19 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- Intersection --\n    ------------------\n \n-   function Intersection (C1, C2 : Container) return Container is\n+   function Intersection (C1 : Container; C2 : Container) return Container is\n       A : constant Element_Array_Access :=\n             new Element_Array'(1 .. Num_Overlaps (C1, C2) => <>);\n       P : Count_Type := 0;\n+\n    begin\n       for I in C1.Elements'Range loop\n          if Find (C2, C1.Elements (I)) > 0 then\n             P := P + 1;\n             A (P) := C1.Elements (I);\n          end if;\n       end loop;\n+\n       return Container'(Elements => A);\n    end Intersection;\n \n@@ -154,14 +162,16 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- Num_Overlaps --\n    ---------------------\n \n-   function Num_Overlaps (C1, C2 : Container) return Count_Type is\n+   function Num_Overlaps (C1 : Container; C2 : Container) return Count_Type is\n       P : Count_Type := 0;\n+\n    begin\n       for I in C1.Elements'Range loop\n          if Find (C2, C1.Elements (I)) > 0 then\n             P := P + 1;\n          end if;\n       end loop;\n+\n       return P;\n    end Num_Overlaps;\n \n@@ -173,25 +183,30 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       A : constant Element_Array_Access :=\n             new Element_Array'(1 .. C.Elements'Last - 1 => <>);\n       P : Count_Type := 0;\n+\n    begin\n       for J in C.Elements'Range loop\n          if J /= To_Count (I) then\n             P := P + 1;\n             A (P) := C.Elements (J);\n          end if;\n       end loop;\n+\n       return Container'(Elements => A);\n    end Remove;\n \n    ---------\n    -- Set --\n    ---------\n \n-   function Set (C : Container; I : Index_Type; E : Element_Type)\n-                 return Container\n+   function Set\n+     (C : Container;\n+      I : Index_Type;\n+      E : Element_Type) return Container\n    is\n       Result : constant Container :=\n                  Container'(Elements => new Element_Array'(C.Elements.all));\n+\n    begin\n       Result.Elements (To_Count (I)) := new Element_Type'(E);\n       return Result;\n@@ -201,7 +216,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- Union --\n    -----------\n \n-   function Union (C1, C2 : Container) return Container is\n+   function Union (C1 : Container; C2 : Container) return Container is\n       N : constant Count_Type := Num_Overlaps (C1, C2);\n \n    begin\n@@ -216,15 +231,18 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       declare\n          L : constant Count_Type := Length (C1) - N + Length (C2);\n          A : constant Element_Array_Access :=\n-           new Element_Array'(C1.Elements.all & (Length (C1) + 1 .. L => <>));\n+               new Element_Array'\n+                     (C1.Elements.all & (Length (C1) + 1 .. L => <>));\n          P : Count_Type := Length (C1);\n+\n       begin\n          for I in C2.Elements'Range loop\n             if Find (C1, C2.Elements (I)) = 0 then\n                P := P + 1;\n                A (P) := C2.Elements (I);\n             end if;\n          end loop;\n+\n          return Container'(Elements => A);\n       end;\n    end Union;"}, {"sha": "92bc6bd00001172ea3edaa535a64627b41f9caf4", "filename": "gcc/ada/a-cofuba.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -41,14 +41,15 @@ private generic\n \n    type Element_Type (<>) is private;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n    subtype Extended_Index is Index_Type'Base range\n      Index_Type'Pred (Index_Type'First) .. Index_Type'Last;\n \n    type Container is private;\n \n-   function \"=\" (C1, C2 : Container) return Boolean;\n+   function \"=\" (C1 : Container; C2 : Container) return Boolean;\n    --  Return True if C1 and C2 contain the same elements at the same position\n \n    function Length (C : Container) return Count_Type;\n@@ -57,8 +58,10 @@ package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    function Get (C : Container; I : Index_Type) return Element_Type;\n    --  Access to the element at index I in C\n \n-   function Set (C : Container; I : Index_Type; E : Element_Type)\n-                 return Container;\n+   function Set\n+     (C : Container;\n+      I : Index_Type;\n+      E : Element_Type) return Container;\n    --  Return a new container which is equal to C except for the element at\n    --  index I, which is set to E.\n \n@@ -79,17 +82,17 @@ package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- Set Operations --\n    --------------------\n \n-   function \"<=\" (C1, C2 : Container) return Boolean;\n+   function \"<=\" (C1 : Container; C2 : Container) return Boolean;\n    --  Return True if every element of C1 is in C2\n \n-   function Num_Overlaps (C1, C2 : Container) return Count_Type;\n+   function Num_Overlaps (C1 : Container; C2 : Container) return Count_Type;\n    --  Return the number of elements that are in both C1 and C2\n \n-   function Union (C1, C2 : Container) return Container;\n+   function Union (C1 : Container; C2 : Container) return Container;\n    --  Return a container which is C1 plus all the elements of C2 that are not\n    --  in C1.\n \n-   function Intersection (C1, C2 : Container) return Container;\n+   function Intersection (C1 : Container; C2 : Container) return Container;\n    --  Return a container which is C1 minus all the elements that are also in\n    --  C2.\n "}, {"sha": "e46f9ae85b2d4f7b3ca35571ae15ad7d303b8804", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -38,15 +38,16 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (M1, M2 : Map) return Boolean is\n+   function \"=\" (M1 : Map; M2 : Map) return Boolean is\n      (M1.Keys <= M2.Keys and M2 <= M1);\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (M1, M2 : Map) return Boolean is\n+   function \"<=\" (M1 : Map; M2 : Map) return Boolean is\n       I2 : Count_Type;\n+\n    begin\n       for I1 in 1 .. Length (M1.Keys) loop\n          I2 := Find (M2.Keys, Get (M1.Keys, I1));\n@@ -84,7 +85,10 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    ------------\n \n    function Is_Add\n-     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+     (M      : Map;\n+      K      : Key_Type;\n+      E      : Element_Type;\n+      Result : Map) return Boolean\n    is\n    begin\n       if Mem (M, K) or not Mem (Result, K) or Get (Result, K) /= E then\n@@ -120,16 +124,19 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    ------------\n \n    function Is_Set\n-     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+     (M      : Map;\n+      K      : Key_Type;\n+      E      : Element_Type;\n+      Result : Map) return Boolean\n    is\n      (Mem (M, K)\n-      and then Mem (Result, K)\n-      and then Get (Result, K) = E\n-      and then (for all KK of M => Mem (Result, KK)\n-                and then\n-                  (if K /= KK\n-                   then Get (Result, KK) = Get (M, KK)))\n-      and then (for all K of Result => Mem (M, K)));\n+       and then Mem (Result, K)\n+       and then Get (Result, K) = E\n+       and then (for all KK of M =>\n+                   Mem (Result, KK)\n+                     and then\n+                       (if K /= KK then Get (Result, KK) = Get (M, KK)))\n+       and then (for all K of Result => Mem (M, K)));\n \n    ------------\n    -- Length --\n@@ -155,4 +162,5 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n \n    function Set (M : Map; K : Key_Type; E : Element_Type) return Map is\n      (Keys => M.Keys, Elements => Set (M.Elements, Find (M.Keys, K), E));\n+\n end Ada.Containers.Functional_Maps;"}, {"sha": "e6da44ae843e42208bda8526cb45da18cd764bd6", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -37,6 +37,7 @@ generic\n    type Element_Type (<>)  is private;\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    pragma Assertion_Policy (Post => Ignore);\n@@ -58,28 +59,29 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    function Mem (M : Map; K : Key_Type) return Boolean with\n      Global => null;\n+\n    function Get (M : Map; K : Key_Type) return Element_Type with\n      Global => null,\n      Pre    => Mem (M, K);\n \n    function Length (M : Map) return Count_Type with\n      Global => null;\n \n-   function \"<=\" (M1, M2 : Map) return Boolean with\n+   function \"<=\" (M1 : Map; M2 : Map) return Boolean with\n    --  Map inclusion\n \n      Global => null,\n      Post   => \"<=\"'Result =\n-       (for all K of M1 => Mem (M2, K)\n-        and then Get (M2, K) = Get (M1, K));\n+       (for all K of M1 =>\n+          Mem (M2, K) and then Get (M2, K) = Get (M1, K));\n \n-   function \"=\" (M1, M2 : Map) return Boolean with\n+   function \"=\" (M1 : Map; M2 : Map) return Boolean with\n    --  Extensional equality over maps\n \n      Global => null,\n      Post   => \"=\"'Result =\n        ((for all K of M1 => Mem (M2, K) and then Get (M2, K) = Get (M1, K))\n-          and (for all K of M2 => Mem (M1, K)));\n+           and (for all K of M2 => Mem (M1, K)));\n \n    pragma Warnings (Off, \"unused variable \"\"K\"\"\");\n    function Is_Empty (M : Map) return Boolean with\n@@ -89,18 +91,23 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n    pragma Warnings (On, \"unused variable \"\"K\"\"\");\n \n    function Is_Add\n-     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n+     (M      : Map;\n+      K      : Key_Type;\n+      E      : Element_Type;\n+      Result : Map) return Boolean\n    --  Returns True if Result is M augmented with the mapping K -> E\n \n    with\n      Global => null,\n-     Post   => Is_Add'Result =\n+     Post   =>\n+       Is_Add'Result =\n          (not Mem (M, K)\n-          and then (Mem (Result, K) and then Get (Result, K) = E\n-            and then (for all K of M => Mem (Result, K)\n-                 and then Get (Result, K) = Get (M, K))\n+            and then Mem (Result, K)\n+            and then Get (Result, K) = E\n+            and then (for all K of M =>\n+                        Mem (Result, K) and then Get (Result, K) = Get (M, K))\n             and then (for all KK of Result =>\n-                        Equivalent_Keys (KK, K) or Mem (M, KK))));\n+                        Equivalent_Keys (KK, K) or Mem (M, KK)));\n \n    function Add (M : Map; K : Key_Type; E : Element_Type) return Map with\n    --  Returns M augmented with the mapping K -> E.\n@@ -137,8 +144,8 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n      Global => null,\n      Pre    => Mem (M, K),\n-     Post   => Length (M) = Length (Set'Result)\n-     and Is_Set (M, K, E, Set'Result);\n+     Post   =>\n+       Length (M) = Length (Set'Result) and Is_Set (M, K, E, Set'Result);\n \n    ---------------------------\n    --  Iteration Primitives --\n@@ -148,11 +155,14 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    function Iter_First (M : Map) return Private_Key with\n      Global => null;\n+\n    function Iter_Has_Element (M : Map; K : Private_Key) return Boolean with\n      Global => null;\n+\n    function Iter_Next (M : Map; K : Private_Key) return Private_Key with\n      Global => null,\n      Pre    => Iter_Has_Element (M, K);\n+\n    function Iter_Element (M : Map; K : Private_Key) return Key_Type with\n      Global => null,\n      Pre    => Iter_Has_Element (M, K);\n@@ -162,18 +172,19 @@ private\n \n    pragma SPARK_Mode (Off);\n \n-   function \"=\"  (Left, Right : Key_Type) return Boolean\n-                  renames Equivalent_Keys;\n+   function \"=\"\n+     (Left  : Key_Type;\n+      Right : Key_Type) return Boolean renames Equivalent_Keys;\n \n    subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n \n    package Element_Containers is new Ada.Containers.Functional_Base\n-     (Element_Type        => Element_Type,\n-      Index_Type          => Positive_Count_Type);\n+     (Element_Type => Element_Type,\n+      Index_Type   => Positive_Count_Type);\n \n    package Key_Containers is new Ada.Containers.Functional_Base\n-     (Element_Type        => Key_Type,\n-      Index_Type          => Positive_Count_Type);\n+     (Element_Type => Key_Type,\n+      Index_Type   => Positive_Count_Type);\n \n    type Map is record\n       Keys     : Key_Containers.Container;"}, {"sha": "12881753c31f19c1e46e1280790586216ae73e87", "filename": "gcc/ada/a-cofuse.adb", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -38,14 +38,15 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (S1, S2 : Set) return Boolean is\n+   function \"=\" (S1 : Set; S2 : Set) return Boolean is\n      (S1.Content <= S2.Content and S2.Content <= S1.Content);\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (S1, S2 : Set) return Boolean is (S1.Content <= S2.Content);\n+   function \"<=\" (S1 : Set; S2 : Set) return Boolean is\n+     (S1.Content <= S2.Content);\n \n    ---------\n    -- Add --\n@@ -58,7 +59,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    -- Intersection --\n    ------------------\n \n-   function Intersection (S1, S2 : Set) return Set is\n+   function Intersection (S1 : Set; S2 : Set) return Set is\n      (Content => Intersection (S1.Content, S2.Content));\n \n    ------------\n@@ -68,8 +69,8 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    function Is_Add (S : Set; E : Element_Type; Result : Set) return Boolean\n    is\n      (Mem (Result, E)\n-      and (for all F of Result => Mem (S, F) or F = E)\n-      and (for all E of S => Mem (Result, E)));\n+        and (for all F of Result => Mem (S, F) or F = E)\n+        and (for all E of S => Mem (Result, E)));\n \n    --------------\n    -- Is_Empty --\n@@ -81,20 +82,24 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    -- Is_Intersection --\n    ---------------------\n \n-   function Is_Intersection (S1, S2, Result : Set) return Boolean is\n+   function Is_Intersection\n+     (S1     : Set;\n+      S2     : Set;\n+      Result : Set) return Boolean\n+   is\n      ((for all E of Result =>\n-            Mem (S1, E) and Mem (S2, E))\n-      and (for all E of S1 =>\n-               (if Mem (S2, E) then Mem (Result, E))));\n+         Mem (S1, E)\n+           and Mem (S2, E))\n+           and (for all E of S1 => (if Mem (S2, E) then Mem (Result, E))));\n \n    --------------\n    -- Is_Union --\n    --------------\n \n-   function Is_Union (S1, S2, Result : Set) return Boolean is\n+   function Is_Union (S1 : Set; S2 : Set; Result : Set) return Boolean is\n      ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n-      and (for all E of S1 => Mem (Result, E))\n-      and (for all E of S2 => Mem (Result, E)));\n+         and (for all E of S1 => Mem (Result, E))\n+         and (for all E of S2 => Mem (Result, E)));\n \n    ------------\n    -- Length --\n@@ -107,14 +112,14 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    ---------\n \n    function Mem (S : Set; E : Element_Type) return Boolean is\n-      (Find (S.Content, E) > 0);\n+     (Find (S.Content, E) > 0);\n \n    ------------------\n    -- Num_Overlaps --\n    ------------------\n \n-   function Num_Overlaps (S1, S2 : Set) return Count_Type is\n-      (Num_Overlaps (S1.Content, S2.Content));\n+   function Num_Overlaps (S1 : Set; S2 : Set) return Count_Type is\n+     (Num_Overlaps (S1.Content, S2.Content));\n \n    ------------\n    -- Remove --\n@@ -127,6 +132,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    -- Union --\n    -----------\n \n-   function Union (S1, S2 : Set) return Set is\n+   function Union (S1 : Set; S2 : Set) return Set is\n      (Content => Union (S1.Content, S2.Content));\n+\n end Ada.Containers.Functional_Sets;"}, {"sha": "410b1cb3d6f871e6b2fa6d5f6313c5d2b10d874d", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -35,6 +35,7 @@ private with Ada.Containers.Functional_Base;\n generic\n    type Element_Type (<>) is private;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n    pragma Assertion_Policy (Post => Ignore);\n@@ -59,19 +60,20 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    function Length (S : Set) return Count_Type with\n      Global => null;\n \n-   function \"<=\" (S1, S2 : Set) return Boolean with\n+   function \"<=\" (S1 : Set; S2 : Set) return Boolean with\n    --  Set inclusion\n \n      Global => null,\n      Post   => \"<=\"'Result = (for all E of S1 => Mem (S2, E));\n \n-   function \"=\" (S1, S2 : Set) return Boolean with\n+   function \"=\" (S1 : Set; S2 : Set) return Boolean with\n    --  Extensional equality over sets\n \n      Global => null,\n      Post   =>\n-       \"=\"'Result = ((for all E of S1 => Mem (S2, E))\n-                     and (for all E of S2 => Mem (S1, E)));\n+       \"=\"'Result =\n+         ((for all E of S1 => Mem (S2, E))\n+             and (for all E of S2 => Mem (S1, E)));\n \n    pragma Warnings (Off, \"unused variable \"\"E\"\"\");\n    function Is_Empty (S : Set) return Boolean with\n@@ -86,10 +88,12 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n    with\n      Global => null,\n-     Post   => Is_Add'Result =\n-       (Mem (Result, E) and not Mem (S, E)\n-        and (for all F of Result => Mem (S, F) or F = E)\n-        and (for all E of S => Mem (Result, E)));\n+     Post   =>\n+       Is_Add'Result =\n+         (Mem (Result, E)\n+            and not Mem (S, E)\n+            and (for all F of Result => Mem (S, F) or F = E)\n+            and (for all E of S => Mem (Result, E)));\n \n    function Add (S : Set; E : Element_Type) return Set with\n    --  Returns S augmented with E.\n@@ -98,8 +102,9 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n      Global => null,\n      Pre    => not Mem (S, E) and Length (S) < Count_Type'Last,\n-     Post   => Length (Add'Result) = Length (S) + 1\n-     and Is_Add (S, E, Add'Result);\n+     Post   =>\n+       Length (Add'Result) = Length (S) + 1\n+         and Is_Add (S, E, Add'Result);\n \n    function Remove (S : Set; E : Element_Type) return Set with\n    --  Returns S without E.\n@@ -108,59 +113,67 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n      Global => null,\n      Pre    => Mem (S, E),\n-     Post   => Length (Remove'Result) = Length (S) - 1\n-     and Is_Add (Remove'Result, E, S);\n+     Post   =>\n+       Length (Remove'Result) = Length (S) - 1\n+         and Is_Add (Remove'Result, E, S);\n \n-   function Is_Intersection (S1, S2, Result : Set) return Boolean with\n+   function Is_Intersection\n+     (S1     : Set;\n+      S2     : Set;\n+      Result : Set) return Boolean\n+   with\n    --  Returns True if Result is the intersection of S1 and S2\n \n      Global => null,\n-     Post   => Is_Intersection'Result =\n-       ((for all E of Result =>\n-               Mem (S1, E) and Mem (S2, E))\n-        and (for all E of S1 =>\n-               (if Mem (S2, E) then Mem (Result, E))));\n+     Post   =>\n+       Is_Intersection'Result =\n+         ((for all E of Result => Mem (S1, E) and Mem (S2, E))\n+             and (for all E of S1 => (if Mem (S2, E) then Mem (Result, E))));\n \n-   function Num_Overlaps (S1, S2 : Set) return Count_Type with\n+   function Num_Overlaps (S1 : Set; S2 : Set) return Count_Type with\n    --  Number of elements that are both in S1 and S2\n \n      Global => null,\n-     Post   => Num_Overlaps'Result <= Length (S1)\n-     and Num_Overlaps'Result <= Length (S2)\n-     and (if Num_Overlaps'Result = 0 then\n-            (for all E of S1 => not Mem (S2, E)));\n+     Post   =>\n+       Num_Overlaps'Result <= Length (S1)\n+         and Num_Overlaps'Result <= Length (S2)\n+         and (if Num_Overlaps'Result = 0 then\n+               (for all E of S1 => not Mem (S2, E)));\n \n-   function Intersection (S1, S2 : Set) return Set with\n+   function Intersection (S1 : Set; S2 : Set) return Set with\n    --  Returns the intersection of S1 and S2.\n    --  Intersection (S1, S2, Result) should be used instead of\n    --  Result = Intersection (S1, S2) whenever possible both for execution and\n    --  for proof.\n \n      Global => null,\n-     Post   => Length (Intersection'Result) = Num_Overlaps (S1, S2)\n-     and Is_Intersection (S1, S2, Intersection'Result);\n+     Post   =>\n+       Length (Intersection'Result) = Num_Overlaps (S1, S2)\n+         and Is_Intersection (S1, S2, Intersection'Result);\n \n-   function Is_Union (S1, S2, Result : Set) return Boolean with\n+   function Is_Union (S1 : Set; S2 : Set; Result : Set) return Boolean with\n    --  Returns True if Result is the union of S1 and S2\n \n      Global => null,\n-     Post   => Is_Union'Result =\n-       ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n-        and (for all E of S1 => Mem (Result, E))\n-        and (for all E of S2 => Mem (Result, E)));\n+     Post   =>\n+       Is_Union'Result =\n+         ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n+             and (for all E of S1 => Mem (Result, E))\n+             and (for all E of S2 => Mem (Result, E)));\n \n-   function Union (S1, S2 : Set) return Set with\n+   function Union (S1 : Set; S2 : Set) return Set with\n    --  Returns the union of S1 and S2.\n    --  Is_Union (S1, S2, Result) should be used instead of\n    --  Result = Union (S1, S2) whenever possible both for execution and for\n    --  proof.\n \n      Global => null,\n-     Pre    => Length (S1) - Num_Overlaps (S1, S2) <=\n-     Count_Type'Last - Length (S2),\n-     Post   => Length (Union'Result) = Length (S1) - Num_Overlaps (S1, S2)\n-     + Length (S2)\n-     and Is_Union (S1, S2, Union'Result);\n+     Pre    =>\n+       Length (S1) - Num_Overlaps (S1, S2) <= Count_Type'Last - Length (S2),\n+     Post   =>\n+       Length (Union'Result) =\n+         Length (S1) - Num_Overlaps (S1, S2) + Length (S2)\n+           and Is_Union (S1, S2, Union'Result);\n \n    ---------------------------\n    --  Iteration Primitives --\n@@ -170,11 +183,14 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n    function Iter_First (S : Set) return Private_Key with\n      Global => null;\n+\n    function Iter_Has_Element (S : Set; K : Private_Key) return Boolean with\n      Global => null;\n+\n    function Iter_Next (S : Set; K : Private_Key) return Private_Key with\n      Global => null,\n      Pre    => Iter_Has_Element (S, K);\n+\n    function Iter_Element (S : Set; K : Private_Key) return Element_Type with\n      Global => null,\n      Pre    => Iter_Has_Element (S, K);"}, {"sha": "fdab8c23a5080d9d727f4ddc27711651850aadf5", "filename": "gcc/ada/a-cofuve.adb", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -37,25 +37,25 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (S1, S2 : Sequence) return Boolean is\n+   function \"=\" (S1 : Sequence; S2 : Sequence) return Boolean is\n      (S1.Content = S2.Content);\n \n    ---------\n    -- \"<\" --\n    ---------\n \n-   function \"<\" (S1, S2 : Sequence) return Boolean is\n+   function \"<\" (S1 : Sequence; S2 : Sequence) return Boolean is\n      (Length (S1.Content) < Length (S2.Content)\n-      and then (for all I in Index_Type'First .. Last (S1) =>\n+       and then (for all I in Index_Type'First .. Last (S1) =>\n                    Get (S1.Content, I) = Get (S2.Content, I)));\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (S1, S2 : Sequence) return Boolean is\n+   function \"<=\" (S1 : Sequence; S2 : Sequence) return Boolean is\n      (Length (S1.Content) <= Length (S2.Content)\n-      and then (for all I in Index_Type'First .. Last (S1) =>\n+       and then (for all I in Index_Type'First .. Last (S1) =>\n                    Get (S1.Content, I) = Get (S2.Content, I)));\n \n    ---------\n@@ -83,32 +83,39 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    function Insert\n      (S : Sequence;\n       N : Index_Type;\n-      E : Element_Type) return Sequence is\n+      E : Element_Type) return Sequence\n+   is\n      (Content => Add (S.Content, N, E));\n \n    ------------\n    -- Is_Add --\n    ------------\n \n    function Is_Add\n-     (S : Sequence; E : Element_Type; Result : Sequence) return Boolean is\n+     (S      : Sequence;\n+      E      : Element_Type;\n+      Result : Sequence) return Boolean\n+   is\n      (Length (Result) = Length (S) + 1\n-      and then Get (Result, Index_Type'Val\n-                    ((Index_Type'Pos (Index_Type'First) - 1) +\n-                       Length (Result))) = E\n+       and then Get (Result, Index_Type'Val\n+                      ((Index_Type'Pos (Index_Type'First) - 1) +\n+                          Length (Result))) = E\n       and then\n         (for all M in Index_Type'First ..\n-             (Index_Type'Val\n-                  ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))) =>\n-              Get (Result, M) = Get (S, M)));\n+           (Index_Type'Val\n+              ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))) =>\n+                  Get (Result, M) = Get (S, M)));\n \n    ------------\n    -- Is_Set --\n    ------------\n \n    function Is_Set\n-     (S : Sequence; N : Index_Type; E : Element_Type; Result : Sequence)\n-      return Boolean is\n+     (S      : Sequence;\n+      N      : Index_Type;\n+      E      : Element_Type;\n+      Result : Sequence) return Boolean\n+   is\n      (N in Index_Type'First ..\n              (Index_Type'Val\n                   ((Index_Type'Pos (Index_Type'First) - 1) + Length (S)))\n@@ -145,7 +152,11 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    -- Set --\n    ---------\n \n-   function Set (S : Sequence; N : Index_Type; E : Element_Type)\n-                 return Sequence is\n+   function Set\n+     (S : Sequence;\n+      N : Index_Type;\n+      E : Element_Type) return Sequence\n+   is\n      (Content => Set (S.Content, N, E));\n+\n end Ada.Containers.Functional_Vectors;"}, {"sha": "74f1bfb42205bca08eb9a37c1d0c915e7939d324", "filename": "gcc/ada/a-cofuve.ads", "status": "modified", "additions": 82, "deletions": 51, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -39,6 +39,7 @@ generic\n \n    type Element_Type (<>) is private;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n    pragma Assertion_Policy (Post => Ignore);\n@@ -64,13 +65,15 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n    function Length (S : Sequence) return Count_Type with\n      Global => null,\n-     Post => (Index_Type'Pos (Index_Type'First) - 1) + Length'Result <=\n-       Index_Type'Pos (Index_Type'Last);\n+     Post   =>\n+       (Index_Type'Pos (Index_Type'First) - 1) + Length'Result <=\n+          Index_Type'Pos (Index_Type'Last);\n \n    function Last (S : Sequence) return Extended_Index with\n      Global => null,\n-     Post => Last'Result =\n-       Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) + Length (S));\n+     Post   =>\n+       Last'Result =\n+         Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) + Length (S));\n \n    function First return Extended_Index is (Index_Type'First);\n \n@@ -81,50 +84,58 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Global => null,\n      Pre    => N in Index_Type'First .. Last (S);\n \n-   function \"=\" (S1, S2 : Sequence) return Boolean with\n+   function \"=\" (S1 : Sequence; S2 : Sequence) return Boolean with\n    --  Extensional equality over sequences\n \n      Global => null,\n-     Post   => \"=\"'Result =\n-       (Length (S1) = Length (S2)\n-        and then (for all N in Index_Type'First .. Last (S1) =>\n-            Get (S1, N) = Get (S2, N)));\n+     Post   =>\n+       \"=\"'Result =\n+         (Length (S1) = Length (S2)\n+            and then (for all N in Index_Type'First .. Last (S1) =>\n+                        Get (S1, N) = Get (S2, N)));\n \n-   function \"<\" (S1, S2 : Sequence) return Boolean with\n+   function \"<\" (S1 : Sequence; S2 : Sequence) return Boolean with\n    --  S1 is a strict subsequence of S2\n \n      Global => null,\n-     Post   => \"<\"'Result =\n-     (Length (S1) < Length (S2)\n-      and then (for all N in Index_Type'First .. Last (S1) =>\n-          Get (S1, N) = Get (S2, N)));\n+     Post   =>\n+       \"<\"'Result =\n+         (Length (S1) < Length (S2)\n+            and then (for all N in Index_Type'First .. Last (S1) =>\n+                        Get (S1, N) = Get (S2, N)));\n \n-   function \"<=\" (S1, S2 : Sequence) return Boolean with\n+   function \"<=\" (S1 : Sequence; S2 : Sequence) return Boolean with\n    --  S1 is a subsequence of S2\n \n      Global => null,\n-     Post   => \"<=\"'Result =\n-     (Length (S1) <= Length (S2)\n-      and then (for all N in Index_Type'First .. Last (S1) =>\n-          Get (S1, N) = Get (S2, N)));\n+     Post   =>\n+       \"<=\"'Result =\n+         (Length (S1) <= Length (S2)\n+            and then (for all N in Index_Type'First .. Last (S1) =>\n+                        Get (S1, N) = Get (S2, N)));\n \n    function Is_Set\n-     (S : Sequence; N : Index_Type; E : Element_Type; Result : Sequence)\n-      return Boolean\n+     (S      : Sequence;\n+      N      : Index_Type;\n+      E      : Element_Type;\n+      Result : Sequence) return Boolean\n    --  Returns True if Result is S, where the Nth element has been replaced by\n    --  E.\n \n    with\n      Global => null,\n-       Post   => Is_Set'Result =\n+     Post   =>\n+       Is_Set'Result =\n          (N in Index_Type'First .. Last (S)\n            and then Length (Result) = Length (S)\n            and then Get (Result, N) = E\n            and then (for all M in Index_Type'First .. Last (S) =>\n                        (if M /= N then Get (Result, M) = Get (S, M))));\n \n    function Set\n-     (S : Sequence; N : Index_Type; E : Element_Type) return Sequence\n+     (S : Sequence;\n+      N : Index_Type;\n+      E : Element_Type) return Sequence\n    --  Returns S, where the Nth element has been replaced by E.\n    --  Is_Set (S, N, E, Result) should be used instead of\n    --  Result = Set (S, N, E) whenever possible both for execution and for\n@@ -136,12 +147,15 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   => Is_Set (S, N, E, Set'Result);\n \n    function Is_Add\n-     (S : Sequence; E : Element_Type; Result : Sequence) return Boolean\n+     (S      : Sequence;\n+      E      : Element_Type;\n+      Result : Sequence) return Boolean\n    --  Returns True if Result is S appended with E\n \n    with\n      Global => null,\n-     Post   => Is_Add'Result =\n+     Post   =>\n+       Is_Add'Result =\n          (Length (Result) = Length (S) + 1\n            and then Get (Result, Last (Result)) = E\n            and then (for all M in Index_Type'First .. Last (S) =>\n@@ -164,37 +178,50 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n    --  Returns S with E inserted at index I\n \n      Global => null,\n-     Pre    => Length (S) < Count_Type'Last and then Last (S) < Index_Type'Last\n-     and then N <= Extended_Index'Succ (Last (S)),\n-     Post   => Length (Insert'Result) = Length (S) + 1\n-     and then Get (Insert'Result, N) = E\n-     and then (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n-                   Get (Insert'Result, M) = Get (S, M))\n-     and then (for all M in Extended_Index'Succ (N) .. Last (Insert'Result) =>\n-                   Get (Insert'Result, M) = Get (S, Extended_Index'Pred (M)))\n-     and then (for all M in N .. Last (S) =>\n-                   Get (Insert'Result, Extended_Index'Succ (M)) = Get (S, M));\n+     Pre    =>\n+       Length (S) < Count_Type'Last\n+         and then Last (S) < Index_Type'Last\n+         and then N <= Extended_Index'Succ (Last (S)),\n+     Post   =>\n+       Length (Insert'Result) = Length (S) + 1\n+         and then Get (Insert'Result, N) = E\n+         and then\n+           (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n+              Get (Insert'Result, M) = Get (S, M))\n+         and then\n+           (for all M in Extended_Index'Succ (N) ..  Last (Insert'Result) =>\n+              Get (Insert'Result, M) = Get (S, Extended_Index'Pred (M)))\n+         and then\n+           (for all M in N .. Last (S) =>\n+              Get (Insert'Result, Extended_Index'Succ (M)) = Get (S, M));\n \n    function Remove (S : Sequence; N : Index_Type) return Sequence with\n    --  Returns S without the element at index N\n \n      Global => null,\n-     Pre    => Length (S) < Count_Type'Last and Last (S) < Index_Type'Last\n-     and N in Index_Type'First .. Last (S),\n-     Post   => Length (Remove'Result) = Length (S) - 1\n-     and then (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n-                   Get (Remove'Result, M) = Get (S, M))\n-     and then (for all M in N .. Last (Remove'Result) =>\n-                   Get (Remove'Result, M) = Get (S, Extended_Index'Succ (M)))\n-     and then (for all M in Extended_Index'Succ (N) .. Last (S) =>\n-                   Get (Remove'Result, Extended_Index'Pred (M)) = Get (S, M));\n+     Pre    =>\n+       Length (S) < Count_Type'Last\n+         and Last (S) < Index_Type'Last\n+         and N in Index_Type'First .. Last (S),\n+     Post   =>\n+       Length (Remove'Result) = Length (S) - 1\n+         and then\n+           (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n+              Get (Remove'Result, M) = Get (S, M))\n+         and then\n+           (for all M in N .. Last (Remove'Result) =>\n+              Get (Remove'Result, M) = Get (S, Extended_Index'Succ (M)))\n+         and then\n+           (for all M in Extended_Index'Succ (N) .. Last (S) =>\n+              Get (Remove'Result, Extended_Index'Pred (M)) = Get (S, M));\n \n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------\n \n    function Iter_First (S : Sequence) return Extended_Index with\n      Global => null;\n+\n    function Iter_Has_Element (S : Sequence; I : Extended_Index) return Boolean\n    with\n      Global => null,\n@@ -218,18 +245,22 @@ private\n       Content : Containers.Container;\n    end record;\n \n-   function Iter_First (S :\n-                        Sequence) return Extended_Index\n-   is (Index_Type'First);\n-   function Iter_Next (S : Sequence; I : Extended_Index) return Extended_Index\n+   function Iter_First (S : Sequence) return Extended_Index is\n+     (Index_Type'First);\n+\n+   function Iter_Next\n+     (S : Sequence;\n+      I : Extended_Index) return Extended_Index\n    is\n      (if I = Extended_Index'Last then Extended_Index'First\n       else Extended_Index'Succ (I));\n \n-   function Iter_Has_Element (S : Sequence; I : Extended_Index) return Boolean\n+   function Iter_Has_Element\n+     (S : Sequence;\n+      I : Extended_Index) return Boolean\n    is\n      (I in Index_Type'First ..\n-        (Index_Type'Val\n-           ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))));\n+       (Index_Type'Val\n+         ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))));\n \n end Ada.Containers.Functional_Vectors;"}, {"sha": "fe480beb426b81d8cba7f104e8e40a7f7011e1e6", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -1176,7 +1176,7 @@ package body CStand is\n       --  Any_Integer is given reasonable and consistent type and size values)\n \n       Any_Type := New_Standard_Entity (\"any type\");\n-      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Decl     := New_Node (N_Full_Type_Declaration, Stloc);\n       Set_Defining_Identifier (Decl, Any_Type);\n       Set_Scope (Any_Type, Standard_Standard);\n       Build_Signed_Integer_Type (Any_Type, Standard_Integer_Size);\n@@ -1194,7 +1194,8 @@ package body CStand is\n       Set_Etype             (Any_Access, Any_Access);\n       Init_Size             (Any_Access, System_Address_Size);\n       Set_Elem_Alignment    (Any_Access);\n-      Set_Directly_Designated_Type (Any_Access, Any_Type);\n+      Set_Directly_Designated_Type\n+                            (Any_Access, Any_Type);\n \n       Any_Character := New_Standard_Entity (\"a character type\");\n       Set_Ekind             (Any_Character, E_Enumeration_Type);"}, {"sha": "bfe96e537dbe15812aa183d3a8ed3036c0b3e229", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -10977,8 +10977,11 @@ package body Einfo is\n    procedure Write_Field38_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Function | E_Procedure =>\n+         when E_Function\n+            | E_Procedure\n+         =>\n             Write_Str (\"class-wide clone\");\n+\n          when others =>\n             Write_Str (\"Field38??\");\n       end case;"}, {"sha": "9644633de4e9922313c6fa50dafebb85c53f2952", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -4043,22 +4043,42 @@ package body Exp_Ch7 is\n    procedure Establish_Transient_Scope (N : Node_Id; Sec_Stack : Boolean) is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Iter_Loop : Entity_Id;\n+      Scop_Id   : Entity_Id;\n+      Scop_Rec  : Scope_Stack_Entry;\n       Wrap_Node : Node_Id;\n \n    begin\n-      --  Do not create a transient scope if we are already inside one\n+      --  Do not create a new transient scope if there is an existing transient\n+      --  scope on the stack.\n \n-      for S in reverse Scope_Stack.First .. Scope_Stack.Last loop\n-         if Scope_Stack.Table (S).Is_Transient then\n+      for Index in reverse Scope_Stack.First .. Scope_Stack.Last loop\n+         Scop_Rec := Scope_Stack.Table (Index);\n+         Scop_Id  := Scop_Rec.Entity;\n+\n+         --  The current scope is transient. If the scope being established\n+         --  needs to manage the secondary stack, then the existing scope\n+         --  overtakes that function.\n+\n+         if Scop_Rec.Is_Transient then\n             if Sec_Stack then\n-               Set_Uses_Sec_Stack (Scope_Stack.Table (S).Entity);\n+               Set_Uses_Sec_Stack (Scop_Id);\n             end if;\n \n             return;\n \n-         --  If we encounter Standard there are no enclosing transient scopes\n-\n-         elsif Scope_Stack.Table (S).Entity = Standard_Standard then\n+         --  Prevent the search from going too far because transient blocks\n+         --  are bounded by packages and subprogram scopes. Reaching Standard\n+         --  should be impossible without hitting one of the other cases first\n+         --  unless Standard was manually pushed.\n+\n+         elsif Scop_Id = Standard_Standard\n+           or else Ekind_In (Scop_Id, E_Entry,\n+                                      E_Entry_Family,\n+                                      E_Function,\n+                                      E_Package,\n+                                      E_Procedure,\n+                                      E_Subprogram_Body)\n+         then\n             exit;\n          end if;\n       end loop;"}, {"sha": "36225a92ad89cfd7dc02e74e8ff2bbcb207a3920", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -172,7 +172,7 @@ package body Exp_Prag is\n \n       if Should_Ignore_Pragma_Sem (N)\n         or else (Prag_Id = Pragma_Default_Scalar_Storage_Order\n-                   and then Ignore_Rep_Clauses)\n+                  and then Ignore_Rep_Clauses)\n       then\n          Rewrite (N, Make_Null_Statement (Sloc (N)));\n          return;"}, {"sha": "6eee24b65d15ebbfdb3223b794a5b69ff6919db3", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -48,10 +49,13 @@ package body Exp_SPARK is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Expand_SPARK_Attribute_Reference (N : Node_Id);\n+   procedure Expand_SPARK_N_Attribute_Reference (N : Node_Id);\n    --  Replace occurrences of System'To_Address by calls to\n    --  System.Storage_Elements.To_Address\n \n+   procedure Expand_SPARK_N_Object_Declaration (N : Node_Id);\n+   --  Perform object declaration-specific expansion\n+\n    procedure Expand_SPARK_N_Object_Renaming_Declaration (N : Node_Id);\n    --  Perform name evaluation for a renamed object\n \n@@ -81,19 +85,16 @@ package body Exp_SPARK is\n          =>\n             Qualify_Entity_Names (N);\n \n-         when N_Expanded_Name\n-            | N_Identifier\n-         =>\n-            Expand_SPARK_Potential_Renaming (N);\n-\n-         when N_Object_Renaming_Declaration =>\n-            Expand_SPARK_N_Object_Renaming_Declaration (N);\n-\n          --  Replace occurrences of System'To_Address by calls to\n          --  System.Storage_Elements.To_Address\n \n          when N_Attribute_Reference =>\n-            Expand_SPARK_Attribute_Reference (N);\n+            Expand_SPARK_N_Attribute_Reference (N);\n+\n+         when N_Expanded_Name\n+            | N_Identifier\n+         =>\n+            Expand_SPARK_Potential_Renaming (N);\n \n          --  Loop iterations over arrays need to be expanded, to avoid getting\n          --  two names referring to the same object in memory (the array and\n@@ -115,18 +116,24 @@ package body Exp_SPARK is\n                end if;\n             end;\n \n+         when N_Object_Declaration =>\n+            Expand_SPARK_N_Object_Declaration (N);\n+\n+         when N_Object_Renaming_Declaration =>\n+            Expand_SPARK_N_Object_Renaming_Declaration (N);\n+\n          --  In SPARK mode, no other constructs require expansion\n \n          when others =>\n             null;\n       end case;\n    end Expand_SPARK;\n \n-   --------------------------------------\n-   -- Expand_SPARK_Attribute_Reference --\n-   --------------------------------------\n+   ----------------------------------------\n+   -- Expand_SPARK_N_Attribute_Reference --\n+   ----------------------------------------\n \n-   procedure Expand_SPARK_Attribute_Reference (N : Node_Id) is\n+   procedure Expand_SPARK_N_Attribute_Reference (N : Node_Id) is\n       Aname   : constant Name_Id      := Attribute_Name (N);\n       Attr_Id : constant Attribute_Id := Get_Attribute_Id (Aname);\n       Loc     : constant Source_Ptr   := Sloc (N);\n@@ -224,7 +231,31 @@ package body Exp_SPARK is\n             end if;\n          end;\n       end if;\n-   end Expand_SPARK_Attribute_Reference;\n+   end Expand_SPARK_N_Attribute_Reference;\n+\n+   ---------------------------------------\n+   -- Expand_SPARK_N_Object_Declaration --\n+   ---------------------------------------\n+\n+   procedure Expand_SPARK_N_Object_Declaration (N : Node_Id) is\n+      Def_Id : constant Entity_Id  := Defining_Identifier (N);\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Typ    : constant Entity_Id  := Etype (Def_Id);\n+\n+   begin\n+      --  If the object declaration denotes a variable without initialization\n+      --  whose type is subject to pragma Default_Initial_Condition, create\n+      --  and analyze a dummy call to the DIC procedure of the type in order\n+      --  to detect potential elaboration issues.\n+\n+      if Comes_From_Source (Def_Id)\n+        and then Has_DIC (Typ)\n+        and then Present (DIC_Procedure (Typ))\n+        and then not Has_Init_Expression (N)\n+      then\n+         Analyze (Build_DIC_Call (Loc, Def_Id, Typ));\n+      end if;\n+   end Expand_SPARK_N_Object_Declaration;\n \n    ------------------------------------------------\n    -- Expand_SPARK_N_Object_Renaming_Declaration --"}, {"sha": "cea58991e65f2f305a3ce1b10f1103f6c5ea8c37", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -297,7 +297,7 @@ begin\n \n    if Should_Ignore_Pragma_Par (Prag_Name)\n      or else (Prag_Id = Pragma_Default_Scalar_Storage_Order\n-                and then Ignore_Rep_Clauses)\n+               and then Ignore_Rep_Clauses)\n    then\n       return Pragma_Node;\n    end if;"}, {"sha": "cfaa8535b384c29921b4ba8b8d49d7174869fdc4", "filename": "gcc/ada/s-excmac-arm.adb", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-arm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-arm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-excmac-arm.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -0,0 +1,42 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . E X C E P T I O N S . M A C H I N E           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2013-2017, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Exceptions.Machine is\n+   function New_Occurrence return GNAT_GCC_Exception_Access is\n+      Res : GNAT_GCC_Exception_Access;\n+   begin\n+      Res := new GNAT_GCC_Exception;\n+      Res.Header.Class := GNAT_Exception_Class;\n+      Res.Header.Unwinder_Cache. Reserved1 := 0;\n+      return Res;\n+   end New_Occurrence;\n+\n+end System.Exceptions.Machine;"}, {"sha": "195d337db1b9b8ba4e9a033142332b4e33af523e", "filename": "gcc/ada/s-excmac-arm.ads", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-excmac-arm.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2013-2017, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -174,13 +174,7 @@ package System.Exceptions.Machine is\n      Ada.Unchecked_Conversion\n      (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n \n-   function New_Occurrence return GNAT_GCC_Exception_Access is\n-      (new GNAT_GCC_Exception'\n-         (Header     => (Class   => GNAT_Exception_Class,\n-                         Unwinder_Cache => (Reserved1 => 0,\n-                                            others => <>),\n-                         others => <>),\n-          Occurrence => <>));\n+   function New_Occurrence return GNAT_GCC_Exception_Access;\n    --  Allocate and initialize a machine occurrence\n \n end System.Exceptions.Machine;"}, {"sha": "7d396514512139304df9717478d95045d5631a1b", "filename": "gcc/ada/s-excmac-gcc.adb", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-excmac-gcc.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -0,0 +1,43 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . E X C E P T I O N S . M A C H I N E           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2013-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Exceptions.Machine is\n+   function New_Occurrence return GNAT_GCC_Exception_Access is\n+      Res : GNAT_GCC_Exception_Access;\n+   begin\n+      Res := new GNAT_GCC_Exception;\n+      Res.Header := (Class   => GNAT_Exception_Class,\n+                     Cleanup => Null_Address,\n+                     others  => 0);\n+      return Res;\n+   end New_Occurrence;\n+\n+end System.Exceptions.Machine;"}, {"sha": "dabf8b68b7493d63a507ca98dbcab7ced70b4d06", "filename": "gcc/ada/s-excmac-gcc.ads", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-gcc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fs-excmac-gcc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-excmac-gcc.ads?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2013-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2013-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -179,12 +179,7 @@ package System.Exceptions.Machine is\n      Ada.Unchecked_Conversion\n        (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n \n-   function New_Occurrence return GNAT_GCC_Exception_Access is\n-      (new GNAT_GCC_Exception'\n-        (Header     => (Class   => GNAT_Exception_Class,\n-                        Cleanup => Null_Address,\n-                        others  => 0),\n-         Occurrence => <>));\n+   function New_Occurrence return GNAT_GCC_Exception_Access;\n    --  Allocate and initialize a machine occurrence\n \n end System.Exceptions.Machine;"}, {"sha": "c78a1310553f00d431bbcc61f09ec7eddd018f16", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -644,12 +644,6 @@ package body Sem_Elab is\n \n       Loc : constant Source_Ptr := Sloc (N);\n \n-      SPARK_Elab_Errors : constant Boolean :=\n-                            SPARK_Mode = On\n-                              and then Dynamic_Elaboration_Checks;\n-      --  Flag set when an entity is called or a variable is read during SPARK\n-      --  dynamic elaboration.\n-\n       Variable_Case : constant Boolean :=\n                         Nkind (N) in N_Has_Entity\n                           and then Present (Entity (N))\n@@ -693,6 +687,14 @@ package body Sem_Elab is\n       --  non-visible unit. This is the scope that is to be investigated to\n       --  see whether an elaboration check is required.\n \n+      Is_DIC : Boolean;\n+      --  Flag set when the subprogram being invoked the procedure generated\n+      --  for pragma Default_Initial_Condition.\n+\n+      SPARK_Elab_Errors : Boolean;\n+      --  Flag set when an entity is called or a variable is read during SPARK\n+      --  dynamic elaboration.\n+\n    --  Start of processing for Check_A_Call\n \n    begin\n@@ -1025,6 +1027,17 @@ package body Sem_Elab is\n          return;\n       end if;\n \n+      --  Determine whether the Default_Initial_Condition procedure of some\n+      --  type is being invoked.\n+\n+      Is_DIC := Ekind (Ent) = E_Procedure and then Is_DIC_Procedure (Ent);\n+\n+      --  Checks related to Default_Initial_Condition fall under the SPARK\n+      --  umbrella because this is a SPARK-specific annotation.\n+\n+      SPARK_Elab_Errors :=\n+        SPARK_Mode = On and (Is_DIC or Dynamic_Elaboration_Checks);\n+\n       --  Now check if an Elaborate_All (or dynamic check) is needed\n \n       if (Elab_Info_Messages or Elab_Warnings or SPARK_Elab_Errors)\n@@ -1080,7 +1093,7 @@ package body Sem_Elab is\n                --  Default_Initial_Condition. This prevents the internal name\n                --  of the procedure from appearing in the error message.\n \n-               if Is_Nontrivial_DIC_Procedure (Ent) then\n+               if Is_DIC then\n                   Error_Msg_N\n                     (\"call to Default_Initial_Condition during elaboration in \"\n                      & \"SPARK\", N);"}, {"sha": "005486e4920e65155287361812908196c483114d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e77e24291b85bcb1ae1c7c48d8194a66ba642974/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e77e24291b85bcb1ae1c7c48d8194a66ba642974", "patch": "@@ -3426,7 +3426,7 @@ package body Sem_Prag is\n    --------------------\n \n    procedure Analyze_Pragma (N : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n \n       Pname : Name_Id := Pragma_Name (N);\n       --  Name of the source pragma, or name of the corresponding aspect for\n@@ -10535,7 +10535,7 @@ package body Sem_Prag is\n \n       if Should_Ignore_Pragma_Sem (N)\n         or else (Prag_Id = Pragma_Default_Scalar_Storage_Order\n-                   and then Ignore_Rep_Clauses)\n+                  and then Ignore_Rep_Clauses)\n       then\n          return;\n       end if;"}]}