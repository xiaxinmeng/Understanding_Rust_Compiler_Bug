{"sha": "cc73528f07789d3453eccd695cc7703755819dad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M3MzUyOGYwNzc4OWQzNDUzZWNjZDY5NWNjNzcwMzc1NTgxOWRhZA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2005-05-04T22:36:14Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-05-04T22:36:14Z"}, "message": "predicates.md: New file.\n\n\t* config/mmix/predicates.md: New file.\n\t* config/mmix/mmix.c (mmix_symbolic_or_address_operand)\n\t(mmix_reg_or_constant_operand, mmix_reg_cc_operand)\n\t(mmix_foldable_comparison_operator, mmix_comparison_operator)\n\t(mmix_reg_or_0_operand, mmix_reg_or_8bit_operand): Remove.\n\t* config/mmix/mmix.h (PREDICATE_CODES, SPECIAL_MODE_PREDICATES):\n\tDon't define.\n\t* config/mmix/mmix.md: Include predicates.md.\n\t(\"call\", \"call_value\"): Force address to register if it isn't a\n\tmmix_symbolic_or_address_operand.\n\nFrom-SVN: r99235", "tree": {"sha": "03a03a8cd0be912065aeed553739dd3eaca9b75a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03a03a8cd0be912065aeed553739dd3eaca9b75a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc73528f07789d3453eccd695cc7703755819dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc73528f07789d3453eccd695cc7703755819dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc73528f07789d3453eccd695cc7703755819dad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc73528f07789d3453eccd695cc7703755819dad/comments", "author": null, "committer": null, "parents": [{"sha": "29572b4dae9eb1605bf7bdbcc9517ca01c5297b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29572b4dae9eb1605bf7bdbcc9517ca01c5297b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29572b4dae9eb1605bf7bdbcc9517ca01c5297b1"}], "stats": {"total": 342, "additions": 188, "deletions": 154}, "files": [{"sha": "eed5263bad1f8462c3341c4851ce04aa3912cf03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc73528f07789d3453eccd695cc7703755819dad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc73528f07789d3453eccd695cc7703755819dad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc73528f07789d3453eccd695cc7703755819dad", "patch": "@@ -1,3 +1,16 @@\n+2005-05-05  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* config/mmix/predicates.md: New file.\n+\t* config/mmix/mmix.c (mmix_symbolic_or_address_operand)\n+\t(mmix_reg_or_constant_operand, mmix_reg_cc_operand)\n+\t(mmix_foldable_comparison_operator, mmix_comparison_operator)\n+\t(mmix_reg_or_0_operand, mmix_reg_or_8bit_operand): Remove.\n+\t* config/mmix/mmix.h (PREDICATE_CODES, SPECIAL_MODE_PREDICATES):\n+\tDon't define.\n+\t* config/mmix/mmix.md: Include predicates.md.\n+\t(\"call\", \"call_value\"): Force address to register if it isn't a\n+\tmmix_symbolic_or_address_operand.\n+\n 2005-05-04  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-flow-inline.h (op_iter_init_use, op_iter_init_def): Assert that"}, {"sha": "15dc69e043e62553e71b2c18cebdec306b5d2b30", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=cc73528f07789d3453eccd695cc7703755819dad", "patch": "@@ -2343,139 +2343,6 @@ mmix_shiftable_wyde_value (unsigned HOST_WIDEST_INT value)\n   return 1;\n }\n \n-/* True if this is an address_operand or a symbolic operand.  */\n-\n-int\n-mmix_symbolic_or_address_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-    case CONST:\n-      op = XEXP (op, 0);\n-      if ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t   || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t  && (GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t      || (GET_CODE (XEXP (op, 1)) == CONST_DOUBLE\n-\t\t  && GET_MODE (XEXP (op, 1)) == VOIDmode)))\n-\treturn 1;\n-      /* Fall through.  */\n-    default:\n-      return address_operand (op, mode);\n-    }\n-}\n-\n-/* True if this is a register or CONST_INT (or CONST_DOUBLE for DImode).\n-   We could narrow the value down with a couple of predicated, but that\n-   doesn't seem to be worth it at the moment.  */\n-\n-int\n-mmix_reg_or_constant_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode)\n-    || (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == VOIDmode)\n-    || GET_CODE (op) == CONST_INT;\n-}\n-\n-/* True if this is a register with a condition-code mode.  */\n-\n-int\n-mmix_reg_cc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  return register_operand (op, mode)\n-    && (mode == CCmode || mode == CC_UNSmode || mode == CC_FPmode\n-\t|| mode == CC_FPEQmode || mode == CC_FUNmode);\n-}\n-\n-/* True if this is a foldable comparison operator\n-   - one where a the result of (compare:CC (reg) (const_int 0)) can be\n-   replaced by (reg).  */\n-\n-int\n-mmix_foldable_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  RTX_CODE code = GET_CODE (op);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode == VOIDmode && COMPARISON_P (op))\n-    mode = GET_MODE (XEXP (op, 0));\n-\n-  return ((mode == CCmode || mode == DImode)\n-\t  && (code == NE || code == EQ || code == GE || code == GT\n-\t      || code == LE))\n-    /* FIXME: This may be a stupid trick.  What happens when GCC wants to\n-       reverse the condition?  Can it do that by itself?  Maybe it can\n-       even reverse the condition to fit a foldable one in the first\n-       place?  */\n-    || (mode == CC_UNSmode && (code == GTU || code == LEU));\n-}\n-\n-/* Like comparison_operator, but only true if this comparison operator is\n-   applied to a valid mode.  Needed to avoid jump.c generating invalid\n-   code with -ffast-math (gcc.dg/20001228-1.c).  */\n-\n-int\n-mmix_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  RTX_CODE code = GET_CODE (op);\n-\n-  /* Comparison operators usually don't have a mode, but let's try and get\n-     one anyway for the day that changes.  */\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  /* Get the mode from the first operand if we don't have one.  */\n-  if (mode == VOIDmode && COMPARISON_P (op))\n-    mode = GET_MODE (XEXP (op, 0));\n-\n-  /* FIXME: This needs to be kept in sync with the tables in\n-     mmix_output_condition.  */\n-  return\n-    (mode == VOIDmode && COMPARISON_P (op))\n-    || (mode == CC_FUNmode\n-\t&& (code == ORDERED || code == UNORDERED))\n-    || (mode == CC_FPmode\n-\t&& (code == GT || code == LT))\n-    || (mode == CC_FPEQmode\n-\t&& (code == NE || code == EQ))\n-    || (mode == CC_UNSmode\n-\t&& (code == GEU || code == GTU || code == LEU || code == LTU))\n-    || (mode == CCmode\n-\t&& (code == NE || code == EQ || code == GE || code == GT\n-\t    || code == LE || code == LT))\n-    || (mode == DImode\n-\t&& (code == NE || code == EQ || code == GE || code == GT\n-\t    || code == LE || code == LT || code == LEU || code == GTU));\n-}\n-\n-/* True if this is a register or 0 (int or float).  */\n-\n-int\n-mmix_reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  /* FIXME: Is mode calculation necessary and correct?  */\n-  return\n-    op == CONST0_RTX (mode == VOIDmode ? GET_MODE (op) : mode)\n-    || register_operand (op, mode);\n-}\n-\n-/* True if this is a register or an int 0..255.  */\n-\n-int\n-mmix_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode)\n-    || (GET_CODE (op) == CONST_INT\n-\t&& CONST_OK_FOR_LETTER_P (INTVAL (op), 'I'));\n-}\n-\n /* Returns zero if code and mode is not a valid condition from a\n    compare-type insn.  Nonzero if it is.  The parameter op, if non-NULL,\n    is the comparison of mode is CC-somethingmode.  */"}, {"sha": "a5feb38fc7a4f600e8abe3ccc770aacfaaf036d9", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=cc73528f07789d3453eccd695cc7703755819dad", "patch": "@@ -964,27 +964,6 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n \n /* Node: Misc */\n \n-#define PREDICATE_CODES\t\t\t\t\\\n- {\"mmix_reg_cc_operand\", {SUBREG, REG}},\t\\\n- {\"mmix_foldable_comparison_operator\",\t\t\\\n-  {NE, EQ, GE, GT, LE, LT}},\t\t\t\\\n- /* All '<', actually.  */\t\t\t\\\n- {\"mmix_comparison_operator\",\t\t\t\\\n-  {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU,\t\\\n-   LTU, UNORDERED, ORDERED, UNEQ, UNGE, UNLE,\t\\\n-   UNLT, LTGT}},\t\t\t\t\\\n- {\"mmix_symbolic_or_address_operand\",\t\t\\\n-  {SYMBOL_REF, LABEL_REF, CONST,\t\t\\\n-   SUBREG, REG, PLUS}},\t\t\t\t\\\n- {\"mmix_reg_or_constant_operand\",\t\t\\\n-  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\t\\\n- {\"mmix_reg_or_8bit_operand\",\t\t\t\\\n-  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\t\\\n- {\"mmix_reg_or_0_operand\",\t\t\t\\\n-  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\n-\n-#define SPECIAL_MODE_PREDICATES \"mmix_symbolic_or_address_operand\",\n-\n /* There's no way to get a PC-relative offset into tables for SImode, so\n    for the moment we have absolute entries in DImode.\n    When we're going ELF, these should be SImode and 1.  */"}, {"sha": "75e1446b4abe8298b416b5c8933c5664dd02541d", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=cc73528f07789d3453eccd695cc7703755819dad", "patch": "@@ -40,7 +40,11 @@\n    (MMIX_rR_REGNUM 260)\n    (MMIX_fp_rO_OFFSET -24)]\n )\n+\f\n+;; Operand and operator predicates.\n \n+(include \"predicates.md\")\n+\f\n ;; FIXME: Can we remove the reg-to-reg for smaller modes?  Shouldn't they\n ;; be synthesized ok?\n (define_insn \"movqi\"\n@@ -1078,6 +1082,16 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"\"\n   \"\n {\n+  /* The caller checks that the operand is generally valid as an\n+     address, but at -O0 nothing makes sure that it's also a valid\n+     call address for a *call*; a mmix_symbolic_or_address_operand.\n+     Force into a register if it isn't.  */\n+  if (!mmix_symbolic_or_address_operand (XEXP (operands[0], 0),\n+\t\t\t\t\t GET_MODE (XEXP (operands[0], 0))))\n+    operands[0]\n+      = replace_equiv_address (operands[0],\n+\t\t\t       force_reg (Pmode, XEXP (operands[0], 0)));\n+\n   /* Since the epilogue 'uses' the return address, and it is clobbered\n      in the call, and we set it back after every call (all but one setting\n      will be optimized away), integrity is maintained.  */\n@@ -1105,6 +1119,16 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n   \"\"\n   \"\n {\n+  /* The caller checks that the operand is generally valid as an\n+     address, but at -O0 nothing makes sure that it's also a valid\n+     call address for a *call*; a mmix_symbolic_or_address_operand.\n+     Force into a register if it isn't.  */\n+  if (!mmix_symbolic_or_address_operand (XEXP (operands[1], 0),\n+\t\t\t\t\t GET_MODE (XEXP (operands[1], 0))))\n+    operands[1]\n+      = replace_equiv_address (operands[1],\n+\t\t\t       force_reg (Pmode, XEXP (operands[1], 0)));\n+\n   /* Since the epilogue 'uses' the return address, and it is clobbered\n      in the call, and we set it back after every call (all but one setting\n      will be optimized away), integrity is maintained.  */"}, {"sha": "c74c561b57d163770aec424b52fd27ce48ffddab", "filename": "gcc/config/mmix/predicates.md", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc73528f07789d3453eccd695cc7703755819dad/gcc%2Fconfig%2Fmmix%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fpredicates.md?ref=cc73528f07789d3453eccd695cc7703755819dad", "patch": "@@ -0,0 +1,151 @@\n+;; Operand and operator predicates for the GCC MMIX port.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street - Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;; True if this is a foldable comparison operator\n+;; - one where a the result of (compare:CC (reg) (const_int 0)) can be\n+;; replaced by (reg).  */\n+\n+(define_predicate \"mmix_foldable_comparison_operator\"\n+  (match_code \"ne, eq, ge, gt, le, lt, gtu, leu\")\n+{\n+  RTX_CODE code = GET_CODE (op);\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  /* This little bit is why the body of this predicate is kept as C.  */\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (XEXP (op, 0));\n+\n+  return ((mode == CCmode || mode == DImode)\n+\t  && (code == NE || code == EQ || code == GE || code == GT\n+\t      || code == LE || code == LT))\n+    /* FIXME: This may be a stupid trick.  What happens when GCC wants to\n+       reverse the condition?  Can it do that by itself?  Maybe it can\n+       even reverse the condition to fit a foldable one in the first\n+       place?  */\n+    || (mode == CC_UNSmode && (code == GTU || code == LEU));\n+})\n+\n+;; Like comparison_operator, but only true if this comparison operator is\n+;; applied to a valid mode.  Needed to avoid jump.c generating invalid\n+;; code with -ffast-math (gcc.dg/20001228-1.c).\n+\n+(define_predicate \"mmix_comparison_operator\"\n+  (match_operand 0 \"comparison_operator\")\n+{\n+  RTX_CODE code = GET_CODE (op);\n+\n+  /* Comparison operators usually don't have a mode, but let's try and get\n+     one anyway for the day that changes.  */\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  /* Get the mode from the first operand if we don't have one.\n+     Also the reason why we do this in C.  */\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (XEXP (op, 0));\n+\n+  /* FIXME: This needs to be kept in sync with the tables in\n+     mmix_output_condition.  */\n+  return\n+    mode == VOIDmode\n+    || (mode == CC_FUNmode\n+\t&& (code == ORDERED || code == UNORDERED))\n+    || (mode == CC_FPmode\n+\t&& (code == GT || code == LT))\n+    || (mode == CC_FPEQmode\n+\t&& (code == NE || code == EQ))\n+    || (mode == CC_UNSmode\n+\t&& (code == GEU || code == GTU || code == LEU || code == LTU))\n+    || (mode == CCmode\n+\t&& (code == NE || code == EQ || code == GE || code == GT\n+\t    || code == LE || code == LT))\n+    || (mode == DImode\n+\t&& (code == NE || code == EQ || code == GE || code == GT\n+\t    || code == LE || code == LT || code == LEU || code == GTU));\n+})\n+\n+;; True if this is a register with a condition-code mode.\n+\n+(define_predicate \"mmix_reg_cc_operand\"\n+  (and (match_operand 0 \"register_operand\")\n+       (ior (match_test \"GET_MODE (op) == CCmode\")\n+\t    (ior (match_test \"GET_MODE (op) == CC_UNSmode\")\n+\t\t (ior (match_test \"GET_MODE (op) == CC_FPmode\")\n+\t\t      (ior (match_test \"GET_MODE (op) == CC_FPEQmode\")\n+\t\t\t   (match_test \"GET_MODE (op) == CC_FUNmode\")))))))\n+\n+;; True if this is an address_operand or a symbolic operand.\n+\n+(define_predicate \"mmix_symbolic_or_address_operand\"\n+  (match_code \"symbol_ref, label_ref, const, subreg, reg, plus\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      /* The reason why this body still is C.  */\n+      op = XEXP (op, 0);\n+      if ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t   || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t  && (GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t      || (GET_CODE (XEXP (op, 1)) == CONST_DOUBLE\n+\t\t  && GET_MODE (XEXP (op, 1)) == VOIDmode)))\n+\treturn 1;\n+      /* Fall through.  */\n+    default:\n+      return address_operand (op, mode);\n+    }\n+})\n+\n+;; True if this is a register or CONST_INT (or CONST_DOUBLE for DImode).\n+;; We could narrow the value down with a couple of predicates, but that\n+;; doesn't seem to be worth it at the moment.\n+\n+(define_predicate \"mmix_reg_or_constant_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (ior (match_code \"const_int\")\n+\t    (and (match_code \"const_double\")\n+\t\t (match_test \"GET_MODE (op) == VOIDmode\")))))\n+\n+;; True if this is a register or 0 (int or float).\n+\n+(define_predicate \"mmix_reg_or_0_operand\"\n+  (ior\n+   (match_operand 0 \"register_operand\")\n+   (ior\n+    (and (match_code \"const_int\")\n+\t (match_test \"op == const0_rtx\"))\n+    (and\n+     (match_code \"const_double\")\n+     ;; FIXME: Is mode calculation necessary and correct?\n+     (match_test\n+      \"op == CONST0_RTX (mode == VOIDmode ? GET_MODE (op) : mode)\")))))\n+\n+;; True if this is a register or an int 0..255.\n+\n+(define_predicate \"mmix_reg_or_8bit_operand\"\n+  (ior\n+   (match_operand 0 \"register_operand\")\n+   (and (match_code \"const_int\")\n+\t(match_test \"CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\"))))"}]}