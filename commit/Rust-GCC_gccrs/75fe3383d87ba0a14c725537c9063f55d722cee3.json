{"sha": "75fe3383d87ba0a14c725537c9063f55d722cee3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVmZTMzODNkODdiYTBhMTRjNzI1NTM3YzkwNjNmNTVkNzIyY2VlMw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-11-01T06:35:14Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-11-01T06:35:14Z"}, "message": "2002-11-01  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/InetAddress.java:\n\t(isAnyLocalAddress): Implemented.\n\t(isLoopbackAddress): Implemented, comment added.\n\t(isLinkLocalAddress): Implemented, documentation added.\n\t(isSiteLocalAddress): Implemented, documentation added.\n\t(isMCGlobal): Implemented, documentation added.\n\t(isMCNodeLocal): Implemented, documentation added.\n\t(isMCLinkLocal): Implemented, documentation added.\n\t(isMCSiteLocal): Implemented, documentation added.\n\t(isMCOrgLocal): Implemented, documentation added.\n\t(getHostName): Documentation added.\n\t(getCanonicalHostName): Implemented, documentation added.\n\t(getAddress): Documentation added.\n\t(hashCode): Documentation added.\n\t(equals): Documentation added.\n\t(toString): Fixed implementation.\n\t(getByAddress): Use Inet4Address and Inet6Address.\n\t(lookup): New linewrap.\n\t(getByName): SecurityManager check added, support Inet4Address and\n\tInet6address, comments added.\n\t(getAllByName): SecurityManager check added, comments added.\n\t* java/net/Inet6Address.java:\n\t(Inet6Address): Initialize parent class with addr instead of null.\n\t* java/net/URL.java\n\t(equals): Documentation added.\n\t(getFile): Documentation added.\n\t(hashCode): Documentation added.\n\t* java/net/natInetAddress.cc:\n\t(aton): Fix IPv6 support.\n\t* java/net/natPlainDatagramSocketImpl.cc:\n\t(peek): Throw PortUnreachableException when suitable.\n\t(peekData): Throw PortUnreachableException when suitable.\n\t(send): Throw PortUnreachableException when suitable.\n\t(receive): Throw PortUnreachableException when suitable.\n\nFrom-SVN: r58704", "tree": {"sha": "00c1b0bb5e071e381adfac0ddb73e98486330d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00c1b0bb5e071e381adfac0ddb73e98486330d14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75fe3383d87ba0a14c725537c9063f55d722cee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fe3383d87ba0a14c725537c9063f55d722cee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75fe3383d87ba0a14c725537c9063f55d722cee3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fe3383d87ba0a14c725537c9063f55d722cee3/comments", "author": null, "committer": null, "parents": [{"sha": "04c7481ed28b3b2767735bd32bf44c01df3433e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c7481ed28b3b2767735bd32bf44c01df3433e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04c7481ed28b3b2767735bd32bf44c01df3433e2"}], "stats": {"total": 245, "additions": 215, "deletions": 30}, "files": [{"sha": "8d04a293ba96ab1ef22d3908176739de2dc32451", "filename": "libjava/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=75fe3383d87ba0a14c725537c9063f55d722cee3", "patch": "@@ -1,3 +1,40 @@\n+2002-11-01  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/InetAddress.java:\n+\t(isAnyLocalAddress): Implemented.\n+\t(isLoopbackAddress): Implemented, comment added.\n+\t(isLinkLocalAddress): Implemented, documentation added.\n+\t(isSiteLocalAddress): Implemented, documentation added.\n+\t(isMCGlobal): Implemented, documentation added.\n+\t(isMCNodeLocal): Implemented, documentation added.\n+\t(isMCLinkLocal): Implemented, documentation added.\n+\t(isMCSiteLocal): Implemented, documentation added.\n+\t(isMCOrgLocal): Implemented, documentation added.\n+\t(getHostName): Documentation added.\n+\t(getCanonicalHostName): Implemented, documentation added.\n+\t(getAddress): Documentation added.\n+\t(hashCode): Documentation added.\n+\t(equals): Documentation added.\n+\t(toString): Fixed implementation.\n+\t(getByAddress): Use Inet4Address and Inet6Address.\n+\t(lookup): New linewrap.\n+\t(getByName): SecurityManager check added, support Inet4Address and\n+\tInet6address, comments added.\n+\t(getAllByName): SecurityManager check added, comments added.\n+\t* java/net/Inet6Address.java:\n+\t(Inet6Address): Initialize parent class with addr instead of null.\n+\t* java/net/URL.java\n+\t(equals): Documentation added.\n+\t(getFile): Documentation added.\n+\t(hashCode): Documentation added.\n+\t* java/net/natInetAddress.cc:\n+\t(aton): Fix IPv6 support.\n+\t* java/net/natPlainDatagramSocketImpl.cc:\n+\t(peek): Throw PortUnreachableException when suitable.\n+\t(peekData): Throw PortUnreachableException when suitable.\n+\t(send): Throw PortUnreachableException when suitable.\n+\t(receive): Throw PortUnreachableException when suitable.\n+\n 2002-10-27  Mark Wielaard  <mark@klomp.org>\n \n \t* java/util/zip/ZipFile.java (readLeShort): Take and use DataInput as"}, {"sha": "8d3c0c3af4465172dc5217211a2e505781797c84", "filename": "libjava/java/net/Inet6Address.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FInet6Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FInet6Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInet6Address.java?ref=75fe3383d87ba0a14c725537c9063f55d722cee3", "patch": "@@ -67,7 +67,7 @@ public final class Inet6Address extends InetAddress\n    */\n   protected Inet6Address (byte[] addr, String host)\n   {\n-    super (null, host);\n+    super (addr, host);\n     this.ipaddress = addr;\n   }\n "}, {"sha": "c15c0f6dc412c460d81b5c3890690c4f8505d53f", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 158, "deletions": 28, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=75fe3383d87ba0a14c725537c9063f55d722cee3", "patch": "@@ -113,8 +113,9 @@ public boolean isMulticastAddress ()\n    */\n   public boolean isAnyLocalAddress ()\n   {\n-    // FIXME: implement this\n-    return false;\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+    return addr == zeros;\n   }\n \n   /**\n@@ -124,89 +125,169 @@ public boolean isAnyLocalAddress ()\n    */\n   public boolean isLoopbackAddress ()\n   {\n-    // FIXME: implement this\n-    return addr [0] == 0x7F;\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+    \n+    return addr[0] == 0x7F;\n   }\n \n   /**\n+   * Utility routine to check if InetAddress is a link local address\n+   * \n    * @since 1.4\n    */\n   public boolean isLinkLocalAddress ()\n   {\n-    // FIXME: implement this\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+\n+    // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n+   * Utility routine to check if InetAddress is a site local address\n+   * \n    * @since 1.4\n    */\n   public boolean isSiteLocalAddress ()\n   {\n-    // FIXME: implement this\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+\n+    // 10.0.0.0/8\n+    if (addr[0] == 0x0A)\n+      return true;\n+\n+    // XXX: Suns JDK 1.4.1 (on Linux) seems to have a bug here:\n+    // it says 172.16.0.0 - 172.255.255.255 are site local addresses\n+\n+    // 172.16.0.0/12\n+    if (addr[0] == 0xAC && (addr[1] & 0xF0) == 0x01)\n+      return true;\n+\n+    // 192.168.0.0/16\n+    if (addr[0] == 0xC0 && addr[1] == 0xA8)\n+      return true;\n+\n+    // XXX: Do we need to check more addresses here ?\n     return false;\n   }\n \n   /**\n+   * Utility routine to check if InetAddress is a global multicast address\n+   * \n    * @since 1.4\n    */\n   public boolean isMCGlobal ()\n   {\n-    // FIXME: implement this\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+\n+    // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n+   * Utility reoutine to check if InetAddress is a node local multicast address\n+   * \n    * @since 1.4\n    */\n   public boolean isMCNodeLocal ()\n   {\n-    // FIXME: implement this\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+\n+    // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n+   * Utility reoutine to check if InetAddress is a link local multicast address\n+   * \n    * @since 1.4\n    */\n   public boolean isMCLinkLocal ()\n   {\n-    // FIXME: implement this\n-    return false;\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+    \n+    if (!isMulticastAddress ())\n+      return false;\n+\n+    return (addr[0] == 0xE0\n+\t    && addr[1] == 0x00\n+\t    && addr[2] == 0x00);\n   }\n \n   /**\n+   * Utility reoutine to check if InetAddress is a site local multicast address\n+   *\n    * @since 1.4\n    */\n   public boolean isMCSiteLocal ()\n   {\n-    // FIXME: implement this\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+\n+    // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n+   * Utility reoutine to check if InetAddress is a organization local\n+   * multicast address\n+   * \n    * @since 1.4\n    */\n   public boolean isMCOrgLocal ()\n   {\n-    // FIXME: implement this\n+    // This is the IPv4 implementation.\n+    // Any class derived from InetAddress should override this.\n+\n+    // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n+  /**\n+   * Returns the hostname represented by this InetAddress\n+   */\n   public String getHostName ()\n   {\n     if (hostName == null)\n       lookup (null, this, false);\n+\n     return hostName;\n   }\n \n   /**\n+   * Returns the canonical hostname represented by this InetAddress\n+   * \n    * @since 1.4\n    */\n   public String getCanonicalHostName ()\n   {\n-    // FIXME: implement this\n-    return \"\";\n+    SecurityManager sm = System.getSecurityManager ();\n+    if (sm != null)\n+      {\n+        try\n+\t  {\n+            sm.checkConnect (hostName, -1);\n+\t  }\n+\tcatch (SecurityException e)\n+\t  {\n+\t    return getHostAddress ();\n+\t  }\n+      }\n+\n+    // Try to find the FDQN now\n+    InetAddress address = new InetAddress (getAddress (), null);\n+    return address.getHostName ();\n   }\n \n+  /**\n+   * Returns the IP address of this InetAddress as array of bytes\n+   */\n   public byte[] getAddress ()\n   {\n     // An experiment shows that JDK1.2 returns a different byte array each\n@@ -284,9 +365,13 @@ else if (i > 0)\n \t  break;\n \tsbuf.append('.');\n       }\n+    \n     return sbuf.toString();\n   }\n \n+  /**\n+   * Returns a hashcode of the InetAddress\n+   */\n   public int hashCode()\n   {\n     // There hashing algorithm is not specified, but a simple experiment\n@@ -299,6 +384,9 @@ public int hashCode()\n     return hash;\n   }\n \n+  /**\n+   * Compares the InetAddress object with another one.\n+   */\n   public boolean equals (Object obj)\n   {\n     if (obj == null || ! (obj instanceof InetAddress))\n@@ -325,7 +413,12 @@ public boolean equals (Object obj)\n    */\n   public String toString()\n   {\n-    return getHostName()+'/'+getHostAddress();\n+    String hostname = getHostName ();\n+\n+    if (hostname == \"\")\n+      hostname = getHostAddress ();\n+    \n+    return hostname + '/' + getHostAddress ();\n   }\n \n   /**\n@@ -346,7 +439,10 @@ public static InetAddress getByAddress(byte[] addr)\n     if (addr.length != 4 && addr.length != 16)\n       throw new UnknownHostException (\"IP address has illegal length\");\n \n-    return new InetAddress (addr, \"\");\n+    if (addr.length == 4)\n+      return new Inet4Address (addr, null);\n+      \n+    return new Inet6Address (addr, null);\n   }\n \n   /**\n@@ -376,8 +472,8 @@ public static InetAddress getByAddress (String host, byte[] addr)\n    * Otherwise, return null. */\n   private static native byte[] aton (String host);\n \n-  private static native InetAddress[] lookup\n-  (String hostname, InetAddress addr, boolean all);\n+  private static native InetAddress[] lookup (String hostname,\n+\t\t                              InetAddress addr, boolean all);\n \n   /**\n    * Determines the IP address of a host, given the host's name.\n@@ -387,17 +483,43 @@ public static InetAddress getByAddress (String host, byte[] addr)\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    */\n-  public static InetAddress getByName (String host)\n+  public static InetAddress getByName (String hostname)\n     throws UnknownHostException\n   {\n-    if (host == null)\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkConnect (hostname, -1);\n+   \n+    // Default to current host if necessary\n+    if (hostname == null)\n       return getLocalHost();\n-    byte[] address = aton(host);\n+\n+    // Assume that the host string is an IP address\n+    byte[] address = aton (hostname);\n     if (address != null)\n-      return new InetAddress(address, null);\n-    InetAddress iaddr = new InetAddress(null, host);\n-    lookup(host, iaddr, false);\n-    return iaddr;\n+      {\n+        if (address.length == 4)\n+          return new Inet4Address (address, null);\n+        else if (address.length == 16)\n+          {\n+\t    if ((address[10] == 0xFF) && (address[11] == 0xFF))\n+\t      {\n+\t\tbyte[] ip4addr = new byte[4];\n+\t\tip4addr[0] = address[12];\n+\t\tip4addr[1] = address[13];\n+\t\tip4addr[2] = address[14];\n+\t\tip4addr[3] = address[15];\n+\t\treturn new Inet4Address (ip4addr, null);\n+\t      }\n+            return new Inet6Address (address, null);\n+\t  }\n+\telse\n+          throw new UnknownHostException (\"Address has invalid length\");\n+      }\n+   \n+    // Try to resolve the host by DNS\n+    InetAddress[] addresses = getAllByName (hostname);\n+    return addresses[0];\n   }\n \n   /**\n@@ -409,20 +531,28 @@ public static InetAddress getByName (String host)\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    */\n-  public static InetAddress[] getAllByName (String host)\n+  public static InetAddress[] getAllByName (String hostname)\n     throws UnknownHostException\n   {\n-    byte[] address = aton(host);\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkConnect(hostname, -1);\n+\n+    // Check if hostname is an IP address\n+    byte[] address = aton (hostname);\n     if (address != null)\n       {\n \tInetAddress[] result = new InetAddress[1];\n \tresult[0] = new InetAddress(address, null);\n \treturn result;\n       }\n-    return lookup(host, null, true);\n+   \n+    // Try to resolve the hostname by DNS\n+    return lookup (hostname, null, true);\n   }\n \n   static final byte[] zeros = {0,0,0,0};\n+  \n   /* dummy InetAddress, used to bind socket to any (all) network interfaces */\n   static final InetAddress ANY_IF = new InetAddress(zeros, null);\n     "}, {"sha": "00dad2c78717a12ea9cc4df37e169585b3ee94b3", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=75fe3383d87ba0a14c725537c9063f55d722cee3", "patch": "@@ -254,6 +254,9 @@ else if (context != null)\n     hashCode = hashCode();\t\t\t// Used for serialization.\n   }\n \n+  /**\n+   * Checks if two URLs are equal\n+   */\n   public boolean equals(Object obj)\n   {\n     if (obj == null || ! (obj instanceof URL))\n@@ -287,6 +290,9 @@ public final Object getContent (Class[] classes) throws IOException\n     return getContent();\n   }\n \n+  /**\n+   * Returns the file of the URL\n+   */\n   public String getFile()\n   {\n     return file;\n@@ -367,6 +373,9 @@ public String getQuery ()\n     return query;\n   }\n \n+  /**\n+   * Returns a hashcode computed by the URLStreamHandler of this URL\n+   */\n   public int hashCode()\n   {\n     // JCL book says this is computed using (only) the hashcodes of the "}, {"sha": "c0083714287b44ac30bff698ddd52109daf7e501", "filename": "libjava/java/net/natInetAddress.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=75fe3383d87ba0a14c725537c9063f55d722cee3", "patch": "@@ -121,7 +121,7 @@ java::net::InetAddress::aton (jstring host)\n #endif\n #if defined (HAVE_INET_PTON) && defined (HAVE_INET6)\n   char inet6_addr[16];\n-  if (len == 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n+  if (len != 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n     {\n       bytes = inet6_addr;\n       blen = 16;"}, {"sha": "60b25d22bfad3c087e2179e07ef4fd494bb1c05b", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe3383d87ba0a14c725537c9063f55d722cee3/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=75fe3383d87ba0a14c725537c9063f55d722cee3", "patch": "@@ -65,6 +65,7 @@ _Jv_bind (int fd, struct sockaddr *addr, int addrlen)\n #include <java/net/InetAddress.h>\n #include <java/net/NetworkInterface.h>\n #include <java/net/DatagramPacket.h>\n+#include <java/net/PortUnreachableException.h>\n #include <java/lang/InternalError.h>\n #include <java/lang/Object.h>\n #include <java/lang/Boolean.h>\n@@ -328,6 +329,8 @@ java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n   return rport;\n  error:\n   char* strerr = strerror (errno);\n+  if (errno == ECONNREFUSED)\n+    throw new PortUnreachableException (JvNewStringUTF (strerr));\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n }\n \n@@ -390,6 +393,8 @@ java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *p)\n   return rport;\n  error:\n   char* strerr = strerror (errno);\n+  if (errno == ECONNREFUSED)\n+    throw new PortUnreachableException (JvNewStringUTF (strerr));\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n }\n \n@@ -441,6 +446,8 @@ java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *p)\n     return;\n \n   char* strerr = strerror (errno);\n+  if (errno == ECONNREFUSED)\n+    throw new PortUnreachableException (JvNewStringUTF (strerr));\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n }\n \n@@ -503,6 +510,8 @@ java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n   return;\n  error:\n   char* strerr = strerror (errno);\n+  if (errno == ECONNREFUSED)\n+    throw new PortUnreachableException (JvNewStringUTF (strerr));\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n }\n "}]}