{"sha": "938bba616d438fadf604fdea50395d3fe356ef72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM4YmJhNjE2ZDQzOGZhZGY2MDRmZGVhNTAzOTVkM2ZlMzU2ZWY3Mg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-10-30T12:01:45Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-10-30T12:01:45Z"}, "message": "IPA ICF: remove dead code\n\n2019-10-30  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-icf-gimple.c (func_checker::compare_ssa_name): Call\n\tcompare_operand.\n\t(func_checker::compare_memory_operand): Remove.\n\t(func_checker::compare_cst_or_decl): Remove.\n\t(func_checker::operand_equal_valueize): Do not handle\n\tFIELD_DECL.\n\t(func_checker::compare_gimple_call): Call compare_operand.\n\t(func_checker::compare_gimple_assign): Likewise.\n\t* ipa-icf-gimple.h: Remove compare_cst_or_decl.\n\t* ipa-icf.c (sem_function::icf_handled_component_p): Remove.\n\t* ipa-icf.h (icf_handled_component_p): Remove.\n\nFrom-SVN: r277616", "tree": {"sha": "577c4b6a23cc84966663c84be43693c50758fe0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577c4b6a23cc84966663c84be43693c50758fe0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/938bba616d438fadf604fdea50395d3fe356ef72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938bba616d438fadf604fdea50395d3fe356ef72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/938bba616d438fadf604fdea50395d3fe356ef72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938bba616d438fadf604fdea50395d3fe356ef72/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c"}], "stats": {"total": 178, "additions": 18, "deletions": 160}, "files": [{"sha": "ec1002176be42d1c8294e163c5a1109f57e34ca2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=938bba616d438fadf604fdea50395d3fe356ef72", "patch": "@@ -1,3 +1,17 @@\n+2019-10-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf-gimple.c (func_checker::compare_ssa_name): Call\n+\tcompare_operand.\n+\t(func_checker::compare_memory_operand): Remove.\n+\t(func_checker::compare_cst_or_decl): Remove.\n+\t(func_checker::operand_equal_valueize): Do not handle\n+\tFIELD_DECL.\n+\t(func_checker::compare_gimple_call): Call compare_operand.\n+\t(func_checker::compare_gimple_assign): Likewise.\n+\t* ipa-icf-gimple.h: Remove compare_cst_or_decl.\n+\t* ipa-icf.c (sem_function::icf_handled_component_p): Remove.\n+\t* ipa-icf.h (icf_handled_component_p): Remove.\n+\n 2019-10-30  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-icf-gimple.c (func_checker::hash_operand): New."}, {"sha": "f4e9a75b9debf8aa686108736b5bc2a5e713b8e5", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 4, "deletions": 142, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=938bba616d438fadf604fdea50395d3fe356ef72", "patch": "@@ -111,13 +111,7 @@ func_checker::compare_ssa_name (tree t1, tree t2)\n       tree b1 = SSA_NAME_VAR (t1);\n       tree b2 = SSA_NAME_VAR (t2);\n \n-      if (b1 == NULL && b2 == NULL)\n-\treturn true;\n-\n-      if (b1 == NULL || b2 == NULL || TREE_CODE (b1) != TREE_CODE (b2))\n-\treturn return_false ();\n-\n-      return compare_cst_or_decl (b1, b2);\n+      return compare_operand (b1, b2);\n     }\n \n   return true;\n@@ -247,80 +241,6 @@ func_checker::compatible_types_p (tree t1, tree t2)\n   return true;\n }\n \n-/* Function compare for equality given memory operands T1 and T2.  */\n-\n-bool\n-func_checker::compare_memory_operand (tree t1, tree t2)\n-{\n-  if (!t1 && !t2)\n-    return true;\n-  else if (!t1 || !t2)\n-    return false;\n-\n-  ao_ref r1, r2;\n-  ao_ref_init (&r1, t1);\n-  ao_ref_init (&r2, t2);\n-\n-  tree b1 = ao_ref_base (&r1);\n-  tree b2 = ao_ref_base (&r2);\n-\n-  bool source_is_memop = DECL_P (b1) || INDIRECT_REF_P (b1)\n-\t\t\t || TREE_CODE (b1) == MEM_REF\n-\t\t\t || TREE_CODE (b1) == TARGET_MEM_REF;\n-\n-  bool target_is_memop = DECL_P (b2) || INDIRECT_REF_P (b2)\n-\t\t\t || TREE_CODE (b2) == MEM_REF\n-\t\t\t || TREE_CODE (b2) == TARGET_MEM_REF;\n-\n-  /* Compare alias sets for memory operands.  */\n-  if (source_is_memop && target_is_memop)\n-    {\n-      if (TREE_THIS_VOLATILE (t1) != TREE_THIS_VOLATILE (t2))\n-\treturn return_false_with_msg (\"different operand volatility\");\n-\n-      if (ao_ref_alias_set (&r1) != ao_ref_alias_set (&r2)\n-\t  || ao_ref_base_alias_set (&r1) != ao_ref_base_alias_set (&r2))\n-\treturn return_false_with_msg (\"ao alias sets are different\");\n-\n-      /* We can't simply use get_object_alignment_1 on the full\n-         reference as for accesses with variable indexes this reports\n-\t too conservative alignment.  We also can't use the ao_ref_base\n-\t base objects as ao_ref_base happily strips MEM_REFs around\n-\t decls even though that may carry alignment info.  */\n-      b1 = t1;\n-      while (handled_component_p (b1))\n-\tb1 = TREE_OPERAND (b1, 0);\n-      b2 = t2;\n-      while (handled_component_p (b2))\n-\tb2 = TREE_OPERAND (b2, 0);\n-      unsigned int align1, align2;\n-      unsigned HOST_WIDE_INT tem;\n-      get_object_alignment_1 (b1, &align1, &tem);\n-      get_object_alignment_1 (b2, &align2, &tem);\n-      if (align1 != align2)\n-\treturn return_false_with_msg (\"different access alignment\");\n-\n-      /* Similarly we have to compare dependence info where equality\n-         tells us we are safe (even some unequal values would be safe\n-\t but then we have to maintain a map of bases and cliques).  */\n-      unsigned short clique1 = 0, base1 = 0, clique2 = 0, base2 = 0;\n-      if (TREE_CODE (b1) == MEM_REF)\n-\t{\n-\t  clique1 = MR_DEPENDENCE_CLIQUE (b1);\n-\t  base1 = MR_DEPENDENCE_BASE (b1);\n-\t}\n-      if (TREE_CODE (b2) == MEM_REF)\n-\t{\n-\t  clique2 = MR_DEPENDENCE_CLIQUE (b2);\n-\t  base2 = MR_DEPENDENCE_BASE (b2);\n-\t}\n-      if (clique1 != clique2 || base1 != base2)\n-\treturn return_false_with_msg (\"different dependence info\");\n-    }\n-\n-  return compare_operand (t1, t2);\n-}\n-\n /* Function compare for equality given trees T1 and T2 which\n    can be either a constant or a declaration type.  */\n \n@@ -352,52 +272,6 @@ func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n   return operand_compare::hash_operand (arg, hstate, flags);\n }\n \n-bool\n-func_checker::compare_cst_or_decl (tree t1, tree t2)\n-{\n-  bool ret;\n-\n-  switch (TREE_CODE (t1))\n-    {\n-    case INTEGER_CST:\n-    case COMPLEX_CST:\n-    case VECTOR_CST:\n-    case STRING_CST:\n-    case REAL_CST:\n-      {\n-\tret = compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t      && operand_equal_p (t1, t2, OEP_ONLY_CONST);\n-\treturn return_with_debug (ret);\n-      }\n-    case FUNCTION_DECL:\n-      /* All function decls are in the symbol table and known to match\n-\t before we start comparing bodies.  */\n-      return true;\n-    case VAR_DECL:\n-      return return_with_debug (compare_variable_decl (t1, t2));\n-    case LABEL_DECL:\n-      {\n-\tif (t1 == t2)\n-\t  return true;\n-\n-\tint *bb1 = m_label_bb_map.get (t1);\n-\tint *bb2 = m_label_bb_map.get (t2);\n-\n-\t/* Labels can point to another function (non-local GOTOs).  */\n-\treturn return_with_debug (bb1 != NULL && bb2 != NULL && *bb1 == *bb2);\n-      }\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case CONST_DECL:\n-      {\n-\tret = compare_decl (t1, t2);\n-\treturn return_with_debug (ret);\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n bool\n func_checker::operand_equal_p (const_tree t1, const_tree t2,\n \t\t\t       unsigned int flags)\n@@ -439,18 +313,6 @@ func_checker::operand_equal_p (const_tree t1, const_tree t2,\n       return compare_decl (tree1, tree2);\n     case SSA_NAME:\n       return compare_ssa_name (tree1, tree2);\n-    case FIELD_DECL:\n-      {\n-\ttree offset1 = DECL_FIELD_OFFSET (t1);\n-\ttree offset2 = DECL_FIELD_OFFSET (t2);\n-\n-\ttree bit_offset1 = DECL_FIELD_BIT_OFFSET (t1);\n-\ttree bit_offset2 = DECL_FIELD_BIT_OFFSET (t2);\n-\n-\tbool ret = (compare_operand (offset1, offset2)\n-\t\t    && compare_operand (bit_offset1, bit_offset2));\n-\treturn return_with_debug (ret);\n-      }\n     default:\n       break;\n     }\n@@ -749,15 +611,15 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n       t1 = gimple_call_arg (s1, i);\n       t2 = gimple_call_arg (s2, i);\n \n-      if (!compare_memory_operand (t1, t2))\n+      if (!compare_operand (t1, t2))\n \treturn return_false_with_msg (\"memory operands are different\");\n     }\n \n   /* Return value checking.  */\n   t1 = gimple_get_lhs (s1);\n   t2 = gimple_get_lhs (s2);\n \n-  return compare_memory_operand (t1, t2);\n+  return compare_operand (t1, t2);\n }\n \n \n@@ -788,7 +650,7 @@ func_checker::compare_gimple_assign (gimple *s1, gimple *s2)\n       arg1 = gimple_op (s1, i);\n       arg2 = gimple_op (s2, i);\n \n-      if (!compare_memory_operand (arg1, arg2))\n+      if (!compare_operand (arg1, arg2))\n \treturn return_false_with_msg (\"memory operands are different\");\n     }\n "}, {"sha": "9118f895e922d9e5ed563b2398ac0b7cc5bccc0e", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=938bba616d438fadf604fdea50395d3fe356ef72", "patch": "@@ -197,10 +197,6 @@ class func_checker : operand_compare\n   /* Function compare for equality given memory operands T1 and T2.  */\n   bool compare_memory_operand (tree t1, tree t2);\n \n-  /* Function compare for equality given trees T1 and T2 which\n-     can be either a constant or a declaration type.  */\n-  bool compare_cst_or_decl (tree t1, tree t2);\n-\n   /* Function responsible for comparison of various operands T1 and T2.\n      If these components, from functions FUNC1 and FUNC2, are equal, true\n      is returned.  */"}, {"sha": "ec3bd4183aa6c64aead7bc1bd745e7319c6d449d", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=938bba616d438fadf604fdea50395d3fe356ef72", "patch": "@@ -1742,17 +1742,6 @@ sem_function::compare_phi_node (basic_block bb1, basic_block bb2)\n   return true;\n }\n \n-/* Returns true if tree T can be compared as a handled component.  */\n-\n-bool\n-sem_function::icf_handled_component_p (tree t)\n-{\n-  tree_code tc = TREE_CODE (t);\n-\n-  return (handled_component_p (t)\n-\t  || tc == ADDR_EXPR || tc == MEM_REF || tc == OBJ_TYPE_REF);\n-}\n-\n /* Basic blocks dictionary BB_DICT returns true if SOURCE index BB\n    corresponds to TARGET.  */\n "}, {"sha": "0b99a6120168930a967c158c0dce289fcb19c6ca", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938bba616d438fadf604fdea50395d3fe356ef72/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=938bba616d438fadf604fdea50395d3fe356ef72", "patch": "@@ -404,9 +404,6 @@ class sem_function: public sem_item\n   /* Processes function equality comparison.  */\n   bool equals_private (sem_item *item);\n \n-  /* Returns true if tree T can be compared as a handled component.  */\n-  static bool icf_handled_component_p (tree t);\n-\n   /* Function checker stores binding between functions.   */\n   ipa_icf_gimple::func_checker *m_checker;\n "}]}