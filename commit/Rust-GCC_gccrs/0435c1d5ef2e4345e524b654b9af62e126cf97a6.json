{"sha": "0435c1d5ef2e4345e524b654b9af62e126cf97a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQzNWMxZDVlZjJlNDM0NWU1MjRiNjU0YjlhZjYyZTEyNmNmOTdhNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2007-07-05T08:30:24Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-07-05T08:30:24Z"}, "message": "dwarf2out.c (dw_ranges_by_label_ref): New typedef.\n\n* dwarf2out.c (dw_ranges_by_label_ref): New typedef.\n(dw_ranges_struct): Rename block_num to num.  Adjust.\n(dw_ranges_by_label_struct): New.\n(ranges_by_label, ranges_by_label_allocated,\nranges_by_label_in_use): New variables.\n(add_ranges_num): Factored most of the code out of...\n(add_ranges): ... this one.  Rewrite in terms of the former.\n(add_ranges_by_labels): New.\n(output_ranges): Output by-label ranges.\n(dwarf2out_finish): Output range for multiple-section\ncompile_unit.  Output standard DW_AT_low_pc in addition to\nunexpected DW_AT_entry_pc.\n\nFrom-SVN: r126357", "tree": {"sha": "8dd7f5411d82c990abdbdd956561ff88db8bf486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dd7f5411d82c990abdbdd956561ff88db8bf486"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0435c1d5ef2e4345e524b654b9af62e126cf97a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435c1d5ef2e4345e524b654b9af62e126cf97a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0435c1d5ef2e4345e524b654b9af62e126cf97a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435c1d5ef2e4345e524b654b9af62e126cf97a6/comments", "author": null, "committer": null, "parents": [{"sha": "67de26d7554de52b2d406903eefa5c4fbbc171d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67de26d7554de52b2d406903eefa5c4fbbc171d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67de26d7554de52b2d406903eefa5c4fbbc171d2"}], "stats": {"total": 163, "additions": 150, "deletions": 13}, "files": [{"sha": "3ee94b146733b548bfb845720698fa6c80bf92ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435c1d5ef2e4345e524b654b9af62e126cf97a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435c1d5ef2e4345e524b654b9af62e126cf97a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0435c1d5ef2e4345e524b654b9af62e126cf97a6", "patch": "@@ -1,3 +1,18 @@\n+2007-07-05  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* dwarf2out.c (dw_ranges_by_label_ref): New typedef.\n+\t(dw_ranges_struct): Rename block_num to num.  Adjust.\n+\t(dw_ranges_by_label_struct): New.\n+\t(ranges_by_label, ranges_by_label_allocated,\n+\tranges_by_label_in_use): New variables.\n+\t(add_ranges_num): Factored most of the code out of...\n+\t(add_ranges): ... this one.  Rewrite in terms of the former.\n+\t(add_ranges_by_labels): New.\n+\t(output_ranges): Output by-label ranges.\n+\t(dwarf2out_finish): Output range for multiple-section\n+\tcompile_unit.  Output standard DW_AT_low_pc in addition to\n+\tunexpected DW_AT_entry_pc.\n+\n 2007-07-04  Daniel Berlin  <dberlin@dberlin.org>\n \n \tPR tree-optimization/32604"}, {"sha": "a54e517dc219741f0bb7b070aadb11ff8f0bf66e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 135, "deletions": 13, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435c1d5ef2e4345e524b654b9af62e126cf97a6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435c1d5ef2e4345e524b654b9af62e126cf97a6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0435c1d5ef2e4345e524b654b9af62e126cf97a6", "patch": "@@ -3715,6 +3715,7 @@ typedef struct dw_line_info_struct *dw_line_info_ref;\n typedef struct dw_separate_line_info_struct *dw_separate_line_info_ref;\n typedef struct pubname_struct *pubname_ref;\n typedef struct dw_ranges_struct *dw_ranges_ref;\n+typedef struct dw_ranges_by_label_struct *dw_ranges_by_label_ref;\n \n /* Each entry in the line_info_table maintains the file and\n    line number associated with the label generated for that\n@@ -3797,7 +3798,15 @@ DEF_VEC_ALLOC_O(pubname_entry, gc);\n \n struct dw_ranges_struct GTY(())\n {\n-  int block_num;\n+  /* If this is positive, it's a block number, otherwise it's a\n+     bitwise-negated index into dw_ranges_by_label.  */\n+  int num;\n+};\n+\n+struct dw_ranges_by_label_struct GTY(())\n+{\n+  const char *begin;\n+  const char *end;\n };\n \n /* The limbo die list structure.  */\n@@ -4004,6 +4013,16 @@ static GTY(()) unsigned ranges_table_allocated;\n /* Number of elements in ranges_table currently in use.  */\n static GTY(()) unsigned ranges_table_in_use;\n \n+/* Array of pairs of labels referenced in ranges_table.  */\n+static GTY ((length (\"ranges_by_label_allocated\")))\n+     dw_ranges_by_label_ref ranges_by_label;\n+\n+/* Number of elements currently allocated for ranges_by_label.  */\n+static GTY(()) unsigned ranges_by_label_allocated;\n+\n+/* Number of elements in ranges_by_label currently in use.  */\n+static GTY(()) unsigned ranges_by_label_in_use;\n+\n /* Size (in elements) of increments by which we may expand the\n    ranges_table.  */\n #define RANGES_TABLE_INCREMENT 64\n@@ -4160,7 +4179,9 @@ static void add_pubtype (tree, dw_die_ref);\n static void output_pubnames (VEC (pubname_entry,gc) *);\n static void add_arange (tree, dw_die_ref);\n static void output_aranges (void);\n+static unsigned int add_ranges_num (int);\n static unsigned int add_ranges (tree);\n+static unsigned int add_ranges_by_labels (const char *, const char *);\n static void output_ranges (void);\n static void output_line_info (void);\n static void output_file_names (void);\n@@ -7570,7 +7591,7 @@ output_aranges (void)\n    was placed.  */\n \n static unsigned int\n-add_ranges (tree block)\n+add_ranges_num (int num)\n {\n   unsigned int in_use = ranges_table_in_use;\n \n@@ -7584,12 +7605,48 @@ add_ranges (tree block)\n \t      RANGES_TABLE_INCREMENT * sizeof (struct dw_ranges_struct));\n     }\n \n-  ranges_table[in_use].block_num = (block ? BLOCK_NUMBER (block) : 0);\n+  ranges_table[in_use].num = num;\n   ranges_table_in_use = in_use + 1;\n \n   return in_use * 2 * DWARF2_ADDR_SIZE;\n }\n \n+/* Add a new entry to .debug_ranges corresponding to a block, or a\n+   range terminator if BLOCK is NULL.  */\n+\n+static unsigned int\n+add_ranges (tree block)\n+{\n+  return add_ranges_num (block ? BLOCK_NUMBER (block) : 0);\n+}\n+\n+/* Add a new entry to .debug_ranges corresponding to a pair of\n+   labels.  */\n+\n+static unsigned int\n+add_ranges_by_labels (const char *begin, const char *end)\n+{\n+  unsigned int in_use = ranges_by_label_in_use;\n+\n+  if (in_use == ranges_by_label_allocated)\n+    {\n+      ranges_by_label_allocated += RANGES_TABLE_INCREMENT;\n+      ranges_by_label\n+\t= ggc_realloc (ranges_by_label,\n+\t\t       (ranges_by_label_allocated\n+\t\t\t* sizeof (struct dw_ranges_by_label_struct)));\n+      memset (ranges_by_label + ranges_by_label_in_use, 0,\n+\t      RANGES_TABLE_INCREMENT\n+\t      * sizeof (struct dw_ranges_by_label_struct));\n+    }\n+\n+  ranges_by_label[in_use].begin = begin;\n+  ranges_by_label[in_use].end = end;\n+  ranges_by_label_in_use = in_use + 1;\n+\n+  return add_ranges_num (-(int)in_use - 1);\n+}\n+\n static void\n output_ranges (void)\n {\n@@ -7599,9 +7656,9 @@ output_ranges (void)\n \n   for (i = 0; i < ranges_table_in_use; i++)\n     {\n-      int block_num = ranges_table[i].block_num;\n+      int block_num = ranges_table[i].num;\n \n-      if (block_num)\n+      if (block_num > 0)\n \t{\n \t  char blabel[MAX_ARTIFICIAL_LABEL_BYTES];\n \t  char elabel[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -7621,10 +7678,10 @@ output_ranges (void)\n \t\t\t\t    text_section_label, NULL);\n \t    }\n \n-\t  /* Otherwise, we add a DW_AT_entry_pc attribute to force the\n-\t     compilation unit base address to zero, which allows us to\n-\t     use absolute addresses, and not worry about whether the\n-\t     target supports cross-section arithmetic.  */\n+\t  /* Otherwise, the compilation unit base address is zero,\n+\t     which allows us to use absolute addresses, and not worry\n+\t     about whether the target supports cross-section\n+\t     arithmetic.  */\n \t  else\n \t    {\n \t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n@@ -7634,6 +7691,38 @@ output_ranges (void)\n \n \t  fmt = NULL;\n \t}\n+\n+      /* Negative block_num stands for an index into ranges_by_label.  */\n+      else if (block_num < 0)\n+\t{\n+\t  int lab_idx = - block_num - 1;\n+\n+\t  if (!have_multiple_function_sections)\n+\t    {\n+\t      gcc_unreachable ();\n+#if 0\n+\t      /* If we ever use add_ranges_by_labels () for a single\n+\t\t function section, all we have to do is to take out\n+\t\t the #if 0 above.  */\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n+\t\t\t\t    ranges_by_label[lab_idx].begin,\n+\t\t\t\t    text_section_label,\n+\t\t\t\t    fmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n+\t\t\t\t    ranges_by_label[lab_idx].end,\n+\t\t\t\t    text_section_label, NULL);\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n+\t\t\t\t   ranges_by_label[lab_idx].begin,\n+\t\t\t\t   fmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n+\t\t\t\t   ranges_by_label[lab_idx].end,\n+\t\t\t\t   NULL);\n+\t    }\n+\t}\n       else\n \t{\n \t  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n@@ -14575,10 +14664,43 @@ dwarf2out_finish (const char *filename)\n       add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, text_end_label);\n     }\n \n-  /* If it wasn't, we need to give .debug_loc and .debug_ranges an appropriate\n-     \"base address\".  Use zero so that these addresses become absolute.  */\n-  else if (have_location_lists || ranges_table_in_use)\n-    add_AT_addr (comp_unit_die, DW_AT_entry_pc, const0_rtx);\n+  else\n+    {\n+      unsigned fde_idx = 0;\n+\n+      /* We need to give .debug_loc and .debug_ranges an appropriate\n+\t \"base address\".  Use zero so that these addresses become\n+\t absolute.  Historically, we've emitted the unexpected\n+\t DW_AT_entry_pc instead of DW_AT_low_pc for this purpose.\n+\t Emit both to give time for other tools to adapt.  */\n+      add_AT_addr (comp_unit_die, DW_AT_low_pc, const0_rtx);\n+      add_AT_addr (comp_unit_die, DW_AT_entry_pc, const0_rtx);\n+\n+      add_AT_range_list (comp_unit_die, DW_AT_ranges,\n+\t\t\t add_ranges_by_labels (text_section_label,\n+\t\t\t\t\t       text_end_label));\n+      if (flag_reorder_blocks_and_partition)\n+\tadd_ranges_by_labels (cold_text_section_label,\n+\t\t\t      cold_end_label);\n+\n+      for (fde_idx = 0; fde_idx < fde_table_in_use; fde_idx++)\n+\t{\n+\t  dw_fde_ref fde = &fde_table[fde_idx];\n+\n+\t  if (fde->dw_fde_switched_sections)\n+\t    {\n+\t      add_ranges_by_labels (fde->dw_fde_hot_section_label,\n+\t\t\t\t    fde->dw_fde_hot_section_end_label);\n+\t      add_ranges_by_labels (fde->dw_fde_unlikely_section_label,\n+\t\t\t\t    fde->dw_fde_unlikely_section_end_label);\n+\t    }\n+\t  else\n+\t    add_ranges_by_labels (fde->dw_fde_begin,\n+\t\t\t\t  fde->dw_fde_end);\n+\t}\n+\n+      add_ranges (NULL);\n+    }\n \n   /* Output location list section if necessary.  */\n   if (have_location_lists)"}]}