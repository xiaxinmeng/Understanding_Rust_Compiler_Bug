{"sha": "8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ3ZGFlMGViMzY2YTg4YTFiYWJhMTg1N2VjYzU0YzA5ZTRhNTIwZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-06-04T15:37:15Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-06-04T15:38:36Z"}, "message": "i386: Add init pattern for V2HI vectors [PR100637]\n\n2021-06-03  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/\n\tPR target/100637\n\t* config/i386/i386-expand.c (ix86_expand_vector_init_duplicate):\n\tHandle V2HI mode.\n\t(ix86_expand_vector_init_general): Ditto.\n\tUse SImode instead of word_mode for logic operations\n\twhen GET_MODE_SIZE (mode) < UNITS_PER_WORD.\n\t(expand_vec_perm_even_odd_1): Assert that V2HI mode should be\n\timplemented by expand_vec_perm_1.\n\t(expand_vec_perm_broadcast_1): Assert that V2HI and V4HI modes\n\tshould be implemented using standard shuffle patterns.\n\t(ix86_vectorize_vec_perm_const): Handle V2HImode.  Add V4HI and\n\tV2HI modes to modes, implementable with shuffle for one operand.\n\t* config/i386/mmx.md (*punpckwd): New insn_and_split pattern.\n\t(*pshufw_1): New insn pattern.\n\t(*vec_dupv2hi): Ditto.\n\t(vec_initv2hihi): New expander.\n\ngcc/testsuite/\n\n\tPR target/100637\n\t* gcc.dg/vect/slp-perm-9.c (dg-final): Adjust dumps for vect32 targets.", "tree": {"sha": "26b097cfe3f13739104673dded476dad2f05ce00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26b097cfe3f13739104673dded476dad2f05ce00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee9548b36a7f17e8a63585b58f340c93dcba95d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9548b36a7f17e8a63585b58f340c93dcba95d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9548b36a7f17e8a63585b58f340c93dcba95d8"}], "stats": {"total": 135, "additions": 121, "deletions": 14}, "files": [{"sha": "804cb59686705b3fb8186bb970be51b528ee11b1", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "patch": "@@ -13723,6 +13723,19 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n \t}\n       goto widen;\n \n+    case E_V2HImode:\n+      if (TARGET_SSE2)\n+\t{\n+\t  rtx x;\n+\n+\t  val = gen_lowpart (SImode, val);\n+\t  x = gen_rtx_TRUNCATE (HImode, val);\n+\t  x = gen_rtx_VEC_DUPLICATE (mode, x);\n+\t  emit_insn (gen_rtx_SET (target, x));\n+\t  return true;\n+\t}\n+      return false;\n+\n     case E_V8QImode:\n       if (!mmx_ok)\n \treturn false;\n@@ -14524,6 +14537,8 @@ ix86_expand_vector_init_general (bool mmx_ok, machine_mode mode,\n \n     case E_V4HImode:\n     case E_V8QImode:\n+\n+    case E_V2HImode:\n       break;\n \n     default:\n@@ -14532,12 +14547,14 @@ ix86_expand_vector_init_general (bool mmx_ok, machine_mode mode,\n \n     {\n       int i, j, n_elts, n_words, n_elt_per_word;\n-      machine_mode inner_mode;\n+      machine_mode tmp_mode, inner_mode;\n       rtx words[4], shift;\n \n+      tmp_mode = (GET_MODE_SIZE (mode) < UNITS_PER_WORD) ? SImode : word_mode;\n+\n       inner_mode = GET_MODE_INNER (mode);\n       n_elts = GET_MODE_NUNITS (mode);\n-      n_words = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+      n_words = GET_MODE_SIZE (mode) / GET_MODE_SIZE (tmp_mode);\n       n_elt_per_word = n_elts / n_words;\n       shift = GEN_INT (GET_MODE_BITSIZE (inner_mode));\n \n@@ -14548,15 +14565,15 @@ ix86_expand_vector_init_general (bool mmx_ok, machine_mode mode,\n \t  for (j = 0; j < n_elt_per_word; ++j)\n \t    {\n \t      rtx elt = XVECEXP (vals, 0, (i+1)*n_elt_per_word - j - 1);\n-\t      elt = convert_modes (word_mode, inner_mode, elt, true);\n+\t      elt = convert_modes (tmp_mode, inner_mode, elt, true);\n \n \t      if (j == 0)\n \t\tword = elt;\n \t      else\n \t\t{\n-\t\t  word = expand_simple_binop (word_mode, ASHIFT, word, shift,\n+\t\t  word = expand_simple_binop (tmp_mode, ASHIFT, word, shift,\n \t\t\t\t\t      word, 1, OPTAB_LIB_WIDEN);\n-\t\t  word = expand_simple_binop (word_mode, IOR, word, elt,\n+\t\t  word = expand_simple_binop (tmp_mode, IOR, word, elt,\n \t\t\t\t\t      word, 1, OPTAB_LIB_WIDEN);\n \t\t}\n \t    }\n@@ -14570,14 +14587,14 @@ ix86_expand_vector_init_general (bool mmx_ok, machine_mode mode,\n \t{\n \t  rtx tmp = gen_reg_rtx (mode);\n \t  emit_clobber (tmp);\n-\t  emit_move_insn (gen_lowpart (word_mode, tmp), words[0]);\n-\t  emit_move_insn (gen_highpart (word_mode, tmp), words[1]);\n+\t  emit_move_insn (gen_lowpart (tmp_mode, tmp), words[0]);\n+\t  emit_move_insn (gen_highpart (tmp_mode, tmp), words[1]);\n \t  emit_move_insn (target, tmp);\n \t}\n       else if (n_words == 4)\n \t{\n \t  rtx tmp = gen_reg_rtx (V4SImode);\n-\t  gcc_assert (word_mode == SImode);\n+\t  gcc_assert (tmp_mode == SImode);\n \t  vals = gen_rtx_PARALLEL (V4SImode, gen_rtvec_v (4, words));\n \t  ix86_expand_vector_init_general (false, V4SImode, tmp, vals);\n \t  emit_move_insn (target, gen_lowpart (mode, tmp));\n@@ -19548,6 +19565,7 @@ expand_vec_perm_even_odd_1 (struct expand_vec_perm_d *d, unsigned odd)\n     case E_V2DImode:\n     case E_V2SImode:\n     case E_V4SImode:\n+    case E_V2HImode:\n       /* These are always directly implementable by expand_vec_perm_1.  */\n       gcc_unreachable ();\n \n@@ -19758,6 +19776,8 @@ expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n     case E_V2DImode:\n     case E_V2SImode:\n     case E_V4SImode:\n+    case E_V2HImode:\n+    case E_V4HImode:\n       /* These are always implementable using standard shuffle patterns.  */\n       gcc_unreachable ();\n \n@@ -20267,6 +20287,10 @@ ix86_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n       if (!TARGET_MMX_WITH_SSE)\n \treturn false;\n       break;\n+    case E_V2HImode:\n+\tif (!TARGET_SSE2)\n+\t  return false;\n+\tbreak;\n     case E_V2DImode:\n     case E_V2DFmode:\n       if (!TARGET_SSE)\n@@ -20298,10 +20322,11 @@ ix86_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n       /* Check whether the mask can be applied to the vector type.  */\n       d.one_operand_p = (which != 3);\n \n-      /* Implementable with shufps or pshufd.  */\n+      /* Implementable with shufps, pshufd or pshuflw.  */\n       if (d.one_operand_p\n \t  && (d.vmode == V4SFmode || d.vmode == V2SFmode\n-\t      || d.vmode == V4SImode || d.vmode == V2SImode))\n+\t      || d.vmode == V4SImode || d.vmode == V2SImode\n+\t      || d.vmode == V4HImode || d.vmode == V2HImode))\n \treturn true;\n \n       /* Otherwise we have to go through the motions and see if we can"}, {"sha": "c3fd2805f252b4447a5c407c5a85d342617c4332", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "patch": "@@ -3292,6 +3292,88 @@\n   DONE;\n })\n \n+(define_insn_and_split \"*punpckwd\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=x,Yw\")\n+\t(vec_select:V2HI\n+\t  (vec_concat:V4HI\n+\t    (match_operand:V2HI 1 \"register_operand\" \"0,Yw\")\n+\t    (match_operand:V2HI 2 \"register_operand\" \"x,Yw\"))\n+          (parallel [(match_operand 3 \"const_0_to_3_operand\")\n+                     (match_operand 4 \"const_0_to_3_operand\")])))]\n+  \"TARGET_SSE2\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 5)\n+        (vec_select:V4HI\n+\t  (match_dup 5)\n+          (parallel [(match_dup 3) (match_dup 4)\n+                     (const_int 0) (const_int 0)])))]\n+{\n+  rtx dest = lowpart_subreg (V8HImode, operands[0], V2HImode);\n+  rtx op1 = lowpart_subreg (V8HImode, operands[1], V2HImode);\n+  rtx op2 = lowpart_subreg (V8HImode, operands[2], V2HImode);\n+\n+  emit_insn (gen_vec_interleave_lowv8hi (dest, op1, op2));\n+\n+  static const int map[4] = { 0, 2, 1, 3 };\n+\n+  int sel0 = map[INTVAL (operands[3])];\n+  int sel1 = map[INTVAL (operands[4])];\n+\n+  if (sel0 == 0 && sel1 == 1)\n+    DONE;\n+\n+  operands[3] = GEN_INT (sel0);\n+  operands[4] = GEN_INT (sel1);\n+\n+  operands[5] = lowpart_subreg (V4HImode, dest, V8HImode);\n+}\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"*pshufw_1\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=Yw\")\n+        (vec_select:V2HI\n+          (match_operand:V2HI 1 \"register_operand\" \"Yw\")\n+          (parallel [(match_operand 2 \"const_0_to_1_operand\")\n+                     (match_operand 3 \"const_0_to_1_operand\")])))]\n+  \"TARGET_SSE2\"\n+{\n+  int mask = 0;\n+  mask |= INTVAL (operands[2]) << 0;\n+  mask |= INTVAL (operands[3]) << 2;\n+  mask |= 2 << 4;\n+  mask |= 3 << 6;\n+  operands[2] = GEN_INT (mask);\n+\n+  return \"%vpshuflw\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_insn \"*vec_dupv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=Yw\")\n+\t(vec_duplicate:V2HI\n+\t  (truncate:HI\n+\t    (match_operand:SI 1 \"register_operand\" \"Yw\"))))]\n+  \"TARGET_SSE2\"\n+  \"%vpshuflw\\t{$0, %1, %0|%0, %1, 0}\"\n+  [(set_attr \"type\" \"sselog1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_expand \"vec_initv2hihi\"\n+  [(match_operand:V2HI 0 \"register_operand\")\n+   (match_operand 1)]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_vector_init (false, operands[0],\n+\t\t\t   operands[1]);\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Miscellaneous"}, {"sha": "873eddf223ee4f47f6ed753d8edcd43b2c5df36d", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-9.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d7dae0eb366a88a1baba1857ecc54c09e4a520e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c?ref=8d7dae0eb366a88a1baba1857ecc54c09e4a520e", "patch": "@@ -57,13 +57,13 @@ int main (int argc, const char* argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { vect_perm_short || vect_load_lanes } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_perm_short || vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { { vect_perm_short || vect32 } || vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { { vect_perm_short || vect32 } || vect_load_lanes } } } } */\n /* We don't try permutes with a group size of 3 for variable-length\n    vectors.  */\n /* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target { vect_perm_short && { { ! vect_perm3_short } && { ! vect_partial_vectors_usage_1 } } } xfail vect_variable_length } } } */\n /* Try to vectorize the epilogue using partial vectors.  */\n /* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 2 \"vect\" { target { vect_perm_short && { { ! vect_perm3_short } && vect_partial_vectors_usage_1 } } xfail vect_variable_length } } } */\n /* { dg-final { scan-tree-dump-not \"permutation requires at least three vectors\" \"vect\" { target vect_perm3_short } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target { { ! vect_perm3_short } || vect_load_lanes } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm3_short && { ! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target { { ! { vect_perm3_short || vect32 } } || vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { { vect_perm3_short || vect32 } && { ! vect_load_lanes } } } } } */"}]}