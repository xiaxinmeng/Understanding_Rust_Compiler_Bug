{"sha": "8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFiMzFjMGMzMWVjZjFmYTM2ODk3NGRjOTgxOTY5NTVjYjJjMjVjZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T13:53:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T13:53:26Z"}, "message": "[multiple changes]\n\n2017-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* fe.h (Warn_On_Questionable_Layout): Declare.\n\t* warnsw.ads (Warn_On_Record_Holes): Move down.\n\t(Warn_On_Questionable_Layout): New boolean variable.\n\t(Warning_Record): Add Warn_On_Questionable_Layout field.\n\t* warnsw.adb (All_Warnings): Set Warn_On_Questionable_Layout.\n\t(Restore_Warnings): Likewise.\n\t(Save_Warnings): Likewise.\n\t(Set_Dot_Warning_Switch): Handle 'q' and 'Q' letters.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust call to\n\tcomponents_to_record.\n\t(gnu_field_to_gnat): New function.\n\t(warn_on_field_placement): Likewise.\n\t(components_to_record): Add GNAT_RECORD_TYPE and remove REORDER\n\tparameters.  Rename local variables and adjust recursive call.\n\tRework final scan of the field list and implement warnings on the\n\tproblematic placement of specific sorts of fields.\n\n2017-04-27  Bob Duff  <duff@adacore.com>\n\n\t* errout.adb, exp_aggr.adb, exp_attr.adb, exp_code.adb, fname.adb,\n\t* fname.ads, freeze.adb, inline.adb, lib.adb, lib.ads, lib-list.adb,\n\t* lib-load.adb, lib-writ.adb, par.adb, restrict.adb, rtsfind.adb,\n\t* sem.adb, sem_cat.adb, sem_ch10.adb, sem_ch12.adb, sem_ch3.adb,\n\t* sem_ch4.adb, sem_ch6.adb, sem_ch8.adb, sem_ch9.adb, sem_elab.adb,\n\t* sem_intr.adb, sem_res.adb, sem_util.adb, sem_warn.adb, sprint.adb:\n\tFor efficiency, cache results of Is_Internal_File_Name and\n\tIs_Predefined_File_Name in the Units table. This avoids a lot\n\tof repeated text processing.\n\n2017-04-27  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-comlin.adb (Sort_Sections): remove useless test.\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cfhase.adb, a-cfhase.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Formal_Model): Ghost package containing model functions that are\n\tused in subprogram contracts.\n\t(Current_To_Last): Removed, model functions should be used instead.\n\t(First_To_Previous): Removed, model functions should be used instead.\n\t(Strict_Equal): Removed, model functions should be used instead.\n\t(No_Overlap): Removed, model functions should be used instead.\n\t(Equivalent_Keys): Functions over cursors are removed. They were\n\tawkward with explicit container parameters.\n\t* a-cforse.adb, a-cforse.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Formal_Model): Ghost package containing model functions that\n\tare used in subprogram contracts.\n\t(Current_To_Last): Removed, model functions should be used instead.\n\t(First_To_Previous): Removed, model functions should be used instead.\n\t(Strict_Equal): Removed, model functions should be used instead.\n\t(No_Overlap): Removed, model functions should be used instead.\n\n2017-04-27  Yannick Moy  <moy@adacore.com>\n\n\t* gnat1drv.adb: Code cleanup.\n\n2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Replace_Entity): The prefix of a 'Result\n\tattribute reference in a post- condition is the subprogram to\n\twhich the condition applies. If the condition is inherited\n\tby a type extension, the prefix becomes a reference to the\n\tinherited operation, but there is no need to create a wrapper\n\tfor this operation, because 'Result is expanded independently\n\twhen elaborating the postconditions.\n\nFrom-SVN: r247338", "tree": {"sha": "63f7052ed1045975db29cac73a1b1a68e9f50ef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63f7052ed1045975db29cac73a1b1a68e9f50ef0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/comments", "author": null, "committer": null, "parents": [{"sha": "a2168462958f03ca5b060ad49e217a3e262750d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2168462958f03ca5b060ad49e217a3e262750d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2168462958f03ca5b060ad49e217a3e262750d0"}], "stats": {"total": 5996, "additions": 4680, "deletions": 1316}, "files": [{"sha": "667d8635756be547fbbe7f8c3908822892688416", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -1,3 +1,73 @@\n+2017-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fe.h (Warn_On_Questionable_Layout): Declare.\n+\t* warnsw.ads (Warn_On_Record_Holes): Move down.\n+\t(Warn_On_Questionable_Layout): New boolean variable.\n+\t(Warning_Record): Add Warn_On_Questionable_Layout field.\n+\t* warnsw.adb (All_Warnings): Set Warn_On_Questionable_Layout.\n+\t(Restore_Warnings): Likewise.\n+\t(Save_Warnings): Likewise.\n+\t(Set_Dot_Warning_Switch): Handle 'q' and 'Q' letters.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust call to\n+\tcomponents_to_record.\n+\t(gnu_field_to_gnat): New function.\n+\t(warn_on_field_placement): Likewise.\n+\t(components_to_record): Add GNAT_RECORD_TYPE and remove REORDER\n+\tparameters.  Rename local variables and adjust recursive call.\n+\tRework final scan of the field list and implement warnings on the\n+\tproblematic placement of specific sorts of fields.\n+\n+2017-04-27  Bob Duff  <duff@adacore.com>\n+\n+\t* errout.adb, exp_aggr.adb, exp_attr.adb, exp_code.adb, fname.adb,\n+\t* fname.ads, freeze.adb, inline.adb, lib.adb, lib.ads, lib-list.adb,\n+\t* lib-load.adb, lib-writ.adb, par.adb, restrict.adb, rtsfind.adb,\n+\t* sem.adb, sem_cat.adb, sem_ch10.adb, sem_ch12.adb, sem_ch3.adb,\n+\t* sem_ch4.adb, sem_ch6.adb, sem_ch8.adb, sem_ch9.adb, sem_elab.adb,\n+\t* sem_intr.adb, sem_res.adb, sem_util.adb, sem_warn.adb, sprint.adb:\n+\tFor efficiency, cache results of Is_Internal_File_Name and\n+\tIs_Predefined_File_Name in the Units table. This avoids a lot\n+\tof repeated text processing.\n+\n+2017-04-27  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-comlin.adb (Sort_Sections): remove useless test.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfhase.adb, a-cfhase.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Formal_Model): Ghost package containing model functions that are\n+\tused in subprogram contracts.\n+\t(Current_To_Last): Removed, model functions should be used instead.\n+\t(First_To_Previous): Removed, model functions should be used instead.\n+\t(Strict_Equal): Removed, model functions should be used instead.\n+\t(No_Overlap): Removed, model functions should be used instead.\n+\t(Equivalent_Keys): Functions over cursors are removed. They were\n+\tawkward with explicit container parameters.\n+\t* a-cforse.adb, a-cforse.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Formal_Model): Ghost package containing model functions that\n+\tare used in subprogram contracts.\n+\t(Current_To_Last): Removed, model functions should be used instead.\n+\t(First_To_Previous): Removed, model functions should be used instead.\n+\t(Strict_Equal): Removed, model functions should be used instead.\n+\t(No_Overlap): Removed, model functions should be used instead.\n+\n+2017-04-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat1drv.adb: Code cleanup.\n+\n+2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Replace_Entity): The prefix of a 'Result\n+\tattribute reference in a post- condition is the subprogram to\n+\twhich the condition applies. If the condition is inherited\n+\tby a type extension, the prefix becomes a reference to the\n+\tinherited operation, but there is no need to create a wrapper\n+\tfor this operation, because 'Result is expanded independently\n+\twhen elaborating the postconditions.\n+\n 2017-04-27  Bob Duff  <duff@adacore.com>\n \n \t* sinput.adb: Minor code cleanup."}, {"sha": "0b4674d5ac88dca8cb97c85d7a6fadbcebb4416e", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -847,6 +847,45 @@ is\n \n    package body Generic_Sorting with SPARK_Mode => Off is\n \n+      ------------------\n+      -- Formal_Model --\n+      ------------------\n+\n+      package body Formal_Model is\n+\n+         -----------------------\n+         -- M_Elements_Sorted --\n+         -----------------------\n+\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n+         begin\n+            if M.Length (Container) = 0 then\n+               return True;\n+            end if;\n+\n+            declare\n+               E1 : Element_Type := Element (Container, 1);\n+\n+            begin\n+               for I in 2 .. M.Length (Container) loop\n+                  declare\n+                     E2 : constant Element_Type := Element (Container, I);\n+\n+                  begin\n+                     if E2 < E1 then\n+                        return False;\n+                     end if;\n+\n+                     E1 := E2;\n+                  end;\n+               end loop;\n+            end;\n+\n+            return True;\n+         end M_Elements_Sorted;\n+\n+      end Formal_Model;\n+\n       ---------------\n       -- Is_Sorted --\n       ---------------\n@@ -867,37 +906,6 @@ is\n          return True;\n       end Is_Sorted;\n \n-      -----------------------\n-      -- M_Elements_Sorted --\n-      -----------------------\n-\n-      function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-      begin\n-         if M.Length (Container) = 0 then\n-            return True;\n-         end if;\n-\n-         declare\n-            E1 : Element_Type := Element (Container, 1);\n-\n-         begin\n-            for I in 2 .. M.Length (Container) loop\n-               declare\n-                  E2 : constant Element_Type := Element (Container, I);\n-\n-               begin\n-                  if E2 < E1 then\n-                     return False;\n-                  end if;\n-\n-                  E1 := E2;\n-               end;\n-            end loop;\n-         end;\n-\n-         return True;\n-      end M_Elements_Sorted;\n-\n       -----------\n       -- Merge --\n       -----------"}, {"sha": "e7b7ba7203cf93be4fd855bb6b706897b468b541", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -1408,8 +1408,8 @@ is\n        Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n \n-       --  If Item is not is not contained in Container after Position, Find\n-       --  returns No_Element.\n+       --  If Item is not contained in Container after Position, Find returns\n+       --  No_Element.\n \n        (not M.Contains\n               (Container => Model (Container),\n@@ -1423,7 +1423,7 @@ is\n         =>\n           Find'Result = No_Element,\n \n-        --  Otherwise, Find returns a valid cusror in Container\n+        --  Otherwise, Find returns a valid cursor in Container\n \n         others =>\n           P.Has_Key (Positions (Container), Find'Result)\n@@ -1463,8 +1463,8 @@ is\n        Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n \n-       --  If Item is not is not contained in Container before Position, Find\n-       --  returns No_Element.\n+       --  If Item is not contained in Container before Position, Find returns\n+       --  No_Element.\n \n        (not M.Contains\n               (Container => Model (Container),\n@@ -1478,7 +1478,7 @@ is\n         =>\n           Reverse_Find'Result = No_Element,\n \n-        --  Otherwise, Find returns a valid cusror in Container\n+        --  Otherwise, Find returns a valid cursor in Container\n \n         others =>\n           P.Has_Key (Positions (Container), Reverse_Find'Result)\n@@ -1533,16 +1533,21 @@ is\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n \n    package Generic_Sorting with SPARK_Mode is\n-      function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          M_Elements_Sorted'Result =\n-            (for all I in 1 .. M.Length (Container) =>\n-              (for all J in I .. M.Length (Container) =>\n-                 Element (Container, I) = Element (Container, J)\n-                   or Element (Container, I) < Element (Container, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      package Formal_Model with Ghost is\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n+         with\n+           Global => null,\n+           Post   =>\n+             M_Elements_Sorted'Result =\n+               (for all I in 1 .. M.Length (Container) =>\n+                  (for all J in I .. M.Length (Container) =>\n+                       Element (Container, I) = Element (Container, J)\n+                         or Element (Container, I) < Element (Container, J)));\n+         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      end Formal_Model;\n+      use Formal_Model;\n \n       function Is_Sorted (Container : List) return Boolean with\n         Global => null,"}, {"sha": "4351102adaab5ee995be04b4a6bab5bd3d129fbb", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -366,6 +366,39 @@ is\n \n    package body Formal_Model is\n \n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n+      is\n+      begin\n+         for I in 1 .. K.Length (Container) loop\n+            if Equivalent_Keys (Key, K.Get (Container, I)) then\n+               return I;\n+            end if;\n+         end loop;\n+         return 0;\n+      end Find;\n+\n+      ---------------------\n+      -- K_Keys_Included --\n+      ---------------------\n+\n+      function K_Keys_Included (Left  : K.Sequence;\n+                               Right : K.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. K.Length (Left) loop\n+            if not K.Contains (Right, 1, K.Length (Right), K.Get (Left, I))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end K_Keys_Included;\n+\n       ----------\n       -- Keys --\n       ----------"}, {"sha": "dc60dc8f9f22ddffef96a74271c4cc7defdb4bf6", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -56,7 +56,9 @@ generic\n    type Element_Type is private;\n \n    with function Hash (Key : Key_Type) return Hash_Type;\n-   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   with function Equivalent_Keys\n+     (Left  : Key_Type;\n+      Right : Key_Type) return Boolean is \"=\";\n \n package Ada.Containers.Formal_Hashed_Maps with\n   SPARK_Mode\n@@ -117,6 +119,30 @@ is\n         (Left  : K.Sequence;\n          Right : K.Sequence) return Boolean renames K.\"<=\";\n \n+      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n+      --  Search for Key in Container\n+\n+      with\n+        Global => null,\n+        Post =>\n+          (if Find'Result > 0 then\n+             Find'Result <= K.Length (Container)\n+               and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n+\n+      function K_Keys_Included\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean\n+      --  Return True if Right contains all the keys of Left\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          K_Keys_Included'Result =\n+            (for all I in 1 .. K.Length (Left) =>\n+               Find (Right, K.Get (Left, I)) > 0\n+                 and then K.Get (Right, Find (Right, K.Get (Left, I))) =\n+                     K.Get (Left, I));\n+\n       package P is new Ada.Containers.Functional_Maps\n         (Key_Type                       => Cursor,\n          Element_Type                   => Positive_Count_Type,\n@@ -137,7 +163,6 @@ is\n          P_Left  : P.Map;\n          P_Right : P.Map) return Boolean\n       with\n-        Ghost,\n         Global => null,\n         Post   =>\n           (if Mapping_Preserved'Result then\n@@ -146,6 +171,10 @@ is\n \n              P.Keys_Included (P_Left, P_Right)\n \n+               --  Right contains all the keys of Left\n+\n+               and K_Keys_Included (K_Left, K_Right)\n+\n                --  Mappings from cursors to elements induced by K_Left, P_Left\n                --  and K_Right, P_Right are the same.\n \n@@ -179,10 +208,15 @@ is\n             --  It contains all the keys contained in Model\n \n             and (for all Key of Model (Container) =>\n-                  (for some L of Keys'Result => Equivalent_Keys (L, Key)))\n+                  (Find (Keys'Result, Key) > 0\n+                     and then Equivalent_Keys\n+                      (K.Get (Keys'Result, Find (Keys'Result, Key)), Key)))\n \n             --  It has no duplicate\n \n+            and (for all I in 1 .. Length (Container) =>\n+                  Find (Keys'Result, K.Get (Keys'Result, I)) = I)\n+\n             and (for all I in 1 .. Length (Container) =>\n                   (for all J in 1 .. Length (Container) =>\n                     (if Equivalent_Keys\n@@ -259,7 +293,14 @@ is\n    with\n      Global => null,\n      Pre    => Capacity <= Container.Capacity,\n-     Post   => Model (Container) = Model (Container)'Old;\n+     Post   =>\n+       Model (Container) = Model (Container)'Old\n+         and Length (Container)'Old = Length (Container)\n+\n+         --  Actual keys are preserved\n+\n+         and K_Keys_Included (Keys (Container), Keys (Container)'Old)\n+         and K_Keys_Included (Keys (Container)'Old, Keys (Container));\n \n    function Is_Empty (Container : Map) return Boolean with\n      Global => null,\n@@ -278,8 +319,8 @@ is\n \n          --  Actual keys are preserved\n \n-         and (for all Key of Keys (Source) =>\n-               Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n+         and K_Keys_Included (Keys (Target), Keys (Source))\n+         and K_Keys_Included (Keys (Source), Keys (Target));\n \n    function Copy\n      (Source   : Map;\n@@ -355,8 +396,8 @@ is\n \n          --  Actual keys are preserved\n \n-         and (for all Key of Keys (Source)'Old =>\n-               Formal_Hashed_Maps.Key (Target, Find (Target, Key)) = Key);\n+         and K_Keys_Included (Keys (Target), Keys (Source)'Old)\n+         and K_Keys_Included (Keys (Source)'Old, Keys (Target));\n \n    procedure Insert\n      (Container : in out Map;\n@@ -700,7 +741,7 @@ is\n      Global         => null,\n      Contract_Cases =>\n \n-       --  If Key is not is not contained in Container, Find returns No_Element\n+       --  If Key is not contained in Container, Find returns No_Element\n \n        (not Contains (Model (Container), Key) =>\n           Find'Result = No_Element,\n@@ -709,6 +750,8 @@ is\n \n         others =>\n           P.Has_Key (Positions (Container), Find'Result)\n+            and P.Get (Positions (Container), Find'Result) =\n+                Find (Keys (Container), Key)\n \n             --  The key designated by the result of Find is Key\n "}, {"sha": "f40fc2fe09b5dcfe7c335df8b60b108e04f2f075", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 394, "deletions": 315, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -263,35 +263,6 @@ is\n       return Target;\n    end Copy;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n-\n-   function Current_To_Last (Container : Set; Current : Cursor) return Set is\n-      Curs : Cursor := First (Container);\n-      C    : Set (Container.Capacity, Container.Modulus) :=\n-               Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-\n-      elsif Current /= No_Element and not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-\n-      else\n-         while Curs.Node /= Current.Node loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n-         end loop;\n-\n-         return C;\n-      end if;\n-   end Current_To_Last;\n-\n    ---------------------\n    -- Default_Modulus --\n    ---------------------\n@@ -521,83 +492,6 @@ is\n       return Is_Equivalent (Left, Right);\n    end Equivalent_Sets;\n \n-   -------------------------\n-   -- Equivalent_Elements --\n-   -------------------------\n-\n-   function Equivalent_Elements\n-     (Left  : Set;\n-      CLeft : Cursor;\n-      Right  : Set;\n-      CRight : Cursor) return Boolean\n-   is\n-   begin\n-      if not Has_Element (Left, CLeft) then\n-         raise Constraint_Error with\n-           \"Left cursor of Equivalent_Elements has no element\";\n-      end if;\n-\n-      if not Has_Element (Right, CRight) then\n-         raise Constraint_Error with\n-           \"Right cursor of Equivalent_Elements has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Left, CLeft),\n-                     \"bad Left cursor in Equivalent_Elements\");\n-      pragma Assert (Vet (Right, CRight),\n-                     \"bad Right cursor in Equivalent_Elements\");\n-\n-      declare\n-         LN : Node_Type renames Left.Nodes (CLeft.Node);\n-         RN : Node_Type renames Right.Nodes (CRight.Node);\n-      begin\n-         return Equivalent_Elements (LN.Element, RN.Element);\n-      end;\n-   end Equivalent_Elements;\n-\n-   function Equivalent_Elements\n-     (Left  : Set;\n-      CLeft : Cursor;\n-      Right : Element_Type) return Boolean\n-   is\n-   begin\n-      if not Has_Element (Left, CLeft) then\n-         raise Constraint_Error with\n-           \"Left cursor of Equivalent_Elements has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Left, CLeft),\n-                     \"Left cursor in Equivalent_Elements is bad\");\n-\n-      declare\n-         LN : Node_Type renames Left.Nodes (CLeft.Node);\n-      begin\n-         return Equivalent_Elements (LN.Element, Right);\n-      end;\n-   end Equivalent_Elements;\n-\n-   function Equivalent_Elements\n-     (Left   : Element_Type;\n-      Right  : Set;\n-      CRight : Cursor) return Boolean\n-   is\n-   begin\n-      if not Has_Element (Right, CRight) then\n-         raise Constraint_Error with\n-           \"Right cursor of Equivalent_Elements has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Right, CRight),\n-         \"Right cursor of Equivalent_Elements is bad\");\n-\n-      declare\n-         RN : Node_Type renames Right.Nodes (CRight.Node);\n-      begin\n-         return Equivalent_Elements (Left, RN.Element);\n-      end;\n-   end Equivalent_Elements;\n-\n    ---------------------\n    -- Equivalent_Keys --\n    ---------------------\n@@ -657,36 +551,221 @@ is\n       return (Node => Node);\n    end First;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n \n-   function First_To_Previous\n-     (Container : Set;\n-      Current   : Cursor) return Set\n-   is\n-      Curs : Cursor := Current;\n-      C    : Set (Container.Capacity, Container.Modulus) :=\n-               Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n+   package body Formal_Model is\n \n-   begin\n-      if Curs = No_Element then\n-         return C;\n+      -------------------------\n+      -- E_Elements_Included --\n+      -------------------------\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. E.Length (Left) loop\n+            if not E.Contains (Right, 1, E.Length (Right), E.Get (Left, I))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n \n-      elsif not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n+         return True;\n+      end E_Elements_Included;\n \n-      else\n-         while Curs.Node /= 0 loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Model : M.Set;\n+         Right : E.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. E.Length (Left) loop\n+            declare\n+               Item : constant Element_Type := E.Get (Left, I);\n+            begin\n+               if M.Contains (Model, Item) then\n+                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n          end loop;\n \n-         return C;\n-      end if;\n-   end First_To_Previous;\n+         return True;\n+      end E_Elements_Included;\n+\n+      function E_Elements_Included\n+        (Container : E.Sequence;\n+         Model     : M.Set;\n+         Left      : E.Sequence;\n+         Right     : E.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. E.Length (Container) loop\n+            declare\n+               Item : constant Element_Type := E.Get (Container, I);\n+            begin\n+               if M.Contains (Model, Item) then\n+                  if not E.Contains (Left, 1, E.Length (Left), Item) then\n+                     return False;\n+                  end if;\n+               else\n+                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end E_Elements_Included;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find\n+        (Container : E.Sequence;\n+         Item      : Element_Type) return Count_Type\n+      is\n+      begin\n+         for I in 1 .. E.Length (Container) loop\n+            if Equivalent_Elements (Item, E.Get (Container, I)) then\n+               return I;\n+            end if;\n+         end loop;\n+         return 0;\n+      end Find;\n+\n+      --------------\n+      -- Elements --\n+      --------------\n+\n+      function Elements (Container : Set) return E.Sequence is\n+         Position : Count_Type := HT_Ops.First (Container);\n+         R        : E.Sequence;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := E.Add (R, Container.Nodes (Position).Element);\n+            Position := HT_Ops.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Elements;\n+\n+      ----------------------------\n+      -- Lift_Abstraction_Level --\n+      ----------------------------\n+\n+      procedure Lift_Abstraction_Level (Container : Set) is null;\n+\n+      -----------------------\n+      -- Mapping_Preserved --\n+      -----------------------\n+\n+      function Mapping_Preserved\n+        (E_Left  : E.Sequence;\n+         E_Right : E.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      is\n+      begin\n+         for C of P_Left loop\n+            if not P.Has_Key (P_Right, C)\n+              or else P.Get (P_Left,  C) > E.Length (E_Left)\n+              or else P.Get (P_Right, C) > E.Length (E_Right)\n+              or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n+                      E.Get (E_Right, P.Get (P_Right, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved;\n+\n+      ------------------------------\n+      -- Mapping_Preserved_Except --\n+      ------------------------------\n+\n+      function Mapping_Preserved_Except\n+        (E_Left   : E.Sequence;\n+         E_Right  : E.Sequence;\n+         P_Left   : P.Map;\n+         P_Right  : P.Map;\n+         Position : Cursor) return Boolean\n+      is\n+      begin\n+         for C of P_Left loop\n+            if C /= Position\n+              and (not P.Has_Key (P_Right, C)\n+                    or else P.Get (P_Left,  C) > E.Length (E_Left)\n+                    or else P.Get (P_Right, C) > E.Length (E_Right)\n+                    or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n+                            E.Get (E_Right, P.Get (P_Right, C)))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved_Except;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : Set) return M.Set is\n+         Position : Count_Type := HT_Ops.First (Container);\n+         R        : M.Set;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R :=\n+              M.Add\n+                (Container => R,\n+                 Item      => Container.Nodes (Position).Element);\n+\n+            Position := HT_Ops.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Model;\n+\n+      ---------------\n+      -- Positions --\n+      ---------------\n+\n+      function Positions (Container : Set) return P.Map is\n+         I        : Count_Type := 1;\n+         Position : Count_Type := HT_Ops.First (Container);\n+         R        : P.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := P.Add (R, (Node => Position), I);\n+            pragma Assert (P.Length (R) = I);\n+            Position := HT_Ops.Next (Container, Position);\n+            I := I + 1;\n+         end loop;\n+\n+         return R;\n+      end Positions;\n+\n+   end Formal_Model;\n \n    ----------\n    -- Free --\n@@ -715,6 +794,190 @@ is\n       HT.Nodes (Node).Has_Element := True;\n    end Generic_Allocate;\n \n+   package body Generic_Keys with SPARK_Mode => Off is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Type) return Boolean;\n+      pragma Inline (Equivalent_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+        new Hash_Tables.Generic_Bounded_Keys\n+          (HT_Types        => HT_Types,\n+           Next            => Next,\n+           Set_Next        => Set_Next,\n+           Key_Type        => Key_Type,\n+           Hash            => Hash,\n+           Equivalent_Keys => Equivalent_Key_Node);\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains\n+        (Container : Set;\n+         Key       : Key_Type) return Boolean\n+      is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Count_Type;\n+\n+      begin\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+\n+         if X = 0 then\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n+         end if;\n+\n+         Free (Container, X);\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element\n+        (Container : Set;\n+         Key       : Key_Type) return Element_Type\n+      is\n+         Node : constant Count_Type := Find (Container, Key).Node;\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n+         return Container.Nodes (Node).Element;\n+      end Element;\n+\n+      -------------------------\n+      -- Equivalent_Key_Node --\n+      -------------------------\n+\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Type) return Boolean\n+      is\n+      begin\n+         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n+      end Equivalent_Key_Node;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Count_Type;\n+      begin\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         Free (Container, X);\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+      begin\n+         return (if Node = 0 then No_Element else (Node => Node));\n+      end Find;\n+\n+      ------------------\n+      -- Formal_Model --\n+      ------------------\n+\n+      package body Formal_Model is\n+\n+         -----------------------\n+         -- M_Included_Except --\n+         -----------------------\n+\n+         function M_Included_Except\n+           (Left  : M.Set;\n+            Right : M.Set;\n+            Key   : Key_Type) return Boolean\n+         is\n+         begin\n+            for E of Left loop\n+               if not Contains (Right, E)\n+                 and not Equivalent_Keys (Generic_Keys.Key (E), Key)\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+            return True;\n+         end M_Included_Except;\n+\n+      end Formal_Model;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Container : Set; Position : Cursor) return Key_Type is\n+      begin\n+         if not Has_Element (Container, Position) then\n+            raise Constraint_Error with\n+              \"Position cursor has no element\";\n+         end if;\n+\n+         pragma Assert\n+           (Vet (Container, Position), \"bad cursor in function Key\");\n+\n+         declare\n+            N  : Node_Type renames Container.Nodes (Position.Node);\n+         begin\n+            return Key (N.Element);\n+         end;\n+      end Key;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n+         end if;\n+\n+         Replace_Element (Container, Node, New_Item);\n+      end Replace;\n+\n+   end Generic_Keys;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1158,34 +1421,6 @@ is\n       Node.Next := Next;\n    end Set_Next;\n \n-   ------------------\n-   -- Strict_Equal --\n-   ------------------\n-\n-   function Strict_Equal (Left, Right : Set) return Boolean is\n-      CuL : Cursor := First (Left);\n-      CuR : Cursor := First (Right);\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      while CuL.Node /= 0 or CuR.Node /= 0 loop\n-         if CuL.Node /= CuR.Node\n-           or else Left.Nodes (CuL.Node).Element /=\n-                   Right.Nodes (CuR.Node).Element\n-         then\n-            return False;\n-         end if;\n-\n-         CuL := Next (Left, CuL);\n-         CuR := Next (Right, CuR);\n-      end loop;\n-\n-      return True;\n-   end Strict_Equal;\n-\n    --------------------------\n    -- Symmetric_Difference --\n    --------------------------\n@@ -1386,160 +1621,4 @@ is\n       end;\n    end Vet;\n \n-   package body Generic_Keys with SPARK_Mode => Off is\n-\n-      -----------------------\n-      -- Local Subprograms --\n-      -----------------------\n-\n-      function Equivalent_Key_Node\n-        (Key  : Key_Type;\n-         Node : Node_Type) return Boolean;\n-      pragma Inline (Equivalent_Key_Node);\n-\n-      --------------------------\n-      -- Local Instantiations --\n-      --------------------------\n-\n-      package Key_Keys is\n-        new Hash_Tables.Generic_Bounded_Keys\n-          (HT_Types        => HT_Types,\n-           Next            => Next,\n-           Set_Next        => Set_Next,\n-           Key_Type        => Key_Type,\n-           Hash            => Hash,\n-           Equivalent_Keys => Equivalent_Key_Node);\n-\n-      --------------\n-      -- Contains --\n-      --------------\n-\n-      function Contains\n-        (Container : Set;\n-         Key       : Key_Type) return Boolean\n-      is\n-      begin\n-         return Find (Container, Key) /= No_Element;\n-      end Contains;\n-\n-      ------------\n-      -- Delete --\n-      ------------\n-\n-      procedure Delete\n-        (Container : in out Set;\n-         Key       : Key_Type)\n-      is\n-         X : Count_Type;\n-\n-      begin\n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n-\n-         if X = 0 then\n-            raise Constraint_Error with \"attempt to delete key not in set\";\n-         end if;\n-\n-         Free (Container, X);\n-      end Delete;\n-\n-      -------------\n-      -- Element --\n-      -------------\n-\n-      function Element\n-        (Container : Set;\n-         Key       : Key_Type) return Element_Type\n-      is\n-         Node : constant Count_Type := Find (Container, Key).Node;\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"key not in map\";\n-         end if;\n-\n-         return Container.Nodes (Node).Element;\n-      end Element;\n-\n-      -------------------------\n-      -- Equivalent_Key_Node --\n-      -------------------------\n-\n-      function Equivalent_Key_Node\n-        (Key  : Key_Type;\n-         Node : Node_Type) return Boolean\n-      is\n-      begin\n-         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n-      end Equivalent_Key_Node;\n-\n-      -------------\n-      -- Exclude --\n-      -------------\n-\n-      procedure Exclude\n-        (Container : in out Set;\n-         Key       : Key_Type)\n-      is\n-         X : Count_Type;\n-      begin\n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n-         Free (Container, X);\n-      end Exclude;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : Set;\n-         Key       : Key_Type) return Cursor\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n-      begin\n-         return (if Node = 0 then No_Element else (Node => Node));\n-      end Find;\n-\n-      ---------\n-      -- Key --\n-      ---------\n-\n-      function Key (Container : Set; Position : Cursor) return Key_Type is\n-      begin\n-         if not Has_Element (Container, Position) then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-\n-         pragma Assert\n-           (Vet (Container, Position), \"bad cursor in function Key\");\n-\n-         declare\n-            N  : Node_Type renames Container.Nodes (Position.Node);\n-         begin\n-            return Key (N.Element);\n-         end;\n-      end Key;\n-\n-      -------------\n-      -- Replace --\n-      -------------\n-\n-      procedure Replace\n-        (Container : in out Set;\n-         Key       : Key_Type;\n-         New_Item  : Element_Type)\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with\n-              \"attempt to replace key not in set\";\n-         end if;\n-\n-         Replace_Element (Container, Node, New_Item);\n-      end Replace;\n-\n-   end Generic_Keys;\n-\n end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "0f2be8560bab9b4fe63d374a44474cd7731e6a8e", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 1103, "deletions": 123, "changes": 1226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,16 +45,9 @@\n --    which is not possible if cursors encapsulate an access to the underlying\n --    container.\n \n---    There are three new functions:\n-\n---      function Strict_Equal (Left, Right : Set) return Boolean;\n---      function First_To_Previous  (Container : Set; Current : Cursor)\n---         return Set;\n---      function Current_To_Last (Container : Set; Current : Cursor)\n---         return Set;\n-\n---    See detailed specifications for these subprograms\n-\n+with Ada.Containers.Functional_Maps;\n+with Ada.Containers.Functional_Sets;\n+with Ada.Containers.Functional_Vectors;\n private with Ada.Containers.Hash_Tables;\n \n generic\n@@ -63,15 +56,10 @@ generic\n    with function Hash (Element : Element_Type) return Hash_Type;\n \n    with function Equivalent_Elements (Left, Right : Element_Type)\n-                                      return Boolean;\n-\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n+                                      return Boolean is \"=\";\n package Ada.Containers.Formal_Hashed_Sets with\n-  Pure,\n   SPARK_Mode\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    type Set (Capacity : Count_Type; Modulus : Hash_Type) is private with\n@@ -82,191 +70,1077 @@ is\n      Default_Initial_Condition => Is_Empty (Set);\n    pragma Preelaborable_Initialization (Set);\n \n-   type Cursor is private;\n-   pragma Preelaborable_Initialization (Cursor);\n+   type Cursor is record\n+      Node : Count_Type;\n+   end record;\n \n-   Empty_Set : constant Set;\n+   No_Element : constant Cursor := (Node => 0);\n+\n+   function Length (Container : Set) return Count_Type with\n+     Global => null,\n+     Post   => Length'Result <= Container.Capacity;\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+      package M is new Ada.Containers.Functional_Sets\n+        (Element_Type    => Element_Type,\n+         Equivalent_Elements => Equivalent_Elements);\n+\n+      function \"=\"\n+        (Left  : M.Set;\n+         Right : M.Set) return Boolean renames M.\"=\";\n+\n+      function \"<=\"\n+        (Left  : M.Set;\n+         Right : M.Set) return Boolean renames M.\"<=\";\n+\n+      package E is new Ada.Containers.Functional_Vectors\n+        (Element_Type => Element_Type,\n+         Index_Type   => Positive_Count_Type);\n+\n+      function \"=\"\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean renames E.\"=\";\n+\n+      function \"<\"\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean renames E.\"<\";\n+\n+      function \"<=\"\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean renames E.\"<=\";\n+\n+      function Find\n+        (Container : E.Sequence;\n+         Item      : Element_Type) return Count_Type\n+      --  Search for Item in Container\n+\n+      with\n+        Global => null,\n+        Post =>\n+          (if Find'Result > 0 then\n+             Find'Result <= E.Length (Container)\n+               and Equivalent_Elements (Item, E.Get (Container, Find'Result)));\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean\n+      --  The elements of Left are contained in Right\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          E_Elements_Included'Result =\n+            (for all I in 1 .. E.Length (Left) =>\n+               Find (Right, E.Get (Left, I)) > 0\n+                 and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n+                     E.Get (Left, I));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Model : M.Set;\n+         Right : E.Sequence) return Boolean\n+      --  The elements of Container contained in Model are in Right\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          E_Elements_Included'Result =\n+            (for all I in 1 .. E.Length (Left) =>\n+              (if M.Contains (Model, E.Get (Left, I)) then\n+                 Find (Right, E.Get (Left, I)) > 0\n+                   and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n+                       E.Get (Left, I)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n+\n+      function E_Elements_Included\n+        (Container : E.Sequence;\n+         Model     : M.Set;\n+         Left      : E.Sequence;\n+         Right     : E.Sequence) return Boolean\n+      --  The elements of Container contained in Model are in Left and others\n+      --  are in Right.\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          E_Elements_Included'Result =\n+            (for all I in 1 .. E.Length (Container) =>\n+              (if M.Contains (Model, E.Get (Container, I)) then\n+                 Find (Left, E.Get (Container, I)) > 0\n+                   and then E.Get (Left, Find (Left, E.Get (Container, I))) =\n+                       E.Get (Container, I)\n+               else\n+                 Find (Right, E.Get (Container, I)) > 0\n+                   and then E.Get (Right, Find (Right, E.Get (Container, I))) =\n+                       E.Get (Container, I)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n+\n+      package P is new Ada.Containers.Functional_Maps\n+        (Key_Type                       => Cursor,\n+         Element_Type                   => Positive_Count_Type,\n+         Equivalent_Keys                => \"=\",\n+         Enable_Handling_Of_Equivalence => False);\n+\n+      function \"=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"=\";\n+\n+      function \"<=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function Mapping_Preserved\n+        (E_Left  : E.Sequence;\n+         E_Right : E.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (if Mapping_Preserved'Result then\n+\n+             --  Right contains all the cursors of Left\n+\n+             P.Keys_Included (P_Left, P_Right)\n+\n+               --  Right contains all the elements of Left\n+\n+               and E_Elements_Included (E_Left, E_Right)\n \n-   No_Element : constant Cursor;\n+               --  Mappings from cursors to elements induced by E_Left, P_Left\n+               --  and E_Right, P_Right are the same.\n+\n+               and (for all C of P_Left =>\n+                     E.Get (E_Left, P.Get (P_Left, C)) =\n+                     E.Get (E_Right, P.Get (P_Right, C))));\n+\n+      function Mapping_Preserved_Except\n+        (E_Left   : E.Sequence;\n+         E_Right  : E.Sequence;\n+         P_Left   : P.Map;\n+         P_Right  : P.Map;\n+         Position : Cursor) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (if Mapping_Preserved_Except'Result then\n+\n+             --  Right contains all the cursors of Left\n+\n+             P.Keys_Included (P_Left, P_Right)\n+\n+               --  Mappings from cursors to elements induced by E_Left, P_Left\n+               --  and E_Right, P_Right are the same except for Position.\n+\n+               and (for all C of P_Left =>\n+                     (if C /= Position then\n+                        E.Get (E_Left, P.Get (P_Left, C)) =\n+                        E.Get (E_Right, P.Get (P_Right, C)))));\n+\n+      function Model (Container : Set) return M.Set with\n+      --  The high-level model of a set is a set of elements. Neither cursors\n+      --  nor order of elements are represented in this model. Elements are\n+      --  modeled up to equivalence.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => M.Length (Model'Result) = Length (Container);\n+\n+      function Elements (Container : Set) return E.Sequence with\n+      --  The Elements sequence represents the underlying list structure of\n+      --  sets that is used for iteration. It stores the actual values of\n+      --  elements in the set. It does not model cursors.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          E.Length (Elements'Result) = Length (Container)\n+\n+            --  It only contains keys contained in Model\n+\n+            and (for all Item of Elements'Result =>\n+                   M.Contains (Model (Container), Item))\n+\n+            --  It contains all the elements contained in Model\n+\n+            and (for all Item of Model (Container) =>\n+                  (Find (Elements'Result, Item) > 0\n+                     and then Equivalent_Elements\n+                      (E.Get (Elements'Result, Find (Elements'Result, Item)),\n+                       Item)))\n+\n+            --  It has no duplicate\n+\n+            and (for all I in 1 .. Length (Container) =>\n+                  Find (Elements'Result, E.Get (Elements'Result, I)) = I)\n+\n+            and (for all I in 1 .. Length (Container) =>\n+                  (for all J in 1 .. Length (Container) =>\n+                    (if Equivalent_Elements\n+                          (E.Get (Elements'Result, I),\n+                           E.Get (Elements'Result, J))\n+                     then I = J)));\n+      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Elements);\n+\n+      function Positions (Container : Set) return P.Map with\n+      --  The Positions map is used to model cursors. It only contains valid\n+      --  cursors and maps them to their position in the container.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          not P.Has_Key (Positions'Result, No_Element)\n+\n+            --  Positions of cursors are smaller than the container's length\n+\n+            and then\n+              (for all I of Positions'Result =>\n+                P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+            --  No two cursors have the same position. Note that we do not\n+            --  state that there is a cursor in the map for each position, as\n+            --  it is rarely needed.\n+\n+            and then\n+              (for all J of Positions'Result =>\n+                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n+                  then I = J)));\n+\n+      procedure Lift_Abstraction_Level (Container : Set) with\n+        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n+        --  assume that we can access the same elements by iterating over\n+        --  positions or cursors.\n+        --  This information is not generally useful except when switching from\n+        --  a low-level, cursor-aware view of a container, to a high-level,\n+        --  position-based view.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (for all Item of Elements (Container) =>\n+            (for some I of Positions (Container) =>\n+              E.Get (Elements (Container), P.Get (Positions (Container), I)) =\n+                Item));\n+\n+      function Contains\n+        (C : M.Set;\n+         K : Element_Type) return Boolean renames M.Contains;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  search for an element in the model to Contains.\n+\n+   end Formal_Model;\n+   use Formal_Model;\n+\n+   Empty_Set : constant Set;\n \n    function \"=\" (Left, Right : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       \"=\"'Result =\n+         (Length (Left) = Length (Right)\n+            and E_Elements_Included (Elements (Left), Elements (Right)))\n+       and\n+         \"=\"'Result =\n+           (E_Elements_Included (Elements (Left), Elements (Right))\n+              and E_Elements_Included (Elements (Right), Elements (Left)));\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Equivalent_Sets'Result = (Model (Left) = Model (Right));\n \n    function To_Set (New_Item : Element_Type) return Set with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       M.Is_Singleton (Model (To_Set'Result), New_Item)\n+         and Length (To_Set'Result) = 1\n+         and E.Get (Elements (To_Set'Result), 1) = New_Item;\n \n    function Capacity (Container : Set) return Count_Type with\n-     Global => null;\n+     Global => null,\n+     Post   => Capacity'Result = Container.Capacity;\n \n    procedure Reserve_Capacity\n      (Container : in out Set;\n       Capacity  : Count_Type)\n    with\n      Global => null,\n-     Pre    => Capacity <= Container.Capacity;\n+     Pre    => Capacity <= Container.Capacity,\n+     Post   =>\n+       Model (Container) = Model (Container)'Old\n+         and Length (Container)'Old = Length (Container)\n \n-   function Length (Container : Set) return Count_Type with\n-     Global => null;\n+         --  Actual elements are preserved\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Container), Elements (Container)'Old)\n+         and\n+           E_Elements_Included\n+             (Elements (Container)'Old, Elements (Container));\n \n    function Is_Empty (Container : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out Set) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n \n    procedure Assign (Target : in out Set; Source : Set) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)\n+         and Length (Target) = Length (Source)\n+\n+         --  Actual elements are preserved\n+\n+         and\n+           E_Elements_Included (Elements (Target), Elements (Source))\n+         and\n+           E_Elements_Included (Elements (Source), Elements (Target));\n \n    function Copy\n      (Source   : Set;\n       Capacity : Count_Type := 0) return Set\n    with\n      Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and Elements (Copy'Result) = Elements (Source)\n+         and Positions (Copy'Result) = Positions (Source)\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Source.Capacity\n+              else\n+                 Copy'Result.Capacity = Capacity);\n \n    function Element\n      (Container : Set;\n       Position  : Cursor) return Element_Type\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Element'Result =\n+         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old\n+\n+          --  Position now maps to New_Item\n+\n+          and Element (Container, Position) = New_Item\n+\n+          --  New_Item is contained in Container\n+\n+          and Contains (Model (Container), New_Item)\n+\n+          --  Other elements are preserved\n+\n+          and M.Included_Except\n+                (Model (Container)'Old,\n+                 Model (Container),\n+                 Element (Container, Position)'Old)\n+          and M.Included_Except\n+                (Model (Container),\n+                 Model (Container)'Old,\n+                 New_Item)\n+\n+          --  Mapping from cursors to elements is preserved\n+\n+          and Mapping_Preserved_Except\n+                (E_Left   => Elements (Container)'Old,\n+                 E_Right  => Elements (Container),\n+                 P_Left   => Positions (Container)'Old,\n+                 P_Right  => Positions (Container),\n+                 Position => Position)\n+          and Positions (Container) = Positions (Container)'Old;\n \n    procedure Move (Target : in out Set; Source : in out Set) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Length (Source) = 0\n+         and Model (Target) = Model (Source)'Old\n+         and Length (Target) = Length (Source)'Old\n+\n+         --  Actual elements are preserved\n+\n+         and\n+           E_Elements_Included (Elements (Target), Elements (Source)'Old)\n+         and\n+           E_Elements_Included (Elements (Source)'Old, Elements (Target));\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity\n+         or Contains (Container, New_Item),\n+     Post           =>\n+       Contains (Container, New_Item)\n+         and Has_Element (Container, Position)\n+         and Equivalent_Elements (Element (Container, Position), New_Item),\n+     Contract_Cases =>\n+\n+       --  If New_Item is already in Container, it is not modified and Inserted\n+       --  is set to False.\n+\n+       (Contains (Container, New_Item) =>\n+          not Inserted\n+            and Model (Container) = Model (Container)'Old\n+            and Elements (Container) = Elements (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, New_Item is inserted in Container and Inserted is set to\n+        --  True.\n+\n+        others =>\n+          Inserted\n+            and Length (Container) = Length (Container)'Old + 1\n+\n+            --  Position now maps to New_Item\n+\n+            and Element (Container, Position) = New_Item\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   New_Item)\n+\n+            --  Mapping from cursors to elements is preserved\n+\n+            and Mapping_Preserved\n+                  (E_Left  => Elements (Container)'Old,\n+                   E_Right => Elements (Container),\n+                   P_Left  => Positions (Container)'Old,\n+                   P_Right => Positions (Container))\n+            and P.Keys_Included_Except\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Position));\n \n    procedure Insert  (Container : in out Set; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Container.Capacity\n-                 and then (not Contains (Container, New_Item));\n+                 and then (not Contains (Container, New_Item)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+         and Contains (Container, New_Item)\n+         and Element (Container, Find (Container, New_Item)) = New_Item\n+\n+         --  Other elements are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+         and M.Included_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                New_Item)\n+\n+         --  Mapping from cursors to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Container)'Old,\n+                E_Right => Elements (Container),\n+                P_Left  => Positions (Container)'Old,\n+                P_Right => Positions (Container))\n+         and P.Keys_Included_Except\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Find (Container, New_Item));\n \n    procedure Include (Container : in out Set; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity\n+         or Contains (Container, New_Item),\n+     Post           =>\n+       Contains (Container, New_Item)\n+         and Element (Container, Find (Container, New_Item)) = New_Item,\n+     Contract_Cases =>\n+\n+       --  If an element equivalent to New_Item is already in Container, it is\n+       --  replaced by New_Item.\n+\n+       (Contains (Container, New_Item) =>\n+\n+          --  Elements are preserved modulo equivalence\n+\n+          Model (Container) = Model (Container)'Old\n+\n+            --  Cursors are preserved\n+\n+            and Positions (Container) = Positions (Container)'Old\n+\n+            --  The actual value of other elements is preserved\n+\n+            and E.Equal_Except\n+                  (Elements (Container)'Old,\n+                   Elements (Container),\n+                   P.Get (Positions (Container), Find (Container, New_Item))),\n+\n+        --  Otherwise, New_Item is inserted in Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old + 1\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   New_Item)\n+\n+            --  Mapping from cursors to elements is preserved\n+\n+            and Mapping_Preserved\n+                  (E_Left  => Elements (Container)'Old,\n+                   E_Right => Elements (Container),\n+                   P_Left  => Positions (Container)'Old,\n+                   P_Right => Positions (Container))\n+            and P.Keys_Included_Except\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Find (Container, New_Item)));\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) with\n      Global => null,\n-     Pre    => Contains (Container, New_Item);\n+     Pre    => Contains (Container, New_Item),\n+     Post   =>\n \n-   procedure Exclude (Container : in out Set; Item     : Element_Type) with\n-     Global => null;\n+       --  Elements are preserved modulo equivalence\n+\n+       Model (Container) = Model (Container)'Old\n+         and Contains (Container, New_Item)\n \n-   procedure Delete  (Container : in out Set; Item     : Element_Type) with\n+         --  Cursors are preserved\n+\n+         and Positions (Container) = Positions (Container)'Old\n+\n+         --  The element equivalent to New_Item in Container is replaced by\n+         --  New_Item.\n+\n+         and Element (Container, Find (Container, New_Item)) = New_Item\n+         and E.Equal_Except\n+               (Elements (Container)'Old,\n+                Elements (Container),\n+                P.Get (Positions (Container), Find (Container, New_Item)));\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type) with\n+     Global         => null,\n+     Post           => not Contains (Container, Item),\n+     Contract_Cases =>\n+\n+       --  If Item is not in Container, nothing is changed\n+\n+       (not Contains (Container, Item) =>\n+          Model (Container) = Model (Container)'Old\n+            and Elements (Container) = Elements (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, Item is removed from Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Item)\n+\n+            --  Mapping from cursors to elements is preserved\n+\n+            and Mapping_Preserved\n+                  (E_Left  => Elements (Container),\n+                   E_Right => Elements (Container)'Old,\n+                   P_Left  => Positions (Container),\n+                   P_Right => Positions (Container)'Old)\n+            and P.Keys_Included_Except\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Find (Container, Item)'Old));\n+\n+   procedure Delete  (Container : in out Set; Item : Element_Type) with\n      Global => null,\n-     Pre    => Contains (Container, Item);\n+     Pre    => Contains (Container, Item),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Item is no longer in Container\n+\n+         and not Contains (Container, Item)\n \n-   procedure Delete (Container : in out Set; Position  : in out Cursor) with\n+         --  Other elements are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Item)\n+\n+         --  Mapping from cursors to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Container),\n+                E_Right => Elements (Container)'Old,\n+                P_Left  => Positions (Container),\n+                P_Right => Positions (Container)'Old)\n+         and P.Keys_Included_Except\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Find (Container, Item)'Old);\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor) with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Position = No_Element\n+         and Length (Container) = Length (Container)'Old - 1\n+\n+         --  The element at position Position is no longer in Container\n+\n+         and not Contains (Container, Element (Container, Position)'Old)\n+         and not P.Has_Key (Positions (Container), Position'Old)\n+\n+         --  Other elements are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Element (Container, Position)'Old)\n+\n+         --  Mapping from cursors to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Container),\n+                E_Right => Elements (Container)'Old,\n+                P_Left  => Positions (Container),\n+                P_Right => Positions (Container)'Old)\n+         and P.Keys_Included_Except\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Position'Old);\n \n    procedure Union (Target : in out Set; Source : Set) with\n      Global => null,\n-     Pre    => Length (Target) + Length (Source) -\n-                 Length (Intersection (Target, Source)) <= Target.Capacity;\n+     Pre    =>\n+       Length (Source) - Length (Target and Source) <=\n+         Target.Capacity - Length (Target),\n+     Post   =>\n+       Length (Target) = Length (Target)'Old\n+         - M.Num_Overlaps (Model (Target)'Old, Model (Source))\n+         + Length (Source)\n+\n+         --  Elements already in Target are still in Target\n+\n+         and Model (Target)'Old <= Model (Target)\n+\n+         --  Elements of Source are included in Target\n+\n+         and Model (Source) <= Model (Target)\n+\n+         --  Elements of Target come from either Source or Target\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Target), Model (Source), Model (Target)'Old)\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Target),\n+              Model (Target)'Old,\n+              Elements (Target)'Old,\n+              Elements (Source))\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Target)'Old, Elements (Target))\n+         and\n+           E_Elements_Included\n+             (Elements (Source),\n+              Model (Target)'Old,\n+              Elements (Source),\n+              Elements (Target))\n+\n+         --  Mapping from cursors of Target to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Target)'Old,\n+                E_Right => Elements (Target),\n+                P_Left  => Positions (Target)'Old,\n+                P_Right => Positions (Target));\n \n    function Union (Left, Right : Set) return Set with\n      Global => null,\n-     Pre    => Length (Left) + Length (Right) -\n-                 Length (Intersection (Left, Right)) <= Count_Type'Last;\n+     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n+     Post   =>\n+       Length (Union'Result) = Length (Left)\n+         - M.Num_Overlaps (Model (Left), Model (Right))\n+         + Length (Right)\n+\n+         --  Elements of Left and Right are in the result of Union\n+\n+         and Model (Left) <= Model (Union'Result)\n+         and Model (Right) <= Model (Union'Result)\n+\n+         --  Elements of the result of union come from either Left or Right\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Union'Result), Model (Left), Model (Right))\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Union'Result),\n+              Model (Left),\n+              Elements (Left),\n+              Elements (Right))\n+         and\n+           E_Elements_Included\n+             (Elements (Left), Model (Left), Elements (Union'Result))\n+         and\n+           E_Elements_Included\n+             (Elements (Right),\n+              Model (Left),\n+              Elements (Right),\n+              Elements (Union'Result));\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n    procedure Intersection (Target : in out Set; Source : Set) with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Target) =\n+         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n+\n+         --  Elements of Target were already in Target\n+\n+         and Model (Target) <= Model (Target)'Old\n+\n+         --  Elements of Target are in Source\n+\n+         and Model (Target) <= Model (Source)\n+\n+         --  Elements both in Source and Target are in the intersection\n+\n+         and\n+           M.Includes_Intersection\n+             (Model (Target), Model (Source), Model (Target)'Old)\n+\n+         --  Actual value of elements of Target is preserved\n+\n+         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Source), Elements (Target))\n+\n+         --  Mapping from cursors of Target to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Target),\n+                E_Right => Elements (Target)'Old,\n+                P_Left  => Positions (Target),\n+                P_Right => Positions (Target)'Old);\n \n    function Intersection (Left, Right : Set) return Set with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Intersection'Result) =\n+         M.Num_Overlaps (Model (Left), Model (Right))\n+\n+         --  Elements in the result of Intersection are in Left and Right\n+\n+         and Model (Intersection'Result) <= Model (Left)\n+         and Model (Intersection'Result) <= Model (Right)\n+\n+         --  Elements both in Left and Right are in the result of Intersection\n+\n+         and\n+           M.Includes_Intersection\n+             (Model (Intersection'Result), Model (Left), Model (Right))\n+\n+         --  Actual value of elements come from Left\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Intersection'Result), Elements (Left))\n+         and\n+           E_Elements_Included\n+             (Elements (Left), Model (Right), Elements (Intersection'Result));\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n    procedure Difference (Target : in out Set; Source : Set) with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Target) = Length (Target)'Old -\n+         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n+\n+         --  Elements of Target were already in Target\n+\n+         and Model (Target) <= Model (Target)'Old\n+\n+         --  Elements of Target are not in Source\n+\n+         and M.No_Overlap (Model (Target), Model (Source))\n+\n+         --  Elements in Target but not in Source are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Target)'Old, Model (Target), Model (Source))\n+\n+         --  Actual value of elements of Target is preserved\n+\n+         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Target), Elements (Target))\n+\n+         --  Mapping from cursors of Target to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Target),\n+                E_Right => Elements (Target)'Old,\n+                P_Left  => Positions (Target),\n+                P_Right => Positions (Target)'Old);\n \n    function Difference (Left, Right : Set) return Set with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Difference'Result) = Length (Left) -\n+         M.Num_Overlaps (Model (Left), Model (Right))\n+\n+         --  Elements of the result of Difference are in Left\n+\n+         and Model (Difference'Result) <= Model (Left)\n+\n+         --  Elements of the result of Difference are in Right\n+\n+         and M.No_Overlap (Model (Difference'Result), Model (Right))\n+\n+         --  Elements in Left but not in Right are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Left), Model (Difference'Result), Model (Right))\n+\n+         --  Actual value of elements come from Left\n+\n+         and\n+           E_Elements_Included (Elements (Difference'Result), Elements (Left))\n+         and\n+           E_Elements_Included\n+             (Elements (Left),\n+              Model (Difference'Result),\n+              Elements (Difference'Result));\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) with\n      Global => null,\n-     Pre    => Length (Target) + Length (Source) -\n-                 2 * Length (Intersection (Target, Source)) <= Target.Capacity;\n+     Pre    =>\n+       Length (Source) - Length (Target and Source) <=\n+         Target.Capacity - Length (Target) + Length (Target and Source),\n+     Post   =>\n+       Length (Target) = Length (Target)'Old -\n+         2 * M.Num_Overlaps (Model (Target)'Old, Model (Source)) +\n+         Length (Source)\n+\n+         --  Elements of the difference were not both in Source and in Target\n+\n+         and M.Not_In_Both (Model (Target), Model (Target)'Old, Model (Source))\n+\n+         --  Elements in Target but not in Source are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Target)'Old, Model (Target), Model (Source))\n+\n+         --  Elements in Source but not in Target are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Source), Model (Target), Model (Target)'Old)\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Target),\n+              Model (Target)'Old,\n+              Elements (Target)'Old,\n+              Elements (Source))\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Target), Elements (Target))\n+         and\n+           E_Elements_Included\n+             (Elements (Source), Model (Target), Elements (Target));\n \n    function Symmetric_Difference (Left, Right : Set) return Set with\n      Global => null,\n-     Pre    => Length (Left) + Length (Right) -\n-                 2 * Length (Intersection (Left, Right)) <= Count_Type'Last;\n+     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n+     Post   =>\n+       Length (Symmetric_Difference'Result) = Length (Left) -\n+         2 * M.Num_Overlaps (Model (Left), Model (Right)) +\n+         Length (Right)\n+\n+         --  Elements of the difference were not both in Left and Right\n+\n+         and\n+           M.Not_In_Both\n+             (Model (Symmetric_Difference'Result), Model (Left), Model (Right))\n+\n+         --  Elements in Left but not in Right are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Left), Model (Symmetric_Difference'Result), Model (Right))\n+\n+         --  Elements in Right but not in Left are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Right), Model (Symmetric_Difference'Result), Model (Left))\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Symmetric_Difference'Result),\n+              Model (Left),\n+              Elements (Left),\n+              Elements (Right))\n+         and\n+           E_Elements_Included\n+             (Elements (Left),\n+              Model (Symmetric_Difference'Result),\n+              Elements (Symmetric_Difference'Result))\n+         and\n+           E_Elements_Included\n+             (Elements (Right),\n+              Model (Symmetric_Difference'Result),\n+              Elements (Symmetric_Difference'Result));\n \n    function \"xor\" (Left, Right : Set) return Set\n      renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Overlap'Result = not (M.No_Overlap (Model (Left), Model (Right)));\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Subset'Result = (Model (Subset) <= Model (Of_Set));\n \n    function First (Container : Set) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          First'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, First'Result)\n+            and P.Get (Positions (Container), First'Result) = 1);\n \n    function Next (Container : Set; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Next'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Next'Result)\n+            and then P.Get (Positions (Container), Next'Result) =\n+                     P.Get (Positions (Container), Position) + 1);\n \n    procedure Next (Container : Set; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) + 1);\n \n    function Find\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean with\n-     Global => null;\n+       --  If Item is not contained in Container, Find returns No_Element\n \n-   function Has_Element (Container : Set; Position : Cursor) return Boolean\n-   with\n-     Global => null;\n+       (not Contains (Model (Container), Item) =>\n+          Find'Result = No_Element,\n \n-   function Equivalent_Elements (Left  : Set; CLeft : Cursor;\n-                                 Right : Set; CRight : Cursor) return Boolean\n-   with\n-     Global => null;\n+        --  Otherwise, Find returns a valid cursor in Container\n \n-   function Equivalent_Elements\n-     (Left  : Set; CLeft : Cursor;\n-      Right : Element_Type) return Boolean\n-   with\n-     Global => null;\n+        others =>\n+          P.Has_Key (Positions (Container), Find'Result)\n+            and P.Get (Positions (Container), Find'Result) =\n+                Find (Elements (Container), Item)\n+\n+            --  The element designated by the result of Find is Item\n+\n+            and Equivalent_Elements\n+                  (Element (Container, Find'Result), Item));\n \n-   function Equivalent_Elements\n-     (Left  : Element_Type;\n-      Right : Set; CRight : Cursor) return Boolean\n+   function Contains (Container : Set; Item : Element_Type) return Boolean with\n+     Global => null,\n+     Post   => Contains'Result = Contains (Model (Container), Item);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n+\n+   function Has_Element (Container : Set; Position : Cursor) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n      Global => null;\n@@ -282,59 +1156,171 @@ is\n \n    package Generic_Keys with SPARK_Mode is\n \n+      package Formal_Model with Ghost is\n+\n+         function M_Included_Except\n+           (Left  : M.Set;\n+            Right : M.Set;\n+            Key   : Key_Type) return Boolean\n+           with\n+             Global => null,\n+             Post   =>\n+               M_Included_Except'Result =\n+                 (for all E of Left =>\n+                    Contains (Right, E)\n+                      or Equivalent_Keys (Generic_Keys.Key (E), Key));\n+\n+      end Formal_Model;\n+      use Formal_Model;\n+\n       function Key (Container : Set; Position : Cursor) return Key_Type with\n-        Global => null;\n+        Global => null,\n+        Post   => Key'Result = Key (Element (Container, Position));\n+      pragma Annotate (GNATprove, Inline_For_Proof, Key);\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type\n       with\n-          Global => null;\n+        Global => null,\n+        Pre    => Contains (Container, Key),\n+        Post   =>\n+          Element'Result = Element (Container, Find (Container, Key));\n+      pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n       procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       with\n-          Global => null;\n+        Global => null,\n+        Pre    => Contains (Container, Key),\n+        Post   =>\n+          Length (Container) = Length (Container)'Old\n+\n+             --  Key now maps to New_Item\n+\n+             and Element (Container, Key) = New_Item\n+\n+             --  New_Item is contained in Container\n+\n+             and Contains (Model (Container), New_Item)\n+\n+             --  Other elements are preserved\n+\n+             and M_Included_Except\n+                   (Model (Container)'Old,\n+                    Model (Container),\n+                    Key)\n+             and M.Included_Except\n+                   (Model (Container),\n+                    Model (Container)'Old,\n+                    New_Item)\n+\n+             --  Mapping from cursors to elements is preserved\n+\n+             and Mapping_Preserved_Except\n+                   (E_Left   => Elements (Container)'Old,\n+                    E_Right  => Elements (Container),\n+                    P_Left   => Positions (Container)'Old,\n+                    P_Right  => Positions (Container),\n+                    Position => Find (Container, Key))\n+             and Positions (Container) = Positions (Container)'Old;\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) with\n-        Global => null;\n+        Global         => null,\n+        Post           => not Contains (Container, Key),\n+        Contract_Cases =>\n+\n+          --  If Key is not in Container, nothing is changed\n+\n+          (not Contains (Container, Key) =>\n+             Model (Container) = Model (Container)'Old\n+               and Elements (Container) = Elements (Container)'Old\n+               and Positions (Container) = Positions (Container)'Old,\n+\n+           --  Otherwise, Key is removed from Container\n+\n+           others =>\n+             Length (Container) = Length (Container)'Old - 1\n+\n+               --  Other elements are preserved\n+\n+               and Model (Container) <= Model (Container)'Old\n+               and M_Included_Except\n+                     (Model (Container)'Old,\n+                      Model (Container),\n+                      Key)\n+\n+               --  Mapping from cursors to elements is preserved\n+\n+               and Mapping_Preserved\n+                     (E_Left  => Elements (Container),\n+                      E_Right => Elements (Container)'Old,\n+                      P_Left  => Positions (Container),\n+                      P_Right => Positions (Container)'Old)\n+               and P.Keys_Included_Except\n+                     (Positions (Container)'Old,\n+                      Positions (Container),\n+                      Find (Container, Key)'Old));\n \n       procedure Delete (Container : in out Set; Key : Key_Type) with\n-        Global => null;\n+        Global => null,\n+        Pre    => Contains (Container, Key),\n+        Post   =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  Key is no longer in Container\n+\n+            and not Contains (Container, Key)\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M_Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Key)\n+\n+            --  Mapping from cursors to elements is preserved\n+\n+            and Mapping_Preserved\n+                  (E_Left  => Elements (Container),\n+                   E_Right => Elements (Container)'Old,\n+                   P_Left  => Positions (Container),\n+                   P_Right => Positions (Container)'Old)\n+            and P.Keys_Included_Except\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Find (Container, Key)'Old);\n \n       function Find (Container : Set; Key : Key_Type) return Cursor with\n-        Global => null;\n+        Global         => null,\n+        Contract_Cases =>\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean with\n-        Global => null;\n+          --  If Key is not contained in Container, Find returns No_Element\n \n-   end Generic_Keys;\n+          ((for all E of Model (Container) =>\n+               not Equivalent_Keys (Key, Generic_Keys.Key (E))) =>\n+             Find'Result = No_Element,\n \n-   function Strict_Equal (Left, Right : Set) return Boolean with\n-     Ghost,\n-     Global => null;\n-   --  Strict_Equal returns True if the containers are physically equal, i.e.\n-   --  they are structurally equal (function \"=\" returns True) and that they\n-   --  have the same set of cursors.\n+           --  Otherwise, Find returns a valid cursor in Container\n \n-   function First_To_Previous  (Container : Set; Current : Cursor) return Set\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+           others =>\n+             P.Has_Key (Positions (Container), Find'Result)\n \n-   function Current_To_Last (Container : Set; Current : Cursor) return Set\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-   --  First_To_Previous returns a container containing all elements preceding\n-   --  Current (excluded) in Container. Current_To_Last returns a container\n-   --  containing all elements following Current (included) in Container.\n-   --  These two new functions can be used to express invariant properties in\n-   --  loops which iterate over containers. First_To_Previous returns the part\n-   --  of the container already scanned and Current_To_Last the part not\n-   --  scanned yet.\n+               --  The key designated by the result of Find is Key\n+\n+               and\n+                 Equivalent_Keys\n+                   (Generic_Keys.Key (Container, Find'Result), Key));\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean with\n+        Global => null,\n+        Post   =>\n+          Contains'Result =\n+            (for some E of Model (Container) =>\n+                Equivalent_Keys (Key, Generic_Keys.Key (E)));\n+\n+   end Generic_Keys;\n \n private\n    pragma SPARK_Mode (Off);\n@@ -356,12 +1342,6 @@ private\n \n    use HT_Types;\n \n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n    Empty_Set : constant Set := (Capacity => 0, Modulus => 0, others => <>);\n \n end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "4cb3227934f0229d4b0cf930c6ec2c0f2aeba358", "filename": "gcc/ada/a-cfinve.adb", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -641,6 +641,45 @@ is\n \n    package body Generic_Sorting with SPARK_Mode => Off is\n \n+      ------------------\n+      -- Formal_Model --\n+      ------------------\n+\n+      package body Formal_Model is\n+\n+         -----------------------\n+         -- M_Elements_Sorted --\n+         -----------------------\n+\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n+         begin\n+            if M.Length (Container) = 0 then\n+               return True;\n+            end if;\n+\n+            declare\n+               E1 : Element_Type := Element (Container, Index_Type'First);\n+\n+            begin\n+               for I in Index_Type'First + 1 .. M.Last (Container) loop\n+                  declare\n+                     E2 : constant Element_Type := Element (Container, I);\n+\n+                  begin\n+                     if E2 < E1 then\n+                        return False;\n+                     end if;\n+\n+                     E1 := E2;\n+                  end;\n+               end loop;\n+            end;\n+\n+            return True;\n+         end M_Elements_Sorted;\n+\n+      end Formal_Model;\n+\n       ---------------\n       -- Is_Sorted --\n       ---------------\n@@ -658,37 +697,6 @@ is\n          return True;\n       end Is_Sorted;\n \n-      -----------------------\n-      -- M_Elements_Sorted --\n-      -----------------------\n-\n-      function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-      begin\n-         if M.Length (Container) = 0 then\n-            return True;\n-         end if;\n-\n-         declare\n-            E1 : Element_Type := Element (Container, Index_Type'First);\n-\n-         begin\n-            for I in Index_Type'First + 1 .. M.Last (Container) loop\n-               declare\n-                  E2 : constant Element_Type := Element (Container, I);\n-\n-               begin\n-                  if E2 < E1 then\n-                     return False;\n-                  end if;\n-\n-                  E1 := E2;\n-               end;\n-            end loop;\n-         end;\n-\n-         return True;\n-      end M_Elements_Sorted;\n-\n       ----------\n       -- Sort --\n       ----------"}, {"sha": "e1bc30cf0b512a983931cc19e56079978c308f6e", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -723,7 +723,7 @@ is\n      Global         => null,\n      Contract_Cases =>\n \n-       --  If Item is not is not contained in Container after Index, Find_Index\n+       --  If Item is not contained in Container after Index, Find_Index\n        --  returns No_Index.\n \n        (Index > Last_Index (Container)\n@@ -760,7 +760,7 @@ is\n      Global         => null,\n      Contract_Cases =>\n \n-       --  If Item is not is not contained in Container before Index,\n+       --  If Item is not contained in Container before Index,\n        --  Reverse_Find_Index returns No_Index.\n \n        (not M.Contains\n@@ -821,16 +821,22 @@ is\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting with SPARK_Mode is\n-      function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          M_Elements_Sorted'Result =\n-            (for all I in Index_Type'First .. M.Last (Container) =>\n-              (for all J in I .. M.Last (Container) =>\n-                Element (Container, I) = Element (Container, J)\n-                  or Element (Container, I) < Element (Container, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      package Formal_Model with Ghost is\n+\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n+         with\n+           Global => null,\n+           Post   =>\n+             M_Elements_Sorted'Result =\n+               (for all I in Index_Type'First .. M.Last (Container) =>\n+                  (for all J in I .. M.Last (Container) =>\n+                       Element (Container, I) = Element (Container, J)\n+                         or Element (Container, I) < Element (Container, J)));\n+         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      end Formal_Model;\n+      use Formal_Model;\n \n       function Is_Sorted (Container : Vector) return Boolean with\n         Global => null,"}, {"sha": "a7dc514f646a4f4baa295a5165e395976a92da09", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -514,6 +514,23 @@ is\n \n    package body Formal_Model is\n \n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n+      is\n+      begin\n+         for I in 1 .. K.Length (Container) loop\n+            if Equivalent_Keys (Key, K.Get (Container, I)) then\n+               return I;\n+            elsif Key < K.Get (Container, I) then\n+               return 0;\n+            end if;\n+         end loop;\n+         return 0;\n+      end Find;\n+\n       -------------------------\n       -- K_Bigger_Than_Range --\n       -------------------------"}, {"sha": "6b0597ec2f87de0de2e890f6eb838a037ba237b9", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -171,6 +171,16 @@ is\n                        Key)));\n       pragma Annotate (GNATprove, Inline_For_Proof, K_Is_Find);\n \n+      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n+      --  Search for Key in Container\n+\n+      with\n+        Global => null,\n+        Post =>\n+          (if Find'Result > 0 then\n+             Find'Result <= K.Length (Container)\n+               and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n+\n       package P is new Ada.Containers.Functional_Maps\n         (Key_Type                       => Cursor,\n          Element_Type                   => Positive_Count_Type,\n@@ -240,17 +250,16 @@ is\n \n             --  It contains all the keys contained in Model\n \n-            and\n-              (for all Key of Model (Container) =>\n-                (for some L of Keys'Result => Equivalent_Keys (L, Key)))\n+            and (for all Key of Model (Container) =>\n+                  (Find (Keys'Result, Key) > 0\n+                     and then Equivalent_Keys\n+                      (K.Get (Keys'Result, Find (Keys'Result, Key)), Key)))\n \n             --  It is sorted in increasing order\n \n-            and\n-              (for all I in 1 .. Length (Container) =>\n-                (for all J in 1 .. Length (Container) =>\n-                   (K.Get (Keys'Result, I) < K.Get (Keys'Result, J)) =\n-                   (I < J)));\n+            and (for all I in 1 .. Length (Container) =>\n+                  Find (Keys'Result, K.Get (Keys'Result, I)) = I\n+                  and K_Is_Find (Keys'Result, K.Get (Keys'Result, I), I));\n       pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n \n       function Positions (Container : Map) return P.Map with\n@@ -482,7 +491,7 @@ is\n \n          --  Key now maps to New_Item\n \n-         and Formal_Ordered_Maps.Key (Container, Find (Container, Key)) = Key\n+         and K.Get (Keys (Container), Find (Keys (Container), Key)) = Key\n          and Element (Model (Container), Key) = New_Item\n \n          --  Other mappings are preserved\n@@ -499,15 +508,14 @@ is\n                (Left  => Keys (Container)'Old,\n                 Right => Keys (Container),\n                 Fst   => 1,\n-                Lst   =>\n-                  P.Get (Positions (Container), Find (Container, Key)) - 1)\n+                Lst   => Find (Keys (Container), Key) - 1)\n \n          --  Other keys are shifted by 1\n \n          and K.Range_Shifted\n                (Left   => Keys (Container)'Old,\n                 Right  => Keys (Container),\n-                Fst    => P.Get (Positions (Container), Find (Container, Key)),\n+                Fst    => Find (Keys (Container), Key),\n                 Lst    => Length (Container)'Old,\n                 Offset => 1)\n \n@@ -516,7 +524,7 @@ is\n          and P_Positions_Shifted\n                (Positions (Container)'Old,\n                 Positions (Container),\n-                Cut => P.Get (Positions (Container), Find (Container, Key)));\n+                Cut => Find (Keys (Container), Key));\n \n    procedure Include\n      (Container : in out Map;\n@@ -541,13 +549,12 @@ is\n             --  The key equivalent to Key in Container is replaced by Key\n \n             and K.Get\n-                  (Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key))) = Key\n+                  (Keys (Container), Find (Keys (Container), Key)) = Key\n \n             and K.Equal_Except\n                   (Keys (Container)'Old,\n                    Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key)))\n+                   Find (Keys (Container), Key))\n \n             --  Elements associated with other keys are preserved\n \n@@ -573,25 +580,22 @@ is\n             --  Key is inserted in Container\n \n             and K.Get\n-                  (Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key))) = Key\n+                  (Keys (Container), Find (Keys (Container), Key)) = Key\n \n             --  The keys of Container located before Key are preserved\n \n             and K.Range_Equal\n                   (Left  => Keys (Container)'Old,\n                    Right => Keys (Container),\n                    Fst   => 1,\n-                   Lst   =>\n-                     P.Get (Positions (Container), Find (Container, Key)) - 1)\n+                   Lst   => Find (Keys (Container), Key) - 1)\n \n             --  Other keys are shifted by 1\n \n             and K.Range_Shifted\n                   (Left   => Keys (Container)'Old,\n                    Right  => Keys (Container),\n-                   Fst    =>\n-                     P.Get (Positions (Container), Find (Container, Key)),\n+                   Fst    => Find (Keys (Container), Key),\n                    Lst    => Length (Container)'Old,\n                    Offset => 1)\n \n@@ -600,8 +604,7 @@ is\n             and P_Positions_Shifted\n                   (Positions (Container)'Old,\n                    Positions (Container),\n-                   Cut =>\n-                     P.Get (Positions (Container), Find (Container, Key))));\n+                   Cut => Find (Keys (Container), Key)));\n \n    procedure Replace\n      (Container : in out Map;\n@@ -610,20 +613,19 @@ is\n    with\n      Global => null,\n      Pre    => Contains (Container, Key),\n-     Post  =>\n+     Post   =>\n \n        --  Cursors are preserved\n \n        Positions (Container) = Positions (Container)'Old\n \n          --  The key equivalent to Key in Container is replaced by Key\n \n-         and K.Get (Keys (Container),\n-                    P.Get (Positions (Container), Find (Container, Key))) = Key\n+         and K.Get (Keys (Container), Find (Keys (Container), Key)) = Key\n          and K.Equal_Except\n               (Keys (Container)'Old,\n                Keys (Container),\n-               P.Get (Positions (Container), Find (Container, Key)))\n+               Find (Keys (Container), Key))\n \n          --  New_Item is now associated with the Key in Container\n \n@@ -668,17 +670,14 @@ is\n                   (Left  => Keys (Container)'Old,\n                    Right => Keys (Container),\n                    Fst   => 1,\n-                   Lst   =>\n-                     P.Get (Positions (Container), Find (Container, Key))'Old\n-                       - 1)\n+                   Lst   => Find (Keys (Container), Key)'Old - 1)\n \n             --  The keys located after Key are shifted by 1\n \n             and K.Range_Shifted\n                   (Left   => Keys (Container),\n                    Right  => Keys (Container)'Old,\n-                   Fst    =>\n-                     P.Get (Positions (Container), Find (Container, Key))'Old,\n+                   Fst    => Find (Keys (Container), Key)'Old,\n                    Lst    => Length (Container),\n                    Offset => 1)\n \n@@ -687,9 +686,7 @@ is\n             and P_Positions_Shifted\n                   (Positions (Container),\n                    Positions (Container)'Old,\n-                   Cut   =>\n-                     P.Get\n-                       (Positions (Container), Find (Container, Key))'Old));\n+                   Cut   => Find (Keys (Container), Key)'Old));\n \n    procedure Delete (Container : in out Map; Key : Key_Type) with\n      Global => null,\n@@ -715,16 +712,14 @@ is\n                (Left  => Keys (Container)'Old,\n                 Right => Keys (Container),\n                 Fst   => 1,\n-                Lst   =>\n-                  P.Get (Positions (Container), Find (Container, Key))'Old - 1)\n+                Lst   => Find (Keys (Container), Key)'Old - 1)\n \n          --  The keys located after Key are shifted by 1\n \n          and K.Range_Shifted\n                (Left   => Keys (Container),\n                 Right  => Keys (Container)'Old,\n-                Fst    =>\n-                  P.Get (Positions (Container), Find (Container, Key))'Old,\n+                Fst    => Find (Keys (Container), Key)'Old,\n                 Lst    => Length (Container),\n                 Offset => 1)\n \n@@ -733,8 +728,7 @@ is\n          and P_Positions_Shifted\n                (Positions (Container),\n                 Positions (Container)'Old,\n-                Cut   =>\n-                  P.Get (Positions (Container), Find (Container, Key))'Old);\n+                Cut   => Find (Keys (Container), Key)'Old);\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) with\n      Global => null,\n@@ -960,29 +954,23 @@ is\n      Global         => null,\n      Contract_Cases =>\n \n-       --  If Key is not is not contained in Container, Find returns No_Element\n+       --  If Key is not contained in Container, Find returns No_Element\n \n        (not Contains (Model (Container), Key) =>\n           not P.Has_Key (Positions (Container), Find'Result)\n             and Find'Result = No_Element,\n \n-        --  Otherwise, Find returns a valid cusror in Container\n+        --  Otherwise, Find returns a valid cursor in Container\n \n         others =>\n           P.Has_Key (Positions (Container), Find'Result)\n+            and P.Get (Positions (Container), Find'Result) =\n+                Find (Keys (Container), Key)\n \n             --  The key designated by the result of Find is Key\n \n             and Equivalent_Keys\n-                  (Formal_Ordered_Maps.Key (Container, Find'Result), Key)\n-\n-            --  Keys of Container are ordered\n-\n-            and K_Is_Find\n-                  (Keys (Container),\n-                   Key,\n-                   P.Get (Positions (Container),\n-                   Find'Result)));\n+                  (Formal_Ordered_Maps.Key (Container, Find'Result), Key));\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type with\n      Global => null,"}, {"sha": "47e863bfbd552ee3ac36306906446c548aa3670e", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 438, "deletions": 88, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -360,34 +360,6 @@ is\n       return Target;\n    end Copy;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n-\n-   function Current_To_Last (Container : Set; Current : Cursor) return Set is\n-      Curs : Cursor := First (Container);\n-      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if Current /= No_Element and not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Current.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Current_To_Last;\n-\n    ------------\n    -- Delete --\n    ------------\n@@ -596,36 +568,6 @@ is\n       end;\n    end First_Element;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n-\n-   function First_To_Previous\n-     (Container : Set;\n-      Current   : Cursor) return Set\n-   is\n-      Curs : Cursor := Current;\n-      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         return C;\n-\n-      elsif not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-\n-      else\n-         while Curs.Node /= 0 loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n-         end loop;\n-\n-         return C;\n-      end if;\n-   end First_To_Previous;\n-\n    -----------\n    -- Floor --\n    -----------\n@@ -644,6 +586,333 @@ is\n       end;\n    end Floor;\n \n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n+\n+   package body Formal_Model is\n+\n+      -------------------------\n+      -- E_Bigger_Than_Range --\n+      -------------------------\n+\n+      function E_Bigger_Than_Range\n+        (Container : E.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Item      : Element_Type) return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if not (E.Get (Container, I) < Item) then\n+               return False;\n+            end if;\n+         end loop;\n+         return True;\n+      end E_Bigger_Than_Range;\n+\n+      -------------------------\n+      -- E_Elements_Included --\n+      -------------------------\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. E.Length (Left) loop\n+            if not E.Contains (Right, 1, E.Length (Right), E.Get (Left, I))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end E_Elements_Included;\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Model : M.Set;\n+         Right : E.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. E.Length (Left) loop\n+            declare\n+               Item : constant Element_Type := E.Get (Left, I);\n+            begin\n+               if M.Contains (Model, Item) then\n+                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end E_Elements_Included;\n+\n+      function E_Elements_Included\n+        (Container : E.Sequence;\n+         Model     : M.Set;\n+         Left      : E.Sequence;\n+         Right     : E.Sequence) return Boolean\n+      is\n+      begin\n+         for I in 1 .. E.Length (Container) loop\n+            declare\n+               Item : constant Element_Type := E.Get (Container, I);\n+            begin\n+               if M.Contains (Model, Item) then\n+                  if not E.Contains (Left, 1, E.Length (Left), Item) then\n+                     return False;\n+                  end if;\n+               else\n+                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end E_Elements_Included;\n+\n+      ---------------\n+      -- E_Is_Find --\n+      ---------------\n+\n+      function E_Is_Find\n+        (Container : E.Sequence;\n+         Item      : Element_Type;\n+         Position  : Count_Type) return Boolean\n+      is\n+      begin\n+         for I in 1 .. Position - 1 loop\n+            if Item < E.Get (Container, I) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         if Position < E.Length (Container) then\n+            for I in Position + 1 .. E.Length (Container) loop\n+               if E.Get (Container, I) < Item then\n+                  return False;\n+               end if;\n+            end loop;\n+         end if;\n+         return True;\n+      end E_Is_Find;\n+\n+      --------------------------\n+      -- E_Smaller_Than_Range --\n+      --------------------------\n+\n+      function E_Smaller_Than_Range\n+        (Container : E.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Item      : Element_Type) return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if not (Item < E.Get (Container, I)) then\n+               return False;\n+            end if;\n+         end loop;\n+         return True;\n+      end E_Smaller_Than_Range;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find\n+        (Container : E.Sequence;\n+         Item      : Element_Type) return Count_Type\n+      is\n+      begin\n+         for I in 1 .. E.Length (Container) loop\n+            if Equivalent_Elements (Item, E.Get (Container, I)) then\n+               return I;\n+            end if;\n+         end loop;\n+         return 0;\n+      end Find;\n+\n+      --------------\n+      -- Elements --\n+      --------------\n+\n+      function Elements (Container : Set) return E.Sequence is\n+         Position : Count_Type := Container.First;\n+         R        : E.Sequence;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := E.Add (R, Container.Nodes (Position).Element);\n+            Position := Tree_Operations.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Elements;\n+\n+      ----------------------------\n+      -- Lift_Abstraction_Level --\n+      ----------------------------\n+\n+      procedure Lift_Abstraction_Level (Container : Set) is null;\n+\n+      -----------------------\n+      -- Mapping_Preserved --\n+      -----------------------\n+\n+      function Mapping_Preserved\n+        (E_Left  : E.Sequence;\n+         E_Right : E.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      is\n+      begin\n+         for C of P_Left loop\n+            if not P.Has_Key (P_Right, C)\n+              or else P.Get (P_Left,  C) > E.Length (E_Left)\n+              or else P.Get (P_Right, C) > E.Length (E_Right)\n+              or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n+                      E.Get (E_Right, P.Get (P_Right, C))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved;\n+\n+      ------------------------------\n+      -- Mapping_Preserved_Except --\n+      ------------------------------\n+\n+      function Mapping_Preserved_Except\n+        (E_Left   : E.Sequence;\n+         E_Right  : E.Sequence;\n+         P_Left   : P.Map;\n+         P_Right  : P.Map;\n+         Position : Cursor) return Boolean\n+      is\n+      begin\n+         for C of P_Left loop\n+            if C /= Position\n+              and (not P.Has_Key (P_Right, C)\n+                    or else P.Get (P_Left,  C) > E.Length (E_Left)\n+                    or else P.Get (P_Right, C) > E.Length (E_Right)\n+                    or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n+                            E.Get (E_Right, P.Get (P_Right, C)))\n+            then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end Mapping_Preserved_Except;\n+\n+      -------------------------\n+      -- P_Positions_Shifted --\n+      -------------------------\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      is\n+      begin\n+         for Cu of Small loop\n+            if not P.Has_Key (Big, Cu) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for Cu of Big loop\n+            declare\n+               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+\n+            begin\n+               if Pos < Cut then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu)\n+                  then\n+                     return False;\n+                  end if;\n+\n+               elsif Pos >= Cut + Count then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu) + Count\n+                  then\n+                     return False;\n+                  end if;\n+\n+               else\n+                  if P.Has_Key (Small, Cu) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end P_Positions_Shifted;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : Set) return M.Set is\n+         Position : Count_Type := Container.First;\n+         R        : M.Set;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R :=\n+              M.Add\n+                (Container => R,\n+                 Item      => Container.Nodes (Position).Element);\n+\n+            Position := Tree_Operations.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Model;\n+\n+      ---------------\n+      -- Positions --\n+      ---------------\n+\n+      function Positions (Container : Set) return P.Map is\n+         I        : Count_Type := 1;\n+         Position : Count_Type := Container.First;\n+         R        : P.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := P.Add (R, (Node => Position), I);\n+            pragma Assert (P.Length (R) = I);\n+            Position := Tree_Operations.Next (Container, Position);\n+            I := I + 1;\n+         end loop;\n+\n+         return R;\n+      end Positions;\n+\n+   end Formal_Model;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -807,6 +1076,116 @@ is\n          return (if Node = 0 then No_Element else (Node => Node));\n       end Floor;\n \n+      ------------------\n+      -- Formal_Model --\n+      ------------------\n+\n+      package body Formal_Model is\n+\n+         -------------------------\n+         -- E_Bigger_Than_Range --\n+         -------------------------\n+\n+         function E_Bigger_Than_Range\n+           (Container : E.Sequence;\n+            Fst       : Positive_Count_Type;\n+            Lst       : Count_Type;\n+            Key       : Key_Type) return Boolean\n+         is\n+         begin\n+            for I in Fst .. Lst loop\n+               if not (Generic_Keys.Key (E.Get (Container, I)) < Key) then\n+                  return False;\n+               end if;\n+            end loop;\n+            return True;\n+         end E_Bigger_Than_Range;\n+\n+         ---------------\n+         -- E_Is_Find --\n+         ---------------\n+\n+         function E_Is_Find\n+           (Container : E.Sequence;\n+            Key       : Key_Type;\n+            Position  : Count_Type) return Boolean\n+         is\n+         begin\n+            for I in 1 .. Position - 1 loop\n+               if Key < Generic_Keys.Key (E.Get (Container, I)) then\n+                  return False;\n+               end if;\n+            end loop;\n+\n+            if Position < E.Length (Container) then\n+               for I in Position + 1 .. E.Length (Container) loop\n+                  if Generic_Keys.Key (E.Get (Container, I)) < Key then\n+                     return False;\n+                  end if;\n+               end loop;\n+            end if;\n+            return True;\n+         end E_Is_Find;\n+\n+         --------------------------\n+         -- E_Smaller_Than_Range --\n+         --------------------------\n+\n+         function E_Smaller_Than_Range\n+           (Container : E.Sequence;\n+            Fst       : Positive_Count_Type;\n+            Lst       : Count_Type;\n+            Key       : Key_Type) return Boolean\n+         is\n+         begin\n+            for I in Fst .. Lst loop\n+               if not (Key < Generic_Keys.Key (E.Get (Container, I))) then\n+                  return False;\n+               end if;\n+            end loop;\n+            return True;\n+         end E_Smaller_Than_Range;\n+\n+         ----------\n+         -- Find --\n+         ----------\n+\n+         function Find\n+           (Container : E.Sequence;\n+            Key       : Key_Type) return Count_Type\n+         is\n+         begin\n+            for I in 1 .. E.Length (Container) loop\n+               if Equivalent_Keys\n+                   (Key, Generic_Keys.Key (E.Get (Container, I)))\n+               then\n+                  return I;\n+               end if;\n+            end loop;\n+            return 0;\n+         end Find;\n+\n+         -----------------------\n+         -- M_Included_Except --\n+         -----------------------\n+\n+         function M_Included_Except\n+           (Left  : M.Set;\n+            Right : M.Set;\n+            Key   : Key_Type) return Boolean\n+         is\n+         begin\n+            for E of Left loop\n+               if not Contains (Right, E)\n+                 and not Equivalent_Keys (Generic_Keys.Key (E), Key)\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+            return True;\n+         end M_Included_Except;\n+      end Formal_Model;\n+\n       -------------------------\n       -- Is_Greater_Key_Node --\n       -------------------------\n@@ -1441,35 +1820,6 @@ is\n       Node.Right := Right;\n    end Set_Right;\n \n-   ------------------\n-   -- Strict_Equal --\n-   ------------------\n-\n-   function Strict_Equal (Left, Right : Set) return Boolean is\n-      LNode : Count_Type := First (Left).Node;\n-      RNode : Count_Type := First (Right).Node;\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      while LNode = RNode loop\n-         if LNode = 0 then\n-            return True;\n-         end if;\n-\n-         if Left.Nodes (LNode).Element /= Right.Nodes (RNode).Element then\n-            exit;\n-         end if;\n-\n-         LNode := Next (Left, LNode);\n-         RNode := Next (Right, RNode);\n-      end loop;\n-\n-      return False;\n-   end Strict_Equal;\n-\n    --------------------------\n    -- Symmetric_Difference --\n    --------------------------"}, {"sha": "6c1323d96a648a681105498105a43b194e6bcad9", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 1516, "deletions": 120, "changes": 1636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,34 +46,28 @@\n --    container. The operators \"<\" and \">\" that could not be modified that way\n --    have been removed.\n \n---    There are three new functions:\n-\n---      function Strict_Equal (Left, Right : Set) return Boolean;\n---      function First_To_Previous (Container : Set; Current : Cursor)\n---         return Set;\n---      function Current_To_Last (Container : Set; Current : Cursor)\n---         return Set;\n-\n---    See detailed specifications for these subprograms\n-\n+with Ada.Containers.Functional_Maps;\n+with Ada.Containers.Functional_Sets;\n+with Ada.Containers.Functional_Vectors;\n private with Ada.Containers.Red_Black_Trees;\n \n generic\n    type Element_Type is private;\n \n    with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Ordered_Sets with\n-  Pure,\n   SPARK_Mode\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Equivalent_Elements'Result =\n+         (not (Left < Right) and not (Right < Left));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Equivalent_Elements);\n \n    type Set (Capacity : Count_Type) is private with\n      Iterable => (First       => First,\n@@ -83,204 +77,1380 @@ is\n      Default_Initial_Condition => Is_Empty (Set);\n    pragma Preelaborable_Initialization (Set);\n \n-   type Cursor is private;\n-   pragma Preelaborable_Initialization (Cursor);\n+   type Cursor is record\n+      Node : Count_Type;\n+   end record;\n \n-   Empty_Set : constant Set;\n+   No_Element : constant Cursor := (Node => 0);\n+\n+   function Length (Container : Set) return Count_Type with\n+     Global => null,\n+     Post   => Length'Result <= Container.Capacity;\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+      package M is new Ada.Containers.Functional_Sets\n+        (Element_Type    => Element_Type,\n+         Equivalent_Elements => Equivalent_Elements);\n+\n+      function \"=\"\n+        (Left  : M.Set;\n+         Right : M.Set) return Boolean renames M.\"=\";\n+\n+      function \"<=\"\n+        (Left  : M.Set;\n+         Right : M.Set) return Boolean renames M.\"<=\";\n+\n+      package E is new Ada.Containers.Functional_Vectors\n+        (Element_Type => Element_Type,\n+         Index_Type   => Positive_Count_Type);\n+\n+      function \"=\"\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean renames E.\"=\";\n+\n+      function \"<\"\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean renames E.\"<\";\n+\n+      function \"<=\"\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean renames E.\"<=\";\n+\n+      function E_Bigger_Than_Range\n+        (Container : E.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Item      : Element_Type) return Boolean\n+      with\n+        Global => null,\n+        Pre    => Lst <= E.Length (Container),\n+        Post   =>\n+          E_Bigger_Than_Range'Result =\n+            (for all I in Fst .. Lst => E.Get (Container, I) < Item);\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Bigger_Than_Range);\n+\n+      function E_Smaller_Than_Range\n+        (Container : E.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Item      : Element_Type) return Boolean\n+      with\n+        Global => null,\n+        Pre    => Lst <= E.Length (Container),\n+        Post   =>\n+          E_Smaller_Than_Range'Result =\n+            (for all I in Fst .. Lst => Item < E.Get (Container, I));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Smaller_Than_Range);\n+\n+      function E_Is_Find\n+        (Container : E.Sequence;\n+         Item      : Element_Type;\n+         Position  : Count_Type) return Boolean\n+      with\n+        Global => null,\n+        Pre    => Position - 1 <= E.Length (Container),\n+        Post   =>\n+          E_Is_Find'Result =\n+\n+            ((if Position > 0 then\n+                E_Bigger_Than_Range (Container, 1, Position - 1, Item))\n+\n+             and (if Position < E.Length (Container) then\n+                    E_Smaller_Than_Range\n+                      (Container,\n+                       Position + 1,\n+                       E.Length (Container),\n+                       Item)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Is_Find);\n+\n+      function Find\n+        (Container : E.Sequence;\n+         Item      : Element_Type) return Count_Type\n+      --  Search for Item in Container\n+\n+      with\n+        Global => null,\n+        Post =>\n+          (if Find'Result > 0 then\n+             Find'Result <= E.Length (Container)\n+               and Equivalent_Elements (Item, E.Get (Container, Find'Result)));\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Right : E.Sequence) return Boolean\n+      --  The elements of Left are contained in Right\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          E_Elements_Included'Result =\n+            (for all I in 1 .. E.Length (Left) =>\n+               Find (Right, E.Get (Left, I)) > 0\n+                 and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n+                     E.Get (Left, I));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n+\n+      function E_Elements_Included\n+        (Left  : E.Sequence;\n+         Model : M.Set;\n+         Right : E.Sequence) return Boolean\n+      --  The elements of Container contained in Model are in Right\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          E_Elements_Included'Result =\n+            (for all I in 1 .. E.Length (Left) =>\n+              (if M.Contains (Model, E.Get (Left, I)) then\n+                 Find (Right, E.Get (Left, I)) > 0\n+                   and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n+                       E.Get (Left, I)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n+\n+      function E_Elements_Included\n+        (Container : E.Sequence;\n+         Model     : M.Set;\n+         Left      : E.Sequence;\n+         Right     : E.Sequence) return Boolean\n+      --  The elements of Container contained in Model are in Left and others\n+      --  are in Right.\n+\n+      with\n+        Global => null,\n+        Post   =>\n+          E_Elements_Included'Result =\n+            (for all I in 1 .. E.Length (Container) =>\n+              (if M.Contains (Model, E.Get (Container, I)) then\n+                 Find (Left, E.Get (Container, I)) > 0\n+                   and then E.Get (Left, Find (Left, E.Get (Container, I))) =\n+                       E.Get (Container, I)\n+               else\n+                 Find (Right, E.Get (Container, I)) > 0\n+                   and then E.Get (Right, Find (Right, E.Get (Container, I))) =\n+                       E.Get (Container, I)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n+\n+      package P is new Ada.Containers.Functional_Maps\n+        (Key_Type                       => Cursor,\n+         Element_Type                   => Positive_Count_Type,\n+         Equivalent_Keys                => \"=\",\n+         Enable_Handling_Of_Equivalence => False);\n+\n+      function \"=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"=\";\n+\n+      function \"<=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      with\n+        Global => null,\n+        Post   =>\n+          P_Positions_Shifted'Result =\n+\n+            --  Big contains all cursors of Small\n+\n+            (P.Keys_Included (Small, Big)\n+\n+              --  Cursors located before Cut are not moved, cursors located\n+              --  after are shifted by Count.\n+\n+              and (for all I of Small =>\n+                    (if P.Get (Small, I) < Cut then\n+                        P.Get (Big, I) = P.Get (Small, I)\n+                     else\n+                        P.Get (Big, I) - Count = P.Get (Small, I)))\n+\n+              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n+              --  Count.\n+\n+              and (for all I of Big =>\n+                    P.Has_Key (Small, I)\n+                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n+\n+      function Mapping_Preserved\n+        (E_Left  : E.Sequence;\n+         E_Right : E.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (if Mapping_Preserved'Result then\n+\n+             --  Right contains all the cursors of Left\n+\n+             P.Keys_Included (P_Left, P_Right)\n+\n+               --  Right contains all the elements of Left\n+\n+               and E_Elements_Included (E_Left, E_Right)\n+\n+               --  Mappings from cursors to elements induced by E_Left, P_Left\n+               --  and E_Right, P_Right are the same.\n+\n+               and (for all C of P_Left =>\n+                     E.Get (E_Left, P.Get (P_Left, C)) =\n+                     E.Get (E_Right, P.Get (P_Right, C))));\n+\n+      function Mapping_Preserved_Except\n+        (E_Left   : E.Sequence;\n+         E_Right  : E.Sequence;\n+         P_Left   : P.Map;\n+         P_Right  : P.Map;\n+         Position : Cursor) return Boolean\n+      with\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (if Mapping_Preserved_Except'Result then\n+\n+             --  Right contains all the cursors of Left\n+\n+             P.Keys_Included (P_Left, P_Right)\n+\n+               --  Mappings from cursors to elements induced by E_Left, P_Left\n+               --  and E_Right, P_Right are the same except for Position.\n+\n+               and (for all C of P_Left =>\n+                     (if C /= Position then\n+                        E.Get (E_Left, P.Get (P_Left, C)) =\n+                        E.Get (E_Right, P.Get (P_Right, C)))));\n+\n+      function Model (Container : Set) return M.Set with\n+      --  The high-level model of a set is a set of elements. Neither cursors\n+      --  nor order of elements are represented in this model. Elements are\n+      --  modeled up to equivalence.\n+\n+        Ghost,\n+        Global => null,\n+        Post   => M.Length (Model'Result) = Length (Container);\n+\n+      function Elements (Container : Set) return E.Sequence with\n+      --  The Elements sequence represents the underlying list structure of\n+      --  sets that is used for iteration. It stores the actual values of\n+      --  elements in the set. It does not model cursors.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          E.Length (Elements'Result) = Length (Container)\n+\n+            --  It only contains keys contained in Model\n+\n+            and (for all Item of Elements'Result =>\n+                   M.Contains (Model (Container), Item))\n+\n+            --  It contains all the elements contained in Model\n+\n+            and (for all Item of Model (Container) =>\n+                  (Find (Elements'Result, Item) > 0\n+                     and then Equivalent_Elements\n+                      (E.Get (Elements'Result, Find (Elements'Result, Item)),\n+                       Item)))\n+\n+            --  It is sorted in increasing order\n+\n+            and (for all I in 1 .. Length (Container) =>\n+                  Find (Elements'Result, E.Get (Elements'Result, I)) = I\n+                  and\n+                    E_Is_Find\n+                      (Elements'Result, E.Get (Elements'Result, I), I));\n+      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Elements);\n+\n+      function Positions (Container : Set) return P.Map with\n+      --  The Positions map is used to model cursors. It only contains valid\n+      --  cursors and maps them to their position in the container.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          not P.Has_Key (Positions'Result, No_Element)\n+\n+            --  Positions of cursors are smaller than the container's length\n+\n+            and then\n+              (for all I of Positions'Result =>\n+                P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+            --  No two cursors have the same position. Note that we do not\n+            --  state that there is a cursor in the map for each position, as\n+            --  it is rarely needed.\n+\n+            and then\n+              (for all J of Positions'Result =>\n+                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n+                  then I = J)));\n+\n+      procedure Lift_Abstraction_Level (Container : Set) with\n+        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n+        --  assume that we can access the same elements by iterating over\n+        --  positions or cursors.\n+        --  This information is not generally useful except when switching from\n+        --  a low-level, cursor-aware view of a container, to a high-level,\n+        --  position-based view.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (for all Item of Elements (Container) =>\n+            (for some I of Positions (Container) =>\n+              E.Get (Elements (Container), P.Get (Positions (Container), I)) =\n+                Item));\n+\n+      function Contains\n+        (C : M.Set;\n+         K : Element_Type) return Boolean renames M.Contains;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  search for an element in the model to Contains.\n+\n+   end Formal_Model;\n+   use Formal_Model;\n \n-   No_Element : constant Cursor;\n+   Empty_Set : constant Set;\n \n    function \"=\" (Left, Right : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+\n+       --  If two sets are equal, they contain the same elements in the same\n+       --  order.\n+\n+       (if \"=\"'Result then Elements (Left) = Elements (Right)\n+\n+        --  If they are different, then they do not contain the same elements\n+\n+        else\n+           not E_Elements_Included (Elements (Left), Elements (Right))\n+              or not E_Elements_Included (Elements (Right), Elements (Left)));\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Equivalent_Sets'Result = (Model (Left) = Model (Right));\n \n    function To_Set (New_Item : Element_Type) return Set with\n-     Global => null;\n-\n-   function Length (Container : Set) return Count_Type with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       M.Is_Singleton (Model (To_Set'Result), New_Item)\n+         and Length (To_Set'Result) = 1\n+         and E.Get (Elements (To_Set'Result), 1) = New_Item;\n \n    function Is_Empty (Container : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out Set) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n \n    procedure Assign (Target : in out Set; Source : Set) with\n-     Pre => Target.Capacity >= Length (Source);\n+     Global => null,\n+     Pre => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)\n+         and Elements (Target) = Elements (Source)\n+         and Length (Target) = Length (Source);\n \n    function Copy (Source : Set; Capacity : Count_Type := 0) return Set with\n      Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and Elements (Copy'Result) = Elements (Source)\n+         and Positions (Copy'Result) = Positions (Source)\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Source.Capacity\n+              else\n+                 Copy'Result.Capacity = Capacity);\n \n    function Element\n      (Container : Set;\n       Position  : Cursor) return Element_Type\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Element'Result =\n+         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old\n+\n+          --  Position now maps to New_Item\n+\n+          and Element (Container, Position) = New_Item\n+\n+          --  New_Item is contained in Container\n+\n+          and Contains (Model (Container), New_Item)\n+\n+          --  Other elements are preserved\n+\n+          and M.Included_Except\n+                (Model (Container)'Old,\n+                 Model (Container),\n+                 Element (Container, Position)'Old)\n+          and M.Included_Except\n+                (Model (Container),\n+                 Model (Container)'Old,\n+                 New_Item)\n+\n+          --  Mapping from cursors to elements is preserved\n+\n+          and Mapping_Preserved_Except\n+                (E_Left   => Elements (Container)'Old,\n+                 E_Right  => Elements (Container),\n+                 P_Left   => Positions (Container)'Old,\n+                 P_Right  => Positions (Container),\n+                 Position => Position)\n+          and Positions (Container) = Positions (Container)'Old;\n \n    procedure Move (Target : in out Set; Source : in out Set) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)'Old\n+         and Elements (Target) = Elements (Source)'Old\n+         and Length (Source)'Old = Length (Target)\n+         and Length (Source) = 0;\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity\n+         or Contains (Container, New_Item),\n+     Post           =>\n+       Contains (Container, New_Item)\n+         and Has_Element (Container, Position)\n+         and Equivalent_Elements (Element (Container, Position), New_Item)\n+         and E_Is_Find\n+               (Elements (Container),\n+                New_Item,\n+                P.Get (Positions (Container), Position)),\n+     Contract_Cases =>\n+\n+       --  If New_Item is already in Container, it is not modified and Inserted\n+       --  is set to False.\n+\n+       (Contains (Container, New_Item) =>\n+          not Inserted\n+            and Model (Container) = Model (Container)'Old\n+            and Elements (Container) = Elements (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, New_Item is inserted in Container and Inserted is set to\n+        --  True\n+\n+        others =>\n+          Inserted\n+            and Length (Container) = Length (Container)'Old + 1\n+\n+            --  Position now maps to New_Item\n+\n+            and Element (Container, Position) = New_Item\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   New_Item)\n+\n+            --  The elements of Container located before Position are preserved\n+\n+            and E.Range_Equal\n+                  (Left  => Elements (Container)'Old,\n+                   Right => Elements (Container),\n+                   Fst   => 1,\n+                   Lst   => P.Get (Positions (Container), Position) - 1)\n+\n+            --  Other elements are shifted by 1\n+\n+            and E.Range_Shifted\n+                  (Left   => Elements (Container)'Old,\n+                   Right  => Elements (Container),\n+                   Fst    => P.Get (Positions (Container), Position),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => 1)\n+\n+            --  A new cursor has been inserted at position Position in\n+            --  Container.\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut => P.Get (Positions (Container), Position)));\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (not Contains (Container, New_Item));\n+     Pre    =>\n+       Length (Container) < Container.Capacity\n+         and then (not Contains (Container, New_Item)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+         and Contains (Container, New_Item)\n+\n+         --  New_Item is inserted in the set\n+\n+         and E.Get (Elements (Container),\n+                    Find (Elements (Container), New_Item)) = New_Item\n+\n+         --  Other mappings are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+         and M.Included_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                New_Item)\n+\n+         --  The elements of Container located before New_Item are preserved\n+\n+         and E.Range_Equal\n+               (Left  => Elements (Container)'Old,\n+                Right => Elements (Container),\n+                Fst   => 1,\n+                Lst   => Find (Elements (Container), New_Item) - 1)\n+\n+         --  Other elements are shifted by 1\n+\n+         and E.Range_Shifted\n+               (Left   => Elements (Container)'Old,\n+                Right  => Elements (Container),\n+                Fst    => Find (Elements (Container), New_Item),\n+                Lst    => Length (Container)'Old,\n+                Offset => 1)\n+\n+         --  A new cursor has been inserted in Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut => Find (Elements (Container), New_Item));\n \n    procedure Include\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity\n+         or Contains (Container, New_Item),\n+     Post           => Contains (Container, New_Item),\n+     Contract_Cases =>\n+\n+       --  If New_Item is already in Container\n+\n+       (Contains (Container, New_Item) =>\n+\n+          --  Elements are preserved\n+\n+          Model (Container)'Old = Model (Container)\n+\n+            --  Cursors are preserved\n+\n+            and Positions (Container) = Positions (Container)'Old\n+\n+            --  The element equivalent to New_Item in Container is replaced by\n+            --  New_Item.\n+\n+            and E.Get (Elements (Container),\n+                       Find (Elements (Container), New_Item)) = New_Item\n+\n+            and E.Equal_Except\n+                  (Elements (Container)'Old,\n+                   Elements (Container),\n+                   Find (Elements (Container), New_Item)),\n+\n+        --  Otherwise, New_Item is inserted in Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old + 1\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   New_Item)\n+\n+            --  New_Item is inserted in Container\n+\n+            and E.Get (Elements (Container),\n+                       Find (Elements (Container), New_Item)) = New_Item\n+\n+            --  The Elements of Container located before New_Item are preserved\n+\n+            and E.Range_Equal\n+                  (Left  => Elements (Container)'Old,\n+                   Right => Elements (Container),\n+                   Fst   => 1,\n+                   Lst   => Find (Elements (Container), New_Item) - 1)\n+\n+            --  Other Elements are shifted by 1\n+\n+            and E.Range_Shifted\n+                  (Left   => Elements (Container)'Old,\n+                   Right  => Elements (Container),\n+                   Fst    => Find (Elements (Container), New_Item),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => 1)\n+\n+            --  A new cursor has been inserted in Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut => Find (Elements (Container), New_Item)));\n \n    procedure Replace\n      (Container : in out Set;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Contains (Container, New_Item);\n+     Pre    => Contains (Container, New_Item),\n+     Post   =>\n+\n+       --  Elements are preserved\n+\n+       Model (Container)'Old = Model (Container)\n+\n+         --  Cursors are preserved\n+\n+         and Positions (Container) = Positions (Container)'Old\n+\n+         --  The element equivalent to New_Item in Container is replaced by\n+         --  New_Item.\n+\n+         and E.Get (Elements (Container),\n+                    Find (Elements (Container), New_Item)) = New_Item\n+         and E.Equal_Except\n+              (Elements (Container)'Old,\n+               Elements (Container),\n+               Find (Elements (Container), New_Item));\n \n    procedure Exclude\n      (Container : in out Set;\n       Item      : Element_Type)\n    with\n-     Global => null;\n+     Global         => null,\n+     Post           => not Contains (Container, Item),\n+     Contract_Cases =>\n+\n+       --  If Item is not in Container, nothing is changed\n+\n+       (not Contains (Container, Item) =>\n+          Model (Container) = Model (Container)'Old\n+            and Elements (Container) = Elements (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, Item is removed from Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Item)\n+\n+            --  The elements of Container located before Item are preserved\n+\n+            and E.Range_Equal\n+                  (Left  => Elements (Container)'Old,\n+                   Right => Elements (Container),\n+                   Fst   => 1,\n+                   Lst   => Find (Elements (Container), Item)'Old - 1)\n+\n+            --  The elements located after Item are shifted by 1\n+\n+            and E.Range_Shifted\n+                  (Left   => Elements (Container),\n+                   Right  => Elements (Container)'Old,\n+                   Fst    => Find (Elements (Container), Item)'Old,\n+                   Lst    => Length (Container),\n+                   Offset => 1)\n+\n+            --  A cursor has been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => Find (Elements (Container), Item)'Old));\n \n    procedure Delete\n      (Container : in out Set;\n       Item      : Element_Type)\n    with\n      Global => null,\n-     Pre    => Contains (Container, Item);\n+     Pre    => Contains (Container, Item),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Item is no longer in Container\n+\n+         and not Contains (Container, Item)\n+\n+         --  Other elements are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Item)\n+\n+         --  The elements of Container located before Item are preserved\n+\n+         and E.Range_Equal\n+               (Left  => Elements (Container)'Old,\n+                Right => Elements (Container),\n+                Fst   => 1,\n+                Lst   => Find (Elements (Container), Item)'Old - 1)\n+\n+         --  The elements located after Item are shifted by 1\n+\n+         and E.Range_Shifted\n+               (Left   => Elements (Container),\n+                Right  => Elements (Container)'Old,\n+                Fst    => Find (Elements (Container), Item)'Old,\n+                Lst    => Length (Container),\n+                Offset => 1)\n+\n+         --  A cursor has been removed from Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => Find (Elements (Container), Item)'Old);\n \n    procedure Delete\n      (Container : in out Set;\n       Position  : in out Cursor)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Position = No_Element\n+         and Length (Container) = Length (Container)'Old - 1\n+\n+         --  The element at position Position is no longer in Container\n+\n+         and not Contains (Container, Element (Container, Position)'Old)\n+         and not P.Has_Key (Positions (Container), Position'Old)\n+\n+         --  Other elements are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Element (Container, Position)'Old)\n+\n+         --  The elements of Container located before Position are preserved.\n+\n+         and E.Range_Equal\n+               (Left  => Elements (Container)'Old,\n+                Right => Elements (Container),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+\n+         --  The elements located after Position are shifted by 1\n+\n+         and E.Range_Shifted\n+               (Left   => Elements (Container),\n+                Right  => Elements (Container)'Old,\n+                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n+                Lst    => Length (Container),\n+                Offset => 1)\n+\n+         --  Position has been removed from Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n \n    procedure Delete_First (Container : in out Set) with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 => Length (Container) = 0,\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  The first element has been removed from Container\n+\n+            and not Contains (Container, First_Element (Container)'Old)\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   First_Element (Container)'Old)\n+\n+            --  Other elements are shifted by 1\n+\n+            and E.Range_Shifted\n+                  (Left   => Elements (Container),\n+                   Right  => Elements (Container)'Old,\n+                   Fst    => 1,\n+                   Lst    => Length (Container),\n+                   Offset => 1)\n+\n+            --  First has been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => 1));\n \n    procedure Delete_Last (Container : in out Set) with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 => Length (Container) = 0,\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  The last element has been removed from Container\n+\n+            and not Contains (Container, Last_Element (Container)'Old)\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Last_Element (Container)'Old)\n+\n+            --  Others elements of Container are preserved\n+\n+            and E.Range_Equal\n+                  (Left  => Elements (Container)'Old,\n+                   Right => Elements (Container),\n+                   Fst   => 1,\n+                   Lst   => Length (Container))\n+\n+            --  Last cursor has been removed from Container\n+\n+            and Positions (Container) <= Positions (Container)'Old);\n \n    procedure Union (Target : in out Set; Source : Set) with\n      Global => null,\n-     Pre    => Length (Target) + Length (Source) -\n-                 Length (Intersection (Target, Source)) <= Target.Capacity;\n+     Pre    =>\n+       Length (Source) - Length (Target and Source) <=\n+         Target.Capacity - Length (Target),\n+     Post   =>\n+       Length (Target) = Length (Target)'Old\n+         - M.Num_Overlaps (Model (Target)'Old, Model (Source))\n+         + Length (Source)\n+\n+         --  Elements already in Target are still in Target\n+\n+         and Model (Target)'Old <= Model (Target)\n+\n+         --  Elements of Source are included in Target\n+\n+         and Model (Source) <= Model (Target)\n+\n+         --  Elements of Target come from either Source or Target\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Target), Model (Source), Model (Target)'Old)\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Target),\n+              Model (Target)'Old,\n+              Elements (Target)'Old,\n+              Elements (Source))\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Target)'Old, Elements (Target))\n+         and\n+           E_Elements_Included\n+             (Elements (Source),\n+              Model (Target)'Old,\n+              Elements (Source),\n+              Elements (Target))\n+\n+         --  Mapping from cursors of Target to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Target)'Old,\n+                E_Right => Elements (Target),\n+                P_Left  => Positions (Target)'Old,\n+                P_Right => Positions (Target));\n \n    function Union (Left, Right : Set) return Set with\n      Global => null,\n-     Pre    => Length (Left) + Length (Right) -\n-                 Length (Intersection (Left, Right)) <= Count_Type'Last;\n+     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n+     Post   =>\n+       Length (Union'Result) = Length (Left)\n+         - M.Num_Overlaps (Model (Left), Model (Right))\n+         + Length (Right)\n+\n+         --  Elements of Left and Right are in the result of Union\n+\n+         and Model (Left) <= Model (Union'Result)\n+         and Model (Right) <= Model (Union'Result)\n+\n+         --  Elements of the result of union come from either Left or Right\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Union'Result), Model (Left), Model (Right))\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Union'Result),\n+              Model (Left),\n+              Elements (Left),\n+              Elements (Right))\n+         and\n+           E_Elements_Included\n+             (Elements (Left), Model (Left), Elements (Union'Result))\n+         and\n+           E_Elements_Included\n+             (Elements (Right),\n+              Model (Left),\n+              Elements (Right),\n+              Elements (Union'Result));\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n    procedure Intersection (Target : in out Set; Source : Set) with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Target) =\n+         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n+\n+         --  Elements of Target were already in Target\n+\n+         and Model (Target) <= Model (Target)'Old\n+\n+         --  Elements of Target are in Source\n+\n+         and Model (Target) <= Model (Source)\n+\n+         --  Elements both in Source and Target are in the intersection\n+\n+         and\n+           M.Includes_Intersection\n+             (Model (Target), Model (Source), Model (Target)'Old)\n+\n+         --  Actual value of elements of Target is preserved\n+\n+         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Source), Elements (Target))\n+\n+         --  Mapping from cursors of Target to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Target),\n+                E_Right => Elements (Target)'Old,\n+                P_Left  => Positions (Target),\n+                P_Right => Positions (Target)'Old);\n \n    function Intersection (Left, Right : Set) return Set with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Intersection'Result) =\n+         M.Num_Overlaps (Model (Left), Model (Right))\n+\n+         --  Elements in the result of Intersection are in Left and Right\n+\n+         and Model (Intersection'Result) <= Model (Left)\n+         and Model (Intersection'Result) <= Model (Right)\n+\n+         --  Elements both in Left and Right are in the result of Intersection\n+\n+         and\n+           M.Includes_Intersection\n+             (Model (Intersection'Result), Model (Left), Model (Right))\n+\n+         --  Actual value of elements come from Left\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Intersection'Result), Elements (Left))\n+         and\n+           E_Elements_Included\n+             (Elements (Left), Model (Right), Elements (Intersection'Result));\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n    procedure Difference (Target : in out Set; Source : Set) with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Target) = Length (Target)'Old -\n+         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n+\n+         --  Elements of Target were already in Target\n+\n+         and Model (Target) <= Model (Target)'Old\n+\n+         --  Elements of Target are not in Source\n+\n+         and M.No_Overlap (Model (Target), Model (Source))\n+\n+         --  Elements in Target but not in Source are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Target)'Old, Model (Target), Model (Source))\n+\n+         --  Actual value of elements of Target is preserved\n+\n+         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Target), Elements (Target))\n+\n+         --  Mapping from cursors of Target to elements is preserved\n+\n+         and Mapping_Preserved\n+               (E_Left  => Elements (Target),\n+                E_Right => Elements (Target)'Old,\n+                P_Left  => Positions (Target),\n+                P_Right => Positions (Target)'Old);\n \n    function Difference (Left, Right : Set) return Set with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Length (Difference'Result) = Length (Left) -\n+         M.Num_Overlaps (Model (Left), Model (Right))\n+\n+         --  Elements of the result of Difference are in Left\n+\n+         and Model (Difference'Result) <= Model (Left)\n+\n+         --  Elements of the result of Difference are in Right\n+\n+         and M.No_Overlap (Model (Difference'Result), Model (Right))\n+\n+         --  Elements in Left but not in Right are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Left), Model (Difference'Result), Model (Right))\n+\n+         --  Actual value of elements come from Left\n+\n+         and\n+           E_Elements_Included (Elements (Difference'Result), Elements (Left))\n+         and\n+           E_Elements_Included\n+             (Elements (Left),\n+              Model (Difference'Result),\n+              Elements (Difference'Result));\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) with\n      Global => null,\n-     Pre    => Length (Target) + Length (Source) -\n-                 2 * Length (Intersection (Target, Source)) <= Target.Capacity;\n+     Pre    =>\n+       Length (Source) - Length (Target and Source) <=\n+         Target.Capacity - Length (Target) + Length (Target and Source),\n+     Post   =>\n+       Length (Target) = Length (Target)'Old -\n+         2 * M.Num_Overlaps (Model (Target)'Old, Model (Source)) +\n+         Length (Source)\n+\n+         --  Elements of the difference were not both in Source and in Target\n+\n+         and M.Not_In_Both (Model (Target), Model (Target)'Old, Model (Source))\n+\n+         --  Elements in Target but not in Source are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Target)'Old, Model (Target), Model (Source))\n+\n+         --  Elements in Source but not in Target are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Source), Model (Target), Model (Target)'Old)\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Target),\n+              Model (Target)'Old,\n+              Elements (Target)'Old,\n+              Elements (Source))\n+         and\n+           E_Elements_Included\n+             (Elements (Target)'Old, Model (Target), Elements (Target))\n+         and\n+           E_Elements_Included\n+             (Elements (Source), Model (Target), Elements (Target));\n \n    function Symmetric_Difference (Left, Right : Set) return Set with\n      Global => null,\n-     Pre    => Length (Left) + Length (Right) -\n-                 2 * Length (Intersection (Left, Right)) <= Count_Type'Last;\n-\n-   function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n+     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n+     Post   =>\n+       Length (Symmetric_Difference'Result) = Length (Left) -\n+         2 * M.Num_Overlaps (Model (Left), Model (Right)) +\n+         Length (Right)\n+\n+         --  Elements of the difference were not both in Left and Right\n+\n+         and\n+           M.Not_In_Both\n+             (Model (Symmetric_Difference'Result), Model (Left), Model (Right))\n+\n+         --  Elements in Left but not in Right are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Left), Model (Symmetric_Difference'Result), Model (Right))\n+\n+         --  Elements in Right but not in Left are in the difference\n+\n+         and\n+           M.Included_In_Union\n+             (Model (Right), Model (Symmetric_Difference'Result), Model (Left))\n+\n+         --  Actual value of elements come from either Left or Right\n+\n+         and\n+           E_Elements_Included\n+             (Elements (Symmetric_Difference'Result),\n+              Model (Left),\n+              Elements (Left),\n+              Elements (Right))\n+         and\n+           E_Elements_Included\n+             (Elements (Left),\n+              Model (Symmetric_Difference'Result),\n+              Elements (Symmetric_Difference'Result))\n+         and\n+           E_Elements_Included\n+             (Elements (Right),\n+              Model (Symmetric_Difference'Result),\n+              Elements (Symmetric_Difference'Result));\n+\n+   function \"xor\" (Left, Right : Set) return Set\n+     renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Overlap'Result = not (M.No_Overlap (Model (Left), Model (Right)));\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Subset'Result = (Model (Subset) <= Model (Of_Set));\n \n    function First (Container : Set) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          First'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, First'Result)\n+            and P.Get (Positions (Container), First'Result) = 1);\n \n    function First_Element (Container : Set) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n-\n-   function Last (Container : Set) return Cursor;\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       First_Element'Result = E.Get (Elements (Container), 1)\n+         and E_Smaller_Than_Range\n+               (Elements (Container),\n+                2,\n+                Length (Container),\n+                First_Element'Result);\n+\n+   function Last (Container : Set) return Cursor with\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          Last'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Last'Result)\n+            and P.Get (Positions (Container), Last'Result) =\n+                  Length (Container));\n \n    function Last_Element (Container : Set) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Last_Element'Result = E.Get (Elements (Container), Length (Container))\n+         and E_Bigger_Than_Range\n+               (Elements (Container),\n+                1,\n+                Length (Container) - 1,\n+                Last_Element'Result);\n \n    function Next (Container : Set; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Next'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Next'Result)\n+            and then P.Get (Positions (Container), Next'Result) =\n+                     P.Get (Positions (Container), Position) + 1);\n \n    procedure Next (Container : Set; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) + 1);\n \n    function Previous (Container : Set; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = 1\n+        =>\n+          Previous'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Previous'Result)\n+            and then P.Get (Positions (Container), Previous'Result) =\n+                     P.Get (Positions (Container), Position) - 1);\n \n    procedure Previous (Container : Set; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = 1\n+         =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) - 1);\n \n    function Find (Container : Set; Item : Element_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  If Item is not contained in Container, Find returns No_Element\n+\n+       (not Contains (Model (Container), Item) =>\n+          not P.Has_Key (Positions (Container), Find'Result)\n+            and Find'Result = No_Element,\n+\n+        --  Otherwise, Find returns a valid cursor in Container\n+\n+        others =>\n+          P.Has_Key (Positions (Container), Find'Result)\n+            and P.Get (Positions (Container), Find'Result) =\n+                Find (Elements (Container), Item)\n+\n+            --  The element designated by the result of Find is Item\n+\n+            and Equivalent_Elements\n+                  (Element (Container, Find'Result), Item));\n \n    function Floor (Container : Set; Item : Element_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 or else Item < First_Element (Container) =>\n+          Floor'Result = No_Element,\n+        others =>\n+          Has_Element (Container, Floor'Result)\n+            and\n+              not (Item < E.Get (Elements (Container),\n+                                 P.Get (Positions (Container), Floor'Result)))\n+            and E_Is_Find\n+                  (Elements (Container),\n+                   Item,\n+                   P.Get (Positions (Container), Floor'Result)));\n \n    function Ceiling (Container : Set; Item : Element_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 or else Last_Element (Container) < Item =>\n+          Ceiling'Result = No_Element,\n+        others =>\n+          Has_Element (Container, Ceiling'Result)\n+            and\n+              not (E.Get (Elements (Container),\n+                          P.Get (Positions (Container), Ceiling'Result)) <\n+                   Item)\n+            and E_Is_Find\n+                  (Elements (Container),\n+                   Item,\n+                   P.Get (Positions (Container), Ceiling'Result)));\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Contains'Result = Contains (Model (Container), Item);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n \n    function Has_Element (Container : Set; Position : Cursor) return Boolean\n    with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    generic\n       type Key_Type (<>) is private;\n@@ -292,68 +1462,300 @@ is\n    package Generic_Keys with SPARK_Mode is\n \n       function Equivalent_Keys (Left, Right : Key_Type) return Boolean with\n-        Global => null;\n+        Global => null,\n+        Post   =>\n+          Equivalent_Keys'Result = (not (Left < Right) and not (Right < Left));\n+      pragma Annotate (GNATprove, Inline_For_Proof, Equivalent_Keys);\n+\n+      package Formal_Model with Ghost is\n+         function E_Bigger_Than_Range\n+           (Container : E.Sequence;\n+            Fst       : Positive_Count_Type;\n+            Lst       : Count_Type;\n+            Key       : Key_Type) return Boolean\n+         with\n+           Global => null,\n+           Pre    => Lst <= E.Length (Container),\n+           Post   =>\n+             E_Bigger_Than_Range'Result =\n+               (for all I in Fst .. Lst =>\n+                  Generic_Keys.Key (E.Get (Container, I)) < Key);\n+         pragma Annotate (GNATprove, Inline_For_Proof, E_Bigger_Than_Range);\n+\n+         function E_Smaller_Than_Range\n+           (Container : E.Sequence;\n+            Fst       : Positive_Count_Type;\n+            Lst       : Count_Type;\n+            Key       : Key_Type) return Boolean\n+         with\n+           Global => null,\n+           Pre    => Lst <= E.Length (Container),\n+           Post   =>\n+             E_Smaller_Than_Range'Result =\n+               (for all I in Fst .. Lst =>\n+                  Key < Generic_Keys.Key (E.Get (Container, I)));\n+         pragma Annotate (GNATprove, Inline_For_Proof, E_Smaller_Than_Range);\n+\n+         function E_Is_Find\n+           (Container : E.Sequence;\n+            Key       : Key_Type;\n+            Position  : Count_Type) return Boolean\n+         with\n+           Global => null,\n+           Pre    => Position - 1 <= E.Length (Container),\n+           Post   =>\n+             E_Is_Find'Result =\n+\n+               ((if Position > 0 then\n+                   E_Bigger_Than_Range (Container, 1, Position - 1, Key))\n+\n+                     and (if Position < E.Length (Container) then\n+                        E_Smaller_Than_Range\n+                          (Container,\n+                           Position + 1,\n+                           E.Length (Container),\n+                           Key)));\n+         pragma Annotate (GNATprove, Inline_For_Proof, E_Is_Find);\n+\n+         function Find\n+           (Container : E.Sequence;\n+            Key       : Key_Type) return Count_Type\n+         --  Search for Key in Container\n+\n+           with\n+             Global                  => null,\n+             Post                    =>\n+               (if Find'Result > 0 then\n+                  Find'Result <= E.Length (Container)\n+                    and Equivalent_Keys\n+                      (Key, Generic_Keys.Key (E.Get (Container, Find'Result)))\n+                    and E_Is_Find (Container, Key, Find'Result));\n+\n+         function M_Included_Except\n+           (Left  : M.Set;\n+            Right : M.Set;\n+            Key   : Key_Type) return Boolean\n+           with\n+             Global                  => null,\n+             Post                    =>\n+               M_Included_Except'Result =\n+                 (for all E of Left =>\n+                    Contains (Right, E)\n+                      or Equivalent_Keys (Generic_Keys.Key (E), Key));\n+      end Formal_Model;\n+      use Formal_Model;\n \n       function Key (Container : Set; Position : Cursor) return Key_Type with\n-        Global => null;\n+        Global => null,\n+        Post   => Key'Result = Key (Element (Container, Position));\n+      pragma Annotate (GNATprove, Inline_For_Proof, Key);\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type\n       with\n-        Global => null;\n+        Global => null,\n+        Pre    => Contains (Container, Key),\n+        Post   =>\n+          Element'Result = Element (Container, Find (Container, Key));\n+      pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n       procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       with\n-        Global => null;\n+        Global => null,\n+        Pre    => Contains (Container, Key),\n+        Post   =>\n+          Length (Container) = Length (Container)'Old\n+\n+             --  Key now maps to New_Item\n+\n+             and Element (Container, Key) = New_Item\n+\n+             --  New_Item is contained in Container\n+\n+             and Contains (Model (Container), New_Item)\n+\n+             --  Other elements are preserved\n+\n+             and M_Included_Except\n+                   (Model (Container)'Old,\n+                    Model (Container),\n+                    Key)\n+             and M.Included_Except\n+                   (Model (Container),\n+                    Model (Container)'Old,\n+                    New_Item)\n+\n+             --  Mapping from cursors to elements is preserved\n+\n+             and Mapping_Preserved_Except\n+                   (E_Left   => Elements (Container)'Old,\n+                    E_Right  => Elements (Container),\n+                    P_Left   => Positions (Container)'Old,\n+                    P_Right  => Positions (Container),\n+                    Position => Find (Container, Key))\n+             and Positions (Container) = Positions (Container)'Old;\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) with\n-        Global => null;\n+        Global         => null,\n+        Post           => not Contains (Container, Key),\n+        Contract_Cases =>\n+\n+          --  If Key is not in Container, nothing is changed\n+\n+          (not Contains (Container, Key) =>\n+             Model (Container) = Model (Container)'Old\n+               and Elements (Container) = Elements (Container)'Old\n+               and Positions (Container) = Positions (Container)'Old,\n+\n+           --  Otherwise, Key is removed from Container\n+\n+           others =>\n+             Length (Container) = Length (Container)'Old - 1\n+\n+               --  Other elements are preserved\n+\n+               and Model (Container) <= Model (Container)'Old\n+               and M_Included_Except\n+                     (Model (Container)'Old,\n+                      Model (Container),\n+                      Key)\n+\n+               --  The elements of Container located before Key are preserved\n+\n+               and E.Range_Equal\n+                     (Left  => Elements (Container)'Old,\n+                      Right => Elements (Container),\n+                      Fst   => 1,\n+                      Lst   => Find (Elements (Container), Key)'Old - 1)\n+\n+               --  The elements located after Key are shifted by 1\n+\n+               and E.Range_Shifted\n+                     (Left   => Elements (Container),\n+                      Right  => Elements (Container)'Old,\n+                      Fst    => Find (Elements (Container), Key)'Old,\n+                      Lst    => Length (Container),\n+                      Offset => 1)\n+\n+               --  A cursor has been removed from Container\n+\n+               and P_Positions_Shifted\n+                     (Positions (Container),\n+                      Positions (Container)'Old,\n+                      Cut   => Find (Elements (Container), Key)'Old));\n \n       procedure Delete (Container : in out Set; Key : Key_Type) with\n-        Global => null;\n+        Global => null,\n+        Pre    => Contains (Container, Key),\n+        Post   =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  Key is no longer in Container\n+\n+            and not Contains (Container, Key)\n+\n+            --  Other elements are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M_Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Key)\n+\n+            --  The elements of Container located before Key are preserved\n+\n+            and E.Range_Equal\n+                  (Left  => Elements (Container)'Old,\n+                   Right => Elements (Container),\n+                   Fst   => 1,\n+                   Lst   => Find (Elements (Container), Key)'Old - 1)\n+\n+            --  The elements located after Key are shifted by 1\n+\n+            and E.Range_Shifted\n+                  (Left   => Elements (Container),\n+                   Right  => Elements (Container)'Old,\n+                   Fst    => Find (Elements (Container), Key)'Old,\n+                   Lst    => Length (Container),\n+                   Offset => 1)\n+\n+            --  A cursor has been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => Find (Elements (Container), Key)'Old);\n \n       function Find (Container : Set; Key : Key_Type) return Cursor with\n-        Global => null;\n+        Global         => null,\n+        Contract_Cases =>\n+\n+          --  If Key is not contained in Container, Find returns No_Element\n+\n+          ((for all E of Model (Container) =>\n+               not Equivalent_Keys (Key, Generic_Keys.Key (E))) =>\n+             not P.Has_Key (Positions (Container), Find'Result)\n+               and Find'Result = No_Element,\n+\n+           --  Otherwise, Find returns a valid cursor in Container\n+\n+           others =>\n+             P.Has_Key (Positions (Container), Find'Result)\n+               and P.Get (Positions (Container), Find'Result) =\n+                   Find (Elements (Container), Key)\n+\n+               --  The element designated by the result of Find is Key\n+\n+               and Equivalent_Keys\n+                  (Generic_Keys.Key (Element (Container, Find'Result)), Key));\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor with\n-        Global => null;\n+        Global         => null,\n+        Contract_Cases =>\n+          (Length (Container) = 0\n+             or else Key < Generic_Keys.Key (First_Element (Container)) =>\n+             Floor'Result = No_Element,\n+           others =>\n+              Has_Element (Container, Floor'Result)\n+               and\n+                 not (Key <\n+                      Generic_Keys.Key\n+                       (E.Get (Elements (Container),\n+                               P.Get (Positions (Container), Floor'Result))))\n+               and E_Is_Find\n+                     (Elements (Container),\n+                      Key,\n+                      P.Get (Positions (Container), Floor'Result)));\n \n       function Ceiling (Container : Set; Key : Key_Type) return Cursor with\n-        Global => null;\n+        Global         => null,\n+        Contract_Cases =>\n+          (Length (Container) = 0\n+             or else Generic_Keys.Key (Last_Element (Container)) < Key =>\n+             Ceiling'Result = No_Element,\n+           others =>\n+             Has_Element (Container, Ceiling'Result)\n+               and\n+                 not (Generic_Keys.Key\n+                       (E.Get (Elements (Container),\n+                               P.Get (Positions (Container), Ceiling'Result)))\n+                      < Key)\n+               and E_Is_Find\n+                     (Elements (Container),\n+                      Key,\n+                      P.Get (Positions (Container), Ceiling'Result)));\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean with\n-        Global => null;\n+        Global => null,\n+        Post   =>\n+          Contains'Result =\n+            (for some E of Model (Container) =>\n+                Equivalent_Keys (Key, Generic_Keys.Key (E)));\n \n    end Generic_Keys;\n \n-   function Strict_Equal (Left, Right : Set) return Boolean with\n-     Ghost,\n-     Global => null;\n-   --  Strict_Equal returns True if the containers are physically equal, i.e.\n-   --  they are structurally equal (function \"=\" returns True) and that they\n-   --  have the same set of cursors.\n-\n-   function First_To_Previous (Container : Set; Current : Cursor) return Set\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-\n-   function Current_To_Last (Container : Set; Current : Cursor) return Set\n-   with\n-     Ghost,\n-     Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-   --  First_To_Previous returns a container containing all elements preceding\n-   --  Current (excluded) in Container. Current_To_Last returns a container\n-   --  containing all elements following Current (included) in Container.\n-   --  These two new functions can be used to express invariant properties in\n-   --  loops which iterate over containers. First_To_Previous returns the part\n-   --  of the container already scanned and Current_To_Last the part not\n-   --  scanned yet.\n-\n private\n    pragma SPARK_Mode (Off);\n \n@@ -377,12 +1779,6 @@ private\n \n    use Red_Black_Trees;\n \n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n    Empty_Set : constant Set := (Capacity => 0, others => <>);\n \n end Ada.Containers.Formal_Ordered_Sets;"}, {"sha": "63cbebbe74f2889f3830ef3d3aba1e5da3f4b026", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -636,6 +636,45 @@ is\n \n    package body Generic_Sorting with SPARK_Mode => Off is\n \n+      ------------------\n+      -- Formal_Model --\n+      ------------------\n+\n+      package body Formal_Model is\n+\n+         -----------------------\n+         -- M_Elements_Sorted --\n+         -----------------------\n+\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n+         begin\n+            if M.Length (Container) = 0 then\n+               return True;\n+            end if;\n+\n+            declare\n+               E1 : Element_Type := Element (Container, Index_Type'First);\n+\n+            begin\n+               for I in Index_Type'First + 1 .. M.Last (Container) loop\n+                  declare\n+                     E2 : constant Element_Type := Element (Container, I);\n+\n+                  begin\n+                     if E2 < E1 then\n+                        return False;\n+                     end if;\n+\n+                     E1 := E2;\n+                  end;\n+               end loop;\n+            end;\n+\n+            return True;\n+         end M_Elements_Sorted;\n+\n+      end Formal_Model;\n+\n       ---------------\n       -- Is_Sorted --\n       ---------------\n@@ -655,37 +694,6 @@ is\n          return True;\n       end Is_Sorted;\n \n-      -----------------------\n-      -- M_Elements_Sorted --\n-      -----------------------\n-\n-      function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-      begin\n-         if M.Length (Container) = 0 then\n-            return True;\n-         end if;\n-\n-         declare\n-            E1 : Element_Type := Element (Container, Index_Type'First);\n-\n-         begin\n-            for I in Index_Type'First + 1 .. M.Last (Container) loop\n-               declare\n-                  E2 : constant Element_Type := Element (Container, I);\n-\n-               begin\n-                  if E2 < E1 then\n-                     return False;\n-                  end if;\n-\n-                  E1 := E2;\n-               end;\n-            end loop;\n-         end;\n-\n-         return True;\n-      end M_Elements_Sorted;\n-\n       ----------\n       -- Sort --\n       ----------"}, {"sha": "681e513d16f6d6002a5b649867d58890bf277a5e", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -717,7 +717,7 @@ is\n      Global         => null,\n      Contract_Cases =>\n \n-       --  If Item is not is not contained in Container after Index, Find_Index\n+       --  If Item is not contained in Container after Index, Find_Index\n        --  returns No_Index.\n \n        (Index > Last_Index (Container)\n@@ -754,7 +754,7 @@ is\n      Global         => null,\n      Contract_Cases =>\n \n-       --  If Item is not is not contained in Container before Index,\n+       --  If Item is not contained in Container before Index,\n        --  Reverse_Find_Index returns No_Index.\n \n        (not M.Contains\n@@ -815,16 +815,22 @@ is\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting with SPARK_Mode is\n-      function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          M_Elements_Sorted'Result =\n-            (for all I in Index_Type'First .. M.Last (Container) =>\n-              (for all J in I .. M.Last (Container) =>\n-                Element (Container, I) = Element (Container, J)\n-                  or Element (Container, I) < Element (Container, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      package Formal_Model with Ghost is\n+\n+         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n+         with\n+           Global => null,\n+           Post   =>\n+             M_Elements_Sorted'Result =\n+               (for all I in Index_Type'First .. M.Last (Container) =>\n+                  (for all J in I .. M.Last (Container) =>\n+                       Element (Container, I) = Element (Container, J)\n+                         or Element (Container, I) < Element (Container, J)));\n+         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n+\n+      end Formal_Model;\n+      use Formal_Model;\n \n       function Is_Sorted (Container : Vector) return Boolean with\n         Global => null,"}, {"sha": "ea44dcf98268b3293f6070e5499dd9d4159f263d", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -35,7 +35,9 @@ private with Ada.Containers.Functional_Base;\n generic\n    type Key_Type (<>) is private;\n    type Element_Type (<>)  is private;\n-   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   with function Equivalent_Keys\n+     (Left  : Key_Type;\n+      Right : Key_Type) return Boolean is \"=\";\n    Enable_Handling_Of_Equivalence : Boolean := True;\n    --  This constant should only be set to False when no particular handling\n    --  of equivalence over keys is needed, that is, Equivalent_Keys defines a\n@@ -53,8 +55,8 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n    --  \"For in\" quantification over maps should not be used.\n    --  \"For of\" quantification over maps iterates over keys.\n    --  Note that, for proof, \"for of\" quantification is understood modulo\n-   --  equivalence (quantification includes keys equivalent to keys of the\n-   --  map).\n+   --  equivalence (the range of quantification comprises all the keys that are\n+   --  equivalent to any key of the map).\n \n    -----------------------\n    --  Basic operations --\n@@ -89,8 +91,8 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n           Get'Result = W_Get (Container, Witness (Container, Key))\n           and (for all K of Container =>\n-                 (if Equivalent_Keys (K, Key) then\n-                    Witness (Container, Key) = Witness (Container, K))));\n+                 (Equivalent_Keys (K, Key) =\n+                    (Witness (Container, Key) = Witness (Container, K)))));\n \n    function Length (Container : Map) return Count_Type with\n      Global => null;"}, {"sha": "22bf68869484083c13983f4f670179e69ce466e7", "filename": "gcc/ada/a-cofuse.adb", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -113,13 +113,43 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    function Is_Empty (Container : Set) return Boolean is\n      (Length (Container.Content) = 0);\n \n+   ------------------\n+   -- Is_Singleton --\n+   ------------------\n+\n+   function Is_Singleton\n+     (Container : Set;\n+      New_Item  : Element_Type) return Boolean\n+   is\n+     (Length (Container.Content) = 1\n+        and New_Item = Get (Container.Content, 1));\n+\n    ------------\n    -- Length --\n    ------------\n \n    function Length (Container : Set) return Count_Type is\n      (Length (Container.Content));\n \n+   -----------------\n+   -- Not_In_Both --\n+   -----------------\n+\n+   function Not_In_Both\n+     (Container : Set;\n+      Left      : Set;\n+      Right     : Set) return Boolean\n+   is\n+     (for all Item of Container =>\n+       not Contains (Right, Item) or not Contains (Left, Item));\n+\n+   ----------------\n+   -- No_Overlap --\n+   ----------------\n+\n+   function No_Overlap (Left : Set; Right : Set) return Boolean is\n+     (Num_Overlaps (Left.Content, Right.Content) = 0);\n+\n    ------------------\n    -- Num_Overlaps --\n    ------------------"}, {"sha": "87165d79edc916afb2c05fb5a3736a718c1d5e01", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -36,7 +36,7 @@ generic\n    type Element_Type (<>) is private;\n    with function Equivalent_Elements\n      (Left  : Element_Type;\n-      Right : Element_Type) return Boolean;\n+      Right : Element_Type) return Boolean is \"=\";\n    Enable_Handling_Of_Equivalence : Boolean := True;\n    --  This constant should only be set to False when no particular handling\n    --  of equivalence over elements is needed, that is, Equivalent_Elements\n@@ -45,7 +45,7 @@ generic\n package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n    type Set is private with\n-     Default_Initial_Condition => Is_Empty (Set) and Length (Set) = 0,\n+     Default_Initial_Condition => Is_Empty (Set),\n      Iterable                  => (First       => Iter_First,\n                                    Next        => Iter_Next,\n                                    Has_Element => Iter_Has_Element,\n@@ -54,8 +54,8 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    --  \"For in\" quantification over sets should not be used.\n    --  \"For of\" quantification over sets iterates over elements.\n    --  Note that, for proof, \"for of\" quantification is understood modulo\n-   --  equivalence (quantification includes elements equivalent to elements of\n-   --  the map).\n+   --  equivalence (the range of quantification comprises all the elements that\n+   --  are equivalent to any element of the set).\n \n    -----------------------\n    --  Basic operations --\n@@ -89,23 +89,23 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    --  Set inclusion\n \n      Global => null,\n-     Post   => \"<=\"'Result = (for all Item of Left => Contains (Right, Item));\n+     Post   => \"<=\"'Result = (for all Item of Left => Contains (Right, Item))\n+       and (if \"<=\"'Result then Length (Left) <= Length (Right));\n \n    function \"=\" (Left : Set; Right : Set) return Boolean with\n    --  Extensional equality over sets\n \n      Global => null,\n-     Post   =>\n-       \"=\"'Result =\n-         (for all Item of Left => Contains (Right, Item))\n-           and (for all Item of Right => Contains (Left, Item));\n+     Post   => \"=\"'Result = (Left <= Right and Right <= Left);\n \n    pragma Warnings (Off, \"unused variable \"\"Item\"\"\");\n    function Is_Empty (Container : Set) return Boolean with\n    --  A set is empty if it contains no element\n \n      Global => null,\n-     Post   => Is_Empty'Result = (for all Item of Container => False);\n+     Post   =>\n+       Is_Empty'Result = (for all Item of Container => False)\n+         and Is_Empty'Result = (Length (Container) = 0);\n    pragma Warnings (On, \"unused variable \"\"Item\"\"\");\n \n    function Included_Except\n@@ -149,15 +149,45 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n          (for all Item of Container =>\n            Contains (Left, Item) or Contains (Right, Item));\n \n+   function Is_Singleton\n+     (Container : Set;\n+      New_Item  : Element_Type) return Boolean\n+   with\n+   --  Return True Container only contains New_Item\n+\n+     Global => null,\n+     Post   =>\n+       Is_Singleton'Result =\n+         (for all Item of Container => Equivalent_Elements (Item, New_Item));\n+\n+   function Not_In_Both\n+     (Container : Set;\n+      Left      : Set;\n+      Right     : Set) return Boolean\n+   --  Return True if there are no elements in Container that are in Left and\n+   --  Right.\n+\n+   with\n+     Global => null,\n+     Post   =>\n+       Not_In_Both'Result =\n+         (for all Item of Container =>\n+            not Contains (Left, Item) or not Contains (Right, Item));\n+\n+   function No_Overlap (Left : Set; Right : Set) return Boolean with\n+   --  Return True if there are no equivalent elements in Left and Right\n+\n+     Global => null,\n+     Post   =>\n+       No_Overlap'Result =\n+         (for all Item of Left => not Contains (Right, Item));\n+\n    function Num_Overlaps (Left : Set; Right : Set) return Count_Type with\n    --  Number of elements that are both in Left and Right\n \n      Global => null,\n      Post   =>\n-       Num_Overlaps'Result <= Length (Left)\n-         and Num_Overlaps'Result <= Length (Right)\n-         and (if Num_Overlaps'Result = 0 then\n-               (for all Item of Left => not Contains (Right, Item)));\n+       Num_Overlaps'Result = Length (Intersection (Left, Right));\n \n    ----------------------------\n    -- Construction Functions --\n@@ -195,8 +225,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n      Global => null,\n      Post   =>\n-       Length (Intersection'Result) = Num_Overlaps (Left, Right)\n-         and Intersection'Result <= Left\n+       Intersection'Result <= Left\n          and Intersection'Result <= Right\n          and Includes_Intersection (Intersection'Result, Left, Right);\n \n@@ -250,9 +279,13 @@ private\n \n    subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n \n+   function \"=\"\n+     (Left  : Element_Type;\n+      Right : Element_Type) return Boolean renames Equivalent_Elements;\n+\n    package Containers is new Ada.Containers.Functional_Base\n-     (Element_Type        => Element_Type,\n-      Index_Type          => Positive_Count_Type);\n+     (Element_Type => Element_Type,\n+      Index_Type   => Positive_Count_Type);\n \n    type Set is record\n       Content : Containers.Container;"}, {"sha": "f71cc888b8b77de1a91eda3802acea8e6d23300e", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -35,7 +35,6 @@ with Csets;    use Csets;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Erroutc;  use Erroutc;\n-with Fname;    use Fname;\n with Gnatvsn;  use Gnatvsn;\n with Lib;      use Lib;\n with Opt;      use Opt;\n@@ -2708,9 +2707,7 @@ package body Errout is\n       --  Types in other language defined units are displayed as\n       --  \"package-name.type-name\"\n \n-      elsif\n-        Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Ent)))\n-      then\n+      elsif Is_Predefined_Unit (Get_Source_Unit (Ent)) then\n          Get_Unqualified_Decoded_Name_String\n            (Unit_Name (Get_Source_Unit (Ent)));\n          Name_Len := Name_Len - 2;\n@@ -2748,8 +2745,7 @@ package body Errout is\n \n       if Sloc (Error_Msg_Node_1) > Standard_Location\n         and then\n-          not Is_Predefined_File_Name\n-                (Unit_File_Name (Get_Source_Unit (Error_Msg_Node_1)))\n+          not Is_Predefined_Unit (Get_Source_Unit (Error_Msg_Node_1))\n       then\n          Get_Name_String (Unit_File_Name (Get_Source_Unit (Error_Msg_Node_1)));\n          Set_Msg_Str (\" defined\");"}, {"sha": "460b1c194ae3694af29006354611b314585fd14a", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -37,7 +37,6 @@ with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n-with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n@@ -4532,8 +4531,7 @@ package body Exp_Aggr is\n                                           and then\n                                             Is_Preelaborated (Spec_Entity (P)))\n                                 or else\n-                                  Is_Predefined_File_Name\n-                                    (Unit_File_Name (Get_Source_Unit (P)))\n+                                  Is_Predefined_Unit (Get_Source_Unit (P))\n                               then\n                                  null;\n "}, {"sha": "b81e26cec18bf7ca726ff48f4123864652c1deee", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -39,7 +39,6 @@ with Exp_Pakd; use Exp_Pakd;\n with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Gnatvsn;  use Gnatvsn;\n with Itypes;   use Itypes;\n@@ -7749,7 +7748,7 @@ package body Exp_Attr is\n       --  instead. That is why we include the test Is_Available when dealing\n       --  with these cases.\n \n-      if not Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit)) then\n+      if not Is_Predefined_Unit (Current_Sem_Unit) then\n          --  Storage_Array as defined in package System.Storage_Elements\n \n          if Is_RTE (Base_Typ, RE_Storage_Array) then"}, {"sha": "a04d90da3021e9afa1eca7d38fca90f8e3c2f21f", "filename": "gcc/ada/exp_code.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_code.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_code.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_code.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,6 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n-with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -274,9 +273,7 @@ package body Exp_Code is\n          --  referenced entity is in a runtime routine.\n \n          if Is_Entity_Name (N)\n-           and then\n-             Is_Predefined_File_Name (Unit_File_Name\n-                                       (Get_Source_Unit (Entity (N))))\n+           and then Is_Predefined_Unit (Get_Source_Unit (Entity (N)))\n          then\n             return;\n "}, {"sha": "056a034078eb353464f7f15b9e936d0d173b5fca", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -1116,9 +1116,15 @@ package body Exp_Util is\n \n                --  If the entity is an overridden primitive and we are not in\n                --  GNATprove mode, we must build a wrapper for the current\n-               --  inherited operation.\n-\n-               if Is_Subprogram (New_E) and then not GNATprove_Mode then\n+               --  inherited operation. If the reference is the prefix of an\n+               --  attribute such as 'Result (or others ???) there is no need\n+               --  for a wrapper: the condition is just  rewritten in terms of\n+               --  the inherited subprogram.\n+\n+               if Is_Subprogram (New_E)\n+                  and then Nkind (Parent (N)) /= N_Attribute_Reference\n+                    and then not GNATprove_Mode\n+               then\n                   Needs_Wrapper := True;\n                end if;\n             end if;"}, {"sha": "48727c64851480a5546b80f941661ec5cd07db08", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2017, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -219,6 +219,7 @@ extern void Check_Elaboration_Code_Allowed (Node_Id);\n extern void Check_Implicit_Dynamic_Code_Allowed (Node_Id);\n \n /* sem_aggr:  */\n+\n #define Is_Others_Aggregate    sem_aggr__is_others_aggregate\n \n extern Boolean Is_Others_Aggregate (Node_Id);\n@@ -297,6 +298,12 @@ extern Boolean Signed_Zeros_On_Target;\n extern Boolean Stack_Check_Probes_On_Target;\n extern Boolean Stack_Check_Limits_On_Target;\n \n+/* warnsw: */\n+\n+#define Warn_On_Questionable_Layout warnsw__warn_on_questionable_layout\n+\n+extern Boolean Warn_On_Questionable_Layout;\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "2bdfbf685d9b39f5dbd4859765452a5586ea513f", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -99,21 +99,14 @@ package body Fname is\n       return False;\n    end Has_Prefix;\n \n-   ---------------------------\n-   -- Is_Internal_File_Name --\n-   ---------------------------\n+   -----------------------\n+   -- Is_GNAT_File_Name --\n+   -----------------------\n \n-   function Is_Internal_File_Name\n-     (Fname              : String;\n-      Renamings_Included : Boolean := True) return Boolean\n-   is\n+   function Is_GNAT_File_Name (Fname : String) return Boolean is\n    begin\n-      if Is_Predefined_File_Name (Fname, Renamings_Included) then\n-         return True;\n-      end if;\n-\n-      --  Check for internal extensions first, so we don't think (e.g.)\n-      --  \"gnat.adc\" is internal.\n+      --  Check for internal extensions before checking prefixes, so we don't\n+      --  think (e.g.) \"gnat.adc\" is internal.\n \n       if not Has_Internal_Extension (Fname) then\n          return False;\n@@ -128,6 +121,29 @@ package body Fname is\n       --  See the note in Is_Predefined_File_Name for the rationale\n \n       return Fname'Length = 8 and then Has_Prefix (Fname, \"gnat\");\n+   end Is_GNAT_File_Name;\n+\n+   function Is_GNAT_File_Name (Fname : File_Name_Type) return Boolean is\n+      Result : constant Boolean :=\n+                 Is_GNAT_File_Name (Get_Name_String (Fname));\n+   begin\n+      return Result;\n+   end Is_GNAT_File_Name;\n+\n+   ---------------------------\n+   -- Is_Internal_File_Name --\n+   ---------------------------\n+\n+   function Is_Internal_File_Name\n+     (Fname              : String;\n+      Renamings_Included : Boolean := True) return Boolean\n+   is\n+   begin\n+      if Is_Predefined_File_Name (Fname, Renamings_Included) then\n+         return True;\n+      end if;\n+\n+      return Is_GNAT_File_Name (Fname);\n    end Is_Internal_File_Name;\n \n    function Is_Internal_File_Name\n@@ -149,27 +165,13 @@ package body Fname is\n      (Fname              : String;\n       Renamings_Included : Boolean := True) return Boolean\n    is\n-      subtype Str8 is String (1 .. 8);\n-\n-      Renaming_Names : constant array (1 .. 8) of Str8 :=\n-        (\"calendar\",   --  Calendar\n-         \"machcode\",   --  Machine_Code\n-         \"unchconv\",   --  Unchecked_Conversion\n-         \"unchdeal\",   --  Unchecked_Deallocation\n-         \"directio\",   --  Direct_IO\n-         \"ioexcept\",   --  IO_Exceptions\n-         \"sequenio\",   --  Sequential_IO\n-         \"text_io.\");  --  Text_IO\n+   begin\n+      --  Definitely false if longer than 12 characters (8.3)\n \n-      --  Note: the implementation is optimized to perform uniform comparisons\n-      --  on string slices whose length is known at compile time and is a small\n-      --  power of 2 (at most 8 characters); the remaining calls to Has_Prefix\n-      --  must be inlined to expose the compile-time known length. There must\n-      --  be no calls to the fallback string comparison routine (e.g. memcmp)\n-      --  left in the object code for the function; this can save up to 10% of\n-      --  the entire compilation time spent in the front end.\n+      if Fname'Length > 12 then\n+         return False;\n+      end if;\n \n-   begin\n       if not Has_Internal_Extension (Fname) then\n          return False;\n       end if;\n@@ -186,12 +188,6 @@ package body Fname is\n          end;\n       end if;\n \n-      --  Definitely false if longer than 12 characters (8.3)\n-\n-      if Fname'Length > 12 then\n-         return False;\n-      end if;\n-\n       --  We include the \".\" in the prefixes below, so we don't match (e.g.)\n       --  adamant.ads. So the first line matches \"ada.ads\", \"ada.adb\", and\n       --  \"ada.ali\". But that's not necessary if they have 8 characters.\n@@ -205,7 +201,48 @@ package body Fname is\n \n       --  If instructed and the name has 8+ characters, check for renamings\n \n-      if Renamings_Included and then Fname'Length >= 8 then\n+      if Renamings_Included\n+        and then Is_Predefined_Renaming_File_Name (Fname)\n+      then\n+         return True;\n+      end if;\n+\n+      return False;\n+   end Is_Predefined_File_Name;\n+\n+   function Is_Predefined_File_Name\n+     (Fname              : File_Name_Type;\n+      Renamings_Included : Boolean := True) return Boolean\n+   is\n+      Result : constant Boolean :=\n+                 Is_Predefined_File_Name\n+                   (Get_Name_String (Fname), Renamings_Included);\n+   begin\n+      return Result;\n+   end Is_Predefined_File_Name;\n+\n+   --------------------------------------\n+   -- Is_Predefined_Renaming_File_Name --\n+   --------------------------------------\n+\n+   function Is_Predefined_Renaming_File_Name\n+     (Fname : String) return Boolean\n+   is\n+      subtype Str8 is String (1 .. 8);\n+\n+      Renaming_Names : constant array (1 .. 8) of Str8 :=\n+        (\"calendar\",   --  Calendar\n+         \"machcode\",   --  Machine_Code\n+         \"unchconv\",   --  Unchecked_Conversion\n+         \"unchdeal\",   --  Unchecked_Deallocation\n+         \"directio\",   --  Direct_IO\n+         \"ioexcept\",   --  IO_Exceptions\n+         \"sequenio\",   --  Sequential_IO\n+         \"text_io.\");  --  Text_IO\n+   begin\n+      --  Definitely false if longer than 12 characters (8.3)\n+\n+      if Fname'Length in 8 .. 12 then\n          declare\n             S : String renames Fname (Fname'First .. Fname'First + 7);\n          begin\n@@ -218,18 +255,15 @@ package body Fname is\n       end if;\n \n       return False;\n-   end Is_Predefined_File_Name;\n+   end Is_Predefined_Renaming_File_Name;\n \n-   function Is_Predefined_File_Name\n-     (Fname              : File_Name_Type;\n-      Renamings_Included : Boolean := True) return Boolean\n-   is\n+   function Is_Predefined_Renaming_File_Name\n+     (Fname : File_Name_Type) return Boolean is\n       Result : constant Boolean :=\n-                 Is_Predefined_File_Name\n-                   (Get_Name_String (Fname), Renamings_Included);\n+                 Is_Predefined_Renaming_File_Name (Get_Name_String (Fname));\n    begin\n       return Result;\n-   end Is_Predefined_File_Name;\n+   end Is_Predefined_Renaming_File_Name;\n \n    ---------------\n    -- Tree_Read --"}, {"sha": "4c84598ac0a98c081c4b7dd7bad1fa58fe45cf98", "filename": "gcc/ada/fname.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffname.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffname.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -79,6 +79,14 @@ package Fname is\n    --  Renamings_Included is True, then Text_IO will return True, otherwise\n    --  only children of Ada, Interfaces and System return True.\n \n+   function Is_Predefined_Renaming_File_Name\n+     (Fname : String) return Boolean;\n+   function Is_Predefined_Renaming_File_Name\n+     (Fname : File_Name_Type) return Boolean;\n+   --  True if Fname is the file name for a predefined renaming (the same file\n+   --  names that are included if Renamings_Included => True is passed to\n+   --  Is_Predefined_File_Name).\n+\n    function Is_Internal_File_Name\n      (Fname              : String;\n       Renamings_Included : Boolean := True) return Boolean;\n@@ -88,6 +96,10 @@ package Fname is\n    --  Same as Is_Predefined_File_Name, except units in the GNAT hierarchy are\n    --  included.\n \n+   function Is_GNAT_File_Name (Fname : String) return Boolean;\n+   function Is_GNAT_File_Name (Fname : File_Name_Type) return Boolean;\n+   --  True for units in the GNAT hierarchy\n+\n    procedure Tree_Read;\n    --  Dummy procedure (reads dummy table values from tree file)\n "}, {"sha": "8ce16cd2ed9b6cb3de84813e4fd424e6c2e11bba", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -37,7 +37,6 @@ with Exp_Disp;  use Exp_Disp;\n with Exp_Pakd;  use Exp_Pakd;\n with Exp_Util;  use Exp_Util;\n with Exp_Tss;   use Exp_Tss;\n-with Fname;     use Fname;\n with Ghost;     use Ghost;\n with Layout;    use Layout;\n with Lib;       use Lib;\n@@ -8197,7 +8196,7 @@ package body Freeze is\n       if Is_Pure (E)\n         and then Is_Subprogram (E)\n         and then not Has_Pragma_Pure_Function (E)\n-        and then not Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n+        and then not Is_Internal_Unit (Current_Sem_Unit)\n       then\n          Check_Function_With_Address_Parameter (E);\n       end if;"}, {"sha": "dc279153542f14ec7efced72e4ece5a92c73521e", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -177,7 +177,7 @@ package body GNAT.Command_Line is\n    --  these.\n \n    procedure Sort_Sections\n-     (Line     : GNAT.OS_Lib.Argument_List_Access;\n+     (Line     : not null GNAT.OS_Lib.Argument_List_Access;\n       Sections : GNAT.OS_Lib.Argument_List_Access;\n       Params   : GNAT.OS_Lib.Argument_List_Access);\n    --  Reorder the command line switches so that the switches belonging to a\n@@ -2792,7 +2792,7 @@ package body GNAT.Command_Line is\n    -------------------\n \n    procedure Sort_Sections\n-     (Line     : GNAT.OS_Lib.Argument_List_Access;\n+     (Line     : not null GNAT.OS_Lib.Argument_List_Access;\n       Sections : GNAT.OS_Lib.Argument_List_Access;\n       Params   : GNAT.OS_Lib.Argument_List_Access)\n    is\n@@ -2805,10 +2805,6 @@ package body GNAT.Command_Line is\n       Index         : Natural;\n \n    begin\n-      if Line = null then\n-         return;\n-      end if;\n-\n       --  First construct a list of all sections\n \n       for E in Line'Range loop"}, {"sha": "0c9c78ac10af2db7cd0ae41301d918d2016a6061", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 278, "deletions": 67, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -217,8 +217,9 @@ static bool constructor_address_p (tree);\n static bool allocatable_size_p (tree, bool);\n static bool initial_value_needs_conversion (tree, tree);\n static int compare_field_bitpos (const PTR, const PTR);\n-static bool components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n-\t\t\t\t  bool, bool, bool, bool, bool, tree, tree *);\n+static bool components_to_record (Node_Id, Entity_Id, tree, tree, int, bool,\n+\t\t\t\t  bool, bool, bool, bool, bool, bool, tree,\n+\t\t\t\t  tree *);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n@@ -3328,11 +3329,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t      }\n \n \t/* Add the fields into the record type and finish it up.  */\n-\tcomponents_to_record (gnu_type, Component_List (record_definition),\n-\t\t\t      gnu_field_list, packed, definition, false,\n-\t\t\t      all_rep, is_unchecked_union,\n-\t\t\t      artificial_p, debug_info_p,\n-\t\t\t      false, OK_To_Reorder_Components (gnat_entity),\n+\tcomponents_to_record (Component_List (record_definition), gnat_entity,\n+\t\t\t      gnu_field_list, gnu_type, packed, definition,\n+\t\t\t      false, all_rep, is_unchecked_union, artificial_p,\n+\t\t\t      debug_info_p, false,\n \t\t\t      all_rep ? NULL_TREE : bitsize_zero_node, NULL);\n \n \t/* Fill in locations of fields.  */\n@@ -7463,6 +7463,71 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n   return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n }\n \n+/* Reverse function from gnat_to_gnu_field: return the GNAT field present in\n+   either GNAT_COMPONENT_LIST or the discriminants of GNAT_RECORD_TYPE, and\n+   corresponding to the GNU tree GNU_FIELD.  */\n+\n+static Entity_Id\n+gnu_field_to_gnat (tree gnu_field, Node_Id gnat_component_list,\n+\t\t   Entity_Id gnat_record_type)\n+{\n+  Entity_Id gnat_component_decl, gnat_field;\n+\n+  if (Present (Component_Items (gnat_component_list)))\n+    for (gnat_component_decl\n+\t   = First_Non_Pragma (Component_Items (gnat_component_list));\n+\t Present (gnat_component_decl);\n+\t gnat_component_decl = Next_Non_Pragma (gnat_component_decl))\n+      {\n+\tgnat_field = Defining_Entity (gnat_component_decl);\n+\tif (gnat_to_gnu_field_decl (gnat_field) == gnu_field)\n+\t  return gnat_field;\n+      }\n+\n+  if (Has_Discriminants (gnat_record_type))\n+    for (gnat_field = First_Stored_Discriminant (gnat_record_type);\n+\t Present (gnat_field);\n+\t gnat_field = Next_Stored_Discriminant (gnat_field))\n+      if (gnat_to_gnu_field_decl (gnat_field) == gnu_field)\n+\treturn gnat_field;\n+\n+  return Empty;\n+}\n+\n+/* Issue a warning for the problematic placement of GNU_FIELD present in\n+   either GNAT_COMPONENT_LIST or the discriminants of GNAT_RECORD_TYPE.\n+   IN_VARIANT is true if GNAT_COMPONENT_LIST is the list of a variant.\n+   DO_REORDER is true if fields of GNAT_RECORD_TYPE are being reordered.  */\n+\n+static void\n+warn_on_field_placement (tree gnu_field, Node_Id gnat_component_list,\n+\t\t\t Entity_Id gnat_record_type, bool in_variant,\n+\t\t\t bool do_reorder)\n+{\n+  const char *msg1\n+    = in_variant\n+      ? \"?variant layout may cause performance issues\"\n+      : \"?record layout may cause performance issues\";\n+  const char *msg2\n+    = field_has_self_size (gnu_field)\n+      ? \"?component & whose length depends on a discriminant\"\n+      : field_has_variable_size (gnu_field)\n+\t? \"?component & whose length is not fixed\"\n+\t: \"?component & whose length is not multiple of a byte\";\n+  const char *msg3\n+    = do_reorder\n+      ? \"?comes too early and was moved down\"\n+      : \"?comes too early and ought to be moved down\";\n+  Entity_Id gnat_field\n+    = gnu_field_to_gnat (gnu_field, gnat_component_list, gnat_record_type);\n+\n+  gcc_assert (Present (gnat_field));\n+\n+  post_error (msg1, gnat_field);\n+  post_error_ne (msg2, gnat_field, gnat_field);\n+  post_error (msg3, gnat_field);\n+}\n+\n /* Structure holding information for a given variant.  */\n typedef struct vinfo\n {\n@@ -7483,14 +7548,15 @@ typedef struct vinfo\n \n } vinfo_t;\n \n-/* Translate and chain the GNAT_COMPONENT_LIST to the GNU_FIELD_LIST, set the\n-   result as the field list of GNU_RECORD_TYPE and finish it up.  Return true\n-   if GNU_RECORD_TYPE has a rep clause which affects the layout (see below).\n-   When called from gnat_to_gnu_entity during the processing of a record type\n-   definition, the GCC node for the parent, if any, will be the single field\n-   of GNU_RECORD_TYPE and the GCC nodes for the discriminants will be on the\n-   GNU_FIELD_LIST.  The other calls to this function are recursive calls for\n-   the component list of a variant and, in this case, GNU_FIELD_LIST is empty.\n+/* Translate and chain GNAT_COMPONENT_LIST present in GNAT_RECORD_TYPE to\n+   GNU_FIELD_LIST, set the result as the field list of GNU_RECORD_TYPE and\n+   finish it up.  Return true if GNU_RECORD_TYPE has a rep clause that affects\n+   the layout (see below).  When called from gnat_to_gnu_entity during the\n+   processing of a record definition, the GCC node for the parent, if any,\n+   will be the single field of GNU_RECORD_TYPE and the GCC nodes for the\n+   discriminants will be on GNU_FIELD_LIST.  The other call to this function\n+   is a recursive call for the component list of a variant and, in this case,\n+   GNU_FIELD_LIST is empty.\n \n    PACKED is 1 if this is for a packed record or -1 if this is for a record\n    with Component_Alignment of Storage_Unit.\n@@ -7514,8 +7580,6 @@ typedef struct vinfo\n    MAYBE_UNUSED is true if this type may be unused in the end; this doesn't\n    mean that its contents may be unused as well, only the container itself.\n \n-   REORDER is true if we are permitted to reorder components of this type.\n-\n    FIRST_FREE_POS, if nonzero, is the first (lowest) free field position in\n    the outer record type down to this variant level.  It is nonzero only if\n    all the fields down to this level have a rep clause and ALL_REP is false.\n@@ -7525,12 +7589,12 @@ typedef struct vinfo\n    be done with such fields and the return value will be false.  */\n \n static bool\n-components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n-\t\t      tree gnu_field_list, int packed, bool definition,\n-\t\t      bool cancel_alignment, bool all_rep,\n-\t\t      bool unchecked_union, bool artificial,\n-\t\t      bool debug_info, bool maybe_unused, bool reorder,\n-\t\t      tree first_free_pos, tree *p_gnu_rep_list)\n+components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n+\t\t      tree gnu_field_list, tree gnu_record_type, int packed,\n+\t\t      bool definition, bool cancel_alignment, bool all_rep,\n+\t\t      bool unchecked_union, bool artificial, bool debug_info,\n+\t\t      bool maybe_unused, tree first_free_pos,\n+\t\t      tree *p_gnu_rep_list)\n {\n   const bool needs_xv_encodings\n     = debug_info && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL;\n@@ -7539,24 +7603,21 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n   bool layout_with_rep = false;\n   bool has_self_field = false;\n   bool has_aliased_after_self_field = false;\n-  Node_Id component_decl, variant_part;\n+  Entity_Id gnat_component_decl, gnat_variant_part;\n   tree gnu_field, gnu_next, gnu_last;\n   tree gnu_variant_part = NULL_TREE;\n   tree gnu_rep_list = NULL_TREE;\n-  tree gnu_var_list = NULL_TREE;\n-  tree gnu_self_list = NULL_TREE;\n-  tree gnu_zero_list = NULL_TREE;\n \n   /* For each component referenced in a component declaration create a GCC\n      field and add it to the list, skipping pragmas in the GNAT list.  */\n   gnu_last = tree_last (gnu_field_list);\n   if (Present (Component_Items (gnat_component_list)))\n-    for (component_decl\n+    for (gnat_component_decl\n \t   = First_Non_Pragma (Component_Items (gnat_component_list));\n-\t Present (component_decl);\n-\t component_decl = Next_Non_Pragma (component_decl))\n+\t Present (gnat_component_decl);\n+\t gnat_component_decl = Next_Non_Pragma (gnat_component_decl))\n       {\n-\tEntity_Id gnat_field = Defining_Entity (component_decl);\n+\tEntity_Id gnat_field = Defining_Entity (gnat_component_decl);\n \tName_Id gnat_name = Chars (gnat_field);\n \n \t/* If present, the _Parent field must have been created as the single\n@@ -7603,7 +7664,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       }\n \n   /* At the end of the component list there may be a variant part.  */\n-  variant_part = Variant_Part (gnat_component_list);\n+  gnat_variant_part = Variant_Part (gnat_component_list);\n \n   /* We create a QUAL_UNION_TYPE for the variant part since the variants are\n      mutually exclusive and should go in the same memory.  To do this we need\n@@ -7612,9 +7673,9 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n      lists for the variants and put them all into the QUAL_UNION_TYPE.\n      If this is an Unchecked_Union, we make a UNION_TYPE instead or\n      use GNU_RECORD_TYPE if there are no fields so far.  */\n-  if (Present (variant_part))\n+  if (Present (gnat_variant_part))\n     {\n-      Node_Id gnat_discr = Name (variant_part), variant;\n+      Node_Id gnat_discr = Name (gnat_variant_part), variant;\n       tree gnu_discr = gnat_to_gnu (gnat_discr);\n       tree gnu_name = TYPE_IDENTIFIER (gnu_record_type);\n       tree gnu_var_name\n@@ -7676,7 +7737,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t the container types and computing the associated properties.  However\n \t we cannot finish up the container types during this pass because we\n \t don't know where the variant part will be placed until the end.  */\n-      for (variant = First_Non_Pragma (Variants (variant_part));\n+      for (variant = First_Non_Pragma (Variants (gnat_variant_part));\n \t   Present (variant);\n \t   variant = Next_Non_Pragma (variant))\n \t{\n@@ -7712,12 +7773,11 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  /* Add the fields into the record type for the variant.  Note that\n \t     we aren't sure to really use it at this point, see below.  */\n \t  has_rep\n-\t    = components_to_record (gnu_variant_type, Component_List (variant),\n-\t\t\t\t    NULL_TREE, packed, definition,\n-\t\t\t\t    !all_rep_and_size, all_rep,\n-\t\t\t\t    unchecked_union,\n-\t\t\t\t    true, needs_xv_encodings, true, reorder,\n-\t\t\t\t    this_first_free_pos,\n+\t    = components_to_record (Component_List (variant), gnat_record_type,\n+\t\t\t\t    NULL_TREE, gnu_variant_type, packed,\n+\t\t\t\t    definition, !all_rep_and_size, all_rep,\n+\t\t\t\t    unchecked_union, true, needs_xv_encodings,\n+\t\t\t\t    true, this_first_free_pos,\n \t\t\t\t    all_rep || this_first_free_pos\n \t\t\t\t    ? NULL : &gnu_rep_list);\n \n@@ -7873,19 +7933,44 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t}\n     }\n \n-  /* Scan GNU_FIELD_LIST and see if any fields have rep clauses and, if we are\n-     permitted to reorder components, self-referential sizes or variable sizes.\n-     If they do, pull them out and put them onto the appropriate list.  We have\n-     to do this in a separate pass since we want to handle the discriminants\n-     but can't play with them until we've used them in debugging data above.\n+  /* Scan GNU_FIELD_LIST and see if any fields have rep clauses.  If they do,\n+     pull them out and put them onto the appropriate list.  We have to do it\n+     in a separate pass since we want to handle the discriminants but can't\n+     play with them until we've used them in debugging data above.\n \n      Similarly, pull out the fields with zero size and no rep clause, as they\n      would otherwise modify the layout and thus very likely run afoul of the\n      Ada semantics, which are different from those of C here.\n \n+     Finally, if there is an aliased field placed in the list after fields\n+     with self-referential size, pull out the latter in the same way.\n+\n+     Optionally, if the reordering mechanism is enabled, pull out the fields\n+     with self-referential size, variable size and fixed size not a multiple\n+     of a byte, so that they don't cause the regular fields to be either at\n+     self-referential/variable offset or misaligned.  Note, in the latter\n+     case, that this can only happen in packed record types so the alignment\n+     is effectively capped to the byte for the whole record.\n+\n+     Optionally, if the layout warning is enabled, keep track of the above 4\n+     different kinds of fields and issue a warning if some of them would be\n+     (or are being) reordered by the reordering mechanism.\n+\n      ??? If we reorder them, debugging information will be wrong but there is\n      nothing that can be done about this at the moment.  */\n-  gnu_last = NULL_TREE;\n+  const bool do_reorder = OK_To_Reorder_Components (gnat_record_type);\n+  const bool w_reorder\n+    = Warn_On_Questionable_Layout\n+      && (Convention (gnat_record_type) == Convention_Ada);\n+  const bool in_variant = (p_gnu_rep_list != NULL);\n+  tree gnu_zero_list = NULL_TREE;\n+  tree gnu_self_list = NULL_TREE;\n+  tree gnu_var_list = NULL_TREE;\n+  tree gnu_bitp_list = NULL_TREE;\n+  tree gnu_tmp_bitp_list = NULL_TREE;\n+  unsigned int tmp_bitp_size = 0;\n+  unsigned int last_reorder_field_type = -1;\n+  unsigned int tmp_last_reorder_field_type = -1;\n \n #define MOVE_FROM_FIELD_LIST_TO(LIST)\t\\\n   do {\t\t\t\t\t\\\n@@ -7898,6 +7983,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n     (LIST) = gnu_field;\t\t\t\\\n   } while (0)\n \n+  gnu_last = NULL_TREE;\n   for (gnu_field = gnu_field_list; gnu_field; gnu_field = gnu_next)\n     {\n       gnu_next = DECL_CHAIN (gnu_field);\n@@ -7908,19 +7994,6 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  continue;\n \t}\n \n-      if ((reorder || has_aliased_after_self_field)\n-\t  && field_has_self_size (gnu_field))\n-\t{\n-\t  MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n-\t  continue;\n-\t}\n-\n-      if (reorder && field_has_variable_size (gnu_field))\n-\t{\n-\t  MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n-\t  continue;\n-\t}\n-\n       if (DECL_SIZE (gnu_field) && integer_zerop (DECL_SIZE (gnu_field)))\n \t{\n \t  DECL_FIELD_OFFSET (gnu_field) = size_zero_node;\n@@ -7934,6 +8007,129 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  continue;\n \t}\n \n+      if (has_aliased_after_self_field && field_has_self_size (gnu_field))\n+\t{\n+\t  MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n+\t  continue;\n+\t}\n+\n+      /* We don't need further processing in default mode.  */\n+      if (!w_reorder && !do_reorder)\n+\t{\n+\t  gnu_last = gnu_field;\n+\t  continue;\n+\t}\n+\n+      if (field_has_self_size (gnu_field))\n+\t{\n+\t  if (w_reorder)\n+\t    {\n+\t      if (last_reorder_field_type < 4)\n+\t\twarn_on_field_placement (gnu_field, gnat_component_list,\n+\t\t\t\t\t gnat_record_type, in_variant,\n+\t\t\t\t\t do_reorder);\n+\t      else\n+\t\tlast_reorder_field_type = 4;\n+\t    }\n+\n+\t  if (do_reorder)\n+\t    {\n+\t      MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      else if (field_has_variable_size (gnu_field))\n+\t{\n+\t  if (w_reorder)\n+\t    {\n+\t      if (last_reorder_field_type < 3)\n+\t\twarn_on_field_placement (gnu_field, gnat_component_list,\n+\t\t\t\t\t gnat_record_type, in_variant,\n+\t\t\t\t\t do_reorder);\n+\t      else\n+\t\tlast_reorder_field_type = 3;\n+\t    }\n+\n+\t  if (do_reorder)\n+\t    {\n+\t      MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  /* If the field has no size, then it cannot be bit-packed.  */\n+\t  const unsigned int bitp_size\n+\t    = DECL_SIZE (gnu_field)\n+\t      ? TREE_INT_CST_LOW (DECL_SIZE (gnu_field)) % BITS_PER_UNIT\n+\t      : 0;\n+\n+\t  /* If the field is bit-packed, we move it to a temporary list that\n+\t     contains the contiguously preceding bit-packed fields, because\n+\t     we want to be able to put them back if the misalignment happens\n+\t     to cancel itself after several bit-packed fields.  */\n+\t  if (bitp_size != 0)\n+\t    {\n+\t      tmp_bitp_size = (tmp_bitp_size + bitp_size) % BITS_PER_UNIT;\n+\n+\t      if (last_reorder_field_type != 2)\n+\t\t{\n+\t\t  tmp_last_reorder_field_type = last_reorder_field_type;\n+\t\t  last_reorder_field_type = 2;\n+\t\t}\n+\n+\t      if (do_reorder)\n+\t\t{\n+\t\t  MOVE_FROM_FIELD_LIST_TO (gnu_tmp_bitp_list);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  /* No more bit-packed fields, move the existing ones to the end or\n+\t     put them back at their original location.  */\n+\t  else if (last_reorder_field_type == 2 || gnu_tmp_bitp_list)\n+\t    {\n+\t      last_reorder_field_type = 1;\n+\n+\t      if (tmp_bitp_size != 0)\n+\t\t{\n+\t\t  if (w_reorder && tmp_last_reorder_field_type < 2)\n+\t\t    warn_on_field_placement (gnu_tmp_bitp_list\n+\t\t\t\t\t     ? gnu_tmp_bitp_list : gnu_last,\n+\t\t\t\t\t     gnat_component_list,\n+\t\t\t\t\t     gnat_record_type, in_variant,\n+\t\t\t\t\t     do_reorder);\n+\n+\t\t  if (do_reorder)\n+\t\t    gnu_bitp_list = chainon (gnu_tmp_bitp_list, gnu_bitp_list);\n+\n+\t\t  gnu_tmp_bitp_list = NULL_TREE;\n+\t\t  tmp_bitp_size = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Rechain the temporary list in front of GNU_FIELD.  */\n+\t\t  tree gnu_bitp_field = gnu_field;\n+\t\t  while (gnu_tmp_bitp_list)\n+\t\t    {\n+\t\t      tree gnu_bitp_next = DECL_CHAIN (gnu_tmp_bitp_list);\n+\t\t      DECL_CHAIN (gnu_tmp_bitp_list) = gnu_bitp_field;\n+\t\t      if (gnu_last)\n+\t\t\tDECL_CHAIN (gnu_last) = gnu_tmp_bitp_list;\n+\t\t      else\n+\t\t\tgnu_field_list = gnu_tmp_bitp_list;\n+\t\t      gnu_bitp_field = gnu_tmp_bitp_list;\n+\t\t      gnu_tmp_bitp_list = gnu_bitp_next;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  else\n+\t    last_reorder_field_type = 1;\n+\t}\n+\n       gnu_last = gnu_field;\n     }\n \n@@ -7943,15 +8139,30 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n   /* If permitted, we reorder the fields as follows:\n \n-       1) all fixed length fields,\n-       2) all fields whose length doesn't depend on discriminants,\n-       3) all fields whose length depends on discriminants,\n-       4) the variant part,\n+      1) all (groups of) fields whose length is fixed and multiple of a byte,\n+      2) the remaining fields whose length is fixed and not multiple of a byte,\n+      3) the remaining fields whose length doesn't depend on discriminants,\n+      4) all fields whose length depends on discriminants,\n+      5) the variant part,\n \n      within the record and within each variant recursively.  */\n-  if (reorder)\n-    gnu_field_list\n-      = chainon (gnu_field_list, chainon (gnu_var_list, gnu_self_list));\n+  if (w_reorder\n+      && last_reorder_field_type == 2\n+      && tmp_last_reorder_field_type < 2)\n+    warn_on_field_placement (gnu_tmp_bitp_list\n+\t\t\t     ? gnu_tmp_bitp_list : gnu_field_list,\n+\t\t\t     gnat_component_list, gnat_record_type,\n+\t\t\t     in_variant, do_reorder);\n+  if (do_reorder)\n+    {\n+      if (gnu_tmp_bitp_list)\n+\tgnu_bitp_list = chainon (gnu_tmp_bitp_list, gnu_bitp_list);\n+\n+      gnu_field_list\n+\t= chainon (gnu_field_list,\n+\t\t   chainon (gnu_bitp_list,\n+\t\t\t    chainon (gnu_var_list, gnu_self_list)));\n+    }\n \n   /* Otherwise, if there is an aliased field placed after a field whose length\n      depends on discriminants, we put all the fields of the latter sort, last."}, {"sha": "8da1c5007edd9f8141ab753571f970accf3330cb", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -500,26 +500,29 @@ procedure Gnat1drv is\n          --  Detect that the runtime library support for floating-point numbers\n          --  may not be compatible with SPARK analysis of IEEE-754 floats.\n \n-         if Denorm_On_Target = False then\n-            Write_Line\n-              (\"warning: Run-time library may be configured incorrectly\");\n-            Write_Line\n-              (\"warning: \"\n-               & \"(SPARK analysis requires support for float subnormals)\");\n-\n-         elsif Machine_Rounds_On_Target = False then\n-            Write_Line\n-              (\"warning: Run-time library may be configured incorrectly\");\n-            Write_Line\n-              (\"warning: \"\n-               & \"(SPARK analysis requires support for float rounding)\");\n-\n-         elsif Signed_Zeros_On_Target = False then\n-            Write_Line\n-              (\"warning: Run-time library may be configured incorrectly\");\n-            Write_Line\n-              (\"warning: (SPARK analysis requires support for signed zeros)\");\n-         end if;\n+         declare\n+            procedure SPARK_Library_Warning (Kind : String);\n+            --  Issue a warning in GNATprove mode if the run-time library does\n+            --  not fully support IEEE-754 floating-point semantics.\n+\n+            procedure SPARK_Library_Warning (Kind : String) is\n+            begin\n+               Write_Line\n+                 (\"warning: run-time library may be configured incorrectly\");\n+               Write_Line\n+                 (\"warning: (SPARK analysis requires support for \" & Kind\n+                  & ')');\n+            end SPARK_Library_Warning;\n+\n+         begin\n+            if Denorm_On_Target = False then\n+               SPARK_Library_Warning (\"float subnormals\");\n+            elsif Machine_Rounds_On_Target = False then\n+               SPARK_Library_Warning (\"float rounding\");\n+            elsif Signed_Zeros_On_Target = False then\n+               SPARK_Library_Warning (\"signed zeros\");\n+            end if;\n+         end;\n       end if;\n \n       --  Set Configurable_Run_Time mode if system.ads flag set or if the"}, {"sha": "a5b1d98bc10e8ca15c6f8d9834f0568d05a7f38d", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -410,8 +410,7 @@ package body Inline is\n \n       if not Comes_From_Source (N)\n         and then In_Extended_Main_Source_Unit (N)\n-        and then\n-          Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (E)))\n+        and then Is_Predefined_Unit (Get_Source_Unit (E))\n       then\n          Set_Needs_Debug_Info (E, False);\n       end if;\n@@ -1556,7 +1555,7 @@ package body Inline is\n          --  subprograms may contain nested subprograms and become ineligible\n          --  for inlining.\n \n-         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n+         if Is_Predefined_Unit (Get_Source_Unit (Subp))\n            and then not In_Extended_Main_Source_Unit (Subp)\n          then\n             null;\n@@ -1602,7 +1601,7 @@ package body Inline is\n          --  compatibility but it will be removed when we enforce the\n          --  strictness of the new rules.\n \n-         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n+         if Is_Predefined_Unit (Get_Source_Unit (Subp))\n            and then not In_Extended_Main_Source_Unit (Subp)\n          then\n             null;\n@@ -1617,9 +1616,7 @@ package body Inline is\n                declare\n                   Gen_P : constant Entity_Id := Generic_Parent (Parent (Subp));\n                begin\n-                  if Is_Predefined_File_Name\n-                       (Unit_File_Name (Get_Source_Unit (Gen_P)))\n-                  then\n+                  if Is_Predefined_Unit (Get_Source_Unit (Gen_P)) then\n                      Set_Is_Inlined (Subp, False);\n                      Error_Msg_NE (Msg & \"p?\", N, Subp);\n                      return;\n@@ -2283,8 +2280,7 @@ package body Inline is\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Is_Predef : constant Boolean :=\n-                    Is_Predefined_File_Name\n-                      (Unit_File_Name (Get_Source_Unit (Subp)));\n+                    Is_Predefined_Unit (Get_Source_Unit (Subp));\n       Orig_Bod  : constant Node_Id :=\n                     Body_To_Inline (Unit_Declaration_Node (Subp));\n \n@@ -3565,8 +3561,7 @@ package body Inline is\n          end if;\n \n          return Present (Conv)\n-           and then Is_Predefined_File_Name\n-                      (Unit_File_Name (Get_Source_Unit (Conv)))\n+           and then Is_Predefined_Unit (Get_Source_Unit (Conv))\n            and then Is_Intrinsic_Subprogram (Conv);\n       end Is_Unchecked_Conversion;\n "}, {"sha": "a856b14f2f83df03bce06555b3436cd0cfd62343", "filename": "gcc/ada/lib-list.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib-list.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib-list.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-list.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,9 +78,7 @@ begin\n \n    for R in Sorted_Units'Range loop\n       if File_Names_Only then\n-         if not Is_Internal_File_Name\n-                  (File_Name (Source_Index (Sorted_Units (R))))\n-         then\n+         if not Is_Internal_Unit (Sorted_Units (R)) then\n             Write_Name (Full_File_Name (Source_Index (Sorted_Units (R))));\n             Write_Eol;\n          end if;"}, {"sha": "e05bde164b399fb77adf9f8f49e9275b9cbb43c5", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 112, "deletions": 74, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -145,7 +145,15 @@ package body Lib.Load is\n       Cunit        : Node_Id;\n       Du_Name      : Node_Or_Entity_Id;\n       End_Lab      : Node_Id;\n-      Save_CS      : constant Boolean := Get_Comes_From_Source_Default;\n+      Fname        : constant File_Name_Type :=\n+        Get_File_Name (Spec_Name, Subunit => False);\n+      Pre_Name : constant Boolean :=\n+        Is_Predefined_File_Name (Fname, Renamings_Included => False);\n+      Ren_Name : constant Boolean :=\n+        Is_Predefined_Renaming_File_Name (Fname);\n+      GNAT_Name : constant Boolean :=\n+        Is_GNAT_File_Name (Fname);\n+      Save_CS : constant Boolean := Get_Comes_From_Source_Default;\n \n    begin\n       --  The created dummy package unit does not come from source\n@@ -205,29 +213,35 @@ package body Lib.Load is\n       Units.Increment_Last;\n       Unum := Units.Last;\n \n-      Units.Table (Unum) := (\n-        Cunit             => Cunit,\n-        Cunit_Entity      => Cunit_Entity,\n-        Dependency_Num    => 0,\n-        Dynamic_Elab      => False,\n-        Error_Location    => Sloc (With_Node),\n-        Expected_Unit     => Spec_Name,\n-        Fatal_Error       => Error_Detected,\n-        Generate_Code     => False,\n-        Has_RACW          => False,\n-        Filler            => False,\n-        Ident_String      => Empty,\n-        Loading           => False,\n-        Main_Priority     => Default_Main_Priority,\n-        Main_CPU          => Default_Main_CPU,\n-        Munit_Index       => 0,\n-        No_Elab_Code_All  => False,\n-        Serial_Number     => 0,\n-        Source_Index      => No_Source_File,\n-        Unit_File_Name    => Get_File_Name (Spec_Name, Subunit => False),\n-        Unit_Name         => Spec_Name,\n-        Version           => 0,\n-        OA_Setting        => 'O');\n+      Units.Table (Unum) :=\n+        (Cunit             => Cunit,\n+         Cunit_Entity      => Cunit_Entity,\n+         Dependency_Num    => 0,\n+         Dynamic_Elab      => False,\n+         Error_Location    => Sloc (With_Node),\n+         Expected_Unit     => Spec_Name,\n+         Fatal_Error       => Error_Detected,\n+         Generate_Code     => False,\n+         Has_RACW          => False,\n+         Filler            => False,\n+         Ident_String      => Empty,\n+\n+         Is_Predefined_Renaming => Ren_Name,\n+         Is_Predefined_Unit     => Pre_Name or Ren_Name,\n+         Is_Internal_Unit       => Pre_Name or Ren_Name or GNAT_Name,\n+         Filler2                => False,\n+\n+         Loading           => False,\n+         Main_Priority     => Default_Main_Priority,\n+         Main_CPU          => Default_Main_CPU,\n+         Munit_Index       => 0,\n+         No_Elab_Code_All  => False,\n+         Serial_Number     => 0,\n+         Source_Index      => No_Source_File,\n+         Unit_File_Name    => Fname,\n+         Unit_Name         => Spec_Name,\n+         Version           => 0,\n+         OA_Setting        => 'O');\n \n       Set_Comes_From_Source_Default (Save_CS);\n       Set_Error_Posted (Cunit_Entity);\n@@ -285,7 +299,13 @@ package body Lib.Load is\n    ----------------------\n \n    procedure Load_Main_Source is\n-      Fname   : File_Name_Type;\n+      Fname : constant File_Name_Type := Next_Main_Source;\n+      Pre_Name : constant Boolean :=\n+        Is_Predefined_File_Name (Fname, Renamings_Included => False);\n+      Ren_Name : constant Boolean :=\n+        Is_Predefined_Renaming_File_Name (Fname);\n+      GNAT_Name : constant Boolean :=\n+        Is_GNAT_File_Name (Fname);\n       Version : Word := 0;\n \n    begin\n@@ -299,7 +319,6 @@ package body Lib.Load is\n       --  Cunit_Entity fields also get filled in later by the parser.\n \n       Units.Increment_Last;\n-      Fname := Next_Main_Source;\n \n       Units.Table (Main_Unit).Unit_File_Name := Fname;\n \n@@ -311,29 +330,35 @@ package body Lib.Load is\n             Version := Source_Checksum (Main_Source_File);\n          end if;\n \n-         Units.Table (Main_Unit) := (\n-           Cunit             => Empty,\n-           Cunit_Entity      => Empty,\n-           Dependency_Num    => 0,\n-           Dynamic_Elab      => False,\n-           Error_Location    => No_Location,\n-           Expected_Unit     => No_Unit_Name,\n-           Fatal_Error       => None,\n-           Generate_Code     => False,\n-           Has_RACW          => False,\n-           Filler            => False,\n-           Ident_String      => Empty,\n-           Loading           => True,\n-           Main_Priority     => Default_Main_Priority,\n-           Main_CPU          => Default_Main_CPU,\n-           Munit_Index       => 0,\n-           No_Elab_Code_All  => False,\n-           Serial_Number     => 0,\n-           Source_Index      => Main_Source_File,\n-           Unit_File_Name    => Fname,\n-           Unit_Name         => No_Unit_Name,\n-           Version           => Version,\n-           OA_Setting        => 'O');\n+         Units.Table (Main_Unit) :=\n+           (Cunit             => Empty,\n+            Cunit_Entity      => Empty,\n+            Dependency_Num    => 0,\n+            Dynamic_Elab      => False,\n+            Error_Location    => No_Location,\n+            Expected_Unit     => No_Unit_Name,\n+            Fatal_Error       => None,\n+            Generate_Code     => False,\n+            Has_RACW          => False,\n+            Filler            => False,\n+            Ident_String      => Empty,\n+\n+            Is_Predefined_Renaming => Ren_Name,\n+            Is_Predefined_Unit     => Pre_Name or Ren_Name,\n+            Is_Internal_Unit       => Pre_Name or Ren_Name or GNAT_Name,\n+            Filler2                => False,\n+\n+            Loading           => True,\n+            Main_Priority     => Default_Main_Priority,\n+            Main_CPU          => Default_Main_CPU,\n+            Munit_Index       => 0,\n+            No_Elab_Code_All  => False,\n+            Serial_Number     => 0,\n+            Source_Index      => Main_Source_File,\n+            Unit_File_Name    => Fname,\n+            Unit_Name         => No_Unit_Name,\n+            Version           => Version,\n+            OA_Setting        => 'O');\n       end if;\n    end Load_Main_Source;\n \n@@ -356,6 +381,9 @@ package body Lib.Load is\n       Unum         : Unit_Number_Type;\n       Unump        : Unit_Number_Type;\n       Fname        : File_Name_Type;\n+      Pre_Name     : Boolean;\n+      Ren_Name     : Boolean;\n+      GNAT_Name    : Boolean;\n       Src_Ind      : Source_File_Index;\n       Save_PMES    : constant Boolean := Parsing_Main_Extended_Source;\n \n@@ -467,7 +495,11 @@ package body Lib.Load is\n          Uname_Actual := Load_Name;\n       end if;\n \n-      Fname := Get_File_Name (Uname_Actual, Subunit);\n+      Fname     := Get_File_Name (Uname_Actual, Subunit);\n+      Pre_Name  :=\n+        Is_Predefined_File_Name (Fname, Renamings_Included => False);\n+      Ren_Name  := Is_Predefined_Renaming_File_Name (Fname);\n+      GNAT_Name := Is_GNAT_File_Name (Fname);\n \n       if Debug_Flag_L then\n          Write_Eol;\n@@ -676,29 +708,35 @@ package body Lib.Load is\n          --  File was found\n \n          if Src_Ind /= No_Source_File then\n-            Units.Table (Unum) := (\n-              Cunit             => Empty,\n-              Cunit_Entity      => Empty,\n-              Dependency_Num    => 0,\n-              Dynamic_Elab      => False,\n-              Error_Location    => Sloc (Error_Node),\n-              Expected_Unit     => Uname_Actual,\n-              Fatal_Error       => None,\n-              Generate_Code     => False,\n-              Has_RACW          => False,\n-              Filler            => False,\n-              Ident_String      => Empty,\n-              Loading           => True,\n-              Main_Priority     => Default_Main_Priority,\n-              Main_CPU          => Default_Main_CPU,\n-              Munit_Index       => 0,\n-              No_Elab_Code_All  => False,\n-              Serial_Number     => 0,\n-              Source_Index      => Src_Ind,\n-              Unit_File_Name    => Fname,\n-              Unit_Name         => Uname_Actual,\n-              Version           => Source_Checksum (Src_Ind),\n-              OA_Setting        => 'O');\n+            Units.Table (Unum) :=\n+              (Cunit             => Empty,\n+               Cunit_Entity      => Empty,\n+               Dependency_Num    => 0,\n+               Dynamic_Elab      => False,\n+               Error_Location    => Sloc (Error_Node),\n+               Expected_Unit     => Uname_Actual,\n+               Fatal_Error       => None,\n+               Generate_Code     => False,\n+               Has_RACW          => False,\n+               Filler            => False,\n+               Ident_String      => Empty,\n+\n+               Is_Predefined_Renaming => Ren_Name,\n+               Is_Predefined_Unit     => Pre_Name or Ren_Name,\n+               Is_Internal_Unit       => Pre_Name or Ren_Name or GNAT_Name,\n+               Filler2                => False,\n+\n+               Loading           => True,\n+               Main_Priority     => Default_Main_Priority,\n+               Main_CPU          => Default_Main_CPU,\n+               Munit_Index       => 0,\n+               No_Elab_Code_All  => False,\n+               Serial_Number     => 0,\n+               Source_Index      => Src_Ind,\n+               Unit_File_Name    => Fname,\n+               Unit_Name         => Uname_Actual,\n+               Version           => Source_Checksum (Src_Ind),\n+               OA_Setting        => 'O');\n \n             --  Parse the new unit\n \n@@ -880,7 +918,7 @@ package body Lib.Load is\n    --  code will have to be generated for it.\n \n    procedure Make_Instance_Unit (N : Node_Id; In_Main : Boolean) is\n-      Sind : constant Source_File_Index := Source_Index (Main_Unit);\n+      Sind  : constant Source_File_Index := Source_Index (Main_Unit);\n \n    begin\n       Units.Increment_Last;"}, {"sha": "895e185d87c73238b998f4454c215effce9abb4b", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -74,28 +74,32 @@ package body Lib.Writ is\n    begin\n       Units.Increment_Last;\n       Units.Table (Units.Last) :=\n-        (Unit_File_Name    => File_Name (S),\n-         Unit_Name         => No_Unit_Name,\n-         Expected_Unit     => No_Unit_Name,\n-         Source_Index      => S,\n-         Cunit             => Empty,\n-         Cunit_Entity      => Empty,\n-         Dependency_Num    => 0,\n-         Dynamic_Elab      => False,\n-         Fatal_Error       => None,\n-         Generate_Code     => False,\n-         Has_RACW          => False,\n-         Filler            => False,\n-         Ident_String      => Empty,\n-         Loading           => False,\n-         Main_Priority     => -1,\n-         Main_CPU          => -1,\n-         Munit_Index       => 0,\n-         No_Elab_Code_All  => False,\n-         Serial_Number     => 0,\n-         Version           => 0,\n-         Error_Location    => No_Location,\n-         OA_Setting        => 'O');\n+        (Unit_File_Name         => File_Name (S),\n+         Unit_Name              => No_Unit_Name,\n+         Expected_Unit          => No_Unit_Name,\n+         Source_Index           => S,\n+         Cunit                  => Empty,\n+         Cunit_Entity           => Empty,\n+         Dependency_Num         => 0,\n+         Dynamic_Elab           => False,\n+         Fatal_Error            => None,\n+         Generate_Code          => False,\n+         Has_RACW               => False,\n+         Filler                 => False,\n+         Ident_String           => Empty,\n+         Is_Predefined_Renaming => False,\n+         Is_Internal_Unit       => False,\n+         Is_Predefined_Unit     => False,\n+         Filler2                => False,\n+         Loading                => False,\n+         Main_Priority          => -1,\n+         Main_CPU               => -1,\n+         Munit_Index            => 0,\n+         No_Elab_Code_All       => False,\n+         Serial_Number          => 0,\n+         Version                => 0,\n+         Error_Location         => No_Location,\n+         OA_Setting             => 'O');\n    end Add_Preprocessing_Dependency;\n \n    ------------------------------\n@@ -130,29 +134,33 @@ package body Lib.Writ is\n       System_Fname := File_Name (System_Source_File_Index);\n \n       Units.Increment_Last;\n-      Units.Table (Units.Last) := (\n-        Unit_File_Name    => System_Fname,\n-        Unit_Name         => System_Uname,\n-        Expected_Unit     => System_Uname,\n-        Source_Index      => System_Source_File_Index,\n-        Cunit             => Empty,\n-        Cunit_Entity      => Empty,\n-        Dependency_Num    => 0,\n-        Dynamic_Elab      => False,\n-        Fatal_Error       => None,\n-        Generate_Code     => False,\n-        Has_RACW          => False,\n-        Filler            => False,\n-        Ident_String      => Empty,\n-        Loading           => False,\n-        Main_Priority     => -1,\n-        Main_CPU          => -1,\n-        Munit_Index       => 0,\n-        No_Elab_Code_All  => False,\n-        Serial_Number     => 0,\n-        Version           => 0,\n-        Error_Location    => No_Location,\n-        OA_Setting        => 'O');\n+      Units.Table (Units.Last) :=\n+        (Unit_File_Name         => System_Fname,\n+         Unit_Name              => System_Uname,\n+         Expected_Unit          => System_Uname,\n+         Source_Index           => System_Source_File_Index,\n+         Cunit                  => Empty,\n+         Cunit_Entity           => Empty,\n+         Dependency_Num         => 0,\n+         Dynamic_Elab           => False,\n+         Fatal_Error            => None,\n+         Generate_Code          => False,\n+         Has_RACW               => False,\n+         Filler                 => False,\n+         Ident_String           => Empty,\n+         Is_Predefined_Renaming => False,\n+         Is_Internal_Unit       => True,\n+         Is_Predefined_Unit     => True,\n+         Filler2                => False,\n+         Loading                => False,\n+         Main_Priority          => -1,\n+         Main_CPU               => -1,\n+         Munit_Index            => 0,\n+         No_Elab_Code_All       => False,\n+         Serial_Number          => 0,\n+         Version                => 0,\n+         Error_Location         => No_Location,\n+         OA_Setting             => 'O');\n \n       --  Parse system.ads so that the checksum is set right. Style checks are\n       --  not applied. The Ekind is set to ensure that this reference is always\n@@ -533,7 +541,7 @@ package body Lib.Writ is\n             Write_Info_Str (\" GE\");\n          end if;\n \n-         if not Is_Internal_File_Name (Unit_File_Name (Unit_Num), True) then\n+         if not Is_Internal_Unit (Unit_Num) then\n             case Identifier_Casing (Source_Index (Unit_Num)) is\n                when All_Lower_Case => Write_Info_Str (\" IL\");\n                when All_Upper_Case => Write_Info_Str (\" IU\");\n@@ -618,8 +626,7 @@ package body Lib.Writ is\n             --  parameters (see Lib_Writ spec for an explanation).\n \n             if Is_Generic_Unit (Cunit_Entity (Main_Unit))\n-              and then\n-                Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n+              and then Is_Predefined_Unit (Current_Sem_Unit)\n               and then Linker_Option_Lines.Table (J).Unit = Unit_Num\n             then\n                Set_Standard_Error;\n@@ -858,7 +865,7 @@ package body Lib.Writ is\n             if not ((Nkind (Unit (Cunit)) in N_Generic_Declaration\n                       or else\n                      Nkind (Unit (Cunit)) in N_Generic_Renaming_Declaration)\n-                    and then Generic_May_Lack_ALI (Fname))\n+                    and then Generic_May_Lack_ALI (Unum))\n \n               --  In SPARK mode, always generate the dependencies on ALI\n               --  files, which are required to compute frame conditions\n@@ -1160,9 +1167,7 @@ package body Lib.Writ is\n          Write_Info_Str (\" DB\");\n       end if;\n \n-      if Tasking_Used\n-        and then not Is_Predefined_File_Name (Unit_File_Name (Main_Unit))\n-      then\n+      if Tasking_Used and then not Is_Predefined_Unit (Main_Unit) then\n          if Locking_Policy /= ' ' then\n             Write_Info_Str  (\" L\");\n             Write_Info_Char (Locking_Policy);"}, {"sha": "16c8afc9ccbd8f99cc2ed12ffaca908d89ad92dc", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -36,7 +36,6 @@ pragma Style_Checks (All_Checks);\n with Atree;    use Atree;\n with Csets;    use Csets;\n with Einfo;    use Einfo;\n-with Fname;    use Fname;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Output;   use Output;\n@@ -127,6 +126,21 @@ package body Lib is\n       return Units.Table (U).Has_RACW;\n    end Has_RACW;\n \n+   function Is_Predefined_Renaming (U : Unit_Number_Type) return Boolean is\n+   begin\n+      return Units.Table (U).Is_Predefined_Renaming;\n+   end Is_Predefined_Renaming;\n+\n+   function Is_Internal_Unit       (U : Unit_Number_Type) return Boolean is\n+   begin\n+      return Units.Table (U).Is_Internal_Unit;\n+   end Is_Internal_Unit;\n+\n+   function Is_Predefined_Unit     (U : Unit_Number_Type) return Boolean is\n+   begin\n+      return Units.Table (U).Is_Predefined_Unit;\n+   end Is_Predefined_Unit;\n+\n    function Ident_String (U : Unit_Number_Type) return Node_Id is\n    begin\n       return Units.Table (U).Ident_String;\n@@ -576,7 +590,7 @@ package body Lib is\n    -- Generic_May_Lack_ALI --\n    --------------------------\n \n-   function Generic_May_Lack_ALI (Sfile : File_Name_Type) return Boolean is\n+   function Generic_May_Lack_ALI (Unum : Unit_Number_Type) return Boolean is\n    begin\n       --  We allow internal generic units to be used without having a\n       --  corresponding ALI files to help bootstrapping with older compilers\n@@ -585,9 +599,7 @@ package body Lib is\n       --  is the elaboration boolean, and we are careful to elaborate all\n       --  predefined units first anyway.\n \n-      return Is_Internal_File_Name\n-               (Fname              => Sfile,\n-                Renamings_Included => True);\n+      return Is_Internal_Unit (Unum);\n    end Generic_May_Lack_ALI;\n \n    -----------------------------\n@@ -904,12 +916,25 @@ package body Lib is\n \n    function In_Internal_Unit (S : Source_Ptr) return Boolean is\n       Unit : constant Unit_Number_Type := Get_Source_Unit (S);\n-      File : constant File_Name_Type   := Unit_File_Name (Unit);\n-\n    begin\n-      return Is_Internal_File_Name (File);\n+      return Is_Internal_Unit (Unit);\n    end In_Internal_Unit;\n \n+   ----------------------------\n+   -- In_Predefined_Renaming --\n+   ----------------------------\n+\n+   function In_Predefined_Renaming (N : Node_Or_Entity_Id) return Boolean is\n+   begin\n+      return In_Predefined_Renaming (Sloc (N));\n+   end In_Predefined_Renaming;\n+\n+   function In_Predefined_Renaming (S : Source_Ptr) return Boolean is\n+      Unit : constant Unit_Number_Type := Get_Source_Unit (S);\n+   begin\n+      return Is_Predefined_Renaming (Unit);\n+   end In_Predefined_Renaming;\n+\n    ------------------------\n    -- In_Predefined_Unit --\n    ------------------------\n@@ -921,9 +946,8 @@ package body Lib is\n \n    function In_Predefined_Unit (S : Source_Ptr) return Boolean is\n       Unit : constant Unit_Number_Type := Get_Source_Unit (S);\n-      File : constant File_Name_Type   := Unit_File_Name (Unit);\n    begin\n-      return Is_Predefined_File_Name (File);\n+      return Is_Predefined_Unit (Unit);\n    end In_Predefined_Unit;\n \n    -----------------------"}, {"sha": "a5b9858eaa920148a8a5c6f433269bfc61b5111b", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -327,6 +327,19 @@ package Lib is\n    --      N_String_Literal node from a valid pragma Ident that applies to\n    --      this unit. If no Ident pragma applies to the unit, then Empty.\n \n+   --    Is_Predefined_Renaming\n+   --      True if this unit is a predefined renaming, as in \"Text_IO renames\n+   --      Ada.Text_IO\").\n+\n+   --    Is_Internal_Unit\n+   --      Same as In_Predefined_Unit, except units in the GNAT hierarchy are\n+   --      included.\n+\n+   --    Is_Predefined_Unit\n+   --      True if this unit is predefined (i.e. part of the Ada, System, or\n+   --      Interface hierarchies, or Is_Predefined_Renaming). Note that units\n+   --      in the GNAT hierarchy are not considered predefined.\n+\n    --    Loading\n    --      A flag that is used to catch circular WITH dependencies. It is set\n    --      True when an entry is initially created in the file table, and set\n@@ -428,6 +441,9 @@ package Lib is\n    function Generate_Code    (U : Unit_Number_Type) return Boolean;\n    function Ident_String     (U : Unit_Number_Type) return Node_Id;\n    function Has_RACW         (U : Unit_Number_Type) return Boolean;\n+   function Is_Predefined_Renaming (U : Unit_Number_Type) return Boolean;\n+   function Is_Internal_Unit       (U : Unit_Number_Type) return Boolean;\n+   function Is_Predefined_Unit     (U : Unit_Number_Type) return Boolean;\n    function Loading          (U : Unit_Number_Type) return Boolean;\n    function Main_CPU         (U : Unit_Number_Type) return Int;\n    function Main_Priority    (U : Unit_Number_Type) return Int;\n@@ -493,7 +509,7 @@ package Lib is\n    --  Return the Nth stored compilation switch, or null if less than N\n    --  switches have been stored. Used by ASIS and back ends written in Ada.\n \n-   function Generic_May_Lack_ALI (Sfile : File_Name_Type) return Boolean;\n+   function Generic_May_Lack_ALI (Unum : Unit_Number_Type) return Boolean;\n    --  Generic units must be separately compiled. Since we always use\n    --  macro substitution for generics, the resulting object file is a dummy\n    --  one with no code, but the ALI file has the normal form, and we need\n@@ -597,13 +613,20 @@ package Lib is\n    --  of the descendant packages of one of these three packages).\n \n    function In_Predefined_Unit (S : Source_Ptr) return Boolean;\n+   pragma Inline (In_Predefined_Unit);\n    --  Same function as above but argument is a source pointer\n \n    function In_Internal_Unit (N : Node_Or_Entity_Id) return Boolean;\n    function In_Internal_Unit (S : Source_Ptr) return Boolean;\n+   pragma Inline (In_Internal_Unit);\n    --  Same as In_Predefined_Unit, except units in the GNAT hierarchy are\n    --  included.\n \n+   function In_Predefined_Renaming (N : Node_Or_Entity_Id) return Boolean;\n+   function In_Predefined_Renaming (S : Source_Ptr) return Boolean;\n+   pragma Inline (In_Predefined_Renaming);\n+   --  Returns True if N or S is in a predefined renaming unit\n+\n    function In_Same_Code_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n    pragma Inline (In_Same_Code_Unit);\n    --  Determines if the two nodes or entities N1 and N2 are in the same\n@@ -776,6 +799,9 @@ private\n    pragma Inline (Set_Fatal_Error);\n    pragma Inline (Set_Generate_Code);\n    pragma Inline (Set_Has_RACW);\n+   pragma Inline (Is_Predefined_Renaming);\n+   pragma Inline (Is_Internal_Unit);\n+   pragma Inline (Is_Predefined_Unit);\n    pragma Inline (Set_Loading);\n    pragma Inline (Set_Main_CPU);\n    pragma Inline (Set_Main_Priority);\n@@ -811,6 +837,11 @@ private\n       Filler            : Boolean;\n       Loading           : Boolean;\n       OA_Setting        : Character;\n+\n+      Is_Predefined_Renaming : Boolean;\n+      Is_Internal_Unit       : Boolean;\n+      Is_Predefined_Unit     : Boolean;\n+      Filler2                : Boolean;\n    end record;\n \n    --  The following representation clause ensures that the above record\n@@ -840,9 +871,14 @@ private\n       Filler            at 61 range 0 ..  7;\n       OA_Setting        at 62 range 0 ..  7;\n       Loading           at 63 range 0 ..  7;\n+\n+      Is_Predefined_Renaming at 64 range 0 .. 7;\n+      Is_Internal_Unit       at 65 range 0 .. 7;\n+      Is_Predefined_Unit     at 66 range 0 .. 7;\n+      Filler2                at 67 range 0 .. 7;\n    end record;\n \n-   for Unit_Record'Size use 64 * 8;\n+   for Unit_Record'Size use 68 * 8;\n    --  This ensures that we did not leave out any fields\n \n    package Units is new Table.Table ("}, {"sha": "41459078421b196c93cff6877ead868f74c18467", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1526,8 +1526,8 @@ begin\n \n       for Ucount in Pos loop\n          Set_Opt_Config_Switches\n-           (Is_Internal_File_Name (File_Name (Current_Source_File)),\n-            Current_Source_Unit = Main_Unit);\n+           (Is_Internal_Unit (Current_Source_Unit),\n+            Main_Unit => Current_Source_Unit = Main_Unit);\n \n          --  Initialize scope table and other parser control variables\n "}, {"sha": "07df8cade5e668396627e6283fc779c4782856be", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1763,7 +1763,7 @@ package body Restrict is\n       --  Otherwise suppress message if internal file\n \n       else\n-         return Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (N)));\n+         return In_Internal_Unit (N);\n       end if;\n    end Suppress_Restriction_Message;\n "}, {"sha": "8bedff6c61ca1d05601e37be55c971193261c9d6", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -469,9 +469,7 @@ package body Rtsfind is\n          --  unit for inlining purposes, the body must be illegal in this\n          --  mode, and there is no point in continuing.\n \n-         if Is_Predefined_File_Name\n-           (Unit_File_Name (Get_Source_Unit (Sloc (Current_Error_Node))))\n-         then\n+         if In_Predefined_Unit (Current_Error_Node) then\n             Error_Msg_N\n               (\"construct not allowed in no run time mode!\",\n                  Current_Error_Node);\n@@ -1626,7 +1624,7 @@ package body Rtsfind is\n       E     : constant Entity_Id        :=\n                 Defining_Entity (Unit (Cunit (Unum)));\n    begin\n-      pragma Assert (Is_Predefined_File_Name (Unit_File_Name (Unum)));\n+      pragma Assert (Is_Predefined_Unit (Unum));\n \n       --  Loop through entries in RTU table looking for matching entry\n "}, {"sha": "35d0d482bbe886abe8aa7c5c7121840a90eb53e2", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -29,7 +29,6 @@ with Debug_A;   use Debug_A;\n with Elists;    use Elists;\n with Exp_SPARK; use Exp_SPARK;\n with Expander;  use Expander;\n-with Fname;     use Fname;\n with Ghost;     use Ghost;\n with Lib;       use Lib;\n with Lib.Load;  use Lib.Load;\n@@ -1425,8 +1424,8 @@ package body Sem is\n       --  Sequential_IO) as this would prevent pragma Extend_System from being\n       --  taken into account, for example when Text_IO is renaming DEC.Text_IO.\n \n-      if Is_Predefined_File_Name\n-           (Unit_File_Name (Current_Sem_Unit), Renamings_Included => False)\n+      if Is_Predefined_Unit (Current_Sem_Unit)\n+        and then not Is_Predefined_Renaming (Current_Sem_Unit)\n       then\n          GNAT_Mode := True;\n       end if;\n@@ -1474,7 +1473,7 @@ package body Sem is\n \n       Save_Opt_Config_Switches (Save_Config_Switches);\n       Set_Opt_Config_Switches\n-        (Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit)),\n+        (Is_Internal_Unit (Current_Sem_Unit),\n          Is_Main_Unit_Or_Main_Unit_Spec);\n \n       --  Save current non-partition-wide restrictions"}, {"sha": "82c4a6ae2733a38c011a11a26aad2383c65ff46e", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -29,7 +29,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Disp; use Exp_Disp;\n-with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -263,8 +262,8 @@ package body Sem_Cat is\n          --  so it is convenient not to generate them (since it causes\n          --  annoying interference with debugging).\n \n-         if Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n-           and then not Is_Internal_File_Name (Unit_File_Name (Main_Unit))\n+         if Is_Internal_Unit (Current_Sem_Unit)\n+           and then not Is_Internal_Unit (Main_Unit)\n          then\n             return;\n \n@@ -949,8 +948,7 @@ package body Sem_Cat is\n \n          if Is_Private_Type (T)\n            and then not Has_Pragma_Preelab_Init (T)\n-           and then not Is_Internal_File_Name\n-                          (Unit_File_Name (Get_Source_Unit (N)))\n+           and then not In_Internal_Unit (N)\n          then\n             Error_Msg_N\n               (\"private ancestor type not allowed in preelaborated unit\", A);\n@@ -1098,8 +1096,7 @@ package body Sem_Cat is\n       if In_Preelaborated_Unit\n         and then not Debug_Flag_PP\n         and then Comes_From_Source (E)\n-        and then not\n-          Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (E)))\n+        and then not In_Internal_Unit (E)\n         and then (not Inside_A_Generic\n                    or else Present (Enclosing_Generic_Body (E)))\n         and then not Is_Protected_Type (Etype (E))\n@@ -2202,7 +2199,7 @@ package body Sem_Cat is\n             E   := Entity (N);\n             Val := Constant_Value (E);\n \n-            if Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (N)))\n+            if In_Internal_Unit (N)\n               and then\n                 Enclosing_Comp_Unit_Node (N) /= Enclosing_Comp_Unit_Node (E)\n               and then (Is_Preelaborated (Scope (E))"}, {"sha": "1f6b237569fac2b419a00a72e3cf1ae13e6eb14d", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -648,9 +648,7 @@ package body Sem_Ch10 is\n             Circularity : Boolean := True;\n \n          begin\n-            if Is_Predefined_File_Name\n-                 (Unit_File_Name (Get_Source_Unit (Unit (N))))\n-            then\n+            if In_Predefined_Unit (N) then\n                Circularity := False;\n \n             else\n@@ -919,13 +917,9 @@ package body Sem_Ch10 is\n \n       --  Register predefined units in Rtsfind\n \n-      declare\n-         Unum : constant Unit_Number_Type := Get_Source_Unit (Sloc (N));\n-      begin\n-         if Is_Predefined_File_Name (Unit_File_Name (Unum)) then\n-            Set_RTU_Loaded (Unit_Node);\n-         end if;\n-      end;\n+      if In_Predefined_Unit (N) then\n+         Set_RTU_Loaded (Unit_Node);\n+      end if;\n \n       --  Treat compilation unit pragmas that appear after the library unit\n \n@@ -1230,7 +1224,7 @@ package body Sem_Ch10 is\n \n                 --  No checks needed for predefined files\n \n-                or else Is_Predefined_File_Name (Unit_File_Name (Unum))\n+                or else Is_Predefined_Unit (Unum)\n \n                 --  No checks required if no separate spec\n \n@@ -2524,18 +2518,10 @@ package body Sem_Ch10 is\n       --  himself, but that's a marginal case, and fixing it is hard ???\n \n       if Restriction_Check_Required (No_Obsolescent_Features) then\n-         declare\n-            F : constant File_Name_Type :=\n-                  Unit_File_Name (Get_Source_Unit (U));\n-         begin\n-            if Is_Predefined_File_Name (F, Renamings_Included => True)\n-                 and then not\n-               Is_Predefined_File_Name (F, Renamings_Included => False)\n-            then\n-               Check_Restriction (No_Obsolescent_Features, N);\n-               Restriction_Violation := True;\n-            end if;\n-         end;\n+         if In_Predefined_Renaming (U) then\n+            Check_Restriction (No_Obsolescent_Features, N);\n+            Restriction_Violation := True;\n+         end if;\n       end if;\n \n       --  Check No_Implementation_Units violation\n@@ -2566,7 +2552,7 @@ package body Sem_Ch10 is\n          --  clauses into regular with clauses.\n \n          if Sloc (U) /= No_Location then\n-            if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (U)))\n+            if In_Predefined_Unit (U)\n \n               --  In ASIS mode the rtsfind mechanism plays no role, and\n               --  we need to maintain the original tree structure, so\n@@ -2598,7 +2584,7 @@ package body Sem_Ch10 is\n \n       Semantics (Library_Unit (N));\n \n-      Intunit := Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit));\n+      Intunit := Is_Internal_Unit (Current_Sem_Unit);\n \n       if Sloc (U) /= No_Location then\n \n@@ -3537,7 +3523,7 @@ package body Sem_Ch10 is\n                   --  Exclude license check if withed unit is an internal unit.\n                   --  This situation arises e.g. with the GPL version of GNAT.\n \n-                  if Is_Internal_File_Name (Unit_File_Name (Withu)) then\n+                  if Is_Internal_Unit (Withu) then\n                      null;\n \n                      --  Otherwise check various cases\n@@ -5276,7 +5262,7 @@ package body Sem_Ch10 is\n       --  skipped for dummy units (for missing packages).\n \n       if Sloc (Uname) /= No_Location\n-        and then (not Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n+        and then (not Is_Internal_Unit (Current_Sem_Unit)\n                    or else Current_Sem_Unit = Main_Unit)\n       then\n          Check_Restricted_Unit"}, {"sha": "14314419345ddb66f692063de1bde650c17859f4", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -4109,8 +4109,7 @@ package body Sem_Ch12 is\n                --  predefined subprograms marked Inline_Always, to minimize\n                --  the use of the run-time library.\n \n-               elsif Is_Predefined_File_Name\n-                       (Unit_File_Name (Get_Source_Unit (Gen_Decl)))\n+               elsif In_Predefined_Unit (Gen_Decl)\n                  and then Configurable_Run_Time_Mode\n                  and then Nkind (Parent (N)) /= N_Compilation_Unit\n                then\n@@ -11210,8 +11209,7 @@ package body Sem_Ch12 is\n             --  interested in finding possible runtime errors.\n \n             if not CodePeer_Mode\n-              and then Is_Predefined_File_Name\n-                         (Unit_File_Name (Get_Source_Unit (Gen_Decl)))\n+              and then In_Predefined_Unit (Gen_Decl)\n             then\n                Analyze (Act_Body, Suppress => All_Checks);\n             else\n@@ -15473,10 +15471,7 @@ package body Sem_Ch12 is\n       --  to predefined units. Nothing needs to be done for non-internal units.\n       --  These are always analyzed in the current mode.\n \n-      if Is_Internal_File_Name\n-           (Fname              => Unit_File_Name (Get_Source_Unit (Gen_Unit)),\n-            Renamings_Included => True)\n-      then\n+      if In_Internal_Unit (Gen_Unit) then\n          Set_Opt_Config_Switches (True, Current_Sem_Unit = Main_Unit);\n \n          --  In Ada2012 we may want to enable assertions in an instance of a"}, {"sha": "bf92e7d7ad384b3af84a91d566a90cf79867be78", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -38,7 +38,6 @@ with Exp_Disp;  use Exp_Disp;\n with Exp_Dist;  use Exp_Dist;\n with Exp_Tss;   use Exp_Tss;\n with Exp_Util;  use Exp_Util;\n-with Fname;     use Fname;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n with Itypes;    use Itypes;\n@@ -3266,7 +3265,7 @@ package body Sem_Ch3 is\n \n       if Chars (Scope (Def_Id)) = Name_System\n         and then Chars (Def_Id) = Name_Address\n-        and then Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (N)))\n+        and then In_Predefined_Unit (N)\n       then\n          Set_Is_Descendant_Of_Address (Def_Id);\n          Set_Is_Descendant_Of_Address (Base_Type (Def_Id));"}, {"sha": "41e6ca5a10a881070da0d5da2cc4f1e3ff989d64", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -30,7 +30,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n@@ -3483,9 +3482,7 @@ package body Sem_Ch4 is\n                  and then\n                   (Etype (Actual) /= Universal_Integer\n                     or else not Is_Descendant_Of_Address (Etype (Formal))\n-                    or else\n-                      Is_Predefined_File_Name\n-                        (Unit_File_Name (Get_Source_Unit (N))))\n+                    or else In_Predefined_Unit (N))\n                then\n                   Next_Actual (Actual);\n                   Next_Formal (Formal);\n@@ -7351,8 +7348,7 @@ package body Sem_Ch4 is\n                --  variants of System, and it must be removed as well.\n \n                elsif Ada_Version >= Ada_2005\n-                 or else Is_Predefined_File_Name\n-                           (Unit_File_Name (Get_Source_Unit (It.Nam)))\n+                 or else In_Predefined_Unit (It.Nam)\n                then\n                   Remove_Interp (I);\n                   exit;"}, {"sha": "45a71aa6864e4a1b5c17f62c9eecc021aa6f30da", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -39,7 +39,6 @@ with Exp_Dbug;  use Exp_Dbug;\n with Exp_Disp;  use Exp_Disp;\n with Exp_Tss;   use Exp_Tss;\n with Exp_Util;  use Exp_Util;\n-with Fname;     use Fname;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n with Inline;    use Inline;\n@@ -3308,8 +3307,7 @@ package body Sem_Ch6 is\n \n          elsif Style_Check\n            and then Can_Override_Operator (Spec_Id)\n-           and then not Is_Predefined_File_Name\n-                          (Unit_File_Name (Get_Source_Unit (Spec_Id)))\n+           and then not In_Predefined_Unit (Spec_Id)\n          then\n             pragma Assert (Unit_Declaration_Node (Body_Id) = N);\n             Style.Missing_Overriding (N, Body_Id);\n@@ -6156,9 +6154,7 @@ package body Sem_Ch6 is\n            and then Chars (Overridden_Subp) = Name_Adjust\n            and then Is_Limited_Type (Etype (First_Formal (Subp)))\n            and then Present (Alias (Overridden_Subp))\n-           and then\n-             Is_Predefined_File_Name\n-               (Unit_File_Name (Get_Source_Unit (Alias (Overridden_Subp))))\n+           and then In_Predefined_Unit (Alias (Overridden_Subp))\n          then\n             Get_Name_String\n               (Unit_File_Name (Get_Source_Unit (Alias (Overridden_Subp))));\n@@ -6243,9 +6239,7 @@ package body Sem_Ch6 is\n          elsif not Error_Posted (Subp)\n            and then Style_Check\n            and then Can_Override_Operator (Subp)\n-           and then\n-             not Is_Predefined_File_Name\n-                   (Unit_File_Name (Get_Source_Unit (Subp)))\n+           and then not In_Predefined_Unit (Subp)\n          then\n             --  If style checks are enabled, indicate that the indicator is\n             --  missing. However, at the point of declaration, the type of"}, {"sha": "03a21c21e0bcf6b51e9d65e99caec6e669e220ab", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -31,7 +31,6 @@ with Errout;   use Errout;\n with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Ghost;    use Ghost;\n with Impunit;  use Impunit;\n@@ -3644,7 +3643,7 @@ package body Sem_Ch8 is\n       --  except that packages whose file name starts a-n are OK (these are\n       --  children of Ada.Numerics, which are never loaded by Rtsfind).\n \n-      if Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n+      if Is_Predefined_Unit (Current_Sem_Unit)\n         and then Get_Name_String\n                    (Unit_File_Name (Current_Sem_Unit)) (1 .. 3) /= \"a-n\"\n         and then Nkind (Unit (Cunit (Current_Sem_Unit))) =\n@@ -4968,7 +4967,7 @@ package body Sem_Ch8 is\n \n          --  Case of from internal file\n \n-         if Is_Internal_File_Name (Fname) then\n+         if In_Internal_Unit (E) then\n \n             --  Private part entities in internal files are never considered\n             --  to be known to the writer of normal application code.\n@@ -5551,17 +5550,14 @@ package body Sem_Ch8 is\n                Nvis_Messages;\n                goto Done;\n \n-            elsif Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n-            then\n+            elsif Is_Predefined_Unit (Current_Sem_Unit) then\n                --  A use-clause in the body of a system file creates conflict\n                --  with some entity in a user scope, while rtsfind is active.\n                --  Keep only the entity coming from another predefined unit.\n \n                E2 := E;\n                while Present (E2) loop\n-                  if Is_Predefined_File_Name\n-                       (Unit_File_Name (Get_Source_Unit (Sloc (E2))))\n-                  then\n+                  if In_Predefined_Unit (E2) then\n                      E := E2;\n                      goto Found;\n                   end if;"}, {"sha": "25e9cbd0a88bc5a91c92e4a24f98d68e518d8844", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,7 +32,6 @@ with Einfo;     use Einfo;\n with Errout;    use Errout;\n with Exp_Ch9;   use Exp_Ch9;\n with Elists;    use Elists;\n-with Fname;     use Fname;\n with Freeze;    use Freeze;\n with Layout;    use Layout;\n with Lib;       use Lib;\n@@ -2024,7 +2023,7 @@ package body Sem_Ch9 is\n       --  implemented.\n \n       if In_Private_Part (Current_Scope)\n-        and then Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n+        and then Is_Internal_Unit (Current_Sem_Unit)\n       then\n          Set_Has_Protected (T, False);\n       else"}, {"sha": "0588c61f8a2a2355aebe3f9bd1ae8c9ea63b9413", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -32,7 +32,6 @@ with Errout;   use Errout;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Expander; use Expander;\n-with Fname;    use Fname;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n with Namet;    use Namet;\n@@ -910,8 +909,7 @@ package body Sem_Elab is\n \n       --  Check cases of internal units\n \n-      Callee_Unit_Internal :=\n-        Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (E_Scope)));\n+      Callee_Unit_Internal := In_Internal_Unit (E_Scope);\n \n       --  Do not give a warning if the with'ed unit is internal and this is\n       --  the generic instantiation case (this saves a lot of hassle dealing\n@@ -924,8 +922,7 @@ package body Sem_Elab is\n       if C_Scope = Standard_Standard then\n          Caller_Unit_Internal := False;\n       else\n-         Caller_Unit_Internal :=\n-           Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (C_Scope)));\n+         Caller_Unit_Internal := In_Internal_Unit (C_Scope);\n       end if;\n \n       --  Do not give a warning if the with'ed unit is internal and the caller"}, {"sha": "ad8c388c616998bf2733e659fc5e0c9b93801fb0", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,7 +28,6 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n-with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Opt;      use Opt;\n@@ -339,8 +338,7 @@ package body Sem_Intr is\n \n       elsif not Comes_From_Source (E)\n         or else not Comes_From_Source (N)\n-        or else Is_Predefined_File_Name\n-                  (Unit_File_Name (Get_Source_Unit (N)))\n+        or else In_Predefined_Unit (N)\n       then\n          null;\n "}, {"sha": "091a800e872bef6ac4bb40013950ce1548a96840", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -35,7 +35,6 @@ with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Ghost;    use Ghost;\n with Inline;   use Inline;\n@@ -1895,9 +1894,7 @@ package body Sem_Res is\n       function Comes_From_Predefined_Lib_Unit (Nod : Node_Id) return Boolean is\n       begin\n          return\n-           Sloc (Nod) = Standard_Location\n-             or else Is_Predefined_File_Name\n-                       (Unit_File_Name (Get_Source_Unit (Sloc (Nod))));\n+           Sloc (Nod) = Standard_Location or else In_Predefined_Unit (Nod);\n       end Comes_From_Predefined_Lib_Unit;\n \n       --------------------"}, {"sha": "f1a414ff06233b70bb71edb622a06dcb54866b0e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -13482,9 +13482,7 @@ package body Sem_Util is\n                   begin\n                      if Present (Init)\n                        and then Comes_From_Source (Init)\n-                       and then not\n-                         Is_Predefined_File_Name\n-                           (File_Name (Get_Source_File_Index (Sloc (Init))))\n+                       and then not In_Predefined_Unit (Init)\n                      then\n                         return True;\n \n@@ -13771,8 +13769,7 @@ package body Sem_Util is\n          return\n            Nam_In (Chars (Iter_Typ), Name_Forward_Iterator,\n                                      Name_Reversible_Iterator)\n-             and then Is_Predefined_File_Name\n-                     (Unit_File_Name (Get_Source_Unit (Root_Type (Iter_Typ))));\n+             and then In_Predefined_Unit (Root_Type (Iter_Typ));\n       end Denotes_Iterator;\n \n       --  Local variables\n@@ -15069,8 +15066,7 @@ package body Sem_Util is\n    begin\n       if Is_Class_Wide_Type (Typ)\n         and then Chars (Root_Type (Typ)) = Name_Reversible_Iterator\n-        and then Is_Predefined_File_Name\n-                   (Unit_File_Name (Get_Source_Unit (Root_Type (Typ))))\n+        and then In_Predefined_Unit (Root_Type (Typ))\n       then\n          return True;\n \n@@ -15084,9 +15080,7 @@ package body Sem_Util is\n          while Present (Iface_Elmt) loop\n             Iface := Node (Iface_Elmt);\n             if Chars (Iface) = Name_Reversible_Iterator\n-              and then\n-                Is_Predefined_File_Name\n-                  (Unit_File_Name (Get_Source_Unit (Iface)))\n+              and then In_Predefined_Unit (Iface)\n             then\n                return True;\n             end if;\n@@ -15597,8 +15591,7 @@ package body Sem_Util is\n                return\n                  Chars (Par) = Name_Unchecked_Conversion\n                    and then Is_Intrinsic_Subprogram (Par)\n-                   and then Is_Predefined_File_Name\n-                              (Unit_File_Name (Get_Source_Unit (Par)));\n+                   and then In_Predefined_Unit (Par);\n             else\n                return\n                  Present (Alias (Id))\n@@ -20982,10 +20975,7 @@ package body Sem_Util is\n       then\n          return;\n \n-      elsif In_Inlined_Body\n-        and then Is_Predefined_File_Name\n-           (Unit_File_Name (Get_Source_Unit (Sloc (T))))\n-      then\n+      elsif In_Inlined_Body and then In_Predefined_Unit (T) then\n          Set_Needs_Debug_Info (T, False);\n       end if;\n "}, {"sha": "c181072b6ceb0e875d1f3115fc23d930cd634cf0", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -28,7 +28,6 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Code; use Exp_Code;\n-with Fname;    use Fname;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -1612,10 +1611,7 @@ package body Sem_Warn is\n                --  (these would be junk warnings for an applications program,\n                --  since they refer to problems in internal units).\n \n-               if GNAT_Mode\n-                 or else not Is_Internal_File_Name\n-                               (Unit_File_Name (Get_Source_Unit (E1)))\n-               then\n+               if GNAT_Mode or else not In_Internal_Unit (E1) then\n                   --  We do not immediately flag the error. This is because we\n                   --  have not expanded generic bodies yet, and they may have\n                   --  the missing reference. So instead we park the entity on a\n@@ -2383,7 +2379,7 @@ package body Sem_Warn is\n          --  clearly undesirable.\n \n          elsif Configurable_Run_Time_Mode\n-           and then Is_Predefined_File_Name (Unit_File_Name (Unit))\n+           and then Is_Predefined_Unit (Unit)\n          then\n             return;\n          end if;\n@@ -2414,9 +2410,7 @@ package body Sem_Warn is\n                   --  (these would be junk warnings for an application program,\n                   --  since they refer to problems in internal units).\n \n-                  if GNAT_Mode\n-                    or else not Is_Internal_File_Name (Unit_File_Name (Unit))\n-                  then\n+                  if GNAT_Mode or else not Is_Internal_Unit (Unit) then\n                      --  Here we definitely have a non-referenced unit. If it\n                      --  is the special call for a spec unit, then just set the\n                      --  flag to be read later.\n@@ -3302,8 +3296,7 @@ package body Sem_Warn is\n         --  Do not consider internal files to allow for various assertions and\n         --  safeguards within our runtime.\n \n-        and then not Is_Internal_File_Name\n-                       (Unit_File_Name (Get_Source_Unit (Op)))\n+        and then not In_Internal_Unit (Op)\n       then\n          Test_Comparison\n            (Op           => Op,"}, {"sha": "85908cb7f57ca15c1c398d81be672334ce8939c8", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,6 @@ with Casing;   use Casing;\n with Csets;    use Csets;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n-with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -4806,9 +4805,7 @@ package body Sprint is\n             Ent : constant Entity_Id := Entity (N);\n          begin\n             if not In_Extended_Main_Source_Unit (Ent)\n-              and then\n-                Is_Predefined_File_Name\n-                  (Unit_File_Name (Get_Source_Unit (Ent)))\n+              and then In_Predefined_Unit (Ent)\n             then\n                --  Run-time routine name, output name with a preceding dollar\n                --  making sure that we do not get a line split between them."}, {"sha": "013ea10d87d3eb6be3912cb9dbff05968f1b9130", "filename": "gcc/ada/warnsw.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fwarnsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fwarnsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.adb?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,6 +75,7 @@ package body Warnsw is\n       Warn_On_Overlap                     := Setting;\n       Warn_On_Overridden_Size             := Setting;\n       Warn_On_Parameter_Order             := Setting;\n+      Warn_On_Questionable_Layout         := Setting;\n       Warn_On_Questionable_Missing_Parens := Setting;\n       Warn_On_Record_Holes                := Setting;\n       Warn_On_Redundant_Constructs        := Setting;\n@@ -166,6 +167,8 @@ package body Warnsw is\n         W.Warn_On_Overridden_Size;\n       Warn_On_Parameter_Order             :=\n         W.Warn_On_Parameter_Order;\n+      Warn_On_Questionable_Layout         :=\n+        W.Warn_On_Questionable_Layout;\n       Warn_On_Questionable_Missing_Parens :=\n         W.Warn_On_Questionable_Missing_Parens;\n       Warn_On_Record_Holes                :=\n@@ -270,6 +273,8 @@ package body Warnsw is\n         Warn_On_Overridden_Size;\n       W.Warn_On_Parameter_Order             :=\n         Warn_On_Parameter_Order;\n+      W.Warn_On_Questionable_Layout         :=\n+        Warn_On_Questionable_Layout;\n       W.Warn_On_Questionable_Missing_Parens :=\n         Warn_On_Questionable_Missing_Parens;\n       W.Warn_On_Record_Holes                :=\n@@ -394,6 +399,12 @@ package body Warnsw is\n          when 'P' =>\n             Warn_On_Parameter_Order             := False;\n \n+         when 'q' =>\n+            Warn_On_Questionable_Layout         := True;\n+\n+         when 'Q' =>\n+            Warn_On_Questionable_Layout         := False;\n+\n          when 'r' =>\n             Warn_On_Object_Renames_Function     := True;\n "}, {"sha": "4afb8b16282a2f4973a37a2ca5b145517a8ff07b", "filename": "gcc/ada/warnsw.ads", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fwarnsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab31c0c31ecf1fa368974dc98196955cb2c25cd/gcc%2Fada%2Fwarnsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.ads?ref=8ab31c0c31ecf1fa368974dc98196955cb2c25cd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,16 +42,21 @@ package Warnsw is\n    --  Warn when tagged type public primitives are defined after its private\n    --  extensions.\n \n-   Warn_On_Record_Holes : Boolean := False;\n-   --  Warn when explicit record component clauses leave uncovered holes (gaps)\n-   --  in a record layout. Off by default, set by -gnatw.h (but not -gnatwa).\n-\n    Warn_On_Overridden_Size : Boolean := False;\n    --  Warn when explicit record component clause or array component_size\n    --  clause specifies a size that overrides a size for the type which was\n    --  set with an explicit size clause. Off by default, modified by use of\n    --  -gnatw.s/.S (but not -gnatwa).\n \n+   Warn_On_Questionable_Layout : Boolean := False;\n+   --  Warn when default layout of a record type is questionable for run-time\n+   --  efficiency reasons and would be improved by reordering the components.\n+   --  Off by default, modified by use of -gnatw.q/.Q (but not -gnatwa).\n+\n+   Warn_On_Record_Holes : Boolean := False;\n+   --  Warn when explicit record component clauses leave uncovered holes (gaps)\n+   --  in a record layout. Off by default, set by -gnatw.h (but not -gnatwa).\n+\n    Warn_On_Size_Alignment : Boolean := True;\n    --  Warn when explicit Size and Alignment clauses are given for a type, and\n    --  the size is not a multiple of the alignment. Off by default, modified\n@@ -104,6 +109,7 @@ package Warnsw is\n       Warn_On_Overlap                     : Boolean;\n       Warn_On_Overridden_Size             : Boolean;\n       Warn_On_Parameter_Order             : Boolean;\n+      Warn_On_Questionable_Layout         : Boolean;\n       Warn_On_Questionable_Missing_Parens : Boolean;\n       Warn_On_Record_Holes                : Boolean;\n       Warn_On_Redundant_Constructs        : Boolean;"}]}