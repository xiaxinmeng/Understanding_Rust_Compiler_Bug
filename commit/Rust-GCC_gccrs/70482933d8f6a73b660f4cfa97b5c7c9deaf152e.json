{"sha": "70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0ODI5MzNkOGY2YTczYjY2MGY0Y2ZhOTdiNWM3YzlkZWFmMTUyZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:08:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T14:08:34Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45954", "tree": {"sha": "133a71d6793865f2028234c0125afcfa4c7afc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/133a71d6793865f2028234c0125afcfa4c7afc76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/comments", "author": null, "committer": null, "parents": [{"sha": "d23b8f573b3dcbfc04d13387885059de809aec50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23b8f573b3dcbfc04d13387885059de809aec50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d23b8f573b3dcbfc04d13387885059de809aec50"}], "stats": {"total": 111795, "additions": 111795, "deletions": 0}, "files": [{"sha": "366d7c59f49c3a656e7e9b69808b48fbbfaa154a", "filename": "gcc/ada/back_end.adb", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,283 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            B A C K _ E N D                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.23 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;   use Atree;\n+with Debug;   use Debug;\n+with Elists;  use Elists;\n+with Lib;     use Lib;\n+with Osint;   use Osint;\n+with Opt;     use Opt;\n+with Osint;   use Osint;\n+with Namet;   use Namet;\n+with Nlists;  use Nlists;\n+with Stand;   use Stand;\n+with Sinput;  use Sinput;\n+with Stringt; use Stringt;\n+with Switch;  use Switch;\n+with System;  use System;\n+with Types;   use Types;\n+\n+package body Back_End is\n+\n+   --  Local subprograms\n+\n+   -------------------\n+   -- Call_Back_End --\n+   -------------------\n+\n+   procedure Call_Back_End (Mode : Back_End_Mode_Type) is\n+\n+      --  The File_Record type has a lot of components that are meaningless\n+      --  to the back end, so a new record is created here to contain the\n+      --  needed information for each file.\n+\n+      type Needed_File_Info_Type is record\n+         File_Name        : File_Name_Type;\n+         First_Sloc       : Source_Ptr;\n+         Last_Sloc        : Source_Ptr;\n+         Num_Source_Lines : Nat;\n+      end record;\n+\n+      File_Info_Array :\n+        array (Main_Unit .. Last_Unit) of Needed_File_Info_Type;\n+\n+      procedure gigi (\n+         gnat_root                     : Int;\n+         max_gnat_node                 : Int;\n+         number_name                   : Nat;\n+         nodes_ptr                     : Address;\n+\n+         next_node_ptr                 : Address;\n+         prev_node_ptr                 : Address;\n+         elists_ptr                    : Address;\n+         elmts_ptr                     : Address;\n+\n+         strings_ptr                   : Address;\n+         string_chars_ptr              : Address;\n+         list_headers_ptr              : Address;\n+         number_units                  : Int;\n+\n+         file_info_ptr                 : Address;\n+         gigi_standard_integer         : Entity_Id;\n+         gigi_standard_long_long_float : Entity_Id;\n+         gigi_standard_exception_type  : Entity_Id;\n+         gigi_operating_mode           : Back_End_Mode_Type);\n+\n+      pragma Import (C, gigi);\n+\n+      S : Source_File_Index;\n+\n+   begin\n+      --  Skip call if in -gnatdH mode\n+\n+      if Debug_Flag_HH then\n+         return;\n+      end if;\n+\n+      for J in Main_Unit .. Last_Unit loop\n+         S := Source_Index (J);\n+         File_Info_Array (J).File_Name        := File_Name (S);\n+         File_Info_Array (J).First_Sloc       := Source_Text (S)'First;\n+         File_Info_Array (J).Last_Sloc        := Source_Text (S)'Last;\n+         File_Info_Array (J).Num_Source_Lines := Num_Source_Lines (S);\n+      end loop;\n+\n+      gigi (\n+         gnat_root          => Int (Cunit (Main_Unit)),\n+         max_gnat_node      => Int (Last_Node_Id - First_Node_Id + 1),\n+         number_name        => Name_Entries_Count,\n+         nodes_ptr          => Nodes_Address,\n+\n+         next_node_ptr      => Next_Node_Address,\n+         prev_node_ptr      => Prev_Node_Address,\n+         elists_ptr         => Elists_Address,\n+         elmts_ptr          => Elmts_Address,\n+\n+         strings_ptr        => Strings_Address,\n+         string_chars_ptr   => String_Chars_Address,\n+         list_headers_ptr   => Lists_Address,\n+         number_units       => Num_Units,\n+\n+         file_info_ptr                 => File_Info_Array'Address,\n+         gigi_standard_integer         => Standard_Integer,\n+         gigi_standard_long_long_float => Standard_Long_Long_Float,\n+         gigi_standard_exception_type  => Standard_Exception_Type,\n+         gigi_operating_mode           => Mode);\n+   end Call_Back_End;\n+\n+   -----------------------------\n+   -- Scan_Compiler_Arguments --\n+   -----------------------------\n+\n+   procedure Scan_Compiler_Arguments is\n+\n+      Next_Arg : Pos := 1;\n+\n+      subtype Big_String is String (Positive);\n+      type BSP is access Big_String;\n+\n+      type Arg_Array is array (Nat) of BSP;\n+      type Arg_Array_Ptr is access Arg_Array;\n+\n+      --  Import flag_stack_check from toplev.c.\n+\n+      flag_stack_check : Int;\n+      pragma Import (C, flag_stack_check); -- Import from toplev.c\n+\n+      save_argc : Nat;\n+      pragma Import (C, save_argc); -- Import from toplev.c\n+\n+      save_argv : Arg_Array_Ptr;\n+      pragma Import (C, save_argv); -- Import from toplev.c\n+\n+      Output_File_Name_Seen : Boolean := False;\n+      --  Set to True after having scanned the file_name for\n+      --  switch \"-gnatO file_name\"\n+\n+      --  Local functions\n+\n+      function Len_Arg (Arg : Pos) return Nat;\n+      --  Determine length of argument number Arg on the original\n+      --  command line from gnat1\n+\n+      procedure Scan_Back_End_Switches (Switch_Chars : String);\n+      --  Procedure to scan out switches stored in Switch_Chars. The first\n+      --  character is known to be a valid switch character, and there are no\n+      --  blanks or other switch terminator characters in the string, so the\n+      --  entire string should consist of valid switch characters, except that\n+      --  an optional terminating NUL character is allowed.\n+      --\n+      --  Back end switches have already been checked and processed by GCC\n+      --  in toplev.c, so no errors can occur and control will always return.\n+      --  The switches must still be scanned to skip the arguments of the\n+      --  \"-o\" or the (undocumented) \"-dumpbase\" switch, by incrementing\n+      --  the Next_Arg variable. The \"-dumpbase\" switch is used to set the\n+      --  basename for GCC dumpfiles.\n+\n+      -------------\n+      -- Len_Arg --\n+      -------------\n+\n+      function Len_Arg (Arg : Pos) return Nat is\n+      begin\n+         for J in 1 .. Nat'Last loop\n+            if save_argv (Arg).all (Natural (J)) = ASCII.NUL then\n+               return J - 1;\n+            end if;\n+         end loop;\n+\n+         raise Program_Error;\n+      end Len_Arg;\n+\n+      ----------------------------\n+      -- Scan_Back_End_Switches --\n+      ----------------------------\n+\n+      procedure Scan_Back_End_Switches (Switch_Chars : String) is\n+         First : constant Positive := Switch_Chars'First + 1;\n+         Last  : Natural := Switch_Chars'Last;\n+\n+      begin\n+         if Last >= First\n+           and then Switch_Chars (Last) = ASCII.NUL\n+         then\n+            Last := Last - 1;\n+         end if;\n+\n+         if Switch_Chars (First .. Last) = \"o\"\n+            or else Switch_Chars (First .. Last) = \"dumpbase\"\n+\n+         then\n+            Next_Arg := Next_Arg + 1;\n+\n+         elsif Switch_Chars (First .. Last) = \"quiet\" then\n+            null; -- do not record this switch\n+\n+         else\n+            --  Store any other GCC switches\n+            Store_Compilation_Switch (Switch_Chars);\n+         end if;\n+      end Scan_Back_End_Switches;\n+\n+   --  Start of processing for Scan_Compiler_Arguments\n+\n+   begin\n+      --  Acquire stack checking mode directly from GCC\n+\n+      Opt.Stack_Checking_Enabled := (flag_stack_check /= 0);\n+\n+      --  Loop through command line arguments, storing them for later access\n+\n+      while Next_Arg < save_argc loop\n+\n+         Look_At_Arg : declare\n+            Argv_Ptr  : constant BSP := save_argv (Next_Arg);\n+            Argv_Len  : constant Nat := Len_Arg (Next_Arg);\n+            Argv      : String := Argv_Ptr (1 .. Natural (Argv_Len));\n+\n+         begin\n+            --  If the previous switch has set the Output_File_Name_Present\n+            --  flag (that is we have seen a -gnatO), then the next argument\n+            --  is the name of the output object file.\n+\n+            if Output_File_Name_Present\n+              and then not Output_File_Name_Seen\n+            then\n+               if Is_Switch (Argv) then\n+                  Fail (\"Object file name missing after -gnatO\");\n+\n+               else\n+                  Set_Output_Object_File_Name (Argv);\n+                  Output_File_Name_Seen := True;\n+               end if;\n+\n+            elsif not Is_Switch (Argv) then -- must be a file name\n+               Add_File (Argv);\n+\n+            elsif Is_Front_End_Switch (Argv) then\n+               Scan_Front_End_Switches (Argv);\n+\n+               --  ??? Should be done in Scan_Front_End_Switches, after\n+               --      Switch is splitted in compiler/make/bind units\n+\n+               if Argv (2) /= 'I' then\n+                  Store_Compilation_Switch (Argv);\n+               end if;\n+\n+            --  All non-front-end switches are back-end switches\n+\n+            else\n+               Scan_Back_End_Switches (Argv);\n+            end if;\n+         end Look_At_Arg;\n+\n+         Next_Arg := Next_Arg + 1;\n+      end loop;\n+   end Scan_Compiler_Arguments;\n+\n+end Back_End;"}, {"sha": "60da9aebdd5ddfece79bad4c5543f076af291a46", "filename": "gcc/ada/back_end.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fback_end.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fback_end.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             B A C K _ E N D                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Call the back end with all the information needed. Also contains other\n+--  back-end specific interfaces required by the front end.\n+\n+package Back_End is\n+\n+   type Back_End_Mode_Type is (\n+      Generate_Object,\n+      --  Full back end operation with object file generation\n+\n+      Declarations_Only,\n+      --  Partial back end operation with no object file generation. In this\n+      --  mode the only useful action performed by gigi is to process all\n+      --  declarations issuing any error messages (in partcicular those to\n+      --  do with rep clauses), and to back annotate representation info.\n+\n+      Skip);\n+      --  Back end call is skipped (syntax only, or errors found)\n+\n+   pragma Convention (C, Back_End_Mode_Type);\n+   for Back_End_Mode_Type use (0, 1, 2);\n+\n+   procedure Call_Back_End (Mode : Back_End_Mode_Type);\n+   --  Call back end, i.e. make call to driver traversing the tree and\n+   --  outputting code. This call is made with all tables locked.\n+   --  The back end is responsible for unlocking any tables it may need\n+   --  to change, and locking them again before returning.\n+\n+   procedure Scan_Compiler_Arguments;\n+   --  Acquires command-line parameters passed to the compiler and processes\n+   --  them. Calls Scan_Front_End_Switches for any front-end switches\n+   --  encountered.\n+   --\n+   --  The processing of arguments is private to the back end, since\n+   --  the way of acquiring the arguments as well as the set of allowable\n+   --  back end switches is different depending on the particular back end\n+   --  being used.\n+   --\n+   --  Any processed switches that influence the result of a compilation\n+   --  must be added to the Compilation_Arguments table.\n+\n+end Back_End;"}, {"sha": "1d38f96153f061971e6363b92bff72c442435d08", "filename": "gcc/ada/bcheck.adb", "status": "added", "additions": 694, "deletions": 0, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,694 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               B C H E C K                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.39 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with ALI;      use ALI;\n+with ALI.Util; use ALI.Util;\n+with Binderr;  use Binderr;\n+with Butil;    use Butil;\n+with Casing;   use Casing;\n+with Debug;    use Debug;\n+with Fname;    use Fname;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Osint;\n+with Output;   use Output;\n+with Rident;   use Rident;\n+with Types;    use Types;\n+\n+package body Bcheck is\n+\n+   --  Local subprograms\n+\n+   --  The following checking subprograms make up the parts\n+   --  of the configuration consistency check.\n+\n+   procedure Check_Consistent_Dynamic_Elaboration_Checking;\n+   procedure Check_Consistent_Floating_Point_Format;\n+   procedure Check_Consistent_Locking_Policy;\n+   procedure Check_Consistent_Normalize_Scalars;\n+   procedure Check_Consistent_Queuing_Policy;\n+   procedure Check_Consistent_Zero_Cost_Exception_Handling;\n+   procedure Check_Partition_Restrictions;\n+\n+   procedure Consistency_Error_Msg (Msg : String);\n+   --  Produce an error or a warning message, depending on whether\n+   --  an inconsistent configuration is permitted or not.\n+\n+   ------------------------------------\n+   -- Check_Consistent_Configuration --\n+   ------------------------------------\n+\n+   procedure Check_Configuration_Consistency is\n+   begin\n+      if Float_Format_Specified /= ' ' then\n+         Check_Consistent_Floating_Point_Format;\n+      end if;\n+\n+      if Queuing_Policy_Specified /= ' ' then\n+         Check_Consistent_Queuing_Policy;\n+      end if;\n+\n+      if Locking_Policy_Specified /= ' ' then\n+         Check_Consistent_Locking_Policy;\n+      end if;\n+\n+      if Zero_Cost_Exceptions_Specified then\n+         Check_Consistent_Zero_Cost_Exception_Handling;\n+      end if;\n+\n+      Check_Consistent_Normalize_Scalars;\n+      Check_Consistent_Dynamic_Elaboration_Checking;\n+\n+      Check_Partition_Restrictions;\n+   end Check_Configuration_Consistency;\n+\n+   ---------------------------------------------------\n+   -- Check_Consistent_Dynamic_Elaboration_Checking --\n+   ---------------------------------------------------\n+\n+   --  The rule here is that if a unit has dynamic elaboration checks,\n+   --  then any unit it withs must meeting one of the following criteria:\n+\n+   --    1. There is a pragma Elaborate_All for the with'ed unit\n+   --    2. The with'ed unit was compiled with dynamic elaboration checks\n+   --    3. The with'ed unit has pragma Preelaborate or Pure\n+   --    4. It is an internal GNAT unit (including children of GNAT)\n+\n+   procedure Check_Consistent_Dynamic_Elaboration_Checking is\n+   begin\n+      if Dynamic_Elaboration_Checks_Specified then\n+         for U in First_Unit_Entry .. Units.Last loop\n+            declare\n+               UR : Unit_Record renames Units.Table (U);\n+\n+            begin\n+               if UR.Dynamic_Elab then\n+                  for W in UR.First_With .. UR.Last_With loop\n+                     declare\n+                        WR : With_Record renames Withs.Table (W);\n+\n+                     begin\n+                        if Get_Name_Table_Info (WR.Uname) /= 0 then\n+                           declare\n+                              WU : Unit_Record renames\n+                                     Units.Table\n+                                       (Unit_Id\n+                                         (Get_Name_Table_Info (WR.Uname)));\n+\n+                           begin\n+                              --  Case 1. Elaborate_All for with'ed unit\n+\n+                              if WR.Elaborate_All then\n+                                 null;\n+\n+                              --  Case 2. With'ed unit has dynamic elab checks\n+\n+                              elsif WU.Dynamic_Elab then\n+                                 null;\n+\n+                              --  Case 3. With'ed unit is Preelaborate or Pure\n+\n+                              elsif WU.Preelab or WU.Pure then\n+                                 null;\n+\n+                              --  Case 4. With'ed unit is internal file\n+\n+                              elsif Is_Internal_File_Name (WU.Sfile) then\n+                                 null;\n+\n+                              --  Issue warning, not one of the safe cases\n+\n+                              else\n+                                 Error_Msg_Name_1 := UR.Sfile;\n+                                 Error_Msg\n+                                   (\"?% has dynamic elaboration checks \" &\n+                                                                 \"and with's\");\n+\n+                                 Error_Msg_Name_1 := WU.Sfile;\n+                                 Error_Msg\n+                                   (\"?  % which has static elaboration \" &\n+                                                                     \"checks\");\n+\n+                                 Warnings_Detected := Warnings_Detected - 1;\n+                              end if;\n+                           end;\n+                        end if;\n+                     end;\n+                  end loop;\n+               end if;\n+            end;\n+         end loop;\n+      end if;\n+   end Check_Consistent_Dynamic_Elaboration_Checking;\n+\n+   --------------------------------------------\n+   -- Check_Consistent_Floating_Point_Format --\n+   --------------------------------------------\n+\n+   --  The rule is that all files must be compiled with the same setting\n+   --  for the floating-point format.\n+\n+   procedure Check_Consistent_Floating_Point_Format is\n+   begin\n+      --  First search for a unit specifying a floating-point format and then\n+      --  check all remaining units against it.\n+\n+      Find_Format : for A1 in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A1).Float_Format /= ' ' then\n+            Check_Format : declare\n+               Format : constant Character := ALIs.Table (A1).Float_Format;\n+            begin\n+               for A2 in A1 + 1 .. ALIs.Last loop\n+                  if ALIs.Table (A2).Float_Format /= Format then\n+                     Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n+                     Error_Msg_Name_2 := ALIs.Table (A2).Sfile;\n+\n+                     Consistency_Error_Msg\n+                       (\"% and % compiled with different \" &\n+                        \"floating-point representations\");\n+                     exit Find_Format;\n+                  end if;\n+               end loop;\n+            end Check_Format;\n+\n+            exit Find_Format;\n+         end if;\n+      end loop Find_Format;\n+   end Check_Consistent_Floating_Point_Format;\n+\n+   -------------------------------------\n+   -- Check_Consistent_Locking_Policy --\n+   -------------------------------------\n+\n+   --  The rule is that all files for which the locking policy is\n+   --  significant must be compiled with the same setting.\n+\n+   procedure Check_Consistent_Locking_Policy is\n+   begin\n+      --  First search for a unit specifying a policy and then\n+      --  check all remaining units against it.\n+\n+      Find_Policy : for A1 in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A1).Locking_Policy /= ' ' then\n+            Check_Policy : declare\n+               Policy : constant Character := ALIs.Table (A1).Locking_Policy;\n+\n+            begin\n+               for A2 in A1 + 1 .. ALIs.Last loop\n+                  if ALIs.Table (A2).Locking_Policy /= ' ' and\n+                     ALIs.Table (A2).Locking_Policy /= Policy\n+                  then\n+                     Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n+                     Error_Msg_Name_2 := ALIs.Table (A2).Sfile;\n+\n+                     Consistency_Error_Msg\n+                       (\"% and % compiled with different locking policies\");\n+                     exit Find_Policy;\n+                  end if;\n+               end loop;\n+            end Check_Policy;\n+\n+            exit Find_Policy;\n+         end if;\n+      end loop Find_Policy;\n+   end Check_Consistent_Locking_Policy;\n+\n+   ----------------------------------------\n+   -- Check_Consistent_Normalize_Scalars --\n+   ----------------------------------------\n+\n+   --  The rule is that if any unit is compiled with Normalized_Scalars,\n+   --  then all other units in the partition must also be compiled with\n+   --  Normalized_Scalars in effect.\n+\n+   --  There is some issue as to whether this consistency check is\n+   --  desirable, it is certainly required at the moment by the RM.\n+   --  We should keep a watch on the ARG and HRG deliberations here.\n+   --  GNAT no longer depends on this consistency (it used to do so,\n+   --  but that has been corrected in the latest version, since the\n+   --  Initialize_Scalars pragma does not require consistency.\n+\n+   procedure Check_Consistent_Normalize_Scalars is\n+   begin\n+      if Normalize_Scalars_Specified and No_Normalize_Scalars_Specified then\n+         Consistency_Error_Msg\n+              (\"some but not all files compiled with Normalize_Scalars\");\n+\n+         Write_Eol;\n+         Write_Str (\"files compiled with Normalize_Scalars\");\n+         Write_Eol;\n+\n+         for A1 in ALIs.First .. ALIs.Last loop\n+            if ALIs.Table (A1).Normalize_Scalars then\n+               Write_Str (\"  \");\n+               Write_Name (ALIs.Table (A1).Sfile);\n+               Write_Eol;\n+            end if;\n+         end loop;\n+\n+         Write_Eol;\n+         Write_Str (\"files compiled without Normalize_Scalars\");\n+         Write_Eol;\n+\n+         for A1 in ALIs.First .. ALIs.Last loop\n+            if not ALIs.Table (A1).Normalize_Scalars then\n+               Write_Str (\"  \");\n+               Write_Name (ALIs.Table (A1).Sfile);\n+               Write_Eol;\n+            end if;\n+         end loop;\n+      end if;\n+   end Check_Consistent_Normalize_Scalars;\n+\n+   -------------------------------------\n+   -- Check_Consistent_Queuing_Policy --\n+   -------------------------------------\n+\n+   --  The rule is that all files for which the queuing policy is\n+   --  significant must be compiled with the same setting.\n+\n+   procedure Check_Consistent_Queuing_Policy is\n+   begin\n+      --  First search for a unit specifying a policy and then\n+      --  check all remaining units against it.\n+\n+      Find_Policy : for A1 in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A1).Queuing_Policy /= ' ' then\n+            Check_Policy : declare\n+               Policy : constant Character := ALIs.Table (A1).Queuing_Policy;\n+            begin\n+               for A2 in A1 + 1 .. ALIs.Last loop\n+                  if ALIs.Table (A2).Queuing_Policy /= ' '\n+                       and then\n+                     ALIs.Table (A2).Queuing_Policy /= Policy\n+                  then\n+                     Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n+                     Error_Msg_Name_2 := ALIs.Table (A2).Sfile;\n+\n+                     Consistency_Error_Msg\n+                       (\"% and % compiled with different queuing policies\");\n+                     exit Find_Policy;\n+                  end if;\n+               end loop;\n+            end Check_Policy;\n+\n+            exit Find_Policy;\n+         end if;\n+      end loop Find_Policy;\n+   end Check_Consistent_Queuing_Policy;\n+\n+   ---------------------------------------------------\n+   -- Check_Consistent_Zero_Cost_Exception_Handling --\n+   ---------------------------------------------------\n+\n+   --  Check consistent zero cost exception handling. The rule is that\n+   --  all units must have the same exception handling mechanism.\n+\n+   procedure Check_Consistent_Zero_Cost_Exception_Handling is\n+   begin\n+      Check_Mechanism : for A1 in ALIs.First + 1 .. ALIs.Last loop\n+         if ALIs.Table (A1).Zero_Cost_Exceptions /=\n+            ALIs.Table (ALIs.First).Zero_Cost_Exceptions\n+\n+         then\n+            Error_Msg_Name_1 := ALIs.Table (A1).Sfile;\n+            Error_Msg_Name_2 := ALIs.Table (ALIs.First).Sfile;\n+\n+            Consistency_Error_Msg (\"% and % compiled with different \"\n+                                            & \"exception handling mechanisms\");\n+         end if;\n+      end loop Check_Mechanism;\n+   end Check_Consistent_Zero_Cost_Exception_Handling;\n+\n+   ----------------------------------\n+   -- Check_Partition_Restrictions --\n+   ----------------------------------\n+\n+   --  The rule is that if a restriction is specified in any unit,\n+   --  then all units must obey the restriction. The check applies\n+   --  only to restrictions which require partition wide consistency,\n+   --  and not to internal units.\n+\n+   --  The check is done in two steps. First for every restriction\n+   --  a unit specifying that restriction is found, if any.\n+   --  Second, all units are verified against the specified restrictions.\n+\n+   procedure Check_Partition_Restrictions is\n+\n+      R : array (Partition_Restrictions) of ALI_Id := (others => No_ALI_Id);\n+      --  Record the first unit specifying each partition restriction\n+\n+      V : array (Partition_Restrictions) of ALI_Id := (others => No_ALI_Id);\n+      --  Record the last unit violating each partition restriction\n+\n+      procedure List_Applicable_Restrictions;\n+      --  Output a list of restrictions that may be applied to the partition,\n+      --  without causing bind errors.\n+\n+      ----------------------------------\n+      -- List_Applicable_Restrictions --\n+      ----------------------------------\n+\n+      procedure List_Applicable_Restrictions is\n+         Additional_Restrictions_Listed : Boolean := False;\n+\n+      begin\n+         --  List any restrictions which were not violated and not specified\n+\n+         for J in Partition_Restrictions loop\n+            if V (J) = No_ALI_Id and R (J) = No_ALI_Id then\n+               if not Additional_Restrictions_Listed then\n+                  Write_Str (\"The following additional restrictions may be\" &\n+                             \" applied to this partition:\");\n+                  Write_Eol;\n+                  Additional_Restrictions_Listed := True;\n+               end if;\n+\n+               Write_Str (\"pragma Restrictions (\");\n+\n+               declare\n+                  S : constant String := Restriction_Id'Image (J);\n+\n+               begin\n+                  Name_Len := S'Length;\n+                  Name_Buffer (1 .. Name_Len) := S;\n+               end;\n+\n+               Set_Casing (Mixed_Case);\n+               Write_Str (Name_Buffer (1 .. Name_Len));\n+               Write_Str (\");\");\n+               Write_Eol;\n+            end if;\n+         end loop;\n+      end List_Applicable_Restrictions;\n+\n+   --  Start of processing for Check_Partition_Restrictions\n+\n+   begin\n+      Find_Restrictions :\n+      for A in ALIs.First .. ALIs.Last loop\n+         for J in Partition_Restrictions loop\n+            if R (J) = No_ALI_Id and ALIs.Table (A).Restrictions (J) = 'r' then\n+               R (J) := A;\n+            end if;\n+         end loop;\n+      end loop Find_Restrictions;\n+\n+      Find_Violations :\n+      for A in ALIs.First .. ALIs.Last loop\n+         for J in Partition_Restrictions loop\n+            if ALIs.Table (A).Restrictions (J) = 'v'\n+               and then not Is_Internal_File_Name (ALIs.Table (A).Sfile)\n+            then\n+               --  A violation of a restriction was found, so check whether\n+               --  that restriction was actually in effect. If so, give an\n+               --  error message.\n+\n+               --  Note that all such violations found are reported.\n+\n+               V (J) := A;\n+\n+               if R (J) /= No_ALI_Id then\n+                  Report_Violated_Restriction : declare\n+                     M1 : constant String := \"% has Restriction (\";\n+                     S  : constant String := Restriction_Id'Image (J);\n+                     M2 : String (1 .. M1'Length + S'Length + 1);\n+\n+                  begin\n+                     Name_Buffer (1 .. S'Length) := S;\n+                     Name_Len := S'Length;\n+                     Set_Casing\n+                       (Units.Table (ALIs.Table (R (J)).First_Unit).Icasing);\n+\n+                     M2 (M1'Range) := M1;\n+                     M2 (M1'Length + 1 .. M2'Last - 1) :=\n+                                                   Name_Buffer (1 .. S'Length);\n+                     M2 (M2'Last) := ')';\n+\n+                     Error_Msg_Name_1 := ALIs.Table (R (J)).Sfile;\n+                     Consistency_Error_Msg (M2);\n+                     Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n+                     Consistency_Error_Msg\n+                       (\"but file % violates this restriction\");\n+                  end Report_Violated_Restriction;\n+               end if;\n+            end if;\n+         end loop;\n+      end loop Find_Violations;\n+\n+      if Debug_Flag_R then\n+         List_Applicable_Restrictions;\n+      end if;\n+   end Check_Partition_Restrictions;\n+\n+   -----------------------\n+   -- Check_Consistency --\n+   -----------------------\n+\n+   procedure Check_Consistency is\n+      Src : Source_Id;\n+      --  Source file Id for this Sdep entry\n+\n+   begin\n+      --  First, we go through the source table to see if there are any cases\n+      --  in which we should go after source files and compute checksums of\n+      --  the source files. We need to do this for any file for which we have\n+      --  mismatching time stamps and (so far) matching checksums.\n+\n+      for S in Source.First .. Source.Last loop\n+\n+         --  If all time stamps for a file match, then there is nothing to\n+         --  do, since we will not be checking checksums in that case anyway\n+\n+         if Source.Table (S).All_Timestamps_Match then\n+            null;\n+\n+         --  If we did not find the source file, then we can't compute its\n+         --  checksum anyway. Note that when we have a time stamp mismatch,\n+         --  we try to find the source file unconditionally (i.e. if\n+         --  Check_Source_Files is False).\n+\n+         elsif not Source.Table (S).Source_Found then\n+            null;\n+\n+         --  If we already have non-matching or missing checksums, then no\n+         --  need to try going after source file, since we won't trust the\n+         --  checksums in any case.\n+\n+         elsif not Source.Table (S).All_Checksums_Match then\n+            null;\n+\n+         --  Now we have the case where we have time stamp mismatches, and\n+         --  the source file is around, but so far all checksums match. This\n+         --  is the case where we need to compute the checksum from the source\n+         --  file, since otherwise we would ignore the time stamp mismatches,\n+         --  and that is wrong if the checksum of the source does not agree\n+         --  with the checksums in the ALI files.\n+\n+         elsif Check_Source_Files then\n+            if Source.Table (S).Checksum /=\n+               Get_File_Checksum (Source.Table (S).Sfile)\n+            then\n+               Source.Table (S).All_Checksums_Match := False;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Loop through ALI files\n+\n+      ALIs_Loop : for A in ALIs.First .. ALIs.Last loop\n+\n+         --  Loop through Sdep entries in one ALI file\n+\n+         Sdep_Loop : for D in\n+           ALIs.Table (A).First_Sdep .. ALIs.Table (A).Last_Sdep\n+         loop\n+            Src := Source_Id (Get_Name_Table_Info (Sdep.Table (D).Sfile));\n+\n+            --  If the time stamps match, or all checksums match, then we\n+            --  are OK, otherwise we have a definite error.\n+\n+            if Sdep.Table (D).Stamp /= Source.Table (Src).Stamp\n+              and then not Source.Table (Src).All_Checksums_Match\n+            then\n+               Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n+               Error_Msg_Name_2 := Sdep.Table (D).Sfile;\n+\n+               --  Two styles of message, depending on whether or not\n+               --  the updated file is the one that must be recompiled\n+\n+               if Error_Msg_Name_1 = Error_Msg_Name_2 then\n+                  if Tolerate_Consistency_Errors then\n+                     Error_Msg\n+                        (\"?% has been modified and should be recompiled\");\n+                  else\n+                     Error_Msg\n+                       (\"% has been modified and must be recompiled\");\n+                  end if;\n+\n+               else\n+                  if Tolerate_Consistency_Errors then\n+                     Error_Msg\n+                       (\"?% should be recompiled (% has been modified)\");\n+\n+                  else\n+                     Error_Msg (\"% must be recompiled (% has been modified)\");\n+                  end if;\n+               end if;\n+\n+               if (not Tolerate_Consistency_Errors) and Verbose_Mode then\n+                  declare\n+                     Msg : constant String := \"file % has time stamp \";\n+                     Buf : String (1 .. Msg'Length + Time_Stamp_Length);\n+\n+                  begin\n+                     Buf (1 .. Msg'Length) := Msg;\n+                     Buf (Msg'Length + 1 .. Buf'Length) :=\n+                       String (Source.Table (Src).Stamp);\n+                     Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n+                     Error_Msg (Buf);\n+\n+                     Buf (Msg'Length + 1 .. Buf'Length) :=\n+                       String (Sdep.Table (D).Stamp);\n+                     Error_Msg_Name_1 := Sdep.Table (D).Sfile;\n+                     Error_Msg (Buf);\n+                  end;\n+               end if;\n+\n+               --  Exit from the loop through Sdep entries once we find one\n+               --  that does not match.\n+\n+               exit Sdep_Loop;\n+            end if;\n+\n+         end loop Sdep_Loop;\n+      end loop ALIs_Loop;\n+   end Check_Consistency;\n+\n+   -------------------------------\n+   -- Check_Duplicated_Subunits --\n+   -------------------------------\n+\n+   procedure Check_Duplicated_Subunits is\n+   begin\n+      for J in Sdep.First .. Sdep.Last loop\n+         if Sdep.Table (J).Subunit_Name /= No_Name then\n+            Get_Decoded_Name_String (Sdep.Table (J).Subunit_Name);\n+            Name_Len := Name_Len + 2;\n+            Name_Buffer (Name_Len - 1) := '%';\n+\n+            --  See if there is a body or spec with the same name\n+\n+            for K in Boolean loop\n+               if K then\n+                  Name_Buffer (Name_Len) := 'b';\n+\n+               else\n+                  Name_Buffer (Name_Len) := 's';\n+               end if;\n+\n+               declare\n+                  Info : constant Int := Get_Name_Table_Info (Name_Find);\n+\n+               begin\n+                  if Info /= 0 then\n+                     Set_Standard_Error;\n+                     Write_Str (\"error: subunit \"\"\");\n+                     Write_Name_Decoded (Sdep.Table (J).Subunit_Name);\n+                     Write_Str (\"\"\" in file \"\"\");\n+                     Write_Name_Decoded (Sdep.Table (J).Sfile);\n+                     Write_Char ('\"');\n+                     Write_Eol;\n+                     Write_Str (\"       has same name as unit \"\"\");\n+                     Write_Unit_Name (Units.Table (Unit_Id (Info)).Uname);\n+                     Write_Str (\"\"\" found in file \"\"\");\n+                     Write_Name_Decoded (Units.Table (Unit_Id (Info)).Sfile);\n+                     Write_Char ('\"');\n+                     Write_Eol;\n+                     Write_Str (\"       this is not allowed within a single \"\n+                                & \"partition (RM 10.2(19))\");\n+                     Write_Eol;\n+                     Osint.Exit_Program (Osint.E_Fatal);\n+                  end if;\n+               end;\n+            end loop;\n+         end if;\n+      end loop;\n+   end Check_Duplicated_Subunits;\n+\n+   --------------------\n+   -- Check_Versions --\n+   --------------------\n+\n+   procedure Check_Versions is\n+      VL : constant Natural := ALIs.Table (ALIs.First).Ver_Len;\n+\n+   begin\n+      for A in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A).Ver_Len /= VL\n+           or else ALIs.Table (A).Ver          (1 .. VL) /=\n+                   ALIs.Table (ALIs.First).Ver (1 .. VL)\n+         then\n+            Error_Msg_Name_1 := ALIs.Table (A).Sfile;\n+            Error_Msg_Name_2 := ALIs.Table (ALIs.First).Sfile;\n+\n+            Consistency_Error_Msg\n+               (\"% and % compiled with different GNAT versions\");\n+         end if;\n+      end loop;\n+   end Check_Versions;\n+\n+   ---------------------------\n+   -- Consistency_Error_Msg --\n+   ---------------------------\n+\n+   procedure Consistency_Error_Msg (Msg : String) is\n+   begin\n+      if Tolerate_Consistency_Errors then\n+\n+         --  If consistency errors are tolerated,\n+         --  output the message as a warning.\n+\n+         declare\n+            Warning_Msg : String (1 .. Msg'Length + 1);\n+\n+         begin\n+            Warning_Msg (1) := '?';\n+            Warning_Msg (2 .. Warning_Msg'Last) := Msg;\n+\n+            Error_Msg (Warning_Msg);\n+         end;\n+\n+      --  Otherwise the consistency error is a true error\n+\n+      else\n+         Error_Msg (Msg);\n+      end if;\n+   end Consistency_Error_Msg;\n+\n+end Bcheck;"}, {"sha": "488580ce66dd9bb6f30ee4e40cd0419eb7cc5565", "filename": "gcc/ada/bcheck.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbcheck.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbcheck.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               B C H E C K                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Bcheck is\n+\n+--  This package contains the routines to perform binder consistency checks\n+\n+   procedure Check_Duplicated_Subunits;\n+   --  Check that no subunit names duplicate names of other packages in\n+   --  the partition (check required by RM 10.2(19)).\n+\n+   procedure Check_Versions;\n+   --  Check correct library and standard versions used\n+\n+   procedure Check_Consistency;\n+   --  This procedure performs checks that the ALI files are consistent\n+   --  with the corresponding source files and with one another. At the\n+   --  time this is called, the Source table has been completely built and\n+   --  contains either the time stamp from the actual source file if the\n+   --  Check_Source_Files mode is set, or the latest stamp found in any of\n+   --  the ALI files in the program.\n+\n+   procedure Check_Configuration_Consistency;\n+   --  This procedure performs a similar check that configuration pragma\n+   --  set items that are required to be consistent are in fact consistent\n+\n+end Bcheck;"}, {"sha": "bce3507a8930d80ded681d38253f9f7ec2e59ea7", "filename": "gcc/ada/binde.adb", "status": "added", "additions": 1296, "deletions": 0, "changes": 1296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,1296 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                B I N D E                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.41 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Binderr; use Binderr;\n+with Butil;   use Butil;\n+with Debug;   use Debug;\n+with Fname;   use Fname;\n+with Namet;   use Namet;\n+with Opt;     use Opt;\n+with Output;  use Output;\n+\n+package body Binde is\n+\n+   --  The following data structures are used to represent the graph that is\n+   --  used to determine the elaboration order (using a topological sort).\n+\n+   --  The following structures are used to record successors. If A is a\n+   --  successor of B in this table, it means that A must be elaborated\n+   --  before B is elaborated.\n+\n+   type Successor_Id is new Nat;\n+   --  Identification of single successor entry\n+\n+   No_Successor : constant Successor_Id := 0;\n+   --  Used to indicate end of list of successors\n+\n+   type Elab_All_Id is new Nat;\n+   --  Identification of Elab_All entry link\n+\n+   No_Elab_All_Link : constant Elab_All_Id := 0;\n+   --  Used to indicate end of list\n+\n+   --  Succ_Reason indicates the reason for a particular elaboration link\n+\n+   type Succ_Reason is\n+     (Withed,\n+      --  After directly with's Before, so the spec of Before must be\n+      --  elaborated before After is elaborated.\n+\n+      Elab,\n+      --  After directly mentions Before in a pragma Elaborate, so the\n+      --  body of Before must be elaborate before After is elaborated.\n+\n+      Elab_All,\n+      --  After either mentions Before directly in a pragma Elaborate_All,\n+      --  or mentions a third unit, X, which itself requires that Before be\n+      --  elaborated before unit X is elaborated. The Elab_All_Link list\n+      --  traces the dependencies in the latter case.\n+\n+      Elab_Desirable,\n+      --  This is just like Elab_All, except that the elaborate all was not\n+      --  explicitly present in the source, but rather was created by the\n+      --  front end, which decided that it was \"desirable\".\n+\n+      Spec_First);\n+      --  After is a body, and Before is the corresponding spec\n+\n+   --  Successor_Link contains the information for one link\n+\n+   type Successor_Link is record\n+      Before : Unit_Id;\n+      --  Predecessor unit\n+\n+      After : Unit_Id;\n+      --  Successor unit\n+\n+      Next : Successor_Id;\n+      --  Next successor on this list\n+\n+      Reason : Succ_Reason;\n+      --  Reason for this link\n+\n+      Elab_Body : Boolean;\n+      --  Set True if this link is needed for the special Elaborate_Body\n+      --  processing described below.\n+\n+      Reason_Unit : Unit_Id;\n+      --  For Reason = Elab, or Elab_All or Elab_Desirable, records the unit\n+      --  containing the pragma leading to the link.\n+\n+      Elab_All_Link : Elab_All_Id;\n+      --  If Reason = Elab_All or Elab_Desirable, then this points to the\n+      --  first elment in a list of Elab_All entries that record the with\n+      --  chain leading resulting in this particular dependency.\n+\n+   end record;\n+\n+   --  Note on handling of Elaborate_Body. Basically, if we have a pragma\n+   --  Elaborate_Body in a unit, it means that the spec and body have to\n+   --  be handled as a single entity from the point of view of determining\n+   --  an elaboration order. What we do is to essentially remove the body\n+   --  from consideration completely, and transfer all its links (other\n+   --  than the spec link) to the spec. Then when then the spec gets chosen,\n+   --  we choose the body right afterwards. We mark the links that get moved\n+   --  from the body to the spec by setting their Elab_Body flag True, so\n+   --  that we can understand what is going on!\n+\n+   Succ_First : constant := 1;\n+\n+   package Succ is new Table.Table (\n+     Table_Component_Type => Successor_Link,\n+     Table_Index_Type     => Successor_Id,\n+     Table_Low_Bound      => Succ_First,\n+     Table_Initial        => 500,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Succ\");\n+\n+   --  For the case of Elaborate_All, the following table is used to record\n+   --  chains of with relationships that lead to the Elab_All link. These\n+   --  are used solely for diagnostic purposes\n+\n+   type Elab_All_Entry is record\n+      Needed_By : Unit_Name_Type;\n+      --  Name of unit from which referencing unit was with'ed or otherwise\n+      --  needed as a result of Elaborate_All or Elaborate_Desirable.\n+\n+      Next_Elab : Elab_All_Id;\n+      --  Link to next entry on chain (No_Elab_All_Link marks end of list)\n+   end record;\n+\n+   package Elab_All_Entries is new Table.Table (\n+     Table_Component_Type => Elab_All_Entry,\n+     Table_Index_Type     => Elab_All_Id,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 2000,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Elab_All_Entries\");\n+\n+   --  A Unit_Node record is built for each active unit\n+\n+   type Unit_Node_Record is record\n+\n+      Successors : Successor_Id;\n+      --  Pointer to list of links for successor nodes\n+\n+      Num_Pred : Int;\n+      --  Number of predecessors for this unit. Normally non-negative, but\n+      --  can go negative in the case of units chosen by the diagnose error\n+      --  procedure (when cycles are being removed from the graph).\n+\n+      Nextnp : Unit_Id;\n+      --  Forward pointer for list of units with no predecessors\n+\n+      Elab_Order : Nat;\n+      --  Position in elaboration order (zero = not placed yet)\n+\n+      Visited : Boolean;\n+      --  Used in computing transitive closure for elaborate all and\n+      --  also in locating cycles and paths in the diagnose routines.\n+\n+      Elab_Position : Natural;\n+      --  Initialized to zero. Set non-zero when a unit is chosen and\n+      --  placed in the elaboration order. The value represents the\n+      --  ordinal position in the elaboration order.\n+\n+   end record;\n+\n+   package UNR is new Table.Table (\n+     Table_Component_Type => Unit_Node_Record,\n+     Table_Index_Type     => Unit_Id,\n+     Table_Low_Bound      => First_Unit_Entry,\n+     Table_Initial        => 500,\n+     Table_Increment      => 200,\n+     Table_Name           => \"UNR\");\n+\n+   No_Pred : Unit_Id;\n+   --  Head of list of items with no predecessors\n+\n+   Num_Left : Int;\n+   --  Number of entries not yet dealt with\n+\n+   Cur_Unit : Unit_Id;\n+   --  Current unit, set by Gather_Dependencies, and picked up in Build_Link\n+   --  to set the Reason_Unit field of the created dependency link.\n+\n+   Num_Chosen : Natural := 0;\n+   --  Number of units chosen in the elaboration order so far\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Better_Choice (U1, U2 : Unit_Id) return Boolean;\n+   --  U1 and U2 are both permitted candidates for selection as the next unit\n+   --  to be elaborated. This function determines whether U1 is a better choice\n+   --  than U2, i.e. should be elaborated in preference to U2, based on a set\n+   --  of heuristics that establish a friendly and predictable order (see body\n+   --  for details). The result is True if U1 is a better choice than U2, and\n+   --  False if it is a worse choice, or there is no preference between them.\n+\n+   procedure Build_Link\n+     (Before : Unit_Id;\n+      After  : Unit_Id;\n+      R      : Succ_Reason;\n+      Ea_Id  : Elab_All_Id := No_Elab_All_Link);\n+   --  Establish a successor link, Before must be elaborated before After,\n+   --  and the reason for the link is R. Ea_Id is the contents to be placed\n+   --  in the Elab_All_Link of the entry.\n+\n+   procedure Choose (Chosen : Unit_Id);\n+   --  Chosen is the next entry chosen in the elaboration order. This\n+   --  procedure updates all data structures appropriately.\n+\n+   function Corresponding_Body (U : Unit_Id) return Unit_Id;\n+   pragma Inline (Corresponding_Body);\n+   --  Given a unit which is a spec for which there is a separate body,\n+   --  return the unit id of the body. It is an error to call this routine\n+   --  with a unit that is not a spec, or which does not have a separate body.\n+\n+   function Corresponding_Spec (U : Unit_Id) return Unit_Id;\n+   pragma Inline (Corresponding_Spec);\n+   --  Given a unit which is a body for which there is a separate spec,\n+   --  return the unit id of the spec. It is an error to call this routine\n+   --  with a unit that is not a body, or which does not have a separate spec.\n+\n+   procedure Diagnose_Elaboration_Problem;\n+   --  Called when no elaboration order can be found. Outputs an appropriate\n+   --  diagnosis of the problem, and then abandons the bind.\n+\n+   procedure Elab_All_Links\n+     (Before : Unit_Id;\n+      After  : Unit_Id;\n+      Reason : Succ_Reason;\n+      Link   : Elab_All_Id);\n+   --  Used to compute the transitive closure of elaboration links for an\n+   --  Elaborate_All pragma (Reason = Elab_All) or for an indication of\n+   --  Elaborate_All_Desirable (Reason = Elab_Desirable). Unit After has\n+   --  a pragma Elaborate_All or the front end has determined that a reference\n+   --  probably requires Elaborate_All is required, and unit Before must be\n+   --  previously elaborated. First a link is built making sure that unit\n+   --  Before is elaborated before After, then a recursive call ensures that\n+   --  we also build links for any units needed by Before (i.e. these units\n+   --  must/should also be elaborated before After). Link is used to build\n+   --  a chain of Elab_All_Entries to explain the reason for a link. The\n+   --  value passed is the chain so far.\n+\n+   procedure Elab_Error_Msg (S : Successor_Id);\n+   --  Given a successor link, outputs an error message of the form\n+   --  \"& must be elaborated before & ...\" where ... is the reason.\n+\n+   procedure Gather_Dependencies;\n+   --  Compute dependencies, building the Succ and UNR tables\n+\n+   function Make_Elab_Entry\n+     (Unam : Unit_Name_Type;\n+      Link : Elab_All_Id)\n+      return Elab_All_Id;\n+   --  Make an Elab_All_Entries table entry with the given Unam and Link.\n+\n+   function Unit_Id_Of (Uname : Unit_Name_Type) return Unit_Id;\n+   --  This function uses the Info field set in the names table to obtain\n+   --  the unit Id of a unit, given its name id value.\n+\n+   function Worse_Choice (U1, U2 : Unit_Id) return Boolean;\n+   --  This is like Better_Choice, and has the same interface, but returns\n+   --  true if U1 is a worse choice than U2 in the sense of the -h (horrible\n+   --  elaboration order) switch. We still have to obey Ada rules, so it is\n+   --  not quite the direct inverse of Better_Choice.\n+\n+   procedure Write_Dependencies;\n+   --  Write out dependencies (called only if appropriate option is set)\n+\n+   procedure Write_Elab_All_Chain (S : Successor_Id);\n+   --  If the reason for the link S is Elaborate_All or Elaborate_Desirable,\n+   --  then this routine will output the \"needed by\" explanation chain.\n+\n+   -------------------\n+   -- Better_Choice --\n+   -------------------\n+\n+   function Better_Choice (U1, U2 : Unit_Id) return Boolean is\n+\n+      function Body_Unit (U : Unit_Id) return Boolean;\n+      --  Determines if given unit is a body\n+\n+      function Waiting_Body (U : Unit_Id) return Boolean;\n+      --  Determines if U is a waiting body, defined as a body which has\n+      --  not been elaborated, but whose spec has been elaborated.\n+\n+      function Body_Unit (U : Unit_Id) return Boolean is\n+      begin\n+         return Units.Table (U).Utype = Is_Body\n+           or else Units.Table (U).Utype = Is_Body_Only;\n+      end Body_Unit;\n+\n+      function Waiting_Body (U : Unit_Id) return Boolean is\n+      begin\n+         return Units.Table (U).Utype = Is_Body\n+           and then UNR.Table (Corresponding_Spec (U)).Elab_Position /= 0;\n+      end Waiting_Body;\n+\n+   --  Start of processing for Better_Choice\n+\n+   --  Note: the checks here are applied in sequence, and the ordering is\n+   --  significant (i.e. the more important criteria are applied first).\n+\n+   begin\n+      --  Prefer a waiting body to any other case\n+\n+      if Waiting_Body (U1) and not Waiting_Body (U2) then\n+         return True;\n+\n+      elsif Waiting_Body (U2) and not Waiting_Body (U1) then\n+         return False;\n+\n+      --  Prefer a predefined unit to a non-predefined unit\n+\n+      elsif Units.Table (U1).Predefined\n+        and not Units.Table (U2).Predefined\n+      then\n+         return True;\n+\n+      elsif Units.Table (U2).Predefined\n+        and not Units.Table (U1).Predefined\n+      then\n+         return False;\n+\n+      --  Prefer an internal unit to a non-internal unit\n+\n+      elsif Units.Table (U1).Internal\n+        and not Units.Table (U2).Internal\n+      then\n+         return True;\n+\n+      elsif Units.Table (U2).Internal\n+        and not Units.Table (U1).Internal\n+      then\n+         return False;\n+\n+      --  Prefer a body to a spec\n+\n+      elsif Body_Unit (U1) and not Body_Unit (U2) then\n+         return True;\n+\n+      elsif Body_Unit (U2) and not Body_Unit (U1) then\n+         return False;\n+\n+      --  If both are waiting bodies, then prefer the one whose spec is\n+      --  more recently elaborated. Consider the following:\n+\n+      --     spec of A\n+      --     spec of B\n+      --     body of A or B?\n+\n+      --  The normal waiting body preference would have placed the body of\n+      --  A before the spec of B if it could. Since it could not, there it\n+      --  must be the case that A depends on B. It is therefore a good idea\n+      --  to put the body of B first.\n+\n+      elsif Waiting_Body (U1) and then Waiting_Body (U2) then\n+         return\n+           UNR.Table (Corresponding_Spec (U1)).Elab_Position >\n+           UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+\n+      --  Otherwise decide on the basis of alphabetical order\n+\n+      else\n+         return Uname_Less (Units.Table (U1).Uname, Units.Table (U2).Uname);\n+      end if;\n+   end Better_Choice;\n+\n+   ----------------\n+   -- Build_Link --\n+   ----------------\n+\n+   procedure Build_Link\n+     (Before : Unit_Id;\n+      After  : Unit_Id;\n+      R      : Succ_Reason;\n+      Ea_Id  : Elab_All_Id := No_Elab_All_Link)\n+   is\n+      Cspec : Unit_Id;\n+\n+   begin\n+      Succ.Increment_Last;\n+      Succ.Table (Succ.Last).Before          := Before;\n+      Succ.Table (Succ.Last).Next            := UNR.Table (Before).Successors;\n+      UNR.Table (Before).Successors          := Succ.Last;\n+      Succ.Table (Succ.Last).Reason          := R;\n+      Succ.Table (Succ.Last).Reason_Unit     := Cur_Unit;\n+      Succ.Table (Succ.Last).Elab_All_Link   := Ea_Id;\n+\n+      --  Deal with special Elab_Body case. If the After of this link is\n+      --  a body whose spec has Elaborate_All set, and this is not the link\n+      --  directly from the body to the spec, then we make the After of the\n+      --  link reference its spec instead, marking the link appropriately.\n+\n+      if Units.Table (After).Utype = Is_Body then\n+         Cspec := Corresponding_Spec (After);\n+\n+         if Units.Table (Cspec).Elaborate_Body\n+           and then Cspec /= Before\n+         then\n+            Succ.Table (Succ.Last).After     := Cspec;\n+            Succ.Table (Succ.Last).Elab_Body := True;\n+            UNR.Table (Cspec).Num_Pred       := UNR.Table (Cspec).Num_Pred + 1;\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Fall through on normal case\n+\n+      Succ.Table (Succ.Last).After           := After;\n+      Succ.Table (Succ.Last).Elab_Body       := False;\n+      UNR.Table (After).Num_Pred             := UNR.Table (After).Num_Pred + 1;\n+   end Build_Link;\n+\n+   ------------\n+   -- Choose --\n+   ------------\n+\n+   procedure Choose (Chosen : Unit_Id) is\n+      S : Successor_Id;\n+      U : Unit_Id;\n+\n+   begin\n+      if Debug_Flag_C then\n+         Write_Str (\"Choosing Unit \");\n+         Write_Unit_Name (Units.Table (Chosen).Uname);\n+         Write_Eol;\n+      end if;\n+\n+      --  Add to elaboration order. Note that units having no elaboration\n+      --  code are not treated specially yet. The special casing of this\n+      --  is in Bindgen, where Gen_Elab_Calls skips over them. Meanwhile\n+      --  we need them here, because the object file list is also driven\n+      --  by the contents of the Elab_Order table.\n+\n+      Elab_Order.Increment_Last;\n+      Elab_Order.Table (Elab_Order.Last) := Chosen;\n+\n+      --  Remove from No_Pred list. This is a little inefficient and may\n+      --  be we should doubly link the list, but it will do for now!\n+\n+      if No_Pred = Chosen then\n+         No_Pred := UNR.Table (Chosen).Nextnp;\n+\n+      else\n+         --  Note that we just ignore the situation where it does not\n+         --  appear in the No_Pred list, this happens in calls from the\n+         --  Diagnose_Elaboration_Problem routine, where cycles are being\n+         --  removed arbitrarily from the graph.\n+\n+         U := No_Pred;\n+         while U /= No_Unit_Id loop\n+            if UNR.Table (U).Nextnp = Chosen then\n+               UNR.Table (U).Nextnp := UNR.Table (Chosen).Nextnp;\n+               exit;\n+            end if;\n+\n+            U := UNR.Table (U).Nextnp;\n+         end loop;\n+      end if;\n+\n+      --  For all successors, decrement the number of predecessors, and\n+      --  if it becomes zero, then add to no predecessor list.\n+\n+      S := UNR.Table (Chosen).Successors;\n+\n+      while S /= No_Successor loop\n+         U := Succ.Table (S).After;\n+         UNR.Table (U).Num_Pred := UNR.Table (U).Num_Pred - 1;\n+\n+         if Debug_Flag_N then\n+            Write_Str (\"  decrementing Num_Pred for unit \");\n+            Write_Unit_Name (Units.Table (U).Uname);\n+            Write_Str (\" new value = \");\n+            Write_Int (Int (UNR.Table (U).Num_Pred));\n+            Write_Eol;\n+         end if;\n+\n+         if UNR.Table (U).Num_Pred = 0 then\n+            UNR.Table (U).Nextnp := No_Pred;\n+            No_Pred := U;\n+         end if;\n+\n+         S := Succ.Table (S).Next;\n+      end loop;\n+\n+      --  All done, adjust number of units left count and set elaboration pos\n+\n+      Num_Left := Num_Left - 1;\n+      Num_Chosen := Num_Chosen + 1;\n+      UNR.Table (Chosen).Elab_Position := Num_Chosen;\n+      Units.Table (Chosen).Elab_Position := Num_Chosen;\n+\n+      --  If we just chose a spec with Elaborate_Body set, then we\n+      --  must immediately elaborate the body, before any other units.\n+\n+      if Units.Table (Chosen).Elaborate_Body then\n+\n+         --  If the unit is a spec only, then there is no body. This is a bit\n+         --  odd given that Elaborate_Body is here, but it is valid in an\n+         --  RCI unit, where we only have the interface in the stub bind.\n+\n+         if Units.Table (Chosen).Utype = Is_Spec_Only\n+           and then Units.Table (Chosen).RCI\n+         then\n+            null;\n+         else\n+            Choose (Corresponding_Body (Chosen));\n+         end if;\n+      end if;\n+   end Choose;\n+\n+   ------------------------\n+   -- Corresponding_Body --\n+   ------------------------\n+\n+   --  Currently if the body and spec are separate, then they appear as\n+   --  two separate units in the same ALI file, with the body appearing\n+   --  first and the spec appearing second.\n+\n+   function Corresponding_Body (U : Unit_Id) return Unit_Id is\n+   begin\n+      pragma Assert (Units.Table (U).Utype = Is_Spec);\n+      return U - 1;\n+   end Corresponding_Body;\n+\n+   ------------------------\n+   -- Corresponding_Spec --\n+   ------------------------\n+\n+   --  Currently if the body and spec are separate, then they appear as\n+   --  two separate units in the same ALI file, with the body appearing\n+   --  first and the spec appearing second.\n+\n+   function Corresponding_Spec (U : Unit_Id) return Unit_Id is\n+   begin\n+      pragma Assert (Units.Table (U).Utype = Is_Body);\n+      return U + 1;\n+   end Corresponding_Spec;\n+\n+   ----------------------------------\n+   -- Diagnose_Elaboration_Problem --\n+   ----------------------------------\n+\n+   procedure Diagnose_Elaboration_Problem is\n+\n+      function Find_Path (Ufrom, Uto : Unit_Id; ML : Nat) return Boolean;\n+      --  Recursive routine used to find a path from node Ufrom to node Uto.\n+      --  If a path exists, returns True and outputs an appropriate set of\n+      --  error messages giving the path. Also calls Choose for each of the\n+      --  nodes so that they get removed from the remaining set. There are\n+      --  two cases of calls, either Ufrom = Uto for an attempt to find a\n+      --  cycle, or Ufrom is a spec and Uto the corresponding body for the\n+      --  case of an unsatisfiable Elaborate_Body pragma. ML is the minimum\n+      --  acceptable length for a path.\n+\n+      ---------------\n+      -- Find_Path --\n+      ---------------\n+\n+      function Find_Path (Ufrom, Uto : Unit_Id; ML : Nat) return Boolean is\n+\n+         function Find_Link (U : Unit_Id; PL : Nat) return Boolean;\n+         --  This is the inner recursive routine, it determines if a path\n+         --  exists from U to Uto, and if so returns True and outputs the\n+         --  appropriate set of error messages. PL is the path length\n+\n+         ---------------\n+         -- Find_Link --\n+         ---------------\n+\n+         function Find_Link (U : Unit_Id; PL : Nat) return Boolean is\n+            S : Successor_Id;\n+\n+         begin\n+            --  Recursion ends if we are at terminating node and the path\n+            --  is sufficiently long, generate error message and return True.\n+\n+            if U = Uto and then PL >= ML then\n+               Choose (U);\n+               return True;\n+\n+            --  All done if already visited, otherwise mark as visited\n+\n+            elsif UNR.Table (U).Visited then\n+               return False;\n+\n+            --  Otherwise mark as visited and look at all successors\n+\n+            else\n+               UNR.Table (U).Visited := True;\n+\n+               S := UNR.Table (U).Successors;\n+               while S /= No_Successor loop\n+                  if Find_Link (Succ.Table (S).After, PL + 1) then\n+                     Elab_Error_Msg (S);\n+                     Choose (U);\n+                     return True;\n+                  end if;\n+\n+                  S := Succ.Table (S).Next;\n+               end loop;\n+\n+               --  Falling through means this does not lead to a path\n+\n+               return False;\n+            end if;\n+         end Find_Link;\n+\n+      --  Start of processing for Find_Path\n+\n+      begin\n+         --  Initialize all non-chosen nodes to not visisted yet\n+\n+         for U in Units.First .. Units.Last loop\n+            UNR.Table (U).Visited := UNR.Table (U).Elab_Position /= 0;\n+         end loop;\n+\n+         --  Now try to find the path\n+\n+         return Find_Link (Ufrom, 0);\n+      end Find_Path;\n+\n+   --  Start of processing for Diagnose_Elaboration_Error\n+\n+   begin\n+      Set_Standard_Error;\n+\n+      --  Output state of things if debug flag N set\n+\n+      if Debug_Flag_N then\n+         declare\n+            NP : Int;\n+\n+         begin\n+            Write_Eol;\n+            Write_Eol;\n+            Write_Str (\"Diagnose_Elaboration_Problem called\");\n+            Write_Eol;\n+            Write_Str (\"List of remaining unchosen units and predecessors\");\n+            Write_Eol;\n+\n+            for U in Units.First .. Units.Last loop\n+               if UNR.Table (U).Elab_Position = 0 then\n+                  NP := UNR.Table (U).Num_Pred;\n+                  Write_Eol;\n+                  Write_Str (\"  Unchosen unit: #\");\n+                  Write_Int (Int (U));\n+                  Write_Str (\"  \");\n+                  Write_Unit_Name (Units.Table (U).Uname);\n+                  Write_Str (\" (Num_Pred = \");\n+                  Write_Int (NP);\n+                  Write_Char (')');\n+                  Write_Eol;\n+\n+                  if NP = 0 then\n+                     if Units.Table (U).Elaborate_Body then\n+                        Write_Str\n+                          (\"    (not chosen because of Elaborate_Body)\");\n+                        Write_Eol;\n+                     else\n+                        Write_Str (\"  ****************** why not chosen?\");\n+                        Write_Eol;\n+                     end if;\n+                  end if;\n+\n+                  --  Search links list to find unchosen predecessors\n+\n+                  for S in Succ.First .. Succ.Last loop\n+                     declare\n+                        SL : Successor_Link renames Succ.Table (S);\n+\n+                     begin\n+                        if SL.After = U\n+                          and then UNR.Table (SL.Before).Elab_Position = 0\n+                        then\n+                           Write_Str (\"    unchosen predecessor: #\");\n+                           Write_Int (Int (SL.Before));\n+                           Write_Str (\"  \");\n+                           Write_Unit_Name (Units.Table (SL.Before).Uname);\n+                           Write_Eol;\n+                           NP := NP - 1;\n+                        end if;\n+                     end;\n+                  end loop;\n+\n+                  if NP /= 0 then\n+                     Write_Str (\"  **************** Num_Pred value wrong!\");\n+                     Write_Eol;\n+                  end if;\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Output the header for the error, and manually increment the\n+      --  error count. We are using Error_Msg_Output rather than Error_Msg\n+      --  here for two reasons:\n+\n+      --    This is really only one error, not one for each line\n+      --    We want this output on standard output since it is voluminous\n+\n+      --  But we do need to deal with the error count manually in this case\n+\n+      Errors_Detected := Errors_Detected + 1;\n+      Error_Msg_Output (\"elaboration circularity detected\", Info => False);\n+\n+      --  Try to find cycles starting with any of the remaining nodes that have\n+      --  not yet been chosen. There must be at least one (there is some reason\n+      --  we are being called!)\n+\n+      for U in Units.First .. Units.Last loop\n+         if UNR.Table (U).Elab_Position = 0 then\n+            if Find_Path (U, U, 1) then\n+               raise Unrecoverable_Error;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  We should never get here, since we were called for some reason,\n+      --  and we should have found and eliminated at least one bad path.\n+\n+      raise Program_Error;\n+\n+   end Diagnose_Elaboration_Problem;\n+\n+   --------------------\n+   -- Elab_All_Links --\n+   --------------------\n+\n+   procedure Elab_All_Links\n+     (Before : Unit_Id;\n+      After  : Unit_Id;\n+      Reason : Succ_Reason;\n+      Link   : Elab_All_Id)\n+   is\n+   begin\n+      if UNR.Table (Before).Visited then\n+         return;\n+      end if;\n+\n+      --  Build the direct link for Before\n+\n+      UNR.Table (Before).Visited := True;\n+      Build_Link (Before, After, Reason, Link);\n+\n+      --  Process all units with'ed by Before recursively\n+\n+      for W in\n+        Units.Table (Before).First_With .. Units.Table (Before).Last_With\n+      loop\n+         --  Skip if no ALI file for this with, happens with certain\n+         --  specialized generic files that do not get compiled.\n+\n+         if Withs.Table (W).Afile /= No_File then\n+\n+            Elab_All_Links\n+              (Unit_Id_Of (Withs.Table (W).Uname),\n+               After,\n+               Reason,\n+               Make_Elab_Entry (Withs.Table (W).Uname, Link));\n+         end if;\n+      end loop;\n+\n+      --  Process corresponding body, if there is one\n+\n+      if Units.Table (Before).Utype = Is_Spec then\n+         Elab_All_Links\n+           (Corresponding_Body (Before),\n+            After, Reason,\n+            Make_Elab_Entry\n+              (Units.Table (Corresponding_Body (Before)).Uname, Link));\n+      end if;\n+   end Elab_All_Links;\n+\n+   --------------------\n+   -- Elab_Error_Msg --\n+   --------------------\n+\n+   procedure Elab_Error_Msg (S : Successor_Id) is\n+      SL : Successor_Link renames Succ.Table (S);\n+\n+   begin\n+      --  Nothing to do if internal unit involved and no -de flag\n+\n+      if not Debug_Flag_E\n+        and then\n+          (Is_Internal_File_Name (Units.Table (SL.Before).Sfile)\n+            or else\n+           Is_Internal_File_Name (Units.Table (SL.After).Sfile))\n+      then\n+         return;\n+      end if;\n+\n+      --  Here we want to generate output\n+\n+      Error_Msg_Name_1 := Units.Table (SL.Before).Uname;\n+\n+      if SL.Elab_Body then\n+         Error_Msg_Name_2 := Units.Table (Corresponding_Body (SL.After)).Uname;\n+      else\n+         Error_Msg_Name_2 := Units.Table (SL.After).Uname;\n+      end if;\n+\n+      Error_Msg_Output (\"  & must be elaborated before &\", Info => True);\n+\n+      Error_Msg_Name_1 := Units.Table (SL.Reason_Unit).Uname;\n+\n+      case SL.Reason is\n+         when Withed =>\n+            Error_Msg_Output\n+              (\"     reason: with clause\",\n+               Info => True);\n+\n+         when Elab =>\n+            Error_Msg_Output\n+              (\"     reason: pragma Elaborate in unit &\",\n+               Info => True);\n+\n+         when Elab_All =>\n+            Error_Msg_Output\n+              (\"     reason: pragma Elaborate_All in unit &\",\n+               Info => True);\n+\n+         when Elab_Desirable =>\n+            Error_Msg_Output\n+              (\"     reason: Elaborate_All probably needed in unit &\",\n+               Info => True);\n+\n+            Error_Msg_Output\n+              (\"     recompile & with -gnatwl for full details\",\n+               Info => True);\n+\n+         when Spec_First =>\n+            Error_Msg_Output\n+              (\"     reason: spec always elaborated before body\",\n+               Info => True);\n+      end case;\n+\n+      Write_Elab_All_Chain (S);\n+\n+      if SL.Elab_Body then\n+         Error_Msg_Name_1 := Units.Table (SL.Before).Uname;\n+         Error_Msg_Name_2 := Units.Table (SL.After).Uname;\n+         Error_Msg_Output\n+           (\"  & must therefore be elaborated before &\",\n+            True);\n+\n+         Error_Msg_Name_1 := Units.Table (SL.After).Uname;\n+         Error_Msg_Output\n+           (\"     (because & has a pragma Elaborate_Body)\",\n+            True);\n+      end if;\n+\n+      Write_Eol;\n+   end Elab_Error_Msg;\n+\n+   ---------------------\n+   -- Find_Elab_Order --\n+   ---------------------\n+\n+   procedure Find_Elab_Order is\n+      U           : Unit_Id;\n+      Best_So_Far : Unit_Id;\n+\n+   begin\n+      Succ.Init;\n+      Num_Left := Int (Units.Last - Units.First + 1);\n+\n+      --  Initialize unit table for elaboration control\n+\n+      for U in Units.First .. Units.Last loop\n+         UNR.Increment_Last;\n+         UNR.Table (UNR.Last).Successors    := No_Successor;\n+         UNR.Table (UNR.Last).Num_Pred      := 0;\n+         UNR.Table (UNR.Last).Nextnp        := No_Unit_Id;\n+         UNR.Table (UNR.Last).Elab_Order    := 0;\n+         UNR.Table (UNR.Last).Elab_Position := 0;\n+      end loop;\n+\n+      --  Gather dependencies and output them if option set\n+\n+      Gather_Dependencies;\n+\n+      --  Output elaboration dependencies if option is set\n+\n+      if Elab_Dependency_Output or Debug_Flag_E then\n+         Write_Dependencies;\n+      end if;\n+\n+      --  Initialize the no predecessor list\n+\n+      No_Pred := No_Unit_Id;\n+\n+      for U in UNR.First .. UNR.Last loop\n+         if UNR.Table (U).Num_Pred = 0 then\n+            UNR.Table (U).Nextnp := No_Pred;\n+            No_Pred := U;\n+         end if;\n+      end loop;\n+\n+      --  OK, now we determine the elaboration order proper. All we do is to\n+      --  select the best choice from the no predecessor list until all the\n+      --  nodes have been chosen.\n+\n+      Outer : loop\n+         --  If there are no nodes with predecessors, then either we are\n+         --  done, as indicated by Num_Left being set to zero, or we have\n+         --  a circularity. In the latter case, diagnose the circularity,\n+         --  removing it from the graph and continue\n+\n+         Get_No_Pred : while No_Pred = No_Unit_Id loop\n+            exit Outer when Num_Left < 1;\n+            Diagnose_Elaboration_Problem;\n+         end loop Get_No_Pred;\n+\n+         U := No_Pred;\n+         Best_So_Far := No_Unit_Id;\n+\n+         --  Loop to choose best entry in No_Pred list\n+\n+         No_Pred_Search : loop\n+            if Debug_Flag_N then\n+               Write_Str (\"  considering choice of \");\n+               Write_Unit_Name (Units.Table (U).Uname);\n+               Write_Eol;\n+\n+               if Units.Table (U).Elaborate_Body then\n+                  Write_Str\n+                    (\"    Elaborate_Body = True, Num_Pred for body = \");\n+                  Write_Int\n+                    (Int (UNR.Table (Corresponding_Body (U)).Num_Pred));\n+               else\n+                  Write_Str\n+                    (\"    Elaborate_Body = False\");\n+               end if;\n+\n+               Write_Eol;\n+            end if;\n+\n+            --  This is a candididate to be considered for choice\n+\n+            if Best_So_Far = No_Unit_Id\n+              or else ((not Pessimistic_Elab_Order)\n+                         and then Better_Choice (U, Best_So_Far))\n+              or else (Pessimistic_Elab_Order\n+                         and then Worse_Choice (U, Best_So_Far))\n+            then\n+               if Debug_Flag_N then\n+                  Write_Str (\"    tentatively chosen (best so far)\");\n+                  Write_Eol;\n+               end if;\n+\n+               Best_So_Far := U;\n+            end if;\n+\n+            U := UNR.Table (U).Nextnp;\n+            exit No_Pred_Search when U = No_Unit_Id;\n+         end loop No_Pred_Search;\n+\n+         --  If no candididate chosen, it means that no unit has No_Pred = 0,\n+         --  but there are units left, hence we have a circular dependency,\n+         --  which we will get Diagnose_Elaboration_Problem to diagnose it.\n+\n+         if Best_So_Far = No_Unit_Id then\n+            Diagnose_Elaboration_Problem;\n+\n+         --  Otherwise choose the best candidate found\n+\n+         else\n+            Choose (Best_So_Far);\n+         end if;\n+      end loop Outer;\n+\n+   end Find_Elab_Order;\n+\n+   -------------------------\n+   -- Gather_Dependencies --\n+   -------------------------\n+\n+   procedure Gather_Dependencies is\n+      Withed_Unit : Unit_Id;\n+\n+   begin\n+      --  Loop through all units\n+\n+      for U in Units.First .. Units.Last loop\n+         Cur_Unit := U;\n+\n+         --  If there is a body and a spec, then spec must be elaborated first\n+         --  Note that the corresponding spec immediately follows the body\n+\n+         if Units.Table (U).Utype = Is_Body then\n+            Build_Link (Corresponding_Spec (U), U, Spec_First);\n+         end if;\n+\n+         --  Process WITH references for this unit ignoring generic units\n+\n+         for W in Units.Table (U).First_With .. Units.Table (U).Last_With loop\n+            if Withs.Table (W).Sfile /= No_File then\n+\n+               --  Check for special case of withing a unit that does not\n+               --  exist any more. If the unit was completely missing we would\n+               --  already have detected this, but a nasty case arises when we\n+               --  have a subprogram body with no spec, and some obsolete unit\n+               --  with's a previous (now disappeared) spec.\n+\n+               if Get_Name_Table_Info (Withs.Table (W).Uname) = 0 then\n+                  Error_Msg_Name_1 := Units.Table (U).Sfile;\n+                  Error_Msg_Name_2 := Withs.Table (W).Uname;\n+                  Error_Msg (\"% depends on & which no longer exists\");\n+                  goto Next_With;\n+               end if;\n+\n+               Withed_Unit :=\n+                 Unit_Id (Unit_Id_Of (Withs.Table (W).Uname));\n+\n+               --  Pragma Elaborate_All case, for this we use the recursive\n+               --  Elab_All_Links procedure to establish the links.\n+\n+               if Withs.Table (W).Elaborate_All then\n+\n+                  --  Reset flags used to stop multiple visits to a given node\n+\n+                  for Uref in UNR.First .. UNR.Last loop\n+                     UNR.Table (Uref).Visited := False;\n+                  end loop;\n+\n+                  --  Now establish all the links we need\n+\n+                  Elab_All_Links\n+                    (Withed_Unit, U, Elab_All,\n+                     Make_Elab_Entry\n+                       (Withs.Table (W).Uname, No_Elab_All_Link));\n+\n+               --  Elaborate_All_Desirable case, for this we establish the\n+               --  same links as above, but with a different reason.\n+\n+               elsif Withs.Table (W).Elab_All_Desirable then\n+\n+                  --  Reset flags used to stop multiple visits to a given node\n+\n+                  for Uref in UNR.First .. UNR.Last loop\n+                     UNR.Table (Uref).Visited := False;\n+                  end loop;\n+\n+                  --  Now establish all the links we need\n+\n+                  Elab_All_Links\n+                    (Withed_Unit, U, Elab_Desirable,\n+                     Make_Elab_Entry\n+                       (Withs.Table (W).Uname, No_Elab_All_Link));\n+\n+               --  Pragma Elaborate case. We must build a link for the withed\n+               --  unit itself, and also the corresponding body if there is one\n+\n+               --  However, skip this processing if there is no ALI file for\n+               --  the WITH entry, because this means it is a generic (even\n+               --  when we fix the generics so that an ALI file is present,\n+               --  we probably still will have no ALI file for unchecked\n+               --  and other special cases).\n+\n+               elsif Withs.Table (W).Elaborate\n+                 and then Withs.Table (W).Afile /= No_File\n+               then\n+                  Build_Link (Withed_Unit, U, Withed);\n+\n+                  if Units.Table (Withed_Unit).Utype = Is_Spec then\n+                     Build_Link\n+                      (Corresponding_Body (Withed_Unit), U, Elab);\n+                  end if;\n+\n+               --  Case of normal WITH with no elaboration pragmas, just\n+               --  build the single link to the directly referenced unit\n+\n+               else\n+                  Build_Link (Withed_Unit, U, Withed);\n+               end if;\n+            end if;\n+\n+            <<Next_With>>\n+               null;\n+         end loop;\n+      end loop;\n+   end Gather_Dependencies;\n+\n+   ---------------------\n+   -- Make_Elab_Entry --\n+   ---------------------\n+\n+   function Make_Elab_Entry\n+     (Unam : Unit_Name_Type;\n+      Link : Elab_All_Id)\n+      return Elab_All_Id\n+   is\n+   begin\n+      Elab_All_Entries.Increment_Last;\n+      Elab_All_Entries.Table (Elab_All_Entries.Last).Needed_By := Unam;\n+      Elab_All_Entries.Table (Elab_All_Entries.Last).Next_Elab := Link;\n+      return Elab_All_Entries.Last;\n+   end Make_Elab_Entry;\n+\n+   ----------------\n+   -- Unit_Id_Of --\n+   ----------------\n+\n+   function Unit_Id_Of (Uname : Unit_Name_Type) return Unit_Id is\n+      Info : constant Int := Get_Name_Table_Info (Uname);\n+\n+   begin\n+      pragma Assert (Info /= 0 and then Unit_Id (Info) /= No_Unit_Id);\n+      return Unit_Id (Info);\n+   end Unit_Id_Of;\n+\n+   ------------------\n+   -- Worse_Choice --\n+   ------------------\n+\n+   function Worse_Choice (U1, U2 : Unit_Id) return Boolean is\n+\n+      function Body_Unit (U : Unit_Id) return Boolean;\n+      --  Determines if given unit is a body\n+\n+      function Waiting_Body (U : Unit_Id) return Boolean;\n+      --  Determines if U is a waiting body, defined as a body which has\n+      --  not been elaborated, but whose spec has been elaborated.\n+\n+      function Body_Unit (U : Unit_Id) return Boolean is\n+      begin\n+         return Units.Table (U).Utype = Is_Body\n+           or else Units.Table (U).Utype = Is_Body_Only;\n+      end Body_Unit;\n+\n+      function Waiting_Body (U : Unit_Id) return Boolean is\n+      begin\n+         return Units.Table (U).Utype = Is_Body and then\n+            UNR.Table (Corresponding_Spec (U)).Elab_Position /= 0;\n+      end Waiting_Body;\n+\n+   --  Start of processing for Worse_Choice\n+\n+   --  Note: the checks here are applied in sequence, and the ordering is\n+   --  significant (i.e. the more important criteria are applied first).\n+\n+   begin\n+      --  If either unit is internal, then use Better_Choice, since the\n+      --  language requires that predefined units not mess up in the choice\n+      --  of elaboration order, and for internal units, any problems are\n+      --  ours and not the programmers.\n+\n+      if Units.Table (U1).Internal or else Units.Table (U2).Internal then\n+         return Better_Choice (U1, U2);\n+\n+      --  Prefer anything else to a waiting body (!)\n+\n+      elsif Waiting_Body (U1) and not Waiting_Body (U2) then\n+         return False;\n+\n+      elsif Waiting_Body (U2) and not Waiting_Body (U1) then\n+         return True;\n+\n+      --  Prefer a spec to a body (!)\n+\n+      elsif Body_Unit (U1) and not Body_Unit (U2) then\n+         return False;\n+\n+      elsif Body_Unit (U2) and not Body_Unit (U1) then\n+         return True;\n+\n+      --  If both are waiting bodies, then prefer the one whose spec is\n+      --  less recently elaborated. Consider the following:\n+\n+      --     spec of A\n+      --     spec of B\n+      --     body of A or B?\n+\n+      --  The normal waiting body preference would have placed the body of\n+      --  A before the spec of B if it could. Since it could not, there it\n+      --  must be the case that A depends on B. It is therefore a good idea\n+      --  to put the body of B last so that if there is an elaboration order\n+      --  problem, we will find it (that's what horrible order is about)\n+\n+      elsif Waiting_Body (U1) and then Waiting_Body (U2) then\n+         return\n+           UNR.Table (Corresponding_Spec (U1)).Elab_Position <\n+           UNR.Table (Corresponding_Spec (U2)).Elab_Position;\n+\n+      --  Otherwise decide on the basis of alphabetical order. We do not try\n+      --  to reverse the usual choice here, since it can cause cancelling\n+      --  errors with the other inversions.\n+\n+      else\n+         return Uname_Less (Units.Table (U1).Uname, Units.Table (U2).Uname);\n+      end if;\n+   end Worse_Choice;\n+\n+   ------------------------\n+   -- Write_Dependencies --\n+   ------------------------\n+\n+   procedure Write_Dependencies is\n+   begin\n+      Write_Eol;\n+      Write_Str\n+        (\"                 ELABORATION ORDER DEPENDENCIES\");\n+      Write_Eol;\n+      Write_Eol;\n+\n+      Info_Prefix_Suppress := True;\n+\n+      for S in Succ_First .. Succ.Last loop\n+         Elab_Error_Msg (S);\n+      end loop;\n+\n+      Info_Prefix_Suppress := False;\n+      Write_Eol;\n+   end Write_Dependencies;\n+\n+   --------------------------\n+   -- Write_Elab_All_Chain --\n+   --------------------------\n+\n+   procedure Write_Elab_All_Chain (S : Successor_Id) is\n+      ST     : constant Successor_Link := Succ.Table (S);\n+      After  : constant Unit_Name_Type := Units.Table (ST.After).Uname;\n+\n+      L   : Elab_All_Id;\n+      Nam : Unit_Name_Type;\n+\n+      First_Name : Boolean := True;\n+\n+   begin\n+      if ST.Reason in Elab_All .. Elab_Desirable then\n+         L := ST.Elab_All_Link;\n+         while L /= No_Elab_All_Link loop\n+            Nam := Elab_All_Entries.Table (L).Needed_By;\n+            Error_Msg_Name_1 := Nam;\n+            Error_Msg_Output (\"        &\", Info => True);\n+\n+            Get_Name_String (Nam);\n+\n+            if Name_Buffer (Name_Len) = 'b' then\n+               if First_Name then\n+                  Error_Msg_Output\n+                    (\"           must be elaborated along with its spec:\",\n+                     Info => True);\n+\n+               else\n+                  Error_Msg_Output\n+                    (\"           which must be elaborated \" &\n+                     \"along with its spec:\",\n+                     Info => True);\n+               end if;\n+\n+            else\n+               if First_Name then\n+                  Error_Msg_Output\n+                    (\"           is withed by:\",\n+                     Info => True);\n+\n+               else\n+                  Error_Msg_Output\n+                    (\"           which is withed by:\",\n+                     Info => True);\n+               end if;\n+            end if;\n+\n+            First_Name := False;\n+\n+            L := Elab_All_Entries.Table (L).Next_Elab;\n+         end loop;\n+\n+         Error_Msg_Name_1 := After;\n+         Error_Msg_Output (\"        &\", Info => True);\n+      end if;\n+   end Write_Elab_All_Chain;\n+\n+end Binde;"}, {"sha": "9d0351b332901c84fbf227ebfb392177f9de1351", "filename": "gcc/ada/binde.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                B I N D E                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines to determine elaboration order\n+\n+with ALI;   use ALI;\n+with Table;\n+with Types; use Types;\n+\n+package Binde is\n+\n+   --  The following table records the chosen elaboration order. It is used\n+   --  by Gen_Elab_Call to generate the sequence of elaboration calls. Note\n+   --  that units are included in this table even if they have no elaboration\n+   --  routine, since the table is also used to drive the generation of object\n+   --  files in the binder output. Gen_Elab_Call skips any units that have no\n+   --  elaboration routine.\n+\n+   package Elab_Order is new Table.Table (\n+     Table_Component_Type => Unit_Id,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 500,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Elab_Order\");\n+\n+   procedure Find_Elab_Order;\n+   --  Determine elaboration order\n+\n+end Binde;"}, {"sha": "b9ea3982c65e35adb5235f6dc706a8c102feb188", "filename": "gcc/ada/binderr.adb", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinderr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinderr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinderr.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,198 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              B I N D E R R                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Butil;   use Butil;\n+with Namet;   use Namet;\n+with Opt;     use Opt;\n+with Output;  use Output;\n+\n+package body Binderr is\n+\n+   ---------------\n+   -- Error_Msg --\n+   ---------------\n+\n+   procedure Error_Msg (Msg : String) is\n+   begin\n+      if Msg (Msg'First) = '?' then\n+         if Warning_Mode = Suppress then\n+            return;\n+         end if;\n+\n+         if Warning_Mode = Treat_As_Error then\n+            Errors_Detected := Errors_Detected + 1;\n+         else\n+            Warnings_Detected := Warnings_Detected + 1;\n+         end if;\n+\n+      else\n+         Errors_Detected := Errors_Detected + 1;\n+      end if;\n+\n+      if Brief_Output or else (not Verbose_Mode) then\n+         Set_Standard_Error;\n+         Error_Msg_Output (Msg, Info => False);\n+         Set_Standard_Output;\n+      end if;\n+\n+      if Verbose_Mode then\n+         if Errors_Detected + Warnings_Detected = 0 then\n+            Write_Eol;\n+         end if;\n+\n+         Error_Msg_Output (Msg, Info => False);\n+      end if;\n+\n+      if Warnings_Detected + Errors_Detected > Maximum_Errors then\n+         raise Unrecoverable_Error;\n+      end if;\n+\n+   end Error_Msg;\n+\n+   --------------------\n+   -- Error_Msg_Info --\n+   --------------------\n+\n+   procedure Error_Msg_Info (Msg : String) is\n+   begin\n+      if Brief_Output or else (not Verbose_Mode) then\n+         Set_Standard_Error;\n+         Error_Msg_Output (Msg, Info => True);\n+         Set_Standard_Output;\n+      end if;\n+\n+      if Verbose_Mode then\n+         Error_Msg_Output (Msg, Info => True);\n+      end if;\n+\n+   end Error_Msg_Info;\n+\n+   ----------------------\n+   -- Error_Msg_Output --\n+   ----------------------\n+\n+   procedure Error_Msg_Output (Msg : String; Info : Boolean) is\n+      Use_Second_Name : Boolean := False;\n+\n+   begin\n+      if Warnings_Detected + Errors_Detected > Maximum_Errors then\n+         Write_Str (\"error: maximum errors exceeded\");\n+         Write_Eol;\n+         return;\n+      end if;\n+\n+      if Msg (Msg'First) = '?' then\n+         Write_Str (\"warning: \");\n+      elsif Info then\n+         if not Info_Prefix_Suppress then\n+            Write_Str (\"info:  \");\n+         end if;\n+      else\n+         Write_Str (\"error: \");\n+      end if;\n+\n+      for I in Msg'Range loop\n+         if Msg (I) = '%' then\n+\n+            if Use_Second_Name then\n+               Get_Name_String (Error_Msg_Name_2);\n+            else\n+               Use_Second_Name := True;\n+               Get_Name_String (Error_Msg_Name_1);\n+            end if;\n+\n+            Write_Char ('\"');\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n+            Write_Char ('\"');\n+\n+         elsif Msg (I) = '&' then\n+            Write_Char ('\"');\n+\n+            if Use_Second_Name then\n+               Write_Unit_Name (Error_Msg_Name_2);\n+            else\n+               Use_Second_Name := True;\n+               Write_Unit_Name (Error_Msg_Name_1);\n+            end if;\n+\n+            Write_Char ('\"');\n+\n+         elsif Msg (I) /= '?' then\n+            Write_Char (Msg (I));\n+         end if;\n+      end loop;\n+\n+      Write_Eol;\n+   end Error_Msg_Output;\n+\n+   ----------------------\n+   -- Finalize_Binderr --\n+   ----------------------\n+\n+   procedure Finalize_Binderr is\n+   begin\n+      --  Message giving number of errors detected (verbose mode only)\n+\n+      if Verbose_Mode then\n+         Write_Eol;\n+\n+         if Errors_Detected = 0 then\n+            Write_Str (\"No errors\");\n+\n+         elsif Errors_Detected = 1 then\n+            Write_Str (\"1 error\");\n+\n+         else\n+            Write_Int (Errors_Detected);\n+            Write_Str (\" errors\");\n+         end if;\n+\n+         if Warnings_Detected = 1 then\n+            Write_Str (\", 1 warning\");\n+\n+         elsif Warnings_Detected > 1 then\n+            Write_Str (\", \");\n+            Write_Int (Warnings_Detected);\n+            Write_Str (\" warnings\");\n+         end if;\n+\n+         Write_Eol;\n+      end if;\n+   end Finalize_Binderr;\n+\n+   ------------------------\n+   -- Initialize_Binderr --\n+   ------------------------\n+\n+   procedure Initialize_Binderr is\n+   begin\n+      Errors_Detected := 0;\n+      Warnings_Detected := 0;\n+   end Initialize_Binderr;\n+\n+end Binderr;"}, {"sha": "37a346f095f2adc727f6d420d0914507d5a7f281", "filename": "gcc/ada/binderr.ads", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinderr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbinderr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinderr.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              B I N D E R R                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines to output error messages for the binder\n+--  and also the routines for handling fatal error conditions in the binder.\n+\n+with Types; use Types;\n+\n+package Binderr is\n+\n+   Errors_Detected : Int;\n+   --  Number of errors detected so far\n+\n+   Warnings_Detected : Int;\n+   --  Number of warnings detected\n+\n+   Info_Prefix_Suppress : Boolean := False;\n+   --  If set to True, the normal \"info: \" header before messages generated\n+   --  by Error_Msg_Info will be omitted.\n+\n+   ---------------------------------------------------------\n+   -- Error Message Text and Message Insertion Characters --\n+   ---------------------------------------------------------\n+\n+   --  Error message text strings are composed of letters, digits and the\n+   --  special characters space, comma, period, colon and semicolon,\n+   --  apostrophe and parentheses. Special insertion characters can also\n+   --  appear which cause the error message circuit to modify the given\n+   --  string as follows:\n+\n+   --    Insertion character % (Percent: insert file name from Names table)\n+   --      The character % is replaced by the text for the file name specified\n+   --      by the Name_Id value stored in Error_Msg_Name_1. The name is always\n+   --      enclosed in quotes. A second % may appear in a single message in\n+   --      which case it is similarly replaced by the name which is specified\n+   --      by the Name_Id value stored in Error_Msg_Name_2.\n+\n+   --    Insertion character & (Ampersand: insert unit name from Names table)\n+   --      The character & is replaced by the text for the unit name specified\n+   --      by the Name_Id value stored in Error_Msg_Name_1. The name is always\n+   --      enclosed in quotes. A second & may appear in a single message in\n+   --      which case it is similarly replaced by the name which is specified\n+   --      by the Name_Id value stored in Error_Msg_Name_2.\n+\n+   --    Insertion character ? (Question mark: warning message)\n+   --      The character ?, which must be the first character in the message\n+   --      string, signals a warning message instead of an error message.\n+\n+   -----------------------------------------------------\n+   -- Global Values Used for Error Message Insertions --\n+   -----------------------------------------------------\n+\n+   --  The following global variables are essentially additional parameters\n+   --  passed to the error message routine for insertion sequences described\n+   --  above. The reason these are passed globally is that the insertion\n+   --  mechanism is essentially an untyped one in which the appropriate\n+   --  variables are set dependingon the specific insertion characters used.\n+\n+   Error_Msg_Name_1 : Name_Id;\n+   Error_Msg_Name_2 : Name_Id;\n+   --  Name_Id values for % insertion characters in message\n+\n+   ------------------------------\n+   -- Error Output Subprograms --\n+   ------------------------------\n+\n+   procedure Error_Msg (Msg : String);\n+   --  Output specified error message to standard error or standard output\n+   --  as governed by the brief and verbose switches, and update error\n+   --  counts appropriately\n+\n+   procedure Error_Msg_Info (Msg : String);\n+   --  Output information line. Indentical in effect to Error_Msg, except\n+   --  that the prefix is info: instead of error: and the error count is\n+   --  not incremented. The prefix may be suppressed by setting the global\n+   --  variable Info_Prefix_Suppress to True.\n+\n+   procedure Error_Msg_Output (Msg : String; Info : Boolean);\n+   --  Output given message, with insertions, to current message output file.\n+   --  The second argument is True for an info message, false for a normal\n+   --  warning or error message. Normally this is not called directly, but\n+   --  rather only by Error_Msg or Error_Msg_Info. It is called directly\n+   --  when the caller must control whether the output goes to stderr or\n+   --  stdout (Error_Msg_Output always goes to the current output file).\n+\n+   procedure Finalize_Binderr;\n+   --  Finalize error output for one file\n+\n+   procedure Initialize_Binderr;\n+   --  Initialize error output for one file\n+\n+end Binderr;"}, {"sha": "677e495cd7993d288f2221793bbfd2ceed8a6293", "filename": "gcc/ada/bindgen.adb", "status": "added", "additions": 2903, "deletions": 0, "changes": 2903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,2903 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              B I N D G E N                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.201 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with ALI;         use ALI;\n+with Binde;       use Binde;\n+with Butil;       use Butil;\n+with Casing;      use Casing;\n+with Fname;       use Fname;\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with Gnatvsn;     use Gnatvsn;\n+with Hostparm;\n+with Namet;       use Namet;\n+with Opt;         use Opt;\n+with Osint;       use Osint;\n+with Output;      use Output;\n+with Types;       use Types;\n+with Sdefault;    use Sdefault;\n+with System;      use System;\n+\n+with GNAT.Heap_Sort_A;     use GNAT.Heap_Sort_A;\n+\n+package body Bindgen is\n+\n+   Statement_Buffer : String (1 .. 1000);\n+   --  Buffer used for constructing output statements\n+\n+   Last : Natural := 0;\n+   --  Last location in Statement_Buffer currently set\n+\n+   With_DECGNAT : Boolean := False;\n+   --  Flag which indicates whether the program uses the DECGNAT library\n+   --  (presence of the unit System.Aux_DEC.DECLIB)\n+\n+   With_GNARL : Boolean := False;\n+   --  Flag which indicates whether the program uses the GNARL library\n+   --  (presence of the unit System.OS_Interface)\n+\n+   Num_Elab_Calls : Nat := 0;\n+   --  Number of generated calls to elaboration routines\n+\n+   subtype chars_ptr is Address;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure WBI (Info : String) renames Osint.Write_Binder_Info;\n+   --  Convenient shorthand used throughout\n+\n+   function ABE_Boolean_Required (U : Unit_Id) return Boolean;\n+   --  Given a unit id value U, determines if the corresponding unit requires\n+   --  an access-before-elaboration check variable, i.e. it is a non-predefined\n+   --  body for which no pragma Elaborate, Elaborate_All or Elaborate_Body is\n+   --  present, and thus could require ABE checks.\n+\n+   procedure Resolve_Binder_Options;\n+   --  Set the value of With_GNARL and With_DECGNAT. The latter only on VMS\n+   --  since it tests for a package named \"dec\" which might cause a conflict\n+   --  on non-VMS systems.\n+\n+   procedure Gen_Adainit_Ada;\n+   --  Generates the Adainit procedure (Ada code case)\n+\n+   procedure Gen_Adainit_C;\n+   --  Generates the Adainit procedure (C code case)\n+\n+   procedure Gen_Adafinal_Ada;\n+   --  Generate the Adafinal procedure (Ada code case)\n+\n+   procedure Gen_Adafinal_C;\n+   --  Generate the Adafinal procedure (C code case)\n+\n+   procedure Gen_Elab_Calls_Ada;\n+   --  Generate sequence of elaboration calls (Ada code case)\n+\n+   procedure Gen_Elab_Calls_C;\n+   --  Generate sequence of elaboration calls (C code case)\n+\n+   procedure Gen_Elab_Order_Ada;\n+   --  Generate comments showing elaboration order chosen (Ada case)\n+\n+   procedure Gen_Elab_Order_C;\n+   --  Generate comments showing elaboration order chosen (C case)\n+\n+   procedure Gen_Elab_Defs_C;\n+   --  Generate sequence of definitions for elaboration routines (C code case)\n+\n+   procedure Gen_Exception_Table_Ada;\n+   --  Generate binder exception table (Ada code case). This consists of\n+   --  declarations followed by a begin followed by a call. If zero cost\n+   --  exceptions are not active, then only the begin is generated.\n+\n+   procedure Gen_Exception_Table_C;\n+   --  Generate binder exception table (C code case). This has no effect\n+   --  if zero cost exceptions are not active, otherwise it generates a\n+   --  set of declarations followed by a call.\n+\n+   procedure Gen_Main_Ada;\n+   --  Generate procedure main (Ada code case)\n+\n+   procedure Gen_Main_C;\n+   --  Generate main() procedure (C code case)\n+\n+   procedure Gen_Object_Files_Options;\n+   --  Output comments containing a list of the full names of the object\n+   --  files to be linked and the list of linker options supplied by\n+   --  Linker_Options pragmas in the source. (C and Ada code case)\n+\n+   procedure Gen_Output_File_Ada (Filename : String);\n+   --  Generate output file (Ada code case)\n+\n+   procedure Gen_Output_File_C (Filename : String);\n+   --  Generate output file (C code case)\n+\n+   procedure Gen_Scalar_Values;\n+   --  Generates scalar initialization values for -Snn. A single procedure\n+   --  handles both the Ada and C cases, since there is much common code.\n+\n+   procedure Gen_Versions_Ada;\n+   --  Output series of definitions for unit versions (Ada code case)\n+\n+   procedure Gen_Versions_C;\n+   --  Output series of definitions for unit versions (C code case)\n+\n+   function Get_Ada_Main_Name return String;\n+   --  This function is used in the Ada main output case to compute a usable\n+   --  name for the generated main program. The normal main program name is\n+   --  Ada_Main, but this won't work if the user has a unit with this name.\n+   --  This function tries Ada_Main first, and if there is such a clash, then\n+   --  it tries Ada_Name_01, Ada_Name_02 ... Ada_Name_99 in sequence.\n+\n+   function Get_Main_Name return String;\n+   --  This function is used in the Ada main output case to compute the\n+   --  correct external main program. It is \"main\" by default, except on\n+   --  VxWorks where it is the name of the Ada main name without the \"_ada\".\n+   --  the -Mname binder option overrides the default with name.\n+\n+   function Lt_Linker_Option (Op1, Op2 : Natural) return Boolean;\n+   --  Compare linker options, when sorting, first according to\n+   --  Is_Internal_File (internal files come later) and then by elaboration\n+   --  order position (latest to earliest) except its not possible to\n+   --  distinguish between a linker option in the spec and one in the body.\n+\n+   procedure Move_Linker_Option (From : Natural; To : Natural);\n+   --  Move routine for sorting linker options\n+\n+   procedure Public_Version_Warning;\n+   --  Emit a warning concerning the use of the Public version under\n+   --  certain circumstances. See details in body.\n+\n+   procedure Set_Char (C : Character);\n+   --  Set given character in Statement_Buffer at the Last + 1 position\n+   --  and increment Last by one to reflect the stored character.\n+\n+   procedure Set_Int (N : Int);\n+   --  Set given value in decimal in Statement_Buffer with no spaces\n+   --  starting at the Last + 1 position, and updating Last past the value.\n+   --  A minus sign is output for a negative value.\n+\n+   procedure Set_Main_Program_Name;\n+   --  Given the main program name in Name_Buffer (length in Name_Len)\n+   --  generate the name of the routine to be used in the call. The name\n+   --  is generated starting at Last + 1, and Last is updated past it.\n+\n+   procedure Set_Name_Buffer;\n+   --  Set the value stored in positions 1 .. Name_Len of the Name_Buffer.\n+\n+   procedure Set_String (S : String);\n+   --  Sets characters of given string in Statement_Buffer, starting at the\n+   --  Last + 1 position, and updating last past the string value.\n+\n+   procedure Set_Unit_Name;\n+   --  Given a unit name in the Name_Buffer, copies it to Statement_Buffer,\n+   --  starting at the Last + 1 position, and updating last past the value.\n+   --  changing periods to double underscores, and updating Last appropriately.\n+\n+   procedure Set_Unit_Number (U : Unit_Id);\n+   --  Sets unit number (first unit is 1, leading zeroes output to line\n+   --  up all output unit numbers nicely as required by the value, and\n+   --  by the total number of units.\n+\n+   procedure Tab_To (N : Natural);\n+   --  If Last is greater than or equal to N, no effect, otherwise store\n+   --  blanks in Statement_Buffer bumping Last, until Last = N.\n+\n+   function Value (chars : chars_ptr) return String;\n+   --  Return C NUL-terminated string at chars as an Ada string\n+\n+   procedure Write_Info_Ada_C (Ada : String; C : String; Common : String);\n+   --  For C code case, write C & Common, for Ada case write Ada & Common\n+   --  to current binder output file using Write_Binder_Info.\n+\n+   procedure Write_Statement_Buffer;\n+   --  Write out contents of statement buffer up to Last, and reset Last to 0\n+\n+   procedure Write_Statement_Buffer (S : String);\n+   --  First writes its argument (using Set_String (S)), then writes out the\n+   --  contents of statement buffer up to Last, and reset Last to 0\n+\n+   --------------------------\n+   -- ABE_Boolean_Required --\n+   --------------------------\n+\n+   function ABE_Boolean_Required (U : Unit_Id) return Boolean is\n+      Typ   : constant Unit_Type := Units.Table (U).Utype;\n+      Unit : Unit_Id;\n+\n+   begin\n+      if Typ /= Is_Body then\n+         return False;\n+\n+      else\n+         Unit := U + 1;\n+\n+         return (not Units.Table (Unit).Pure)\n+                   and then\n+                (not Units.Table (Unit).Preelab)\n+                   and then\n+                (not Units.Table (Unit).Elaborate_Body)\n+                   and then\n+                (not Units.Table (Unit).Predefined);\n+      end if;\n+   end ABE_Boolean_Required;\n+\n+   ----------------------\n+   -- Gen_Adafinal_Ada --\n+   ----------------------\n+\n+   procedure Gen_Adafinal_Ada is\n+   begin\n+      WBI (\"\");\n+      WBI (\"   procedure \" & Ada_Final_Name.all & \" is\");\n+      WBI (\"   begin\");\n+\n+      --  If compiling for the JVM, we directly call Adafinal because\n+      --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n+\n+      if Hostparm.Java_VM then\n+         WBI (\"      System.Standard_Library.Adafinal;\");\n+      else\n+         WBI (\"      Do_Finalize;\");\n+      end if;\n+\n+      WBI (\"   end \" & Ada_Final_Name.all & \";\");\n+   end Gen_Adafinal_Ada;\n+\n+   --------------------\n+   -- Gen_Adafinal_C --\n+   --------------------\n+\n+   procedure Gen_Adafinal_C is\n+   begin\n+      WBI (\"void \" & Ada_Final_Name.all & \" () {\");\n+      WBI (\"   system__standard_library__adafinal ();\");\n+      WBI (\"}\");\n+      WBI (\"\");\n+   end Gen_Adafinal_C;\n+\n+   ---------------------\n+   -- Gen_Adainit_Ada --\n+   ---------------------\n+\n+   procedure Gen_Adainit_Ada is\n+   begin\n+      WBI (\"   procedure \" & Ada_Init_Name.all & \" is\");\n+\n+      --  Generate externals for elaboration entities\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         declare\n+            Unum : constant Unit_Id := Elab_Order.Table (E);\n+            U    : Unit_Record renames Units.Table (Unum);\n+\n+         begin\n+            if U.Set_Elab_Entity then\n+               Set_String (\"      \");\n+               Set_String (\"E\");\n+               Set_Unit_Number (Unum);\n+               Set_String (\" : Boolean; pragma Import (Ada, \");\n+               Set_String (\"E\");\n+               Set_Unit_Number (Unum);\n+               Set_String (\", \"\"\");\n+               Get_Name_String (U.Uname);\n+\n+               --  In the case of JGNAT we need to emit an Import name\n+               --  that includes the class name (using '$' separators\n+               --  in the case of a child unit name).\n+\n+               if Hostparm.Java_VM then\n+                  for J in 1 .. Name_Len - 2 loop\n+                     if Name_Buffer (J) /= '.' then\n+                        Set_Char (Name_Buffer (J));\n+                     else\n+                        Set_String (\"$\");\n+                     end if;\n+                  end loop;\n+\n+                  Set_String (\".\");\n+\n+                  --  If the unit name is very long, then split the\n+                  --  Import link name across lines using \"&\" (occurs\n+                  --  in some C2 tests).\n+\n+                  if 2 * Name_Len + 60 > Hostparm.Max_Line_Length then\n+                     Set_String (\"\"\" &\");\n+                     Write_Statement_Buffer;\n+                     Set_String (\"         \"\"\");\n+                  end if;\n+               end if;\n+\n+               Set_Unit_Name;\n+               Set_String (\"_E\"\");\");\n+               Write_Statement_Buffer;\n+            end if;\n+         end;\n+      end loop;\n+\n+      Write_Statement_Buffer;\n+\n+      --  Normal case (no pragma No_Run_Time). The global values are\n+      --  assigned using the runtime routine Set_Globals (we have to use\n+      --  the routine call, rather than define the globals in the binder\n+      --  file to deal with cross-library calls in some systems.\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"\");\n+         WBI (\"      procedure Set_Globals\");\n+         WBI (\"        (Main_Priority            : Integer;\");\n+         WBI (\"         Time_Slice_Value         : Integer;\");\n+         WBI (\"         WC_Encoding              : Character;\");\n+         WBI (\"         Locking_Policy           : Character;\");\n+         WBI (\"         Queuing_Policy           : Character;\");\n+         WBI (\"         Task_Dispatching_Policy  : Character;\");\n+         WBI (\"         Adafinal                 : System.Address;\");\n+         WBI (\"         Unreserve_All_Interrupts : Integer;\");\n+         WBI (\"         Exception_Tracebacks     : Integer);\");\n+         WBI (\"      pragma Import (C, Set_Globals, \"\"__gnat_set_globals\"\");\");\n+         WBI (\"\");\n+\n+         --  Import entry point for elaboration time signal handler\n+         --  installation, and indication of whether it's been called\n+         --  previously\n+         WBI (\"\");\n+         WBI (\"      procedure Install_Handler;\");\n+         WBI (\"      pragma Import (C, Install_Handler, \" &\n+              \"\"\"__gnat_install_handler\"\");\");\n+         WBI (\"\");\n+         WBI (\"      Handler_Installed : Integer;\");\n+         WBI (\"      pragma Import (C, Handler_Installed, \" &\n+              \"\"\"__gnat_handler_installed\"\");\");\n+\n+         --  Generate exception table\n+\n+         Gen_Exception_Table_Ada;\n+\n+         --  Generate the call to Set_Globals\n+\n+         WBI (\"      Set_Globals\");\n+\n+         Set_String (\"        (Main_Priority            => \");\n+         Set_Int    (ALIs.Table (ALIs.First).Main_Priority);\n+         Set_Char   (',');\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         Time_Slice_Value         => \");\n+\n+         if Task_Dispatching_Policy_Specified = 'F'\n+           and then ALIs.Table (ALIs.First).Time_Slice_Value = -1\n+         then\n+            Set_Int (0);\n+         else\n+            Set_Int (ALIs.Table (ALIs.First).Time_Slice_Value);\n+         end if;\n+\n+         Set_Char   (',');\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         WC_Encoding              => '\");\n+         Set_Char   (ALIs.Table (ALIs.First).WC_Encoding);\n+         Set_String (\"',\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         Locking_Policy           => '\");\n+         Set_Char   (Locking_Policy_Specified);\n+         Set_String (\"',\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         Queuing_Policy           => '\");\n+         Set_Char   (Queuing_Policy_Specified);\n+         Set_String (\"',\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         Task_Dispatching_Policy  => '\");\n+         Set_Char   (Task_Dispatching_Policy_Specified);\n+         Set_String (\"',\");\n+         Write_Statement_Buffer;\n+\n+         WBI (\"         Adafinal                 => System.Null_Address,\");\n+\n+         Set_String (\"         Unreserve_All_Interrupts => \");\n+\n+         if Unreserve_All_Interrupts_Specified then\n+            Set_String (\"1\");\n+         else\n+            Set_String (\"0\");\n+         end if;\n+\n+         Set_String (\",\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"         Exception_Tracebacks     => \");\n+\n+         if Exception_Tracebacks then\n+            Set_String (\"1\");\n+         else\n+            Set_String (\"0\");\n+         end if;\n+\n+         Set_String (\");\");\n+         Write_Statement_Buffer;\n+\n+         --  Generate call to Install_Handler\n+         WBI (\"\");\n+         WBI (\"      if Handler_Installed = 0 then\");\n+         WBI (\"        Install_Handler;\");\n+         WBI (\"      end if;\");\n+\n+      --  Case of pragma No_Run_Time present. Globals are not needed since\n+      --  there are no runtime routines to make use of them, and no routine\n+      --  to store them in any case! Also no exception tables are needed.\n+\n+      else\n+         WBI (\"   begin\");\n+         WBI (\"      null;\");\n+      end if;\n+\n+      Gen_Elab_Calls_Ada;\n+\n+      WBI (\"   end \" & Ada_Init_Name.all & \";\");\n+   end Gen_Adainit_Ada;\n+\n+   -------------------\n+   -- Gen_Adainit_C --\n+   --------------------\n+\n+   procedure Gen_Adainit_C is\n+   begin\n+      WBI (\"void \" & Ada_Init_Name.all & \" ()\");\n+      WBI (\"{\");\n+\n+      --  Generate externals for elaboration entities\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         declare\n+            Unum : constant Unit_Id := Elab_Order.Table (E);\n+            U    : Unit_Record renames Units.Table (Unum);\n+\n+         begin\n+            if U.Set_Elab_Entity then\n+               Set_String (\"   extern char \");\n+               Get_Name_String (U.Uname);\n+               Set_Unit_Name;\n+               Set_String (\"_E;\");\n+               Write_Statement_Buffer;\n+            end if;\n+         end;\n+      end loop;\n+\n+      Write_Statement_Buffer;\n+\n+      --  Code for normal case (no pragma No_Run_Time in use)\n+\n+      if not No_Run_Time_Specified then\n+\n+         Gen_Exception_Table_C;\n+\n+         --  Generate call to set the runtime global variables defined in\n+         --  a-init.c. We define the varables in a-init.c, rather than in\n+         --  the binder generated file itself to avoid undefined externals\n+         --  when the runtime is linked as a shareable image library.\n+\n+         --  We call the routine from inside adainit() because this works for\n+         --  both programs with and without binder generated \"main\" functions.\n+\n+         WBI (\"   __gnat_set_globals (\");\n+\n+         Set_String (\"      \");\n+         Set_Int (ALIs.Table (ALIs.First).Main_Priority);\n+         Set_Char (',');\n+         Tab_To (15);\n+         Set_String (\"/* Main_Priority              */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      \");\n+\n+         if Task_Dispatching_Policy = 'F'\n+           and then ALIs.Table (ALIs.First).Time_Slice_Value = -1\n+         then\n+            Set_Int (0);\n+         else\n+            Set_Int (ALIs.Table (ALIs.First).Time_Slice_Value);\n+         end if;\n+\n+         Set_Char   (',');\n+         Tab_To (15);\n+         Set_String (\"/* Time_Slice_Value           */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      '\");\n+         Set_Char   (ALIs.Table (ALIs.First).WC_Encoding);\n+         Set_String (\"',\");\n+         Tab_To (15);\n+         Set_String (\"/* WC_Encoding                */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      '\");\n+         Set_Char (Locking_Policy_Specified);\n+         Set_String (\"',\");\n+         Tab_To (15);\n+         Set_String (\"/* Locking_Policy             */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      '\");\n+         Set_Char (Queuing_Policy_Specified);\n+         Set_String (\"',\");\n+         Tab_To (15);\n+         Set_String (\"/* Queuing_Policy             */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      '\");\n+         Set_Char (Task_Dispatching_Policy_Specified);\n+         Set_String (\"',\");\n+         Tab_To (15);\n+         Set_String (\"/* Tasking_Dispatching_Policy */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      \");\n+         Set_String (\"0,\");\n+         Tab_To (15);\n+         Set_String (\"/* Finalization routine address, not used anymore */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      \");\n+         Set_Int    (Boolean'Pos (Unreserve_All_Interrupts_Specified));\n+         Set_String (\",\");\n+         Tab_To (15);\n+         Set_String (\"/* Unreserve_All_Interrupts */\");\n+         Write_Statement_Buffer;\n+\n+         Set_String (\"      \");\n+         Set_Int    (Boolean'Pos (Exception_Tracebacks));\n+         Set_String (\");\");\n+         Tab_To (15);\n+         Set_String (\"/* Exception_Tracebacks */\");\n+         Write_Statement_Buffer;\n+\n+         --  Install elaboration time signal handler\n+         WBI (\"   if (__gnat_handler_installed == 0)\");\n+         WBI (\"     {\");\n+         WBI (\"        __gnat_install_handler ();\");\n+         WBI (\"     }\");\n+\n+      --  Case where No_Run_Time pragma is present (no globals required)\n+      --  Nothing more needs to be done in this case.\n+\n+      else\n+         null;\n+      end if;\n+\n+      WBI (\"\");\n+      Gen_Elab_Calls_C;\n+      WBI (\"}\");\n+   end Gen_Adainit_C;\n+\n+   ------------------------\n+   -- Gen_Elab_Calls_Ada --\n+   ------------------------\n+\n+   procedure Gen_Elab_Calls_Ada is\n+   begin\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         declare\n+            Unum : constant Unit_Id := Elab_Order.Table (E);\n+            U    : Unit_Record renames Units.Table (Unum);\n+\n+            Unum_Spec : Unit_Id;\n+            --  This is the unit number of the spec that corresponds to\n+            --  this entry. It is the same as Unum except when the body\n+            --  and spec are different and we are currently processing\n+            --  the body, in which case it is the spec (Unum + 1).\n+\n+            procedure Set_Elab_Entity;\n+            --  Set name of elaboration entity flag\n+\n+            procedure Set_Elab_Entity is\n+            begin\n+               Get_Decoded_Name_String_With_Brackets (U.Uname);\n+               Name_Len := Name_Len - 2;\n+               Set_Casing (U.Icasing);\n+               Set_Name_Buffer;\n+            end Set_Elab_Entity;\n+\n+         begin\n+            if U.Utype = Is_Body then\n+               Unum_Spec := Unum + 1;\n+            else\n+               Unum_Spec := Unum;\n+            end if;\n+\n+            --  Case of no elaboration code\n+\n+            if U.No_Elab then\n+\n+               --  The only case in which we have to do something is if\n+               --  this is a body, with a separate spec, where the separate\n+               --  spec has an elaboration entity defined.\n+\n+               --  In that case, this is where we set the elaboration entity\n+               --  to True, we do not need to test if this has already been\n+               --  done, since it is quicker to set the flag than to test it.\n+\n+               if U.Utype = Is_Body\n+                 and then Units.Table (Unum_Spec).Set_Elab_Entity\n+               then\n+                  Set_String (\"      E\");\n+                  Set_Unit_Number (Unum_Spec);\n+                  Set_String (\" := True;\");\n+                  Write_Statement_Buffer;\n+               end if;\n+\n+            --  Here if elaboration code is present. We generate:\n+\n+            --    if not uname_E then\n+            --       uname'elab_[spec|body];\n+            --       uname_E := True;\n+            --    end if;\n+\n+            --  The uname_E assignment is skipped if this is a separate spec,\n+            --  since the assignment will be done when we process the body.\n+\n+            else\n+               Set_String (\"      if not E\");\n+               Set_Unit_Number (Unum_Spec);\n+               Set_String (\" then\");\n+               Write_Statement_Buffer;\n+\n+               Set_String (\"         \");\n+               Get_Decoded_Name_String_With_Brackets (U.Uname);\n+\n+               if Name_Buffer (Name_Len) = 's' then\n+                  Name_Buffer (Name_Len - 1 .. Name_Len + 8) := \"'elab_spec\";\n+               else\n+                  Name_Buffer (Name_Len - 1 .. Name_Len + 8) := \"'elab_body\";\n+               end if;\n+\n+               Name_Len := Name_Len + 8;\n+               Set_Casing (U.Icasing);\n+               Set_Name_Buffer;\n+               Set_Char (';');\n+               Write_Statement_Buffer;\n+\n+               if U.Utype /= Is_Spec then\n+                  Set_String (\"         E\");\n+                  Set_Unit_Number (Unum_Spec);\n+                  Set_String (\" := True;\");\n+                  Write_Statement_Buffer;\n+               end if;\n+\n+               WBI (\"      end if;\");\n+            end if;\n+         end;\n+      end loop;\n+\n+   end Gen_Elab_Calls_Ada;\n+\n+   ----------------------\n+   -- Gen_Elab_Calls_C --\n+   ----------------------\n+\n+   procedure Gen_Elab_Calls_C is\n+   begin\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         declare\n+            Unum : constant Unit_Id := Elab_Order.Table (E);\n+            U    : Unit_Record renames Units.Table (Unum);\n+\n+            Unum_Spec : Unit_Id;\n+            --  This is the unit number of the spec that corresponds to\n+            --  this entry. It is the same as Unum except when the body\n+            --  and spec are different and we are currently processing\n+            --  the body, in which case it is the spec (Unum + 1).\n+\n+         begin\n+            if U.Utype = Is_Body then\n+               Unum_Spec := Unum + 1;\n+            else\n+               Unum_Spec := Unum;\n+            end if;\n+\n+            --  Case of no elaboration code\n+\n+            if U.No_Elab then\n+\n+               --  The only case in which we have to do something is if\n+               --  this is a body, with a separate spec, where the separate\n+               --  spec has an elaboration entity defined.\n+\n+               --  In that case, this is where we set the elaboration entity\n+               --  to True, we do not need to test if this has already been\n+               --  done, since it is quicker to set the flag than to test it.\n+\n+               if U.Utype = Is_Body\n+                 and then Units.Table (Unum_Spec).Set_Elab_Entity\n+               then\n+                  Set_String (\"   \");\n+                  Get_Name_String (U.Uname);\n+                  Set_Unit_Name;\n+                  Set_String (\"_E = 1;\");\n+                  Write_Statement_Buffer;\n+               end if;\n+\n+            --  Here if elaboration code is present. We generate:\n+\n+            --    if (uname_E == 0) {\n+            --       uname__elab[s|b] ();\n+            --       uname_E++;\n+            --    }\n+\n+            --  The uname_E assignment is skipped if this is a separate spec,\n+            --  since the assignment will be done when we process the body.\n+\n+            else\n+               Set_String (\"   if (\");\n+               Get_Name_String (U.Uname);\n+               Set_Unit_Name;\n+               Set_String (\"_E == 0) {\");\n+               Write_Statement_Buffer;\n+\n+               Set_String (\"      \");\n+               Set_Unit_Name;\n+               Set_String (\"___elab\");\n+               Set_Char (Name_Buffer (Name_Len)); -- 's' or 'b' for spec/body\n+               Set_String (\" ();\");\n+               Write_Statement_Buffer;\n+\n+               if U.Utype /= Is_Spec then\n+                  Set_String (\"      \");\n+                  Set_Unit_Name;\n+                  Set_String (\"_E++;\");\n+                  Write_Statement_Buffer;\n+               end if;\n+\n+               WBI (\"   }\");\n+            end if;\n+         end;\n+      end loop;\n+\n+   end Gen_Elab_Calls_C;\n+\n+   ----------------------\n+   -- Gen_Elab_Defs_C --\n+   ----------------------\n+\n+   procedure Gen_Elab_Defs_C is\n+   begin\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+\n+         --  Generate declaration of elaboration procedure if elaboration\n+         --  needed. Note that passive units are always excluded.\n+\n+         if not Units.Table (Elab_Order.Table (E)).No_Elab then\n+            Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n+            Set_String (\"extern void \");\n+            Set_Unit_Name;\n+            Set_String (\"___elab\");\n+            Set_Char (Name_Buffer (Name_Len)); -- 's' or 'b' for spec/body\n+            Set_String (\" PARAMS ((void));\");\n+            Write_Statement_Buffer;\n+         end if;\n+\n+      end loop;\n+\n+      WBI (\"\");\n+   end Gen_Elab_Defs_C;\n+\n+   ------------------------\n+   -- Gen_Elab_Order_Ada --\n+   ------------------------\n+\n+   procedure Gen_Elab_Order_Ada is\n+   begin\n+      WBI (\"\");\n+      WBI (\"   -- BEGIN ELABORATION ORDER\");\n+\n+      for J in Elab_Order.First .. Elab_Order.Last loop\n+         Set_String (\"   -- \");\n+         Get_Unit_Name_String (Units.Table (Elab_Order.Table (J)).Uname);\n+         Set_Name_Buffer;\n+         Write_Statement_Buffer;\n+      end loop;\n+\n+      WBI (\"   -- END ELABORATION ORDER\");\n+   end Gen_Elab_Order_Ada;\n+\n+   ----------------------\n+   -- Gen_Elab_Order_C --\n+   ----------------------\n+\n+   procedure Gen_Elab_Order_C is\n+   begin\n+      WBI (\"\");\n+      WBI (\"/* BEGIN ELABORATION ORDER\");\n+\n+      for J in Elab_Order.First .. Elab_Order.Last loop\n+         Get_Unit_Name_String (Units.Table (Elab_Order.Table (J)).Uname);\n+         Set_Name_Buffer;\n+         Write_Statement_Buffer;\n+      end loop;\n+\n+      WBI (\"   END ELABORATION ORDER */\");\n+   end Gen_Elab_Order_C;\n+\n+   -----------------------------\n+   -- Gen_Exception_Table_Ada --\n+   -----------------------------\n+\n+   procedure Gen_Exception_Table_Ada is\n+      Num  : Nat;\n+      Last : ALI_Id := No_ALI_Id;\n+\n+   begin\n+      if not Zero_Cost_Exceptions_Specified then\n+         WBI (\"   begin\");\n+         return;\n+      end if;\n+\n+      --  The code we generate looks like\n+\n+      --        procedure SDP_Table_Build\n+      --          (SDP_Addresses   : System.Address;\n+      --           SDP_Count       : Natural;\n+      --           Elab_Addresses  : System.Address;\n+      --           Elab_Addr_Count : Natural);\n+      --        pragma Import (C, SDP_Table_Build, \"__gnat_SDP_Table_Build\");\n+      --\n+      --        ST : aliased constant array (1 .. nnn) of System.Address := (\n+      --               unit_name_1'UET_Address,\n+      --               unit_name_2'UET_Address,\n+      --               ...\n+      --               unit_name_3'UET_Address,\n+      --\n+      --        EA : aliased constant array (1 .. eee) of System.Address := (\n+      --               adainit'Code_Address,\n+      --               adafinal'Code_Address,\n+      --               unit_name'elab[spec|body]'Code_Address,\n+      --               unit_name'elab[spec|body]'Code_Address,\n+      --               unit_name'elab[spec|body]'Code_Address,\n+      --               unit_name'elab[spec|body]'Code_Address);\n+      --\n+      --     begin\n+      --        SDP_Table_Build (ST'Address, nnn, EA'Address, eee);\n+\n+      Num := 0;\n+      for A in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A).Unit_Exception_Table then\n+            Num := Num + 1;\n+            Last := A;\n+         end if;\n+      end loop;\n+\n+      WBI (\"      procedure SDP_Table_Build\");\n+      WBI (\"        (SDP_Addresses   : System.Address;\");\n+      WBI (\"         SDP_Count       : Natural;\");\n+      WBI (\"         Elab_Addresses  : System.Address;\");\n+      WBI (\"         Elab_Addr_Count : Natural);\");\n+      WBI (\"      \" &\n+           \"pragma Import (C, SDP_Table_Build, \"\"__gnat_SDP_Table_Build\"\");\");\n+\n+      WBI (\" \");\n+      Set_String (\"      ST : aliased constant array (1 .. \");\n+      Set_Int (Num);\n+      Set_String (\") of System.Address := (\");\n+\n+      if Num = 1 then\n+         Set_String (\"1 => A1);\");\n+         Write_Statement_Buffer;\n+\n+      else\n+         Write_Statement_Buffer;\n+\n+         for A in ALIs.First .. ALIs.Last loop\n+            if ALIs.Table (A).Unit_Exception_Table then\n+               Get_Decoded_Name_String_With_Brackets\n+                 (Units.Table (ALIs.Table (A).First_Unit).Uname);\n+               Set_Casing (Mixed_Case);\n+               Set_String (\"        \");\n+               Set_String (Name_Buffer (1 .. Name_Len - 2));\n+               Set_String (\"'UET_Address\");\n+\n+               if A = Last then\n+                  Set_String (\");\");\n+               else\n+                  Set_Char (',');\n+               end if;\n+\n+               Write_Statement_Buffer;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      WBI (\" \");\n+      Set_String (\"      EA : aliased constant array (1 .. \");\n+      Set_Int (Num_Elab_Calls + 2);\n+      Set_String (\") of System.Address := (\");\n+      Write_Statement_Buffer;\n+      WBI (\"        \" & Ada_Init_Name.all & \"'Code_Address,\");\n+\n+      --  If compiling for the JVM, we directly reference Adafinal because\n+      --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n+\n+      if Hostparm.Java_VM then\n+         Set_String (\"        System.Standard_Library.Adafinal'Code_Address\");\n+      else\n+         Set_String (\"        Do_Finalize'Code_Address\");\n+      end if;\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         Get_Decoded_Name_String_With_Brackets\n+           (Units.Table (Elab_Order.Table (E)).Uname);\n+\n+         if Units.Table (Elab_Order.Table (E)).No_Elab then\n+            null;\n+\n+         else\n+            Set_Char (',');\n+            Write_Statement_Buffer;\n+            Set_String (\"        \");\n+\n+            if Name_Buffer (Name_Len) = 's' then\n+               Name_Buffer (Name_Len - 1 .. Name_Len + 21) :=\n+                                        \"'elab_spec'code_address\";\n+            else\n+               Name_Buffer (Name_Len - 1 .. Name_Len + 21) :=\n+                                        \"'elab_body'code_address\";\n+            end if;\n+\n+            Name_Len := Name_Len + 21;\n+            Set_Casing (Units.Table (Elab_Order.Table (E)).Icasing);\n+            Set_Name_Buffer;\n+         end if;\n+      end loop;\n+\n+      Set_String (\");\");\n+      Write_Statement_Buffer;\n+\n+      WBI (\" \");\n+      WBI (\"   begin\");\n+\n+      Set_String (\"      SDP_Table_Build (ST'Address, \");\n+      Set_Int (Num);\n+      Set_String (\", EA'Address, \");\n+      Set_Int (Num_Elab_Calls + 2);\n+      Set_String (\");\");\n+      Write_Statement_Buffer;\n+   end Gen_Exception_Table_Ada;\n+\n+   ---------------------------\n+   -- Gen_Exception_Table_C --\n+   ---------------------------\n+\n+   procedure Gen_Exception_Table_C is\n+      Num  : Nat;\n+      Num2 : Nat;\n+\n+   begin\n+      if not Zero_Cost_Exceptions_Specified then\n+         return;\n+      end if;\n+\n+      --  The code we generate looks like\n+\n+      --     extern void *__gnat_unitname1__SDP;\n+      --     extern void *__gnat_unitname2__SDP;\n+      --     ...\n+      --\n+      --     void **st[nnn] = {\n+      --       &__gnat_unitname1__SDP,\n+      --       &__gnat_unitname2__SDP,\n+      --       ...\n+      --       &__gnat_unitnamen__SDP};\n+      --\n+      --     extern void unitname1__elabb ();\n+      --     extern void unitname2__elabb ();\n+      --     ...\n+      --\n+      --     void (*ea[eee]) () = {\n+      --       adainit,\n+      --       adafinal,\n+      --       unitname1___elab[b,s],\n+      --       unitname2___elab[b,s],\n+      --       ...\n+      --       unitnamen___elab[b,s]};\n+      --\n+      --     __gnat_SDP_Table_Build (&st, nnn, &ea, eee);\n+\n+      Num := 0;\n+      for A in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A).Unit_Exception_Table then\n+            Num := Num + 1;\n+\n+            Set_String (\"   extern void *__gnat_\");\n+            Get_Name_String (Units.Table (ALIs.Table (A).First_Unit).Uname);\n+            Set_Unit_Name;\n+            Set_String (\"__SDP\");\n+            Set_Char (';');\n+            Write_Statement_Buffer;\n+         end if;\n+      end loop;\n+\n+      WBI (\" \");\n+\n+      Set_String (\"   void **st[\");\n+      Set_Int (Num);\n+      Set_String (\"] = {\");\n+      Write_Statement_Buffer;\n+\n+      Num2 := 0;\n+      for A in ALIs.First .. ALIs.Last loop\n+         if ALIs.Table (A).Unit_Exception_Table then\n+            Num2 := Num2 + 1;\n+\n+            Set_String (\"     &__gnat_\");\n+            Get_Name_String (Units.Table (ALIs.Table (A).First_Unit).Uname);\n+            Set_Unit_Name;\n+            Set_String (\"__SDP\");\n+\n+            if Num = Num2 then\n+               Set_String (\"};\");\n+            else\n+               Set_Char (',');\n+            end if;\n+\n+            Write_Statement_Buffer;\n+         end if;\n+      end loop;\n+\n+      WBI (\"\");\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n+\n+         if Units.Table (Elab_Order.Table (E)).No_Elab then\n+            null;\n+\n+         else\n+            Set_String (\"   extern void \");\n+            Set_Unit_Name;\n+            Set_String (\"___elab\");\n+            Set_Char (Name_Buffer (Name_Len)); -- 's' or 'b' for spec/body\n+            Set_String (\" ();\");\n+            Write_Statement_Buffer;\n+         end if;\n+      end loop;\n+\n+      WBI (\"\");\n+      Set_String (\"   void (*ea[\");\n+      Set_Int (Num_Elab_Calls + 2);\n+      Set_String (\"]) () = {\");\n+      Write_Statement_Buffer;\n+\n+      WBI (\"     \" & Ada_Init_Name.all & \",\");\n+      Set_String (\"     system__standard_library__adafinal\");\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n+\n+         if Units.Table (Elab_Order.Table (E)).No_Elab then\n+            null;\n+\n+         else\n+            Set_Char (',');\n+            Write_Statement_Buffer;\n+            Set_String (\"     \");\n+            Set_Unit_Name;\n+            Set_String (\"___elab\");\n+            Set_Char (Name_Buffer (Name_Len)); -- 's' or 'b' for spec/body\n+         end if;\n+      end loop;\n+\n+      Set_String (\"};\");\n+      Write_Statement_Buffer;\n+\n+      WBI (\" \");\n+\n+      Set_String (\"   __gnat_SDP_Table_Build (&st, \");\n+      Set_Int (Num);\n+      Set_String (\", ea, \");\n+      Set_Int (Num_Elab_Calls + 2);\n+      Set_String (\");\");\n+      Write_Statement_Buffer;\n+   end Gen_Exception_Table_C;\n+\n+   ------------------\n+   -- Gen_Main_Ada --\n+   ------------------\n+\n+   procedure Gen_Main_Ada is\n+      Target         : constant String_Ptr := Target_Name;\n+      VxWorks_Target : constant Boolean :=\n+                         Target (Target'Last - 7 .. Target'Last) = \"vxworks/\";\n+\n+   begin\n+      WBI (\"\");\n+      Set_String (\"   function \");\n+      Set_String (Get_Main_Name);\n+\n+      if VxWorks_Target then\n+         Set_String (\" return Integer is\");\n+         Write_Statement_Buffer;\n+\n+      else\n+         Write_Statement_Buffer;\n+         WBI (\"     (argc : Integer;\");\n+         WBI (\"      argv : System.Address;\");\n+         WBI (\"      envp : System.Address)\");\n+         WBI (\"      return Integer\");\n+         WBI (\"   is\");\n+      end if;\n+\n+      --  Initialize and Finalize are not used in No_Run_Time mode\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"      procedure initialize;\");\n+         WBI (\"      pragma Import (C, initialize, \"\"__gnat_initialize\"\");\");\n+         WBI (\"\");\n+         WBI (\"      procedure finalize;\");\n+         WBI (\"      pragma Import (C, finalize, \"\"__gnat_finalize\"\");\");\n+         WBI (\"\");\n+      end if;\n+\n+      --  Deal with declarations for main program case\n+\n+      if not No_Main_Subprogram then\n+\n+         --  To call the main program, we declare it using a pragma Import\n+         --  Ada with the right link name.\n+\n+         --  It might seem more obvious to \"with\" the main program, and call\n+         --  it in the normal Ada manner. We do not do this for three reasons:\n+\n+         --    1. It is more efficient not to recompile the main program\n+         --    2. We are not entitled to assume the source is accessible\n+         --    3. We don't know what options to use to compile it\n+\n+         --  It is really reason 3 that is most critical (indeed we used\n+         --  to generate the \"with\", but several regression tests failed).\n+\n+         WBI (\"\");\n+\n+         if ALIs.Table (ALIs.First).Main_Program = Func then\n+            WBI (\"      Result : Integer;\");\n+            WBI (\"\");\n+            WBI (\"      function Ada_Main_Program return Integer;\");\n+\n+         else\n+            WBI (\"      procedure Ada_Main_Program;\");\n+         end if;\n+\n+         Set_String (\"      pragma Import (Ada, Ada_Main_Program, \"\"\");\n+         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+         Set_Main_Program_Name;\n+         Set_String (\"\"\");\");\n+\n+         Write_Statement_Buffer;\n+         WBI (\"\");\n+      end if;\n+\n+      WBI (\"   begin\");\n+\n+      --  On VxWorks, there are no command line arguments\n+\n+      if VxWorks_Target then\n+         WBI (\"      gnat_argc := 0;\");\n+         WBI (\"      gnat_argv := System.Null_Address;\");\n+         WBI (\"      gnat_envp := System.Null_Address;\");\n+\n+      --  Normal case of command line arguments present\n+\n+      else\n+         WBI (\"      gnat_argc := argc;\");\n+         WBI (\"      gnat_argv := argv;\");\n+         WBI (\"      gnat_envp := envp;\");\n+         WBI (\"\");\n+      end if;\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"      Initialize;\");\n+      end if;\n+\n+      WBI (\"      \" & Ada_Init_Name.all & \";\");\n+\n+      if not No_Main_Subprogram then\n+         WBI (\"      Break_Start;\");\n+\n+         if ALIs.Table (ALIs.First).Main_Program = Proc then\n+            WBI (\"      Ada_Main_Program;\");\n+         else\n+            WBI (\"      Result := Ada_Main_Program;\");\n+         end if;\n+      end if;\n+\n+      --  Adafinal is only called if we have a run time\n+\n+      if not No_Run_Time_Specified then\n+\n+         --  If compiling for the JVM, we directly call Adafinal because\n+         --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n+\n+         if Hostparm.Java_VM then\n+            WBI (\"      System.Standard_Library.Adafinal;\");\n+         else\n+            WBI (\"      Do_Finalize;\");\n+         end if;\n+      end if;\n+\n+      --  Finalize is only called if we have a run time\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"      Finalize;\");\n+      end if;\n+\n+      --  Return result\n+\n+      if No_Main_Subprogram\n+        or else ALIs.Table (ALIs.First).Main_Program = Proc\n+      then\n+         WBI (\"      return (gnat_exit_status);\");\n+      else\n+         WBI (\"      return (Result);\");\n+      end if;\n+\n+      WBI (\"   end;\");\n+   end Gen_Main_Ada;\n+\n+   ----------------\n+   -- Gen_Main_C --\n+   ----------------\n+\n+   procedure Gen_Main_C is\n+      Target         : constant String_Ptr := Target_Name;\n+      VxWorks_Target : constant Boolean :=\n+                         Target (Target'Last - 7 .. Target'Last) = \"vxworks/\";\n+\n+   begin\n+      Set_String (\"int \");\n+      Set_String (Get_Main_Name);\n+\n+      --  On VxWorks, there are no command line arguments\n+\n+      if VxWorks_Target then\n+         Set_String (\" ()\");\n+\n+      --  Normal case with command line arguments present\n+\n+      else\n+         Set_String (\" (argc, argv, envp)\");\n+      end if;\n+\n+      Write_Statement_Buffer;\n+\n+      --  VxWorks doesn't have the notion of argc/argv\n+\n+      if VxWorks_Target then\n+         WBI (\"{\");\n+         WBI (\"   int result;\");\n+         WBI (\"   gnat_argc = 0;\");\n+         WBI (\"   gnat_argv = 0;\");\n+         WBI (\"   gnat_envp = 0;\");\n+\n+      --  Normal case of arguments present\n+\n+      else\n+         WBI (\"    int argc;\");\n+         WBI (\"    char **argv;\");\n+         WBI (\"    char **envp;\");\n+         WBI (\"{\");\n+\n+         if ALIs.Table (ALIs.First).Main_Program = Func then\n+            WBI (\"   int result;\");\n+         end if;\n+\n+         WBI (\"   gnat_argc = argc;\");\n+         WBI (\"   gnat_argv = argv;\");\n+         WBI (\"   gnat_envp = envp;\");\n+         WBI (\" \");\n+      end if;\n+\n+      --  The __gnat_initialize routine is used only if we have a run-time\n+\n+      if not No_Run_Time_Specified then\n+         WBI\n+          (\"   __gnat_initialize ();\");\n+      end if;\n+\n+      WBI (\"   \" & Ada_Init_Name.all & \" ();\");\n+\n+      if not No_Main_Subprogram then\n+\n+         WBI (\"   __gnat_break_start ();\");\n+         WBI (\" \");\n+\n+         --  Output main program name\n+\n+         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+\n+         --  Main program is procedure case\n+\n+         if ALIs.Table (ALIs.First).Main_Program = Proc then\n+            Set_String (\"   \");\n+            Set_Main_Program_Name;\n+            Set_String (\" ();\");\n+            Write_Statement_Buffer;\n+\n+         --  Main program is function case\n+\n+         else -- ALIs.Table (ALIs_First).Main_Program = Func\n+            Set_String (\"   result = \");\n+            Set_Main_Program_Name;\n+            Set_String (\" ();\");\n+            Write_Statement_Buffer;\n+         end if;\n+\n+      end if;\n+\n+      --  Adafinal is called only when we have a run-time\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\" \");\n+         WBI (\"   system__standard_library__adafinal ();\");\n+      end if;\n+\n+      --  The finalize routine is used only if we have a run-time\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"   __gnat_finalize ();\");\n+      end if;\n+\n+      if ALIs.Table (ALIs.First).Main_Program = Func then\n+\n+         if Hostparm.OpenVMS then\n+\n+            --  VMS must use the Posix exit routine in order to get an\n+            --  Unix compatible exit status.\n+\n+            WBI (\"   __posix_exit (result);\");\n+\n+         else\n+            WBI (\"   exit (result);\");\n+         end if;\n+\n+      else\n+\n+         if Hostparm.OpenVMS then\n+            --  VMS must use the Posix exit routine in order to get an\n+            --  Unix compatible exit status.\n+            WBI (\"   __posix_exit (gnat_exit_status);\");\n+         else\n+            WBI (\"   exit (gnat_exit_status);\");\n+         end if;\n+      end if;\n+\n+      WBI (\"}\");\n+   end Gen_Main_C;\n+\n+   ------------------------------\n+   -- Gen_Object_Files_Options --\n+   ------------------------------\n+\n+   procedure Gen_Object_Files_Options is\n+      Lgnat                     : Integer;\n+\n+      procedure Write_Linker_Option;\n+      --  Write binder info linker option.\n+\n+      -------------------------\n+      -- Write_Linker_Option --\n+      -------------------------\n+\n+      procedure Write_Linker_Option is\n+         Start : Natural;\n+         Stop  : Natural;\n+\n+      begin\n+         --  Loop through string, breaking at null's\n+\n+         Start := 1;\n+         while Start < Name_Len loop\n+\n+            --  Find null ending this section\n+\n+            Stop := Start + 1;\n+            while Name_Buffer (Stop) /= ASCII.NUL\n+              and then Stop <= Name_Len loop\n+               Stop := Stop + 1;\n+            end loop;\n+\n+            --  Process section if non-null\n+\n+            if Stop > Start then\n+                  if Output_Linker_Option_List then\n+                     Write_Str (Name_Buffer (Start .. Stop - 1));\n+                     Write_Eol;\n+                  end if;\n+                  Write_Info_Ada_C\n+                    (\"   --   \", \"\", Name_Buffer (Start .. Stop - 1));\n+            end if;\n+\n+            Start := Stop + 1;\n+         end loop;\n+      end Write_Linker_Option;\n+\n+   --  Start of processing for Gen_Object_Files_Options\n+\n+   begin\n+      WBI (\"\");\n+      Write_Info_Ada_C (\"--\", \"/*\", \" BEGIN Object file/option list\");\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+\n+         --  If not spec that has an associated body, then generate a\n+         --  comment giving the name of the corresponding object file.\n+\n+         if Units.Table (Elab_Order.Table (E)).Utype /= Is_Spec then\n+            Get_Name_String\n+              (ALIs.Table\n+                (Units.Table (Elab_Order.Table (E)).My_ALI).Ofile_Full_Name);\n+\n+            --  If the presence of an object file is necessary or if it\n+            --  exists, then use it.\n+\n+            if not Hostparm.Exclude_Missing_Objects\n+              or else\n+                GNAT.OS_Lib.Is_Regular_File (Name_Buffer (1 .. Name_Len))\n+            then\n+               Write_Info_Ada_C (\"   --   \", \"\", Name_Buffer (1 .. Name_Len));\n+               if Output_Object_List then\n+                  Write_Str (Name_Buffer (1 .. Name_Len));\n+                  Write_Eol;\n+               end if;\n+\n+               --  Don't link with the shared library on VMS if an internal\n+               --  filename object is seen. Multiply defined symbols will\n+               --  result.\n+\n+               if Hostparm.OpenVMS\n+                 and then Is_Internal_File_Name\n+                  (ALIs.Table\n+                   (Units.Table (Elab_Order.Table (E)).My_ALI).Sfile)\n+               then\n+                  Opt.Shared_Libgnat := False;\n+               end if;\n+\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Add a \"-Ldir\" for each directory in the object path. We skip this\n+      --  in No_Run_Time mode, where we want more precise control of exactly\n+      --  what goes into the resulting object file\n+\n+      if not No_Run_Time_Specified then\n+         for J in 1 .. Nb_Dir_In_Obj_Search_Path loop\n+            declare\n+               Dir : String_Ptr := Dir_In_Obj_Search_Path (J);\n+\n+            begin\n+               Name_Len := 0;\n+               Add_Str_To_Name_Buffer (\"-L\");\n+               Add_Str_To_Name_Buffer (Dir.all);\n+               Write_Linker_Option;\n+            end;\n+         end loop;\n+      end if;\n+\n+      --  Sort linker options\n+\n+      Sort (Linker_Options.Last, Move_Linker_Option'Access,\n+                                    Lt_Linker_Option'Access);\n+\n+      --  Write user linker options\n+\n+      Lgnat := Linker_Options.Last + 1;\n+\n+      for J in 1 .. Linker_Options.Last loop\n+         if not Linker_Options.Table (J).Internal_File then\n+            Get_Name_String (Linker_Options.Table (J).Name);\n+            Write_Linker_Option;\n+         else\n+            Lgnat := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      if not (No_Run_Time_Specified or else Opt.No_Stdlib) then\n+\n+         Name_Len := 0;\n+\n+         if Opt.Shared_Libgnat then\n+            Add_Str_To_Name_Buffer (\"-shared\");\n+         else\n+            Add_Str_To_Name_Buffer (\"-static\");\n+         end if;\n+\n+         --  Write directly to avoid -K output.\n+\n+         Write_Info_Ada_C (\"   --   \", \"\", Name_Buffer (1 .. Name_Len));\n+\n+         if With_DECGNAT then\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer (\"-ldecgnat\");\n+            Write_Linker_Option;\n+         end if;\n+\n+         if With_GNARL then\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer (\"-lgnarl\");\n+            Write_Linker_Option;\n+         end if;\n+\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (\"-lgnat\");\n+         Write_Linker_Option;\n+\n+      end if;\n+\n+      --  Write internal linker options\n+\n+      for J in Lgnat .. Linker_Options.Last loop\n+         Get_Name_String (Linker_Options.Table (J).Name);\n+         Write_Linker_Option;\n+      end loop;\n+\n+      if Ada_Bind_File then\n+         WBI (\"-- END Object file/option list   \");\n+      else\n+         WBI (\"   END Object file/option list */\");\n+      end if;\n+\n+   end Gen_Object_Files_Options;\n+\n+   ---------------------\n+   -- Gen_Output_File --\n+   ---------------------\n+\n+   procedure Gen_Output_File (Filename : String) is\n+\n+      function Public_Version return Boolean;\n+      --  Return true if the version number contains a 'p'\n+\n+      function Public_Version return Boolean is\n+      begin\n+         for J in Gnat_Version_String'Range loop\n+            if Gnat_Version_String (J) = 'p'  then\n+               return True;\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end Public_Version;\n+\n+   --  Start of processing for Gen_Output_File\n+\n+   begin\n+      --  Override Ada_Bind_File and Bind_Main_Program for Java since\n+      --  JGNAT only supports Ada code, and the main program is already\n+      --  generated by the compiler.\n+\n+      if Hostparm.Java_VM then\n+         Ada_Bind_File := True;\n+         Bind_Main_Program := False;\n+      end if;\n+\n+      --  Override time slice value if -T switch is set\n+\n+      if Time_Slice_Set then\n+         ALIs.Table (ALIs.First).Time_Slice_Value := Opt.Time_Slice_Value;\n+      end if;\n+\n+      --  Count number of elaboration calls\n+\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         if Units.Table (Elab_Order.Table (E)).No_Elab then\n+            null;\n+         else\n+            Num_Elab_Calls := Num_Elab_Calls + 1;\n+         end if;\n+      end loop;\n+\n+      --  Get the time stamp of the former bind for public version warning\n+\n+      if Public_Version then\n+         Record_Time_From_Last_Bind;\n+      end if;\n+\n+      --  Generate output file in appropriate language\n+\n+      if Ada_Bind_File then\n+         Gen_Output_File_Ada (Filename);\n+      else\n+         Gen_Output_File_C (Filename);\n+      end if;\n+\n+      --  Periodically issue a warning when the public version is used on\n+      --  big projects\n+\n+      if Public_Version then\n+         Public_Version_Warning;\n+      end if;\n+   end Gen_Output_File;\n+\n+   -------------------------\n+   -- Gen_Output_File_Ada --\n+   -------------------------\n+\n+   procedure Gen_Output_File_Ada (Filename : String) is\n+\n+      Bfiles : Name_Id;\n+      --  Name of generated bind file (spec)\n+\n+      Bfileb : Name_Id;\n+      --  Name of generated bind file (body)\n+\n+      Ada_Main : constant String := Get_Ada_Main_Name;\n+      --  Name to be used for generated Ada main program. See the body of\n+      --  function Get_Ada_Main_Name for details on the form of the name.\n+\n+      Target         : constant String_Ptr := Target_Name;\n+      VxWorks_Target : constant Boolean :=\n+                         Target (Target'Last - 7 .. Target'Last) = \"vxworks/\";\n+\n+   begin\n+      --  Create spec first\n+\n+      Create_Binder_Output (Filename, 's', Bfiles);\n+\n+      if No_Run_Time_Specified then\n+         WBI (\"pragma No_Run_Time;\");\n+      end if;\n+\n+      --  Generate with of System so we can reference System.Address, note\n+      --  that such a reference is safe even in No_Run_Time mode, since we\n+      --  do not need any run-time code for such a reference, and we output\n+      --  a pragma No_Run_Time for this compilation above.\n+\n+      WBI (\"with System;\");\n+\n+      --  Generate with of System.Initialize_Scalars if active\n+\n+      if Initialize_Scalars_Used then\n+         WBI (\"with System.Scalar_Values;\");\n+      end if;\n+\n+      Resolve_Binder_Options;\n+\n+      if not No_Run_Time_Specified then\n+\n+         --  Usually, adafinal is called using a pragma Import C. Since\n+         --  Import C doesn't have the same semantics for JGNAT, we use\n+         --  standard Ada.\n+\n+         if Hostparm.Java_VM then\n+            WBI (\"with System.Standard_Library;\");\n+         end if;\n+      end if;\n+\n+      WBI (\"package \" & Ada_Main & \" is\");\n+\n+      --  Main program case\n+\n+      if Bind_Main_Program then\n+\n+         --  Generate argc/argv stuff\n+\n+         WBI (\"\");\n+         WBI (\"   gnat_argc : Integer;\");\n+         WBI (\"   gnat_argv : System.Address;\");\n+         WBI (\"   gnat_envp : System.Address;\");\n+\n+         --  If we have a run time present, these variables are in the\n+         --  runtime data area for easy access from the runtime\n+\n+         if not No_Run_Time_Specified then\n+            WBI (\"\");\n+            WBI (\"   pragma Import (C, gnat_argc);\");\n+            WBI (\"   pragma Import (C, gnat_argv);\");\n+            WBI (\"   pragma Import (C, gnat_envp);\");\n+         end if;\n+\n+         --  Define exit status. Again in normal mode, this is in the\n+         --  run-time library, and is initialized there, but in the no\n+         --  run time case, the variable is here and initialized here.\n+\n+         WBI (\"\");\n+\n+         if No_Run_Time_Specified then\n+            WBI (\"   gnat_exit_status : Integer := 0;\");\n+         else\n+            WBI (\"   gnat_exit_status : Integer;\");\n+            WBI (\"   pragma Import (C, gnat_exit_status);\");\n+         end if;\n+      end if;\n+\n+      --  Generate the GNAT_Version info only for the main program. Otherwise,\n+      --  it can lead under some circumstances to a symbol duplication during\n+      --  the link (for instance when a C program uses 2 Ada libraries)\n+\n+      if Bind_Main_Program then\n+         WBI (\"\");\n+         WBI (\"   GNAT_Version : constant String :=\");\n+         WBI (\"                    \"\"GNAT Version: \" &\n+                                   Gnat_Version_String & \"\"\";\");\n+         WBI (\"   pragma Export (C, GNAT_Version, \"\"__gnat_version\"\");\");\n+      end if;\n+\n+      --  No need to generate a finalization routine if there is no\n+      --  runtime, since there is nothing to do in this case.\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"\");\n+         WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n+         WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n+              Ada_Final_Name.all & \"\"\");\");\n+      end if;\n+\n+      WBI (\"\");\n+      WBI (\"   procedure \" & Ada_Init_Name.all & \";\");\n+      WBI (\"   pragma Export (C, \" & Ada_Init_Name.all & \", \"\"\" &\n+           Ada_Init_Name.all & \"\"\");\");\n+\n+      if Bind_Main_Program then\n+\n+         --  If we have a run time, then Break_Start is defined there, but\n+         --  if there is no run-time, Break_Start is defined in this file.\n+\n+         WBI (\"\");\n+         WBI (\"   procedure Break_Start;\");\n+\n+         if No_Run_Time_Specified then\n+            WBI (\"   pragma Export (C, Break_Start, \"\"__gnat_break_start\"\");\");\n+         else\n+            WBI (\"   pragma Import (C, Break_Start, \"\"__gnat_break_start\"\");\");\n+         end if;\n+\n+         WBI (\"\");\n+         WBI (\"   function \" & Get_Main_Name);\n+\n+         --  Generate argument list (except on VxWorks, where none is present)\n+\n+         if not VxWorks_Target then\n+            WBI (\"     (argc : Integer;\");\n+            WBI (\"      argv : System.Address;\");\n+            WBI (\"      envp : System.Address)\");\n+         end if;\n+\n+         WBI (\"      return Integer;\");\n+         WBI (\"   pragma Export (C, \" & Get_Main_Name & \", \"\"\" &\n+           Get_Main_Name & \"\"\");\");\n+      end if;\n+\n+      if Initialize_Scalars_Used then\n+         Gen_Scalar_Values;\n+      end if;\n+\n+      Gen_Versions_Ada;\n+      Gen_Elab_Order_Ada;\n+\n+      --  Spec is complete\n+\n+      WBI (\"\");\n+      WBI (\"end \" & Ada_Main & \";\");\n+      Close_Binder_Output;\n+\n+      --  Prepare to write body\n+\n+      Create_Binder_Output (Filename, 'b', Bfileb);\n+\n+      --  Output Source_File_Name pragmas which look like\n+\n+      --    pragma Source_File_Name (Ada_Main, Spec_File_Name => \"sss\");\n+      --    pragma Source_File_Name (Ada_Main, Body_File_Name => \"bbb\");\n+\n+      --  where sss/bbb are the spec/body file names respectively\n+\n+      Get_Name_String (Bfiles);\n+      Name_Buffer (Name_Len + 1 .. Name_Len + 3) := \"\"\");\";\n+\n+      WBI (\"pragma Source_File_Name (\" &\n+           Ada_Main &\n+           \", Spec_File_Name => \"\"\" &\n+           Name_Buffer (1 .. Name_Len + 3));\n+\n+      Get_Name_String (Bfileb);\n+      Name_Buffer (Name_Len + 1 .. Name_Len + 3) := \"\"\");\";\n+\n+      WBI (\"pragma Source_File_Name (\" &\n+           Ada_Main &\n+           \", Body_File_Name => \"\"\" &\n+           Name_Buffer (1 .. Name_Len + 3));\n+\n+      WBI (\"\");\n+      WBI (\"package body \" & Ada_Main & \" is\");\n+\n+      --  Import the finalization procedure only if there is a runtime.\n+\n+      if not No_Run_Time_Specified then\n+\n+         --  In the Java case, pragma Import C cannot be used, so the\n+         --  standard Ada constructs will be used instead.\n+\n+         if not Hostparm.Java_VM then\n+            WBI (\"\");\n+            WBI (\"   procedure Do_Finalize;\");\n+            WBI\n+              (\"   pragma Import (C, Do_Finalize, \" &\n+               \"\"\"system__standard_library__adafinal\"\");\");\n+            WBI (\"\");\n+         end if;\n+      end if;\n+\n+      Gen_Adainit_Ada;\n+\n+      --  No need to generate a finalization routine if there is no\n+      --  runtime, since there is nothing to do in this case.\n+\n+      if not No_Run_Time_Specified then\n+         Gen_Adafinal_Ada;\n+      end if;\n+\n+      if Bind_Main_Program then\n+\n+         --  In No_Run_Time mode, generate dummy body for Break_Start\n+\n+         if No_Run_Time_Specified then\n+            WBI (\"\");\n+            WBI (\"   procedure Break_Start is\");\n+            WBI (\"   begin\");\n+            WBI (\"      null;\");\n+            WBI (\"   end;\");\n+         end if;\n+\n+         Gen_Main_Ada;\n+      end if;\n+\n+      --  Output object file list and the Ada body is complete\n+\n+      Gen_Object_Files_Options;\n+\n+      WBI (\"\");\n+      WBI (\"end \" & Ada_Main & \";\");\n+\n+      Close_Binder_Output;\n+   end Gen_Output_File_Ada;\n+\n+   -----------------------\n+   -- Gen_Output_File_C --\n+   -----------------------\n+\n+   procedure Gen_Output_File_C (Filename : String) is\n+\n+      Bfile : Name_Id;\n+      --  Name of generated bind file\n+\n+   begin\n+      Create_Binder_Output (Filename, 'c', Bfile);\n+\n+      Resolve_Binder_Options;\n+\n+      WBI (\"#ifdef __STDC__\");\n+      WBI (\"#define PARAMS(paramlist) paramlist\");\n+      WBI (\"#else\");\n+      WBI (\"#define PARAMS(paramlist) ()\");\n+      WBI (\"#endif\");\n+      WBI (\"\");\n+\n+      WBI (\"extern void __gnat_set_globals \");\n+      WBI (\" PARAMS ((int, int, int, int, int, int, \");\n+      WBI (\"          void (*) PARAMS ((void)), int, int));\");\n+      WBI (\"extern void \" & Ada_Final_Name.all & \" PARAMS ((void));\");\n+      WBI (\"extern void \" & Ada_Init_Name.all & \" PARAMS ((void));\");\n+\n+      WBI (\"extern void system__standard_library__adafinal PARAMS ((void));\");\n+\n+      if not No_Main_Subprogram then\n+         WBI (\"extern int main PARAMS ((int, char **, char **));\");\n+         if Hostparm.OpenVMS then\n+            WBI (\"extern void __posix_exit PARAMS ((int));\");\n+         else\n+            WBI (\"extern void exit PARAMS ((int));\");\n+         end if;\n+\n+         WBI (\"extern void __gnat_break_start PARAMS ((void));\");\n+         Set_String (\"extern \");\n+\n+         if ALIs.Table (ALIs.First).Main_Program = Proc then\n+            Set_String (\"void \");\n+         else\n+            Set_String (\"int \");\n+         end if;\n+\n+         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+         Set_Main_Program_Name;\n+         Set_String (\" PARAMS ((void));\");\n+         Write_Statement_Buffer;\n+      end if;\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"extern void __gnat_initialize PARAMS ((void));\");\n+         WBI (\"extern void __gnat_finalize PARAMS ((void));\");\n+         WBI (\"extern void __gnat_install_handler PARAMS ((void));\");\n+      end if;\n+\n+      WBI (\"\");\n+\n+      Gen_Elab_Defs_C;\n+\n+      --  Imported variable used to track elaboration/finalization phase.\n+      --  Used only when we have a runtime.\n+\n+      if not No_Run_Time_Specified then\n+         WBI (\"extern int  __gnat_handler_installed;\");\n+         WBI (\"\");\n+      end if;\n+\n+      --  Write argv/argc stuff if main program case\n+\n+      if Bind_Main_Program then\n+\n+         --  In the normal case, these are in the runtime library\n+\n+         if not No_Run_Time_Specified then\n+            WBI (\"extern int gnat_argc;\");\n+            WBI (\"extern char **gnat_argv;\");\n+            WBI (\"extern char **gnat_envp;\");\n+            WBI (\"extern int gnat_exit_status;\");\n+\n+         --  In the No_Run_Time case, they are right in the binder file\n+         --  and we initialize gnat_exit_status in the declaration.\n+\n+         else\n+            WBI (\"int gnat_argc;\");\n+            WBI (\"char **gnat_argv;\");\n+            WBI (\"char **gnat_envp;\");\n+            WBI (\"int gnat_exit_status = 0;\");\n+         end if;\n+\n+         WBI (\"\");\n+      end if;\n+\n+      --  In no run-time mode, the __gnat_break_start routine (for the\n+      --  debugger to get initial control) is defined in this file.\n+\n+      if No_Run_Time_Specified then\n+         WBI (\"\");\n+         WBI (\"void __gnat_break_start () {}\");\n+      end if;\n+\n+      --  Generate the __gnat_version info only for the main program.\n+      --  Otherwise, it can lead under some circumstances to a symbol\n+      --  duplication during the link (for instance when a C program\n+      --  uses 2 Ada libraries)\n+\n+      if Bind_Main_Program then\n+         WBI (\"\");\n+         WBI (\"char __gnat_version[] = \"\"GNAT Version: \" &\n+                                   Gnat_Version_String & \"\"\";\");\n+      end if;\n+\n+      --  Generate the adafinal routine. In no runtime mode, this is\n+      --  not needed, since there is no finalization to do.\n+\n+      if not No_Run_Time_Specified then\n+         Gen_Adafinal_C;\n+      end if;\n+\n+      Gen_Adainit_C;\n+\n+      --  Main is only present for Ada main case\n+\n+      if Bind_Main_Program then\n+         Gen_Main_C;\n+      end if;\n+\n+      --  Scalar values, versions and object files needed in both cases\n+\n+      if Initialize_Scalars_Used then\n+         Gen_Scalar_Values;\n+      end if;\n+\n+      Gen_Versions_C;\n+      Gen_Elab_Order_C;\n+      Gen_Object_Files_Options;\n+\n+      --  C binder output is complete\n+\n+      Close_Binder_Output;\n+   end Gen_Output_File_C;\n+\n+   -----------------------\n+   -- Gen_Scalar_Values --\n+   -----------------------\n+\n+   procedure Gen_Scalar_Values is\n+\n+      --  Strings to hold hex values of initialization constants. Note that\n+      --  we store these strings in big endian order, but they are actually\n+      --  used to initialize integer values, so the actual generated data\n+      --  will automaticaly have the right endianess.\n+\n+      IS_Is1 : String (1 .. 2);\n+      IS_Is2 : String (1 .. 4);\n+      IS_Is4 : String (1 .. 8);\n+      IS_Is8 : String (1 .. 16);\n+      IS_Iu1 : String (1 .. 2);\n+      IS_Iu2 : String (1 .. 4);\n+      IS_Iu4 : String (1 .. 8);\n+      IS_Iu8 : String (1 .. 16);\n+      IS_Isf : String (1 .. 8);\n+      IS_Ifl : String (1 .. 8);\n+      IS_Ilf : String (1 .. 16);\n+\n+      --  The string for Long_Long_Float is special. This is used only on the\n+      --  ia32 with 80-bit extended float (stored in 96 bits by gcc). The\n+      --  value here is represented little-endian, since that's the only way\n+      --  it is ever generated (this is not used on big-endian machines.\n+\n+      IS_Ill : String (1 .. 24);\n+\n+   begin\n+      --  -Sin (invalid values)\n+\n+      if Opt.Initialize_Scalars_Mode = 'I' then\n+         IS_Is1 := \"80\";\n+         IS_Is2 := \"8000\";\n+         IS_Is4 := \"80000000\";\n+         IS_Is8 := \"8000000000000000\";\n+         IS_Iu1 := \"FF\";\n+         IS_Iu2 := \"FFFF\";\n+         IS_Iu4 := \"FFFFFFFF\";\n+         IS_Iu8 := \"FFFFFFFFFFFFFFFF\";\n+         IS_Isf := IS_Iu4;\n+         IS_Ifl := IS_Iu4;\n+         IS_Ilf := IS_Iu8;\n+         IS_Ill := \"00000000000000C0FFFF0000\";\n+\n+      --  -Slo (low values)\n+\n+      elsif Opt.Initialize_Scalars_Mode = 'L' then\n+         IS_Is1 := \"80\";\n+         IS_Is2 := \"8000\";\n+         IS_Is4 := \"80000000\";\n+         IS_Is8 := \"8000000000000000\";\n+         IS_Iu1 := \"00\";\n+         IS_Iu2 := \"0000\";\n+         IS_Iu4 := \"00000000\";\n+         IS_Iu8 := \"0000000000000000\";\n+         IS_Isf := \"FF800000\";\n+         IS_Ifl := IS_Isf;\n+         IS_Ilf := \"FFF0000000000000\";\n+         IS_Ill := \"0000000000000080FFFF0000\";\n+\n+      --  -Shi (high values)\n+\n+      elsif Opt.Initialize_Scalars_Mode = 'H' then\n+         IS_Is1 := \"7F\";\n+         IS_Is2 := \"7FFF\";\n+         IS_Is4 := \"7FFFFFFF\";\n+         IS_Is8 := \"7FFFFFFFFFFFFFFF\";\n+         IS_Iu1 := \"FF\";\n+         IS_Iu2 := \"FFFF\";\n+         IS_Iu4 := \"FFFFFFFF\";\n+         IS_Iu8 := \"FFFFFFFFFFFFFFFF\";\n+         IS_Isf := \"7F800000\";\n+         IS_Ifl := IS_Isf;\n+         IS_Ilf := \"7FF0000000000000\";\n+         IS_Ill := \"0000000000000080FF7F0000\";\n+\n+      --  -Shh (hex byte)\n+\n+      else pragma Assert (Opt.Initialize_Scalars_Mode = 'X');\n+         IS_Is1 (1  .. 2)  := Opt.Initialize_Scalars_Val;\n+         IS_Is2 (1  .. 2)  := Opt.Initialize_Scalars_Val;\n+         IS_Is2 (3  .. 4)  := Opt.Initialize_Scalars_Val;\n+\n+         for J in 1 .. 4 loop\n+            IS_Is4 (2 * J - 1 .. 2 * J) := Opt.Initialize_Scalars_Val;\n+         end loop;\n+\n+         for J in 1 .. 8 loop\n+            IS_Is8 (2 * J - 1 .. 2 * J) := Opt.Initialize_Scalars_Val;\n+         end loop;\n+\n+         IS_Iu1 := IS_Is1;\n+         IS_Iu2 := IS_Is2;\n+         IS_Iu4 := IS_Is4;\n+         IS_Iu8 := IS_Is8;\n+\n+         IS_Isf := IS_Is4;\n+         IS_Ifl := IS_Is4;\n+         IS_Ilf := IS_Is8;\n+\n+         for J in 1 .. 12 loop\n+            IS_Ill (2 * J - 1 .. 2 * J) := Opt.Initialize_Scalars_Val;\n+         end loop;\n+      end if;\n+\n+      --  Generate output, Ada case\n+\n+      if Ada_Bind_File then\n+         WBI (\"\");\n+\n+         Set_String (\"   IS_Is1 : constant System.Scalar_Values.Byte1 := 16#\");\n+         Set_String (IS_Is1);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Is2 : constant System.Scalar_Values.Byte2 := 16#\");\n+         Set_String (IS_Is2);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Is4 : constant System.Scalar_Values.Byte4 := 16#\");\n+         Set_String (IS_Is4);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Is8 : constant System.Scalar_Values.Byte8 := 16#\");\n+         Set_String (IS_Is8);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Iu1 : constant System.Scalar_Values.Byte1 := 16#\");\n+         Set_String (IS_Iu1);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Iu2 : constant System.Scalar_Values.Byte2 := 16#\");\n+         Set_String (IS_Iu2);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Iu4 : constant System.Scalar_Values.Byte4 := 16#\");\n+         Set_String (IS_Iu4);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Iu8 : constant System.Scalar_Values.Byte8 := 16#\");\n+         Set_String (IS_Iu8);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Isf : constant System.Scalar_Values.Byte4 := 16#\");\n+         Set_String (IS_Isf);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Ifl : constant System.Scalar_Values.Byte4 := 16#\");\n+         Set_String (IS_Ifl);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         Set_String (\"   IS_Ilf : constant System.Scalar_Values.Byte8 := 16#\");\n+         Set_String (IS_Ilf);\n+         Write_Statement_Buffer (\"#;\");\n+\n+         --  Special case of Long_Long_Float. This is a 10-byte value used\n+         --  only on the x86. We could omit it for other architectures, but\n+         --  we don't easily have that kind of target specialization in the\n+         --  binder, and it's only 10 bytes, and only if -Sxx is used. Note\n+         --  that for architectures where Long_Long_Float is the same as\n+         --  Long_Float, the expander uses the Long_Float constant for the\n+         --  initializations of Long_Long_Float values.\n+\n+         WBI (\"   IS_Ill : constant array (1 .. 12) of\");\n+         WBI (\"              System.Scalar_Values.Byte1 := (\");\n+         Set_String (\"               \");\n+\n+         for J in 1 .. 6 loop\n+            Set_String (\" 16#\");\n+            Set_Char (IS_Ill (2 * J - 1));\n+            Set_Char (IS_Ill (2 * J));\n+            Set_String (\"#,\");\n+         end loop;\n+\n+         Write_Statement_Buffer;\n+         Set_String (\"               \");\n+\n+         for J in 7 .. 12 loop\n+            Set_String (\" 16#\");\n+            Set_Char (IS_Ill (2 * J - 1));\n+            Set_Char (IS_Ill (2 * J));\n+\n+            if J = 12 then\n+               Set_String (\"#);\");\n+            else\n+               Set_String (\"#,\");\n+            end if;\n+         end loop;\n+\n+         Write_Statement_Buffer;\n+\n+         --  Output export statements to export to System.Scalar_Values\n+\n+         WBI (\"\");\n+\n+         WBI (\"   pragma Export (Ada, IS_Is1, \"\"__gnat_Is1\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Is2, \"\"__gnat_Is2\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Is4, \"\"__gnat_Is4\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Is8, \"\"__gnat_Is8\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Iu1, \"\"__gnat_Iu1\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Iu2, \"\"__gnat_Iu2\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Iu4, \"\"__gnat_Iu4\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Iu8, \"\"__gnat_Iu8\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Isf, \"\"__gnat_Isf\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Ifl, \"\"__gnat_Ifl\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Ilf, \"\"__gnat_Ilf\"\");\");\n+         WBI (\"   pragma Export (Ada, IS_Ill, \"\"__gnat_Ill\"\");\");\n+\n+      --  Generate output C case\n+\n+      else\n+         --  The lines we generate in this case are of the form\n+         --    typ __gnat_I?? = 0x??;\n+         --  where typ is appropriate to the length\n+\n+         WBI (\"\");\n+\n+         Set_String (\"unsigned char      __gnat_Is1 = 0x\");\n+         Set_String (IS_Is1);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"unsigned short     __gnat_Is2 = 0x\");\n+         Set_String (IS_Is2);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"unsigned           __gnat_Is4 = 0x\");\n+         Set_String (IS_Is4);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"long long unsigned __gnat_Is8 = 0x\");\n+         Set_String (IS_Is8);\n+         Write_Statement_Buffer (\"LL;\");\n+\n+         Set_String (\"unsigned char      __gnat_Iu1 = 0x\");\n+         Set_String (IS_Is1);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"unsigned short     __gnat_Iu2 = 0x\");\n+         Set_String (IS_Is2);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"unsigned           __gnat_Iu4 = 0x\");\n+         Set_String (IS_Is4);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"long long unsigned __gnat_Iu8 = 0x\");\n+         Set_String (IS_Is8);\n+         Write_Statement_Buffer (\"LL;\");\n+\n+         Set_String (\"unsigned           __gnat_Isf = 0x\");\n+         Set_String (IS_Isf);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"unsigned           __gnat_Ifl = 0x\");\n+         Set_String (IS_Ifl);\n+         Write_Statement_Buffer (\";\");\n+\n+         Set_String (\"long long unsigned __gnat_Ilf = 0x\");\n+         Set_String (IS_Ilf);\n+         Write_Statement_Buffer (\"LL;\");\n+\n+         --  For Long_Long_Float, we generate\n+         --    char __gnat_Ill[12] = {0x??, 0x??, 0x??, 0x??, 0x??, 0x??,\n+         --                           0x??, 0x??, 0x??, 0x??, 0x??, 0x??);\n+\n+         Set_String (\"unsigned char      __gnat_Ill[12] = {\");\n+\n+         for J in 1 .. 6 loop\n+            Set_String (\"0x\");\n+            Set_Char (IS_Ill (2 * J - 1));\n+            Set_Char (IS_Ill (2 * J));\n+            Set_String (\", \");\n+         end loop;\n+\n+         Write_Statement_Buffer;\n+         Set_String (\"                                     \");\n+\n+         for J in 7 .. 12 loop\n+            Set_String (\"0x\");\n+            Set_Char (IS_Ill (2 * J - 1));\n+            Set_Char (IS_Ill (2 * J));\n+\n+            if J = 12 then\n+               Set_String (\"};\");\n+            else\n+               Set_String (\", \");\n+            end if;\n+         end loop;\n+\n+         Write_Statement_Buffer;\n+      end if;\n+   end Gen_Scalar_Values;\n+\n+   ----------------------\n+   -- Gen_Versions_Ada --\n+   ----------------------\n+\n+   --  This routine generates two sets of lines. The first set has the form:\n+\n+   --    unnnnn : constant Integer := 16#hhhhhhhh#;\n+\n+   --  The second set has the form\n+\n+   --    pragma Export (C, unnnnn, unam);\n+\n+   --  for each unit, where unam is the unit name suffixed by either B or\n+   --  S for body or spec, with dots replaced by double underscores, and\n+   --  hhhhhhhh is the version number, and nnnnn is a 5-digits serial number.\n+\n+   procedure Gen_Versions_Ada is\n+      Ubuf : String (1 .. 6) := \"u00000\";\n+\n+      procedure Increment_Ubuf;\n+      --  Little procedure to increment the serial number\n+\n+      procedure Increment_Ubuf is\n+      begin\n+         for J in reverse Ubuf'Range loop\n+            Ubuf (J) := Character'Succ (Ubuf (J));\n+            exit when Ubuf (J) <= '9';\n+            Ubuf (J) := '0';\n+         end loop;\n+      end Increment_Ubuf;\n+\n+   --  Start of processing for Gen_Versions_Ada\n+\n+   begin\n+      if Bind_For_Library then\n+\n+         --  When building libraries, the version number of each unit can\n+         --  not be computed, since the binder does not know the full list\n+         --  of units. Therefore, the 'Version and 'Body_Version\n+         --  attributes can not supported in this case.\n+\n+         return;\n+      end if;\n+\n+      WBI (\"\");\n+\n+      WBI (\"   type Version_32 is mod 2 ** 32;\");\n+      for U in Units.First .. Units.Last loop\n+         Increment_Ubuf;\n+         WBI (\"   \" & Ubuf & \" : constant Version_32 := 16#\" &\n+              Units.Table (U).Version & \"#;\");\n+      end loop;\n+\n+      WBI (\"\");\n+      Ubuf := \"u00000\";\n+\n+      for U in Units.First .. Units.Last loop\n+         Increment_Ubuf;\n+         Set_String (\"   pragma Export (C, \");\n+         Set_String (Ubuf);\n+         Set_String (\", \"\"\");\n+\n+         Get_Name_String (Units.Table (U).Uname);\n+\n+         for K in 1 .. Name_Len loop\n+            if Name_Buffer (K) = '.' then\n+               Set_Char ('_');\n+               Set_Char ('_');\n+\n+            elsif Name_Buffer (K) = '%' then\n+               exit;\n+\n+            else\n+               Set_Char (Name_Buffer (K));\n+            end if;\n+         end loop;\n+\n+         if Name_Buffer (Name_Len) = 's' then\n+            Set_Char ('S');\n+         else\n+            Set_Char ('B');\n+         end if;\n+\n+         Set_String (\"\"\");\");\n+         Write_Statement_Buffer;\n+      end loop;\n+\n+   end Gen_Versions_Ada;\n+\n+   --------------------\n+   -- Gen_Versions_C --\n+   --------------------\n+\n+   --  This routine generates a line of the form:\n+\n+   --    unsigned unam = 0xhhhhhhhh;\n+\n+   --  for each unit, where unam is the unit name suffixed by either B or\n+   --  S for body or spec, with dots replaced by double underscores.\n+\n+   procedure Gen_Versions_C is\n+   begin\n+      if Bind_For_Library then\n+\n+         --  When building libraries, the version number of each unit can\n+         --  not be computed, since the binder does not know the full list\n+         --  of units. Therefore, the 'Version and 'Body_Version\n+         --  attributes can not supported.\n+\n+         return;\n+      end if;\n+\n+      for U in Units.First .. Units.Last loop\n+         Set_String (\"unsigned \");\n+\n+         Get_Name_String (Units.Table (U).Uname);\n+\n+         for K in 1 .. Name_Len loop\n+            if Name_Buffer (K) = '.' then\n+               Set_String (\"__\");\n+\n+            elsif Name_Buffer (K) = '%' then\n+               exit;\n+\n+            else\n+               Set_Char (Name_Buffer (K));\n+            end if;\n+         end loop;\n+\n+         if Name_Buffer (Name_Len) = 's' then\n+            Set_Char ('S');\n+         else\n+            Set_Char ('B');\n+         end if;\n+\n+         Set_String (\" = 0x\");\n+         Set_String (Units.Table (U).Version);\n+         Set_Char   (';');\n+         Write_Statement_Buffer;\n+      end loop;\n+\n+   end Gen_Versions_C;\n+\n+   -----------------------\n+   -- Get_Ada_Main_Name --\n+   -----------------------\n+\n+   function Get_Ada_Main_Name return String is\n+      Suffix : constant String := \"_00\";\n+      Name   : String (1 .. Opt.Ada_Main_Name.all'Length + Suffix'Length) :=\n+                 Opt.Ada_Main_Name.all & Suffix;\n+      Nlen   : Natural;\n+\n+   begin\n+      --  The main program generated by JGNAT expects a package called\n+      --  ada_<main procedure>.\n+\n+      if Hostparm.Java_VM then\n+         --  Get main program name\n+\n+         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+\n+         --  Remove the %b\n+\n+         return \"ada_\" & Name_Buffer (1 .. Name_Len - 2);\n+      end if;\n+\n+      --  This loop tries the following possibilities in order\n+      --    <Ada_Main>\n+      --    <Ada_Main>_01\n+      --    <Ada_Main>_02\n+      --    ..\n+      --    <Ada_Main>_99\n+      --  where <Ada_Main> is equal to Opt.Ada_Main_Name. By default,\n+      --  it is set to 'ada_main'.\n+\n+      for J in 0 .. 99 loop\n+         if J = 0 then\n+            Nlen := Name'Length - Suffix'Length;\n+         else\n+            Nlen := Name'Length;\n+            Name (Name'Last) := Character'Val (J mod 10 + Character'Pos ('0'));\n+            Name (Name'Last - 1) :=\n+              Character'Val (J /   10 + Character'Pos ('0'));\n+         end if;\n+\n+         for K in ALIs.First .. ALIs.Last loop\n+            for L in ALIs.Table (K).First_Unit .. ALIs.Table (K).Last_Unit loop\n+\n+               --  Get unit name, removing %b or %e at end\n+\n+               Get_Name_String (Units.Table (L).Uname);\n+               Name_Len := Name_Len - 2;\n+\n+               if Name_Buffer (1 .. Name_Len) = Name (1 .. Nlen) then\n+                  goto Continue;\n+               end if;\n+            end loop;\n+         end loop;\n+\n+         return Name (1 .. Nlen);\n+\n+      <<Continue>>\n+         null;\n+      end loop;\n+\n+      --  If we fall through, just use a peculiar unlikely name\n+\n+      return (\"Qwertyuiop\");\n+   end Get_Ada_Main_Name;\n+\n+   -------------------\n+   -- Get_Main_Name --\n+   -------------------\n+\n+   function Get_Main_Name return String is\n+      Target         : constant String_Ptr := Target_Name;\n+      VxWorks_Target : constant Boolean :=\n+                         Target (Target'Last - 7 .. Target'Last) = \"vxworks/\";\n+\n+   begin\n+      --  Explicit name given with -M switch\n+\n+      if Bind_Alternate_Main_Name then\n+         return Alternate_Main_Name.all;\n+\n+      --  Case of main program name to be used directly\n+\n+      elsif VxWorks_Target then\n+\n+         --  Get main program name\n+\n+         Get_Name_String (Units.Table (First_Unit_Entry).Uname);\n+\n+         --  If this is a child name, return only the name of the child,\n+         --  since we can't have dots in a nested program name. Note that\n+         --  we do not include the %b at the end of the unit name.\n+\n+         for J in reverse 1 .. Name_Len - 3 loop\n+            if J = 1 or else Name_Buffer (J - 1) = '.' then\n+               return Name_Buffer (J .. Name_Len - 2);\n+            end if;\n+         end loop;\n+\n+         raise Program_Error; -- impossible exit\n+\n+      --  Case where \"main\" is to be used as default\n+\n+      else\n+         return \"main\";\n+      end if;\n+   end Get_Main_Name;\n+\n+   ----------------------\n+   -- Lt_Linker_Option --\n+   ----------------------\n+\n+   function Lt_Linker_Option (Op1, Op2 : Natural) return Boolean is\n+   begin\n+      if Linker_Options.Table (Op1).Internal_File\n+           /=\n+         Linker_Options.Table (Op2).Internal_File\n+      then\n+         return Linker_Options.Table (Op1).Internal_File\n+                  <\n+                 Linker_Options.Table (Op2).Internal_File;\n+      else\n+         if Units.Table (Linker_Options.Table (Op1).Unit).Elab_Position\n+              /=\n+            Units.Table (Linker_Options.Table (Op2).Unit).Elab_Position\n+         then\n+            return Units.Table (Linker_Options.Table (Op1).Unit).Elab_Position\n+                     >\n+                   Units.Table (Linker_Options.Table (Op2).Unit).Elab_Position;\n+\n+         else\n+            return Linker_Options.Table (Op1).Original_Pos\n+                     <\n+                   Linker_Options.Table (Op2).Original_Pos;\n+         end if;\n+      end if;\n+   end Lt_Linker_Option;\n+\n+   ------------------------\n+   -- Move_Linker_Option --\n+   ------------------------\n+\n+   procedure Move_Linker_Option (From : Natural; To : Natural) is\n+   begin\n+      Linker_Options.Table (To) := Linker_Options.Table (From);\n+   end Move_Linker_Option;\n+\n+   ----------------------------\n+   -- Public_Version_Warning --\n+   ----------------------------\n+\n+   procedure Public_Version_Warning is\n+\n+      Time : Int := Time_From_Last_Bind;\n+\n+      --  Constants to help defining periods\n+\n+      Hour : constant := 60;\n+      Day  : constant := 24 * Hour;\n+\n+      Never : constant := Integer'Last;\n+      --  Special value indicating no warnings should be given\n+\n+      --  Constants defining when the warning is issued. Programs with more\n+      --  than Large Units will issue a warning every Period_Large amount of\n+      --  time. Smaller programs will generate a warning every Period_Small\n+      --  amount of time.\n+\n+      Large : constant := 20;\n+      --  Threshold for considering a program small or large\n+\n+      Period_Large : constant := Day;\n+      --  Periodic warning time for large programs\n+\n+      Period_Small : constant := Never;\n+      --  Periodic warning time for small programs\n+\n+      Nb_Unit : Int;\n+\n+   begin\n+      --  Compute the number of units that are not GNAT internal files\n+\n+      Nb_Unit := 0;\n+      for A in ALIs.First .. ALIs.Last loop\n+         if not Is_Internal_File_Name (ALIs.Table (A).Sfile) then\n+            Nb_Unit := Nb_Unit + 1;\n+         end if;\n+      end loop;\n+\n+      --  Do not emit the message if the last message was emitted in the\n+      --  specified period taking into account the number of units.\n+\n+      if Nb_Unit < Large and then Time <= Period_Small then\n+         return;\n+\n+      elsif Time <= Period_Large then\n+         return;\n+      end if;\n+\n+      Write_Eol;\n+      Write_Str (\"IMPORTANT NOTICE:\");\n+      Write_Eol;\n+      Write_Str (\"    This version of GNAT is unsupported\"\n+        &                        \" and comes with absolutely no warranty.\");\n+      Write_Eol;\n+      Write_Str (\"    If you intend to evaluate or use GNAT for building \"\n+        &                                       \"commercial applications,\");\n+      Write_Eol;\n+      Write_Str (\"    please consult http://www.gnat.com/ for information\");\n+      Write_Eol;\n+      Write_Str (\"    on the GNAT Professional product line.\");\n+      Write_Eol;\n+      Write_Eol;\n+   end Public_Version_Warning;\n+\n+   ----------------------------\n+   -- Resolve_Binder_Options --\n+   ----------------------------\n+\n+   procedure Resolve_Binder_Options is\n+   begin\n+      for E in Elab_Order.First .. Elab_Order.Last loop\n+         Get_Name_String (Units.Table (Elab_Order.Table (E)).Uname);\n+\n+         --  The procedure of looking for specific packages and setting\n+         --  flags is very wrong, but there isn't a good alternative at\n+         --  this time.\n+\n+         if Name_Buffer (1 .. 19) = \"system.os_interface\" then\n+            With_GNARL := True;\n+         end if;\n+\n+         if Hostparm.OpenVMS and then Name_Buffer (1 .. 3) = \"dec\" then\n+            With_DECGNAT := True;\n+         end if;\n+      end loop;\n+   end Resolve_Binder_Options;\n+\n+   --------------\n+   -- Set_Char --\n+   --------------\n+\n+   procedure Set_Char (C : Character) is\n+   begin\n+      Last := Last + 1;\n+      Statement_Buffer (Last) := C;\n+   end Set_Char;\n+\n+   -------------\n+   -- Set_Int --\n+   -------------\n+\n+   procedure Set_Int (N : Int) is\n+   begin\n+      if N < 0 then\n+         Set_String (\"-\");\n+         Set_Int (-N);\n+\n+      else\n+         if N > 9 then\n+            Set_Int (N / 10);\n+         end if;\n+\n+         Last := Last + 1;\n+         Statement_Buffer (Last) :=\n+           Character'Val (N mod 10 + Character'Pos ('0'));\n+      end if;\n+   end Set_Int;\n+\n+   ---------------------------\n+   -- Set_Main_Program_Name --\n+   ---------------------------\n+\n+   procedure Set_Main_Program_Name is\n+   begin\n+      --  Note that name has %b on the end which we ignore\n+\n+      --  First we output the initial _ada_ since we know that the main\n+      --  program is a library level subprogram.\n+\n+      Set_String (\"_ada_\");\n+\n+      --  Copy name, changing dots to double underscores\n+\n+      for J in 1 .. Name_Len - 2 loop\n+         if Name_Buffer (J) = '.' then\n+            Set_String (\"__\");\n+         else\n+            Set_Char (Name_Buffer (J));\n+         end if;\n+      end loop;\n+   end Set_Main_Program_Name;\n+\n+   ---------------------\n+   -- Set_Name_Buffer --\n+   ---------------------\n+\n+   procedure Set_Name_Buffer is\n+   begin\n+      for J in 1 .. Name_Len loop\n+         Set_Char (Name_Buffer (J));\n+      end loop;\n+   end Set_Name_Buffer;\n+\n+   ----------------\n+   -- Set_String --\n+   ----------------\n+\n+   procedure Set_String (S : String) is\n+   begin\n+      Statement_Buffer (Last + 1 .. Last + S'Length) := S;\n+      Last := Last + S'Length;\n+   end Set_String;\n+\n+   -------------------\n+   -- Set_Unit_Name --\n+   -------------------\n+\n+   procedure Set_Unit_Name is\n+   begin\n+      for J in 1 .. Name_Len - 2 loop\n+         if Name_Buffer (J) /= '.' then\n+            Set_Char (Name_Buffer (J));\n+         else\n+            Set_String (\"__\");\n+         end if;\n+      end loop;\n+   end Set_Unit_Name;\n+\n+   ---------------------\n+   -- Set_Unit_Number --\n+   ---------------------\n+\n+   procedure Set_Unit_Number (U : Unit_Id) is\n+      Num_Units : constant Nat := Nat (Units.Table'Last) - Nat (Unit_Id'First);\n+      Unum      : constant Nat := Nat (U) - Nat (Unit_Id'First);\n+\n+   begin\n+      if Num_Units >= 10 and then Unum < 10 then\n+         Set_Char ('0');\n+      end if;\n+\n+      if Num_Units >= 100 and then Unum < 100 then\n+         Set_Char ('0');\n+      end if;\n+\n+      Set_Int (Unum);\n+   end Set_Unit_Number;\n+\n+   ------------\n+   -- Tab_To --\n+   ------------\n+\n+   procedure Tab_To (N : Natural) is\n+   begin\n+      while Last < N loop\n+         Set_Char (' ');\n+      end loop;\n+   end Tab_To;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (chars : chars_ptr) return String is\n+      function Strlen (chars : chars_ptr) return Natural;\n+      pragma Import (C, Strlen);\n+\n+   begin\n+      if chars = Null_Address then\n+         return \"\";\n+\n+      else\n+         declare\n+            subtype Result_Type is String (1 .. Strlen (chars));\n+\n+            Result : Result_Type;\n+            for Result'Address use chars;\n+\n+         begin\n+            return Result;\n+         end;\n+      end if;\n+   end Value;\n+\n+   ----------------------\n+   -- Write_Info_Ada_C --\n+   ----------------------\n+\n+   procedure Write_Info_Ada_C (Ada : String; C : String; Common : String) is\n+   begin\n+      if Ada_Bind_File then\n+         declare\n+            S : String (1 .. Ada'Length + Common'Length);\n+\n+         begin\n+            S (1 .. Ada'Length) := Ada;\n+            S (Ada'Length + 1 .. S'Length) := Common;\n+            WBI (S);\n+         end;\n+\n+      else\n+         declare\n+            S : String (1 .. C'Length + Common'Length);\n+\n+         begin\n+            S (1 .. C'Length) := C;\n+            S (C'Length + 1 .. S'Length) := Common;\n+            WBI (S);\n+         end;\n+      end if;\n+   end Write_Info_Ada_C;\n+\n+   ----------------------------\n+   -- Write_Statement_Buffer --\n+   ----------------------------\n+\n+   procedure Write_Statement_Buffer is\n+   begin\n+      WBI (Statement_Buffer (1 .. Last));\n+      Last := 0;\n+   end Write_Statement_Buffer;\n+\n+   procedure Write_Statement_Buffer (S : String) is\n+   begin\n+      Set_String (S);\n+      Write_Statement_Buffer;\n+   end Write_Statement_Buffer;\n+\n+end Bindgen;"}, {"sha": "11cabd3781217e127a3cac324ef2eae6af7d4e35", "filename": "gcc/ada/bindgen.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              B I N D G E N                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--   Copyright (C) 1992,1993,1994,1995,1996 Free Software Foundation, Inc.  --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines to output the binder file. This is\n+--  a C program which contains the following:\n+\n+--     initialization for main program case\n+--     sequence of calls to elaboration routines in appropriate order\n+--     call to main program for main program case\n+\n+--  See the body for exact details of the file that is generated\n+\n+package Bindgen is\n+\n+   ------------------\n+   --  Subprograms --\n+   ------------------\n+\n+   procedure Gen_Output_File (Filename : String);\n+   --  Filename is the full path name of the binder output file\n+\n+end Bindgen;"}, {"sha": "764e9c426c9e2cbc3d925553e3b9794116f9c5e3", "filename": "gcc/ada/bindusg.adb", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,273 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GBIND BINDER COMPONENTS                           --\n+--                                                                          --\n+--                             B I N D U S G                                --\n+--                                                                          --\n+--                                B o d y                                   --\n+--                                                                          --\n+--                            $Revision: 1.52 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Osint;  use Osint;\n+with Output; use Output;\n+\n+procedure Bindusg is\n+\n+   procedure Write_Switch_Char;\n+   --  Write two spaces followed by appropriate switch character\n+\n+   procedure Write_Switch_Char is\n+   begin\n+      Write_Str (\"  \");\n+      Write_Char (Switch_Character);\n+   end Write_Switch_Char;\n+\n+--  Start of processing for Bindusg\n+\n+begin\n+   --  Usage line\n+\n+   Write_Str (\"Usage: \");\n+   Write_Program_Name;\n+   Write_Char (' ');\n+   Write_Str (\"switches lfile\");\n+   Write_Eol;\n+   Write_Eol;\n+\n+   --  Line for -aO switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"aOdir    Specify library files search path\");\n+   Write_Eol;\n+\n+   --  Line for -aI switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"aIdir    Specify source files search path\");\n+   Write_Eol;\n+\n+   --  Line for A switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"A        Generate binder program in Ada (default)\");\n+   Write_Eol;\n+\n+   --  Line for -b switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"b        Generate brief messages to std\");\n+   Write_Str (\"err even if verbose mode set\");\n+   Write_Eol;\n+\n+   --  Line for -c switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"c        Check only, no generation of b\");\n+   Write_Str (\"inder output file\");\n+   Write_Eol;\n+\n+   --  Line for C switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"C        Generate binder program in C\");\n+   Write_Eol;\n+\n+   --  Line for -e switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"e        Output complete list of elabor\");\n+   Write_Str (\"ation order dependencies\");\n+   Write_Eol;\n+\n+   --  Line for -E switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"E        Store tracebacks in Exception occurrences\");\n+   Write_Eol;\n+\n+   --  Line for -f switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"f        Force RM elaboration ordering rules\");\n+   Write_Eol;\n+\n+   --  Line for -h switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"h        Output this usage (help) infor\");\n+   Write_Str (\"mation\");\n+   Write_Eol;\n+\n+   --  Line for -I switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"Idir     Specify library and source files search path\");\n+   Write_Eol;\n+\n+   --  Line for -I- switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"I-       Don't look for sources & library files\");\n+   Write_Str (\" in default directory\");\n+   Write_Eol;\n+\n+   --  Line for -K switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"K        Give list of linker options specified for link\");\n+   Write_Eol;\n+\n+   --  Line for -l switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"l        Output chosen elaboration order\");\n+   Write_Eol;\n+\n+   --  Line of -L switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"Lxyz     Library build: adainit/final \");\n+   Write_Str (\"renamed to xyzinit/final, implies -n\");\n+   Write_Eol;\n+\n+   --  Line for -M switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"Mxyz     Rename generated main program from main to xyz\");\n+   Write_Eol;\n+\n+   --  Line for -m switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"mnnn     Limit number of detected error\");\n+   Write_Str (\"s to nnn (1-999)\");\n+   Write_Eol;\n+\n+   --  Line for -n switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"n        No Ada main program (foreign main routine)\");\n+   Write_Eol;\n+\n+   --  Line for -nostdinc\n+\n+   Write_Switch_Char;\n+   Write_Str (\"nostdinc Don't look for source files\");\n+   Write_Str (\" in the system default directory\");\n+   Write_Eol;\n+\n+   --  Line for -nostdlib\n+\n+   Write_Switch_Char;\n+   Write_Str (\"nostdlib Don't look for library files\");\n+   Write_Str (\" in the system default directory\");\n+   Write_Eol;\n+\n+   --  Line for -o switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"o file   Give the output file name (default is b~xxx.adb) \");\n+   Write_Eol;\n+\n+   --  Line for -O switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"O        Give list of objects required for link\");\n+   Write_Eol;\n+\n+   --  Line for -p switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"p        Pessimistic (worst-case) elaborat\");\n+   Write_Str (\"ion order\");\n+   Write_Eol;\n+\n+   --  Line for -s switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"s        Require all source files to be\");\n+   Write_Str (\" present\");\n+   Write_Eol;\n+\n+   --  Line for -Sxx switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"S??      Sin/lo/hi/xx for Initialize_Scalars\");\n+   Write_Str (\" invalid/low/high/hex\");\n+   Write_Eol;\n+\n+   --  Line for -static\n+\n+   Write_Switch_Char;\n+   Write_Str (\"static   Link against a static GNAT run time\");\n+   Write_Eol;\n+\n+   --  Line for -shared\n+\n+   Write_Switch_Char;\n+   Write_Str (\"shared   Link against a shared GNAT run time\");\n+   Write_Eol;\n+\n+   --  Line for -t switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"t        Tolerate time stamp and other consistency errors\");\n+   Write_Eol;\n+\n+   --  Line for -T switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"Tn       Set time slice value to n microseconds (n >= 0)\");\n+   Write_Eol;\n+\n+   --  Line for -v switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"v        Verbose mode. Error messages, \");\n+   Write_Str (\"header, summary output to stdout\");\n+   Write_Eol;\n+\n+   --  Lines for -w switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"wx       Warning mode. (x=s/e for supp\");\n+   Write_Str (\"ress/treat as error)\");\n+   Write_Eol;\n+\n+   --  Line for -x switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"x        Exclude source files (check ob\");\n+   Write_Str (\"ject consistency only)\");\n+   Write_Eol;\n+\n+   --  Line for -z switch\n+\n+   Write_Switch_Char;\n+   Write_Str (\"z        No main subprogram (zero main)\");\n+   Write_Eol;\n+\n+   --  Line for sfile\n+\n+   Write_Str (\"  lfile     Library file names\");\n+   Write_Eol;\n+\n+end Bindusg;"}, {"sha": "1bb5169edab20edb5aa21a01017e385169b18caa", "filename": "gcc/ada/bindusg.ads", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindusg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbindusg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,31 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              B I N D U S G                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Procedure to generate screen of usage information if no file name present\n+\n+procedure Bindusg;"}, {"sha": "ef5d1820d4ecb8e1a9d2aa3ca95e0cde40e37f09", "filename": "gcc/ada/butil.adb", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbutil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbutil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbutil.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,185 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                B U T I L                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Hostparm; use Hostparm;\n+with Namet;    use Namet;\n+with Output;   use Output;\n+\n+package body Butil is\n+\n+   --------------------------\n+   -- Get_Unit_Name_String --\n+   --------------------------\n+\n+   procedure Get_Unit_Name_String (U : Unit_Name_Type) is\n+   begin\n+      Get_Name_String (U);\n+\n+      if Name_Buffer (Name_Len) = 's' then\n+         Name_Buffer (Name_Len - 1 .. Name_Len + 5) := \" (spec)\";\n+      else\n+         Name_Buffer (Name_Len - 1 .. Name_Len + 5) := \" (body)\";\n+      end if;\n+\n+      Name_Len := Name_Len + 5;\n+   end Get_Unit_Name_String;\n+\n+   ----------------------\n+   -- Is_Internal_Unit --\n+   ----------------------\n+\n+   --  Note: the reason we do not use the Fname package for this function\n+   --  is that it would drag too much junk into the binder.\n+\n+   function Is_Internal_Unit return Boolean is\n+   begin\n+      return Is_Predefined_Unit\n+        or else (Name_Len > 4\n+                   and then (Name_Buffer (1 .. 5) = \"gnat%\"\n+                               or else\n+                             Name_Buffer (1 .. 5) = \"gnat.\"))\n+        or else\n+          (OpenVMS\n+             and then Name_Len > 3\n+             and then (Name_Buffer (1 .. 4) = \"dec%\"\n+                         or else\n+                       Name_Buffer (1 .. 4) = \"dec.\"));\n+\n+   end Is_Internal_Unit;\n+\n+   ------------------------\n+   -- Is_Predefined_Unit --\n+   ------------------------\n+\n+   --  Note: the reason we do not use the Fname package for this function\n+   --  is that it would drag too much junk into the binder.\n+\n+   function Is_Predefined_Unit return Boolean is\n+   begin\n+      return    (Name_Len >  3\n+                  and then Name_Buffer (1 ..  4) = \"ada.\")\n+\n+        or else (Name_Len >  6\n+                  and then Name_Buffer (1 ..  7) = \"system.\")\n+\n+        or else (Name_Len > 10\n+                   and then Name_Buffer (1 .. 11) = \"interfaces.\")\n+\n+        or else (Name_Len >  3\n+                   and then Name_Buffer (1 ..  4) = \"ada%\")\n+\n+        or else (Name_Len >  8\n+                   and then Name_Buffer (1 ..  9) = \"calendar%\")\n+\n+        or else (Name_Len >  9\n+                   and then Name_Buffer (1 .. 10) = \"direct_io%\")\n+\n+        or else (Name_Len > 10\n+                   and then Name_Buffer (1 .. 11) = \"interfaces%\")\n+\n+        or else (Name_Len > 13\n+                   and then Name_Buffer (1 .. 14) = \"io_exceptions%\")\n+\n+        or else (Name_Len > 12\n+                   and then Name_Buffer (1 .. 13) = \"machine_code%\")\n+\n+        or else (Name_Len > 13\n+                   and then Name_Buffer (1 .. 14) = \"sequential_io%\")\n+\n+        or else (Name_Len >  6\n+                   and then Name_Buffer (1 ..  7) = \"system%\")\n+\n+        or else (Name_Len >  7\n+                   and then Name_Buffer (1 ..  8) = \"text_io%\")\n+\n+        or else (Name_Len > 20\n+                   and then Name_Buffer (1 .. 21) = \"unchecked_conversion%\")\n+\n+        or else (Name_Len > 22\n+                   and then Name_Buffer (1 .. 23) = \"unchecked_deallocation%\")\n+\n+        or else (Name_Len > 4\n+                   and then Name_Buffer (1 .. 5) = \"gnat%\")\n+\n+        or else (Name_Len > 4\n+                   and then Name_Buffer (1 .. 5) = \"gnat.\");\n+   end Is_Predefined_Unit;\n+\n+   ----------------\n+   -- Uname_Less --\n+   ----------------\n+\n+   function Uname_Less (U1, U2 : Unit_Name_Type) return Boolean is\n+   begin\n+      Get_Name_String (U1);\n+\n+      declare\n+         U1_Name : constant String (1 .. Name_Len) :=\n+                                           Name_Buffer (1 .. Name_Len);\n+         Min_Length : Natural;\n+\n+      begin\n+         Get_Name_String (U2);\n+\n+         if Name_Len < U1_Name'Last then\n+            Min_Length := Name_Len;\n+         else\n+            Min_Length := U1_Name'Last;\n+         end if;\n+\n+         for I in 1 .. Min_Length loop\n+            if U1_Name (I) > Name_Buffer (I) then\n+               return False;\n+            elsif U1_Name (I) < Name_Buffer (I) then\n+               return True;\n+            end if;\n+         end loop;\n+\n+         return U1_Name'Last < Name_Len;\n+      end;\n+   end Uname_Less;\n+\n+   ---------------------\n+   -- Write_Unit_Name --\n+   ---------------------\n+\n+   procedure Write_Unit_Name (U : Unit_Name_Type) is\n+   begin\n+      Get_Name_String (U);\n+      Write_Str (Name_Buffer (1 .. Name_Len - 2));\n+\n+      if Name_Buffer (Name_Len) = 's' then\n+         Write_Str (\" (spec)\");\n+      else\n+         Write_Str (\" (body)\");\n+      end if;\n+\n+      Name_Len := Name_Len + 5;\n+   end Write_Unit_Name;\n+\n+end Butil;"}, {"sha": "0dd08f81fe3983a7ebf774fb0dfd3bbf512ef6ae", "filename": "gcc/ada/butil.ads", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbutil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fbutil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbutil.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,61 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                B U T I L                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.9 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Butil is\n+\n+--  This package contains utility routines for the binder\n+\n+   function Is_Predefined_Unit return Boolean;\n+   --  Given a unit name stored in Name_Buffer with length in Name_Len,\n+   --  returns True if this is the name of a predefined unit or a child of\n+   --  a predefined unit (including the obsolescent renamings). This is used\n+   --  in the preference selection (see Better_Choice in body of Binde).\n+\n+   function Is_Internal_Unit return Boolean;\n+   --  Given a unit name stored in Name_Buffer with length in Name_Len,\n+   --  returns True if this is the name of an internal unit or a child of\n+   --  an internal. Similar in usage to Is_Predefined_Unit.\n+\n+   --  Note: the following functions duplicate functionality in Uname, but\n+   --  we want to avoid bringing Uname into the binder since it generates\n+   --  to many unnecessary dependencies, and makes the binder too large.\n+\n+   function Uname_Less (U1, U2 : Unit_Name_Type) return Boolean;\n+   --  Determines if the unit name U1 is alphabetically before U2\n+\n+   procedure Get_Unit_Name_String (U : Unit_Name_Type);\n+   --  Compute unit name with (body) or (spec) after as required. On return\n+   --  the result is stored in Name_Buffer and Name_Len is the length.\n+\n+   procedure Write_Unit_Name (U : Unit_Name_Type);\n+   --  Output unit name with (body) or (spec) after as required. On return\n+   --  Name_Len is set to the number of characters which were output.\n+\n+end Butil;"}, {"sha": "d0a7f544dffff226133551f32d0d7ea50c878077", "filename": "gcc/ada/cal.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcal.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,95 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                   C A L                                  *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/*  This file contains those routines named by Import pragmas in package    */\n+/*  GNAT.Calendar. It is used to to Duration to timeval convertion.         */\n+/*  These are simple wrappers function to abstarct the fact that the C      */\n+/*  struct timeval fields type are not normalized (they are generaly        */\n+/*  defined as int or long values).                                         */\n+\n+#if defined(VMS)\n+\n+/* this is temporary code to avoid build failure under VMS */\n+\n+void\n+__gnat_timeval_to_duration (void *t, long *sec, long *usec)\n+{\n+}\n+\n+void\n+__gnat_duration_to_timeval (long sec, long usec, void *t)\n+{\n+}\n+\n+#else\n+\n+#if defined (__vxworks)\n+#include <sys/times.h>\n+#else\n+#include <sys/time.h>\n+#endif\n+\n+void\n+__gnat_timeval_to_duration (struct timeval *t, long *sec, long *usec)\n+{\n+  *sec  = (long) t->tv_sec;\n+  *usec = (long) t->tv_usec;\n+}\n+\n+void\n+__gnat_duration_to_timeval (long sec, long usec, struct timeval *t)\n+{\n+  /* here we are doing implicit convertion from a long to the struct timeval\n+     fields types. */\n+\n+  t->tv_sec = sec;\n+  t->tv_usec = usec;\n+}\n+#endif\n+\n+#ifdef __alpha_vxworks\n+#include \"vxWorks.h\"\n+#elif defined (__vxworks)\n+#include <types/vxTypesOld.h>\n+#endif\n+\n+/* Return the value of the \"time\" C library function.  We always return\n+   a long and do it this way to avoid problems with not knowing\n+   what time_t is on the target.  */\n+\n+long\n+gnat_time ()\n+{\n+  return time (0);\n+}"}, {"sha": "eb8f374f8520f4d2dfbaf8084bf92479897d6c73", "filename": "gcc/ada/calendar.ads", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcalendar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcalendar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcalendar.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,20 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                             C A L E N D A R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;\n+\n+package Calendar renames Ada.Calendar;"}, {"sha": "e9ed296110a20b97fb931f09d005cfb910feb030", "filename": "gcc/ada/casing.adb", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcasing.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcasing.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcasing.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,186 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               C A S I N G                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.23 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Csets;    use Csets;\n+with Namet;    use Namet;\n+with Opt;      use Opt;\n+with Types;    use Types;\n+with Widechar; use Widechar;\n+\n+package body Casing is\n+\n+   ----------------------\n+   -- Determine_Casing --\n+   ----------------------\n+\n+   function Determine_Casing (Ident : Text_Buffer) return Casing_Type is\n+\n+      All_Lower : Boolean := True;\n+      --  Set False if upper case letter found\n+\n+      All_Upper : Boolean := True;\n+      --  Set False if lower case letter found\n+\n+      Mixed : Boolean := True;\n+      --  Set False if exception to mixed case rule found (lower case letter\n+      --  at start or after underline, or upper case letter elsewhere).\n+\n+      Decisive : Boolean := False;\n+      --  Set True if at least one instance of letter not after underline\n+\n+      After_Und : Boolean := True;\n+      --  True at start of string, and after an underline character\n+\n+   begin\n+      for S in Ident'Range loop\n+         if Ident (S) = '_' or else Ident (S) = '.' then\n+            After_Und := True;\n+\n+         elsif Is_Lower_Case_Letter (Ident (S)) then\n+            All_Upper := False;\n+\n+            if not After_Und then\n+               Decisive := True;\n+            else\n+               After_Und := False;\n+               Mixed := False;\n+            end if;\n+\n+         elsif Is_Upper_Case_Letter (Ident (S)) then\n+            All_Lower := False;\n+\n+            if not After_Und then\n+               Decisive := True;\n+               Mixed := False;\n+            else\n+               After_Und := False;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Now we can figure out the result from the flags we set in that loop\n+\n+      if All_Lower then\n+         return All_Lower_Case;\n+\n+      elsif not Decisive then\n+         return Unknown;\n+\n+      elsif All_Upper then\n+         return All_Upper_Case;\n+\n+      elsif Mixed then\n+         return Mixed_Case;\n+\n+      else\n+         return Unknown;\n+      end if;\n+   end Determine_Casing;\n+\n+   ------------------------\n+   -- Set_All_Upper_Case --\n+   ------------------------\n+\n+   procedure Set_All_Upper_Case is\n+   begin\n+      Set_Casing (All_Upper_Case);\n+   end Set_All_Upper_Case;\n+\n+   ----------------\n+   -- Set_Casing --\n+   ----------------\n+\n+   procedure Set_Casing (C : Casing_Type; D : Casing_Type := Mixed_Case) is\n+      Ptr : Natural;\n+\n+      Actual_Casing : Casing_Type;\n+      --  Set from C or D as appropriate\n+\n+      After_Und : Boolean := True;\n+      --  True at start of string, and after an underline character or after\n+      --  any other special character that is not a normal identifier char).\n+\n+   begin\n+      if C /= Unknown then\n+         Actual_Casing := C;\n+      else\n+         Actual_Casing := D;\n+      end if;\n+\n+      Ptr := 1;\n+\n+      while Ptr <= Name_Len loop\n+         if Name_Buffer (Ptr) = ASCII.ESC\n+           or else Name_Buffer (Ptr) = '['\n+           or else (Upper_Half_Encoding\n+                     and then Name_Buffer (Ptr) in Upper_Half_Character)\n+         then\n+            Skip_Wide (Name_Buffer, Ptr);\n+            After_Und := False;\n+\n+         elsif Name_Buffer (Ptr) = '_'\n+            or else not Identifier_Char (Name_Buffer (Ptr))\n+         then\n+            After_Und := True;\n+            Ptr := Ptr + 1;\n+\n+         elsif Is_Lower_Case_Letter (Name_Buffer (Ptr)) then\n+            if Actual_Casing = All_Upper_Case\n+              or else (After_Und and then Actual_Casing = Mixed_Case)\n+            then\n+               Name_Buffer (Ptr) := Fold_Upper (Name_Buffer (Ptr));\n+            end if;\n+\n+            After_Und := False;\n+            Ptr := Ptr + 1;\n+\n+         elsif Is_Upper_Case_Letter (Name_Buffer (Ptr)) then\n+            if Actual_Casing = All_Lower_Case\n+              or else (not After_Und and then Actual_Casing = Mixed_Case)\n+            then\n+               Name_Buffer (Ptr) := Fold_Lower (Name_Buffer (Ptr));\n+            end if;\n+\n+            After_Und := False;\n+            Ptr := Ptr + 1;\n+\n+         else  --  all other characters\n+            After_Und := False;\n+            Ptr := Ptr + 1;\n+         end if;\n+      end loop;\n+   end Set_Casing;\n+\n+end Casing;"}, {"sha": "a8aa6c82bfc79af80e9bad870c9aacf051ef256b", "filename": "gcc/ada/casing.ads", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcasing.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcasing.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcasing.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,90 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               C A S I N G                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.12 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Casing is\n+\n+   --  This package contains data and subprograms to support the feature that\n+   --  recognizes the letter case styles used in the source program being\n+   --  compiled, and uses this information for error message formatting, and\n+   --  for recognizing reserved words that are misused as identifiers.\n+\n+   -------------------------------\n+   -- Case Control Declarations --\n+   -------------------------------\n+\n+   --  Declaration of type for describing casing convention\n+\n+   type Casing_Type is (\n+\n+      All_Upper_Case,\n+      --  All letters are upper case\n+\n+      All_Lower_Case,\n+      --  All letters are lower case\n+\n+      Mixed_Case,\n+      --  The initial letter, and any letters after underlines are upper case.\n+      --  All other letters are lower case\n+\n+      Unknown\n+      --  Used if an identifier does not distinguish between the above cases,\n+      --  (e.g. X, Y_3, M4, A_B, or if it is inconsistent ABC_def).\n+   );\n+\n+   ------------------------------\n+   -- Case Control Subprograms --\n+   ------------------------------\n+\n+   procedure Set_Casing (C : Casing_Type; D : Casing_Type := Mixed_Case);\n+   --  Takes the name stored in the first Name_Len positions of Name_Buffer\n+   --  and modifies it to be consistent with the casing given by C, or if\n+   --  C = Unknown, then with the casing given by D. The name is basically\n+   --  treated as an identifier, except that special separator characters\n+   --  other than underline are permitted and treated like underlines (this\n+   --  handles cases like minus and period in unit names, apostrophes in error\n+   --  messages, angle brackets in names like <any_type>, etc).\n+\n+   procedure Set_All_Upper_Case;\n+   pragma Inline (Set_All_Upper_Case);\n+   --  This procedure is called with an identifier name stored in Name_Buffer.\n+   --  On return, the identifier is converted to all upper case. The call is\n+   --  equivalent to Set_Casing (All_Upper_Case).\n+\n+   function Determine_Casing (Ident : Text_Buffer) return Casing_Type;\n+   --  Determines the casing of the identifier/keyword string Ident\n+\n+end Casing;"}, {"sha": "b71b3ff99c10aa0c5c9922cf808ec2f4eec07e19", "filename": "gcc/ada/checks.adb", "status": "added", "additions": 4093, "deletions": 0, "changes": 4093, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "d265ae8da8f053397d9226aaa16a9cde28c2361e", "filename": "gcc/ada/checks.ads", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,526 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               C H E C K S                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.55 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package containing routines used to deal with runtime checks. These\n+--  routines are used both by the semantics and by the expander. In some\n+--  cases, checks are enabled simply by setting flags for gigi, and in\n+--  other cases the code for the check is expanded.\n+\n+--  The approach used for range and length checks, in regards to suppressed\n+--  checks, is to attempt to detect at compilation time that a constraint\n+--  error will occur. If this is detected a warning or error is issued and the\n+--  offending expression or statement replaced with a constraint error node.\n+--  This always occurs whether checks are suppressed or not.  Dynamic range\n+--  checks are, of course, not inserted if checks are suppressed.\n+\n+with Types; use Types;\n+with Uintp; use Uintp;\n+\n+package Checks is\n+\n+   procedure Initialize;\n+   --  Called for each new main source program, to initialize internal\n+   --  variables used in the package body of the Checks unit.\n+\n+   function Access_Checks_Suppressed        (E : Entity_Id) return Boolean;\n+   function Accessibility_Checks_Suppressed (E : Entity_Id) return Boolean;\n+   function Discriminant_Checks_Suppressed  (E : Entity_Id) return Boolean;\n+   function Division_Checks_Suppressed      (E : Entity_Id) return Boolean;\n+   function Elaboration_Checks_Suppressed   (E : Entity_Id) return Boolean;\n+   function Index_Checks_Suppressed         (E : Entity_Id) return Boolean;\n+   function Length_Checks_Suppressed        (E : Entity_Id) return Boolean;\n+   function Overflow_Checks_Suppressed      (E : Entity_Id) return Boolean;\n+   function Range_Checks_Suppressed         (E : Entity_Id) return Boolean;\n+   function Storage_Checks_Suppressed       (E : Entity_Id) return Boolean;\n+   function Tag_Checks_Suppressed           (E : Entity_Id) return Boolean;\n+   --  These functions check to see if the named check is suppressed,\n+   --  either by an active scope suppress setting, or because the check\n+   --  has been specifically suppressed for the given entity. If no entity\n+   --  is relevant for the current check, then Empty is used as an argument.\n+   --  Note: the reason we insist on specifying Empty is to force the\n+   --  caller to think about whether there is any relevant entity that\n+   --  should be checked.\n+\n+   --  General note on following checks. These checks are always active if\n+   --  Expander_Active and not Inside_A_Generic. They are inactive and have\n+   --  no effect Inside_A_Generic. In the case where not Expander_Active\n+   --  and not Inside_A_Generic, most of them are inactive, but some of them\n+   --  operate anyway since they may generate useful compile time warnings.\n+\n+   procedure Apply_Access_Check (N : Node_Id);\n+   --  Determines whether an expression node should be flagged as needing\n+   --  a runtime access check. If the node requires such a check, the\n+   --  Do_Access_Check flag is turned on.\n+\n+   procedure Apply_Accessibility_Check (N : Node_Id; Typ : Entity_Id);\n+   --  Given a name N denoting an access parameter, emits a run-time\n+   --  accessibility check (if necessary), checking that the level of\n+   --  the object denoted by the access parameter is not deeper than the\n+   --  level of the type Typ. Program_Error is raised if the check fails.\n+\n+   procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id);\n+   --  N is the node for an object declaration that declares an object of\n+   --  array type Typ. This routine generates, if necessary, a check that\n+   --  the size of the array is not too large, raising Storage_Error if so.\n+\n+   procedure Apply_Arithmetic_Overflow_Check (N : Node_Id);\n+   --  Given a binary arithmetic operator (+ - *) expand a software integer\n+   --  overflow check using range checks on a larger checking type or a call\n+   --  to an appropriate runtime routine. This is used for all three operators\n+   --  for the signed integer case, and for +/- in the fixed-point case. The\n+   --  check is expanded only if Software_Overflow_Checking is enabled and\n+   --  Do_Overflow_Check is set on node N. Note that divide is handled\n+   --  separately using Apply_Arithmetic_Divide_Overflow_Check.\n+\n+   procedure Apply_Constraint_Check\n+     (N          : Node_Id;\n+      Typ        : Entity_Id;\n+      No_Sliding : Boolean := False);\n+   --  Top-level procedure, calls all the others depending on the class of Typ.\n+   --  Checks that expression N verifies the constraint of type Typ. No_Sliding\n+   --  is only relevant for constrained array types, id set to true, it\n+   --  checks that indexes are in range.\n+\n+   procedure Apply_Discriminant_Check\n+     (N   : Node_Id;\n+      Typ : Entity_Id;\n+      Lhs : Node_Id := Empty);\n+   --  Given an expression N of a discriminated type, or of an access type\n+   --  whose designated type is a discriminanted type, generates a check to\n+   --  ensure that the expression can be converted to the subtype given as\n+   --  the second parameter. Lhs is empty except in the case of assignments,\n+   --  where the target object may be needed to determine the subtype to\n+   --  check against (such as the cases of unconstrained formal parameters\n+   --  and unconstrained aliased objects). For the case of unconstrained\n+   --  formals, the check is peformed only if the corresponding actual is\n+   --  constrained, i.e., whether Lhs'Constrained is True.\n+\n+   function Build_Discriminant_Checks\n+     (N     : Node_Id;\n+      T_Typ : Entity_Id)\n+      return  Node_Id;\n+   --  Subsidiary routine for Apply_Discriminant_Check. Builds the expression\n+   --  that compares discriminants of the expression with discriminants of the\n+   --  type. Also used directly for membership tests (see Exp_Ch4.Expand_N_In).\n+\n+   procedure Apply_Divide_Check (N : Node_Id);\n+   --  The node kind is N_Op_Divide, N_Op_Mod, or N_Op_Rem. An appropriate\n+   --  check is generated to ensure that the right operand is non-zero. In\n+   --  the divide case, we also check that we do not have the annoying case\n+   --  of the largest negative number divided by minus one.\n+\n+   procedure Apply_Type_Conversion_Checks (N : Node_Id);\n+   --  N is an N_Type_Conversion node. A type conversion actually involves\n+   --  two sorts of checks. The first check is the checks that ensures that\n+   --  the operand in the type conversion fits onto the base type of the\n+   --  subtype it is being converted to (see RM 4.6 (28)-(50)). The second\n+   --  check is there to ensure that once the operand has been converted to\n+   --  a value of the target type, this converted value meets the\n+   --  constraints imposed by the target subtype (see RM 4.6 (51)).\n+\n+   procedure Apply_Universal_Integer_Attribute_Checks (N : Node_Id);\n+   --  The argument N is an attribute reference node intended for processing\n+   --  by gigi. The attribute is one that returns a universal integer, but\n+   --  the attribute reference node is currently typed with the expected\n+   --  result type. This routine deals with range and overflow checks needed\n+   --  to make sure that the universal result is in range.\n+\n+   procedure Determine_Range\n+     (N  : Node_Id;\n+      OK : out Boolean;\n+      Lo : out Uint;\n+      Hi : out Uint);\n+   --  N is a node for a subexpression. If N is of a discrete type with\n+   --  no error indications, and no other peculiarities (e.g. missing\n+   --  type fields), then OK is True on return, and Lo and Hi are set\n+   --  to a conservative estimate of the possible range of values of N.\n+   --  Thus if OK is True on return, the value of the subexpression N is\n+   --  known to like in the range Lo .. Hi (inclusive). If the expression\n+   --  is not of a discrete type, or some kind of error condition is\n+   --  detected, then OK is False on exit, and Lo/Hi are set to No_Uint.\n+   --  Thus the significance of OK being False on return is that no\n+   --  useful information is available on the range of the expression.\n+\n+   -----------------------------\n+   -- Length and Range Checks --\n+   -----------------------------\n+\n+   --  In the following procedures, there are three arguments which have\n+   --  a common meaning as follows:\n+\n+   --    Expr        The expression to be checked. If a check is required,\n+   --                the appropriate flag will be placed on this node. Whether\n+   --                this node is further examined depends on the setting of\n+   --                the parameter Source_Typ, as described below.\n+\n+   --    Target_Typ  The target type on which the check is to be based. For\n+   --                example, if we have a scalar range check, then the check\n+   --                is that we are in range of this type.\n+\n+   --    Source_Typ  Normally Empty, but can be set to a type, in which case\n+   --                this type is used for the check, see below.\n+\n+   --  The checks operate in one of two modes:\n+\n+   --    If Source_Typ is Empty, then the node Expr is examined, at the\n+   --    very least to get the source subtype. In addition for some of\n+   --    the checks, the actual form of the node may be examined. For\n+   --    example, a node of type Integer whose actual form is an Integer\n+   --    conversion from a type with range 0 .. 3 can be determined to\n+   --    have a value in the range 0 .. 3.\n+\n+   --    If Source_Typ is given, then nothing can be assumed about the\n+   --    Expr, and indeed its contents are not examined. In this case the\n+   --    check is based on the assumption that Expr can be an arbitrary\n+   --    value of the given Source_Typ.\n+\n+   --  Currently, the only case in which a Source_Typ is explicitly supplied\n+   --  is for the case of Out and In_Out parameters, where, for the conversion\n+   --  on return (the Out direction), the types must be reversed. This is\n+   --  handled by the caller.\n+\n+   procedure Apply_Length_Check\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty);\n+   --  This procedure builds a sequence of declarations to do a length check\n+   --  that checks if the lengths of the two arrays Target_Typ and source type\n+   --  are the same. The resulting actions are inserted at Node using a call\n+   --  to Insert_Actions.\n+   --\n+   --  For access types, the Directly_Designated_Type is retrieved and\n+   --  processing continues as enumerated above, with a guard against\n+   --  null values.\n+   --\n+   --  Note: calls to Apply_Length_Check currently never supply an explicit\n+   --  Source_Typ parameter, but Apply_Length_Check takes this parameter and\n+   --  processes it as described above for consistency with the other routines\n+   --  in this section.\n+\n+   procedure Apply_Range_Check\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty);\n+   --  For an Node of kind N_Range, constructs a range check action that\n+   --  tests first that the range is not null and then that the range\n+   --  is contained in the Target_Typ range.\n+   --\n+   --  For scalar types, constructs a range check action that first tests that\n+   --  the expression is contained in the Target_Typ range. The difference\n+   --  between this and Apply_Scalar_Range_Check is that the latter generates\n+   --  the actual checking code in gigi against the Etype of the expression.\n+   --\n+   --  For constrained array types, construct series of range check actions\n+   --  to check that each Expr range is properly contained in the range of\n+   --  Target_Typ.\n+   --\n+   --  For a type conversion to an unconstrained array type, constructs\n+   --  a range check action to check that the bounds of the source type\n+   --  are within the constraints imposed by the Target_Typ.\n+   --\n+   --  For access types, the Directly_Designated_Type is retrieved and\n+   --  processing continues as enumerated above, with a guard against\n+   --  null values.\n+   --\n+   --  The source type is used by type conversions to unconstrained array\n+   --  types to retrieve the corresponding bounds.\n+\n+   procedure Apply_Static_Length_Check\n+     (Expr       : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty);\n+   --  Tries to determine statically whether the two array types source type\n+   --  and Target_Typ have the same length. If it can be determined at compile\n+   --  time that they do not, then an N_Raise_Constraint_Error node replaces\n+   --  Expr, and a warning message is issued.\n+\n+   procedure Apply_Scalar_Range_Check\n+     (Expr       : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty;\n+      Fixed_Int  : Boolean   := False);\n+   --  For scalar types, determines whether an expression node should be\n+   --  flagged as needing a runtime range check. If the node requires such\n+   --  a check, the Do_Range_Check flag is turned on. The Fixed_Int flag\n+   --  if set causes any fixed-point values to be treated as though they\n+   --  were discrete values (i.e. the underlying integer value is used).\n+\n+   type Check_Result is private;\n+   --  Type used to return result of Range_Check call, for later use in\n+   --  call to Insert_Range_Checks procedure.\n+\n+   procedure Append_Range_Checks\n+     (Checks       : Check_Result;\n+      Stmts        : List_Id;\n+      Suppress_Typ : Entity_Id;\n+      Static_Sloc  : Source_Ptr;\n+      Flag_Node    : Node_Id);\n+   --  Called to append range checks as returned by a call to Range_Check.\n+   --  Stmts is a list to which either the dynamic check is appended or\n+   --  the raise Constraint_Error statement is appended (for static checks).\n+   --  Static_Sloc is the Sloc at which the raise CE node points,\n+   --  Flag_Node is used as the node at which to set the Has_Dynamic_Check\n+   --  flag. Checks_On is a boolean value that says if range and index checking\n+   --  is on or not.\n+\n+   procedure Enable_Range_Check (N : Node_Id);\n+   pragma Inline (Enable_Range_Check);\n+   --  Set Do_Range_Check flag in node N to True unless Kill_Range_Check flag\n+   --  is set in N (the purpose of the latter flag is precisely to prevent\n+   --  Do_Range_Check from being set).\n+\n+   procedure Insert_Range_Checks\n+     (Checks       : Check_Result;\n+      Node         : Node_Id;\n+      Suppress_Typ : Entity_Id;\n+      Static_Sloc  : Source_Ptr := No_Location;\n+      Flag_Node    : Node_Id    := Empty;\n+      Do_Before    : Boolean    := False);\n+   --  Called to insert range checks as returned by a call to Range_Check.\n+   --  Node is the node after which either the dynamic check is inserted or\n+   --  the raise Constraint_Error statement is inserted (for static checks).\n+   --  Suppress_Typ is the type to check to determine if checks are suppressed.\n+   --  Static_Sloc, if passed, is the Sloc at which the raise CE node points,\n+   --  otherwise Sloc (Node) is used. The Has_Dynamic_Check flag is normally\n+   --  set at Node. If Flag_Node is present, then this is used instead as the\n+   --  node at which to set the Has_Dynamic_Check flag. Normally the check is\n+   --  inserted after, if Do_Before is True, the check is inserted before\n+   --  Node.\n+\n+   function Range_Check\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id;\n+      Source_Typ : Entity_Id := Empty;\n+      Warn_Node  : Node_Id   := Empty)\n+      return       Check_Result;\n+   --  Like Apply_Range_Check, except it does not modify anything. Instead\n+   --  it returns an encapsulated result of the check operations for later\n+   --  use in a call to Insert_Range_Checks. If Warn_Node is non-empty, its\n+   --  Sloc is used, in the static case, for the generated warning or error.\n+   --  Additionally, it is used rather than Expr (or Low/High_Bound of Expr)\n+   --  in constructing the check.\n+\n+   -----------------------\n+   -- Validity Checking --\n+   -----------------------\n+\n+   --  In (RM 13.9.1(9-11)) we have the following rules on invalid values\n+\n+   --    9   If the representation of a scalar object does not represent a\n+   --    value of the object's subtype (perhaps because the object was not\n+   --    initialized), the object is said to have an invalid representation.\n+   --    It is a bounded error to evaluate the value of such an object.  If\n+   --    the error is detected, either Constraint_Error or Program_Error is\n+   --    raised.  Otherwise, execution continues using the invalid\n+   --    representation.  The rules of the language outside this subclause\n+   --    assume that all objects have valid representations.  The semantics\n+   --    of operations on invalid representations are as follows:\n+   --\n+   --       10  If the representation of the object represents a value of the\n+   --           object's type, the value of the type is used.\n+   --\n+   --       11  If the representation of the object does not represent a value\n+   --           of the object's type, the semantics of operations on such\n+   --           representations is implementation-defined, but does not by\n+   --           itself lead to erroneous or unpredictable execution, or to\n+   --           other objects becoming abnormal.\n+\n+   --  We quote the rules in full here since they are quite delicate. Most\n+   --  of the time, we can just compute away with wrong values, and get a\n+   --  possibly wrong result, which is well within the range of allowed\n+   --  implementation defined behavior. The two tricky cases are subscripted\n+   --  array assignments, where we don't want to do wild stores, and case\n+   --  statements where we don't want to do wild jumps.\n+\n+   --  In GNAT, we control validity checking with a switch -gnatV that\n+   --  can take three parameters, n/d/f for None/Default/Full. These\n+   --  modes have the following meanings:\n+\n+   --    None (no validity checking)\n+\n+   --      In this mode, there is no specific checking for invalid values\n+   --      and the code generator assumes that all stored values are always\n+   --      within the bounds of the object subtype. The consequences are as\n+   --      follows:\n+\n+   --        For case statements, an out of range invalid value will cause\n+   --        Constraint_Error to be raised, or an arbitrary one of the case\n+   --        alternatives will be executed. Wild jumps cannot result even\n+   --        in this mode, since we always do a range check\n+\n+   --        For subscripted array assignments, wild stores will result in\n+   --        the expected manner when addresses are calculated using values\n+   --        of subscripts that are out of range.\n+\n+   --      It could perhaps be argued that this mode is still conformant with\n+   --      the letter of the RM, since implementation defined is a rather\n+   --      broad category, but certainly it is not in the spirit of the\n+   --      RM requirement, since wild stores certainly seem to be a case of\n+   --      erroneous behavior.\n+\n+   --    Default (default standard RM-compatible validity checking)\n+\n+   --      In this mode, which is the default, minimal validity checking is\n+   --      performed to ensure no erroneous behavior as follows:\n+\n+   --        For case statements, an out of range invalid value will cause\n+   --        Constraint_Error to be raised.\n+\n+   --        For subscripted array assignments, invalid out of range\n+   --        subscript values will cause Constraint_Error to be raised.\n+\n+   --    Full (Full validity checking)\n+\n+   --      In this mode, the protections guaranteed by the standard mode are\n+   --      in place, and the following additional checks are made:\n+\n+   --        For every assignment, the right side is checked for validity\n+\n+   --        For every call, IN and IN OUT parameters are checked for validity\n+\n+   --        For every subscripted array reference, both for stores and loads,\n+   --        all subscripts are checked for validity.\n+\n+   --      These checks are not required by the RM, but will in practice\n+   --      improve the detection of uninitialized variables, particularly\n+   --      if used in conjunction with pragma Normalize_Scalars.\n+\n+   --  In the above description, we talk about performing validity checks,\n+   --  but we don't actually generate a check in a case where the compiler\n+   --  can be sure that the value is valid. Note that this assurance must\n+   --  be achieved without assuming that any uninitialized value lies within\n+   --  the range of its type. The following are cases in which values are\n+   --  known to be valid. The flag Is_Known_Valid is used to keep track of\n+   --  some of these cases.\n+\n+   --    If all possible stored values are valid, then any uninitialized\n+   --    value must be valid.\n+\n+   --    Literals, including enumeration literals, are clearly always valid.\n+\n+   --    Constants are always assumed valid, with a validity check being\n+   --    performed on the initializing value where necessary to ensure that\n+   --    this is the case.\n+\n+   --    For variables, the status is set to known valid if there is an\n+   --    initializing expression. Again a check is made on the initializing\n+   --    value if necessary to ensure that this assumption is valid. The\n+   --    status can change as a result of local assignments to a variable.\n+   --    If a known valid value is unconditionally assigned, then we mark\n+   --    the left side as known valid. If a value is assigned that is not\n+   --    known to be valid, then we mark the left side as invalid. This\n+   --    kind of processing does NOT apply to non-local variables since we\n+   --    are not following the flow graph (more properly the flow of actual\n+   --    processing only corresponds to the flow graph for local assignments).\n+   --    For non-local variables, we preserve the current setting, i.e. a\n+   --    validity check is performed when assigning to a knonwn valid global.\n+\n+   --  Note: no validity checking is required if range checks are suppressed\n+   --  regardless of the setting of the validity checking mode.\n+\n+   --  The following procedures are used in handling validity checking\n+\n+   procedure Apply_Subscript_Validity_Checks (Expr : Node_Id);\n+   --  Expr is the node for an indexed component. If validity checking and\n+   --  range checking are enabled, all subscripts for this indexed component\n+   --  are checked for validity.\n+\n+   procedure Check_Valid_Lvalue_Subscripts (Expr : Node_Id);\n+   --  Expr is a lvalue, i.e. an expression representing the target of\n+   --  an assignment. This procedure checks for this expression involving\n+   --  an assignment to an array value. We have to be sure that all the\n+   --  subscripts in such a case are valid, since according to the rules\n+   --  in (RM 13.9.1(9-11)) such assignments are not permitted to result\n+   --  in erroneous behavior in the case of invalid subscript values.\n+\n+   procedure Ensure_Valid (Expr : Node_Id; Holes_OK : Boolean := False);\n+   --  Ensure that Expr represents a valid value of its type. If this type\n+   --  is not a scalar type, then the call has no effect, since validity\n+   --  is only an issue for scalar types. The effect of this call is to\n+   --  check if the value is known valid, if so, nothing needs to be done.\n+   --  If this is not known, then either Expr is set to be range checked,\n+   --  or specific checking code is inserted so that an exception is raised\n+   --  if the value is not valid.\n+   --\n+   --  The optional argument Holes_OK indicates whether it is necessary to\n+   --  worry about enumeration types with non-standard representations leading\n+   --  to \"holes\" in the range of possible representations. If Holes_OK is\n+   --  True, then such values are assumed valid (this is used when the caller\n+   --  will make a separate check for this case anyway). If Holes_OK is False,\n+   --  then this case is checked, and code is inserted to ensure that Expr is\n+   --  valid, raising Constraint_Error if the value is not valid.\n+\n+   function Expr_Known_Valid (Expr : Node_Id) return Boolean;\n+   --  This function tests it the value of Expr is known to be valid in\n+   --  the sense of RM 13.9.1(9-11). In the case of GNAT, it is only\n+   --  discrete types which are a concern, since for non-discrete types\n+   --  we simply continue computation with invalid values, which does\n+   --  not lead to erroneous behavior. Thus Expr_Known_Valid always\n+   --  returns True if the type of Expr is non-discrete. For discrete\n+   --  types the value returned is True only if it can be determined\n+   --  that the value is Valid. Otherwise False is returned.\n+\n+   procedure Insert_Valid_Check (Expr : Node_Id);\n+   --  Inserts code that will check for the value of Expr being valid, in\n+   --  the sense of the 'Valid attribute returning True. Constraint_Error\n+   --  will be raised if the value is not valid.\n+\n+private\n+\n+   type Check_Result is array (Positive range 1 .. 2) of Node_Id;\n+   --  There are two cases for the result returned by Range_Check:\n+   --\n+   --    For the static case the result is one or two nodes that should cause\n+   --    a Constraint_Error. Typically these will include Expr itself or the\n+   --    direct descendents of Expr, such as Low/High_Bound (Expr)). It is the\n+   --    responsibility of the caller to rewrite and substitute the nodes with\n+   --    N_Raise_Constraint_Error nodes.\n+   --\n+   --    For the non-static case a single N_Raise_Constraint_Error node\n+   --    with a non-empty Condition field is returned.\n+   --\n+   --  Unused entries in Check_Result, if any, are simply set to Empty\n+   --  For external clients, the required processing on this result is\n+   --  achieved using the Insert_Range_Checks routine.\n+\n+   pragma Inline (Access_Checks_Suppressed);\n+   pragma Inline (Accessibility_Checks_Suppressed);\n+   pragma Inline (Discriminant_Checks_Suppressed);\n+   pragma Inline (Division_Checks_Suppressed);\n+   pragma Inline (Elaboration_Checks_Suppressed);\n+   pragma Inline (Index_Checks_Suppressed);\n+   pragma Inline (Length_Checks_Suppressed);\n+   pragma Inline (Overflow_Checks_Suppressed);\n+   pragma Inline (Range_Checks_Suppressed);\n+   pragma Inline (Storage_Checks_Suppressed);\n+   pragma Inline (Tag_Checks_Suppressed);\n+\n+   pragma Inline (Apply_Length_Check);\n+   pragma Inline (Apply_Range_Check);\n+   pragma Inline (Apply_Static_Length_Check);\n+end Checks;"}, {"sha": "bcd83c3fb9900e1138a185c8dd4a86ef0db07fb7", "filename": "gcc/ada/cio.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcio.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,145 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                  C I O                                   *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision: 1.2 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include <sys/stat.h>\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"adaint.h\"\n+\n+#ifdef __RT__\n+\n+/* Linux kernel modules don't have inputs, so don't define get_int.\n+   Simple output can be done via printk. */\n+\n+void\n+put_char (c)\n+     int c;\n+{\n+  printk (\"%c\", c);\n+}\n+\n+void\n+put_char_stderr (c)\n+     int c;\n+{\n+  put_char (c);\n+}\n+\n+void\n+put_int (x)\n+     int x;\n+{\n+  printk (\"%d\", x);\n+}\n+\n+void\n+put_int_stderr (int x)\n+{\n+  put_int (x);\n+}\n+\n+#else\n+\n+/* Don't use macros on linux since they cause incompatible changes between\n+   glibc 2.0 and 2.1 */\n+#ifdef linux\n+#undef putchar\n+#undef getchar\n+#undef fputc\n+#undef stderr\n+#endif\n+\n+int\n+get_char ()\n+{\n+#ifdef VMS\n+  return decc$getchar();\n+#else\n+  return getchar ();\n+#endif\n+}\n+\n+int\n+get_int ()\n+{\n+  int x;\n+\n+  scanf (\" %d\", &x);\n+  return x;\n+}\n+\n+void\n+put_int (x)\n+     int x;\n+{\n+  printf (\"%d\", x);\n+}\n+\n+void\n+put_int_stderr (x)\n+   int x;\n+{\n+  fprintf (stderr, \"%d\", x);\n+}\n+\n+void\n+put_char (c)\n+     int c;\n+{\n+  putchar (c);\n+}\n+\n+void\n+put_char_stderr (c)\n+     int c;\n+{\n+  fputc (c, stderr);\n+}\n+#endif\n+\n+#ifdef __vxworks\n+\n+char *\n+mktemp (template)\n+     char *template;\n+{\n+  return tmpnam (NULL);\n+}\n+#endif"}, {"sha": "e92e0c4a97e6453305b27073c5703ced5ff3770e", "filename": "gcc/ada/comperr.adb", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,357 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              C O M P E R R                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.57 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines called when a fatal internal compiler\n+--  error is detected. Calls to these routines cause termination of the\n+--  current compilation with appropriate error output.\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Errout;   use Errout;\n+with Fname;    use Fname;\n+with Gnatvsn;  use Gnatvsn;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Osint;    use Osint;\n+with Output;   use Output;\n+with Sinput;   use Sinput;\n+with Sprint;   use Sprint;\n+with Sdefault; use Sdefault;\n+with Treepr;   use Treepr;\n+with Types;    use Types;\n+\n+with Ada.Exceptions; use Ada.Exceptions;\n+\n+with System.Soft_Links; use System.Soft_Links;\n+\n+package body Comperr is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Repeat_Char (Char : Character; Col : Nat; After : Character);\n+   --  Output Char until current column is at or past Col, and then output\n+   --  the character given by After (if column is already past Col on entry,\n+   --  then the effect is simply to output the After character).\n+\n+   --------------------\n+   -- Compiler_Abort --\n+   --------------------\n+\n+   procedure Compiler_Abort\n+     (X    : String;\n+      Code : Integer := 0)\n+   is\n+      procedure End_Line;\n+      --  Add blanks up to column 76, and then a final vertical bar\n+\n+      procedure End_Line is\n+      begin\n+         Repeat_Char (' ', 76, '|');\n+         Write_Eol;\n+      end End_Line;\n+\n+      Public_Version : constant Boolean := (Gnat_Version_String (5) = 'p');\n+\n+   --  Start of processing for Compiler_Abort\n+\n+   begin\n+      --  If errors have already occured, then we guess that the abort may\n+      --  well be caused by previous errors, and we don't make too much fuss\n+      --  about it, since we want to let the programmer fix the errors first.\n+\n+      --  Debug flag K disables this behavior (useful for debugging)\n+\n+      if Errors_Detected /= 0 and then not Debug_Flag_K then\n+         Errout.Finalize;\n+\n+         Set_Standard_Error;\n+         Write_Str (\"compilation abandoned due to previous error\");\n+         Write_Eol;\n+\n+         Set_Standard_Output;\n+         Source_Dump;\n+         Tree_Dump;\n+         Exit_Program (E_Errors);\n+\n+      --  Otherwise give message with details of the abort\n+\n+      else\n+         Set_Standard_Error;\n+\n+         --  Generate header for bug box\n+\n+         Write_Char ('+');\n+         Repeat_Char ('=', 29, 'G');\n+         Write_Str (\"NAT BUG DETECTED\");\n+         Repeat_Char ('=', 76, '+');\n+         Write_Eol;\n+\n+         --  Output GNAT version identification\n+\n+         Write_Str (\"| \");\n+         Write_Str (Gnat_Version_String);\n+         Write_Str (\" (\");\n+\n+         --  Output target name, deleting junk final reverse slash\n+\n+         if Target_Name.all (Target_Name.all'Last) = '\\'\n+           or else Target_Name.all (Target_Name.all'Last) = '/'\n+         then\n+            Write_Str (Target_Name.all (1 .. Target_Name.all'Last - 1));\n+         else\n+            Write_Str (Target_Name.all);\n+         end if;\n+\n+         --  Output identification of error\n+\n+         Write_Str (\") \");\n+\n+         if X'Length + Column > 76 then\n+            if Code < 0 then\n+               Write_Str (\"GCC error:\");\n+            end if;\n+\n+            End_Line;\n+\n+            Write_Str (\"| \");\n+         end if;\n+\n+         if X'Length > 70 then\n+            declare\n+               Last_Blank : Integer := 70;\n+\n+            begin\n+               for P in 40 .. 69 loop\n+                  if X (P) = ' ' then\n+                     Last_Blank := P;\n+                  end if;\n+               end loop;\n+\n+               Write_Str (X (1 .. Last_Blank));\n+               End_Line;\n+               Write_Str (\"|    \");\n+               Write_Str (X (Last_Blank + 1 .. X'Length));\n+            end;\n+         else\n+            Write_Str (X);\n+         end if;\n+\n+         if Code > 0 then\n+            Write_Str (\", Code=\");\n+            Write_Int (Int (Code));\n+\n+         elsif Code = 0 then\n+\n+            --  For exception case, get exception message from the TSD. Note\n+            --  that it would be neater and cleaner to pass the exception\n+            --  message (obtained from Exception_Message) as a parameter to\n+            --  Compiler_Abort, but we can't do this quite yet since it would\n+            --  cause bootstrap path problems for 3.10 to 3.11.\n+\n+            Write_Char (' ');\n+            Write_Str (Exception_Message (Get_Current_Excep.all.all));\n+         end if;\n+\n+         End_Line;\n+\n+         --  Output source location information\n+\n+         if Sloc (Current_Error_Node) <= Standard_Location\n+           or else Sloc (Current_Error_Node) = No_Location\n+         then\n+            Write_Str (\"| No source file position information available\");\n+            End_Line;\n+         else\n+            Write_Str (\"| Error detected at \");\n+            Write_Location (Sloc (Current_Error_Node));\n+            End_Line;\n+         end if;\n+\n+         --  There are two cases now. If the file gnat_bug.box exists,\n+         --  we use the contents of this file at this point.\n+\n+         declare\n+            Lo  : Source_Ptr;\n+            Hi  : Source_Ptr;\n+            Src : Source_Buffer_Ptr;\n+\n+         begin\n+            Namet.Unlock;\n+            Name_Buffer (1 .. 12) := \"gnat_bug.box\";\n+            Name_Len := 12;\n+            Read_Source_File (Name_Enter, 0, Hi, Src);\n+\n+            --  If we get a Src file, we use it\n+\n+            if Src /= null then\n+               Lo := 0;\n+\n+               Outer : while Lo < Hi loop\n+                  Write_Str (\"| \");\n+\n+                  Inner : loop\n+                     exit Inner when Src (Lo) = ASCII.CR\n+                       or else Src (Lo) = ASCII.LF;\n+                     Write_Char (Src (Lo));\n+                     Lo := Lo + 1;\n+                  end loop Inner;\n+\n+                  End_Line;\n+\n+                  while Lo <= Hi\n+                    and then (Src (Lo) = ASCII.CR\n+                                or else Src (Lo) = ASCII.LF)\n+                  loop\n+                     Lo := Lo + 1;\n+                  end loop;\n+               end loop Outer;\n+\n+            --  Otherwise we use the standard fixed text\n+\n+            else\n+               Write_Str\n+                 (\"| Please submit bug report by email to report@gnat.com.\");\n+               End_Line;\n+\n+               if not Public_Version then\n+                  Write_Str\n+                    (\"| Use a subject line meaningful to you\" &\n+                     \" and us to track the bug.\");\n+                  End_Line;\n+\n+                  Write_Str\n+                    (\"| (include your customer number #nnn \" &\n+                     \"in the subject line).\");\n+                  End_Line;\n+               end if;\n+\n+               Write_Str\n+                 (\"| Include the entire contents of this bug \" &\n+                  \"box in the report.\");\n+               End_Line;\n+\n+               Write_Str\n+                 (\"| Include the exact gcc or gnatmake command \" &\n+                  \"that you entered.\");\n+               End_Line;\n+\n+               Write_Str\n+                 (\"| Also include sources listed below in gnatchop format\");\n+               End_Line;\n+\n+               Write_Str\n+                 (\"| (concatenated together with no headers between files).\");\n+               End_Line;\n+\n+               if Public_Version then\n+                  Write_Str\n+                    (\"| (use plain ASCII or MIME attachment).\");\n+                  End_Line;\n+\n+                  Write_Str\n+                    (\"| See gnatinfo.txt for full info on procedure \" &\n+                     \"for submitting bugs.\");\n+                  End_Line;\n+\n+               else\n+                  Write_Str\n+                    (\"| (use plain ASCII or MIME attachment, or FTP \"\n+                     & \"to your customer directory).\");\n+                  End_Line;\n+\n+                  Write_Str\n+                    (\"| See README.GNATPRO for full info on procedure \" &\n+                     \"for submitting bugs.\");\n+                  End_Line;\n+               end if;\n+            end if;\n+         end;\n+\n+         --  Complete output of bug box\n+\n+         Write_Char ('+');\n+         Repeat_Char ('=', 76, '+');\n+         Write_Eol;\n+\n+         if Debug_Flag_3 then\n+            Write_Eol;\n+            Write_Eol;\n+            Print_Tree_Node (Current_Error_Node);\n+            Write_Eol;\n+         end if;\n+\n+         Write_Eol;\n+\n+         Write_Line (\"Please include these source files with error report\");\n+         Write_Eol;\n+\n+         for U in Main_Unit .. Last_Unit loop\n+            begin\n+               if not Is_Internal_File_Name\n+                        (File_Name (Source_Index (U)))\n+               then\n+                  Write_Name (Full_File_Name (Source_Index (U)));\n+                  Write_Eol;\n+               end if;\n+\n+            --  No point in double bug box if we blow up trying to print\n+            --  the list of file names! Output informative msg and quit.\n+\n+            exception\n+               when others =>\n+                  Write_Str (\"list may be incomplete\");\n+                  exit;\n+            end;\n+         end loop;\n+\n+         Write_Eol;\n+         Set_Standard_Output;\n+\n+         Tree_Dump;\n+         Source_Dump;\n+         raise Unrecoverable_Error;\n+      end if;\n+\n+   end Compiler_Abort;\n+\n+   -----------------\n+   -- Repeat_Char --\n+   -----------------\n+\n+   procedure Repeat_Char (Char : Character; Col : Nat; After : Character) is\n+   begin\n+      while Column < Col loop\n+         Write_Char (Char);\n+      end loop;\n+\n+      Write_Char (After);\n+   end Repeat_Char;\n+\n+end Comperr;"}, {"sha": "a55a49fb5c30ef1fe7b2b0fe5d96c7f09f3786e7", "filename": "gcc/ada/comperr.ads", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcomperr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcomperr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,96 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              C O M P E R R                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.18 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine called when a fatal internal compiler\n+--  error is detected. Calls to this routines cause termination of the\n+--  current compilation with appropriate error output.\n+\n+package Comperr is\n+\n+   procedure Compiler_Abort\n+     (X    : String;\n+      Code : Integer := 0);\n+   --  Signals an internal compiler error. Never returns control. Depending\n+   --  on processing may end up raising Unrecoverable_Error, or exiting\n+   --  directly. The message output is a \"bug box\" containing the\n+   --  string passed as an argument. The node in Current_Error_Node is used\n+   --  to provide the location where the error should be signalled. The\n+   --  message includes the node id, and the code parameter if it is positive.\n+   --  Note that this is only used at the outer level (to handle constraint\n+   --  errors or assert errors etc.) In the normal logic of the compiler we\n+   --  always use pragma Assert to check for errors, and if necessary an\n+   --  explicit abort is achieved by pragma Assert (False). Code is positive\n+   --  for a gigi abort (giving the gigi abort code), zero for a front\n+   --  end exception (with possible message stored in TSD.Current_Excep,\n+   --  and negative (an unused value) for a GCC abort.\n+\n+   ------------------------------\n+   -- Use of gnat_bug.box File --\n+   ------------------------------\n+\n+   --  When comperr generates the \"bug box\". The first two lines contain\n+   --  information on the version number, type of abort, and source location.\n+\n+   --  Normally the remaining text is one of the following two forms\n+   --  depending on the version number (p identifies public versions):\n+\n+   --    Please submit bug report by email to report@gnat.com.\n+   --    Use a subject line meaningful to you and us to track the bug.\n+   --    (include your customer number #nnn in the subject line).\n+   --    Include the entire contents of this bug box in the report.\n+   --    Include the exact gcc or gnatmake command that you entered.\n+   --    Also include sources listed below in gnatchop format\n+   --    (concatenated together with no headers between files).\n+   --    (use plain ASCII or MIME attachment,\n+   --    or FTP to your customer directory).\n+   --    See README.GNATPRO for full info on procedure for submitting bugs.\n+\n+   --  or (public version case)\n+\n+   --    Please submit bug report by email to report@gnat.com.\n+   --    Use a subject line meaningful to you and us to track the bug.\n+   --    (include your customer number #nnn in the subject line).\n+   --    Include the entire contents of this bug box in the report.\n+   --    Include the exact gcc or gnatmake command that you entered.\n+   --    Also include sources listed below in gnatchop format\n+   --    (concatenated together with no headers between files).\n+   --    See gnatinfo.txt for full info on procedure for submitting bugs.\n+\n+   --  However, an alternative mechanism exists for easily substituting\n+   --  different text for this message. Compiler_Abort checks for the\n+   --  existence of the file \"gnat_bug.box\" in the current source path.\n+   --  Most typically this file, if present, will be in the directory\n+   --  containing the run-time sources.\n+\n+   --  If this file is present, then it is a plain ASCII file, whose\n+   --  contents replace the above quoted paragraphs. The lines in this\n+   --  file should be 72 characters or less to avoid misformatting the\n+   --  right boundary of the box. Note that the file does not contain\n+   --  the vertical bar characters or any leading spaces in lines.\n+\n+end Comperr;"}, {"sha": "5268fe2b81fc661273acf6d4896d0d987cd08882", "filename": "gcc/ada/config-lang.in", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fconfig-lang.in?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,39 @@\n+# Top level configure fragment for GNU Ada (GNAT).\n+#   Copyright (C) 1994 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# boot_language - \"yes\" if we need to build this language in stage1\n+# compilers\t- value to add to $(COMPILERS)\n+# stagestuff\t- files to add to $(STAGESTUFF)\n+# diff_excludes\t- files to ignore when building diffs between two versions.\n+\n+language=\"ada\"\n+boot_language=yes\n+boot_language_boot_flags='ADAFLAGS=\"$(BOOT_ADAFLAGS)\"'\n+\n+compilers=\"gnat1\\$(exeext)\"\n+\n+stagestuff=\"gnatbind\\$(exeext) gnat1\\$(exeext)\"\n+\n+diff_excludes=\"-x ada/a-einfo.h -x ada/a-sinfo.h -x ada/nmake.adb -x ada/nmake.ads -x ada/treeprs.ads -x ada/sysid.ads\"\n+\n+outputs=ada/Makefile"}, {"sha": "6855f4dc0afcd631396fa875e8349d681bb14631", "filename": "gcc/ada/csets.adb", "status": "added", "additions": 1037, "deletions": 0, "changes": 1037, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcsets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcsets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsets.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,1037 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                C S E T S                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.25 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Opt;   use Opt;\n+\n+with System.WCh_Con; use System.WCh_Con;\n+\n+package body Csets is\n+\n+   X_80 : constant Character := Character'Val (16#80#);\n+   X_81 : constant Character := Character'Val (16#81#);\n+   X_82 : constant Character := Character'Val (16#82#);\n+   X_83 : constant Character := Character'Val (16#83#);\n+   X_84 : constant Character := Character'Val (16#84#);\n+   X_85 : constant Character := Character'Val (16#85#);\n+   X_86 : constant Character := Character'Val (16#86#);\n+   X_87 : constant Character := Character'Val (16#87#);\n+   X_88 : constant Character := Character'Val (16#88#);\n+   X_89 : constant Character := Character'Val (16#89#);\n+   X_8A : constant Character := Character'Val (16#8A#);\n+   X_8B : constant Character := Character'Val (16#8B#);\n+   X_8C : constant Character := Character'Val (16#8C#);\n+   X_8D : constant Character := Character'Val (16#8D#);\n+   X_8E : constant Character := Character'Val (16#8E#);\n+   X_8F : constant Character := Character'Val (16#8F#);\n+   X_90 : constant Character := Character'Val (16#90#);\n+   X_91 : constant Character := Character'Val (16#91#);\n+   X_92 : constant Character := Character'Val (16#92#);\n+   X_93 : constant Character := Character'Val (16#93#);\n+   X_94 : constant Character := Character'Val (16#94#);\n+   X_95 : constant Character := Character'Val (16#95#);\n+   X_96 : constant Character := Character'Val (16#96#);\n+   X_97 : constant Character := Character'Val (16#97#);\n+   X_98 : constant Character := Character'Val (16#98#);\n+   X_99 : constant Character := Character'Val (16#99#);\n+   X_9A : constant Character := Character'Val (16#9A#);\n+   X_9B : constant Character := Character'Val (16#9B#);\n+   X_9C : constant Character := Character'Val (16#9C#);\n+   X_9D : constant Character := Character'Val (16#9D#);\n+   X_9E : constant Character := Character'Val (16#9E#);\n+   X_9F : constant Character := Character'Val (16#9F#);\n+   X_A0 : constant Character := Character'Val (16#A0#);\n+   X_A1 : constant Character := Character'Val (16#A1#);\n+   X_A2 : constant Character := Character'Val (16#A2#);\n+   X_A3 : constant Character := Character'Val (16#A3#);\n+   X_A4 : constant Character := Character'Val (16#A4#);\n+   X_A5 : constant Character := Character'Val (16#A5#);\n+   X_A6 : constant Character := Character'Val (16#A6#);\n+   X_A7 : constant Character := Character'Val (16#A7#);\n+   X_A8 : constant Character := Character'Val (16#A8#);\n+   X_A9 : constant Character := Character'Val (16#A9#);\n+   X_AA : constant Character := Character'Val (16#AA#);\n+   X_AB : constant Character := Character'Val (16#AB#);\n+   X_AC : constant Character := Character'Val (16#AC#);\n+   X_AD : constant Character := Character'Val (16#AD#);\n+   X_AE : constant Character := Character'Val (16#AE#);\n+   X_AF : constant Character := Character'Val (16#AF#);\n+   X_B0 : constant Character := Character'Val (16#B0#);\n+   X_B1 : constant Character := Character'Val (16#B1#);\n+   X_B2 : constant Character := Character'Val (16#B2#);\n+   X_B3 : constant Character := Character'Val (16#B3#);\n+   X_B4 : constant Character := Character'Val (16#B4#);\n+   X_B5 : constant Character := Character'Val (16#B5#);\n+   X_B6 : constant Character := Character'Val (16#B6#);\n+   X_B7 : constant Character := Character'Val (16#B7#);\n+   X_B8 : constant Character := Character'Val (16#B8#);\n+   X_B9 : constant Character := Character'Val (16#B9#);\n+   X_BA : constant Character := Character'Val (16#BA#);\n+   X_BB : constant Character := Character'Val (16#BB#);\n+   X_BC : constant Character := Character'Val (16#BC#);\n+   X_BD : constant Character := Character'Val (16#BD#);\n+   X_BE : constant Character := Character'Val (16#BE#);\n+   X_BF : constant Character := Character'Val (16#BF#);\n+   X_C0 : constant Character := Character'Val (16#C0#);\n+   X_C1 : constant Character := Character'Val (16#C1#);\n+   X_C2 : constant Character := Character'Val (16#C2#);\n+   X_C3 : constant Character := Character'Val (16#C3#);\n+   X_C4 : constant Character := Character'Val (16#C4#);\n+   X_C5 : constant Character := Character'Val (16#C5#);\n+   X_C6 : constant Character := Character'Val (16#C6#);\n+   X_C7 : constant Character := Character'Val (16#C7#);\n+   X_C8 : constant Character := Character'Val (16#C8#);\n+   X_C9 : constant Character := Character'Val (16#C9#);\n+   X_CA : constant Character := Character'Val (16#CA#);\n+   X_CB : constant Character := Character'Val (16#CB#);\n+   X_CC : constant Character := Character'Val (16#CC#);\n+   X_CD : constant Character := Character'Val (16#CD#);\n+   X_CE : constant Character := Character'Val (16#CE#);\n+   X_CF : constant Character := Character'Val (16#CF#);\n+   X_D0 : constant Character := Character'Val (16#D0#);\n+   X_D1 : constant Character := Character'Val (16#D1#);\n+   X_D2 : constant Character := Character'Val (16#D2#);\n+   X_D3 : constant Character := Character'Val (16#D3#);\n+   X_D4 : constant Character := Character'Val (16#D4#);\n+   X_D5 : constant Character := Character'Val (16#D5#);\n+   X_D6 : constant Character := Character'Val (16#D6#);\n+   X_D7 : constant Character := Character'Val (16#D7#);\n+   X_D8 : constant Character := Character'Val (16#D8#);\n+   X_D9 : constant Character := Character'Val (16#D9#);\n+   X_DA : constant Character := Character'Val (16#DA#);\n+   X_DB : constant Character := Character'Val (16#DB#);\n+   X_DC : constant Character := Character'Val (16#DC#);\n+   X_DD : constant Character := Character'Val (16#DD#);\n+   X_DE : constant Character := Character'Val (16#DE#);\n+   X_DF : constant Character := Character'Val (16#DF#);\n+   X_E0 : constant Character := Character'Val (16#E0#);\n+   X_E1 : constant Character := Character'Val (16#E1#);\n+   X_E2 : constant Character := Character'Val (16#E2#);\n+   X_E3 : constant Character := Character'Val (16#E3#);\n+   X_E4 : constant Character := Character'Val (16#E4#);\n+   X_E5 : constant Character := Character'Val (16#E5#);\n+   X_E6 : constant Character := Character'Val (16#E6#);\n+   X_E7 : constant Character := Character'Val (16#E7#);\n+   X_E8 : constant Character := Character'Val (16#E8#);\n+   X_E9 : constant Character := Character'Val (16#E9#);\n+   X_EA : constant Character := Character'Val (16#EA#);\n+   X_EB : constant Character := Character'Val (16#EB#);\n+   X_EC : constant Character := Character'Val (16#EC#);\n+   X_ED : constant Character := Character'Val (16#ED#);\n+   X_EE : constant Character := Character'Val (16#EE#);\n+   X_EF : constant Character := Character'Val (16#EF#);\n+   X_F0 : constant Character := Character'Val (16#F0#);\n+   X_F1 : constant Character := Character'Val (16#F1#);\n+   X_F2 : constant Character := Character'Val (16#F2#);\n+   X_F3 : constant Character := Character'Val (16#F3#);\n+   X_F4 : constant Character := Character'Val (16#F4#);\n+   X_F5 : constant Character := Character'Val (16#F5#);\n+   X_F6 : constant Character := Character'Val (16#F6#);\n+   X_F7 : constant Character := Character'Val (16#F7#);\n+   X_F8 : constant Character := Character'Val (16#F8#);\n+   X_F9 : constant Character := Character'Val (16#F9#);\n+   X_FA : constant Character := Character'Val (16#FA#);\n+   X_FB : constant Character := Character'Val (16#FB#);\n+   X_FC : constant Character := Character'Val (16#FC#);\n+   X_FD : constant Character := Character'Val (16#FD#);\n+   X_FE : constant Character := Character'Val (16#FE#);\n+   X_FF : constant Character := Character'Val (16#FF#);\n+\n+   -----------------------------\n+   -- Definitions for Latin-1 --\n+   -----------------------------\n+\n+   Fold_Latin_1 : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',  X_E0 => X_C0,  X_F0 => X_D0,\n+      'b' => 'B',  X_E1 => X_C1,  X_F1 => X_D1,\n+      'c' => 'C',  X_E2 => X_C2,  X_F2 => X_D2,\n+      'd' => 'D',  X_E3 => X_C3,  X_F3 => X_D3,\n+      'e' => 'E',  X_E4 => X_C4,  X_F4 => X_D4,\n+      'f' => 'F',  X_E5 => X_C5,  X_F5 => X_D5,\n+      'g' => 'G',  X_E6 => X_C6,  X_F6 => X_D6,\n+      'h' => 'H',  X_E7 => X_C7,\n+      'i' => 'I',  X_E8 => X_C8,  X_F8 => X_D8,\n+      'j' => 'J',  X_E9 => X_C9,  X_F9 => X_D9,\n+      'k' => 'K',  X_EA => X_CA,  X_FA => X_DA,\n+      'l' => 'L',  X_EB => X_CB,  X_FB => X_DB,\n+      'm' => 'M',  X_EC => X_CC,  X_FC => X_DC,\n+      'n' => 'N',  X_ED => X_CD,  X_FD => X_DD,\n+      'o' => 'O',  X_EE => X_CE,  X_FE => X_DE,\n+      'p' => 'P',  X_EF => X_CF,\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',  X_C0 => X_C0,  X_D0 => X_D0,\n+      'B' => 'B',  X_C1 => X_C1,  X_D1 => X_D1,\n+      'C' => 'C',  X_C2 => X_C2,  X_D2 => X_D2,\n+      'D' => 'D',  X_C3 => X_C3,  X_D3 => X_D3,\n+      'E' => 'E',  X_C4 => X_C4,  X_D4 => X_D4,\n+      'F' => 'F',  X_C5 => X_C5,  X_D5 => X_D5,\n+      'G' => 'G',  X_C6 => X_C6,  X_D6 => X_D6,\n+      'H' => 'H',  X_C7 => X_C7,\n+      'I' => 'I',  X_C8 => X_C8,  X_D8 => X_D8,\n+      'J' => 'J',  X_C9 => X_C9,  X_D9 => X_D9,\n+      'K' => 'K',  X_CA => X_CA,  X_DA => X_DA,\n+      'L' => 'L',  X_CB => X_CB,  X_DB => X_DB,\n+      'M' => 'M',  X_CC => X_CC,  X_DC => X_DC,\n+      'N' => 'N',  X_CD => X_CD,  X_DD => X_DD,\n+      'O' => 'O',  X_CE => X_CE,  X_DE => X_DE,\n+      'P' => 'P',  X_CF => X_CF,  X_DF => X_DF,  X_FF => X_FF,\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   -----------------------------\n+   -- Definitions for Latin-2 --\n+   -----------------------------\n+\n+   Fold_Latin_2 : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',  X_E0 => X_C0,  X_F0 => X_D0,\n+      'b' => 'B',  X_E1 => X_C1,  X_F1 => X_D1,  X_B1 => X_A1,\n+      'c' => 'C',  X_E2 => X_C2,  X_F2 => X_D2,\n+      'd' => 'D',  X_E3 => X_C3,  X_F3 => X_D3,  X_B3 => X_A3,\n+      'e' => 'E',  X_E4 => X_C4,  X_F4 => X_D4,\n+      'f' => 'F',  X_E5 => X_C5,  X_F5 => X_D5,  X_B5 => X_A5,\n+      'g' => 'G',  X_E6 => X_C6,  X_F6 => X_D6,  X_B6 => X_A6,\n+      'h' => 'H',  X_E7 => X_C7,\n+      'i' => 'I',  X_E8 => X_C8,  X_F8 => X_D8,\n+      'j' => 'J',  X_E9 => X_C9,  X_F9 => X_D9,  X_B9 => X_A9,\n+      'k' => 'K',  X_EA => X_CA,  X_FA => X_DA,  X_BA => X_AA,\n+      'l' => 'L',  X_EB => X_CB,  X_FB => X_DB,  X_BB => X_AB,\n+      'm' => 'M',  X_EC => X_CC,  X_FC => X_DC,  X_BC => X_AC,\n+      'n' => 'N',  X_ED => X_CD,  X_FD => X_DD,\n+      'o' => 'O',  X_EE => X_CE,  X_FE => X_DE,  X_BE => X_AE,\n+      'p' => 'P',  X_EF => X_CF,  X_FF => X_DF,  X_BF => X_AF,\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',  X_C0 => X_C0,  X_D0 => X_D0,\n+      'B' => 'B',  X_C1 => X_C1,  X_D1 => X_D1,  X_A1 => X_A1,\n+      'C' => 'C',  X_C2 => X_C2,  X_D2 => X_D2,\n+      'D' => 'D',  X_C3 => X_C3,  X_D3 => X_D3,  X_A3 => X_A3,\n+      'E' => 'E',  X_C4 => X_C4,  X_D4 => X_D4,\n+      'F' => 'F',  X_C5 => X_C5,  X_D5 => X_D5,  X_A5 => X_A5,\n+      'G' => 'G',  X_C6 => X_C6,  X_D6 => X_D6,  X_A6 => X_A6,\n+      'H' => 'H',  X_C7 => X_C7,\n+      'I' => 'I',  X_C8 => X_C8,  X_D8 => X_D8,\n+      'J' => 'J',  X_C9 => X_C9,  X_D9 => X_D9,  X_A9 => X_A9,\n+      'K' => 'K',  X_CA => X_CA,  X_DA => X_DA,  X_AA => X_AA,\n+      'L' => 'L',  X_CB => X_CB,  X_DB => X_DB,  X_AB => X_AB,\n+      'M' => 'M',  X_CC => X_CC,  X_DC => X_DC,  X_AC => X_AC,\n+      'N' => 'N',  X_CD => X_CD,  X_DD => X_DD,\n+      'O' => 'O',  X_CE => X_CE,  X_DE => X_DE,  X_AE => X_AE,\n+      'P' => 'P',  X_CF => X_CF,  X_DF => X_DF,  X_AF => X_AF,\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   -----------------------------\n+   -- Definitions for Latin-3 --\n+   -----------------------------\n+\n+   Fold_Latin_3 : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',  X_E0 => X_C0,\n+      'b' => 'B',  X_E1 => X_C1,  X_F1 => X_D1,  X_B1 => X_A1,\n+      'c' => 'C',  X_E2 => X_C2,  X_F2 => X_D2,\n+      'd' => 'D',                 X_F3 => X_D3,\n+      'e' => 'E',  X_E4 => X_C4,  X_F4 => X_D4,\n+      'f' => 'F',  X_E5 => X_C5,  X_F5 => X_D5,  X_B5 => X_A5,\n+      'g' => 'G',  X_E6 => X_C6,  X_F6 => X_D6,  X_B6 => X_A6,\n+      'h' => 'H',  X_E7 => X_C7,\n+      'i' => 'I',  X_E8 => X_C8,  X_F8 => X_D8,\n+      'j' => 'J',  X_E9 => X_C9,  X_F9 => X_D9,  X_B9 => X_A9,\n+      'k' => 'K',  X_EA => X_CA,  X_FA => X_DA,  X_BA => X_AA,\n+      'l' => 'L',  X_EB => X_CB,  X_FB => X_DB,  X_BB => X_AB,\n+      'm' => 'M',  X_EC => X_CC,  X_FC => X_DC,  X_BC => X_AC,\n+      'n' => 'N',  X_ED => X_CD,  X_FD => X_DD,\n+      'o' => 'O',  X_EE => X_CE,  X_FE => X_DE,\n+      'p' => 'P',  X_EF => X_CF,                 X_BF => X_AF,\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',  X_C0 => X_C0,\n+      'B' => 'B',  X_C1 => X_C1,  X_D1 => X_D1,  X_A1 => X_A1,\n+      'C' => 'C',  X_C2 => X_C2,  X_D2 => X_D2,\n+      'D' => 'D',                 X_D3 => X_D3,\n+      'E' => 'E',  X_C4 => X_C4,  X_D4 => X_D4,\n+      'F' => 'F',  X_C5 => X_C5,  X_D5 => X_D5,  X_A5 => X_A5,\n+      'G' => 'G',  X_C6 => X_C6,  X_D6 => X_D6,  X_A6 => X_A6,\n+      'H' => 'H',  X_C7 => X_C7,\n+      'I' => 'I',  X_C8 => X_C8,  X_D8 => X_D8,\n+      'J' => 'J',  X_C9 => X_C9,  X_D9 => X_D9,  X_A9 => X_A9,\n+      'K' => 'K',  X_CA => X_CA,  X_DA => X_DA,  X_AA => X_AA,\n+      'L' => 'L',  X_CB => X_CB,  X_DB => X_DB,  X_AB => X_AB,\n+      'M' => 'M',  X_CC => X_CC,  X_DC => X_DC,  X_AC => X_AC,\n+      'N' => 'N',  X_CD => X_CD,  X_DD => X_DD,\n+      'O' => 'O',  X_CE => X_CE,  X_DE => X_DE,\n+      'P' => 'P',  X_CF => X_CF,                 X_AF => X_AF,\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   -----------------------------\n+   -- Definitions for Latin-4 --\n+   -----------------------------\n+\n+   Fold_Latin_4 : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',  X_E0 => X_C0,  X_F0 => X_D0,\n+      'b' => 'B',  X_E1 => X_C1,  X_F1 => X_D1,  X_B1 => X_A1,\n+      'c' => 'C',  X_E2 => X_C2,  X_F2 => X_D2,\n+      'd' => 'D',  X_E3 => X_C3,  X_F3 => X_D3,  X_B3 => X_A3,\n+      'e' => 'E',  X_E4 => X_C4,  X_F4 => X_D4,\n+      'f' => 'F',  X_E5 => X_C5,  X_F5 => X_D5,  X_B5 => X_A5,\n+      'g' => 'G',  X_E6 => X_C6,  X_F6 => X_D6,  X_B6 => X_A6,\n+      'h' => 'H',  X_E7 => X_C7,\n+      'i' => 'I',  X_E8 => X_C8,  X_F8 => X_D8,\n+      'j' => 'J',  X_E9 => X_C9,  X_F9 => X_D9,  X_B9 => X_A9,\n+      'k' => 'K',  X_EA => X_CA,  X_FA => X_DA,  X_BA => X_AA,\n+      'l' => 'L',  X_EB => X_CB,  X_FB => X_DB,  X_BB => X_AB,\n+      'm' => 'M',  X_EC => X_CC,  X_FC => X_DC,  X_BC => X_AC,\n+      'n' => 'N',  X_ED => X_CD,  X_FD => X_DD,\n+      'o' => 'O',  X_EE => X_CE,  X_FE => X_DE,  X_BE => X_AE,\n+      'p' => 'P',  X_EF => X_CF,\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',  X_C0 => X_C0,  X_D0 => X_D0,\n+      'B' => 'B',  X_C1 => X_C1,  X_D1 => X_D1,  X_A1 => X_A1,\n+      'C' => 'C',  X_C2 => X_C2,  X_D2 => X_D2,\n+      'D' => 'D',  X_C3 => X_C3,  X_D3 => X_D3,  X_A3 => X_A3,\n+      'E' => 'E',  X_C4 => X_C4,  X_D4 => X_D4,\n+      'F' => 'F',  X_C5 => X_C5,  X_D5 => X_D5,  X_A5 => X_A5,\n+      'G' => 'G',  X_C6 => X_C6,  X_D6 => X_D6,  X_A6 => X_A6,\n+      'H' => 'H',  X_C7 => X_C7,\n+      'I' => 'I',  X_C8 => X_C8,  X_D8 => X_D8,\n+      'J' => 'J',  X_C9 => X_C9,  X_D9 => X_D9,  X_A9 => X_A9,\n+      'K' => 'K',  X_CA => X_CA,  X_DA => X_DA,  X_AA => X_AA,\n+      'L' => 'L',  X_CB => X_CB,  X_DB => X_DB,  X_AB => X_AB,\n+      'M' => 'M',  X_CC => X_CC,  X_DC => X_DC,  X_AC => X_AC,\n+      'N' => 'N',  X_CD => X_CD,  X_DD => X_DD,\n+      'O' => 'O',  X_CE => X_CE,  X_DE => X_DE,  X_AE => X_AE,\n+      'P' => 'P',  X_CF => X_CF,\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   --------------------------------------------\n+   -- Definitions for IBM PC (Code Page 437) --\n+   --------------------------------------------\n+\n+   --  Note: Code page 437 is the typical default in DOS, Windows and OS/2\n+   --  for PC's in the US, it corresponds to the original PC character set.\n+   --  See also the definitions for code page 850.\n+\n+   Fold_IBM_PC_437 : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',\n+      'b' => 'B',\n+      'c' => 'C',\n+      'd' => 'D',\n+      'e' => 'E',\n+      'f' => 'F',\n+      'g' => 'G',\n+      'h' => 'H',\n+      'i' => 'I',\n+      'j' => 'J',\n+      'k' => 'K',\n+      'l' => 'L',\n+      'm' => 'M',\n+      'n' => 'N',\n+      'o' => 'O',\n+      'p' => 'P',\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',\n+      'B' => 'B',\n+      'C' => 'C',\n+      'D' => 'D',\n+      'E' => 'E',\n+      'F' => 'F',\n+      'G' => 'G',\n+      'H' => 'H',\n+      'I' => 'I',\n+      'J' => 'J',\n+      'K' => 'K',\n+      'L' => 'L',\n+      'M' => 'M',\n+      'N' => 'N',\n+      'O' => 'O',\n+      'P' => 'P',\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      X_80 => X_80,  -- C cedilla\n+      X_81 => X_9A,  -- u umlaut\n+      X_82 => X_90,  -- e acute\n+      X_83 => X_83,  -- a circumflex\n+      X_84 => X_8E,  -- a umlaut\n+      X_85 => X_85,  -- a grave\n+      X_86 => X_8F,  -- a ring\n+      X_87 => X_80,  -- c cedilla\n+      X_88 => X_88,  -- e circumflex\n+      X_89 => X_89,  -- e umlaut\n+      X_8A => X_8A,  -- e grave\n+      X_8B => X_8B,  -- i umlaut\n+      X_8C => X_8C,  -- i circumflex\n+      X_8D => X_8D,  -- i grave\n+      X_8E => X_8E,  -- A umlaut\n+      X_8F => X_8F,  -- A ring\n+\n+      X_90 => X_90,  -- E acute\n+      X_91 => X_92,  -- ae\n+      X_92 => X_92,  -- AE\n+      X_93 => X_93,  -- o circumflex\n+      X_94 => X_99,  -- o umlaut\n+      X_95 => X_95,  -- o grave\n+      X_96 => X_96,  -- u circumflex\n+      X_97 => X_97,  -- u grave\n+      X_98 => X_98,  -- y umlaut\n+      X_99 => X_99,  -- O umlaut\n+      X_9A => X_9A,  -- U umlaut\n+\n+      X_A0 => X_A0,  -- a acute\n+      X_A1 => X_A1,  -- i acute\n+      X_A2 => X_A2,  -- o acute\n+      X_A3 => X_A3,  -- u acute\n+      X_A4 => X_A5,  -- n tilde\n+      X_A5 => X_A5,  -- N tilde\n+      X_A6 => X_A6,  -- a underline\n+      X_A7 => X_A7,  -- o underline\n+\n+      X_E0 => X_E0,  -- lower case alpha\n+      X_E1 => X_E1,  -- lower case beta\n+      X_E2 => X_E2,  -- upper case gamma\n+      X_E3 => X_E3,  -- lower case pi\n+      X_E4 => X_E4,  -- upper case sigma (lower/upper sigma not equivalent)\n+      X_E5 => X_E5,  -- lower case sigma (lower/upper sigma not equivalent)\n+      X_E6 => X_E6,  -- lower case mu\n+      X_E7 => X_E7,  -- lower case tau\n+      X_E8 => X_E8,  -- upper case phi   (lower/upper phi not equivalent)\n+      X_E9 => X_E9,  -- lower case theta\n+      X_EA => X_EA,  -- upper case omega\n+      X_EB => X_EB,  -- lower case delta\n+      X_ED => X_ED,  -- lower case phi   (lower/upper phi not equivalent)\n+      X_EE => X_EE,  -- lower case epsilon\n+\n+      X_FC => X_FC,  -- lower case eta\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   --------------------------------------------\n+   -- Definitions for IBM PC (Code Page 850) --\n+   --------------------------------------------\n+\n+   --  Note: Code page 850 is the typical default in DOS, Windows and OS/2\n+   --  for PC's in Europe, it is an extension of the original PC character\n+   --  set to include the additional characters defined in ISO Latin-1.\n+   --  See also the definitions for code page 437.\n+\n+   Fold_IBM_PC_850 : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',\n+      'b' => 'B',\n+      'c' => 'C',\n+      'd' => 'D',\n+      'e' => 'E',\n+      'f' => 'F',\n+      'g' => 'G',\n+      'h' => 'H',\n+      'i' => 'I',\n+      'j' => 'J',\n+      'k' => 'K',\n+      'l' => 'L',\n+      'm' => 'M',\n+      'n' => 'N',\n+      'o' => 'O',\n+      'p' => 'P',\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',\n+      'B' => 'B',\n+      'C' => 'C',\n+      'D' => 'D',\n+      'E' => 'E',\n+      'F' => 'F',\n+      'G' => 'G',\n+      'H' => 'H',\n+      'I' => 'I',\n+      'J' => 'J',\n+      'K' => 'K',\n+      'L' => 'L',\n+      'M' => 'M',\n+      'N' => 'N',\n+      'O' => 'O',\n+      'P' => 'P',\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      X_80 => X_80,  -- C cedilla\n+      X_81 => X_9A,  -- u umlaut\n+      X_82 => X_90,  -- e acute\n+      X_83 => X_B6,  -- a circumflex\n+      X_84 => X_8E,  -- a umlaut\n+      X_85 => X_B7,  -- a grave\n+      X_86 => X_8F,  -- a ring\n+      X_87 => X_80,  -- c cedilla\n+      X_88 => X_D2,  -- e circumflex\n+      X_89 => X_D3,  -- e umlaut\n+      X_8A => X_D4,  -- e grave\n+      X_8B => X_D8,  -- i umlaut\n+      X_8C => X_D7,  -- i circumflex\n+      X_8D => X_DE,  -- i grave\n+      X_8E => X_8E,  -- A umlaut\n+      X_8F => X_8F,  -- A ring\n+\n+      X_90 => X_90,  -- E acute\n+      X_91 => X_92,  -- ae\n+      X_92 => X_92,  -- AE\n+      X_93 => X_E2,  -- o circumflex\n+      X_94 => X_99,  -- o umlaut\n+      X_95 => X_E3,  -- o grave\n+      X_96 => X_EA,  -- u circumflex\n+      X_97 => X_EB,  -- u grave\n+      X_98 => X_98,  -- y umlaut\n+      X_99 => X_99,  -- O umlaut\n+      X_9A => X_9A,  -- U umlaut\n+\n+      X_A0 => X_B5,  -- a acute\n+      X_A1 => X_D6,  -- i acute\n+      X_A2 => X_E0,  -- o acute\n+      X_A3 => X_E9,  -- u acute\n+      X_A4 => X_A5,  -- n tilde\n+      X_A5 => X_A5,  -- N tilde\n+      X_A6 => X_A6,  -- a underline\n+      X_A7 => X_A7,  -- o underline\n+\n+      X_B5 => X_B5,  -- A acute\n+      X_B6 => X_B6,  -- A circumflex\n+      X_B7 => X_B7,  -- A grave\n+\n+      X_C6 => X_C7,  -- a tilde\n+      X_C7 => X_C7,  -- A tilde\n+\n+      X_D0 => X_D1,  -- eth\n+      X_D1 => X_D1,  -- Eth\n+      X_D2 => X_D2,  -- E circumflex\n+      X_D3 => X_D3,  -- E umlaut\n+      X_D4 => X_D4,  -- E grave\n+      X_D5 => X_D5,  -- dotless i, no uppercase\n+      X_D6 => X_D6,  -- I acute\n+      X_D7 => X_D7,  -- I circumflex\n+      X_D8 => X_D8,  -- I umlaut\n+      X_DE => X_DE,  -- I grave\n+\n+      X_E0 => X_E0,  -- O acute\n+      X_E1 => X_E1,  -- german dbl s, no uppercase\n+      X_E2 => X_E2,  -- O circumflex\n+      X_E3 => X_E3,  -- O grave\n+      X_E4 => X_E4,  -- o tilde\n+      X_E5 => X_E5,  -- O tilde\n+      X_E7 => X_E8,  -- thorn\n+      X_E8 => X_E8,  -- Thorn\n+      X_E9 => X_E9,  -- U acute\n+      X_EA => X_EA,  -- U circumflex\n+      X_EB => X_EB,  -- U grave\n+      X_EC => X_ED,  -- y acute\n+      X_ED => X_ED,  -- Y acute\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   -----------------------------------------\n+   -- Definitions for Full Upper Half Set --\n+   -----------------------------------------\n+\n+   --  The full upper half set allows all upper half characters as letters,\n+   --  and does not recognize any upper/lower case equivalences in this half.\n+\n+   Fold_Full_Upper_Half : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',\n+      'b' => 'B',\n+      'c' => 'C',\n+      'd' => 'D',\n+      'e' => 'E',\n+      'f' => 'F',\n+      'g' => 'G',\n+      'h' => 'H',\n+      'i' => 'I',\n+      'j' => 'J',\n+      'k' => 'K',\n+      'l' => 'L',\n+      'm' => 'M',\n+      'n' => 'N',\n+      'o' => 'O',\n+      'p' => 'P',\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',\n+      'B' => 'B',\n+      'C' => 'C',\n+      'D' => 'D',\n+      'E' => 'E',\n+      'F' => 'F',\n+      'G' => 'G',\n+      'H' => 'H',\n+      'I' => 'I',\n+      'J' => 'J',\n+      'K' => 'K',\n+      'L' => 'L',\n+      'M' => 'M',\n+      'N' => 'N',\n+      'O' => 'O',\n+      'P' => 'P',\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      X_80 => X_80,  X_90 => X_90,  X_A0 => X_A0,  X_B0 => X_B0,\n+      X_81 => X_81,  X_91 => X_91,  X_A1 => X_A1,  X_B1 => X_B1,\n+      X_82 => X_82,  X_92 => X_92,  X_A2 => X_A2,  X_B2 => X_B2,\n+      X_83 => X_83,  X_93 => X_93,  X_A3 => X_A3,  X_B3 => X_B3,\n+      X_84 => X_84,  X_94 => X_94,  X_A4 => X_A4,  X_B4 => X_B4,\n+      X_85 => X_85,  X_95 => X_95,  X_A5 => X_A5,  X_B5 => X_B5,\n+      X_86 => X_86,  X_96 => X_96,  X_A6 => X_A6,  X_B6 => X_B6,\n+      X_87 => X_87,  X_97 => X_97,  X_A7 => X_A7,  X_B7 => X_B7,\n+      X_88 => X_88,  X_98 => X_98,  X_A8 => X_A8,  X_B8 => X_B8,\n+      X_89 => X_89,  X_99 => X_99,  X_A9 => X_A9,  X_B9 => X_B9,\n+      X_8A => X_8A,  X_9A => X_9A,  X_AA => X_AA,  X_BA => X_BA,\n+      X_8B => X_8B,  X_9B => X_9B,  X_AB => X_AB,  X_BB => X_BB,\n+      X_8C => X_8C,  X_9C => X_9C,  X_AC => X_AC,  X_BC => X_BC,\n+      X_8D => X_8D,  X_9D => X_9D,  X_AD => X_AD,  X_BD => X_BD,\n+      X_8E => X_8E,  X_9E => X_9E,  X_AE => X_AE,  X_BE => X_BE,\n+      X_8F => X_8F,  X_9F => X_9F,  X_AF => X_AF,  X_BF => X_BF,\n+\n+      X_C0 => X_C0,  X_D0 => X_D0,  X_E0 => X_E0,  X_F0 => X_F0,\n+      X_C1 => X_C1,  X_D1 => X_D1,  X_E1 => X_E1,  X_F1 => X_F1,\n+      X_C2 => X_C2,  X_D2 => X_D2,  X_E2 => X_E2,  X_F2 => X_F2,\n+      X_C3 => X_C3,  X_D3 => X_D3,  X_E3 => X_E3,  X_F3 => X_F3,\n+      X_C4 => X_C4,  X_D4 => X_D4,  X_E4 => X_E4,  X_F4 => X_F4,\n+      X_C5 => X_C5,  X_D5 => X_D5,  X_E5 => X_E5,  X_F5 => X_F5,\n+      X_C6 => X_C6,  X_D6 => X_D6,  X_E6 => X_E6,  X_F6 => X_F6,\n+      X_C7 => X_C7,  X_D7 => X_D7,  X_E7 => X_E7,  X_F7 => X_F7,\n+      X_C8 => X_C8,  X_D8 => X_D8,  X_E8 => X_E8,  X_F8 => X_F8,\n+      X_C9 => X_C9,  X_D9 => X_D9,  X_E9 => X_E9,  X_F9 => X_F9,\n+      X_CA => X_CA,  X_DA => X_DA,  X_EA => X_EA,  X_FA => X_FA,\n+      X_CB => X_CB,  X_DB => X_DB,  X_EB => X_EB,  X_FB => X_FB,\n+      X_CC => X_CC,  X_DC => X_DC,  X_EC => X_EC,  X_FC => X_FC,\n+      X_CD => X_CD,  X_DD => X_DD,  X_ED => X_ED,  X_FD => X_FD,\n+      X_CE => X_CE,  X_DE => X_DE,  X_EE => X_EE,  X_FE => X_FE,\n+      X_CF => X_CF,  X_DF => X_DF,  X_EF => X_EF,  X_FF => X_FF,\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   ---------------------------------------\n+   -- Definitions for No Upper Half Set --\n+   ---------------------------------------\n+\n+   --  The no upper half set allows no upper half characters as letters, and\n+   --  thus there are no upper/lower case equivalences in this half. This set\n+   --  corresponds to the Ada 83 rules.\n+\n+   Fold_No_Upper_Half : Translate_Table := Translate_Table'(\n+\n+      'a' => 'A',\n+      'b' => 'B',\n+      'c' => 'C',\n+      'd' => 'D',\n+      'e' => 'E',\n+      'f' => 'F',\n+      'g' => 'G',\n+      'h' => 'H',\n+      'i' => 'I',\n+      'j' => 'J',\n+      'k' => 'K',\n+      'l' => 'L',\n+      'm' => 'M',\n+      'n' => 'N',\n+      'o' => 'O',\n+      'p' => 'P',\n+      'q' => 'Q',\n+      'r' => 'R',\n+      's' => 'S',\n+      't' => 'T',\n+      'u' => 'U',\n+      'v' => 'V',\n+      'w' => 'W',\n+      'x' => 'X',\n+      'y' => 'Y',\n+      'z' => 'Z',\n+\n+      'A' => 'A',\n+      'B' => 'B',\n+      'C' => 'C',\n+      'D' => 'D',\n+      'E' => 'E',\n+      'F' => 'F',\n+      'G' => 'G',\n+      'H' => 'H',\n+      'I' => 'I',\n+      'J' => 'J',\n+      'K' => 'K',\n+      'L' => 'L',\n+      'M' => 'M',\n+      'N' => 'N',\n+      'O' => 'O',\n+      'P' => 'P',\n+      'Q' => 'Q',\n+      'R' => 'R',\n+      'S' => 'S',\n+      'T' => 'T',\n+      'U' => 'U',\n+      'V' => 'V',\n+      'W' => 'W',\n+      'X' => 'X',\n+      'Y' => 'Y',\n+      'Z' => 'Z',\n+\n+      '0' => '0',\n+      '1' => '1',\n+      '2' => '2',\n+      '3' => '3',\n+      '4' => '4',\n+      '5' => '5',\n+      '6' => '6',\n+      '7' => '7',\n+      '8' => '8',\n+      '9' => '9',\n+\n+      '_' => '_',\n+\n+      others => ' ');\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+\n+      --  Set Fold_Upper table from source code indication\n+\n+      if Identifier_Character_Set = '1'\n+        or else Identifier_Character_Set = 'w'\n+      then\n+         Fold_Upper := Fold_Latin_1;\n+\n+      elsif Identifier_Character_Set = '2' then\n+         Fold_Upper := Fold_Latin_2;\n+\n+      elsif Identifier_Character_Set = '3' then\n+         Fold_Upper := Fold_Latin_3;\n+\n+      elsif Identifier_Character_Set = '4' then\n+         Fold_Upper := Fold_Latin_4;\n+\n+      elsif Identifier_Character_Set = 'p' then\n+         Fold_Upper := Fold_IBM_PC_437;\n+\n+      elsif Identifier_Character_Set = '8' then\n+         Fold_Upper := Fold_IBM_PC_850;\n+\n+      elsif Identifier_Character_Set = 'f' then\n+         Fold_Upper := Fold_Full_Upper_Half;\n+\n+      else -- Identifier_Character_Set = 'n'\n+         Fold_Upper := Fold_No_Upper_Half;\n+      end if;\n+\n+      --  Use Fold_Upper table to compute Fold_Lower table\n+\n+      Fold_Lower := Fold_Upper;\n+\n+      for J in Character loop\n+         if J /= Fold_Upper (J) then\n+            Fold_Lower (Fold_Upper (J)) := J;\n+            Fold_Lower (J) := J;\n+         end if;\n+      end loop;\n+\n+      Fold_Lower (' ') := ' ';\n+\n+      --  Build Identifier_Char table from used entries of Fold_Upper\n+\n+      for J in Character loop\n+         Identifier_Char (J) := (Fold_Upper (J) /= ' ');\n+      end loop;\n+\n+      --  Always add [ as an identifier character to deal with the brackets\n+      --  notation for wide characters used in identifiers. Note that if\n+      --  we are not allowing wide characters in identifiers, then any use\n+      --  of this notation will be flagged as an error in Scan_Identifier.\n+\n+      Identifier_Char ('[') := True;\n+\n+      --  Add entry for ESC if wide characters in use with a wide character\n+      --  encoding method active that uses the ESC code for encoding. Also\n+      --  add entry for left bracket to capture use of brackets notation.\n+\n+      if Identifier_Character_Set = 'w'\n+        and then Wide_Character_Encoding_Method in WC_ESC_Encoding_Method\n+      then\n+         Identifier_Char (ASCII.ESC) := True;\n+      end if;\n+   end Initialize;\n+\n+   --------------------------\n+   -- Is_Lower_Case_Letter --\n+   --------------------------\n+\n+   function Is_Lower_Case_Letter (C : Character) return Boolean is\n+   begin\n+      return C /= Fold_Upper (C);\n+   end Is_Lower_Case_Letter;\n+\n+   --------------------------\n+   -- Is_Upper_Case_Letter --\n+   --------------------------\n+\n+   function Is_Upper_Case_Letter (C : Character) return Boolean is\n+   begin\n+      return C /= Fold_Lower (C);\n+   end Is_Upper_Case_Letter;\n+\n+end Csets;"}, {"sha": "8ed7fb1dac419f3617d38f5e5a302caa3dac07c7", "filename": "gcc/ada/csets.ads", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcsets.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcsets.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsets.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,99 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                C S E T S                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.16 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Csets is\n+pragma Elaborate_Body (Csets);\n+\n+   --  This package contains character tables for the various character\n+   --  sets that are supported for source representation. Character and\n+   --  string literals are not affected, only identifiers. For each set,\n+   --  the table in this package gives the mapping of letters to their\n+   --  upper case equivalent. Each table thus provides the information\n+   --  for building the table used to fold lower case to upper case, and\n+   --  also the table of flags showing which characters are allowed in\n+   --  identifiers.\n+\n+   type Translate_Table is array (Character) of Character;\n+   --  Type used to describe translate tables\n+\n+   type Char_Array_Flags is array (Character) of Boolean;\n+   --  Type used for character attribute arrays. Note that we deliberately\n+   --  do NOT pack this table, since we don't want the extra overhead of\n+   --  accessing a packed bit string.\n+\n+   -----------------------------------------------\n+   --  Character Tables For Current Compilation --\n+   -----------------------------------------------\n+\n+   procedure Initialize;\n+   --  Routine to initialize following character tables, whose content depends\n+   --  on the character code being used to represent the source program. In\n+   --  particular, the use of the upper half of the 8-bit code set varies.\n+   --  The character set in use is specified by the value stored in\n+   --  Opt.Identifier_Character_Set, which has the following settings:\n+\n+   --    '1'  Latin-1\n+   --    '2'  Latin-2\n+   --    '3'  Latin-3\n+   --    '4'  Latin-4\n+   --    'p'  IBM PC (code page 437)\n+   --    '8'  IBM PC (code page 850)\n+   --    'f'  Full upper set (all distinct)\n+   --    'n'  No upper characters (Ada/83 rules)\n+   --    'w'  Latin-1 plus wide characters also allowed\n+\n+   function Is_Upper_Case_Letter (C : Character) return Boolean;\n+   pragma Inline (Is_Upper_Case_Letter);\n+   --  Determine if character is upper case letter\n+\n+   function Is_Lower_Case_Letter (C : Character) return Boolean;\n+   pragma Inline (Is_Lower_Case_Letter);\n+   --  Determine if character is lower case letter\n+\n+   Fold_Upper : Translate_Table;\n+   --  Table to fold lower case identifier letters to upper case\n+\n+   Fold_Lower : Translate_Table;\n+   --  Table to fold upper case identifier letters to lower case\n+\n+   Identifier_Char : Char_Array_Flags;\n+   --  This table has True entries for all characters that can legally appear\n+   --  in identifiers, including digits, the underline character, all letters\n+   --  including upper and lower case and extended letters (as controlled by\n+   --  the setting of Opt.Identifier_Character_Set, left bracket for brackets\n+   --  notation wide characters and also ESC if wide characters are permitted\n+   --  in identifiers using escape sequences starting with ESC.\n+\n+end Csets;"}, {"sha": "5f167fb3b0c7dd1d422b777c018bec33b14adcec", "filename": "gcc/ada/cstand.adb", "status": "added", "additions": 1518, "deletions": 0, "changes": 1518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,1518 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               C S T A N D                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.213 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Csets;    use Csets;\n+with Debug;    use Debug;\n+with Einfo;    use Einfo;\n+with Layout;   use Layout;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n+with Ttypef;   use Ttypef;\n+with Sem_Mech; use Sem_Mech;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Uintp;    use Uintp;\n+with Urealp;   use Urealp;\n+\n+package body CStand is\n+\n+   Stloc  : constant Source_Ptr := Standard_Location;\n+   Staloc : constant Source_Ptr := Standard_ASCII_Location;\n+   --  Standard abbreviations used throughout this package\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Build_Float_Type (E : Entity_Id; Siz : Int; Digs : Int);\n+   --  Procedure to build standard predefined float base type. The first\n+   --  parameter is the entity for the type, and the second parameter\n+   --  is the size in bits. The third parameter is the digits value.\n+\n+   procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Int);\n+   --  Procedure to build standard predefined signed integer subtype. The\n+   --  first parameter is the entity for the subtype. The second parameter\n+   --  is the size in bits. The corresponding base type is not built by\n+   --  this routine but instead must be built by the caller where needed.\n+\n+   procedure Create_Operators;\n+   --  Make entries for each of the predefined operators in Standard\n+\n+   procedure Create_Unconstrained_Base_Type\n+     (E : Entity_Id;\n+      K : Entity_Kind);\n+   --  The predefined signed integer types are constrained subtypes which\n+   --  must have a corresponding unconstrained base type. This type is almost\n+   --  useless. The only place it has semantics is Subtypes_Statically_Match.\n+   --  Consequently, we arrange for it to be identical apart from the setting\n+   --  of the constrained bit. This routine takes an entity E for the Type,\n+   --  copies it to estabish the base type, then resets the Ekind of the\n+   --  original entity to K (the Ekind for the subtype). The Etype field of\n+   --  E is set by the call (to point to the created base type entity), and\n+   --  also the Is_Constrained flag of E is set.\n+   --\n+   --  To understand the exact requirement for this, see RM 3.5.4(11) which\n+   --  makes it clear that Integer, for example, is constrained, with the\n+   --  constraint bounds matching the bounds of the (unconstrained) base\n+   --  type. The point is that Integer and Integer'Base have identical\n+   --  bounds, but do not statically match, since a subtype with constraints\n+   --  never matches a subtype with no constraints.\n+\n+   function Identifier_For (S : Standard_Entity_Type) return Node_Id;\n+   --  Returns an identifier node with the same name as the defining\n+   --  identifier corresponding to the given Standard_Entity_Type value\n+\n+   procedure Make_Component\n+     (Rec : Entity_Id;\n+      Typ : Entity_Id;\n+      Nam : String);\n+   --  Build a record component with the given type and name, and append to\n+   --  the list of components of Rec.\n+\n+   function Make_Formal\n+     (Typ         : Entity_Id;\n+      Formal_Name : String)\n+      return        Entity_Id;\n+   --  Construct entity for subprogram formal with given name and type\n+\n+   function Make_Integer (V : Uint) return Node_Id;\n+   --  Builds integer literal with given value\n+\n+   procedure Make_Name (Id : Entity_Id; Nam : String);\n+   --  Make an entry in the names table for Nam, and set as Chars field of Id\n+\n+   function New_Operator (Op : Name_Id; Typ : Entity_Id) return Entity_Id;\n+   --  Build entity for standard operator with given name and type.\n+\n+   function New_Standard_Entity\n+     (New_Node_Kind : Node_Kind := N_Defining_Identifier)\n+      return          Entity_Id;\n+   --  Builds a new entity for Standard\n+\n+   procedure Set_Integer_Bounds\n+     (Id  : Entity_Id;\n+      Typ : Entity_Id;\n+      Lb  : Uint;\n+      Hb  : Uint);\n+   --  Procedure to set bounds for integer type or subtype. Id is the entity\n+   --  whose bounds and type are to be set. The Typ parameter is the Etype\n+   --  value for the entity (which will be the same as Id for all predefined\n+   --  integer base types. The third and fourth parameters are the bounds.\n+\n+   ----------------------\n+   -- Build_Float_Type --\n+   ----------------------\n+\n+   procedure Build_Float_Type (E : Entity_Id; Siz : Int; Digs : Int) is\n+   begin\n+      Set_Type_Definition (Parent (E),\n+        Make_Floating_Point_Definition (Stloc,\n+          Digits_Expression => Make_Integer (UI_From_Int (Digs))));\n+      Set_Ekind                      (E, E_Floating_Point_Type);\n+      Set_Etype                      (E, E);\n+      Init_Size                      (E, Siz);\n+      Set_Prim_Alignment             (E);\n+      Init_Digits_Value              (E, Digs);\n+      Set_Float_Bounds               (E);\n+      Set_Is_Frozen                  (E);\n+      Set_Is_Public                  (E);\n+      Set_Size_Known_At_Compile_Time (E);\n+   end Build_Float_Type;\n+\n+   -------------------------------\n+   -- Build_Signed_Integer_Type --\n+   -------------------------------\n+\n+   procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Int) is\n+      U2Siz1 : constant Uint := 2 ** (Siz - 1);\n+      Lbound : constant Uint := -U2Siz1;\n+      Ubound : constant Uint := U2Siz1 - 1;\n+\n+   begin\n+      Set_Type_Definition (Parent (E),\n+        Make_Signed_Integer_Type_Definition (Stloc,\n+          Low_Bound  => Make_Integer (Lbound),\n+          High_Bound => Make_Integer (Ubound)));\n+\n+      Set_Ekind                      (E, E_Signed_Integer_Type);\n+      Set_Etype                      (E, E);\n+      Init_Size                      (E, Siz);\n+      Set_Prim_Alignment             (E);\n+      Set_Integer_Bounds             (E, E, Lbound, Ubound);\n+      Set_Is_Frozen                  (E);\n+      Set_Is_Public                  (E);\n+      Set_Is_Known_Valid             (E);\n+      Set_Size_Known_At_Compile_Time (E);\n+   end Build_Signed_Integer_Type;\n+\n+   ----------------------\n+   -- Create_Operators --\n+   ----------------------\n+\n+   --  Each operator has an abbreviated signature. The formals have the names\n+   --  LEFT and RIGHT. Their types are not actually used for resolution.\n+\n+   procedure Create_Operators is\n+      Op_Node : Entity_Id;\n+\n+      --  Following list has two entries for concatenation, to include\n+      --  explicitly the operation on wide strings.\n+\n+      Binary_Ops : constant array (S_Binary_Ops) of Name_Id :=\n+        (Name_Op_Add,      Name_Op_And,   Name_Op_Concat,   Name_Op_Concat,\n+         Name_Op_Divide,   Name_Op_Eq,    Name_Op_Expon,    Name_Op_Ge,\n+         Name_Op_Gt,       Name_Op_Le,    Name_Op_Lt,       Name_Op_Mod,\n+         Name_Op_Multiply, Name_Op_Ne,    Name_Op_Or,       Name_Op_Rem,\n+         Name_Op_Subtract, Name_Op_Xor);\n+\n+      Bin_Op_Types : constant array (S_Binary_Ops) of Entity_Id :=\n+        (Universal_Integer, Standard_Boolean,\n+         Standard_String,   Standard_Wide_String,\n+         Universal_Integer, Standard_Boolean,\n+         Universal_Integer, Standard_Boolean,\n+         Standard_Boolean,  Standard_Boolean,\n+         Standard_Boolean,  Universal_Integer,\n+         Universal_Integer, Standard_Boolean,\n+         Standard_Boolean,  Universal_Integer,\n+         Universal_Integer, Standard_Boolean);\n+\n+      Unary_Ops : constant array (S_Unary_Ops) of Name_Id :=\n+        (Name_Op_Abs, Name_Op_Subtract, Name_Op_Not, Name_Op_Add);\n+\n+      Unary_Op_Types : constant array (S_Unary_Ops) of Entity_Id :=\n+        (Universal_Integer, Universal_Integer,\n+         Standard_Boolean,  Universal_Integer);\n+\n+      --  Corresponding to Abs, Minus, Not, and Plus.\n+\n+   begin\n+      for J in S_Binary_Ops loop\n+         Op_Node := New_Operator (Binary_Ops (J), Bin_Op_Types (J));\n+         SE (J)  := Op_Node;\n+         Append_Entity (Make_Formal (Any_Type, \"LEFT\"),  Op_Node);\n+         Append_Entity (Make_Formal (Any_Type, \"RIGHT\"), Op_Node);\n+      end loop;\n+\n+      for J in S_Unary_Ops loop\n+         Op_Node := New_Operator (Unary_Ops (J), Unary_Op_Types (J));\n+         SE (J)  := Op_Node;\n+         Append_Entity (Make_Formal (Any_Type, \"RIGHT\"), Op_Node);\n+      end loop;\n+\n+      --  For concatenation, we create a separate operator for each\n+      --  array type. This simplifies the resolution of the component-\n+      --  component concatenation operation. In Standard, we set the types\n+      --  of the formals for string and wide string concatenation.\n+\n+      Set_Etype (First_Entity (Standard_Op_Concat),  Standard_String);\n+      Set_Etype (Last_Entity  (Standard_Op_Concat),  Standard_String);\n+\n+      Set_Etype (First_Entity (Standard_Op_Concatw), Standard_Wide_String);\n+      Set_Etype (Last_Entity  (Standard_Op_Concatw), Standard_Wide_String);\n+\n+   end Create_Operators;\n+\n+   ---------------------\n+   -- Create_Standard --\n+   ---------------------\n+\n+   --  The tree for the package Standard is prefixed to all compilations.\n+   --  Several entities required by semantic analysis are denoted by global\n+   --  variables that are initialized to point to the corresponding\n+   --  occurences in STANDARD. The visible entities of STANDARD are\n+   --  created here. The private entities defined in STANDARD are created\n+   --  by Initialize_Standard in the semantics module.\n+\n+   procedure Create_Standard is\n+      Decl_S : List_Id;\n+      --  List of declarations in Standard\n+\n+      Decl_A : List_Id;\n+      --  List of declarations in ASCII\n+\n+      Decl       : Node_Id;\n+      Pspec      : Node_Id;\n+      Tdef_Node  : Node_Id;\n+      Ident_Node : Node_Id;\n+      Ccode      : Char_Code;\n+      E_Id       : Entity_Id;\n+      R_Node     : Node_Id;\n+      B_Node     : Node_Id;\n+\n+      procedure Build_Exception (S : Standard_Entity_Type);\n+      --  Procedure to declare given entity as an exception\n+\n+      ---------------------\n+      -- Build_Exception --\n+      ---------------------\n+\n+      procedure Build_Exception (S : Standard_Entity_Type) is\n+      begin\n+         Set_Ekind          (Standard_Entity (S), E_Exception);\n+         Set_Etype          (Standard_Entity (S), Standard_Exception_Type);\n+         Set_Exception_Code (Standard_Entity (S), Uint_0);\n+         Set_Is_Public      (Standard_Entity (S), True);\n+\n+         Decl :=\n+           Make_Exception_Declaration (Stloc,\n+             Defining_Identifier => Standard_Entity (S));\n+         Append (Decl, Decl_S);\n+      end Build_Exception;\n+\n+   --  Start of processing for Create_Standard\n+\n+   begin\n+      Decl_S := New_List;\n+\n+      --  First step is to create defining identifiers for each entity\n+\n+      for S in Standard_Entity_Type loop\n+         declare\n+            S_Name : constant String := Standard_Entity_Type'Image (S);\n+            --  Name of entity (note we skip S_ at the start)\n+\n+            Ident_Node : Node_Id;\n+            --  Defining identifier node\n+\n+         begin\n+            Ident_Node := New_Standard_Entity;\n+            Make_Name (Ident_Node, S_Name (3 .. S_Name'Length));\n+            Standard_Entity (S) := Ident_Node;\n+         end;\n+      end loop;\n+\n+      --  Create package declaration node for package Standard\n+\n+      Standard_Package_Node := New_Node (N_Package_Declaration, Stloc);\n+\n+      Pspec := New_Node (N_Package_Specification, Stloc);\n+      Set_Specification (Standard_Package_Node, Pspec);\n+\n+      Set_Defining_Unit_Name (Pspec, Standard_Standard);\n+      Set_Visible_Declarations (Pspec, Decl_S);\n+\n+      Set_Ekind (Standard_Standard, E_Package);\n+      Set_Is_Pure (Standard_Standard);\n+      Set_Is_Compilation_Unit (Standard_Standard);\n+\n+      --  Create type declaration nodes for standard types\n+\n+      for S in S_Types loop\n+         Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+         Set_Defining_Identifier (Decl, Standard_Entity (S));\n+         Set_Is_Frozen (Standard_Entity (S));\n+         Set_Is_Public (Standard_Entity (S));\n+         Append (Decl, Decl_S);\n+      end loop;\n+\n+      --  Create type definition node for type Boolean. The Size is set to\n+      --  1 as required by Ada 95 and current ARG interpretations for Ada/83.\n+\n+      --  Note: Object_Size of Boolean is 8. This means that we do NOT in\n+      --  general know that Boolean variables have valid values, so we do\n+      --  not set the Is_Known_Valid flag.\n+\n+      Tdef_Node := New_Node (N_Enumeration_Type_Definition, Stloc);\n+      Set_Literals (Tdef_Node, New_List);\n+      Append (Standard_False, Literals (Tdef_Node));\n+      Append (Standard_True, Literals (Tdef_Node));\n+      Set_Type_Definition (Parent (Standard_Boolean), Tdef_Node);\n+\n+      Set_Ekind          (Standard_Boolean, E_Enumeration_Type);\n+      Set_First_Literal  (Standard_Boolean, Standard_False);\n+      Set_Etype          (Standard_Boolean, Standard_Boolean);\n+      Init_Esize         (Standard_Boolean, 8);\n+      Init_RM_Size       (Standard_Boolean, 1);\n+      Set_Prim_Alignment (Standard_Boolean);\n+\n+      Set_Is_Unsigned_Type           (Standard_Boolean);\n+      Set_Size_Known_At_Compile_Time (Standard_Boolean);\n+\n+      Set_Ekind           (Standard_True, E_Enumeration_Literal);\n+      Set_Etype           (Standard_True, Standard_Boolean);\n+      Set_Enumeration_Pos (Standard_True, Uint_1);\n+      Set_Enumeration_Rep (Standard_True, Uint_1);\n+      Set_Is_Known_Valid  (Standard_True, True);\n+\n+      Set_Ekind           (Standard_False, E_Enumeration_Literal);\n+      Set_Etype           (Standard_False, Standard_Boolean);\n+      Set_Enumeration_Pos (Standard_False, Uint_0);\n+      Set_Enumeration_Rep (Standard_False, Uint_0);\n+      Set_Is_Known_Valid  (Standard_False, True);\n+\n+      --  For the bounds of Boolean, we create a range node corresponding to\n+\n+      --    range False .. True\n+\n+      --  where the occurrences of the literals must point to the\n+      --  corresponding  definition.\n+\n+      R_Node := New_Node (N_Range, Stloc);\n+      B_Node := New_Node (N_Identifier, Stloc);\n+      Set_Chars  (B_Node, Chars (Standard_False));\n+      Set_Entity (B_Node,  Standard_False);\n+      Set_Etype  (B_Node, Standard_Boolean);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Low_Bound  (R_Node, B_Node);\n+\n+      B_Node := New_Node (N_Identifier, Stloc);\n+      Set_Chars  (B_Node, Chars (Standard_True));\n+      Set_Entity (B_Node,  Standard_True);\n+      Set_Etype  (B_Node, Standard_Boolean);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_High_Bound (R_Node, B_Node);\n+\n+      Set_Scalar_Range (Standard_Boolean, R_Node);\n+      Set_Etype (R_Node, Standard_Boolean);\n+      Set_Parent (R_Node, Standard_Boolean);\n+\n+      --  Create type definition nodes for predefined integer types\n+\n+      Build_Signed_Integer_Type\n+        (Standard_Short_Short_Integer, Standard_Short_Short_Integer_Size);\n+\n+      Build_Signed_Integer_Type\n+        (Standard_Short_Integer, Standard_Short_Integer_Size);\n+\n+      Build_Signed_Integer_Type\n+        (Standard_Integer, Standard_Integer_Size);\n+\n+      declare\n+         LIS : Nat;\n+\n+      begin\n+         if Debug_Flag_M then\n+            LIS := 64;\n+         else\n+            LIS := Standard_Long_Integer_Size;\n+         end if;\n+\n+         Build_Signed_Integer_Type (Standard_Long_Integer, LIS);\n+      end;\n+\n+      Build_Signed_Integer_Type\n+        (Standard_Long_Long_Integer, Standard_Long_Long_Integer_Size);\n+\n+      Create_Unconstrained_Base_Type\n+        (Standard_Short_Short_Integer, E_Signed_Integer_Subtype);\n+\n+      Create_Unconstrained_Base_Type\n+        (Standard_Short_Integer, E_Signed_Integer_Subtype);\n+\n+      Create_Unconstrained_Base_Type\n+        (Standard_Integer, E_Signed_Integer_Subtype);\n+\n+      Create_Unconstrained_Base_Type\n+        (Standard_Long_Integer, E_Signed_Integer_Subtype);\n+\n+      Create_Unconstrained_Base_Type\n+        (Standard_Long_Long_Integer, E_Signed_Integer_Subtype);\n+\n+      --  Create type definition nodes for predefined float types\n+\n+      Build_Float_Type\n+        (Standard_Short_Float,\n+         Standard_Short_Float_Size,\n+         Standard_Short_Float_Digits);\n+\n+      Build_Float_Type\n+        (Standard_Float,\n+         Standard_Float_Size,\n+         Standard_Float_Digits);\n+\n+      Build_Float_Type\n+        (Standard_Long_Float,\n+         Standard_Long_Float_Size,\n+         Standard_Long_Float_Digits);\n+\n+      Build_Float_Type\n+        (Standard_Long_Long_Float,\n+         Standard_Long_Long_Float_Size,\n+         Standard_Long_Long_Float_Digits);\n+\n+      --  Create type definition node for type Character. Note that we do not\n+      --  set the Literals field, since type Character is handled with special\n+      --  routine that do not need a literal list.\n+\n+      Tdef_Node := New_Node (N_Enumeration_Type_Definition, Stloc);\n+      Set_Type_Definition (Parent (Standard_Character), Tdef_Node);\n+\n+      Set_Ekind          (Standard_Character, E_Enumeration_Type);\n+      Set_Etype          (Standard_Character, Standard_Character);\n+      Init_Size          (Standard_Character, Standard_Character_Size);\n+      Set_Prim_Alignment (Standard_Character);\n+\n+      Set_Is_Unsigned_Type           (Standard_Character);\n+      Set_Is_Character_Type          (Standard_Character);\n+      Set_Is_Known_Valid             (Standard_Character);\n+      Set_Size_Known_At_Compile_Time (Standard_Character);\n+\n+      --  Create the bounds for type Character.\n+\n+      R_Node := New_Node (N_Range, Stloc);\n+\n+      --  Low bound for type Character (Standard.Nul)\n+\n+      B_Node := New_Node (N_Character_Literal, Stloc);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Chars                (B_Node, No_Name);\n+      Set_Char_Literal_Value   (B_Node, 16#00#);\n+      Set_Entity               (B_Node,  Empty);\n+      Set_Etype                (B_Node, Standard_Character);\n+      Set_Low_Bound (R_Node, B_Node);\n+\n+      --  High bound for type Character\n+\n+      B_Node := New_Node (N_Character_Literal, Stloc);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Chars                (B_Node, No_Name);\n+      Set_Char_Literal_Value   (B_Node, 16#FF#);\n+      Set_Entity               (B_Node,  Empty);\n+      Set_Etype                (B_Node, Standard_Character);\n+      Set_High_Bound (R_Node, B_Node);\n+\n+      Set_Scalar_Range (Standard_Character, R_Node);\n+      Set_Etype (R_Node, Standard_Character);\n+      Set_Parent (R_Node, Standard_Character);\n+\n+      --  Create type definition for type Wide_Character. Note that we do not\n+      --  set the Literals field, since type Wide_Character is handled with\n+      --  special routines that do not need a literal list.\n+\n+      Tdef_Node := New_Node (N_Enumeration_Type_Definition, Stloc);\n+      Set_Type_Definition (Parent (Standard_Wide_Character), Tdef_Node);\n+\n+      Set_Ekind      (Standard_Wide_Character, E_Enumeration_Type);\n+      Set_Etype      (Standard_Wide_Character, Standard_Wide_Character);\n+      Init_Size      (Standard_Wide_Character, Standard_Wide_Character_Size);\n+\n+      Set_Prim_Alignment             (Standard_Wide_Character);\n+      Set_Is_Unsigned_Type           (Standard_Wide_Character);\n+      Set_Is_Character_Type          (Standard_Wide_Character);\n+      Set_Is_Known_Valid             (Standard_Wide_Character);\n+      Set_Size_Known_At_Compile_Time (Standard_Wide_Character);\n+\n+      --  Create the bounds for type Wide_Character.\n+\n+      R_Node := New_Node (N_Range, Stloc);\n+\n+      --  Low bound for type Wide_Character\n+\n+      B_Node := New_Node (N_Character_Literal, Stloc);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Chars                (B_Node, No_Name);    --  ???\n+      Set_Char_Literal_Value   (B_Node, 16#0000#);\n+      Set_Entity               (B_Node,  Empty);\n+      Set_Etype                (B_Node, Standard_Wide_Character);\n+      Set_Low_Bound (R_Node, B_Node);\n+\n+      --  High bound for type Wide_Character\n+\n+      B_Node := New_Node (N_Character_Literal, Stloc);\n+      Set_Is_Static_Expression (B_Node);\n+      Set_Chars                (B_Node, No_Name);    --  ???\n+      Set_Char_Literal_Value   (B_Node, 16#FFFF#);\n+      Set_Entity               (B_Node,  Empty);\n+      Set_Etype                (B_Node, Standard_Wide_Character);\n+      Set_High_Bound           (R_Node, B_Node);\n+\n+      Set_Scalar_Range (Standard_Wide_Character, R_Node);\n+      Set_Etype (R_Node, Standard_Wide_Character);\n+      Set_Parent (R_Node, Standard_Wide_Character);\n+\n+      --  Create type definition node for type String\n+\n+      Tdef_Node := New_Node (N_Unconstrained_Array_Definition, Stloc);\n+      Set_Subtype_Indication (Tdef_Node, Identifier_For (S_Character));\n+      Set_Subtype_Marks      (Tdef_Node, New_List);\n+      Append (Identifier_For (S_Positive), Subtype_Marks (Tdef_Node));\n+      Set_Type_Definition (Parent (Standard_String), Tdef_Node);\n+\n+      Set_Ekind          (Standard_String, E_String_Type);\n+      Set_Etype          (Standard_String, Standard_String);\n+      Set_Component_Type (Standard_String, Standard_Character);\n+      Set_Component_Size (Standard_String, Uint_8);\n+      Init_Size_Align    (Standard_String);\n+\n+      --  Set index type of String\n+\n+      E_Id := First\n+        (Subtype_Marks (Type_Definition (Parent (Standard_String))));\n+      Set_First_Index (Standard_String, E_Id);\n+      Set_Entity (E_Id, Standard_Positive);\n+      Set_Etype (E_Id, Standard_Positive);\n+\n+      --  Create type definition node for type Wide_String\n+\n+      Tdef_Node := New_Node (N_Unconstrained_Array_Definition, Stloc);\n+      Set_Subtype_Indication (Tdef_Node, Identifier_For (S_Wide_Character));\n+      Set_Subtype_Marks (Tdef_Node, New_List);\n+      Append (Identifier_For (S_Positive), Subtype_Marks (Tdef_Node));\n+      Set_Type_Definition (Parent (Standard_Wide_String), Tdef_Node);\n+\n+      Set_Ekind          (Standard_Wide_String, E_String_Type);\n+      Set_Etype          (Standard_Wide_String, Standard_Wide_String);\n+      Set_Component_Type (Standard_Wide_String, Standard_Wide_Character);\n+      Set_Component_Size (Standard_Wide_String, Uint_16);\n+      Init_Size_Align    (Standard_Wide_String);\n+\n+      --  Set index type of Wide_String\n+\n+      E_Id := First\n+        (Subtype_Marks (Type_Definition (Parent (Standard_Wide_String))));\n+      Set_First_Index (Standard_Wide_String, E_Id);\n+      Set_Entity (E_Id, Standard_Positive);\n+      Set_Etype (E_Id, Standard_Positive);\n+\n+      --  Create subtype declaration for Natural\n+\n+      Decl := New_Node (N_Subtype_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Natural);\n+      Set_Subtype_Indication (Decl,\n+        New_Occurrence_Of (Standard_Integer, Stloc));\n+      Append (Decl, Decl_S);\n+\n+      Set_Ekind          (Standard_Natural, E_Signed_Integer_Subtype);\n+      Set_Etype          (Standard_Natural, Base_Type (Standard_Integer));\n+      Init_Esize         (Standard_Natural, Standard_Integer_Size);\n+      Init_RM_Size       (Standard_Natural, Standard_Integer_Size - 1);\n+      Set_Prim_Alignment (Standard_Natural);\n+      Set_Size_Known_At_Compile_Time\n+                         (Standard_Natural);\n+      Set_Integer_Bounds (Standard_Natural,\n+        Typ => Base_Type (Standard_Integer),\n+        Lb  => Uint_0,\n+        Hb  => Intval (High_Bound (Scalar_Range (Standard_Integer))));\n+      Set_Is_Constrained (Standard_Natural);\n+      Set_Is_Frozen      (Standard_Natural);\n+      Set_Is_Public      (Standard_Natural);\n+\n+      --  Create subtype declaration for Positive\n+\n+      Decl := New_Node (N_Subtype_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Positive);\n+      Set_Subtype_Indication (Decl,\n+        New_Occurrence_Of (Standard_Integer, Stloc));\n+      Append (Decl, Decl_S);\n+\n+      Set_Ekind          (Standard_Positive, E_Signed_Integer_Subtype);\n+      Set_Etype          (Standard_Positive, Base_Type (Standard_Integer));\n+      Init_Esize         (Standard_Positive, Standard_Integer_Size);\n+      Init_RM_Size       (Standard_Positive, Standard_Integer_Size - 1);\n+      Set_Prim_Alignment (Standard_Positive);\n+\n+      Set_Size_Known_At_Compile_Time (Standard_Positive);\n+\n+      Set_Integer_Bounds   (Standard_Positive,\n+         Typ => Base_Type (Standard_Integer),\n+         Lb  => Uint_1,\n+         Hb  => Intval (High_Bound (Scalar_Range (Standard_Integer))));\n+      Set_Is_Constrained   (Standard_Positive);\n+      Set_Is_Frozen        (Standard_Positive);\n+      Set_Is_Public        (Standard_Positive);\n+\n+      --  Create declaration for package ASCII\n+\n+      Decl := New_Node (N_Package_Declaration, Stloc);\n+      Append (Decl, Decl_S);\n+\n+      Pspec := New_Node (N_Package_Specification, Stloc);\n+      Set_Specification (Decl, Pspec);\n+\n+      Set_Defining_Unit_Name (Pspec, Standard_Entity (S_ASCII));\n+      Set_Ekind (Standard_Entity (S_ASCII), E_Package);\n+      Decl_A := New_List; -- for ASCII declarations\n+      Set_Visible_Declarations (Pspec, Decl_A);\n+\n+      --  Create control character definitions in package ASCII. Note that\n+      --  the character literal entries created here correspond to literal\n+      --  values that are impossible in the source, but can be represented\n+      --  internally with no difficulties.\n+\n+      Ccode := 16#00#;\n+\n+      for S in S_ASCII_Names loop\n+         Decl := New_Node (N_Object_Declaration, Staloc);\n+         Set_Constant_Present (Decl, True);\n+\n+         declare\n+            A_Char    : Entity_Id := Standard_Entity (S);\n+            Expr_Decl : Node_Id;\n+\n+         begin\n+            Set_Sloc                   (A_Char, Staloc);\n+            Set_Ekind                  (A_Char, E_Constant);\n+            Set_Not_Source_Assigned    (A_Char, True);\n+            Set_Is_True_Constant       (A_Char, True);\n+            Set_Etype                  (A_Char, Standard_Character);\n+            Set_Scope                  (A_Char, Standard_Entity (S_ASCII));\n+            Set_Is_Immediately_Visible (A_Char, False);\n+            Set_Is_Public              (A_Char, True);\n+            Set_Is_Known_Valid         (A_Char, True);\n+\n+            Append_Entity (A_Char, Standard_Entity (S_ASCII));\n+            Set_Defining_Identifier (Decl, A_Char);\n+\n+            Set_Object_Definition (Decl, Identifier_For (S_Character));\n+            Expr_Decl := New_Node (N_Character_Literal, Staloc);\n+            Set_Expression (Decl, Expr_Decl);\n+\n+            Set_Is_Static_Expression (Expr_Decl);\n+            Set_Chars                (Expr_Decl, No_Name);\n+            Set_Etype                (Expr_Decl, Standard_Character);\n+            Set_Char_Literal_Value   (Expr_Decl, Ccode);\n+         end;\n+\n+         Append (Decl, Decl_A);\n+\n+         --  Increment character code, dealing with non-contiguities\n+\n+         Ccode := Ccode + 1;\n+\n+         if Ccode = 16#20# then\n+            Ccode := 16#21#;\n+         elsif Ccode = 16#27# then\n+            Ccode := 16#3A#;\n+         elsif Ccode = 16#3C# then\n+            Ccode := 16#3F#;\n+         elsif Ccode = 16#41# then\n+            Ccode := 16#5B#;\n+         end if;\n+      end loop;\n+\n+      --  Create semantic phase entities\n+\n+      Standard_Void_Type := New_Standard_Entity;\n+      Set_Ekind       (Standard_Void_Type, E_Void);\n+      Set_Etype       (Standard_Void_Type, Standard_Void_Type);\n+      Init_Size_Align (Standard_Void_Type);\n+      Set_Scope       (Standard_Void_Type, Standard_Standard);\n+      Make_Name       (Standard_Void_Type, \"_void_type\");\n+\n+      --  The type field of packages is set to void\n+\n+      Set_Etype (Standard_Standard, Standard_Void_Type);\n+      Set_Etype (Standard_ASCII, Standard_Void_Type);\n+\n+      --  Standard_A_String is actually used in generated code, so it has a\n+      --  type name that is reasonable, but does not overlap any Ada name.\n+\n+      Standard_A_String := New_Standard_Entity;\n+      Set_Ekind      (Standard_A_String, E_Access_Type);\n+      Set_Scope      (Standard_A_String, Standard_Standard);\n+      Set_Etype      (Standard_A_String, Standard_A_String);\n+\n+      if Debug_Flag_6 then\n+         Init_Size   (Standard_A_String, System_Address_Size);\n+      else\n+         Init_Size   (Standard_A_String, System_Address_Size * 2);\n+      end if;\n+\n+      Init_Alignment (Standard_A_String);\n+\n+      Set_Directly_Designated_Type\n+                     (Standard_A_String, Standard_String);\n+      Make_Name      (Standard_A_String, \"access_string\");\n+\n+      Standard_A_Char := New_Standard_Entity;\n+      Set_Ekind          (Standard_A_Char, E_Access_Type);\n+      Set_Scope          (Standard_A_Char, Standard_Standard);\n+      Set_Etype          (Standard_A_Char, Standard_A_String);\n+      Init_Size          (Standard_A_Char, System_Address_Size);\n+      Set_Prim_Alignment (Standard_A_Char);\n+\n+      Set_Directly_Designated_Type (Standard_A_Char, Standard_Character);\n+      Make_Name     (Standard_A_Char, \"access_character\");\n+\n+      --  Note on type names. The type names for the following special types\n+      --  are constructed so that they will look reasonable should they ever\n+      --  appear in error messages etc, although in practice the use of the\n+      --  special insertion character } for types results in special handling\n+      --  of these type names in any case. The blanks in these names would\n+      --  trouble in Gigi, but that's OK here, since none of these types\n+      --  should ever get through to Gigi! Attributes of these types are\n+      --  filled out to minimize problems with cascaded errors (for example,\n+      --  Any_Integer is given reasonable and consistent type and size values)\n+\n+      Any_Type := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Any_Type);\n+      Set_Scope (Any_Type, Standard_Standard);\n+      Build_Signed_Integer_Type (Any_Type, Standard_Integer_Size);\n+      Make_Name (Any_Type, \"any type\");\n+\n+      Any_Id := New_Standard_Entity;\n+      Set_Ekind             (Any_Id, E_Variable);\n+      Set_Scope             (Any_Id, Standard_Standard);\n+      Set_Etype             (Any_Id, Any_Type);\n+      Init_Size_Align       (Any_Id);\n+      Make_Name             (Any_Id, \"any id\");\n+\n+      Any_Access := New_Standard_Entity;\n+      Set_Ekind             (Any_Access, E_Access_Type);\n+      Set_Scope             (Any_Access, Standard_Standard);\n+      Set_Etype             (Any_Access, Any_Access);\n+      Init_Size             (Any_Access, System_Address_Size);\n+      Set_Prim_Alignment    (Any_Access);\n+      Make_Name             (Any_Access, \"an access type\");\n+\n+      Any_Array := New_Standard_Entity;\n+      Set_Ekind             (Any_Array, E_String_Type);\n+      Set_Scope             (Any_Array, Standard_Standard);\n+      Set_Etype             (Any_Array, Any_Array);\n+      Set_Component_Type    (Any_Array, Any_Character);\n+      Init_Size_Align       (Any_Array);\n+      Make_Name             (Any_Array, \"an array type\");\n+\n+      Any_Boolean := New_Standard_Entity;\n+      Set_Ekind             (Any_Boolean, E_Enumeration_Type);\n+      Set_Scope             (Any_Boolean, Standard_Standard);\n+      Set_Etype             (Any_Boolean, Standard_Boolean);\n+      Init_Esize            (Any_Boolean, 8);\n+      Init_RM_Size          (Any_Boolean, 1);\n+      Set_Prim_Alignment    (Any_Boolean);\n+      Set_Is_Unsigned_Type  (Any_Boolean);\n+      Set_Scalar_Range      (Any_Boolean, Scalar_Range (Standard_Boolean));\n+      Make_Name             (Any_Boolean, \"a boolean type\");\n+\n+      Any_Character := New_Standard_Entity;\n+      Set_Ekind             (Any_Character, E_Enumeration_Type);\n+      Set_Scope             (Any_Character, Standard_Standard);\n+      Set_Etype             (Any_Character, Any_Character);\n+      Set_Is_Unsigned_Type  (Any_Character);\n+      Set_Is_Character_Type (Any_Character);\n+      Init_Size             (Any_Character, Standard_Character_Size);\n+      Set_Prim_Alignment    (Any_Character);\n+      Set_Scalar_Range      (Any_Character, Scalar_Range (Standard_Character));\n+      Make_Name             (Any_Character, \"a character type\");\n+\n+      Any_Composite := New_Standard_Entity;\n+      Set_Ekind             (Any_Composite, E_Array_Type);\n+      Set_Scope             (Any_Composite, Standard_Standard);\n+      Set_Etype             (Any_Composite, Any_Composite);\n+      Set_Component_Size    (Any_Composite, Uint_0);\n+      Set_Component_Type    (Any_Composite, Standard_Integer);\n+      Init_Size_Align       (Any_Composite);\n+      Make_Name             (Any_Composite, \"a composite type\");\n+\n+      Any_Discrete := New_Standard_Entity;\n+      Set_Ekind             (Any_Discrete, E_Signed_Integer_Type);\n+      Set_Scope             (Any_Discrete, Standard_Standard);\n+      Set_Etype             (Any_Discrete, Any_Discrete);\n+      Init_Size             (Any_Discrete, Standard_Integer_Size);\n+      Set_Prim_Alignment    (Any_Discrete);\n+      Make_Name             (Any_Discrete, \"a discrete type\");\n+\n+      Any_Fixed := New_Standard_Entity;\n+      Set_Ekind             (Any_Fixed, E_Ordinary_Fixed_Point_Type);\n+      Set_Scope             (Any_Fixed, Standard_Standard);\n+      Set_Etype             (Any_Fixed, Any_Fixed);\n+      Init_Size             (Any_Fixed, Standard_Integer_Size);\n+      Set_Prim_Alignment    (Any_Fixed);\n+      Make_Name             (Any_Fixed, \"a fixed-point type\");\n+\n+      Any_Integer := New_Standard_Entity;\n+      Set_Ekind             (Any_Integer, E_Signed_Integer_Type);\n+      Set_Scope             (Any_Integer, Standard_Standard);\n+      Set_Etype             (Any_Integer, Standard_Long_Long_Integer);\n+      Init_Size             (Any_Integer, Standard_Long_Long_Integer_Size);\n+      Set_Prim_Alignment    (Any_Integer);\n+\n+      Set_Integer_Bounds\n+        (Any_Integer,\n+         Typ => Base_Type (Standard_Integer),\n+         Lb  => Uint_0,\n+         Hb  => Intval (High_Bound (Scalar_Range (Standard_Integer))));\n+      Make_Name (Any_Integer, \"an integer type\");\n+\n+      Any_Modular := New_Standard_Entity;\n+      Set_Ekind             (Any_Modular, E_Modular_Integer_Type);\n+      Set_Scope             (Any_Modular, Standard_Standard);\n+      Set_Etype             (Any_Modular, Standard_Long_Long_Integer);\n+      Init_Size             (Any_Modular, Standard_Long_Long_Integer_Size);\n+      Set_Prim_Alignment    (Any_Modular);\n+      Set_Is_Unsigned_Type  (Any_Modular);\n+      Make_Name             (Any_Modular, \"a modular type\");\n+\n+      Any_Numeric := New_Standard_Entity;\n+      Set_Ekind             (Any_Numeric, E_Signed_Integer_Type);\n+      Set_Scope             (Any_Numeric, Standard_Standard);\n+      Set_Etype             (Any_Numeric, Standard_Long_Long_Integer);\n+      Init_Size             (Any_Numeric, Standard_Long_Long_Integer_Size);\n+      Set_Prim_Alignment    (Any_Numeric);\n+      Make_Name             (Any_Numeric, \"a numeric type\");\n+\n+      Any_Real := New_Standard_Entity;\n+      Set_Ekind             (Any_Real, E_Floating_Point_Type);\n+      Set_Scope             (Any_Real, Standard_Standard);\n+      Set_Etype             (Any_Real, Standard_Long_Long_Float);\n+      Init_Size             (Any_Real, Standard_Long_Long_Float_Size);\n+      Set_Prim_Alignment    (Any_Real);\n+      Make_Name             (Any_Real, \"a real type\");\n+\n+      Any_Scalar := New_Standard_Entity;\n+      Set_Ekind             (Any_Scalar, E_Signed_Integer_Type);\n+      Set_Scope             (Any_Scalar, Standard_Standard);\n+      Set_Etype             (Any_Scalar, Any_Scalar);\n+      Init_Size             (Any_Scalar, Standard_Integer_Size);\n+      Set_Prim_Alignment    (Any_Scalar);\n+      Make_Name             (Any_Scalar, \"a scalar type\");\n+\n+      Any_String := New_Standard_Entity;\n+      Set_Ekind             (Any_String, E_String_Type);\n+      Set_Scope             (Any_String, Standard_Standard);\n+      Set_Etype             (Any_String, Any_String);\n+      Set_Component_Type    (Any_String, Any_Character);\n+      Init_Size_Align       (Any_String);\n+      Make_Name             (Any_String, \"a string type\");\n+\n+      declare\n+         Index   : Node_Id;\n+         Indexes : List_Id;\n+\n+      begin\n+         Index :=\n+           Make_Range (Stloc,\n+             Low_Bound  => Make_Integer (Uint_0),\n+             High_Bound => Make_Integer (Uint_2 ** Standard_Integer_Size));\n+         Indexes := New_List (Index);\n+         Set_Etype (Index, Standard_Integer);\n+         Set_First_Index (Any_String, Index);\n+      end;\n+\n+      Standard_Integer_8 := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Integer_8);\n+      Make_Name (Standard_Integer_8, \"integer_8\");\n+      Set_Scope (Standard_Integer_8, Standard_Standard);\n+      Build_Signed_Integer_Type (Standard_Integer_8, 8);\n+\n+      Standard_Integer_16 := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Integer_16);\n+      Make_Name (Standard_Integer_16, \"integer_16\");\n+      Set_Scope (Standard_Integer_16, Standard_Standard);\n+      Build_Signed_Integer_Type (Standard_Integer_16, 16);\n+\n+      Standard_Integer_32 := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Integer_32);\n+      Make_Name (Standard_Integer_32, \"integer_32\");\n+      Set_Scope (Standard_Integer_32, Standard_Standard);\n+      Build_Signed_Integer_Type (Standard_Integer_32, 32);\n+\n+      Standard_Integer_64 := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Integer_64);\n+      Make_Name (Standard_Integer_64, \"integer_64\");\n+      Set_Scope (Standard_Integer_64, Standard_Standard);\n+      Build_Signed_Integer_Type (Standard_Integer_64, 64);\n+\n+      Standard_Unsigned := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Unsigned);\n+      Make_Name (Standard_Unsigned, \"unsigned\");\n+\n+      Set_Ekind             (Standard_Unsigned, E_Modular_Integer_Type);\n+      Set_Scope             (Standard_Unsigned, Standard_Standard);\n+      Set_Etype             (Standard_Unsigned, Standard_Unsigned);\n+      Init_Size             (Standard_Unsigned, Standard_Integer_Size);\n+      Set_Prim_Alignment    (Standard_Unsigned);\n+      Set_Modulus           (Standard_Unsigned,\n+                              Uint_2 ** Standard_Integer_Size);\n+\n+      Set_Is_Unsigned_Type  (Standard_Unsigned);\n+\n+      R_Node := New_Node (N_Range, Stloc);\n+      Set_Low_Bound  (R_Node,\n+        Make_Integer_Literal (Stloc, 0));\n+      Set_High_Bound (R_Node,\n+        Make_Integer_Literal (Stloc, Modulus (Standard_Unsigned)));\n+      Set_Scalar_Range (Standard_Unsigned, R_Node);\n+\n+      --  Note: universal integer and universal real are constructed as fully\n+      --  formed signed numeric types, with parameters corresponding to the\n+      --  longest runtime types (Long_Long_Integer and Long_Long_Float). This\n+      --  allows Gigi to properly process references to universal types that\n+      --  are not folded at compile time.\n+\n+      Universal_Integer := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Universal_Integer);\n+      Make_Name (Universal_Integer, \"universal_integer\");\n+      Set_Scope (Universal_Integer, Standard_Standard);\n+      Build_Signed_Integer_Type\n+        (Universal_Integer, Standard_Long_Long_Integer_Size);\n+\n+      Universal_Real := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Universal_Real);\n+      Make_Name (Universal_Real, \"universal_real\");\n+      Set_Scope (Universal_Real, Standard_Standard);\n+      Build_Float_Type\n+        (Universal_Real,\n+         Standard_Long_Long_Float_Size,\n+         Standard_Long_Long_Float_Digits);\n+\n+      --  Note: universal fixed, unlike universal integer and universal real,\n+      --  is never used at runtime, so it does not need to have bounds set.\n+\n+      Universal_Fixed := New_Standard_Entity;\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Universal_Fixed);\n+      Make_Name            (Universal_Fixed, \"universal_fixed\");\n+      Set_Ekind            (Universal_Fixed, E_Ordinary_Fixed_Point_Type);\n+      Set_Etype            (Universal_Fixed, Universal_Fixed);\n+      Set_Scope            (Universal_Fixed, Standard_Standard);\n+      Init_Size            (Universal_Fixed, Standard_Long_Long_Integer_Size);\n+      Set_Prim_Alignment   (Universal_Fixed);\n+      Set_Size_Known_At_Compile_Time\n+                           (Universal_Fixed);\n+\n+      --  Create type declaration for Duration, using a 64-bit size.\n+      --  Delta is 1 nanosecond.\n+\n+      Build_Duration : declare\n+         Dlo : constant Uint := Intval (Type_Low_Bound (Standard_Integer_64));\n+         Dhi : constant Uint := Intval (Type_High_Bound (Standard_Integer_64));\n+\n+         Delta_Val : constant Ureal := UR_From_Components (Uint_1, Uint_9, 10);\n+\n+      begin\n+         Decl :=\n+           Make_Full_Type_Declaration (Stloc,\n+             Defining_Identifier => Standard_Duration,\n+             Type_Definition =>\n+               Make_Ordinary_Fixed_Point_Definition (Stloc,\n+                 Delta_Expression => Make_Real_Literal (Stloc, Delta_Val),\n+                 Real_Range_Specification =>\n+                   Make_Real_Range_Specification (Stloc,\n+                     Low_Bound  => Make_Real_Literal (Stloc,\n+                       Realval => Dlo * Delta_Val),\n+                     High_Bound => Make_Real_Literal (Stloc,\n+                       Realval => Dhi * Delta_Val))));\n+\n+         Set_Ekind          (Standard_Duration, E_Ordinary_Fixed_Point_Type);\n+         Set_Etype          (Standard_Duration, Standard_Duration);\n+         Init_Size          (Standard_Duration, 64);\n+         Set_Prim_Alignment (Standard_Duration);\n+         Set_Delta_Value    (Standard_Duration, Delta_Val);\n+         Set_Small_Value    (Standard_Duration, Delta_Val);\n+         Set_Scalar_Range   (Standard_Duration,\n+                              Real_Range_Specification\n+                                (Type_Definition (Decl)));\n+\n+         --  Normally it does not matter that nodes in package Standard are\n+         --  not marked as analyzed. The Scalar_Range of the fixed-point\n+         --  type Standard_Duration is an exception, because of the special\n+         --  test made in Freeze.Freeze_Fixed_Point_Type.\n+\n+         Set_Analyzed (Scalar_Range (Standard_Duration));\n+\n+         Set_Etype (Type_High_Bound (Standard_Duration), Standard_Duration);\n+         Set_Etype (Type_Low_Bound  (Standard_Duration), Standard_Duration);\n+\n+         Set_Is_Static_Expression (Type_High_Bound (Standard_Duration));\n+         Set_Is_Static_Expression (Type_Low_Bound  (Standard_Duration));\n+\n+         Set_Corresponding_Integer_Value\n+           (Type_High_Bound (Standard_Duration), Dhi);\n+\n+         Set_Corresponding_Integer_Value\n+           (Type_Low_Bound  (Standard_Duration), Dlo);\n+\n+         Set_Size_Known_At_Compile_Time (Standard_Duration);\n+      end Build_Duration;\n+\n+      --  Build standard exception type. Note that the type name here is\n+      --  actually used in the generated code, so it must be set correctly\n+\n+      Standard_Exception_Type := New_Standard_Entity;\n+      Set_Ekind       (Standard_Exception_Type, E_Record_Type);\n+      Set_Etype       (Standard_Exception_Type, Standard_Exception_Type);\n+      Set_Scope       (Standard_Exception_Type, Standard_Standard);\n+      Set_Girder_Constraint\n+                      (Standard_Exception_Type, No_Elist);\n+      Init_Size_Align (Standard_Exception_Type);\n+      Set_Size_Known_At_Compile_Time\n+                      (Standard_Exception_Type, True);\n+      Make_Name       (Standard_Exception_Type, \"exception\");\n+\n+      Make_Component  (Standard_Exception_Type, Standard_Boolean,\n+                                                 \"Not_Handled_By_Others\");\n+      Make_Component  (Standard_Exception_Type, Standard_Character, \"Lang\");\n+      Make_Component  (Standard_Exception_Type, Standard_Natural,\n+                                                           \"Name_Length\");\n+      Make_Component  (Standard_Exception_Type, Standard_A_Char,\n+                                                             \"Full_Name\");\n+      Make_Component  (Standard_Exception_Type, Standard_A_Char,\n+                                                            \"HTable_Ptr\");\n+      Make_Component  (Standard_Exception_Type, Standard_Integer,\n+                                                          \"Import_Code\");\n+\n+      --  Build tree for record declaration, for use by the back-end.\n+\n+      declare\n+         Comp_List : List_Id;\n+         Comp      : Entity_Id;\n+\n+      begin\n+         Comp      := First_Entity (Standard_Exception_Type);\n+         Comp_List := New_List;\n+\n+         while Present (Comp) loop\n+            Append (\n+              Make_Component_Declaration (Stloc,\n+                Defining_Identifier => Comp,\n+                Subtype_Indication => New_Occurrence_Of (Etype (Comp), Stloc)),\n+              Comp_List);\n+\n+            Next_Entity (Comp);\n+         end loop;\n+\n+         Decl := Make_Full_Type_Declaration (Stloc,\n+           Defining_Identifier => Standard_Exception_Type,\n+           Type_Definition =>\n+             Make_Record_Definition (Stloc,\n+               End_Label => Empty,\n+               Component_List =>\n+                 Make_Component_List (Stloc,\n+                   Component_Items => Comp_List)));\n+      end;\n+\n+      Append (Decl, Decl_S);\n+\n+      --  Create declarations of standard exceptions\n+\n+      Build_Exception (S_Constraint_Error);\n+      Build_Exception (S_Program_Error);\n+      Build_Exception (S_Storage_Error);\n+      Build_Exception (S_Tasking_Error);\n+\n+      --  Numeric_Error is a normal exception in Ada 83, but in Ada 95\n+      --  it is a renaming of Constraint_Error\n+\n+      if Ada_83 then\n+         Build_Exception (S_Numeric_Error);\n+\n+      else\n+         Decl := New_Node (N_Exception_Renaming_Declaration, Stloc);\n+         E_Id := Standard_Entity (S_Numeric_Error);\n+\n+         Set_Ekind          (E_Id, E_Exception);\n+         Set_Exception_Code (E_Id, Uint_0);\n+         Set_Etype          (E_Id, Standard_Exception_Type);\n+         Set_Is_Public      (E_Id);\n+         Set_Renamed_Entity (E_Id, Standard_Entity (S_Constraint_Error));\n+\n+         Set_Defining_Identifier (Decl, E_Id);\n+         Append (Decl, Decl_S);\n+\n+         Ident_Node := New_Node (N_Identifier, Stloc);\n+         Set_Chars  (Ident_Node, Chars (Standard_Entity (S_Constraint_Error)));\n+         Set_Entity (Ident_Node, Standard_Entity (S_Constraint_Error));\n+         Set_Name   (Decl, Ident_Node);\n+      end if;\n+\n+      --  Abort_Signal is an entity that does not get made visible\n+\n+      Abort_Signal := New_Standard_Entity;\n+      Set_Chars          (Abort_Signal, Name_uAbort_Signal);\n+      Set_Ekind          (Abort_Signal, E_Exception);\n+      Set_Exception_Code (Abort_Signal, Uint_0);\n+      Set_Etype          (Abort_Signal, Standard_Exception_Type);\n+      Set_Scope          (Abort_Signal, Standard_Standard);\n+      Set_Is_Public      (Abort_Signal, True);\n+      Decl :=\n+        Make_Exception_Declaration (Stloc,\n+          Defining_Identifier => Abort_Signal);\n+\n+      --  Create defining identifiers for shift operator entities. Note\n+      --  that these entities are used only for marking shift operators\n+      --  generated internally, and hence need no structure, just a name\n+      --  and a unique identity.\n+\n+      Standard_Op_Rotate_Left := New_Standard_Entity;\n+      Set_Chars (Standard_Op_Rotate_Left, Name_Rotate_Left);\n+      Set_Ekind (Standard_Op_Rotate_Left, E_Operator);\n+\n+      Standard_Op_Rotate_Right := New_Standard_Entity;\n+      Set_Chars (Standard_Op_Rotate_Right, Name_Rotate_Right);\n+      Set_Ekind (Standard_Op_Rotate_Right, E_Operator);\n+\n+      Standard_Op_Shift_Left := New_Standard_Entity;\n+      Set_Chars (Standard_Op_Shift_Left, Name_Shift_Left);\n+      Set_Ekind (Standard_Op_Shift_Left, E_Operator);\n+\n+      Standard_Op_Shift_Right := New_Standard_Entity;\n+      Set_Chars (Standard_Op_Shift_Right, Name_Shift_Right);\n+      Set_Ekind (Standard_Op_Shift_Right, E_Operator);\n+\n+      Standard_Op_Shift_Right_Arithmetic := New_Standard_Entity;\n+      Set_Chars (Standard_Op_Shift_Right_Arithmetic,\n+                                          Name_Shift_Right_Arithmetic);\n+      Set_Ekind (Standard_Op_Shift_Right_Arithmetic,\n+                                          E_Operator);\n+\n+      --  Create standard operator declarations\n+\n+      Create_Operators;\n+\n+      --  Initialize visibility table with entities in Standard\n+\n+      for E in Standard_Entity_Type loop\n+         if Ekind (Standard_Entity (E)) /= E_Operator then\n+            Set_Name_Entity_Id\n+              (Chars (Standard_Entity (E)), Standard_Entity (E));\n+            Set_Homonym (Standard_Entity (E), Empty);\n+         end if;\n+\n+         if E not in S_ASCII_Names then\n+            Set_Scope (Standard_Entity (E), Standard_Standard);\n+            Set_Is_Immediately_Visible (Standard_Entity (E));\n+         end if;\n+      end loop;\n+\n+      --  The predefined package Standard itself does not have a scope;\n+      --  it is the only entity in the system not to have one, and this\n+      --  is what identifies the package to Gigi.\n+\n+      Set_Scope (Standard_Standard, Empty);\n+\n+      --  Set global variables indicating last Id values and version\n+\n+      Last_Standard_Node_Id := Last_Node_Id;\n+      Last_Standard_List_Id := Last_List_Id;\n+\n+   end Create_Standard;\n+\n+   ------------------------------------\n+   -- Create_Unconstrained_Base_Type --\n+   ------------------------------------\n+\n+   procedure Create_Unconstrained_Base_Type\n+     (E : Entity_Id;\n+      K : Entity_Kind)\n+   is\n+      New_Ent : constant Entity_Id := New_Copy (E);\n+\n+   begin\n+      Set_Ekind          (E, K);\n+      Set_Is_Constrained (E, True);\n+      Set_Etype          (E, New_Ent);\n+\n+      Append_Entity (New_Ent, Standard_Standard);\n+      Set_Is_Constrained (New_Ent, False);\n+      Set_Etype          (New_Ent, New_Ent);\n+      Set_Is_Known_Valid (New_Ent, True);\n+\n+      if K = E_Signed_Integer_Subtype then\n+         Set_Etype (Low_Bound  (Scalar_Range (E)), New_Ent);\n+         Set_Etype (High_Bound (Scalar_Range (E)), New_Ent);\n+      end if;\n+\n+   end Create_Unconstrained_Base_Type;\n+\n+   --------------------\n+   -- Identifier_For --\n+   --------------------\n+\n+   function Identifier_For (S : Standard_Entity_Type) return Node_Id is\n+      Ident_Node : Node_Id;\n+\n+   begin\n+      Ident_Node := New_Node (N_Identifier, Stloc);\n+      Set_Chars (Ident_Node, Chars (Standard_Entity (S)));\n+      return Ident_Node;\n+   end Identifier_For;\n+\n+   --------------------\n+   -- Make_Component --\n+   --------------------\n+\n+   procedure Make_Component\n+     (Rec : Entity_Id;\n+      Typ : Entity_Id;\n+      Nam : String)\n+   is\n+      Id : Entity_Id := New_Standard_Entity;\n+\n+   begin\n+      Set_Ekind                 (Id, E_Component);\n+      Set_Etype                 (Id, Typ);\n+      Set_Scope                 (Id, Rec);\n+      Init_Component_Location   (Id);\n+\n+      Set_Original_Record_Component (Id, Id);\n+      Make_Name (Id, Nam);\n+      Append_Entity (Id, Rec);\n+   end Make_Component;\n+\n+   -----------------\n+   -- Make_Formal --\n+   -----------------\n+\n+   function Make_Formal\n+     (Typ         : Entity_Id;\n+      Formal_Name : String)\n+      return        Entity_Id\n+   is\n+      Formal : Entity_Id;\n+\n+   begin\n+      Formal := New_Standard_Entity;\n+\n+      Set_Ekind     (Formal, E_In_Parameter);\n+      Set_Mechanism (Formal, Default_Mechanism);\n+      Set_Scope     (Formal, Standard_Standard);\n+      Set_Etype     (Formal, Typ);\n+      Make_Name     (Formal, Formal_Name);\n+\n+      return Formal;\n+   end Make_Formal;\n+\n+   ------------------\n+   -- Make_Integer --\n+   ------------------\n+\n+   function Make_Integer (V : Uint) return Node_Id is\n+      N : constant Node_Id := Make_Integer_Literal (Stloc, V);\n+\n+   begin\n+      Set_Is_Static_Expression (N);\n+      return N;\n+   end Make_Integer;\n+\n+   ---------------\n+   -- Make_Name --\n+   ---------------\n+\n+   procedure Make_Name (Id : Entity_Id; Nam : String) is\n+   begin\n+      for J in 1 .. Nam'Length loop\n+         Name_Buffer (J) := Fold_Lower (Nam (Nam'First + (J - 1)));\n+      end loop;\n+\n+      Name_Len := Nam'Length;\n+      Set_Chars (Id, Name_Find);\n+   end Make_Name;\n+\n+   ------------------\n+   -- New_Operator --\n+   ------------------\n+\n+   function New_Operator (Op : Name_Id; Typ : Entity_Id) return Entity_Id is\n+      Ident_Node : Entity_Id;\n+\n+   begin\n+      Ident_Node := Make_Defining_Identifier (Stloc, Op);\n+\n+      Set_Is_Pure    (Ident_Node, True);\n+      Set_Ekind      (Ident_Node, E_Operator);\n+      Set_Etype      (Ident_Node, Typ);\n+      Set_Scope      (Ident_Node, Standard_Standard);\n+      Set_Homonym    (Ident_Node, Get_Name_Entity_Id (Op));\n+      Set_Convention (Ident_Node, Convention_Intrinsic);\n+\n+      Set_Is_Immediately_Visible   (Ident_Node, True);\n+      Set_Is_Intrinsic_Subprogram  (Ident_Node, True);\n+\n+      Set_Name_Entity_Id (Op, Ident_Node);\n+      Append_Entity (Ident_Node, Standard_Standard);\n+      return Ident_Node;\n+   end New_Operator;\n+\n+   -------------------------\n+   -- New_Standard_Entity --\n+   -------------------------\n+\n+   function New_Standard_Entity\n+     (New_Node_Kind : Node_Kind := N_Defining_Identifier)\n+      return          Entity_Id\n+   is\n+      E : constant Entity_Id := New_Entity (New_Node_Kind, Stloc);\n+\n+   begin\n+      --  All standard entities are Pure and Public\n+\n+      Set_Is_Pure (E);\n+      Set_Is_Public (E);\n+\n+      --  All standard entity names are analyzed manually, and are thus\n+      --  frozen as soon as they are created.\n+\n+      Set_Is_Frozen (E);\n+\n+      --  Set debug information required for all standard types\n+\n+      Set_Needs_Debug_Info (E);\n+\n+      --  All standard entities are built with fully qualified names, so\n+      --  set the flag to prevent an abortive attempt at requalification!\n+\n+      Set_Has_Qualified_Name (E);\n+\n+      --  Return newly created entity to be completed by caller\n+\n+      return E;\n+   end New_Standard_Entity;\n+\n+   ----------------------\n+   -- Set_Float_Bounds --\n+   ----------------------\n+\n+   procedure Set_Float_Bounds (Id  : Entity_Id) is\n+      L  : Node_Id;\n+      --  Low bound of literal value\n+\n+      H  : Node_Id;\n+      --  High bound of literal value\n+\n+      R  : Node_Id;\n+      --  Range specification\n+\n+      Digs  : constant Nat := UI_To_Int (Digits_Value (Id));\n+      --  Digits value, used to select bounds\n+\n+   begin\n+      --  Note: for the call from Cstand to initially create the types in\n+      --  Standard, Vax_Float will always be False. Circuitry in Sem_Vfpt\n+      --  will adjust these types appropriately in the Vax_Float case if\n+      --  a pragma Float_Representation (VAX_Float) is used.\n+\n+      if Vax_Float (Id) then\n+         if Digs = VAXFF_Digits then\n+            L := Real_Convert\n+                   (VAXFF_First'Universal_Literal_String);\n+            H := Real_Convert\n+                   (VAXFF_Last'Universal_Literal_String);\n+\n+         elsif Digs = VAXDF_Digits then\n+            L := Real_Convert\n+                   (VAXDF_First'Universal_Literal_String);\n+            H := Real_Convert\n+                   (VAXDF_Last'Universal_Literal_String);\n+\n+         else\n+            pragma Assert (Digs = VAXGF_Digits);\n+\n+            L := Real_Convert\n+                   (VAXGF_First'Universal_Literal_String);\n+            H := Real_Convert\n+                   (VAXGF_Last'Universal_Literal_String);\n+         end if;\n+\n+      elsif Is_AAMP_Float (Id) then\n+         if Digs = AAMPS_Digits then\n+            L := Real_Convert\n+                   (AAMPS_First'Universal_Literal_String);\n+            H := Real_Convert\n+                   (AAMPS_Last'Universal_Literal_String);\n+\n+         else\n+            pragma Assert (Digs = AAMPL_Digits);\n+            L := Real_Convert\n+                   (AAMPL_First'Universal_Literal_String);\n+            H := Real_Convert\n+                   (AAMPL_Last'Universal_Literal_String);\n+         end if;\n+\n+      elsif Digs = IEEES_Digits then\n+         L := Real_Convert\n+                (IEEES_First'Universal_Literal_String);\n+         H := Real_Convert\n+                (IEEES_Last'Universal_Literal_String);\n+\n+      elsif Digs = IEEEL_Digits then\n+         L := Real_Convert\n+                (IEEEL_First'Universal_Literal_String);\n+         H := Real_Convert\n+                (IEEEL_Last'Universal_Literal_String);\n+\n+      else\n+         pragma Assert (Digs = IEEEX_Digits);\n+\n+         L := Real_Convert\n+                (IEEEX_First'Universal_Literal_String);\n+         H := Real_Convert\n+                (IEEEX_Last'Universal_Literal_String);\n+      end if;\n+\n+      Set_Etype                (L, Id);\n+      Set_Is_Static_Expression (L);\n+\n+      Set_Etype                (H, Id);\n+      Set_Is_Static_Expression (H);\n+\n+      R := New_Node (N_Range, Stloc);\n+      Set_Low_Bound  (R, L);\n+      Set_High_Bound (R, H);\n+      Set_Includes_Infinities (R, True);\n+      Set_Scalar_Range (Id, R);\n+      Set_Etype (R, Id);\n+      Set_Parent (R, Id);\n+   end Set_Float_Bounds;\n+\n+   ------------------------\n+   -- Set_Integer_Bounds --\n+   ------------------------\n+\n+   procedure Set_Integer_Bounds\n+     (Id  : Entity_Id;\n+      Typ : Entity_Id;\n+      Lb  : Uint;\n+      Hb  : Uint)\n+   is\n+      L : Node_Id;     -- Low bound of literal value\n+      H : Node_Id;     -- High bound of literal value\n+      R : Node_Id;     -- Range specification\n+\n+   begin\n+      L := Make_Integer (Lb);\n+      H := Make_Integer (Hb);\n+\n+      Set_Etype (L, Typ);\n+      Set_Etype (H, Typ);\n+\n+      R := New_Node (N_Range, Stloc);\n+      Set_Low_Bound  (R, L);\n+      Set_High_Bound (R, H);\n+      Set_Scalar_Range (Id, R);\n+      Set_Etype (R, Typ);\n+      Set_Parent (R, Id);\n+      Set_Is_Unsigned_Type (Id, Lb >= 0);\n+   end Set_Integer_Bounds;\n+\n+end CStand;"}, {"sha": "5a344928f7389c698a157293896cd2b4e871b287", "filename": "gcc/ada/cstand.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               C S T A N D                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the procedure that is used to create the tree for\n+--  package Standard and initialize the entities in package Stand.\n+\n+with Types; use Types;\n+\n+package CStand is\n+\n+   procedure Create_Standard;\n+   --  This procedure creates the tree for package standard, and initializes\n+   --  the Standard_Entities array and Standard_Package_Node. First the\n+   --  syntactic representation is created (as though the parser had parsed\n+   --  a copy of the source of Standard) and then semantic information is\n+   --  added as it would be by the semantic phases of the compiler. The\n+   --  tree is in the standard format defined by Syntax_Info, except that\n+   --  all Sloc values are set to Standard_Location except for nodes that\n+   --  are part of package ASCII, which have Sloc = Standard_ASCII_Location.\n+   --  The semantics info is in the format given by Entity_Info. The global\n+   --  variables Last_Standard_Node_Id and Last_Standard_List_Id are also set.\n+\n+   procedure Set_Float_Bounds (Id  : Entity_Id);\n+   --  Procedure to set bounds for float type or subtype. Id is the entity\n+   --  whose bounds and type are to be set (a floating-point type).\n+\n+end CStand;"}, {"sha": "7dd5557513ce1a8cab82cc7b8937c465848eb9f6", "filename": "gcc/ada/cstreams.c", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,247 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                          GNAT RUN-TIME COMPONENTS                        *\n+ *                                                                          *\n+ *                              C S T R E A M S                             *\n+ *                                                                          *\n+ *              Auxiliary C functions for Interfaces.C.Streams              *\n+ *                                                                          *\n+ *                              $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Routines required for implementing routines in Interfaces.C.Streams */\n+\n+#ifdef __vxworks\n+#include \"vxWorks.h\"\n+#endif\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include <sys/stat.h>\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"adaint.h\"\n+\n+#ifdef __EMX__\n+int max_path_len = _MAX_PATH;\n+#elif defined (VMS)\n+#include <unixlib.h>\n+int max_path_len = 255; /* PATH_MAX */\n+\n+#elif defined (__vxworks) || defined (__OPENNT)\n+\n+int max_path_len = PATH_MAX;\n+\n+#else\n+\n+#ifdef linux\n+\n+/* Don't use macros on linux since they cause incompatible changes between\n+   glibc 2.0 and 2.1 */\n+\n+#ifdef stderr\n+#  undef stderr\n+#endif\n+#ifdef stdin\n+#  undef stdin\n+#endif\n+#ifdef stdout\n+#  undef stdout\n+#endif\n+\n+#endif\n+\n+#include <sys/param.h>\n+\n+int max_path_len = MAXPATHLEN;\n+#endif\n+\n+/* The _IONBF value in CYGNUS or MINGW32 stdio.h is wrong.  */\n+#if defined (WINNT) || defined (_WINNT)\n+#undef _IONBF\n+#define _IONBF 0004\n+#endif\n+\n+\n+int\n+__gnat_feof (stream)\n+     FILE *stream;\n+{\n+  return (feof (stream));\n+}\n+\n+int\n+__gnat_ferror (stream)\n+     FILE *stream;\n+{\n+   return (ferror (stream));\n+}\n+\n+int\n+__gnat_fileno (stream)\n+     FILE *stream;\n+{\n+   return (fileno (stream));\n+}\n+\n+int\n+__gnat_is_regular_file_fd (fd)\n+     int fd;\n+{\n+  int ret;\n+  struct stat statbuf;\n+\n+#ifdef __EMX__\n+  /* Programs using screen I/O may need to reset the FPU after\n+     initialization of screen-handling related DLL's, so force\n+     DLL initialization by doing a null-write and then reset the FPU */\n+\n+  DosWrite (0, &ret, 0, &ret);\n+  __gnat_init_float();\n+#endif\n+\n+  ret = fstat (fd, &statbuf);\n+  return (!ret && S_ISREG (statbuf.st_mode));\n+}\n+\n+/* on some systems, the constants for seek are not defined, if so, then\n+   provide the conventional definitions */\n+\n+#ifndef SEEK_SET\n+#define SEEK_SET 0  /* Set file pointer to offset                           */\n+#define SEEK_CUR 1  /* Set file pointer to its current value plus offset    */\n+#define SEEK_END 2  /* Set file pointer to the size of the file plus offset */\n+#endif\n+\n+/* if L_tmpnam is not set, use a large number that should be safe */\n+#ifndef L_tmpnam\n+#define L_tmpnam 256\n+#endif\n+\n+int    __gnat_constant_eof      = EOF;\n+int    __gnat_constant_iofbf    = _IOFBF;\n+int    __gnat_constant_iolbf    = _IOLBF;\n+int    __gnat_constant_ionbf    = _IONBF;\n+int    __gnat_constant_l_tmpnam = L_tmpnam;\n+int    __gnat_constant_seek_cur = SEEK_CUR;\n+int    __gnat_constant_seek_end = SEEK_END;\n+int    __gnat_constant_seek_set = SEEK_SET;\n+\n+FILE *\n+__gnat_constant_stderr ()\n+{\n+  return stderr;\n+}\n+\n+FILE *\n+__gnat_constant_stdin ()\n+{\n+  return stdin;\n+}\n+\n+FILE *\n+__gnat_constant_stdout ()\n+{\n+  return stdout;\n+}\n+\n+char *\n+__gnat_full_name (nam, buffer)\n+     char *nam;\n+     char *buffer;\n+{\n+  char *p;\n+\n+#if defined(__EMX__) || defined (__MINGW32__)\n+  /* If this is a device file return it as is; under Windows NT and\n+     OS/2 a device file end with \":\".  */\n+  if (nam [strlen (nam) - 1] == ':')\n+    strcpy (buffer, nam);\n+  else\n+    {\n+      _fullpath (buffer, nam, max_path_len);\n+\n+      for (p = buffer; *p; p++)\n+\tif (*p == '/')\n+\t  *p = '\\\\';\n+    }\n+\n+#elif defined (MSDOS)\n+  _fixpath (nam, buffer);\n+\n+#elif defined (sgi)\n+\n+  /* Use realpath function which resolves links and references to .. and ..\n+     on those Unix systems that support it. Note that linux provides it but\n+     cannot handle more than 5 symbolic links in a full name, so we use the\n+     getcwd approach instead. */\n+  realpath (nam, buffer);\n+\n+#elif defined (VMS)\n+  strcpy (buffer, __gnat_to_canonical_file_spec (nam));\n+\n+  if (buffer[0] == '/')\n+    strcpy (buffer, __gnat_to_host_file_spec (buffer));\n+  else\n+    {\n+      char nambuffer [MAXPATHLEN];\n+\n+      strcpy (nambuffer, buffer);\n+      strcpy (buffer, getcwd (buffer, max_path_len, 0));\n+      strcat (buffer, \"/\");\n+      strcat (buffer, nambuffer);\n+      strcpy (buffer, __gnat_to_host_file_spec (buffer));\n+    }\n+\n+  return buffer;\n+\n+#else\n+  if (nam[0] != '/')\n+    {\n+      p = getcwd (buffer, max_path_len);\n+      if (p == 0)\n+\t{\n+\t  buffer[0] = '\\0';\n+\t  return 0;\n+\t}\n+\n+      /* If the name returned is an absolute path, it is safe to append '/'\n+\t to the path and concatenate the name of the file. */\n+      if (buffer[0] == '/')\n+\tstrcat (buffer, \"/\");\n+\n+      strcat (buffer, nam);\n+    }\n+  else\n+    strcpy (buffer, nam);\n+\n+  return buffer;\n+#endif\n+}"}, {"sha": "8b1835b67a20ffe58a69df5d78b8cfb8a217c9f0", "filename": "gcc/ada/cuintp.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,110 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                        GNAT COMPILER COMPONENTS                          *\n+ *                                                                          *\n+ *                               C U I N T P                                *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file corresponds to the Ada package body Uintp. It was created\n+   manually from the files uintp.ads and uintp.adb. */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"uintp.h\"\n+#include \"atree.h\"\n+#include \"elists.h\"\n+#include \"nlists.h\"\n+#include \"stringt.h\"\n+#include \"fe.h\"\n+#include \"gigi.h\"\n+\n+/* Universal integers are represented by the Uint type which is an index into\n+   the Uints_Ptr table containing Uint_Entry values.  A Uint_Entry contains an\n+   index and length for getting the \"digits\" of the universal integer from the\n+   Udigits_Ptr table.\n+\n+   For efficiency, this method is used only for integer values larger than the\n+   constant Uint_Bias.  If a Uint is less than this constant, then it contains\n+   the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n+   that a Uint value of Uint_Bias indexes the first element.  */\n+\n+/* Similarly to UI_To_Int, but return a GCC INTEGER_CST.  Overflow is tested\n+   by the constant-folding used to build the node.  TYPE is the GCC type of the\n+   resulting node.  */\n+\n+tree\n+UI_To_gnu (Input, type)\n+     Uint Input;\n+     tree type;\n+{\n+  tree gnu_ret;\n+\n+  if (Input <= Uint_Direct_Last)\n+    gnu_ret = convert (type, build_int_2 (Input - Uint_Direct_Bias, \n+\t\t\t\t\t  Input < Uint_Direct_Bias ? -1 : 0));\n+  else\n+    {\n+      Int Idx =    Uints_Ptr[Input].Loc;\n+      Pos Length = Uints_Ptr[Input].Length;\n+      Int First = Udigits_Ptr[Idx];\n+      /* Do computations in integer type or TYPE whichever is wider, then\n+\t convert later.  This avoid overflow if type is short integer.  */\n+      tree comp_type\n+\t= (TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node)\n+\t   ? type : integer_type_node);\n+      tree gnu_base = convert (comp_type, build_int_2 (Base, 0));\n+\n+      if (Length <= 0)\n+\tgigi_abort (601);\n+\n+      gnu_ret = convert (comp_type, build_int_2 (First, First < 0 ? -1 : 0));\n+      if (First < 0)\n+\tfor (Idx++, Length--; Length; Idx++, Length--)\n+\t  gnu_ret = fold (build (MINUS_EXPR, comp_type,\n+\t\t\t\t fold (build (MULT_EXPR, comp_type,\n+\t\t\t\t\t      gnu_ret, gnu_base)),\n+\t\t\t\t convert (comp_type,\n+\t\t\t\t\t  build_int_2 (Udigits_Ptr[Idx], 0))));\n+      else\n+\tfor (Idx++, Length--; Length; Idx++, Length--)\n+\t  gnu_ret = fold (build (PLUS_EXPR, comp_type,\n+\t\t\t\t fold (build (MULT_EXPR, comp_type,\n+\t\t\t\t\t      gnu_ret, gnu_base)),\n+\t\t\t\t convert (comp_type,\n+\t\t\t\t\t  build_int_2 (Udigits_Ptr[Idx], 0))));\n+    }\n+\n+  gnu_ret = convert (type, gnu_ret);\n+\n+  /* We don't need any NOP_EXPR or NON_LVALUE_EXPR on GNU_RET.  */\n+  while ((TREE_CODE (gnu_ret) == NOP_EXPR\n+\t  || TREE_CODE (gnu_ret) == NON_LVALUE_EXPR)\n+\t && TREE_TYPE (TREE_OPERAND (gnu_ret, 0)) == TREE_TYPE (gnu_ret))\n+    gnu_ret = TREE_OPERAND (gnu_ret, 0);\n+\n+  return gnu_ret;\n+}"}, {"sha": "27c934bd99c74dad4c2bbfd6277bd4465a974ca1", "filename": "gcc/ada/debug.adb", "status": "added", "additions": 577, "deletions": 0, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,577 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                D E B U G                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.88 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Debug is\n+\n+   ---------------------------------\n+   -- Summary of Debug Flag Usage --\n+   ---------------------------------\n+\n+   --  Debug flags for compiler (GNAT1 and GNATF)\n+\n+   --  da   Generate messages tracking semantic analyzer progress\n+   --  db   Show encoding of type names for debug output\n+   --  dc   List names of units as they are compiled\n+   --  dd   Dynamic allocation of tables messages generated\n+   --  de   List the entity table\n+   --  df   Full tree/source print (includes withed units)\n+   --  dg   Print source from tree (generated code only)\n+   --  dh   Generate listing showing loading of name table hash chains\n+   --  di   Generate messages for visibility linking/delinking\n+   --  dj   Suppress \"junk null check\" for access parameter values\n+   --  dk   Generate GNATBUG message on abort, even if previous errors\n+   --  dl   Generate unit load trace messages\n+   --  dm   Allow VMS features even if not OpenVMS version\n+   --  dn   Generate messages for node/list allocation\n+   --  do   Print source from tree (original code only)\n+   --  dp   Generate messages for parser scope stack push/pops\n+   --  dq\n+   --  dr   Generate parser resynchronization messages\n+   --  ds   Print source from tree (including original and generated stuff)\n+   --  dt   Print full tree\n+   --  du   Uncheck categorization pragmas\n+   --  dv   Output trace of overload resolution\n+   --  dw   Print trace of semantic scope stack\n+   --  dx   Force expansion on, even if no code being generated\n+   --  dy   Print tree of package Standard\n+   --  dz   Print source of package Standard\n+\n+   --  dA   All entities included in representation information output\n+   --  dB   Output debug encoding of type names and variants\n+   --  dC\n+   --  dD   Delete elaboration checks in inner level routines\n+   --  dE   Apply elaboration checks to predefined units\n+   --  dF   Front end data layout enabled.\n+   --  dG   Generate input showing file creating info for debug file\n+   --  dH   Hold (kill) call to gigi\n+   --  dI   Inhibit internal name numbering in gnatG listing\n+   --  dJ   Output debugging trace info for JGNAT (Java VM version of GNAT)\n+   --  dK   Kill all error messages\n+   --  dL   Output trace information on elaboration checking\n+   --  dM\n+   --  dN   Do not generate file/line exception messages\n+   --  dO   Output immediate error messages\n+   --  dP   Do not check for controlled objects in preelaborable packages\n+   --  dQ\n+   --  dR   Bypass check for correct version of s-rpc\n+   --  dS   Never convert numbers to machine numbers in Sem_Eval\n+   --  dT   Convert to machine numbers only for constant declarations\n+   --  dU   Enable garbage collection of unreachable entities\n+   --  dV   Enable viewing of all symbols in debugger\n+   --  dW\n+   --  dX   Enable Frontend ZCX even when it is not supported\n+   --  dY\n+   --  dZ\n+\n+   --  d1   Error msgs have node numbers where possible\n+   --  d2   Eliminate error flags in verbose form error messages\n+   --  d3   Dump bad node in Comperr on an abort\n+   --  d4   Inhibit automatic krunch of predefined library unit files\n+   --  d5   Debug output for tree read/write\n+   --  d6   Default access unconstrained to thin pointers\n+   --  d7   Do not output version & file time stamp in -gnatv or -gnatl mode\n+   --  d8   Force opposite endianness in packed stuff\n+   --  d9\n+\n+   --  Debug flags for binder (GNATBIND)\n+\n+   --  da\n+   --  db\n+   --  dc  List units as they are chosen\n+   --  dd\n+   --  de  Elaboration dependencies including system units\n+   --  df\n+   --  dg\n+   --  dh\n+   --  di\n+   --  dj\n+   --  dk\n+   --  dl\n+   --  dm\n+   --  dn  List details of manipulation of Num_Pred values\n+   --  do\n+   --  dp\n+   --  dq\n+   --  dr  List additional restrictions that may be specified\n+   --  ds\n+   --  dt\n+   --  du  List units as they are acquired\n+   --  dv\n+   --  dw\n+   --  dx\n+   --  dy\n+   --  dz\n+\n+   --  d1\n+   --  d2\n+   --  d3\n+   --  d4\n+   --  d5\n+   --  d6\n+   --  d7\n+   --  d8\n+   --  d9\n+\n+   --  Debug flags used in package Make and its clients (e.g. GNATMAKE)\n+\n+   --  da\n+   --  db\n+   --  dc\n+   --  dd\n+   --  de\n+   --  df\n+   --  dg\n+   --  dh\n+   --  di\n+   --  dj\n+   --  dk\n+   --  dl\n+   --  dm\n+   --  dn\n+   --  do\n+   --  dp  Prints the contents of the Q used by Make.Compile_Sources\n+   --  dq  Prints source files as they are enqueued and dequeued\n+   --  dr\n+   --  ds\n+   --  dt\n+   --  du\n+   --  dv\n+   --  dw  Prints the list of units withed by the unit currently explored\n+   --  dx\n+   --  dy\n+   --  dz\n+\n+   --  d1\n+   --  d2\n+   --  d3\n+   --  d4\n+   --  d5\n+   --  d6\n+   --  d7\n+   --  d8\n+   --  d9\n+\n+   --------------------------------------------\n+   -- Documentation for Compiler Debug Flags --\n+   --------------------------------------------\n+\n+   --  da   Generate messages tracking semantic analyzer progress. A message\n+   --       is output showing each node as it gets analyzed, expanded,\n+   --       resolved, or evaluated. This option is useful for finding out\n+   --       exactly where a bomb during semantic analysis is occurring.\n+\n+   --  db   In Exp_Dbug, certain type names are encoded to include debugging\n+   --       information. This debug switch causes lines to be output showing\n+   --       the encodings used.\n+\n+   --  dc   List names of units as they are compiled. One line of output will\n+   --       be generated at the start of compiling each unit (package or\n+   --       subprogram).\n+\n+   --  dd   Dynamic allocation of tables messages generated. Each time a\n+   --       table is reallocated, a line is output indicating the expansion.\n+\n+   --  dD   Delete new elaboration checks. This flag causes GNAT to return\n+   --       to the 3.13a elaboration semantics, and to suppress the fixing\n+   --       of two bugs. The first is in the context of inner routines in\n+   --       dynamic elaboration mode, when the subprogram we are in was\n+   --       called at elaboration time by a unit that was also compiled with\n+   --       dynamic elaboration checks. In this case, if A calls B calls C,\n+   --       and all are in different units, we need an elaboration check at\n+   --       each call. These nested checks were only put in recently (see\n+   --       version 1.80 of Sem_Elab) and we provide this debug flag to\n+   --       revert to the previous behavior in case of regressions. The\n+   --       other behavior reverted by this flag is the treatment of the\n+   --       Elaborate_Body pragma in static elaboration mode. This used to\n+   --       be treated as not needing elaboration checking, but in fact in\n+   --       general Elaborate_All is still required because of nested calls.\n+\n+   --  de   List the entity table\n+\n+   --  df   Full tree/source print (includes withed units). Normally the tree\n+   --       output (dt) or recreated source output (dg,do,ds) includes only\n+   --       the main unit. If df is set, then the output in either case\n+   --       includes all compiled units (see also dg,do,ds,dt). Note that to\n+   --       be effective, this swich must be used in combination with one or\n+   --       more of dt, dg, do or ds.\n+\n+   --  dF   Front end data layout enabled. Normally front end data layout\n+   --       is only enabled if the target parameter Backend_Layout is False.\n+   --       This debugging switch enables it unconditionally.\n+\n+   --  dg   Print the source recreated from the generated tree. In the case\n+   --       where the tree has been rewritten this output includes only the\n+   --       generated code, not the original code (see also df,do,ds,dz).\n+   --       This flag differs from -gnatG in that the output also includes\n+   --       non-source generated null statements, and freeze nodes, which\n+   --       are normally omitted in -gnatG mode.\n+\n+   --  dG   Print trace information showing calls to Create_Debug_Source and\n+   --       Write_Debug_Line. Used for debugging -gnatD operation problems.\n+\n+   --  dh   Generates a table at the end of a compilation showing how the hash\n+   --       table chains built by the Namet package are loaded. This is useful\n+   --       in ensuring that the hashing algorithm (in Namet.Hash) is working\n+   --       effectively with typical sets of program identifiers.\n+\n+   --  dH   Inhibit call to gigi. This is useful for testing front end data\n+   --       layout, and may be useful in other debugging situations where\n+   --       you do not want gigi to intefere with the testing.\n+\n+   --  di   Generate messages for visibility linking/delinking\n+\n+   --  dj   Suppress \"junk null check\" for access parameters. This flag permits\n+   --       Ada programs to pass null parameters to access parameters, and to\n+   --       explicitly check such access values against the null literal.\n+   --       Neither of these is valid Ada, but both were allowed in versions of\n+   --       GNAT before 3.10, so this switch can ease the transition process.\n+\n+   --  dJ   Generate debugging trace output for the JGNAT back end. This\n+   --       consists of symbolic Java Byte Code sequences for all generated\n+   --       classes plus additional information to indicate local variables\n+   --       and methods.\n+\n+   --  dk   Immediate kill on abort. Normally on an abort (i.e. a call to\n+   --       Comperr.Compiler_Abort), the GNATBUG message is not given if\n+   --       there is a previous error. This debug switch bypasses this test\n+   --       and gives the message unconditionally (useful for debugging).\n+\n+   --  dK   Kill all error messages. This debug flag suppresses the output\n+   --       of all error messages. It is used in regression tests where the\n+   --       error messages are target dependent and irrelevant.\n+\n+   --  dl   Generate unit load trace messages. A line of traceback output is\n+   --       generated each time a request is made to the library manager to\n+   --       load a new unit.\n+\n+   --  dm   Some features are permitted only in OpenVMS ports of GNAT (e.g.\n+   --       the specification of passing by descriptor). Normally any use\n+   --       of these features will be flagged as an error, but this debug\n+   --       flag allows acceptance of these features in non OpenVMS ports.\n+   --       Of course they may not have any useful effect, and in particular\n+   --       attempting to generate code with this flag set may blow up.\n+   --       The flag also forces the use of 64-bits for Long_Integer.\n+\n+   --  dn   Generate messages for node/list allocation. Each time a node or\n+   --       list header is allocated, a line of output is generated. Certain\n+   --       other basic tree operations also cause a line of output to be\n+   --       generated. This option is useful in seeing where the parser is\n+   --       blowing up.;\n+\n+   --  dN   Do not generate file/line exception messages. Normally we do the\n+   --       explicit generation of these messages, but since these can only\n+   --       be disabled using pragma Discard_Names, this switch may be useful.\n+\n+   --  do   Print the source recreated from the generated tree. In the case\n+   --       where the tree has been rewritten, this output includes only the\n+   --       original code, not the generated code (see also df,dg,ds,dz).\n+\n+   --  dp   Generate messages for parser scope stack push/pops. A line of\n+   --       output by the parser each time the parser scope stack is either\n+   --       pushed or popped. Useful in debugging situations where the\n+   --       parser scope stack ends up incorrectly synchronized\n+\n+   --  dr   Generate parser resynchronization messages. Normally the parser\n+   --       resynchronizes quietly. With this debug option, two messages\n+   --       are generated, one when the parser starts a resynchronization\n+   --       skip, and another when it resumes parsing. Useful in debugging\n+   --       inadequate error recovery situations.\n+\n+   --  ds   Print the source recreated from the generated tree. In the case\n+   --       where the tree has been rewritten this output includes both the\n+   --       generated code and the original code with the generated code\n+   --       being enlosed in curly brackets (see also df,do,ds,dz)\n+\n+   --  dt   Print full tree. The generated tree is output (see also df,dy)\n+\n+   --  du   Uncheck categorization pragmas. This debug switch causes the\n+   --       categorization pragmas (Pure, Preelaborate etc) to be ignored\n+   --       so that normal checks are not made (this is particularly useful\n+   --       for adding temporary debugging code to units that have pragmas\n+   --       that are inconsistent with the debugging code added.\n+\n+   --  dw   Write semantic scope stack messages. Each time a scope is created\n+   --       or removed, a message is output (see the Sem_Ch8.New_Scope and\n+   --       Sem_Ch8.Pop_Scope subprograms).\n+\n+   --  dx   Force expansion on, even if no code being generated. Normally the\n+   --       expander is inhibited if no code is generated. This switch forces\n+   --       expansion to proceed normally even if the backend is not being\n+   --       called. This is particularly useful for debugging purposes when\n+   --       using the front-end only version of the compiler (which normally\n+   --       would never do any expansion).\n+\n+   --  dy   Print tree of package Standard. Normally the tree print out does\n+   --       not include package Standard, even if the -df switch is set. This\n+   --       switch forces output of the internal tree built for Standard.\n+\n+   --  dz   Print source of package Standard. Normally the source print out\n+   --       does not include package Standard, even if the -df switch is set.\n+   --       This switch forces output of the source recreated from the internal\n+   --       tree built for Standard.\n+\n+   --  dA   Forces output of representation information, including full\n+   --       information for all internal type and object entities, as well\n+   --       as all user defined type and object entities.\n+\n+   --  dB   Output debug encodings for types and variants. See Exp_Dbug for\n+   --       exact form of the generated output.\n+\n+   --  dE   Apply compile time elaboration checking for with relations between\n+   --       predefined units. Normally no checks are made (it seems that at\n+   --       least on the SGI, such checks run into trouble).\n+\n+   --  dI   Inhibit internal name numbering in gnatDG listing. For internal\n+   --       names of the form <uppercase-letters><digits><suffix>, the output\n+   --       will be modified to <uppercase-letters>...<suffix>. This is used\n+   --       in the fixed bugs run to minimize system and version dependency\n+   --       in filed -gnatDG output.\n+\n+   --  dL   Output trace information on elaboration checking. This debug\n+   --       switch causes output to be generated showing each call or\n+   --       instantiation as it is checked, and the progress of the recursive\n+   --       trace through calls at elaboration time.\n+\n+   --  dO   Output immediate error messages. This causes error messages to\n+   --       be output as soon as they are generated (disconnecting several\n+   --       circuits for improvement of messages, deletion of duplicate\n+   --       messages etc). Useful to diagnose compiler bombs caused by\n+   --       erroneous handling of error situations\n+\n+   --  dP   Do not check for controlled objects in preelaborable packages.\n+   --       RM 10.2.1(9) forbids the use of library level controlled objects\n+   --       in preelaborable packages, but this restriction is a huge pain,\n+   --       especially in the predefined library units.\n+\n+   --  dR   Bypass the check for a proper version of s-rpc being present\n+   --       to use the -gnatz? switch. This allows debugging of the use\n+   --       of stubs generation without needing to have GLADE (or some\n+   --       other PCS  installed).\n+\n+   --  dS   Omit conversion of fpt numbers to exact machine numbers in\n+   --       non-static evaluation contexts (see Check_Non_Static_Context).\n+   --       This is intended for testing out timing problems with this\n+   --       conversion circuit.\n+\n+   --  dT   Similar to dS, but omits the conversions only in the case where\n+   --       the parent is not a constant declaration.\n+\n+   --  dU   Enable garbage collection of unreachable entities. This enables\n+   --       both the reachability analysis and changing the Is_Public and\n+   --       Is_Eliminated flags.\n+\n+   --  dV   Enable viewing of all symbols in debugger. Causes debug information\n+   --       to be generated for all symbols, including internal symbols. This\n+   --       is enabled by default for -gnatD, but this switch allows this to\n+   --       be enabled without generating modified source files. Note that the\n+   --       use of -gnatdV ensures in the dwarf/elf case that all symbols that\n+   --       are present in the elf tables are also in the dwarf tables (which\n+   --       seems to be required by some tools).\n+\n+   --  dX   Enable frontend ZCX even when it is not supported. Equivalent to\n+   --       -gnatZ but without verifying that System.Front_End_ZCX_Support\n+   --       is set. This causes the front end to generate suitable tables\n+   --       for ZCX handling even when the runtime cannot handle ZCX. This\n+   --       is used for testing the front end for correct ZCX operation, and\n+   --       in particular is useful for multi-target testing.\n+\n+   --  d1   Error msgs have node numbers where possible. Normally error\n+   --       messages have only source locations. This option is useful when\n+   --       debugging errors caused by expanded code, where the source location\n+   --       does not give enough information.\n+\n+   --  d2   Suppress output of the error position flags for verbose form error\n+   --       messages. The messages are still interspersed in the listing, but\n+   --       without any error flags or extra blank lines. Also causes an extra\n+   --       <<< to be output at the right margin. This is intended to be the\n+   --       easiest format for checking conformance of ACVC B tests.\n+\n+   --  d3   Causes Comperr to dump the contents of the node for which an abort\n+   --       was detected (normally only the Node_Id of the node is output).\n+\n+   --  d4   Inhibits automatic krunching of predefined library unit file names.\n+   --       Normally, as described in the spec of package Krunch, such files\n+   --       are automatically krunched to 8 characters, with special treatment\n+   --       of the prefixes Ada, System, and Interfaces. Setting this debug\n+   --       switch disables this special treatment.\n+\n+   --  d6   Normally access-to-unconstrained-array types are represented\n+   --       using fat (double) pointers. Using this debug flag causes them\n+   --       to default to thin. This can be used to test the performance\n+   --       implications of using thin pointers, and also to test that the\n+   --       compiler functions correctly with this choice.\n+\n+   --  d7   Normally a -gnatl or -gnatv listing includes the time stamp\n+   --       of the source file. This debug flag suppresses this output,\n+   --       and also suppresses the message with the version number.\n+   --       This is useful in certain regression tests.\n+\n+   --  d8   This forces the packed stuff to generate code assuming the\n+   --       opposite endianness from the actual correct value. Useful in\n+   --       testing out code generation from the packed routines.\n+\n+   ------------------------------------------\n+   -- Documentation for Binder Debug Flags --\n+   ------------------------------------------\n+\n+   --  dc  List units as they are chosen. As units are selected for addition to\n+   --      the elaboration order, a line of output is generated showing which\n+   --      unit has been selected.\n+\n+   --  de  Similar to the effect of -e (output complete list of elaboration\n+   --      dependencies) except that internal units are included in the\n+   --      listing.\n+\n+   --  dn  List details of manipulation of Num_Pred values during execution of\n+   --      the algorithm used to determine a correct order of elaboration. This\n+   --      is useful in diagnosing any problems in its behavior.\n+\n+   --  dr  List restrictions which have not been specified, but could have\n+   --      been without causing bind errors.\n+\n+   --  du  List unit name and file name for each unit as it is read in\n+\n+   ------------------------------------------------------------\n+   -- Documentation for the Debug Flags used in package Make --\n+   ------------------------------------------------------------\n+\n+   --  Please note that such flags apply to all of Make clients,\n+   --  such as gnatmake.\n+\n+   --  dp  Prints the Q used by routine Make.Compile_Sources every time\n+   --      we go around the main compile loop of Make.Compile_Sources\n+\n+   --  dq  Prints source files as they are enqueued and dequeued in the Q\n+   --      used by routine Make.Compile_Sources. Useful to figure out the\n+   --      order in which sources are recompiled.\n+\n+   --  dw  Prints the list of units withed by the unit currently explored\n+   --      during the main loop of Make.Compile_Sources.\n+\n+   ----------------------\n+   -- Get_Debug_Flag_K --\n+   ----------------------\n+\n+   function Get_Debug_Flag_K return Boolean is\n+   begin\n+      return Debug_Flag_K;\n+   end Get_Debug_Flag_K;\n+\n+   --------------------\n+   -- Set_Debug_Flag --\n+   --------------------\n+\n+   procedure Set_Debug_Flag (C : Character; Val : Boolean := True) is\n+      subtype Dig  is Character range '1' .. '9';\n+      subtype LLet is Character range 'a' .. 'z';\n+      subtype ULet is Character range 'A' .. 'Z';\n+\n+   begin\n+      if C in Dig then\n+         case Dig (C) is\n+            when '1' => Debug_Flag_1 := Val;\n+            when '2' => Debug_Flag_2 := Val;\n+            when '3' => Debug_Flag_3 := Val;\n+            when '4' => Debug_Flag_4 := Val;\n+            when '5' => Debug_Flag_5 := Val;\n+            when '6' => Debug_Flag_6 := Val;\n+            when '7' => Debug_Flag_7 := Val;\n+            when '8' => Debug_Flag_8 := Val;\n+            when '9' => Debug_Flag_9 := Val;\n+         end case;\n+\n+      elsif C in ULet then\n+         case ULet (C) is\n+            when 'A' => Debug_Flag_AA := Val;\n+            when 'B' => Debug_Flag_BB := Val;\n+            when 'C' => Debug_Flag_CC := Val;\n+            when 'D' => Debug_Flag_DD := Val;\n+            when 'E' => Debug_Flag_EE := Val;\n+            when 'F' => Debug_Flag_FF := Val;\n+            when 'G' => Debug_Flag_GG := Val;\n+            when 'H' => Debug_Flag_HH := Val;\n+            when 'I' => Debug_Flag_II := Val;\n+            when 'J' => Debug_Flag_JJ := Val;\n+            when 'K' => Debug_Flag_KK := Val;\n+            when 'L' => Debug_Flag_LL := Val;\n+            when 'M' => Debug_Flag_MM := Val;\n+            when 'N' => Debug_Flag_NN := Val;\n+            when 'O' => Debug_Flag_OO := Val;\n+            when 'P' => Debug_Flag_PP := Val;\n+            when 'Q' => Debug_Flag_QQ := Val;\n+            when 'R' => Debug_Flag_RR := Val;\n+            when 'S' => Debug_Flag_SS := Val;\n+            when 'T' => Debug_Flag_TT := Val;\n+            when 'U' => Debug_Flag_UU := Val;\n+            when 'V' => Debug_Flag_VV := Val;\n+            when 'W' => Debug_Flag_WW := Val;\n+            when 'X' => Debug_Flag_XX := Val;\n+            when 'Y' => Debug_Flag_YY := Val;\n+            when 'Z' => Debug_Flag_ZZ := Val;\n+         end case;\n+\n+      else\n+         case LLet (C) is\n+            when 'a' => Debug_Flag_A := Val;\n+            when 'b' => Debug_Flag_B := Val;\n+            when 'c' => Debug_Flag_C := Val;\n+            when 'd' => Debug_Flag_D := Val;\n+            when 'e' => Debug_Flag_E := Val;\n+            when 'f' => Debug_Flag_F := Val;\n+            when 'g' => Debug_Flag_G := Val;\n+            when 'h' => Debug_Flag_H := Val;\n+            when 'i' => Debug_Flag_I := Val;\n+            when 'j' => Debug_Flag_J := Val;\n+            when 'k' => Debug_Flag_K := Val;\n+            when 'l' => Debug_Flag_L := Val;\n+            when 'm' => Debug_Flag_M := Val;\n+            when 'n' => Debug_Flag_N := Val;\n+            when 'o' => Debug_Flag_O := Val;\n+            when 'p' => Debug_Flag_P := Val;\n+            when 'q' => Debug_Flag_Q := Val;\n+            when 'r' => Debug_Flag_R := Val;\n+            when 's' => Debug_Flag_S := Val;\n+            when 't' => Debug_Flag_T := Val;\n+            when 'u' => Debug_Flag_U := Val;\n+            when 'v' => Debug_Flag_V := Val;\n+            when 'w' => Debug_Flag_W := Val;\n+            when 'x' => Debug_Flag_X := Val;\n+            when 'y' => Debug_Flag_Y := Val;\n+            when 'z' => Debug_Flag_Z := Val;\n+         end case;\n+      end if;\n+   end Set_Debug_Flag;\n+\n+end Debug;"}, {"sha": "dcc849bafbf0150d57083582c314b9df98e3d0e9", "filename": "gcc/ada/debug.ads", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                D E B U G                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.31 $\n+--                                                                          --\n+--          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Debug is\n+pragma Preelaborate (Debug);\n+\n+--  This package contains global flags used to control the inclusion\n+--  of debugging code in various phases of the compiler.\n+\n+   -------------------------\n+   -- Dynamic Debug Flags --\n+   -------------------------\n+\n+   --  Thirty six flags that can be used to active various specialized\n+   --  debugging output information. The flags are preset to False, which\n+   --  corresponds to the given output being suppressed. The individual\n+   --  flags can be turned on using the undocumented switch /dxxx where\n+   --  xxx is a string of letters for flags to be turned on. Documentation\n+   --  on the current usage of these flags is contained in the body of Debug\n+   --  rather than the spec, so that we don't have to recompile the world\n+   --  when a new debug flag is added\n+\n+   Debug_Flag_A : Boolean := False;\n+   Debug_Flag_B : Boolean := False;\n+   Debug_Flag_C : Boolean := False;\n+   Debug_Flag_D : Boolean := False;\n+   Debug_Flag_E : Boolean := False;\n+   Debug_Flag_F : Boolean := False;\n+   Debug_Flag_G : Boolean := False;\n+   Debug_Flag_H : Boolean := False;\n+   Debug_Flag_I : Boolean := False;\n+   Debug_Flag_J : Boolean := False;\n+   Debug_Flag_K : Boolean := False;\n+   Debug_Flag_L : Boolean := False;\n+   Debug_Flag_M : Boolean := False;\n+   Debug_Flag_N : Boolean := False;\n+   Debug_Flag_O : Boolean := False;\n+   Debug_Flag_P : Boolean := False;\n+   Debug_Flag_Q : Boolean := False;\n+   Debug_Flag_R : Boolean := False;\n+   Debug_Flag_S : Boolean := False;\n+   Debug_Flag_T : Boolean := False;\n+   Debug_Flag_U : Boolean := False;\n+   Debug_Flag_V : Boolean := False;\n+   Debug_Flag_W : Boolean := False;\n+   Debug_Flag_X : Boolean := False;\n+   Debug_Flag_Y : Boolean := False;\n+   Debug_Flag_Z : Boolean := False;\n+\n+   Debug_Flag_AA : Boolean := False;\n+   Debug_Flag_BB : Boolean := False;\n+   Debug_Flag_CC : Boolean := False;\n+   Debug_Flag_DD : Boolean := False;\n+   Debug_Flag_EE : Boolean := False;\n+   Debug_Flag_FF : Boolean := False;\n+   Debug_Flag_GG : Boolean := False;\n+   Debug_Flag_HH : Boolean := False;\n+   Debug_Flag_II : Boolean := False;\n+   Debug_Flag_JJ : Boolean := False;\n+   Debug_Flag_KK : Boolean := False;\n+   Debug_Flag_LL : Boolean := False;\n+   Debug_Flag_MM : Boolean := False;\n+   Debug_Flag_NN : Boolean := False;\n+   Debug_Flag_OO : Boolean := False;\n+   Debug_Flag_PP : Boolean := False;\n+   Debug_Flag_QQ : Boolean := False;\n+   Debug_Flag_RR : Boolean := False;\n+   Debug_Flag_SS : Boolean := False;\n+   Debug_Flag_TT : Boolean := False;\n+   Debug_Flag_UU : Boolean := False;\n+   Debug_Flag_VV : Boolean := False;\n+   Debug_Flag_WW : Boolean := False;\n+   Debug_Flag_XX : Boolean := False;\n+   Debug_Flag_YY : Boolean := False;\n+   Debug_Flag_ZZ : Boolean := False;\n+\n+   Debug_Flag_1 : Boolean := False;\n+   Debug_Flag_2 : Boolean := False;\n+   Debug_Flag_3 : Boolean := False;\n+   Debug_Flag_4 : Boolean := False;\n+   Debug_Flag_5 : Boolean := False;\n+   Debug_Flag_6 : Boolean := False;\n+   Debug_Flag_7 : Boolean := False;\n+   Debug_Flag_8 : Boolean := False;\n+   Debug_Flag_9 : Boolean := False;\n+\n+   function Get_Debug_Flag_K return Boolean;\n+   --  This function is called from C code to get the setting of the K flag\n+   --  (it does not work to try to access a constant object directly).\n+\n+   procedure Set_Debug_Flag (C : Character; Val : Boolean := True);\n+   --  Where C is 0-9, A-Z, or a-z, sets the corresponding debug flag to\n+   --  the given value. In the checks off version of debug, the call to\n+   --  Set_Debug_Flag is always a null operation.\n+\n+end Debug;"}, {"sha": "ccb9e772afd59beb4db92c40a2cd3bced5430358", "filename": "gcc/ada/debug_a.adb", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug_a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug_a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug_a.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,128 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              D E B U G _ A                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.11 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;   use Atree;\n+with Debug;   use Debug;\n+with Sinfo;   use Sinfo;\n+with Sinput;  use Sinput;\n+with Output;  use Output;\n+\n+package body Debug_A is\n+\n+   Debug_A_Depth : Natural := 0;\n+   --  Output for the debug A flag is preceded by a sequence of vertical bar\n+   --  characters corresponding to the recursion depth of the actions being\n+   --  recorded (analysis, expansion, resolution and evaluation of nodes)\n+   --  This variable records the depth.\n+\n+   Max_Node_Ids : constant := 200;\n+   --  Maximum number of Node_Id values that get stacked\n+\n+   Node_Ids : array (1 .. Max_Node_Ids) of Node_Id;\n+   --  A stack used to keep track of Node_Id values for setting the value of\n+   --  Current_Error_Node correctly. Note that if we have more than 200\n+   --  recursion levels, we just don't reset the right value on exit, which\n+   --  is not crucial, since this is only for debugging!\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Debug_Output_Astring;\n+   --  Outputs Debug_A_Depth number of vertical bars, used to preface messages\n+\n+   -------------------\n+   -- Debug_A_Entry --\n+   -------------------\n+\n+   procedure Debug_A_Entry (S : String; N : Node_Id) is\n+   begin\n+      if Debug_Flag_A then\n+         Debug_Output_Astring;\n+         Write_Str (S);\n+         Write_Str (\"Node_Id = \");\n+         Write_Int (Int (N));\n+         Write_Str (\"  \");\n+         Write_Location (Sloc (N));\n+         Write_Str (\"  \");\n+         Write_Str (Node_Kind'Image (Nkind (N)));\n+         Write_Eol;\n+      end if;\n+\n+      Debug_A_Depth := Debug_A_Depth + 1;\n+      Current_Error_Node := N;\n+\n+      if Debug_A_Depth <= Max_Node_Ids then\n+         Node_Ids (Debug_A_Depth) := N;\n+      end if;\n+   end Debug_A_Entry;\n+\n+   ------------------\n+   -- Debug_A_Exit --\n+   ------------------\n+\n+   procedure Debug_A_Exit (S : String; N : Node_Id; Comment : String) is\n+   begin\n+      Debug_A_Depth := Debug_A_Depth - 1;\n+\n+      if Debug_A_Depth in 1 .. Max_Node_Ids then\n+         Current_Error_Node := Node_Ids (Debug_A_Depth);\n+      end if;\n+\n+      if Debug_Flag_A then\n+         Debug_Output_Astring;\n+         Write_Str (S);\n+         Write_Str (\"Node_Id = \");\n+         Write_Int (Int (N));\n+         Write_Str (Comment);\n+         Write_Eol;\n+      end if;\n+   end Debug_A_Exit;\n+\n+   --------------------------\n+   -- Debug_Output_Astring --\n+   --------------------------\n+\n+   procedure Debug_Output_Astring is\n+      Vbars : String := \"|||||||||||||||||||||||||\";\n+      --  Should be constant, removed because of GNAT 1.78 bug ???\n+\n+   begin\n+      if Debug_A_Depth > Vbars'Length then\n+         for I in Vbars'Length .. Debug_A_Depth loop\n+            Write_Char ('|');\n+         end loop;\n+\n+         Write_Str (Vbars);\n+\n+      else\n+         Write_Str (Vbars (1 .. Debug_A_Depth));\n+      end if;\n+   end Debug_Output_Astring;\n+\n+end Debug_A;"}, {"sha": "cc62a03b6d28d5b7d8ddd52f91a3b09d468cdb7c", "filename": "gcc/ada/debug_a.ads", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug_a.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdebug_a.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug_a.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,66 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              D E B U G _ A                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains data and subprograms to support the A debug switch\n+--  that is used to generate output showing what node is being analyzed,\n+--  resolved, evaluated, or expanded.\n+\n+with Types; use Types;\n+\n+package Debug_A is\n+\n+   --  Note: the following subprograms are used in a stack like manner, with\n+   --  an exit call matching each entry call. This means that they can keep\n+   --  track of the current node being worked on, with the entry call setting\n+   --  a new value, by pushing the Node_Id value on a stack, and the exit call\n+   --  popping this value off. Comperr.Current_Error_Node is set by both the\n+   --  entry and exit routines to point to the current node so that an abort\n+   --  message indicates the node involved as accurately as possible.\n+\n+   procedure Debug_A_Entry (S : String; N : Node_Id);\n+   pragma Inline (Debug_A_Entry);\n+   --  Generates a message prefixed by a sequence of bars showing the nesting\n+   --  depth (depth increases by 1 for a Debug_A_Entry call and is decreased\n+   --  by the corresponding Debug_A_Exit call). Then the string is output\n+   --  (analyzing, expanding etc), followed by the node number and its kind.\n+   --  This output is generated only if the debug A flag is set. If the debug\n+   --  A flag is not set, then no output is generated. This call also sets the\n+   --  Node_Id value in Comperr.Current_Error_Node in case a bomb occurs. This\n+   --  is done unconditionally, whether or not the debug A flag is set.\n+\n+   procedure Debug_A_Exit (S : String; N : Node_Id; Comment : String);\n+   pragma Inline (Debug_A_Exit);\n+   --  Generates the corresponding termination message. The message is preceded\n+   --  by a sequence of bars, followed by the string S, the node number, and\n+   --  a trailing comment (e.g. \" (already evaluated)\"). This output is\n+   --  generated only if the debug A flag is set. If the debug A flag is not\n+   --  set, then no output is generated. This call also resets the value in\n+   --  Comperr.Current_Error_Node to what it was before the corresponding call\n+   --  to Debug_A_Entry.\n+\n+end Debug_A;"}, {"sha": "2a063370dde0e809309055c2c4400e58ca35236c", "filename": "gcc/ada/dec-io.adb", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdec-io.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdec-io.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdec-io.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,211 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                               D E C . I O                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--            Copyright (C) 2001 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an AlphaVMS package that provides the interface between\n+--  GNAT, DECLib IO packages and the DECLib Bliss library.\n+\n+pragma Extend_System (Aux_DEC);\n+\n+with System;                            use  System;\n+with System.Task_Primitives;            use  System.Task_Primitives;\n+with System.Task_Primitives.Operations; use  System.Task_Primitives.Operations;\n+with IO_Exceptions;                     use  IO_Exceptions;\n+with Aux_IO_Exceptions;                 use  Aux_IO_Exceptions;\n+\n+package body DEC.IO is\n+\n+   type File_Type is record\n+      FCB : Integer   := 0;   -- Temporary\n+      SEQ : Integer   := 0;\n+   end record;\n+\n+   for File_Type'Size use 64;\n+   for File_Type'Alignment use 8;\n+\n+   for File_Type use record\n+      FCB at 0 range 0 .. 31;\n+      SEQ at 4 range 0 .. 31;\n+   end record;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function GNAT_Name_64 (File : File_Type) return String;\n+   pragma Export_Function (GNAT_Name_64, \"GNAT$NAME_64\");\n+   --  ??? comment\n+\n+   function GNAT_Form_64 (File : File_Type) return String;\n+   pragma Export_Function (GNAT_Form_64, \"GNAT$FORM_64\");\n+   --  ??? comment\n+\n+   procedure Init_IO;\n+   pragma Interface (C, Init_IO);\n+   pragma Import_Procedure (Init_IO, \"GNAT$$INIT_IO\");\n+   --  ??? comment\n+\n+   ----------------\n+   -- IO_Locking --\n+   ----------------\n+\n+   package body IO_Locking is\n+\n+      ------------------\n+      -- Create_Mutex --\n+      ------------------\n+\n+      function Create_Mutex return Access_Mutex is\n+         M : constant Access_Mutex := new RTS_Lock;\n+\n+      begin\n+         Initialize_Lock (M, Global_Task_Level);\n+         return M;\n+      end Create_Mutex;\n+\n+      -------------\n+      -- Acquire --\n+      -------------\n+\n+      procedure Acquire (M : Access_Mutex) is\n+      begin\n+         Write_Lock (M);\n+      end Acquire;\n+\n+      -------------\n+      -- Release --\n+      -------------\n+\n+      procedure Release (M : Access_Mutex) is\n+      begin\n+         Unlock (M);\n+      end Release;\n+\n+   end IO_Locking;\n+\n+   ------------------\n+   -- GNAT_Name_64 --\n+   ------------------\n+\n+   function GNAT_Name_64 (File : File_Type) return String is\n+      subtype Buffer_Subtype is String (1 .. 8192);\n+\n+      Buffer : Buffer_Subtype;\n+      Length : System.Integer_32;\n+\n+      procedure Get_Name\n+        (File    : System.Address;\n+         MaxLen  : System.Integer_32;\n+         Buffer  : out Buffer_Subtype;\n+         Length  : out System.Integer_32);\n+      pragma Interface (C, Get_Name);\n+      pragma Import_Procedure\n+        (Get_Name, \"GNAT$FILE_NAME\",\n+         Mechanism => (Value, Value, Reference, Reference));\n+\n+   begin\n+      Get_Name (File'Address, Buffer'Length, Buffer, Length);\n+      return Buffer (1 .. Integer (Length));\n+   end GNAT_Name_64;\n+\n+   ------------------\n+   -- GNAT_Form_64 --\n+   ------------------\n+\n+   function GNAT_Form_64 (File : File_Type) return String is\n+      subtype Buffer_Subtype is String (1 .. 8192);\n+\n+      Buffer : Buffer_Subtype;\n+      Length : System.Integer_32;\n+\n+      procedure Get_Form\n+        (File    : System.Address;\n+         MaxLen  : System.Integer_32;\n+         Buffer  : out Buffer_Subtype;\n+         Length  : out System.Integer_32);\n+      pragma Interface (C, Get_Form);\n+      pragma Import_Procedure\n+        (Get_Form, \"GNAT$FILE_FORM\",\n+         Mechanism => (Value, Value, Reference, Reference));\n+\n+   begin\n+      Get_Form (File'Address, Buffer'Length, Buffer, Length);\n+      return Buffer (1 .. Integer (Length));\n+   end GNAT_Form_64;\n+\n+   ------------------------\n+   -- Raise_IO_Exception --\n+   ------------------------\n+\n+   procedure Raise_IO_Exception (EN : Exception_Number) is\n+   begin\n+      case EN is\n+         when GNAT_EN_LOCK_ERROR =>      raise LOCK_ERROR;\n+         when GNAT_EN_EXISTENCE_ERROR => raise EXISTENCE_ERROR;\n+         when GNAT_EN_KEY_ERROR =>       raise KEY_ERROR;\n+         when GNAT_EN_KEYSIZERR =>       raise PROGRAM_ERROR; -- KEYSIZERR;\n+         when GNAT_EN_STAOVF =>          raise STORAGE_ERROR; -- STAOVF;\n+         when GNAT_EN_CONSTRAINT_ERRO => raise CONSTRAINT_ERROR;\n+         when GNAT_EN_IOSYSFAILED =>     raise DEVICE_ERROR;  -- IOSYSFAILED;\n+         when GNAT_EN_LAYOUT_ERROR =>    raise LAYOUT_ERROR;\n+         when GNAT_EN_STORAGE_ERROR =>   raise STORAGE_ERROR;\n+         when GNAT_EN_DATA_ERROR =>      raise DATA_ERROR;\n+         when GNAT_EN_DEVICE_ERROR =>    raise DEVICE_ERROR;\n+         when GNAT_EN_END_ERROR =>       raise END_ERROR;\n+         when GNAT_EN_MODE_ERROR =>      raise MODE_ERROR;\n+         when GNAT_EN_NAME_ERROR =>      raise NAME_ERROR;\n+         when GNAT_EN_STATUS_ERROR =>    raise STATUS_ERROR;\n+         when GNAT_EN_NOT_OPEN =>        raise USE_ERROR;   -- NOT_OPEN;\n+         when GNAT_EN_ALREADY_OPEN =>    raise USE_ERROR;   -- ALREADY_OPEN;\n+         when GNAT_EN_USE_ERROR =>       raise USE_ERROR;\n+         when GNAT_EN_UNSUPPORTED =>     raise USE_ERROR;   -- UNSUPPORTED;\n+         when GNAT_EN_FAC_MODE_MISMAT => raise USE_ERROR;   -- FAC_MODE_MISMAT;\n+         when GNAT_EN_ORG_MISMATCH =>    raise USE_ERROR;   -- ORG_MISMATCH;\n+         when GNAT_EN_RFM_MISMATCH =>    raise USE_ERROR;   -- RFM_MISMATCH;\n+         when GNAT_EN_RAT_MISMATCH =>    raise USE_ERROR;   -- RAT_MISMATCH;\n+         when GNAT_EN_MRS_MISMATCH =>    raise USE_ERROR;   -- MRS_MISMATCH;\n+         when GNAT_EN_MRN_MISMATCH =>    raise USE_ERROR;   -- MRN_MISMATCH;\n+         when GNAT_EN_KEY_MISMATCH =>    raise USE_ERROR;   -- KEY_MISMATCH;\n+         when GNAT_EN_MAXLINEXC =>       raise CONSTRAINT_ERROR; -- MAXLINEXC;\n+         when GNAT_EN_LINEXCMRS =>       raise CONSTRAINT_ERROR; -- LINEXCMRS;\n+      end case;\n+   end Raise_IO_Exception;\n+\n+-------------------------\n+-- Package Elaboration --\n+-------------------------\n+\n+begin\n+   Init_IO;\n+end DEC.IO;"}, {"sha": "ab1e693274784ee42169e4c0b393b97899a07df7", "filename": "gcc/ada/dec-io.ads", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdec-io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdec-io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdec-io.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,125 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                               D E C . I O                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--          Copyright (C) 1996-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an AlphaVMS package that contains the declarations and\n+--  function specifications needed by the DECLib IO packages.\n+\n+with System.Task_Primitives;\n+package DEC.IO is\n+private\n+\n+   type Exception_Number is (\n+     GNAT_EN_LOCK_ERROR,\n+     GNAT_EN_EXISTENCE_ERROR,\n+     GNAT_EN_KEY_ERROR,\n+     GNAT_EN_KEYSIZERR,\n+     GNAT_EN_STAOVF,\n+     GNAT_EN_CONSTRAINT_ERRO,\n+     GNAT_EN_IOSYSFAILED,\n+     GNAT_EN_LAYOUT_ERROR,\n+     GNAT_EN_STORAGE_ERROR,\n+     GNAT_EN_DATA_ERROR,\n+     GNAT_EN_DEVICE_ERROR,\n+     GNAT_EN_END_ERROR,\n+     GNAT_EN_MODE_ERROR,\n+     GNAT_EN_NAME_ERROR,\n+     GNAT_EN_STATUS_ERROR,\n+     GNAT_EN_NOT_OPEN,\n+     GNAT_EN_ALREADY_OPEN,\n+     GNAT_EN_USE_ERROR,\n+     GNAT_EN_UNSUPPORTED,\n+     GNAT_EN_FAC_MODE_MISMAT,\n+     GNAT_EN_ORG_MISMATCH,\n+     GNAT_EN_RFM_MISMATCH,\n+     GNAT_EN_RAT_MISMATCH,\n+     GNAT_EN_MRS_MISMATCH,\n+     GNAT_EN_MRN_MISMATCH,\n+     GNAT_EN_KEY_MISMATCH,\n+     GNAT_EN_MAXLINEXC,\n+     GNAT_EN_LINEXCMRS);\n+\n+   for Exception_Number'Size use 32;\n+\n+   for Exception_Number use (\n+     GNAT_EN_LOCK_ERROR => 1,\n+     GNAT_EN_EXISTENCE_ERROR => 2,\n+     GNAT_EN_KEY_ERROR => 3,\n+     GNAT_EN_KEYSIZERR => 4,\n+     GNAT_EN_STAOVF => 5,\n+     GNAT_EN_CONSTRAINT_ERRO => 6,\n+     GNAT_EN_IOSYSFAILED => 7,\n+     GNAT_EN_LAYOUT_ERROR => 8,\n+     GNAT_EN_STORAGE_ERROR => 9,\n+     GNAT_EN_DATA_ERROR => 10,\n+     GNAT_EN_DEVICE_ERROR => 11,\n+     GNAT_EN_END_ERROR => 12,\n+     GNAT_EN_MODE_ERROR => 13,\n+     GNAT_EN_NAME_ERROR => 14,\n+     GNAT_EN_STATUS_ERROR => 15,\n+     GNAT_EN_NOT_OPEN => 16,\n+     GNAT_EN_ALREADY_OPEN => 17,\n+     GNAT_EN_USE_ERROR => 18,\n+     GNAT_EN_UNSUPPORTED => 19,\n+     GNAT_EN_FAC_MODE_MISMAT => 20,\n+     GNAT_EN_ORG_MISMATCH => 21,\n+     GNAT_EN_RFM_MISMATCH => 22,\n+     GNAT_EN_RAT_MISMATCH => 23,\n+     GNAT_EN_MRS_MISMATCH => 24,\n+     GNAT_EN_MRN_MISMATCH => 25,\n+     GNAT_EN_KEY_MISMATCH => 26,\n+     GNAT_EN_MAXLINEXC => 27,\n+     GNAT_EN_LINEXCMRS => 28);\n+\n+   procedure Raise_IO_Exception (EN : Exception_Number);\n+   pragma Export_Procedure (Raise_IO_Exception, \"GNAT$RAISE_IO_EXCEPTION\",\n+      Mechanism => Value);\n+\n+   package IO_Locking is\n+      type Access_Mutex is private;\n+      function Create_Mutex return Access_Mutex;\n+      procedure Acquire (M : Access_Mutex);\n+      procedure Release (M : Access_Mutex);\n+\n+   private\n+      type Access_Mutex is access System.Task_Primitives.RTS_Lock;\n+      pragma Export_Function (Create_Mutex, \"GNAT$CREATE_MUTEX\",\n+          Mechanism => Value);\n+      pragma Export_Procedure (Acquire, \"GNAT$ACQUIRE_MUTEX\",\n+          Mechanism => Value);\n+      pragma Export_Procedure (Release, \"GNAT$RELEASE_MUTEX\",\n+          Mechanism => Value);\n+   end IO_Locking;\n+\n+end DEC.IO;"}, {"sha": "b3af42a9cd4110bc31d6e78c23428816a2c7fd39", "filename": "gcc/ada/dec.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdec.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,42 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                                  D E C                                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--          Copyright (C) 1996-2001  Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an AlphaVMS package, which is imported by every package in\n+--  DECLib and tested for in gnatbind, in order to add \"-ldecgnat\" to\n+--  the bind. It is also a convenient parent for all DEC IO child packages.\n+\n+package DEC is\n+pragma Pure (DEC);\n+end DEC;"}, {"sha": "c2acdbcfc254073c89761a714cd6f4699f927876", "filename": "gcc/ada/decl.c", "status": "added", "additions": 6133, "deletions": 0, "changes": 6133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "635f5a853ab0cd51ab61986152ff85f318d6f0ed", "filename": "gcc/ada/deftarg.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdeftarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdeftarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdeftarg.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,40 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             D E F T A R G                                *\n+ *                                                                          *\n+ *                                  Body                                    *\n+ *                                                                          *\n+ *                             $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Include a default definition for TARGET_FLAGS for gnatpsta.  */\n+\n+#include \"config.h\"\n+#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n+\n+int target_flags = TARGET_DEFAULT;"}, {"sha": "555ce551b73d7987f9019df82d06922e0199e4bf", "filename": "gcc/ada/directio.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdirectio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fdirectio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdirectio.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,21 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--                            D I R E C T _ I O                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.8 $                              --\n+--                                                                          --\n+-- This specification is adapted from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Ada_95;\n+with Ada.Direct_IO;\n+\n+generic package Direct_IO renames Ada.Direct_IO;"}, {"sha": "55c039431dd16f841fd66b440bd3e0e25d4a66b3", "filename": "gcc/ada/einfo.adb", "status": "added", "additions": 6844, "deletions": 0, "changes": 6844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "eaa97c8800ca601640b5c6ca120c2d3d69d289a4", "filename": "gcc/ada/einfo.ads", "status": "added", "additions": 6291, "deletions": 0, "changes": 6291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "1bfbfd72c3317d5750192779b7f7856c0735d7e6", "filename": "gcc/ada/elists.adb", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,469 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               E L I S T S                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.22 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  WARNING: There is a C version of this package. Any changes to this\n+--  source file must be properly reflected in the C header a-elists.h.\n+\n+with Alloc;\n+with Debug;  use Debug;\n+with Output; use Output;\n+with Table;\n+\n+package body Elists is\n+\n+   -------------------------------------\n+   -- Implementation of Element Lists --\n+   -------------------------------------\n+\n+   --  Element lists are composed of three types of entities. The element\n+   --  list header, which references the first and last elements of the\n+   --  list, the elements themselves which are singly linked and also\n+   --  reference the nodes on the list, and finally the nodes themselves.\n+   --  The following diagram shows how an element list is represented:\n+\n+   --       +----------------------------------------------------+\n+   --       |  +------------------------------------------+      |\n+   --       |  |                                          |      |\n+   --       V  |                                          V      |\n+   --    +-----|--+    +-------+    +-------+         +-------+  |\n+   --    |  Elmt  |    |  1st  |    |  2nd  |         |  Last |  |\n+   --    |  List  |--->|  Elmt |--->|  Elmt  ---...-->|  Elmt ---+\n+   --    | Header |    |   |   |    |   |   |         |   |   |\n+   --    +--------+    +---|---+    +---|---+         +---|---+\n+   --                      |            |                 |\n+   --                      V            V                 V\n+   --                  +-------+    +-------+         +-------+\n+   --                  |       |    |       |         |       |\n+   --                  | Node1 |    | Node2 |         | Node3 |\n+   --                  |       |    |       |         |       |\n+   --                  +-------+    +-------+         +-------+\n+\n+   --  The list header is an entry in the Elists table. The values used for\n+   --  the type Elist_Id are subscripts into this table. The First_Elmt field\n+   --  (Lfield1) points to the first element on the list, or to No_Elmt in the\n+   --  case of an empty list. Similarly the Last_Elmt field (Lfield2) points to\n+   --  the last element on the list or to No_Elmt in the case of an empty list.\n+\n+   --  The elements themselves are entries in the Elmts table. The Next field\n+   --  of each entry points to the next element, or to the Elist header if this\n+   --  is the last item in the list. The Node field points to the node which\n+   --  is referenced by the corresponding list entry.\n+\n+   --------------------------\n+   --  Element List Tables --\n+   --------------------------\n+\n+   type Elist_Header is record\n+      First : Elmt_Id;\n+      Last  : Elmt_Id;\n+   end record;\n+\n+   package Elists is new Table.Table (\n+     Table_Component_Type => Elist_Header,\n+     Table_Index_Type     => Elist_Id,\n+     Table_Low_Bound      => First_Elist_Id,\n+     Table_Initial        => Alloc.Elists_Initial,\n+     Table_Increment      => Alloc.Elists_Increment,\n+     Table_Name           => \"Elists\");\n+\n+   type Elmt_Item is record\n+      Node : Node_Id;\n+      Next : Union_Id;\n+   end record;\n+\n+   package Elmts is new Table.Table (\n+     Table_Component_Type => Elmt_Item,\n+     Table_Index_Type     => Elmt_Id,\n+     Table_Low_Bound      => First_Elmt_Id,\n+     Table_Initial        => Alloc.Elmts_Initial,\n+     Table_Increment      => Alloc.Elmts_Increment,\n+     Table_Name           => \"Elmts\");\n+\n+   -----------------\n+   -- Append_Elmt --\n+   -----------------\n+\n+   procedure Append_Elmt (Node : Node_Id; To : Elist_Id) is\n+      L : constant Elmt_Id := Elists.Table (To).Last;\n+\n+   begin\n+      Elmts.Increment_Last;\n+      Elmts.Table (Elmts.Last).Node := Node;\n+      Elmts.Table (Elmts.Last).Next := Union_Id (To);\n+\n+      if L = No_Elmt then\n+         Elists.Table (To).First := Elmts.Last;\n+      else\n+         Elmts.Table (L).Next := Union_Id (Elmts.Last);\n+      end if;\n+\n+      Elists.Table (To).Last  := Elmts.Last;\n+\n+      if Debug_Flag_N then\n+         Write_Str (\"Append new element Elmt_Id = \");\n+         Write_Int (Int (Elmts.Last));\n+         Write_Str (\" to list Elist_Id = \");\n+         Write_Int (Int (To));\n+         Write_Str (\" referencing Node_Id = \");\n+         Write_Int (Int (Node));\n+         Write_Eol;\n+      end if;\n+   end Append_Elmt;\n+\n+   --------------------\n+   -- Elists_Address --\n+   --------------------\n+\n+   function Elists_Address return System.Address is\n+   begin\n+      return Elists.Table (First_Elist_Id)'Address;\n+   end Elists_Address;\n+\n+   -------------------\n+   -- Elmts_Address --\n+   -------------------\n+\n+   function Elmts_Address return System.Address is\n+   begin\n+      return Elmts.Table (First_Elmt_Id)'Address;\n+   end Elmts_Address;\n+\n+   ----------------\n+   -- First_Elmt --\n+   ----------------\n+\n+   function First_Elmt (List : Elist_Id) return Elmt_Id is\n+   begin\n+      pragma Assert (List > Elist_Low_Bound);\n+      return Elists.Table (List).First;\n+   end First_Elmt;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Elists.Init;\n+      Elmts.Init;\n+   end Initialize;\n+\n+   -----------------------\n+   -- Insert_Elmt_After --\n+   -----------------------\n+\n+   procedure Insert_Elmt_After (Node : Node_Id; Elmt : Elmt_Id) is\n+      N : constant Union_Id := Elmts.Table (Elmt).Next;\n+\n+   begin\n+\n+      pragma Assert (Elmt /= No_Elmt);\n+\n+      Elmts.Increment_Last;\n+      Elmts.Table (Elmts.Last).Node := Node;\n+      Elmts.Table (Elmts.Last).Next := N;\n+\n+      Elmts.Table (Elmt).Next := Union_Id (Elmts.Last);\n+\n+      if N in Elist_Range then\n+         Elists.Table (Elist_Id (N)).Last := Elmts.Last;\n+      end if;\n+   end Insert_Elmt_After;\n+\n+   ------------------------\n+   -- Is_Empty_Elmt_List --\n+   ------------------------\n+\n+   function Is_Empty_Elmt_List (List : Elist_Id) return Boolean is\n+   begin\n+      return Elists.Table (List).First = No_Elmt;\n+   end Is_Empty_Elmt_List;\n+\n+   -------------------\n+   -- Last_Elist_Id --\n+   -------------------\n+\n+   function Last_Elist_Id return Elist_Id is\n+   begin\n+      return Elists.Last;\n+   end Last_Elist_Id;\n+\n+   ---------------\n+   -- Last_Elmt --\n+   ---------------\n+\n+   function Last_Elmt (List : Elist_Id) return Elmt_Id is\n+   begin\n+      return Elists.Table (List).Last;\n+   end Last_Elmt;\n+\n+   ------------------\n+   -- Last_Elmt_Id --\n+   ------------------\n+\n+   function Last_Elmt_Id return Elmt_Id is\n+   begin\n+      return Elmts.Last;\n+   end Last_Elmt_Id;\n+\n+   ----------\n+   -- Lock --\n+   ----------\n+\n+   procedure Lock is\n+   begin\n+      Elists.Locked := True;\n+      Elmts.Locked := True;\n+      Elists.Release;\n+      Elmts.Release;\n+   end Lock;\n+\n+   -------------------\n+   -- New_Elmt_List --\n+   -------------------\n+\n+   function New_Elmt_List return Elist_Id is\n+   begin\n+      Elists.Increment_Last;\n+      Elists.Table (Elists.Last).First := No_Elmt;\n+      Elists.Table (Elists.Last).Last  := No_Elmt;\n+\n+      if Debug_Flag_N then\n+         Write_Str (\"Allocate new element list, returned ID = \");\n+         Write_Int (Int (Elists.Last));\n+         Write_Eol;\n+      end if;\n+\n+      return Elists.Last;\n+   end New_Elmt_List;\n+\n+   ---------------\n+   -- Next_Elmt --\n+   ---------------\n+\n+   function Next_Elmt (Elmt : Elmt_Id) return Elmt_Id is\n+      N : constant Union_Id := Elmts.Table (Elmt).Next;\n+\n+   begin\n+      if N in Elist_Range then\n+         return No_Elmt;\n+      else\n+         return Elmt_Id (N);\n+      end if;\n+   end Next_Elmt;\n+\n+   procedure Next_Elmt (Elmt : in out Elmt_Id) is\n+   begin\n+      Elmt := Next_Elmt (Elmt);\n+   end Next_Elmt;\n+\n+   --------\n+   -- No --\n+   --------\n+\n+   function No (List : Elist_Id) return Boolean is\n+   begin\n+      return List = No_Elist;\n+   end No;\n+\n+   function No (Elmt : Elmt_Id) return Boolean is\n+   begin\n+      return Elmt = No_Elmt;\n+   end No;\n+\n+   -----------\n+   -- Node --\n+   -----------\n+\n+   function Node (Elmt : Elmt_Id) return Node_Id is\n+   begin\n+      if Elmt = No_Elmt then\n+         return Empty;\n+      else\n+         return Elmts.Table (Elmt).Node;\n+      end if;\n+   end Node;\n+\n+   ----------------\n+   -- Num_Elists --\n+   ----------------\n+\n+   function Num_Elists return Nat is\n+   begin\n+      return Int (Elmts.Last) - Int (Elmts.First) + 1;\n+   end Num_Elists;\n+\n+   ------------------\n+   -- Prepend_Elmt --\n+   ------------------\n+\n+   procedure Prepend_Elmt (Node : Node_Id; To : Elist_Id) is\n+      F : constant Elmt_Id := Elists.Table (To).First;\n+\n+   begin\n+      Elmts.Increment_Last;\n+      Elmts.Table (Elmts.Last).Node := Node;\n+\n+      if F = No_Elmt then\n+         Elists.Table (To).Last := Elmts.Last;\n+         Elmts.Table (Elmts.Last).Next := Union_Id (To);\n+      else\n+         Elmts.Table (Elmts.Last).Next := Union_Id (F);\n+      end if;\n+\n+      Elists.Table (To).First  := Elmts.Last;\n+\n+   end Prepend_Elmt;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (List : Elist_Id) return Boolean is\n+   begin\n+      return List /= No_Elist;\n+   end Present;\n+\n+   function Present (Elmt : Elmt_Id) return Boolean is\n+   begin\n+      return Elmt /= No_Elmt;\n+   end Present;\n+\n+   -----------------\n+   -- Remove_Elmt --\n+   -----------------\n+\n+   procedure Remove_Elmt (List : Elist_Id; Elmt : Elmt_Id) is\n+      Nxt : Elmt_Id;\n+      Prv : Elmt_Id;\n+\n+   begin\n+      Nxt := Elists.Table (List).First;\n+\n+      --  Case of removing only element in the list\n+\n+      if Elmts.Table (Nxt).Next in Elist_Range then\n+\n+         pragma Assert (Nxt = Elmt);\n+\n+         Elists.Table (List).First := No_Elmt;\n+         Elists.Table (List).Last  := No_Elmt;\n+\n+      --  Case of removing the first element in the list\n+\n+      elsif Nxt = Elmt then\n+         Elists.Table (List).First := Elmt_Id (Elmts.Table (Nxt).Next);\n+\n+      --  Case of removing second or later element in the list\n+\n+      else\n+         loop\n+            Prv := Nxt;\n+            Nxt := Elmt_Id (Elmts.Table (Prv).Next);\n+            exit when Nxt = Elmt\n+              or else Elmts.Table (Nxt).Next in Elist_Range;\n+         end loop;\n+\n+         pragma Assert (Nxt = Elmt);\n+\n+         Elmts.Table (Prv).Next := Elmts.Table (Nxt).Next;\n+\n+         if Elmts.Table (Prv).Next in Elist_Range then\n+            Elists.Table (List).Last := Prv;\n+         end if;\n+      end if;\n+   end Remove_Elmt;\n+\n+   ----------------------\n+   -- Remove_Last_Elmt --\n+   ----------------------\n+\n+   procedure Remove_Last_Elmt (List : Elist_Id) is\n+      Nxt : Elmt_Id;\n+      Prv : Elmt_Id;\n+\n+   begin\n+      Nxt := Elists.Table (List).First;\n+\n+      --  Case of removing only element in the list\n+\n+      if Elmts.Table (Nxt).Next in Elist_Range then\n+         Elists.Table (List).First := No_Elmt;\n+         Elists.Table (List).Last  := No_Elmt;\n+\n+      --  Case of at least two elements in list\n+\n+      else\n+         loop\n+            Prv := Nxt;\n+            Nxt := Elmt_Id (Elmts.Table (Prv).Next);\n+            exit when Elmts.Table (Nxt).Next in Elist_Range;\n+         end loop;\n+\n+         Elmts.Table (Prv).Next   := Elmts.Table (Nxt).Next;\n+         Elists.Table (List).Last := Prv;\n+      end if;\n+   end Remove_Last_Elmt;\n+\n+   ------------------\n+   -- Replace_Elmt --\n+   ------------------\n+\n+   procedure Replace_Elmt (Elmt : Elmt_Id; New_Node : Node_Id) is\n+   begin\n+      Elmts.Table (Elmt).Node := New_Node;\n+   end Replace_Elmt;\n+\n+   ---------------\n+   -- Tree_Read --\n+   ---------------\n+\n+   procedure Tree_Read is\n+   begin\n+      Elists.Tree_Read;\n+      Elmts.Tree_Read;\n+   end Tree_Read;\n+\n+   ----------------\n+   -- Tree_Write --\n+   ----------------\n+\n+   procedure Tree_Write is\n+   begin\n+      Elists.Tree_Write;\n+      Elmts.Tree_Write;\n+   end Tree_Write;\n+\n+end Elists;"}, {"sha": "0c42196189caa12ff9b39758095ce0555054fc9e", "filename": "gcc/ada/elists.ads", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Felists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Felists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,171 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               E L I S T S                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.14 $                             --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides facilities for manipulating lists of nodes (see\n+--  package Atree for format and implementation of tree nodes). Separate list\n+--  elements are allocated to represent elements of these lists, so it is\n+--  possible for a given node to be on more than one element list at a time.\n+--  See also package Nlists, which provides another form that is threaded\n+--  through the nodes themselves (using the Link field), which is more time\n+--  and space efficient, but a node can be only one such list.\n+\n+with Types;  use Types;\n+with System;\n+\n+package Elists is\n+\n+   --  An element list is represented by a header that is allocated in the\n+   --  Elist header table. This header contains pointers to the first and\n+   --  last elements in the list, or to No_Elmt if the list is empty.\n+\n+   --  The elements in the list each contain a pointer to the next element\n+   --  and a pointer to the referenced node. Putting a node into an element\n+   --  list causes no change at all to the node itself, so a node may be\n+   --  included in multiple element lists, and the nodes thus included may\n+   --  or may not be elements of node lists (see package Nlists).\n+\n+   procedure Initialize;\n+   --  Initialize allocation of element list tables. Called at the start of\n+   --  compiling each new main source file. Note that Initialize must not be\n+   --  called if Tree_Read is used.\n+\n+   procedure Lock;\n+   --  Lock tables used for element lists before calling backend\n+\n+   procedure Tree_Read;\n+   --  Initializes internal tables from current tree file using Tree_Read.\n+   --  Note that Initialize should not be called if Tree_Read is used.\n+   --  Tree_Read includes all necessary initialization.\n+\n+   procedure Tree_Write;\n+   --  Writes out internal tables to current tree file using Tree_Write\n+\n+   function Last_Elist_Id return Elist_Id;\n+   --  Returns Id of last allocated element list header\n+\n+   function Elists_Address return System.Address;\n+   --  Return address of Elists table (used in Back_End for Gigi call)\n+\n+   function Num_Elists return Nat;\n+   --  Number of currently allocated element lists\n+\n+   function Last_Elmt_Id return Elmt_Id;\n+   --  Returns Id of last allocated list element\n+\n+   function Elmts_Address return System.Address;\n+   --  Return address of Elmts table (used in Back_End for Gigi call)\n+\n+   function Node (Elmt : Elmt_Id) return Node_Id;\n+   pragma Inline (Node);\n+   --  Returns the value of a given list element. Returns Empty if Elmt\n+   --  is set to No_Elmt.\n+\n+   function New_Elmt_List return Elist_Id;\n+   --  Creates a new empty element list. Typically this is used to initialize\n+   --  a field in some other node which points to an element list where the\n+   --  list is then subsequently filled in using Append calls.\n+\n+   function First_Elmt (List : Elist_Id) return Elmt_Id;\n+   pragma Inline (First_Elmt);\n+   --  Obtains the first element of the given element list or, if the\n+   --  list has no items, then No_Elmt is returned.\n+\n+   function Last_Elmt (List : Elist_Id) return Elmt_Id;\n+   pragma Inline (Last_Elmt);\n+   --  Obtains the last element of the given element list or, if the\n+   --  list has no items, then No_Elmt is returned.\n+\n+   function Next_Elmt (Elmt : Elmt_Id) return Elmt_Id;\n+   pragma Inline (Next_Elmt);\n+   --  This function returns the next element on an element list. The argument\n+   --  must be a list element other than No_Elmt. Returns No_Elmt if the given\n+   --  element is the last element of the list.\n+\n+   procedure Next_Elmt (Elmt : in out Elmt_Id);\n+   pragma Inline (Next_Elmt);\n+   --  Next_Elmt (Elmt) is equivalent to Elmt := Next_Elmt (Elmt)\n+\n+   function Is_Empty_Elmt_List (List : Elist_Id) return Boolean;\n+   pragma Inline (Is_Empty_Elmt_List);\n+   --  This function determines if a given tree id references an element list\n+   --  that contains no items.\n+\n+   procedure Append_Elmt (Node : Node_Id; To : Elist_Id);\n+   --  Appends Node at the end of To, allocating a new element.\n+\n+   procedure Prepend_Elmt (Node : Node_Id; To : Elist_Id);\n+   --  Appends Node at the beginning of To, allocating a new element.\n+\n+   procedure Insert_Elmt_After (Node : Node_Id; Elmt : Elmt_Id);\n+   --  Add a new element (Node) right after the pre-existing element Elmt\n+   --  It is invalid to call this subprogram with Elmt = No_Elmt.\n+\n+   procedure Replace_Elmt (Elmt : Elmt_Id; New_Node : Node_Id);\n+   pragma Inline (Replace_Elmt);\n+   --  Causes the given element of the list to refer to New_Node, the node\n+   --  which was previously referred to by Elmt is effectively removed from\n+   --  the list and replaced by New_Node.\n+\n+   procedure Remove_Elmt (List : Elist_Id; Elmt : Elmt_Id);\n+   --  Removes Elmt from the given list. The node itself is not affected,\n+   --  but the space used by the list element may be (but is not required\n+   --  to be) freed for reuse in a subsequent Append_Elmt call.\n+\n+   procedure Remove_Last_Elmt (List : Elist_Id);\n+   --  Removes the last element of the given list. The node itself is not\n+   --  affected, but the space used by the list element may be (but is not\n+   --  required to be) freed for reuse in a subsequent Append_Elmt call.\n+\n+   function No (List : Elist_Id) return Boolean;\n+   pragma Inline (No);\n+   --  Tests given Id for equality with No_Elist. This allows notations like\n+   --  \"if No (Statements)\" as opposed to \"if Statements = No_Elist\".\n+\n+   function Present (List : Elist_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Tests given Id for inequality with No_Elist. This allows notations like\n+   --  \"if Present (Statements)\" as opposed to \"if Statements /= No_Elist\".\n+\n+   function No (Elmt : Elmt_Id) return Boolean;\n+   pragma Inline (No);\n+   --  Tests given Id for equality with No_Elmt. This allows notations like\n+   --  \"if No (Operation)\" as opposed to \"if Operation = No_Elmt\".\n+\n+   function Present (Elmt : Elmt_Id) return Boolean;\n+   pragma Inline (Present);\n+   --  Tests given Id for inequality with No_Elmt. This allows notations like\n+   --  \"if Present (Operation)\" as opposed to \"if Operation /= No_Elmt\".\n+\n+end Elists;"}, {"sha": "f9eaea7cabe39fc5a99f870a1c0758355aa668ed", "filename": "gcc/ada/elists.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Felists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Felists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.h?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,107 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                               E L I S T S                                *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This is the C header corresponding to the Ada package specification for\n+   Elists. It also contains the implementations of inlined functions from the\n+   package body for Elists.  It was generated manually from elists.ads and\n+   elists.adb and must be kept synchronized with changes in these files.\n+\n+   Note that only routines for reading the tree are included, since the\n+   tree transformer is not supposed to modify the tree in any way. */\n+\n+/*  The following are the structures used to hold element lists */\n+\n+struct Elist_Header\n+{\n+  Elmt_Id first;\n+  Elmt_Id last;\n+};\n+\n+struct Elmt_Item\n+{\n+  Node_Id node;\n+  Int next;\n+};\n+\n+/* The element list headers and element descriptors themselves are stored in\n+   two arrays. The pointers to these arrays are passed as a parameter to the\n+   tree transformer procedure and stored in the global variables Elists_Ptr\n+   and Elmts_Ptr after adjusting them by subtracting Elist_First_Entry and\n+   Elmt_First_Entry, so that Elist_Id and Elmt_Id values can be used as\n+   subscripts into these arrays */\n+\n+extern struct Elist_Header *Elists_Ptr;\n+extern struct Elmt_Item *Elmts_Ptr;\n+\n+/* Element List Access Functions:  */\n+\n+static Node_Id Node\t\tPARAMS ((Elmt_Id));\n+static Elmt_Id First_Elmt\tPARAMS ((Elist_Id));\n+static Elmt_Id Last_Elmt\tPARAMS ((Elist_Id));\n+static Elmt_Id Next_Elmt\tPARAMS ((Elmt_Id));\n+static Boolean Is_Empty_Elmt_List PARAMS ((Elist_Id));\n+\n+INLINE Node_Id\n+Node (Elmt)\n+     Elmt_Id Elmt;\n+{\n+  return Elmts_Ptr [Elmt].node;\n+}\n+\n+INLINE Elmt_Id\n+First_Elmt (List)\n+     Elist_Id List;\n+{\n+  return Elists_Ptr [List].first;\n+}\n+\n+INLINE Elmt_Id\n+Last_Elmt (List)\n+     Elist_Id List;\n+{\n+  return Elists_Ptr [List].last;\n+}\n+\n+INLINE Elmt_Id\n+Next_Elmt (Node)\n+     Elmt_Id Node;\n+{\n+  Int N = Elmts_Ptr [Node].next;\n+\n+  if (IN (N, Elist_Range))\n+    return No_Elmt;\n+  else\n+    return N;\n+}\n+\n+INLINE Boolean\n+Is_Empty_Elmt_List (Id)\n+     Elist_Id Id;\n+{\n+  return Elists_Ptr [Id].first == No_Elmt;\n+}"}, {"sha": "92eb2e3f84cd3aa8d438f900531ec97bef99dba7", "filename": "gcc/ada/errno.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ferrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ferrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrno.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,57 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               *\n+ *                                                                          *\n+ *                                E R R N O                                 *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                             $Revision: 1.1 $\n+ *                                                                          *\n+ *           Copyright (C) 1992-2001 Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file provides access to the C-language errno to the Ada interface\n+   for POSIX.  It is not possible in general to import errno, even in\n+   Ada compilers that allow (as GNAT does) the importation of variables,\n+   as it may be defined using a macro.\n+*/\n+\n+\n+#define _REENTRANT\n+#define _THREAD_SAFE\n+\n+#include <errno.h>\n+int\n+__get_errno()\n+{\n+  return errno;\n+}\n+\n+void\n+__set_errno(err)\n+     int err;\n+{\n+  errno = err;\n+}"}, {"sha": "ad64a5fa30af78c27d1dff173d6c59d119bd4801", "filename": "gcc/ada/errout.adb", "status": "added", "additions": 3083, "deletions": 0, "changes": 3083, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "ece8175434c99806cd98054d0f6780ac1bd43884", "filename": "gcc/ada/errout.ads", "status": "added", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,504 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               E R R O U T                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.70 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines to output error messages. They\n+--  are basically system independent, however in some environments, e.g.\n+--  when the parser is embedded into an editor, it may be appropriate\n+--  to replace the implementation of this package.\n+\n+with Table;\n+with Types; use Types;\n+with Uintp; use Uintp;\n+\n+package Errout is\n+\n+   Errors_Detected : Nat;\n+   --  Number of errors detected so far\n+\n+   Warnings_Detected : Nat;\n+   --  Number of warnings detected\n+\n+   type Compiler_State_Type is (Parsing, Analyzing);\n+   Compiler_State : Compiler_State_Type;\n+   --  Indicates current state of compilation. This is put in the Errout\n+   --  spec because it affects the action of the error message handling.\n+   --  In particular, an attempt is made by Errout to suppress cascaded\n+   --  error messages in Parsing mode, but not in the other modes.\n+\n+   Current_Error_Source_File : Source_File_Index;\n+   --  Id of current messages. Used to post file name when unit changes. This\n+   --  is initialized to Main_Source_File at the start of a compilation, which\n+   --  means that no file names will be output unless there are errors in units\n+   --  other than the main unit. However, if the main unit has a pragma\n+   --  Source_Reference line, then this is initialized to No_Source_File,\n+   --  to force an initial reference to the real source file name.\n+\n+   Raise_Exception_On_Error : Nat := 0;\n+   --  If this value is non-zero, then any attempt to generate an error\n+   --  message raises the exception Error_Msg_Exception, and the error\n+   --  message is not output. This is used for defending against junk\n+   --  resulting from illegalities, and also for substitution of more\n+   --  appropriate error messages from higher semantic levels. It is\n+   --  a counter so that the increment/decrement protocol nests neatly.\n+\n+   Error_Msg_Exception : exception;\n+   --  Exception raised if Raise_Exception_On_Error is true\n+\n+   -----------------------------------\n+   -- Suppression of Error Messages --\n+   -----------------------------------\n+\n+   --  In an effort to reduce the impact of redundant error messages, the\n+   --  error output routines in this package normally suppress certain\n+   --  classes of messages as follows:\n+\n+   --    1.  Identical messages placed at the same point in the text. Such\n+   --        duplicate error message result for example from rescanning\n+   --        sections of the text that contain lexical errors. Only one of\n+   --        such a set of duplicate messages is output, and the rest are\n+   --        suppressed.\n+\n+   --    2.  If more than one parser message is generated for a single source\n+   --        line, then only the first message is output, the remaining\n+   --        messages on the same line are suppressed.\n+\n+   --    3.  If a message is posted on a node for which a message has been\n+   --        previously posted, then only the first message is retained. The\n+   --        Error_Posted flag is used to detect such multiple postings. Note\n+   --        that this only applies to semantic messages, since otherwise\n+   --        for parser messages, this would be a special case of case 2.\n+\n+   --    4.  If a message is posted on a node whose Etype or Entity\n+   --        fields reference entities on which an error message has\n+   --        already been placed, as indicated by the Error_Posted flag\n+   --        being set on these entities, then the message is suppressed.\n+\n+   --    5.  If a message attempts to insert an Error node, or a direct\n+   --        reference to the Any_Type node, then the message is suppressed.\n+\n+   --  This normal suppression action may be overridden in cases 2-5 (but not\n+   --  in case 1) by setting All_Errors mode, or by setting the special\n+   --  unconditional message insertion character (!) at the end of the message\n+   --  text as described below.\n+\n+   ---------------------------------------------------------\n+   -- Error Message Text and Message Insertion Characters --\n+   ---------------------------------------------------------\n+\n+   --  Error message text strings are composed of lower case letters, digits\n+   --  and the special characters space, comma, period, colon and semicolon,\n+   --  apostrophe and parentheses. Special insertion characters can also\n+   --  appear which cause the error message circuit to modify the given\n+   --  string as follows:\n+\n+   --    Insertion character % (Percent: insert name from Names table)\n+   --      The character % is replaced by the text for the name specified by\n+   --      the Name_Id value stored in Error_Msg_Name_1. A blank precedes\n+   --      the name if it is preceded by a non-blank character other than a\n+   --      left parenthesis. The name is enclosed in quotes unless manual\n+   --      quotation mode is set. If the Name_Id is set to No_Name, then\n+   --      no insertion occurs; if the Name_Id is set to Error_Name, then\n+   --      the string <error> is inserted. A second and third % may appear\n+   --      in a single message, similarly replaced by the names which are\n+   --      specified by the Name_Id values stored in Error_Msg_Name_2 and\n+   --      Error_Msg_Name_3. The names are decoded and cased according to\n+   --      the current identifier casing mode.\n+\n+   --    Insertion character $ (Dollar: insert unit name from Names table)\n+   --      The character $ is treated similarly to %, except that the name\n+   --      is obtained from the Unit_Name_Type value in Error_Msg_Unit_1\n+   --      and Error_Msg_Unit_2, as provided by Get_Unit_Name_String in\n+   --      package Uname. Note that this name includes the postfix (spec)\n+   --      or (body) strings. If this postfix is not required, use the\n+   --      normal % insertion for the unit name.\n+\n+   --    Insertion character { (Left brace: insert literally from names table)\n+   --      The character { is treated similarly to %, except that the\n+   --      name is output literally as stored in the names table without\n+   --      adjusting the casing. This can be used for file names and in\n+   --      other situations where the name string is to be output unchanged.\n+\n+   --    Insertion character * (Asterisk, insert reserved word name)\n+   --      The insertion character * is treated exactly like % except that\n+   --      the resulting name is cased according to the default conventions\n+   --      for reserved words (see package Scans).\n+\n+   --    Insertion character & (Ampersand: insert name from node)\n+   --      The insertion character & is treated similarly to %, except that\n+   --      the name is taken from the Chars field of the given node, and may\n+   --      refer to a child unit name, or a selected component. The casing\n+   --      is, if possible, taken from the original source reference, which\n+   --      is obtained from the Sloc field of the given node or nodes. If no\n+   --      Sloc is available (happens e.g. for nodes in package Standard),\n+   --      then the default case (see Scans spec) is used. The nodes to be\n+   --      used are stored in Error_Msg_Node_1, Error_Msg_Node_2. No insertion\n+   --      occurs for the Empty node, and the Error node results in the\n+   --      insertion of the characters <error>. In addition, if the special\n+   --      global variable Error_Msg_Qual_Level is non-zero, then the\n+   --      reference will include up to the given number of levels of\n+   --      qualification, using the scope chain.\n+\n+   --    Insertion character # (Pound: insert line number reference)\n+   --      The character # is replaced by the string indicating the source\n+   --      position stored in Error_Msg_Sloc. There are three cases:\n+   --\n+   --        for package Standard:           in package Standard\n+   --        for locations in current file:  at line nnn:ccc\n+   --        for locations in other files:   at filename:nnn:ccc\n+   --\n+   --      By convention, the # insertion character is only used at the end\n+   --      of an error message, so the above strings only appear as the last\n+   --      characters of an error message.\n+\n+   --    Insertion character } (Right brace: insert type reference)\n+   --      The character } is replaced by a string describing the type\n+   --      referenced by the entity whose Id is stored in Error_Msg_Node_1.\n+   --      the string gives the name or description of the type, and also\n+   --      where appropriate the location of its declaration. Special\n+   --      cases like \"some integer type\" are handled appropriately. Only\n+   --      one } is allowed in a message, since there is not enough room\n+   --      for two (the insertion can be quite long, including a file name)\n+   --      In addition, if the special global variable Error_Msg_Qual_Level\n+   --      is non-zero, then the reference will include up to the given\n+   --      number of levels of qualification, using the scope chain.\n+\n+   --    Insertion character @ (At: insert column number reference)\n+   --      The character @ is replaced by null if the RM_Column_Check mode is\n+   --      off (False). If the switch is on (True), then @ is replaced by the\n+   --      text string \" in column nnn\" where nnn is the decimal representation\n+   --      of the column number stored in Error_Msg_Col plus one (the plus one\n+   --      is because the number is stored 0-origin and displayed 1-origin).\n+\n+   --    Insertion character ^ (Carret: insert integer value)\n+   --      The character ^ is replaced by the decimal conversion of the Uint\n+   --      value stored in Error_Msg_Uint_1, with a possible leading minus.\n+   --      A second ^ may occur in the message, in which case it is replaced\n+   --      by the decimal conversion of the Uint value in Error_Msg_Uint_2.\n+\n+   --    Insertion character ! (Exclamation: unconditional message)\n+   --      The character ! appearing as the last character of a message makes\n+   --      the message unconditional which means that it is output even if it\n+   --      would normally be suppressed. See section above for a description\n+   --      of the cases in which messages are normally suppressed.\n+\n+   --    Insertion character ? (Question: warning message)\n+   --      The character ? appearing anywhere in a message makes the message\n+   --      a warning instead of a normal error message, and the text of the\n+   --      message will be preceded by \"Warning:\" instead of \"Error:\" The\n+   --      handling of warnings if further controlled by the Warning_Mode\n+   --      option (-w switch), see package Opt for further details, and\n+   --      also by the current setting from pragma Warnings. This pragma\n+   --      applies only to warnings issued from the semantic phase (not\n+   --      the parser), but currently all relevant warnings are posted\n+   --      by the semantic phase anyway. Messages starting with (style)\n+   --      are also treated as warning messages.\n+\n+   --    Insertion character A-Z (Upper case letter: Ada reserved word)\n+   --      If two or more upper case letters appear in the message, they are\n+   --      taken as an Ada reserved word, and are converted to the default\n+   --      case for reserved words (see Scans package spec). Surrounding\n+   --      quotes are added unless manual quotation mode is currently set.\n+\n+   --    Insertion character ` (Backquote: set manual quotation mode)\n+   --      The backquote character always appears in pairs. Each backquote\n+   --      of the pair is replaced by a double quote character. In addition,\n+   --      Any reserved keywords, or name insertions between these backquotes\n+   --      are not surrounded by the usual automatic double quotes. See the\n+   --      section below on manual quotation mode for further details.\n+\n+   --    Insertion character ' (Quote: literal character)\n+   --      Precedes a character which is placed literally into the message.\n+   --      Used to insert characters into messages that are one of the\n+   --      insertion characters defined here.\n+\n+   --    Insertion character \\ (Backslash: continuation message)\n+   --      Indicates that the message is a continuation of a message\n+   --      previously posted. This is used to ensure that such groups\n+   --      of messages are treated as a unit. The \\ character must be\n+   --      the first character of the message text.\n+\n+   -----------------------------------------------------\n+   -- Global Values Used for Error Message Insertions --\n+   -----------------------------------------------------\n+\n+   --  The following global variables are essentially additional parameters\n+   --  passed to the error message routine for insertion sequences described\n+   --  above. The reason these are passed globally is that the insertion\n+   --  mechanism is essentially an untyped one in which the appropriate\n+   --  variables are set dependingon the specific insertion characters used.\n+\n+   Error_Msg_Col : Column_Number;\n+   --  Column for @ insertion character in message\n+\n+   Error_Msg_Uint_1 : Uint;\n+   Error_Msg_Uint_2 : Uint;\n+   --  Uint values for ^ insertion characters in message\n+\n+   Error_Msg_Sloc : Source_Ptr;\n+   --  Source location for # insertion character in message\n+\n+   Error_Msg_Name_1 : Name_Id;\n+   Error_Msg_Name_2 : Name_Id;\n+   Error_Msg_Name_3 : Name_Id;\n+   --  Name_Id values for % insertion characters in message\n+\n+   Error_Msg_Unit_1 : Name_Id;\n+   Error_Msg_Unit_2 : Name_Id;\n+   --  Name_Id values for $ insertion characters in message\n+\n+   Error_Msg_Node_1 : Node_Id;\n+   Error_Msg_Node_2 : Node_Id;\n+   --  Node_Id values for & insertion characters in message\n+\n+   Error_Msg_Qual_Level : Int := 0;\n+   --  Number of levels of qualification required for type name (see the\n+   --  description of the } insertion character. Note that this value does\n+   --  note get reset by any Error_Msg call, so the caller is responsible\n+   --  for resetting it.\n+\n+   Warn_On_Instance : Boolean := False;\n+   --  Normally if a warning is generated in a generic template from the\n+   --  analysis of the template, then the warning really belongs in the\n+   --  template, and the default value of False for this Boolean achieves\n+   --  that effect. If Warn_On_Instance is set True, then the warnings are\n+   --  generated on the instantiation (referring to the template) rather\n+   --  than on the template itself.\n+\n+   -----------------------------------------------------\n+   -- Format of Messages and Manual Quotation Control --\n+   -----------------------------------------------------\n+\n+   --  Messages are generally all in lower case, except for inserted names\n+   --  and appear in one of the following three forms:\n+\n+   --    error: text\n+   --    warning: text\n+\n+   --  The prefixes error and warning are supplied automatically (depending\n+   --  on the use of the ? insertion character), and the call to the error\n+   --  message routine supplies the text. The \"error: \" prefix is omitted\n+   --  in brief error message formats.\n+\n+   --  Reserved Ada keywords in the message are in the default keyword case\n+   --  (determined from the given source program), surrounded by quotation\n+   --  marks. This is achieved by spelling the reserved word in upper case\n+   --  letters, which is recognized as a request for insertion of quotation\n+   --  marks by the error text processor. Thus for example:\n+\n+   --    Error_Msg_AP (\"IS expected\");\n+\n+   --  would result in the output of one of the following:\n+\n+   --    error: \"is\" expected\n+   --    error: \"IS\" expected\n+   --    error: \"Is\" expected\n+\n+   --  the choice between these being made by looking at the casing convention\n+   --  used for keywords (actually the first compilation unit keyword) in the\n+   --  source file.\n+\n+   --  In the case of names, the default mode for the error text processor\n+   --  is to surround the name by quotation marks automatically. The case\n+   --  used for the identifier names is taken from the source program where\n+   --  possible, and otherwise is the default casing convention taken from\n+   --  the source file usage.\n+\n+   --  In some cases, better control over the placement of quote marks is\n+   --  required. This is achieved using manual quotation mode. In this mode,\n+   --  one or more insertion sequences is surrounded by backquote characters.\n+   --  The backquote characters are output as double quote marks, and normal\n+   --  automatic insertion of quotes is suppressed between the double quotes.\n+   --  For example:\n+\n+   --    Error_Msg_AP (\"`END &;` expected\");\n+\n+   --  generates a message like\n+\n+   --    error: \"end Open_Scope;\" expected\n+\n+   --  where the node specifying the name Open_Scope has been stored in\n+   --  Error_Msg_Node_1 prior to the call. The great majority of error\n+   --  messages operates in normal quotation mode.\n+\n+   --  Note: the normal automatic insertion of spaces before insertion\n+   --  sequences (such as those that come from & and %) is suppressed in\n+   --  manual quotation mode, so blanks, if needed as in the above example,\n+   --  must be explicitly present.\n+\n+   ----------------------------\n+   -- Message ID Definitions --\n+   ----------------------------\n+\n+   type Error_Msg_Id is new Int;\n+   --  A type used to represent specific error messages. Used by the clients\n+   --  of this package only in the context of the Get_Error_Id and\n+   --  Change_Error_Text subprograms.\n+\n+   No_Error_Msg : constant Error_Msg_Id := 0;\n+   --  A constant which is different from any value returned by Get_Error_Id.\n+   --  Typically used by a client to indicate absense of a saved Id value.\n+\n+   function Get_Msg_Id return Error_Msg_Id;\n+   --  Returns the Id of the message most recently posted using one of the\n+   --  Error_Msg routines.\n+\n+   function Get_Location (E : Error_Msg_Id) return Source_Ptr;\n+   --  Returns the flag location of the error message with the given id E.\n+\n+   ------------------------\n+   -- List Pragmas Table --\n+   ------------------------\n+\n+   --  When a pragma Page or pragma List is encountered by the parser, an\n+   --  entry is made in the following table. This table is then used to\n+   --  control the full listing if one is being generated. Note that the\n+   --  reason we do the processing in the parser is so that we get proper\n+   --  listing control even in syntax check only mode.\n+\n+   type List_Pragma_Type is (List_On, List_Off, Page);\n+\n+   type List_Pragma_Record is record\n+      Ptyp : List_Pragma_Type;\n+      Ploc : Source_Ptr;\n+   end record;\n+\n+   --  Note: Ploc points to the terminating semicolon in the List_Off and\n+   --  Page cases, and to the pragma keyword for List_On. In the case of\n+   --  a pragma List_Off, a List_On entry is also made in the table,\n+   --  pointing to the pragma keyword. This ensures that, as required,\n+   --  a List (Off) pragma is listed even in list off mode.\n+\n+   package List_Pragmas is new Table.Table (\n+     Table_Component_Type => List_Pragma_Record,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 50,\n+     Table_Increment      => 200,\n+     Table_Name           => \"List_Pragmas\");\n+\n+   ---------------------------\n+   -- Ignore_Errors Feature --\n+   ---------------------------\n+\n+   --  In certain cases, notably for optional subunits, the compiler operates\n+   --  in a mode where errors are to be ignored, and the whole unit is to be\n+   --  considered as not present. To implement this we provide the following\n+   --  flag to enable special handling, where error messages are suppressed,\n+   --  but the Fatal_Error flag will still be set in the normal manner.\n+\n+   Ignore_Errors_Enable : Nat := 0;\n+   --  Triggering switch. If non-zero, then ignore errors mode is activated.\n+   --  This is a counter to allow convenient nesting of enable/disable.\n+\n+   ------------------------------\n+   -- Error Output Subprograms --\n+   ------------------------------\n+\n+   procedure Initialize;\n+   --  Initializes for output of error messages. Must be called for each\n+   --  source file before using any of the other routines in the package.\n+\n+   procedure Finalize;\n+   --  Finalize processing of error messages for one file and output message\n+   --  indicating the number of detected errors.\n+\n+   procedure Error_Msg (Msg : String; Flag_Location : Source_Ptr);\n+   --  Output a message at specified location. Can be called from the parser\n+   --  or the semantic analyzer.\n+\n+   procedure Error_Msg_S (Msg : String);\n+   --  Output a message at current scan pointer location. This routine can be\n+   --  called only from the parser, since it references Scan_Ptr.\n+\n+   procedure Error_Msg_AP (Msg : String);\n+   --  Output a message just after the previous token. This routine can be\n+   --  called only from the parser, since it references Prev_Token_Ptr.\n+\n+   procedure Error_Msg_BC (Msg : String);\n+   --  Output a message just before the current token. Note that the important\n+   --  difference between this and the previous routine is that the BC case\n+   --  posts a flag on the current line, whereas AP can post a flag at the\n+   --  end of the preceding line. This routine can be called only from the\n+   --  parser, since it references Token_Ptr.\n+\n+   procedure Error_Msg_SC (Msg : String);\n+   --  Output a message at the start of the current token, unless we are at\n+   --  the end of file, in which case we always output the message after the\n+   --  last real token in the file. This routine can be called only from the\n+   --  parser, since it references Token_Ptr.\n+\n+   procedure Error_Msg_SP (Msg : String);\n+   --  Output a message at the start of the previous token. This routine can\n+   --  be called only from the parser, since it references Prev_Token_Ptr.\n+\n+   procedure Error_Msg_N (Msg : String; N : Node_Or_Entity_Id);\n+   --  Output a message at the Sloc of the given node. This routine can be\n+   --  called from the parser or the semantic analyzer, although the call\n+   --  from the latter is much more common (and is the most usual way of\n+   --  generating error messages from the analyzer). The message text may\n+   --  contain a single & insertion, which will reference the given node.\n+\n+   procedure Error_Msg_NE\n+     (Msg : String;\n+      N   : Node_Or_Entity_Id;\n+      E   : Node_Or_Entity_Id);\n+   --  Output a message at the Sloc of the given node, with an insertion of\n+   --  the name from the given entity node. This is used by the semantic\n+   --  routines, where this is a common error message situation. The Msg\n+   --  text will contain a & or } as usual to mark the insertion point.\n+   --  This routine can be called from the parser or the analyzer.\n+\n+   procedure Change_Error_Text (Error_Id : Error_Msg_Id; New_Msg : String);\n+   --  The error message text of the message identified by Id is replaced by\n+   --  the given text. This text may contain insertion characters in the\n+   --  usual manner, and need not be the same length as the original text.\n+\n+   procedure Purge_Messages (From : Source_Ptr; To : Source_Ptr);\n+   --  All error messages whose location is in the range From .. To (not\n+   --  including the end points) will be deleted from the error listing.\n+\n+   procedure Remove_Warning_Messages (N : Node_Id);\n+   --  Remove any warning messages corresponding to the Sloc of N or any\n+   --  of its descendent nodes. No effect if no such warnings.\n+\n+   procedure Set_Warnings_Mode_Off (Loc : Source_Ptr);\n+   --  Called in response to a pragma Warnings (Off) to record the source\n+   --  location from which warnings are to be turned off.\n+\n+   procedure Set_Warnings_Mode_On (Loc : Source_Ptr);\n+   --  Called in response to a pragma Warnings (On) to record the source\n+   --  location from which warnings are to be turned back on.\n+\n+   function Compilation_Errors return Boolean;\n+   --  Returns true if errors have been detected, or warnings in -gnatwe\n+   --  (treat warnings as errors) mode.\n+\n+   procedure dmsg (Id : Error_Msg_Id);\n+   --  Debugging routine to dump an error message\n+\n+end Errout;"}, {"sha": "99f5a9f6a196bfd856d1289b263e2c1a25de6d43", "filename": "gcc/ada/eval_fat.adb", "status": "added", "additions": 935, "deletions": 0, "changes": 935, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,935 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E V A L _ F A T                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.33 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Einfo;    use Einfo;\n+with Sem_Util; use Sem_Util;\n+with Ttypef;   use Ttypef;\n+with Targparm; use Targparm;\n+\n+package body Eval_Fat is\n+\n+   Radix : constant Int := 2;\n+   --  This code is currently only correct for the radix 2 case. We use\n+   --  the symbolic value Radix where possible to help in the unlikely\n+   --  case of anyone ever having to adjust this code for another value,\n+   --  and for documentation purposes.\n+\n+   type Radix_Power_Table is array (Int range 1 .. 4) of Int;\n+\n+   Radix_Powers : constant Radix_Power_Table\n+     := (Radix**1, Radix**2, Radix**3, Radix**4);\n+\n+   function Float_Radix return T renames Ureal_2;\n+   --  Radix expressed in real form\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Decompose\n+     (RT       : R;\n+      X        : in T;\n+      Fraction : out T;\n+      Exponent : out UI;\n+      Mode     : Rounding_Mode := Round);\n+   --  Decomposes a non-zero floating-point number into fraction and\n+   --  exponent parts. The fraction is in the interval 1.0 / Radix ..\n+   --  T'Pred (1.0) and uses Rbase = Radix.\n+   --  The result is rounded to a nearest machine number.\n+\n+   procedure Decompose_Int\n+     (RT               : R;\n+      X                : in T;\n+      Fraction         : out UI;\n+      Exponent         : out UI;\n+      Mode             : Rounding_Mode);\n+   --  This is similar to Decompose, except that the Fraction value returned\n+   --  is an integer representing the value Fraction * Scale, where Scale is\n+   --  the value (Radix ** Machine_Mantissa (RT)). The value is obtained by\n+   --  using biased rounding (halfway cases round away from zero), round to\n+   --  even, a floor operation or a ceiling operation depending on the setting\n+   --  of Mode (see corresponding descriptions in Urealp).\n+   --  In case rounding was specified, Rounding_Was_Biased is set True\n+   --  if the input was indeed halfway between to machine numbers and\n+   --  got rounded away from zero to an odd number.\n+\n+   function Eps_Model (RT : R) return T;\n+   --  Return the smallest model number of R.\n+\n+   function Eps_Denorm (RT : R) return T;\n+   --  Return the smallest denormal of type R.\n+\n+   function Machine_Mantissa (RT : R) return Nat;\n+   --  Get value of machine mantissa\n+\n+   --------------\n+   -- Adjacent --\n+   --------------\n+\n+   function Adjacent (RT : R; X, Towards : T) return T is\n+   begin\n+      if Towards = X then\n+         return X;\n+\n+      elsif Towards > X then\n+         return Succ (RT, X);\n+\n+      else\n+         return Pred (RT, X);\n+      end if;\n+   end Adjacent;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (RT : R; X : T) return T is\n+      XT : constant T := Truncation (RT, X);\n+\n+   begin\n+      if UR_Is_Negative (X) then\n+         return XT;\n+\n+      elsif X = XT then\n+         return X;\n+\n+      else\n+         return XT + Ureal_1;\n+      end if;\n+   end Ceiling;\n+\n+   -------------\n+   -- Compose --\n+   -------------\n+\n+   function Compose (RT : R; Fraction : T; Exponent : UI) return T is\n+      Arg_Frac : T;\n+      Arg_Exp  : UI;\n+\n+   begin\n+      if UR_Is_Zero (Fraction) then\n+         return Fraction;\n+      else\n+         Decompose (RT, Fraction, Arg_Frac, Arg_Exp);\n+         return Scaling (RT, Arg_Frac, Exponent);\n+      end if;\n+   end Compose;\n+\n+   ---------------\n+   -- Copy_Sign --\n+   ---------------\n+\n+   function Copy_Sign (RT : R; Value, Sign : T) return T is\n+      Result : T;\n+\n+   begin\n+      Result := abs Value;\n+\n+      if UR_Is_Negative (Sign) then\n+         return -Result;\n+      else\n+         return Result;\n+      end if;\n+   end Copy_Sign;\n+\n+   ---------------\n+   -- Decompose --\n+   ---------------\n+\n+   procedure Decompose\n+     (RT       : R;\n+      X        : in T;\n+      Fraction : out T;\n+      Exponent : out UI;\n+      Mode     : Rounding_Mode := Round)\n+   is\n+      Int_F : UI;\n+\n+   begin\n+      Decompose_Int (RT, abs X, Int_F, Exponent, Mode);\n+\n+      Fraction := UR_From_Components\n+       (Num      => Int_F,\n+        Den      => UI_From_Int (Machine_Mantissa (RT)),\n+        Rbase    => Radix,\n+        Negative => False);\n+\n+      if UR_Is_Negative (X) then\n+         Fraction := -Fraction;\n+      end if;\n+\n+      return;\n+   end Decompose;\n+\n+   -------------------\n+   -- Decompose_Int --\n+   -------------------\n+\n+   --  This procedure should be modified with care, as there\n+   --  are many non-obvious details that may cause problems\n+   --  that are hard to detect. The cases of positive and\n+   --  negative zeroes are also special and should be\n+   --  verified separately.\n+\n+   procedure Decompose_Int\n+     (RT               : R;\n+      X                : in T;\n+      Fraction         : out UI;\n+      Exponent         : out UI;\n+      Mode             : Rounding_Mode)\n+   is\n+      Base : Int := Rbase (X);\n+      N    : UI  := abs Numerator (X);\n+      D    : UI  := Denominator (X);\n+\n+      N_Times_Radix : UI;\n+\n+      Even : Boolean;\n+      --  True iff Fraction is even\n+\n+      Most_Significant_Digit : constant UI :=\n+                                 Radix ** (Machine_Mantissa (RT) - 1);\n+\n+      Uintp_Mark : Uintp.Save_Mark;\n+      --  The code is divided into blocks that systematically release\n+      --  intermediate values (this routine generates lots of junk!)\n+\n+   begin\n+      Calculate_D_And_Exponent_1 : begin\n+         Uintp_Mark := Mark;\n+         Exponent := Uint_0;\n+\n+         --  In cases where Base > 1, the actual denominator is\n+         --  Base**D. For cases where Base is a power of Radix, use\n+         --  the value 1 for the Denominator and adjust the exponent.\n+\n+         --  Note: Exponent has different sign from D, because D is a divisor\n+\n+         for Power in 1 .. Radix_Powers'Last loop\n+            if Base = Radix_Powers (Power) then\n+               Exponent := -D * Power;\n+               Base := 0;\n+               D := Uint_1;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         Release_And_Save (Uintp_Mark, D, Exponent);\n+      end Calculate_D_And_Exponent_1;\n+\n+      if Base > 0 then\n+         Calculate_Exponent : begin\n+            Uintp_Mark := Mark;\n+\n+            --  For bases that are a multiple of the Radix, divide\n+            --  the base by Radix and adjust the Exponent. This will\n+            --  help because D will be much smaller and faster to process.\n+\n+            --  This occurs for decimal bases on a machine with binary\n+            --  floating-point for example. When calculating 1E40,\n+            --  with Radix = 2, N will be 93 bits instead of 133.\n+\n+            --        N            E\n+            --      ------  * Radix\n+            --           D\n+            --       Base\n+\n+            --                  N                        E\n+            --    =  --------------------------  *  Radix\n+            --                     D        D\n+            --         (Base/Radix)  * Radix\n+\n+            --             N                  E-D\n+            --    =  ---------------  *  Radix\n+            --                    D\n+            --        (Base/Radix)\n+\n+            --  This code is commented out, because it causes numerous\n+            --  failures in the regression suite. To be studied ???\n+\n+            while False and then Base > 0 and then Base mod Radix = 0 loop\n+               Base := Base / Radix;\n+               Exponent := Exponent + D;\n+            end loop;\n+\n+            Release_And_Save (Uintp_Mark, Exponent);\n+         end Calculate_Exponent;\n+\n+         --  For remaining bases we must actually compute\n+         --  the exponentiation.\n+\n+         --  Because the exponentiation can be negative, and D must\n+         --  be integer, the numerator is corrected instead.\n+\n+         Calculate_N_And_D : begin\n+            Uintp_Mark := Mark;\n+\n+            if D < 0 then\n+               N := N * Base ** (-D);\n+               D := Uint_1;\n+            else\n+               D := Base ** D;\n+            end if;\n+\n+            Release_And_Save (Uintp_Mark, N, D);\n+         end Calculate_N_And_D;\n+\n+         Base := 0;\n+      end if;\n+\n+      --  Now scale N and D so that N / D is a value in the\n+      --  interval [1.0 / Radix, 1.0) and adjust Exponent accordingly,\n+      --  so the value N / D * Radix ** Exponent remains unchanged.\n+\n+      --  Step 1 - Adjust N so N / D >= 1 / Radix, or N = 0\n+\n+      --  N and D are positive, so N / D >= 1 / Radix implies N * Radix >= D.\n+      --  This scaling is not possible for N is Uint_0 as there\n+      --  is no way to scale Uint_0 so the first digit is non-zero.\n+\n+      Calculate_N_And_Exponent : begin\n+         Uintp_Mark := Mark;\n+\n+         N_Times_Radix := N * Radix;\n+\n+         if N /= Uint_0 then\n+            while not (N_Times_Radix >= D) loop\n+               N := N_Times_Radix;\n+               Exponent := Exponent - 1;\n+\n+               N_Times_Radix := N * Radix;\n+            end loop;\n+         end if;\n+\n+         Release_And_Save (Uintp_Mark, N, Exponent);\n+      end Calculate_N_And_Exponent;\n+\n+      --  Step 2 - Adjust D so N / D < 1\n+\n+      --  Scale up D so N / D < 1, so N < D\n+\n+      Calculate_D_And_Exponent_2 : begin\n+         Uintp_Mark := Mark;\n+\n+         while not (N < D) loop\n+\n+            --  As N / D >= 1, N / (D * Radix) will be at least 1 / Radix,\n+            --  so the result of Step 1 stays valid\n+\n+            D := D * Radix;\n+            Exponent := Exponent + 1;\n+         end loop;\n+\n+         Release_And_Save (Uintp_Mark, D, Exponent);\n+      end Calculate_D_And_Exponent_2;\n+\n+      --  Here the value N / D is in the range [1.0 / Radix .. 1.0)\n+\n+      --  Now find the fraction by doing a very simple-minded\n+      --  division until enough digits have been computed.\n+\n+      --  This division works for all radices, but is only efficient for\n+      --  a binary radix. It is just like a manual division algorithm,\n+      --  but instead of moving the denominator one digit right, we move\n+      --  the numerator one digit left so the numerator and denominator\n+      --  remain integral.\n+\n+      Fraction := Uint_0;\n+      Even := True;\n+\n+      Calculate_Fraction_And_N : begin\n+         Uintp_Mark := Mark;\n+\n+         loop\n+            while N >= D loop\n+               N := N - D;\n+               Fraction := Fraction + 1;\n+               Even := not Even;\n+            end loop;\n+\n+            --  Stop when the result is in [1.0 / Radix, 1.0)\n+\n+            exit when Fraction >= Most_Significant_Digit;\n+\n+            N := N * Radix;\n+            Fraction := Fraction * Radix;\n+            Even := True;\n+         end loop;\n+\n+         Release_And_Save (Uintp_Mark, Fraction, N);\n+      end Calculate_Fraction_And_N;\n+\n+      Calculate_Fraction_And_Exponent : begin\n+         Uintp_Mark := Mark;\n+\n+         --  Put back sign before applying the rounding.\n+\n+         if UR_Is_Negative (X) then\n+            Fraction := -Fraction;\n+         end if;\n+\n+         --  Determine correct rounding based on the remainder\n+         --  which is in N and the divisor D.\n+\n+         Rounding_Was_Biased := False; -- Until proven otherwise\n+\n+         case Mode is\n+            when Round_Even =>\n+\n+               --  This rounding mode should not be used for static\n+               --  expressions, but only for compile-time evaluation\n+               --  of non-static expressions.\n+\n+               if (Even and then N * 2 > D)\n+                     or else\n+                  (not Even and then N * 2 >= D)\n+               then\n+                  Fraction := Fraction + 1;\n+               end if;\n+\n+            when Round   =>\n+\n+               --  Do not round to even as is done with IEEE arithmetic,\n+               --  but instead round away from zero when the result is\n+               --  exactly between two machine numbers. See RM 4.9(38).\n+\n+               if N * 2 >= D then\n+                  Fraction := Fraction + 1;\n+\n+                  Rounding_Was_Biased := Even and then N * 2 = D;\n+                  --  Check for the case where the result is actually\n+                  --  different from Round_Even.\n+               end if;\n+\n+            when Ceiling =>\n+               if N > Uint_0 then\n+                  Fraction := Fraction + 1;\n+               end if;\n+\n+            when Floor   => null;\n+         end case;\n+\n+         --  The result must be normalized to [1.0/Radix, 1.0),\n+         --  so adjust if the result is 1.0 because of rounding.\n+\n+         if Fraction = Most_Significant_Digit * Radix then\n+            Fraction := Most_Significant_Digit;\n+            Exponent := Exponent + 1;\n+         end if;\n+\n+         Release_And_Save (Uintp_Mark, Fraction, Exponent);\n+      end Calculate_Fraction_And_Exponent;\n+\n+   end Decompose_Int;\n+\n+   ----------------\n+   -- Eps_Denorm --\n+   ----------------\n+\n+   function Eps_Denorm (RT : R) return T is\n+      Digs : constant UI := Digits_Value (RT);\n+      Emin : Int;\n+      Mant : Int;\n+\n+   begin\n+      if Vax_Float (RT) then\n+         if Digs = VAXFF_Digits then\n+            Emin := VAXFF_Machine_Emin;\n+            Mant := VAXFF_Machine_Mantissa;\n+\n+         elsif Digs = VAXDF_Digits then\n+            Emin := VAXDF_Machine_Emin;\n+            Mant := VAXDF_Machine_Mantissa;\n+\n+         else\n+            pragma Assert (Digs = VAXGF_Digits);\n+            Emin := VAXGF_Machine_Emin;\n+            Mant := VAXGF_Machine_Mantissa;\n+         end if;\n+\n+      elsif Is_AAMP_Float (RT) then\n+         if Digs = AAMPS_Digits then\n+            Emin := AAMPS_Machine_Emin;\n+            Mant := AAMPS_Machine_Mantissa;\n+\n+         else\n+            pragma Assert (Digs = AAMPL_Digits);\n+            Emin := AAMPL_Machine_Emin;\n+            Mant := AAMPL_Machine_Mantissa;\n+         end if;\n+\n+      else\n+         if Digs = IEEES_Digits then\n+            Emin := IEEES_Machine_Emin;\n+            Mant := IEEES_Machine_Mantissa;\n+\n+         elsif Digs = IEEEL_Digits then\n+            Emin := IEEEL_Machine_Emin;\n+            Mant := IEEEL_Machine_Mantissa;\n+\n+         else\n+            pragma Assert (Digs = IEEEX_Digits);\n+            Emin := IEEEX_Machine_Emin;\n+            Mant := IEEEX_Machine_Mantissa;\n+         end if;\n+      end if;\n+\n+      return Float_Radix ** UI_From_Int (Emin - Mant);\n+   end Eps_Denorm;\n+\n+   ---------------\n+   -- Eps_Model --\n+   ---------------\n+\n+   function Eps_Model (RT : R) return T is\n+      Digs : constant UI := Digits_Value (RT);\n+      Emin : Int;\n+\n+   begin\n+      if Vax_Float (RT) then\n+         if Digs = VAXFF_Digits then\n+            Emin := VAXFF_Machine_Emin;\n+\n+         elsif Digs = VAXDF_Digits then\n+            Emin := VAXDF_Machine_Emin;\n+\n+         else\n+            pragma Assert (Digs = VAXGF_Digits);\n+            Emin := VAXGF_Machine_Emin;\n+         end if;\n+\n+      elsif Is_AAMP_Float (RT) then\n+         if Digs = AAMPS_Digits then\n+            Emin := AAMPS_Machine_Emin;\n+\n+         else\n+            pragma Assert (Digs = AAMPL_Digits);\n+            Emin := AAMPL_Machine_Emin;\n+         end if;\n+\n+      else\n+         if Digs = IEEES_Digits then\n+            Emin := IEEES_Machine_Emin;\n+\n+         elsif Digs = IEEEL_Digits then\n+            Emin := IEEEL_Machine_Emin;\n+\n+         else\n+            pragma Assert (Digs = IEEEX_Digits);\n+            Emin := IEEEX_Machine_Emin;\n+         end if;\n+      end if;\n+\n+      return Float_Radix ** UI_From_Int (Emin);\n+   end Eps_Model;\n+\n+   --------------\n+   -- Exponent --\n+   --------------\n+\n+   function Exponent (RT : R; X : T) return UI is\n+      X_Frac : UI;\n+      X_Exp  : UI;\n+\n+   begin\n+      if UR_Is_Zero (X) then\n+         return Uint_0;\n+      else\n+         Decompose_Int (RT, X, X_Frac, X_Exp, Round_Even);\n+         return X_Exp;\n+      end if;\n+   end Exponent;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (RT : R; X : T) return T is\n+      XT : constant T := Truncation (RT, X);\n+\n+   begin\n+      if UR_Is_Positive (X) then\n+         return XT;\n+\n+      elsif XT = X then\n+         return X;\n+\n+      else\n+         return XT - Ureal_1;\n+      end if;\n+   end Floor;\n+\n+   --------------\n+   -- Fraction --\n+   --------------\n+\n+   function Fraction (RT : R; X : T) return T is\n+      X_Frac : T;\n+      X_Exp  : UI;\n+\n+   begin\n+      if UR_Is_Zero (X) then\n+         return X;\n+      else\n+         Decompose (RT, X, X_Frac, X_Exp);\n+         return X_Frac;\n+      end if;\n+   end Fraction;\n+\n+   ------------------\n+   -- Leading_Part --\n+   ------------------\n+\n+   function Leading_Part (RT : R; X : T; Radix_Digits : UI) return T is\n+      L    : UI;\n+      Y, Z : T;\n+\n+   begin\n+      if Radix_Digits >= Machine_Mantissa (RT) then\n+         return X;\n+\n+      else\n+         L := Exponent (RT, X) - Radix_Digits;\n+         Y := Truncation (RT, Scaling (RT, X, -L));\n+         Z := Scaling (RT, Y, L);\n+         return Z;\n+      end if;\n+\n+   end Leading_Part;\n+\n+   -------------\n+   -- Machine --\n+   -------------\n+\n+   function Machine (RT : R; X : T; Mode : Rounding_Mode) return T is\n+      X_Frac : T;\n+      X_Exp  : UI;\n+\n+   begin\n+      if UR_Is_Zero (X) then\n+         return X;\n+      else\n+         Decompose (RT, X, X_Frac, X_Exp, Mode);\n+         return Scaling (RT, X_Frac, X_Exp);\n+      end if;\n+   end Machine;\n+\n+   ----------------------\n+   -- Machine_Mantissa --\n+   ----------------------\n+\n+   function Machine_Mantissa (RT : R) return Nat is\n+      Digs : constant UI := Digits_Value (RT);\n+      Mant : Nat;\n+\n+   begin\n+      if Vax_Float (RT) then\n+         if Digs = VAXFF_Digits then\n+            Mant := VAXFF_Machine_Mantissa;\n+\n+         elsif Digs = VAXDF_Digits then\n+            Mant := VAXDF_Machine_Mantissa;\n+\n+         else\n+            pragma Assert (Digs = VAXGF_Digits);\n+            Mant := VAXGF_Machine_Mantissa;\n+         end if;\n+\n+      elsif Is_AAMP_Float (RT) then\n+         if Digs = AAMPS_Digits then\n+            Mant := AAMPS_Machine_Mantissa;\n+\n+         else\n+            pragma Assert (Digs = AAMPL_Digits);\n+            Mant := AAMPL_Machine_Mantissa;\n+         end if;\n+\n+      else\n+         if Digs = IEEES_Digits then\n+            Mant := IEEES_Machine_Mantissa;\n+\n+         elsif Digs = IEEEL_Digits then\n+            Mant := IEEEL_Machine_Mantissa;\n+\n+         else\n+            pragma Assert (Digs = IEEEX_Digits);\n+            Mant := IEEEX_Machine_Mantissa;\n+         end if;\n+      end if;\n+\n+      return Mant;\n+   end Machine_Mantissa;\n+\n+   -----------\n+   -- Model --\n+   -----------\n+\n+   function Model (RT : R; X : T) return T is\n+      X_Frac : T;\n+      X_Exp  : UI;\n+\n+   begin\n+      Decompose (RT, X, X_Frac, X_Exp);\n+      return Compose (RT, X_Frac, X_Exp);\n+   end Model;\n+\n+   ----------\n+   -- Pred --\n+   ----------\n+\n+   function Pred (RT : R; X : T) return T is\n+      Result_F : UI;\n+      Result_X : UI;\n+\n+   begin\n+      if abs X < Eps_Model (RT) then\n+         if Denorm_On_Target then\n+            return X - Eps_Denorm (RT);\n+\n+         elsif X > Ureal_0 then\n+            --  Target does not support denorms, so predecessor is 0.0\n+            return Ureal_0;\n+\n+         else\n+            --  Target does not support denorms, and X is 0.0\n+            --  or at least bigger than -Eps_Model (RT)\n+\n+            return -Eps_Model (RT);\n+         end if;\n+\n+      else\n+         Decompose_Int (RT, X, Result_F,  Result_X, Ceiling);\n+         return UR_From_Components\n+           (Num      => Result_F - 1,\n+            Den      => Machine_Mantissa (RT) - Result_X,\n+            Rbase    => Radix,\n+            Negative => False);\n+         --  Result_F may be false, but this is OK as UR_From_Components\n+         --  handles that situation.\n+      end if;\n+   end Pred;\n+\n+   ---------------\n+   -- Remainder --\n+   ---------------\n+\n+   function Remainder (RT : R; X, Y : T) return T is\n+      A        : T;\n+      B        : T;\n+      Arg      : T;\n+      P        : T;\n+      Arg_Frac : T;\n+      P_Frac   : T;\n+      Sign_X   : T;\n+      IEEE_Rem : T;\n+      Arg_Exp  : UI;\n+      P_Exp    : UI;\n+      K        : UI;\n+      P_Even   : Boolean;\n+\n+   begin\n+      if UR_Is_Positive (X) then\n+         Sign_X :=  Ureal_1;\n+      else\n+         Sign_X := -Ureal_1;\n+      end if;\n+\n+      Arg := abs X;\n+      P   := abs Y;\n+\n+      if Arg < P then\n+         P_Even := True;\n+         IEEE_Rem := Arg;\n+         P_Exp := Exponent (RT, P);\n+\n+      else\n+         --  ??? what about zero cases?\n+         Decompose (RT, Arg, Arg_Frac, Arg_Exp);\n+         Decompose (RT, P,   P_Frac,   P_Exp);\n+\n+         P := Compose (RT, P_Frac, Arg_Exp);\n+         K := Arg_Exp - P_Exp;\n+         P_Even := True;\n+         IEEE_Rem := Arg;\n+\n+         for Cnt in reverse 0 .. UI_To_Int (K) loop\n+            if IEEE_Rem >= P then\n+               P_Even := False;\n+               IEEE_Rem := IEEE_Rem - P;\n+            else\n+               P_Even := True;\n+            end if;\n+\n+            P := P * Ureal_Half;\n+         end loop;\n+      end if;\n+\n+      --  That completes the calculation of modulus remainder. The final step\n+      --  is get the IEEE remainder. Here we compare Rem with (abs Y) / 2.\n+\n+      if P_Exp >= 0 then\n+         A := IEEE_Rem;\n+         B := abs Y * Ureal_Half;\n+\n+      else\n+         A := IEEE_Rem * Ureal_2;\n+         B := abs Y;\n+      end if;\n+\n+      if A > B or else (A = B and then not P_Even) then\n+         IEEE_Rem := IEEE_Rem - abs Y;\n+      end if;\n+\n+      return Sign_X * IEEE_Rem;\n+\n+   end Remainder;\n+\n+   --------------\n+   -- Rounding --\n+   --------------\n+\n+   function Rounding (RT : R; X : T) return T is\n+      Result : T;\n+      Tail   : T;\n+\n+   begin\n+      Result := Truncation (RT, abs X);\n+      Tail   := abs X - Result;\n+\n+      if Tail >= Ureal_Half  then\n+         Result := Result + Ureal_1;\n+      end if;\n+\n+      if UR_Is_Negative (X) then\n+         return -Result;\n+      else\n+         return Result;\n+      end if;\n+\n+   end Rounding;\n+\n+   -------------\n+   -- Scaling --\n+   -------------\n+\n+   function Scaling (RT : R; X : T; Adjustment : UI) return T is\n+   begin\n+      if Rbase (X) = Radix then\n+         return UR_From_Components\n+           (Num      => Numerator (X),\n+            Den      => Denominator (X) - Adjustment,\n+            Rbase    => Radix,\n+            Negative => UR_Is_Negative (X));\n+\n+      elsif Adjustment >= 0 then\n+         return X * Radix ** Adjustment;\n+      else\n+         return X / Radix ** (-Adjustment);\n+      end if;\n+   end Scaling;\n+\n+   ----------\n+   -- Succ --\n+   ----------\n+\n+   function Succ (RT : R; X : T) return T is\n+      Result_F : UI;\n+      Result_X : UI;\n+\n+   begin\n+      if abs X < Eps_Model (RT) then\n+         if Denorm_On_Target then\n+            return X + Eps_Denorm (RT);\n+\n+         elsif X < Ureal_0 then\n+            --  Target does not support denorms, so successor is 0.0\n+            return Ureal_0;\n+\n+         else\n+            --  Target does not support denorms, and X is 0.0\n+            --  or at least smaller than Eps_Model (RT)\n+\n+            return Eps_Model (RT);\n+         end if;\n+\n+      else\n+         Decompose_Int (RT, X, Result_F, Result_X, Floor);\n+         return UR_From_Components\n+           (Num      => Result_F + 1,\n+            Den      => Machine_Mantissa (RT) - Result_X,\n+            Rbase    => Radix,\n+            Negative => False);\n+         --  Result_F may be false, but this is OK as UR_From_Components\n+         --  handles that situation.\n+      end if;\n+   end Succ;\n+\n+   ----------------\n+   -- Truncation --\n+   ----------------\n+\n+   function Truncation (RT : R; X : T) return T is\n+   begin\n+      return UR_From_Uint (UR_Trunc (X));\n+   end Truncation;\n+\n+   -----------------------\n+   -- Unbiased_Rounding --\n+   -----------------------\n+\n+   function Unbiased_Rounding (RT : R; X : T) return T is\n+      Abs_X  : constant T := abs X;\n+      Result : T;\n+      Tail   : T;\n+\n+   begin\n+      Result := Truncation (RT, Abs_X);\n+      Tail   := Abs_X - Result;\n+\n+      if Tail > Ureal_Half  then\n+         Result := Result + Ureal_1;\n+\n+      elsif Tail = Ureal_Half then\n+         Result := Ureal_2 *\n+                     Truncation (RT, (Result / Ureal_2) + Ureal_Half);\n+      end if;\n+\n+      if UR_Is_Negative (X) then\n+         return -Result;\n+      elsif UR_Is_Positive (X) then\n+         return Result;\n+\n+      --  For zero case, make sure sign of zero is preserved\n+\n+      else\n+         return X;\n+      end if;\n+\n+   end Unbiased_Rounding;\n+\n+end Eval_Fat;"}, {"sha": "b3e398ab208bf78c65348bc8e567bf024baa73d2", "filename": "gcc/ada/eval_fat.ads", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feval_fat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Feval_fat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,91 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E V A L _ F A T                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides for compile-time evaluation of static calls to the\n+--  floating-point attribute functions. It is the compile-time equivalent of\n+--  the System.Fat_Gen runtime package. The coding is quite similar, as are\n+--  the subprogram specs, except that the type is passed as an explicit\n+--  first parameter (and used via ttypes, to obtain the necessary information\n+--  about the characteristics of the type for computing the results.\n+\n+with Types;  use Types;\n+with Uintp;  use Uintp;\n+with Urealp; use Urealp;\n+\n+package Eval_Fat is\n+\n+   subtype UI is Uint;\n+   --  The compile time representation of universal integer\n+\n+   subtype T is Ureal;\n+   --  The compile time representation of floating-point values\n+\n+   subtype R is Entity_Id;\n+   --  The compile time representation of the floating-point root type\n+\n+   type Rounding_Mode is (Floor, Ceiling, Round, Round_Even);\n+   --  Used to indicate rounding mode for Machine attribute\n+\n+   Rounding_Was_Biased : Boolean;\n+   --  Set if last use of Machine rounded a halfway case away from zero\n+\n+   function Adjacent          (RT : R; X, Towards : T)              return T;\n+\n+   function Ceiling           (RT : R; X : T)                       return T;\n+\n+   function Compose           (RT : R; Fraction : T; Exponent : UI) return T;\n+\n+   function Copy_Sign         (RT : R; Value, Sign : T)             return T;\n+\n+   function Exponent          (RT : R; X : T)                       return UI;\n+\n+   function Floor             (RT : R; X : T)                       return T;\n+\n+   function Fraction          (RT : R; X : T)                       return T;\n+\n+   function Leading_Part      (RT : R; X : T; Radix_Digits : UI)    return T;\n+\n+   function Machine           (RT : R; X : T; Mode : Rounding_Mode) return T;\n+\n+   function Model             (RT : R; X : T)                       return T;\n+\n+   function Pred              (RT : R; X : T)                       return T;\n+\n+   function Remainder         (RT : R; X, Y : T)                    return T;\n+\n+   function Rounding          (RT : R; X : T)                       return T;\n+\n+   function Scaling           (RT : R; X : T; Adjustment : UI)      return T;\n+\n+   function Succ              (RT : R; X : T)                       return T;\n+\n+   function Truncation        (RT : R; X : T)                       return T;\n+\n+   function Unbiased_Rounding (RT : R; X : T)                       return T;\n+\n+end Eval_Fat;"}, {"sha": "85bc863fccc7489bfdf4fbad9fcf5164ed33f5d8", "filename": "gcc/ada/exit.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexit.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,59 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                E X I T                                   *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *                            $Revision: 1.1 $\n+ *                                                                          *\n+ *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#ifdef __alpha_vxworks\n+#include \"vxWorks.h\"\n+#endif\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include <sys/stat.h>\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"adaint.h\"\n+\n+/* Routine used by Ada.Command_Line.Set_Exit_Status */\n+\n+int gnat_exit_status = 0;\n+\n+void\n+__gnat_set_exit_status (i)\n+     int i;\n+{\n+  gnat_exit_status = i;\n+}"}, {"sha": "92a7396fd636a01a4e50ac8c11b46752a14164aa", "filename": "gcc/ada/exp_aggr.adb", "status": "added", "additions": 4016, "deletions": 0, "changes": 4016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "2e435defa32e8efd58f4ba908d0785ccf5564019", "filename": "gcc/ada/exp_aggr.ads", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ A G G R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Types; use Types;\n+\n+package Exp_Aggr is\n+\n+   procedure Expand_N_Aggregate           (N : Node_Id);\n+   procedure Expand_N_Extension_Aggregate (N : Node_Id);\n+\n+   function Is_Delayed_Aggregate (N : Node_Id) return Boolean;\n+   --  returns True if N is a delayed aggregate of some kind\n+\n+   procedure Convert_Aggr_In_Object_Decl  (N : Node_Id);\n+   --  N is a N_Object_Declaration with an expression which must be\n+   --  an N_Aggregate or N_Extension_Aggregate with Expansion_Delayed\n+   --  This procedure performs in-place aggregate assignment.\n+\n+   procedure Convert_Aggr_In_Allocator (Decl, Aggr : Node_Id);\n+   --  Decl is an access N_Object_Declaration (produced during\n+   --  allocator expansion), Aggr is the initial expression aggregate\n+   --  of an allocator. This procedure perform in-place aggregate\n+   --  assignent in the newly allocated object.\n+\n+   procedure Convert_Aggr_In_Assignment (N : Node_Id);\n+   --  Decl is an access N_Object_Declaration (produced during\n+   --  allocator expansion), Aggr is the initial expression aggregate\n+   --  of an allocator. This procedure perform in-place aggregate\n+   --  assignent in the newly allocated object.\n+\n+\n+end Exp_Aggr;"}, {"sha": "2fada3e36a57ec2560a3cc577d0341ce3d114a3d", "filename": "gcc/ada/exp_attr.adb", "status": "added", "additions": 3924, "deletions": 0, "changes": 3924, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "1665bc74c145071b8313c36fcb714f8239343fe1", "filename": "gcc/ada/exp_attr.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,35 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ A T T R                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for attribute references\n+\n+with Types; use Types;\n+\n+package Exp_Attr is\n+   procedure Expand_N_Attribute_Reference       (N : Node_Id);\n+end Exp_Attr;"}, {"sha": "d98350cd85fdac3b5bb13e1d95f92d1fc7230560", "filename": "gcc/ada/exp_ch10.ads", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch10.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,32 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 0                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.3 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for chapter 10 constructs\n+\n+package Exp_Ch10 is\n+end Exp_Ch10;"}, {"sha": "62a4f6fd3e641f41f0d9a55b726e565e9a3a4531", "filename": "gcc/ada/exp_ch11.adb", "status": "added", "additions": 1824, "deletions": 0, "changes": 1824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,1824 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 1                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.117 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Casing;   use Casing;\n+with Debug;    use Debug;\n+with Einfo;    use Einfo;\n+with Exp_Ch7;  use Exp_Ch7;\n+with Exp_Util; use Exp_Util;\n+with Hostparm; use Hostparm;\n+with Inline;   use Inline;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n+with Restrict; use Restrict;\n+with Sem;      use Sem;\n+with Sem_Ch5;  use Sem_Ch5;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Targparm; use Targparm;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+with Uname;    use Uname;\n+\n+package body Exp_Ch11 is\n+\n+   SD_List : List_Id;\n+   --  This list gathers the values SDn'Unrestricted_Access used to\n+   --  construct the unit exception table. It is set to Empty_List if\n+   --  there are no subprogram descriptors.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Expand_Exception_Handler_Tables (HSS : Node_Id);\n+   --  Subsidiary procedure called by Expand_Exception_Handlers if zero\n+   --  cost exception handling is installed for this target. Replaces the\n+   --  exception handler structure with appropriate labeled code and tables\n+   --  that allow the zero cost exception handling circuits to find the\n+   --  correct handler (see unit Ada.Exceptions for details).\n+\n+   procedure Generate_Subprogram_Descriptor\n+     (N     : Node_Id;\n+      Loc   : Source_Ptr;\n+      Spec  : Entity_Id;\n+      Slist : List_Id);\n+   --  Procedure called to generate a subprogram descriptor. N is the\n+   --  subprogram body node or, in the case of an imported subprogram, is\n+   --  Empty, and Spec is the entity of the sunprogram. For details of the\n+   --  required structure, see package System.Exceptions. The generated\n+   --  subprogram descriptor is appended to Slist. Loc provides the\n+   --  source location to be used for the generated descriptor.\n+\n+   ---------------------------\n+   -- Expand_At_End_Handler --\n+   ---------------------------\n+\n+   --  For a handled statement sequence that has a cleanup (At_End_Proc\n+   --  field set), an exception handler of the following form is required:\n+\n+   --     exception\n+   --       when all others =>\n+   --          cleanup call\n+   --          raise;\n+\n+   --  Note: this exception handler is treated rather specially by\n+   --  subsequent expansion in two respects:\n+\n+   --    The normal call to Undefer_Abort is omitted\n+   --    The raise call does not do Defer_Abort\n+\n+   --  This is because the current tasking code seems to assume that\n+   --  the call to the cleanup routine that is made from an exception\n+   --  handler for the abort signal is called with aborts deferred.\n+\n+   procedure Expand_At_End_Handler (HSS : Node_Id; Block : Node_Id) is\n+      Clean   : constant Entity_Id  := Entity (At_End_Proc (HSS));\n+      Loc     : constant Source_Ptr := Sloc (Clean);\n+      Ohandle : Node_Id;\n+      Stmnts  : List_Id;\n+\n+   begin\n+      pragma Assert (Present (Clean));\n+      pragma Assert (No (Exception_Handlers (HSS)));\n+\n+      if Restrictions (No_Exception_Handlers) then\n+         return;\n+      end if;\n+\n+      if Present (Block) then\n+         New_Scope (Block);\n+      end if;\n+\n+      Ohandle :=\n+        Make_Others_Choice (Loc);\n+      Set_All_Others (Ohandle);\n+\n+      Stmnts := New_List (\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (Clean, Loc)),\n+        Make_Raise_Statement (Loc));\n+\n+      Set_Exception_Handlers (HSS, New_List (\n+        Make_Exception_Handler (Loc,\n+          Exception_Choices => New_List (Ohandle),\n+          Statements        => Stmnts)));\n+\n+      Analyze_List (Stmnts, Suppress => All_Checks);\n+      Expand_Exception_Handlers (HSS);\n+\n+      if Present (Block) then\n+         Pop_Scope;\n+      end if;\n+   end Expand_At_End_Handler;\n+\n+   -------------------------------------\n+   -- Expand_Exception_Handler_Tables --\n+   -------------------------------------\n+\n+   --  See Ada.Exceptions specification for full details of the data\n+   --  structures that we need to construct here. As an example of the\n+   --  transformation that is required, given the structure:\n+\n+   --     declare\n+   --        {declarations}\n+   --        ..\n+   --     begin\n+   --        {statements-1}\n+   --        ...\n+   --     exception\n+   --        when a | b =>\n+   --           {statements-2}\n+   --           ...\n+   --        when others =>\n+   --           {statements-3}\n+   --           ...\n+   --     end;\n+\n+   --  We transform this into:\n+\n+   --     declare\n+   --        {declarations}\n+   --        ...\n+   --        L1 : label;\n+   --        L2 : label;\n+   --        L3 : label;\n+   --        L4 : Label;\n+   --        L5 : label;\n+\n+   --     begin\n+   --        <<L1>>\n+   --           {statements-1}\n+   --        <<L2>>\n+\n+   --     exception\n+\n+   --        when a | b =>\n+   --           <<L3>>\n+   --           {statements-2}\n+\n+   --           HR2 : constant Handler_Record := (\n+   --                   Lo      => L1'Address,\n+   --                   Hi      => L2'Address,\n+   --                   Id      => a'Identity,\n+   --                   Handler => L5'Address);\n+\n+   --           HR3 : constant Handler_Record := (\n+   --                   Lo      => L1'Address,\n+   --                   Hi      => L2'Address,\n+   --                   Id      => b'Identity,\n+   --                   Handler => L4'Address);\n+\n+   --        when others =>\n+   --           <<L4>>\n+   --           {statements-3}\n+\n+   --           HR1 : constant Handler_Record := (\n+   --                   Lo      => L1'Address,\n+   --                   Hi      => L2'Address,\n+   --                   Id      => Others_Id,\n+   --                   Handler => L4'Address);\n+   --     end;\n+\n+   --  The exception handlers in the transformed version are marked with the\n+   --  Zero_Cost_Handling flag set, and all gigi does in this case is simply\n+   --  to put the handler code somewhere. It can optionally be put inline\n+   --  between the goto L3 and the label <<L3>> (which is why we generate\n+   --  that goto in the first place).\n+\n+   procedure Expand_Exception_Handler_Tables (HSS : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (HSS);\n+      Handlrs : constant List_Id    := Exception_Handlers (HSS);\n+      Stms    : constant List_Id    := Statements (HSS);\n+      Handler : Node_Id;\n+\n+      Hlist : List_Id;\n+      --  This is the list to which handlers are to be appended. It is\n+      --  either the list for the enclosing subprogram, or the enclosing\n+      --  selective accept statement (which will turn into a subprogram\n+      --  during expansion later on).\n+\n+      L1 : constant Entity_Id :=\n+             Make_Defining_Identifier (Loc,\n+               Chars => New_Internal_Name ('L'));\n+\n+      L2 : constant Entity_Id :=\n+             Make_Defining_Identifier (Loc,\n+               Chars => New_Internal_Name ('L'));\n+\n+      Lnn    : Entity_Id;\n+      Choice : Node_Id;\n+      E_Id   : Node_Id;\n+      HR_Ent : Node_Id;\n+      HL_Ref : Node_Id;\n+      Item   : Node_Id;\n+\n+      Subp_Entity : Entity_Id;\n+      --  This is the entity for the subprogram (or library level package)\n+      --  to which the handler record is to be attached for later reference\n+      --  in a subprogram descriptor for this entity.\n+\n+      procedure Append_To_Stms (N : Node_Id);\n+      --  Append given statement to the end of the statements of the\n+      --  handled sequence of statements and analyze it in place.\n+\n+      function Inside_Selective_Accept return Boolean;\n+      --  This function is called if we are inside the scope of an entry\n+      --  or task. It checks if the handler is appearing in the context\n+      --  of a selective accept statement. If so, Hlist is set to\n+      --  temporarily park the handlers in the N_Accept_Alternative.\n+      --  node. They will subsequently be moved to the procedure entity\n+      --  for the procedure built for this alternative. The statements that\n+      --  follow the Accept within the alternative are not inside the Accept\n+      --  for purposes of this test, and handlers that may appear within\n+      --  them belong in the enclosing task procedure.\n+\n+      procedure Set_Hlist;\n+      --  Sets the handler list corresponding to Subp_Entity\n+\n+      --------------------\n+      -- Append_To_Stms --\n+      --------------------\n+\n+      procedure Append_To_Stms (N : Node_Id) is\n+      begin\n+         Insert_After_And_Analyze (Last (Stms), N);\n+         Set_Exception_Junk (N);\n+      end Append_To_Stms;\n+\n+      -----------------------------\n+      -- Inside_Selective_Accept --\n+      -----------------------------\n+\n+      function Inside_Selective_Accept return Boolean is\n+         Parnt : Node_Id;\n+         Curr  : Node_Id := HSS;\n+\n+      begin\n+         Parnt := Parent (HSS);\n+         while Nkind (Parnt) /= N_Compilation_Unit loop\n+            if Nkind (Parnt) = N_Accept_Alternative\n+              and then Curr = Accept_Statement (Parnt)\n+            then\n+               if Present (Accept_Handler_Records (Parnt)) then\n+                  Hlist := Accept_Handler_Records (Parnt);\n+               else\n+                  Hlist := New_List;\n+                  Set_Accept_Handler_Records (Parnt, Hlist);\n+               end if;\n+\n+               return True;\n+            else\n+               Curr  := Parnt;\n+               Parnt := Parent (Parnt);\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end Inside_Selective_Accept;\n+\n+      ---------------\n+      -- Set_Hlist --\n+      ---------------\n+\n+      procedure Set_Hlist is\n+      begin\n+         --  Never try to inline a subprogram with exception handlers\n+\n+         Set_Is_Inlined (Subp_Entity, False);\n+\n+         if Present (Subp_Entity)\n+           and then Present (Handler_Records (Subp_Entity))\n+         then\n+            Hlist := Handler_Records (Subp_Entity);\n+         else\n+            Hlist := New_List;\n+            Set_Handler_Records (Subp_Entity, Hlist);\n+         end if;\n+      end Set_Hlist;\n+\n+   --  Start of processing for Expand_Exception_Handler_Tables\n+\n+   begin\n+      --  Nothing to do if this handler has already been processed\n+\n+      if Zero_Cost_Handling (HSS) then\n+         return;\n+      end if;\n+\n+      Set_Zero_Cost_Handling (HSS);\n+\n+      --  Find the parent subprogram or package scope containing this\n+      --  exception frame. This should always find a real package or\n+      --  subprogram. If it does not it will stop at Standard, but\n+      --  this cannot legitimately occur.\n+\n+      --  We only stop at library level packages, for inner packages\n+      --  we always attach handlers to the containing procedure.\n+\n+      Subp_Entity := Current_Scope;\n+      Scope_Loop : loop\n+\n+         --  Never need tables expanded inside a generic template\n+\n+         if Is_Generic_Unit (Subp_Entity) then\n+            return;\n+\n+         --  Stop if we reached containing subprogram. Go to protected\n+         --  subprogram if there is one defined.\n+\n+         elsif Ekind (Subp_Entity) = E_Function\n+           or else Ekind (Subp_Entity) = E_Procedure\n+         then\n+            if Present (Protected_Body_Subprogram (Subp_Entity)) then\n+               Subp_Entity := Protected_Body_Subprogram (Subp_Entity);\n+            end if;\n+\n+            Set_Hlist;\n+            exit Scope_Loop;\n+\n+         --  Case of within an entry\n+\n+         elsif Is_Entry (Subp_Entity) then\n+\n+            --  Protected entry, use corresponding body subprogram\n+\n+            if Present (Protected_Body_Subprogram (Subp_Entity)) then\n+               Subp_Entity := Protected_Body_Subprogram (Subp_Entity);\n+               Set_Hlist;\n+               exit Scope_Loop;\n+\n+            --  Check if we are within a selective accept alternative\n+\n+            elsif Inside_Selective_Accept then\n+\n+               --  As a side effect, Inside_Selective_Accept set Hlist,\n+               --  in much the same manner as Set_Hlist, except that\n+               --  the list involved was the one for the selective accept.\n+\n+               exit Scope_Loop;\n+            end if;\n+\n+         --  Case of within library level package\n+\n+         elsif Ekind (Subp_Entity) = E_Package\n+           and then Is_Compilation_Unit (Subp_Entity)\n+         then\n+            if Is_Body_Name (Unit_Name (Get_Code_Unit (HSS))) then\n+               Subp_Entity := Body_Entity (Subp_Entity);\n+            end if;\n+\n+            Set_Hlist;\n+            exit Scope_Loop;\n+\n+         --  Task type case\n+\n+         elsif Ekind (Subp_Entity) = E_Task_Type then\n+\n+            --  Check if we are within a selective accept alternative\n+\n+            if Inside_Selective_Accept then\n+\n+               --  As a side effect, Inside_Selective_Accept set Hlist,\n+               --  in much the same manner as Set_Hlist, except that the\n+               --  list involved was the one for the selective accept.\n+\n+               exit Scope_Loop;\n+\n+            --  Stop if we reached task type with task body procedure,\n+            --  use the task body procedure.\n+\n+            elsif Present (Get_Task_Body_Procedure (Subp_Entity)) then\n+               Subp_Entity := Get_Task_Body_Procedure (Subp_Entity);\n+               Set_Hlist;\n+               exit Scope_Loop;\n+            end if;\n+         end if;\n+\n+         --  If we fall through, keep looking\n+\n+         Subp_Entity := Scope (Subp_Entity);\n+      end loop Scope_Loop;\n+\n+      pragma Assert (Subp_Entity /= Standard_Standard);\n+\n+      --  Analyze standard labels\n+\n+      Analyze_Label_Entity (L1);\n+      Analyze_Label_Entity (L2);\n+\n+      Insert_Before_And_Analyze (First (Stms),\n+        Make_Label (Loc,\n+          Identifier => New_Occurrence_Of (L1, Loc)));\n+      Set_Exception_Junk (First (Stms));\n+\n+      Append_To_Stms (\n+        Make_Label (Loc,\n+          Identifier => New_Occurrence_Of (L2, Loc)));\n+\n+      --  Loop through exception handlers\n+\n+      Handler := First_Non_Pragma (Handlrs);\n+      while Present (Handler) loop\n+         Set_Zero_Cost_Handling (Handler);\n+\n+         --  Add label at start of handler, and goto at the end\n+\n+         Lnn :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_Internal_Name ('L'));\n+\n+         Analyze_Label_Entity (Lnn);\n+\n+         Item :=\n+           Make_Label (Loc,\n+             Identifier => New_Occurrence_Of (Lnn, Loc));\n+         Set_Exception_Junk (Item);\n+         Insert_Before_And_Analyze (First (Statements (Handler)), Item);\n+\n+         --  Loop through choices\n+\n+         Choice := First (Exception_Choices (Handler));\n+         while Present (Choice) loop\n+\n+            --  Others (or all others) choice\n+\n+            if Nkind (Choice) = N_Others_Choice then\n+               if All_Others (Choice) then\n+                  E_Id := New_Occurrence_Of (RTE (RE_All_Others_Id), Loc);\n+               else\n+                  E_Id := New_Occurrence_Of (RTE (RE_Others_Id), Loc);\n+               end if;\n+\n+            --  Special case of VMS_Exception. Not clear what we will do\n+            --  eventually here if and when we implement zero cost exceptions\n+            --  on VMS. But at least for now, don't blow up trying to take\n+            --  a garbage code address for such an exception.\n+\n+            elsif Is_VMS_Exception (Entity (Choice)) then\n+               E_Id := New_Occurrence_Of (RTE (RE_Null_Id), Loc);\n+\n+            --  Normal case of specific exception choice\n+\n+            else\n+               E_Id :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => New_Occurrence_Of (Entity (Choice), Loc),\n+                   Attribute_Name => Name_Identity);\n+            end if;\n+\n+            HR_Ent :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('H'));\n+\n+            HL_Ref :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Occurrence_Of (HR_Ent, Loc),\n+                Attribute_Name => Name_Unrestricted_Access);\n+\n+            --  Now we need to add the entry for the new handler record to\n+            --  the list of handler records for the current subprogram.\n+\n+            --  Normally we end up generating the handler records in exactly\n+            --  the right order. Here right order means innermost first,\n+            --  since the table will be searched sequentially. Since we\n+            --  generally expand from outside to inside, the order is just\n+            --  what we want, and we need to append the new entry to the\n+            --  end of the list.\n+\n+            --  However, there are exceptions, notably in the case where\n+            --  a generic body is inserted later on. See for example the\n+            --  case of ACVC test C37213J, which has the following form:\n+\n+            --    generic package x ... end x;\n+            --    package body x is\n+            --    begin\n+            --       ...\n+            --    exception  (1)\n+            --       ...\n+            --    end x;\n+\n+            --    ...\n+\n+            --    declare\n+            --       package q is new x;\n+            --    begin\n+            --       ...\n+            --    exception (2)\n+            --       ...\n+            --    end;\n+\n+            --  In this case, we will expand exception handler (2) first,\n+            --  since the expansion of (1) is delayed till later when the\n+            --  generic body is inserted. But (1) belongs before (2) in\n+            --  the chain.\n+\n+            --  Note that scopes are not totally ordered, because two\n+            --  scopes can be in parallel blocks, so that it does not\n+            --  matter what order these entries appear in. An ordering\n+            --  relation exists if one scope is inside another, and what\n+            --  we really want is some partial ordering.\n+\n+            --  A simple, not very efficient, but adequate algorithm to\n+            --  achieve this partial ordering is to search the list for\n+            --  the first entry containing the given scope, and put the\n+            --  new entry just before it.\n+\n+            declare\n+               New_Scop : constant Entity_Id := Current_Scope;\n+               Ent      : Node_Id;\n+\n+            begin\n+               Ent := First (Hlist);\n+               loop\n+                  --  If all searched, then we can just put the new\n+                  --  entry at the end of the list (it actually does\n+                  --  not matter where we put it in this case).\n+\n+                  if No (Ent) then\n+                     Append_To (Hlist, HL_Ref);\n+                     exit;\n+\n+                  --  If the current scope is within the scope of the\n+                  --  entry then insert the entry before to retain the\n+                  --  proper order as per above discussion.\n+\n+                  --  Note that for equal entries, we just keep going,\n+                  --  which is fine, the entry will end up at the end\n+                  --  of the list where it belongs.\n+\n+                  elsif Scope_Within\n+                          (New_Scop, Scope (Entity (Prefix (Ent))))\n+                  then\n+                     Insert_Before (Ent, HL_Ref);\n+                     exit;\n+\n+                  --  Otherwise keep looking\n+\n+                  else\n+                     Next (Ent);\n+                  end if;\n+               end loop;\n+            end;\n+\n+            Item :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => HR_Ent,\n+                Constant_Present    => True,\n+                Aliased_Present     => True,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (RTE (RE_Handler_Record), Loc),\n+\n+                Expression          =>\n+                  Make_Aggregate (Loc,\n+                    Expressions => New_List (\n+                      Make_Attribute_Reference (Loc,             -- Lo\n+                        Prefix => New_Occurrence_Of (L1, Loc),\n+                        Attribute_Name => Name_Address),\n+\n+                      Make_Attribute_Reference (Loc,             -- Hi\n+                        Prefix => New_Occurrence_Of (L2, Loc),\n+                        Attribute_Name => Name_Address),\n+\n+                      E_Id,                                      -- Id\n+\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix => New_Occurrence_Of (Lnn, Loc),  -- Handler\n+                        Attribute_Name => Name_Address))));\n+\n+            Set_Handler_List_Entry (Item, HL_Ref);\n+            Set_Exception_Junk (Item);\n+            Insert_After_And_Analyze (Last (Statements (Handler)), Item);\n+            Set_Is_Statically_Allocated (HR_Ent);\n+\n+            --  If this is a late insertion (from body instance) it is being\n+            --  inserted in the component list of an already analyzed aggre-\n+            --  gate, and must be analyzed explicitly.\n+\n+            Analyze_And_Resolve (HL_Ref, RTE (RE_Handler_Record_Ptr));\n+\n+            Next (Choice);\n+         end loop;\n+\n+         Next_Non_Pragma (Handler);\n+      end loop;\n+   end Expand_Exception_Handler_Tables;\n+\n+   -------------------------------\n+   -- Expand_Exception_Handlers --\n+   -------------------------------\n+\n+   procedure Expand_Exception_Handlers (HSS : Node_Id) is\n+      Handlrs       : constant List_Id := Exception_Handlers (HSS);\n+      Loc           : Source_Ptr;\n+      Handler       : Node_Id;\n+      Others_Choice : Boolean;\n+      Obj_Decl      : Node_Id;\n+\n+      procedure Prepend_Call_To_Handler\n+        (Proc : RE_Id;\n+         Args : List_Id := No_List);\n+      --  Routine to prepend a call to the procedure referenced by Proc at\n+      --  the start of the handler code for the current Handler.\n+\n+      procedure Prepend_Call_To_Handler\n+        (Proc : RE_Id;\n+         Args : List_Id := No_List)\n+      is\n+         Call : constant Node_Id :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Occurrence_Of (RTE (Proc), Loc),\n+                   Parameter_Associations => Args);\n+\n+      begin\n+         Prepend_To (Statements (Handler), Call);\n+         Analyze (Call, Suppress => All_Checks);\n+      end Prepend_Call_To_Handler;\n+\n+   --  Start of processing for Expand_Exception_Handlers\n+\n+   begin\n+      --  Loop through handlers\n+\n+      Handler := First_Non_Pragma (Handlrs);\n+      while Present (Handler) loop\n+         Loc := Sloc (Handler);\n+\n+         --  If an exception occurrence is present, then we must declare it\n+         --  and initialize it from the value stored in the TSD\n+\n+         --     declare\n+         --        name : Exception_Occurrence;\n+         --\n+         --     begin\n+         --        Save_Occurrence (name, Get_Current_Excep.all)\n+         --        ...\n+         --     end;\n+\n+         if Present (Choice_Parameter (Handler)) then\n+            declare\n+               Cparm : constant Entity_Id  := Choice_Parameter (Handler);\n+               Clc   : constant Source_Ptr := Sloc (Cparm);\n+               Save  : Node_Id;\n+\n+            begin\n+               Save :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Occurrence_Of (RTE (RE_Save_Occurrence), Loc),\n+                   Parameter_Associations => New_List (\n+                     New_Occurrence_Of (Cparm, Clc),\n+                     Make_Explicit_Dereference (Loc,\n+                       Make_Function_Call (Loc,\n+                         Name => Make_Explicit_Dereference (Loc,\n+                           New_Occurrence_Of\n+                             (RTE (RE_Get_Current_Excep), Loc))))));\n+\n+               Mark_Rewrite_Insertion (Save);\n+               Prepend (Save, Statements (Handler));\n+\n+               Obj_Decl :=\n+                 Make_Object_Declaration (Clc,\n+                   Defining_Identifier => Cparm,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of\n+                       (RTE (RE_Exception_Occurrence), Clc));\n+               Set_No_Initialization (Obj_Decl, True);\n+\n+               Rewrite (Handler,\n+                 Make_Exception_Handler (Loc,\n+                   Exception_Choices => Exception_Choices (Handler),\n+\n+                   Statements => New_List (\n+                     Make_Block_Statement (Loc,\n+                       Declarations => New_List (Obj_Decl),\n+                       Handled_Statement_Sequence =>\n+                         Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => Statements (Handler))))));\n+\n+               Analyze_List (Statements (Handler), Suppress => All_Checks);\n+            end;\n+         end if;\n+\n+         --  The processing at this point is rather different for the\n+         --  JVM case, so we completely separate the processing.\n+\n+         --  For the JVM case, we unconditionally call Update_Exception,\n+         --  passing a call to the intrinsic function Current_Target_Exception\n+         --  (see JVM version of Ada.Exceptions in 4jexcept.adb for details).\n+\n+         if Hostparm.Java_VM then\n+            declare\n+               Arg  : Node_Id\n+                 := Make_Function_Call (Loc,\n+                      Name => New_Occurrence_Of\n+                                (RTE (RE_Current_Target_Exception), Loc));\n+            begin\n+               Prepend_Call_To_Handler (RE_Update_Exception, New_List (Arg));\n+            end;\n+\n+         --  For the normal case, we have to worry about the state of abort\n+         --  deferral. Generally, we defer abort during runtime handling of\n+         --  exceptions. When control is passed to the handler, then in the\n+         --  normal case we undefer aborts. In any case this entire handling\n+         --  is relevant only if aborts are allowed!\n+\n+         elsif Abort_Allowed then\n+\n+            --  There are some special cases in which we do not do the\n+            --  undefer. In particular a finalization (AT END) handler\n+            --  wants to operate with aborts still deferred.\n+\n+            --  We also suppress the call if this is the special handler\n+            --  for Abort_Signal, since if we are aborting, we want to keep\n+            --  aborts deferred (one abort is enough thank you very much :-)\n+\n+            --  If abort really needs to be deferred the expander must add\n+            --  this call explicitly, see Exp_Ch9.Expand_N_Asynchronous_Select.\n+\n+            Others_Choice :=\n+              Nkind (First (Exception_Choices (Handler))) = N_Others_Choice;\n+\n+            if (Others_Choice\n+                 or else Entity (First (Exception_Choices (Handler))) /=\n+                                                      Stand.Abort_Signal)\n+              and then not\n+                (Others_Choice\n+                   and then All_Others (First (Exception_Choices (Handler))))\n+              and then Abort_Allowed\n+            then\n+               Prepend_Call_To_Handler (RE_Abort_Undefer);\n+            end if;\n+         end if;\n+\n+         Next_Non_Pragma (Handler);\n+      end loop;\n+\n+      --  The last step for expanding exception handlers is to expand the\n+      --  exception tables if zero cost exception handling is active.\n+\n+      if Exception_Mechanism = Front_End_ZCX then\n+         Expand_Exception_Handler_Tables (HSS);\n+      end if;\n+   end Expand_Exception_Handlers;\n+\n+   ------------------------------------\n+   -- Expand_N_Exception_Declaration --\n+   ------------------------------------\n+\n+   --  Generates:\n+   --     exceptE : constant String := \"A.B.EXCEP\";   -- static data\n+   --     except : exception_data :=  (\n+   --                    Handled_By_Other => False,\n+   --                    Lang             => 'A',\n+   --                    Name_Length      => exceptE'Length\n+   --                    Full_Name        => exceptE'Address\n+   --                    HTable_Ptr       => null);\n+\n+   --  (protecting test only needed if not at library level)\n+   --\n+   --     exceptF : Boolean := True --  static data\n+   --     if exceptF then\n+   --        exceptF := False;\n+   --        Register_Exception (except'Unchecked_Access);\n+   --     end if;\n+\n+   procedure Expand_N_Exception_Declaration (N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Id      : constant Entity_Id  := Defining_Identifier (N);\n+      L       : List_Id             := New_List;\n+      Flag_Id : Entity_Id;\n+\n+      Name_Exname : constant Name_Id := New_External_Name (Chars (Id), 'E');\n+      Exname      : constant Node_Id :=\n+                      Make_Defining_Identifier (Loc, Name_Exname);\n+\n+   begin\n+      --  There is no expansion needed when compiling for the JVM since the\n+      --  JVM has a built-in exception mechanism. See 4jexcept.ads for details.\n+\n+      if Hostparm.Java_VM then\n+         return;\n+      end if;\n+\n+      --  Definition of the external name: nam : constant String := \"A.B.NAME\";\n+\n+      Insert_Action (N,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Exname,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n+          Expression => Make_String_Literal (Loc, Full_Qualified_Name (Id))));\n+\n+      Set_Is_Statically_Allocated (Exname);\n+\n+      --  Create the aggregate list for type Standard.Exception_Type:\n+      --  Handled_By_Other component: False\n+\n+      Append_To (L, New_Occurrence_Of (Standard_False, Loc));\n+\n+      --  Lang component: 'A'\n+\n+      Append_To (L,\n+        Make_Character_Literal (Loc, Name_uA, Get_Char_Code ('A')));\n+\n+      --  Name_Length component: Nam'Length\n+\n+      Append_To (L,\n+        Make_Attribute_Reference (Loc,\n+          Prefix         => New_Occurrence_Of (Exname, Loc),\n+          Attribute_Name => Name_Length));\n+\n+      --  Full_Name component: Standard.A_Char!(Nam'Address)\n+\n+      Append_To (L, Unchecked_Convert_To (Standard_A_Char,\n+        Make_Attribute_Reference (Loc,\n+          Prefix         => New_Occurrence_Of (Exname, Loc),\n+          Attribute_Name => Name_Address)));\n+\n+      --  HTable_Ptr component: null\n+\n+      Append_To (L, Make_Null (Loc));\n+\n+      --  Import_Code component: 0\n+\n+      Append_To (L, Make_Integer_Literal (Loc, 0));\n+\n+      Set_Expression (N, Make_Aggregate (Loc, Expressions => L));\n+      Analyze_And_Resolve (Expression (N), Etype (Id));\n+\n+      --  Register_Exception (except'Unchecked_Access);\n+\n+      if not Restrictions (No_Exception_Handlers) then\n+         L := New_List (\n+                Make_Procedure_Call_Statement (Loc,\n+                  Name => New_Occurrence_Of (RTE (RE_Register_Exception), Loc),\n+                  Parameter_Associations => New_List (\n+                    Unchecked_Convert_To (RTE (RE_Exception_Data_Ptr),\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix         => New_Occurrence_Of (Id, Loc),\n+                        Attribute_Name => Name_Unrestricted_Access)))));\n+\n+         Set_Register_Exception_Call (Id, First (L));\n+\n+         if not Is_Library_Level_Entity (Id) then\n+            Flag_Id :=  Make_Defining_Identifier (Loc,\n+                          New_External_Name (Chars (Id), 'F'));\n+\n+            Insert_Action (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Flag_Id,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc),\n+                Expression          =>\n+                  New_Occurrence_Of (Standard_True, Loc)));\n+\n+            Set_Is_Statically_Allocated (Flag_Id);\n+\n+            Append_To (L,\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Occurrence_Of (Flag_Id, Loc),\n+                Expression => New_Occurrence_Of (Standard_False, Loc)));\n+\n+            Insert_After_And_Analyze (N,\n+              Make_Implicit_If_Statement (N,\n+                Condition       => New_Occurrence_Of (Flag_Id, Loc),\n+                Then_Statements => L));\n+\n+         else\n+            Insert_List_After_And_Analyze (N, L);\n+         end if;\n+      end if;\n+\n+   end Expand_N_Exception_Declaration;\n+\n+   ---------------------------------------------\n+   -- Expand_N_Handled_Sequence_Of_Statements --\n+   ---------------------------------------------\n+\n+   procedure Expand_N_Handled_Sequence_Of_Statements (N : Node_Id) is\n+   begin\n+      if Present (Exception_Handlers (N)) then\n+         Expand_Exception_Handlers (N);\n+      end if;\n+\n+      --  The following code needs comments ???\n+\n+      if Nkind (Parent (N)) /= N_Package_Body\n+        and then Nkind (Parent (N)) /= N_Accept_Statement\n+        and then not Delay_Cleanups (Current_Scope)\n+      then\n+         Expand_Cleanup_Actions (Parent (N));\n+      else\n+         Set_First_Real_Statement (N, First (Statements (N)));\n+      end if;\n+\n+   end Expand_N_Handled_Sequence_Of_Statements;\n+\n+   -------------------------------------\n+   -- Expand_N_Raise_Constraint_Error --\n+   -------------------------------------\n+\n+   --  The only processing required is to adjust the condition to deal\n+   --  with the C/Fortran boolean case. This may well not be necessary,\n+   --  as all such conditions are generated by the expander and probably\n+   --  are all standard boolean, but who knows what strange optimization\n+   --  in future may require this adjustment!\n+\n+   procedure Expand_N_Raise_Constraint_Error (N : Node_Id) is\n+   begin\n+      Adjust_Condition (Condition (N));\n+   end Expand_N_Raise_Constraint_Error;\n+\n+   ----------------------------------\n+   -- Expand_N_Raise_Program_Error --\n+   ----------------------------------\n+\n+   --  The only processing required is to adjust the condition to deal\n+   --  with the C/Fortran boolean case. This may well not be necessary,\n+   --  as all such conditions are generated by the expander and probably\n+   --  are all standard boolean, but who knows what strange optimization\n+   --  in future may require this adjustment!\n+\n+   procedure Expand_N_Raise_Program_Error (N : Node_Id) is\n+   begin\n+      Adjust_Condition (Condition (N));\n+   end Expand_N_Raise_Program_Error;\n+\n+   ------------------------------\n+   -- Expand_N_Raise_Statement --\n+   ------------------------------\n+\n+   procedure Expand_N_Raise_Statement (N : Node_Id) is\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Ehand : Node_Id;\n+      E     : Entity_Id;\n+      Str   : String_Id;\n+\n+   begin\n+      --  There is no expansion needed for statement \"raise <exception>;\" when\n+      --  compiling for the JVM since the JVM has a built-in exception\n+      --  mechanism. However we need the keep the expansion for \"raise;\"\n+      --  statements. See 4jexcept.ads for details.\n+\n+      if Present (Name (N)) and then Hostparm.Java_VM then\n+         return;\n+      end if;\n+\n+      --  Convert explicit raise of Program_Error, Constraint_Error, and\n+      --  Storage_Error into the corresponding raise node (in No_Run_Time\n+      --  mode all other raises will get normal expansion and be disallowed,\n+      --  but this is also faster in all modes).\n+\n+      if Present (Name (N)) and then Nkind (Name (N)) = N_Identifier then\n+         if Entity (Name (N)) = Standard_Program_Error then\n+            Rewrite (N, Make_Raise_Program_Error (Loc));\n+            Analyze (N);\n+            return;\n+\n+         elsif Entity (Name (N)) = Standard_Constraint_Error then\n+            Rewrite (N, Make_Raise_Constraint_Error (Loc));\n+            Analyze (N);\n+            return;\n+\n+         elsif Entity (Name (N)) = Standard_Storage_Error then\n+            Rewrite (N, Make_Raise_Storage_Error (Loc));\n+            Analyze (N);\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Case of name present, in this case we expand raise name to\n+\n+      --    Raise_Exception (name'Identity, location_string);\n+\n+      --  where location_string identifies the file/line of the raise\n+\n+      if Present (Name (N)) then\n+         declare\n+            Id : Entity_Id := Entity (Name (N));\n+\n+         begin\n+            Build_Location_String (Loc);\n+\n+            --  Build a C compatible string in case of no exception handlers,\n+            --  since this is what the last chance handler is expecting.\n+\n+            if Restrictions (No_Exception_Handlers) then\n+               --  Generate a C null message when Global_Discard_Names is True\n+               --  or when Debug_Flag_NN is set.\n+\n+               if Global_Discard_Names or else Debug_Flag_NN then\n+                  Name_Buffer (1) := ASCII.NUL;\n+                  Name_Len := 1;\n+               else\n+                  Name_Len := Name_Len + 1;\n+               end if;\n+\n+            --  Do not generate the message when Global_Discard_Names is True\n+            --  or when Debug_Flag_NN is set.\n+\n+            elsif Global_Discard_Names or else Debug_Flag_NN then\n+               Name_Len := 0;\n+            end if;\n+\n+            Str := String_From_Name_Buffer;\n+\n+            --  For VMS exceptions, convert the raise into a call to\n+            --  lib$stop so it will be handled by __gnat_error_handler.\n+\n+            if Is_VMS_Exception (Id) then\n+               declare\n+                  Excep_Image : String_Id;\n+                  Cond        : Node_Id;\n+\n+               begin\n+                  if Present (Interface_Name (Id)) then\n+                     Excep_Image := Strval (Interface_Name (Id));\n+                  else\n+                     Get_Name_String (Chars (Id));\n+                     Set_All_Upper_Case;\n+                     Excep_Image := String_From_Name_Buffer;\n+                  end if;\n+\n+                  if Exception_Code (Id) /= No_Uint then\n+                     Cond :=\n+                       Make_Integer_Literal (Loc, Exception_Code (Id));\n+                  else\n+                     Cond :=\n+                       Unchecked_Convert_To (Standard_Integer,\n+                         Make_Function_Call (Loc,\n+                           Name => New_Occurrence_Of\n+                             (RTE (RE_Import_Value), Loc),\n+                           Parameter_Associations => New_List\n+                             (Make_String_Literal (Loc,\n+                               Strval => Excep_Image))));\n+                  end if;\n+\n+                  Rewrite (N,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Occurrence_Of (RTE (RE_Lib_Stop), Loc),\n+                      Parameter_Associations => New_List (Cond)));\n+                        Analyze_And_Resolve (Cond, Standard_Integer);\n+               end;\n+\n+            --  Not VMS exception case, convert raise to call to the\n+            --  Raise_Exception routine.\n+\n+            else\n+               Rewrite (N,\n+                 Make_Procedure_Call_Statement (Loc,\n+                    Name => New_Occurrence_Of (RTE (RE_Raise_Exception), Loc),\n+                    Parameter_Associations => New_List (\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix => Name (N),\n+                        Attribute_Name => Name_Identity),\n+                      Make_String_Literal (Loc,\n+                        Strval => Str))));\n+            end if;\n+         end;\n+\n+      --  Case of no name present (reraise). We rewrite the raise to:\n+\n+      --    Reraise_Occurrence_Always (EO);\n+\n+      --  where EO is the current exception occurrence. If the current handler\n+      --  does not have a choice parameter specification, then we provide one.\n+\n+      else\n+         --  Find innermost enclosing exception handler (there must be one,\n+         --  since the semantics has already verified that this raise statement\n+         --  is valid, and a raise with no arguments is only permitted in the\n+         --  context of an exception handler.\n+\n+         Ehand := Parent (N);\n+         while Nkind (Ehand) /= N_Exception_Handler loop\n+            Ehand := Parent (Ehand);\n+         end loop;\n+\n+         --  Make exception choice parameter if none present. Note that we do\n+         --  not need to put the entity on the entity chain, since no one will\n+         --  be referencing this entity by normal visibility methods.\n+\n+         if No (Choice_Parameter (Ehand)) then\n+            E := Make_Defining_Identifier (Loc, New_Internal_Name ('E'));\n+            Set_Choice_Parameter (Ehand, E);\n+            Set_Ekind (E, E_Variable);\n+            Set_Etype (E, RTE (RE_Exception_Occurrence));\n+            Set_Scope (E, Current_Scope);\n+         end if;\n+\n+         --  Now rewrite the raise as a call to Reraise. A special case arises\n+         --  if this raise statement occurs in the context of a handler for\n+         --  all others (i.e. an at end handler). in this case we avoid\n+         --  the call to defer abort, cleanup routines are expected to be\n+         --  called in this case with aborts deferred.\n+\n+         declare\n+            Ech : constant Node_Id := First (Exception_Choices (Ehand));\n+            Ent : Entity_Id;\n+\n+         begin\n+            if Nkind (Ech) = N_Others_Choice\n+              and then All_Others (Ech)\n+            then\n+               Ent := RTE (RE_Reraise_Occurrence_No_Defer);\n+            else\n+               Ent := RTE (RE_Reraise_Occurrence_Always);\n+            end if;\n+\n+            Rewrite (N,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Occurrence_Of (Ent, Loc),\n+                Parameter_Associations => New_List (\n+                  New_Occurrence_Of (Choice_Parameter (Ehand), Loc))));\n+         end;\n+      end if;\n+\n+      Analyze (N);\n+   end Expand_N_Raise_Statement;\n+\n+   ----------------------------------\n+   -- Expand_N_Raise_Storage_Error --\n+   ----------------------------------\n+\n+   --  The only processing required is to adjust the condition to deal\n+   --  with the C/Fortran boolean case. This may well not be necessary,\n+   --  as all such conditions are generated by the expander and probably\n+   --  are all standard boolean, but who knows what strange optimization\n+   --  in future may require this adjustment!\n+\n+   procedure Expand_N_Raise_Storage_Error (N : Node_Id) is\n+   begin\n+      Adjust_Condition (Condition (N));\n+   end Expand_N_Raise_Storage_Error;\n+\n+   ------------------------------\n+   -- Expand_N_Subprogram_Info --\n+   ------------------------------\n+\n+   procedure Expand_N_Subprogram_Info (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+   begin\n+      --  For now, we replace an Expand_N_Subprogram_Info node with an\n+      --  attribute reference that gives the address of the procedure.\n+      --  This is because gigi does not yet recognize this node, and\n+      --  for the initial targets, this is the right value anyway.\n+\n+      Rewrite (N,\n+        Make_Attribute_Reference (Loc,\n+          Prefix => Identifier (N),\n+          Attribute_Name => Name_Code_Address));\n+\n+      Analyze_And_Resolve (N, RTE (RE_Code_Loc));\n+   end Expand_N_Subprogram_Info;\n+\n+   ------------------------------------\n+   -- Generate_Subprogram_Descriptor --\n+   ------------------------------------\n+\n+   procedure Generate_Subprogram_Descriptor\n+     (N     : Node_Id;\n+      Loc   : Source_Ptr;\n+      Spec  : Entity_Id;\n+      Slist : List_Id)\n+   is\n+      Code  : Node_Id;\n+      Ent   : Entity_Id;\n+      Decl  : Node_Id;\n+      Dtyp  : Entity_Id;\n+      Numh  : Nat;\n+      Sdes  : Node_Id;\n+      Hrc   : List_Id;\n+\n+   begin\n+      if Exception_Mechanism /= Front_End_ZCX then\n+         return;\n+      end if;\n+\n+      --  Suppress descriptor if we are not generating code. This happens\n+      --  in the case of a -gnatc -gnatt compilation where we force generics\n+      --  to be generated, but we still don't want exception tables.\n+\n+      if Operating_Mode /= Generate_Code then\n+         return;\n+      end if;\n+\n+      --  Suppress descriptor if we are in No_Exceptions restrictions mode,\n+      --  since we can never propagate exceptions in any case in this mode.\n+      --  The same consideration applies for No_Exception_Handlers (which\n+      --   is also set in No_Run_Time mode).\n+\n+      if Restrictions (No_Exceptions)\n+        or Restrictions (No_Exception_Handlers)\n+      then\n+         return;\n+      end if;\n+\n+      --  Suppress descriptor if we are inside a generic. There are two\n+      --  ways that we can tell that, depending on what is going on. If\n+      --  we are actually inside the processing for a generic right now,\n+      --  then Expander_Active will be reset. If we are outside the\n+      --  generic, then we will see the generic entity.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n+      --  Suppress descriptor is subprogram is marked as eliminated, for\n+      --  example if this is a subprogram created to analyze a default\n+      --  expression with potential side effects. Ditto if it is nested\n+      --  within an eliminated subprogram, for example a cleanup action.\n+\n+      declare\n+         Scop : Entity_Id;\n+\n+      begin\n+         Scop := Spec;\n+         while Scop /= Standard_Standard loop\n+            if Ekind (Scop) = E_Generic_Procedure\n+                 or else\n+               Ekind (Scop) = E_Generic_Function\n+                 or else\n+               Ekind (Scop) = E_Generic_Package\n+                 or else\n+               Is_Eliminated (Scop)\n+            then\n+               return;\n+            end if;\n+\n+            Scop := Scope (Scop);\n+         end loop;\n+      end;\n+\n+      --  Suppress descriptor for original protected subprogram (we will\n+      --  be called again later to generate the descriptor for the actual\n+      --  protected body subprogram.) This does not apply to barrier\n+      --  functions which are there own protected subprogram.\n+\n+      if Is_Subprogram (Spec)\n+        and then Present (Protected_Body_Subprogram (Spec))\n+        and then Protected_Body_Subprogram (Spec) /= Spec\n+      then\n+         return;\n+      end if;\n+\n+      --  Suppress descriptors for packages unless they have at least one\n+      --  handler. The binder will generate the dummy (no handler) descriptors\n+      --  for elaboration procedures. We can't do it here, because we don't\n+      --  know if an elaboration routine does in fact exist.\n+\n+      --  If there is at least one handler for the package spec or body\n+      --  then most certainly an elaboration routine must exist, so we\n+      --  can safely reference it.\n+\n+      if (Nkind (N) = N_Package_Declaration\n+            or else\n+          Nkind (N) = N_Package_Body)\n+        and then No (Handler_Records (Spec))\n+      then\n+         return;\n+      end if;\n+\n+      --  Suppress all subprogram descriptors for the file System.Exceptions.\n+      --  We similarly suppress subprogram descriptors for Ada.Exceptions.\n+      --  These are all init_proc's for types which cannot raise exceptions.\n+      --  The reason this is done is that otherwise we get embarassing\n+      --  elaboration dependencies.\n+\n+      Get_Name_String (Unit_File_Name (Current_Sem_Unit));\n+\n+      if Name_Buffer (1 .. 12) = \"s-except.ads\"\n+           or else\n+         Name_Buffer (1 .. 12) = \"a-except.ads\"\n+      then\n+         return;\n+      end if;\n+\n+      --  Similarly, we need to suppress entries for System.Standard_Library,\n+      --  since otherwise we get elaboration circularities. Again, this would\n+      --  better be done with a Suppress_Initialization pragma :-)\n+\n+      if Name_Buffer (1 .. 11) = \"s-stalib.ad\" then\n+         return;\n+      end if;\n+\n+      --  For now, also suppress entries for s-stoele because we have\n+      --  some kind of unexplained error there ???\n+\n+      if Name_Buffer (1 .. 11) = \"s-stoele.ad\" then\n+         return;\n+      end if;\n+\n+      --  And also for g-htable, because it cannot raise exceptions,\n+      --  and generates some kind of elaboration order problem.\n+\n+      if Name_Buffer (1 .. 11) = \"g-htable.ad\" then\n+         return;\n+      end if;\n+\n+      --  Suppress subprogram descriptor if already generated. This happens\n+      --  in the case of late generation from Delay_Subprogram_Descriptors\n+      --  beging set (where there is more than one instantiation in the list)\n+\n+      if Has_Subprogram_Descriptor (Spec) then\n+         return;\n+      else\n+         Set_Has_Subprogram_Descriptor (Spec);\n+      end if;\n+\n+      --  Never generate descriptors for inlined bodies\n+\n+      if Analyzing_Inlined_Bodies then\n+         return;\n+      end if;\n+\n+      --  Here we definitely are going to generate a subprogram descriptor\n+\n+      declare\n+         Hnum : Nat := Homonym_Number (Spec);\n+\n+      begin\n+         if Hnum = 1 then\n+            Hnum := 0;\n+         end if;\n+\n+         Ent :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Spec), \"SD\", Hnum));\n+      end;\n+\n+      if No (Handler_Records (Spec)) then\n+         Hrc  := Empty_List;\n+         Numh := 0;\n+      else\n+         Hrc  := Handler_Records (Spec);\n+         Numh := List_Length (Hrc);\n+      end if;\n+\n+      New_Scope (Spec);\n+\n+      --  We need a static subtype for the declaration of the subprogram\n+      --  descriptor. For the case of 0-3 handlers we can use one of the\n+      --  predefined subtypes in System.Exceptions. For more handlers,\n+      --  we build our own subtype here.\n+\n+      case Numh is\n+         when 0 =>\n+            Dtyp := RTE (RE_Subprogram_Descriptor_0);\n+\n+         when 1 =>\n+            Dtyp := RTE (RE_Subprogram_Descriptor_1);\n+\n+         when 2 =>\n+            Dtyp := RTE (RE_Subprogram_Descriptor_2);\n+\n+         when 3 =>\n+            Dtyp := RTE (RE_Subprogram_Descriptor_3);\n+\n+         when others =>\n+            Dtyp :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('T'));\n+\n+            --  Set the constructed type as global, since we wil be\n+            --  referencing the object that is of this type globally\n+\n+            Set_Is_Statically_Allocated (Dtyp);\n+\n+            Decl :=\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => Dtyp,\n+                Subtype_Indication =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Occurrence_Of (RTE (RE_Subprogram_Descriptor), Loc),\n+                    Constraint =>\n+                      Make_Index_Or_Discriminant_Constraint (Loc,\n+                        Constraints => New_List (\n+                          Make_Integer_Literal (Loc, Numh)))));\n+\n+            Append (Decl, Slist);\n+\n+            --  We analyze the descriptor for the subprogram and package\n+            --  case, but not for the imported subprogram case (it will\n+            --  be analyzed when the freeze entity actions are analyzed.\n+\n+            if Present (N) then\n+               Analyze (Decl);\n+            end if;\n+\n+            Set_Exception_Junk (Decl);\n+      end case;\n+\n+      --  Prepare the code address entry for the table entry. For the normal\n+      --  case of being within a procedure, this is simply:\n+\n+      --    P'Code_Address\n+\n+      --  where P is the procedure, but for the package case, it is\n+\n+      --    P'Elab_Body'Code_Address\n+      --    P'Elab_Spec'Code_Address\n+\n+      --  for the body and spec respectively. Note that we do our own\n+      --  analysis of these attribute references, because we know in this\n+      --  case that the prefix of ELab_Body/Spec is a visible package,\n+      --  which can be referenced directly instead of using the general\n+      --  case expansion for these attributes.\n+\n+      if Ekind (Spec) = E_Package then\n+         Code :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Spec, Loc),\n+             Attribute_Name => Name_Elab_Spec);\n+         Set_Etype (Code, Standard_Void_Type);\n+         Set_Analyzed (Code);\n+\n+      elsif Ekind (Spec) = E_Package_Body then\n+         Code :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Spec_Entity (Spec), Loc),\n+             Attribute_Name => Name_Elab_Body);\n+         Set_Etype (Code, Standard_Void_Type);\n+         Set_Analyzed (Code);\n+\n+      else\n+         Code := New_Occurrence_Of (Spec, Loc);\n+      end if;\n+\n+      Code :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix         => Code,\n+          Attribute_Name => Name_Code_Address);\n+\n+      Set_Etype (Code, RTE (RE_Address));\n+      Set_Analyzed (Code);\n+\n+      --  Now we can build the subprogram descriptor\n+\n+      Sdes :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier      => Ent,\n+          Constant_Present         => True,\n+          Aliased_Present          => True,\n+          Object_Definition        => New_Occurrence_Of (Dtyp, Loc),\n+\n+          Expression               =>\n+            Make_Aggregate (Loc,\n+              Expressions => New_List (\n+                Make_Integer_Literal (Loc, Numh),          -- Num_Handlers\n+\n+                Code,                                      -- Code\n+\n+--  temp code ???\n+\n+--                Make_Subprogram_Info (Loc,                 -- Subprogram_Info\n+--                  Identifier =>\n+--                    New_Occurrence_Of (Spec, Loc)),\n+\n+                New_Copy_Tree (Code),\n+\n+                Make_Aggregate (Loc,                       -- Handler_Records\n+                  Expressions => Hrc))));\n+\n+      Set_Exception_Junk (Sdes);\n+      Set_Is_Subprogram_Descriptor (Sdes);\n+\n+      Append (Sdes, Slist);\n+\n+      --  We analyze the descriptor for the subprogram and package case,\n+      --  but not for the imported subprogram case (it will be analyzed\n+      --  when the freeze entity actions are analyzed.\n+\n+      if Present (N) then\n+         Analyze (Sdes);\n+      end if;\n+\n+      --  We can now pop the scope used for analyzing the descriptor\n+\n+      Pop_Scope;\n+\n+      --  We need to set the descriptor as statically allocated, since\n+      --  it will be referenced from the unit exception table.\n+\n+      Set_Is_Statically_Allocated (Ent);\n+\n+      --  Append the resulting descriptor to the list. We do this only\n+      --  if we are in the main unit. You might think that we could\n+      --  simply skip generating the descriptors completely if we are\n+      --  not in the main unit, but in fact this is not the case, since\n+      --  we have problems with inconsistent serial numbers for internal\n+      --  names if we do this.\n+\n+      if In_Extended_Main_Code_Unit (Spec) then\n+         Append_To (SD_List,\n+           Make_Attribute_Reference (Loc,\n+             Prefix => New_Occurrence_Of (Ent, Loc),\n+             Attribute_Name => Name_Unrestricted_Access));\n+\n+         Unit_Exception_Table_Present := True;\n+      end if;\n+\n+   end Generate_Subprogram_Descriptor;\n+\n+   ------------------------------------------------------------\n+   -- Generate_Subprogram_Descriptor_For_Imported_Subprogram --\n+   ------------------------------------------------------------\n+\n+   procedure Generate_Subprogram_Descriptor_For_Imported_Subprogram\n+     (Spec  : Entity_Id;\n+      Slist : List_Id)\n+   is\n+   begin\n+      Generate_Subprogram_Descriptor (Empty, Sloc (Spec), Spec, Slist);\n+   end Generate_Subprogram_Descriptor_For_Imported_Subprogram;\n+\n+   ------------------------------------------------\n+   -- Generate_Subprogram_Descriptor_For_Package --\n+   ------------------------------------------------\n+\n+   procedure Generate_Subprogram_Descriptor_For_Package\n+     (N    : Node_Id;\n+      Spec : Entity_Id)\n+   is\n+      Adecl : Node_Id;\n+\n+   begin\n+      Adecl := Aux_Decls_Node (Parent (N));\n+\n+      if No (Actions (Adecl)) then\n+         Set_Actions (Adecl, New_List);\n+      end if;\n+\n+      Generate_Subprogram_Descriptor (N, Sloc (N), Spec, Actions (Adecl));\n+   end Generate_Subprogram_Descriptor_For_Package;\n+\n+   ---------------------------------------------------\n+   -- Generate_Subprogram_Descriptor_For_Subprogram --\n+   ---------------------------------------------------\n+\n+   procedure Generate_Subprogram_Descriptor_For_Subprogram\n+     (N    : Node_Id;\n+      Spec : Entity_Id)\n+   is\n+      HSS : constant Node_Id := Handled_Statement_Sequence (N);\n+\n+   begin\n+      if No (Exception_Handlers (HSS)) then\n+         Generate_Subprogram_Descriptor\n+           (N, Sloc (N), Spec, Statements (HSS));\n+      else\n+         Generate_Subprogram_Descriptor\n+           (N, Sloc (N), Spec, Statements (Last (Exception_Handlers (HSS))));\n+      end if;\n+   end Generate_Subprogram_Descriptor_For_Subprogram;\n+\n+   -----------------------------------\n+   -- Generate_Unit_Exception_Table --\n+   -----------------------------------\n+\n+   --  The only remaining thing to generate here is to generate the\n+   --  reference to the subprogram descriptor chain. See Ada.Exceptions\n+   --  for details of required data structures.\n+\n+   procedure Generate_Unit_Exception_Table is\n+      Loc      : constant Source_Ptr := No_Location;\n+      Num      : Nat;\n+      Decl     : Node_Id;\n+      Ent      : Entity_Id;\n+      Next_Ent : Entity_Id;\n+      Stent    : Entity_Id;\n+\n+   begin\n+      --  Nothing to be done if zero length exceptions not active\n+\n+      if Exception_Mechanism /= Front_End_ZCX then\n+         return;\n+      end if;\n+\n+      --  Remove any entries from SD_List that correspond to eliminated\n+      --  subprograms.\n+\n+      Ent := First (SD_List);\n+      while Present (Ent) loop\n+         Next_Ent := Next (Ent);\n+         if Is_Eliminated (Scope (Entity (Prefix (Ent)))) then\n+            Remove (Ent); -- After this, there is no Next (Ent) anymore\n+         end if;\n+\n+         Ent := Next_Ent;\n+      end loop;\n+\n+      --  Nothing to do if no unit exception table present.\n+      --  An empty table can result from subprogram elimination,\n+      --  in such a case, eliminate the exception table itself.\n+\n+      if Is_Empty_List (SD_List) then\n+         Unit_Exception_Table_Present := False;\n+         return;\n+      end if;\n+\n+      --  Do not generate table in a generic\n+\n+      if Inside_A_Generic then\n+         return;\n+      end if;\n+\n+      --  Generate the unit exception table\n+\n+      --    subtype Tnn is Subprogram_Descriptors_Record (Num);\n+      --    __gnat_unitname__SDP : aliased constant Tnn :=\n+      --                             Num,\n+      --                             (sub1'unrestricted_access,\n+      --                              sub2'unrestricted_access,\n+      --                              ...\n+      --                              subNum'unrestricted_access));\n+\n+      Num := List_Length (SD_List);\n+\n+      Stent :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('T'));\n+\n+      Insert_Library_Level_Action (\n+        Make_Subtype_Declaration (Loc,\n+          Defining_Identifier => Stent,\n+          Subtype_Indication =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark =>\n+                New_Occurrence_Of\n+                 (RTE (RE_Subprogram_Descriptors_Record), Loc),\n+              Constraint =>\n+                Make_Index_Or_Discriminant_Constraint (Loc,\n+                  Constraints => New_List (\n+                    Make_Integer_Literal (Loc, Num))))));\n+\n+      Set_Is_Statically_Allocated (Stent);\n+\n+      Get_External_Unit_Name_String (Unit_Name (Main_Unit));\n+      Name_Buffer (1 + 7 .. Name_Len + 7) := Name_Buffer (1 .. Name_Len);\n+      Name_Buffer (1 .. 7) := \"__gnat_\";\n+      Name_Len := Name_Len + 7;\n+      Add_Str_To_Name_Buffer (\"__SDP\");\n+\n+      Ent :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => Name_Find);\n+\n+      Get_Name_String (Chars (Ent));\n+      Set_Interface_Name (Ent,\n+        Make_String_Literal (Loc, Strval => String_From_Name_Buffer));\n+\n+      Decl :=\n+        Make_Object_Declaration (Loc,\n+             Defining_Identifier => Ent,\n+             Object_Definition   => New_Occurrence_Of (Stent, Loc),\n+          Constant_Present => True,\n+          Aliased_Present  => True,\n+          Expression =>\n+            Make_Aggregate (Loc,\n+              New_List (\n+                Make_Integer_Literal (Loc, List_Length (SD_List)),\n+\n+              Make_Aggregate (Loc,\n+                Expressions => SD_List))));\n+\n+      Insert_Library_Level_Action (Decl);\n+\n+      Set_Is_Exported             (Ent, True);\n+      Set_Is_Public               (Ent, True);\n+      Set_Is_Statically_Allocated (Ent, True);\n+\n+      Get_Name_String (Chars (Ent));\n+      Set_Interface_Name (Ent,\n+        Make_String_Literal (Loc,\n+          Strval => String_From_Name_Buffer));\n+\n+   end Generate_Unit_Exception_Table;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      SD_List := Empty_List;\n+   end Initialize;\n+\n+   ----------------------\n+   -- Is_Non_Ada_Error --\n+   ----------------------\n+\n+   function Is_Non_Ada_Error (E : Entity_Id) return Boolean is\n+   begin\n+      if not OpenVMS_On_Target then\n+         return False;\n+      end if;\n+\n+      Get_Name_String (Chars (E));\n+\n+      --  Note: it is a little irregular for the body of exp_ch11 to know\n+      --  the details of the encoding scheme for names, but on the other\n+      --  hand, gigi knows them, and this is for gigi's benefit anyway!\n+\n+      if Name_Buffer (1 .. 30) /= \"system__aux_dec__non_ada_error\" then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Is_Non_Ada_Error;\n+\n+   ----------------------------\n+   -- Remove_Handler_Entries --\n+   ----------------------------\n+\n+   procedure Remove_Handler_Entries (N : Node_Id) is\n+      function Check_Handler_Entry (N : Node_Id) return Traverse_Result;\n+      --  This function checks one node for a possible reference to a\n+      --  handler entry that must be deleted. it always returns OK.\n+\n+      function Remove_All_Handler_Entries is new\n+        Traverse_Func (Check_Handler_Entry);\n+      --  This defines the traversal operation\n+\n+      Discard : Traverse_Result;\n+\n+      function Check_Handler_Entry (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Object_Declaration then\n+\n+            if Present (Handler_List_Entry (N)) then\n+               Remove (Handler_List_Entry (N));\n+               Delete_Tree (Handler_List_Entry (N));\n+               Set_Handler_List_Entry (N, Empty);\n+\n+            elsif Is_Subprogram_Descriptor (N) then\n+               declare\n+                  SDN : Node_Id;\n+\n+               begin\n+                  SDN := First (SD_List);\n+                  while Present (SDN) loop\n+                     if Defining_Identifier (N) = Entity (Prefix (SDN)) then\n+                        Remove (SDN);\n+                        Delete_Tree (SDN);\n+                        exit;\n+                     end if;\n+\n+                     Next (SDN);\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Check_Handler_Entry;\n+\n+   --  Start of processing for Remove_Handler_Entries\n+\n+   begin\n+      if Exception_Mechanism = Front_End_ZCX then\n+         Discard := Remove_All_Handler_Entries (N);\n+      end if;\n+   end Remove_Handler_Entries;\n+\n+end Exp_Ch11;"}, {"sha": "56af9a49e4289e8a531b37956954fad002c76897", "filename": "gcc/ada/exp_ch11.ads", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,119 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 1                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.25 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for chapter 11 constructs\n+\n+with Types; use Types;\n+\n+package Exp_Ch11 is\n+   procedure Expand_N_Exception_Declaration          (N : Node_Id);\n+   procedure Expand_N_Handled_Sequence_Of_Statements (N : Node_Id);\n+   procedure Expand_N_Raise_Constraint_Error         (N : Node_Id);\n+   procedure Expand_N_Raise_Program_Error            (N : Node_Id);\n+   procedure Expand_N_Raise_Statement                (N : Node_Id);\n+   procedure Expand_N_Raise_Storage_Error            (N : Node_Id);\n+   procedure Expand_N_Subprogram_Info                (N : Node_Id);\n+\n+   --  Data structures for gathering information to build exception tables\n+   --  See runtime routine Ada.Exceptions for full details on the format and\n+   --  content of these tables.\n+\n+   procedure Initialize;\n+   --  Initializes these data structures for a new main unit file\n+\n+   procedure Expand_At_End_Handler (HSS : Node_Id; Block : Node_Id);\n+   --  Given a handled statement sequence, HSS, for which the At_End_Proc\n+   --  field is set, and which currently has no exception handlers, this\n+   --  procedure expands the special exception handler required.\n+   --  This procedure also create a new scope for the given Block, if\n+   --  Block is not Empty.\n+\n+   procedure Expand_Exception_Handlers (HSS : Node_Id);\n+   --  This procedure expands exception handlers, and is called as part\n+   --  of the processing for Expand_N_Handled_Sequence_Of_Statements and\n+   --  is also called from Expand_At_End_Handler. N is the handled sequence\n+   --  of statements that has the exception handler(s) to be expanded. This\n+   --  is also called to expand the special exception handler built for\n+   --  accept bodies (see Exp_Ch9.Build_Accept_Body).\n+\n+   procedure Generate_Unit_Exception_Table;\n+   --  Procedure called by main driver to generate unit exception table if\n+   --  zero cost exceptions are enabled. See System.Exceptions for details.\n+\n+   function Is_Non_Ada_Error (E : Entity_Id) return Boolean;\n+   --  This function is provided for Gigi use. It returns True if operating on\n+   --  VMS, and the argument E is the entity for System.Aux_Dec.Non_Ada_Error.\n+   --  This is used to generate the special matching code for this exception.\n+\n+   procedure Remove_Handler_Entries (N : Node_Id);\n+   --  This procedure is called when optimization circuits determine that\n+   --  an entire subtree can be removed. If the subtree contains handler\n+   --  entries in zero cost exception mode, then such removal can lead to\n+   --  dangling references to non-existent handlers in the handler table.\n+   --  This procedure removes such references.\n+\n+   --------------------------------------\n+   -- Subprogram_Descriptor Generation --\n+   --------------------------------------\n+\n+   --  Subprogram descriptors are required for all subprograms, including\n+   --  explicit subprograms defined in the program, subprograms that are\n+   --  imported via pragma Import, and also for the implicit elaboration\n+   --  subprograms used to elaborate package specs and bodies.\n+\n+   procedure Generate_Subprogram_Descriptor_For_Package\n+     (N    : Node_Id;\n+      Spec : Entity_Id);\n+   --  This is used to create a descriptor for the implicit elaboration\n+   --  procedure for a package spec of body. The compiler only generates\n+   --  such descriptors if the package spec or body contains exception\n+   --  handlers (either explicitly in the case of a body, or from generic\n+   --  package instantiations). N is the node for the package body or\n+   --  spec, and Spec is the package body or package entity respectively.\n+   --  N must be a compilation unit, and the descriptor is placed at\n+   --  the end of the actions for the auxiliary compilation unit node.\n+\n+   procedure Generate_Subprogram_Descriptor_For_Subprogram\n+     (N    : Node_Id;\n+      Spec : Entity_Id);\n+   --  This is used to create a desriptor for a subprogram, both those\n+   --  present in the source, and those implicitly generated by code\n+   --  expansion. N is the subprogram body node, and Spec is the entity\n+   --  for the subprogram. The descriptor is placed at the end of the\n+   --  Last exception handler, or, if there are no handlers, at the end\n+   --  of the statement sequence.\n+\n+   procedure Generate_Subprogram_Descriptor_For_Imported_Subprogram\n+     (Spec  : Entity_Id;\n+      Slist : List_Id);\n+   --  This is used to create a descriptor for an imported subprogram.\n+   --  Such descriptors are needed for propagation of exceptions through\n+   --  such subprograms. The descriptor never references any handlers,\n+   --  and is appended to the given Slist.\n+\n+end Exp_Ch11;"}, {"sha": "fe1416f6761e3cdcfdf3ff804745de2f455c2747", "filename": "gcc/ada/exp_ch12.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch12.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 2                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Checks;   use Checks;\n+with Einfo;    use Einfo;\n+with Exp_Util; use Exp_Util;\n+with Nmake;    use Nmake;\n+with Sinfo;    use Sinfo;\n+with Stand;    use Stand;\n+with Tbuild;   use Tbuild;\n+\n+package body Exp_Ch12 is\n+\n+   ------------------------------------\n+   -- Expand_N_Generic_Instantiation --\n+   ------------------------------------\n+\n+   --  If elaboration entity is defined and this is not an outer level entity,\n+   --  we need to generate a check for it here.\n+\n+   procedure Expand_N_Generic_Instantiation (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Ent : constant Entity_Id  := Entity (Name (N));\n+\n+   begin\n+      if Etype (Name (N)) = Any_Type then\n+         return;\n+      end if;\n+\n+      if Present (Elaboration_Entity (Ent))\n+        and then not Is_Compilation_Unit (Ent)\n+        and then not Elaboration_Checks_Suppressed (Ent)\n+      then\n+         Insert_Action (Instance_Spec (N),\n+           Make_Raise_Program_Error (Loc,\n+             Condition =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd =>\n+                   New_Occurrence_Of (Elaboration_Entity (Ent), Loc))));\n+      end if;\n+   end Expand_N_Generic_Instantiation;\n+\n+end Exp_Ch12;"}, {"sha": "2cbc4e71b0c955b564b4a826a6058d7be59bdfae", "filename": "gcc/ada/exp_ch12.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch12.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,35 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 2                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for chapter 12 constructs\n+\n+with Types; use Types;\n+\n+package Exp_Ch12 is\n+   procedure Expand_N_Generic_Instantiation (N : Node_Id);\n+end Exp_Ch12;"}, {"sha": "6e57f3beb77f32495aa15d3b3915dcfaccf458f3", "filename": "gcc/ada/exp_ch13.adb", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,425 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 3                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.76 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Imgv; use Exp_Imgv;\n+with Exp_Util; use Exp_Util;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Ch7;  use Sem_Ch7;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+\n+package body Exp_Ch13 is\n+\n+   ------------------------------------------\n+   -- Expand_N_Attribute_Definition_Clause --\n+   ------------------------------------------\n+\n+   --  Expansion action depends on attribute involved\n+\n+   procedure Expand_N_Attribute_Definition_Clause (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Exp : constant Node_Id    := Expression (N);\n+      Ent : Entity_Id;\n+      V   : Node_Id;\n+\n+   begin\n+      Ent := Entity (Name (N));\n+\n+      if Is_Type (Ent) then\n+         Ent := Underlying_Type (Ent);\n+      end if;\n+\n+      case Get_Attribute_Id (Chars (N)) is\n+\n+         -------------\n+         -- Address --\n+         -------------\n+\n+         when Attribute_Address =>\n+\n+            --  If there is an initialization which did not come from\n+            --  the source program, then it is an artifact of our\n+            --  expansion, and we suppress it. The case we are most\n+            --  concerned about here is the initialization of a packed\n+            --  array to all false, which seems inappropriate for a\n+            --  variable to which an address clause is applied. The\n+            --  expression may itself have been rewritten if the type is a\n+            --  packed array, so we need to examine whether the original\n+            --  node is in the source.\n+\n+            declare\n+               Decl : constant Node_Id := Declaration_Node (Ent);\n+\n+            begin\n+               if Nkind (Decl) = N_Object_Declaration\n+                  and then Present (Expression (Decl))\n+                  and then\n+                   not Comes_From_Source (Original_Node (Expression (Decl)))\n+               then\n+                  Set_Expression (Decl, Empty);\n+               end if;\n+            end;\n+\n+         ---------------\n+         -- Alignment --\n+         ---------------\n+\n+         when Attribute_Alignment =>\n+\n+            --  As required by Gigi, we guarantee that the operand is an\n+            --  integer literal (this simplifies things in Gigi).\n+\n+            if Nkind (Exp) /= N_Integer_Literal then\n+               Rewrite\n+                 (Exp, Make_Integer_Literal (Loc, Expr_Value (Exp)));\n+            end if;\n+\n+         ------------------\n+         -- External_Tag --\n+         ------------------\n+\n+         --  For the rep clause \"for x'external_tag use y\" generate:\n+\n+         --     xV : constant string := y;\n+         --     Set_External_Tag (x'tag, xV'Address);\n+         --     Register_Tag (x'tag);\n+\n+         --  note that register_tag has been delayed up to now because\n+         --  the external_tag must be set before resistering.\n+\n+         when Attribute_External_Tag => External_Tag : declare\n+            E       : Entity_Id;\n+            Old_Val : String_Id := Strval (Expr_Value_S (Exp));\n+            New_Val : String_Id;\n+\n+         begin\n+            --  Create a new nul terminated string if it is not already\n+\n+            if String_Length (Old_Val) > 0\n+              and then Get_String_Char (Old_Val, String_Length (Old_Val)) = 0\n+            then\n+               New_Val := Old_Val;\n+            else\n+               Start_String (Old_Val);\n+               Store_String_Char (Get_Char_Code (ASCII.NUL));\n+               New_Val := End_String;\n+            end if;\n+\n+            E :=\n+              Make_Defining_Identifier (Loc,\n+                New_External_Name (Chars (Ent), 'A'));\n+\n+            Insert_Action (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => E,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Reference_To (Standard_String, Loc),\n+                Expression          =>\n+                  Make_String_Literal (Loc, Strval => New_Val)));\n+\n+            Insert_Actions (N, New_List (\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Set_External_Tag), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Attribute_Name => Name_Tag,\n+                    Prefix         => New_Occurrence_Of (Ent, Loc)),\n+\n+                  Make_Attribute_Reference (Loc,\n+                    Attribute_Name => Name_Address,\n+                    Prefix         => New_Occurrence_Of (E, Loc)))),\n+\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Register_Tag), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Attribute_Name => Name_Tag,\n+                    Prefix         => New_Occurrence_Of (Ent, Loc))))));\n+         end External_Tag;\n+\n+         ------------------\n+         -- Storage_Size --\n+         ------------------\n+\n+         when Attribute_Storage_Size =>\n+\n+            --  If the type is a task type, then assign the value of the\n+            --  storage size to the Size variable associated with the task.\n+            --    task_typeZ := expression\n+\n+            if Ekind (Ent) = E_Task_Type then\n+               Insert_Action (N,\n+                 Make_Assignment_Statement (Loc,\n+                   Name => New_Reference_To (Storage_Size_Variable (Ent), Loc),\n+                   Expression =>\n+                     Convert_To (RTE (RE_Size_Type), Expression (N))));\n+\n+            --  For Storage_Size for an access type, create a variable to hold\n+            --  the value of the specified size with name typeV and expand an\n+            --  assignment statement to initialze this value.\n+\n+            elsif Is_Access_Type (Ent) then\n+\n+               V := Make_Defining_Identifier (Loc,\n+                      New_External_Name (Chars (Ent), 'V'));\n+\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => V,\n+                   Object_Definition  =>\n+                     New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+                   Expression =>\n+                     Convert_To (RTE (RE_Storage_Offset), Expression (N))));\n+\n+               Set_Storage_Size_Variable (Ent, Entity_Id (V));\n+            end if;\n+\n+         --  Other attributes require no expansion\n+\n+         when others =>\n+            null;\n+\n+      end case;\n+\n+   end Expand_N_Attribute_Definition_Clause;\n+\n+   ----------------------------\n+   -- Expand_N_Freeze_Entity --\n+   ----------------------------\n+\n+   procedure Expand_N_Freeze_Entity (N : Node_Id) is\n+      E              : constant Entity_Id := Entity (N);\n+      E_Scope        : Entity_Id;\n+      S              : Entity_Id;\n+      In_Other_Scope : Boolean;\n+      In_Outer_Scope : Boolean;\n+      Decl           : Node_Id;\n+\n+   begin\n+      if not Is_Type (E) and then not Is_Subprogram (E) then\n+         return;\n+      end if;\n+\n+      E_Scope := Scope (E);\n+\n+      --  If we are freezing entities defined in protected types, they\n+      --  belong in the enclosing scope, given that the original type\n+      --  has been expanded away. The same is true for entities in task types,\n+      --  in particular the parameter records of entries (Entities in bodies\n+      --  are all frozen within the body). If we are in the task body, this\n+      --  is a proper scope.\n+\n+      if Ekind (E_Scope) = E_Protected_Type\n+        or else (Ekind (E_Scope) = E_Task_Type\n+                   and then not Has_Completion (E_Scope))\n+      then\n+         E_Scope := Scope (E_Scope);\n+      end if;\n+\n+      S := Current_Scope;\n+      while S /= Standard_Standard and then S /= E_Scope loop\n+         S := Scope (S);\n+      end loop;\n+\n+      In_Other_Scope := not (S = E_Scope);\n+      In_Outer_Scope := (not In_Other_Scope) and then (S /= Current_Scope);\n+\n+      --  If the entity being frozen is defined in a scope that is not\n+      --  currently on the scope stack, we must establish the proper\n+      --  visibility before freezing the entity and related subprograms.\n+\n+      if In_Other_Scope then\n+         New_Scope (E_Scope);\n+         Install_Visible_Declarations (E_Scope);\n+\n+         if Ekind (E_Scope) = E_Package         or else\n+            Ekind (E_Scope) = E_Generic_Package or else\n+            Is_Protected_Type (E_Scope)         or else\n+            Is_Task_Type (E_Scope)\n+         then\n+            Install_Private_Declarations (E_Scope);\n+         end if;\n+\n+      --  If the entity is in an outer scope, then that scope needs to\n+      --  temporarily become the current scope so that operations created\n+      --  during type freezing will be declared in the right scope and\n+      --  can properly override any corresponding inherited operations.\n+\n+      elsif In_Outer_Scope then\n+         New_Scope (E_Scope);\n+      end if;\n+\n+      --  If type, freeze the type\n+\n+      if Is_Type (E) then\n+         Freeze_Type (N);\n+\n+         --  And for enumeration type, build the enumeration tables\n+\n+         if Is_Enumeration_Type (E) then\n+            Build_Enumeration_Image_Tables (E, N);\n+         end if;\n+\n+      --  If subprogram, freeze the subprogram\n+\n+      elsif Is_Subprogram (E) then\n+         Freeze_Subprogram (N);\n+\n+      --  No other entities require any front end freeze actions\n+\n+      else\n+         null;\n+      end if;\n+\n+      --  Analyze actions generated by freezing. The init_proc contains\n+      --  source expressions that may raise constraint_error, and the\n+      --  assignment procedure for complex types needs checks on individual\n+      --  component assignments, but all other freezing actions should be\n+      --  compiled with all checks off.\n+\n+      if Present (Actions (N)) then\n+         Decl := First (Actions (N));\n+\n+         while Present (Decl) loop\n+\n+            if Nkind (Decl) = N_Subprogram_Body\n+              and then (Chars (Defining_Entity (Decl)) = Name_uInit_Proc\n+                 or else Chars (Defining_Entity (Decl)) = Name_uAssign)\n+            then\n+               Analyze (Decl);\n+\n+            --  A subprogram body created for a renaming_as_body completes\n+            --  a previous declaration, which may be in a different scope.\n+            --  Establish the proper scope before analysis.\n+\n+            elsif Nkind (Decl) = N_Subprogram_Body\n+              and then Present (Corresponding_Spec (Decl))\n+              and then Scope (Corresponding_Spec (Decl)) /= Current_Scope\n+            then\n+               New_Scope (Scope (Corresponding_Spec (Decl)));\n+               Analyze (Decl, Suppress => All_Checks);\n+               Pop_Scope;\n+\n+            else\n+               Analyze (Decl, Suppress => All_Checks);\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end if;\n+\n+      if In_Other_Scope then\n+         if Ekind (Current_Scope) = E_Package then\n+            End_Package_Scope (E_Scope);\n+         else\n+            End_Scope;\n+         end if;\n+\n+      elsif In_Outer_Scope then\n+         Pop_Scope;\n+      end if;\n+   end Expand_N_Freeze_Entity;\n+\n+   -------------------------------------------\n+   -- Expand_N_Record_Representation_Clause --\n+   -------------------------------------------\n+\n+   --  The only expansion required is for the case of a mod clause present,\n+   --  which is removed, and translated into an alignment representation\n+   --  clause inserted immediately after the record rep clause with any\n+   --  initial pragmas inserted at the start of the component clause list.\n+\n+   procedure Expand_N_Record_Representation_Clause (N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Rectype : constant Entity_Id  := Entity (Identifier (N));\n+      Mod_Val : Uint;\n+      Citems  : List_Id;\n+      Repitem : Node_Id;\n+      AtM_Nod : Node_Id;\n+\n+   begin\n+      if Present (Mod_Clause (N)) then\n+         Mod_Val := Expr_Value (Expression (Mod_Clause (N)));\n+         Citems  := Pragmas_Before (Mod_Clause (N));\n+\n+         if Present (Citems) then\n+            Append_List_To (Citems, Component_Clauses (N));\n+            Set_Component_Clauses (N, Citems);\n+         end if;\n+\n+         AtM_Nod :=\n+           Make_Attribute_Definition_Clause (Loc,\n+             Name       => New_Reference_To (Base_Type (Rectype), Loc),\n+             Chars      => Name_Alignment,\n+             Expression => Make_Integer_Literal (Loc, Mod_Val));\n+\n+         Set_From_At_Mod (AtM_Nod);\n+         Insert_After (N, AtM_Nod);\n+         Set_Mod_Clause (N, Empty);\n+      end if;\n+\n+      --  If the record representation clause has no components, then\n+      --  completely remove it.  Note that we also have to remove\n+      --  ourself from the Rep Item list.\n+\n+      if Is_Empty_List (Component_Clauses (N)) then\n+         if First_Rep_Item (Rectype) = N then\n+            Set_First_Rep_Item (Rectype, Next_Rep_Item (N));\n+         else\n+            Repitem := First_Rep_Item (Rectype);\n+            while Present (Next_Rep_Item (Repitem)) loop\n+               if Next_Rep_Item (Repitem) = N then\n+                  Set_Next_Rep_Item (Repitem, Next_Rep_Item (N));\n+                  exit;\n+               end if;\n+\n+               Next_Rep_Item (Repitem);\n+            end loop;\n+         end if;\n+\n+         Rewrite (N,\n+           Make_Null_Statement (Loc));\n+      end if;\n+   end Expand_N_Record_Representation_Clause;\n+\n+end Exp_Ch13;"}, {"sha": "b68d197601f90d898ca15958750a8f52df40fb13", "filename": "gcc/ada/exp_ch13.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,39 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ C H 1 3                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.6 $                              --\n+--                                                                          --\n+--        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for chapter 13 constructs\n+\n+with Types; use Types;\n+\n+package Exp_Ch13 is\n+\n+   procedure Expand_N_Attribute_Definition_Clause  (N : Node_Id);\n+   procedure Expand_N_Freeze_Entity                (N : Node_Id);\n+   procedure Expand_N_Record_Representation_Clause (N : Node_Id);\n+\n+end Exp_Ch13;"}, {"sha": "1a0c903f8928da51ab37a06974dcb917d8fdc1b9", "filename": "gcc/ada/exp_ch2.adb", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,487 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              E X P _ C H 2                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.64 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Exp_Smem; use Exp_Smem;\n+with Exp_Util; use Exp_Util;\n+with Exp_VFpt; use Exp_VFpt;\n+with Nmake;    use Nmake;\n+with Sem;      use Sem;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Tbuild;   use Tbuild;\n+with Snames;   use Snames;\n+\n+package body Exp_Ch2 is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Expand_Discriminant (N : Node_Id);\n+   --  An occurence of a discriminant within a discriminated type is replaced\n+   --  with the corresponding discriminal, that is to say the formal parameter\n+   --  of the initialization procedure for the type that is associated with\n+   --  that particular discriminant. This replacement is not performed for\n+   --  discriminants of records that appear in constraints of component of the\n+   --  record, because Gigi uses the discriminant name to retrieve its value.\n+   --  In the other hand, it has to be performed for default expressions of\n+   --  components because they are used in the record init procedure. See\n+   --  Einfo for more details, and Exp_Ch3, Exp_Ch9 for examples of use.\n+   --  For discriminants of tasks and protected types, the transformation is\n+   --  more complex when it occurs within a default expression for an entry\n+   --  or protected operation. The corresponding default_expression_function\n+   --  has an additional parameter which is the target of an entry call, and\n+   --  the discriminant of the task must be replaced with a reference to the\n+   --  discriminant of that formal parameter.\n+\n+   procedure Expand_Entity_Reference (N : Node_Id);\n+   --  Common processing for expansion of identifiers and expanded names\n+\n+   procedure Expand_Entry_Index_Parameter (N : Node_Id);\n+   --  A reference to the identifier in the entry index specification\n+   --  of a protected entry body is modified to a reference to a constant\n+   --  definintion equal to the index of the entry family member being\n+   --  called. This constant is calculated as part of the elaboration\n+   --  of the expanded code for the body, and is calculated from the\n+   --  object-wide entry index returned by Next_Entry_Call.\n+\n+   procedure Expand_Entry_Parameter (N : Node_Id);\n+   --  A reference to an entry parameter is modified to be a reference to\n+   --  the corresponding component of the entry parameter record that is\n+   --  passed by the runtime to the accept body procedure\n+\n+   procedure Expand_Formal (N : Node_Id);\n+   --  A reference to a formal parameter of a protected subprogram is\n+   --  expanded to the corresponding formal of the unprotected procedure\n+   --  used to represent the protected subprogram within the protected object.\n+\n+   procedure Expand_Protected_Private (N : Node_Id);\n+   --  A reference to a private object of a protected type is expanded\n+   --  to a component selected from the record used to implement\n+   --  the protected object. Such a record is passed to all operations\n+   --  on a protected object in a parameter named _object. Such an object\n+   --  is a constant within a function, and a variable otherwise.\n+\n+   procedure Expand_Renaming (N : Node_Id);\n+   --  For renamings, just replace the identifier by the corresponding\n+   --  name expression. Note that this has been evaluated (see routine\n+   --  Exp_Ch8.Expand_N_Object_Renaming.Evaluate_Name) so this gives\n+   --  the correct renaming semantics.\n+\n+   -------------------------\n+   -- Expand_Discriminant --\n+   -------------------------\n+\n+   procedure Expand_Discriminant (N : Node_Id) is\n+      Scop     : constant Entity_Id := Scope (Entity (N));\n+      P        : Node_Id := N;\n+      Parent_P : Node_Id := Parent (P);\n+      In_Entry : Boolean := False;\n+\n+   begin\n+      --  The Incomplete_Or_Private_Kind happens while resolving the\n+      --  discriminant constraint involved in a derived full type,\n+      --  such as:\n+\n+      --    type D is private;\n+      --    type D(C : ...) is new T(C);\n+\n+      if Ekind (Scop) = E_Record_Type\n+        or Ekind (Scop) in Incomplete_Or_Private_Kind\n+      then\n+\n+         --  Find the origin by walking up the tree till the component\n+         --  declaration\n+\n+         while Present (Parent_P)\n+           and then Nkind (Parent_P) /= N_Component_Declaration\n+         loop\n+            P := Parent_P;\n+            Parent_P := Parent (P);\n+         end loop;\n+\n+         --  If the discriminant reference was part of the default expression\n+         --  it has to be \"discriminalized\"\n+\n+         if Present (Parent_P) and then P = Expression (Parent_P) then\n+            Set_Entity (N, Discriminal (Entity (N)));\n+         end if;\n+\n+      elsif Is_Concurrent_Type (Scop) then\n+         while Present (Parent_P)\n+           and then Nkind (Parent_P) /= N_Subprogram_Body\n+         loop\n+            P := Parent_P;\n+\n+            if Nkind (P) = N_Entry_Declaration then\n+               In_Entry := True;\n+            end if;\n+\n+            Parent_P := Parent (Parent_P);\n+         end loop;\n+\n+         --  If the discriminant occurs within the default expression for\n+         --  a formal of an entry or protected operation, create a default\n+         --  function for it, and replace the discriminant with a reference\n+         --  to the discriminant of the formal of the default function.\n+         --  The discriminant entity is the one defined in the corresponding\n+         --  record.\n+\n+         if Present (Parent_P)\n+           and then Present (Corresponding_Spec (Parent_P))\n+         then\n+\n+            declare\n+               Loc    : constant Source_Ptr := Sloc (N);\n+               D_Fun  : Entity_Id := Corresponding_Spec  (Parent_P);\n+               Formal : Entity_Id := First_Formal (D_Fun);\n+               New_N  : Node_Id;\n+               Disc   : Entity_Id;\n+\n+            begin\n+               --  Verify that we are within a default function: the type of\n+               --  its formal parameter is the same task or protected type.\n+\n+               if Present (Formal)\n+                 and then Etype (Formal) = Scope (Entity (N))\n+               then\n+                  Disc := CR_Discriminant (Entity (N));\n+\n+                  New_N :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix => New_Occurrence_Of (Formal, Loc),\n+                      Selector_Name => New_Occurrence_Of (Disc, Loc));\n+\n+                  Set_Etype (New_N, Etype (N));\n+                  Rewrite (N, New_N);\n+\n+               else\n+                  Set_Entity (N, Discriminal (Entity (N)));\n+               end if;\n+            end;\n+\n+         elsif Nkind (Parent (N)) = N_Range\n+           and then In_Entry\n+         then\n+            Set_Entity (N, CR_Discriminant (Entity (N)));\n+         else\n+            Set_Entity (N, Discriminal (Entity (N)));\n+         end if;\n+\n+      else\n+         Set_Entity (N, Discriminal (Entity (N)));\n+      end if;\n+   end Expand_Discriminant;\n+\n+   -----------------------------\n+   -- Expand_Entity_Reference --\n+   -----------------------------\n+\n+   procedure Expand_Entity_Reference (N : Node_Id) is\n+      E : constant Entity_Id := Entity (N);\n+\n+   begin\n+      if Ekind (E) = E_Discriminant then\n+         Expand_Discriminant (N);\n+\n+      elsif Is_Entry_Formal (E) then\n+         Expand_Entry_Parameter (N);\n+\n+      elsif Ekind (E) = E_Component\n+        and then Is_Protected_Private (E)\n+      then\n+         Expand_Protected_Private (N);\n+\n+      elsif Ekind (E) = E_Entry_Index_Parameter then\n+         Expand_Entry_Index_Parameter (N);\n+\n+      elsif Is_Formal (E) then\n+         Expand_Formal (N);\n+\n+      elsif Is_Renaming_Of_Object (E) then\n+         Expand_Renaming (N);\n+\n+      elsif Ekind (E) = E_Variable\n+        and then Is_Shared_Passive (E)\n+      then\n+         Expand_Shared_Passive_Variable (N);\n+      end if;\n+   end Expand_Entity_Reference;\n+\n+   ----------------------------------\n+   -- Expand_Entry_Index_Parameter --\n+   ----------------------------------\n+\n+   procedure Expand_Entry_Index_Parameter (N : Node_Id) is\n+   begin\n+      Set_Entity (N, Entry_Index_Constant (Entity (N)));\n+   end Expand_Entry_Index_Parameter;\n+\n+   ----------------------------\n+   -- Expand_Entry_Parameter --\n+   ----------------------------\n+\n+   procedure Expand_Entry_Parameter (N : Node_Id) is\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Ent_Formal : constant Entity_Id  := Entity (N);\n+      Ent_Spec   : constant Entity_Id  := Scope (Ent_Formal);\n+      Parm_Type  : constant Entity_Id  := Entry_Parameters_Type (Ent_Spec);\n+      Acc_Stack  : constant Elist_Id   := Accept_Address (Ent_Spec);\n+      Addr_Ent   : constant Entity_Id  := Node (Last_Elmt (Acc_Stack));\n+      P_Comp_Ref : Entity_Id;\n+\n+   begin\n+      --  What we need is a reference to the corresponding component of the\n+      --  parameter record object. The Accept_Address field of the entry\n+      --  entity references the address variable that contains the address\n+      --  of the accept parameters record. We first have to do an unchecked\n+      --  conversion to turn this into a pointer to the parameter record and\n+      --  then we select the required parameter field.\n+\n+      P_Comp_Ref :=\n+        Make_Selected_Component (Loc,\n+          Prefix =>\n+            Unchecked_Convert_To (Parm_Type,\n+              New_Reference_To (Addr_Ent, Loc)),\n+          Selector_Name =>\n+            New_Reference_To (Entry_Component (Ent_Formal), Loc));\n+\n+      --  For all types of parameters, the constructed parameter record\n+      --  object contains a pointer to the parameter. Thus we must\n+      --  dereference them to access them (this will often be redundant,\n+      --  since the needed deference is implicit, but no harm is done by\n+      --  making it explicit).\n+\n+      Rewrite (N,\n+        Make_Explicit_Dereference (Loc, P_Comp_Ref));\n+\n+      Analyze (N);\n+   end Expand_Entry_Parameter;\n+\n+   -------------------\n+   -- Expand_Formal --\n+   -------------------\n+\n+   procedure Expand_Formal (N : Node_Id) is\n+      E    : constant Entity_Id  := Entity (N);\n+      Subp : constant Entity_Id  := Scope (E);\n+\n+   begin\n+      if Is_Protected_Type (Scope (Subp))\n+        and then Chars (Subp) /= Name_uInit_Proc\n+        and then Present (Protected_Formal (E))\n+      then\n+         Set_Entity (N, Protected_Formal (E));\n+      end if;\n+   end Expand_Formal;\n+\n+   ----------------------------\n+   -- Expand_N_Expanded_Name --\n+   ----------------------------\n+\n+   procedure Expand_N_Expanded_Name (N : Node_Id) is\n+   begin\n+      Expand_Entity_Reference (N);\n+   end Expand_N_Expanded_Name;\n+\n+   -------------------------\n+   -- Expand_N_Identifier --\n+   -------------------------\n+\n+   procedure Expand_N_Identifier (N : Node_Id) is\n+   begin\n+      Expand_Entity_Reference (N);\n+   end Expand_N_Identifier;\n+\n+   ---------------------------\n+   -- Expand_N_Real_Literal --\n+   ---------------------------\n+\n+   procedure Expand_N_Real_Literal (N : Node_Id) is\n+   begin\n+      if Vax_Float (Etype (N)) then\n+         Expand_Vax_Real_Literal (N);\n+      end if;\n+   end Expand_N_Real_Literal;\n+\n+   ------------------------------\n+   -- Expand_Protected_Private --\n+   ------------------------------\n+\n+   procedure Expand_Protected_Private (N : Node_Id) is\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      E        : constant Entity_Id  := Entity (N);\n+      Op       : constant Node_Id    := Protected_Operation (E);\n+      Scop     : Entity_Id;\n+      Lo       : Node_Id;\n+      Hi       : Node_Id;\n+      D_Range  : Node_Id;\n+\n+   begin\n+      if Nkind (Op) /= N_Subprogram_Body\n+        or else Nkind (Specification (Op)) /= N_Function_Specification\n+      then\n+         Set_Ekind (Prival (E), E_Variable);\n+      else\n+         Set_Ekind (Prival (E), E_Constant);\n+      end if;\n+\n+      --  If the private component appears in an assignment (either lhs or\n+      --  rhs) and is a one-dimensional array constrained by a discriminant,\n+      --  rewrite as  P (Lo .. Hi) with an explicit range, so that discriminal\n+      --  is directly visible. This solves delicate visibility problems.\n+\n+      if Comes_From_Source (N)\n+        and then Is_Array_Type (Etype (E))\n+        and then Number_Dimensions (Etype (E)) = 1\n+        and then not Within_Init_Proc\n+      then\n+         Lo := Type_Low_Bound  (Etype (First_Index (Etype (E))));\n+         Hi := Type_High_Bound (Etype (First_Index (Etype (E))));\n+\n+         if Nkind (Parent (N)) = N_Assignment_Statement\n+           and then ((Is_Entity_Name (Lo)\n+                          and then Ekind (Entity (Lo)) = E_In_Parameter)\n+                       or else (Is_Entity_Name (Hi)\n+                                  and then\n+                                    Ekind (Entity (Hi)) = E_In_Parameter))\n+         then\n+            D_Range := New_Node (N_Range, Loc);\n+\n+            if Is_Entity_Name (Lo)\n+              and then Ekind (Entity (Lo)) = E_In_Parameter\n+            then\n+               Set_Low_Bound (D_Range,\n+                 Make_Identifier (Loc, Chars (Entity (Lo))));\n+            else\n+               Set_Low_Bound (D_Range, Duplicate_Subexpr (Lo));\n+            end if;\n+\n+            if Is_Entity_Name (Hi)\n+              and then Ekind (Entity (Hi)) = E_In_Parameter\n+            then\n+               Set_High_Bound (D_Range,\n+                 Make_Identifier (Loc, Chars (Entity (Hi))));\n+            else\n+               Set_High_Bound (D_Range, Duplicate_Subexpr (Hi));\n+            end if;\n+\n+            Rewrite (N,\n+              Make_Slice (Loc,\n+                Prefix => New_Occurrence_Of (E, Loc),\n+                Discrete_Range => D_Range));\n+\n+            Analyze_And_Resolve (N, Etype (E));\n+            return;\n+         end if;\n+      end if;\n+\n+      --  The type of the reference is the type of the prival, which may\n+      --  differ from that of the original component if it is an itype.\n+\n+      Set_Entity (N, Prival (E));\n+      Set_Etype  (N, Etype (Prival (E)));\n+      Scop := Current_Scope;\n+\n+      --  Find entity for protected operation, which must be on scope stack.\n+\n+      while not Is_Protected_Type (Scope (Scop)) loop\n+         Scop := Scope (Scop);\n+      end loop;\n+\n+      Append_Elmt (N, Privals_Chain (Scop));\n+   end Expand_Protected_Private;\n+\n+   ---------------------\n+   -- Expand_Renaming --\n+   ---------------------\n+\n+   procedure Expand_Renaming (N : Node_Id) is\n+      E : constant Entity_Id := Entity (N);\n+      T : constant Entity_Id := Etype (N);\n+\n+   begin\n+      Rewrite (N, New_Copy_Tree (Renamed_Object (E)));\n+\n+      --  We mark the copy as unanalyzed, so that it is sure to be\n+      --  reanalyzed at the top level. This is needed in the packed\n+      --  case since we specifically avoided expanding packed array\n+      --  references when the renaming declaration was analyzed.\n+\n+      Reset_Analyzed_Flags (N);\n+      Analyze_And_Resolve (N, T);\n+   end Expand_Renaming;\n+\n+   ------------------\n+   -- Param_Entity --\n+   ------------------\n+\n+   --  This would be trivial, simply a test for an identifier that was a\n+   --  reference to a formal, if it were not for the fact that a previous\n+   --  call to Expand_Entry_Parameter will have modified the reference\n+   --  to the identifier to be of the form\n+\n+   --    typ!(recobj).rec.all'Constrained\n+\n+   --  where rec is a selector whose Entry_Formal link points to the formal\n+\n+   function Param_Entity (N : Node_Id) return Entity_Id is\n+   begin\n+      --  Simple reference case\n+\n+      if Nkind (N) = N_Identifier then\n+         if Is_Formal (Entity (N)) then\n+            return Entity (N);\n+         end if;\n+\n+      else\n+         if Nkind (N) = N_Explicit_Dereference then\n+            declare\n+               P : constant Node_Id := Prefix (N);\n+               S : Node_Id;\n+\n+            begin\n+               if Nkind (P) = N_Selected_Component then\n+                  S := Selector_Name (P);\n+\n+                  if Present (Entry_Formal (Entity (S))) then\n+                     return Entry_Formal (Entity (S));\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+\n+      return (Empty);\n+   end Param_Entity;\n+\n+end Exp_Ch2;"}, {"sha": "f5f105e40643ab9faf43b4ec793722d188be6d6d", "filename": "gcc/ada/exp_ch2.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              E X P _ C H 2                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for chapter 2 constructs\n+\n+with Types; use Types;\n+package Exp_Ch2 is\n+\n+   procedure Expand_N_Expanded_Name  (N : Node_Id);\n+   procedure Expand_N_Identifier     (N : Node_Id);\n+   procedure Expand_N_Real_Literal   (N : Node_Id);\n+\n+   function Param_Entity (N : Node_Id) return Entity_Id;\n+   --  Given an expression N, determines if the expression is a reference\n+   --  to a formal (of a subprogram or entry), and if so returns the Id\n+   --  of the corresponding formal entity, otherwise returns Empty. The\n+   --  reason that this is in Exp_Ch2 is that it has to deal with the\n+   --  case where the reference is to an entry formal, and has been\n+   --  expanded already. Since Exp_Ch2 is in charge of the expansion, it\n+   --  is best suited to knowing how to detect this case.\n+\n+end Exp_Ch2;"}, {"sha": "76520cfdb9aa7eede9860bdedb1887ed0d1e8810", "filename": "gcc/ada/exp_ch3.adb", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "ff65667b8e597fc0081dc2ad56369216cee10a98", "filename": "gcc/ada/exp_ch3.ads", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "2f140685afb00844bd214772c8d0ffcd45fc34b5", "filename": "gcc/ada/exp_ch4.adb", "status": "added", "additions": 5985, "deletions": 0, "changes": 5985, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "c7e24180d87bcea24a0e16908aca5e1ec33b8edf", "filename": "gcc/ada/exp_ch4.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "8c56fe386b04cf713096899e00b8fafd7971c9ab", "filename": "gcc/ada/exp_ch5.adb", "status": "added", "additions": 2858, "deletions": 0, "changes": 2858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "eb45c52233eac8b790703feac54c78719ac6eeb6", "filename": "gcc/ada/exp_ch5.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "e15328519cbdb7b7f29b543799d42dfe5bebb59c", "filename": "gcc/ada/exp_ch6.adb", "status": "added", "additions": 3227, "deletions": 0, "changes": 3227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "edb633f48b7a7825c9035f37ef8aeb35e9d8ddca", "filename": "gcc/ada/exp_ch6.ads", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "3feba78ecd7a53e73d782c5994027961e8e79745", "filename": "gcc/ada/exp_ch7.adb", "status": "added", "additions": 2801, "deletions": 0, "changes": 2801, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "aeff51f2b965a5f3956cfb5772717f9d7aef2eaa", "filename": "gcc/ada/exp_ch7.ads", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "54b113300e340465cdd555f7d9847e8e99464342", "filename": "gcc/ada/exp_ch8.adb", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "806d0dd0b931ee276bf073ea46f284d3f60de023", "filename": "gcc/ada/exp_ch8.ads", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "31b5d124e6354c54bcf40c2de998b48aca157efc", "filename": "gcc/ada/exp_ch9.adb", "status": "added", "additions": 8543, "deletions": 0, "changes": 8543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "949356fb39162048c31968eb5c29e793c1df8f6b", "filename": "gcc/ada/exp_ch9.ads", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "dbd8c44956d408f5643b785ee0350948f9f90586", "filename": "gcc/ada/exp_code.adb", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_code.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_code.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_code.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "0043c3c045add4239c43d8a537742adc352f9c02", "filename": "gcc/ada/exp_code.ads", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_code.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_code.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_code.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "871b0c56c64a5938ecd5e1f00da3fb8eeb17cdc9", "filename": "gcc/ada/exp_dbug.adb", "status": "added", "additions": 1753, "deletions": 0, "changes": 1753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "5351ea71b87aa4398061892c575123c018d418ae", "filename": "gcc/ada/exp_dbug.ads", "status": "added", "additions": 1428, "deletions": 0, "changes": 1428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "bdddde4a2899296de5481f80792d7d5c904a0f80", "filename": "gcc/ada/exp_disp.adb", "status": "added", "additions": 1278, "deletions": 0, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "f5ff995d61b00f3e51522d07b525b5b97a363390", "filename": "gcc/ada/exp_disp.ads", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "c0d79d12d22d83fd31a24d93359caf44ade8ce8f", "filename": "gcc/ada/exp_dist.adb", "status": "added", "additions": 3760, "deletions": 0, "changes": 3760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "e66dceccca70e61a18800d9ed9f83784dbc7a7b5", "filename": "gcc/ada/exp_dist.ads", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "656173f47f196319c0887a9d260efa5d8396c8eb", "filename": "gcc/ada/exp_fixd.adb", "status": "added", "additions": 2340, "deletions": 0, "changes": 2340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "45f68df9d0649e2561800be24541911eae5044dc", "filename": "gcc/ada/exp_fixd.ads", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_fixd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_fixd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "296d12daec6095c6e619dd29d9c9d1b953e85db9", "filename": "gcc/ada/exp_imgv.adb", "status": "added", "additions": 862, "deletions": 0, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "e05fec50cd5540edb6c73a836e15d9b70a9f0bdb", "filename": "gcc/ada/exp_imgv.ads", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_imgv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_imgv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "53be18f7e39d37a1751a77b021c4396ceeb8e58a", "filename": "gcc/ada/exp_intr.adb", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "35de9b4b603361d745bd583d52110ba0d2cbcbb9", "filename": "gcc/ada/exp_intr.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_intr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_intr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "2cc4f255473c7b336f79c676d18c7e21988dbe30", "filename": "gcc/ada/exp_pakd.adb", "status": "added", "additions": 2379, "deletions": 0, "changes": 2379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "8cfcead4f6fd642492dc177fe4f4d94149a6481e", "filename": "gcc/ada/exp_pakd.ads", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_pakd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_pakd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "855c3725dd12ddd48c6af90384e7a080d127cf88", "filename": "gcc/ada/exp_prag.adb", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "9034b8d16bb32e62e848e1b3013d4cf31107875f", "filename": "gcc/ada/exp_prag.ads", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "b89f42fc40592cc68dd04ca22ccb905def2d4f4c", "filename": "gcc/ada/exp_smem.adb", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "1d6cbd5dcba9125281c6de6692e6738bd4daccfe", "filename": "gcc/ada/exp_smem.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_smem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_smem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "92ff393b2ef4635ab3dd10bf8989004204a1a871", "filename": "gcc/ada/exp_strm.adb", "status": "added", "additions": 1472, "deletions": 0, "changes": 1472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "c70f4e9ac7eb5180d4736bbe0504883e2f20b549", "filename": "gcc/ada/exp_strm.ads", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_strm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_strm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "6e3722c5202f1d2563dd8f734493e148b2a151c0", "filename": "gcc/ada/exp_tss.adb", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_tss.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_tss.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "1df084fed88df207c423005a19d7f515881c5ac2", "filename": "gcc/ada/exp_tss.ads", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "c95fd9f841d5638b1404333ac324b7997df2e84f", "filename": "gcc/ada/exp_util.adb", "status": "added", "additions": 3186, "deletions": 0, "changes": 3186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "2af5b800a59bc82f07accde1e9126e5740e2b753", "filename": "gcc/ada/exp_util.ads", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "0d4c74a61046f4be56aac085c84bfb31e33d428d", "filename": "gcc/ada/exp_vfpt.adb", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_vfpt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_vfpt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_vfpt.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "8e3c95c07896101c9908ac623d6490bd51106891", "filename": "gcc/ada/exp_vfpt.ads", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_vfpt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexp_vfpt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_vfpt.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "7c48655ecc58f09f814741b41eecb669d65d014a", "filename": "gcc/ada/expander.adb", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "529fabaf28c53c519f5b43fcd8e6cc5b2416e893", "filename": "gcc/ada/expander.ads", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexpander.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexpander.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "591401cf1dc594e7afa118847bd40025e18c1033", "filename": "gcc/ada/expect.c", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexpect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Fexpect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpect.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "e21f0cf49b2b9f7c35f2c6c0d2fabc7eccc8ce30", "filename": "gcc/ada/fe.h", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "f388b3fb69e57617c3dbcbc7344236133bc54f2a", "filename": "gcc/ada/final.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffinal.c?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "ddb0134ca73001d282c9eae18b8c3b15530a030a", "filename": "gcc/ada/fname-sf.adb", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-sf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-sf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-sf.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "c401045be8ce090281d9df600bca5d6b4d6039d6", "filename": "gcc/ada/fname-sf.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-sf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-sf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-sf.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "ab6aaeb6b82e70df304aa4dd87bb7884adcc35dc", "filename": "gcc/ada/fname-uf.adb", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "5c626ecca781e930f035267dc4e1ee881da7cfb1", "filename": "gcc/ada/fname-uf.ads", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-uf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname-uf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "7ac38bbc52d5bb9b6ad23714fae9bf739b12e3b6", "filename": "gcc/ada/fname.adb", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "d4b589fd858ec0519282323198afbd419426f658", "filename": "gcc/ada/fname.ads", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffname.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "6f4c4c7c7c165bc61920bac229a5c048592bedff", "filename": "gcc/ada/freeze.adb", "status": "added", "additions": 3903, "deletions": 0, "changes": 3903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "f782a5ced1d45c8d1121ab9587ab04f41e4c72a6", "filename": "gcc/ada/freeze.ads", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "9aa1e7d16c914ab34e17039ead76c9acc6dad9ae", "filename": "gcc/ada/frontend.adb", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}, {"sha": "dd8240541c63113bfd9f7b6ec51cff89146c248a", "filename": "gcc/ada/frontend.ads", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffrontend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70482933d8f6a73b660f4cfa97b5c7c9deaf152e/gcc%2Fada%2Ffrontend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.ads?ref=70482933d8f6a73b660f4cfa97b5c7c9deaf152e"}]}