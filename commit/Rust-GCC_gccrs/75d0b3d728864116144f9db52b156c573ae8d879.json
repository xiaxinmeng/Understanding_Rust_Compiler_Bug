{"sha": "75d0b3d728864116144f9db52b156c573ae8d879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkMGIzZDcyODg2NDExNjE0NGY5ZGI1MmIxNTZjNTczYWU4ZDg3OQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-05-13T15:05:54Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-05-14T19:45:09Z"}, "message": "amdgcn: fix vcc clobber in vector load/store\n\nThis switches the code that expands scalar addresses to vectors of addresses\nfrom using VCC to using CC_SAVE_REG, for the lo-part to hi-part carry values.\nThese were fine in code expanded in earlier passes, but addresses expanded\nlate, such as for stack spills or reloads, could clobber live VCC values,\ncausing execution failures.\n\nThis is the first target-specific testcase for GCN, so the new .exp file is\nincluded.\n\n2020-05-14  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/gcn/gcn-valu.md (add<mode>3_zext_dup): Change to a\n\tdefine_expand, and rename the original to ...\n\t(add<mode>3_vcc_zext_dup): ... this, and add a custom VCC operand.\n\t(add<mode>3_zext_dup_exec): Likewise, with ...\n\t(add<mode>3_vcc_zext_dup_exec): ... this.\n\t(add<mode>3_zext_dup2): Likewise, with ...\n\t(add<mode>3_zext_dup_exec): ... this.\n\t(add<mode>3_zext_dup2_exec): Likewise, with ...\n\t(add<mode>3_zext_dup2): ... this.\n\t* config/gcn/gcn.c (gcn_expand_scalar_to_vector_address): Switch\n\taddv64di3_zext* calls to use addv64di3_vcc_zext*.\n\n\tgcc/testsuite/\n\t* testsuite/gcc.target/gcn/gcn.exp: New file.\n\t* testsuite/gcc.target/gcn/vcc-clobber.c: New file.", "tree": {"sha": "fb76ce9b448d07876e380edabe7ca129a0d96141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb76ce9b448d07876e380edabe7ca129a0d96141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75d0b3d728864116144f9db52b156c573ae8d879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d0b3d728864116144f9db52b156c573ae8d879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d0b3d728864116144f9db52b156c573ae8d879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d0b3d728864116144f9db52b156c573ae8d879/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9056cd80351c65c3b9a3257644236f2007c46a3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9056cd80351c65c3b9a3257644236f2007c46a3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9056cd80351c65c3b9a3257644236f2007c46a3f"}], "stats": {"total": 268, "additions": 217, "deletions": 51}, "files": [{"sha": "27b4b04f9b0df7a0422403144f5d98c7bb134a78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75d0b3d728864116144f9db52b156c573ae8d879", "patch": "@@ -1,3 +1,17 @@\n+2020-05-14  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/gcn/gcn-valu.md (add<mode>3_zext_dup): Change to a\n+\tdefine_expand, and rename the original to ...\n+\t(add<mode>3_vcc_zext_dup): ... this, and add a custom VCC operand.\n+\t(add<mode>3_zext_dup_exec): Likewise, with ...\n+\t(add<mode>3_vcc_zext_dup_exec): ... this.\n+\t(add<mode>3_zext_dup2): Likewise, with ...\n+\t(add<mode>3_zext_dup_exec): ... this.\n+\t(add<mode>3_zext_dup2_exec): Likewise, with ...\n+\t(add<mode>3_zext_dup2): ... this.\n+\t* config/gcn/gcn.c (gcn_expand_scalar_to_vector_address): Switch\n+\taddv64di3_zext* calls to use addv64di3_vcc_zext*.\n+\n 2020-05-14  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/95046"}, {"sha": "a43d6b6c6f374ad65a62a257750ac2dbd7a48623", "filename": "gcc/config/gcn/gcn-valu.md", "status": "modified", "additions": 116, "deletions": 45, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-valu.md?ref=75d0b3d728864116144f9db52b156c573ae8d879", "patch": "@@ -1379,135 +1379,206 @@\n   [(set_attr \"type\" \"vmult\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"add<mode>3_zext_dup\"\n-  [(set (match_operand:V_DI 0 \"register_operand\"    \"= v,  v\")\n+(define_insn_and_split \"add<mode>3_vcc_zext_dup\"\n+  [(set (match_operand:V_DI 0 \"register_operand\"    \"=   v,   v\")\n \t(plus:V_DI\n \t  (zero_extend:V_DI\n \t    (vec_duplicate:<VnSI>\n-\t      (match_operand:SI 1 \"gcn_alu_operand\" \"BSv,ASv\")))\n-\t  (match_operand:V_DI 2 \"gcn_alu_operand\"   \"vDA,vDb\")))\n-   (clobber (reg:DI VCC_REG))]\n+\t      (match_operand:SI 1 \"gcn_alu_operand\" \"  BSv, ASv\")))\n+\t  (match_operand:V_DI 2 \"gcn_alu_operand\"   \"  vDA, vDb\")))\n+   (set (match_operand:DI 3 \"register_operand\"\t    \"=SgcV,SgcV\")\n+\t(ltu:DI (plus:V_DI \n+\t\t  (zero_extend:V_DI (vec_duplicate:<VnSI> (match_dup 1)))\n+\t\t  (match_dup 2))\n+\t\t(match_dup 1)))]\n   \"\"\n   \"#\"\n   \"gcn_can_split_p  (<MODE>mode, operands[0])\n    && gcn_can_split_p (<MODE>mode, operands[2])\"\n   [(const_int 0)]\n   {\n-    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n     emit_insn (gen_add<vnsi>3_vcc_dup\n \t\t(gcn_operand_part (<MODE>mode, operands[0], 0),\n \t\t gcn_operand_part (DImode, operands[1], 0),\n \t\t gcn_operand_part (<MODE>mode, operands[2], 0),\n-\t\t vcc));\n+\t\t operands[3]));\n     emit_insn (gen_addc<vnsi>3\n \t\t(gcn_operand_part (<MODE>mode, operands[0], 1),\n \t\t gcn_operand_part (<MODE>mode, operands[2], 1),\n-\t\t const0_rtx, vcc, vcc));\n+\t\t const0_rtx, operands[3], operands[3]));\n     DONE;\n   }\n   [(set_attr \"type\" \"vmult\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"add<mode>3_zext_dup_exec\"\n-  [(set (match_operand:V_DI 0 \"register_operand\"\t\t \"= v,  v\")\n+(define_expand \"add<mode>3_zext_dup\"\n+  [(match_operand:V_DI 0 \"register_operand\")\n+   (match_operand:SI 1 \"gcn_alu_operand\")\n+   (match_operand:V_DI 2 \"gcn_alu_operand\")]\n+  \"\"\n+  {\n+    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n+    emit_insn (gen_add<mode>3_vcc_zext_dup (operands[0], operands[1],\n+\t\t\t\t\t    operands[2], vcc));\n+    DONE;\n+  })\n+\n+(define_insn_and_split \"add<mode>3_vcc_zext_dup_exec\"\n+  [(set (match_operand:V_DI 0 \"register_operand\"\t\t\"=   v,   v\")\n \t(vec_merge:V_DI\n \t  (plus:V_DI\n \t    (zero_extend:V_DI\n \t      (vec_duplicate:<VnSI>\n-\t\t(match_operand:SI 1 \"gcn_alu_operand\"\t\t \"ASv,BSv\")))\n-\t    (match_operand:V_DI 2 \"gcn_alu_operand\"\t\t \"vDb,vDA\"))\n-\t  (match_operand:V_DI 3 \"gcn_register_or_unspec_operand\" \" U0, U0\")\n-\t  (match_operand:DI 4 \"gcn_exec_reg_operand\"\t\t \"  e,  e\")))\n-   (clobber (reg:DI VCC_REG))]\n+\t\t(match_operand:SI 1 \"gcn_alu_operand\"\t\t\"  ASv, BSv\")))\n+\t    (match_operand:V_DI 2 \"gcn_alu_operand\"\t\t\"  vDb, vDA\"))\n+\t  (match_operand:V_DI 4 \"gcn_register_or_unspec_operand\" \"  U0,  U0\")\n+\t  (match_operand:DI 5 \"gcn_exec_reg_operand\"\t\t\"    e,   e\")))\n+   (set (match_operand:DI 3 \"register_operand\"\t\t\t\"=SgcV,SgcV\")\n+\t(and:DI\n+\t  (ltu:DI (plus:V_DI \n+\t\t    (zero_extend:V_DI (vec_duplicate:<VnSI> (match_dup 1)))\n+\t\t    (match_dup 2))\n+\t\t  (match_dup 1))\n+\t  (match_dup 5)))]\n   \"\"\n   \"#\"\n   \"gcn_can_split_p  (<MODE>mode, operands[0])\n    && gcn_can_split_p (<MODE>mode, operands[2])\n-   && gcn_can_split_p (<MODE>mode, operands[3])\"\n+   && gcn_can_split_p (<MODE>mode, operands[4])\"\n   [(const_int 0)]\n   {\n-    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n     emit_insn (gen_add<vnsi>3_vcc_dup_exec\n \t\t(gcn_operand_part (<MODE>mode, operands[0], 0),\n \t\t gcn_operand_part (DImode, operands[1], 0),\n \t\t gcn_operand_part (<MODE>mode, operands[2], 0),\n-\t\t vcc,\n-\t\t gcn_operand_part (<MODE>mode, operands[3], 0),\n-\t\t operands[4]));\n+\t\t operands[3],\n+\t\t gcn_operand_part (<MODE>mode, operands[4], 0),\n+\t\t operands[5]));\n     emit_insn (gen_addc<vnsi>3_exec\n \t\t(gcn_operand_part (<MODE>mode, operands[0], 1),\n \t\t gcn_operand_part (<MODE>mode, operands[2], 1),\n-\t\t const0_rtx, vcc, vcc,\n-\t\t gcn_operand_part (<MODE>mode, operands[3], 1),\n-\t\t operands[4]));\n+\t\t const0_rtx, operands[3], operands[3],\n+\t\t gcn_operand_part (<MODE>mode, operands[4], 1),\n+\t\t operands[5]));\n     DONE;\n   }\n   [(set_attr \"type\" \"vmult\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"add<mode>3_zext_dup2\"\n-  [(set (match_operand:V_DI 0 \"register_operand\"\t\t      \"=  v\")\n+(define_expand \"add<mode>3_zext_dup_exec\"\n+  [(match_operand:V_DI 0 \"register_operand\")\n+   (match_operand:SI 1 \"gcn_alu_operand\")\n+   (match_operand:V_DI 2 \"gcn_alu_operand\")\n+   (match_operand:V_DI 3 \"gcn_register_or_unspec_operand\")\n+   (match_operand:DI 4 \"gcn_exec_reg_operand\")]\n+  \"\"\n+  {\n+    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n+    emit_insn (gen_add<mode>3_vcc_zext_dup_exec (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2], vcc, operands[3],\n+\t\t\t\t\t\t operands[4]));\n+    DONE;\n+  })\n+\n+(define_insn_and_split \"add<mode>3_vcc_zext_dup2\"\n+  [(set (match_operand:V_DI 0 \"register_operand\"\t\t    \"=   v\")\n \t(plus:V_DI\n \t  (zero_extend:V_DI (match_operand:<VnSI> 1 \"gcn_alu_operand\" \" vA\"))\n-\t  (vec_duplicate:V_DI (match_operand:DI 2 \"gcn_alu_operand\"   \"DbSv\"))))\n-   (clobber (reg:DI VCC_REG))]\n+\t  (vec_duplicate:V_DI (match_operand:DI 2 \"gcn_alu_operand\" \" DbSv\"))))\n+   (set (match_operand:DI 3 \"register_operand\"\t\t\t    \"=SgcV\")\n+\t(ltu:DI (plus:V_DI \n+\t\t  (zero_extend:V_DI (match_dup 1))\n+\t\t  (vec_duplicate:V_DI (match_dup 2)))\n+\t\t(match_dup 1)))]\n   \"\"\n   \"#\"\n   \"gcn_can_split_p (<MODE>mode, operands[0])\"\n   [(const_int 0)]\n   {\n-    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n     emit_insn (gen_add<vnsi>3_vcc_dup\n \t\t(gcn_operand_part (<MODE>mode, operands[0], 0),\n \t\t gcn_operand_part (DImode, operands[2], 0),\n \t\t operands[1],\n-\t\t vcc));\n+\t\t operands[3]));\n     rtx dsthi = gcn_operand_part (<MODE>mode, operands[0], 1);\n     emit_insn (gen_vec_duplicate<vnsi>\n \t\t(dsthi, gcn_operand_part (DImode, operands[2], 1)));\n-    emit_insn (gen_addc<vnsi>3 (dsthi, dsthi, const0_rtx, vcc, vcc));\n+    emit_insn (gen_addc<vnsi>3 (dsthi, dsthi, const0_rtx, operands[3],\n+\t\t\t\toperands[3]));\n     DONE;\n   }\n   [(set_attr \"type\" \"vmult\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn_and_split \"add<mode>3_zext_dup2_exec\"\n-  [(set (match_operand:V_DI 0 \"register_operand\"\t\t       \"= v\")\n+(define_expand \"add<mode>3_zext_dup2\"\n+  [(match_operand:V_DI 0 \"register_operand\")\n+   (match_operand:<VnSI> 1 \"gcn_alu_operand\")\n+   (match_operand:DI 2 \"gcn_alu_operand\")]\n+  \"\"\n+  {\n+    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n+    emit_insn (gen_add<mode>3_vcc_zext_dup2 (operands[0], operands[1],\n+\t\t\t\t\t     operands[2], vcc));\n+    DONE;\n+  })\n+\n+(define_insn_and_split \"add<mode>3_vcc_zext_dup2_exec\"\n+  [(set (match_operand:V_DI 0 \"register_operand\"\t\t     \"=   v\")\n \t(vec_merge:V_DI\n \t  (plus:V_DI\n \t    (zero_extend:V_DI (match_operand:<VnSI> 1 \"gcn_alu_operand\" \"vA\"))\n \t    (vec_duplicate:V_DI (match_operand:DI 2 \"gcn_alu_operand\"  \"BSv\")))\n-\t  (match_operand:V_DI 3 \"gcn_register_or_unspec_operand\"       \" U0\")\n-\t  (match_operand:DI 4 \"gcn_exec_reg_operand\"\t\t       \"  e\")))\n-   (clobber (reg:DI VCC_REG))]\n+\t  (match_operand:V_DI 4 \"gcn_register_or_unspec_operand\"     \"   U0\")\n+\t  (match_operand:DI 5 \"gcn_exec_reg_operand\"\t\t     \"    e\")))\n+   (set (match_operand:DI 3 \"register_operand\"\t\t\t     \"=SgcV\")\n+\t(and:DI\n+\t  (ltu:DI (plus:V_DI \n+\t\t    (zero_extend:V_DI (match_dup 1))\n+\t\t    (vec_duplicate:V_DI (match_dup 2)))\n+\t\t  (match_dup 1))\n+\t  (match_dup 5)))]\n   \"\"\n   \"#\"\n   \"gcn_can_split_p  (<MODE>mode, operands[0])\n-   && gcn_can_split_p (<MODE>mode, operands[3])\"\n+   && gcn_can_split_p (<MODE>mode, operands[4])\"\n   [(const_int 0)]\n   {\n-    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n     emit_insn (gen_add<vnsi>3_vcc_dup_exec\n \t\t(gcn_operand_part (<MODE>mode, operands[0], 0),\n \t\t gcn_operand_part (DImode, operands[2], 0),\n \t\t operands[1],\n-\t\t vcc,\n-\t\t gcn_operand_part (<MODE>mode, operands[3], 0),\n-\t\t operands[4]));\n+\t\t operands[3],\n+\t\t gcn_operand_part (<MODE>mode, operands[4], 0),\n+\t\t operands[5]));\n     rtx dsthi = gcn_operand_part (<MODE>mode, operands[0], 1);\n     emit_insn (gen_vec_duplicate<vnsi>_exec\n \t\t(dsthi, gcn_operand_part (DImode, operands[2], 1),\n-\t\t gcn_operand_part (<MODE>mode, operands[3], 1),\n-\t\t operands[4]));\n+\t\t gcn_operand_part (<MODE>mode, operands[4], 1),\n+\t\t operands[5]));\n     emit_insn (gen_addc<vnsi>3_exec\n-\t\t(dsthi, dsthi, const0_rtx, vcc, vcc,\n-\t\t gcn_operand_part (<MODE>mode, operands[3], 1),\n-\t\t operands[4]));\n+\t\t(dsthi, dsthi, const0_rtx, operands[3], operands[3],\n+\t\t gcn_operand_part (<MODE>mode, operands[4], 1),\n+\t\t operands[5]));\n     DONE;\n   }\n   [(set_attr \"type\" \"vmult\")\n    (set_attr \"length\" \"8\")])\n \n+(define_expand \"add<mode>3_zext_dup2_exec\"\n+  [(match_operand:V_DI 0 \"register_operand\")\n+   (match_operand:<VnSI> 1 \"gcn_alu_operand\")\n+   (match_operand:DI 2 \"gcn_alu_operand\")\n+   (match_operand:V_DI 3 \"gcn_register_or_unspec_operand\")\n+   (match_operand:DI 4 \"gcn_exec_reg_operand\")]\n+  \"\"\n+  {\n+    rtx vcc = gen_rtx_REG (DImode, VCC_REG);\n+    emit_insn (gen_add<mode>3_vcc_zext_dup2_exec (operands[0], operands[1],\n+\t\t\t\t\t\t  operands[2], vcc,\n+\t\t\t\t\t\t  operands[3], operands[4]));\n+    DONE;\n+  })\n+\n (define_insn_and_split \"add<mode>3_sext_dup2\"\n   [(set (match_operand:V_DI 0 \"register_operand\"\t\t      \"= v\")\n \t(plus:V_DI"}, {"sha": "39eb8fd283f383c2a4b36f31c3b5a54682443e41", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=75d0b3d728864116144f9db52b156c573ae8d879", "patch": "@@ -1786,9 +1786,10 @@ gcn_expand_scalar_to_vector_address (machine_mode mode, rtx exec, rtx mem,\n \n   if (AS_FLAT_P (as))\n     {\n+      rtx vcc = gen_rtx_REG (DImode, CC_SAVE_REG);\n+\n       if (REG_P (tmp))\n \t{\n-\t  rtx vcc = gen_rtx_REG (DImode, CC_SAVE_REG);\n \t  rtx mem_base_lo = gcn_operand_part (DImode, mem_base, 0);\n \t  rtx mem_base_hi = gcn_operand_part (DImode, mem_base, 1);\n \t  rtx tmphi = gcn_operand_part (V64DImode, tmp, 1);\n@@ -1809,17 +1810,17 @@ gcn_expand_scalar_to_vector_address (machine_mode mode, rtx exec, rtx mem,\n \t\t\t\t\t      vcc, vcc, undef_v64si, exec));\n \t    }\n \t  else\n-\t    emit_insn (gen_addv64di3_zext_dup (tmp, mem_base_lo, tmp));\n+\t    emit_insn (gen_addv64di3_vcc_zext_dup (tmp, mem_base_lo, tmp, vcc));\n \t}\n       else\n \t{\n \t  tmp = gen_reg_rtx (V64DImode);\n \t  if (exec)\n-\t    emit_insn (gen_addv64di3_zext_dup2_exec (tmp, tmplo, mem_base,\n-\t\t\t\t\t\t     gcn_gen_undef (V64DImode),\n-\t\t\t\t\t\t     exec));\n+\t    emit_insn (gen_addv64di3_vcc_zext_dup2_exec\n+\t\t       (tmp, tmplo, mem_base, vcc, gcn_gen_undef (V64DImode),\n+\t\t\texec));\n \t  else\n-\t    emit_insn (gen_addv64di3_zext_dup2 (tmp, tmplo, mem_base));\n+\t    emit_insn (gen_addv64di3_vcc_zext_dup2 (tmp, tmplo, mem_base, vcc));\n \t}\n \n       new_base = tmp;"}, {"sha": "7319b2026cda4d5cae92d8060a7bda9b1651c46f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75d0b3d728864116144f9db52b156c573ae8d879", "patch": "@@ -1,3 +1,8 @@\n+2020-05-14  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* testsuite/gcc.target/gcn/gcn.exp: New file.\n+\t* testsuite/gcc.target/gcn/vcc-clobber.c: New file.\n+\n 2020-05-14  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/95046"}, {"sha": "0e799e8bc8093cb187bac3470384b70f1a85fe28", "filename": "gcc/testsuite/gcc.target/gcn/gcn.exp", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fgcn.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fgcn.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fgcn.exp?ref=75d0b3d728864116144f9db52b156c573ae8d879", "patch": "@@ -0,0 +1,42 @@\n+# Specific regression driver for nvptx.\n+# Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't a nvptx target.\n+if ![istarget amdgcn*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "e52733cf1e5478b4a9015f25567e7cf953bfc7e6", "filename": "gcc/testsuite/gcc.target/gcn/vcc-clobber.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fvcc-clobber.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d0b3d728864116144f9db52b156c573ae8d879/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fvcc-clobber.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fvcc-clobber.c?ref=75d0b3d728864116144f9db52b156c573ae8d879", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+/* Test that gcn_expand_scalar_to_vector_address does not clobber VCC.\n+   If it does then spills and reloads will be unsafe, leading to unexpected\n+   conditional branch behaviour.  */\n+\n+extern void abort ();\n+\n+__attribute__((vector_size(256))) int vec[2] = {{0}, {0}};\n+\n+int\n+main()\n+{\n+  long vcc = 0;\n+\n+  /* Load a known value into VCC.  The memory barrier ensures that the vector\n+     load must happen after this point.  */\n+  asm volatile (\"s_mov_b32 vcc_lo, 0x12345689\\n\\t\"\n+\t\t\"s_mov_b32 vcc_hi, 0xabcdef0\"\n+\t\t::: \"memory\");\n+\n+  /* Compiler inserts vector load here.  */\n+\n+  /* Consume the abitrary vector, and return the current value of VCC.  */\n+  asm volatile (\"; no-op\" : \"=cV\"(vcc) : \"v\"(vec[0]), \"v\"(vec[1]));\n+\n+  /* The value should match the initialized value.  */\n+  if (vcc != 0xabcdef012345689)\n+    abort ();\n+\n+  return 0;\n+}"}]}