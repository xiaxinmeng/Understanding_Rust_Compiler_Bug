{"sha": "7c54b003358e3a314479edeafc13d1f7318a0497", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M1NGIwMDMzNThlM2EzMTQ0NzllZGVhZmMxM2QxZjczMThhMDQ5Nw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-10-21T12:29:43Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-21T12:29:43Z"}, "message": "PlainDatagramSocketImpl.java, [...]: Renamed fnum to native_fd to match classpath more.\n\n2003-10-21  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/net/PlainDatagramSocketImpl.java,\n\tgnu/java/net/PlainSocketImpl.java,\n\tgnu/java/net/natPlainDatagramSocketImplPosix.cc,\n\tgnu/java/net/natPlainDatagramSocketImplWin32.cc,\n\tgnu/java/net/natPlainSocketImplPosix.cc,\n\tgnu/java/net/natPlainSocketImplWin32.cc:\n\tRenamed fnum to native_fd to match classpath more.\n\nFrom-SVN: r72746", "tree": {"sha": "7c76fd763fe70176e08b712fa4d52f9769f72f4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c76fd763fe70176e08b712fa4d52f9769f72f4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c54b003358e3a314479edeafc13d1f7318a0497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c54b003358e3a314479edeafc13d1f7318a0497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c54b003358e3a314479edeafc13d1f7318a0497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c54b003358e3a314479edeafc13d1f7318a0497/comments", "author": null, "committer": null, "parents": [{"sha": "d23ad8c84e99db31a61b3c51ce61459cf9134482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23ad8c84e99db31a61b3c51ce61459cf9134482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d23ad8c84e99db31a61b3c51ce61459cf9134482"}], "stats": {"total": 348, "additions": 179, "deletions": 169}, "files": [{"sha": "42087e120a198d2460ce2e93eae6b092ff877fe5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -1,3 +1,13 @@\n+2003-10-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/net/PlainDatagramSocketImpl.java,\n+\tgnu/java/net/PlainSocketImpl.java,\n+\tgnu/java/net/natPlainDatagramSocketImplPosix.cc,\n+\tgnu/java/net/natPlainDatagramSocketImplWin32.cc,\n+\tgnu/java/net/natPlainSocketImplPosix.cc,\n+\tgnu/java/net/natPlainSocketImplWin32.cc:\n+\tRenamed fnum to native_fd to match classpath more.\n+\n 2003-10-21  Jerry Quinn  <jlquinn@optonline.net>\n \n         * posix-threads.cc (_Jv_CondNotify,_Jv_CondNotifyAll): Rename"}, {"sha": "9f710d37b4c1eaae678a4fd30f71e118d19c973d", "filename": "libjava/gnu/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -45,8 +45,8 @@\n import java.net.InetSocketAddress;\n import java.net.NetworkInterface;\n import java.net.SocketAddress;\n-import java.net.SocketOptions;\n import java.net.SocketException;\n+import java.net.SocketOptions;\n import gnu.classpath.Configuration;\n \n /**\n@@ -94,7 +94,7 @@ public final class PlainDatagramSocketImpl extends DatagramSocketImpl\n   /**\n    * This is the actual underlying file descriptor\n    */\n-  int fnum = -1;\n+  int native_fd = -1;\n \n   // FIXME: Is this necessary?  Could it help w/ DatagramSocket.getLocalAddress?\n   // InetAddress address;\n@@ -116,15 +116,15 @@ protected void finalize() throws Throwable\n   {\n     synchronized (this)\n       {\n-\tif (fnum != -1)\n+\tif (native_fd != -1)\n \t  close();\n       }\n     super.finalize();\n   }\n \n   public int getNativeFD()\n   {\n-    return fnum;\n+    return native_fd;\n   }\n \n   /**"}, {"sha": "80139115cfe09e547224d3956b740fe5882c6682", "filename": "libjava/gnu/java/net/PlainSocketImpl.java", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -1,5 +1,6 @@\n /* PlainSocketImpl.java -- Default socket implementation\n-   Copyright (C) 1998, 1999, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -100,7 +101,7 @@ public final class PlainSocketImpl extends SocketImpl\n    *\n    * When the socket is closed this is reset to -1.\n    */\n-  int fnum = -1;\n+  int native_fd = -1;\n \n   // This value is set/read by setOption/getOption.\n   int timeout = 0;\n@@ -129,22 +130,21 @@ protected void finalize() throws Throwable\n   {\n     synchronized (this)\n       {\n-\tif (fnum != -1)\n+\tif (native_fd != -1)\n \t  try\n \t    {\n \t      close();\n \t    }\n \t  catch (IOException ex)\n \t    {\n-\t      // ignore\n \t    }\n       }\n     super.finalize();\n   }\n \n   public int getNativeFD()\n   {\n-    return fnum;\n+    return native_fd;\n   }\n \n   /**"}, {"sha": "65d083c09708bf86ae57dfc2ac4d6552aea45a68", "filename": "libjava/gnu/java/net/natPlainDatagramSocketImplPosix.cc", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -81,9 +81,9 @@ gnu::java::net::PlainDatagramSocketImpl::create ()\n \n   _Jv_platform_close_on_exec (sock);\n \n-  // We use fnum in place of fd here.  From leaving fd null we avoid\n+  // We use native_fd in place of fd here.  From leaving fd null we avoid\n   // the double close problem in FileDescriptor.finalize.\n-  fnum = sock;\n+  native_fd = sock;\n }\n \n void\n@@ -121,20 +121,20 @@ gnu::java::net::PlainDatagramSocketImpl::bind (jint lport,\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (_Jv_bind (fnum, ptr, len) == 0)\n+  if (_Jv_bind (native_fd, ptr, len) == 0)\n     {\n       socklen_t addrlen = sizeof(u);\n \n       if (lport != 0)\n         localPort = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      else if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) == 0)\n         localPort = ntohs (u.address.sin_port);\n       else\n         goto error;\n \n       /* Allow broadcast by default. */\n       int broadcast = 1;\n-      if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast, \n+      if (::setsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast, \n                         sizeof (broadcast)) != 0)\n         goto error;\n \n@@ -167,7 +167,7 @@ gnu::java::net::PlainDatagramSocketImpl::peek (::java::net::InetAddress *i)\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n   ssize_t retlen =\n-    ::recvfrom (fnum, (char *) NULL, 0, MSG_PEEK, (sockaddr*) &u,\n+    ::recvfrom (native_fd, (char *) NULL, 0, MSG_PEEK, (sockaddr*) &u,\n       &addrlen);\n   if (retlen < 0)\n     goto error;\n@@ -212,23 +212,23 @@ gnu::java::net::PlainDatagramSocketImpl::peekData (::java::net::DatagramPacket *\n   ssize_t retlen = 0;\n \n   // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0 && native_fd >= 0 && native_fd < FD_SETSIZE)\n     {\n       fd_set rset;\n       struct timeval tv;\n       FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n+      FD_SET(native_fd, &rset);\n       tv.tv_sec = timeout / 1000;\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+      if ((retval = _Jv_select (native_fd + 1, &rset, NULL, NULL, &tv)) < 0)\n         goto error;\n       else if (retval == 0)\n         throw new ::java::io::InterruptedIOException ();\n     }\n \n   retlen =\n-    ::recvfrom (fnum, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n+    ::recvfrom (native_fd, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n       &addrlen);\n   if (retlen < 0)\n     goto error;\n@@ -275,8 +275,8 @@ gnu::java::net::PlainDatagramSocketImpl::close ()\n \n   // The method isn't declared to throw anything, so we disregard\n   // the return value.\n-  _Jv_close (fnum);\n-  fnum = -1;\n+  _Jv_close (native_fd);\n+  native_fd = -1;\n   timeout = 0;\n }\n \n@@ -310,7 +310,7 @@ gnu::java::net::PlainDatagramSocketImpl::send (::java::net::DatagramPacket *p)\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::sendto (fnum, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n+  if (::sendto (native_fd, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n     return;\n \n   char* strerr = strerror (errno);\n@@ -331,23 +331,23 @@ gnu::java::net::PlainDatagramSocketImpl::receive (::java::net::DatagramPacket *p\n   ssize_t retlen = 0;\n \n   // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0 && native_fd >= 0 && native_fd < FD_SETSIZE)\n     {\n       fd_set rset;\n       struct timeval tv;\n       FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n+      FD_SET(native_fd, &rset);\n       tv.tv_sec = timeout / 1000;\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+      if ((retval = _Jv_select (native_fd + 1, &rset, NULL, NULL, &tv)) < 0)\n         goto error;\n       else if (retval == 0)\n         throw new ::java::io::InterruptedIOException ();\n     }\n \n   retlen =\n-    ::recvfrom (fnum, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n+    ::recvfrom (native_fd, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n       &addrlen);\n   if (retlen < 0)\n     goto error;\n@@ -392,7 +392,7 @@ gnu::java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n   char val = (char) ttl;\n   socklen_t val_len = sizeof(val);\n \n-  if (::setsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, val_len) == 0)\n+  if (::setsockopt (native_fd, IPPROTO_IP, IP_MULTICAST_TTL, &val, val_len) == 0)\n     return;\n \n   char* strerr = strerror (errno);\n@@ -406,7 +406,7 @@ gnu::java::net::PlainDatagramSocketImpl::getTimeToLive ()\n   char val;\n   socklen_t val_len = sizeof(val);\n \n-  if (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, &val_len) == 0)\n+  if (::getsockopt (native_fd, IPPROTO_IP, IP_MULTICAST_TTL, &val, &val_len) == 0)\n     return ((int) val) & 0xFF;\n \n   char* strerr = strerror (errno);\n@@ -466,7 +466,7 @@ gnu::java::net::PlainDatagramSocketImpl::mcastGrp (::java::net::InetAddress *ine\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::setsockopt (fnum, level, opname, ptr, len) == 0)\n+  if (::setsockopt (native_fd, level, opname, ptr, len) == 0)\n     return;\n \n   char* strerr = strerror (errno);\n@@ -480,7 +480,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n   int val;\n   socklen_t val_len = sizeof (val);\n \n-  if (fnum < 0)\n+  if (native_fd < 0)\n     throw new ::java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n \n   if (_Jv_IsInstanceOf (value, &::java::lang::Boolean::class$))\n@@ -513,7 +513,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         return;\n \n       case _Jv_SO_BROADCAST_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n                           val_len) != 0)\n           goto error;\n \tbreak;\n@@ -528,7 +528,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n+        if (::setsockopt (native_fd, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n \t  goto error;    \n #else\n         throw new ::java::lang::InternalError (\n@@ -537,7 +537,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         return;\n       case _Jv_SO_REUSEADDR_ :\n #if defined(SO_REUSEADDR)\n-\tif (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+\tif (::setsockopt (native_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n \t    val_len) != 0)\n \t  goto error;\n #else\n@@ -583,7 +583,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n \t  throw\n \t    new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-\tif (::setsockopt (fnum, level, opname, ptr, len) != 0)\n+\tif (::setsockopt (native_fd, level, opname, ptr, len) != 0)\n \t  goto error;\n         return;\n \t\n@@ -598,7 +598,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         break;\n \t\n       case _Jv_IP_TOS_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n \t   val_len) != 0)\n \t  goto error;    \n \treturn;\n@@ -639,7 +639,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         break;\n \t\n       case _Jv_SO_BROADCAST_ :\n-\tif (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+\tif (::getsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n \t    &val_len) != 0)\n \t  goto error;\n \treturn new ::java::lang::Boolean (val != 0);\n@@ -654,7 +654,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n+        if (::getsockopt (native_fd, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n \t  goto error;    \n         else\n \t  return new ::java::lang::Integer (val);\n@@ -668,7 +668,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n \tif (localAddress == NULL)\n \t  {\t\n \t    jbyteArray laddr;\n-\t    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+\t    if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) != 0)\n \t      goto error;\n \t    if (u.address.sin_family == AF_INET)\n \t      {\n@@ -691,7 +691,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n \tbreak;\n       case _Jv_SO_REUSEADDR_ :\n #if defined(SO_REUSEADDR)\n-\tif (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+\tif (::getsockopt (native_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n \t    &val_len) != 0)\n \t  goto error;\n \treturn new ::java::lang::Boolean (val != 0);\n@@ -707,7 +707,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n \tchar *bytes;\n \n   \tinaddr_len = sizeof(inaddr);\n-\tif (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n+\tif (::getsockopt (native_fd, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n \t    &inaddr_len) != 0)\n \t  goto error;\n \n@@ -729,13 +729,13 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         break;\n \t\n       case _Jv_IP_MULTICAST_LOOP_ :\n-\tif (::getsockopt (fnum, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n+\tif (::getsockopt (native_fd, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n \t    &val_len) != 0)\n \t  goto error;\n \treturn new ::java::lang::Boolean (val != 0);\n \t\n       case _Jv_IP_TOS_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+        if (::getsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n            &val_len) != 0)\n           goto error;\n         return new ::java::lang::Integer (val);"}, {"sha": "1098e6158a8f6637a999b5968a4339c0b200b4c0", "filename": "libjava/gnu/java/net/natPlainDatagramSocketImplWin32.cc", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -71,9 +71,9 @@ gnu::java::net::PlainDatagramSocketImpl::create ()\n \n   _Jv_platform_close_on_exec (sock);\n \n-  // We use fnum in place of fd here.  From leaving fd null we avoid\n+  // We use native_fd in place of fd here.  From leaving fd null we avoid\n   // the double close problem in FileDescriptor.finalize.\n-  fnum = (int) sock;\n+  native_fd = (int) sock;\n }\n \n void\n@@ -111,20 +111,20 @@ gnu::java::net::PlainDatagramSocketImpl::bind (jint lport,\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::bind (fnum, ptr, len) == 0)\n+  if (::bind (native_fd, ptr, len) == 0)\n     {\n       socklen_t addrlen = sizeof(u);\n \n       if (lport != 0)\n         localPort = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      else if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) == 0)\n         localPort = ntohs (u.address.sin_port);\n       else\n         goto error;\n \n       /* Allow broadcast by default. */\n       int broadcast = 1;\n-      if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast,\n+      if (::setsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast,\n                         sizeof (broadcast)) != 0)\n         goto error;\n \n@@ -157,7 +157,7 @@ gnu::java::net::PlainDatagramSocketImpl::peek (::java::net::InetAddress *i)\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n   ssize_t retlen =\n-    ::recvfrom (fnum, (char *) NULL, 0, MSG_PEEK, (sockaddr*) &u,\n+    ::recvfrom (native_fd, (char *) NULL, 0, MSG_PEEK, (sockaddr*) &u,\n       &addrlen);\n   if (retlen < 0)\n     goto error;\n@@ -204,14 +204,14 @@ gnu::java::net::PlainDatagramSocketImpl::peekData(::java::net::DatagramPacket *p\n \n   if (timeout > 0)\n     {\n-      int nRet= ::setsockopt(fnum, SOL_SOCKET, SO_RCVTIMEO,\n+      int nRet= ::setsockopt(native_fd, SOL_SOCKET, SO_RCVTIMEO,\n         (char*)&timeout, sizeof(timeout));\n       if (nRet != NO_ERROR)\n         goto error;\n     }\n \n   retlen =\n-    ::recvfrom (fnum, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n+    ::recvfrom (native_fd, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n       &addrlen);\n   if (retlen == SOCKET_ERROR)\n     goto error;\n@@ -262,8 +262,8 @@ gnu::java::net::PlainDatagramSocketImpl::close ()\n \n   // The method isn't declared to throw anything, so we disregard\n   // the return value.\n-  ::closesocket (fnum);\n-  fnum = -1;\n+  ::closesocket (native_fd);\n+  native_fd = -1;\n   timeout = 0;\n }\n \n@@ -297,7 +297,7 @@ gnu::java::net::PlainDatagramSocketImpl::send (::java::net::DatagramPacket *p)\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::sendto (fnum, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n+  if (::sendto (native_fd, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n     return;\n \n   DWORD dwErrorCode = WSAGetLastError ();\n@@ -321,14 +321,14 @@ gnu::java::net::PlainDatagramSocketImpl::receive (::java::net::DatagramPacket *p\n       // This implementation doesn't allow specifying an infinite\n       // timeout after specifying a finite one, but Sun's JDK 1.4.1\n       // didn't seem to allow this either....\n-      int nRet= ::setsockopt(fnum, SOL_SOCKET, SO_RCVTIMEO,\n+      int nRet= ::setsockopt(native_fd, SOL_SOCKET, SO_RCVTIMEO,\n         (char*)&timeout, sizeof(timeout));\n       if (nRet != NO_ERROR)\n         goto error;\n     }\n \n   retlen =\n-    ::recvfrom (fnum, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n+    ::recvfrom (native_fd, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n       &addrlen);\n   if (retlen < 0)\n     goto error;\n@@ -374,7 +374,7 @@ gnu::java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n   char val = (char) ttl;\n   socklen_t val_len = sizeof(val);\n \n-  if (::setsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, val_len) == 0)\n+  if (::setsockopt (native_fd, IPPROTO_IP, IP_MULTICAST_TTL, &val, val_len) == 0)\n     return;\n \n   _Jv_ThrowIOException ();\n@@ -387,7 +387,7 @@ gnu::java::net::PlainDatagramSocketImpl::getTimeToLive ()\n   char val;\n   socklen_t val_len = sizeof(val);\n \n-  if (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, &val_len) == 0)\n+  if (::getsockopt (native_fd, IPPROTO_IP, IP_MULTICAST_TTL, &val, &val_len) == 0)\n     return ((int) val) & 0xFF;\n \n   _Jv_ThrowIOException ();\n@@ -446,7 +446,7 @@ gnu::java::net::PlainDatagramSocketImpl::mcastGrp (::java::net::InetAddress *ine\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::setsockopt (fnum, level, opname, ptr, len) == 0)\n+  if (::setsockopt (native_fd, level, opname, ptr, len) == 0)\n     return;\n \n   _Jv_ThrowIOException ();\n@@ -459,7 +459,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n   int val;\n   socklen_t val_len = sizeof (val);\n \n-  if (fnum < 0)\n+  if (native_fd < 0)\n     throw new ::java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n \n   if (_Jv_IsInstanceOf (value, &::java::lang::Boolean::class$))\n@@ -492,7 +492,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         return;\n \n       case _Jv_SO_BROADCAST_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n                           val_len) != 0)\n           goto error;\n   break;\n@@ -506,11 +506,11 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n       case _Jv_SO_RCVBUF_ :\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n+        if (::setsockopt (native_fd, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n     goto error;\n         return;\n       case _Jv_SO_REUSEADDR_ :\n-  if (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+  if (::setsockopt (native_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n       val_len) != 0)\n     goto error;\n   return;\n@@ -552,7 +552,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n     throw\n       new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::setsockopt (fnum, level, opname, ptr, len) != 0)\n+  if (::setsockopt (native_fd, level, opname, ptr, len) != 0)\n     goto error;\n         return;\n \n@@ -567,7 +567,7 @@ gnu::java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         break;\n \n       case _Jv_IP_TOS_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n      val_len) != 0)\n     goto error;\n   return;\n@@ -607,7 +607,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         break;\n \n       case _Jv_SO_BROADCAST_ :\n-  if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+  if (::getsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n       &val_len) != 0)\n     goto error;\n   return new ::java::lang::Boolean (val != 0);\n@@ -621,7 +621,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n       case _Jv_SO_SNDBUF_ :\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n+        if (::getsockopt (native_fd, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n     goto error;\n         else\n     return new ::java::lang::Integer (val);\n@@ -631,7 +631,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n   if (localAddress == NULL)\n     {\n       jbyteArray laddr;\n-      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+      if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) != 0)\n         goto error;\n       if (u.address.sin_family == AF_INET)\n         {\n@@ -653,7 +653,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n   return localAddress;\n   break;\n       case _Jv_SO_REUSEADDR_ :\n-  if (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+  if (::getsockopt (native_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n       &val_len) != 0)\n     goto error;\n   return new ::java::lang::Boolean (val != 0);\n@@ -664,7 +664,7 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n   char *bytes;\n \n     inaddr_len = sizeof(inaddr);\n-  if (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n+  if (::getsockopt (native_fd, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n       &inaddr_len) != 0)\n     goto error;\n \n@@ -682,13 +682,13 @@ gnu::java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         break;\n \n       case _Jv_IP_MULTICAST_LOOP_ :\n-  if (::getsockopt (fnum, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n+  if (::getsockopt (native_fd, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n       &val_len) != 0)\n     goto error;\n   return new ::java::lang::Boolean (val != 0);\n \n       case _Jv_IP_TOS_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+        if (::getsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n            &val_len) != 0)\n           goto error;\n         return new ::java::lang::Integer (val);"}, {"sha": "8a09f9af595dae2071f2e48dca081bbe981d5454", "filename": "libjava/gnu/java/net/natPlainSocketImplPosix.cc", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -73,9 +73,9 @@ gnu::java::net::PlainSocketImpl::create (jboolean stream)\n \n   _Jv_platform_close_on_exec (sock);\n \n-  // We use fnum in place of fd here.  From leaving fd null we avoid\n+  // We use native_fd in place of fd here.  From leaving fd null we avoid\n   // the double close problem in FileDescriptor.finalize.\n-  fnum = sock;\n+  native_fd = sock;\n }\n \n void\n@@ -113,16 +113,16 @@ gnu::java::net::PlainSocketImpl::bind (::java::net::InetAddress *host, jint lpor\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n   // Enable SO_REUSEADDR, so that servers can reuse ports left in TIME_WAIT.\n-  ::setsockopt(fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &i, sizeof(i));\n+  ::setsockopt(native_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &i, sizeof(i));\n   \n-  if (_Jv_bind (fnum, ptr, len) == 0)\n+  if (_Jv_bind (native_fd, ptr, len) == 0)\n     {\n       address = host;\n       socklen_t addrlen = sizeof(u);\n \n       if (lport != 0)\n         localport = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      else if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) == 0)\n         localport = ntohs (u.address.sin_port);\n       else\n         goto error;\n@@ -170,31 +170,31 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n \n   if (timeout > 0)\n     {\n-      int flags = ::fcntl (fnum, F_GETFL);\n-      ::fcntl (fnum, F_SETFL, flags | O_NONBLOCK);\n+      int flags = ::fcntl (native_fd, F_GETFL);\n+      ::fcntl (native_fd, F_SETFL, flags | O_NONBLOCK);\n       \n-      if ((_Jv_connect (fnum, ptr, len) != 0) && (errno != EINPROGRESS))\n+      if ((_Jv_connect (native_fd, ptr, len) != 0) && (errno != EINPROGRESS))\n         goto error;\n \n       fd_set fset;\n       struct timeval tv;\n       FD_ZERO(&fset);\n-      FD_SET(fnum, &fset);\n+      FD_SET(native_fd, &fset);\n       tv.tv_sec = timeout / 1000;\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n       \n-      if ((retval = _Jv_select (fnum + 1, &fset, &fset, NULL, &tv)) < 0)\n+      if ((retval = _Jv_select (native_fd + 1, &fset, &fset, NULL, &tv)) < 0)\n         goto error;\n       else if (retval == 0)\n         throw new ::java::net::SocketTimeoutException\n           (JvNewStringUTF (\"Connect timed out\"));\n        // Set the socket back into a blocking state.\n-       ::fcntl (fnum, F_SETFL, flags);\n+       ::fcntl (native_fd, F_SETFL, flags);\n     }\n   else\n     {\n-      if (_Jv_connect (fnum, ptr, len) != 0)\n+      if (_Jv_connect (native_fd, ptr, len) != 0)\n         goto error;\n     }\n \n@@ -204,7 +204,7 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n   // A bind may not have been done on this socket; if so, set localport now.\n   if (localport == 0)\n     {\n-      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) == 0)\n         localport = ntohs (u.address.sin_port);\n       else\n         goto error;\n@@ -220,7 +220,7 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n void\n gnu::java::net::PlainSocketImpl::listen (jint backlog)\n {\n-  if (::listen (fnum, backlog) != 0)\n+  if (::listen (native_fd, backlog) != 0)\n     {\n       char* strerr = strerror (errno);\n       throw new ::java::io::IOException (JvNewStringUTF (strerr));\n@@ -235,23 +235,23 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n   int new_socket = 0; \n \n   // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0 && native_fd >= 0 && native_fd < FD_SETSIZE)\n     {\n       fd_set fset;\n       struct timeval tv;\n       FD_ZERO(&fset);\n-      FD_SET(fnum, &fset);\n+      FD_SET(native_fd, &fset);\n       tv.tv_sec = timeout / 1000;\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n-      if ((retval = _Jv_select (fnum + 1, &fset, &fset, NULL, &tv)) < 0)\n+      if ((retval = _Jv_select (native_fd + 1, &fset, &fset, NULL, &tv)) < 0)\n         goto error;\n       else if (retval == 0)\n         throw new ::java::net::SocketTimeoutException (\n \t                                  JvNewStringUTF(\"Accept timed out\"));\n     }\n \n-  new_socket = _Jv_accept (fnum, (sockaddr*) &u, &addrlen);\n+  new_socket = _Jv_accept (native_fd, (sockaddr*) &u, &addrlen);\n \n   if (new_socket < 0)\n     goto error;\n@@ -277,7 +277,7 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  s->fnum = new_socket;\n+  s->native_fd = new_socket;\n   s->localport = localport;\n   s->address = new ::java::net::InetAddress (raddr, NULL);\n   s->port = rport;\n@@ -296,7 +296,7 @@ gnu::java::net::PlainSocketImpl::close()\n   JvSynchronize sync (this);\n \n   // should we use shutdown here? how would that effect so_linger?\n-  int res = _Jv_close (fnum);\n+  int res = _Jv_close (native_fd);\n \n   if (res == -1)\n     {\n@@ -306,7 +306,7 @@ gnu::java::net::PlainSocketImpl::close()\n         throw new ::java::io::IOException  (JvNewStringUTF (strerror (errno)));\n     }\n   // Safe place to reset the file pointer.\n-  fnum = -1;\n+  native_fd = -1;\n   timeout = 0;\n }\n \n@@ -319,7 +319,7 @@ gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jint b)\n \n   while (r != 1)\n     {\n-      r = _Jv_write (this$0->fnum, &d, 1);\n+      r = _Jv_write (this$0->native_fd, &d, 1);\n       if (r == -1)\n         {\n           if (::java::lang::Thread::interrupted())\n@@ -352,7 +352,7 @@ gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jbyteArray b, jint off\n \n   while (len > 0)\n     {\n-      int r = _Jv_write (this$0->fnum, bytes, len);\n+      int r = _Jv_write (this$0->native_fd, bytes, len);\n \n       if (r == -1)\n         {\n@@ -389,22 +389,22 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n {\n   jbyte b;\n   jint timeout = this$0->timeout;\n-  jint fnum = this$0->fnum;\n+  jint native_fd = this$0->native_fd;\n \n   // Do timeouts via select.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0 && native_fd >= 0 && native_fd < FD_SETSIZE)\n     {\n       // Create the file descriptor set.\n       fd_set read_fds;\n       FD_ZERO (&read_fds);\n-      FD_SET (fnum,&read_fds);\n+      FD_SET (native_fd,&read_fds);\n       // Create the timeout struct based on our internal timeout value.\n       struct timeval timeout_value;\n       timeout_value.tv_sec = timeout / 1000;\n       timeout_value.tv_usec = (timeout % 1000) * 1000;\n       // Select on the fds.\n       int sel_retval =\n-        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+        _Jv_select (native_fd + 1, &read_fds, NULL, NULL, &timeout_value);\n       // If select returns 0 we've waited without getting data...\n       // that means we've timed out.\n       if (sel_retval == 0)\n@@ -414,7 +414,7 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n       // either way we need to try to read.\n     }\n \n-  int r = _Jv_read (fnum, &b, 1);\n+  int r = _Jv_read (native_fd, &b, 1);\n \n   if (r == 0)\n     return -1;\n@@ -445,7 +445,7 @@ jint\n gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, jint offset, \n   jint count)\n {\n-  jint fnum = this$0->fnum;\n+  jint native_fd = this$0->native_fd;\n   jint timeout = this$0->timeout;\n \n   if (! buffer)\n@@ -459,19 +459,19 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, jint\n   jbyte *bytes = elements (buffer) + offset;\n \n   // Do timeouts via select.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0 && native_fd >= 0 && native_fd < FD_SETSIZE)\n     {\n       // Create the file descriptor set.\n       fd_set read_fds;\n       FD_ZERO (&read_fds);\n-      FD_SET (fnum, &read_fds);\n+      FD_SET (native_fd, &read_fds);\n       // Create the timeout struct based on our internal timeout value.\n       struct timeval timeout_value;\n       timeout_value.tv_sec = timeout / 1000;\n       timeout_value.tv_usec =(timeout % 1000) * 1000;\n       // Select on the fds.\n       int sel_retval =\n-        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+        _Jv_select (native_fd + 1, &read_fds, NULL, NULL, &timeout_value);\n       // We're only interested in the 0 return.\n       // error returns still require us to try to read \n       // the socket to see what happened.\n@@ -485,7 +485,7 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, jint\n     }\n \n   // Read the socket.\n-  int r = ::recv (fnum, (char *) bytes, count, 0);\n+  int r = ::recv (native_fd, (char *) bytes, count, 0);\n \n   if (r == 0)\n     return -1;\n@@ -521,7 +521,7 @@ gnu::java::net::PlainSocketImpl::available(void)\n   bool num_set = false;\n \n #if defined(FIONREAD)\n-  r = ::ioctl (fnum, FIONREAD, &num);\n+  r = ::ioctl (native_fd, FIONREAD, &num);\n \n   if (r == -1 && errno == ENOTTY)\n     {\n@@ -532,7 +532,7 @@ gnu::java::net::PlainSocketImpl::available(void)\n   else\n     num_set = true;\n #elif defined(HAVE_SELECT)\n-  if (fnum < 0)\n+  if (native_fd < 0)\n     {\n       errno = EBADF;\n       r = -1;\n@@ -549,15 +549,15 @@ gnu::java::net::PlainSocketImpl::available(void)\n \n #if defined(HAVE_SELECT)\n   if (! num_set)\n-    if (! num_set && fnum >= 0 && fnum < FD_SETSIZE)\n+    if (! num_set && native_fd >= 0 && native_fd < FD_SETSIZE)\n       {\n         fd_set rd;\n         FD_ZERO (&rd);\n-        FD_SET (fnum, &rd);\n+        FD_SET (native_fd, &rd);\n         struct timeval tv;\n         tv.tv_sec = 0;\n         tv.tv_usec = 0;\n-        r = _Jv_select (fnum + 1, &rd, NULL, NULL, &tv);\n+        r = _Jv_select (native_fd + 1, &rd, NULL, NULL, &tv);\n         if(r == -1)\n           goto posix_error;\n         num = r == 0 ? 0 : 1;\n@@ -576,7 +576,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n   int val;\n   socklen_t val_len = sizeof (val);\n \n-  if (fnum < 0)\n+  if (native_fd < 0)\n     throw new ::java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n \n   if (_Jv_IsInstanceOf (value, &::java::lang::Boolean::class$))\n@@ -609,7 +609,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n     {\n       case _Jv_TCP_NODELAY_ :\n #ifdef TCP_NODELAY\n-        if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+        if (::setsockopt (native_fd, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n                           val_len) != 0)\n           goto error;\n #else\n@@ -619,7 +619,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         return;\n \n       case _Jv_SO_KEEPALIVE_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n                           val_len) != 0)\n           goto error;\n         break;\n@@ -630,7 +630,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         break;\n \t\n       case _Jv_SO_OOBINLINE_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n                           val_len) != 0)\n           goto error;\n         break;\n@@ -641,7 +641,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         l_val.l_onoff = (val != -1);\n         l_val.l_linger = val;\n \n-        if (::setsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n                           sizeof(l_val)) != 0)\n           goto error;    \n #else\n@@ -655,7 +655,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n+        if (::setsockopt (native_fd, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n           goto error;    \n #else\n         throw new ::java::lang::InternalError (\n@@ -684,7 +684,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         break;\n \t\n       case _Jv_IP_TOS_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n                           val_len) != 0)\n           goto error;    \n         break;\n@@ -721,7 +721,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n     {\n #ifdef TCP_NODELAY\n     case _Jv_TCP_NODELAY_ :\n-      if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+      if (::getsockopt (native_fd, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n                         &val_len) != 0)\n         goto error;\n       else\n@@ -734,7 +734,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n       \n     case _Jv_SO_LINGER_ :\n #ifdef SO_LINGER\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n                         &l_val_len) != 0)\n         goto error;    \n  \n@@ -749,20 +749,20 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n       break;    \n \n     case _Jv_SO_KEEPALIVE_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n                         &val_len) != 0)\n         goto error;\n       else\n         return new ::java::lang::Boolean (val != 0);\n \n     case _Jv_SO_BROADCAST_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n                         &val_len) != 0)\n         goto error;    \n       return new ::java::lang::Boolean ((jboolean)val);\n \t\n     case _Jv_SO_OOBINLINE_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n                         &val_len) != 0)\n         goto error;    \n       return new ::java::lang::Boolean ((jboolean)val);\n@@ -772,7 +772,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n       int opt;\n       optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-      if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n+      if (::getsockopt (native_fd, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n         goto error;    \n       else\n         return new ::java::lang::Integer (val);\n@@ -787,7 +787,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n         {\n           jbyteArray laddr;\n \n-          if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+          if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) != 0)\n             goto error;\n \n           if (u.address.sin_family == AF_INET)\n@@ -826,7 +826,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n       break;\n \t\n     case _Jv_IP_TOS_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n                         &val_len) != 0)\n         goto error;\n       return new ::java::lang::Integer (val);\n@@ -853,13 +853,13 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n void\n gnu::java::net::PlainSocketImpl::shutdownInput (void)\n {\n-  if (::shutdown (fnum, 0))\n+  if (::shutdown (native_fd, 0))\n     throw new ::java::net::SocketException (JvNewStringUTF (strerror (errno)));\n }\n \n void\n gnu::java::net::PlainSocketImpl::shutdownOutput (void)\n {\n-  if (::shutdown (fnum, 1))\n+  if (::shutdown (native_fd, 1))\n     throw new ::java::net::SocketException (JvNewStringUTF (strerror (errno)));\n }"}, {"sha": "411acfa023af71b3b37b2a178f6eedd9acffe2a9", "filename": "libjava/gnu/java/net/natPlainSocketImplWin32.cc", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c54b003358e3a314479edeafc13d1f7318a0497/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc?ref=7c54b003358e3a314479edeafc13d1f7318a0497", "patch": "@@ -54,9 +54,9 @@ gnu::java::net::PlainSocketImpl::create (jboolean stream)\n \n   _Jv_platform_close_on_exec (sock);\n \n-  // We use fnum in place of fd here.  From leaving fd null we avoid\n+  // We use native_fd in place of fd here.  From leaving fd null we avoid\n   // the double close problem in FileDescriptor.finalize.\n-  fnum = sock;\n+  native_fd = sock;\n }\n \n void\n@@ -94,16 +94,16 @@ gnu::java::net::PlainSocketImpl::bind (::java::net::InetAddress *host, jint lpor\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n   // Enable SO_REUSEADDR, so that servers can reuse ports left in TIME_WAIT.\n-  ::setsockopt(fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &i, sizeof(i));\n+  ::setsockopt(native_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &i, sizeof(i));\n \n-  if (::bind (fnum, ptr, len) != SOCKET_ERROR)\n+  if (::bind (native_fd, ptr, len) != SOCKET_ERROR)\n     {\n       address = host;\n       socklen_t addrlen = sizeof(u);\n \n       if (lport != 0)\n         localport = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != SOCKET_ERROR)\n+      else if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) != SOCKET_ERROR)\n         localport = ntohs (u.address.sin_port);\n       else\n         goto error;\n@@ -165,10 +165,10 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n   if (timeout > 0)\n     {\n       // FIXME: we're creating a fresh WSAEVENT for each connect().\n-      WSAEventWrapper aWSAEventWrapper(fnum, FD_CONNECT);\n+      WSAEventWrapper aWSAEventWrapper(native_fd, FD_CONNECT);\n       WSAEVENT hEvent = aWSAEventWrapper.getEventHandle ();\n \n-      if (::connect (fnum, ptr, len) == SOCKET_ERROR)\n+      if (::connect (native_fd, ptr, len) == SOCKET_ERROR)\n       {\n         if (WSAGetLastError () != WSAEWOULDBLOCK)\n           throwConnectException ();\n@@ -189,7 +189,7 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n         // connect() succeeded. Use any socket-specific error code\n         // instead of the thread-based one.\n         int nErrCode; int nErrLen=sizeof(nErrCode);\n-        if (::getsockopt(fnum, SOL_SOCKET, SO_ERROR, (char*) &nErrCode,\n+        if (::getsockopt(native_fd, SOL_SOCKET, SO_ERROR, (char*) &nErrCode,\n           &nErrLen) == SOCKET_ERROR)\n           {\n             throwConnectException ();\n@@ -203,7 +203,7 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n     }\n   else\n     {\n-      if (::connect (fnum, ptr, len) == SOCKET_ERROR)\n+      if (::connect (native_fd, ptr, len) == SOCKET_ERROR)\n         throwConnectException();\n     }\n \n@@ -213,7 +213,7 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n   // A bind may not have been done on this socket; if so, set localport now.\n   if (localport == 0)\n     {\n-      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != SOCKET_ERROR)\n+      if (::getsockname (native_fd, (sockaddr*) &u, &addrlen) != SOCKET_ERROR)\n         localport = ntohs (u.address.sin_port);\n       else\n         throwConnectException();\n@@ -223,7 +223,7 @@ gnu::java::net::PlainSocketImpl::connect (::java::net::SocketAddress *addr,\n void\n gnu::java::net::PlainSocketImpl::listen (jint backlog)\n {\n-  if (::listen (fnum, backlog) == SOCKET_ERROR)\n+  if (::listen (native_fd, backlog) == SOCKET_ERROR)\n     {\n       _Jv_ThrowIOException ();\n     }\n@@ -239,15 +239,15 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n   if (timeout > 0)\n     {\n       // FIXME: we're creating a fresh WSAEVENT for each accept().\n-      // One possible alternative would be that fnum really points\n+      // One possible alternative would be that native_fd really points\n       // to an extended structure consisting of the SOCKET, its\n       // associated WSAEVENT, etc.\n-      WSAEventWrapper aWSAEventWrapper(fnum, FD_ACCEPT);\n+      WSAEventWrapper aWSAEventWrapper(native_fd, FD_ACCEPT);\n       WSAEVENT hEvent = aWSAEventWrapper.getEventHandle ();\n \n       for (;;)\n       {\n-        new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n+        new_socket = ::accept (native_fd, (sockaddr*) &u, &addrlen);\n \n         if (new_socket != int(INVALID_SOCKET))\n         {\n@@ -285,7 +285,7 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n     }\n   else\n     {\n-      new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n+      new_socket = ::accept (native_fd, (sockaddr*) &u, &addrlen);\n     }\n \n   if (new_socket == int(INVALID_SOCKET))\n@@ -312,7 +312,7 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n   else\n     throw new ::java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  s->fnum = new_socket;\n+  s->native_fd = new_socket;\n   s->localport = localport;\n   s->address = new ::java::net::InetAddress (raddr, NULL);\n   s->port = rport;\n@@ -330,7 +330,7 @@ gnu::java::net::PlainSocketImpl::close()\n   JvSynchronize sync (this);\n \n   // should we use shutdown here? how would that effect so_linger?\n-  int res = ::closesocket (fnum);\n+  int res = ::closesocket (native_fd);\n \n   if (res == -1)\n     {\n@@ -342,7 +342,7 @@ gnu::java::net::PlainSocketImpl::close()\n         _Jv_ThrowIOException ();\n     }\n   // Safe place to reset the file pointer.\n-  fnum = -1;\n+  native_fd = -1;\n   timeout = 0;\n }\n \n@@ -355,7 +355,7 @@ gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jint b)\n \n   while (r != 1)\n     {\n-      r = ::send (this$0->fnum, (char*) &d, 1, 0);\n+      r = ::send (this$0->native_fd, (char*) &d, 1, 0);\n       if (r == -1)\n         {\n           DWORD dwErr = WSAGetLastError();\n@@ -390,7 +390,7 @@ gnu::java::net::PlainSocketImpl$SocketOutputStream::write(jbyteArray b,\n   int written = 0;\n   while (len > 0)\n     {\n-      int r = ::send (this$0->fnum, (char*) bytes, len, 0);\n+      int r = ::send (this$0->native_fd, (char*) bytes, len, 0);\n \n       if (r == -1)\n         {\n@@ -425,7 +425,7 @@ gnu::java::net::PlainSocketImpl::sendUrgentData (jint)\n \n // read() helper\n static jint\n-doRead(int fnum, void* buf, int count, int timeout)\n+doRead(int native_fd, void* buf, int count, int timeout)\n {\n   int r = 0;\n   DWORD dwErrorCode = 0;\n@@ -438,15 +438,15 @@ doRead(int fnum, void* buf, int count, int timeout)\n   // gone from a non-zero to zero timeout. What we'd\n   // really need is a member state variable in addition\n   // to timeout\n-  int nRet= ::setsockopt(fnum, SOL_SOCKET, SO_RCVTIMEO,\n+  int nRet= ::setsockopt(native_fd, SOL_SOCKET, SO_RCVTIMEO,\n     (char*)&timeout, sizeof(timeout));\n   if (nRet != NO_ERROR)\n   {\n     dwErrorCode = WSAGetLastError ();\n     goto error;\n   }\n   \n-  r = ::recv (fnum, (char*) buf, count, 0);\n+  r = ::recv (native_fd, (char*) buf, count, 0);\n \n   if (r == 0)\n     return -1;\n@@ -485,7 +485,7 @@ jint\n gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n {\n   jbyte b;\n-  doRead(this$0->fnum, &b, 1, this$0->timeout);\n+  doRead(this$0->native_fd, &b, 1, this$0->timeout);\n   return b & 0xFF;\n }\n \n@@ -505,7 +505,7 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer,\n   jbyte *bytes = elements (buffer) + offset;\n \n   // Read the socket.\n-  return doRead(this$0->fnum, bytes, count, this$0->timeout);\n+  return doRead(this$0->native_fd, bytes, count, this$0->timeout);\n }\n \n // How many bytes are available?\n@@ -514,7 +514,7 @@ gnu::java::net::PlainSocketImpl::available(void)\n {\n   unsigned long num = 0;\n \n-  if (::ioctlsocket (fnum, FIONREAD, &num) == SOCKET_ERROR)\n+  if (::ioctlsocket (native_fd, FIONREAD, &num) == SOCKET_ERROR)\n     _Jv_ThrowIOException ();\n \n   return (jint) num;\n@@ -526,7 +526,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n   int val;\n   socklen_t val_len = sizeof (val);\n \n-  if (fnum < 0)\n+  if (native_fd < 0)\n     throw new ::java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n \n   if (_Jv_IsInstanceOf (value, &::java::lang::Boolean::class$))\n@@ -558,13 +558,13 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n   switch (optID)\n     {\n       case _Jv_TCP_NODELAY_ :\n-        if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+        if (::setsockopt (native_fd, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n                           val_len) == SOCKET_ERROR)\n           goto error;\n         return;\n \n       case _Jv_SO_KEEPALIVE_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n                           val_len) == SOCKET_ERROR)\n           goto error;\n         break;\n@@ -575,7 +575,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         break;\n \n       case _Jv_SO_OOBINLINE_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n                           val_len) == SOCKET_ERROR)\n           goto error;\n         break;\n@@ -585,7 +585,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         l_val.l_onoff = (val != -1);\n         l_val.l_linger = val;\n \n-        if (::setsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n                           sizeof(l_val)) == SOCKET_ERROR)\n           goto error;\n         return;\n@@ -594,7 +594,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n       case _Jv_SO_RCVBUF_ :\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, opt, (char *) &val,\n                           val_len) == SOCKET_ERROR)\n           goto error;\n         return;\n@@ -620,7 +620,7 @@ gnu::java::net::PlainSocketImpl::setOption (jint optID, ::java::lang::Object *va\n         break;\n \n       case _Jv_IP_TOS_ :\n-        if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+        if (::setsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n                           val_len) == SOCKET_ERROR)\n           goto error;\n         break;\n@@ -655,15 +655,15 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n   switch (optID)\n     {\n     case _Jv_TCP_NODELAY_ :\n-      if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+      if (::getsockopt (native_fd, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n                         &val_len) == SOCKET_ERROR)\n         goto error;\n       else\n         return new ::java::lang::Boolean (val != 0);\n       break;\n \n     case _Jv_SO_LINGER_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n                         &l_val_len) == SOCKET_ERROR)\n         goto error;\n \n@@ -674,20 +674,20 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n       break;\n \n     case _Jv_SO_KEEPALIVE_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n                         &val_len) == SOCKET_ERROR)\n         goto error;\n       else\n         return new ::java::lang::Boolean (val != 0);\n \n     case _Jv_SO_BROADCAST_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n                         &val_len) == SOCKET_ERROR)\n         goto error;\n       return new ::java::lang::Boolean ((jboolean)val);\n \n     case _Jv_SO_OOBINLINE_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n                         &val_len) == SOCKET_ERROR)\n         goto error;\n       return new ::java::lang::Boolean ((jboolean)val);\n@@ -696,7 +696,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n     case _Jv_SO_SNDBUF_ :\n       int opt;\n       optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-      if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, opt, (char *) &val,\n                         &val_len) == SOCKET_ERROR)\n         goto error;\n       else\n@@ -708,7 +708,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n         {\n           jbyteArray laddr;\n \n-          if (::getsockname (fnum, (sockaddr*) &u,\n+          if (::getsockname (native_fd, (sockaddr*) &u,\n                              &addrlen) == SOCKET_ERROR)\n             goto error;\n \n@@ -748,7 +748,7 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n       break;\n \n     case _Jv_IP_TOS_ :\n-      if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+      if (::getsockopt (native_fd, SOL_SOCKET, IP_TOS, (char *) &val,\n                         &val_len) == SOCKET_ERROR)\n         goto error;\n       return new ::java::lang::Integer (val);\n@@ -776,13 +776,13 @@ gnu::java::net::PlainSocketImpl::getOption (jint optID)\n void\n gnu::java::net::PlainSocketImpl::shutdownInput (void)\n {\n-  if (::shutdown (fnum, 0))\n+  if (::shutdown (native_fd, 0))\n     _Jv_ThrowSocketException ();\n }\n \n void\n gnu::java::net::PlainSocketImpl::shutdownOutput (void)\n {\n-  if (::shutdown (fnum, 1))\n+  if (::shutdown (native_fd, 1))\n     _Jv_ThrowSocketException ();\n }"}]}