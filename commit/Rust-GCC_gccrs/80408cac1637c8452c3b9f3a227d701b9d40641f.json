{"sha": "80408cac1637c8452c3b9f3a227d701b9d40641f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0MDhjYWMxNjM3Yzg0NTJjM2I5ZjNhMjI3ZDcwMWI5ZDQwNjQxZg==", "commit": {"author": {"name": "Wu Yongwei", "email": "adah@sh163.net", "date": "2004-04-27T21:38:05Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2004-04-27T21:38:05Z"}, "message": "gthr-win32.h (__gthread_mutex_t): Change typedef to new structure.\n\n2004-04-27  Wu Yongwei  <adah@sh163.net>\n\n\t* gthr-win32.h (__gthread_mutex_t): Change typedef to new structure.\n\t(__GTHREAD_MUTEX_INIT_DEFAULT): Adjust.\n\t(__gthread_mutex_init_function): Replace CreateMutex with\n\tinitialization of custom mutex using CreateSemaphore.\n\t(__gthread_mutex_lock): Use InterlockedIncrement.\n\t(__gthread_mutex_trylock): Use InterlockedCompareExchange.\n\t(__gthread_mutex_unlock): Use InterlockedDecrement and\n\tReleaseSemaphore to unlock\n\t* config/i386/gthr-win32.c (__gthread_mutex_init_function,\n\t__gthread_mutex_lock, __gthread_mutex_trylock,\n\t__gthread_mutex_unlock): Adjust to match inline versions in\n\tgthr-win32.h.\n\nFrom-SVN: r81227", "tree": {"sha": "cfd7dc5d643ae5922fccb3082a401b80049d8d46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfd7dc5d643ae5922fccb3082a401b80049d8d46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80408cac1637c8452c3b9f3a227d701b9d40641f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80408cac1637c8452c3b9f3a227d701b9d40641f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80408cac1637c8452c3b9f3a227d701b9d40641f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80408cac1637c8452c3b9f3a227d701b9d40641f/comments", "author": null, "committer": null, "parents": [{"sha": "1f1d584b73ffdfaf6cbfbcb8541cf67ad5136e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f1d584b73ffdfaf6cbfbcb8541cf67ad5136e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f1d584b73ffdfaf6cbfbcb8541cf67ad5136e6f"}], "stats": {"total": 83, "additions": 58, "deletions": 25}, "files": [{"sha": "7bd874a42f5fa91be43131ef58e69860e3fbae16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80408cac1637c8452c3b9f3a227d701b9d40641f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80408cac1637c8452c3b9f3a227d701b9d40641f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80408cac1637c8452c3b9f3a227d701b9d40641f", "patch": "@@ -1,3 +1,18 @@\n+2004-04-27  Wu Yongwei  <adah@sh163.net>\n+\n+\t* gthr-win32.h (__gthread_mutex_t): Change typedef to new structure.\n+\t(__GTHREAD_MUTEX_INIT_DEFAULT): Adjust.\n+\t(__gthread_mutex_init_function): Replace CreateMutex with\n+\tinitialization of custom mutex using CreateSemaphore.\n+\t(__gthread_mutex_lock): Use InterlockedIncrement.\n+\t(__gthread_mutex_trylock): Use InterlockedCompareExchange.\n+\t(__gthread_mutex_unlock): Use InterlockedDecrement and\n+\tReleaseSemaphore to unlock\n+\t* config/i386/gthr-win32.c (__gthread_mutex_init_function,\n+\t__gthread_mutex_lock, __gthread_mutex_trylock,\n+\t__gthread_mutex_unlock): Adjust to match inline versions in\n+\tgthr-win32.h.\n+\n 2004-04-27  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (arm_promote_prototypes): New function."}, {"sha": "e4852afef8010d752972911e5aefb669bbc571d6", "filename": "gcc/config/i386/gthr-win32.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80408cac1637c8452c3b9f3a227d701b9d40641f/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80408cac1637c8452c3b9f3a227d701b9d40641f/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgthr-win32.c?ref=80408cac1637c8452c3b9f3a227d701b9d40641f", "patch": "@@ -61,10 +61,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       This may cause incorrect error return due to truncation values on \n       hw where sizeof (DWORD) > sizeof (int).\n    \n-   3. We might consider using Critical Sections instead of Windows32 \n-      mutexes for better performance, but emulating __gthread_mutex_trylock \n-      interface becomes more complicated (Win9x does not support\n-      TryEnterCriticalSectioni, while NT does).\n+   3. We are currently using a special mutex instead of the Critical\n+      Sections, since Win9x does not support TryEnterCriticalSection\n+      (while NT does).\n   \n    The basic framework should work well enough. In the long term, GCC\n    needs to use Structured Exception Handling on Windows32.  */\n@@ -145,23 +144,29 @@ __gthr_win32_setspecific (__gthread_key_t key, const void *ptr)\n void\n __gthr_win32_mutex_init_function (__gthread_mutex_t *mutex)\n {\n-  /* Create unnamed mutex with default security attr and no initial owner.  */ \n-  *mutex = CreateMutex (NULL, 0, NULL);\n+  mutex->counter = 0;\n+  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n }\n \n int\n __gthr_win32_mutex_lock (__gthread_mutex_t *mutex)\n {\n-  if (WaitForSingleObject (*mutex, INFINITE) == WAIT_OBJECT_0)\n+  if (InterlockedIncrement (&mutex->counter) == 1 ||\n+      WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n     return 0;\n   else\n-    return 1;\n+    {\n+      // WaitForSingleObject returns WAIT_FAILED, and we can only do\n+      // some best-effort cleanup here.\n+      InterlockedDecrement (&mutex->counter);\n+      return 1;\n+    }\n }\n \n int\n __gthr_win32_mutex_trylock (__gthread_mutex_t *mutex)\n {\n-  if (WaitForSingleObject (*mutex, 0) == WAIT_OBJECT_0)\n+  if (InterlockedCompareExchange (&mutex->counter, 1, 0 ) == 0)\n     return 0;\n   else\n     return 1;\n@@ -170,5 +175,8 @@ __gthr_win32_mutex_trylock (__gthread_mutex_t *mutex)\n int\n __gthr_win32_mutex_unlock (__gthread_mutex_t *mutex)\n {\n-    return (ReleaseMutex (*mutex) != 0) ? 0 : 1;\n+  if (InterlockedDecrement (&mutex->counter))\n+    return ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n+  else\n+    return 0;\n }"}, {"sha": "e399047e485d2f661af637c360c7fb3c01a18d7e", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80408cac1637c8452c3b9f3a227d701b9d40641f/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80408cac1637c8452c3b9f3a227d701b9d40641f/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=80408cac1637c8452c3b9f3a227d701b9d40641f", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1999, 2000, 2002, 2003  Free Software Foundation, Inc.\n+/* Copyright (C) 1999, 2000, 2002, 2003, 2004  Free Software Foundation, Inc.\n    Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n \n This file is part of GCC.\n@@ -54,10 +54,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       This may cause incorrect error return due to truncation values on\n       hw where sizeof (DWORD) > sizeof (int).\n \n-   3. We might consider using Critical Sections instead of Windows32\n-      mutexes for better performance, but emulating __gthread_mutex_trylock\n-      interface becomes more complicated (Win9x does not support\n-      TryEnterCriticalSectioni, while NT does).\n+   3. We are currently using a special mutex instead of the Critical\n+      Sections, since Win9x does not support TryEnterCriticalSection\n+      (while NT does).\n \n    The basic framework should work well enough. In the long term, GCC\n    needs to use Structured Exception Handling on Windows32.  */\n@@ -339,11 +338,14 @@ typedef struct {\n   long started;\n } __gthread_once_t;\n \n-typedef void* __gthread_mutex_t;\n+typedef struct {\n+  long counter;\n+  void *sema;\n+} __gthread_mutex_t;\n \n #define __GTHREAD_ONCE_INIT {0, -1}\n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n-#define __GTHREAD_MUTEX_INIT_DEFAULT 0\n+#define __GTHREAD_MUTEX_INIT_DEFAULT {0, 0}\n \n #if __MINGW32_MAJOR_VERSION >= 1 || \\\n   (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n@@ -534,8 +536,8 @@ __gthread_setspecific (__gthread_key_t key, const void *ptr)\n static inline void\n __gthread_mutex_init_function (__gthread_mutex_t *mutex)\n {\n-  /* Create unnamed mutex with default security attr and no initial owner.  */\n-  *mutex = CreateMutex (NULL, 0, NULL);\n+  mutex->counter = 0;\n+  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n }\n \n static inline int\n@@ -545,10 +547,16 @@ __gthread_mutex_lock (__gthread_mutex_t *mutex)\n \n   if (__gthread_active_p ())\n     {\n-      if (WaitForSingleObject (*mutex, INFINITE) == WAIT_OBJECT_0)\n+      if (InterlockedIncrement (&mutex->counter) == 1 ||\n+\t  WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n \tstatus = 0;\n       else\n-\tstatus = 1;\n+\t{\n+\t  // WaitForSingleObject returns WAIT_FAILED, and we can only do\n+\t  // some best-effort cleanup here.\n+\t  InterlockedDecrement (&mutex->counter);\n+\t  status = 1;\n+\t}\n     }\n   return status;\n }\n@@ -560,7 +568,7 @@ __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n \n   if (__gthread_active_p ())\n     {\n-      if (WaitForSingleObject (*mutex, 0) == WAIT_OBJECT_0)\n+      if (InterlockedCompareExchange (&mutex->counter, 1, 0 ) == 0)\n \tstatus = 0;\n       else\n \tstatus = 1;\n@@ -572,9 +580,11 @@ static inline int\n __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n-    return (ReleaseMutex (*mutex) != 0) ? 0 : 1;\n-  else\n-    return 0;\n+    {\n+      if (InterlockedDecrement (&mutex->counter))\n+\treturn ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n+    }\n+  return 0;\n }\n \n #endif /*  __GTHREAD_HIDE_WIN32API */"}]}