{"sha": "b3abc9d82253e6ecf097d703bd069f0054b22f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNhYmM5ZDgyMjUzZTZlY2YwOTdkNzAzYmQwNjlmMDA1NGIyMmY1Mw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-07-05T21:21:07Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-07-05T21:21:07Z"}, "message": "hashtable_policy.h (_ReuseOrAllocNode): Use forward pattern.\n\n2013-07-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable_policy.h (_ReuseOrAllocNode): Use forward\n\tpattern.\n\t(_MoveReuseOrAllocNode): Remove.\n\t(_Insert_base): Take a functor defining how the node is generated.\n\t* include/bits/hashtable.h: Adapt.\n\t(operator=(initializer_list<value_type>)): Reuse node if any.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/unordered_set/\n\tnot_default_constructible_hash_neg.cc: Likewise.\n\nFrom-SVN: r200724", "tree": {"sha": "2c8131d6719d93f9ea17d9101511b18ff4766f65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c8131d6719d93f9ea17d9101511b18ff4766f65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3abc9d82253e6ecf097d703bd069f0054b22f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3abc9d82253e6ecf097d703bd069f0054b22f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3abc9d82253e6ecf097d703bd069f0054b22f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3abc9d82253e6ecf097d703bd069f0054b22f53/comments", "author": null, "committer": null, "parents": [{"sha": "2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c"}], "stats": {"total": 358, "additions": 191, "deletions": 167}, "files": [{"sha": "08cfe7ad4e34a1c875739c1bf17121ef73db78ba", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b3abc9d82253e6ecf097d703bd069f0054b22f53", "patch": "@@ -1,3 +1,16 @@\n+2013-07-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable_policy.h (_ReuseOrAllocNode): Use forward\n+\tpattern.\n+\t(_MoveReuseOrAllocNode): Remove.\n+\t(_Insert_base): Take a functor defining how the node is generated.\n+\t* include/bits/hashtable.h: Adapt.\n+\t(operator=(initializer_list<value_type>)): Reuse node if any.\n+\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n+\tAdjust dg-error line number.\n+\t* testsuite/23_containers/unordered_set/\n+\tnot_default_constructible_hash_neg.cc: Likewise.\n+\n 2013-07-04  Veres Lajos  <vlajos@gmail.com>\n \t    Jonathan Wakely  <jwakely.gcc@gmail.com>\n "}, {"sha": "44ce3b30ef8d64f9e07d1328abb8ea9f69afa900", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=b3abc9d82253e6ecf097d703bd069f0054b22f53", "patch": "@@ -239,6 +239,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n \t\t\t\t\t    _RehashPolicy, _Traits>;\n \n+      using __reuse_or_alloc_node_type =\n+\t__detail::_ReuseOrAllocNode<_Key, _Value, _Alloc,\n+\t\t\t\t    _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t\t\t    _RehashPolicy, _Traits>;\n+\n       // Metaprogramming for picking apart hash caching.\n       template<typename _Cond>\n \tusing __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;\n@@ -284,7 +289,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    \"Cache the hash code or make functors involved in hash code\"\n \t\t    \" and bucket index computation copy assignable\");\n \n-    public:\n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n \t       typename _H1a, typename _H2a, typename _Hasha,\n@@ -308,17 +312,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n \t       typename _H1a, typename _H2a, typename _Hasha,\n-\t       typename _RehashPolicya, typename _Traitsa,\n-\t       bool _IsCopyAssignable>\n+\t       typename _RehashPolicya, typename _Traitsa>\n \tfriend struct __detail::_ReuseOrAllocNode;\n \n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n \t       typename _H1a, typename _H2a, typename _Hasha,\n-\t       typename _RehashPolicya, typename _Traitsa,\n-\t       bool _IsMoveAssignable>\n-\tfriend struct __detail::_MoveReuseOrAllocNode;\n+\t       typename _RehashPolicya, typename _Traitsa>\n+\tfriend struct __detail::_AllocNode;\n \n+    public:\n       using size_type = typename __hashtable_base::size_type;\n       using difference_type = typename __hashtable_base::difference_type;\n \n@@ -394,9 +397,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_begin() const\n       { return static_cast<__node_type*>(_M_before_begin()._M_nxt); }\n \n-      template<typename _UnaryOp>\n+      template<typename _NodeGenerator>\n \tvoid\n-\t_M_assign(const _Hashtable&, const _UnaryOp&);\n+\t_M_assign(const _Hashtable&, const _NodeGenerator&);\n \n       void\n       _M_move_assign(_Hashtable&&, std::true_type);\n@@ -487,8 +490,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable&\n       operator=(initializer_list<value_type> __l)\n       {\n+\t__reuse_or_alloc_node_type __roan(_M_begin(), *this);\n+\t_M_before_begin()._M_nxt = nullptr;\n \tclear();\n-\tthis->insert(__l.begin(), __l.end());\n+\tthis->_M_insert_range(__l.begin(), __l.end(), __roan);\n \treturn *this;\n       }\n \n@@ -701,25 +706,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \titerator\n \t_M_emplace(const_iterator, std::false_type, _Args&&... __args);\n \n-      template<typename _Arg>\n+      template<typename _Arg, typename _NodeGenerator>\n \tstd::pair<iterator, bool>\n-\t_M_insert(_Arg&&, std::true_type);\n+\t_M_insert(_Arg&&, const _NodeGenerator&, std::true_type);\n \n-      template<typename _Arg>\n+      template<typename _Arg, typename _NodeGenerator>\n \titerator\n-\t_M_insert(_Arg&& __arg, std::false_type __uk)\n-\t{ return _M_insert(cend(), std::forward<_Arg>(__arg), __uk); }\n+\t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n+\t\t  std::false_type __uk)\n+\t{\n+\t  return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,\n+\t\t\t   __uk);\n+\t}\n \n       // Insert with hint, not used when keys are unique.\n-      template<typename _Arg>\n+      template<typename _Arg, typename _NodeGenerator>\n \titerator\n-\t_M_insert(const_iterator, _Arg&& __arg, std::true_type __uk)\n-\t{ return _M_insert(std::forward<_Arg>(__arg), __uk).first; }\n+\t_M_insert(const_iterator, _Arg&& __arg, const _NodeGenerator& __node_gen,\n+\t\t  std::true_type __uk)\n+\t{\n+\t  return\n+\t    _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;\n+\t}\n \n       // Insert with hint when keys are not unique.\n-      template<typename _Arg>\n+      template<typename _Arg, typename _NodeGenerator>\n \titerator\n-\t_M_insert(const_iterator, _Arg&&, std::false_type);\n+\t_M_insert(const_iterator, _Arg&&, const _NodeGenerator&, std::false_type);\n \n       size_type\n       _M_erase(std::true_type, const key_type&);\n@@ -1029,12 +1042,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __hashtable_base::operator=(__ht);\n \t    _M_element_count = __ht._M_element_count;\n \t    _M_rehash_policy = __ht._M_rehash_policy;\n-\t    __detail::_ReuseOrAllocNode<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t_RehashPolicy, _Traits>\n-\t      __roan(_M_begin(), *this);\n+\t    __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n \t    _M_before_begin()._M_nxt = nullptr;\n-\t    _M_assign(__ht, __roan);\n+\t    _M_assign(__ht, \n+\t\t      [&__roan](const __node_type* __n)\n+\t\t      { return __roan(__n->_M_v()); });\n \t    if (__former_buckets)\n \t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n \t  }\n@@ -1059,11 +1071,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    template<typename _UnaryOp>\n+    template<typename _NodeGenerator>\n       void\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_assign(const _Hashtable& __ht, const _UnaryOp& __node_getter)\n+      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)\n       {\n \t__bucket_type* __buckets = nullptr;\n \tif (!_M_buckets)\n@@ -1077,7 +1089,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // First deal with the special first node pointed to by\n \t    // _M_before_begin.\n \t    __node_type* __ht_n = __ht._M_begin();\n-\t    __node_type* __this_n = __node_getter(__ht_n);\n+\t    __node_type* __this_n = __node_gen(__ht_n);\n \t    this->_M_copy_code(__this_n, __ht_n);\n \t    _M_before_begin()._M_nxt = __this_n;\n \t    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin();\n@@ -1086,7 +1098,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __node_base* __prev_n = __this_n;\n \t    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n \t      {\n-\t\t__this_n = __node_getter(__ht_n);\n+\t\t__this_n = __node_gen(__ht_n);\n \t\t__prev_n->_M_nxt = __this_n;\n \t\tthis->_M_copy_code(__this_n, __ht_n);\n \t\tsize_type __bkt = _M_bucket_index(__this_n);\n@@ -1181,12 +1193,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __hashtable_base::operator=(std::move(__ht));\n \t      _M_element_count = __ht._M_element_count;\n \t      _M_rehash_policy = __ht._M_rehash_policy;\n-\t      __detail::_MoveReuseOrAllocNode<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t\t      _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t      _RehashPolicy, _Traits>\n-\t\t__mroan(_M_begin(), *this);\n+\t      __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n \t      _M_before_begin()._M_nxt = nullptr;\n-\t      _M_assign(__ht, __mroan);\n+\t      _M_assign(__ht,\n+\t\t\t[&__roan](__node_type* __n)\n+\t\t\t{ return __roan(std::move_if_noexcept(__n->_M_v())); });\n \t      __ht.clear();\n \t    }\n \t  __catch(...)\n@@ -1534,11 +1545,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base* __prev_p = _M_buckets[__n];\n       if (!__prev_p)\n \treturn nullptr;\n-      __node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);\n-      for (;; __p = __p->_M_next())\n+\n+      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;\n+\t   __p = __p->_M_next())\n \t{\n \t  if (this->_M_equals(__k, __code, __p))\n \t    return __prev_p;\n+\n \t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n \t    break;\n \t  __prev_p = __p;\n@@ -1796,14 +1809,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    template<typename _Arg>\n+    template<typename _Arg, typename _NodeGenerator>\n       std::pair<typename _Hashtable<_Key, _Value, _Alloc,\n \t\t\t\t    _ExtractKey, _Equal, _H1,\n \t\t\t\t    _H2, _Hash, _RehashPolicy,\n \t\t\t\t    _Traits>::iterator, bool>\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_insert(_Arg&& __v, std::true_type)\n+      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, std::true_type)\n       {\n \tconst key_type& __k = this->_M_extract()(__v);\n \t__hash_code __code = this->_M_hash_code(__k);\n@@ -1813,7 +1826,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (__n)\n \t  return std::make_pair(iterator(__n), false);\n \n-\t__n = _M_allocate_node(std::forward<_Arg>(__v));\n+\t__n = __node_gen(std::forward<_Arg>(__v));\n \treturn std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);\n       }\n \n@@ -1822,20 +1835,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    template<typename _Arg>\n+    template<typename _Arg, typename _NodeGenerator>\n       typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n \t\t\t  _Traits>::iterator\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_insert(const_iterator __hint, _Arg&& __v, std::false_type)\n+      _M_insert(const_iterator __hint, _Arg&& __v,\n+\t\tconst _NodeGenerator& __node_gen,\n+\t\tstd::false_type)\n       {\n \t// First compute the hash code so that we don't do anything if it\n \t// throws.\n \t__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));\n \n \t// Second allocate new node so that we don't rehash if it throws.\n-\t__node_type* __node = _M_allocate_node(std::forward<_Arg>(__v));\n+\t__node_type* __node = __node_gen(std::forward<_Arg>(__v));\n \n \treturn _M_insert_multi_node(__hint._M_cur, __code, __node);\n       }"}, {"sha": "a95b8d4f6a545457b33645ff84913efd785d7076", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 120, "deletions": 124, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=b3abc9d82253e6ecf097d703bd069f0054b22f53", "patch": "@@ -102,6 +102,90 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return std::get<0>(std::forward<_Tp>(__x)); }\n   };\n \n+  // Functor recycling a pool of nodes and using allocation once the pool is\n+  // empty.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _ReuseOrAllocNode\n+    {\n+    private:\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+      using __val_alloc_type = typename __hashtable::_Value_alloc_type;\n+      using __val_alloc_traits = typename __hashtable::_Value_alloc_traits;\n+      using __node_alloc_traits = typename __hashtable::_Node_alloc_traits;\n+      using __node_type = typename __hashtable::__node_type;\n+\n+    public:\n+      _ReuseOrAllocNode(__node_type* __nodes, __hashtable& __h)\n+\t: _M_nodes(__nodes), _M_h(__h) { }\n+      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;\n+\n+      ~_ReuseOrAllocNode()\n+      { _M_h._M_deallocate_nodes(_M_nodes); }\n+\n+      template<typename _Arg>\n+\t__node_type*\n+\toperator()(_Arg&& __arg) const\n+\t{\n+\t  if (_M_nodes)\n+\t    {\n+\t      __node_type* __node = _M_nodes;\n+\t      _M_nodes = _M_nodes->_M_next();\n+\t      __node->_M_nxt = nullptr;\n+\t      __val_alloc_type __a(_M_h._M_node_allocator());\n+\t      __val_alloc_traits::destroy(__a, __node->_M_valptr());\n+\t      __try\n+\t\t{\n+\t\t  __val_alloc_traits::construct(__a, __node->_M_valptr(),\n+\t\t\t\t\t\tstd::forward<_Arg>(__arg));\n+\t\t}\n+\t      __catch(...)\n+\t\t{\n+\t\t  __node->~__node_type();\n+\t\t  __node_alloc_traits::deallocate(_M_h._M_node_allocator(),\n+\t\t\t\t\t\t  __node, 1);\n+\t\t  __throw_exception_again;\n+\t\t}\n+\t      return __node;\n+\t    }\n+\t  return _M_h._M_allocate_node(std::forward<_Arg>(__arg));\n+\t}\n+\n+    private:\n+      mutable __node_type* _M_nodes;\n+      __hashtable& _M_h;\n+    };\n+\n+  // Functor similar to the previous one but without any pool of node to recycle.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _AllocNode\n+    {\n+    private:\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n+      using __node_type = typename __hashtable::__node_type;\n+\n+    public:\n+      _AllocNode(__hashtable& __h)\n+\t: _M_h(__h) { }\n+\n+      template<typename _Arg>\n+\t__node_type*\n+\toperator()(_Arg&& __arg) const\n+\t{ return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }\n+\n+    private:\n+      __hashtable& _M_h;\n+    };\n+\n   // Auxiliary types used for all instantiations of _Hashtable nodes\n   // and iterators.\n \n@@ -597,6 +681,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Insert_base\n     {\n+    protected:\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t     _Equal, _H1, _H2, _Hash,\n \t\t\t\t     _RehashPolicy, _Traits>;\n@@ -612,23 +697,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __unique_keys = typename __hashtable_base::__unique_keys;\n       using __ireturn_type = typename __hashtable_base::__ireturn_type;\n+      using __node_gen_type = _AllocNode<_Key, _Value, _Alloc, _ExtractKey,\n+\t\t\t\t\t _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t _RehashPolicy, _Traits>;\n \n       __hashtable&\n       _M_conjure_hashtable()\n       { return *(static_cast<__hashtable*>(this)); }\n \n+      template<typename _InputIterator, typename _NodeGetter>\n+\tvoid\n+\t_M_insert_range(_InputIterator __first, _InputIterator __last,\n+\t\t\tconst _NodeGetter&);\n+\n+    public:\n       __ireturn_type\n       insert(const value_type& __v)\n       {\n \t__hashtable& __h = _M_conjure_hashtable();\n-\treturn __h._M_insert(__v, __unique_keys());\n+\t__node_gen_type __node_gen(__h);\n+\treturn __h._M_insert(__v, __node_gen, __unique_keys());\n       }\n \n       iterator\n       insert(const_iterator __hint, const value_type& __v)\n       {\n \t__hashtable& __h = _M_conjure_hashtable();\n-\treturn __h._M_insert(__hint, __v, __unique_keys());\n+\t__node_gen_type __node_gen(__h);\t\n+\treturn __h._M_insert(__hint, __v, __node_gen, __unique_keys());\n       }\n \n       void\n@@ -637,18 +733,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _InputIterator>\n \tvoid\n-\tinsert(_InputIterator __first, _InputIterator __last);\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{\n+\t  __hashtable& __h = _M_conjure_hashtable();\n+\t  __node_gen_type __node_gen(__h);\n+\t  return _M_insert_range(__first, __last, __node_gen);\n+\t}\n     };\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   typename _RehashPolicy, typename _Traits>\n-    template<typename _InputIterator>\n+    template<typename _InputIterator, typename _NodeGetter>\n       void\n       _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n \t\t    _RehashPolicy, _Traits>::\n-      insert(_InputIterator __first, _InputIterator __last)\n+      _M_insert_range(_InputIterator __first, _InputIterator __last,\n+\t\t      const _NodeGetter& __node_gen)\n       {\n \tusing __rehash_type = typename __hashtable::__rehash_type;\n \tusing __rehash_state = typename __hashtable::__rehash_state;\n@@ -667,7 +769,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __h._M_rehash(__do_rehash.second, __saved_state);\n \n \tfor (; __first != __last; ++__first)\n-\t  __h._M_insert(*__first, __unique_keys());\n+\t  __h._M_insert(*__first, __node_gen, __unique_keys());\n       }\n \n   /**\n@@ -702,21 +804,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __unique_keys = typename __base_type::__unique_keys;\n       using __hashtable = typename __base_type::__hashtable;\n+      using __node_gen_type = typename __base_type::__node_gen_type;\n \n       using __base_type::insert;\n \n       std::pair<iterator, bool>\n       insert(value_type&& __v)\n       {\n \t__hashtable& __h = this->_M_conjure_hashtable();\n-\treturn __h._M_insert(std::move(__v), __unique_keys());\n+\t__node_gen_type __node_gen(__h);\n+\treturn __h._M_insert(std::move(__v), __node_gen, __unique_keys());\n       }\n \n       iterator\n       insert(const_iterator __hint, value_type&& __v)\n       {\n \t__hashtable& __h = this->_M_conjure_hashtable();\n-\treturn __h._M_insert(__hint, std::move(__v), __unique_keys());\n+\t__node_gen_type __node_gen(__h);\n+\treturn __h._M_insert(__hint, std::move(__v), __node_gen,\n+\t\t\t     __unique_keys());\n       }\n     };\n \n@@ -739,21 +845,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __unique_keys = typename __base_type::__unique_keys;\n       using __hashtable = typename __base_type::__hashtable;\n+      using __node_gen_type = typename __base_type::__node_gen_type;\n \n       using __base_type::insert;\n \n       iterator\n       insert(value_type&& __v)\n       {\n \t__hashtable& __h = this->_M_conjure_hashtable();\n-\treturn __h._M_insert(std::move(__v), __unique_keys());\n+\t__node_gen_type __node_gen(__h);\n+\treturn __h._M_insert(std::move(__v), __node_gen, __unique_keys());\n       }\n \n       iterator\n       insert(const_iterator __hint, value_type&& __v)\n       {\n \t__hashtable& __h = this->_M_conjure_hashtable();\n-\treturn __h._M_insert(__hint, std::move(__v), __unique_keys());\n+\t__node_gen_type __node_gen(__h);\n+\treturn __h._M_insert(__hint, std::move(__v), __node_gen,\n+\t\t\t     __unique_keys());\n       }\n     };\n \n@@ -1694,120 +1804,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n     };\n \n-  /*\n-   * Following are functors recyclicing a pool of nodes and using allocation\n-   * once the pool is empty.\n-   */\n-  /// Version using copy semantic through the copy constructor.\n-  template<typename _Key, typename _Value, typename _Alloc,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n-\t   typename _RehashPolicy, typename _Traits>\n-    struct _ReuseOrAllocNode\n-    {\n-    private:\n-      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t     _Equal, _H1, _H2, _Hash,\n-\t\t\t\t     _RehashPolicy, _Traits>;\n-      using __val_alloc_type = typename __hashtable::_Value_alloc_type;\n-      using __val_alloc_traits = typename __hashtable::_Value_alloc_traits;\n-      using __node_alloc_traits = typename __hashtable::_Node_alloc_traits;\n-      using __node_type = typename __hashtable::__node_type;\n-\n-    public:\n-      _ReuseOrAllocNode(__node_type* __nodes, __hashtable& __h)\n-\t: _M_nodes(__nodes), _M_h(__h) { }\n-      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;\n-\n-      ~_ReuseOrAllocNode()\n-      { _M_h._M_deallocate_nodes(_M_nodes); }\n-\n-      __node_type*\n-      operator()(const __node_type* __n) const\n-      {\n-\tif (_M_nodes)\n-\t  {\n-\t    __node_type* __node = _M_nodes;\n-\t    _M_nodes = _M_nodes->_M_next();\n-\t    __node->_M_nxt = nullptr;\n-\t    __val_alloc_type __a(_M_h._M_node_allocator());\n-\t    __val_alloc_traits::destroy(__a, __node->_M_valptr());\n-\t    __try\n-\t      {\n-\t\t__val_alloc_traits::construct(__a, __node->_M_valptr(),\n-\t\t\t\t\t      __n->_M_v());\n-\t      }\n-\t    __catch(...)\n-\t      {\n-\t\t__node->~__node_type();\n-\t\t__node_alloc_traits::deallocate(_M_h._M_node_allocator(),\n-\t\t\t\t\t\t__node, 1);\n-\t\t__throw_exception_again;\n-\t      }\n-\t    return __node;\n-\t  }\n-\treturn _M_h._M_allocate_node(__n->_M_v());\n-      }\n-\n-      mutable __node_type* _M_nodes;\n-      __hashtable& _M_h;\n-    };\n-\n-  /// Version using move semantic through the move constructor.\n-  template<typename _Key, typename _Value, typename _Alloc,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n-\t   typename _RehashPolicy, typename _Traits>\n-    struct _MoveReuseOrAllocNode\n-    {\n-    private:\n-      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t     _Equal, _H1, _H2, _Hash,\n-\t\t\t\t     _RehashPolicy, _Traits>;\n-      using __val_alloc_type = typename __hashtable::_Value_alloc_type;\n-      using __val_alloc_traits = typename __hashtable::_Value_alloc_traits;\n-      using __node_alloc_traits = typename __hashtable::_Node_alloc_traits;\n-      using __node_type = typename __hashtable::__node_type;\n-\n-    public:\n-      _MoveReuseOrAllocNode(__node_type* __nodes, __hashtable& __h)\n-\t: _M_nodes(__nodes), _M_h(__h) { }\n-      _MoveReuseOrAllocNode(const _MoveReuseOrAllocNode&) = delete;\n-\n-      ~_MoveReuseOrAllocNode()\n-      { _M_h._M_deallocate_nodes(_M_nodes); }\n-\n-      __node_type*\n-      operator()(__node_type* __n) const\n-      {\n-\tif (_M_nodes)\n-\t  {\n-\t    __node_type* __node = _M_nodes;\n-\t    _M_nodes = _M_nodes->_M_next();\n-\t    __node->_M_nxt = nullptr;\n-\t    __val_alloc_type  __a(_M_h._M_node_allocator());\n-\t    __val_alloc_traits::destroy(__a, __node->_M_valptr());\n-\t    __try\n-\t      {\n-\t\t__val_alloc_traits::construct(__a, __node->_M_valptr(),\n-\t\t\t\t\tstd::move_if_noexcept(__n->_M_v()));\n-\t      }\n-\t    __catch(...)\n-\t      {\n-\t\t__node->~__node_type();\n-\t\t__node_alloc_traits::deallocate(_M_h._M_node_allocator(),\n-\t\t\t\t\t\t__node, 1);\n-\t\t__throw_exception_again;\n-\t      }\n-\t    return __node;\n-\t  }\n-\treturn _M_h._M_allocate_node(std::move_if_noexcept(__n->_M_v()));\n-      }\n-\n-      mutable __node_type* _M_nodes;\n-      __hashtable& _M_h;\n-    };\n-\n  //@} hashtable-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail"}, {"sha": "ff0c832dd88d680564fa95135f14410a8548e85b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=b3abc9d82253e6ecf097d703bd069f0054b22f53", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 253 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 258 }\n \n #include <unordered_set>\n "}, {"sha": "be5b1201edd4d429f21a0b6a0ecb1d93e64b975d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/not_default_constructible_hash_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3abc9d82253e6ecf097d703bd069f0054b22f53/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc?ref=b3abc9d82253e6ecf097d703bd069f0054b22f53", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"default constructible\" \"\" { target *-*-* } 271 }\n+// { dg-error \"default constructible\" \"\" { target *-*-* } 276 }\n \n #include <unordered_set>\n "}]}