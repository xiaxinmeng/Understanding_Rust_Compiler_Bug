{"sha": "41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFiMWJhZDQwMmFhM2RjYjM2NTdjNzVlMGM5M2UyYTExNGQyZTJjYg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-25T14:47:10Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Added more error_at formatting fixes\n\nDebug for parsing failure with partially consolidated lifetime parsing\n\nMore debug for parsing failure\n\nCorrected the apparent lack of skip_token in parse_lifetime_param()", "tree": {"sha": "82793a1b58ba8507a220a4173896e2b88c43c612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82793a1b58ba8507a220a4173896e2b88c43c612"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "636b1630184a37a9d5647cff19103bca34c8f125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b1630184a37a9d5647cff19103bca34c8f125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636b1630184a37a9d5647cff19103bca34c8f125"}], "stats": {"total": 374, "additions": 190, "deletions": 184}, "files": [{"sha": "64aad25d6a87ba2e3e40d3f13f229a387c59ec81", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "patch": "@@ -869,7 +869,7 @@ Lexer::parse_in_type_suffix ()\n     }\n   else\n     {\n-      rust_error_at (get_current_location (), \"unknown number suffix %<%s%>\",\n+      rust_error_at (get_current_location (), \"unknown number suffix %qs\",\n \t\t     suffix.c_str ());\n \n       return std::make_pair (CORETYPE_UNKNOWN, additional_length_offset);\n@@ -969,8 +969,10 @@ Lexer::parse_escape (char opening_char)\n \tif (hexLong > 255 || hexLong < 0)\n \t  rust_error_at (\n \t    get_current_location (),\n-\t    \"byte \\\\x escape %<\\\\x%X%> out of range - allows up to %<\\\\xFF%>\",\n+\t    \"byte \\\\x escape %<\\\\x%x%> out of range - allows up to %<\\\\xFF%>\",\n \t    static_cast<unsigned int> (hexLong));\n+\t/* TODO: restore capital for escape output - gcc pretty-printer doesn't\n+\t * support %X directly */\n \tchar hexChar = static_cast<char> (hexLong);\n \n \toutput_char = hexChar;\n@@ -999,7 +1001,7 @@ Lexer::parse_escape (char opening_char)\n       break;\n     case 'u':\n       rust_error_at (get_current_location (),\n-\t\t     \"cannot have a unicode escape \\\\u in a byte %s!\",\n+\t\t     \"cannot have a unicode escape \\\\u in a byte %s\",\n \t\t     opening_char == '\\'' ? \"character\" : \"string\");\n       return std::make_tuple (output_char, additional_length_offset, false);\n     case '\\r':\n@@ -1047,8 +1049,10 @@ Lexer::parse_utf8_escape (char opening_char)\n \tif (hexLong > 127 || hexLong < 0)\n \t  rust_error_at (\n \t    get_current_location (),\n-\t    \"ascii \\\\x escape %<\\\\x%X%> out of range - allows up to %<\\\\x7F%>\",\n+\t    \"ascii \\\\x escape %<\\\\x%x%> out of range - allows up to %<\\\\x7F%>\",\n \t    static_cast<unsigned int> (hexLong));\n+\t/* TODO: restore capital for escape output - gcc pretty-printer doesn't\n+\t * support %X directly */\n \tchar hexChar = static_cast<char> (hexLong);\n \n \toutput_char = hexChar;\n@@ -1518,7 +1522,7 @@ Lexer::parse_raw_identifier (Location loc)\n       || str == \"Self\")\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"%<%s%> is a forbidden raw identifier\", str.c_str ());\n+\t\t     \"%qs is a forbidden raw identifier\", str.c_str ());\n \n       return nullptr;\n     }\n@@ -1755,7 +1759,7 @@ Lexer::parse_non_decimal_int_literal (Location loc, IsDigitFunc is_digit_func,\n   if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64)\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"invalid type suffix %<%s%> for integer (%s) literal\",\n+\t\t     \"invalid type suffix %qs for integer (%s) literal\",\n \t\t     get_type_hint_string (type_hint),\n \t\t     base == 16\n \t\t       ? \"hex\"\n@@ -1847,7 +1851,7 @@ Lexer::parse_decimal_int_or_float (Location loc)\n \t  && type_hint != CORETYPE_UNKNOWN)\n \t{\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"invalid type suffix %<%s%> for float literal\",\n+\t\t\t \"invalid type suffix %qs for float literal\",\n \t\t\t get_type_hint_string (type_hint));\n \t  // ignore invalid type suffix as everything else seems fine\n \t  type_hint = CORETYPE_UNKNOWN;\n@@ -1896,7 +1900,7 @@ Lexer::parse_decimal_int_or_float (Location loc)\n \t  && type_hint != CORETYPE_UNKNOWN)\n \t{\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"invalid type suffix %<%s%> for float literal\",\n+\t\t\t \"invalid type suffix %qs for float literal\",\n \t\t\t get_type_hint_string (type_hint));\n \t  // ignore invalid type suffix as everything else seems fine\n \t  type_hint = CORETYPE_UNKNOWN;\n@@ -1920,7 +1924,7 @@ Lexer::parse_decimal_int_or_float (Location loc)\n \t{\n \t  rust_error_at (\n \t    get_current_location (),\n-\t    \"invalid type suffix %<%s%> for integer (decimal) literal\",\n+\t    \"invalid type suffix %qs for integer (decimal) literal\",\n \t    get_type_hint_string (type_hint));\n \t  // ignore invalid type suffix as everything else seems fine\n \t  type_hint = CORETYPE_UNKNOWN;\n@@ -2007,8 +2011,9 @@ Lexer::parse_char_or_lifetime (Location loc)\n \t}\n       else\n \t{\n-\t  rust_error_at (get_current_location (),\n-\t\t\t \"expected ' after character constant in char literal\");\n+\t  rust_error_at (\n+\t    get_current_location (),\n+\t    \"expected %' after character constant in char literal\");\n \t  return nullptr;\n \t}\n     }\n@@ -2320,8 +2325,8 @@ Lexer::test_peek_codepoint_input (int n)\n void\n Lexer::split_current_token (TokenId new_left, TokenId new_right)\n {\n-  // TODO: assert that this TokenId is a \"simple token\" like punctuation and not\n-  // like \"IDENTIFIER\"?\n+  /* TODO: assert that this TokenId is a \"simple token\" like punctuation and not\n+   * like \"IDENTIFIER\"? */\n   Location current_loc = peek_token ()->get_locus ();\n   TokenPtr new_left_tok = Token::make (new_left, current_loc);\n   TokenPtr new_right_tok = Token::make (new_right, current_loc + 1);"}, {"sha": "e47692cf521c0d5501acfcee547bd61ceb9e3511", "filename": "gcc/rust/lex/rust-token.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.cc?ref=41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "patch": "@@ -106,8 +106,7 @@ Token::get_str () const\n     {\n       rust_error_at (get_locus (),\n \t\t     \"attempted to get string for '%s', which has no string. \"\n-\t\t     \"returning empty string \"\n-\t\t     \"instead.\",\n+\t\t     \"returning empty string instead.\",\n \t\t     get_token_description ());\n       return empty;\n     }"}, {"sha": "da31a6cb2e7962d9a46f72cf00536e8a99dc8ef3", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 170, "deletions": 168, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "patch": "@@ -238,7 +238,7 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n       }\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"expected %<>%> at end of generic argument - found %<%s%>\",\n+\t\t     \"expected %<>%> at end of generic argument - found %qs\",\n \t\t     tok->get_token_description ());\n       return false;\n     }\n@@ -721,7 +721,7 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n \t  {\n \t    rust_error_at (\n \t      t->get_locus (),\n-\t      \"unknown token %<%s%> in attribute body - literal expected\",\n+\t      \"unknown token %qs in attribute body - literal expected\",\n \t      t->get_token_description ());\n \t    skip_after_end_attribute ();\n \t    return nullptr;\n@@ -770,7 +770,7 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n       return nullptr;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unknown token %<%s%> in attribute body - attribute input \"\n+\t\t     \"unknown token %qs in attribute body - attribute input \"\n \t\t     \"or none expected\",\n \t\t     t->get_token_description ());\n       skip_after_end_attribute ();\n@@ -837,7 +837,7 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> - expecting delimiters (for a \"\n+\t\t     \"unexpected token %qs - expecting delimiters (for a \"\n \t\t     \"delimited token tree)\",\n \t\t     t->get_token_description ());\n       return AST::DelimTokenTree::create_empty ();\n@@ -857,7 +857,7 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n \t  // TODO: is this error handling appropriate?\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"failed to parse token tree in delimited token tree - found %<%s%>\",\n+\t    \"failed to parse token tree in delimited token tree - found %qs\",\n \t    t->get_token_description ());\n \t  return AST::DelimTokenTree::create_empty ();\n \t}\n@@ -891,13 +891,13 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n-\t\"(for a delimited token tree)\",\n-\tt->get_token_description (),\n-\t(delim_type == AST::PARENS ? \")\"\n-\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unexpected token %qs - expecting closing delimiter %qs \"\n+\t\t     \"(for a delimited token tree)\",\n+\t\t     t->get_token_description (),\n+\t\t     (delim_type == AST::PARENS\n+\t\t\t? \")\"\n+\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return empty token tree despite possibly parsing valid token tree -\n        * TODO is this a good idea? */\n@@ -926,11 +926,10 @@ Parser<ManagedTokenSource>::parse_token_tree ()\n     case RIGHT_SQUARE:\n     case RIGHT_CURLY:\n       // error - should not be called when this a token\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unexpected closing delimiter %<%s%> - token tree requires \"\n-\t\"either paired delimiters or non-delimiter tokens\",\n-\tt->get_token_description ());\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unexpected closing delimiter %qs - token tree requires \"\n+\t\t     \"either paired delimiters or non-delimiter tokens\",\n+\t\t     t->get_token_description ());\n       lexer.skip_token ();\n       return nullptr;\n     default:\n@@ -1045,8 +1044,7 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n     default:\n       // otherwise unrecognised\n       // return parse_macro_item(std::move(outer_attrs));\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> for start of %s\",\n+      rust_error_at (t->get_locus (), \"unrecognised token %qs for start of %s\",\n \t\t     t->get_token_description (),\n \t\t     called_from_statement ? \"statement\" : \"item\");\n       // skip somewhere?\n@@ -1166,15 +1164,15 @@ Parser<ManagedTokenSource>::parse_vis_item (\n \t    default:\n \t      rust_error_at (\n \t\tt->get_locus (),\n-\t\t\"unexpected token %<%s%> in some sort of extern production\",\n+\t\t\"unexpected token %qs in some sort of extern production\",\n \t\tt->get_token_description ());\n \t      lexer.skip_token (2); // TODO: is this right thing to do?\n \t      return nullptr;\n \t    }\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token %<%s%> in some sort of extern production\",\n+\t    \"unexpected token %qs in some sort of extern production\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n@@ -1218,7 +1216,7 @@ Parser<ManagedTokenSource>::parse_vis_item (\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token %<%s%> in some sort of const production\",\n+\t    \"unexpected token %qs in some sort of const production\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n@@ -1245,7 +1243,7 @@ Parser<ManagedTokenSource>::parse_vis_item (\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token %<%s%> in some sort of unsafe production\",\n+\t    \"unexpected token %qs in some sort of unsafe production\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n@@ -1352,7 +1350,7 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> - expecting delimiters (for a \"\n+\t\t     \"unexpected token %qs - expecting delimiters (for a \"\n \t\t     \"macro rules definition)\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -1441,13 +1439,13 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n-\t\"(for a macro rules definition)\",\n-\tt->get_token_description (),\n-\t(delim_type == AST::PARENS ? \")\"\n-\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unexpected token %qs - expecting closing delimiter %qs \"\n+\t\t     \"(for a macro rules definition)\",\n+\t\t     t->get_token_description (),\n+\t\t     (delim_type == AST::PARENS\n+\t\t\t? \")\"\n+\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return empty macro definiton despite possibly parsing mostly valid one\n        * - TODO is this a good idea? */\n@@ -1488,7 +1486,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> - expecting delimiters (for a \"\n+\t\t     \"unexpected token %qs - expecting delimiters (for a \"\n \t\t     \"macro invocation semi body)\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -1508,7 +1506,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t{\n \t  rust_error_at (t->get_locus (),\n \t\t\t \"failed to parse token tree for macro invocation semi \"\n-\t\t\t \"- found %<%s%>\",\n+\t\t\t \"- found %qs\",\n \t\t\t t->get_token_description ());\n \t  return nullptr;\n \t}\n@@ -1553,13 +1551,13 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n-\t\"(for a macro invocation semi)\",\n-\tt->get_token_description (),\n-\t(delim_type == AST::PARENS ? \")\"\n-\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unexpected token %qs - expecting closing delimiter %qs \"\n+\t\t     \"(for a macro invocation semi)\",\n+\t\t     t->get_token_description (),\n+\t\t     (delim_type == AST::PARENS\n+\t\t\t? \")\"\n+\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return empty macro invocation despite possibly parsing mostly valid one\n        * - TODO is this a good idea? */\n@@ -1650,7 +1648,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n     default:\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unexpected token %<%s%> - expecting delimiters (for a macro matcher)\",\n+\t\"unexpected token %qs - expecting delimiters (for a macro matcher)\",\n \tt->get_token_description ());\n       return AST::MacroMatcher::create_error ();\n     }\n@@ -1669,7 +1667,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \t{\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"failed to parse macro match for macro matcher - found %<%s%>\",\n+\t    \"failed to parse macro match for macro matcher - found %qs\",\n \t    t->get_token_description ());\n \t  return AST::MacroMatcher::create_error ();\n \t}\n@@ -1694,13 +1692,13 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n-\t\"(for a macro matcher)\",\n-\tt->get_token_description (),\n-\t(delim_type == AST::PARENS ? \")\"\n-\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unexpected token %qs - expecting closing delimiter %qs \"\n+\t\t     \"(for a macro matcher)\",\n+\t\t     t->get_token_description (),\n+\t\t     (delim_type == AST::PARENS\n+\t\t\t? \")\"\n+\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return error macro matcher despite possibly parsing mostly correct one?\n        * TODO is this the best idea? */\n@@ -1758,7 +1756,7 @@ Parser<ManagedTokenSource>::parse_macro_match ()\n     case RIGHT_CURLY:\n       // not allowed\n       rust_error_at (t->get_locus (),\n-\t\t     \"closing delimiters like %<%s%> are not allowed at the \"\n+\t\t     \"closing delimiters like %qs are not allowed at the \"\n \t\t     \"start of a macro match\",\n \t\t     t->get_token_description ());\n       // skip somewhere?\n@@ -1797,10 +1795,9 @@ Parser<ManagedTokenSource>::parse_macro_match_fragment ()\n   AST::MacroFragSpec frag = AST::get_frag_spec_from_str (t->get_str ());\n   if (frag == AST::INVALID)\n     {\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"invalid fragment specifier %<%s%> in fragment macro match\",\n-\tt->get_str ().c_str ());\n+      rust_error_at (t->get_locus (),\n+\t\t     \"invalid fragment specifier %qs in fragment macro match\",\n+\t\t     t->get_str ().c_str ());\n       return nullptr;\n     }\n \n@@ -1902,7 +1899,7 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n       rust_error_at (\n \tt->get_locus (),\n \t\"expected macro repetition operator (%<*%>, %<+%>, or %<?%>) in \"\n-\t\"macro match - found %<%s%>\",\n+\t\"macro match - found %qs\",\n \tt->get_token_description ());\n       // skip after somewhere?\n       return nullptr;\n@@ -1976,7 +1973,7 @@ Parser<ManagedTokenSource>::parse_visibility ()\n \treturn AST::Visibility::create_in_path (std::move (path));\n       }\n     default:\n-      rust_error_at (t->get_locus (), \"unexpected token %<%s%> in visibility\",\n+      rust_error_at (t->get_locus (), \"unexpected token %qs in visibility\",\n \t\t     t->get_token_description ());\n       lexer.skip_token ();\n       return AST::Visibility::create_error ();\n@@ -2048,7 +2045,7 @@ Parser<ManagedTokenSource>::parse_module (\n     default:\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unexpected token %<%s%> in module declaration/definition item\",\n+\t\"unexpected token %qs in module declaration/definition item\",\n \tt->get_token_description ());\n       lexer.skip_token ();\n       return nullptr;\n@@ -2090,10 +2087,9 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     default:\n-      rust_error_at (\n-\tcrate_name_tok->get_locus (),\n-\t\"expecting crate name (identifier or %<self%>), found %<%s%>\",\n-\tcrate_name_tok->get_token_description ());\n+      rust_error_at (crate_name_tok->get_locus (),\n+\t\t     \"expecting crate name (identifier or %<self%>), found %qs\",\n+\t\t     crate_name_tok->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n     }\n@@ -2132,7 +2128,7 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n     default:\n       rust_error_at (\n \tas_name_tok->get_locus (),\n-\t\"expecting as clause name (identifier or %<_%>), found %<%s%>\",\n+\t\"expecting as clause name (identifier or %<_%>), found %qs\",\n \tas_name_tok->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n@@ -2290,12 +2286,12 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t  // this is not allowed\n \t  rust_error_at (t->get_locus (),\n \t\t\t \"use declaration with rebind %<as%> requires a valid \"\n-\t\t\t \"simple path - none found.\");\n+\t\t\t \"simple path - none found\");\n \t  skip_after_semicolon ();\n \t  return nullptr;\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token %<%s%> in use tree with no valid \"\n+\t\t\t \"unexpected token %qs in use tree with no valid \"\n \t\t\t \"simple path (i.e. list or glob use tree)\",\n \t\t\t t->get_token_description ());\n \t  skip_after_semicolon ();\n@@ -2381,7 +2377,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\t\t\t\t  std::string (\"_\")));\n \t      default:\n \t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token %<%s%> in use tree with as \"\n+\t\t\t       \"unexpected token %qs in use tree with as \"\n \t\t\t       \"clause - expected \"\n \t\t\t       \"identifier or %<_%>\",\n \t\t\t       t->get_token_description ());\n@@ -2406,7 +2402,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\t\t\t    locus));\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token %<%s%> in use tree with valid path\",\n+\t\t\t \"unexpected token %qs in use tree with valid path\",\n \t\t\t t->get_token_description ());\n \t  // skip_after_semicolon();\n \t  return nullptr;\n@@ -2872,14 +2868,22 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs (\n {\n   std::vector<AST::LifetimeParam> lifetime_params;\n \n+  // DEBUG:\n+  fprintf (\n+    stderr,\n+    \"about to start parse_lifetime_params_objs - current token: '%s', \"\n+    \"is_end_token(...): '%s'\\n\",\n+    lexer.peek_token ()->get_token_description (),\n+    std::to_string (is_end_token (lexer.peek_token ()->get_id ())).c_str ());\n+\n   while (!is_end_token (lexer.peek_token ()->get_id ()))\n     {\n       AST::LifetimeParam lifetime_param = parse_lifetime_param ();\n \n       if (lifetime_param.is_error ())\n \t{\n-\t  // TODO: is it worth throwing away all lifetime params just because\n-\t  // one failed?\n+\t  /* TODO: is it worth throwing away all lifetime params just because\n+\t   * one failed? */\n \t  rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t\t \"failed to parse lifetime param in lifetime params\");\n \t  return {};\n@@ -2896,6 +2900,12 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs (\n \n   lifetime_params.shrink_to_fit ();\n \n+  // DEBUG:\n+  fprintf (stderr,\n+\t   \"returned lifetime_params of length %d. Current token is '%s'\\n\",\n+\t   static_cast<int> (lifetime_params.size ()),\n+\t   lexer.peek_token ()->get_token_description ());\n+\n   return lifetime_params;\n }\n \n@@ -2951,6 +2961,7 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n       // if lifetime is missing, must not be a lifetime param, so return null\n       return AST::LifetimeParam::create_error ();\n     }\n+  lexer.skip_token ();\n   /* TODO: does this always create a named lifetime? or can a different type be\n    * made? */\n   AST::Lifetime lifetime (AST::Lifetime::NAMED, lifetime_tok->get_str (),\n@@ -3180,12 +3191,12 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n \n   lexer.skip_token ();\n \n-  // parse where clause items - this is not a separate rule in the reference so\n-  // won't be here\n+  /* parse where clause items - this is not a separate rule in the reference so\n+   * won't be here */\n   std::vector<std::unique_ptr<AST::WhereClauseItem> > where_clause_items;\n \n-  // HACK: where clauses end with a right curly or semicolon or equals in all\n-  // uses currently\n+  /* HACK: where clauses end with a right curly or semicolon or equals in all\n+   * uses currently */\n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != LEFT_CURLY && t->get_id () != SEMICOLON\n \t && t->get_id () != EQUAL)\n@@ -3203,11 +3214,9 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n \n       // also skip comma if it exists\n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      lexer.skip_token ();\n+\tbreak;\n \n+      lexer.skip_token ();\n       t = lexer.peek_token ();\n     }\n \n@@ -3224,13 +3233,9 @@ Parser<ManagedTokenSource>::parse_where_clause_item ()\n   const_TokenPtr t = lexer.peek_token ();\n \n   if (t->get_id () == LIFETIME)\n-    {\n-      return parse_lifetime_where_clause_item ();\n-    }\n+    return parse_lifetime_where_clause_item ();\n   else\n-    {\n-      return parse_type_bound_where_clause_item ();\n-    }\n+    return parse_type_bound_where_clause_item ();\n }\n \n // Parses a lifetime where clause item.\n@@ -3309,12 +3314,17 @@ Parser<ManagedTokenSource>::parse_for_lifetimes ()\n       return params;\n     }\n \n-  // cannot specify end token due to parsing problems with '>' tokens being\n-  // nested\n+  /* cannot specify end token due to parsing problems with '>' tokens being\n+   * nested */\n   params = parse_lifetime_params_objs (is_right_angle_tok);\n \n   if (!skip_generics_right_angle ())\n     {\n+      // DEBUG\n+      fprintf (stderr, \"failed to skip generics right angle after (supposedly) \"\n+\t\t       \"finished parsing where clause items\\n\");\n+      // ok, well this gets called.\n+\n       // skip after somewhere?\n       return params;\n     }\n@@ -3667,7 +3677,7 @@ Parser<ManagedTokenSource>::parse_struct (\n \t\t\t       std::move (outer_attrs), locus));\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> in struct declaration\",\n+\t\t     \"unexpected token %qs in struct declaration\",\n \t\t     t->get_token_description ());\n       // skip somewhere?\n       return nullptr;\n@@ -4089,7 +4099,7 @@ Parser<ManagedTokenSource>::parse_const_item (\n       rust_error_at (\n \tident_tok->get_locus (),\n \t\"expected item name (identifier or %<_%>) in constant item \"\n-\t\"declaration - found %<%s%>\",\n+\t\"declaration - found %qs\",\n \tident_tok->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n@@ -4354,7 +4364,7 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t  default:\n \t    rust_error_at (t->get_locus (),\n \t\t\t   \"expected %<;%> or definiton at the end of trait %s \"\n-\t\t\t   \"definition - found %<%s%> instead\",\n+\t\t\t   \"definition - found %qs instead\",\n \t\t\t   is_method ? \"method\" : \"function\",\n \t\t\t   t->get_token_description ());\n \t    // skip?\n@@ -4744,17 +4754,16 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n \t\t\t\t\t\t\t\t outer_attrs));\n \t      default:\n \t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token %<%s%> in some sort of const \"\n+\t\t\t       \"unexpected token %qs in some sort of const \"\n \t\t\t       \"item in inherent impl\",\n \t\t\t       t->get_token_description ());\n \t\tlexer.skip_token (1); // TODO: is this right thing to do?\n \t\treturn nullptr;\n \t      }\n \t  default:\n-\t    rust_error_at (\n-\t      t->get_locus (),\n-\t      \"unrecognised token %<%s%> for item in inherent impl\",\n-\t      t->get_token_description ());\n+\t    rust_error_at (t->get_locus (),\n+\t\t\t   \"unrecognised token %qs for item in inherent impl\",\n+\t\t\t   t->get_token_description ());\n \t    // skip?\n \t    return nullptr;\n \t  }\n@@ -4783,7 +4792,7 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n \t    AST::Visibility::create_error (), std::move (outer_attrs));\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token %<%s%> in some sort of const item \"\n+\t\t\t \"unexpected token %qs in some sort of const item \"\n \t\t\t \"in inherent impl\",\n \t\t\t t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n@@ -4792,7 +4801,7 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n       gcc_unreachable ();\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> for item in inherent impl\",\n+\t\t     \"unrecognised token %qs for item in inherent impl\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -4965,15 +4974,15 @@ Parser<ManagedTokenSource>::parse_trait_impl_item ()\n \t\t\t\t\t\t\t      outer_attrs));\n \t      default:\n \t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token %<%s%> in some sort of const \"\n+\t\t\t       \"unexpected token %qs in some sort of const \"\n \t\t\t       \"item in trait impl\",\n \t\t\t       t->get_token_description ());\n \t\tlexer.skip_token (1); // TODO: is this right thing to do?\n \t\treturn nullptr;\n \t      }\n \t  default:\n \t    rust_error_at (t->get_locus (),\n-\t\t\t   \"unrecognised token %<%s%> for item in trait impl\",\n+\t\t\t   \"unrecognised token %qs for item in trait impl\",\n \t\t\t   t->get_token_description ());\n \t    // skip?\n \t    return nullptr;\n@@ -5004,15 +5013,15 @@ Parser<ManagedTokenSource>::parse_trait_impl_item ()\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token %<%s%> in some sort of const item in trait impl\",\n+\t    \"unexpected token %qs in some sort of const item in trait impl\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n \t}\n       gcc_unreachable ();\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> for item in trait impl\",\n+\t\t     \"unrecognised token %qs for item in trait impl\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -5351,7 +5360,7 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t\t  {\n \t\t    rust_error_at (t->get_locus (),\n \t\t\t\t   \"expected comma or right parentheses in \"\n-\t\t\t\t   \"named function parameters, found %<%s%>\",\n+\t\t\t\t   \"named function parameters, found %qs\",\n \t\t\t\t   t->get_token_description ());\n \t\t  }\n \t\telse\n@@ -5404,10 +5413,9 @@ Parser<ManagedTokenSource>::parse_external_item ()\n       }\n     default:\n       // error\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unrecognised token %<%s%> in extern block item declaration\",\n-\tt->get_token_description ());\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unrecognised token %qs in extern block item declaration\",\n+\t\t     t->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n     }\n@@ -6548,11 +6556,10 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n       expr_parsed = parse_labelled_loop_expr (std::move (outer_attrs));\n       break;\n     default:\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"could not recognise expr beginning with %<%s%> as an expr \"\n-\t\"with block in parsing expr statement.\",\n-\tt->get_token_description ());\n+      rust_error_at (t->get_locus (),\n+\t\t     \"could not recognise expr beginning with %qs as an expr \"\n+\t\t     \"with block in parsing expr statement\",\n+\t\t     t->get_token_description ());\n       skip_after_next_block ();\n       return nullptr;\n     }\n@@ -6864,7 +6871,7 @@ Parser<ManagedTokenSource>::parse_closure_expr (\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> in closure expression - expected \"\n+\t\t     \"unexpected token %qs in closure expression - expected \"\n \t\t     \"%<|%> or %<||%>\",\n \t\t     t->get_token_description ());\n       // skip somewhere?\n@@ -6989,7 +6996,7 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n     default:\n       // error - cannot be a literal expr\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> when parsing literal expression\",\n+\t\t     \"unexpected token %qs when parsing literal expression\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -7140,7 +7147,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t     \"if let expression probably exists, but is being parsed \"\n-\t\t     \"as an if expression. This may be a parser error.\");\n+\t\t     \"as an if expression. This may be a parser error\");\n       // skip somewhere?\n       return nullptr;\n     }\n@@ -7250,7 +7257,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \tdefault:\n \t  // error - invalid token\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token %<%s%> after else in if expression\",\n+\t\t\t \"unexpected token %qs after else in if expression\",\n \t\t\t t->get_token_description ());\n \t  // skip somewhere?\n \t  return nullptr;\n@@ -7276,7 +7283,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t     \"if expression probably exists, but is being parsed as an \"\n-\t\t     \"if let expression. This may be a parser error.\");\n+\t\t     \"if let expression. This may be a parser error\");\n       // skip somewhere?\n       return nullptr;\n     }\n@@ -7410,10 +7417,9 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t  }\n \tdefault:\n \t  // error - invalid token\n-\t  rust_error_at (\n-\t    t->get_locus (),\n-\t    \"unexpected token %<%s%> after else in if let expression\",\n-\t    t->get_token_description ());\n+\t  rust_error_at (t->get_locus (),\n+\t\t\t \"unexpected token %qs after else in if let expression\",\n+\t\t\t t->get_token_description ());\n \t  // skip somewhere?\n \t  return nullptr;\n \t}\n@@ -7651,7 +7657,7 @@ Parser<ManagedTokenSource>::parse_labelled_loop_expr (\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t     \"expected lifetime in labelled loop expr (to parse loop \"\n-\t\t     \"label) - found %<%s%>\",\n+\t\t     \"label) - found %qs\",\n \t\t     lexer.peek_token ()->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -7690,7 +7696,7 @@ Parser<ManagedTokenSource>::parse_labelled_loop_expr (\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> when parsing labelled loop\",\n+\t\t     \"unexpected token %qs when parsing labelled loop\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -8148,7 +8154,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t  // error\n \t  rust_error_at (\n \t    lexer.peek_token ()->get_locus (),\n-\t    \"unexpected token %<%s%> in array expression (arrayelems)\",\n+\t    \"unexpected token %qs in array expression (arrayelems)\",\n \t    lexer.peek_token ()->get_token_description ());\n \t  // skip somewhere?\n \t  return nullptr;\n@@ -8289,7 +8295,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n       // error\n       const_TokenPtr t = lexer.peek_token ();\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> in grouped or tuple expression \"\n+\t\t     \"unexpected token %qs in grouped or tuple expression \"\n \t\t     \"(parenthesised expression) - expected %<)%> for grouped \"\n \t\t     \"expr and %<,%> for tuple expr\",\n \t\t     t->get_token_description ());\n@@ -8619,7 +8625,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  }\n       }\n     default:\n-      rust_error_at (t->get_locus (), \"unrecognised token %<%s%> in type\",\n+      rust_error_at (t->get_locus (), \"unrecognised token %qs in type\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -8844,7 +8850,7 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> in bare function type or trait \"\n+\t\t     \"unrecognised token %qs in bare function type or trait \"\n \t\t     \"object type or trait object type one bound\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -9053,7 +9059,7 @@ Parser<ManagedTokenSource>::parse_raw_pointer_type ()\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> in raw pointer type\",\n+\t\t     \"unrecognised token %qs in raw pointer type\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9124,7 +9130,7 @@ Parser<ManagedTokenSource>::parse_slice_or_array_type ()\n       // error\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unrecognised token %<%s%> in slice or array type after inner type\",\n+\t\"unrecognised token %qs in slice or array type after inner type\",\n \tt->get_token_description ());\n       return nullptr;\n     }\n@@ -9357,7 +9363,7 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n       }\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> in type no bounds\",\n+\t\t     \"unrecognised token %qs in type no bounds\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9516,17 +9522,16 @@ Parser<ManagedTokenSource>::parse_literal_or_range_pattern ()\n \t  break;\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n-\t\t\t \"token type %<%s%> cannot be parsed as range pattern \"\n+\t\t\t \"token type %qs cannot be parsed as range pattern \"\n \t\t\t \"bound or literal after minus symbol\",\n \t\t\t range_lower->get_token_description ());\n \t  return nullptr;\n \t}\n       break;\n     default:\n-      rust_error_at (\n-\trange_lower->get_locus (),\n-\t\"token type %<%s%> cannot be parsed as range pattern bound\",\n-\trange_lower->get_token_description ());\n+      rust_error_at (range_lower->get_locus (),\n+\t\t     \"token type %qs cannot be parsed as range pattern bound\",\n+\t\t     range_lower->get_token_description ());\n       return nullptr;\n     }\n \n@@ -9620,7 +9625,7 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \t      range_lower_locus, true));\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n-\t\t\t \"token type %<%s%> cannot be parsed as range pattern \"\n+\t\t\t \"token type %qs cannot be parsed as range pattern \"\n \t\t\t \"bound after minus symbol\",\n \t\t\t range_lower->get_token_description ());\n \t  return nullptr;\n@@ -9659,10 +9664,9 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \t  new AST::RangePatternBoundQualPath (std::move (path)));\n       }\n     default:\n-      rust_error_at (\n-\trange_lower->get_locus (),\n-\t\"token type %<%s%> cannot be parsed as range pattern bound\",\n-\trange_lower->get_token_description ());\n+      rust_error_at (range_lower->get_locus (),\n+\t\t     \"token type %qs cannot be parsed as range pattern bound\",\n+\t\t     range_lower->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -9842,7 +9846,7 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t  }\n       }\n     default:\n-      rust_error_at (t->get_locus (), \"unexpected token %<%s%> in pattern\",\n+      rust_error_at (t->get_locus (), \"unexpected token %qs in pattern\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9868,7 +9872,7 @@ Parser<ManagedTokenSource>::parse_reference_pattern ()\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> in reference pattern\",\n+\t\t     \"unexpected token %qs in reference pattern\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -10068,7 +10072,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> in grouped or tuple pattern \"\n+\t\t     \"unrecognised token %qs in grouped or tuple pattern \"\n \t\t     \"after first pattern\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -10178,7 +10182,7 @@ Parser<ManagedTokenSource>::parse_identifier_pattern ()\n \t{\n \t  rust_error_at (\n \t    lexer.peek_token ()->get_locus (),\n-\t    \"failed to parse pattern to bind in identifier pattern\\n\");\n+\t    \"failed to parse pattern to bind in identifier pattern\");\n \t  return nullptr;\n \t}\n     }\n@@ -10454,7 +10458,7 @@ Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token %<%s%> in tuple struct items\",\n+\t\t     \"unexpected token %qs in tuple struct items\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -10596,7 +10600,7 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n \tdefault:\n \t  // error\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unrecognised token %<%s%> in struct pattern field\",\n+\t\t\t \"unrecognised token %qs in struct pattern field\",\n \t\t\t t->get_token_description ());\n \t  return nullptr;\n \t}\n@@ -10730,7 +10734,7 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \t    }\n \t  default:\n \t    rust_error_at (t2->get_locus (),\n-\t\t\t   \"unrecognised token %<%s%> after parsing unsafe - \"\n+\t\t\t   \"unrecognised token %qs after parsing unsafe - \"\n \t\t\t   \"expected beginning of expression or statement\",\n \t\t\t   t->get_token_description ());\n \t    // skip somewhere?\n@@ -10932,7 +10936,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t  default:\n \t    rust_error_at (\n \t      t3->get_locus (),\n-\t      \"unrecognised token %<%s%> in macro invocation - (opening) \"\n+\t      \"unrecognised token %qs in macro invocation - (opening) \"\n \t      \"delimiter expected\",\n \t      t3->get_token_description ());\n \t    return ExprOrStmt::create_error ();\n@@ -10953,7 +10957,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t\trust_error_at (\n \t\t  t3->get_locus (),\n \t\t  \"failed to parse token tree for macro invocation (or semi) - \"\n-\t\t  \"found %<%s%>\",\n+\t\t  \"found %qs\",\n \t\t  t3->get_token_description ());\n \t\treturn ExprOrStmt::create_error ();\n \t      }\n@@ -11003,8 +11007,8 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t  {\n \t    // tokens don't match opening delimiters, so produce error\n \t    rust_error_at (t2->get_locus (),\n-\t\t\t   \"unexpected token %<%s%> - expecting closing \"\n-\t\t\t   \"delimiter %<%s%> (for a \"\n+\t\t\t   \"unexpected token %qs - expecting closing \"\n+\t\t\t   \"delimiter %qs (for a \"\n \t\t\t   \"macro invocation)\",\n \t\t\t   t2->get_token_description (),\n \t\t\t   (type == AST::PARENS\n@@ -11185,7 +11189,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n       return nullptr;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token %<%s%> as first token of struct expr \"\n+\t\t     \"unrecognised token %qs as first token of struct expr \"\n \t\t     \"field - expected identifier or int literal\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -11228,11 +11232,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n       type = AST::CURLY;\n       break;\n     default:\n-      rust_error_at (\n-\tt3->get_locus (),\n-\t\"unrecognised token %<%s%> in macro invocation - (opening) \"\n-\t\"delimiter expected\",\n-\tt3->get_token_description ());\n+      rust_error_at (t3->get_locus (),\n+\t\t     \"unrecognised token %qs in macro invocation - (opening) \"\n+\t\t     \"delimiter expected\",\n+\t\t     t3->get_token_description ());\n       return ExprOrStmt::create_error ();\n     }\n   lexer.skip_token ();\n@@ -11250,7 +11253,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \t{\n \t  rust_error_at (t3->get_locus (),\n \t\t\t \"failed to parse token tree for macro invocation (or \"\n-\t\t\t \"semi) - found %<%s%>\",\n+\t\t\t \"semi) - found %qs\",\n \t\t\t t3->get_token_description ());\n \t  return ExprOrStmt::create_error ();\n \t}\n@@ -11301,7 +11304,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n       // tokens don't match opening delimiters, so produce error\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> (for a \"\n+\t\"unexpected token %qs - expecting closing delimiter %qs (for a \"\n \t\"macro invocation)\",\n \tt->get_token_description (),\n \t(type == AST::PARENS ? \")\" : (type == AST::SQUARE ? \"]\" : \"}\")));\n@@ -11314,7 +11317,7 @@ template <typename ManagedTokenSource>\n void\n Parser<ManagedTokenSource>::unexpected_token (const_TokenPtr t)\n {\n-  rust_error_at (t->get_locus (), \"unexpected token %<%s%>\\n\",\n+  rust_error_at (t->get_locus (), \"unexpected token %qs\\n\",\n \t\t t->get_token_description ());\n }\n \n@@ -11359,7 +11362,7 @@ Parser<ManagedTokenSource>::expect_token (TokenId token_id)\n     }\n   else\n     {\n-      rust_error_at (t->get_locus (), \"expecting %<%s%> but %<%s%> found\\n\",\n+      rust_error_at (t->get_locus (), \"expecting %qs but %qs found\",\n \t\t     get_token_description (token_id),\n \t\t     t->get_token_description ());\n \n@@ -11849,7 +11852,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t// TODO: fix: this is for global paths, i.e. std::string::whatever\n \trust_error_at (tok->get_locus (),\n \t\t       \"found null denotation scope resolution operator, and \"\n-\t\t       \"haven't written handling for it.\");\n+\t\t       \"have not written handling for it\");\n \treturn nullptr;\n       }\n     case SELF:\n@@ -11963,7 +11966,7 @@ Parser<ManagedTokenSource>::null_denotation (\n       return parse_array_expr (std::move (outer_attrs), true);\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"found unexpected token %<%s%> in null denotation\",\n+\t\t     \"found unexpected token %qs in null denotation\",\n \t\t     tok->get_token_description ());\n       return nullptr;\n     }\n@@ -12225,7 +12228,7 @@ Parser<ManagedTokenSource>::left_denotation (\n       // path expression - binary infix? FIXME should this even be parsed here?\n       rust_error_at (tok->get_locus (),\n \t\t     \"found scope resolution operator in left denotation \"\n-\t\t     \"function - this should probably be handled elsewhere.\");\n+\t\t     \"function - this should probably be handled elsewhere\");\n       return nullptr;\n       case DOT: {\n \t/* field expression or method call - relies on parentheses after next\n@@ -12281,7 +12284,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t   restrictions);\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"found unexpected token %<%s%> in left denotation\",\n+\t\t     \"found unexpected token %qs in left denotation\",\n \t\t     tok->get_token_description ());\n       return nullptr;\n     }\n@@ -13628,11 +13631,10 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n \t\t\t\t\t   std::move (outer_attrs)));\n       }\n     default:\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unrecognised token %<%s%> in struct (or enum) expression - \"\n-\t\"expected %<}%>, identifier, int literal, or %<..%>\",\n-\tt->get_token_description ());\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unrecognised token %qs in struct (or enum) expression - \"\n+\t\t     \"expected %<}%>, identifier, int literal, or %<..%>\",\n+\t\t     t->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -13735,7 +13737,7 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n       gcc_fallthrough ();\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"unrecognised token %<%s%> in path in expression\",\n+\t\t     \"unrecognised token %qs in path in expression\",\n \t\t     tok->get_token_description ());\n       return AST::PathInExpression::create_error ();\n     }\n@@ -13859,7 +13861,7 @@ Parser<ManagedTokenSource>::parse_closure_expr_pratt (\n       }\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"unexpected token %<%s%> in closure expression - expected \"\n+\t\t     \"unexpected token %qs in closure expression - expected \"\n \t\t     \"%<|%> or %<||%>\",\n \t\t     tok->get_token_description ());\n       // skip somewhere?"}, {"sha": "dbc40ac2d8c42f7e84430c8e1e795b66c3920c82", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=41b1bad402aa3dcb3657c75e0c93e2a114d2e2cb", "patch": "@@ -383,7 +383,7 @@ Session::enable_dump (std::string arg)\n   else\n     {\n       rust_error_at (Location (),\n-\t\t     \"dump option %<%s%> was unrecognised. choose %<lex%>, \"\n+\t\t     \"dump option %qs was unrecognised. choose %<lex%>, \"\n \t\t     \"%<parse%>, or %<target_options%>\",\n \t\t     arg.c_str ());\n       return false;"}]}