{"sha": "603cca934439bff931f1902e93416ec34922a80a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAzY2NhOTM0NDM5YmZmOTMxZjE5MDJlOTM0MTZlYzM0OTIyYTgwYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-12-14T15:26:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-12-14T15:26:24Z"}, "message": "re PR middle-end/68852 (ICE in vect_is_simple_use (tree-vect-stmts.c:8750) using -O3)\n\n2015-12-14  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/68852\n\t* tree-vectorizer.h (struct _slp_tree): Add def_type member.\n\t(SLP_TREE_DEF_TYPE): New accessor.\n\t* tree-vect-stmts.c (vect_is_simple_use): Remove BB vectorization\n\thack.\n\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n\tSLP_TREE_DEF_TYPE.\n\t(vect_build_slp_tree): When a node is to be built up from scalars\n\tdo not push a NULL as child but instead set its def_type to\n\tvect_external_def.\n\t(vect_analyze_slp_cost_1): Check for child def-type instead\n\tof NULL.\n\t(vect_detect_hybrid_slp_stmts): Likewise.\n\t(vect_bb_slp_scalar_cost): Likewise.\n\t(vect_get_slp_defs): Likewise.\n\t(vect_slp_analyze_node_operations): Likewise.  Before\n\tprocessing node push the children def-types to the underlying\n\tstmts vinfo and restore it afterwards.\n\t(vect_schedule_slp_instance): Likewise.\n\t(vect_slp_analyze_bb_1): Do not mark stmts not in SLP instances\n\tas not vectorizable.\n\n\t* g++.dg/torture/pr68852.C: New testcase.\n\nFrom-SVN: r231619", "tree": {"sha": "0a16a9e00ab79d716834c67868ac06ea567a72bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a16a9e00ab79d716834c67868ac06ea567a72bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/603cca934439bff931f1902e93416ec34922a80a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/603cca934439bff931f1902e93416ec34922a80a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/603cca934439bff931f1902e93416ec34922a80a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/603cca934439bff931f1902e93416ec34922a80a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60f2b864499470fd9a656e771191222dcaee5a4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f2b864499470fd9a656e771191222dcaee5a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f2b864499470fd9a656e771191222dcaee5a4c"}], "stats": {"total": 225, "additions": 181, "deletions": 44}, "files": [{"sha": "35a05864a254eb66fe9f839763d326ecd30b3d82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603cca934439bff931f1902e93416ec34922a80a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603cca934439bff931f1902e93416ec34922a80a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=603cca934439bff931f1902e93416ec34922a80a", "patch": "@@ -1,3 +1,27 @@\n+2015-12-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/68852\n+\t* tree-vectorizer.h (struct _slp_tree): Add def_type member.\n+\t(SLP_TREE_DEF_TYPE): New accessor.\n+\t* tree-vect-stmts.c (vect_is_simple_use): Remove BB vectorization\n+\thack.\n+\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n+\tSLP_TREE_DEF_TYPE.\n+\t(vect_build_slp_tree): When a node is to be built up from scalars\n+\tdo not push a NULL as child but instead set its def_type to\n+\tvect_external_def.\n+\t(vect_analyze_slp_cost_1): Check for child def-type instead\n+\tof NULL.\n+\t(vect_detect_hybrid_slp_stmts): Likewise.\n+\t(vect_bb_slp_scalar_cost): Likewise.\n+\t(vect_get_slp_defs): Likewise.\n+\t(vect_slp_analyze_node_operations): Likewise.  Before\n+\tprocessing node push the children def-types to the underlying\n+\tstmts vinfo and restore it afterwards.\n+\t(vect_schedule_slp_instance): Likewise.\n+\t(vect_slp_analyze_bb_1): Do not mark stmts not in SLP instances\n+\tas not vectorizable.\n+\n 2015-12-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68775"}, {"sha": "45db39a777eff37dc38e4f1b52d5b89058240b46", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=603cca934439bff931f1902e93416ec34922a80a", "patch": "@@ -1,3 +1,8 @@\n+2015-12-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/68852\n+\t* g++.dg/torture/pr68852.C: New testcase.\n+\n 2015-12-14  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* gcc.dg/builtin-return-1.c: Correct effective-target test."}, {"sha": "417275177609fdecda3787b7e5b4d1731a78c349", "filename": "gcc/testsuite/g++.dg/torture/pr68852.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr68852.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr68852.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr68852.C?ref=603cca934439bff931f1902e93416ec34922a80a", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+\n+struct A {\n+    double x, y, z, w;\n+    A() {}\n+    A(double, double p2, double p3, double) : y(p2), z(p3) {}\n+    void m_fn1();\n+};\n+\n+struct B {\n+    double x, y;\n+};\n+struct D : A {\n+    D() {}\n+    D(double p1, double p2, double p3, double p4) : A(p1, p2, p3, p4) {}\n+};\n+\n+class C {\n+public:\n+    float _11, _12, _13, _14;\n+    float _21, _22, _23, _24;\n+    float _31, _32, _33, _34;\n+    float _41, _42, _43, _44;\n+    D m_fn2(B p1) {\n+\tdouble z(p1.x + _43);\n+\treturn *this * D(p1.x, p1.y, z, 1);\n+    }\n+    int ProjectRectBounds_next;\n+    B __trans_tmp_3;\n+    int m_fn3(int) {\n+\tB a, b;\n+\tD c[1];\n+\tb = __trans_tmp_3;\n+\tc[2] = m_fn2(b);\n+\tc[3] = m_fn2(a);\n+\tc[ProjectRectBounds_next].m_fn1();\n+    }\n+    D operator*(D p1) {\n+\tD d;\n+\td.x = p1.x * _11 + p1.y * _21 + p1.z * _31 + _41;\n+\td.y = p1.x * _12 + p1.y * _22 + p1.z * _32 + _42;\n+\td.z = p1.x * _13 + p1.y * _23 + p1.z * _33 + _43;\n+\td.w = p1.x * _14 + p1.y * _24 + p1.z * _34 + _44;\n+\treturn d;\n+    }\n+};\n+\n+void fn1() {\n+    C e;\n+    int f = e.m_fn3(f);\n+}"}, {"sha": "b87b3d4124d5bc18bc35bd97b2cee5670d09c2ff", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 97, "deletions": 40, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=603cca934439bff931f1902e93416ec34922a80a", "patch": "@@ -51,9 +51,6 @@ vect_free_slp_tree (slp_tree node)\n   int i;\n   slp_tree child;\n \n-  if (!node)\n-    return;\n-\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_free_slp_tree (child);\n \n@@ -103,6 +100,7 @@ vect_create_new_slp_node (vec<gimple *> scalar_stmts)\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n   SLP_TREE_TWO_OPERATORS (node) = false;\n+  SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n \n   return node;\n }\n@@ -938,23 +936,23 @@ vect_build_slp_tree (vec_info *vinfo,\n \t      slp_tree grandchild;\n \n \t      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\tif (grandchild != NULL)\n+\t\tif (SLP_TREE_DEF_TYPE (grandchild) == vect_internal_def)\n \t\t  break;\n \t      if (!grandchild)\n \t\t{\n \t\t  /* Roll back.  */\n \t\t  *max_nunits = old_max_nunits;\n \t\t  loads->truncate (old_nloads);\n \t\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\t      vect_free_slp_tree (grandchild);\n+\t\t    vect_free_slp_tree (grandchild);\n \t\t  SLP_TREE_CHILDREN (child).truncate (0);\n \n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t   \"Building parent vector operands from \"\n \t\t\t\t   \"scalars instead\\n\");\n \t\t  oprnd_info->def_stmts = vNULL;\n-\t\t  vect_free_slp_tree (child);\n-\t\t  SLP_TREE_CHILDREN (*node).quick_push (NULL);\n+\t\t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n+\t\t  SLP_TREE_CHILDREN (*node).quick_push (child);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -992,8 +990,8 @@ vect_build_slp_tree (vec_info *vinfo,\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Building vector operands from scalars\\n\");\n \t  oprnd_info->def_stmts = vNULL;\n-\t  vect_free_slp_tree (child);\n-\t  SLP_TREE_CHILDREN (*node).quick_push (NULL);\n+\t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n+\t  SLP_TREE_CHILDREN (*node).quick_push (child);\n \t  continue;\n \t}\n \n@@ -1066,7 +1064,7 @@ vect_build_slp_tree (vec_info *vinfo,\n \t\t  slp_tree grandchild;\n \n \t\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (child), j, grandchild)\n-\t\t    if (grandchild != NULL)\n+\t\t    if (SLP_TREE_DEF_TYPE (grandchild) == vect_internal_def)\n \t\t      break;\n \t\t  if (!grandchild)\n \t\t    {\n@@ -1081,8 +1079,8 @@ vect_build_slp_tree (vec_info *vinfo,\n \t\t\t\t       \"Building parent vector operands from \"\n \t\t\t\t       \"scalars instead\\n\");\n \t\t      oprnd_info->def_stmts = vNULL;\n-\t\t      vect_free_slp_tree (child);\n-\t\t      SLP_TREE_CHILDREN (*node).quick_push (NULL);\n+\t\t      SLP_TREE_DEF_TYPE (child) = vect_external_def;\n+\t\t      SLP_TREE_CHILDREN (*node).quick_push (child);\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -1117,10 +1115,9 @@ vect_print_slp_tree (int dump_kind, location_t loc, slp_tree node)\n   gimple *stmt;\n   slp_tree child;\n \n-  if (!node)\n-    return;\n-\n-  dump_printf_loc (dump_kind, loc, \"node\\n\");\n+  dump_printf_loc (dump_kind, loc, \"node%s\\n\",\n+\t\t   SLP_TREE_DEF_TYPE (node) != vect_internal_def\n+\t\t   ? \" (external)\" : \"\");\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       dump_printf_loc (dump_kind, loc, \"\\tstmt %d \", i);\n@@ -1143,7 +1140,7 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n   gimple *stmt;\n   slp_tree child;\n \n-  if (!node)\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n@@ -1165,7 +1162,7 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n   stmt_vec_info stmt_info;\n   slp_tree child;\n \n-  if (!node)\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n@@ -1403,7 +1400,7 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t\t\t stmt_vector_for_cost *body_cost_vec,\n \t\t\t unsigned ncopies_for_cost)\n {\n-  unsigned i;\n+  unsigned i, j;\n   slp_tree child;\n   gimple *stmt, *s;\n   stmt_vec_info stmt_info;\n@@ -1412,7 +1409,7 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \n   /* Recurse down the SLP tree.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (child)\n+    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n       vect_analyze_slp_cost_1 (instance, child, prologue_cost_vec,\n \t\t\t       body_cost_vec, ncopies_for_cost);\n \n@@ -1467,9 +1464,16 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t}\n     }\n \n+  /* Push SLP node def-type to stmts.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = SLP_TREE_DEF_TYPE (child);\n+\n   /* Scan operands and account for prologue cost of constants/externals.\n      ???  This over-estimates cost for multiple uses and should be\n      re-engineered.  */\n+  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   lhs = gimple_get_lhs (stmt);\n   for (i = 0; i < gimple_num_ops (stmt); ++i)\n     {\n@@ -1492,6 +1496,12 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t\t\t      stmt_info, 0, vect_prologue);\n \t}\n     }\n+\n+  /* Restore stmt def-types.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_internal_def;\n }\n \n /* Compute the cost for the SLP instance INSTANCE.  */\n@@ -1798,6 +1808,33 @@ vect_analyze_slp_instance (vec_info *vinfo,\n             }\n         }\n \n+      /* If the loads and stores can be handled with load/store-lane\n+         instructions do not generate this SLP instance.  */\n+      if (is_a <loop_vec_info> (vinfo)\n+\t  && loads_permuted\n+\t  && dr && vect_store_lanes_supported (vectype, group_size))\n+\t{\n+\t  slp_tree load_node;\n+\t  FOR_EACH_VEC_ELT (loads, i, load_node)\n+\t    {\n+\t      gimple *first_stmt = GROUP_FIRST_ELEMENT\n+\t\t  (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n+\t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (first_stmt);\n+\t      if (! vect_load_lanes_supported (STMT_VINFO_VECTYPE (stmt_vinfo),\n+\t\t\t\t\t       GROUP_SIZE (stmt_vinfo)))\n+\t\tbreak;\n+\t    }\n+\t  if (i == loads.length ())\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Built SLP cancelled: can use \"\n+\t\t\t\t \"load/store-lanes\\n\");\n+              vect_free_slp_instance (new_instance);\n+              return false;\n+\t    }\n+\t}\n+\n       vinfo->slp_instances.safe_push (new_instance);\n \n       if (dump_enabled_p ())\n@@ -2007,7 +2044,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n     }\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    if (child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_external_def)\n       vect_detect_hybrid_slp_stmts (child, i, stype);\n }\n \n@@ -2188,28 +2225,44 @@ static bool\n vect_slp_analyze_node_operations (slp_tree node)\n {\n   bool dummy;\n-  int i;\n+  int i, j;\n   gimple *stmt;\n   slp_tree child;\n \n-  if (!node)\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return true;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (!vect_slp_analyze_node_operations (child))\n       return false;\n \n+  /* Push SLP node def-type to stmts.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = SLP_TREE_DEF_TYPE (child);\n+\n+  bool res = true;\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       gcc_assert (stmt_info);\n       gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n \n       if (!vect_analyze_stmt (stmt, &dummy, node))\n-\treturn false;\n+\t{\n+\t  res = false;\n+\t  break;\n+\t}\n     }\n \n-  return true;\n+  /* Restore stmt def-types.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_internal_def;\n+\n+  return res;\n }\n \n \n@@ -2289,7 +2342,7 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \t    if (!is_gimple_debug (use_stmt)\n \t\t&& (! vect_stmt_in_region_p (vinfo_for_stmt (stmt)->vinfo,\n \t\t\t\t\t     use_stmt)\n-\t\t    || !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (use_stmt))))\n+\t\t    || ! PURE_SLP_STMT (vinfo_for_stmt (use_stmt))))\n \t      {\n \t\t(*life)[i] = true;\n \t\tBREAK_FROM_IMM_USE_STMT (use_iter);\n@@ -2313,7 +2366,7 @@ vect_bb_slp_scalar_cost (basic_block bb,\n     }\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (child)\n+    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n       scalar_cost += vect_bb_slp_scalar_cost (bb, child, life);\n \n   return scalar_cost;\n@@ -2502,15 +2555,6 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n-  /* Mark all the statements that we do not want to vectorize.  */\n-  for (gimple_stmt_iterator gsi = bb_vinfo->region_begin;\n-       gsi_stmt (gsi) != gsi_stmt (bb_vinfo->region_end); gsi_next (&gsi))\n-    {\n-      stmt_vec_info vinfo = vinfo_for_stmt (gsi_stmt (gsi));\n-      if (STMT_SLP_TYPE (vinfo) != pure_slp)\n-\tSTMT_VINFO_VECTORIZABLE (vinfo) = false;\n-    }\n-\n   if (!vect_slp_analyze_operations (BB_VINFO_SLP_INSTANCES (bb_vinfo),\n \t\t\t\t    BB_VINFO_TARGET_COST_DATA (bb_vinfo)))\n     {\n@@ -3088,7 +3132,7 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n           child = SLP_TREE_CHILDREN (slp_node)[child_index];\n \n \t  /* We have to check both pattern and original def, if available.  */\n-\t  if (child)\n+\t  if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t    {\n \t      gimple *first_def = SLP_TREE_SCALAR_STMTS (child)[0];\n \t      gimple *related\n@@ -3377,15 +3421,21 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   stmt_vec_info stmt_info;\n   unsigned int vec_stmts_size, nunits, group_size;\n   tree vectype;\n-  int i;\n+  int i, j;\n   slp_tree child;\n \n-  if (!node)\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return false;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_schedule_slp_instance (child, instance, vectorization_factor);\n \n+  /* Push SLP node def-type to stmts.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = SLP_TREE_DEF_TYPE (child);\n+\n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   stmt_info = vinfo_for_stmt (stmt);\n \n@@ -3504,6 +3554,13 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t}\n     }\n   is_store = vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n+\n+  /* Restore stmt def-types.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n+\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_internal_def;\n+\n   return is_store;\n }\n \n@@ -3522,7 +3579,7 @@ vect_remove_slp_scalar_calls (slp_tree node)\n   tree lhs;\n   stmt_vec_info stmt_info;\n \n-  if (!node)\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)"}, {"sha": "b1342fb477a2a280c7a1c67cc2ae34443e321471", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=603cca934439bff931f1902e93416ec34922a80a", "patch": "@@ -8649,10 +8649,7 @@ vect_is_simple_use (tree operand, vec_info *vinfo,\n   else\n     {\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (*def_stmt);\n-      if (is_a <bb_vec_info> (vinfo) && !STMT_VINFO_VECTORIZABLE (stmt_vinfo))\n-\t*dt = vect_external_def;\n-      else\n-\t*dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n+      *dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n     }\n \n   if (dump_enabled_p ())"}, {"sha": "ac687501bf1b7890fbf71eda3d5b9a58251ebab3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/603cca934439bff931f1902e93416ec34922a80a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=603cca934439bff931f1902e93416ec34922a80a", "patch": "@@ -107,6 +107,8 @@ struct _slp_tree {\n   unsigned int vec_stmts_size;\n   /* Whether the scalar computations use two different operators.  */\n   bool two_operators;\n+  /* The DEF type of this node.  */\n+  enum vect_def_type def_type;\n };\n \n \n@@ -139,6 +141,7 @@ typedef struct _slp_instance {\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n #define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators\n+#define SLP_TREE_DEF_TYPE(S)\t\t\t (S)->def_type\n \n \n "}]}