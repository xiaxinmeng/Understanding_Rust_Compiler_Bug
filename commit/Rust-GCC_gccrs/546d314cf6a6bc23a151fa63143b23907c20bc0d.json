{"sha": "546d314cf6a6bc23a151fa63143b23907c20bc0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2ZDMxNGNmNmE2YmMyM2ExNTFmYTYzMTQzYjIzOTA3YzIwYmMwZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-12-05T14:36:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-12-05T14:36:44Z"}, "message": "re PR tree-optimization/50904 (pessimization when -fno-protect-parens is enabled by -Ofast)\n\n2011-12-05  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/50904\n\t* tree-ssa-loop-im.c (struct mem_ref): Remove vops member.\n\t(MEM_ANALYZABLE): New.\n\t(memory_references): Remove clobbered_vops and vop_ref_map\n\tmembers, add all_refs_stored_in_loop member.\n\t(memref_free): Adjust.\n\t(mem_ref_alloc): Likewise.\n\t(gather_mem_refs_stmt): Do not record clobbers, instead\n\trecord refs for unanalyzable stmts.\n\t(gather_mem_refs_in_loops): Do not propagate clobbers.\n\t(struct vop_to_refs_elt, vtoe_hash, vtoe_eq, vtoe_free,\n\trecord_vop_access, get_vop_accesses, get_vop_stores,\n\tadd_vop_ref_mapping): Remove.\n\t(create_vop_ref_mapping_loop): Adjust to simply record all\n\tstores.\n\t(analyze_memory_references): Adjust.\n\t(refs_independent_p): Check for not analyzable refs.\n\t(can_sm_ref_p): Likewise.\n\t(ref_indep_loop_p_1): Simplify.\n\t(tree_ssa_lim_finalize): Adjust.\n\n\t* tree-ssa-loop-im.c (stmt_cost): Simplify, use LIM_EXPENSIVE\n\trather than magic constants.  Assign zero cost to PAREN_EXPR\n\tand SSA_NAME copies.  Assign cost proportional to the vector\n\tsize for vector constructors.\n\nFrom-SVN: r182010", "tree": {"sha": "4ff938497e864ee7720a2f079095533642f02ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ff938497e864ee7720a2f079095533642f02ebb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546d314cf6a6bc23a151fa63143b23907c20bc0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546d314cf6a6bc23a151fa63143b23907c20bc0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546d314cf6a6bc23a151fa63143b23907c20bc0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546d314cf6a6bc23a151fa63143b23907c20bc0d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14cd91f923c6977d085287a91b26b32919754047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cd91f923c6977d085287a91b26b32919754047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14cd91f923c6977d085287a91b26b32919754047"}], "stats": {"total": 309, "additions": 107, "deletions": 202}, "files": [{"sha": "34d55bb0caef4c268398b3584c71aec1ef0a3a49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d314cf6a6bc23a151fa63143b23907c20bc0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d314cf6a6bc23a151fa63143b23907c20bc0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=546d314cf6a6bc23a151fa63143b23907c20bc0d", "patch": "@@ -1,3 +1,31 @@\n+2011-12-05  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50904\n+\t* tree-ssa-loop-im.c (struct mem_ref): Remove vops member.\n+\t(MEM_ANALYZABLE): New.\n+\t(memory_references): Remove clobbered_vops and vop_ref_map\n+\tmembers, add all_refs_stored_in_loop member.\n+\t(memref_free): Adjust.\n+\t(mem_ref_alloc): Likewise.\n+\t(gather_mem_refs_stmt): Do not record clobbers, instead\n+\trecord refs for unanalyzable stmts.\n+\t(gather_mem_refs_in_loops): Do not propagate clobbers.\n+\t(struct vop_to_refs_elt, vtoe_hash, vtoe_eq, vtoe_free,\n+\trecord_vop_access, get_vop_accesses, get_vop_stores,\n+\tadd_vop_ref_mapping): Remove.\n+\t(create_vop_ref_mapping_loop): Adjust to simply record all\n+\tstores.\n+\t(analyze_memory_references): Adjust.\n+\t(refs_independent_p): Check for not analyzable refs.\n+\t(can_sm_ref_p): Likewise.\n+\t(ref_indep_loop_p_1): Simplify.\n+\t(tree_ssa_lim_finalize): Adjust.\n+\n+\t* tree-ssa-loop-im.c (stmt_cost): Simplify, use LIM_EXPENSIVE\n+\trather than magic constants.  Assign zero cost to PAREN_EXPR\n+\tand SSA_NAME copies.  Assign cost proportional to the vector\n+\tsize for vector constructors.\n+\n 2011-12-05  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-alias.h (struct ao_ref_s): Add volatile_p field."}, {"sha": "3c7bb65e0bf43f3f4f62803f7e57c3d8b63bbd40", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 79, "deletions": 202, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546d314cf6a6bc23a151fa63143b23907c20bc0d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546d314cf6a6bc23a151fa63143b23907c20bc0d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=546d314cf6a6bc23a151fa63143b23907c20bc0d", "patch": "@@ -135,8 +135,6 @@ typedef struct mem_ref\n   VEC (mem_ref_locs_p, heap) *accesses_in_loop;\n \t\t\t\t/* The locations of the accesses.  Vector\n \t\t\t\t   indexed by the loop number.  */\n-  bitmap vops;\t\t\t/* Vops corresponding to this memory\n-\t\t\t\t   location.  */\n \n   /* The following sets are computed on demand.  We keep both set and\n      its complement, so that we know whether the information was\n@@ -181,12 +179,9 @@ static struct\n      subloops.  */\n   VEC (bitmap, heap) *all_refs_in_loop;\n \n-  /* The set of virtual operands clobbered in a given loop.  */\n-  VEC (bitmap, heap) *clobbered_vops;\n-\n-  /* Map from the pair (loop, virtual operand) to the set of refs that\n-     touch the virtual operand in the loop.  */\n-  VEC (htab_t, heap) *vop_ref_map;\n+  /* The set of memory references stored in each loop, including\n+     subloops.  */\n+  VEC (bitmap, heap) *all_refs_stored_in_loop;\n \n   /* Cache for expanding memory addresses.  */\n   struct pointer_map_t *ttae_cache;\n@@ -202,6 +197,9 @@ static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n #define ALWAYS_EXECUTED_IN(BB) ((struct loop *) (BB)->aux)\n #define SET_ALWAYS_EXECUTED_IN(BB, VAL) ((BB)->aux = (void *) (VAL))\n \n+/* Whether the reference was analyzable.  */\n+#define MEM_ANALYZABLE(REF) ((REF)->mem != error_mark_node)\n+\n static struct lim_aux_data *\n init_lim_data (gimple stmt)\n {\n@@ -509,28 +507,21 @@ add_dependency (tree def, struct lim_aux_data *data, struct loop *loop,\n   return true;\n }\n \n-/* Returns an estimate for a cost of statement STMT.  TODO -- the values here\n-   are just ad-hoc constants.  The estimates should be based on target-specific\n-   values.  */\n+/* Returns an estimate for a cost of statement STMT.  The values here\n+   are just ad-hoc constants, similar to costs for inlining.  */\n \n static unsigned\n stmt_cost (gimple stmt)\n {\n-  tree fndecl;\n-  unsigned cost = 1;\n-\n   /* Always try to create possibilities for unswitching.  */\n   if (gimple_code (stmt) == GIMPLE_COND\n       || gimple_code (stmt) == GIMPLE_PHI)\n     return LIM_EXPENSIVE;\n \n-  /* Hoisting memory references out should almost surely be a win.  */\n-  if (gimple_references_memory_p (stmt))\n-    cost += 20;\n-\n+  /* We should be hoisting calls if possible.  */\n   if (is_gimple_call (stmt))\n     {\n-      /* We should be hoisting calls if possible.  */\n+      tree fndecl;\n \n       /* Unless the call is a builtin_constant_p; this always folds to a\n \t constant, so moving it is useless.  */\n@@ -540,11 +531,15 @@ stmt_cost (gimple stmt)\n \t  && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CONSTANT_P)\n \treturn 0;\n \n-      return cost + 20;\n+      return LIM_EXPENSIVE;\n     }\n \n+  /* Hoisting memory references out should almost surely be a win.  */\n+  if (gimple_references_memory_p (stmt))\n+    return LIM_EXPENSIVE;\n+\n   if (gimple_code (stmt) != GIMPLE_ASSIGN)\n-    return cost;\n+    return 1;\n \n   switch (gimple_assign_rhs_code (stmt))\n     {\n@@ -565,22 +560,31 @@ stmt_cost (gimple stmt)\n     case TRUNC_MOD_EXPR:\n     case RDIV_EXPR:\n       /* Division and multiplication are usually expensive.  */\n-      cost += 20;\n-      break;\n+      return LIM_EXPENSIVE;\n \n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n     case WIDEN_LSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n-      cost += 20;\n-      break;\n+      /* Shifts and rotates are usually expensive.  */\n+      return LIM_EXPENSIVE;\n+\n+    case CONSTRUCTOR:\n+      /* Make vector construction cost proportional to the number\n+         of elements.  */\n+      return CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt));\n+\n+    case SSA_NAME:\n+    case PAREN_EXPR:\n+      /* Whether or not something is wrapped inside a PAREN_EXPR\n+         should not change move cost.  Nor should an intermediate\n+\t unpropagated SSA name copy.  */\n+      return 0;\n \n     default:\n-      break;\n+      return 1;\n     }\n-\n-  return cost;\n }\n \n /* Finds the outermost loop between OUTER and LOOP in that the memory reference\n@@ -1472,7 +1476,6 @@ memref_free (void *obj)\n     free_mem_ref_locs (accs);\n   VEC_free (mem_ref_locs_p, heap, mem->accesses_in_loop);\n \n-  BITMAP_FREE (mem->vops);\n   free (mem);\n }\n \n@@ -1492,7 +1495,6 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n   ref->indep_ref = BITMAP_ALLOC (NULL);\n   ref->dep_ref = BITMAP_ALLOC (NULL);\n   ref->accesses_in_loop = NULL;\n-  ref->vops = BITMAP_ALLOC (NULL);\n \n   return ref;\n }\n@@ -1559,17 +1561,28 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n   hashval_t hash;\n   PTR *slot;\n   mem_ref_p ref;\n-  tree vname;\n   bool is_stored;\n-  bitmap clvops;\n   unsigned id;\n \n   if (!gimple_vuse (stmt))\n     return;\n \n   mem = simple_mem_ref_in_stmt (stmt, &is_stored);\n   if (!mem)\n-    goto fail;\n+    {\n+      id = VEC_length (mem_ref_p, memory_accesses.refs_list);\n+      ref = mem_ref_alloc (error_mark_node, 0, id);\n+      VEC_safe_push (mem_ref_p, heap, memory_accesses.refs_list, ref);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Unanalyzed memory reference %u: \", id);\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      if (gimple_vdef (stmt))\n+\tmark_ref_stored (ref, loop);\n+      record_mem_ref_loc (ref, loop, stmt, mem);\n+      return;\n+    }\n \n   hash = iterative_hash_expr (*mem, 0);\n   slot = htab_find_slot_with_hash (memory_accesses.refs, *mem, hash, INSERT);\n@@ -1596,15 +1609,8 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n   if (is_stored)\n     mark_ref_stored (ref, loop);\n \n-  if ((vname = gimple_vuse (stmt)) != NULL_TREE)\n-    bitmap_set_bit (ref->vops, DECL_UID (SSA_NAME_VAR (vname)));\n   record_mem_ref_loc (ref, loop, stmt, mem);\n   return;\n-\n-fail:\n-  clvops = VEC_index (bitmap, memory_accesses.clobbered_vops, loop->num);\n-  if ((vname = gimple_vuse (stmt)) != NULL_TREE)\n-    bitmap_set_bit (clvops, DECL_UID (SSA_NAME_VAR (vname)));\n }\n \n /* Gathers memory references in loops.  */\n@@ -1616,7 +1622,6 @@ gather_mem_refs_in_loops (void)\n   basic_block bb;\n   struct loop *loop;\n   loop_iterator li;\n-  bitmap clvo, clvi;\n   bitmap lrefs, alrefs, alrefso;\n \n   FOR_EACH_BB (bb)\n@@ -1629,8 +1634,8 @@ gather_mem_refs_in_loops (void)\n \tgather_mem_refs_stmt (loop, gsi_stmt (bsi));\n     }\n \n-  /* Propagate the information about clobbered vops and accessed memory\n-     references up the loop hierarchy.  */\n+  /* Propagate the information about accessed memory references up\n+     the loop hierarchy.  */\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       lrefs = VEC_index (bitmap, memory_accesses.refs_in_loop, loop->num);\n@@ -1640,133 +1645,12 @@ gather_mem_refs_in_loops (void)\n       if (loop_outer (loop) == current_loops->tree_root)\n \tcontinue;\n \n-      clvi = VEC_index (bitmap, memory_accesses.clobbered_vops, loop->num);\n-      clvo = VEC_index (bitmap, memory_accesses.clobbered_vops,\n-\t\t\tloop_outer (loop)->num);\n-      bitmap_ior_into (clvo, clvi);\n-\n       alrefso = VEC_index (bitmap, memory_accesses.all_refs_in_loop,\n \t\t\t   loop_outer (loop)->num);\n       bitmap_ior_into (alrefso, alrefs);\n     }\n }\n \n-/* Element of the hash table that maps vops to memory references.  */\n-\n-struct vop_to_refs_elt\n-{\n-  /* DECL_UID of the vop.  */\n-  unsigned uid;\n-\n-  /* List of the all references.  */\n-  bitmap refs_all;\n-\n-  /* List of stored references.  */\n-  bitmap refs_stored;\n-};\n-\n-/* A hash function for struct vop_to_refs_elt object OBJ.  */\n-\n-static hashval_t\n-vtoe_hash (const void *obj)\n-{\n-  const struct vop_to_refs_elt *const vtoe =\n-    (const struct vop_to_refs_elt *) obj;\n-\n-  return vtoe->uid;\n-}\n-\n-/* An equality function for struct vop_to_refs_elt object OBJ1 with\n-   uid of a vop OBJ2.  */\n-\n-static int\n-vtoe_eq (const void *obj1, const void *obj2)\n-{\n-  const struct vop_to_refs_elt *const vtoe =\n-    (const struct vop_to_refs_elt *) obj1;\n-  const unsigned *const uid = (const unsigned *) obj2;\n-\n-  return vtoe->uid == *uid;\n-}\n-\n-/* A function to free the struct vop_to_refs_elt object.  */\n-\n-static void\n-vtoe_free (void *obj)\n-{\n-  struct vop_to_refs_elt *const vtoe =\n-    (struct vop_to_refs_elt *) obj;\n-\n-  BITMAP_FREE (vtoe->refs_all);\n-  BITMAP_FREE (vtoe->refs_stored);\n-  free (vtoe);\n-}\n-\n-/* Records REF to hashtable VOP_TO_REFS for the index VOP.  STORED is true\n-   if the reference REF is stored.  */\n-\n-static void\n-record_vop_access (htab_t vop_to_refs, unsigned vop, unsigned ref, bool stored)\n-{\n-  void **slot = htab_find_slot_with_hash (vop_to_refs, &vop, vop, INSERT);\n-  struct vop_to_refs_elt *vtoe;\n-\n-  if (!*slot)\n-    {\n-      vtoe = XNEW (struct vop_to_refs_elt);\n-      vtoe->uid = vop;\n-      vtoe->refs_all = BITMAP_ALLOC (NULL);\n-      vtoe->refs_stored = BITMAP_ALLOC (NULL);\n-      *slot = vtoe;\n-    }\n-  else\n-    vtoe = (struct vop_to_refs_elt *) *slot;\n-\n-  bitmap_set_bit (vtoe->refs_all, ref);\n-  if (stored)\n-    bitmap_set_bit (vtoe->refs_stored, ref);\n-}\n-\n-/* Returns the set of references that access VOP according to the table\n-   VOP_TO_REFS.  */\n-\n-static bitmap\n-get_vop_accesses (htab_t vop_to_refs, unsigned vop)\n-{\n-  struct vop_to_refs_elt *const vtoe =\n-    (struct vop_to_refs_elt *) htab_find_with_hash (vop_to_refs, &vop, vop);\n-  return vtoe->refs_all;\n-}\n-\n-/* Returns the set of stores that access VOP according to the table\n-   VOP_TO_REFS.  */\n-\n-static bitmap\n-get_vop_stores (htab_t vop_to_refs, unsigned vop)\n-{\n-  struct vop_to_refs_elt *const vtoe =\n-    (struct vop_to_refs_elt *) htab_find_with_hash (vop_to_refs, &vop, vop);\n-  return vtoe->refs_stored;\n-}\n-\n-/* Adds REF to mapping from virtual operands to references in LOOP.  */\n-\n-static void\n-add_vop_ref_mapping (struct loop *loop, mem_ref_p ref)\n-{\n-  htab_t map = VEC_index (htab_t, memory_accesses.vop_ref_map, loop->num);\n-  bool stored = bitmap_bit_p (ref->stored, loop->num);\n-  bitmap clobbers = VEC_index (bitmap, memory_accesses.clobbered_vops,\n-\t\t\t       loop->num);\n-  bitmap_iterator bi;\n-  unsigned vop;\n-\n-  EXECUTE_IF_AND_COMPL_IN_BITMAP (ref->vops, clobbers, 0, vop, bi)\n-    {\n-      record_vop_access (map, vop, ref->id, stored);\n-    }\n-}\n-\n /* Create a mapping from virtual operands to references that touch them\n    in LOOP.  */\n \n@@ -1782,8 +1666,15 @@ create_vop_ref_mapping_loop (struct loop *loop)\n   EXECUTE_IF_SET_IN_BITMAP (refs, 0, i, bi)\n     {\n       ref = VEC_index (mem_ref_p, memory_accesses.refs_list, i);\n-      for (sloop = loop; sloop != current_loops->tree_root; sloop = loop_outer (sloop))\n-\tadd_vop_ref_mapping (sloop, ref);\n+      for (sloop = loop; sloop != current_loops->tree_root;\n+\t   sloop = loop_outer (sloop))\n+\tif (bitmap_bit_p (ref->stored, loop->num))\n+\t  {\n+\t    bitmap refs_stored\n+\t      = VEC_index (bitmap, memory_accesses.all_refs_stored_in_loop,\n+\t\t\t   sloop->num);\n+\t    bitmap_set_bit (refs_stored, ref->id);\n+\t  }\n     }\n }\n \n@@ -1809,7 +1700,6 @@ analyze_memory_references (void)\n {\n   unsigned i;\n   bitmap empty;\n-  htab_t hempty;\n \n   memory_accesses.refs\n \t  = htab_create (100, memref_hash, memref_eq, memref_free);\n@@ -1818,10 +1708,8 @@ analyze_memory_references (void)\n \t\t\t\t\t    number_of_loops ());\n   memory_accesses.all_refs_in_loop = VEC_alloc (bitmap, heap,\n \t\t\t\t\t\tnumber_of_loops ());\n-  memory_accesses.clobbered_vops = VEC_alloc (bitmap, heap,\n-\t\t\t\t\t      number_of_loops ());\n-  memory_accesses.vop_ref_map = VEC_alloc (htab_t, heap,\n-\t\t\t\t\t   number_of_loops ());\n+  memory_accesses.all_refs_stored_in_loop = VEC_alloc (bitmap, heap,\n+\t\t\t\t\t\t       number_of_loops ());\n \n   for (i = 0; i < number_of_loops (); i++)\n     {\n@@ -1830,9 +1718,7 @@ analyze_memory_references (void)\n       empty = BITMAP_ALLOC (NULL);\n       VEC_quick_push (bitmap, memory_accesses.all_refs_in_loop, empty);\n       empty = BITMAP_ALLOC (NULL);\n-      VEC_quick_push (bitmap, memory_accesses.clobbered_vops, empty);\n-      hempty = htab_create (10, vtoe_hash, vtoe_eq, vtoe_free);\n-      VEC_quick_push (htab_t, memory_accesses.vop_ref_map, hempty);\n+      VEC_quick_push (bitmap, memory_accesses.all_refs_stored_in_loop, empty);\n     }\n \n   memory_accesses.ttae_cache = NULL;\n@@ -2183,6 +2069,9 @@ refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n     return true;\n   if (bitmap_bit_p (ref1->dep_ref, ref2->id))\n     return false;\n+  if (!MEM_ANALYZABLE (ref1)\n+      || !MEM_ANALYZABLE (ref2))\n+    return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Querying dependency of refs %u and %u: \",\n@@ -2225,43 +2114,32 @@ record_indep_loop (struct loop *loop, mem_ref_p ref, bool indep)\n static bool\n ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref)\n {\n-  bitmap clobbers, refs_to_check, refs;\n+  bitmap refs_to_check;\n   unsigned i;\n   bitmap_iterator bi;\n   bool ret = true, stored = bitmap_bit_p (ref->stored, loop->num);\n-  htab_t map;\n   mem_ref_p aref;\n \n-  /* If the reference is clobbered, it is not independent.  */\n-  clobbers = VEC_index (bitmap, memory_accesses.clobbered_vops, loop->num);\n-  if (bitmap_intersect_p (ref->vops, clobbers))\n-    return false;\n-\n-  refs_to_check = BITMAP_ALLOC (NULL);\n-\n-  map = VEC_index (htab_t, memory_accesses.vop_ref_map, loop->num);\n-  EXECUTE_IF_AND_COMPL_IN_BITMAP (ref->vops, clobbers, 0, i, bi)\n-    {\n-      if (stored)\n-\trefs = get_vop_accesses (map, i);\n-      else\n-\trefs = get_vop_stores (map, i);\n-\n-      bitmap_ior_into (refs_to_check, refs);\n-    }\n+  if (stored)\n+    refs_to_check = VEC_index (bitmap,\n+\t\t\t       memory_accesses.all_refs_in_loop, loop->num);\n+  else\n+    refs_to_check = VEC_index (bitmap,\n+\t\t\t       memory_accesses.all_refs_stored_in_loop,\n+\t\t\t       loop->num);\n \n   EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n     {\n       aref = VEC_index (mem_ref_p, memory_accesses.refs_list, i);\n-      if (!refs_independent_p (ref, aref))\n+      if (!MEM_ANALYZABLE (aref)\n+\t  || !refs_independent_p (ref, aref))\n \t{\n \t  ret = false;\n \t  record_indep_loop (loop, aref, false);\n \t  break;\n \t}\n     }\n \n-  BITMAP_FREE (refs_to_check);\n   return ret;\n }\n \n@@ -2296,6 +2174,10 @@ can_sm_ref_p (struct loop *loop, mem_ref_p ref)\n {\n   tree base;\n \n+  /* Can't hoist unanalyzable refs.  */\n+  if (!MEM_ANALYZABLE (ref))\n+    return false;\n+\n   /* Unless the reference is stored in the loop, there is nothing to do.  */\n   if (!bitmap_bit_p (ref->stored, loop->num))\n     return false;\n@@ -2515,7 +2397,6 @@ tree_ssa_lim_finalize (void)\n   basic_block bb;\n   unsigned i;\n   bitmap b;\n-  htab_t h;\n \n   FOR_EACH_BB (bb)\n     SET_ALWAYS_EXECUTED_IN (bb, NULL);\n@@ -2533,13 +2414,9 @@ tree_ssa_lim_finalize (void)\n     BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.all_refs_in_loop);\n \n-  FOR_EACH_VEC_ELT (bitmap, memory_accesses.clobbered_vops, i, b)\n+  FOR_EACH_VEC_ELT (bitmap, memory_accesses.all_refs_stored_in_loop, i, b)\n     BITMAP_FREE (b);\n-  VEC_free (bitmap, heap, memory_accesses.clobbered_vops);\n-\n-  FOR_EACH_VEC_ELT (htab_t, memory_accesses.vop_ref_map, i, h)\n-    htab_delete (h);\n-  VEC_free (htab_t, heap, memory_accesses.vop_ref_map);\n+  VEC_free (bitmap, heap, memory_accesses.all_refs_stored_in_loop);\n \n   if (memory_accesses.ttae_cache)\n     pointer_map_destroy (memory_accesses.ttae_cache);"}]}