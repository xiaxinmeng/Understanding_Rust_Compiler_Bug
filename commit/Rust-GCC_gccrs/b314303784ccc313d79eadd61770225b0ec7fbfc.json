{"sha": "b314303784ccc313d79eadd61770225b0ec7fbfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMxNDMwMzc4NGNjYzMxM2Q3OWVhZGQ2MTc3MDIyNWIwZWM3ZmJmYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T13:09:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T13:09:07Z"}, "message": "[multiple changes]\n\n2016-04-19  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb, sem_attr.adb, par-prag.adb, exp_aggr.adb, sem_type.adb\n\tsem_ch12.adb, sem_ch3.adb, exp_ch7.adb, exp_ch9.adb: Code cleanup.\n\t* sem_res.adb, sem_util.ads, sem_util.adb (Is_OK_Volatile_Context):\n\tPromoted from being a nested subprogram in Sem_Res.Resolve_Entity_Name\n\tto publicly visible routine in Sem_Util.\n\n2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* checks.adb (Apply_Parameter_Aliasing_Checks): Do not apply\n\tthe check if the type of the actual is By_Reference.\n\nFrom-SVN: r235199", "tree": {"sha": "259ca518485684926c1173c48c5455e7f043577f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/259ca518485684926c1173c48c5455e7f043577f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b314303784ccc313d79eadd61770225b0ec7fbfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b314303784ccc313d79eadd61770225b0ec7fbfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b314303784ccc313d79eadd61770225b0ec7fbfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b314303784ccc313d79eadd61770225b0ec7fbfc/comments", "author": null, "committer": null, "parents": [{"sha": "e90e9503dff78ba8d3c31f01ef41ea8b75d953ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90e9503dff78ba8d3c31f01ef41ea8b75d953ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90e9503dff78ba8d3c31f01ef41ea8b75d953ee"}], "stats": {"total": 567, "additions": 292, "deletions": 275}, "files": [{"sha": "7cc7ff9d410a9177ecda90bce804478c3ca29f30", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -1,3 +1,16 @@\n+2016-04-19  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb, sem_attr.adb, par-prag.adb, exp_aggr.adb, sem_type.adb\n+\tsem_ch12.adb, sem_ch3.adb, exp_ch7.adb, exp_ch9.adb: Code cleanup.\n+\t* sem_res.adb, sem_util.ads, sem_util.adb (Is_OK_Volatile_Context):\n+\tPromoted from being a nested subprogram in Sem_Res.Resolve_Entity_Name\n+\tto publicly visible routine in Sem_Util.\n+\n+2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* checks.adb (Apply_Parameter_Aliasing_Checks): Do not apply\n+\tthe check if the type of the actual is By_Reference.\n+\n 2016-04-19  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_res.adb (Within_Subprogram_Call): Detect"}, {"sha": "eca82d77818c1f0ae7756ad206d78d07a5c7ca91", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -2373,7 +2373,10 @@ package body Checks is\n          --  Elementary types are always passed by value, therefore actuals of\n          --  such types cannot lead to aliasing. An aggregate is an object in\n          --  Ada 2012, but an actual that is an aggregate cannot overlap with\n-         --  another actual.\n+         --  another actual. A type that is By_Reference (such as an array of\n+         --  controlled types) is not subject to the check because any update\n+         --  will be done in place and a subsequent read will always see the\n+         --  correct value, see RM 6.2 (12/3).\n \n          if Nkind (Original_Actual (Actual_1)) = N_Aggregate\n            or else\n@@ -2385,6 +2388,8 @@ package body Checks is\n \n          elsif Is_Object_Reference (Original_Actual (Actual_1))\n            and then not Is_Elementary_Type (Etype (Original_Actual (Actual_1)))\n+           and then\n+              not Is_By_Reference_Type (Etype (Original_Actual (Actual_1)))\n          then\n             Actual_2 := Next_Actual (Actual_1);\n             Formal_2 := Next_Formal (Formal_1);"}, {"sha": "cb97dca4d7c037b8bb8c566ce6a5f1dacd8a7362", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -4321,7 +4321,7 @@ package body Exp_Aggr is\n          Decl     : Node_Id;\n          Typ      : constant Entity_Id := Etype (N);\n          Indexes  : constant List_Id   := New_List;\n-         Num      : Int;\n+         Num      : Nat;\n          Sub_Agg  : Node_Id;\n \n       begin\n@@ -7085,7 +7085,7 @@ package body Exp_Aggr is\n          Byte_Size : constant Int := UI_To_Int (Component_Size (Packed_Array));\n          --  The packed array type is a byte array\n \n-         Packed_Num : Int;\n+         Packed_Num : Nat;\n          --  Number of components accumulated in current byte\n \n          Comps : List_Id;"}, {"sha": "daa5f91c6685a0cff69e6eac4f9b83fb95a8e68b", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -6227,7 +6227,7 @@ package body Exp_Ch7 is\n \n       procedure Preprocess_Components\n         (Comps     : Node_Id;\n-         Num_Comps : out Int;\n+         Num_Comps : out Nat;\n          Has_POC   : out Boolean);\n       --  Examine all components in component list Comps, count all controlled\n       --  components and determine whether at least one of them is per-object\n@@ -6265,7 +6265,7 @@ package body Exp_Ch7 is\n             Decl_Id   : Entity_Id;\n             Decl_Typ  : Entity_Id;\n             Has_POC   : Boolean;\n-            Num_Comps : Int;\n+            Num_Comps : Nat;\n \n             procedure Process_Component_For_Adjust (Decl : Node_Id);\n             --  Process the declaration of a single controlled component\n@@ -6679,7 +6679,7 @@ package body Exp_Ch7 is\n             Jump_Block : Node_Id;\n             Label      : Node_Id;\n             Label_Id   : Entity_Id;\n-            Num_Comps  : Int;\n+            Num_Comps  : Nat;\n             Stmts      : List_Id;\n \n             procedure Process_Component_For_Finalize\n@@ -7236,7 +7236,7 @@ package body Exp_Ch7 is\n \n       procedure Preprocess_Components\n         (Comps     : Node_Id;\n-         Num_Comps : out Int;\n+         Num_Comps : out Nat;\n          Has_POC   : out Boolean)\n       is\n          Decl : Node_Id;"}, {"sha": "faa1d8cafd0c90fe964ae2cdb67df2585f2b492c", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -10590,7 +10590,7 @@ package body Exp_Ch9 is\n       End_Lab        : Node_Id;\n       Index          : Pos := 1;\n       Lab            : Node_Id;\n-      Num_Alts       : Int;\n+      Num_Alts       : Nat;\n       Num_Accept     : Nat := 0;\n       Proc           : Node_Id;\n       Time_Type      : Entity_Id;"}, {"sha": "123f9090ff73f1c27a26a77be4f30b6418629240", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -974,13 +974,13 @@ begin\n                declare\n                   Slen    : constant Natural := Natural (String_Length (S));\n                   Options : String (1 .. Slen);\n-                  J       : Natural;\n-                  Ptr     : Natural;\n+                  J       : Positive;\n+                  Ptr     : Positive;\n \n                begin\n                   J := 1;\n                   loop\n-                     C := Get_String_Char (S, Int (J));\n+                     C := Get_String_Char (S, Pos (J));\n \n                      if not In_Character_Range (C) then\n                         OK := False;"}, {"sha": "fa44c1d96d6b78751c5df4101c24bda89df2f43c", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -6041,7 +6041,7 @@ package body Sem_Attr is\n \n                Start_String;\n                for J in 1 .. String_Length (Full_Name) - 1 loop\n-                  Store_String_Char (Get_String_Char (Full_Name, Int (J)));\n+                  Store_String_Char (Get_String_Char (Full_Name, Pos (J)));\n                end loop;\n \n                Store_String_Chars (\"'Type_Key\");"}, {"sha": "084335c472d86cab1c5c866e0543806d4cd3bd3c", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -15117,7 +15117,7 @@ package body Sem_Ch12 is\n       T       : constant Entity_Id := Entity (Prefix (Def));\n       Is_Fun  : constant Boolean := (Ekind (Nam) = E_Function);\n       F       : Entity_Id;\n-      Num_F   : Int;\n+      Num_F   : Nat;\n       OK      : Boolean;\n \n    begin"}, {"sha": "f2e111536cd1349a1f9614d8147521183b1684a8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -13871,8 +13871,8 @@ package body Sem_Ch3 is\n       --  Inherit the discriminants of the parent type\n \n       Add_Discriminants : declare\n-         Num_Disc : Int;\n-         Num_Gird : Int;\n+         Num_Disc : Nat;\n+         Num_Gird : Nat;\n \n       begin\n          Num_Disc := 0;"}, {"sha": "289cfc8274a5ac593d498017b43727672f8e4b39", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -21242,12 +21242,12 @@ package body Sem_Prag is\n                   declare\n                      Slen    : constant Natural := Natural (String_Length (S));\n                      Options : String (1 .. Slen);\n-                     J       : Natural;\n+                     J       : Positive;\n \n                   begin\n                      J := 1;\n                      loop\n-                        C := Get_String_Char (S, Int (J));\n+                        C := Get_String_Char (S, Pos (J));\n                         exit when not In_Character_Range (C);\n                         Options (J) := Get_Character (C);\n \n@@ -22592,14 +22592,14 @@ package body Sem_Prag is\n                   declare\n                      Slen    : constant Natural := Natural (String_Length (S));\n                      Options : String (1 .. Slen);\n-                     J       : Natural;\n+                     J       : Positive;\n \n                   begin\n                      --  Couldn't we use a for loop here over Options'Range???\n \n                      J := 1;\n                      loop\n-                        C := Get_String_Char (S, Int (J));\n+                        C := Get_String_Char (S, Pos (J));\n \n                         --  This is a weird test, it skips setting validity\n                         --  checks entirely if any element of S is out of"}, {"sha": "85bf0c409639d58316952ea42e9add633dc33a49", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -6820,13 +6820,6 @@ package body Sem_Res is\n       --  Determine whether node Context denotes an assignment statement or an\n       --  object declaration whose expression is node Expr.\n \n-      function Is_OK_Volatile_Context\n-        (Context : Node_Id;\n-         Obj_Ref : Node_Id) return Boolean;\n-      --  Determine whether node Context denotes a \"non-interfering context\"\n-      --  (as defined in SPARK RM 7.1.3(12)) where volatile reference Obj_Ref\n-      --  can safely reside.\n-\n       ----------------------------------------\n       -- Is_Assignment_Or_Object_Expression --\n       ----------------------------------------\n@@ -6869,254 +6862,6 @@ package body Sem_Res is\n          end if;\n       end Is_Assignment_Or_Object_Expression;\n \n-      ----------------------------\n-      -- Is_OK_Volatile_Context --\n-      ----------------------------\n-\n-      function Is_OK_Volatile_Context\n-        (Context : Node_Id;\n-         Obj_Ref : Node_Id) return Boolean\n-      is\n-         function Is_Protected_Operation_Call (Nod : Node_Id) return Boolean;\n-         --  Determine whether an arbitrary node denotes a call to a protected\n-         --  entry, function or procedure in prefixed form where the prefix is\n-         --  Obj_Ref.\n-\n-         function Within_Check (Nod : Node_Id) return Boolean;\n-         --  Determine whether an arbitrary node appears in a check node\n-\n-         function Within_Subprogram_Call (Nod : Node_Id) return Boolean;\n-         --  Determine whether an arbitrary node appears in a subprogram call\n-\n-         function Within_Volatile_Function (Id : Entity_Id) return Boolean;\n-         --  Determine whether an arbitrary entity appears in a volatile\n-         --  function.\n-\n-         ---------------------------------\n-         -- Is_Protected_Operation_Call --\n-         ---------------------------------\n-\n-         function Is_Protected_Operation_Call (Nod : Node_Id) return Boolean is\n-            Pref : Node_Id;\n-            Subp : Node_Id;\n-\n-         begin\n-            --  A call to a protected operations retains its selected component\n-            --  form as opposed to other prefixed calls that are transformed in\n-            --  expanded names.\n-\n-            if Nkind (Nod) = N_Selected_Component then\n-               Pref := Prefix (Nod);\n-               Subp := Selector_Name (Nod);\n-\n-               return\n-                 Pref = Obj_Ref\n-                   and then Present (Etype (Pref))\n-                   and then Is_Protected_Type (Etype (Pref))\n-                   and then Is_Entity_Name (Subp)\n-                   and then Present (Entity (Subp))\n-                   and then Ekind_In (Entity (Subp), E_Entry,\n-                                                     E_Entry_Family,\n-                                                     E_Function,\n-                                                     E_Procedure);\n-            else\n-               return False;\n-            end if;\n-         end Is_Protected_Operation_Call;\n-\n-         ------------------\n-         -- Within_Check --\n-         ------------------\n-\n-         function Within_Check (Nod : Node_Id) return Boolean is\n-            Par : Node_Id;\n-\n-         begin\n-            --  Climb the parent chain looking for a check node\n-\n-            Par := Nod;\n-            while Present (Par) loop\n-               if Nkind (Par) in N_Raise_xxx_Error then\n-                  return True;\n-\n-               --  Prevent the search from going too far\n-\n-               elsif Is_Body_Or_Package_Declaration (Par) then\n-                  exit;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            return False;\n-         end Within_Check;\n-\n-         ----------------------------\n-         -- Within_Subprogram_Call --\n-         ----------------------------\n-\n-         function Within_Subprogram_Call (Nod : Node_Id) return Boolean is\n-            Par : Node_Id;\n-\n-         begin\n-            --  Climb the parent chain looking for a function or procedure call\n-\n-            Par := Nod;\n-            while Present (Par) loop\n-               if Nkind_In (Par, N_Function_Call,\n-                                 N_Procedure_Call_Statement,\n-                                 N_Entry_Call_Statement)\n-               then\n-                  return True;\n-\n-               --  Prevent the search from going too far\n-\n-               elsif Is_Body_Or_Package_Declaration (Par) then\n-                  exit;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            return False;\n-         end Within_Subprogram_Call;\n-\n-         ------------------------------\n-         -- Within_Volatile_Function --\n-         ------------------------------\n-\n-         function Within_Volatile_Function (Id : Entity_Id) return Boolean is\n-            Func_Id : Entity_Id;\n-\n-         begin\n-            --  Traverse the scope stack looking for a [generic] function\n-\n-            Func_Id := Id;\n-            while Present (Func_Id) and then Func_Id /= Standard_Standard loop\n-               if Ekind_In (Func_Id, E_Function, E_Generic_Function) then\n-                  return Is_Volatile_Function (Func_Id);\n-               end if;\n-\n-               Func_Id := Scope (Func_Id);\n-            end loop;\n-\n-            return False;\n-         end Within_Volatile_Function;\n-\n-         --  Local variables\n-\n-         Obj_Id : Entity_Id;\n-\n-      --  Start of processing for Is_OK_Volatile_Context\n-\n-      begin\n-         --  The volatile object appears on either side of an assignment\n-\n-         if Nkind (Context) = N_Assignment_Statement then\n-            return True;\n-\n-         --  The volatile object is part of the initialization expression of\n-         --  another object.\n-\n-         elsif Nkind (Context) = N_Object_Declaration\n-           and then Present (Expression (Context))\n-           and then Expression (Context) = Obj_Ref\n-         then\n-            Obj_Id := Defining_Entity (Context);\n-\n-            --  The volatile object acts as the initialization expression of an\n-            --  extended return statement. This is valid context as long as the\n-            --  function is volatile.\n-\n-            if Is_Return_Object (Obj_Id) then\n-               return Within_Volatile_Function (Obj_Id);\n-\n-            --  Otherwise this is a normal object initialization\n-\n-            else\n-               return True;\n-            end if;\n-\n-         --  The volatile object acts as the name of a renaming declaration\n-\n-         elsif Nkind (Context) = N_Object_Renaming_Declaration\n-           and then Name (Context) = Obj_Ref\n-         then\n-            return True;\n-\n-         --  The volatile object appears as an actual parameter in a call to an\n-         --  instance of Unchecked_Conversion whose result is renamed.\n-\n-         elsif Nkind (Context) = N_Function_Call\n-           and then Is_Entity_Name (Name (Context))\n-           and then Is_Unchecked_Conversion_Instance (Entity (Name (Context)))\n-           and then Nkind (Parent (Context)) = N_Object_Renaming_Declaration\n-         then\n-            return True;\n-\n-         --  The volatile object is actually the prefix in a protected entry,\n-         --  function, or procedure call.\n-\n-         elsif Is_Protected_Operation_Call (Context) then\n-            return True;\n-\n-         --  The volatile object appears as the expression of a simple return\n-         --  statement that applies to a volatile function.\n-\n-         elsif Nkind (Context) = N_Simple_Return_Statement\n-           and then Expression (Context) = Obj_Ref\n-         then\n-            return\n-              Within_Volatile_Function (Return_Statement_Entity (Context));\n-\n-         --  The volatile object appears as the prefix of a name occurring\n-         --  in a non-interfering context.\n-\n-         elsif Nkind_In (Context, N_Attribute_Reference,\n-                                  N_Explicit_Dereference,\n-                                  N_Indexed_Component,\n-                                  N_Selected_Component,\n-                                  N_Slice)\n-           and then Prefix (Context) = Obj_Ref\n-           and then Is_OK_Volatile_Context\n-                      (Context => Parent (Context),\n-                       Obj_Ref => Context)\n-         then\n-            return True;\n-\n-         --  The volatile object appears as the expression of a type conversion\n-         --  occurring in a non-interfering context.\n-\n-         elsif Nkind_In (Context, N_Type_Conversion,\n-                                  N_Unchecked_Type_Conversion)\n-           and then Expression (Context) = Obj_Ref\n-           and then Is_OK_Volatile_Context\n-                      (Context => Parent (Context),\n-                       Obj_Ref => Context)\n-         then\n-            return True;\n-\n-         --  Allow references to volatile objects in various checks. This is\n-         --  not a direct SPARK 2014 requirement.\n-\n-         elsif Within_Check (Context) then\n-            return True;\n-\n-         --  Assume that references to effectively volatile objects that appear\n-         --  as actual parameters in a subprogram call are always legal. A full\n-         --  legality check is done when the actuals are resolved.\n-\n-         elsif Within_Subprogram_Call (Context) then\n-            return True;\n-\n-         --  Otherwise the context is not suitable for an effectively volatile\n-         --  object.\n-\n-         else\n-            return False;\n-         end if;\n-      end Is_OK_Volatile_Context;\n-\n       --  Local variables\n \n       E   : constant Entity_Id := Entity (N);"}, {"sha": "a648bfa58374afa82517c7435244f50b0baf567e", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -3029,7 +3029,7 @@ package body Sem_Type is\n       Op_Name     : constant Name_Id   := Chars (Op);\n       T           : constant Entity_Id := Etype (New_S);\n       New_F       : Entity_Id;\n-      Num         : Int;\n+      Num         : Nat;\n       Old_F       : Entity_Id;\n       T1          : Entity_Id;\n       T2          : Entity_Id;"}, {"sha": "d4a276ca5d8c33b0e60c86c1d4a735a6c1d158da", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -13010,6 +13010,253 @@ package body Sem_Util is\n       end if;\n    end Is_OK_Variable_For_Out_Formal;\n \n+   ----------------------------\n+   -- Is_OK_Volatile_Context --\n+   ----------------------------\n+\n+   function Is_OK_Volatile_Context\n+     (Context : Node_Id;\n+      Obj_Ref : Node_Id) return Boolean\n+   is\n+      function Is_Protected_Operation_Call (Nod : Node_Id) return Boolean;\n+      --  Determine whether an arbitrary node denotes a call to a protected\n+      --  entry, function or procedure in prefixed form where the prefix is\n+      --  Obj_Ref.\n+\n+      function Within_Check (Nod : Node_Id) return Boolean;\n+      --  Determine whether an arbitrary node appears in a check node\n+\n+      function Within_Subprogram_Call (Nod : Node_Id) return Boolean;\n+      --  Determine whether an arbitrary node appears in a procedure call\n+\n+      function Within_Volatile_Function (Id : Entity_Id) return Boolean;\n+      --  Determine whether an arbitrary entity appears in a volatile function\n+\n+      ---------------------------------\n+      -- Is_Protected_Operation_Call --\n+      ---------------------------------\n+\n+      function Is_Protected_Operation_Call (Nod : Node_Id) return Boolean is\n+         Pref : Node_Id;\n+         Subp : Node_Id;\n+\n+      begin\n+         --  A call to a protected operations retains its selected component\n+         --  form as opposed to other prefixed calls that are transformed in\n+         --  expanded names.\n+\n+         if Nkind (Nod) = N_Selected_Component then\n+            Pref := Prefix (Nod);\n+            Subp := Selector_Name (Nod);\n+\n+            return\n+              Pref = Obj_Ref\n+              and then Present (Etype (Pref))\n+              and then Is_Protected_Type (Etype (Pref))\n+              and then Is_Entity_Name (Subp)\n+              and then Present (Entity (Subp))\n+              and then Ekind_In (Entity (Subp), E_Entry,\n+                                 E_Entry_Family,\n+                                 E_Function,\n+                                 E_Procedure);\n+         else\n+            return False;\n+         end if;\n+      end Is_Protected_Operation_Call;\n+\n+      ------------------\n+      -- Within_Check --\n+      ------------------\n+\n+      function Within_Check (Nod : Node_Id) return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         --  Climb the parent chain looking for a check node\n+\n+         Par := Nod;\n+         while Present (Par) loop\n+            if Nkind (Par) in N_Raise_xxx_Error then\n+               return True;\n+\n+               --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return False;\n+      end Within_Check;\n+\n+      ----------------------------\n+      -- Within_Subprogram_Call --\n+      ----------------------------\n+\n+      function Within_Subprogram_Call (Nod : Node_Id) return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         --  Climb the parent chain looking for a function or procedure call\n+\n+         Par := Nod;\n+         while Present (Par) loop\n+            if Nkind_In (Par, N_Function_Call,\n+                              N_Procedure_Call_Statement,\n+                              N_Entry_Call_Statement)\n+            then\n+               return True;\n+\n+               --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return False;\n+      end Within_Subprogram_Call;\n+\n+      ------------------------------\n+      -- Within_Volatile_Function --\n+      ------------------------------\n+\n+      function Within_Volatile_Function (Id : Entity_Id) return Boolean is\n+         Func_Id : Entity_Id;\n+\n+      begin\n+         --  Traverse the scope stack looking for a [generic] function\n+\n+         Func_Id := Id;\n+         while Present (Func_Id) and then Func_Id /= Standard_Standard loop\n+            if Ekind_In (Func_Id, E_Function, E_Generic_Function) then\n+               return Is_Volatile_Function (Func_Id);\n+            end if;\n+\n+            Func_Id := Scope (Func_Id);\n+         end loop;\n+\n+         return False;\n+      end Within_Volatile_Function;\n+\n+      --  Local variables\n+\n+      Obj_Id : Entity_Id;\n+\n+   --  Start of processing for Is_OK_Volatile_Context\n+\n+   begin\n+      --  The volatile object appears on either side of an assignment\n+\n+      if Nkind (Context) = N_Assignment_Statement then\n+         return True;\n+\n+         --  The volatile object is part of the initialization expression of\n+         --  another object.\n+\n+      elsif Nkind (Context) = N_Object_Declaration\n+        and then Present (Expression (Context))\n+        and then Expression (Context) = Obj_Ref\n+      then\n+         Obj_Id := Defining_Entity (Context);\n+\n+         --  The volatile object acts as the initialization expression of an\n+         --  extended return statement. This is valid context as long as the\n+         --  function is volatile.\n+\n+         if Is_Return_Object (Obj_Id) then\n+            return Within_Volatile_Function (Obj_Id);\n+\n+            --  Otherwise this is a normal object initialization\n+\n+         else\n+            return True;\n+         end if;\n+\n+         --  The volatile object acts as the name of a renaming declaration\n+\n+      elsif Nkind (Context) = N_Object_Renaming_Declaration\n+        and then Name (Context) = Obj_Ref\n+      then\n+         return True;\n+\n+         --  The volatile object appears as an actual parameter in a call to an\n+         --  instance of Unchecked_Conversion whose result is renamed.\n+\n+      elsif Nkind (Context) = N_Function_Call\n+        and then Is_Entity_Name (Name (Context))\n+        and then Is_Unchecked_Conversion_Instance (Entity (Name (Context)))\n+        and then Nkind (Parent (Context)) = N_Object_Renaming_Declaration\n+      then\n+         return True;\n+\n+         --  The volatile object is actually the prefix in a protected entry,\n+         --  function, or procedure call.\n+\n+      elsif Is_Protected_Operation_Call (Context) then\n+         return True;\n+\n+         --  The volatile object appears as the expression of a simple return\n+         --  statement that applies to a volatile function.\n+\n+      elsif Nkind (Context) = N_Simple_Return_Statement\n+        and then Expression (Context) = Obj_Ref\n+      then\n+         return\n+           Within_Volatile_Function (Return_Statement_Entity (Context));\n+\n+         --  The volatile object appears as the prefix of a name occurring in a\n+         --  non-interfering context.\n+\n+      elsif Nkind_In (Context, N_Attribute_Reference,\n+                      N_Explicit_Dereference,\n+                      N_Indexed_Component,\n+                      N_Selected_Component,\n+                      N_Slice)\n+        and then Prefix (Context) = Obj_Ref\n+        and then Is_OK_Volatile_Context\n+          (Context => Parent (Context),\n+           Obj_Ref => Context)\n+      then\n+         return True;\n+\n+         --  The volatile object appears as the expression of a type conversion\n+         --  occurring in a non-interfering context.\n+\n+      elsif Nkind_In (Context, N_Type_Conversion,\n+                      N_Unchecked_Type_Conversion)\n+        and then Expression (Context) = Obj_Ref\n+        and then Is_OK_Volatile_Context\n+          (Context => Parent (Context),\n+           Obj_Ref => Context)\n+      then\n+         return True;\n+\n+         --  Allow references to volatile objects in various checks. This is\n+         --  not a direct SPARK 2014 requirement.\n+\n+      elsif Within_Check (Context) then\n+         return True;\n+\n+         --  Assume that references to effectively volatile objects that appear\n+         --  as actual parameters in a subprogram call are always legal. A full\n+         --  legality check is done when the actuals are resolved.\n+\n+      elsif Within_Subprogram_Call (Context) then\n+         return True;\n+\n+         --  Otherwise the context is not suitable for an effectively volatile\n+         --  object.\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_OK_Volatile_Context;\n+\n    ------------------------------------\n    -- Is_Package_Contract_Annotation --\n    ------------------------------------"}, {"sha": "4575077fead00bac55b23773fdfc35c3ebb5d9f8", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b314303784ccc313d79eadd61770225b0ec7fbfc/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b314303784ccc313d79eadd61770225b0ec7fbfc", "patch": "@@ -1474,6 +1474,13 @@ package Sem_Util is\n    --  the Is_Variable sense) with an untagged type target are considered view\n    --  conversions and hence variables.\n \n+   function Is_OK_Volatile_Context\n+     (Context : Node_Id;\n+      Obj_Ref : Node_Id) return Boolean;\n+   --  Determine whether node Context denotes a \"non-interfering context\" (as\n+   --  defined in SPARK RM 7.1.3(12)) where volatile reference Obj_Ref can\n+   --  safely reside.\n+\n    function Is_Package_Contract_Annotation (Item : Node_Id) return Boolean;\n    --  Determine whether aspect specification or pragma Item is one of the\n    --  following package contract annotations:"}]}