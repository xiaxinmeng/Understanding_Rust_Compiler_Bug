{"sha": "230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMwZmExZmM3M2Q0ZDAzZmZlNzVmZDYyMGI0MzZmMzZhNzBjYmYyNg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-05-27T05:27:31Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-05-27T05:27:31Z"}, "message": "re PR libfortran/40187 (c_f_pointer with stride in SHAPE)\n\n2009-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/40187\n\t* intrinsics/iso_c_binding.c (c_f_pointer_u0):  Take care\n\tof stride in \"shape\" argument.\n\n2009-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/40187\n\t* gfortran.dg/c_f_pointer_shape_tests_4.f03:  New file.\n\t* gfortran.dg/c_f_pointer_shape_tests_4_driver.c:  New file.\n\nFrom-SVN: r147894", "tree": {"sha": "04870f893271fc3fdd567d604453d382cc3fd865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04870f893271fc3fdd567d604453d382cc3fd865"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/comments", "author": null, "committer": null, "parents": [{"sha": "82f331ff93ed75fef446c6a0c846ad22a49cd0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f331ff93ed75fef446c6a0c846ad22a49cd0dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82f331ff93ed75fef446c6a0c846ad22a49cd0dd"}], "stats": {"total": 235, "additions": 208, "deletions": 27}, "files": [{"sha": "3c081297d6c65a8910c9a99d4b06199ff02d7057", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "patch": "@@ -1,3 +1,9 @@\n+2009-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/40187\n+\t* gfortran.dg/c_f_pointer_shape_tests_4.f03:  New file.\n+\t* gfortran.dg/c_f_pointer_shape_tests_4_driver.c:  New file.\n+\n 2009-05-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40246"}, {"sha": "89b8666d7ae479bd25976973a34bca4f71aefc48", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_tests_4.f03", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_4.f03?ref=230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "patch": "@@ -0,0 +1,115 @@\n+! { dg-do run }\n+! { dg-additional-sources c_f_pointer_shape_tests_2_driver.c }\n+! Verify that the optional SHAPE parameter to c_f_pointer can be of any\n+! valid integer kind.  We don't test all kinds here since it would be \n+! difficult to know what kinds are valid for the architecture we're running on.\n+! However, testing ones that should be different should be sufficient.\n+module c_f_pointer_shape_tests_4\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+contains\n+  subroutine test_long_long_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_long_long), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_long_long_1d\n+\n+  subroutine test_long_long_2d(cPtr, num_rows, num_cols) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_rows\n+    integer(c_int), value :: num_cols\n+    integer, dimension(:,:), pointer :: myArrayPtr\n+    integer(c_long_long), dimension(3) :: shape\n+    integer :: i,j\n+    \n+    shape(1) = num_rows\n+    shape(2) = -3;\n+    shape(3) = num_cols\n+    call c_f_pointer(cPtr, myArrayPtr, shape(1:3:2)) \n+    do j = 1, num_cols\n+       do i = 1, num_rows\n+          if(myArrayPtr(i,j) /= ((j-1)*num_rows)+(i-1)) call abort ()\n+       end do\n+    end do\n+  end subroutine test_long_long_2d\n+\n+  subroutine test_long_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_long), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_long_1d\n+\n+  subroutine test_int_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_int), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_int_1d\n+\n+  subroutine test_short_1d(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_short), dimension(1) :: shape\n+    integer :: i\n+    \n+    shape(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_short_1d\n+\n+  subroutine test_mixed(cPtr, num_elems) bind(c)\n+    use, intrinsic :: iso_c_binding\n+    type(c_ptr), value :: cPtr\n+    integer(c_int), value :: num_elems\n+    integer, dimension(:), pointer :: myArrayPtr\n+    integer(c_int), dimension(1) :: shape1\n+    integer(c_long_long), dimension(1) :: shape2\n+    integer :: i\n+\n+    shape1(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape1) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+\n+    nullify(myArrayPtr)\n+    shape2(1) = num_elems\n+    call c_f_pointer(cPtr, myArrayPtr, shape2) \n+    do i = 1, num_elems\n+       if(myArrayPtr(i) /= (i-1)) call abort ()\n+    end do\n+  end subroutine test_mixed\n+end module c_f_pointer_shape_tests_4\n+! { dg-final { cleanup-modules \"c_f_pointer_shape_tests_4\" } } \n+"}, {"sha": "1282beb12d7e7794eea476be5891784b7006af47", "filename": "gcc/testsuite/gfortran.dg/c_f_pointer_shape_tests_4_driver.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_4_driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_4_driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_f_pointer_shape_tests_4_driver.c?ref=230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "patch": "@@ -0,0 +1,46 @@\n+#define NUM_ELEMS 10\n+#define NUM_ROWS 2\n+#define NUM_COLS 3\n+\n+void test_long_long_1d(int *array, int num_elems);\n+void test_long_long_2d(int *array, int num_rows, int num_cols);\n+void test_long_1d(int *array, int num_elems);\n+void test_int_1d(int *array, int num_elems);\n+void test_short_1d(int *array, int num_elems);\n+void test_mixed(int *array, int num_elems);\n+\n+int main(int argc, char **argv)\n+{\n+  int my_array[NUM_ELEMS];\n+  int my_2d_array[NUM_ROWS][NUM_COLS];\n+  int i, j;\n+\n+  for(i = 0; i < NUM_ELEMS; i++)\n+    my_array[i] = i;\n+\n+  for(i = 0; i < NUM_ROWS; i++)\n+    for(j = 0; j < NUM_COLS; j++)\n+      my_2d_array[i][j] = (i*NUM_COLS) + j;\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_long_long.  */\n+  test_long_long_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_long_long.  \n+     The indices are transposed for Fortran.  */\n+  test_long_long_2d(my_2d_array[0], NUM_COLS, NUM_ROWS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_long.  */\n+  test_long_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_int.  */\n+  test_int_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_short.  */\n+  test_short_1d(my_array, NUM_ELEMS);\n+\n+  /* Test c_f_pointer where SHAPE is of type integer, kind=c_int and\n+\t  kind=c_long_long.  */\n+  test_mixed(my_array, NUM_ELEMS);\n+\n+  return 0;\n+}"}, {"sha": "d4a34c52475cc86cec573d095d9716c46213db3b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "patch": "@@ -1,3 +1,9 @@\n+2009-05-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/40187\n+\t* intrinsics/iso_c_binding.c (c_f_pointer_u0):  Take care\n+\tof stride in \"shape\" argument.\n+\n 2009-05-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/39178"}, {"sha": "38f07753c72e3439b9e8d86515fc5d6309b80c00", "filename": "libgfortran/intrinsics/iso_c_binding.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230fa1fc73d4d03ffe75fd620b436f36a70cbf26/libgfortran%2Fintrinsics%2Fiso_c_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fiso_c_binding.c?ref=230fa1fc73d4d03ffe75fd620b436f36a70cbf26", "patch": "@@ -95,9 +95,17 @@ ISO_C_BINDING_PREFIX (c_f_pointer_u0) (void *c_ptr_in,\n \n   if (shape != NULL)\n     {\n+      index_type source_stride;\n+      index_type size;\n+      char *p;\n+\n       f_ptr_out->offset = 0;\n       shapeSize = 0;\n-      \n+      p = shape->data;\n+      size = GFC_DESCRIPTOR_SIZE(shape);\n+\n+      source_stride = shape->dim[0].stride * size;\n+\n       /* shape's length (rank of the output array) */\n       shapeSize = shape->dim[0].ubound + 1 - shape->dim[0].lbound;\n       for (i = 0; i < shapeSize; i++)\n@@ -107,40 +115,40 @@ ISO_C_BINDING_PREFIX (c_f_pointer_u0) (void *c_ptr_in,\n           /* Have to allow for the SHAPE array to be any valid kind for\n              an INTEGER type.  */\n #ifdef HAVE_GFC_INTEGER_1\n-\t  if (GFC_DESCRIPTOR_SIZE (shape) == 1)\n-\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_1 *) (shape->data))[i];\n+\t  if (size == 1)\n+\t    f_ptr_out->dim[i].ubound = *((GFC_INTEGER_1 *) p);\n #endif\n #ifdef HAVE_GFC_INTEGER_2\n-\t  if (GFC_DESCRIPTOR_SIZE (shape) == 2)\n-\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_2 *) (shape->data))[i];\n+\t  if (size == 2)\n+\t    f_ptr_out->dim[i].ubound = *((GFC_INTEGER_2 *) p);\n #endif\n #ifdef HAVE_GFC_INTEGER_4\n-\t  if (GFC_DESCRIPTOR_SIZE (shape) == 4)\n-\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_4 *) (shape->data))[i];\n+\t  if (size == 4)\n+\t    f_ptr_out->dim[i].ubound = *((GFC_INTEGER_4 *) p);\n #endif\n #ifdef HAVE_GFC_INTEGER_8\n-\t  if (GFC_DESCRIPTOR_SIZE (shape) == 8)\n-\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_8 *) (shape->data))[i];\n+\t  if (size == 8)\n+\t    f_ptr_out->dim[i].ubound = *((GFC_INTEGER_8 *) p);\n #endif\n #ifdef HAVE_GFC_INTEGER_16\n-\t  if (GFC_DESCRIPTOR_SIZE (shape) == 16)\n-\t    f_ptr_out->dim[i].ubound = ((GFC_INTEGER_16 *) (shape->data))[i];\n-#endif\t\t\n-        }\n-\n-      /* Set the offset and strides.\n-         offset is (sum of (dim[i].lbound * dim[i].stride) for all\n-         dims) the -1 means we'll back the data pointer up that much\n-         perhaps we could just realign the data pointer and not change\n-         the offset?  */\n-      f_ptr_out->dim[0].stride = 1;\n-      f_ptr_out->offset = f_ptr_out->dim[0].lbound * f_ptr_out->dim[0].stride;\n-      for (i = 1; i < shapeSize; i++)\n-        {\n-          f_ptr_out->dim[i].stride = (f_ptr_out->dim[i-1].ubound + 1)\n-            - f_ptr_out->dim[i-1].lbound;\n-          f_ptr_out->offset += f_ptr_out->dim[i].lbound\n-            * f_ptr_out->dim[i].stride;\n+\t  if (size == 16)\n+\t    f_ptr_out->dim[i].ubound = *((GFC_INTEGER_16 *) p);\n+#endif\n+\t  p += source_stride;\n+\n+\t  if (i == 0)\n+\t    {\n+\t      f_ptr_out->dim[0].stride = 1;\n+\t      f_ptr_out->offset = f_ptr_out->dim[0].lbound\n+\t\t* f_ptr_out->dim[0].stride;\n+\t    }\n+\t  else\n+\t    {\n+\t      f_ptr_out->dim[i].stride = (f_ptr_out->dim[i-1].ubound + 1)\n+\t\t- f_ptr_out->dim[i-1].lbound;\n+\t      f_ptr_out->offset += f_ptr_out->dim[i].lbound\n+\t\t* f_ptr_out->dim[i].stride;\n+\t    }\n         }\n \n       f_ptr_out->offset *= -1;"}]}