{"sha": "68f14fb08aa9b46935fdc9aa3ae771ac9387f107", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmMTRmYjA4YWE5YjQ2OTM1ZmRjOWFhM2FlNzcxYWM5Mzg3ZjEwNw==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2004-01-06T18:02:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-01-06T18:02:23Z"}, "message": "JLayeredPane.java: Fix semantics, add javadocs.\n\n2004-01-06  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/JLayeredPane.java: Fix semantics, add javadocs.\n\nFrom-SVN: r75478", "tree": {"sha": "541aa3ad9458e034ace9d28aa6fc0009f4bd0d28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/541aa3ad9458e034ace9d28aa6fc0009f4bd0d28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f14fb08aa9b46935fdc9aa3ae771ac9387f107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f14fb08aa9b46935fdc9aa3ae771ac9387f107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f14fb08aa9b46935fdc9aa3ae771ac9387f107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f14fb08aa9b46935fdc9aa3ae771ac9387f107/comments", "author": null, "committer": null, "parents": [{"sha": "68dad68725071670b8357c5ffef0b6314c610917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68dad68725071670b8357c5ffef0b6314c610917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68dad68725071670b8357c5ffef0b6314c610917"}], "stats": {"total": 815, "additions": 512, "deletions": 303}, "files": [{"sha": "747c4b40667d2fce2ba4a4c612ede51f9e52624d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f14fb08aa9b46935fdc9aa3ae771ac9387f107/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f14fb08aa9b46935fdc9aa3ae771ac9387f107/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=68f14fb08aa9b46935fdc9aa3ae771ac9387f107", "patch": "@@ -1,3 +1,7 @@\n+2004-01-06  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/JLayeredPane.java: Fix semantics, add javadocs.\n+\n 2004-01-06  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/file/Connection.java:"}, {"sha": "3bb5070b6e3ef45fcfa24f50d50ba75ffbf0c54b", "filename": "libjava/javax/swing/JLayeredPane.java", "status": "modified", "additions": 508, "deletions": 303, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f14fb08aa9b46935fdc9aa3ae771ac9387f107/libjava%2Fjavax%2Fswing%2FJLayeredPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f14fb08aa9b46935fdc9aa3ae771ac9387f107/libjava%2Fjavax%2Fswing%2FJLayeredPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJLayeredPane.java?ref=68f14fb08aa9b46935fdc9aa3ae771ac9387f107", "patch": "@@ -1,39 +1,40 @@\n /* JLayeredPane.java -- \n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n+   This file is part of GNU Classpath.\n+\n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+\n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+\n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. \n+*/\n \n \n package javax.swing;\n@@ -45,347 +46,551 @@\n \n \n /**\n- * The \"Layered Pane\" is a container which divides its children into 6 (or\n- * more) disjoint sets. the pre-defined sets are:\n+ * <p>The \"Layered Pane\" is a container which divides its children into 6 (or\n+ * more) disjoint sets. the pre-defined sets are:</p>\n  *\n- *  \"Frame Content\", \"Default\", \"Palette\", \"Modal\", \"Popup\", and \"Drag\".\n+ *  <ul>\n+ *    <li>\"Frame Content\"</li>\n+ *    <li>\"Default\"</li>\n+ *    <li>\"Palette\"</li>\n+ *    <li>\"Modal\"</li>\n+ *    <li>\"Popup\"</li>\n+ *    <li>\"Drag\"</li>\n+ *  </ul>\n  *\n- * A child is in exactly one of these layers at any time, though there may\n- * be other layers if someone creates them.\n+ * <p>A child is in exactly one of these layers at any time, though there may\n+ * be other layers if someone creates them.</p>\n  *\n- * The purpose of this class is to translate this view of \"layers\" into a\n+ * <p>The purpose of this class is to translate this view of \"layers\" into a\n  * contiguous array of components: the one held in our ancestor,\n- * java.awt.Container.\n+ * {@link java.awt.Container}.</p>\n  *\n- * There is a precise set of words we will use to refer to numbers within\n- * this class:\n+ * <p>There is a precise set of words we will use to refer to numbers within\n+ * this class:</p>\n  * \n- * Internal Component Index: an offset into the \"component\" array held in\n- * our ancestor, java.awt.Container, from [0 .. component.length). The\n- * drawing rule with internal indices is that 0 is drawn first.\n+ * <dl>\n+ * <dt>Internal Component Index:</dt> \n+ * <dd>An offset into the <code>component</code> array held in our ancestor,\n+ * {@link java.awt.Container}, from <code>[0 .. component.length)</code>. The drawing\n+ * rule with internal indices is that 0 is drawn first.</dd>\n  *\n- * External Component Index: an offset into the \"logical drawing order\" of\n- * this container. If I is the internal index of a component, the external\n- * index E = component.length - I. The rule with external indices is that 0\n- * is drawn last.\n+ * <dt>External Component Index:</dt>\n+ * <dd>An offset into the \"logical drawing order\" of this container. If <code>I</code>\n+ * is the internal index of a component, the external index <tt>E =\n+ * component.length - I</tt>. The rule with external indices is that 0 is\n+ * drawn last.</dd>\n  *\n- * Layer Number: a general int specifying a layer within this component.\n- * Negative numbers are drawn first, then layer 0, then positive numbered\n- * layers, in ascending order.\n+ * <dt>Layer Number:</dt>\n+ * <dd>A general <code>int</code> specifying a layer within this component.  Negative\n+ * numbers are drawn first, then layer 0, then positive numbered layers, in\n+ * ascending order.</dd>\n  *\n- * Position: an offset into a layer's \"logical drawing order\". Layer\n- * position 0 is drawn last. Layer position -1 is a synonym for the first\n- * layer position (the logical \"bottom\").\n+ * <dt>Position:</dt> \n+ * <dd>An offset into a layer's \"logical drawing order\". Layer position 0\n+ * is drawn last. Layer position -1 is a synonym for the first layer\n+ * position (the logical \"bottom\").</dd>\n+ *\n+ * @author Graydon Hoare <graydon@redhat.com>\n  */\n \n public class JLayeredPane extends JComponent implements Accessible\n {\n \n-    public static String LAYER_PROPERTY = \"LAYER_PROPERTY\";\n+  public static String LAYER_PROPERTY = \"LAYER_PROPERTY\";\n+\n+  public static Integer FRAME_CONTENT_LAYER = new Integer (-30000);\n+\n+  public static Integer DEFAULT_LAYER = new Integer (0);\n+  public static Integer PALETTE_LAYER = new Integer (100);\n+  public static Integer MODAL_LAYER   = new Integer (200);\n+  public static Integer POPUP_LAYER   = new Integer (300);\n+  public static Integer DRAG_LAYER    = new Integer (400);\n+\n+  TreeMap layers;               // Layer Number (Integer) -> Layer Size (Integer)\n+  Hashtable componentToLayer;   // Component -> Layer Number (Integer)\n \n-    public static Integer FRAME_CONTENT_LAYER = new Integer (-30000);\n+  JLayeredPane()\n+  {\n+    layers = new TreeMap ();\n+    componentToLayer = new Hashtable ();\n+  }\n \n-    public static Integer DEFAULT_LAYER = new Integer (0);\n-    public static Integer PALETTE_LAYER = new Integer (100);\n-    public static Integer MODAL_LAYER   = new Integer (200);\n-    public static Integer POPUP_LAYER   = new Integer (300);\n-    public static Integer DRAG_LAYER    = new Integer (400);\n \n-    TreeMap layers;               // Layer Number (Integer) -> Layer Size (Integer)\n-    Hashtable componentToLayer;   // Component -> Layer Number (Integer)\n+  /** \n+   * Looks up the layer a child component is currently assigned to.\n+   *\n+   * @param c the component to look up.\n+   * @return the layer the component is currently assigned to, in this container.\n+   * @throws IllegalArgumentException if the component is not a child of this container.\n+   */\n \n-    protected Integer getLayer (Component c)\n-    {\n-\tif (! componentToLayer.containsKey (c))\n+  protected Integer getLayer (Component c)\n+  {\n+    if (! componentToLayer.containsKey (c))\n \t    throw new IllegalArgumentException ();\n-\treturn (Integer) componentToLayer.get (c);\n-    }\n-\n-    // this returns a half-open range [bottom, top), which is the range of\n-    // internal component indices this layer number corresponds to.  note\n-    // that top is *not* included in the range of component indices in this\n-    // layer: a layer with 0 elements in it has ret[0] == ret[1].\n-\n-    protected int[] layerToRange (Integer layer)\n-    {\n-\tint[] ret = new int[2];\t\n-\tIterator i = layers.entrySet ().iterator ();\n-\twhile (i.hasNext())\n+    return (Integer) componentToLayer.get (c);\n+  }\n+\n+  /**\n+   * Returns a pair of ints representing a half-open interval\n+   * <code>[bottom, top)</code>, which is the range of internal component\n+   * indices the provided layer number corresponds to.\n+   *\n+   * Note that \"top\" is <em>not</em> included in the interval of \n+   * component indices in this layer: a layer with 0 elements in it has \n+   * <code>ret[0] == ret[1]</code>.\n+   *\n+   * @param layer the layer to look up.\n+   * @return the half-open range of internal indices this layer spans.\n+   * @throws IllegalArgumentException if layer does not refer to an active layer\n+   * in this container.\n+   */\n+\n+  protected int[] layerToRange (Integer layer)\n+  {\n+    int[] ret = new int[2];\t\n+    Iterator i = layers.entrySet ().iterator ();\n+    while (i.hasNext())\n \t    {\n-\t\tMap.Entry pair = (Map.Entry) i.next();\n-\t\tInteger layerNum = (Integer) pair.getKey ();\n-\t\tInteger layerSz = (Integer) pair.getValue ();\n-\t\tif (layerNum == layer)\n-\t\t    {\n-\t\t\tret[1] = ret[0] + layerSz.intValue ();\n-\t\t\treturn ret;\n-\t\t    }\n-\t\telse\n-\t\t    {\n-\t\t\tret[0] += layerSz.intValue ();\n-\t\t    }\n+        Map.Entry pair = (Map.Entry) i.next();\n+        Integer layerNum = (Integer) pair.getKey ();\n+        Integer layerSz = (Integer) pair.getValue ();\n+        if (layerNum == layer)\n+          {\n+            ret[1] = ret[0] + layerSz.intValue ();\n+            return ret;\n+          }\n+        else\n+          {\n+            ret[0] += layerSz.intValue ();\n+          }\n \t    }\n-\t// should have found the layer during iteration\n-\tthrow new IllegalArgumentException ();\n-    }\n-\n-    protected void incrLayer(Integer layer)\n-    {\n-\tint sz = 1;\n-\tif (layers.containsKey (layer))\n+    // should have found the layer during iteration\n+    throw new IllegalArgumentException ();\n+  }\n+\n+  /**\n+   * Increments the recorded size of a given layer.\n+   *\n+   * @param layer the layer number to increment.\n+   * @see #incrLayer()\n+   */\n+\n+  protected void incrLayer(Integer layer)\n+  {\n+    int sz = 1;\n+    if (layers.containsKey (layer))\n \t    sz += ((Integer)(layers.get (layer))).intValue ();\n-\tlayers.put (layer, new Integer(sz));\n-    }\n-\n-    protected void decrLayer(Integer layer)\n-    {\n-\tint sz = 0;\n-\tif (layers.containsKey (layer))\n+    layers.put (layer, new Integer(sz));\n+  }\n+\n+  /**\n+   * Decrements the recorded size of a given layer.\n+   *\n+   * @param layer the layer number to decrement.\n+   * @see #decrLayer()\n+   */\n+\n+  protected void decrLayer(Integer layer)\n+  {\n+    int sz = 0;\n+    if (layers.containsKey (layer))\n \t    sz = ((Integer)(layers.get (layer))).intValue () - 1;\n-\tlayers.put (layer, new Integer(sz));\n-    }\n-\n-    JLayeredPane()\n-    {\n-\tlayers = new TreeMap ();\n-\tlayers.put (FRAME_CONTENT_LAYER, new Integer (0));\n-\tlayers.put (DEFAULT_LAYER, new Integer (0));\n-\tlayers.put (PALETTE_LAYER, new Integer (0));\n-\tlayers.put (MODAL_LAYER, new Integer (0));\n-\tlayers.put (POPUP_LAYER, new Integer (0));\n-\tlayers.put (DRAG_LAYER, new Integer (0));\t\n-\n-\tcomponentToLayer = new Hashtable ();\n-    }\n-\n-    public int highestLayer()\n-    {\n-\tif (layers.size() == 0)\n+    layers.put (layer, new Integer(sz));\n+  }\n+\n+  /**\n+   * Return the greatest layer number currently in use, in this container.\n+   * This number may legally be positive <em>or</em> negative.\n+   *\n+   * @return the least layer number.\n+   * @see #lowestLayer()\n+   */\n+\n+  public int highestLayer()\n+  {\n+    if (layers.size() == 0)\n \t    return 0;\n-\treturn ((Integer)(layers.lastKey ())).intValue ();\n-    }\n+    return ((Integer)(layers.lastKey ())).intValue ();\n+  }\n+\n+  /**\n+   * Return the least layer number currently in use, in this container.\n+   * This number may legally be positive <em>or</em> negative.\n+   *\n+   * @return the least layer number.\n+   * @see #highestLayer()\n+   */\n     \n-    public int lowestLayer()\n-    {\n-\tif (layers.size() == 0)\n+  public int lowestLayer()\n+  {\n+    if (layers.size() == 0)\n \t    return 0;\n-\treturn ((Integer)(layers.firstKey ())).intValue ();\n-    }\n-\n-    public void moveToFront(Component c)\n-    {\n-\tsetPosition (c, 0);\n-    }\n-\n-    public void moveToBack(Component c)\n-    {\n-\tsetPosition (c, -1);\n-    }\n+    return ((Integer)(layers.firstKey ())).intValue ();\n+  }\n+\n+  /**\n+   * Moves a component to the \"front\" of its layer. The \"front\" is a\n+   * synonym for position 0, which is also the last position drawn in each\n+   * layer, so is usually the component which occludes the most other\n+   * components in its layer.\n+   *\n+   * @param c the component to move to the front of its layer.\n+   * @throws IllegalArgumentException if the component is not a child of\n+   * this container.\n+   * @see #moveToBack()\n+   */\n+\n+  public void moveToFront(Component c)\n+  {\n+    setPosition (c, 0);\n+  }\n+\n+  /**\n+   * <p>Moves a component to the \"back\" of its layer. The \"back\" is a\n+   * synonym for position N-1 (also known as position -1), where N is the\n+   * size of the layer.</p>\n+   *\n+   * <p>The \"back\" of a layer is the first position drawn, so the component at\n+   * the \"back\" is usually the component which is occluded by the most\n+   * other components in its layer.</p>\n+   *\n+   * @param c the component to move to the back of its layer.\n+   * @throws IllegalArgumentException if the component is not a child of\n+   * this container.\n+   * @see #moveToFront()\n+   */\n+\n+  public void moveToBack(Component c)\n+  {\n+    setPosition (c, -1);\n+  }\n+\n+  /**\n+   * Return the position of a component within its layer. Positions are assigned\n+   * from the \"front\" (position 0) to the \"back\" (position N-1), and drawn from \n+   * the back towards the front.\n+   *\n+   * @param c the component to get the position of.\n+   * @throws IllegalArgumentException if the component is not a child of\n+   * this container.\n+   * @see #setPosition()\n+   */\n     \n-    public int getPosition(Component c)\n-    {\n-\tInteger layer = getLayer (c);\n-\tint[] range = layerToRange (layer);\n-\tint top = (range[1] - 1);\n-\tComponent[] comps = getComponents ();\n-\tfor (int i = range[0]; i < range[1]; ++i)\n+  public int getPosition(Component c)\n+  {\n+    Integer layer = getLayer (c);\n+    int[] range = layerToRange (layer);\n+    int top = (range[1] - 1);\n+    Component[] comps = getComponents ();\n+    for (int i = range[0]; i < range[1]; ++i)\n \t    {\n-\t\tif (comps[i] == c)\n-\t\t    return top - i;\n+        if (comps[i] == c)\n+          return top - i;\n \t    }\n-\t// should have found it\n-\tthrow new IllegalArgumentException ();\n-    }\n-\n-    public void setPosition(Component c, int position)\n-    {\n-\tInteger layer = getLayer (c);\n-\tint[] range = layerToRange (layer);\n-\tif (range[0] == range[1])\n+    // should have found it\n+    throw new IllegalArgumentException ();\n+  }\n+\n+  /**\n+   * Change the position of a component within its layer. Positions are assigned\n+   * from the \"front\" (position 0) to the \"back\" (position N-1), and drawn from \n+   * the back towards the front.\n+   *\n+   * @param c the component to change the position of.\n+   * @param position the position to assign the component to.\n+   * @throws IllegalArgumentException if the component is not a child of\n+   * this container.\n+   * @see #getPosition()\n+   */\n+\n+  public void setPosition(Component c, int position)\n+  {\n+    Integer layer = getLayer (c);\n+    int[] range = layerToRange (layer);\n+    if (range[0] == range[1])\n \t    throw new IllegalArgumentException ();\n \n-\tint top = (range[1] - 1);\n-\tif (position == -1)\n+    int top = (range[1] - 1);\n+    if (position == -1)\n \t    position = top - range[0];\n-\tint targ = top - position;\n-\tint curr = -1;\n+    int targ = top - position;\n+    int curr = -1;\n \n-\tComponent[] comps = getComponents();\n-\tfor (int i = range[0]; i < range[1]; ++i)\n+    Component[] comps = getComponents();\n+    for (int i = range[0]; i < range[1]; ++i)\n \t    {\n-\t\tif (comps[i] == c)\n-\t\t    {\n-\t\t\tcurr = i;\n-\t\t\tbreak;\n-\t\t    }\n+        if (comps[i] == c)\n+          {\n+            curr = i;\n+            break;\n+          }\n \t    }\n-\tif (curr == -1)\n+    if (curr == -1)\n \t    // should have found it\n \t    throw new IllegalArgumentException ();\n \n-\t// System.err.println(\"set component position to \" + position + \" in layer \" + layer);\n-\n-\tComponent tmp = comps[curr];\n-\tsuper.remove (curr);\n-\tsuper.add (tmp, targ);\n-\tsuper.validate ();\n-    }\n+    super.swapComponents (curr, targ);\n+    validate();\n+    repaint();\n+  }\n     \n-\n-\n-    public Component[] getComponentsInLayer(int layer)\n-    {\n-\tint[] range = layerToRange (getObjectForLayer (layer));\n-\tif (range[0] == range[1])\n+  /**\n+   * Return an array of all components within a layer of this\n+   * container. Components are ordered back-to-front, with the \"back\"\n+   * element (which draws first) at position 0 of the returned array.\n+   *\n+   * @param layer the layer to return components from.\n+   * @return the components in the layer.\n+   */\n+\n+  public Component[] getComponentsInLayer(int layer)\n+  {\n+    int[] range = layerToRange (getObjectForLayer (layer));\n+    if (range[0] == range[1])\n \t    return new Component[0];\n-\telse\n+    else\n \t    {\n-\t\tComponent[] comps = getComponents ();\n-\t\tint sz = (range[1] - 1) - range[0];\n-\t\tComponent[] nc = new Component[sz];\n-\t\tfor (int i = 0; i < sz; ++i)\n-\t\t    nc[i] = comps[range[0] + i];\n-\t\treturn nc;\n+        Component[] comps = getComponents ();\n+        int sz = (range[1] - 1) - range[0];\n+        Component[] nc = new Component[sz];\n+        for (int i = 0; i < sz; ++i)\n+          nc[i] = comps[range[0] + i];\n+        return nc;\n \t    }\n-    }\n-\n-    public int getComponentCountInLayer(int layer)\n-    {\n-\tint[] range = layerToRange (getObjectForLayer (layer));\n-\tif (range[0] == range[1])\n+  }\n+\n+  /**\n+   * Return the number of components within a layer of this\n+   * container. \n+   *\n+   * @param layer the layer count components in.\n+   * @return the number of components in the layer.\n+   */\n+\n+  public int getComponentCountInLayer(int layer)\n+  {\n+    int[] range = layerToRange (getObjectForLayer (layer));\n+    if (range[0] == range[1])\n \t    return 0;\n-\telse\n-\t    return ((range[1] - 1) - range[0]);\n-    }\n-\n-    protected Hashtable getComponentToLayer()\n-    {\n-\treturn componentToLayer;\n-    }\n-\n-    protected int getInternalIndexOf(Component c) \n-    {\n-\tInteger layer = getLayer (c);\n-\tint[] range = layerToRange (layer);\n-\tComponent[] comps = getComponents();\n-\tfor (int i = range[0]; i < range[1]; ++i)\n+    else\n+\t    return (range[1] - range[0]);\n+  }\n+\n+  /**\n+   * Return a hashtable mapping child components of this container to\n+   * Integer objects representing the component's layer assignments.\n+   */\n+\n+  protected Hashtable getComponentToLayer()\n+  {\n+    return componentToLayer;\n+  }\n+\n+\n+  /**\n+   * Return the index of a component within the underlying (contiguous)\n+   * array of children. This is a \"raw\" number which does not represent the\n+   * child's position in a layer, but rather its position in the\n+   * concatenation of <em>all</em> layers within the container.\n+   *\n+   * @param c the component to look up.\n+   * @return the internal index of the component.\n+   * @throws IllegalArgumentException if the component is not a child of\n+   * this container.\n+   */\n+\n+  protected int getInternalIndexOf(Component c) \n+  {\n+    Integer layer = getLayer (c);\n+    int[] range = layerToRange (layer);\n+    Component[] comps = getComponents();\n+    for (int i = range[0]; i < range[1]; ++i)\n \t    {\n-\t\tif (comps[i] == c)\n-\t\t    return i;\n+        if (comps[i] == c)\n+          return i;\n \t    }\n-\t// should have found the component during iteration\n-\tthrow new IllegalArgumentException ();\n-    }\n-\n-\n-    public int getIndexOf(Component c) \n-    {\n-\t// returns the *external* index of the component.\n-\tint top = getComponentCount() - 1;\n-\treturn top - getIndexOf (c);\n-    }    \n-\n-\n-    protected Integer getObjectForLayer(int layer)\n-    {\n-\tswitch (layer)\n+    // should have found the component during iteration\n+    throw new IllegalArgumentException ();\n+  }\n+\n+\n+  /**\n+   * Return the external index of a component within the underlying\n+   * (contiguous) array of children. This is a \"raw\" number which does not\n+   * represent the child's position in a layer, but rather its position in\n+   * the logical drawing order of all children of the container.\n+   *\n+   * @param c the component to look up.\n+   * @return the external index of the component.\n+   * @throws IllegalArgumentException if the component is not a child of\n+   * this container.\n+   */\n+\n+  public int getIndexOf(Component c) \n+  {\n+    // returns the *external* index of the component.\n+    int top = getComponentCount() - 1;\n+    return top - getIndexOf (c);\n+  }    \n+\n+  /**\n+   * Return an Integer object which holds the same int value as the\n+   * parameter. This is strictly an optimization to minimize the number of\n+   * identical Integer objects which we allocate.\n+   *\n+   * @param layer the layer number as an int.\n+   * @return the layer number as an Integer, possibly shared.\n+   */\n+\n+  protected Integer getObjectForLayer(int layer)\n+  {\n+    switch (layer)\n \t    {\n \t    case -30000:\n-\t\treturn FRAME_CONTENT_LAYER;\n+        return FRAME_CONTENT_LAYER;\n \n \t    case 0:\n-\t\treturn DEFAULT_LAYER;\n+        return DEFAULT_LAYER;\n \n \t    case 100:\n-\t\treturn PALETTE_LAYER;\n+        return PALETTE_LAYER;\n \n \t    case 200:\n-\t\treturn MODAL_LAYER;\n+        return MODAL_LAYER;\n \n \t    case 300:\n-\t\treturn POPUP_LAYER;\n+        return POPUP_LAYER;\n \n \t    case 400:\n-\t\treturn DRAG_LAYER;\n+        return DRAG_LAYER;\n \n \t    default:\n-\t\tbreak;\n+        break;\n \t    }\n \n-\treturn new Integer(layer);\n-    }\n+    return new Integer(layer);\n+  }\n+\n+  /**\n+   * Computes an internal index at which to request the superclass {@link\n+   * java.awt.Container} inserts a component, given an abstract layer and\n+   * position number.\n+   *\n+   * @param layer the layer in which to insert a component.\n+   * @param position the position in the layer at which to insert a component.\n+   * @return the internal index at which to insert the component.\n+   */\n     \n-    protected int insertIndexForLayer(int layer, int position)\n-    {\n-\tint[] range = layerToRange (getObjectForLayer (layer));\n-\tif (range[0] == range[1])\n+  protected int insertIndexForLayer(int layer, int position)\n+  {\n+\n+    Integer lobj = getObjectForLayer (layer);\n+    if (! layers.containsKey(lobj))\n+      layers.put (lobj, new Integer (0));\n+    int[] range = layerToRange (lobj);\n+    if (range[0] == range[1])\n \t    return range[0];\n \t\n-\tint bottom = range[0];\n-\tint top = range[1] - 1;\n+    int bottom = range[0];\n+    int top = range[1] - 1;\n \t\n-\tif (position == -1 || position > (top - bottom))\n+    if (position == -1 || position > (top - bottom))\n \t    return bottom;\n-\telse\n+    else\n \t    return top - position;\n-    }\n+  }\n+\n+  /**\n+   * Removes a child from this container. The child is specified by\n+   * internal index. After removal, the child no longer occupies a layer.\n+   *\n+   * @param index the internal index of the child component to remove.\n+   */\n     \n-    public void remove (int index)\n-    {\n-\tComponent c = getComponent (index);\n-\tInteger layer = getLayer (c);\n-\tdecrLayer (layer);\n-\tcomponentToLayer.remove (c);\n-\tsuper.remove (index);\n-    }\n+  public void remove (int index)\n+  {\n+    Component c = getComponent (index);\n+    Integer layer = getLayer (c);\n+    decrLayer (layer);\n+    componentToLayer.remove (c);\n+    super.remove (index);\n+  }\n+\n+  /**\n+   * Removes a child from this container. The child is specified directly.\n+   * After removal, the child no longer occupies a layer.\n+   *\n+   * @param comp the child to remove.\n+   */\n \t\n-    public void remove (Component comp)\n-    {\n-\tInteger layer = getLayer (comp);\n-\tdecrLayer (layer);\n-\tcomponentToLayer.remove (comp);\n-\tsuper.remove (comp);\n-    }\n-\n-    public void removeAll ()\n-    {\n-\tcomponentToLayer.clear ();\n-\tlayers.clear ();\n-\tsuper.removeAll ();\n-    }\n-\n-    public void setLayer(Component c, int layer)\n-    {\n-\tcomponentToLayer.put (c, getObjectForLayer (layer));\n-    }\n-\n-    public void setLayer(Component c,\n-\t\t\t int layer,\n-\t\t\t int position)\n-    {\n-\tcomponentToLayer.put (c, getObjectForLayer (layer));\n-\tsetPosition(c, position);\n-        repaint();\n-    }\n-\n-    protected void addImpl(Component comp, Object layerConstraint, int index) \n-    {        \t\n-\tInteger layer;\n-\tif (layerConstraint != null && layerConstraint instanceof Integer)\n-\t\tlayer = (Integer) layerConstraint;\n-\telse if (componentToLayer.containsKey (comp))\n+  public void remove (Component comp)\n+  {\n+    remove (getInternalIndexOf (comp));\n+  }\n+\n+  /**\n+   * <p>Set the layer property for a component, within this container. The\n+   * component will be implicitly mapped to the bottom-most position in the\n+   * layer, but only if added <em>after</em> calling this method.</p>\n+   *\n+   * <p>Read that carefully: this method should be called <em>before</em> the\n+   * component is added to the container.</p>\n+   *\n+   * @param c the component to set the layer property for.\n+   * @param layer the layer number to assign to the component.\n+   */\n+\n+  public void setLayer(Component c, int layer)\n+  {\n+    componentToLayer.put (c, getObjectForLayer (layer));\n+  }\n+\n+  /**\n+   * Set the layer and position of a component, within this container. \n+   *\n+   * @param c the child component to set the layer property for.\n+   * @param layer the layer number to assign to the component.\n+   * @param position the position number to assign to the component.\n+   */\n+\n+  public void setLayer(Component c,\n+                       int layer,\n+                       int position)\n+  {\n+    componentToLayer.put (c, getObjectForLayer (layer));\n+    setPosition(c, position);\n+    validate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Overrides the default implementation from {@link java.awt.Container}\n+   * such that <code>layerConstraint</code> is interpreted as an {@link\n+   * Integer}, specifying the layer to which the component will be added\n+   * (at the bottom position).\n+   *\n+   * @param comp the component to add.\n+   * @param layerConstraint an integer specifying the layer to add the component to.\n+   * @param index an ignored parameter, for compatibility.\n+   */\n+\n+  protected void addImpl(Component comp, Object layerConstraint, int index) \n+  {        \t\n+    Integer layer;\n+    if (layerConstraint != null && layerConstraint instanceof Integer)\n+      layer = (Integer) layerConstraint;\n+    else if (componentToLayer.containsKey (comp))\n \t    layer = (Integer) componentToLayer.remove (comp);\n-\telse\n+    else\n \t    layer = DEFAULT_LAYER;\n \n-\tint newIdx = insertIndexForLayer(layer.intValue (), -1);\n-\tcomponentToLayer.put (comp, layer);\n-\tincrLayer (layer);\n-\n-\t// System.err.println(\"adding component to layer \" + layer);\n+    int newIdx = insertIndexForLayer(layer.intValue (), -1);\n+    componentToLayer.put (comp, layer);\n+    incrLayer (layer);\n \t\n-        super.addImpl(comp, null, newIdx);\t\n-        validate();\n-        repaint();\n-    }     \n+    super.addImpl(comp, null, newIdx);\t\n+    validate();\n+    repaint();\n+  }     \n }"}]}