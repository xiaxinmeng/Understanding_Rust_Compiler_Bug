{"sha": "80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "node_id": "C_kwDOANBUbNoAKDgwZjc4NzE2YzJjN2NlMWI3Zjk2MDc3YzM1YzFkZDQ3NGEyMDg2YTI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-08-16T17:18:37Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-08-17T01:09:00Z"}, "message": "Abstract interesting ssa-names from GORI.\n\nProvide a routine to pick out the ssa-names from interesting statements.\n\n\t* gimple-range-fold.cc (gimple_range_ssa_names): New.\n\t* gimple-range-fold.h (gimple_range_ssa_names): New prototype.\n\t* gimple-range-gori.cc (range_def_chain::get_def_chain): Move\n\t  code to new routine.", "tree": {"sha": "f6af5d1fef6ba4f80be68a4b331806d7cebd5168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6af5d1fef6ba4f80be68a4b331806d7cebd5168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/comments", "author": null, "committer": null, "parents": [{"sha": "47a61e65148c6f1c237638144eb72ed5afd86387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a61e65148c6f1c237638144eb72ed5afd86387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a61e65148c6f1c237638144eb72ed5afd86387"}], "stats": {"total": 77, "additions": 49, "deletions": 28}, "files": [{"sha": "b0b221063206708a85cf3edfdff67c7ab7496977", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "patch": "@@ -1580,3 +1580,36 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \t}\n     }\n }\n+\n+// Given stmt S, fill VEC, up to VEC_SIZE elements, with relevant ssa-names\n+// on the statement.  For efficiency, it is an error to not pass in enough\n+// elements for the vector.  Return the number of ssa-names.\n+\n+unsigned\n+gimple_range_ssa_names (tree *vec, unsigned vec_size, gimple *stmt)\n+{\n+  tree ssa;\n+  int count = 0;\n+\n+  if (range_op_handler (stmt))\n+    {\n+      gcc_checking_assert (vec_size >= 2);\n+      if ((ssa = gimple_range_ssa_p (gimple_range_operand1 (stmt))))\n+\tvec[count++] = ssa;\n+      if ((ssa = gimple_range_ssa_p (gimple_range_operand2 (stmt))))\n+\tvec[count++] = ssa;\n+    }\n+  else if (is_a<gassign *> (stmt)\n+\t   && gimple_assign_rhs_code (stmt) == COND_EXPR)\n+    {\n+      gcc_checking_assert (vec_size >= 3);\n+      gassign *st = as_a<gassign *> (stmt);\n+      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs1 (st))))\n+\tvec[count++] = ssa;\n+      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs2 (st))))\n+\tvec[count++] = ssa;\n+      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs3 (st))))\n+\tvec[count++] = ssa;\n+    }\n+  return count;\n+}"}, {"sha": "f2eab72021375c053857ee4195ee88000e016103", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "patch": "@@ -96,6 +96,14 @@ range_compatible_p (tree type1, tree type2)\n \t  && TYPE_SIGN (type1) == TYPE_SIGN (type2));\n }\n \n+extern tree gimple_range_operand1 (const gimple *s);\n+extern tree gimple_range_operand2 (const gimple *s);\n+\n+// Given stmt S, fill VEC, up to VEC_SIZE elements, with relevant ssa-names\n+// on the statement.  For efficiency, it is an error to not pass in enough\n+// elements for the vector.  Return the number of ssa-names.\n+\n+unsigned gimple_range_ssa_names (tree *vec, unsigned vec_size, gimple *stmt);\n \n // Source of all operands for fold_using_range and gori_compute.\n // It abstracts out the source of an operand so it can come from a stmt or\n@@ -150,9 +158,6 @@ class fur_depend : public fur_stmt\n   relation_oracle *m_oracle;\n };\n \n-extern tree gimple_range_operand1 (const gimple *s);\n-extern tree gimple_range_operand2 (const gimple *s);\n-\n // This class uses ranges to fold a gimple statement producinf a range for\n // the LHS.  The source of all operands is supplied via the fur_source class\n // which provides a range_query as well as a source location and any other"}, {"sha": "957b8d543fa4bfa0260cc63d31f0aea2efa01d44", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f78716c2c7ce1b7f96077c35c1dd474a2086a2/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=80f78716c2c7ce1b7f96077c35c1dd474a2086a2", "patch": "@@ -331,7 +331,7 @@ range_def_chain::has_def_chain (tree name)\n bitmap\n range_def_chain::get_def_chain (tree name)\n {\n-  tree ssa1, ssa2, ssa3;\n+  tree ssa[3];\n   unsigned v = SSA_NAME_VERSION (name);\n \n   // If it has already been processed, just return the cached value.\n@@ -347,23 +347,10 @@ range_def_chain::get_def_chain (tree name)\n     }\n \n   gimple *stmt = SSA_NAME_DEF_STMT (name);\n-  if (range_op_handler (stmt))\n+  unsigned count = gimple_range_ssa_names (ssa, 3, stmt);\n+  if (count == 0)\n     {\n-      ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n-      ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n-      ssa3 = NULL_TREE;\n-    }\n-  else if (is_a<gassign *> (stmt)\n-\t   && gimple_assign_rhs_code (stmt) == COND_EXPR)\n-    {\n-      gassign *st = as_a<gassign *> (stmt);\n-      ssa1 = gimple_range_ssa_p (gimple_assign_rhs1 (st));\n-      ssa2 = gimple_range_ssa_p (gimple_assign_rhs2 (st));\n-      ssa3 = gimple_range_ssa_p (gimple_assign_rhs3 (st));\n-    }\n-  else\n-    {\n-      // Stmts not understood are always imports.\n+      // Stmts not understood or with no operands are always imports.\n       set_import (m_def_chain[v], name, NULL);\n       return NULL;\n     }\n@@ -373,17 +360,13 @@ range_def_chain::get_def_chain (tree name)\n     return NULL;\n \n   // Increase the depth if we have a pair of ssa-names.\n-  if (ssa1 && ssa2)\n+  if (count > 1)\n     m_logical_depth++;\n \n-  register_dependency (name, ssa1, gimple_bb (stmt));\n-  register_dependency (name, ssa2, gimple_bb (stmt));\n-  register_dependency (name, ssa3, gimple_bb (stmt));\n-  // Stmts with no understandable operands are also imports.\n-  if (!ssa1 && !ssa2 & !ssa3)\n-    set_import (m_def_chain[v], name, NULL);\n+  for (unsigned x = 0; x < count; x++)\n+    register_dependency (name, ssa[x], gimple_bb (stmt));\n \n-  if (ssa1 && ssa2)\n+  if (count > 1)\n     m_logical_depth--;\n \n   return m_def_chain[v].bm;"}]}