{"sha": "0be5d99ff22bb43d45d13c620071ba377d3e02d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJlNWQ5OWZmMjJiYjQzZDQ1ZDEzYzYyMDA3MWJhMzc3ZDNlMDJkNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-08T17:58:36Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-08T17:58:36Z"}, "message": "Rewrite movsf/movdf/movdi patterns\n\nFrom-SVN: r8039", "tree": {"sha": "f7cd3b22b40f6bcf6bd789842d5a67891b60b34e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7cd3b22b40f6bcf6bd789842d5a67891b60b34e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0be5d99ff22bb43d45d13c620071ba377d3e02d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be5d99ff22bb43d45d13c620071ba377d3e02d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be5d99ff22bb43d45d13c620071ba377d3e02d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be5d99ff22bb43d45d13c620071ba377d3e02d6/comments", "author": null, "committer": null, "parents": [{"sha": "19d5775a094c1b1955413a8017dc7164da55425a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d5775a094c1b1955413a8017dc7164da55425a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d5775a094c1b1955413a8017dc7164da55425a"}], "stats": {"total": 562, "additions": 457, "deletions": 105}, "files": [{"sha": "79d35d0aa7379c1c18cc838653a33b9f2954f3ee", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 457, "deletions": 105, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be5d99ff22bb43d45d13c620071ba377d3e02d6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be5d99ff22bb43d45d13c620071ba377d3e02d6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0be5d99ff22bb43d45d13c620071ba377d3e02d6", "patch": "@@ -1058,10 +1058,33 @@\n   return AS2 (mov%B0,%1,%0);\n }\")\n \n-(define_insn \"\"\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Special case memory->memory moves */\n+  if (TARGET_MOVE\n+      && (reload_in_progress | reload_completed) == 0\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx (*genfunc) PROTO((rtx, rtx));\n+      if (push_operand (operands[0], SFmode))\n+\tgenfunc = (TARGET_386) ? gen_movsf_push386 : gen_movsf_push486_mem;\n+      else\n+\tgenfunc = gen_movsf_mem;\n+\n+      emit_insn ((*genfunc) (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"movsf_push386\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n \t(match_operand:SF 1 \"general_operand\" \"gF,f\"))]\n-  \"\"\n+  \"TARGET_386 || !TARGET_MOVE\"\n   \"*\n {\n   if (STACK_REG_P (operands[1]))\n@@ -1086,14 +1109,63 @@\n   return AS1 (push%L1,%1);\n }\")\n \n-;; Allow MEM-MEM moves before reload.  The reload class for such a\n-;; move will be ALL_REGS.  PREFERRED_RELOAD_CLASS will narrow this to\n-;; GENERAL_REGS.  For the purposes of regclass, prefer FLOAT_REGS.\n+(define_insn \"movsf_push486\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:SF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  \"!TARGET_386\"\n+  \"*\n+{\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      if (! STACK_TOP_P (operands[1]))\n+        abort ();\n+\n+      xops[0] = AT_SP (SFmode);\n+      xops[1] = GEN_INT (4);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+\n+      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+        output_asm_insn (AS1 (fstp%S0,%0), xops);\n+      else\n+        output_asm_insn (AS1 (fst%S0,%0), xops);\n+      RET;\n+    }\n+  return AS1 (push%L1,%1);\n+}\")\n+\n+(define_insn \"movsf_push486_mem\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n+\t(match_operand:SF 1 \"memory_operand\" \"m\"))\n+   (clobber (match_scratch:SI 2 \"=r\"))]\n+  \"!TARGET_386\"\n+  \"*\n+{\n+  output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n+  return AS1 (push%L2,%2);\n+}\")\n+\n+;; Special memory<->memory pattern that combine will recreate from the\n+;; moves to pseudos.\n+(define_insn \"movsf_mem\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SF 1 \"memory_operand\" \"m\"))\n+   (clobber (match_scratch:SI 2 \"=r\"))]\n+  \"\"\n+  \"*\n+{\n+  output_asm_insn (AS2 (mov%L2,%1,%2), operands);\n+  return AS2 (mov%L0,%2,%0);\n+}\")\n \n-(define_insn \"movsf\"\n+;; For the purposes of regclass, prefer FLOAT_REGS.\n+(define_insn \"movsf_normal\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=*rfm,*rf,f,!*rm\")\n \t(match_operand:SF 1 \"general_operand\" \"*rf,*rfm,fG,fF\"))]\n-  \"\"\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n@@ -1145,11 +1217,47 @@\n   return singlemove_string (operands);\n }\")\n \n-;;should change to handle the memory operands[1] without doing df push..\n-(define_insn \"\"\n+(define_insn \"swapsf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"f\")\n+\t(match_operand:SF 1 \"register_operand\" \"f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return AS1 (fxch,%1);\n+  else\n+    return AS1 (fxch,%0);\n+}\")\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Special case memory->memory moves */\n+  if (TARGET_MOVE\n+      && (reload_in_progress | reload_completed) == 0\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx (*genfunc) PROTO((rtx, rtx));\n+      if (push_operand (operands[0], DFmode))\n+\tgenfunc = (TARGET_386) ? gen_movdf_push386 : gen_movdf_push486_mem;\n+      else\n+\tgenfunc = gen_movdf_mem;\n+\n+      emit_insn ((*genfunc) (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"movdf_push386\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n \t(match_operand:DF 1 \"general_operand\" \"gF,f\"))]\n-  \"\"\n+  \"TARGET_386 || !TARGET_MOVE\"\n   \"*\n {\n   if (STACK_REG_P (operands[1]))\n@@ -1173,28 +1281,107 @@\n     return output_move_double (operands);\n }\")\n \n-(define_insn \"swapdf\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"f\")\n-\t(match_operand:DF 1 \"register_operand\" \"f\"))\n-   (set (match_dup 1)\n-\t(match_dup 0))]\n-  \"\"\n+(define_insn \"movdf_push486\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:DF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  \"!TARGET_386\"\n   \"*\n {\n-  if (STACK_TOP_P (operands[0]))\n-    return AS1 (fxch,%1);\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      xops[0] = AT_SP (SFmode);\n+      xops[1] = GEN_INT (8);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+\n+      if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+        output_asm_insn (AS1 (fstp%Q0,%0), xops);\n+      else\n+        output_asm_insn (AS1 (fst%Q0,%0), xops);\n+\n+      RET;\n+    }\n   else\n-    return AS1 (fxch,%0);\n+    return output_move_double (operands);\n }\")\n \n-;; Allow MEM-MEM moves before reload.  The reload class for such a\n-;; move will be ALL_REGS.  PREFERRED_RELOAD_CLASS will narrow this to\n-;; GENERAL_REGS.  For the purposes of regclass, prefer FLOAT_REGS.\n+(define_insn \"movdf_push486_mem\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:DF 1 \"general_operand\" \"o,o\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n+  \"!TARGET_386\"\n+  \"*\n+{\n+  rtx low[1], high[1], xop[4];\n \n-(define_insn \"movdf\"\n+  split_di (&operands[1], 1, low, high);\n+  xop[0] = operands[2];\n+  xop[1] = operands[3];\n+  xop[2] = high[0];\n+  xop[3] = low[0];\n+\n+  if (GET_CODE (operands[3]) == REG)\n+    {\t\t\t\t/* 2 scratch registers available */\n+      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%1), xop);\n+    }\n+  else\n+    {\t\t\t\t/* 1 scratch register */\n+      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+    }\n+\n+  RET;\n+}\")\n+\n+(define_insn \"movdf_mem\"\n+  [(set (match_operand:DF 0 \"memory_operand\" \"=o,o\")\n+\t(match_operand:DF 1 \"memory_operand\" \"o,o\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx low[2], high[2], xop[6];\n+\n+  split_di (operands, 2, low, high);\n+  xop[0] = operands[2];\n+  xop[1] = operands[3];\n+  xop[2] = high[0];\n+  xop[3] = high[1];\n+  xop[4] = low[0];\n+  xop[5] = low[1];\n+  if (GET_CODE (operands[3]) == REG)\n+    {\t\t\t\t/* 2 scratch registers available */\n+      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+      output_asm_insn (AS2 (mov%L0,%0,%4), xop);\n+      output_asm_insn (AS2 (mov%L0,%1,%2), xop);\n+    }\n+  else\n+    {\t\t\t\t/* 1 scratch register */\n+      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%0,%4), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%0,%2), xop);\n+    }\n+\n+  RET;\n+}\")\n+\n+;; For the purposes of regclass, prefer FLOAT_REGS.\n+(define_insn \"movdf_normal\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=*rfm,*rf,f,!*rm\")\n \t(match_operand:DF 1 \"general_operand\" \"*rf,*rfm,fG,fF\"))]\n-  \"\"\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n@@ -1246,10 +1433,47 @@\n   return output_move_double (operands);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"swapdf\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"f\")\n+\t(match_operand:DF 1 \"register_operand\" \"f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return AS1 (fxch,%1);\n+  else\n+    return AS1 (fxch,%0);\n+}\")\n+\n+(define_expand \"movxf\"\n+  [(set (match_operand:XF 0 \"general_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Special case memory->memory moves */\n+  if (TARGET_MOVE\n+      && (reload_in_progress | reload_completed) == 0\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx (*genfunc) PROTO((rtx, rtx));\n+      if (push_operand (operands[0], XFmode))\n+\tgenfunc = (TARGET_386) ? gen_movxf_push386 : gen_movxf_push486_mem;\n+      else\n+\tgenfunc = gen_movxf_mem;\n+\n+      emit_insn ((*genfunc) (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"movxf_push386\"\n   [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n  \t(match_operand:XF 1 \"general_operand\" \"gF,f\"))]\n-  \"\"\n+  \"TARGET_386 || !TARGET_MOVE\"\n   \"*\n {\n   if (STACK_REG_P (operands[1]))\n@@ -1271,26 +1495,114 @@\n     return output_move_double (operands);\n  }\")\n \n-(define_insn \"swapxf\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"f\")\n-\t(match_operand:XF 1 \"register_operand\" \"f\"))\n-   (set (match_dup 1)\n-\t(match_dup 0))]\n-  \"\"\n+(define_insn \"movxf_push486\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n+ \t(match_operand:XF 1 \"nonmemory_operand\" \"rF,f\"))]\n+  \"!TARGET_386\"\n   \"*\n {\n-  if (STACK_TOP_P (operands[0]))\n-    return AS1 (fxch,%1);\n+  if (STACK_REG_P (operands[1]))\n+    {\n+      rtx xops[3];\n+\n+      xops[0] = AT_SP (SFmode);\n+      xops[1] = GEN_INT (12);\n+      xops[2] = stack_pointer_rtx;\n+\n+      output_asm_insn (AS2 (sub%L2,%1,%2), xops);\n+      output_asm_insn (AS1 (fstp%T0,%0), xops);\n+      if (! find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n+\toutput_asm_insn (AS1 (fld%T0,%0), xops);\n+\n+      RET;\n+    }\n   else\n-    return AS1 (fxch,%0);\n+    return output_move_double (operands);\n+ }\")\n+\n+(define_insn \"movxf_push486_mem\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:XF 1 \"memory_operand\" \"o,o\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n+  \"!TARGET_386\"\n+  \"*\n+{\n+  rtx xop[5];\n+\n+  xop[0] = operands[2];\n+  xop[1] = operands[3];\n+  xop[2] = adj_offsettable_operand (operands[1], 8);\n+  xop[3] = adj_offsettable_operand (operands[1], 4);\n+  xop[4] = operands[1];\n+\n+  if (GET_CODE (operands[3]) == REG)\n+    {\t\t\t\t/* 2 scratch registers available */\n+      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%1), xop);\n+      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+    }\n+  else\n+    {\t\t\t\t/* 1 scratch register */\n+      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n+      output_asm_insn (AS1 (push%L0,%0), xop);\n+    }\n+\n+  RET;\n }\")\n \n-(define_insn \"movxf\"\n+(define_insn \"movxf_mem\"\n+  [(set (match_operand:XF 0 \"memory_operand\" \"=o,o\")\n+\t(match_operand:XF 1 \"memory_operand\" \"o,o\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n+  \"!TARGET_386\"\n+  \"*\n+{\n+  rtx xop[8];\n+\n+  xop[0] = operands[2];\n+  xop[1] = operands[3];\n+  xop[2] = adj_offsettable_operand (operands[1], 8);\n+  xop[3] = adj_offsettable_operand (operands[1], 4);\n+  xop[4] = operands[1];\n+  xop[5] = adj_offsettable_operand (operands[0], 8);\n+  xop[6] = adj_offsettable_operand (operands[0], 4);\n+  xop[7] = operands[0];\n+\n+  if (GET_CODE (operands[3]) == REG)\n+    {\t\t\t\t/* 2 scratch registers available */\n+      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n+      output_asm_insn (AS2 (mov%L5,%5,%0), xop);\n+      output_asm_insn (AS2 (mov%L6,%6,%1), xop);\n+      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n+      output_asm_insn (AS2 (mov%L7,%7,%0), xop);\n+    }\n+  else\n+    {\t\t\t\t/* 1 scratch register */\n+      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%6,%0), xop);\n+      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n+      output_asm_insn (AS2 (mov%L7,%7,%0), xop);\n+    }\n+\n+  RET;\n+}\")\n+\n+(define_insn \"movxf_normal\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=f,fm,!*rf,!*rm\")\n \t(match_operand:XF 1 \"general_operand\" \"fmG,f,*rfm,*rfF\"))]\n-;;  [(set (match_operand:XF 0 \"general_operand\" \"=*rf,*rfm,f,!*rm\")\n-;;\t(match_operand:XF 1 \"general_operand\" \"*rfm,*rf,fG,fF\"))]\n-  \"\"\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n   \"*\n {\n   int stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n@@ -1343,19 +1655,60 @@\n   return output_move_double (operands);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"swapxf\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"f\")\n+\t(match_operand:XF 1 \"register_operand\" \"f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"\"\n+  \"*\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return AS1 (fxch,%1);\n+  else\n+    return AS1 (fxch,%0);\n+}\")\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Special case memory->memory moves */\n+  if (TARGET_MOVE\n+      && (reload_in_progress | reload_completed) == 0\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx (*genfunc) PROTO((rtx, rtx));\n+      if (push_operand (operands[0], DImode))\n+\tgenfunc = (TARGET_386) ? gen_movdi_push386 : gen_movdi_push486_mem;\n+      else\n+\tgenfunc = gen_movdi_mem;\n+\n+      emit_insn ((*genfunc) (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"movdi_push386\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n-\t(match_operand:DI 1 \"general_operand\" \"roiF\"))\n-   (clobber (match_scratch:SI 2 \"X\"))\n-   (clobber (match_scratch:SI 3 \"X\"))]\n-  \"TARGET_386\"\n+\t(match_operand:DI 1 \"general_operand\" \"roiF\"))]\n+  \"TARGET_386 || !TARGET_MOVE\"\n   \"* return output_move_double (operands);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DI 1 \"general_operand\" \"riF,o,o\"))\n-   (clobber (match_scratch:SI 2 \"X,=&r,=&r\"))\n-   (clobber (match_scratch:SI 3 \"X,=&r,X\"))]\n+(define_insn \"movdi_push486\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n+\t(match_operand:DI 1 \"nonmemory_operand\" \"riF\"))]\n+  \"!TARGET_386\"\n+  \"* return output_move_double (operands);\")\n+\n+(define_insn \"movdi_push486_mem\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:DI 1 \"memory_operand\" \"o,o\"))\n+   (clobber (match_scratch:SI 2 \"=&r,=&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n   \"!TARGET_386\"\n   \"*\n {\n@@ -1367,12 +1720,7 @@\n   xop[2] = high[0];\n   xop[3] = low[0];\n \n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      output_asm_insn (AS1 (push%L0,%2), xop);\n-      output_asm_insn (AS1 (push%L0,%3), xop);\n-    }\n-  else if (GET_CODE (operands[3]) == REG)\n+  if (GET_CODE (operands[3]) == REG)\n     {\t\t\t\t/* 2 scratch registers available */\n       output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n       output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n@@ -1390,19 +1738,16 @@\n   RET;\n }\")\n \n-(define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r,rm,o,o\")\n-\t(match_operand:DI 1 \"general_operand\" \"m,riF,o,o\"))\n-   (clobber (match_scratch:SI 2 \"X,X,=&r,=&r\"))\n-   (clobber (match_scratch:SI 3 \"X,X,=&r,X\"))]\n+(define_insn \"movdi_mem\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=o,o\")\n+\t(match_operand:DI 1 \"memory_operand\" \"o,o\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n   \"\"\n   \"*\n {\n   rtx low[2], high[2], xop[6];\n \n-  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-    return output_move_double (operands);\n-\n   split_di (operands, 2, low, high);\n   xop[0] = operands[2];\n   xop[1] = operands[3];\n@@ -1427,7 +1772,13 @@\n \n   RET;\n }\")\n-  \n+\n+(define_insn \"movdi_normal\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,rm\")\n+\t(match_operand:DI 1 \"general_operand\" \"m,riF\"))]\n+  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n+  \"* return output_move_double (operands);\")\n+\n \f\n ;;- conversion instructions\n ;;- NONE\n@@ -1847,7 +2198,7 @@\n \n (define_expand \"fixuns_truncdfsi2\"\n   [(set (match_dup 4)\n-\t(match_operand:DF 1 \"register_operand\" \"\"))\n+\t(match_operand:DF 1 \"general_operand\" \"\"))\n    (parallel [(set (match_dup 2)\n \t\t   (fix:DI (fix:DF (match_dup 4))))\n \t      (clobber (match_dup 4))\n@@ -1868,7 +2219,7 @@\n \n (define_expand \"fixuns_truncsfsi2\"\n   [(set (match_dup 4)\n-\t(match_operand:SF 1 \"register_operand\" \"\"))\n+\t(match_operand:SF 1 \"general_operand\" \"\"))\n    (parallel [(set (match_dup 2)\n \t\t   (fix:DI (fix:SF (match_dup 4))))\n \t      (clobber (match_dup 4))\n@@ -1890,62 +2241,63 @@\n ;; Signed conversion to DImode.\n \n (define_expand \"fix_truncxfdi2\"\n-  [(set (match_dup 2)\n-\t(match_operand:XF 1 \"register_operand\" \"\"))\n-   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:XF (match_dup 2))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(fix:DI (match_operand:XF 1 \"general_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n-  operands[2] = gen_reg_rtx (XFmode);\n-  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[4] = (rtx) assign_386_stack_local (SImode, 1);\n+  if (operands[0])\t\t/* prevent unused code message */\n+    {\n+      rtx reg = gen_reg_rtx (XFmode);\n+      emit_insn (gen_movxf (reg, operands[1]));\n+      emit_insn (gen_fix_truncxfdi2_internal (operands[0],\n+\t\t\t\t\t      reg,\n+\t\t\t\t\t      assign_386_stack_local (SImode, 0),\n+\t\t\t\t\t      assign_386_stack_local (SImode, 1)));\n+      DONE;\n+    }\n }\")\n \n (define_expand \"fix_truncdfdi2\"\n-  [(set (match_dup 2)\n-\t(match_operand:DF 1 \"register_operand\" \"\"))\n-   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:DF (match_dup 2))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(fix:DI (match_operand:DF 1 \"general_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[1] = copy_to_mode_reg (DFmode, operands[1]);\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[4] = (rtx) assign_386_stack_local (SImode, 1);\n+  if (operands[0])\t\t/* prevent unused code message */\n+    {\n+      rtx reg = gen_reg_rtx (DFmode);\n+      emit_insn (gen_movdf (reg, operands[1]));\n+      emit_insn (gen_fix_truncdfdi2_internal (operands[0],\n+\t\t\t\t\t      reg,\n+\t\t\t\t\t      assign_386_stack_local (SImode, 0),\n+\t\t\t\t\t      assign_386_stack_local (SImode, 1)));\n+      DONE;\n+    }\n }\")\n \n+\n (define_expand \"fix_truncsfdi2\"\n-  [(set (match_dup 2)\n-\t(match_operand:SF 1 \"register_operand\" \"\"))\n-   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:SF (match_dup 2))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(fix:DI (match_operand:SF 1 \"general_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n-  operands[2] = gen_reg_rtx (SFmode);\n-  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[4] = (rtx) assign_386_stack_local (SImode, 1);\n+  if (operands[0])\t\t/* prevent unused code message */\n+    {\n+      rtx reg = gen_reg_rtx (SFmode);\n+      emit_insn (gen_movsf (reg, operands[1]));\n+      emit_insn (gen_fix_truncsfdi2_internal (operands[0],\n+\t\t\t\t\t      reg,\n+\t\t\t\t\t      assign_386_stack_local (SImode, 0),\n+\t\t\t\t\t      assign_386_stack_local (SImode, 1)));\n+      DONE;\n+    }\n }\")\n \n ;; These match a signed conversion of either DFmode or SFmode to DImode.\n \n-(define_insn \"\"\n+(define_insn \"fix_truncxfdi2_internal\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n \t(fix:DI (fix:XF (match_operand:XF 1 \"register_operand\" \"f\"))))\n    (clobber (match_dup 1))\n@@ -1955,7 +2307,7 @@\n   \"TARGET_80387\"\n   \"* return output_fix_trunc (insn, operands);\")\n \n-(define_insn \"\"\n+(define_insn \"fix_truncdfdi2_internal\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n \t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n    (clobber (match_dup 1))\n@@ -1965,7 +2317,7 @@\n   \"TARGET_80387\"\n   \"* return output_fix_trunc (insn, operands);\")\n \n-(define_insn \"\"\n+(define_insn \"fix_truncsfdi2_internal\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n \t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))\n    (clobber (match_dup 1))"}]}