{"sha": "d9987fb40780ff8900d0dca8b40ebd501c963bd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk5ODdmYjQwNzgwZmY4OTAwZDBkY2E4YjQwZWJkNTAxYzk2M2JkNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-05-17T06:31:05Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-05-17T06:31:05Z"}, "message": "re PR tree-optimization/24659 (Conversions are not vectorized)\n\n\tPR tree-optimization/24659\n        * optabs.h (enum optab_index): Add OTI_vec_unpacks_float_hi,\n\tOTI_vec_unpacks_float_lo, OTI_vec_unpacku_float_hi,\n\tOTI_vec_unpacku_float_lo, OTI_vec_pack_sfix_trunc and\n\tOTI_vec_pack_ufix_trunc.\n\t(vec_unpacks_float_hi_optab): Define new macro.\n\t(vec_unpacks_float_lo_optab): Ditto.\n\t(vec_unpacku_float_hi_optab): Ditto.\n\t(vec_unpacku_float_lo_optab): Ditto.\n\t(vec_pack_sfix_trunc_optab): Ditto.\n\t(vec_pack_ufix_trunc_optab): Ditto.\n\t* genopinit.c (optabs): Implement vec_unpack[s|u]_[hi|lo]_optab\n\tand vec_pack_[s|u]fix_trunc_optab using\n\tvec_unpack[s|u]_[hi\\lo]_* and vec_pack_[u|s]fix_trunc_* patterns\n\t* tree-vectorizer.c (supportable_widening_operation): Handle\n\tFLOAT_EXPR and CONVERT_EXPR.  Update comment.\n\t(supportable_narrowing_operation): New function.\n\t* tree-vectorizer.h (supportable_narrowing_operation): Prototype.\n\t* tree-vect-transform.c (vectorizable_conversion): Handle\n\t(nunits_in == nunits_out / 2) and (nunits_out == nunits_in / 2) cases.\n\t(vect_gen_widened_results_half): Move before vectorizable_conversion.\n\t(vectorizable_type_demotion): Call supportable_narrowing_operation()\n\tto check for target support.\n\t* optabs.c (optab_for_tree_code) Return vec_unpack[s|u]_float_hi_optab\n\tfor VEC_UNPACK_FLOAT_HI_EXPR, vec_unpack[s|u]_float_lo_optab\n\tfor VEC_UNPACK_FLOAT_LO_EXPR and vec_pack_[u|s]fix_trunc_optab\n\tfor VEC_PACK_FIX_TRUNC_EXPR.\n\t(expand_binop): Special case mode of the result for\n\tvec_pack_[u|s]fix_trunc_optab.\n\t(init_optabs): Initialize vec_unpack[s|u]_[hi|lo]_optab and\n\tvec_pack_[u|s]fix_trunc_optab.\n\n\t* tree.def (VEC_UNPACK_FLOAT_HI_EXPR, VEC_UNPACK_FLOAT_LO_EXPR,\n\tVEC_PACK_FIX_TRUNC_EXPR): New tree codes.\n\t* tree-pretty-print.c (dump_generic_node): Handle\n\tVEC_UNPACK_FLOAT_HI_EXPR, VEC_UNPACK_FLOAT_LO_EXPR and\n\tVEC_PACK_FIX_TRUNC_EXPR.\n\t(op_prio): Ditto.\n\t* expr.c (expand_expr_real_1): Ditto.\n\t* tree-inline.c (estimate_num_insns_1): Ditto.\n\t* tree-vect-generic.c (expand_vector_operations_1): Ditto.\n\n\t* config/i386/sse.md (vec_unpacks_float_hi_v8hi): New expander.\n\t(vec_unpacks_float_lo_v8hi): Ditto.\n\t(vec_unpacku_float_hi_v8hi): Ditto.\n\t(vec_unpacku_float_lo_v8hi): Ditto.\n\t(vec_unpacks_float_hi_v4si): Ditto.\n\t(vec_unpacks_float_lo_v4si): Ditto.\n\t(vec_pack_sfix_trunc_v2df): Ditto.\n\n\t* doc/c-tree.texi (Expression trees) [VEC_UNPACK_FLOAT_HI_EXPR]:\n\tDocument.\n\t[VEC_UNPACK_FLOAT_LO_EXPR]: Ditto.\n\t[VEC_PACK_FIX_TRUNC_EXPR]: Ditto.\n\t* doc/md.texi (Standard Names) [vec_pack_sfix_trunc]: Document.\n\t[vec_pack_ufix_trunc]: Ditto.\n\t[vec_unpacks_float_hi]: Ditto.\n\t[vec_unpacks_float_lo]: Ditto.\n\t[vec_unpacku_float_hi]: Ditto.\n\t[vec_unpacku_float_lo]: Ditto.\n\ntestsuite/ChangeLog:\n\n\tPR tree-optimization/24659\n\t* gcc.dg/vect/vect-floatint-conversion-2.c: New test.\n\t* gcc.dg/vect/vect-intfloat-conversion-1.c: Require vect_float,\n\tnot vect_int target.\n\t* gcc.dg/vect/vect-intfloat-conversion-2.c: Require vect_float,\n\tnot vect_int target.  Loop is vectorized for vect_intfloat_cvt\n\ttargets.\n\t* gcc.dg/vect/vect-intfloat-conversion-3.c: New test.\n\t* gcc.dg/vect/vect-intfloat-conversion-4a.c: New test.\n\t* gcc.dg/vect/vect-intfloat-conversion-4b.c: New test.\n\nFrom-SVN: r124784", "tree": {"sha": "89eb8371ed2645bc5faf2ffeb7e859c669317654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89eb8371ed2645bc5faf2ffeb7e859c669317654"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9987fb40780ff8900d0dca8b40ebd501c963bd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9987fb40780ff8900d0dca8b40ebd501c963bd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9987fb40780ff8900d0dca8b40ebd501c963bd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9987fb40780ff8900d0dca8b40ebd501c963bd5/comments", "author": null, "committer": null, "parents": [{"sha": "f59d2a7c86c5d8834ca0558682cac83e31035e68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f59d2a7c86c5d8834ca0558682cac83e31035e68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f59d2a7c86c5d8834ca0558682cac83e31035e68"}], "stats": {"total": 941, "additions": 791, "deletions": 150}, "files": [{"sha": "f50bdc5ff9a9d6b8e2390422f5cb312cbdf99423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1,3 +1,66 @@\n+2007-05-17  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/24659\n+\t* optabs.h (enum optab_index): Add OTI_vec_unpacks_float_hi,\n+\tOTI_vec_unpacks_float_lo, OTI_vec_unpacku_float_hi,\n+\tOTI_vec_unpacku_float_lo, OTI_vec_pack_sfix_trunc and\n+\tOTI_vec_pack_ufix_trunc.\n+\t(vec_unpacks_float_hi_optab): Define new macro.\n+\t(vec_unpacks_float_lo_optab): Ditto.\n+\t(vec_unpacku_float_hi_optab): Ditto.\n+\t(vec_unpacku_float_lo_optab): Ditto.\n+\t(vec_pack_sfix_trunc_optab): Ditto.\n+\t(vec_pack_ufix_trunc_optab): Ditto.\n+\t* genopinit.c (optabs): Implement vec_unpack[s|u]_[hi|lo]_optab\n+\tand vec_pack_[s|u]fix_trunc_optab using\n+\tvec_unpack[s|u]_[hi\\lo]_* and vec_pack_[u|s]fix_trunc_* patterns\n+\t* tree-vectorizer.c (supportable_widening_operation): Handle\n+\tFLOAT_EXPR and CONVERT_EXPR.  Update comment.\n+\t(supportable_narrowing_operation): New function.\n+\t* tree-vectorizer.h (supportable_narrowing_operation): Prototype.\n+\t* tree-vect-transform.c (vectorizable_conversion): Handle\n+\t(nunits_in == nunits_out / 2) and (nunits_out == nunits_in / 2) cases.\n+\t(vect_gen_widened_results_half): Move before vectorizable_conversion.\n+\t(vectorizable_type_demotion): Call supportable_narrowing_operation()\n+\tto check for target support.\n+\t* optabs.c (optab_for_tree_code) Return vec_unpack[s|u]_float_hi_optab\n+\tfor VEC_UNPACK_FLOAT_HI_EXPR, vec_unpack[s|u]_float_lo_optab\n+\tfor VEC_UNPACK_FLOAT_LO_EXPR and vec_pack_[u|s]fix_trunc_optab\n+\tfor VEC_PACK_FIX_TRUNC_EXPR.\n+\t(expand_binop): Special case mode of the result for\n+\tvec_pack_[u|s]fix_trunc_optab.\n+\t(init_optabs): Initialize vec_unpack[s|u]_[hi|lo]_optab and\n+\tvec_pack_[u|s]fix_trunc_optab.\n+\n+\t* tree.def (VEC_UNPACK_FLOAT_HI_EXPR, VEC_UNPACK_FLOAT_LO_EXPR,\n+\tVEC_PACK_FIX_TRUNC_EXPR): New tree codes.\n+\t* tree-pretty-print.c (dump_generic_node): Handle\n+\tVEC_UNPACK_FLOAT_HI_EXPR, VEC_UNPACK_FLOAT_LO_EXPR and\n+\tVEC_PACK_FIX_TRUNC_EXPR.\n+\t(op_prio): Ditto.\n+\t* expr.c (expand_expr_real_1): Ditto.\n+\t* tree-inline.c (estimate_num_insns_1): Ditto.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Ditto.\n+\n+\t* config/i386/sse.md (vec_unpacks_float_hi_v8hi): New expander.\n+\t(vec_unpacks_float_lo_v8hi): Ditto.\n+\t(vec_unpacku_float_hi_v8hi): Ditto.\n+\t(vec_unpacku_float_lo_v8hi): Ditto.\n+\t(vec_unpacks_float_hi_v4si): Ditto.\n+\t(vec_unpacks_float_lo_v4si): Ditto.\n+\t(vec_pack_sfix_trunc_v2df): Ditto.\n+\n+\t* doc/c-tree.texi (Expression trees) [VEC_UNPACK_FLOAT_HI_EXPR]:\n+\tDocument.\n+\t[VEC_UNPACK_FLOAT_LO_EXPR]: Ditto.\n+\t[VEC_PACK_FIX_TRUNC_EXPR]: Ditto.\n+\t* doc/md.texi (Standard Names) [vec_pack_sfix_trunc]: Document.\n+\t[vec_pack_ufix_trunc]: Ditto.\n+\t[vec_unpacks_float_hi]: Ditto.\n+\t[vec_unpacks_float_lo]: Ditto.\n+\t[vec_unpacku_float_hi]: Ditto.\n+\t[vec_unpacku_float_lo]: Ditto.\n+\n 2007-05-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* soft-fp/README: Update for new files.\n@@ -46,14 +109,15 @@\n \n 2007-05-16  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * config/i386/i386.c (legitimize_tls_address): Mark __tls_get_addr\n-        calls as pure.\n+\t* config/i386/i386.c (legitimize_tls_address): Mark __tls_get_addr\n+\tcalls as pure.\n \n 2007-05-16  Eric Christopher  <echristo@apple.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_prologue): Move altivec register\n-        saving after stack push. Set sp_offset whenever we push.\n-        (rs6000_emit_epilogue): Move altivec register restore before stack push.\n+\tsaving after stack push. Set sp_offset whenever we push.\n+\t(rs6000_emit_epilogue): Move altivec register restore before\n+\tstack push.\n \n 2007-05-16  Richard Sandiford  <richard@codesourcery.com>\n \n@@ -496,7 +560,7 @@\n \tdumps.\n \n 2007-05-08  Sandra Loosemore  <sandra@codesourcery.com>\n-            Nigel Stephens  <nigel@mips.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n \n \t* config/mips/mips.h (MAX_FPRS_PER_FMT): Renamed from FP_INC.\n \tUpdate comments and all uses.\n@@ -563,7 +627,7 @@\n \t* configure: Regenerate.\n \t* config.in: Regenerate.\n \n-2007-05-07   Naveen.H.S  <naveen.hs@kpitcummins.com>\n+2007-05-07  Naveen.H.S  <naveen.hs@kpitcummins.com>\n \n \t* config/m32c/muldiv.md (mulhisi3_c): Limit the mode of the 2nd\n \toperand to HI mode.\n@@ -1062,7 +1126,7 @@\n \tPR middle-end/22156\n \tTemporarily revert:\n \t2007-04-06  Andreas Tobler  <a.tobler@schweiz.org>\n-        * tree-sra.c (sra_build_elt_assignment): Initialize min/maxshift.\n+\t* tree-sra.c (sra_build_elt_assignment): Initialize min/maxshift.\n \t2007-04-05  Alexandre Oliva  <aoliva@redhat.com>\n \t* tree-sra.c (try_instantiate_multiple_fields): Needlessly\n \tinitialize align to silence bogus warning.\n@@ -1274,17 +1338,17 @@\n \tPR tree-optimization/30965\n \tPR tree-optimization/30978\n \t* Makefile.in (tree-ssa-forwprop.o): Depend on $(FLAGS_H).\n-        * tree-ssa-forwprop.c (forward_propagate_into_cond_1): Remove.\n-        (find_equivalent_equality_comparison): Likewise.\n-        (simplify_cond): Likewise.\n-        (get_prop_source_stmt): New helper.\n-        (get_prop_dest_stmt): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_into_cond_1): Remove.\n+\t(find_equivalent_equality_comparison): Likewise.\n+\t(simplify_cond): Likewise.\n+\t(get_prop_source_stmt): New helper.\n+\t(get_prop_dest_stmt): Likewise.\n \t(can_propagate_from): Likewise.\n \t(remove_prop_source_from_use): Likewise.\n-        (combine_cond_expr_cond): Likewise.\n-        (forward_propagate_comparison): New function.\n-        (forward_propagate_into_cond): Rewrite to use fold for\n-        tree combining.\n+\t(combine_cond_expr_cond): Likewise.\n+\t(forward_propagate_comparison): New function.\n+\t(forward_propagate_into_cond): Rewrite to use fold for\n+\ttree combining.\n \t(tree_ssa_forward_propagate_single_use_vars): Call\n \tforward_propagate_comparison to propagate comparisons.\n "}, {"sha": "aa581ac1443115a7c96f050d75baf4c896da6fc1", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -2205,6 +2205,80 @@\n \t    (parallel [(const_int 0) (const_int 1)]))))]\n   \"TARGET_SSE2\")\n \n+(define_expand \"vec_unpacks_float_hi_v8hi\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx tmp = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_unpacks_hi_v8hi (tmp, operands[1]));\n+  emit_insn (gen_sse2_cvtdq2ps (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_float_lo_v8hi\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx tmp = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_unpacks_lo_v8hi (tmp, operands[1]));\n+  emit_insn (gen_sse2_cvtdq2ps (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_float_hi_v8hi\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx tmp = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_unpacku_hi_v8hi (tmp, operands[1]));\n+  emit_insn (gen_sse2_cvtdq2ps (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_float_lo_v8hi\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx tmp = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_vec_unpacku_lo_v8hi (tmp, operands[1]));\n+  emit_insn (gen_sse2_cvtdq2ps (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_float_hi_v4si\"\n+  [(set (match_dup 2)\n+\t(vec_select:V4SI\n+\t  (match_operand:V4SI 1 \"nonimmediate_operand\" \"\")\n+\t  (parallel [(const_int 2)\n+\t\t     (const_int 3)\n+\t\t     (const_int 2)\n+\t\t     (const_int 3)])))\n+   (set (match_operand:V2DF 0 \"register_operand\" \"\")\n+        (float:V2DF\n+\t  (vec_select:V2SI\n+\t  (match_dup 2)\n+\t    (parallel [(const_int 0) (const_int 1)]))))]\n+ \"TARGET_SSE2\"\n+{\n+ operands[2] = gen_reg_rtx (V4SImode);\n+})\n+\n+(define_expand \"vec_unpacks_float_lo_v4si\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n+\t(float:V2DF\n+\t  (vec_select:V2SI\n+\t    (match_operand:V4SI 1 \"nonimmediate_operand\" \"\")\n+\t    (parallel [(const_int 0) (const_int 1)]))))]\n+  \"TARGET_SSE2\")\n+\n (define_expand \"vec_pack_trunc_v2df\"\n   [(match_operand:V4SF 0 \"register_operand\" \"\")\n    (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n@@ -2222,6 +2296,25 @@\n   DONE;\n })\n \n+(define_expand \"vec_pack_sfix_trunc_v2df\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx r1, r2;\n+\n+  r1 = gen_reg_rtx (V4SImode);\n+  r2 = gen_reg_rtx (V4SImode);\n+\n+  emit_insn (gen_sse2_cvttpd2dq (r1, operands[1]));\n+  emit_insn (gen_sse2_cvttpd2dq (r2, operands[2]));\n+  emit_insn (gen_sse2_punpcklqdq (gen_lowpart (V2DImode, operands[0]),\n+\t\t\t\t  gen_lowpart (V2DImode, r1),\n+\t\t\t\t  gen_lowpart (V2DImode, r2)));\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point element swizzling\n@@ -3525,7 +3618,7 @@\n   \"TARGET_SSE2\"\n {\n   rtx op1, op2, h1, l1, h2, l2, h3, l3;\n-                                                                                \n+\n   op1 = gen_lowpart (V16QImode, operands[1]);\n   op2 = gen_lowpart (V16QImode, operands[2]);\n   h1 = gen_reg_rtx (V16QImode);\n@@ -3534,7 +3627,7 @@\n   l2 = gen_reg_rtx (V16QImode);\n   h3 = gen_reg_rtx (V16QImode);\n   l3 = gen_reg_rtx (V16QImode);\n-                                                                                \n+\n   emit_insn (gen_vec_interleave_highv16qi (h1, op1, op2));\n   emit_insn (gen_vec_interleave_lowv16qi (l1, op1, op2));\n   emit_insn (gen_vec_interleave_highv16qi (h2, l1, h1));\n@@ -3544,7 +3637,7 @@\n   emit_insn (gen_vec_interleave_lowv16qi (operands[0], l3, h3));\n   DONE;\n })\n-                                                                                \n+\n ;; Reduce:\n ;;      op1 = abcdefgh\n ;;      op2 = ijklmnop\n@@ -3560,22 +3653,22 @@\n   \"TARGET_SSE2\"\n {\n   rtx op1, op2, h1, l1, h2, l2;\n-                                                                                \n+\n   op1 = gen_lowpart (V8HImode, operands[1]);\n   op2 = gen_lowpart (V8HImode, operands[2]);\n   h1 = gen_reg_rtx (V8HImode);\n   l1 = gen_reg_rtx (V8HImode);\n   h2 = gen_reg_rtx (V8HImode);\n   l2 = gen_reg_rtx (V8HImode);\n-                                                                                \n+\n   emit_insn (gen_vec_interleave_highv8hi (h1, op1, op2));\n   emit_insn (gen_vec_interleave_lowv8hi (l1, op1, op2));\n   emit_insn (gen_vec_interleave_highv8hi (h2, l1, h1));\n   emit_insn (gen_vec_interleave_lowv8hi (l2, l1, h1));\n   emit_insn (gen_vec_interleave_lowv8hi (operands[0], l2, h2));\n   DONE;\n })\n-                                                                                \n+\n ;; Reduce:\n ;;     op1 = abcd\n ;;     op2 = efgh\n@@ -3589,12 +3682,12 @@\n   \"TARGET_SSE2\"\n {\n   rtx op1, op2, h1, l1;\n-                                                                                \n+\n   op1 = gen_lowpart (V4SImode, operands[1]);\n   op2 = gen_lowpart (V4SImode, operands[2]);\n   h1 = gen_reg_rtx (V4SImode);\n   l1 = gen_reg_rtx (V4SImode);\n-                                                                                \n+\n   emit_insn (gen_vec_interleave_highv4si (h1, op1, op2));\n   emit_insn (gen_vec_interleave_lowv4si (l1, op1, op2));\n   emit_insn (gen_vec_interleave_lowv4si (operands[0], l1, h1));"}, {"sha": "bd4c62308ee5f0e86108a0a1a45262c4122febd7", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1983,8 +1983,11 @@ This macro returns the attributes on the type @var{type}.\n @tindex VEC_WIDEN_MULT_LO_EXPR\n @tindex VEC_UNPACK_HI_EXPR\n @tindex VEC_UNPACK_LO_EXPR\n+@tindex VEC_UNPACK_FLOAT_HI_EXPR\n+@tindex VEC_UNPACK_FLOAT_LO_EXPR\n @tindex VEC_PACK_TRUNC_EXPR\n @tindex VEC_PACK_SAT_EXPR\n+@tindex VEC_PACK_FIX_TRUNC_EXPR\n @tindex VEC_EXTRACT_EVEN_EXPR \n @tindex VEC_EXTRACT_ODD_EXPR\n @tindex VEC_INTERLEAVE_HIGH_EXPR\n@@ -2846,6 +2849,17 @@ high @code{N/2} elements of the vector are extracted and widened (promoted).\n In the case of @code{VEC_UNPACK_LO_EXPR} the low @code{N/2} elements of the\n vector are extracted and widened (promoted).\n \n+@item VEC_UNPACK_FLOAT_HI_EXPR\n+@item VEC_UNPACK_FLOAT_LO_EXPR\n+These nodes represent unpacking of the high and low parts of the input vector,\n+where the values are converted from fixed point to floating point.  The\n+single operand is a vector that contains @code{N} elements of the same\n+integral type.  The result is a vector that contains half as many elements\n+of a floating point type whose size is twice as wide.  In the case of\n+@code{VEC_UNPACK_HI_EXPR} the high @code{N/2} elements of the vector are\n+extracted, converted and widened.  In the case of @code{VEC_UNPACK_LO_EXPR}\n+the low @code{N/2} elements of the vector are extracted, converted and widened.\n+\n @item VEC_PACK_TRUNC_EXPR\n This node represents packing of truncated elements of the two input vectors\n into the output vector.  Input operands are vectors that contain the same\n@@ -2862,6 +2876,15 @@ vector that contains twice as many elements of an integral type whose size\n is half as wide.  The elements of the two vectors are demoted and merged\n (concatenated) to form the output vector.\n \n+@item VEC_PACK_FIX_TRUNC_EXPR\n+This node represents packing of elements of the two input vectors into the\n+output vector, where the values are converted from floating point\n+to fixed point.  Input operands are vectors that contain the same number\n+of elements of a floating point type.  The result is a vector that contains\n+twice as many elements of an integral type whose size is half as wide.  The\n+elements of the two vectors are merged (concatenated) to form the output\n+vector.\n+\n @item VEC_EXTRACT_EVEN_EXPR\n @item VEC_EXTRACT_ODD_EXPR\n These nodes represent extracting of the even/odd elements of the two input "}, {"sha": "029657d3fe0e615d87bf84d5a3521d007db53b7d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -3607,6 +3607,14 @@ Operand 0 is the resulting vector in which the elements of the two input\n vectors are concatenated after narrowing them down using signed/unsigned\n saturating arithmetic.\n \n+@cindex @code{vec_pack_sfix_trunc_@var{m}} instruction pattern\n+@cindex @code{vec_pack_ufix_trunc_@var{m}} instruction pattern\n+@item @samp{vec_pack_sfix_trunc_@var{m}}, @samp{vec_pack_ufix_trunc_@var{m}}\n+Narrow, convert to signed/unsigned integral type and merge the elements\n+of two vectors.  Operands 1 and 2 are vectors of the same mode having N\n+floating point elements of size S.  Operand 0 is the resulting vector\n+in which 2*N elements of size N/2 are concatenated.\n+\n @cindex @code{vec_unpacks_hi_@var{m}} instruction pattern\n @cindex @code{vec_unpacks_lo_@var{m}} instruction pattern\n @item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}\n@@ -3624,11 +3632,24 @@ integral elements.  The input vector (operand 1) has N elements of size S.\n Widen (promote) the high/low elements of the vector using zero extension and\n place the resulting N/2 values of size 2*S in the output vector (operand 0).\n \n+@cindex @code{vec_unpacks_float_hi_@var{m}} instruction pattern\n+@cindex @code{vec_unpacks_float_lo_@var{m}} instruction pattern\n+@cindex @code{vec_unpacku_float_hi_@var{m}} instruction pattern\n+@cindex @code{vec_unpacku_float_lo_@var{m}} instruction pattern\n+@item @samp{vec_unpacks_float_hi_@var{m}}, @samp{vec_unpacks_float_lo_@var{m}}\n+@itemx @samp{vec_unpacku_float_hi_@var{m}}, @samp{vec_unpacku_float_lo_@var{m}}\n+Extract, convert to floating point type and widen the high/low part of a\n+vector of signed/unsigned integral elements.  The input vector (operand 1)\n+has N elements of size S.  Convert the high/low elements of the vector using\n+floating point conversion and place the resulting N/2 values of size 2*S in\n+the output vector (operand 0).\n+\n @cindex @code{vec_widen_umult_hi_@var{m}} instruction pattern\n @cindex @code{vec_widen_umult_lo__@var{m}} instruction pattern\n @cindex @code{vec_widen_smult_hi_@var{m}} instruction pattern\n @cindex @code{vec_widen_smult_lo_@var{m}} instruction pattern\n-@item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}, @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}\n+@item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}\n+@itemx @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}\n Signed/Unsigned widening multiplication.  The two inputs (operands 1 and 2)\n are vectors with N signed/unsigned elements of size S.  Multiply the high/low\n elements of the two vectors, and put the N/2 products of size 2*S in the"}, {"sha": "9286ffab7c246135d2aac44040c6a58e00645fc4", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -9001,6 +9001,21 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn temp;\n       }\n \n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n+      {\n+\top0 = expand_normal (TREE_OPERAND (exp, 0));\n+\t/* The signedness is determined from input operand.  */\n+\tthis_optab = optab_for_tree_code (code,\n+\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\ttemp = expand_widen_pattern_expr\n+\t  (exp, op0, NULL_RTX, NULL_RTX,\n+\t   target, TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+\n+\tgcc_assert (temp);\n+\treturn temp;\n+      }\n+\n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:\n       {\n@@ -9016,6 +9031,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n+    case VEC_PACK_FIX_TRUNC_EXPR:\n       {\n \tmode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \tgoto binop;"}, {"sha": "a16d0e17c6bc10238d83580415fce3fd0091d0c4", "filename": "gcc/genopinit.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -233,9 +233,15 @@ static const char * const optabs[] =\n   \"vec_unpacks_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_lo_$a$)\",\n   \"vec_unpacku_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_hi_$a$)\",\n   \"vec_unpacku_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_lo_$a$)\",\n+  \"vec_unpacks_float_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_float_hi_$a$)\",\n+  \"vec_unpacks_float_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacks_float_lo_$a$)\",\n+  \"vec_unpacku_float_hi_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_float_hi_$a$)\",\n+  \"vec_unpacku_float_lo_optab->handlers[$A].insn_code = CODE_FOR_$(vec_unpacku_float_lo_$a$)\",\n   \"vec_pack_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_trunc_$a$)\",\n   \"vec_pack_ssat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ssat_$a$)\",\n-  \"vec_pack_usat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_usat_$a$)\"\n+  \"vec_pack_usat_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_usat_$a$)\",\n+  \"vec_pack_sfix_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_sfix_trunc_$a$)\",\n+  \"vec_pack_ufix_trunc_optab->handlers[$A].insn_code = CODE_FOR_$(vec_pack_ufix_trunc_$a$)\"\n };\n \n static void gen_insn (rtx);"}, {"sha": "d659132c1e9c1f91272d664cebd1d962ead039f0", "filename": "gcc/optabs.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -340,12 +340,26 @@ optab_for_tree_code (enum tree_code code, tree type)\n       return TYPE_UNSIGNED (type) ? \n \tvec_unpacku_lo_optab : vec_unpacks_lo_optab;\n \n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+      /* The signedness is determined from input operand.  */\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_unpacku_float_hi_optab : vec_unpacks_float_hi_optab;\n+\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n+      /* The signedness is determined from input operand.  */\n+      return TYPE_UNSIGNED (type) ? \n+\tvec_unpacku_float_lo_optab : vec_unpacks_float_lo_optab;\n+\n     case VEC_PACK_TRUNC_EXPR:\n       return vec_pack_trunc_optab;\n \n     case VEC_PACK_SAT_EXPR:\n       return TYPE_UNSIGNED (type) ? vec_pack_usat_optab : vec_pack_ssat_optab;\n \n+    case VEC_PACK_FIX_TRUNC_EXPR:\n+      return TYPE_UNSIGNED (type) ?\n+\tvec_pack_ufix_trunc_optab : vec_pack_sfix_trunc_optab;\n+\n     default:\n       break;\n     }\n@@ -1375,7 +1389,9 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (binoptab == vec_pack_trunc_optab \n \t  || binoptab == vec_pack_usat_optab\n-          || binoptab == vec_pack_ssat_optab)\n+\t  || binoptab == vec_pack_ssat_optab\n+\t  || binoptab == vec_pack_ufix_trunc_optab\n+\t  || binoptab == vec_pack_sfix_trunc_optab)\n \t{\n \t  /* The mode of the result is different then the mode of the\n \t     arguments.  */\n@@ -5565,9 +5581,15 @@ init_optabs (void)\n   vec_unpacks_lo_optab = init_optab (UNKNOWN);\n   vec_unpacku_hi_optab = init_optab (UNKNOWN);\n   vec_unpacku_lo_optab = init_optab (UNKNOWN);\n+  vec_unpacks_float_hi_optab = init_optab (UNKNOWN);\n+  vec_unpacks_float_lo_optab = init_optab (UNKNOWN);\n+  vec_unpacku_float_hi_optab = init_optab (UNKNOWN);\n+  vec_unpacku_float_lo_optab = init_optab (UNKNOWN);\n   vec_pack_trunc_optab = init_optab (UNKNOWN);\n   vec_pack_usat_optab = init_optab (UNKNOWN);\n   vec_pack_ssat_optab = init_optab (UNKNOWN);\n+  vec_pack_ufix_trunc_optab = init_optab (UNKNOWN);\n+  vec_pack_sfix_trunc_optab = init_optab (UNKNOWN);\n \n   powi_optab = init_optab (UNKNOWN);\n "}, {"sha": "7df2669e2ae1cf401e691dd82ac05539bc846b16", "filename": "gcc/optabs.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -298,11 +298,24 @@ enum optab_index\n      elements.  */\n   OTI_vec_unpacku_hi,\n   OTI_vec_unpacku_lo,\n+\n+  /* Extract, convert to floating point and widen the high/low part of\n+     a vector of signed or unsigned integer elements.  */\n+  OTI_vec_unpacks_float_hi,\n+  OTI_vec_unpacks_float_lo,\n+  OTI_vec_unpacku_float_hi,\n+  OTI_vec_unpacku_float_lo,\n+\n   /* Narrow (demote) and merge the elements of two vectors.  */\n   OTI_vec_pack_trunc,\n   OTI_vec_pack_usat,\n   OTI_vec_pack_ssat,\n \n+  /* Convert to signed/unsigned integer, narrow and merge elements\n+     of two vectors of floating point elements.  */\n+  OTI_vec_pack_sfix_trunc,\n+  OTI_vec_pack_ufix_trunc,\n+\n   /* Perform a raise to the power of integer.  */\n   OTI_powi,\n \n@@ -446,9 +459,15 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define vec_unpacks_lo_optab (optab_table[OTI_vec_unpacks_lo])\n #define vec_unpacku_hi_optab (optab_table[OTI_vec_unpacku_hi])\n #define vec_unpacku_lo_optab (optab_table[OTI_vec_unpacku_lo])\n+#define vec_unpacks_float_hi_optab (optab_table[OTI_vec_unpacks_float_hi])\n+#define vec_unpacks_float_lo_optab (optab_table[OTI_vec_unpacks_float_lo])\n+#define vec_unpacku_float_hi_optab (optab_table[OTI_vec_unpacku_float_hi])\n+#define vec_unpacku_float_lo_optab (optab_table[OTI_vec_unpacku_float_lo])\n #define vec_pack_trunc_optab (optab_table[OTI_vec_pack_trunc])\n #define vec_pack_ssat_optab (optab_table[OTI_vec_pack_ssat])\n #define vec_pack_usat_optab (optab_table[OTI_vec_pack_usat])\n+#define vec_pack_sfix_trunc_optab (optab_table[OTI_vec_pack_sfix_trunc])\n+#define vec_pack_ufix_trunc_optab (optab_table[OTI_vec_pack_ufix_trunc])\n \n #define powi_optab (optab_table[OTI_powi])\n "}, {"sha": "2c0203004365403b9807fea13a14b797d95cfed6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1,3 +1,16 @@\n+2007-05-17  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR tree-optimization/24659\n+\t* gcc.dg/vect/vect-floatint-conversion-2.c: New test.\n+\t* gcc.dg/vect/vect-intfloat-conversion-1.c: Require vect_float,\n+\tnot vect_int target.\n+\t* gcc.dg/vect/vect-intfloat-conversion-2.c: Require vect_float,\n+\tnot vect_int target.  Loop is vectorized for vect_intfloat_cvt\n+\ttargets.\n+\t* gcc.dg/vect/vect-intfloat-conversion-3.c: New test.\n+\t* gcc.dg/vect/vect-intfloat-conversion-4a.c: New test.\n+\t* gcc.dg/vect/vect-intfloat-conversion-4b.c: New test.\n+\n 2007-05-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/torture/fp-int-convert-float128.c: Do not xfail for i?86-*-*\n@@ -746,7 +759,7 @@\n \t* g++.dg/expr/bitfield8.C: New test.\n \n 2007-04-17  Joseph Myers  <joseph@codesourcery.com>\n-            Richard Sandiford  <richard@codesourcery.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n \n \t* lib/target-supports.exp (check_profiling_available): Return 0\n \tfor uClibc with -p or -pg."}, {"sha": "5d115fffb91872ddeac091ecac1fac064f2759aa", "filename": "gcc/testsuite/gcc.dg/vect/vect-floatint-conversion-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-floatint-conversion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-floatint-conversion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-floatint-conversion-2.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int\n+main1 ()\n+{\n+  int i;\n+  double db[N] = {0.4,3.5,6.6,9.4,12.5,15.6,18.4,21.5,24.6,27.4,30.5,33.6,36.4,39.5,42.6,45.4,0.5,3.6,6.4,9.5,12.6,15.4,18.5,21.6,24.4,27.5,30.6,33.4,36.5,39.6,42.4,45.5};\n+  int ia[N];\n+\n+  /* double -> int */\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = (int) db[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != (int) db[i])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_floatint_cvt } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "48f91d903b34c8eae7c4807b9d0ecccdc86d14ba", "filename": "gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-1.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_float } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "0723f8af810eef13d4905f8f0a89bc188e025cc2", "filename": "gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-2.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_float } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -36,5 +36,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_intfloat_cvt } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e496e401656014c9bb849e7b9f75b21378186a6b", "filename": "gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-3.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int main1 ()\n+{\n+  int i;\n+  int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  double da[N];\n+\n+  /* int -> double */\n+  for (i = 0; i < N; i++)\n+    {\n+      da[i] = (double) ib[i];\t\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (da[i] != (double) ib[i]) \n+        abort (); \n+    }   \n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_intfloat_cvt } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e34f3458c6e3f30216a46075eec0535a9d4acdeb", "filename": "gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-4a.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-4a.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int main1 ()\n+{\n+  int i;\n+  short sb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,-3,-6,-9,-12,-15,-18,-21,-24,-27,-30,-33,-36,-39,-42,-45};\n+  float fa[N];\n+\n+  /* short -> float */\n+  for (i = 0; i < N; i++)\n+    {\n+      fa[i] = (float) sb[i];\t\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (fa[i] != (float) sb[i]) \n+        abort (); \n+    }   \n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_intfloat_cvt } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "72e7bf6aaa12e434975db632895ca54fd4a7f8fc", "filename": "gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-4b.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-4b.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int main1 ()\n+{\n+  int i;\n+  unsigned short usb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,65533,65530,65527,65524,65521,65518,65515,65512,65509,65506,65503,65500,65497,65494,65491};\n+  float fa[N];\n+\n+  /* unsigned short -> float */\n+  for (i = 0; i < N; i++)\n+    {\n+      fa[i] = (float) usb[i];\t\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (fa[i] != (float) usb[i]) \n+        abort (); \n+    }   \n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_intfloat_cvt } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "799b4f3fb6e3abc55bd9defbc8d91e861daa3275", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -2148,8 +2148,11 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case VEC_WIDEN_MULT_LO_EXPR:\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n+    case VEC_PACK_FIX_TRUNC_EXPR:\n \n     case WIDEN_MULT_EXPR:\n "}, {"sha": "991b1e11654c967532cbbe99e6f5d4163800a162", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1943,22 +1943,42 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+      pp_string (buffer, \" VEC_UNPACK_FLOAT_HI_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n+      pp_string (buffer, \" VEC_UNPACK_FLOAT_LO_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     case VEC_PACK_TRUNC_EXPR:\n       pp_string (buffer, \" VEC_PACK_TRUNC_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_string (buffer, \", \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n       pp_string (buffer, \" > \");\n       break;\n-                                                                                \n+\n     case VEC_PACK_SAT_EXPR:\n       pp_string (buffer, \" VEC_PACK_SAT_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_string (buffer, \", \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n       pp_string (buffer, \" > \");\n       break;\n-                                                                                \n+\n+    case VEC_PACK_FIX_TRUNC_EXPR:\n+      pp_string (buffer, \" VEC_PACK_FIX_TRUNC_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     case BLOCK:\n       {\n \ttree t;\n@@ -2352,6 +2372,8 @@ op_prio (tree op)\n     case VEC_RSHIFT_EXPR:\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n+    case VEC_UNPACK_FLOAT_HI_EXPR:\n+    case VEC_UNPACK_FLOAT_LO_EXPR:\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:\n       return 16;"}, {"sha": "e955c44743cec86c9ae2bb15775e45b4a344b898", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -421,8 +421,11 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n       || code == VEC_WIDEN_MULT_LO_EXPR\n       || code == VEC_UNPACK_HI_EXPR\n       || code == VEC_UNPACK_LO_EXPR\n+      || code == VEC_UNPACK_FLOAT_HI_EXPR\n+      || code == VEC_UNPACK_FLOAT_LO_EXPR\n       || code == VEC_PACK_TRUNC_EXPR\n-      || code == VEC_PACK_SAT_EXPR)\n+      || code == VEC_PACK_SAT_EXPR\n+      || code == VEC_PACK_FIX_TRUNC_EXPR)\n     type = TREE_TYPE (TREE_OPERAND (rhs, 0));\n \n   /* Optabs will try converting a negation into a subtraction, so"}, {"sha": "30e7211354cfb33bbec09becac048e59b78bb406", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 204, "deletions": 109, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -210,7 +210,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n    accessed in the loop by STMT, along with the def-use update chain to \n    appropriately advance the pointer through the loop iterations. Also set\n    aliasing information for the pointer.  This vector pointer is used by the\n-   callers to this function to create a memory reference expression for vector \n+   callers to this function to create a memory reference expression for vector\n    load/store access.\n \n    Input:\n@@ -1931,6 +1931,64 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n }\n \n \n+/* Function vect_gen_widened_results_half\n+\n+   Create a vector stmt whose code, type, number of arguments, and result\n+   variable are CODE, VECTYPE, OP_TYPE, and VEC_DEST, and its arguments are \n+   VEC_OPRND0 and VEC_OPRND1. The new vector stmt is to be inserted at BSI.\n+   In the case that CODE is a CALL_EXPR, this means that a call to DECL\n+   needs to be created (DECL is a function-decl of a target-builtin).\n+   STMT is the original scalar stmt that we are vectorizing.  */\n+\n+static tree\n+vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n+                               tree vec_oprnd0, tree vec_oprnd1, int op_type,\n+                               tree vec_dest, block_stmt_iterator *bsi,\n+\t\t\t       tree stmt)\n+{ \n+  tree expr; \n+  tree new_stmt; \n+  tree new_temp; \n+  tree sym; \n+  ssa_op_iter iter;\n+ \n+  /* Generate half of the widened result:  */ \n+  if (code == CALL_EXPR) \n+    {  \n+      /* Target specific support  */ \n+      if (op_type == binary_op)\n+\texpr = build_call_expr (decl, 2, vec_oprnd0, vec_oprnd1);\n+      else\n+\texpr = build_call_expr (decl, 1, vec_oprnd0);\n+    } \n+  else \n+    { \n+      /* Generic support */ \n+      gcc_assert (op_type == TREE_CODE_LENGTH (code)); \n+      if (op_type == binary_op) \n+        expr = build2 (code, vectype, vec_oprnd0, vec_oprnd1); \n+      else  \n+        expr = build1 (code, vectype, vec_oprnd0); \n+    } \n+  new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n+  new_temp = make_ssa_name (vec_dest, new_stmt); \n+  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp; \n+  vect_finish_stmt_generation (stmt, new_stmt, bsi); \n+\n+  if (code == CALL_EXPR)\n+    {\n+      FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n+        {\n+          if (TREE_CODE (sym) == SSA_NAME)\n+            sym = SSA_NAME_VAR (sym);\n+          mark_sym_for_renaming (sym);\n+        }\n+    }\n+\n+  return new_stmt;\n+}\n+\n+\n /* Function vectorizable_conversion.\n \n Check if STMT performs a conversion operation, that can be vectorized. \n@@ -1946,21 +2004,24 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   tree scalar_dest;\n   tree operation;\n   tree op0;\n-  tree vec_oprnd0 = NULL_TREE;\n+  tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  enum tree_code code;\n+  enum tree_code code, code1 = CODE_FOR_nothing, code2 = CODE_FOR_nothing;\n+  tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n   tree def, def_stmt;\n   enum vect_def_type dt0;\n   tree new_stmt;\n+  stmt_vec_info prev_stmt_info;\n   int nunits_in;\n   int nunits_out;\n-  int ncopies, j;\n   tree vectype_out, vectype_in;\n+  int ncopies, j;\n+  tree expr;\n   tree rhs_type, lhs_type;\n   tree builtin_decl;\n-  stmt_vec_info prev_stmt_info;\n+  enum { NARROW, NONE, WIDEN } modifier;\n \n   /* Is STMT a vectorizable conversion?   */\n \n@@ -1998,23 +2059,36 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   lhs_type = TREE_TYPE (scalar_dest);\n   vectype_out = get_vectype_for_scalar_type (lhs_type);\n-  gcc_assert (STMT_VINFO_VECTYPE (stmt_info) == vectype_out);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n \n-  /* FORNOW: need to extend to support short<->float conversions as well.  */\n-  if (nunits_out != nunits_in)\n+  /* FORNOW */\n+  if (nunits_in == nunits_out / 2)\n+    modifier = NARROW;\n+  else if (nunits_out == nunits_in)\n+    modifier = NONE;\n+  else if (nunits_out == nunits_in / 2)\n+    modifier = WIDEN;\n+  else\n     return false;\n \n+  if (modifier == NONE)\n+    gcc_assert (STMT_VINFO_VECTYPE (stmt_info) == vectype_out);\n+\n   /* Bail out if the types are both integral or non-integral */\n   if ((INTEGRAL_TYPE_P (rhs_type) && INTEGRAL_TYPE_P (lhs_type))\n       || (!INTEGRAL_TYPE_P (rhs_type) && !INTEGRAL_TYPE_P (lhs_type)))\n     return false;\n \n+  if (modifier == NARROW)\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+\n   /* Sanity check: make sure that at least one copy of the vectorized stmt\n      needs to be generated.  */\n-  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n   gcc_assert (ncopies >= 1);\n \n+  /* Check the operands of the operation.  */\n   if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2023,59 +2097,145 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n     }\n \n   /* Supportable by target?  */\n-  if (!targetm.vectorize.builtin_conversion (code, vectype_in))\n+  if ((modifier == NONE\n+       && !targetm.vectorize.builtin_conversion (code, vectype_in))\n+      || (modifier == WIDEN\n+\t  && !supportable_widening_operation (code, stmt, vectype_in,\n+\t\t\t\t\t      &decl1, &decl2,\n+\t\t\t\t\t      &code1, &code2))\n+      || (modifier == NARROW\n+\t  && !supportable_narrowing_operation (code, stmt, vectype_in,\n+\t\t\t\t\t       &code1)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"op not supported by target.\");\n       return false;\n     }\n \n+  if (modifier != NONE)\n+    STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n+\n   if (!vec_stmt)\t\t/* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n       return true;\n     }\n \n-    /** Transform.  **/\n-\n+  /** Transform.  **/\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform conversion.\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   prev_stmt_info = NULL;\n-  for (j = 0; j < ncopies; j++)\n+  switch (modifier)\n     {\n-      tree sym;\n-      ssa_op_iter iter;\n+    case NONE:\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  tree sym;\n+\t  ssa_op_iter iter;\n \n-      if (j == 0)\n-\tvec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-      else\n-\tvec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  if (j == 0)\n+\t    vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t  else\n+\t    vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n \n-      builtin_decl =\n-\ttargetm.vectorize.builtin_conversion (code, vectype_in);\n-      new_stmt = build_call_expr (builtin_decl, 1, vec_oprnd0);\n+\t  builtin_decl =\n+\t    targetm.vectorize.builtin_conversion (code, vectype_in);\n+\t  new_stmt = build_call_expr (builtin_decl, 1, vec_oprnd0);\n \n-      /* Arguments are ready. create the new vector stmt.  */\n-      new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-      FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n-        {\n-          if (TREE_CODE (sym) == SSA_NAME)\n-            sym = SSA_NAME_VAR (sym);\n-          mark_sym_for_renaming (sym);\n-        }\n+\t  /* Arguments are ready. create the new vector stmt.  */\n+\t  new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\t  FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n+\t    {\n+\t      if (TREE_CODE (sym) == SSA_NAME)\n+\t\tsym = SSA_NAME_VAR (sym);\n+\t      mark_sym_for_renaming (sym);\n+\t    }\n \n-      if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n-      else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t  if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n+      break;\n+\n+    case WIDEN:\n+      /* In case the vectorization factor (VF) is bigger than the number\n+\t of elements that we can fit in a vectype (nunits), we have to\n+\t generate more than one vector stmt - i.e - we need to \"unroll\"\n+\t the vector stmt by a factor VF/nunits.  */\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  if (j == 0)\n+\t    vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t  else\n+\t    vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\n+\t  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n+\n+\t  /* Generate first half of the widened result:  */\n+\t  new_stmt\n+\t    = vect_gen_widened_results_half (code1, vectype_out, decl1, \n+\t\t\t\t\t     vec_oprnd0, vec_oprnd1,\n+\t\t\t\t\t     unary_op, vec_dest, bsi, stmt);\n+\t  if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\n+\t  /* Generate second half of the widened result:  */\n+\t  new_stmt\n+\t    = vect_gen_widened_results_half (code2, vectype_out, decl2,\n+\t\t\t\t\t     vec_oprnd0, vec_oprnd1,\n+\t\t\t\t\t     unary_op, vec_dest, bsi, stmt);\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n+      break;\n+\n+    case NARROW:\n+      /* In case the vectorization factor (VF) is bigger than the number\n+\t of elements that we can fit in a vectype (nunits), we have to\n+\t generate more than one vector stmt - i.e - we need to \"unroll\"\n+\t the vector stmt by a factor VF/nunits.  */\n+      for (j = 0; j < ncopies; j++)\n+\t{\n+\t  /* Handle uses.  */\n+\t  if (j == 0)\n+\t    {\n+\t      vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t    }\n+\t  else\n+\t    {\n+\t      vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd1);\n+\t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t    }\n+\n+\t  /* Arguments are ready. Create the new vector stmt.  */\n+\t  expr = build2 (code1, vectype_out, vec_oprnd0, vec_oprnd1);\n+\t  new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\n+\t  if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n+\n+      *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n     }\n   return true;\n }\n@@ -2525,7 +2685,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n bool\n vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n-                             tree *vec_stmt)\n+\t\t\t    tree *vec_stmt)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -2534,7 +2694,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  enum tree_code code;\n+  enum tree_code code, code1 = CODE_FOR_nothing;\n   tree new_temp;\n   tree def, def_stmt;\n   enum vect_def_type dt0;\n@@ -2548,8 +2708,6 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   tree expr;\n   tree vectype_in;\n   tree scalar_type;\n-  optab optab;\n-  enum machine_mode vec_mode;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -2607,13 +2765,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n     }\n \n   /* Supportable by target?  */\n-  code = VEC_PACK_TRUNC_EXPR;\n-  optab = optab_for_tree_code (code, vectype_in);\n-  if (!optab)\n-    return false;\n-\n-  vec_mode = TYPE_MODE (vectype_in);\n-  if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n+  if (!supportable_narrowing_operation (code, stmt, vectype_in, &code1))\n     return false;\n \n   STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n@@ -2652,7 +2804,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n \t}\n \n       /* Arguments are ready. Create the new vector stmt.  */\n-      expr = build2 (code, vectype_out, vec_oprnd0, vec_oprnd1);\n+      expr = build2 (code1, vectype_out, vec_oprnd0, vec_oprnd1);\n       new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n@@ -2671,64 +2823,6 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n }\n \n \n-/* Function vect_gen_widened_results_half\n-\n-   Create a vector stmt whose code, type, number of arguments, and result\n-   variable are CODE, VECTYPE, OP_TYPE, and VEC_DEST, and its arguments are \n-   VEC_OPRND0 and VEC_OPRND1. The new vector stmt is to be inserted at BSI.\n-   In the case that CODE is a CALL_EXPR, this means that a call to DECL\n-   needs to be created (DECL is a function-decl of a target-builtin).\n-   STMT is the original scalar stmt that we are vectorizing.  */\n-\n-static tree\n-vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n-                               tree vec_oprnd0, tree vec_oprnd1, int op_type,\n-                               tree vec_dest, block_stmt_iterator *bsi,\n-\t\t\t       tree stmt)\n-{ \n-  tree expr; \n-  tree new_stmt; \n-  tree new_temp; \n-  tree sym; \n-  ssa_op_iter iter;\n- \n-  /* Generate half of the widened result:  */ \n-  if (code == CALL_EXPR) \n-    {  \n-      /* Target specific support  */ \n-      if (op_type == binary_op)\n-\texpr = build_call_expr (decl, 2, vec_oprnd0, vec_oprnd1);\n-      else\n-\texpr = build_call_expr (decl, 1, vec_oprnd0);\n-    } \n-  else \n-    { \n-      /* Generic support */ \n-      gcc_assert (op_type == TREE_CODE_LENGTH (code)); \n-      if (op_type == binary_op) \n-        expr = build2 (code, vectype, vec_oprnd0, vec_oprnd1); \n-      else  \n-        expr = build1 (code, vectype, vec_oprnd0); \n-    } \n-  new_stmt = build_gimple_modify_stmt (vec_dest, expr);\n-  new_temp = make_ssa_name (vec_dest, new_stmt); \n-  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp; \n-  vect_finish_stmt_generation (stmt, new_stmt, bsi); \n-\n-  if (code == CALL_EXPR)\n-    {\n-      FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n-        {\n-          if (TREE_CODE (sym) == SSA_NAME)\n-            sym = SSA_NAME_VAR (sym);\n-          mark_sym_for_renaming (sym);\n-        }\n-    }\n-\n-  return new_stmt;\n-}\n-\n-\n /* Function vectorizable_type_promotion\n \n    Check if STMT performs a binary or unary operation that involves\n@@ -2785,7 +2879,8 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n \n   operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n-  if (code != NOP_EXPR && code != WIDEN_MULT_EXPR)\n+  if (code != NOP_EXPR && code != CONVERT_EXPR\n+      && code != WIDEN_MULT_EXPR)\n     return false;\n \n   op0 = TREE_OPERAND (operation, 0);"}, {"sha": "df884f4224236d550f11d94ad2125a0d59483b80", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1736,10 +1736,10 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n    widening operation that is supported by the target platform in \n    vector form (i.e., when operating on arguments of type VECTYPE).\n     \n-   The two kinds of widening operations we currently support are\n-   NOP and WIDEN_MULT. This function checks if these operations\n-   are supported by the target platform either directly (via vector \n-   tree-codes), or via target builtins.\n+   Widening operations we currently support are NOP (CONVERT), FLOAT\n+   and WIDEN_MULT.  This function checks if these operations are supported\n+   by the target platform either directly (via vector tree-codes), or via\n+   target builtins.\n \n    Output:\n    - CODE1 and CODE2 are codes of vector operations to be used when \n@@ -1815,6 +1815,7 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n       break;\n \n     case NOP_EXPR:\n+    case CONVERT_EXPR:\n       if (BYTES_BIG_ENDIAN)\n         {\n           c1 = VEC_UNPACK_HI_EXPR;\n@@ -1827,6 +1828,19 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n         }\n       break;\n \n+    case FLOAT_EXPR:\n+      if (BYTES_BIG_ENDIAN)\n+        {\n+          c1 = VEC_UNPACK_FLOAT_HI_EXPR;\n+          c2 = VEC_UNPACK_FLOAT_LO_EXPR;\n+        }\n+      else\n+        {\n+          c2 = VEC_UNPACK_FLOAT_HI_EXPR;\n+          c1 = VEC_UNPACK_FLOAT_LO_EXPR;\n+        }\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -1851,6 +1865,63 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n }\n \n \n+/* Function supportable_narrowing_operation\n+\n+   Check whether an operation represented by the code CODE is a \n+   narrowing operation that is supported by the target platform in \n+   vector form (i.e., when operating on arguments of type VECTYPE).\n+    \n+   Narrowing operations we currently support are NOP (CONVERT) and\n+   FIX_TRUNC. This function checks if these operations are supported by\n+   the target platform directly via vector tree-codes.\n+\n+   Output:\n+   - CODE1 is the code of a vector operation to be used when \n+   vectorizing the operation, if available.  */\n+\n+bool\n+supportable_narrowing_operation (enum tree_code code,\n+\t\t\t\t tree stmt, tree vectype,\n+\t\t\t\t enum tree_code *code1)\n+{\n+  enum machine_mode vec_mode;\n+  enum insn_code icode1;\n+  optab optab1;\n+  tree expr = GIMPLE_STMT_OPERAND (stmt, 1);\n+  tree type = TREE_TYPE (expr);\n+  tree narrow_vectype = get_vectype_for_scalar_type (type);\n+  enum tree_code c1;\n+\n+  switch (code)\n+    {\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      c1 = VEC_PACK_TRUNC_EXPR;\n+      break;\n+\n+    case FIX_TRUNC_EXPR:\n+      c1 = VEC_PACK_FIX_TRUNC_EXPR;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  *code1 = c1;\n+  optab1 = optab_for_tree_code (c1, vectype);\n+\n+  if (!optab1)\n+    return false;\n+\n+  vec_mode = TYPE_MODE (vectype);\n+  if ((icode1 = optab1->handlers[(int) vec_mode].insn_code) == CODE_FOR_nothing\n+      || insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n /* Function reduction_code_for_scalar_code\n \n    Input:"}, {"sha": "dd8e2b8ad56dd89ea276e408bf370c2404b19ee4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -398,6 +398,9 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n extern bool reduction_code_for_scalar_code (enum tree_code, enum tree_code *);\n extern bool supportable_widening_operation (enum tree_code, tree, tree,\n   tree *, tree *, enum tree_code *, enum tree_code *);\n+extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n+\t\t\t\t\t     enum tree_code *);\n+\n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n extern void destroy_loop_vec_info (loop_vec_info);"}, {"sha": "e1f5fef063e03424d3910cb132dbf94310cd01d0", "filename": "gcc/tree.def", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9987fb40780ff8900d0dca8b40ebd501c963bd5/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=d9987fb40780ff8900d0dca8b40ebd501c963bd5", "patch": "@@ -1085,20 +1085,33 @@ DEFTREECODE (GIMPLE_MODIFY_STMT, \"gimple_modify_stmt\", tcc_gimple_stmt, 2)\n DEFTREECODE (VEC_WIDEN_MULT_HI_EXPR, \"widen_mult_hi_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_WIDEN_MULT_LO_EXPR, \"widen_mult_hi_expr\", tcc_binary, 2)\n \n-/* Unpack (extract and promote/widen) the high/low elements of the input vector\n-   into the output vector. The input vector has twice as many elements\n-   as the output vector, that are half the size of the elements\n+/* Unpack (extract and promote/widen) the high/low elements of the input\n+   vector into the output vector.  The input vector has twice as many\n+   elements as the output vector, that are half the size of the elements\n    of the output vector.  This is used to support type promotion. */\n DEFTREECODE (VEC_UNPACK_HI_EXPR, \"vec_unpack_hi_expr\", tcc_unary, 1)\n DEFTREECODE (VEC_UNPACK_LO_EXPR, \"vec_unpack_lo_expr\", tcc_unary, 1)\n \n+/* Unpack (extract) the high/low elements of the input vector, convert\n+   fixed point values to floating point and widen elements into the\n+   output vector.  The input vector has twice as many elements as the output\n+   vector, that are half the size of the elements of the output vector.  */\n+DEFTREECODE (VEC_UNPACK_FLOAT_HI_EXPR, \"vec_unpack_float_hi_expr\", tcc_unary, 1)\n+DEFTREECODE (VEC_UNPACK_FLOAT_LO_EXPR, \"vec_unpack_float_lo_expr\", tcc_unary, 1)\n+\n /* Pack (demote/narrow and merge) the elements of the two input vectors\n    into the output vector using truncation/saturation.\n    The elements of the input vectors are twice the size of the elements of the\n    output vector.  This is used to support type demotion.  */\n DEFTREECODE (VEC_PACK_TRUNC_EXPR, \"vec_pack_trunc_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_PACK_SAT_EXPR, \"vec_pack_sat_expr\", tcc_binary, 2)\n \n+/* Convert floating point values of the two input vectors to integer\n+   and pack (narrow and merge) the elements into the output vector. The\n+   elements of the input vector are twice the size of the elements of\n+   the output vector.  */\n+DEFTREECODE (VEC_PACK_FIX_TRUNC_EXPR, \"vec_pack_fix_trunc_expr\", tcc_binary, 2)\n+\n /* Extract even/odd fields from vectors.  */\n DEFTREECODE (VEC_EXTRACT_EVEN_EXPR, \"vec_extracteven_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_EXTRACT_ODD_EXPR, \"vec_extractodd_expr\", tcc_binary, 2)"}]}