{"sha": "096308ba6c4b48af66c8cc3dc689f2760c024e2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk2MzA4YmE2YzRiNDhhZjY2YzhjYzNkYzY4OWYyNzYwYzAyNGUyZg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-01-02T20:00:18Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-01-02T20:00:18Z"}, "message": "PR 78534 Modify string copy to avoid -Wstringop-overflow warning\n\nWhen the character length is changed from int to size_t the existing\nalgorithm causes a -Wstringop-overflow warning with -O1 on the\ngfortran.dg/allocate_deferred_char_scalar_1.f03 testcase. This change\nis committed separately from the character length size change in order\nto make bisecting potential performance issues easier.\n\n2017-01-02  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR fortran/78534\n\t* trans-expr.c (gfc_trans_string_copy): Rework string copy\n\talgorithm to avoid -Wstringop-overflow warning.\n\nFrom-SVN: r244003", "tree": {"sha": "6098f1ffe583ce60a2d838f34ba3f577cda89e63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6098f1ffe583ce60a2d838f34ba3f577cda89e63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/096308ba6c4b48af66c8cc3dc689f2760c024e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096308ba6c4b48af66c8cc3dc689f2760c024e2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096308ba6c4b48af66c8cc3dc689f2760c024e2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096308ba6c4b48af66c8cc3dc689f2760c024e2f/comments", "author": null, "committer": null, "parents": [{"sha": "a94d23fc69de8d286f507b497e1af626771a447c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94d23fc69de8d286f507b497e1af626771a447c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94d23fc69de8d286f507b497e1af626771a447c"}], "stats": {"total": 61, "additions": 28, "deletions": 33}, "files": [{"sha": "ec209b2caf7f7712260dc5b9d31ca6db1d839ad1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096308ba6c4b48af66c8cc3dc689f2760c024e2f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096308ba6c4b48af66c8cc3dc689f2760c024e2f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=096308ba6c4b48af66c8cc3dc689f2760c024e2f", "patch": "@@ -1,3 +1,9 @@\n+2017-01-02  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/78534\n+\t* trans-expr.c (gfc_trans_string_copy): Rework string copy\n+\talgorithm to avoid -Wstringop-overflow warning.\n+\n 2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "b9c134a11d4387b6bedfe79ec458c2b8651c53c8", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096308ba6c4b48af66c8cc3dc689f2760c024e2f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096308ba6c4b48af66c8cc3dc689f2760c024e2f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=096308ba6c4b48af66c8cc3dc689f2760c024e2f", "patch": "@@ -6450,33 +6450,19 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n       return;\n     }\n \n+  /* The string copy algorithm below generates code like\n+\n+     if (dlen > 0) {\n+         memmove (dest, src, min(dlen, slen));\n+         if (slen < dlen)\n+             memset(&dest[slen], ' ', dlen - slen);\n+     }\n+  */\n+\n   /* Do nothing if the destination length is zero.  */\n   cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, dlen,\n \t\t\t  build_int_cst (size_type_node, 0));\n \n-  /* The following code was previously in _gfortran_copy_string:\n-\n-       // The two strings may overlap so we use memmove.\n-       void\n-       copy_string (GFC_INTEGER_4 destlen, char * dest,\n-                    GFC_INTEGER_4 srclen, const char * src)\n-       {\n-         if (srclen >= destlen)\n-           {\n-             // This will truncate if too long.\n-             memmove (dest, src, destlen);\n-           }\n-         else\n-           {\n-             memmove (dest, src, srclen);\n-             // Pad with spaces.\n-             memset (&dest[srclen], ' ', destlen - srclen);\n-           }\n-       }\n-\n-     We're now doing it here for better optimization, but the logic\n-     is the same.  */\n-\n   /* For non-default character kinds, we have to multiply the string\n      length by the base type size.  */\n   chartype = gfc_get_char_type (dkind);\n@@ -6499,17 +6485,19 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   else\n     src = gfc_build_addr_expr (pvoid_type_node, src);\n \n-  /* Truncate string if source is too long.  */\n-  cond2 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, slen,\n-\t\t\t   dlen);\n+  /* First do the memmove. */\n+  tmp2 = fold_build2_loc (input_location, MIN_EXPR, TREE_TYPE (dlen), dlen,\n+\t\t\t  slen);\n   tmp2 = build_call_expr_loc (input_location,\n \t\t\t      builtin_decl_explicit (BUILT_IN_MEMMOVE),\n-\t\t\t      3, dest, src, dlen);\n+\t\t\t      3, dest, src, tmp2);\n+  stmtblock_t tmpblock2;\n+  gfc_init_block (&tmpblock2);\n+  gfc_add_expr_to_block (&tmpblock2, tmp2);\n \n-  /* Else copy and pad with spaces.  */\n-  tmp3 = build_call_expr_loc (input_location,\n-\t\t\t      builtin_decl_explicit (BUILT_IN_MEMMOVE),\n-\t\t\t      3, dest, src, slen);\n+  /* If the destination is longer, fill the end with spaces.  */\n+  cond2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, slen,\n+\t\t\t   dlen);\n \n   /* Wstringop-overflow appears at -O3 even though this warning is not\n      explicitly available in fortran nor can it be switched off. If the\n@@ -6525,13 +6513,14 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   tmp4 = fill_with_spaces (tmp4, chartype, tmp);\n \n   gfc_init_block (&tempblock);\n-  gfc_add_expr_to_block (&tempblock, tmp3);\n   gfc_add_expr_to_block (&tempblock, tmp4);\n   tmp3 = gfc_finish_block (&tempblock);\n \n   /* The whole copy_string function is there.  */\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond2,\n-\t\t\t tmp2, tmp3);\n+\t\t\t tmp3, build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&tmpblock2, tmp);\n+  tmp = gfc_finish_block (&tmpblock2);\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n \t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);"}]}