{"sha": "a4dfd0f089af33f2af57bf422f9859405b9b4a16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkZmQwZjA4OWFmMzNmMmFmNTdiZjQyMmY5ODU5NDA1YjliNGExNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-24T05:55:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-26T20:00:38Z"}, "message": "c++: constexpr and empty fields [PR97566]\n\nIn the discussion of PR98463, Jakub pointed out that in C++17 and up,\ncxx_fold_indirect_ref_1 could use the field we build for an empty base.  I\ntried implementing that, but it broke one of the tuple tests, so I did some\nmore digging.\n\nTo start with, I generalized the PR98463 patch to handle the case where we\ndo have a field, for an empty base or [[no_unique_address]] member.  This is\nenough also for the no-field case because the member of the empty base must\nitself be an empty field; if it weren't, the base would not be empty.\n\nI looked for related PRs and found 97566, which was also fixed by the patch.\nAfter some poking around to figure out why, I noticed that the testcase had\nbeen breaking because E, though an empty class, has an ABI nvsize of one\nbyte, and we were giving the [[no_unique_address]] FIELD_DECL that\nDECL_SIZE, whereas in build_base_field_1 empty base fields always get\nDECL_SIZE zero, and various places were relying on that to recognize empty\nfields.  So I adjusted both the size and the checking.  When I adjusted\ncheck_bases I wondered if we were correctly handling bases with only empty\ndata members, but it appears we do.\n\nI'm deferring the cxx_fold_indirect_ref_1 change until stage 1, as I don't\nthink it actually fixes anything.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97566\n\tPR c++/98463\n\t* class.c (layout_class_type): An empty field gets size 0.\n\t(is_empty_field): New.\n\t(check_bases): Check it.\n\t* cp-tree.h (is_empty_field): Declare it.\n\t* constexpr.c (cxx_eval_store_expression): Check it.\n\t(cx_check_missing_mem_inits): Likewise.\n\t* init.c (perform_member_init): Likewise.\n\t* typeck2.c (process_init_constructor_record): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97566\n\t* g++.dg/cpp2a/no_unique_address10.C: New test.\n\t* g++.dg/cpp2a/no_unique_address9.C: New test.", "tree": {"sha": "a464db65d5d3e2c6ce5e0afe1ef258cca6a7aa0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a464db65d5d3e2c6ce5e0afe1ef258cca6a7aa0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4dfd0f089af33f2af57bf422f9859405b9b4a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dfd0f089af33f2af57bf422f9859405b9b4a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4dfd0f089af33f2af57bf422f9859405b9b4a16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dfd0f089af33f2af57bf422f9859405b9b4a16/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e80f1f6b7a339bce1db03567e497658ae32d135e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80f1f6b7a339bce1db03567e497658ae32d135e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80f1f6b7a339bce1db03567e497658ae32d135e"}], "stats": {"total": 122, "additions": 102, "deletions": 20}, "files": [{"sha": "40f5fef7baa0925f138fe0b5e9bb4acc1a7270e1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -1835,15 +1835,13 @@ check_bases (tree t,\n \t  else if (CLASSTYPE_REPEATED_BASE_P (t))\n \t    CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n \t  else\n-\t    /* ...either has no non-static data members in the most-derived\n-\t       class and at most one base class with non-static data\n-\t       members, or has no base classes with non-static data\n-\t       members.  FIXME This was reworded in DR 1813.  */\n+\t    /* ...has all non-static data members and bit-fields in the class\n+\t       and its base classes first declared in the same class.  */\n \t    for (basefield = TYPE_FIELDS (basetype); basefield;\n \t\t basefield = DECL_CHAIN (basefield))\n \t      if (TREE_CODE (basefield) == FIELD_DECL\n \t\t  && !(DECL_FIELD_IS_BASE (basefield)\n-\t\t       && integer_zerop (DECL_SIZE (basefield))))\n+\t\t       && is_empty_field (basefield)))\n \t\t{\n \t\t  if (field)\n \t\t    CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n@@ -4226,6 +4224,25 @@ field_poverlapping_p (tree decl)\n \t\t\t   DECL_ATTRIBUTES (decl));\n }\n \n+/* Return true iff DECL is an empty field, either for an empty base or a\n+   [[no_unique_address]] data member.  */\n+\n+bool\n+is_empty_field (tree decl)\n+{\n+  if (TREE_CODE (decl) != FIELD_DECL)\n+    return false;\n+\n+  bool r = (is_empty_class (TREE_TYPE (decl))\n+\t    && (DECL_FIELD_IS_BASE (decl)\n+\t\t|| field_poverlapping_p (decl)));\n+\n+  /* Empty fields should have size zero.  */\n+  gcc_checking_assert (!r || integer_zerop (DECL_SIZE (decl)));\n+\n+  return r;\n+}\n+\n /* Record all of the empty subobjects of DECL_OR_BINFO.  */\n \n static void\n@@ -6612,7 +6629,9 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  /* end_of_class doesn't always give dsize, but it does in the case of\n \t     a class with virtual bases, which is when dsize > nvsize.  */\n \t  tree dsize = end_of_class (type, /*vbases*/true);\n-\t  if (tree_int_cst_le (dsize, nvsize))\n+\t  if (CLASSTYPE_EMPTY_P (type))\n+\t    DECL_SIZE (field) = DECL_SIZE_UNIT (field) = size_zero_node;\n+\t  else if (tree_int_cst_le (dsize, nvsize))\n \t    {\n \t      DECL_SIZE_UNIT (field) = nvsize;\n \t      DECL_SIZE (field) = CLASSTYPE_SIZE (type);"}, {"sha": "baa97a0ef17769dfdb474902d55d7a40deacd0f6", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -821,7 +821,7 @@ cx_check_missing_mem_inits (tree ctype, tree body, bool complain)\n \t    /* A flexible array can't be intialized here, so don't complain\n \t       that it isn't.  */\n \t    continue;\n-\t  if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field)))\n+\t  if (is_empty_field (field))\n \t    /* An empty field doesn't need an initializer.  */\n \t    continue;\n \t  ftype = strip_array_types (ftype);\n@@ -5291,17 +5291,13 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       type = refs->pop();\n       tree index = refs->pop();\n \n-      if (TREE_CODE (index) == FIELD_DECL\n-\t  && !(same_type_ignoring_top_level_qualifiers_p\n-\t       (DECL_CONTEXT (index), TREE_TYPE (*valp))))\n-\t{\n-\t  /* INDEX isn't a member of *valp.  This can happen if it's a member\n-\t     of an empty base which isn't represented with a FIELD_DECL.  Stop\n-\t     trying to build a CONSTRUCTOR for the inner target; we'll notice\n-\t     this disconnect again below and just return init.  */\n-\t  gcc_assert (is_empty_class (DECL_CONTEXT (index)));\n-\t  break;\n-\t}\n+      if (is_empty_field (index))\n+\t/* Don't build a sub-CONSTRUCTOR for an empty base or field, as they\n+\t   have no data and might have an offset lower than previously declared\n+\t   fields, which confuses the middle-end.  The code below will notice\n+\t   that we don't have a CONSTRUCTOR for our inner target and just\n+\t   return init.  */\n+\tbreak;\n \n       if (code == UNION_TYPE && CONSTRUCTOR_NELTS (*valp)\n \t  && CONSTRUCTOR_ELT (*valp, 0)->index != index)"}, {"sha": "f31319904eb1b1d080188b1216a7beb821e2c12e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -6515,6 +6515,7 @@ extern int same_signature_p\t\t\t(const_tree, const_tree);\n extern tree lookup_vfn_in_binfo\t\t\t(tree, tree);\n extern void maybe_add_class_template_decl_list\t(tree, tree, int);\n extern void unreverse_member_declarations\t(tree);\n+extern bool is_empty_field\t\t\t(tree);\n extern void invalidate_class_lookup_cache\t(void);\n extern void maybe_note_name_used_in_class\t(tree, tree);\n extern void note_name_declared_in_class\t\t(tree, tree);"}, {"sha": "131da1a4ae40d780b7023bc0a64e6f6148fc21a9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -877,7 +877,7 @@ perform_member_init (tree member, tree init)\n \t}\n       if (init == error_mark_node)\n \treturn;\n-      if (DECL_SIZE (member) && integer_zerop (DECL_SIZE (member))\n+      if (is_empty_field (member)\n \t  && !TREE_SIDE_EFFECTS (init))\n \t/* Don't add trivial initialization of an empty base/field, as they\n \t   might not be ordered the way the back-end expects.  */"}, {"sha": "9ba2897390a2ac6c132011b034cad80de3f9e155", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -1626,7 +1626,7 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,\n \t    }\n \t}\n \n-      if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field))\n+      if (is_empty_field (field)\n \t  && !TREE_SIDE_EFFECTS (next))\n \t/* Don't add trivial initialization of an empty base/field to the\n \t   constructor, as they might not be ordered the way the back-end"}, {"sha": "cd9e8de4ad172311c85991c878f0b01d08ab56ca", "filename": "gcc/testsuite/g++.dg/cpp2a/no_unique_address10.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address10.C?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -0,0 +1,16 @@\n+// Make sure [[no_unique_address]] doesn't affect is_standard_layout.\n+// { dg-do compile { target c++11 } }\n+\n+struct E1 { }; struct E2 { };\n+struct A\n+{\n+  [[no_unique_address]] E1 e;\n+};\n+\n+struct B: A\n+{\n+  [[no_unique_address]] E2 e;\n+};\n+\n+static_assert(__is_standard_layout (A), \"\");\n+static_assert(!__is_standard_layout (B), \"\");"}, {"sha": "7837acf0ea57df255d43d1cbbb138286020f2956", "filename": "gcc/testsuite/g++.dg/cpp2a/no_unique_address9.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dfd0f089af33f2af57bf422f9859405b9b4a16/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address9.C?ref=a4dfd0f089af33f2af57bf422f9859405b9b4a16", "patch": "@@ -0,0 +1,50 @@\n+// PR c++/97566\n+// { dg-do compile { target c++14 } }\n+\n+// error disappears if E doesn't inherit from B\n+struct B {};\n+struct E : B {};\n+\n+struct counter {\n+  constexpr void inc() { size++; }\n+\n+  // error disappears if you remove or reorder this value\n+  int unused = 0;\n+  int size = 0;\n+  [[no_unique_address]] E empty = {};\n+};\n+\n+#define SA(X) static_assert((X),#X)\n+\n+constexpr int test1() {\n+  counter x;\n+  x.inc();\n+  return x.size;\n+}\n+SA(test1() == 1);\n+\n+constexpr int test2() {\n+  counter x = { 0, 1, {} };\n+  x.inc();\n+  return x.size;\n+}\n+SA(test2() == 2);\n+\n+counter y;\n+\n+struct counter2 {\n+  constexpr counter2() { inc(); }\n+  constexpr void inc() { size++; }\n+\n+  // error disappears if you remove or reorder this value\n+  int unused = 0;\n+  int size = 0;\n+  [[no_unique_address]] E empty = {};\n+};\n+\n+constexpr int test3() {\n+  counter2 x;\n+  x.inc();\n+  return x.size;\n+}\n+SA(test3() == 2);"}]}