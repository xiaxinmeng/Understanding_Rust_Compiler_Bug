{"sha": "c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyNDBiZTQ2MzBhNmI3NDQwZmUwZmQ1YmU1ZDM4MWUxNGQwZGFlNw==", "commit": {"author": {"name": "James E. Wilson", "email": "wilson@cygnus.com", "date": "2000-06-07T02:27:51Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-06-07T02:27:51Z"}, "message": "Fix gas/gcc unwind/EH discrepancies.  And a shared library build problem.\n\n\t* frame.h (struct unwind_info_ptr): Collapse version, flags, and length\n\tfields into header field.\n\t(IA64_UNW_HDR_LENGTH, IA64_UNW_HDR_FLAGS, IA64_UNW_HDR_VERSION): New\n\tmacros to access length, flags, and version info from header field.\n\t* config/ia64/crtbegin.asm (__do_frame_setup_aux): Delete here.\n\t...\n\nFrom-SVN: r34441", "tree": {"sha": "73c8dc5478aae00eb8cc397f7cd0b011add7148d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73c8dc5478aae00eb8cc397f7cd0b011add7148d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/comments", "author": null, "committer": null, "parents": [{"sha": "24c40136c3e06831cf63df58fd5faee1dbbb0d56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c40136c3e06831cf63df58fd5faee1dbbb0d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c40136c3e06831cf63df58fd5faee1dbbb0d56"}], "stats": {"total": 170, "additions": 101, "deletions": 69}, "files": [{"sha": "2f8e558fa82a2621b43f42f0f8d7c90c9554a011", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "patch": "@@ -1,3 +1,23 @@\n+2000-06-06  James E. Wilson  <wilson@cygnus.com>\n+\n+\t* frame.h (struct unwind_info_ptr): Collapse version, flags, and length\n+\tfields into header field.\n+\t(IA64_UNW_HDR_LENGTH, IA64_UNW_HDR_FLAGS, IA64_UNW_HDR_VERSION): New\n+\tmacros to access length, flags, and version info from header field.\n+\t* config/ia64/crtbegin.asm (__do_frame_setup_aux): Delete here.\n+\t* config/ia64/crtend.asm (__do_frame_setup_aux): Add here.\n+\t(__do_global_ctors_aux): Fix caller.\n+\t* config/ia64/frame-ia64.c (get_unwind_record): Change parameter\n+\tprologue_flag to header.  Pass to read_P_record.\n+\t(read_P_record): New argument header.  Implement P4 format.\n+\tMultiply P7_T_SIZE by 16.\n+\t(execute_one_ia64_descriptor): New static local region_header.  Pass to\n+\tget_unwind_record.  Copy r to region_header if r is a header record.\n+\t(print_all_records): Likewise.\n+\t(__build_ia64_frame_state): Use IA64_UNW_HDR_LENGTH.\n+\t(__get_personality, __get_except_table): Likewise.\n+\t* config/ia64/ia64.c (process_set): Do not divide offsets by 4.\n+\n 2000-06-06  Philipp Thomas  <pthomas@suse.de>\n \n         * configure.in (AC_C_INLINE): Added."}, {"sha": "3f2b2f7080a102a739f778255acae279bcf464d0", "filename": "gcc/config/ia64/crtbegin.asm", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "patch": "@@ -296,38 +296,3 @@ __do_frame_setup:\n #endif\n .weak __deregister_frame_info#\n .weak __register_frame_info#\n-\n-\t.text\n-\t.align 16\n-\t.global\t__do_frame_setup_aux#\n-\t.proc\t__do_frame_setup_aux#\n-__do_frame_setup_aux:\n-\t/*\n-\t\tif (__register_frame_info_aux)\n-\t\t  __register_frame_info_aux(__EH_FRAME_END__)\n-\t*/\n-        alloc loc0 = ar.pfs, 0, 3, 1, 0\n-        addl r14 = @ltoff(@fptr(__register_frame_info_aux#)), gp\n-        mov loc1 = b0\n-        ;;\n-\t// r16 contains the address of a pointer to __EH_FRAME_END__.\n-        ld8 out0 = [r16]\n-        ld8 r15 = [r14]\n-\tmov loc2 = gp\n-        ;;\n-        cmp.eq p6, p7 = 0, r15\n-        (p6) br.cond.dptk 1f\n-        ld8 r8 = [r15], 8\n-        ;;\n-        ld8 gp = [r15]\n-        mov b6 = r8\n-        ;;\n-        br.call.sptk.many b0 = b6\n-\t;;\n-1:\n-\tmov gp = loc2\n-        mov ar.pfs = loc0\n-        mov b0 = loc1\n-        br.ret.sptk.many b0\n-\t.endp\t__do_frame_setup#\n-.weak __register_frame_info_aux#"}, {"sha": "07b71ea5c10db5cc16f13f369fe20b4d887ccc93", "filename": "gcc/config/ia64/crtend.asm", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fcrtend.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtend.asm?ref=c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "patch": "@@ -113,7 +113,6 @@ __do_global_ctors_aux:\n \n .section .init,\"ax\",\"progbits\"\n \t{ .mlx\n-\t  // __do_frame_setup_aux is in crtbegin.asm\n \t  movl r2 = @gprel(__do_frame_setup_aux#)\n \t  ;;\n \t}\n@@ -123,12 +122,42 @@ __do_global_ctors_aux:\n \t  ;;\n \t  mov b6 = r2\n \t}\n-\t{ .mib\n-\t  // __do_frame_setup_aux needs the address of __EH_FRAME_END__,\n-\t  // so we pass it in r16.  This is rather evil, but we have no\n-\t  // output registers.\n-          addl r16 = @ltoff(__EH_FRAME_END__#), gp\n+\t{ .bbb\n \t  br.call.sptk.many b0 = b6\n \t  ;;\n         }\n \n+.text\n+\t.align 16\n+\t.proc\t__do_frame_setup_aux#\n+__do_frame_setup_aux:\n+\t/*\n+\t\tif (__register_frame_info_aux)\n+\t\t  __register_frame_info_aux(__EH_FRAME_END__)\n+\t*/\n+\talloc loc0 = ar.pfs, 0, 3, 1, 0\n+\taddl r14 = @ltoff(@fptr(__register_frame_info_aux#)), gp\n+\tmov loc1 = b0\n+\t;;\n+\tld8 r15 = [r14]\n+\taddl r16 = @ltoff(__EH_FRAME_END__#), gp\n+\tmov loc2 = gp\n+\t;;\n+\tcmp.eq p6, p7 = 0, r15\n+\t(p6) br.cond.dptk 1f\n+\tld8 r8 = [r15], 8\n+\tld8 out0 = [r16]\n+\t;;\n+\tld8 gp = [r15]\n+\tmov b6 = r8\n+\t;;\n+\tbr.call.sptk.many b0 = b6\n+\t;;\n+1:\n+\tmov gp = loc2\n+\tmov ar.pfs = loc0\n+\tmov b0 = loc1\n+\tbr.ret.sptk.many b0\n+\t.endp\t__do_frame_setup_aux#\n+\n+.weak __register_frame_info_aux#"}, {"sha": "4ff78dd4a4dcdd0ac84138bea0274be165c8a27a", "filename": "gcc/config/ia64/frame-ia64.c", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fframe-ia64.c?ref=c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "patch": "@@ -247,23 +247,22 @@ bad_record (ptr, offset)\n static unsigned char *read_R_record (unwind_record *, unsigned char, unsigned char *);\n static unsigned char *read_X_record (unwind_record *, unsigned char, unsigned char *);\n static unsigned char *read_B_record (unwind_record *, unsigned char, unsigned char *);\n-static unsigned char *read_P_record (unwind_record *, unsigned char, unsigned char *);\n+static unsigned char *read_P_record (unwind_record *, unsigned char, unsigned char *, unwind_record *);\n \n \n /* This routine will determine what type of record the memory pointer\n    is refering to, and fill in the appropriate fields for that record type. \n-   PROLOGUE_FLAG is TRUE if we are currently processing a PROLOGUE\n-   body. \n+   HEADER is a pointer to the last region header unwind record.\n    DATA is a pointer to an unwind record which will be filled in.\n    PTR is a pointer to the current location in the unwind table where we\n    will read the next record from.  \n    The return value is the start of the next record.  */\n \n extern unsigned char *\n-get_unwind_record (prologue_flag, data, ptr)\n-    int prologue_flag;\n-    unwind_record *data;\n-    unsigned char *ptr;\n+get_unwind_record (header, data, ptr)\n+     unwind_record *header;\n+     unwind_record *data;\n+     unsigned char *ptr;\n {\n   unsigned char val = *ptr++;\n \n@@ -275,8 +274,8 @@ get_unwind_record (prologue_flag, data, ptr)\n   if (val == UNW_X1 || val == UNW_X2 || val == UNW_X3 || val == UNW_X4)\n     return read_X_record (data, val, ptr);\n \n-  if (prologue_flag)\n-    return read_P_record (data, val, ptr);\n+  if (header->type != body)\n+    return read_P_record (data, val, ptr, header);\n   else\n     return read_B_record (data, val, ptr);\n }\n@@ -534,10 +533,11 @@ static unsigned char P8_additional_fields [] = {\n \n \n static unsigned char *\n-read_P_record (data, val, ptr)\n+read_P_record (data, val, ptr, header)\n      unwind_record *data;\n      unsigned char val;\n      unsigned char *ptr;\n+     unwind_record *header;\n {\n   if ((val & 0xe0) == 0x80)\n     {\n@@ -575,13 +575,12 @@ read_P_record (data, val, ptr)\n \n   if (val == UNW_P4)\n     {\n-      /* P4 format.  Currently unimplemented.  */\n-      int len = 0;  /* TODO.. get prologue rlen. */\n-      int size = (len * 2 + 7) / 8;\n+      /* P4 format.  */\n+      int size = (header->record.r.rlen * 2 + 7) / 8;\n \n       data->type = spill_mask;\n       data->record.p.imask = (unsigned char *) malloc (size);\n-      /* memcpy (data->record.p.imask, ptr, size);  */\n+      memcpy (data->record.p.imask, ptr, size);\n       return ptr+size;\n     }\n \n@@ -617,7 +616,7 @@ read_P_record (data, val, ptr)\n         {\n \t  case P7_T_SIZE:\n \t    data->record.p.t = read_uleb128 (&ptr);\n-\t    data->record.p.size = read_uleb128 (&ptr);\n+\t    data->record.p.size = read_uleb128 (&ptr) << 4;\n \t    break;\n \t  case P7_T:\n \t    data->record.p.t = read_uleb128 (&ptr);\n@@ -733,11 +732,14 @@ execute_one_ia64_descriptor (addr, frame, len)\n      long *len;\n {\n   unwind_record r;\n+  /* The last region_header.  Needed to distinguish between prologue and body\n+     descriptors.  Also needed for length of P4 format.  */\n+  static unwind_record region_header;\n   ia64_reg_loc *loc_ptr = NULL;\n   int grmask = 0, frmask = 0;\n \n   *len = -1;\n-  addr = get_unwind_record (1, &r, addr);\n+  addr = get_unwind_record (&region_header, &r, addr);\n \n   /* process it in 2 phases, the first phase will either do the work,\n      or set up a pointer to the records we care about \n@@ -748,6 +750,7 @@ execute_one_ia64_descriptor (addr, frame, len)\n       case prologue:\n       case body:\n \t*len = r.record.r.rlen;\n+\tmemcpy (&region_header, &r, sizeof (unwind_record));\n \tbreak;\n       case prologue_gr:\n         {\n@@ -780,6 +783,7 @@ execute_one_ia64_descriptor (addr, frame, len)\n \t      frame->pr.loc_type  = IA64_UNW_LOC_TYPE_GR;\n \t      frame->pr.l.regno = reg++;\n \t    }\n+\t  memcpy (&region_header, &r, sizeof (unwind_record));\n \t  break;\n \t}\n       case mem_stack_f:\n@@ -1312,7 +1316,7 @@ __build_ia64_frame_state (pc, frame, bsp, pc_base_ptr)\n   start_pc = pc_base + entry->start_offset;\n   unw_info_ptr = ((struct unwind_info_ptr *)(pc_base + entry->unwind_offset));\n   addr = unw_info_ptr->unwind_descriptors;\n-  end = addr + unw_info_ptr->length * 8;\n+  end = addr + IA64_UNW_HDR_LENGTH (unw_info_ptr->header) * 8;\n   pc_offset = (pc - start_pc) / 16 * 3;\n \n   init_ia64_unwind_frame (frame);\n@@ -1345,7 +1349,8 @@ __get_personality (ptr)\n      unwind_info_ptr *ptr;\n {\n   void **p;\n-  p = (void **) (ptr->unwind_descriptors + ptr->length * 8);\n+  p = (void **) (ptr->unwind_descriptors\n+\t\t + IA64_UNW_HDR_LENGTH (ptr->header) * 8);\n   return *p;\n }\n \n@@ -1354,11 +1359,13 @@ __get_except_table (ptr)\n      unwind_info_ptr *ptr;\n {\n   void **p, *table;\n-  p = (void **) (ptr->unwind_descriptors + ptr->length * 8);\n+  p = (void **) (ptr->unwind_descriptors\n+\t\t + IA64_UNW_HDR_LENGTH (ptr->header) * 8);\n   /* If there is no personality, there is no handler data.  */\n   if (*p == 0)\n     return 0;\n-  table = (void *) (ptr->unwind_descriptors + ptr->length * 8 + 8);\n+  table = (void *) (ptr->unwind_descriptors\n+\t\t    + IA64_UNW_HDR_LENGTH (ptr->header) * 8 + 8);\n   return table;\n }\n \n@@ -1595,12 +1602,23 @@ print_all_records (f, mem, size)\n {\n   unsigned char *end = mem + size;\n   unwind_record r;\n+  static unwind_record region_header;\n \n   fprintf (f, \"UNWIND IMAGE:\\n\");\n   while (mem < end) \n     {\n-      mem = get_unwind_record (1, &r, mem);\n+      mem = get_unwind_record (&region_header, &r, mem);\n       print_record (f, &r);\n+      switch (r.type)\n+\t{\n+\tcase prologue:\n+\tcase body:\n+\tcase prologue_gr:\n+\t  memcpy (region_header, r, sizeof (unwind_record));\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n     }\n   fprintf (f, \"--end unwind image--\\n\\n\");\n }"}, {"sha": "e9eade30b93c0e7b42067370ff539a0b9fa0be28", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "patch": "@@ -3117,8 +3117,7 @@ process_set (asm_out_file, pat)\n \t      if (!spill_offset_emitted)\n \t        {\n \t\t  fprintf (asm_out_file, \"\\t.spill %d\\n\",\n-/*\t\t\t   (frame_size + 16 - spill_offset ) / 4); */\n-\t\t\t   (-(spill_offset - 8) + 16) / 4);\n+\t\t\t   (-(spill_offset - 8) + 16));\n \t\t  spill_offset_emitted = 1;\n \t\t}\n \t    }\n@@ -3138,10 +3137,10 @@ process_set (asm_out_file, pat)\n \t\t  /* register 9 is ar.unat.  */\n \t\t  if (tmp_saved == 9)\n \t\t    fprintf (asm_out_file, \"\\t.savesp ar.unat, %d\\n\",\n-\t\t\t     (sp_offset - 8) / 4);\n+\t\t\t     (sp_offset - 8));\n \t\t  else if (tmp_saved == 5)\n \t\t    fprintf (asm_out_file, \"\\t.savesp pr, %d\\n\",\n-\t\t\t     (sp_offset - 8) / 4);\n+\t\t\t     (sp_offset - 8));\n \t\t  else if (tmp_saved >= BR_REG (1) && tmp_saved <= BR_REG (5))\n \t\t    {\n \t\t      /* BR regs are saved this way too.  */"}, {"sha": "85c5e436d5b93a4bf988a4f28121fd1dadbbe134", "filename": "gcc/frame.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fframe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0240be4630a6b7440fe0fd5be5d381e14d0dae7/gcc%2Fframe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.h?ref=c0240be4630a6b7440fe0fd5be5d381e14d0dae7", "patch": "@@ -256,12 +256,13 @@ typedef struct ia64_frame_state\n \n typedef struct unwind_info_ptr \n {\n-  unsigned short version;\n-  unsigned short flags;\n-  unsigned int length;\n+  unsigned long header; /* version, flags, & length */\n   unsigned char unwind_descriptors[1];\n } unwind_info_ptr;\n \n+#define IA64_UNW_HDR_LENGTH(x)\t((x) & 0x00000000ffffffffUL)\n+#define IA64_UNW_HDR_FLAGS(x)\t(((x) >> 32) & 0xffffUL)\n+#define IA64_UNW_HDR_VERSION(x)\t(((x) >> 48) & 0xffffUL)\n \n extern unwind_info_ptr *__build_ia64_frame_state (unsigned char *, \n \t\t\t\t\t\t  ia64_frame_state *, void *,"}]}