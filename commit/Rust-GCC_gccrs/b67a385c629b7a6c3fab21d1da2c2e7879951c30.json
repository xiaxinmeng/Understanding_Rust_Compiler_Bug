{"sha": "b67a385c629b7a6c3fab21d1da2c2e7879951c30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3YTM4NWM2MjliN2E2YzNmYWIyMWQxZGEyYzJlNzg3OTk1MWMzMA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:07:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:07:13Z"}, "message": "sem_ch4.adb (Try_Primitive_Operation): Code cleanup to ensure that we generate the same errors compiling under -gnatc.\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch4.adb (Try_Primitive_Operation): Code cleanup to ensure that we\n\tgenerate the same errors compiling under -gnatc.\n\t(Try_Object_Operation): If no candidate interpretation succeeds, but\n\tthere is at least one primitive operation with the right name, report\n\terror in call rather than on a malformed selected component.\n\t(Analyze_Selected_Component): If the prefix is an incomplete type from\n\ta limited view, and the full view is available, use the full view to\n\tdetermine whether this is a prefixed call to a primitive operation.\n\t(Operator_Check): Verify that a candidate interpretation is a binary\n\toperation before checking the type of its second formal.\n\t(Analyze_Call): Add additional warnings for function call contexts not\n\tyet supported.\n\t(Analyze_Allocator): Move the check for \"initialization not allowed for\n\tlimited types\" after analyzing the expression. This is necessary,\n\tbecause OK_For_Limited_Init looks at the structure of the expression.\n\tBefore analysis, we don't necessarily know what sort of expression it\n\tis. For example, we don't know whether F(X) is a function call or an\n\tindexed component; the former is legal in Ada 2005; the latter is not.\n\t(Analyze_Allocator): Correct code for AI-287 -- extension aggregates\n\twere missing. We also didn't handle qualified expressions. Now also\n\tallow function calls. Use new common routine OK_For_Limited_Init.\n\t(Analyze_Type_Conversion): Do not perform some legality checks in an\n\tinstance, because the error message will be redundant or spurious.\n\t(Analyze_Overloaded_Selected_Component): Do not do style check when\n\tsetting an entity, since we do not know it is the right entity yet.\n\t(Analyze_Selected_Component): Move Generate_Reference call to Sem_Res\n\t(Analyze_Overloaded_Selected_Component): Same change\n\t(Analyze_Selected_Component): Remove unnecessary prefix type retrieval\n\tsince regular incomplete subtypes are transformed into corresponding\n\tsubtypes of their full views.\n\t(Complete_Object_Operation): Treat name of transformed subprogram call\n\tas coming from source, for browsing purposes.\n\t(Try_Primitive_Operation): If formal is an access parameter, compare\n\twith base type of object to determine whether it is a primitive\n\toperation.\n\t(Operator_Check): If no interpretation of the operator matches, check\n\twhether a use clause on any candidate might make the operation legal.\n\t(Try_Class_Wide_Operation): Check whether the first parameter is an\n\taccess type whose designated type is class-wide.\n\nFrom-SVN: r118302", "tree": {"sha": "1871b0662cc5ad20169a149435da0fc7989acdb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1871b0662cc5ad20169a149435da0fc7989acdb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b67a385c629b7a6c3fab21d1da2c2e7879951c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67a385c629b7a6c3fab21d1da2c2e7879951c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67a385c629b7a6c3fab21d1da2c2e7879951c30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67a385c629b7a6c3fab21d1da2c2e7879951c30/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affbee12f4cd5c6eefd53f78dca2f2db313a06b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/affbee12f4cd5c6eefd53f78dca2f2db313a06b7"}], "stats": {"total": 255, "additions": 191, "deletions": 64}, "files": [{"sha": "6d8e81ef94f3eb47783f47d11157d48cf80519a9", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 191, "deletions": 64, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67a385c629b7a6c3fab21d1da2c2e7879951c30/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67a385c629b7a6c3fab21d1da2c2e7879951c30/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b67a385c629b7a6c3fab21d1da2c2e7879951c30", "patch": "@@ -41,11 +41,11 @@ with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -298,9 +298,7 @@ package body Sem_Ch4 is\n    --  Start of processing for Ambiguous_Operands\n \n    begin\n-      if Nkind (N) = N_In\n-        or else Nkind (N) = N_Not_In\n-      then\n+      if Nkind (N) in N_Membership_Test then\n          Error_Msg_N (\"ambiguous operands for membership\",  N);\n \n       elsif Nkind (N) = N_Op_Eq\n@@ -341,7 +339,7 @@ package body Sem_Ch4 is\n    procedure Analyze_Allocator (N : Node_Id) is\n       Loc      : constant Source_Ptr := Sloc (N);\n       Sav_Errs : constant Nat        := Serious_Errors_Detected;\n-      E        : Node_Id            := Expression (N);\n+      E        : Node_Id             := Expression (N);\n       Acc_Type : Entity_Id;\n       Type_Id  : Entity_Id;\n \n@@ -357,27 +355,18 @@ package body Sem_Ch4 is\n          Check_Fully_Declared (Type_Id, N);\n          Set_Directly_Designated_Type (Acc_Type, Type_Id);\n \n+         Analyze_And_Resolve (Expression (E), Type_Id);\n+\n          if Is_Limited_Type (Type_Id)\n            and then Comes_From_Source (N)\n            and then not In_Instance_Body\n          then\n-            --  Ada 2005 (AI-287): Do not post an error if the expression\n-            --  corresponds to a limited aggregate. Limited aggregates\n-            --  are checked in sem_aggr in a per-component manner\n-            --  (compare with handling of Get_Value subprogram).\n-\n-            if Ada_Version >= Ada_05\n-              and then Nkind (Expression (E)) = N_Aggregate\n-            then\n-               null;\n-            else\n+            if not OK_For_Limited_Init (Expression (E)) then\n                Error_Msg_N (\"initialization not allowed for limited types\", N);\n                Explain_Limited_Type (Type_Id, N);\n             end if;\n          end if;\n \n-         Analyze_And_Resolve (Expression (E), Type_Id);\n-\n          --  A qualified expression requires an exact match of the type,\n          --  class-wide matching is not allowed.\n \n@@ -928,6 +917,26 @@ package body Sem_Ch4 is\n \n          End_Interp_List;\n       end if;\n+\n+      --  Check for not-yet-implemented cases of AI-318.\n+      --  We only need to check for inherently limited types,\n+      --  because other limited types will be returned by copy,\n+      --  which works just fine.\n+\n+      if Ada_Version >= Ada_05\n+        and then not Debug_Flag_Dot_L\n+        and then Is_Inherently_Limited_Type (Etype (N))\n+        and then (Nkind (Parent (N)) = N_Selected_Component\n+                  or else Nkind (Parent (N)) = N_Indexed_Component\n+                  or else Nkind (Parent (N)) = N_Slice\n+                  or else Nkind (Parent (N)) = N_Attribute_Reference\n+                  or else Nkind (Parent (N)) = N_Component_Declaration\n+                  or else Nkind (Parent (N)) = N_Formal_Object_Declaration\n+                  or else Nkind (Parent (N)) = N_Generic_Association)\n+      then\n+         Error_Msg_N (\"(Ada 2005) limited function call in this context\" &\n+                      \" is not yet implemented\", N);\n+      end if;\n    end Analyze_Call;\n \n    ---------------------------\n@@ -2333,9 +2342,7 @@ package body Sem_Ch4 is\n                if Chars (Comp) = Chars (Sel)\n                  and then Is_Visible_Component (Comp)\n                then\n-                  Set_Entity_With_Style_Check (Sel, Comp);\n-                  Generate_Reference (Comp, Sel);\n-\n+                  Set_Entity (Sel, Comp);\n                   Set_Etype (Sel, Etype (Comp));\n                   Add_One_Interp (N, Etype (Comp), Etype (Comp));\n \n@@ -2610,6 +2617,18 @@ package body Sem_Ch4 is\n          end if;\n \n          Prefix_Type := Designated_Type (Prefix_Type);\n+\n+         --  (Ada 2005): if the prefix is the limited view of a type, and\n+         --  the context already includes the full view, use the full view\n+         --  in what follows, either to retrieve a component of to find\n+         --  a primitive operation.\n+\n+         if Is_Incomplete_Type (Prefix_Type)\n+           and then From_With_Type (Prefix_Type)\n+           and then Present (Non_Limited_View (Prefix_Type))\n+         then\n+            Prefix_Type := Non_Limited_View (Prefix_Type);\n+         end if;\n       end if;\n \n       if Ekind (Prefix_Type) = E_Private_Subtype then\n@@ -2661,8 +2680,6 @@ package body Sem_Ch4 is\n               and then Is_Visible_Component (Comp)\n             then\n                Set_Entity_With_Style_Check (Sel, Comp);\n-               Generate_Reference (Comp, Sel);\n-\n                Set_Etype (Sel, Etype (Comp));\n \n                if Ekind (Comp) = E_Discriminant then\n@@ -2687,19 +2704,22 @@ package body Sem_Ch4 is\n \n                Resolve (Name);\n \n-               --  Ada 2005 (AI-50217): Check wrong use of incomplete type.\n+               --  Ada 2005 (AI-50217): Check wrong use of incomplete types or\n+               --  subtypes in a package specification.\n                --  Example:\n \n                --    limited with Pkg;\n                --    package Pkg is\n                --       type Acc_Inc is access Pkg.T;\n                --       X : Acc_Inc;\n-               --       N : Natural := X.all.Comp; -- ERROR\n-               --    end Pkg;\n+               --       N : Natural := X.all.Comp;  --  ERROR, limited view\n+               --    end Pkg;                       --  Comp is not visible\n \n                if Nkind (Name) = N_Explicit_Dereference\n                  and then From_With_Type (Etype (Prefix (Name)))\n                  and then not Is_Potentially_Use_Visible (Etype (Name))\n+                 and then Nkind (Parent (Cunit_Entity (Current_Sem_Unit))) =\n+                            N_Package_Specification\n                then\n                   Error_Msg_NE\n                     (\"premature usage of incomplete}\", Prefix (Name),\n@@ -3182,6 +3202,15 @@ package body Sem_Ch4 is\n       if not Comes_From_Source (N) then\n          return;\n \n+      --  If there was an error in a generic unit, no need to replicate the\n+      --  error message. Conversely, constant-folding in the generic may\n+      --  transform the argument of a conversion into a string literal, which\n+      --  is legal. Therefore the following tests are not performed in an\n+      --  instance.\n+\n+      elsif In_Instance then\n+         return;\n+\n       elsif Nkind (Expr) = N_Null then\n          Error_Msg_N (\"argument of conversion cannot be null\", N);\n          Error_Msg_N (\"\\use qualified expression instead\", N);\n@@ -4372,8 +4401,9 @@ package body Sem_Ch4 is\n \n       if Etype (N) = Any_Type then\n          declare\n-            L : Node_Id;\n-            R : Node_Id;\n+            L     : Node_Id;\n+            R     : Node_Id;\n+            Op_Id : Entity_Id := Empty;\n \n          begin\n             R := Right_Opnd (N);\n@@ -4546,11 +4576,51 @@ package body Sem_Ch4 is\n                      Error_Msg_N (\"there is no applicable operator& for}\", N);\n \n                   else\n-                     Error_Msg_N (\"invalid operand types for operator&\", N);\n+                     --  Another attempt to find a fix: one of the candidate\n+                     --  interpretations may not be use-visible. This has\n+                     --  already been checked for predefined operators, so\n+                     --  we examine only user-defined functions.\n+\n+                     Op_Id := Get_Name_Entity_Id (Chars (N));\n+\n+                     while Present (Op_Id) loop\n+                        if Ekind (Op_Id) /= E_Operator\n+                          and then Is_Overloadable (Op_Id)\n+                        then\n+                           if not Is_Immediately_Visible (Op_Id)\n+                             and then not In_Use (Scope (Op_Id))\n+                             and then not Is_Abstract (Op_Id)\n+                             and then not Is_Hidden (Op_Id)\n+                             and then Ekind (Scope (Op_Id)) = E_Package\n+                             and then\n+                               Has_Compatible_Type\n+                                 (L, Etype (First_Formal (Op_Id)))\n+                             and then Present\n+                              (Next_Formal (First_Formal (Op_Id)))\n+                             and then\n+                               Has_Compatible_Type\n+                                 (R,\n+                                  Etype (Next_Formal (First_Formal (Op_Id))))\n+                           then\n+                              Error_Msg_N\n+                                (\"No legal interpretation for operator&\", N);\n+                              Error_Msg_NE\n+                                (\"\\use clause on& would make operation legal\",\n+                                   N, Scope (Op_Id));\n+                              exit;\n+                           end if;\n+                        end if;\n \n-                     if Nkind (N) /= N_Op_Concat then\n-                        Error_Msg_NE (\"\\left operand has}!\",  N, Etype (L));\n-                        Error_Msg_NE (\"\\right operand has}!\", N, Etype (R));\n+                        Op_Id := Homonym (Op_Id);\n+                     end loop;\n+\n+                     if No (Op_Id) then\n+                        Error_Msg_N (\"invalid operand types for operator&\", N);\n+\n+                        if Nkind (N) /= N_Op_Concat then\n+                           Error_Msg_NE (\"\\left operand has}!\",  N, Etype (L));\n+                           Error_Msg_NE (\"\\right operand has}!\", N, Etype (R));\n+                        end if;\n                      end if;\n                   end if;\n                end if;\n@@ -4913,15 +4983,21 @@ package body Sem_Ch4 is\n    --------------------------\n \n    function Try_Object_Operation (N : Node_Id) return Boolean is\n-      K               : constant Node_Kind  := Nkind (Parent (N));\n-      Loc             : constant Source_Ptr := Sloc (N);\n-      Is_Subprg_Call  : constant Boolean    := K = N_Procedure_Call_Statement\n-                                                or else K = N_Function_Call;\n-      Obj             : constant Node_Id    := Prefix (N);\n-      Subprog         : constant Node_Id    := Selector_Name (N);\n+      K              : constant Node_Kind  := Nkind (Parent (N));\n+      Loc            : constant Source_Ptr := Sloc (N);\n+      Candidate      : Entity_Id := Empty;\n+      Is_Subprg_Call : constant Boolean    := K = N_Procedure_Call_Statement\n+                                               or else K = N_Function_Call;\n+      Obj            : constant Node_Id    := Prefix (N);\n+      Subprog        : constant Node_Id    := Selector_Name (N);\n+      Success        : Boolean := False;\n+\n+      Report_Error : Boolean := False;\n+      --  If no candidate interpretation matches the context, redo the\n+      --  analysis with error enabled to provide additional information.\n \n       Actual          : Node_Id;\n-      New_Call_Node  :  Node_Id := Empty;\n+      New_Call_Node   : Node_Id := Empty;\n       Node_To_Replace : Node_Id;\n       Obj_Type        : Entity_Id := Etype (Obj);\n \n@@ -4971,6 +5047,12 @@ package body Sem_Ch4 is\n          First_Actual := First (Parameter_Associations (Call_Node));\n          Set_Name (Call_Node, Subprog);\n \n+         --  For cross-reference purposes, treat the new node as being in\n+         --  the source if the original one is.\n+\n+         Set_Comes_From_Source (Subprog, Comes_From_Source (N));\n+         Set_Comes_From_Source (Call_Node, Comes_From_Source (N));\n+\n          if Nkind (N) = N_Selected_Component\n            and then not Inside_A_Generic\n          then\n@@ -5111,32 +5193,37 @@ package body Sem_Ch4 is\n          Node_To_Replace : Node_Id) return Boolean\n       is\n          Anc_Type : Entity_Id;\n+         Cls_Type : Entity_Id;\n          Hom      : Entity_Id;\n          Hom_Ref  : Node_Id;\n          Success  : Boolean;\n \n       begin\n          --  Loop through ancestor types, traverse the homonym chain of the\n          --  subprogram, and try out those homonyms whose first formal has the\n-         --  class-wide type of the ancestor.\n-\n-         --  Should we verify that it is declared in the same package as the\n-         --  ancestor type ???\n+         --  class-wide type of the ancestor, or an access type to it.\n \n          Anc_Type := Obj_Type;\n \n          loop\n+            Cls_Type := Class_Wide_Type (Anc_Type);\n+\n             Hom := Current_Entity (Subprog);\n             while Present (Hom) loop\n                if (Ekind (Hom) = E_Procedure\n                      or else\n                    Ekind (Hom) = E_Function)\n+                 and then Scope (Hom) = Scope (Anc_Type)\n                  and then Present (First_Formal (Hom))\n-                 and then Etype (First_Formal (Hom)) =\n-                            Class_Wide_Type (Anc_Type)\n+                 and then\n+                   (Etype (First_Formal (Hom)) = Cls_Type\n+                     or else\n+                       (Is_Access_Type (Etype (First_Formal (Hom)))\n+                          and then\n+                            Designated_Type (Etype (First_Formal (Hom))) =\n+                                                                 Cls_Type))\n                then\n                   Hom_Ref := New_Reference_To (Hom, Sloc (Subprog));\n-\n                   Set_Etype (Call_Node, Any_Type);\n                   Set_Parent (Call_Node, Parent (Node_To_Replace));\n \n@@ -5145,7 +5232,7 @@ package body Sem_Ch4 is\n                   Analyze_One_Call\n                     (N          => Call_Node,\n                      Nam        => Hom,\n-                     Report     => False,\n+                     Report     => Report_Error,\n                      Success    => Success,\n                      Skip_First => True);\n \n@@ -5218,15 +5305,15 @@ package body Sem_Ch4 is\n \n               or else\n                 (Ekind (Typ) = E_Anonymous_Access_Type\n-                  and then Designated_Type (Typ) = Obj_Type);\n+                  and then Designated_Type (Typ) = Base_Type (Obj_Type));\n          end Valid_First_Argument_Of;\n \n       --  Start of processing for Try_Primitive_Operation\n \n       begin\n          --  Look for subprograms in the list of primitive operations\n-         --  The name must be identical, and the kind of call indicates\n-         --  the expected kind of operation (function or procedure).\n+         --  The name must be identical, and the kind of call indicates the\n+         --  expected kind of operation (function or procedure).\n \n          Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n          while Present (Elmt) loop\n@@ -5239,21 +5326,22 @@ package body Sem_Ch4 is\n                  (Nkind (Call_Node) = N_Function_Call)\n                    = (Ekind (Prim_Op) = E_Function)\n             then\n-               --  If this primitive operation corresponds with an immediate\n-               --  ancestor interface there is no need to add it to the list\n-               --  of interpretations; the corresponding aliased primitive is\n-               --  also in this list of primitive operations and will be\n-               --  used instead.\n+               --  Ada 2005 (AI-251): If this primitive operation corresponds\n+               --  with an immediate ancestor interface there is no need to add\n+               --  it to the list of interpretations; the corresponding aliased\n+               --  primitive is also in this list of primitive operations and\n+               --  will be used instead.\n \n                if Present (Abstract_Interface_Alias (Prim_Op))\n-                 and then Present (DTC_Entity (Alias (Prim_Op)))\n-                 and then Etype (DTC_Entity (Alias (Prim_Op))) = RTE (RE_Tag)\n+                 and then Is_Ancestor (Find_Dispatching_Type\n+                                         (Alias (Prim_Op)), Obj_Type)\n                then\n                   goto Continue;\n                end if;\n \n                if not Success then\n                   Prim_Op_Ref := New_Reference_To (Prim_Op, Sloc (Subprog));\n+                  Candidate := Prim_Op;\n \n                   Set_Etype (Call_Node, Any_Type);\n                   Set_Parent (Call_Node, Parent (Node_To_Replace));\n@@ -5263,7 +5351,7 @@ package body Sem_Ch4 is\n                   Analyze_One_Call\n                     (N          => Call_Node,\n                      Nam        => Prim_Op,\n-                     Report     => False,\n+                     Report     => Report_Error,\n                      Success    => Success,\n                      Skip_First => True);\n \n@@ -5357,15 +5445,54 @@ package body Sem_Ch4 is\n       Set_Etype (New_Call_Node, Any_Type);\n       Set_Parent (New_Call_Node, Parent (Node_To_Replace));\n \n-      return\n-         Try_Primitive_Operation\n-           (Call_Node       => New_Call_Node,\n-            Node_To_Replace => Node_To_Replace)\n+      if Try_Primitive_Operation\n+          (Call_Node       => New_Call_Node,\n+           Node_To_Replace => Node_To_Replace)\n \n         or else\n-         Try_Class_Wide_Operation\n-           (Call_Node       => New_Call_Node,\n-            Node_To_Replace => Node_To_Replace);\n+          Try_Class_Wide_Operation\n+            (Call_Node       => New_Call_Node,\n+             Node_To_Replace => Node_To_Replace)\n+      then\n+         return True;\n+\n+      elsif Present (Candidate) then\n+\n+         --  The argument list is not type correct. Re-analyze with error\n+         --  reporting enabled, and use one of the possible candidates.\n+         --  In all_errors mode, re-analyze all failed interpretations.\n+\n+         if All_Errors_Mode then\n+            Report_Error := True;\n+            if Try_Primitive_Operation\n+                (Call_Node       => New_Call_Node,\n+                 Node_To_Replace => Node_To_Replace)\n+\n+              or else\n+                Try_Class_Wide_Operation\n+                  (Call_Node       => New_Call_Node,\n+                   Node_To_Replace => Node_To_Replace)\n+            then\n+               null;\n+            end if;\n+\n+         else\n+            Analyze_One_Call\n+              (N          => New_Call_Node,\n+               Nam        => Candidate,\n+               Report     => True,\n+               Success    => Success,\n+               Skip_First => True);\n+         end if;\n+\n+         return True;  --  No need for further errors.\n+\n+      else\n+         --  There was no candidate operation, so report it as an error\n+         --  in the caller: Analyze_Selected_Component.\n+\n+         return False;\n+      end if;\n    end Try_Object_Operation;\n \n end Sem_Ch4;"}]}