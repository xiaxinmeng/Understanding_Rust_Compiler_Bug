{"sha": "c2edc52b76c68acc7cf342c0485176902699c6e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJlZGM1MmI3NmM2OGFjYzdjZjM0MmMwNDg1MTc2OTAyNjk5YzZlNA==", "commit": {"author": {"name": "Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-10-31T12:55:36Z"}, "committer": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-10-31T12:55:36Z"}, "message": "C90 update\n\nFrom-SVN: r73140", "tree": {"sha": "5aecbb57e39e0db82ccf308f2724a6088968908b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aecbb57e39e0db82ccf308f2724a6088968908b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2edc52b76c68acc7cf342c0485176902699c6e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2edc52b76c68acc7cf342c0485176902699c6e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2edc52b76c68acc7cf342c0485176902699c6e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2edc52b76c68acc7cf342c0485176902699c6e4/comments", "author": null, "committer": null, "parents": [{"sha": "14df9585bb5d9b454f6ee76d01d138f315b22386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14df9585bb5d9b454f6ee76d01d138f315b22386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14df9585bb5d9b454f6ee76d01d138f315b22386"}], "stats": {"total": 285, "additions": 137, "deletions": 148}, "files": [{"sha": "e1cd2b4b9ea4f66ade9bdf7c5a23b4a8131f169e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2edc52b76c68acc7cf342c0485176902699c6e4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2edc52b76c68acc7cf342c0485176902699c6e4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c2edc52b76c68acc7cf342c0485176902699c6e4", "patch": "@@ -1,3 +1,7 @@\n+2003-10-31  Kelley Cook  <kcook@gcc.gnu.org>\n+\n+\t* gigi.h: Missed commit from update for C90.\n+\n 2003-10-31  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Makefile.in (ada/b_gnat1.o): Compile with -Wno-error."}, {"sha": "cf9ccb773548c303af299c9cc9b9000143a5a587", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 133, "deletions": 148, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2edc52b76c68acc7cf342c0485176902699c6e4/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2edc52b76c68acc7cf342c0485176902699c6e4/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=c2edc52b76c68acc7cf342c0485176902699c6e4", "patch": "@@ -39,42 +39,42 @@ extern unsigned int largest_move_alignment;\n /* See if DECL has an RTL that is indirect via a pseudo-register or a\n    memory location and replace it with an indirect reference if so.\n    This improves the debugger's ability to display the value.  */\n-extern void adjust_decl_rtl\tPARAMS ((tree));\n+extern void adjust_decl_rtl (tree);\n \n /* Record the current code position in GNAT_NODE.  */\n-extern void record_code_position PARAMS ((Node_Id));\n+extern void record_code_position (Node_Id);\n \n /* Insert the code for GNAT_NODE at the position saved for that node.  */\n-extern void insert_code_for\tPARAMS ((Node_Id));\n+extern void insert_code_for (Node_Id);\n \n /* Compute the alignment of the largest mode that can be used for copying\n    objects.  */\n-extern void gnat_compute_largest_alignment PARAMS ((void));\n+extern void gnat_compute_largest_alignment (void);\n \n /* Routine called by gcc for emitting a stack check. GNU_EXPR is the\n    expression that contains the last address on the stack to check. */\n-extern tree emit_stack_check    PARAMS ((tree));\n+extern tree emit_stack_check (tree);\n \n /* Make a TRANSFORM_EXPR to later expand GNAT_NODE into code.  */\n-extern tree make_transform_expr PARAMS ((Node_Id));\n+extern tree make_transform_expr (Node_Id);\n \n /* Update the setjmp buffer BUF with the current stack pointer.  We assume\n    here that a __builtin_setjmp was done to BUF.  */\n-extern void update_setjmp_buf PARAMS ((tree));\n+extern void update_setjmp_buf (tree);\n \n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n-extern int default_pass_by_ref\tPARAMS ((tree));\n+extern int default_pass_by_ref (tree);\n \n /* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n    if it should be passed by reference.  */\n-extern int must_pass_by_ref\tPARAMS ((tree));\n+extern int must_pass_by_ref (tree);\n \n /* Elaboration routines for the front end.  */\n-extern void elab_all_gnat       PARAMS ((void));\n+extern void elab_all_gnat (void);\n \n /* Initialize DUMMY_NODE_TABLE.  */\n-extern void init_dummy_type\tPARAMS ((void));\n+extern void init_dummy_type (void);\n \n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, this routine returns the equivalent GCC tree for that entity\n@@ -91,63 +91,63 @@ extern void init_dummy_type\tPARAMS ((void));\n    was not created previously.  The value of 1 is normally used for a non-zero\n    DEFINITION, but a value of 2 is used in special circumstances, defined in\n    the code.  */\n-extern tree gnat_to_gnu_entity\tPARAMS ((Entity_Id, tree, int));\n+extern tree gnat_to_gnu_entity (Entity_Id, tree, int);\n \n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n    refer to an Ada type.  */\n-extern tree gnat_to_gnu_type\tPARAMS ((Entity_Id));\n+extern tree gnat_to_gnu_type (Entity_Id);\n \n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n-extern void elaborate_entity\tPARAMS ((Entity_Id));\n+extern void elaborate_entity (Entity_Id);\n \n /* Mark GNAT_ENTITY as going out of scope at this point.  Recursively mark\n    any entities on its entity chain similarly.  */\n-extern void mark_out_of_scope\tPARAMS ((Entity_Id));\n+extern void mark_out_of_scope (Entity_Id);\n \n /* Make a dummy type corresponding to GNAT_TYPE.  */\n-extern tree make_dummy_type\tPARAMS ((Entity_Id));\n+extern tree make_dummy_type (Entity_Id);\n \n /* Get the unpadded version of a GNAT type.  */\n-extern tree get_unpadded_type\tPARAMS ((Entity_Id));\n+extern tree get_unpadded_type (Entity_Id);\n \n /* Called when we need to protect a variable object using a save_expr.  */\n-extern tree maybe_variable\tPARAMS ((tree, Node_Id));\n+extern tree maybe_variable (tree, Node_Id);\n \n /* Create a record type that contains a field of TYPE with a starting bit\n    position so that it is aligned to ALIGN bits.  */\n /* Create a record type that contains a field of TYPE with a starting bit\n    position so that it is aligned to ALIGN bits and is SIZE bytes long.  */\n-extern tree make_aligning_type\tPARAMS ((tree, int, tree));\n+extern tree make_aligning_type (tree, int, tree);\n \n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */\n-extern tree choices_to_gnu\tPARAMS ((tree, Node_Id));\n+extern tree choices_to_gnu (tree, Node_Id);\n \n /* Given a type T, a FIELD_DECL F, and a replacement value R,\n    return a new type with all size expressions that contain F\n    updated by replacing F with R.  This is identical to GCC's\n    substitute_in_type except that it knows about TYPE_INDEX_TYPE.  */\n-extern tree gnat_substitute_in_type PARAMS ((tree, tree, tree));\n+extern tree gnat_substitute_in_type (tree, tree, tree);\n \n /* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n    needed to represent the object.  */\n-extern tree rm_size\t\tPARAMS ((tree));\n+extern tree rm_size (tree);\n \n /* Given GNU_ID, an IDENTIFIER_NODE containing a name and SUFFIX, a\n    string, return a new IDENTIFIER_NODE that is the concatenation of\n    the name in GNU_ID and SUFFIX.  */\n-extern tree concat_id_with_name PARAMS ((tree, const char *));\n+extern tree concat_id_with_name (tree, const char *);\n \n /* Return the name to be used for GNAT_ENTITY.  If a type, create a\n    fully-qualified name, possibly with type information encoding.\n    Otherwise, return the name.  */\n-extern tree get_entity_name PARAMS ((Entity_Id));\n+extern tree get_entity_name (Entity_Id);\n \n /* Return a name for GNAT_ENTITY concatenated with two underscores and\n    SUFFIX.  */\n-extern tree create_concat_name PARAMS ((Entity_Id, const char *));\n+extern tree create_concat_name (Entity_Id, const char *);\n \n /* Flag indicating whether file names are discarded in exception messages */\n extern int discard_file_names;\n@@ -168,87 +168,78 @@ extern GTY(()) tree gnu_block_stack;\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n \n-extern void gigi\t\tPARAMS ((Node_Id, int, int, struct Node *,\n-\t\t\t\t\t Node_Id *, Node_Id *,\n-\t\t\t\t\t struct Elist_Header *,\n-\t\t\t\t\t struct Elmt_Item *,\n-\t\t\t\t\t struct String_Entry *,\n-\t\t\t\t\t Char_Code *,\n-\t\t\t\t\t struct List_Header *,\n-\t\t\t\t\t Int, char *,\n-\t\t\t\t\t Entity_Id, Entity_Id, Entity_Id,\n-\t\t\t\t\t Int));\n+extern void gigi (Node_Id, int, int, struct Node *, Node_Id *, Node_Id *,\n+\t\t  struct Elist_Header *, struct Elmt_Item *,\n+\t\t  struct String_Entry *, Char_Code *, struct List_Header *,\n+\t\t  Int, char *, Entity_Id, Entity_Id, Entity_Id, Int);\n \n /* This function is the driver of the GNAT to GCC tree transformation process.\n    GNAT_NODE is the root of some gnat tree.  It generates code for that\n    part of the tree.  */\n-extern void gnat_to_code\tPARAMS ((Node_Id));\n+extern void gnat_to_code (Node_Id);\n \n /* GNAT_NODE is the root of some GNAT tree.  Return the root of the\n    GCC tree corresponding to that GNAT tree.  Normally, no code is generated;\n    we just return an equivalent tree which is used elsewhere to generate\n    code.  */\n-extern tree gnat_to_gnu\t\tPARAMS ((Node_Id));\n+extern tree gnat_to_gnu (Node_Id);\n \n /* GNU_STMT is a statement.  We generate code for that statement.  */\n-extern void gnat_expand_stmt\tPARAMS ((tree));\n+extern void gnat_expand_stmt (tree);\n \n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n    make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n \n-extern void process_type\tPARAMS ((Entity_Id));\n+extern void process_type (Entity_Id);\n \n /* Determine the input_filename and the input_line from the source location\n    (Sloc) of GNAT_NODE node.  Set the global variable input_filename and\n    input_line.  If WRITE_NOTE_P is true, emit a line number note. */\n-extern void set_lineno\t\tPARAMS ((Node_Id, int));\n+extern void set_lineno (Node_Id, int);\n \n /* Likewise, but passed a Sloc.  */\n-extern void set_lineno_from_sloc PARAMS ((Source_Ptr, int));\n+extern void set_lineno_from_sloc (Source_Ptr, int);\n \n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n    \"&\" substitution.  */\n-extern void post_error\t\tPARAMS ((const char *, Node_Id));\n+extern void post_error (const char *, Node_Id);\n \n /* Similar, but NODE is the node at which to post the error and ENT\n    is the node to use for the \"&\" substitution.  */\n-extern void post_error_ne\tPARAMS ((const char *, Node_Id, Entity_Id));\n+extern void post_error_ne (const char *, Node_Id, Entity_Id);\n \n /* Similar, but NODE is the node at which to post the error, ENT is the node\n    to use for the \"&\" substitution, and N is the number to use for the ^.  */\n-extern void post_error_ne_num\tPARAMS ((const char *, Node_Id, Entity_Id,\n-\t\t\t\t\t int));\n+extern void post_error_ne_num (const char *, Node_Id, Entity_Id, int);\n \n /* Similar to post_error_ne_num, but T is a GCC tree representing the number\n    to write.  If the tree represents a constant that fits within a\n    host integer, the text inside curly brackets in MSG will be output\n    (presumably including a '^').  Otherwise that text will not be output\n    and the text inside square brackets will be output instead.  */\n-extern void post_error_ne_tree\tPARAMS ((const char *, Node_Id, Entity_Id,\n-\t\t\t\t\t tree));\n+extern void post_error_ne_tree (const char *, Node_Id, Entity_Id, tree);\n \n /* Similar to post_error_ne_tree, except that NUM is a second\n    integer to write in the message.  */\n-extern void post_error_ne_tree_2 PARAMS ((const char *, Node_Id, Entity_Id,\n-\t\t\t\t\t  tree, int));\n+extern void post_error_ne_tree_2 (const char *, Node_Id, Entity_Id, tree, int);\n \n /* Set the node for a second '&' in the error message.  */\n-extern void set_second_error_entity PARAMS ((Entity_Id));\n+extern void set_second_error_entity (Entity_Id);\n \n /* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n-extern tree protect_multiple_eval PARAMS ((tree));\n+extern tree protect_multiple_eval (tree);\n \n /* Signal abort, with \"Gigi abort\" as the error label, and error_gnat_node\n    as the relevant node that provides the location info for the error.\n    The single parameter CODE is an integer code that is included in the\n    additional error message generated. */\n-extern void gigi_abort          PARAMS ((int)) ATTRIBUTE_NORETURN;\n+extern void gigi_abort (int) ATTRIBUTE_NORETURN;\n \n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */\n-extern void init_code_table\tPARAMS ((void));\n+extern void init_code_table (void);\n \n /* Current node being treated, in case gigi_abort or Check_Elaboration_Code\n    called.  */\n@@ -258,7 +249,7 @@ extern Node_Id error_gnat_node;\n    how to handle our new nodes and we take an extra argument that says\n    whether to force evaluation of everything.  */\n \n-extern tree gnat_stabilize_reference PARAMS ((tree, int));\n+extern tree gnat_stabilize_reference (tree, int);\n \n /* Highest number in the front-end node table.  */\n extern int max_gnat_nodes;\n@@ -386,18 +377,18 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n    prototype and names as below.  */\n \n /* Returns non-zero if we are currently in the global binding level       */\n-extern int global_bindings_p\t\tPARAMS ((void));\n+extern int global_bindings_p (void);\n \n /* Returns the list of declarations in the current level. Note that this list\n    is in reverse order (it has to be so for back-end compatibility).  */\n-extern tree getdecls\t\t\tPARAMS ((void));\n+extern tree getdecls (void);\n \n /* Nonzero if the current level needs to have a BLOCK made.  */\n-extern int kept_level_p \t\tPARAMS ((void));\n+extern int kept_level_p (void);\n \n /* Enter a new binding level. The input parameter is ignored, but has to be\n    specified for back-end compatibility.  */\n-extern void pushlevel\t\t\tPARAMS ((int));\n+extern void pushlevel (int);\n \n /* Exit a binding level.\n    Pop the level off, and restore the state of the identifier-decl mappings\n@@ -413,52 +404,52 @@ extern void pushlevel\t\t\tPARAMS ((int));\n \n    If REVERSE is nonzero, reverse the order of decls before putting\n    them into the BLOCK.  */\n-extern tree poplevel\t\t\tPARAMS ((int,int, int));\n+extern tree poplevel (int, int, int);\n \n /* Insert BLOCK at the end of the list of subblocks of the\n    current binding level.  This is used when a BIND_EXPR is expanded,\n    to handle the BLOCK node inside the BIND_EXPR.  */\n-extern void insert_block\t\tPARAMS ((tree));\n+extern void insert_block (tree);\n \n /* Set the BLOCK node for the innermost scope\n    (the one we are currently in).  */\n-extern void set_block\t\t\tPARAMS ((tree));\n+extern void set_block (tree);\n \n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n    Returns the ..._DECL node. */\n-extern tree pushdecl\t\t\tPARAMS ((tree));\n+extern tree pushdecl (tree);\n \n /* Create the predefined scalar types such as `integer_type_node' needed\n    in the gcc back-end and initialize the global binding level.  */\n-extern void gnat_init_decl_processing\tPARAMS ((void));\n-extern void init_gigi_decls\t\tPARAMS ((tree, tree));\n-extern void gnat_init_gcc_eh\t\tPARAMS ((void));\n+extern void gnat_init_decl_processing (void);\n+extern void init_gigi_decls (tree, tree);\n+extern void gnat_init_gcc_eh (void);\n \n /* Return an integer type with the number of bits of precision given by\n    PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n    it is a signed type.  */\n-extern tree gnat_type_for_size\t\tPARAMS ((unsigned, int));\n+extern tree gnat_type_for_size (unsigned, int);\n \n /* Return a data type that has machine mode MODE.  UNSIGNEDP selects\n    an unsigned type; otherwise a signed type is returned.  */\n-extern tree gnat_type_for_mode\t\tPARAMS ((enum machine_mode, int));\n+extern tree gnat_type_for_mode (enum machine_mode, int);\n \n /* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_unsigned_type\t\tPARAMS ((tree));\n+extern tree gnat_unsigned_type (tree);\n \n /* Return the signed version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_signed_type\t\t\tPARAMS ((tree));\n+extern tree gnat_signed_type (tree);\n \n /* Return a type the same as TYPE except unsigned or signed according to\n    UNSIGNEDP.  */\n-extern tree gnat_signed_or_unsigned_type\tPARAMS ((int, tree));\n+extern tree gnat_signed_or_unsigned_type (int, tree);\n \n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n    conversions; callers should filter out those that are\n    not permitted by the language being compiled.  */\n-extern tree convert\t\t\tPARAMS ((tree, tree));\n+extern tree convert (tree, tree);\n \n /* Routines created solely for the tree translator's sake. Their prototypes\n    can be changed as desired.  */\n@@ -468,26 +459,26 @@ extern tree convert\t\t\tPARAMS ((tree, tree));\n    GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n    If NO_CHECK is nonzero, the latter check is suppressed.\n    If GNU_DECL is zero, a previous association is to be reset.  */\n-extern void save_gnu_tree\t\tPARAMS ((Entity_Id, tree, int));\n+extern void save_gnu_tree (Entity_Id, tree, int);\n \n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n    Return the ..._DECL node that was associated with it.  If there is no tree\n    node associated with GNAT_ENTITY, abort.  */\n-extern tree get_gnu_tree\t\tPARAMS ((Entity_Id));\n+extern tree get_gnu_tree (Entity_Id);\n \n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n-extern int present_gnu_tree\t\tPARAMS ((Entity_Id));\n+extern int present_gnu_tree (Entity_Id);\n \n /* Initialize tables for above routines.  */\n-extern void init_gnat_to_gnu\t\tPARAMS ((void));\n+extern void init_gnat_to_gnu (void);\n \n /* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL\n    nodes (FIELDLIST), finish constructing the record or union type.\n    If HAS_REP is nonzero, this record has a rep clause; don't call\n    layout_type but merely set the size and alignment ourselves.\n    If DEFER_DEBUG is nonzero, do not call the debugging routines\n    on this type; it will be done later. */\n-extern void finish_record_type\t\tPARAMS ((tree, tree, int, int));\n+extern void finish_record_type (tree, tree, int, int);\n \n /* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n    subprogram. If it is void_type_node, then we are dealing with a procedure,\n@@ -498,23 +489,21 @@ extern void finish_record_type\t\tPARAMS ((tree, tree, int, int));\n    object.  RETURNS_BY_REF is nonzero if the function returns by reference.\n    RETURNS_WITH_DSP is nonzero if the function is to return with a\n    depressed stack pointer.  */\n-extern tree create_subprog_type\t\tPARAMS ((tree, tree, tree, int, int,\n-\t\t\t\t\t\t int));\n+extern tree create_subprog_type (tree, tree, tree, int, int, int);\n \n /* Return a copy of TYPE, but safe to modify in any way.  */\n-extern tree copy_type\t\t\tPARAMS ((tree));\n+extern tree copy_type (tree);\n \n /* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n    TYPE_INDEX_TYPE is INDEX.  */\n-extern tree create_index_type\t\tPARAMS ((tree, tree, tree));\n+extern tree create_index_type (tree, tree, tree);\n \n /* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n    string) and TYPE is a ..._TYPE node giving its data type.\n    ARTIFICIAL_P is nonzero if this is a declaration that was generated\n    by the compiler.  DEBUG_INFO_P is nonzero if we need to write debugging\n    information about this type.  */\n-extern tree create_type_decl\t\tPARAMS ((tree, tree, struct attrib *,\n-\t\t\t\t\t\t int, int));\n+extern tree create_type_decl (tree, tree, struct attrib *, int, int);\n \n /* Returns a GCC VAR_DECL node. VAR_NAME gives the name of the variable.\n    ASM_NAME is its assembler name (if provided).  TYPE is\n@@ -530,51 +519,49 @@ extern tree create_type_decl\t\tPARAMS ((tree, tree, struct attrib *,\n    definition: no storage is to be allocated for the variable here).\n    STATIC_FLAG is only relevant when not at top level.  In that case\n    it indicates whether to always allocate storage to the variable.  */\n-extern tree create_var_decl\t\tPARAMS ((tree, tree, tree, tree, int,\n-\t\t\t\t\t\t int, int, int,\n-\t\t\t\t\t\t struct attrib *));\n+extern tree create_var_decl (tree, tree, tree, tree, int, int, int, int,\n+\t\t\t     struct attrib *);\n \n /* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n-extern void process_attributes\t\tPARAMS ((tree, struct attrib *));\n+extern void process_attributes (tree, struct attrib *);\n \n /* Obtain any pending elaborations and clear the old list.  */\n-extern tree get_pending_elaborations\tPARAMS ((void));\n+extern tree get_pending_elaborations (void);\n \n /* Return nonzero if there are pending elaborations.  */\n-extern int pending_elaborations_p\tPARAMS ((void));\n+extern int pending_elaborations_p (void);\n \n /* Save a copy of the current pending elaboration list and make a new\n    one.  */\n-extern void push_pending_elaborations\tPARAMS ((void));\n+extern void push_pending_elaborations (void);\n \n /* Pop the stack of pending elaborations.  */\n-extern void pop_pending_elaborations\tPARAMS ((void));\n+extern void pop_pending_elaborations (void);\n \n /* Return the current position in pending_elaborations so we can insert\n    elaborations after that point.  */\n-extern tree get_elaboration_location\tPARAMS ((void));\n+extern tree get_elaboration_location (void);\n \n /* Insert the current elaborations after ELAB, which is in some elaboration\n    list.  */\n-extern void insert_elaboration_list\tPARAMS ((tree));\n+extern void insert_elaboration_list (tree);\n \n /* Add some pending elaborations to the current list.  */\n-extern void add_pending_elaborations\tPARAMS ((tree, tree));\n+extern void add_pending_elaborations (tree, tree);\n \n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n    it is the specified size for this field.  If POS is nonzero, it is the bit\n    position.  If ADDRESSABLE is nonzero, it means we are allowed to take\n    the address of this field for aliasing purposes.  */\n-extern tree create_field_decl\t\tPARAMS ((tree, tree, tree, int,\n-\t\t\t\t\t\t tree, tree, int));\n+extern tree create_field_decl (tree, tree, tree, int, tree, tree, int);\n \n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is nonzero if the parameter is\n    readonly (either an IN parameter or an address of a pass-by-ref\n    parameter). */\n-extern tree create_param_decl\t\tPARAMS ((tree, tree, int));\n+extern tree create_param_decl (tree, tree, int);\n \n /* Returns a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n    ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n@@ -583,25 +570,25 @@ extern tree create_param_decl\t\tPARAMS ((tree, tree, int));\n \n    INLINE_FLAG, PUBLIC_FLAG, and EXTERN_FLAG are used to set the appropriate\n    fields in the FUNCTION_DECL.  */\n-extern tree create_subprog_decl\t\tPARAMS ((tree, tree, tree, tree, int,\n-\t\t\t\t\t\t int, int, struct attrib *));\n+extern tree create_subprog_decl (tree, tree, tree, tree, int, int, int, \n+\t\t\t\t struct attrib *);\n \n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n-extern tree create_label_decl\t\tPARAMS ((tree));\n+extern tree create_label_decl (tree);\n \n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n    body. This routine needs to be invoked before processing the declarations\n    appearing in the subprogram.  */\n-extern void begin_subprog_body\t\tPARAMS ((tree));\n+extern void begin_subprog_body (tree);\n \n /* Finish the definition of the current subprogram and compile it all the way\n    to assembler language output.  */\n-extern void end_subprog_body\t\tPARAMS ((void));\n+extern void end_subprog_body (void);\n \n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n    EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs.\n    Return a constructor for the template.  */\n-extern tree build_template\t\tPARAMS ((tree, tree, tree));\n+extern tree build_template (tree, tree, tree);\n \n /* Build a VMS descriptor from a Mechanism_Type, which must specify\n    a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n@@ -610,41 +597,40 @@ extern tree build_template\t\tPARAMS ((tree, tree, tree));\n    to print out an error message if the mechanism cannot be applied to\n    an object of that type and also for the name.  */\n \n-extern tree build_vms_descriptor  \tPARAMS ((tree, Mechanism_Type,\n-\t\t\t\t\t\t Entity_Id));\n+extern tree build_vms_descriptor (tree, Mechanism_Type, Entity_Id);\n \n /* Build a type to be used to represent an aliased object whose nominal\n    type is an unconstrained array.  This consists of a RECORD_TYPE containing\n    a field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an\n    ARRAY_TYPE.  If ARRAY_TYPE is that of the unconstrained array, this\n    is used to represent an arbitrary unconstrained object.  Use NAME\n    as the name of the record.  */\n-extern tree build_unc_object_type\tPARAMS ((tree, tree, tree));\n+extern tree build_unc_object_type (tree, tree, tree);\n \n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n    the normal case this is just two adjustments, but we have more to do\n    if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n-extern void update_pointer_to\t\tPARAMS ((tree, tree));\n+extern void update_pointer_to (tree, tree);\n \n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or\n    minimum (if ! MAX_P) possible value of the discriminant.  */\n-extern tree max_size\t\t\tPARAMS ((tree, int));\n+extern tree max_size (tree, int);\n \n /* Remove all conversions that are done in EXP.  This includes converting\n    from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n    is nonzero, always return the address of the containing object even if\n    the address is not bit-aligned.  */\n-extern tree remove_conversions\t\tPARAMS ((tree, int));\n+extern tree remove_conversions (tree, int);\n \n /* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n    refers to the underlying array.  If its type has TYPE_CONTAINS_TEMPLATE_P,\n    likewise return an expression pointing to the underlying array.  */\n-extern tree maybe_unconstrained_array\tPARAMS ((tree));\n+extern tree maybe_unconstrained_array (tree);\n \n /* Return an expression that does an unchecked converstion of EXPR to TYPE.\n    If NOTRUNC_P is set, truncation operations should be suppressed.  */\n-extern tree unchecked_convert\t\tPARAMS ((tree, tree, int));\n+extern tree unchecked_convert (tree, tree, int);\n \n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n@@ -658,55 +644,55 @@ extern tree unchecked_convert\t\tPARAMS ((tree, tree, int));\n    The resulting type should always be the same as the input type.\n    This function is simpler than the corresponding C version since\n    the only possible operands will be things of Boolean type.  */\n-extern tree gnat_truthvalue_conversion      PARAMS((tree));\n+extern tree gnat_truthvalue_conversion (tree);\n \n /* Return the base type of TYPE.  */\n-extern tree get_base_type\tPARAMS((tree));\n+extern tree get_base_type (tree);\n \n /* Likewise, but only return types known at Ada source.  */\n-extern tree get_ada_base_type\tPARAMS((tree));\n+extern tree get_ada_base_type (tree);\n \n /* EXP is a GCC tree representing an address.  See if we can find how\n    strictly the object at that address is aligned.   Return that alignment\n    strictly the object at that address is aligned.   Return that alignment\n    in bits.  If we don't know anything about the alignment, return 0.  */\n-extern unsigned int known_alignment\tPARAMS((tree));\n+extern unsigned int known_alignment (tree);\n \n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n    in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n    in which case the type to be used will be derived from the operands.  */\n-extern tree build_binary_op\tPARAMS((enum tree_code, tree, tree, tree));\n+extern tree build_binary_op (enum tree_code, tree, tree, tree);\n \n /* Similar, but make unary operation.   */\n-extern tree build_unary_op\tPARAMS((enum tree_code, tree, tree));\n+extern tree build_unary_op (enum tree_code, tree, tree);\n \n /* Similar, but for COND_EXPR.  */\n-extern tree build_cond_expr\tPARAMS((tree, tree, tree, tree));\n+extern tree build_cond_expr (tree, tree, tree, tree);\n \n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */\n-extern tree build_call_1_expr\tPARAMS((tree, tree));\n+extern tree build_call_1_expr (tree, tree);\n \n /* Build a CALL_EXPR to call FUNDECL with two argument, ARG1 & ARG2.  Return\n    the CALL_EXPR.  */\n-extern tree build_call_2_expr\tPARAMS((tree, tree, tree));\n+extern tree build_call_2_expr (tree, tree, tree);\n \n /* Likewise to call FUNDECL with no arguments.  */\n-extern tree build_call_0_expr\tPARAMS((tree));\n+extern tree build_call_0_expr (tree);\n \n /* Call a function that raises an exception and pass the line number and file\n    name, if requested.  MSG says which exception function to call.  */\n-extern tree build_call_raise\tPARAMS((int));\n+extern tree build_call_raise (int);\n \n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n    same as build_constructor in the language-independent tree.c.  */\n-extern tree gnat_build_constructor PARAMS((tree, tree));\n+extern tree gnat_build_constructor (tree, tree);\n \n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n    for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n-extern tree build_component_ref\tPARAMS((tree, tree, tree, int));\n+extern tree build_component_ref (tree, tree, tree, int);\n \n /* Build a GCC tree to call an allocation or deallocation function.\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n@@ -715,46 +701,45 @@ extern tree build_component_ref\tPARAMS((tree, tree, tree, int));\n    GNU_SIZE is the size of the object and ALIGN is the alignment.\n    GNAT_PROC, if present is a procedure to call and GNAT_POOL is the\n    storage pool to use.  If not preset, malloc and free will be used.  */\n-extern tree build_call_alloc_dealloc PARAMS((tree, tree, int, Entity_Id,\n-\t\t\t\t\t     Entity_Id, Node_Id));\n+extern tree build_call_alloc_dealloc (tree, tree, int, Entity_Id,\n+\t\t\t\t      Entity_Id, Node_Id);\n \n /* Build a GCC tree to correspond to allocating an object of TYPE whose\n    initial value if INIT, if INIT is nonzero.  Convert the expression to\n    RESULT_TYPE, which must be some type of pointer.  Return the tree.\n    GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n    the storage pool to use.  GNAT_NODE is used to provide an error\n    location for restriction violations messages.  */\n-extern tree build_allocator\tPARAMS((tree, tree, tree, Entity_Id,\n-\t\t\t\t\tEntity_Id, Node_Id));\n+extern tree build_allocator (tree, tree, tree, Entity_Id, Entity_Id, Node_Id);\n \n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n    GNAT_FORMAL is how we find the descriptor record.  */\n \n-extern tree fill_vms_descriptor PARAMS((tree, Entity_Id));\n+extern tree fill_vms_descriptor (tree, Entity_Id);\n \n /* Indicate that we need to make the address of EXPR_NODE and it therefore\n    should not be allocated in a register.  Return true if successful.  */\n-extern bool gnat_mark_addressable PARAMS((tree));\n+extern bool gnat_mark_addressable (tree);\n \n /* These functions return the basic data type sizes and related parameters\n    about the target machine.  */\n \n-extern Pos get_target_bits_per_unit\t\tPARAMS ((void));\n-extern Pos get_target_bits_per_word\t\tPARAMS ((void));\n-extern Pos get_target_char_size\t\t\tPARAMS ((void));\n-extern Pos get_target_wchar_t_size\t\tPARAMS ((void));\n-extern Pos get_target_short_size\t\tPARAMS ((void));\n-extern Pos get_target_int_size\t\t\tPARAMS ((void));\n-extern Pos get_target_long_size\t\t\tPARAMS ((void));\n-extern Pos get_target_long_long_size\t\tPARAMS ((void));\n-extern Pos get_target_float_size\t\tPARAMS ((void));\n-extern Pos get_target_double_size\t\tPARAMS ((void));\n-extern Pos get_target_long_double_size\t\tPARAMS ((void));\n-extern Pos get_target_pointer_size\t\tPARAMS ((void));\n-extern Pos get_target_maximum_alignment\t\tPARAMS ((void));\n-extern Boolean get_target_no_dollar_in_label\tPARAMS ((void));\n-extern Nat get_float_words_be\t\t\tPARAMS ((void));\n-extern Nat get_words_be\t\t\t\tPARAMS ((void));\n-extern Nat get_bytes_be\t\t\t\tPARAMS ((void));\n-extern Nat get_bits_be\t\t\t\tPARAMS ((void));\n-extern Nat get_strict_alignment\t\t\tPARAMS ((void));\n+extern Pos get_target_bits_per_unit (void);\n+extern Pos get_target_bits_per_word (void);\n+extern Pos get_target_char_size (void);\n+extern Pos get_target_wchar_t_size (void);\n+extern Pos get_target_short_size (void);\n+extern Pos get_target_int_size (void);\n+extern Pos get_target_long_size (void);\n+extern Pos get_target_long_long_size (void);\n+extern Pos get_target_float_size (void);\n+extern Pos get_target_double_size (void);\n+extern Pos get_target_long_double_size (void);\n+extern Pos get_target_pointer_size (void);\n+extern Pos get_target_maximum_alignment (void);\n+extern Boolean get_target_no_dollar_in_label (void);\n+extern Nat get_float_words_be (void);\n+extern Nat get_words_be (void);\n+extern Nat get_bytes_be (void);\n+extern Nat get_bits_be (void);\n+extern Nat get_strict_alignment (void);"}]}