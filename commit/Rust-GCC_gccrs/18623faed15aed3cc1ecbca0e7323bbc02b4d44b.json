{"sha": "18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg2MjNmYWVkMTVhZWQzY2MxZWNiY2EwZTczMjNiYmMwMmI0ZDQ0Yg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jblomqvi@cc.hut.fi", "date": "2005-09-26T20:24:45Z"}, "committer": {"name": "Bud Davis", "email": "bdavis@gcc.gnu.org", "date": "2005-09-26T20:24:45Z"}, "message": "[multiple changes]\n\n2005-09-24  Janne Blomqvist  <jblomqvi@cc.hut.fi>\n\n\t* trans-io.c (gfc_build_io_library_fndecls): Add entry\n\tiocall_x_array for transfer_array. (transfer_array_desc): New\n\tfunction. (gfc_trans_transfer): Add code to call\n\ttransfer_array_desc.\n\n2005-09-24  Janne Blomqvist <jblomqvi@cc.hut.fi>\n\n\t* io.h: Changed prototypes of list_formatted_{read|write}.\n\t* list_read.c (list_formatted_read): Renamed to\n\tlist_formatted_read_scalar and made static. (list_formatted_read):\n\tNew function.\n\t* transfer.c: Prototype for transfer_array. Changed transfer\n\tfunction pointer. (unformatted_read): Add nelems argument, use\n\tit. (unformatted_write): Likewise. (formatted_transfer): Changed\n\tname to formatted_transfer_scalar. (formatted_transfer): New\n\tfunction. (transfer_integer): Add nelems argument to transfer\n\tcall, move updating item count to transfer\n\tfunctions. (transfer_real): Likewise. (transfer_logical):\n\tLikewise. (transfer_character): Likewise. (transfer_complex):\n\tLikewise. (transfer_array): New function. (data_transfer_init):\n\tCall formatted_transfer with new argument. (iolength_transfer):\n\tNew argument, use it.\n\t* write.c (list_formatted_write): Renamed to\n\tlist_formatted_write_scalar, made static. (list_formatted_write):\n\tNew function.\n\nFrom-SVN: r104662", "tree": {"sha": "1d8a8fc9695ef85e44fe907a795461636d663eb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d8a8fc9695ef85e44fe907a795461636d663eb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/comments", "author": null, "committer": null, "parents": [{"sha": "d05d9ac771ec6e7f7a1f0f0417106b0c73a9943d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05d9ac771ec6e7f7a1f0f0417106b0c73a9943d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05d9ac771ec6e7f7a1f0f0417106b0c73a9943d"}], "stats": {"total": 315, "additions": 281, "deletions": 34}, "files": [{"sha": "3044bdf008a7c9e9ece9e5f93879a2d7f261ac7a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -1,3 +1,10 @@\n+2005-09-24  Janne Blomqvist  <jblomqvi@cc.hut.fi>\n+\n+\t* trans-io.c (gfc_build_io_library_fndecls): Add entry\n+\tiocall_x_array for transfer_array. (transfer_array_desc): New\n+\tfunction. (gfc_trans_transfer): Add code to call\n+\ttransfer_array_desc.\n+\n 2005-09-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/23677"}, {"sha": "2c8a9cdec28346407745c8e6967b162a1f0d94d4", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -120,6 +120,7 @@ static GTY(()) tree iocall_x_logical;\n static GTY(()) tree iocall_x_character;\n static GTY(()) tree iocall_x_real;\n static GTY(()) tree iocall_x_complex;\n+static GTY(()) tree iocall_x_array;\n static GTY(()) tree iocall_open;\n static GTY(()) tree iocall_close;\n static GTY(()) tree iocall_inquire;\n@@ -267,6 +268,12 @@ gfc_build_io_library_fndecls (void)\n \t\t\t\t     void_type_node, 2, pvoid_type_node,\n \t\t\t\t     gfc_int4_type_node);\n \n+  iocall_x_array =\n+    gfc_build_library_function_decl (get_identifier\n+\t\t\t\t     (PREFIX(\"transfer_array\")),\n+\t\t\t\t     void_type_node, 2, pvoid_type_node,\n+\t\t\t\t     gfc_charlen_type_node);\n+\n   /* Library entry points */\n \n   iocall_read =\n@@ -1584,6 +1591,27 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n }\n \n \n+/* Generate a call to pass an array descriptor to the IO library. The\n+   array should be of one of the intrinsic types.  */\n+\n+static void\n+transfer_array_desc (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n+{\n+  tree args, tmp, charlen_arg;\n+\n+  if (ts->type == BT_CHARACTER)\n+    charlen_arg = se->string_length;\n+  else\n+    charlen_arg = build_int_cstu (NULL_TREE, 0);\n+\n+  args = gfc_chainon_list (NULL_TREE, addr_expr);\n+  args = gfc_chainon_list (args, charlen_arg);\n+  tmp = gfc_build_function_call (iocall_x_array, args);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+  gfc_add_block_to_block (&se->pre, &se->post);\n+}\n+\n+\n /* gfc_trans_transfer()-- Translate a TRANSFER code node */\n \n tree\n@@ -1597,15 +1625,19 @@ gfc_trans_transfer (gfc_code * code)\n   tree tmp;\n \n   gfc_start_block (&block);\n+  gfc_init_block (&body);\n \n   expr = code->expr;\n   ss = gfc_walk_expr (expr);\n \n   gfc_init_se (&se, NULL);\n \n   if (ss == gfc_ss_terminator)\n-    gfc_init_block (&body);\n-  else\n+    {\n+      gfc_conv_expr_reference (&se, expr);\n+      transfer_expr (&se, &expr->ts, se.expr);\n+    }\n+  else if (expr->ts.type == BT_DERIVED)\n     {\n       /* Initialize the scalarizer.  */\n       gfc_init_loopinfo (&loop);\n@@ -1621,11 +1653,17 @@ gfc_trans_transfer (gfc_code * code)\n \n       gfc_copy_loopinfo_to_se (&se, &loop);\n       se.ss = ss;\n-    }\n-\n-  gfc_conv_expr_reference (&se, expr);\n \n-  transfer_expr (&se, &expr->ts, se.expr);\n+      gfc_conv_expr_reference (&se, expr);\n+      transfer_expr (&se, &expr->ts, se.expr);\n+    }\n+  else\n+    {\n+      /* Pass the array descriptor to the library.  */\n+      gfc_conv_expr_descriptor (&se, expr, ss);\n+      tmp = gfc_build_addr_expr (NULL, se.expr);\n+      transfer_array_desc (&se, &expr->ts, tmp);\n+    }\n \n   gfc_add_block_to_block (&body, &se.pre);\n   gfc_add_block_to_block (&body, &se.post);"}, {"sha": "2b27b434b0bdd26fd893ac515e076f40eddc750c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -1,3 +1,24 @@\n+2005-09-24  Janne Blomqvist <jblomqvi@cc.hut.fi>\n+\n+\t* io.h: Changed prototypes of list_formatted_{read|write}.\n+\t* list_read.c (list_formatted_read): Renamed to\n+\tlist_formatted_read_scalar and made static. (list_formatted_read):\n+\tNew function.\n+\t* transfer.c: Prototype for transfer_array. Changed transfer\n+\tfunction pointer. (unformatted_read): Add nelems argument, use\n+\tit. (unformatted_write): Likewise. (formatted_transfer): Changed\n+\tname to formatted_transfer_scalar. (formatted_transfer): New\n+\tfunction. (transfer_integer): Add nelems argument to transfer\n+\tcall, move updating item count to transfer\n+\tfunctions. (transfer_real): Likewise. (transfer_logical):\n+\tLikewise. (transfer_character): Likewise. (transfer_complex):\n+\tLikewise. (transfer_array): New function. (data_transfer_init):\n+\tCall formatted_transfer with new argument. (iolength_transfer):\n+\tNew argument, use it.\n+\t* write.c (list_formatted_write): Renamed to\n+\tlist_formatted_write_scalar, made static. (list_formatted_write):\n+\tNew function.\n+\n 2005-09-26  David Edelsohn  <dje@watson.ibm.com>\n \n \t* configure.ac: Add check for __clog."}, {"sha": "65051fafe004535eeb4658d701a1e7a93a85fa05", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -613,7 +613,7 @@ internal_proto(read_decimal);\n \n /* list_read.c */\n \n-extern void list_formatted_read (bt, void *, int);\n+extern void list_formatted_read (bt, void *, int, size_t);\n internal_proto(list_formatted_read);\n \n extern void finish_list_read (void);\n@@ -666,7 +666,7 @@ internal_proto(write_x);\n extern void write_z (fnode *, const char *, int);\n internal_proto(write_z);\n \n-extern void list_formatted_write (bt, void *, int);\n+extern void list_formatted_write (bt, void *, int, size_t);\n internal_proto(list_formatted_write);\n \n /* error.c */"}, {"sha": "c3510f6ae61743b6f3375ec232671356dd12cce9", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -1285,8 +1285,8 @@ check_type (bt type, int len)\n    reading, usually in the value[] array.  If a repeat count is\n    greater than one, we copy the data item multiple times.  */\n \n-void\n-list_formatted_read (bt type, void *p, int len)\n+static void\n+list_formatted_read_scalar (bt type, void *p, int len)\n {\n   char c;\n   int m;\n@@ -1406,6 +1406,30 @@ list_formatted_read (bt type, void *p, int len)\n     free_saved ();\n }\n \n+\n+void\n+list_formatted_read  (bt type, void *p, int len, size_t nelems)\n+{\n+  size_t elem;\n+  int size;\n+  char *tmp;\n+\n+  tmp = (char *) p;\n+\n+  if (type == BT_COMPLEX)\n+    size = 2 * len;\n+  else\n+    size = len;\n+\n+  /* Big loop over all the elements.  */\n+  for (elem = 0; elem < nelems; elem++)\n+    {\n+      g.item_count++;\n+      list_formatted_read_scalar (type, tmp + size*elem, len);\n+    }\n+}\n+\n+\n void\n init_at_eol(void)\n {"}, {"sha": "ca9246b89f7c1394173e457cb003a1f446290b9d", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 156, "deletions": 22, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -78,6 +78,9 @@ export_proto(transfer_character);\n extern void transfer_complex (void *, int);\n export_proto(transfer_complex);\n \n+extern void transfer_array (gfc_array_char *, gfc_charlen_type);\n+export_proto(transfer_array);\n+\n gfc_unit *current_unit = NULL;\n static int sf_seen_eor = 0;\n static int eor_condition = 0;\n@@ -101,7 +104,7 @@ static st_option advance_opt[] = {\n };\n \n \n-static void (*transfer) (bt, void *, int);\n+static void (*transfer) (bt, void *, int, size_t);\n \n \n typedef enum\n@@ -312,11 +315,13 @@ write_block (int length)\n /* Master function for unformatted reads.  */\n \n static void\n-unformatted_read (bt type, void *dest, int length)\n+unformatted_read (bt type, void *dest, int length, size_t nelems)\n {\n   void *source;\n   int w;\n \n+  length *= nelems;\n+\n   /* Transfer functions get passed the kind of the entity, so we have\n      to fix this for COMPLEX data which are twice the size of their\n      kind.  */\n@@ -337,17 +342,20 @@ unformatted_read (bt type, void *dest, int length)\n /* Master function for unformatted writes.  */\n \n static void\n-unformatted_write (bt type, void *source, int length)\n+unformatted_write (bt type, void *source, int length, size_t nelems)\n {\n   void *dest;\n+  size_t len;\n+\n+  len = length * nelems;\n \n   /* Correction for kind vs. length as in unformatted_read.  */\n   if (type == BT_COMPLEX)\n-    length *= 2;\n+    len *= 2;\n \n-  dest = write_block (length);\n+  dest = write_block (len);\n   if (dest != NULL)\n-    memcpy (dest, source, length);\n+    memcpy (dest, source, len);\n }\n \n \n@@ -442,7 +450,7 @@ require_type (bt expected, bt actual, fnode * f)\n    of the next element, then comes back here to process it.  */\n \n static void\n-formatted_transfer (bt type, void *p, int len)\n+formatted_transfer_scalar (bt type, void *p, int len)\n {\n   int pos, bytes_used;\n   fnode *f;\n@@ -837,6 +845,29 @@ formatted_transfer (bt type, void *p, int len)\n   unget_format (f);\n }\n \n+static void\n+formatted_transfer (bt type, void *p, int len, size_t nelems)\n+{\n+  size_t elem;\n+  int  size;\n+  char *tmp;\n+\n+  tmp = (char *) p;\n+\n+  if (type == BT_COMPLEX)\n+    size = 2 * len;\n+  else\n+    size = len;\n+\n+  /* Big loop over all the elements.  */\n+  for (elem = 0; elem < nelems; elem++)\n+    {\n+      g.item_count++;\n+      formatted_transfer_scalar (type, tmp + size*elem, len);\n+    }\n+}\n+\n+\n \n /* Data transfer entry points.  The type of the data entity is\n    implicit in the subroutine call.  This prevents us from having to\n@@ -845,50 +876,153 @@ formatted_transfer (bt type, void *p, int len)\n void\n transfer_integer (void *p, int kind)\n {\n-  g.item_count++;\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n-  transfer (BT_INTEGER, p, kind);\n+  transfer (BT_INTEGER, p, kind, 1);\n }\n \n \n void\n transfer_real (void *p, int kind)\n {\n-  g.item_count++;\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n-  transfer (BT_REAL, p, kind);\n+  transfer (BT_REAL, p, kind, 1);\n }\n \n \n void\n transfer_logical (void *p, int kind)\n {\n-  g.item_count++;\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n-  transfer (BT_LOGICAL, p, kind);\n+  transfer (BT_LOGICAL, p, kind, 1);\n }\n \n \n void\n transfer_character (void *p, int len)\n {\n-  g.item_count++;\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n-  transfer (BT_CHARACTER, p, len);\n+  transfer (BT_CHARACTER, p, len, 1);\n }\n \n \n void\n transfer_complex (void *p, int kind)\n {\n-  g.item_count++;\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n-  transfer (BT_COMPLEX, p, kind);\n+  transfer (BT_COMPLEX, p, kind, 1);\n+}\n+\n+\n+void\n+transfer_array (gfc_array_char *desc, gfc_charlen_type charlen)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0, rank, size, type, n, kind;\n+  size_t tsize;\n+  char *data;\n+  bt iotype;\n+\n+  if (ioparm.library_return != LIBRARY_OK)\n+    return;\n+\n+  type = GFC_DESCRIPTOR_TYPE (desc);\n+  size = GFC_DESCRIPTOR_SIZE (desc);\n+  kind = size;\n+\n+  /* FIXME: What a kludge: Array descriptors and the IO library use\n+     different enums for types.  */\n+  switch (type)\n+    {\n+    case GFC_DTYPE_UNKNOWN:\n+      iotype = BT_NULL;  /* Is this correct?  */\n+      break;\n+    case GFC_DTYPE_INTEGER:\n+      iotype = BT_INTEGER;\n+      break;\n+    case GFC_DTYPE_LOGICAL:\n+      iotype = BT_LOGICAL;\n+      break;\n+    case GFC_DTYPE_REAL:\n+      iotype = BT_REAL;\n+      break;\n+    case GFC_DTYPE_COMPLEX:\n+      iotype = BT_COMPLEX;\n+      kind /= 2;\n+      break;\n+    case GFC_DTYPE_CHARACTER:\n+      iotype = BT_CHARACTER;\n+      /* FIXME: Currently dtype contains the charlen, which is\n+\t clobbered if charlen > 2**24. That's why we use a separate\n+\t argument for the charlen. However, if we want to support\n+\t non-8-bit charsets we need to fix dtype to contain\n+\t sizeof(chartype) and fix the code below.  */\n+      size = charlen;\n+      kind = charlen;\n+      break;\n+    case GFC_DTYPE_DERIVED:\n+      internal_error (\"Derived type I/O should have been handled via the frontend.\");\n+      break;\n+    default:\n+      internal_error (\"transfer_array(): Bad type\");\n+    }\n+\n+  if (desc->dim[0].stride == 0)\n+    desc->dim[0].stride = 1;\n+\n+  rank = GFC_DESCRIPTOR_RANK (desc);\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = desc->dim[n].stride;\n+      extent[n] = desc->dim[n].ubound + 1 - desc->dim[n].lbound;\n+\n+      /* If the extent of even one dimension is zero, then the entire\n+\t array section contains zero elements, so we return.  */\n+      if (extent[n] == 0)\n+\treturn;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  /* If the innermost dimension has stride 1, we can do the transfer\n+     in contiguous chunks.  */\n+  if (stride0 == 1)\n+    tsize = extent[0];\n+  else\n+    tsize = 1;\n+\n+  data = GFC_DESCRIPTOR_DATA (desc);\n+\n+  while (data)\n+    {\n+      transfer (iotype, data, kind, tsize);\n+      data += stride0 * size * tsize;\n+      count[0] += tsize;\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  data -= stride[n] * extent[n] * size;\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      data = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      data += stride[n] * size;\n+\t    }\n+\t}\n+    }\n }\n \n \n@@ -1245,7 +1379,7 @@ data_transfer_init (int read_flag)\n   /* Start the data transfer if we are doing a formatted transfer.  */\n   if (current_unit->flags.form == FORM_FORMATTED && !ioparm.list_format\n       && ioparm.namelist_name == NULL && ionml == NULL)\n-    formatted_transfer (0, NULL, 0);\n+    formatted_transfer (0, NULL, 0, 1);\n }\n \n \n@@ -1568,15 +1702,15 @@ finalize_transfer (void)\n    data transfer, it just updates the length counter.  */\n \n static void\n-iolength_transfer (bt type , void *dest __attribute__ ((unused)),\n-\t\t   int len)\n+iolength_transfer (bt type, void *dest __attribute__ ((unused)),\n+\t\t   int len, size_t nelems)\n {\n   if (ioparm.iolength != NULL)\n     {\n       if (type == BT_COMPLEX)\n-\t*ioparm.iolength += 2*len;\n+\t*ioparm.iolength += 2 * len * nelems;\n       else\n-\t*ioparm.iolength += len;\n+\t*ioparm.iolength += len * nelems;\n     }\n }\n "}, {"sha": "04361345ffb757667ad3f31f831061d1fa0abafb", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18623faed15aed3cc1ecbca0e7323bbc02b4d44b/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=18623faed15aed3cc1ecbca0e7323bbc02b4d44b", "patch": "@@ -1423,8 +1423,8 @@ write_separator (void)\n    TODO: handle skipping to the next record correctly, particularly\n    with strings.  */\n \n-void\n-list_formatted_write (bt type, void *p, int len)\n+static void\n+list_formatted_write_scalar (bt type, void *p, int len)\n {\n   static int char_flag;\n \n@@ -1468,6 +1468,29 @@ list_formatted_write (bt type, void *p, int len)\n   char_flag = (type == BT_CHARACTER);\n }\n \n+\n+void\n+list_formatted_write (bt type, void *p, int len, size_t nelems)\n+{\n+  size_t elem;\n+  int size;\n+  char *tmp;\n+\n+  tmp = (char *) p;\n+\n+  if (type == BT_COMPLEX)\n+    size = 2 * len;\n+  else\n+    size = len;\n+\n+  /* Big loop over all the elements.  */\n+  for (elem = 0; elem < nelems; elem++)\n+    {\n+      g.item_count++;\n+      list_formatted_write_scalar (type, tmp + size*elem, len);\n+    }\n+}\n+\n /*\t\t\tNAMELIST OUTPUT\n \n    nml_write_obj writes a namelist object to the output stream.  It is called"}]}