{"sha": "3651c1b5c9c0960e50f00ca5b59d144b8a586b5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY1MWMxYjVjOWMwOTYwZTUwZjAwY2E1YjU5ZDE0NGI4YTU4NmI1ZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-01-14T19:12:22Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-01-14T19:12:22Z"}, "message": "calibrate intervals to avoid zero in futures poll test\n\nWe get occasional failures of 30_threads/future/members/poll.cc\non some platforms whose high resolution clock doesn't have such a high\nresolution; wait_for_0 ends up as 0, and then some asserts fail as\nintervals measured as longer than zero are tested for less than\nseveral times zero.\n\nThis patch adds some calibration in the iteration count to set a\nmeasurable base time interval with some additional margin.\n\n\nfor  libstdc++-v3/ChangeLog\n\n\t* testsuite/30_threads/future/members/poll.cc: Calibrate\n\titeration count.", "tree": {"sha": "a7ffe3633ce440ad6f17520fc12630482810a4ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7ffe3633ce440ad6f17520fc12630482810a4ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3651c1b5c9c0960e50f00ca5b59d144b8a586b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3651c1b5c9c0960e50f00ca5b59d144b8a586b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3651c1b5c9c0960e50f00ca5b59d144b8a586b5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3651c1b5c9c0960e50f00ca5b59d144b8a586b5d/comments", "author": null, "committer": null, "parents": [{"sha": "6541fcadc8622e7b4bf2e90501b51df329e51924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6541fcadc8622e7b4bf2e90501b51df329e51924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6541fcadc8622e7b4bf2e90501b51df329e51924"}], "stats": {"total": 33, "additions": 32, "deletions": 1}, "files": [{"sha": "133dae15ac47140c1321d77a9dc8eb0cc8065ee8", "filename": "libstdc++-v3/testsuite/30_threads/future/members/poll.cc", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3651c1b5c9c0960e50f00ca5b59d144b8a586b5d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3651c1b5c9c0960e50f00ca5b59d144b8a586b5d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc?ref=3651c1b5c9c0960e50f00ca5b59d144b8a586b5d", "patch": "@@ -25,7 +25,7 @@\n #include <iostream>\n #include <testsuite_hooks.h>\n \n-const int iterations = 200;\n+int iterations = 200;\n \n using namespace std;\n \n@@ -45,10 +45,41 @@ int main()\n   promise<int> p;\n   future<int> f = p.get_future();\n \n+ start_over:\n   auto start = chrono::high_resolution_clock::now();\n   for(int i = 0; i < iterations; i++)\n     f.wait_for(chrono::seconds(0));\n   auto stop = chrono::high_resolution_clock::now();\n+\n+  /* We've run too few iterations for the clock resolution.\n+     Attempt to calibrate it.  */\n+  if (start == stop)\n+    {\n+      /* Loop until the clock advances, so that start is right after a\n+\t time increment.  */\n+      do\n+\tstart = chrono::high_resolution_clock::now();\n+      while (start == stop);\n+      int i = 0;\n+      /* Now until the clock advances again, so that stop is right\n+\t after another time increment.  */\n+      do\n+\t{\n+\t  f.wait_for(chrono::seconds(0));\n+\t  stop = chrono::high_resolution_clock::now();\n+\t  i++;\n+\t}\n+      while (start == stop);\n+      /* Go for some 10 cycles, but if we're already past that and\n+\t still get into the calibration loop, double the iteration\n+\t count and try again.  */\n+      if (iterations < i * 10)\n+\titerations = i * 10;\n+      else\n+\titerations *= 2;\n+      goto start_over;\n+    }\n+\n   double wait_for_0 = print(\"wait_for(0s)\", stop - start);\n \n   start = chrono::high_resolution_clock::now();"}]}