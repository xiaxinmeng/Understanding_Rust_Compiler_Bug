{"sha": "7f4d640cd9ecf834ce2f6ab469076ddd49021374", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0ZDY0MGNkOWVjZjgzNGNlMmY2YWI0NjkwNzZkZGQ0OTAyMTM3NA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-11-06T22:51:36Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-11-06T22:51:36Z"}, "message": "Revert \"preprocessor/58580 - preprocessor goes OOM with warning for zero literals\"\n\nThis reverts commit fc3eff8854861fcd70d33d26095b17fe456fae31.\n\nFrom-SVN: r204490", "tree": {"sha": "44627b6221b370fdd68008a052a86fa6e7c16f32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44627b6221b370fdd68008a052a86fa6e7c16f32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f4d640cd9ecf834ce2f6ab469076ddd49021374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4d640cd9ecf834ce2f6ab469076ddd49021374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4d640cd9ecf834ce2f6ab469076ddd49021374", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4d640cd9ecf834ce2f6ab469076ddd49021374/comments", "author": null, "committer": null, "parents": [{"sha": "9954c743b9e985bd30194525464a0a8a64697b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9954c743b9e985bd30194525464a0a8a64697b68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9954c743b9e985bd30194525464a0a8a64697b68"}], "stats": {"total": 161, "additions": 34, "deletions": 127}, "files": [{"sha": "75603e79382f8d1f15c5f3ab147b37e89fa5abc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f4d640cd9ecf834ce2f6ab469076ddd49021374", "patch": "@@ -80,27 +80,6 @@\n \t(register_new_assert_for): Use drop_tree_overflow.\n \t(vrp_visit_phi_node): Likewise.\n \n-2013-11-06  Dodji Seketeli  <dodji@redhat.com>\n-\n-\tpreprocessor/58580\n-\t* input.h (location_get_source_line): Take an additional line_size\n-\tparameter.\n-\t* input.c (get_line): New static function definition.\n-\t(read_line): Take an additional line_length output parameter to be\n-\tset to the size of the line.  Use the new get_line function do the\n-\tactual line reading.\n-\t(location_get_source_line): Take an additional output line_len\n-\tparameter.  Update the use of read_line to pass it the line_len\n-\tparameter.\n-\t* diagnostic.c (adjust_line): Take an additional input parameter\n-\tfor the length of the line, rather than calculating it with\n-\tstrlen.\n-\t(diagnostic_show_locus): Adjust the use of\n-\tlocation_get_source_line and adjust_line with respect to their new\n-\tsignature.  While displaying a line now, do not stop at the first\n-\tnull byte.  Rather, display the zero byte as a space and keep\n-\tgoing until we reach the size of the line.\n-\n 2013-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/i386/i386.c (ix86_expand_prologue): Optimize stack"}, {"sha": "36094a19c9a6659ed43225d72ad0919d19f769b2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=7f4d640cd9ecf834ce2f6ab469076ddd49021374", "patch": "@@ -259,13 +259,12 @@ diagnostic_build_prefix (diagnostic_context *context,\n    MAX_WIDTH by some margin, then adjust the start of the line such\n    that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n    margin is either 10 characters or the difference between the column\n-   and the length of the line, whatever is smaller.  The length of\n-   LINE is given by LINE_WIDTH.  */\n+   and the length of the line, whatever is smaller.  */\n static const char *\n-adjust_line (const char *line, int line_width,\n-\t     int max_width, int *column_p)\n+adjust_line (const char *line, int max_width, int *column_p)\n {\n   int right_margin = 10;\n+  int line_width = strlen (line);\n   int column = *column_p;\n \n   right_margin = MIN (line_width - column, right_margin);\n@@ -285,7 +284,6 @@ diagnostic_show_locus (diagnostic_context * context,\n \t\t       const diagnostic_info *diagnostic)\n {\n   const char *line;\n-  int line_width;\n   char *buffer;\n   expanded_location s;\n   int max_width;\n@@ -299,25 +297,22 @@ diagnostic_show_locus (diagnostic_context * context,\n \n   context->last_location = diagnostic->location;\n   s = expand_location_to_spelling_point (diagnostic->location);\n-  line = location_get_source_line (s, &line_width);\n+  line = location_get_source_line (s);\n   if (line == NULL)\n     return;\n \n   max_width = context->caret_max_width;\n-  line = adjust_line (line, line_width, max_width, &(s.column));\n+  line = adjust_line (line, max_width, &(s.column));\n \n   pp_newline (context->printer);\n   saved_prefix = pp_get_prefix (context->printer);\n   pp_set_prefix (context->printer, NULL);\n   pp_space (context->printer);\n-  while (max_width > 0 && line_width > 0)\n+  while (max_width > 0 && *line != '\\0')\n     {\n       char c = *line == '\\t' ? ' ' : *line;\n-      if (c == '\\0')\n-\tc = ' ';\n       pp_character (context->printer, c);\n       max_width--;\n-      line_width--;\n       line++;\n     }\n   pp_newline (context->printer);"}, {"sha": "a141a92cac3e79f9f4c735b4662317ac2abb7790", "filename": "gcc/input.c", "status": "modified", "additions": 27, "deletions": 88, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=7f4d640cd9ecf834ce2f6ab469076ddd49021374", "patch": "@@ -87,114 +87,53 @@ expand_location_1 (source_location loc,\n   return xloc;\n }\n \n-/* This function reads a line that might contain bytes whose value is\n-   zero.  It returns the number of bytes read.  The 'end-of-line'\n-   character found at the end of the line is not contained in the\n-   returned buffer.  Note that this function has been adapted from\n-   getline() and _IO_getdelim() GNU C library functions.  It's been\n-   duplicated here because the getline() function is not necessarily\n-   present on all platforms.\n-\n-   LINEPTR points to a buffer that is to contain the line read.\n-\n-   N points to the size of the the LINEPTR buffer.\n-\n-   FP points to the file to consider.  */\n-\n-static ssize_t\n-get_line (char **lineptr, size_t *n, FILE *fp)\n+/* Reads one line from file into a static buffer.  */\n+static const char *\n+read_line (FILE *file)\n {\n-  ssize_t cur_len = 0, len;\n-  char buf[16384];\n-\n-  if (lineptr == NULL || n == NULL)\n-    return -1;\n+  static char *string;\n+  static size_t string_len;\n+  size_t pos = 0;\n+  char *ptr;\n \n-  if (*lineptr == NULL || *n == 0)\n+  if (!string_len)\n     {\n-      *n = 120;\n-      *lineptr = XNEWVEC (char, *n);\n+      string_len = 200;\n+      string = XNEWVEC (char, string_len);\n     }\n \n-  len = fread (buf, 1, sizeof buf, fp);\n-  if (ferror (fp))\n-    return -1;\n-\n-  for (;;)\n+  while ((ptr = fgets (string + pos, string_len - pos, file)))\n     {\n-      size_t needed;\n-      char *t = (char*) memchr (buf, '\\n', len);\n-      if (t != NULL) len = (t - buf);\n-      if (__builtin_expect (len >= SSIZE_MAX - cur_len, 0))\n-\treturn -1;\n-      needed = cur_len + len + 1;\n-      if (needed > *n)\n+      size_t len = strlen (string + pos);\n+\n+      if (string[pos + len - 1] == '\\n')\n \t{\n-\t  char *new_lineptr;\n-\t  if (needed < 2 * *n)\n-\t    needed = 2 * *n;\n-\t  new_lineptr = XRESIZEVEC (char, *lineptr, needed);\n-\t  *lineptr = new_lineptr;\n-\t  *n = needed;\n+\t  string[pos + len - 1] = 0;\n+\t  return string;\n \t}\n-      memcpy (*lineptr + cur_len, buf, len);\n-      cur_len += len;\n-      if (t != NULL)\n-\tbreak;\n-      len = fread (buf, 1, sizeof buf, fp);\n-      if (ferror (fp))\n-\treturn -1;\n-      if (len == 0)\n-\tbreak;\n+      pos += len;\n+      string = XRESIZEVEC (char, string, string_len * 2);\n+      string_len *= 2;\n     }\n-\n-  if (cur_len)\n-    (*lineptr)[cur_len] = '\\0';\n-  return cur_len;\n-}\n-\n-/* Reads one line from FILE into a static buffer.  If LINE_LENGTH is\n- *non-null LINE_LENGTH, will be set by this function to the length of\n- *the returned line.  Note that the returned line can contain several\n- *zero bytes.  Also note that the returned string is allocated in\n- *static storage that is going to be re-used by subsequent invocations\n- *of read_line.  */\n-static const char *\n-read_line (FILE *file, int *line_length)\n-{\n-  static char *string;\n-  static size_t string_len;\n-  int len;\n-\n-  len = get_line (&string, &string_len, file);\n-  if (line_length)\n-    *line_length = len;\n-  return len ? string : NULL;\n+      \n+  return pos ? string : NULL;\n }\n \n /* Return the physical source line that corresponds to xloc in a\n    buffer that is statically allocated.  The newline is replaced by\n-   the null character.  Note that the line can contain several null\n-   characters, so LINE_LEN, if non-null, points to the actual length\n-   of the line.  */\n+   the null character.  */\n \n const char *\n-location_get_source_line (expanded_location xloc,\n-\t\t\t  int *line_len)\n+location_get_source_line (expanded_location xloc)\n {\n-  const char *buffer = NULL, *ptr;\n-  int lines = 0, len = 0;\n+  const char *buffer;\n+  int lines = 1;\n   FILE *stream = xloc.file ? fopen (xloc.file, \"r\") : NULL;\n   if (!stream)\n     return NULL;\n \n-  while ((ptr = read_line (stream, &len)) && lines < xloc.line)\n-    {\n-      buffer = ptr;\n-      lines++;\n-      if (line_len)\n-\t*line_len = len;\n-    }\n+  while ((buffer = read_line (stream)) && lines < xloc.line)\n+    lines++;\n \n   fclose (stream);\n   return buffer;"}, {"sha": "8fdc7b28d92e92af42e90bdd09a97f649074b0f6", "filename": "gcc/input.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=7f4d640cd9ecf834ce2f6ab469076ddd49021374", "patch": "@@ -37,8 +37,7 @@ extern char builtins_location_check[(BUILTINS_LOCATION\n \t\t\t\t     < RESERVED_LOCATION_COUNT) ? 1 : -1];\n \n extern expanded_location expand_location (source_location);\n-extern const char *location_get_source_line (expanded_location xloc,\n-\t\t\t\t\t     int *line_size);\n+extern const char *location_get_source_line (expanded_location xloc);\n extern expanded_location expand_location_to_spelling_point (source_location);\n extern source_location expansion_point_location_if_in_system_header (source_location);\n "}, {"sha": "ce0c26c7e45c7cc311d014fa42fcbe16faa94bf0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4d640cd9ecf834ce2f6ab469076ddd49021374/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f4d640cd9ecf834ce2f6ab469076ddd49021374", "patch": "@@ -199,11 +199,6 @@\n \t* gcc.dg/cilk-plus/cilk-plus.exp: Removed duplicate/un-necessary\n \tcompiler flag testing.\n \n-2013-11-06  Dodji Seketeli  <dodji@redhat.com>\n-\n-\tpreprocessor/58580\n-\t* c-c++-common/cpp/warning-zero-in-literals-1.c: New test file.\n-\n 2013-11-06  Christian Bruel  <christian.bruel@st.com>\n \n \t* gcc.target/sh/strlen.c: New test."}, {"sha": "ff2ed962ac96e47ae05b0b040f4e10b8e09637e2", "filename": "gcc/testsuite/c-c++-common/cpp/warning-zero-in-literals-1.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9954c743b9e985bd30194525464a0a8a64697b68/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fwarning-zero-in-literals-1.c?ref=9954c743b9e985bd30194525464a0a8a64697b68"}]}