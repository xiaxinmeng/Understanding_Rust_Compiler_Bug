{"sha": "6f80451c66dcc194baf195462734046e0b06934e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY4MDQ1MWM2NmRjYzE5NGJhZjE5NTQ2MjczNDA0NmUwYjA2OTM0ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-03T18:57:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-03T18:57:37Z"}, "message": "cp-tree.def (VEC_INIT_EXPR): Remove.\n\n\t* cp-tree.def (VEC_INIT_EXPR): Remove.\n\t* cp-tree.h (struct stmt_tree): New type.\n\t(struct saved_scope): Remove firstobj.  Add x_saved_tree,\n\tx_stmt_tree.\n\t(class_cache_firstobj): Remove.\n\t(struct language_function): Remove stmts_are_full_exprs_p,\n\tx_last_tree, and x_last_expr_type.  Add x_stmt_tree.\n\t(current_stmt_tree): New macro.\n\t(last_tree): Adjust.\n\t(last_expr_type): Likewise.\n\t(doing_semantic_analysis_p): Simplify.\n\t(stmts_are_full_exprs_p): Adjust.\n\t(begin_tree): Remove prototype.\n\t(end_tree): Likewise.\n\t(begin_stmt_tree): Change prototype.\n\t(finish_stmt_tree): Likewise.\n\t(building_stmt_tree): Simplify.\n\t* decl.c (mark_stmt_tree): New function.\n\t(mark_saved_scope): Use it.\n\t(start_function): Rearrange slightly to call begin_stmt_tree\n\tearlier.\n\t(save_function_data): Tweak.\n\t(finish_function): Adjust call to finish_stmt_tree.\n\t(mark_lang_function): Use mark_stmt_tree.\n\t* expr.c (cplus_expand_expr): Don't handle VEC_INIT_EXPR.\n\t* init.c (build_new_1): Remove creation of VEC_INIT_EXPR.\n\t(build_vec_init): Remove creation of stand-in intializer.\n\t* pt.c (begin_tree): Remove.\n\t(end_tree): Likewise.\n\t* semantics.c (SET_LAST_STMT): New macro.  Use it throughout.\n\t(begin_compound_stmt): Handle a compound-statement outside of a\n\tfunction.\n\t(begin_stmt_expr): Handle a statement-expression outsidef of a\n\tfunction.\n\t(finish_stmt_expr): Likewise.\n\t(begin_class_definition): Don't call begin_tree.\n\t(finish_inline_definitions): Don't call end_tree.\n\t(begin_stmt_tree): Take a pointer to tree, not a function as input.\n\t(finish_stmt_tree): Likewise.\n\t* tree.c (search_tree): Don't handle VEC_INIT_EXPR.\n\t(mapcar): Likewise.\n\n\t* parse.y (simple_stmt): Don't call finish_stmt unnecessarily.\n\t* parse.c: Regenerated.\n\n\t* dump.c (dqueue_and_dump): Dump bitfieldness.\n\nFrom-SVN: r29786", "tree": {"sha": "23c45ab9815fae6e8e4ce0ec105986b3c4e684e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c45ab9815fae6e8e4ce0ec105986b3c4e684e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f80451c66dcc194baf195462734046e0b06934e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f80451c66dcc194baf195462734046e0b06934e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f80451c66dcc194baf195462734046e0b06934e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f80451c66dcc194baf195462734046e0b06934e/comments", "author": null, "committer": null, "parents": [{"sha": "e192c1020f20455e953b7d73c7a1f84bf7f0fb8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e192c1020f20455e953b7d73c7a1f84bf7f0fb8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e192c1020f20455e953b7d73c7a1f84bf7f0fb8e"}], "stats": {"total": 506, "additions": 272, "deletions": 234}, "files": [{"sha": "982c00d5e4b829adeac016a23221a7081f4ba14a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -1,5 +1,52 @@\n 1999-10-03  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.def (VEC_INIT_EXPR): Remove.\n+\t* cp-tree.h (struct stmt_tree): New type.\n+\t(struct saved_scope): Remove firstobj.  Add x_saved_tree,\n+\tx_stmt_tree.\n+\t(class_cache_firstobj): Remove.\n+\t(struct language_function): Remove stmts_are_full_exprs_p,\n+\tx_last_tree, and x_last_expr_type.  Add x_stmt_tree.\n+\t(current_stmt_tree): New macro.\n+\t(last_tree): Adjust.\n+\t(last_expr_type): Likewise.\n+\t(doing_semantic_analysis_p): Simplify.\n+\t(stmts_are_full_exprs_p): Adjust.\n+\t(begin_tree): Remove prototype.\n+\t(end_tree): Likewise.\n+\t(begin_stmt_tree): Change prototype.\n+\t(finish_stmt_tree): Likewise.\n+\t(building_stmt_tree): Simplify.\n+\t* decl.c (mark_stmt_tree): New function.\n+\t(mark_saved_scope): Use it.\n+\t(start_function): Rearrange slightly to call begin_stmt_tree \n+\tearlier.\n+\t(save_function_data): Tweak.\n+\t(finish_function): Adjust call to finish_stmt_tree.\n+\t(mark_lang_function): Use mark_stmt_tree.\n+\t* expr.c (cplus_expand_expr): Don't handle VEC_INIT_EXPR.\n+\t* init.c (build_new_1): Remove creation of VEC_INIT_EXPR.\n+\t(build_vec_init): Remove creation of stand-in intializer.\n+\t* pt.c (begin_tree): Remove.\n+\t(end_tree): Likewise.\n+\t* semantics.c (SET_LAST_STMT): New macro.  Use it throughout.\n+\t(begin_compound_stmt): Handle a compound-statement outside of a\n+\tfunction.\n+\t(begin_stmt_expr): Handle a statement-expression outsidef of a\n+\tfunction.\n+\t(finish_stmt_expr): Likewise.\n+\t(begin_class_definition): Don't call begin_tree.\n+\t(finish_inline_definitions): Don't call end_tree.\n+\t(begin_stmt_tree): Take a pointer to tree, not a function as input.\n+\t(finish_stmt_tree): Likewise.\n+\t* tree.c (search_tree): Don't handle VEC_INIT_EXPR.\n+\t(mapcar): Likewise.\n+\t\n+\t* parse.y (simple_stmt): Don't call finish_stmt unnecessarily.\n+\t* parse.c: Regenerated.\n+\t\n+\t* dump.c (dqueue_and_dump): Dump bitfieldness.\n+\t\n \t* tree.c (lvalue_p_1): Use DECL_C_BIT_FIELD to check for\n \tbitfields, rather than DECL_BIT_FIELD.\n \t* ir.texi: Document how to tell whether or not a field is a"}, {"sha": "372ad77593d8fe4ecb189ac378a1e39b791eaa4b", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -70,11 +70,6 @@ DEFTREECODE (AGGR_INIT_EXPR, \"aggr_init_expr\", 'e', 3)\n    else it is NULL_TREE.  */\n DEFTREECODE (THROW_EXPR, \"throw_expr\", 'e', 1)\n \n-/* Initialization of a vector, used in build_new.  Operand 0 is the target\n-   of the initialization, operand 1 is the initializer, and operand 2 is\n-   the number of elements.  */\n-DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", 'e', 3)\n-\n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for\n    accessing this data."}, {"sha": "f1134afff6352155b3e7443c7fb56d269044c4b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -566,6 +566,12 @@ extern tree cp_global_trees[CPTI_MAX];\n \n /* Global state.  */\n \n+struct stmt_tree {\n+  tree x_last_stmt;\n+  tree x_last_expr_type;\n+  int stmts_are_full_exprs_p; \n+};\n+\n struct saved_scope {\n   tree old_bindings;\n   tree old_namespace;\n@@ -580,13 +586,14 @@ struct saved_scope {\n   tree template_parms;\n   tree x_previous_class_type;\n   tree x_previous_class_values;\n+  tree x_saved_tree;\n \n   HOST_WIDE_INT x_processing_template_decl;\n   int x_processing_specialization;\n   int x_processing_explicit_instantiation;\n   int need_pop_function_context;\n \n-  char *firstobj;\n+  struct stmt_tree x_stmt_tree;\n \n   struct binding_level *class_bindings;\n   struct binding_level *bindings;\n@@ -640,10 +647,6 @@ struct saved_scope {\n \n #define previous_class_values scope_chain->x_previous_class_values\n \n-/* The low-water mark on the class-cache obstack.  */\n-\n-#define class_cache_firstobj scope_chain->firstobj\n-\n extern struct saved_scope *scope_chain;\n \n /* Global state pertinent to the current function.  */\n@@ -657,8 +660,6 @@ struct language_function\n   tree x_member_init_list;\n   tree x_current_class_ptr;\n   tree x_current_class_ref;\n-  tree x_last_tree;\n-  tree x_last_expr_type;\n   tree x_eh_spec_try_block;\n   tree x_scope_stmt_stack;\n   tree x_in_charge_parm;\n@@ -676,10 +677,11 @@ struct language_function\n   int static_labelno;\n   int in_function_try_handler;\n   int x_expanding_p;\n-  int stmts_are_full_exprs_p; \n   int name_declared;\n   int vtbls_set_up_p;\n \n+  struct stmt_tree x_stmt_tree;\n+\n   struct named_label_list *x_named_label_uses;\n   struct binding_level *bindings;\n \n@@ -722,16 +724,23 @@ struct language_function\n #define current_class_ref \\\n   (current_function ? cp_function_chain->x_current_class_ref : NULL_TREE)\n \n-/* When building a statement-tree, this is the last node added to the\n-   tree.  */\n+/* Information about the current statement tree.  */\n+\n+#define current_stmt_tree\t\t\t\\\n+  (current_function \t\t\t\t\\\n+   ? &cp_function_chain->x_stmt_tree\t\t\\\n+   : &scope_chain->x_stmt_tree)\n+\n+/* When building a statement-tree, this is the last statement added to\n+   the tree.  */\n \n-#define last_tree cp_function_chain->x_last_tree\n+#define last_tree current_stmt_tree->x_last_stmt\n \n /* The type of the last expression-statement we have seen.  This is\n    required because the type of a statement-expression is the type of\n    the last expression statement.  */\n \n-#define last_expr_type cp_function_chain->x_last_expr_type\n+#define last_expr_type current_stmt_tree->x_last_expr_type\n \n /* The TRY_BLOCK for the exception-specifiers for the current\n    function, if any.  */\n@@ -796,8 +805,7 @@ struct language_function\n /* Non-zero if we are in the semantic analysis phase for the current\n    function.  */\n \n-#define doing_semantic_analysis_p() \\\n-  (!expanding_p || !current_function->x_whole_function_mode_p)\n+#define doing_semantic_analysis_p() (!expanding_p)\n \n /* Non-zero if we should treat statements as full expressions.  In\n    particular, this variable is no-zero if at the end of a statement\n@@ -811,7 +819,8 @@ struct language_function\n    within the statement expression should not result in cleanups being\n    run until the entire enclosing statement is complete.  */\n \n-#define stmts_are_full_exprs_p cp_function_chain->stmts_are_full_exprs_p\n+#define stmts_are_full_exprs_p \\\n+  current_stmt_tree->stmts_are_full_exprs_p\n \n #define in_function_try_handler cp_function_chain->in_function_try_handler\n \n@@ -3719,8 +3728,6 @@ extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree get_bindings\t\t\tPROTO((tree, tree, tree));\n extern void add_tree\t\t\t\tPROTO((tree));\n-extern void begin_tree                          PROTO((void));\n-extern void end_tree                            PROTO((void));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n extern void pop_tinst_level\t\t\tPROTO((void));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n@@ -3879,15 +3886,14 @@ extern void finish_decl_cleanup                 PROTO((tree, tree));\n extern void finish_named_return_value           PROTO((tree, tree));\n extern tree expand_stmt                         PROTO((tree));\n extern void expand_body                         PROTO((tree));\n-extern void begin_stmt_tree                     PROTO((tree));\n-extern void finish_stmt_tree                    PROTO((tree));\n+extern void begin_stmt_tree                     PROTO((tree *));\n+extern void finish_stmt_tree                    PROTO((tree *));\n extern void prep_stmt                           PROTO((tree));\n extern void do_pushlevel                        PROTO((void));\n extern tree do_poplevel                         PROTO((void));\n /* Non-zero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n-#define building_stmt_tree()\t\t\t\t\t  \\\n-  (current_function && (processing_template_decl || !expanding_p))\n+#define building_stmt_tree() (last_tree != NULL_TREE)\n \n /* in spew.c */\n extern void init_spew\t\t\t\tPROTO((void));"}, {"sha": "9c51069c4d03ee74965eeb39502eafcd605cf654", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -168,6 +168,7 @@ static void mark_binding_level PROTO((void *));\n static void mark_cp_function_context PROTO((struct function *));\n static void mark_saved_scope PROTO((void *));\n static void mark_lang_function PROTO((struct language_function *));\n+static void mark_stmt_tree PROTO((struct stmt_tree *));\n static void save_function_data PROTO((tree));\n static void check_function_type PROTO((tree));\n static void destroy_local_static PROTO((tree));\n@@ -2271,6 +2272,16 @@ pop_nested_namespace (ns)\n    scope isn't enough, because more binding levels may be pushed.  */\n struct saved_scope *scope_chain;\n \n+/* Mark ST for GC.  */\n+\n+static void\n+mark_stmt_tree (st)\n+     struct stmt_tree *st;\n+{\n+  ggc_mark_tree (st->x_last_stmt);\n+  ggc_mark_tree (st->x_last_expr_type);\n+}\n+\n /* Mark ARG (which is really a struct saved_scope **) for GC.  */\n \n static void\n@@ -2294,6 +2305,9 @@ mark_saved_scope (arg)\n       ggc_mark_tree (t->template_parms);\n       ggc_mark_tree (t->x_previous_class_type);\n       ggc_mark_tree (t->x_previous_class_values);\n+      ggc_mark_tree (t->x_saved_tree);\n+\n+      mark_stmt_tree (&t->x_stmt_tree);\n       mark_binding_level (&t->bindings);\n       t = t->prev;\n     }\n@@ -12890,6 +12904,10 @@ start_function (declspecs, declarator, attrs, flags)\n   immediate_size_expand = 0;\n   current_function->x_dont_save_pending_sizes_p = 1;\n \n+  /* If we're building a statement-tree, start the tree now.  */\n+  if (processing_template_decl || !expanding_p)\n+    begin_stmt_tree (&DECL_SAVED_TREE (decl1));\n+\n   /* Let the user know we're compiling this function.  */\n   if (processing_template_decl || !building_stmt_tree ())\n     announce_function (decl1);\n@@ -13071,9 +13089,6 @@ start_function (declspecs, declarator, attrs, flags)\n      function body.  */\n   push_momentary ();\n \n-  if (building_stmt_tree ())\n-    begin_stmt_tree (decl1);\n-\n   ++function_depth;\n \n   if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1))\n@@ -13289,8 +13304,8 @@ save_function_data (decl)\n   /* Clear out the bits we don't need.  */\n   f->x_base_init_list = NULL_TREE;\n   f->x_member_init_list = NULL_TREE;\n-  f->x_last_tree = NULL_TREE;\n-  f->x_last_expr_type = NULL_TREE;\n+  f->x_stmt_tree.x_last_stmt = NULL_TREE;\n+  f->x_stmt_tree.x_last_expr_type = NULL_TREE;\n   f->x_last_dtor_insn = NULL_RTX;\n   f->x_last_parm_cleanup_insn = NULL_RTX;\n   f->x_result_rtx = NULL_RTX;\n@@ -13630,7 +13645,7 @@ finish_function (lineno, flags)\n   \n   /* If we're saving up tree structure, tie off the function now.  */\n   if (!expand_p)\n-    finish_stmt_tree (fndecl);\n+    finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n \n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n@@ -14229,15 +14244,14 @@ mark_lang_function (p)\n   ggc_mark_tree (p->x_member_init_list);\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);\n-  ggc_mark_tree (p->x_last_tree);\n-  ggc_mark_tree (p->x_last_expr_type);\n   ggc_mark_tree (p->x_eh_spec_try_block);\n   ggc_mark_tree (p->x_scope_stmt_stack);\n \n   ggc_mark_rtx (p->x_last_dtor_insn);\n   ggc_mark_rtx (p->x_last_parm_cleanup_insn);\n   ggc_mark_rtx (p->x_result_rtx);\n \n+  mark_stmt_tree (&p->x_stmt_tree);\n   mark_binding_level (&p->bindings);\n }\n "}, {"sha": "00d9e18f558597610379db2dc18f23b09c2638a8", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -596,7 +596,11 @@ dequeue_and_dump (di)\n       dump_int (di, \"algn\", DECL_ALIGN (t));\n \n       if (TREE_CODE (t) == FIELD_DECL && dump_children_p)\n-\tdump_child (\"bpos\", DECL_FIELD_BITPOS (t));\n+\t{\n+\t  if (DECL_C_BIT_FIELD (t))\n+\t    dump_string (di, \"bitfield\");\n+\t  dump_child (\"bpos\", DECL_FIELD_BITPOS (t));\n+\t}\n       break;\n \n     case FUNCTION_DECL:"}, {"sha": "9556caced88e213db14fdba98ebf3a710ec01599", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -233,14 +233,6 @@ cplus_expand_expr (exp, target, tmode, modifier)\n       expand_internal_throw ();\n       return NULL;\n \n-    case VEC_INIT_EXPR:\n-      return expand_expr\n-\t(build_vec_init\n-\t (NULL_TREE, TREE_OPERAND (exp, 0),\n-\t  build_binary_op (MINUS_EXPR, TREE_OPERAND (exp, 2),\n-\t\t\t   integer_one_node),\n-\t  TREE_OPERAND (exp, 1), 0), target, tmode, modifier);\n-\n     case STMT_EXPR:\n       {\n \ttree rtl_expr = begin_stmt_expr ();"}, {"sha": "40fd8c9cb8113be2cf3d71ad33b6ba381612076d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -2363,16 +2363,13 @@ build_new_1 (exp)\n \t  rval = newrval;\n \t  TREE_HAS_CONSTRUCTOR (rval) = 1;\n \t}\n-      else if (current_function_decl)\n+      else\n \trval = (build_vec_init\n \t\t(NULL_TREE, \n \t\t save_expr (rval),\n \t\t build_binary_op (MINUS_EXPR, nelts, integer_one_node),\n \t\t init,\n \t\t /*from_array=*/0));\n-      else\n-\trval = build (VEC_INIT_EXPR, TREE_TYPE (rval),\n-\t\t      save_expr (rval), init, nelts);\n \n       /* If any part of the object initialization terminates by throwing an\n \t exception and a suitable deallocation function can be found, the\n@@ -2698,15 +2695,6 @@ build_vec_init (decl, base, maxindex, init, from_array)\n   if (maxindex == error_mark_node)\n     return error_mark_node;\n \n-  if (current_function_decl == NULL_TREE)\n-    {\n-      rval = make_tree_vec (3);\n-      TREE_VEC_ELT (rval, 0) = base;\n-      TREE_VEC_ELT (rval, 1) = maxindex;\n-      TREE_VEC_ELT (rval, 2) = init;\n-      return rval;\n-    }\n-\n   type = TREE_TYPE (TREE_TYPE (base));\n   ptype = build_pointer_type (type);\n   size = size_in_bytes (type);"}, {"sha": "e7d774d112906ec42aa739f64fa78a1f5a5dc45f", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 118, "deletions": 123, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -735,19 +735,19 @@ static const short yyrline[] = { 0,\n   3216,  3219,  3222,  3225,  3228,  3230,  3233,  3237,  3239,  3245,\n   3247,  3248,  3250,  3255,  3257,  3259,  3261,  3263,  3266,  3267,\n   3269,  3272,  3273,  3276,  3276,  3279,  3279,  3282,  3282,  3284,\n-  3286,  3288,  3290,  3296,  3302,  3305,  3308,  3314,  3316,  3318,\n-  3322,  3324,  3325,  3326,  3328,  3331,  3334,  3337,  3343,  3347,\n-  3349,  3352,  3354,  3357,  3361,  3363,  3366,  3368,  3371,  3388,\n-  3396,  3399,  3401,  3403,  3407,  3410,  3411,  3419,  3423,  3427,\n-  3430,  3431,  3437,  3440,  3443,  3445,  3449,  3454,  3457,  3467,\n-  3472,  3473,  3480,  3483,  3486,  3488,  3491,  3493,  3503,  3517,\n-  3521,  3524,  3526,  3530,  3534,  3537,  3540,  3542,  3546,  3548,\n-  3555,  3562,  3565,  3569,  3573,  3577,  3583,  3587,  3592,  3594,\n-  3597,  3602,  3608,  3619,  3622,  3624,  3628,  3636,  3639,  3643,\n-  3646,  3648,  3650,  3656,  3661,  3664,  3666,  3668,  3670,  3672,\n-  3674,  3676,  3678,  3680,  3682,  3684,  3686,  3688,  3690,  3692,\n-  3694,  3696,  3698,  3700,  3702,  3704,  3706,  3708,  3710,  3712,\n-  3714,  3716,  3718,  3720,  3722,  3724,  3726,  3729,  3731\n+  3286,  3288,  3290,  3296,  3302,  3305,  3308,  3314,  3316,  3317,\n+  3320,  3322,  3323,  3324,  3326,  3329,  3332,  3335,  3341,  3345,\n+  3347,  3350,  3352,  3355,  3359,  3361,  3364,  3366,  3369,  3386,\n+  3394,  3397,  3399,  3401,  3405,  3408,  3409,  3417,  3421,  3425,\n+  3428,  3429,  3435,  3438,  3441,  3443,  3447,  3452,  3455,  3465,\n+  3470,  3471,  3478,  3481,  3484,  3486,  3489,  3491,  3501,  3515,\n+  3519,  3522,  3524,  3528,  3532,  3535,  3538,  3540,  3544,  3546,\n+  3553,  3560,  3563,  3567,  3571,  3575,  3581,  3585,  3590,  3592,\n+  3595,  3600,  3606,  3617,  3620,  3622,  3626,  3634,  3637,  3641,\n+  3644,  3646,  3648,  3654,  3659,  3662,  3664,  3666,  3668,  3670,\n+  3672,  3674,  3676,  3678,  3680,  3682,  3684,  3686,  3688,  3690,\n+  3692,  3694,  3696,  3698,  3700,  3702,  3704,  3706,  3708,  3710,\n+  3712,  3714,  3716,  3718,  3720,  3722,  3724,  3727,  3729\n };\n #endif\n \n@@ -7673,172 +7673,167 @@ case 758:\n #line 3315 \"parse.y\"\n { finish_goto_stmt (yyvsp[-1].ttype); ;\n     break;}\n-case 759:\n-#line 3317 \"parse.y\"\n-{ finish_stmt (); ;\n-    break;}\n case 760:\n-#line 3319 \"parse.y\"\n+#line 3318 \"parse.y\"\n { error (\"label must be followed by statement\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  finish_stmt (); ;\n+\t\t  yyungetc ('}', 0); ;\n     break;}\n case 761:\n-#line 3323 \"parse.y\"\n+#line 3321 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 764:\n-#line 3327 \"parse.y\"\n+#line 3325 \"parse.y\"\n { do_local_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 766:\n-#line 3333 \"parse.y\"\n+#line 3331 \"parse.y\"\n { yyval.ttype = begin_function_try_block (); ;\n     break;}\n case 767:\n-#line 3335 \"parse.y\"\n+#line 3333 \"parse.y\"\n { finish_function_try_block (yyvsp[-2].ttype); ;\n     break;}\n case 768:\n-#line 3337 \"parse.y\"\n+#line 3335 \"parse.y\"\n {\n \t\t  finish_function_handler_sequence (yyvsp[-4].ttype);\n \t\t  yyval.itype = yyvsp[-3].itype;\n \t\t;\n     break;}\n case 769:\n-#line 3345 \"parse.y\"\n+#line 3343 \"parse.y\"\n { yyval.ttype = begin_try_block (); ;\n     break;}\n case 770:\n-#line 3347 \"parse.y\"\n+#line 3345 \"parse.y\"\n { finish_try_block (yyvsp[-1].ttype); ;\n     break;}\n case 771:\n-#line 3349 \"parse.y\"\n+#line 3347 \"parse.y\"\n { finish_handler_sequence (yyvsp[-3].ttype); ;\n     break;}\n case 774:\n-#line 3359 \"parse.y\"\n+#line 3357 \"parse.y\"\n { yyval.ttype = begin_handler(); ;\n     break;}\n case 775:\n-#line 3361 \"parse.y\"\n+#line 3359 \"parse.y\"\n { yyval.ttype = finish_handler_parms (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 776:\n-#line 3363 \"parse.y\"\n+#line 3361 \"parse.y\"\n { finish_handler (yyvsp[-1].ttype, yyvsp[-3].ttype); ;\n     break;}\n case 779:\n-#line 3373 \"parse.y\"\n+#line 3371 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 780:\n-#line 3389 \"parse.y\"\n+#line 3387 \"parse.y\"\n { \n \t\t  check_for_new_type (\"inside exception declarations\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = start_handler_parms (TREE_PURPOSE (yyvsp[-1].ftype.t),\n \t\t\t\t\t    TREE_VALUE (yyvsp[-1].ftype.t));\n \t\t;\n     break;}\n case 781:\n-#line 3398 \"parse.y\"\n+#line 3396 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 782:\n-#line 3400 \"parse.y\"\n+#line 3398 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 783:\n-#line 3402 \"parse.y\"\n+#line 3400 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 784:\n-#line 3404 \"parse.y\"\n+#line 3402 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 785:\n-#line 3409 \"parse.y\"\n+#line 3407 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 787:\n-#line 3412 \"parse.y\"\n+#line 3410 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 788:\n-#line 3421 \"parse.y\"\n+#line 3419 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 789:\n-#line 3424 \"parse.y\"\n+#line 3422 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 790:\n-#line 3429 \"parse.y\"\n+#line 3427 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 792:\n-#line 3432 \"parse.y\"\n+#line 3430 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 793:\n-#line 3439 \"parse.y\"\n+#line 3437 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 796:\n-#line 3446 \"parse.y\"\n+#line 3444 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 797:\n-#line 3451 \"parse.y\"\n+#line 3449 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 798:\n-#line 3456 \"parse.y\"\n+#line 3454 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 799:\n-#line 3458 \"parse.y\"\n+#line 3456 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 800:\n-#line 3469 \"parse.y\"\n+#line 3467 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 802:\n-#line 3474 \"parse.y\"\n+#line 3472 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 803:\n-#line 3482 \"parse.y\"\n+#line 3480 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 804:\n-#line 3484 \"parse.y\"\n+#line 3482 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 805:\n-#line 3487 \"parse.y\"\n+#line 3485 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 806:\n-#line 3489 \"parse.y\"\n+#line 3487 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 807:\n-#line 3492 \"parse.y\"\n+#line 3490 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 808:\n-#line 3494 \"parse.y\"\n+#line 3492 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7850,7 +7845,7 @@ case 808:\n \t\t;\n     break;}\n case 809:\n-#line 3504 \"parse.y\"\n+#line 3502 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7863,99 +7858,99 @@ case 809:\n \t\t;\n     break;}\n case 810:\n-#line 3519 \"parse.y\"\n+#line 3517 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 811:\n-#line 3521 \"parse.y\"\n+#line 3519 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 814:\n-#line 3532 \"parse.y\"\n+#line 3530 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 815:\n-#line 3535 \"parse.y\"\n+#line 3533 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 816:\n-#line 3538 \"parse.y\"\n+#line 3536 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 817:\n-#line 3541 \"parse.y\"\n+#line 3539 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 818:\n-#line 3543 \"parse.y\"\n+#line 3541 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 820:\n-#line 3549 \"parse.y\"\n+#line 3547 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 821:\n-#line 3559 \"parse.y\"\n+#line 3557 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 822:\n-#line 3563 \"parse.y\"\n+#line 3561 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 823:\n-#line 3566 \"parse.y\"\n+#line 3564 \"parse.y\"\n { yyval.ftype.t = build_tree_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 824:\n-#line 3570 \"parse.y\"\n+#line 3568 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 825:\n-#line 3574 \"parse.y\"\n+#line 3572 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 826:\n-#line 3578 \"parse.y\"\n+#line 3576 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 827:\n-#line 3585 \"parse.y\"\n+#line 3583 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 828:\n-#line 3588 \"parse.y\"\n+#line 3586 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 831:\n-#line 3599 \"parse.y\"\n+#line 3597 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 832:\n-#line 3604 \"parse.y\"\n+#line 3602 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 833:\n-#line 3609 \"parse.y\"\n+#line 3607 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7966,192 +7961,192 @@ case 833:\n \t\t;\n     break;}\n case 834:\n-#line 3621 \"parse.y\"\n+#line 3619 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 835:\n-#line 3623 \"parse.y\"\n+#line 3621 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 836:\n-#line 3625 \"parse.y\"\n+#line 3623 \"parse.y\"\n { yyval.ttype = empty_except_spec; ;\n     break;}\n case 837:\n-#line 3630 \"parse.y\"\n+#line 3628 \"parse.y\"\n {\n \t\t  check_for_new_type (\"exception specifier\", yyvsp[0].ftype);\n \t\t  yyval.ttype = groktypename (yyvsp[0].ftype.t);\n \t\t;\n     break;}\n case 838:\n-#line 3638 \"parse.y\"\n+#line 3636 \"parse.y\"\n { yyval.ttype = add_exception_specifier (NULL_TREE, yyvsp[0].ttype, 1); ;\n     break;}\n case 839:\n-#line 3640 \"parse.y\"\n+#line 3638 \"parse.y\"\n { yyval.ttype = add_exception_specifier (yyvsp[-2].ttype, yyvsp[0].ttype, 1); ;\n     break;}\n case 840:\n-#line 3645 \"parse.y\"\n+#line 3643 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 841:\n-#line 3647 \"parse.y\"\n+#line 3645 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 842:\n-#line 3649 \"parse.y\"\n+#line 3647 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 843:\n-#line 3651 \"parse.y\"\n+#line 3649 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 844:\n-#line 3658 \"parse.y\"\n+#line 3656 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 845:\n-#line 3663 \"parse.y\"\n+#line 3661 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 846:\n-#line 3665 \"parse.y\"\n+#line 3663 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 847:\n-#line 3667 \"parse.y\"\n+#line 3665 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 848:\n-#line 3669 \"parse.y\"\n+#line 3667 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 849:\n-#line 3671 \"parse.y\"\n+#line 3669 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 850:\n-#line 3673 \"parse.y\"\n+#line 3671 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 851:\n-#line 3675 \"parse.y\"\n+#line 3673 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 852:\n-#line 3677 \"parse.y\"\n+#line 3675 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 853:\n-#line 3679 \"parse.y\"\n+#line 3677 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 854:\n-#line 3681 \"parse.y\"\n+#line 3679 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 855:\n-#line 3683 \"parse.y\"\n+#line 3681 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 856:\n-#line 3685 \"parse.y\"\n+#line 3683 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 857:\n-#line 3687 \"parse.y\"\n+#line 3685 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 858:\n-#line 3689 \"parse.y\"\n+#line 3687 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 859:\n-#line 3691 \"parse.y\"\n+#line 3689 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 860:\n-#line 3693 \"parse.y\"\n+#line 3691 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 861:\n-#line 3695 \"parse.y\"\n+#line 3693 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 862:\n-#line 3697 \"parse.y\"\n+#line 3695 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 863:\n-#line 3699 \"parse.y\"\n+#line 3697 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 864:\n-#line 3701 \"parse.y\"\n+#line 3699 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 865:\n-#line 3703 \"parse.y\"\n+#line 3701 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 866:\n-#line 3705 \"parse.y\"\n+#line 3703 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 867:\n-#line 3707 \"parse.y\"\n+#line 3705 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 868:\n-#line 3709 \"parse.y\"\n+#line 3707 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 869:\n-#line 3711 \"parse.y\"\n+#line 3709 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 870:\n-#line 3713 \"parse.y\"\n+#line 3711 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 871:\n-#line 3715 \"parse.y\"\n+#line 3713 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 872:\n-#line 3717 \"parse.y\"\n+#line 3715 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 873:\n-#line 3719 \"parse.y\"\n+#line 3717 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 874:\n-#line 3721 \"parse.y\"\n+#line 3719 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 875:\n-#line 3723 \"parse.y\"\n+#line 3721 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 876:\n-#line 3725 \"parse.y\"\n+#line 3723 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 877:\n-#line 3727 \"parse.y\"\n+#line 3725 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 878:\n-#line 3730 \"parse.y\"\n+#line 3728 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 879:\n-#line 3732 \"parse.y\"\n+#line 3730 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -8376,7 +8371,7 @@ case 879:\n     }\n   return 1;\n }\n-#line 3735 \"parse.y\"\n+#line 3733 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "e9d8068e388f94be23ebdc1a8e61d89a2e0fa83c", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -3314,11 +3314,9 @@ simple_stmt:\n \t| GOTO identifier ';'\n                 { finish_goto_stmt ($2); }\n \t| label_colon stmt\n-\t\t{ finish_stmt (); }\n \t| label_colon '}'\n \t\t{ error (\"label must be followed by statement\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  finish_stmt (); }\n+\t\t  yyungetc ('}', 0); }\n \t| ';'\n \t\t{ finish_stmt (); }\n \t| try_block"}, {"sha": "9586ec2fb78ee37df786359443e53b22b934e41b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -9807,29 +9807,6 @@ tsubst_expr_values (t, argvec)\n   return first;\n }\n \n-void\n-begin_tree ()\n-{\n-  if (current_function)\n-    {\n-      saved_trees = tree_cons (NULL_TREE, last_tree, saved_trees);\n-      last_tree = NULL_TREE;\n-    }\n-  else\n-    saved_trees = tree_cons (NULL_TREE, NULL_TREE, saved_trees);\n-}\n-\n-\n-void \n-end_tree ()\n-{\n-  my_friendly_assert (saved_trees != NULL_TREE, 0);\n-\n-  if (current_function)\n-    last_tree = TREE_VALUE (saved_trees);\n-  saved_trees = TREE_CHAIN (saved_trees);\n-}\n-\n /* D is an undefined function declaration in the presence of templates with\n    the same name, listed in FNS.  If one of them can produce D as an\n    instantiation, remember this so we can instantiate it at EOF if D has"}, {"sha": "eb1767e850eac44143d7f07e0b4c99e3ff14d438", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -45,6 +45,12 @@\n static tree expand_cond PROTO((tree));\n static tree maybe_convert_cond PROTO((tree));\n \n+/* Record the fact that STMT was the last statement added to the\n+   statement tree.  */\n+\n+#define SET_LAST_STMT(stmt) \\\n+  (current_stmt_tree->x_last_stmt = (stmt))\n+\n /* When parsing a template, LAST_TREE contains the last statement\n    parsed.  These are chained together through the TREE_CHAIN field,\n    but often need to be re-organized since the parse is performed\n@@ -55,7 +61,7 @@ static tree maybe_convert_cond PROTO((tree));\n   do {\t\t\t\t\t\\\n     substmt = TREE_CHAIN (stmt);\t\\\n     TREE_CHAIN (stmt) = NULL_TREE;\t\\\n-    last_tree = stmt;\t\t\t\\\n+    SET_LAST_STMT (stmt);\t\t\\\n   } while (0)\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n@@ -82,7 +88,8 @@ add_tree (t)\n      tree t;\n {\n   /* Add T to the statement-tree.  */\n-  last_tree = TREE_CHAIN (last_tree) = t;\n+  TREE_CHAIN (last_tree) = t;\n+  SET_LAST_STMT (t);\n \n   /* When we expand a statement-tree, we must know whether or not the\n      statements are full-expresions.  We record that fact here.  */\n@@ -201,7 +208,7 @@ finish_then_clause (if_stmt)\n   if (building_stmt_tree ())\n     {\n       RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n-      last_tree = if_stmt;\n+      SET_LAST_STMT (if_stmt);\n       return if_stmt;\n     }\n   else\n@@ -934,7 +941,8 @@ begin_compound_stmt (has_no_scope)\n \n   /* If this is the outermost block of the function, declare the\n      variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n-  if (!current_function_name_declared \n+  if (current_function\n+      && !current_function_name_declared \n       && !processing_template_decl\n       && !has_no_scope)\n     {\n@@ -1322,6 +1330,12 @@ finish_parenthesized_expr (expr)\n tree \n begin_stmt_expr ()\n {\n+  /* If we're outside a function, we won't have a statement-tree to\n+     work with.  But, if we see a statement-expression we need to\n+     create one.  */\n+  if (!current_function && !last_tree)\n+    begin_stmt_tree (&scope_chain->x_saved_tree);\n+\n   keep_next_level (1);\n   /* If we're building a statement tree, then the upcoming compound\n      statement will be chained onto the tree structure, starting at\n@@ -1359,12 +1373,18 @@ finish_stmt_expr (rtl_expr)\n       \n       /* Remove the compound statement from the tree structure; it is\n \t now saved in the STMT_EXPR.  */\n-      last_tree = rtl_expr;\n+      SET_LAST_STMT (rtl_expr);\n       TREE_CHAIN (last_tree) = NULL_TREE;\n     }\n   else \n     result = rtl_expr;\n \n+  /* If we created a statement-tree for this statement-expression,\n+     remove it now.  */ \n+  if (!current_function \n+      && TREE_CHAIN (scope_chain->x_saved_tree) == NULL_TREE)\n+    finish_stmt_tree (&scope_chain->x_saved_tree);\n+\n   return result;\n }\n \n@@ -1840,11 +1860,6 @@ begin_class_definition (t)\n #endif\n   reset_specialization();\n   \n-  /* In case this is a local class within a template\n-     function, we save the current tree structure so\n-     that we can get it back later.  */\n-  begin_tree ();\n-\n   /* Make a declaration for this class in its own scope.  */\n   build_self_reference ();\n \n@@ -1997,9 +2012,6 @@ finish_inline_definitions ()\n {\n   if (current_class_type == NULL_TREE)\n     clear_inline_text_obstack (); \n-  \n-  /* Undo the begin_tree in begin_class_definition.  */\n-  end_tree ();\n }\n \n /* Finish processing the declaration of a member class template\n@@ -2172,36 +2184,40 @@ finish_typeof (expr)\n   return TREE_TYPE (expr);\n }\n \n-/* Create an empty statement tree for FN.  */\n+/* Create an empty statement tree rooted at T.  */\n \n void\n-begin_stmt_tree (fn)\n-     tree fn;\n+begin_stmt_tree (t)\n+     tree *t;\n {\n   /* We create a trivial EXPR_STMT so that last_tree is never NULL in\n      what follows.  We remove the extraneous statement in\n      finish_stmt_tree.  */\n-  DECL_SAVED_TREE (fn) = build_nt (EXPR_STMT, void_zero_node);\n-  last_tree = DECL_SAVED_TREE (fn);\n+  *t = build_nt (EXPR_STMT, void_zero_node);\n+  SET_LAST_STMT (*t);\n   last_expr_type = NULL_TREE;\n }\n \n-/* Finish the statement tree for FN.  */\n+/* Finish the statement tree rooted at T.  */\n \n void\n-finish_stmt_tree (fn)\n-     tree fn;\n+finish_stmt_tree (t)\n+     tree *t;\n {\n   tree stmt;\n   \n   /* Remove the fake extra statement added in begin_stmt_tree.  */\n-  stmt = TREE_CHAIN (DECL_SAVED_TREE (fn));\n-  DECL_SAVED_TREE (fn) = stmt;\n+  stmt = TREE_CHAIN (*t);\n+  *t = stmt;\n+  SET_LAST_STMT (NULL_TREE);\n \n-  /* The line-number recorded in the outermost statement in a function\n-     is the line number of the end of the function.  */\n-  STMT_LINENO (stmt) = lineno;\n-  STMT_LINENO_FOR_FN_P (stmt) = 1;\n+  if (current_function)\n+    {\n+      /* The line-number recorded in the outermost statement in a function\n+\t is the line number of the end of the function.  */\n+      STMT_LINENO (stmt) = lineno;\n+      STMT_LINENO_FOR_FN_P (stmt) = 1;\n+    }\n }\n \n /* We're about to expand T, a statement.  Set up appropriate context"}, {"sha": "347668bc36111d22a369215b4eb122c8cc745888", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -1617,7 +1617,6 @@ search_tree (tp, func)\n     case TARGET_EXPR:\n     case AGGR_INIT_EXPR:\n     case NEW_EXPR:\n-    case VEC_INIT_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       TRY (TREE_OPERAND (t, 1));\n       TRY (TREE_OPERAND (t, 2));\n@@ -1988,7 +1987,6 @@ mapcar (t, func)\n       return t;\n \n     case NEW_EXPR:\n-    case VEC_INIT_EXPR:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);"}, {"sha": "f28ac8e7e72ad2169d566ff692033af28b9fd6d0", "filename": "gcc/testsuite/g++.old-deja/g++.ext/stmtexpr1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fstmtexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f80451c66dcc194baf195462734046e0b06934e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fstmtexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fstmtexpr1.C?ref=6f80451c66dcc194baf195462734046e0b06934e", "patch": "@@ -0,0 +1,8 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options:\n+\n+void f ()\n+{\n+  int i = ({ l: 3; });\n+}"}]}