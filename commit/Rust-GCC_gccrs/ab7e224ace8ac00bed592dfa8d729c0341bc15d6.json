{"sha": "ab7e224ace8ac00bed592dfa8d729c0341bc15d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3ZTIyNGFjZThhYzAwYmVkNTkyZGZhOGQ3MjljMDM0MWJjMTVkNg==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@spamcop.net", "date": "2010-01-19T05:46:27Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2010-01-19T05:46:27Z"}, "message": "tm.texi (TARGET_FIXED_CONDITION_CODE_REGS): Add argument names.\n\n\t* doc/tm.texi (TARGET_FIXED_CONDITION_CODE_REGS): Add argument names.\n\n\t(TARGET_CC_MODES_COMPATIBLE): Put return value in braces.\n\tAdd argument names.\n\n\t(TARGET_SCHED_INIT_SCHED_CONTEXT): Clarify language.\n\nFrom-SVN: r156034", "tree": {"sha": "6adf8f7b78d3e7c91dfa03d4c506c4110c34ce50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6adf8f7b78d3e7c91dfa03d4c506c4110c34ce50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab7e224ace8ac00bed592dfa8d729c0341bc15d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab7e224ace8ac00bed592dfa8d729c0341bc15d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab7e224ace8ac00bed592dfa8d729c0341bc15d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab7e224ace8ac00bed592dfa8d729c0341bc15d6/comments", "author": null, "committer": null, "parents": [{"sha": "547cc7eefe0dc2fa2086e674eb472aee26339f5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/547cc7eefe0dc2fa2086e674eb472aee26339f5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/547cc7eefe0dc2fa2086e674eb472aee26339f5a"}], "stats": {"total": 18, "additions": 13, "deletions": 5}, "files": [{"sha": "82f38e4dfb480e192635e052d3247d18e42a75d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e224ace8ac00bed592dfa8d729c0341bc15d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e224ace8ac00bed592dfa8d729c0341bc15d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab7e224ace8ac00bed592dfa8d729c0341bc15d6", "patch": "@@ -1,3 +1,12 @@\n+2010-01-19  Joern Rennecke  <amylaar@spamcop.net>\n+\n+\t* doc/tm.texi (TARGET_FIXED_CONDITION_CODE_REGS): Add argument names.\n+\n+\t(TARGET_CC_MODES_COMPATIBLE): Put return value in braces.\n+\tAdd argument names.\n+\n+\t(TARGET_SCHED_INIT_SCHED_CONTEXT): Clarify language.\n+\n 2010-01-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/42774"}, {"sha": "22ea8a17de8f4eb229eaa15be21c8a5c8ec58d6c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab7e224ace8ac00bed592dfa8d729c0341bc15d6/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab7e224ace8ac00bed592dfa8d729c0341bc15d6/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ab7e224ace8ac00bed592dfa8d729c0341bc15d6", "patch": "@@ -5998,7 +5998,7 @@ like:\n @end smallexample\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *, unsigned int *)\n+@deftypefn {Target Hook} bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *@var{p1}, unsigned int *@var{p2})\n On targets which do not use @code{(cc0)}, and which use a hard\n register rather than a pseudo-register to hold condition codes, the\n regular CSE passes are often not able to identify cases in which the\n@@ -6007,13 +6007,13 @@ small pass which optimizes such cases.  This hook should return true\n to enable this pass, and it should set the integers to which its\n arguments point to the hard register numbers used for condition codes.\n When there is only one such register, as is true on most systems, the\n-integer pointed to by the second argument should be set to\n+integer pointed to by @var{p2} should be set to\n @code{INVALID_REGNUM}.\n \n The default version of this hook returns false.\n @end deftypefn\n \n-@deftypefn {Target Hook} enum machine_mode TARGET_CC_MODES_COMPATIBLE (enum machine_mode, enum machine_mode)\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_CC_MODES_COMPATIBLE (enum machine_mode @var{m1}, enum machine_mode @var{m2})\n On targets which use multiple condition code modes in class\n @code{MODE_CC}, it is sometimes the case that a comparison can be\n validly done in more than one mode.  On such a system, define this\n@@ -6599,8 +6599,7 @@ Return a pointer to a store large enough to hold target scheduling context.\n @deftypefn {Target Hook} void TARGET_SCHED_INIT_SCHED_CONTEXT (void *@var{tc}, bool @var{clean_p})\n Initialize store pointed to by @var{tc} to hold target scheduling context.\n It @var{clean_p} is true then initialize @var{tc} as if scheduler is at the\n-beginning of the block.  Otherwise, make a copy of the current context in\n-@var{tc}.\n+beginning of the block.  Otherwise, copy the current context into @var{tc}.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_CONTEXT (void *@var{tc})"}]}