{"sha": "6e5b5de88b7764a779cee87591186a01cab96f50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU1YjVkZTg4Yjc3NjRhNzc5Y2VlODc1OTExODZhMDFjYWI5NmY1MA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2015-05-19T17:30:25Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2015-05-19T17:30:25Z"}, "message": "S/390 Add vector scalar instruction support.\n\nWith this patch GCC makes use of the vector instruction which are\navailable in single element mode.  By using these instructions scalar\ndouble operations can use 32 registers.\n\ngcc/\n\t* config/s390/s390-modes.def: Add new modes CCVEQ, CCVFH, and\n\tCCVFHE.\n\t* config/s390/s390.c (s390_match_ccmode_set): Handle new modes.\n\t(s390_select_ccmode): Likewise.\n\t(s390_canonicalize_comparison): Swap operands if necessary.\n\t(s390_expand_vec_compare_scalar): Expand DFmode compare using\n\tsingle element vector instructions.\n\t(s390_emit_compare): Call s390_expand_vec_compare_scalar.\n\t(s390_branch_condition_mask): Generate CC masks for the new modes.\n\t* config/s390/s390.md (v0, vf, vd): New mode attributes.\n\t(VFCMP, asm_fcmp, insn_cmp): New mode iterator and attributes.\n\t(*vec_cmp<insn_cmp>df_cconly, *fixuns_truncdfdi2_z13)\n\t(*fix_trunc<BFP:mode><GPR:mode>2_bfp, *floatunsdidf2_z13)\n\t(*floatuns<GPR:mode><FP:mode>2, *extendsfdf2_z13)\n\t(*extend<DSF:mode><BFP:mode>2): New insn definition.\n\t(fix_trunc<BFP:mode><GPR:mode>2_bfp, loatuns<GPR:mode><FP:mode>2)\n\t(extend<DSF:mode><BFP:mode>2): Turn into expander.\n\t(floatdi<mode>2, truncdfsf2, add<mode>3, sub<mode>3, mul<mode>3)\n\t(div<mode>3, *neg<mode>2, *abs<mode>2, *negabs<mode>2)\n\t(sqrt<mode>2): Add vector instruction.\n\ngcc/testsuite/\n\t* gcc.target/s390/vector/vec-scalar-cmp-1.c: New test.\n\nFrom-SVN: r223397", "tree": {"sha": "196e4e08c320a4f82e80110361a66a48300828a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/196e4e08c320a4f82e80110361a66a48300828a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e5b5de88b7764a779cee87591186a01cab96f50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5b5de88b7764a779cee87591186a01cab96f50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e5b5de88b7764a779cee87591186a01cab96f50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5b5de88b7764a779cee87591186a01cab96f50/comments", "author": null, "committer": null, "parents": [{"sha": "91b019a388a79e71bef9c0efd8a7a4664c4430c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b019a388a79e71bef9c0efd8a7a4664c4430c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b019a388a79e71bef9c0efd8a7a4664c4430c2"}], "stats": {"total": 520, "additions": 429, "deletions": 91}, "files": [{"sha": "f646147446bd440456fe8b3c4456239d5e6e83a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e5b5de88b7764a779cee87591186a01cab96f50", "patch": "@@ -1,3 +1,26 @@\n+2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390-modes.def: Add new modes CCVEQ, CCVFH, and\n+\tCCVFHE.\n+\t* config/s390/s390.c (s390_match_ccmode_set): Handle new modes.\n+\t(s390_select_ccmode): Likewise.\n+\t(s390_canonicalize_comparison): Swap operands if necessary.\n+\t(s390_expand_vec_compare_scalar): Expand DFmode compare using\n+\tsingle element vector instructions.\n+\t(s390_emit_compare): Call s390_expand_vec_compare_scalar.\n+\t(s390_branch_condition_mask): Generate CC masks for the new modes.\n+\t* config/s390/s390.md (v0, vf, vd): New mode attributes.\n+\t(VFCMP, asm_fcmp, insn_cmp): New mode iterator and attributes.\n+\t(*vec_cmp<insn_cmp>df_cconly, *fixuns_truncdfdi2_z13)\n+\t(*fix_trunc<BFP:mode><GPR:mode>2_bfp, *floatunsdidf2_z13)\n+\t(*floatuns<GPR:mode><FP:mode>2, *extendsfdf2_z13)\n+\t(*extend<DSF:mode><BFP:mode>2): New insn definition.\n+\t(fix_trunc<BFP:mode><GPR:mode>2_bfp, loatuns<GPR:mode><FP:mode>2)\n+\t(extend<DSF:mode><BFP:mode>2): Turn into expander.\n+\t(floatdi<mode>2, truncdfsf2, add<mode>3, sub<mode>3, mul<mode>3)\n+\t(div<mode>3, *neg<mode>2, *abs<mode>2, *negabs<mode>2)\n+\t(sqrt<mode>2): Add vector instruction.\n+\n 2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/constraints.md (j00, jm1, jxx, jyy, v): New"}, {"sha": "26c0a8165a2839f6b41baca378f7711931ef56e4", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=6e5b5de88b7764a779cee87591186a01cab96f50", "patch": "@@ -84,7 +84,12 @@ Requested mode            -> Destination CC register mode\n CCS, CCU, CCT, CCSR, CCUR -> CCZ\n CCA                       -> CCAP, CCAN\n \n+Vector comparison modes\n \n+CCVEQ  \t  EQ\t  - \t       - \t   NE\t      (VCEQ)\n+\n+CCVFH\t  GT\t  -   \t       -   \t   UNLE\t      (VFCH)\n+CCVFHE\t  GE\t  -   \t       -   \t   UNLT\t      (VFCHE)\n *** Comments ***\n \n CCAP, CCAN\n@@ -182,6 +187,11 @@ CC_MODE (CCT2);\n CC_MODE (CCT3);\n CC_MODE (CCRAW);\n \n+CC_MODE (CCVEQ);\n+CC_MODE (CCVFH);\n+CC_MODE (CCVFHE);\n+\n+\n /* Vector modes.  */\n \n VECTOR_MODES (INT, 2);        /*                 V2QI */"}, {"sha": "68a92a9294649fb75616d843d622dbdc1a803006", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 127, "deletions": 3, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6e5b5de88b7764a779cee87591186a01cab96f50", "patch": "@@ -681,6 +681,9 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n     case CCT1mode:\n     case CCT2mode:\n     case CCT3mode:\n+    case CCVEQmode:\n+    case CCVFHmode:\n+    case CCVFHEmode:\n       if (req_mode != set_mode)\n         return 0;\n       break;\n@@ -781,6 +784,29 @@ s390_tm_ccmode (rtx op1, rtx op2, bool mixed)\n machine_mode\n s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n {\n+  if (TARGET_VX\n+      && register_operand (op0, DFmode)\n+      && register_operand (op1, DFmode))\n+    {\n+      /* LT, LE, UNGT, UNGE require swapping OP0 and OP1.  Either\n+\t s390_emit_compare or s390_canonicalize_comparison will take\n+\t care of it.  */\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\tcase NE:\n+\t  return CCVEQmode;\n+\tcase GT:\n+\tcase UNLE:\n+\t  return CCVFHmode;\n+\tcase GE:\n+\tcase UNLT:\n+\t  return CCVFHEmode;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+\n   switch (code)\n     {\n       case EQ:\n@@ -1058,8 +1084,73 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n       rtx tem = *op0; *op0 = *op1; *op1 = tem;\n       *code = (int)swap_condition ((enum rtx_code)*code);\n     }\n+\n+  /* Using the scalar variants of vector instructions for 64 bit FP\n+     comparisons might require swapping the operands.  */\n+  if (TARGET_VX\n+      && register_operand (*op0, DFmode)\n+      && register_operand (*op1, DFmode)\n+      && (*code == LT || *code == LE || *code == UNGT || *code == UNGE))\n+    {\n+      rtx tmp;\n+\n+      switch (*code)\n+\t{\n+\tcase LT:   *code = GT; break;\n+\tcase LE:   *code = GE; break;\n+\tcase UNGT: *code = UNLE; break;\n+\tcase UNGE: *code = UNLT; break;\n+\tdefault: ;\n+\t}\n+      tmp = *op0; *op0 = *op1; *op1 = tmp;\n+    }\n }\n \n+/* Helper function for s390_emit_compare.  If possible emit a 64 bit\n+   FP compare using the single element variant of vector instructions.\n+   Replace CODE with the comparison code to be used in the CC reg\n+   compare and return the condition code register RTX in CC.  */\n+\n+static bool\n+s390_expand_vec_compare_scalar (enum rtx_code *code, rtx cmp1, rtx cmp2,\n+\t\t\t\trtx *cc)\n+{\n+  machine_mode cmp_mode;\n+  bool swap_p = false;\n+\n+  switch (*code)\n+    {\n+    case EQ:   cmp_mode = CCVEQmode;  break;\n+    case NE:   cmp_mode = CCVEQmode;  break;\n+    case GT:   cmp_mode = CCVFHmode;  break;\n+    case GE:   cmp_mode = CCVFHEmode; break;\n+    case UNLE: cmp_mode = CCVFHmode;  break;\n+    case UNLT: cmp_mode = CCVFHEmode; break;\n+    case LT:   cmp_mode = CCVFHmode;  *code = GT;   swap_p = true; break;\n+    case LE:   cmp_mode = CCVFHEmode; *code = GE;   swap_p = true; break;\n+    case UNGE: cmp_mode = CCVFHmode;  *code = UNLE; swap_p = true; break;\n+    case UNGT: cmp_mode = CCVFHEmode; *code = UNLT; swap_p = true; break;\n+    default: return false;\n+    }\n+\n+  if (swap_p)\n+    {\n+      rtx tmp = cmp2;\n+      cmp2 = cmp1;\n+      cmp1 = tmp;\n+    }\n+  *cc = gen_rtx_REG (cmp_mode, CC_REGNUM);\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t       gen_rtvec (2,\n+\t\t\t  gen_rtx_SET (*cc,\n+\t\t\t\t       gen_rtx_COMPARE (cmp_mode, cmp1,\n+\t\t\t\t\t\t\tcmp2)),\n+\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t   gen_rtx_SCRATCH (V2DImode)))));\n+  return true;\n+}\n+\n+\n /* Emit a compare instruction suitable to implement the comparison\n    OP0 CODE OP1.  Return the correct condition RTL to be placed in\n    the IF_THEN_ELSE of the conditional branch testing the result.  */\n@@ -1070,10 +1161,18 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n   machine_mode mode = s390_select_ccmode (code, op0, op1);\n   rtx cc;\n \n-  /* Do not output a redundant compare instruction if a compare_and_swap\n-     pattern already computed the result and the machine modes are compatible.  */\n-  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n+  if (TARGET_VX\n+      && register_operand (op0, DFmode)\n+      && register_operand (op1, DFmode)\n+      && s390_expand_vec_compare_scalar (&code, op0, op1, &cc))\n+    {\n+      /* Work has been done by s390_expand_vec_compare_scalar already.  */\n+    }\n+  else if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n     {\n+      /* Do not output a redundant compare instruction if a\n+\t compare_and_swap pattern already computed the result and the\n+\t machine modes are compatible.  */\n       gcc_assert (s390_cc_modes_compatible (GET_MODE (op0), mode)\n \t\t  == GET_MODE (op0));\n       cc = op0;\n@@ -1308,6 +1407,31 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n+      /* Vector comparison modes.  */\n+\n+    case CCVEQmode:\n+      switch (GET_CODE (code))\n+\t{\n+\tcase EQ:        return CC0;\n+\tcase NE:        return CC3;\n+\tdefault:        return -1;\n+\t}\n+      /* FP vector compare modes.  */\n+\n+    case CCVFHmode:\n+      switch (GET_CODE (code))\n+\t{\n+\tcase GT:        return CC0;\n+\tcase UNLE:      return CC3;\n+\tdefault:        return -1;\n+\t}\n+    case CCVFHEmode:\n+      switch (GET_CODE (code))\n+\t{\n+\tcase GE:        return CC0;\n+\tcase UNLT:      return CC3;\n+\tdefault:        return -1;\n+\t}\n     case CCRAWmode:\n       switch (GET_CODE (code))\n \t{"}, {"sha": "e1188ba4f21889a58bad9473308622ab6b76a739", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 216, "deletions": 88, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=6e5b5de88b7764a779cee87591186a01cab96f50", "patch": "@@ -524,6 +524,14 @@\n ;; first and the second operand match for bfp modes.\n (define_mode_attr f0 [(TF \"0\") (DF \"0\") (SF \"0\") (TD \"f\") (DD \"f\") (DD \"f\")])\n \n+;; This attribute is used to merge the scalar vector instructions into\n+;; the FP patterns.  For non-supported modes (all but DF) it expands\n+;; to constraints which are supposed to be matched by an earlier\n+;; variant.\n+(define_mode_attr v0      [(TF \"0\") (DF \"v\") (SF \"0\") (TD \"0\") (DD \"0\") (DD \"0\") (TI \"0\") (DI \"v\") (SI \"0\")])\n+(define_mode_attr vf      [(TF \"f\") (DF \"v\") (SF \"f\") (TD \"f\") (DD \"f\") (DD \"f\") (TI \"f\") (DI \"v\") (SI \"f\")])\n+(define_mode_attr vd      [(TF \"d\") (DF \"v\") (SF \"d\") (TD \"d\") (DD \"d\") (DD \"d\") (TI \"d\") (DI \"v\") (SI \"d\")])\n+\n ;; This attribute is used in the operand list of the instruction to have an\n ;; additional operand for the dfp instructions.\n (define_mode_attr op1 [(TF \"\") (DF \"\") (SF \"\")\n@@ -635,6 +643,17 @@\n ;; Allow return and simple_return to be defined from a single template.\n (define_code_iterator ANY_RETURN [return simple_return])\n \n+\n+\n+; Condition code modes generated by vector fp comparisons.  These will\n+; be used also in single element mode.\n+(define_mode_iterator VFCMP [CCVEQ CCVFH CCVFHE])\n+; Used with VFCMP to expand part of the mnemonic\n+; For fp we have a mismatch: eq in the insn name - e in asm\n+(define_mode_attr asm_fcmp [(CCVEQ \"e\") (CCVFH \"h\") (CCVFHE \"he\")])\n+(define_mode_attr insn_cmp [(CCVEQ \"eq\") (CCVFH \"h\") (CCVFHE \"he\")])\n+\n+\n (include \"vector.md\")\n \n ;;\n@@ -1144,6 +1163,15 @@\n    [(set_attr \"op_type\" \"RRE,RXE\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n+; wfcedbs, wfchdbs, wfchedbs\n+(define_insn \"*vec_cmp<insn_cmp>df_cconly\"\n+  [(set (reg:VFCMP CC_REGNUM)\n+\t(compare:VFCMP (match_operand:DF 0 \"register_operand\" \"v\")\n+\t\t       (match_operand:DF 1 \"register_operand\" \"v\")))\n+   (clobber (match_scratch:V2DI 2 \"=v\"))]\n+  \"TARGET_Z13 && TARGET_HARD_FLOAT\"\n+  \"wfc<asm_fcmp>dbs\\t%v2,%v0,%v1\"\n+  [(set_attr \"op_type\" \"VRR\")])\n \n ; Compare and Branch instructions\n \n@@ -4360,14 +4388,27 @@\n \n ; fixuns_trunc(tf|df|sf|td|dd)(di|si)2 instruction patterns.\n \n+(define_insn \"*fixuns_truncdfdi2_z13\"\n+  [(set (match_operand:DI                  0 \"register_operand\" \"=d,v\")\n+\t(unsigned_fix:DI (match_operand:DF 1 \"register_operand\"  \"f,v\")))\n+   (unspec:DI [(match_operand:DI           2 \"immediate_operand\" \"K,K\")] UNSPEC_ROUND)\n+   (clobber (reg:CC CC_REGNUM))]\n+   \"TARGET_Z13 && TARGET_HARD_FLOAT\"\n+   \"@\n+    clgdbr\\t%0,%h2,%1,0\n+    wclgdb\\t%v0,%v1,0,%h2\"\n+   [(set_attr \"op_type\" \"RRF,VRR\")\n+    (set_attr \"type\"    \"ftoi\")])\n+\n ; clfebr, clfdbr, clfxbr, clgebr, clgdbr, clgxbr\n ;         clfdtr, clfxtr,         clgdtr, clgxtr\n (define_insn \"*fixuns_trunc<FP:mode><GPR:mode>2_z196\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n-\t(unsigned_fix:GPR (match_operand:FP 1 \"register_operand\" \"f\")))\n-   (unspec:GPR [(match_operand:GPR 2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n+  [(set (match_operand:GPR                  0 \"register_operand\" \"=d\")\n+\t(unsigned_fix:GPR (match_operand:FP 1 \"register_operand\"  \"f\")))\n+   (unspec:GPR [(match_operand:GPR          2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n    (clobber (reg:CC CC_REGNUM))]\n-   \"TARGET_Z196\"\n+   \"TARGET_Z196 && TARGET_HARD_FLOAT\n+    && (!TARGET_Z13 || <GPR:MODE>mode != DImode || <FP:MODE>mode != DFmode)\"\n    \"cl<GPR:gf><FP:xde><FP:bt>r\\t%0,%h2,%1,0\"\n    [(set_attr \"op_type\" \"RRF\")\n     (set_attr \"type\"    \"ftoi\")])\n@@ -4382,18 +4423,37 @@\n   DONE;\n })\n \n+(define_insn \"*fix_truncdfdi2_bfp_z13\"\n+  [(set (match_operand:DI         0 \"register_operand\" \"=d,v\")\n+        (fix:DI (match_operand:DF 1 \"register_operand\"  \"f,v\")))\n+   (unspec:DI [(match_operand:DI  2 \"immediate_operand\" \"K,K\")] UNSPEC_ROUND)\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z13 && TARGET_HARD_FLOAT\"\n+  \"@\n+   cgdbr\\t%0,%h2,%1\n+   wcgdb\\t%v0,%v1,0,%h2\"\n+  [(set_attr \"op_type\" \"RRE,VRR\")\n+   (set_attr \"type\"    \"ftoi\")])\n+\n ; cgxbr, cgdbr, cgebr, cfxbr, cfdbr, cfebr\n-(define_insn \"fix_trunc<BFP:mode><GPR:mode>2_bfp\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-        (fix:GPR (match_operand:BFP 1 \"register_operand\" \"f\")))\n-   (unspec:GPR [(match_operand:GPR 2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n+(define_insn \"*fix_trunc<BFP:mode><GPR:mode>2_bfp\"\n+  [(set (match_operand:GPR          0 \"register_operand\" \"=d\")\n+        (fix:GPR (match_operand:BFP 1 \"register_operand\"  \"f\")))\n+   (unspec:GPR [(match_operand:GPR  2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_HARD_FLOAT\"\n+  \"TARGET_HARD_FLOAT\n+    && (!TARGET_VX || <GPR:MODE>mode != DImode || <BFP:MODE>mode != DFmode)\"\n   \"c<GPR:gf><BFP:xde>br\\t%0,%h2,%1\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"type\"    \"ftoi\")])\n \n-\n+(define_expand \"fix_trunc<BFP:mode><GPR:mode>2_bfp\"\n+  [(parallel\n+    [(set (match_operand:GPR          0 \"register_operand\" \"=d\")\n+\t  (fix:GPR (match_operand:BFP 1 \"register_operand\"  \"f\")))\n+     (unspec:GPR [(match_operand:GPR  2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n+     (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_HARD_FLOAT\")\n ;\n ; fix_trunc(td|dd)di2 instruction pattern(s).\n ;\n@@ -4440,12 +4500,15 @@\n \n ; cxgbr, cdgbr, cegbr, cxgtr, cdgtr\n (define_insn \"floatdi<mode>2\"\n-  [(set (match_operand:FP 0 \"register_operand\" \"=f\")\n-        (float:FP (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  [(set (match_operand:FP           0 \"register_operand\" \"=f,<vf>\")\n+        (float:FP (match_operand:DI 1 \"register_operand\"  \"d,<vd>\")))]\n   \"TARGET_ZARCH && TARGET_HARD_FLOAT\"\n-  \"c<xde>g<bt>r\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\"    \"itof<mode>\" )])\n+  \"@\n+   c<xde>g<bt>r\\t%0,%1\n+   wcdgb\\t%v0,%v1,0,0\"\n+  [(set_attr \"op_type\"      \"RRE,VRR\")\n+   (set_attr \"type\"         \"itof<mode>\" )\n+   (set_attr \"cpu_facility\" \"*,vec\")])\n \n ; cxfbr, cdfbr, cefbr\n (define_insn \"floatsi<mode>2\"\n@@ -4469,27 +4532,47 @@\n ; floatuns(si|di)(tf|df|sf|td|dd)2 instruction pattern(s).\n ;\n \n+(define_insn \"*floatunsdidf2_z13\"\n+  [(set (match_operand:DF                    0 \"register_operand\" \"=f,v\")\n+        (unsigned_float:DF (match_operand:DI 1 \"register_operand\"  \"d,v\")))]\n+  \"TARGET_Z13 && TARGET_HARD_FLOAT\"\n+  \"@\n+   cdlgbr\\t%0,0,%1,0\n+   wcdlgb\\t%v0,%v1,0,0\"\n+  [(set_attr \"op_type\" \"RRE,VRR\")\n+   (set_attr \"type\"    \"itofdf\")])\n+\n ; cxlgbr, cdlgbr, celgbr, cxlgtr, cdlgtr\n ; cxlfbr, cdlfbr, celfbr, cxlftr, cdlftr\n-(define_insn \"floatuns<GPR:mode><FP:mode>2\"\n-  [(set (match_operand:FP 0 \"register_operand\" \"=f\")\n-        (unsigned_float:FP (match_operand:GPR 1 \"register_operand\" \"d\")))]\n-  \"TARGET_Z196 && TARGET_HARD_FLOAT\"\n+(define_insn \"*floatuns<GPR:mode><FP:mode>2\"\n+  [(set (match_operand:FP                     0 \"register_operand\" \"=f\")\n+        (unsigned_float:FP (match_operand:GPR 1 \"register_operand\"  \"d\")))]\n+  \"TARGET_Z196 && TARGET_HARD_FLOAT\n+   && (!TARGET_VX || <FP:MODE>mode != DFmode || <GPR:MODE>mode != DImode)\"\n   \"c<FP:xde>l<GPR:gf><FP:bt>r\\t%0,0,%1,0\"\n   [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\"    \"itof<FP:mode>\" )])\n+   (set_attr \"type\"    \"itof<FP:mode>\")])\n+\n+(define_expand \"floatuns<GPR:mode><FP:mode>2\"\n+  [(set (match_operand:FP                     0 \"register_operand\" \"\")\n+        (unsigned_float:FP (match_operand:GPR 1 \"register_operand\" \"\")))]\n+  \"TARGET_Z196 && TARGET_HARD_FLOAT\")\n \n ;\n ; truncdfsf2 instruction pattern(s).\n ;\n \n (define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-        (float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:SF                    0 \"register_operand\" \"=f,v\")\n+        (float_truncate:SF (match_operand:DF 1 \"register_operand\"  \"f,v\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"ledbr\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"   \"ftruncdf\")])\n+  \"@\n+   ledbr\\t%0,%1\n+   wledb\\t%v0,%v1,0,0\" ; IEEE inexact exception not suppressed\n+                       ; According to BFP rounding mode\n+  [(set_attr \"op_type\"      \"RRE,VRR\")\n+   (set_attr \"type\"         \"ftruncdf\")\n+   (set_attr \"cpu_facility\" \"*,vec\")])\n \n ;\n ; trunctf(df|sf)2 instruction pattern(s).\n@@ -4542,17 +4625,35 @@\n ; extend(sf|df)(df|tf)2 instruction pattern(s).\n ;\n \n+(define_insn \"*extendsfdf2_z13\"\n+  [(set (match_operand:DF                  0 \"register_operand\"     \"=f,f,v\")\n+        (float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\"  \"f,R,v\")))]\n+  \"TARGET_Z13 && TARGET_HARD_FLOAT\"\n+  \"@\n+   ldebr\\t%0,%1\n+   ldeb\\t%0,%1\n+   wldeb\\t%v0,%v1\"\n+  [(set_attr \"op_type\" \"RRE,RXE,VRR\")\n+   (set_attr \"type\"    \"fsimpdf, floaddf,fsimpdf\")])\n+\n ; ldebr, ldeb, lxdbr, lxdb, lxebr, lxeb\n-(define_insn \"extend<DSF:mode><BFP:mode>2\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n+(define_insn \"*extend<DSF:mode><BFP:mode>2\"\n+  [(set (match_operand:BFP                   0 \"register_operand\"     \"=f,f\")\n         (float_extend:BFP (match_operand:DSF 1 \"nonimmediate_operand\"  \"f,R\")))]\n   \"TARGET_HARD_FLOAT\n-   && GET_MODE_SIZE (<BFP:MODE>mode) > GET_MODE_SIZE (<DSF:MODE>mode)\"\n+   && GET_MODE_SIZE (<BFP:MODE>mode) > GET_MODE_SIZE (<DSF:MODE>mode)\n+   && (!TARGET_VX || <BFP:MODE>mode != DFmode || <DSF:MODE>mode != SFmode)\"\n   \"@\n    l<BFP:xde><DSF:xde>br\\t%0,%1\n    l<BFP:xde><DSF:xde>b\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"   \"fsimp<BFP:mode>, fload<BFP:mode>\")])\n+  [(set_attr \"op_type\" \"RRE,RXE\")\n+   (set_attr \"type\"    \"fsimp<BFP:mode>, fload<BFP:mode>\")])\n+\n+(define_expand \"extend<DSF:mode><BFP:mode>2\"\n+  [(set (match_operand:BFP                   0 \"register_operand\"     \"\")\n+        (float_extend:BFP (match_operand:DSF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\n+   && GET_MODE_SIZE (<BFP:MODE>mode) > GET_MODE_SIZE (<DSF:MODE>mode)\")\n \n ;\n ; extendddtd2 and extendsddd2 instruction pattern(s).\n@@ -5156,17 +5257,20 @@\n ;\n \n ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n+; FIXME: wfadb does not clobber cc\n (define_insn \"add<mode>3\"\n-  [(set (match_operand:FP 0 \"register_operand\"              \"=f,   f\")\n-        (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,0\")\n-\t\t (match_operand:FP 2 \"general_operand\"      \" f,<Rf>\")))\n+  [(set (match_operand:FP 0 \"register_operand\"                 \"=f,   f,<vf>\")\n+        (plus:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,   0,<v0>\")\n+\t\t (match_operand:FP 2 \"general_operand\"          \"f,<Rf>,<vf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    a<xde><bt>r\\t%0,<op1>%2\n-   a<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   a<xde>b\\t%0,%2\n+   wfadb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"<RRer>,RXE,VRR\")\n+   (set_attr \"type\"         \"fsimp<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n ; axbr, adbr, aebr, axb, adb, aeb, adtr, axtr\n (define_insn \"*add<mode>3_cc\"\n@@ -5579,16 +5683,18 @@\n \n ; sxbr, sdbr, sebr, sdb, seb, sxtr, sdtr\n (define_insn \"sub<mode>3\"\n-  [(set (match_operand:FP 0 \"register_operand\"            \"=f,  f\")\n-        (minus:FP (match_operand:FP 1 \"register_operand\" \"<f0>,0\")\n-                  (match_operand:FP 2 \"general_operand\"  \"f,<Rf>\")))\n+  [(set (match_operand:FP           0 \"register_operand\"   \"=f,   f,<vf>\")\n+        (minus:FP (match_operand:FP 1 \"register_operand\" \"<f0>,   0,<v0>\")\n+                  (match_operand:FP 2 \"general_operand\"     \"f,<Rf>,<vf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    s<xde><bt>r\\t%0,<op1>%2\n-   s<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+   s<xde>b\\t%0,%2\n+   wfsdb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"<RRer>,RXE,VRR\")\n+   (set_attr \"type\"         \"fsimp<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n ; sxbr, sdbr, sebr, sdb, seb, sxtr, sdtr\n (define_insn \"*sub<mode>3_cc\"\n@@ -5994,41 +6100,47 @@\n \n ; mxbr, mdbr, meebr, mxb, mxb, meeb, mdtr, mxtr\n (define_insn \"mul<mode>3\"\n-  [(set (match_operand:FP 0 \"register_operand\"              \"=f,f\")\n-        (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,0\")\n-                 (match_operand:FP 2 \"general_operand\"      \"f,<Rf>\")))]\n+  [(set (match_operand:FP          0 \"register_operand\"        \"=f,   f,<vf>\")\n+        (mult:FP (match_operand:FP 1 \"nonimmediate_operand\" \"%<f0>,   0,<v0>\")\n+                 (match_operand:FP 2 \"general_operand\"          \"f,<Rf>,<vf>\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    m<xdee><bt>r\\t%0,<op1>%2\n-   m<xdee>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n-   (set_attr \"type\"     \"fmul<mode>\")])\n+   m<xdee>b\\t%0,%2\n+   wfmdb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"<RRer>,RXE,VRR\")\n+   (set_attr \"type\"         \"fmul<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n ; madbr, maebr, maxb, madb, maeb\n (define_insn \"fma<mode>4\"\n-  [(set (match_operand:DSF 0 \"register_operand\" \"=f,f\")\n-\t(fma:DSF (match_operand:DSF 1 \"nonimmediate_operand\" \"%f,f\")\n-\t\t (match_operand:DSF 2 \"nonimmediate_operand\" \"f,R\")\n-\t\t (match_operand:DSF 3 \"register_operand\" \"0,0\")))]\n+  [(set (match_operand:DSF          0 \"register_operand\"     \"=f,f,<vf>\")\n+\t(fma:DSF (match_operand:DSF 1 \"nonimmediate_operand\" \"%f,f,<vf>\")\n+\t\t (match_operand:DSF 2 \"nonimmediate_operand\"  \"f,R,<vf>\")\n+\t\t (match_operand:DSF 3 \"register_operand\"      \"0,0,<v0>\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    ma<xde>br\\t%0,%1,%2\n-   ma<xde>b\\t%0,%1,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fmadd<mode>\")])\n+   ma<xde>b\\t%0,%1,%2\n+   wfmadb\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\"      \"RRE,RXE,VRR\")\n+   (set_attr \"type\"         \"fmadd<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n ; msxbr, msdbr, msebr, msxb, msdb, mseb\n (define_insn \"fms<mode>4\"\n-  [(set (match_operand:DSF 0 \"register_operand\" \"=f,f\")\n-\t(fma:DSF (match_operand:DSF 1 \"nonimmediate_operand\" \"%f,f\")\n-\t\t (match_operand:DSF 2 \"nonimmediate_operand\" \"f,R\")\n-\t\t (neg:DSF (match_operand:DSF 3 \"register_operand\" \"0,0\"))))]\n+  [(set (match_operand:DSF                   0 \"register_operand\"     \"=f,f,<vf>\")\n+\t(fma:DSF (match_operand:DSF          1 \"nonimmediate_operand\" \"%f,f,<vf>\")\n+\t\t (match_operand:DSF          2 \"nonimmediate_operand\"  \"f,R,<vf>\")\n+\t\t (neg:DSF (match_operand:DSF 3 \"register_operand\"      \"0,0,<v0>\"))))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    ms<xde>br\\t%0,%1,%2\n-   ms<xde>b\\t%0,%1,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"     \"fmadd<mode>\")])\n+   ms<xde>b\\t%0,%1,%2\n+   wfmsdb\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\"      \"RRE,RXE,VRR\")\n+   (set_attr \"type\"         \"fmadd<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n ;;\n ;;- Divide and modulo instructions.\n@@ -6454,15 +6566,17 @@\n \n ; dxbr, ddbr, debr, dxb, ddb, deb, ddtr, dxtr\n (define_insn \"div<mode>3\"\n-  [(set (match_operand:FP 0 \"register_operand\"          \"=f,f\")\n-        (div:FP (match_operand:FP 1 \"register_operand\" \"<f0>,0\")\n-                 (match_operand:FP 2 \"general_operand\"  \"f,<Rf>\")))]\n+  [(set (match_operand:FP         0 \"register_operand\"   \"=f,   f,<vf>\")\n+        (div:FP (match_operand:FP 1 \"register_operand\" \"<f0>,   0,<v0>\")\n+\t\t(match_operand:FP 2 \"general_operand\"     \"f,<Rf>,<vf>\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    d<xde><bt>r\\t%0,<op1>%2\n-   d<xde>b\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"<RRer>,RXE\")\n-   (set_attr \"type\"     \"fdiv<mode>\")])\n+   d<xde>b\\t%0,%2\n+   wfddb\\t%v0,%v1,%v2\"\n+  [(set_attr \"op_type\"      \"<RRer>,RXE,VRR\")\n+   (set_attr \"type\"         \"fdiv<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n \n ;;\n@@ -7671,14 +7785,18 @@\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n ; lcxbr, lcdbr, lcebr\n+; FIXME: wflcdb does not clobber cc\n (define_insn \"*neg<mode>2\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n-        (neg:BFP (match_operand:BFP 1 \"register_operand\" \"f\")))\n+  [(set (match_operand:BFP          0 \"register_operand\" \"=f,<vf>\")\n+        (neg:BFP (match_operand:BFP 1 \"register_operand\"  \"f,<vf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n-  \"lc<xde>br\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  \"@\n+   lc<xde>br\\t%0,%1\n+   wflcdb\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,VRR\")\n+   (set_attr \"cpu_facility\" \"*,vec\")\n+   (set_attr \"type\"         \"fsimp<mode>,*\")])\n \n \n ;;\n@@ -7789,14 +7907,18 @@\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n ; lpxbr, lpdbr, lpebr\n+; FIXME: wflpdb does not clobber cc\n (define_insn \"*abs<mode>2\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n-        (abs:BFP (match_operand:BFP 1 \"register_operand\" \"f\")))\n+  [(set (match_operand:BFP          0 \"register_operand\" \"=f,<vf>\")\n+        (abs:BFP (match_operand:BFP 1 \"register_operand\"  \"f,<vf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n-  \"lp<xde>br\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  \"@\n+    lp<xde>br\\t%0,%1\n+    wflpdb\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,VRR\")\n+   (set_attr \"cpu_facility\" \"*,vec\")\n+   (set_attr \"type\"         \"fsimp<mode>,*\")])\n \n \n ;;\n@@ -7900,14 +8022,18 @@\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n ; lnxbr, lndbr, lnebr\n+; FIXME: wflndb does not clobber cc\n (define_insn \"*negabs<mode>2\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f\")\n-        (neg:BFP (abs:BFP (match_operand:BFP 1 \"register_operand\" \"f\"))))\n+  [(set (match_operand:BFP                   0 \"register_operand\" \"=f,<vf>\")\n+        (neg:BFP (abs:BFP (match_operand:BFP 1 \"register_operand\"  \"f,<vf>\"))))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT\"\n-  \"ln<xde>br\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RRE\")\n-   (set_attr \"type\"     \"fsimp<mode>\")])\n+  \"@\n+   ln<xde>br\\t%0,%1\n+   wflndb\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,VRR\")\n+   (set_attr \"cpu_facility\" \"*,vec\")\n+   (set_attr \"type\"         \"fsimp<mode>,*\")])\n \n ;;\n ;;- Square root instructions.\n@@ -7919,14 +8045,16 @@\n \n ; sqxbr, sqdbr, sqebr, sqdb, sqeb\n (define_insn \"sqrt<mode>2\"\n-  [(set (match_operand:BFP 0 \"register_operand\" \"=f,f\")\n-\t(sqrt:BFP (match_operand:BFP 1 \"general_operand\" \"f,<Rf>\")))]\n+  [(set (match_operand:BFP           0 \"register_operand\" \"=f,   f,<vf>\")\n+\t(sqrt:BFP (match_operand:BFP 1 \"general_operand\"   \"f,<Rf>,<vf>\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    sq<xde>br\\t%0,%1\n-   sq<xde>b\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXE\")\n-   (set_attr \"type\" \"fsqrt<mode>\")])\n+   sq<xde>b\\t%0,%1\n+   wfsqdb\\t%v0,%v1\"\n+  [(set_attr \"op_type\"      \"RRE,RXE,VRR\")\n+   (set_attr \"type\"         \"fsqrt<mode>\")\n+   (set_attr \"cpu_facility\" \"*,*,vec\")])\n \n \n ;;"}, {"sha": "7e0fd9d7338304ee8638520b0daa87f1ed080807", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e5b5de88b7764a779cee87591186a01cab96f50", "patch": "@@ -1,3 +1,7 @@\n+2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/vector/vec-scalar-cmp-1.c: New test.\n+\n 2015-05-19  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/s390.exp"}, {"sha": "b79120f20f0f7c435a010b1549812f1a1de3cf36", "filename": "gcc/testsuite/gcc.target/s390/vector/vec-scalar-cmp-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-scalar-cmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e5b5de88b7764a779cee87591186a01cab96f50/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-scalar-cmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fvec-scalar-cmp-1.c?ref=6e5b5de88b7764a779cee87591186a01cab96f50", "patch": "@@ -0,0 +1,49 @@\n+/* Check that we use the scalar variants of vector compares.  */\n+\n+/* { dg-do compile { target { s390*-*-* } } } */\n+/* { dg-options \"-O3 -mzarch -march=z13\" } */\n+\n+/* { dg-final { scan-assembler-times \"wfcedbs\\t%v\\[0-9\\]*,%v0,%v2\" 2 } } */\n+/* { dg-final { scan-assembler-times \"wfchdbs\\t%v\\[0-9\\]*,%v0,%v2\" 1 } } */\n+/* { dg-final { scan-assembler-times \"wfchedbs\\t%v\\[0-9\\]*,%v2,%v0\" 1 } } */\n+/* { dg-final { scan-assembler-times \"wfchdbs\\t%v\\[0-9\\]*,%v2,%v0\" 1 } } */\n+/* { dg-final { scan-assembler-times \"wfchedbs\\t%v\\[0-9\\]*,%v2,%v0\" 1 } } */\n+/* { dg-final { scan-assembler-times \"locrne\" 5 } } */\n+/* { dg-final { scan-assembler-times \"locrno\" 1 } } */\n+\n+\n+int\n+eq (double a, double b)\n+{\n+  return a == b;\n+}\n+\n+int\n+ne (double a, double b)\n+{\n+  return a != b;\n+}\n+\n+int\n+gt (double a, double b)\n+{\n+  return a > b;\n+}\n+\n+int\n+ge (double a, double b)\n+{\n+  return a >= b;\n+}\n+\n+int\n+lt (double a, double b)\n+{\n+  return a < b;\n+}\n+\n+int\n+le (double a, double b)\n+{\n+  return a <= b;\n+}"}]}