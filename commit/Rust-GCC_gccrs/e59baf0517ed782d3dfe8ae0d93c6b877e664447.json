{"sha": "e59baf0517ed782d3dfe8ae0d93c6b877e664447", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5YmFmMDUxN2VkNzgyZDNkZmU4YWUwZDkzYzZiODc3ZTY2NDQ0Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-04-11T19:51:52Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-04-11T19:51:52Z"}, "message": "re PR c++/52748 ([C++11] N3276 changes to decltype)\n\n\tPR c++/52748\n\t* parser.c (complain_flags): New.\n\t(cp_parser_postfix_expression): Use it.\n\t(cp_parser_unary_expression): Likewise.\n\t(cp_parser_binary_expression): Likewise.\n\t(cp_parser_assignment_expression): Likewise.\n\t(cp_parser_expression): Likewise.\n\t(cp_parser_postfix_open_square_expression): Take decltype_p.\n\t(cp_parser_builtin_offsetof): Adjust.\n\t(cp_convert_range_for): Pass complain to finish_unary_op_expr.\n\t* semantics.c (finish_unary_op_expr): Add complain parm.\n\nFrom-SVN: r197826", "tree": {"sha": "cf1aa9cecbf228591a7c53d99bdc51da8621d751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1aa9cecbf228591a7c53d99bdc51da8621d751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e59baf0517ed782d3dfe8ae0d93c6b877e664447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59baf0517ed782d3dfe8ae0d93c6b877e664447", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e59baf0517ed782d3dfe8ae0d93c6b877e664447", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59baf0517ed782d3dfe8ae0d93c6b877e664447/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43a8d6ccf2142b8128e659b14842f50cf2fa48b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a8d6ccf2142b8128e659b14842f50cf2fa48b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a8d6ccf2142b8128e659b14842f50cf2fa48b2"}], "stats": {"total": 177, "additions": 151, "deletions": 26}, "files": [{"sha": "d396893a59af684c7bd3ff8fb5d6873f05c10aa6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e59baf0517ed782d3dfe8ae0d93c6b877e664447", "patch": "@@ -1,3 +1,17 @@\n+2013-04-11  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/52748\n+\t* parser.c (complain_flags): New.\n+\t(cp_parser_postfix_expression): Use it.\n+\t(cp_parser_unary_expression): Likewise.\n+\t(cp_parser_binary_expression): Likewise.\n+\t(cp_parser_assignment_expression): Likewise.\n+\t(cp_parser_expression): Likewise.\n+\t(cp_parser_postfix_open_square_expression): Take decltype_p.\n+\t(cp_parser_builtin_offsetof): Adjust.\n+\t(cp_convert_range_for): Pass complain to finish_unary_op_expr.\n+\t* semantics.c (finish_unary_op_expr): Add complain parm.\n+\n 2013-04-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/56895"}, {"sha": "f7c65b68dc9954c78f7a04097a5fafad068fb578", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e59baf0517ed782d3dfe8ae0d93c6b877e664447", "patch": "@@ -5241,7 +5241,7 @@ extern void maybe_make_one_only\t\t\t(tree);\n extern bool vague_linkage_p\t\t\t(tree);\n extern void grokclassfn\t\t\t\t(tree, tree,\n \t\t\t\t\t\t enum overload_flags);\n-extern tree grok_array_decl\t\t\t(location_t, tree, tree);\n+extern tree grok_array_decl\t\t\t(location_t, tree, tree, bool);\n extern tree delete_sanity\t\t\t(tree, tree, bool, int, tsubst_flags_t);\n extern tree check_classfn\t\t\t(tree, tree, tree);\n extern void check_member_template\t\t(tree);\n@@ -5706,7 +5706,8 @@ extern tree finish_call_expr\t\t\t(tree, vec<tree, va_gc> **, bool,\n extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n-extern tree finish_unary_op_expr\t\t(location_t, enum tree_code, tree);\n+extern tree finish_unary_op_expr\t\t(location_t, enum tree_code, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree finish_compound_literal\t\t(tree, tree, tsubst_flags_t);\n extern tree finish_fname\t\t\t(tree);\n extern void finish_translation_unit\t\t(void);"}, {"sha": "a5b265502f77f9bc0478629aff40f9daa86e4e22", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e59baf0517ed782d3dfe8ae0d93c6b877e664447", "patch": "@@ -335,10 +335,11 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags)\n }\n \n /* Create an ARRAY_REF, checking for the user doing things backwards\n-   along the way.  */\n+   along the way.  DECLTYPE_P is for N3276, as in the parser.  */\n \n tree\n-grok_array_decl (location_t loc, tree array_expr, tree index_exp)\n+grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n+\t\t bool decltype_p)\n {\n   tree type;\n   tree expr;\n@@ -364,8 +365,13 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp)\n \n   /* If they have an `operator[]', use that.  */\n   if (MAYBE_CLASS_TYPE_P (type) || MAYBE_CLASS_TYPE_P (TREE_TYPE (index_exp)))\n-    expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr, index_exp,\n-\t\t\t NULL_TREE, /*overload=*/NULL, tf_warning_or_error);\n+    {\n+      tsubst_flags_t complain = tf_warning_or_error;\n+      if (decltype_p)\n+\tcomplain |= tf_decltype;\n+      expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n+\t\t\t   index_exp, NULL_TREE, /*overload=*/NULL, complain);\n+    }\n   else\n     {\n       tree p1, p2, i1, i2;"}, {"sha": "6b5020eefb6045daefcf4838e2cf8ca9b15cc7d5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e59baf0517ed782d3dfe8ae0d93c6b877e664447", "patch": "@@ -1852,7 +1852,7 @@ static tree cp_parser_qualifying_entity\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_postfix_open_square_expression\n-  (cp_parser *, tree, bool);\n+  (cp_parser *, tree, bool, bool);\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *, location_t);\n static vec<tree, va_gc> *cp_parser_parenthesized_expression_list\n@@ -3891,6 +3891,18 @@ cp_parser_translation_unit (cp_parser* parser)\n   return success;\n }\n \n+/* Return the appropriate tsubst flags for parsing, possibly in N3276\n+   decltype context.  */\n+\n+static inline tsubst_flags_t\n+complain_flags (bool decltype_p)\n+{\n+  tsubst_flags_t complain = tf_warning_or_error;\n+  if (decltype_p)\n+    complain |= tf_decltype;\n+  return complain;\n+}\n+\n /* Expressions [gram.expr] */\n \n /* Parse a primary-expression.\n@@ -5726,7 +5738,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  postfix_expression\n \t    = cp_parser_postfix_open_square_expression (parser,\n \t\t\t\t\t\t\tpostfix_expression,\n-\t\t\t\t\t\t\tfalse);\n+\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\tdecltype_p);\n \t  idk = CP_ID_KIND_NONE;\n           is_member_access = false;\n \t  break;\n@@ -5738,12 +5751,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    bool is_builtin_constant_p;\n \t    bool saved_integral_constant_expression_p = false;\n \t    bool saved_non_integral_constant_expression_p = false;\n-\t    int complain = tf_warning_or_error;\n+\t    tsubst_flags_t complain = complain_flags (decltype_p);\n \t    vec<tree, va_gc> *args;\n \n-\t    if (decltype_p)\n-\t      complain |= tf_decltype;\n-\n             is_member_access = false;\n \n \t    is_builtin_constant_p\n@@ -5972,7 +5982,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n static tree\n cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t\t\t\t\t  tree postfix_expression,\n-\t\t\t\t\t  bool for_offsetof)\n+\t\t\t\t\t  bool for_offsetof,\n+\t\t\t\t\t  bool decltype_p)\n {\n   tree index;\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n@@ -6006,7 +6017,8 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n   /* Build the ARRAY_REF.  */\n-  postfix_expression = grok_array_decl (loc, postfix_expression, index);\n+  postfix_expression = grok_array_decl (loc, postfix_expression,\n+\t\t\t\t\tindex, decltype_p);\n \n   /* When not doing offsetof, array references are not permitted in\n      constant-expressions.  */\n@@ -6702,6 +6714,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n       tree expression = error_mark_node;\n       non_integral_constant non_constant_p = NIC_NONE;\n       location_t loc = token->location;\n+      tsubst_flags_t complain = complain_flags (decltype_p);\n \n       /* Consume the operator token.  */\n       token = cp_lexer_consume_token (parser->lexer);\n@@ -6719,7 +6732,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  non_constant_p = NIC_STAR;\n \t  expression = build_x_indirect_ref (loc, cast_expression,\n \t\t\t\t\t     RO_UNARY_STAR,\n-                                             tf_warning_or_error);\n+                                             complain);\n \t  break;\n \n \tcase ADDR_EXPR:\n@@ -6728,7 +6741,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tcase BIT_NOT_EXPR:\n \t  expression = build_x_unary_op (loc, unary_operator,\n \t\t\t\t\t cast_expression,\n-                                         tf_warning_or_error);\n+                                         complain);\n \t  break;\n \n \tcase PREINCREMENT_EXPR:\n@@ -6740,7 +6753,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tcase NEGATE_EXPR:\n \tcase TRUTH_NOT_EXPR:\n \t  expression = finish_unary_op_expr (loc, unary_operator,\n-\t\t\t\t\t     cast_expression);\n+\t\t\t\t\t     cast_expression, complain);\n \t  break;\n \n \tdefault:\n@@ -7567,7 +7580,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \tcurrent.lhs = build_x_binary_op (current.loc, current.tree_type,\n \t\t\t\t\t current.lhs, current.lhs_type,\n \t\t\t\t\t rhs, rhs_type, &overload,\n-\t\t\t\t\t tf_warning_or_error);\n+\t\t\t\t\t complain_flags (decltype_p));\n       current.lhs_type = current.tree_type;\n       if (EXPR_P (current.lhs))\n \tSET_EXPR_LOCATION (current.lhs, current.loc);\n@@ -7722,7 +7735,7 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n \t      expr = build_x_modify_expr (loc, expr,\n \t\t\t\t\t  assignment_operator,\n \t\t\t\t\t  rhs,\n-\t\t\t\t\t  tf_warning_or_error);\n+\t\t\t\t\t  complain_flags (decltype_p));\n \t      input_location = saved_input_location;\n \t    }\n \t}\n@@ -7868,7 +7881,7 @@ cp_parser_expression (cp_parser* parser, bool cast_p, bool decltype_p,\n       else\n \texpression = build_x_compound_expr (loc, expression,\n \t\t\t\t\t    assignment_expression,\n-                                            tf_warning_or_error);\n+\t\t\t\t\t    complain_flags (decltype_p));\n       /* If the next token is not a comma, then we are done with the\n \t expression.  */\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n@@ -8019,12 +8032,14 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \t{\n \tcase CPP_OPEN_SQUARE:\n \t  /* offsetof-member-designator \"[\" expression \"]\" */\n-\t  expr = cp_parser_postfix_open_square_expression (parser, expr, true);\n+\t  expr = cp_parser_postfix_open_square_expression (parser, expr,\n+\t\t\t\t\t\t\t   true, false);\n \t  break;\n \n \tcase CPP_DEREF:\n \t  /* offsetof-member-designator \"->\" identifier */\n-\t  expr = grok_array_decl (token->location, expr, integer_zero_node);\n+\t  expr = grok_array_decl (token->location, expr,\n+\t\t\t\t  integer_zero_node, false);\n \t  /* FALLTHRU */\n \n \tcase CPP_DOT:\n@@ -9766,7 +9781,8 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n \n   /* The new increment expression.  */\n   expression = finish_unary_op_expr (input_location,\n-\t\t\t\t     PREINCREMENT_EXPR, begin);\n+\t\t\t\t     PREINCREMENT_EXPR, begin,\n+\t\t\t\t     tf_warning_or_error);\n   finish_for_expr (expression, statement);\n \n   /* The declaration is initialized with *__begin inside the loop body.  */"}, {"sha": "a09a7f480edc857c828c007ef6004c2b2b271764", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e59baf0517ed782d3dfe8ae0d93c6b877e664447", "patch": "@@ -2408,10 +2408,12 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n /* Finish an expression of the form CODE EXPR.  */\n \n tree\n-finish_unary_op_expr (location_t loc, enum tree_code code, tree expr)\n+finish_unary_op_expr (location_t loc, enum tree_code code, tree expr,\n+\t\t      tsubst_flags_t complain)\n {\n-  tree result = build_x_unary_op (loc, code, expr, tf_warning_or_error);\n-  if (TREE_OVERFLOW_P (result) && !TREE_OVERFLOW_P (expr))\n+  tree result = build_x_unary_op (loc, code, expr, complain);\n+  if ((complain & tf_warning)\n+      && TREE_OVERFLOW_P (result) && !TREE_OVERFLOW_P (expr))\n     overflow_warning (input_location, result);\n \n   return result;"}, {"sha": "1d12b0159b20d4cbc11ad8b770d0ff08cef27510", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype-call3.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-call3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59baf0517ed782d3dfe8ae0d93c6b877e664447/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-call3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype-call3.C?ref=e59baf0517ed782d3dfe8ae0d93c6b877e664447", "patch": "@@ -0,0 +1,86 @@\n+// Testcase for N3276 and operator overloading\n+// { dg-require-effective-target c++11 }\n+\n+struct A;\n+struct B {\n+  A operator()(int);\n+  A operator[](int);\n+  A operator=(int);\n+  A operator+=(int);\n+  A operator-=(int);\n+  A operator*=(int);\n+  A operator/=(int);\n+  A operator^=(int);\n+  A operator&=(int);\n+  A operator|=(int);\n+  A operator<<=(int);\n+  A operator>>=(int);\n+};\n+\n+A operator-(B);\n+A operator+(B);\n+A operator*(B);\n+A operator&(B);\n+A operator!(B);\n+A operator~(B);\n+A operator++(B);\n+A operator--(B);\n+\n+A operator+(B,B);\n+A operator-(B,B);\n+A operator*(B,B);\n+A operator/(B,B);\n+A operator%(B,B);\n+A operator^(B,B);\n+A operator&(B,B);\n+A operator|(B,B);\n+A operator<(B,B);\n+A operator>(B,B);\n+A operator,(B,B);\n+A operator<<(B,B);\n+A operator>>(B,B);\n+A operator==(B,B);\n+A operator->*(B,B);\n+\n+#define TRY(E) static_cast<decltype(E)*>(0)\n+int main()\n+{\n+  B b;\n+  TRY(b(0));\n+  TRY(b[0]);\n+  TRY(b=0);\n+  TRY(b+=0);\n+  TRY(b-=0);\n+  TRY(b*=0);\n+  TRY(b/=0);\n+  TRY(b^=0);\n+  TRY(b&=0);\n+  TRY(b|=0);\n+  TRY(b<<=0);\n+  TRY(b>>=0);\n+\n+  TRY(-b);\n+  TRY(+b);\n+  TRY(*b);\n+  TRY(&b);\n+  TRY(!b);\n+  TRY(~b);\n+  TRY(++b);\n+  TRY(--b);\n+\n+  TRY(b+b);\n+  TRY(b-b);\n+  TRY(b*b);\n+  TRY(b/b);\n+  TRY(b%b);\n+  TRY(b^b);\n+  TRY(b&b);\n+  TRY(b|b);\n+  TRY(b>b);\n+  TRY(b<b);\n+  TRY((b,b));\n+  TRY(b<<b);\n+  TRY(b>>b);\n+  TRY(b==b);\n+  TRY(b->*b);\n+}"}]}