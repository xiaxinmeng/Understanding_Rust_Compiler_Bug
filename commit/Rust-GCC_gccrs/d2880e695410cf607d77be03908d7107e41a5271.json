{"sha": "d2880e695410cf607d77be03908d7107e41a5271", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4ODBlNjk1NDEwY2Y2MDdkNzdiZTAzOTA4ZDcxMDdlNDFhNTI3MQ==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2019-09-18T08:32:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-18T08:32:19Z"}, "message": "[Ada] Factor out code for deciding statically known Constrained attributes\n\nCreate a separate routine in Exp_Util for deciding the value of the\nConstrained attribute when it is statically known. This routine is used\nin Exp_Attr and will be reused in the backend of GNATprove.\n\nThere is no impact on compilation and hence no test.\n\n2019-09-18  Claire Dross  <dross@adacore.com>\n\ngcc/ada/\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Call routine from\n\tExp_Util to know the value of the Constrained attribute in the\n\tstatic case.\n\t* exp_spark.adb (Expand_SPARK_N_Attribute_Reference): Make\n\timplicit dereferences inside the Constrained attribute explicit.\n\t* exp_util.ads, exp_util.adb\n\t(Attribute_Constrained_Static_Value): New routine to compute the\n\tvalue of a statically known reference to the Constrained\n\tattribute.\n\nFrom-SVN: r275848", "tree": {"sha": "57c6cac95e82f6ee492df37a5713a431ef033e55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57c6cac95e82f6ee492df37a5713a431ef033e55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2880e695410cf607d77be03908d7107e41a5271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2880e695410cf607d77be03908d7107e41a5271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2880e695410cf607d77be03908d7107e41a5271", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2880e695410cf607d77be03908d7107e41a5271/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "209a0094c4b1a8603b73beb77f28ea6c314d5875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/209a0094c4b1a8603b73beb77f28ea6c314d5875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/209a0094c4b1a8603b73beb77f28ea6c314d5875"}], "stats": {"total": 347, "additions": 208, "deletions": 139}, "files": [{"sha": "b5c319b2e08081949e5c02d93eeb0eecb941af7b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d2880e695410cf607d77be03908d7107e41a5271", "patch": "@@ -1,3 +1,15 @@\n+2019-09-18  Claire Dross  <dross@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Call routine from\n+\tExp_Util to know the value of the Constrained attribute in the\n+\tstatic case.\n+\t* exp_spark.adb (Expand_SPARK_N_Attribute_Reference): Make\n+\timplicit dereferences inside the Constrained attribute explicit.\n+\t* exp_util.ads, exp_util.adb\n+\t(Attribute_Constrained_Static_Value): New routine to compute the\n+\tvalue of a statically known reference to the Constrained\n+\tattribute.\n+\n 2019-09-18  Vadim Godunko  <godunko@adacore.com>\n \n \t* libgnat/g-expect.adb (Expect_Internal): Don't include invalid"}, {"sha": "a8e68bbb033f54923ae708d650d90176471f7082", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 13, "deletions": 139, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d2880e695410cf607d77be03908d7107e41a5271", "patch": "@@ -2770,40 +2770,6 @@ package body Exp_Attr is\n       when Attribute_Constrained => Constrained : declare\n          Formal_Ent : constant Entity_Id := Param_Entity (Pref);\n \n-         function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean;\n-         --  Ada 2005 (AI-363): Returns True if the object name Obj denotes a\n-         --  view of an aliased object whose subtype is constrained.\n-\n-         ---------------------------------\n-         -- Is_Constrained_Aliased_View --\n-         ---------------------------------\n-\n-         function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean is\n-            E : Entity_Id;\n-\n-         begin\n-            if Is_Entity_Name (Obj) then\n-               E := Entity (Obj);\n-\n-               if Present (Renamed_Object (E)) then\n-                  return Is_Constrained_Aliased_View (Renamed_Object (E));\n-               else\n-                  return Is_Aliased (E) and then Is_Constrained (Etype (E));\n-               end if;\n-\n-            else\n-               return Is_Aliased_View (Obj)\n-                        and then\n-                      (Is_Constrained (Etype (Obj))\n-                         or else\n-                           (Nkind (Obj) = N_Explicit_Dereference\n-                              and then\n-                                not Object_Type_Has_Constrained_Partial_View\n-                                      (Typ  => Base_Type (Etype (Obj)),\n-                                       Scop => Current_Scope)));\n-            end if;\n-         end Is_Constrained_Aliased_View;\n-\n       --  Start of processing for Constrained\n \n       begin\n@@ -2844,115 +2810,23 @@ package body Exp_Attr is\n               New_Occurrence_Of\n                 (Extra_Constrained (Entity (Pref)), Sloc (N)));\n \n-         --  For all other entity names, we can tell at compile time\n+         --  For all other cases, we can tell at compile time\n \n-         elsif Is_Entity_Name (Pref) then\n-            declare\n-               Ent : constant Entity_Id   := Entity (Pref);\n-               Res : Boolean;\n-\n-            begin\n-               --  (RM J.4) obsolescent cases\n-\n-               if Is_Type (Ent) then\n-\n-                  --  Private type\n-\n-                  if Is_Private_Type (Ent) then\n-                     Res := not Has_Discriminants (Ent)\n-                              or else Is_Constrained (Ent);\n-\n-                  --  It not a private type, must be a generic actual type\n-                  --  that corresponded to a private type. We know that this\n-                  --  correspondence holds, since otherwise the reference\n-                  --  within the generic template would have been illegal.\n-\n-                  else\n-                     if Is_Composite_Type (Underlying_Type (Ent)) then\n-                        Res := Is_Constrained (Ent);\n-                     else\n-                        Res := True;\n-                     end if;\n-                  end if;\n-\n-               else\n-                  --  For access type, apply access check as needed\n-\n-                  if Is_Access_Type (Ptyp) then\n-                     Apply_Access_Check (N);\n-                  end if;\n-\n-                  --  If the prefix is not a variable or is aliased, then\n-                  --  definitely true; if it's a formal parameter without an\n-                  --  associated extra formal, then treat it as constrained.\n-\n-                  --  Ada 2005 (AI-363): An aliased prefix must be known to be\n-                  --  constrained in order to set the attribute to True.\n-\n-                  if not Is_Variable (Pref)\n-                    or else Present (Formal_Ent)\n-                    or else (Ada_Version < Ada_2005\n-                              and then Is_Aliased_View (Pref))\n-                    or else (Ada_Version >= Ada_2005\n-                              and then Is_Constrained_Aliased_View (Pref))\n-                  then\n-                     Res := True;\n-\n-                  --  Variable case, look at type to see if it is constrained.\n-                  --  Note that the one case where this is not accurate (the\n-                  --  procedure formal case), has been handled above.\n-\n-                  --  We use the Underlying_Type here (and below) in case the\n-                  --  type is private without discriminants, but the full type\n-                  --  has discriminants. This case is illegal, but we generate\n-                  --  it internally for passing to the Extra_Constrained\n-                  --  parameter.\n-\n-                  else\n-                     --  In Ada 2012, test for case of a limited tagged type,\n-                     --  in which case the attribute is always required to\n-                     --  return True. The underlying type is tested, to make\n-                     --  sure we also return True for cases where there is an\n-                     --  unconstrained object with an untagged limited partial\n-                     --  view which has defaulted discriminants (such objects\n-                     --  always produce a False in earlier versions of\n-                     --  Ada). (Ada 2012: AI05-0214)\n-\n-                     Res :=\n-                       Is_Constrained (Underlying_Type (Etype (Ent)))\n-                         or else\n-                           (Ada_Version >= Ada_2012\n-                             and then Is_Tagged_Type (Underlying_Type (Ptyp))\n-                             and then Is_Limited_Type (Ptyp));\n-                  end if;\n-               end if;\n-\n-               Rewrite (N, New_Occurrence_Of (Boolean_Literals (Res), Loc));\n-            end;\n+         else\n+            --  For access type, apply access check as needed\n \n-         --  Prefix is not an entity name. These are also cases where we can\n-         --  always tell at compile time by looking at the form and type of the\n-         --  prefix. If an explicit dereference of an object with constrained\n-         --  partial view, this is unconstrained (Ada 2005: AI95-0363). If the\n-         --  underlying type is a limited tagged type, then Constrained is\n-         --  required to always return True (Ada 2012: AI05-0214).\n+            if Is_Entity_Name (Pref)\n+              and then not Is_Type (Entity (Pref))\n+              and then Is_Access_Type (Ptyp)\n+            then\n+               Apply_Access_Check (N);\n+            end if;\n \n-         else\n             Rewrite (N,\n-              New_Occurrence_Of (\n-                Boolean_Literals (\n-                  not Is_Variable (Pref)\n-                    or else\n-                     (Nkind (Pref) = N_Explicit_Dereference\n-                       and then\n-                         not Object_Type_Has_Constrained_Partial_View\n-                               (Typ  => Base_Type (Ptyp),\n-                                Scop => Current_Scope))\n-                    or else Is_Constrained (Underlying_Type (Ptyp))\n-                    or else (Ada_Version >= Ada_2012\n-                              and then Is_Tagged_Type (Underlying_Type (Ptyp))\n-                              and then Is_Limited_Type (Ptyp))),\n-                Loc));\n+              New_Occurrence_Of\n+                (Boolean_Literals\n+                   (Exp_Util.Attribute_Constrained_Static_Value\n+                      (Pref)), Sloc (N)));\n          end if;\n \n          Analyze_And_Resolve (N, Standard_Boolean);"}, {"sha": "28484aaaa79df592d46b7527962f9018a10e56bc", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=d2880e695410cf607d77be03908d7107e41a5271", "patch": "@@ -176,6 +176,7 @@ package body Exp_SPARK is\n       Aname   : constant Name_Id      := Attribute_Name (N);\n       Attr_Id : constant Attribute_Id := Get_Attribute_Id (Aname);\n       Loc     : constant Source_Ptr   := Sloc (N);\n+      Pref    : constant Node_Id      := Prefix (N);\n       Typ     : constant Entity_Id    := Etype (N);\n       Expr    : Node_Id;\n \n@@ -302,6 +303,20 @@ package body Exp_SPARK is\n                Set_Do_Overflow_Check (N);\n             end if;\n          end;\n+\n+      elsif Attr_Id = Attribute_Constrained then\n+\n+         --  If the prefix is an access to object, the attribute applies to\n+         --  the designated object, so rewrite with an explicit dereference.\n+\n+         if Is_Access_Type (Etype (Pref))\n+           and then\n+             (not Is_Entity_Name (Pref) or else Is_Object (Entity (Pref)))\n+         then\n+            Rewrite (Pref,\n+                     Make_Explicit_Dereference (Loc, Relocate_Node (Pref)));\n+            Analyze_And_Resolve (N, Standard_Boolean);\n+         end if;\n       end if;\n    end Expand_SPARK_N_Attribute_Reference;\n "}, {"sha": "06f5cc314be7cad8d8e06f48f6038e36c7c80c90", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d2880e695410cf607d77be03908d7107e41a5271", "patch": "@@ -32,6 +32,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n+with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;\n@@ -472,6 +473,169 @@ package body Exp_Util is\n       end if;\n    end Append_Freeze_Actions;\n \n+   --------------------------------------\n+   -- Attr_Constrained_Statically_True --\n+   --------------------------------------\n+\n+   function Attribute_Constrained_Static_Value (Pref : Node_Id) return Boolean\n+   is\n+      Ptyp       : constant Entity_Id := Etype (Pref);\n+      Formal_Ent : constant Entity_Id := Param_Entity (Pref);\n+\n+      function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean;\n+      --  Ada 2005 (AI-363): Returns True if the object name Obj denotes a\n+      --  view of an aliased object whose subtype is constrained.\n+\n+      ---------------------------------\n+      -- Is_Constrained_Aliased_View --\n+      ---------------------------------\n+\n+      function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean is\n+         E : Entity_Id;\n+\n+      begin\n+         if Is_Entity_Name (Obj) then\n+            E := Entity (Obj);\n+\n+            if Present (Renamed_Object (E)) then\n+               return Is_Constrained_Aliased_View (Renamed_Object (E));\n+            else\n+               return Is_Aliased (E) and then Is_Constrained (Etype (E));\n+            end if;\n+\n+         else\n+            return Is_Aliased_View (Obj)\n+              and then\n+                (Is_Constrained (Etype (Obj))\n+                 or else\n+                   (Nkind (Obj) = N_Explicit_Dereference\n+                    and then\n+                      not Object_Type_Has_Constrained_Partial_View\n+                        (Typ  => Base_Type (Etype (Obj)),\n+                         Scop => Current_Scope)));\n+         end if;\n+      end Is_Constrained_Aliased_View;\n+\n+   --  Start of processing for Attribute_Constrained_Static_Value\n+\n+   begin\n+      --  We are in a case where the attribute is known statically, and\n+      --  implicit dereferences have been rewritten.\n+\n+      pragma Assert\n+        (not (Present (Formal_Ent)\n+              and then Ekind (Formal_Ent) /= E_Constant\n+              and then Present (Extra_Constrained (Formal_Ent)))\n+         and then\n+           not (Is_Access_Type (Etype (Pref))\n+                and then (not Is_Entity_Name (Pref)\n+                          or else Is_Object (Entity (Pref))))\n+         and then\n+           not (Nkind (Pref) = N_Identifier\n+                and then Ekind (Entity (Pref)) = E_Variable\n+                and then Present (Extra_Constrained (Entity (Pref)))));\n+\n+      if Is_Entity_Name (Pref) then\n+         declare\n+            Ent : constant Entity_Id   := Entity (Pref);\n+            Res : Boolean;\n+\n+         begin\n+            --  (RM J.4) obsolescent cases\n+\n+            if Is_Type (Ent) then\n+\n+               --  Private type\n+\n+               if Is_Private_Type (Ent) then\n+                  Res := not Has_Discriminants (Ent)\n+                    or else Is_Constrained (Ent);\n+\n+               --  It not a private type, must be a generic actual type\n+               --  that corresponded to a private type. We know that this\n+               --  correspondence holds, since otherwise the reference\n+               --  within the generic template would have been illegal.\n+\n+               else\n+                  if Is_Composite_Type (Underlying_Type (Ent)) then\n+                     Res := Is_Constrained (Ent);\n+                  else\n+                     Res := True;\n+                  end if;\n+               end if;\n+\n+            else\n+\n+               --  If the prefix is not a variable or is aliased, then\n+               --  definitely true; if it's a formal parameter without an\n+               --  associated extra formal, then treat it as constrained.\n+\n+               --  Ada 2005 (AI-363): An aliased prefix must be known to be\n+               --  constrained in order to set the attribute to True.\n+\n+               if not Is_Variable (Pref)\n+                 or else Present (Formal_Ent)\n+                 or else (Ada_Version < Ada_2005\n+                          and then Is_Aliased_View (Pref))\n+                 or else (Ada_Version >= Ada_2005\n+                          and then Is_Constrained_Aliased_View (Pref))\n+               then\n+                  Res := True;\n+\n+               --  Variable case, look at type to see if it is constrained.\n+               --  Note that the one case where this is not accurate (the\n+               --  procedure formal case), has been handled above.\n+\n+               --  We use the Underlying_Type here (and below) in case the\n+               --  type is private without discriminants, but the full type\n+               --  has discriminants. This case is illegal, but we generate\n+               --  it internally for passing to the Extra_Constrained\n+               --  parameter.\n+\n+               else\n+                  --  In Ada 2012, test for case of a limited tagged type,\n+                  --  in which case the attribute is always required to\n+                  --  return True. The underlying type is tested, to make\n+                  --  sure we also return True for cases where there is an\n+                  --  unconstrained object with an untagged limited partial\n+                  --  view which has defaulted discriminants (such objects\n+                  --  always produce a False in earlier versions of\n+                  --  Ada). (Ada 2012: AI05-0214)\n+\n+                  Res :=\n+                    Is_Constrained (Underlying_Type (Etype (Ent)))\n+                    or else\n+                      (Ada_Version >= Ada_2012\n+                       and then Is_Tagged_Type (Underlying_Type (Ptyp))\n+                       and then Is_Limited_Type (Ptyp));\n+               end if;\n+            end if;\n+\n+            return Res;\n+         end;\n+\n+      --  Prefix is not an entity name. These are also cases where we can\n+      --  always tell at compile time by looking at the form and type of the\n+      --  prefix. If an explicit dereference of an object with constrained\n+      --  partial view, this is unconstrained (Ada 2005: AI95-0363). If the\n+      --  underlying type is a limited tagged type, then Constrained is\n+      --  required to always return True (Ada 2012: AI05-0214).\n+\n+      else\n+         return not Is_Variable (Pref)\n+           or else\n+             (Nkind (Pref) = N_Explicit_Dereference\n+              and then\n+                not Object_Type_Has_Constrained_Partial_View\n+                  (Typ  => Base_Type (Ptyp),\n+                   Scop => Current_Scope))\n+           or else Is_Constrained (Underlying_Type (Ptyp))\n+           or else (Ada_Version >= Ada_2012\n+                    and then Is_Tagged_Type (Underlying_Type (Ptyp))\n+                    and then Is_Limited_Type (Ptyp));\n+      end if;\n+   end Attribute_Constrained_Static_Value;\n+\n    ------------------------------------\n    -- Build_Allocate_Deallocate_Proc --\n    ------------------------------------"}, {"sha": "ab33e8ddb5954feaec40543168cea4b879b5ceb9", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2880e695410cf607d77be03908d7107e41a5271/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=d2880e695410cf607d77be03908d7107e41a5271", "patch": "@@ -240,6 +240,10 @@ package Exp_Util is\n    --  Note that the added nodes are not analyzed. The analyze call is found in\n    --  Exp_Ch13.Expand_N_Freeze_Entity.\n \n+   function Attribute_Constrained_Static_Value (Pref : Node_Id) return Boolean;\n+   --  Return the static value of a statically known attribute reference\n+   --  Pref'Constrained.\n+\n    procedure Build_Allocate_Deallocate_Proc\n      (N           : Node_Id;\n       Is_Allocate : Boolean);"}]}