{"sha": "4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJlNWM3MmNmM2VhM2VlOThhOTdhYzJlNTNkMjExMjJhZDIyNGIxMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-11-05T07:47:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-11-05T07:47:02Z"}, "message": "Implement P0732R2, class types in non-type template parameters.\n\nThere is one significant piece of this that is not implemented yet: the\nreliance on defaulted operator<=>, which someone else has been working on.\nSo, for the moment those lines are commented out of the testcases.\n\nOne tricky bit was treating template parameters of classtype as const\nlvalues without making their decltype const; for this I used a\nVIEW_CONVERT_EXPR wrapper, which previously could only appear in templates\nas location wrappers.\n\nThe user-defined literal parts of P0732R2 are in the next patch.\n\ngcc/cp/\n\t* error.c (dump_simple_decl): Look through a template parm object.\n\t* mangle.c (write_template_arg): Likewise.\n\t(mangle_template_parm_object): New.\n\t* pt.c (template_parm_object_p, get_template_parm_object): New.\n\t(invalid_tparm_referent_p): Factor from convert_nontype_argument.\n\t(convert_nontype_argument, invalid_nontype_parm_type_p): Handle\n\tclass-type template arguments.\n\t* tree.c (lvalue_kind): Likewise.\ngcc/c-family/\n\t* c-cppbuiltin.c (c_cpp_builtins): Add\n\t__cpp_nontype_template_parameter_class.\nlibiberty/\n\t* cp-demangle.c (d_dump, d_make_comp, d_count_templates_scopes)\n\t(d_print_comp_inner): Handle DEMANGLE_COMPONENT_TPARM_OBJ.\n\t(d_special_name): Handle TA.\n\t(d_expresion_1): Fix demangling of brace-enclosed initializer list.\ninclude/\n\t* demangle.h (enum demangle_component_type): Add\n\tDEMANGLE_COMPONENT_TPARM_OBJ.\n\nFrom-SVN: r265789", "tree": {"sha": "074d1e84a17c188274a39b3a002dc5c265626a8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/074d1e84a17c188274a39b3a002dc5c265626a8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab8b11c41fe72ea606c38884f7730bd2aeafdc"}], "stats": {"total": 615, "additions": 494, "deletions": 121}, "files": [{"sha": "fbafb9da2fb00b0152708b270a9eb8c4f554b655", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -1,3 +1,8 @@\n+2018-10-19  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Add\n+\t__cpp_nontype_template_parameter_class.\n+\n 2018-10-31  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-opts.c (c_finish_options): Force command line macro"}, {"sha": "e7f4c6690566217e3f8798a3d3b0ba50435edc6e", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -979,6 +979,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t{\n \t  /* Set feature test macros for C++2a.  */\n \t  cpp_define (pfile, \"__cpp_explicit_bool=201806\");\n+\t  cpp_define (pfile, \"__cpp_nontype_template_parameter_class=201806\");\n \t}\n       if (flag_concepts)\n \tcpp_define (pfile, \"__cpp_concepts=201507\");"}, {"sha": "95149b19656a7326eb471ac14719c615557a0b87", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -1,5 +1,15 @@\n 2018-11-04  Jason Merrill  <jason@redhat.com>\n \n+\tImplement P0732R2, class types in non-type template parameters.\n+\t* error.c (dump_simple_decl): Look through a template parm object.\n+\t* mangle.c (write_template_arg): Likewise.\n+\t(mangle_template_parm_object): New.\n+\t* pt.c (template_parm_object_p, get_template_parm_object): New.\n+\t(invalid_tparm_referent_p): Factor from convert_nontype_argument.\n+\t(convert_nontype_argument, invalid_nontype_parm_type_p): Handle\n+\tclass-type template arguments.\n+\t* tree.c (lvalue_kind): Likewise.\n+\n \t* cvt.c (ocp_convert): Don't wrap a CONSTRUCTOR in a NOP_EXPR.\n \t* constexpr.c (initialized_type): Fix AGGR_INIT_EXPR handling.\n \t(cxx_eval_vec_init_1): Correct type of AGGR_INIT_EXPR."}, {"sha": "61b431e5f9d816721b6d880e7b19a7ba2c79c54e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -6746,6 +6746,7 @@ extern bool variable_template_specialization_p  (tree);\n extern bool alias_type_or_template_p            (tree);\n extern bool alias_template_specialization_p     (const_tree);\n extern bool dependent_alias_template_spec_p     (const_tree);\n+extern bool template_parm_object_p\t\t(const_tree);\n extern bool explicit_class_specialization_p     (tree);\n extern bool push_tinst_level                    (tree);\n extern bool push_tinst_level_loc                (tree, location_t);\n@@ -7446,6 +7447,7 @@ extern tree mangle_tls_init_fn\t\t\t(tree);\n extern tree mangle_tls_wrapper_fn\t\t(tree);\n extern bool decl_tls_wrapper_p\t\t\t(tree);\n extern tree mangle_ref_init_variable\t\t(tree);\n+extern tree mangle_template_parm_object\t\t(tree);\n extern char * get_mangled_vtable_map_var_name   (tree);\n extern bool mangle_return_type_p\t\t(tree);\n extern tree mangle_decomp\t\t\t(tree, vec<tree> &);"}, {"sha": "72b42bd5cbe4da281cee181b9c8f6eb6c020a3ba", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -1006,6 +1006,9 @@ dump_global_iord (cxx_pretty_printer *pp, tree t)\n static void\n dump_simple_decl (cxx_pretty_printer *pp, tree t, tree type, int flags)\n {\n+  if (template_parm_object_p (t))\n+    return dump_expr (pp, DECL_INITIAL (t), flags);\n+\n   if (flags & TFF_DECL_SPECIFIERS)\n     {\n       if (VAR_P (t) && DECL_DECLARED_CONSTEXPR_P (t))"}, {"sha": "1b323015dedf4485eba4cf54cbe943889537fa80", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -3437,6 +3437,10 @@ write_template_arg (tree node)\n \t}\n     }\n \n+  if (template_parm_object_p (node))\n+    /* We want to mangle the argument, not the var we stored it in.  */\n+    node = DECL_INITIAL (node);\n+\n   /* Strip a conversion added by convert_nontype_argument.  */\n   if (TREE_CODE (node) == IMPLICIT_CONV_EXPR)\n     node = TREE_OPERAND (node, 0);\n@@ -4257,6 +4261,19 @@ mangle_ref_init_variable (const tree variable)\n   write_unsigned_number (temp_count++);\n   return finish_mangling_get_identifier ();\n }\n+\n+/* Return an identifier for the mangled name of a C++20 template parameter\n+   object for template argument EXPR.  */\n+\n+tree\n+mangle_template_parm_object (tree expr)\n+{\n+  start_mangling (expr);\n+  write_string (\"_ZTAX\");\n+  write_expression (expr);\n+  write_char ('E');\n+  return finish_mangling_get_identifier ();\n+}\n \f\n /* Given a CLASS_TYPE, such as a record for std::bad_exception this\n    function generates a mangled name for the vtable map variable of"}, {"sha": "80b4eec8fdbd7dee83e3fbddbfebd1a11c63d317", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 240, "deletions": 112, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -6584,6 +6584,169 @@ unify_template_argument_mismatch (bool explain_p, tree parm, tree arg)\n   return unify_invalid (explain_p);\n }\n \n+/* True if T is a C++20 template parameter object to store the argument for a\n+   template parameter of class type.  */\n+\n+bool\n+template_parm_object_p (const_tree t)\n+{\n+  return (TREE_CODE (t) == VAR_DECL && DECL_ARTIFICIAL (t) && DECL_NAME (t)\n+\t  && !strncmp (IDENTIFIER_POINTER (DECL_NAME (t)), \"_ZTA\", 4));\n+}\n+\n+/* Subroutine of convert_nontype_argument, to check whether EXPR, as an\n+   argument for TYPE, points to an unsuitable object.  */\n+\n+static bool\n+invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+    CASE_CONVERT:\n+      return invalid_tparm_referent_p (type, TREE_OPERAND (expr, 0),\n+\t\t\t\t       complain);\n+\n+    case TARGET_EXPR:\n+      return invalid_tparm_referent_p (type, TARGET_EXPR_INITIAL (expr),\n+\t\t\t\t       complain);\n+\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned i; tree elt;\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), i, elt)\n+\t  if (invalid_tparm_referent_p (TREE_TYPE (elt), elt, complain))\n+\t    return true;\n+      }\n+      break;\n+\n+    case ADDR_EXPR:\n+      {\n+\ttree decl = TREE_OPERAND (expr, 0);\n+\n+\tif (!VAR_P (decl))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"%qE is not a valid template argument of type %qT \"\n+\t\t     \"because %qE is not a variable\", expr, type, decl);\n+\t    return true;\n+\t  }\n+\telse if (cxx_dialect < cxx11 && !DECL_EXTERNAL_LINKAGE_P (decl))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"%qE is not a valid template argument of type %qT \"\n+\t\t     \"in C++98 because %qD does not have external linkage\",\n+\t\t     expr, type, decl);\n+\t    return true;\n+\t  }\n+\telse if ((cxx_dialect >= cxx11 && cxx_dialect < cxx17)\n+\t\t && decl_linkage (decl) == lk_none)\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"%qE is not a valid template argument of type %qT \"\n+\t\t     \"because %qD has no linkage\", expr, type, decl);\n+\t    return true;\n+\t  }\n+\t/* C++17: For a non-type template-parameter of reference or pointer\n+\t   type, the value of the constant expression shall not refer to (or\n+\t   for a pointer type, shall not be the address of):\n+\t   * a subobject (4.5),\n+\t   * a temporary object (15.2),\n+\t   * a string literal (5.13.5),\n+\t   * the result of a typeid expression (8.2.8), or\n+\t   * a predefined __func__ variable (11.4.1).  */\n+\telse if (DECL_ARTIFICIAL (decl))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"the address of %qD is not a valid template argument\",\n+\t\t     decl);\n+\t    return true;\n+\t  }\n+\telse if (!same_type_ignoring_top_level_qualifiers_p\n+\t\t (strip_array_types (TREE_TYPE (type)),\n+\t\t  strip_array_types (TREE_TYPE (decl))))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"the address of the %qT subobject of %qD is not a \"\n+\t\t     \"valid template argument\", TREE_TYPE (type), decl);\n+\t    return true;\n+\t  }\n+\telse if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"the address of %qD is not a valid template argument \"\n+\t\t     \"because it does not have static storage duration\",\n+\t\t     decl);\n+\t    return true;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      if (!INDIRECT_TYPE_P (type))\n+\t/* We're only concerned about pointers and references here.  */;\n+      else if (cxx_dialect >= cxx11 && integer_zerop (expr))\n+\t/* Null pointer values are OK in C++11.  */;\n+      else\n+\t{\n+\t  if (VAR_P (expr))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"%qD is not a valid template argument \"\n+\t\t       \"because %qD is a variable, not the address of \"\n+\t\t       \"a variable\", expr, expr);\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument for %qT \"\n+\t\t       \"because it is not the address of a variable\",\n+\t\t       expr, type);\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+\n+}\n+\n+/* Return a VAR_DECL for the C++20 template parameter object corresponding to\n+   template argument EXPR.  */\n+\n+static tree\n+get_template_parm_object (tree expr, tsubst_flags_t complain)\n+{\n+  if (TREE_CODE (expr) == TARGET_EXPR)\n+    expr = TARGET_EXPR_INITIAL (expr);\n+\n+  if (!TREE_CONSTANT (expr))\n+    {\n+      if ((complain & tf_error)\n+\t  && require_rvalue_constant_expression (expr))\n+\tcxx_constant_value (expr);\n+      return error_mark_node;\n+    }\n+  if (invalid_tparm_referent_p (TREE_TYPE (expr), expr, complain))\n+    return error_mark_node;\n+\n+  tree name = mangle_template_parm_object (expr);\n+  tree decl = get_global_binding (name);\n+  if (decl)\n+    return decl;\n+\n+  tree type = cp_build_qualified_type (TREE_TYPE (expr), TYPE_QUAL_CONST);\n+  decl = create_temporary_var (type);\n+  TREE_STATIC (decl) = true;\n+  DECL_DECLARED_CONSTEXPR_P (decl) = true;\n+  TREE_READONLY (decl) = true;\n+  DECL_NAME (decl) = name;\n+  SET_DECL_ASSEMBLER_NAME (decl, name);\n+  DECL_CONTEXT (decl) = global_namespace;\n+  comdat_linkage (decl);\n+  pushdecl_top_level_and_finish (decl, expr);\n+  return decl;\n+}\n+\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccessful, return\n@@ -6609,15 +6772,13 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree expr_type;\n   location_t loc = cp_expr_loc_or_loc (expr, input_location);\n-  tree orig_expr = expr;\n \n   /* Detect immediately string literals as invalid non-type argument.\n      This special-case is not needed for correctness (we would easily\n      catch this later), but only to provide better diagnostic for this\n      common user mistake. As suggested by DR 100, we do not mention\n      linkage issues in the diagnostic as this is not the point.  */\n-  /* FIXME we're making this OK.  */\n-  if (TREE_CODE (expr) == STRING_CST)\n+  if (TREE_CODE (expr) == STRING_CST && !CLASS_TYPE_P (type))\n     {\n       if (complain & tf_error)\n \terror (\"%qE is not a valid template argument for type %qT \"\n@@ -6841,88 +7002,13 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t;\n       else if (cxx_dialect >= cxx11 && integer_zerop (expr))\n \t/* Null pointer values are OK in C++11.  */;\n-      else if (TREE_CODE (expr) != ADDR_EXPR)\n-\t{\n-\t  if (VAR_P (expr))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qD is not a valid template argument \"\n-\t\t       \"because %qD is a variable, not the address of \"\n-\t\t       \"a variable\", orig_expr, expr);\n-\t      return NULL_TREE;\n-\t    }\n-\t  if (INDIRECT_TYPE_P (expr_type))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qE is not a valid template argument for %qT \"\n-\t\t       \"because it is not the address of a variable\",\n-\t\t       orig_expr, type);\n-\t      return NULL_TREE;\n-\t    }\n-\t  /* Other values, like integer constants, might be valid\n-\t     non-type arguments of some other type.  */\n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  tree decl = TREE_OPERAND (expr, 0);\n-\n-\t  if (!VAR_P (decl))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qE is not a valid template argument of type %qT \"\n-\t\t       \"because %qE is not a variable\", orig_expr, type, decl);\n-\t      return NULL_TREE;\n-\t    }\n-\t  else if (cxx_dialect < cxx11 && !DECL_EXTERNAL_LINKAGE_P (decl))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qE is not a valid template argument of type %qT \"\n-\t\t       \"because %qD does not have external linkage\",\n-\t\t       orig_expr, type, decl);\n-\t      return NULL_TREE;\n-\t    }\n-\t  else if ((cxx_dialect >= cxx11 && cxx_dialect < cxx17)\n-\t\t   && decl_linkage (decl) == lk_none)\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qE is not a valid template argument of type %qT \"\n-\t\t       \"because %qD has no linkage\", orig_expr, type, decl);\n-\t      return NULL_TREE;\n-\t    }\n-\t  /* C++17: For a non-type template-parameter of reference or pointer\n-\t     type, the value of the constant expression shall not refer to (or\n-\t     for a pointer type, shall not be the address of):\n-\t       * a subobject (4.5),\n-\t       * a temporary object (15.2),\n-\t       * a string literal (5.13.5),\n-\t       * the result of a typeid expression (8.2.8), or\n-\t       * a predefined __func__ variable (11.4.1).  */\n-\t  else if (DECL_ARTIFICIAL (decl))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"the address of %qD is not a valid template argument\",\n-\t\t       decl);\n-\t      return NULL_TREE;\n-\t    }\n-\t  else if (!same_type_ignoring_top_level_qualifiers_p\n-\t\t   (strip_array_types (TREE_TYPE (type)),\n-\t\t    strip_array_types (TREE_TYPE (decl))))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"the address of the %qT subobject of %qD is not a \"\n-\t\t       \"valid template argument\", TREE_TYPE (type), decl);\n-\t      return NULL_TREE;\n-\t    }\n-\t  else if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"the address of %qD is not a valid template argument \"\n-\t\t       \"because it does not have static storage duration\",\n-\t\t       decl);\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n+      else if (TREE_CODE (expr) != ADDR_EXPR\n+\t       && !INDIRECT_TYPE_P (expr_type))\n+\t/* Other values, like integer constants, might be valid\n+\t   non-type arguments of some other type.  */\n+\treturn error_mark_node;\n+      else if (invalid_tparm_referent_p (type, expr, complain))\n+\treturn NULL_TREE;\n \n       expr = decayed;\n \n@@ -6985,27 +7071,10 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t   itself value-dependent, since what we want here is its address.  */;\n       else\n \t{\n-\t  if (!DECL_P (expr))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qE is not a valid template argument for type %qT \"\n-\t\t       \"because it is not an object with linkage\",\n-\t\t       expr, type);\n-\t      return NULL_TREE;\n-\t    }\n-\n-\t  /* DR 1155 allows internal linkage in C++11 and up.  */\n-\t  linkage_kind linkage = decl_linkage (expr);\n-\t  if (linkage < (cxx_dialect >= cxx11 ? lk_internal : lk_external))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qE is not a valid template argument for type %qT \"\n-\t\t       \"because object %qD does not have linkage\",\n-\t\t       expr, type, expr);\n-\t      return NULL_TREE;\n-\t    }\n-\n \t  expr = build_address (expr);\n+\n+\t  if (invalid_tparm_referent_p (type, expr, complain))\n+\t    return NULL_TREE;\n \t}\n \n       if (!same_type_p (type, TREE_TYPE (expr)))\n@@ -7111,6 +7180,14 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t}\n       return expr;\n     }\n+  else if (CLASS_TYPE_P (type))\n+    {\n+      /* Replace the argument with a reference to the corresponding template\n+\t parameter object.  */\n+      expr = get_template_parm_object (expr, complain);\n+      if (expr == error_mark_node)\n+\treturn NULL_TREE;\n+    }\n   /* A template non-type parameter must be one of the above.  */\n   else\n     gcc_unreachable ();\n@@ -15593,9 +15670,31 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     first, *then* reusing the resulting type.  Doing the type\n \t     first ensures that we handle template parameters and\n \t     parameter pack expansions.  */\n-\t  gcc_assert (location_wrapper_p (t));\n-\t  tree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\t  return maybe_wrap_with_location (op0, EXPR_LOCATION (t));\n+\t  if (location_wrapper_p (t))\n+\t    {\n+\t      tree op0 = tsubst_copy (TREE_OPERAND (t, 0), args,\n+\t\t\t\t      complain, in_decl);\n+\t      return maybe_wrap_with_location (op0, EXPR_LOCATION (t));\n+\t    }\n+\t  tree op = TREE_OPERAND (t, 0);\n+\t  if (code == VIEW_CONVERT_EXPR\n+\t      && TREE_CODE (op) == TEMPLATE_PARM_INDEX)\n+\t    {\n+\t      /* Wrapper to make a C++20 template parameter object const.  */\n+\t      op = tsubst_copy (op, args, complain, in_decl);\n+\t      if (TREE_CODE (op) == TEMPLATE_PARM_INDEX)\n+\t\t{\n+\t\t  tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t\t  return build1 (code, type, op);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (op)));\n+\t\t  return op;\n+\t\t}\n+\t    }\n+\t  /* We shouldn't see any other uses of these in templates.  */\n+\t  gcc_unreachable ();\n \t}\n \n     case CAST_EXPR:\n@@ -19042,10 +19141,9 @@ tsubst_copy_and_build (tree t,\n \n     case NON_LVALUE_EXPR:\n     case VIEW_CONVERT_EXPR:\n-      /* We should only see these for location wrapper nodes, or within\n-\t instantiate_non_dependent_expr (when args is NULL_TREE).  */\n-      gcc_assert (location_wrapper_p (t) || args == NULL_TREE);\n       if (location_wrapper_p (t))\n+\t/* We need to do this here as well as in tsubst_copy so we get the\n+\t   other tsubst_copy_and_build semantics for a PARM_DECL operand.  */\n \tRETURN (maybe_wrap_with_location (RECUR (TREE_OPERAND (t, 0)),\n \t\t\t\t\t  EXPR_LOCATION (t)));\n       /* fallthrough.  */\n@@ -24566,6 +24664,33 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n   else if (cxx_dialect >= cxx11\n \t   && TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     return false;\n+  else if (CLASS_TYPE_P (type))\n+    {\n+      if (cxx_dialect < cxx2a)\n+\t{\n+\t  error (\"non-type template parameters of class type only available \"\n+\t\t \"with -std=c++2a or -std=gnu++2a\");\n+\t  return true;\n+\t}\n+      if (!complete_type_or_else (type, NULL_TREE))\n+\treturn true;\n+      if (!literal_type_p (type))\n+\t{\n+\t  error (\"%qT is not a valid type for a template non-type parameter \"\n+\t\t \"because it is not literal\", type);\n+\t  explain_non_literal_class (type);\n+\t  return true;\n+\t}\n+      if (cp_has_mutable_p (type))\n+\t{\n+\t  error (\"%qT is not a valid type for a template non-type parameter \"\n+\t\t \"because it has a mutable member\", type);\n+\t  return true;\n+\t}\n+      /* FIXME check op<=> and strong structural equality once spaceship is\n+\t implemented.  */\n+      return false;\n+    }\n \n   if (complain & tf_error)\n     {\n@@ -25361,7 +25486,10 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n       return NULL_TREE;\n \n     case TEMPLATE_PARM_INDEX:\n-      return *tp;\n+      if (dependent_type_p (TREE_TYPE (*tp)))\n+\treturn *tp;\n+      /* We'll check value-dependence separately.  */\n+      return NULL_TREE;\n \n       /* Handle expressions with type operands.  */\n     case SIZEOF_EXPR:"}, {"sha": "b54ecb068be17792192ca4741f17c2fb3fe714ec", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -3648,8 +3648,17 @@ finish_id_expression (tree id_expression,\n       *idk = CP_ID_KIND_NONE;\n       if (TREE_CODE (decl) == TEMPLATE_PARM_INDEX)\n \tdecl = TEMPLATE_PARM_DECL (decl);\n-      r = convert_from_reference (DECL_INITIAL (decl));\n-\n+      r = DECL_INITIAL (decl);\n+      if (CLASS_TYPE_P (TREE_TYPE (r)) && !CP_TYPE_CONST_P (TREE_TYPE (r)))\n+\t{\n+\t  /* If the entity is a template parameter object for a template\n+\t     parameter of type T, the type of the expression is const T.  */\n+\t  tree ctype = TREE_TYPE (r);\n+\t  ctype = cp_build_qualified_type (ctype, (cp_type_quals (ctype)\n+\t\t\t\t\t\t   | TYPE_QUAL_CONST));\n+\t  r = build1 (VIEW_CONVERT_EXPR, ctype, r);\n+\t}\n+      r = convert_from_reference (r);\n       if (integral_constant_expression_p\n \t  && !dependent_type_p (TREE_TYPE (decl))\n \t  && !(INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (r))))\n@@ -8802,7 +8811,8 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n       if (identifier_p (expr))\n         expr = lookup_name (expr);\n \n-      if (INDIRECT_REF_P (expr))\n+      if (INDIRECT_REF_P (expr)\n+\t  || TREE_CODE (expr) == VIEW_CONVERT_EXPR)\n         /* This can happen when the expression is, e.g., \"a.b\". Just\n            look at the underlying operand.  */\n         expr = TREE_OPERAND (expr, 0);"}, {"sha": "e9db3ea85c583cfbcdbccbf251732be52ec9931f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -280,6 +280,12 @@ lvalue_kind (const_tree ref)\n     case PAREN_EXPR:\n       return lvalue_kind (TREE_OPERAND (ref, 0));\n \n+    case TEMPLATE_PARM_INDEX:\n+      if (CLASS_TYPE_P (TREE_TYPE (ref)))\n+\t/* A template parameter object is an lvalue.  */\n+\treturn clk_ordinary;\n+      return clk_none;\n+\n     default:\n     default_:\n       if (!TREE_TYPE (ref))"}, {"sha": "faed6697382edd4148fab10a9f6e711bd5afde53", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -416,6 +416,12 @@\n #  error \"__cpp_variadic_using != 201611\"\n #endif\n \n+// C++20 features\n+\n+#if __cpp_nontype_template_parameter_class != 201806\n+# error \"__cpp_nontype_template_parameter_class != 201806\"\n+#endif\n+\n #ifdef __has_cpp_attribute\n \n #  if ! __has_cpp_attribute(maybe_unused)"}, {"sha": "0c0b94d22c03fb87a8eafbaad7f29544341bc7ca", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class1.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A\n+{\n+  int i;\n+  constexpr A (int i): i(i) {}\n+  // auto operator<=> (const A&) = default;\n+};\n+\n+template <A a>\n+struct B\n+{\n+  static constexpr int i = a.i;\n+  static constexpr A const* ap = &a;\n+};\n+\n+template <A a>\n+struct C\n+{\n+  static constexpr A const* ap = &a;\n+};\n+\n+static_assert(B<1>::i == 1);\n+static_assert(B<2>::i == 2);\n+static_assert(B<1>::ap == C<1>::ap);\n+static_assert(B<1>::ap != C<2>::ap);\n+\n+// { dg-final { scan-assembler \"_Z1fP1BIXtl1ALi1EEEE\" } }\n+// { dg-final { scan-assembler \"_ZTAXtl1ALi1EEE\" } }\n+const void* f(B<1> *p) {\n+  constexpr int i = p->ap->i;\n+  return p->ap;\n+}"}, {"sha": "2785f9475448a919722eaa897905ce0fa3c480d2", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class2.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  int i;\n+  // auto operator<=> (const A&) = default;\n+};\n+template <typename T, T t> void f()\n+{\n+  g(t);\t\t\t\t// { dg-error \"not declared\" }\n+}\n+\n+int main()\n+{\n+  f<A,A{1}>();\n+}\n+\n+// { dg-message \"T t = A{1}\" \"\" { target *-*-* } 0 }"}, {"sha": "0c0fcf6be337838db76babe2904e0eb0de3e68ab", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class3.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  int i;\n+  // auto operator<=> (const A&) = default;\n+};\n+template <A a> void g();\n+template <auto t> void f()\n+{\n+  g<t>();\n+}\n+\n+int main()\n+{\n+  f<A{1}>();\n+}"}, {"sha": "fc0e7c9655de9a7762acdd4c14ba75d16a0af7d3", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class4.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++2a } }\n+\n+template <class T>\n+struct A {\n+  constexpr A(T) {}\n+  // auto operator<=> (const A&) = default;\n+};\n+template <A a> void f();\n+\n+int main()\n+{\n+  constexpr A a = 1;\n+  f<a>();\n+  f<1>();\n+}\n+\n+// { dg-final { scan-assembler \"_Z1fIXtl1AIiEEEEvv\" } }\n+// { dg-final { scan-assembler-not \"_Z1fIXtlK1AIiEEEEvv\" } }"}, {"sha": "8c39cd72715125317d7a75c12281228f9f06dd7a", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class5.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,12 @@\n+// Example from P0732\n+// { dg-do compile { target c++2a } }\n+\n+template<class T, T p> class X {\n+  /* ... */\n+};\n+\n+struct A {\n+  constexpr A(const char*) {}\n+  // auto operator<=> (const A&) = default;\n+};\n+X<A, \"Pyrophoricity\"> x3; // OK: string literal is a constructor argument to A"}, {"sha": "15389e185370e485f9d9bed2c3b5b48bf2805b38", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class7.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class7.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,26 @@\n+// Example from P0732.\n+// { dg-do compile { target c++2a } }\n+\n+namespace std {\n+  using size_t = decltype(sizeof(1));\n+  template <typename CharT, std::size_t N>\n+  struct basic_fixed_string\n+  {\n+    constexpr basic_fixed_string(const CharT (&foo)[N+1])\n+    : m_data()\n+    {\n+      for (int i = 0; i <= N; ++i)\n+\tm_data[i] = foo[i];\n+    }\n+    // auto operator<=>(const basic_fixed_string &) = default;\n+    CharT m_data[N+1];\n+  };\n+  template <typename CharT, std::size_t N>\n+  basic_fixed_string(const CharT (&str)[N])->basic_fixed_string<CharT, N-1>;\n+  template <std::size_t N>\n+  using fixed_string = basic_fixed_string<char, N>;\n+}\n+\n+template <std::basic_fixed_string Str>\n+struct A {};\n+using hello_A = A<\"hello\">;"}, {"sha": "47fc9c7f5c0ccd8214802cb36bdd31a893665ade", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class8.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class8.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -0,0 +1,26 @@\n+// If the entity is a template parameter object for a template parameter of\n+// type T, the type of the expression is const T.\n+\n+// { dg-do compile { target c++2a } }\n+\n+template <class T, class U> struct same;\n+template <class T> struct same<T,T> {};\n+\n+struct A {\n+  int i;\n+  // auto operator<=> (const A&) = default;\n+};\n+void f(A&) = delete;\n+void f(const A&) { }\n+\n+template < A a > struct B\n+{\n+  B()\n+  {\n+    f(a);\n+    same<A,decltype(a)> s;\n+    same<const A&,decltype((a))> s2;\n+  }\n+};\n+\n+B<A{42}> b;"}, {"sha": "5416e32cacb16dbefac9967fbc0513e5ed5bacee", "filename": "gcc/testsuite/g++.dg/template/crash55.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -1,6 +1,6 @@\n //PR c++/27668\n \n-template<typename class T, T = T()> // { dg-error \"nested-name-specifier|two or more|valid type\" }\n+template<typename class T, T = T()> // { dg-error \"nested-name-specifier|two or more|class type|incomplete\" }\n // { dg-error \"cast\" \"\" { target c++98_only } .-1 }\n struct A {};\n "}, {"sha": "8b3612debde18c02c55b68770e91485843451cba", "filename": "gcc/testsuite/g++.dg/template/nontype16.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype16.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -5,5 +5,5 @@ template<int> struct A\n     template<typename> void foo();\n };\n \n-template<> template<struct T> void A<0>::foo() {} // { dg-error \"not a valid type\" }\n+template<> template<struct T> void A<0>::foo() {} // { dg-error \"class type|incomplete\" }\n  "}, {"sha": "b0d07814df1799123f5aa9c89601c24de39b3a0a", "filename": "gcc/testsuite/g++.dg/template/nontype4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype4.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -8,7 +8,7 @@\n template <int> struct A\n {\n     typedef A<0> B;\t\t// { dg-message \"previous declaration\" }\n-    template <B> struct B {};\t// { dg-error \"not a valid type|typedef\" }\n+    template <B> struct B {};\t// { dg-error \"class type|incomplete|typedef\" }\n };\n \n A<0> a;"}, {"sha": "47c179ea7412462c28d893ef47d8358d7a3ad1ee", "filename": "gcc/testsuite/g++.dg/template/nontype5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype5.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -8,7 +8,7 @@\n template <int> struct A\n {\n     typedef A<0> B;\n-    template <B> struct C {};\t// { dg-error \"not a valid type\" }\n+    template <B> struct C {};\t// { dg-error \"class type|incomplete\" }\n };\n \n A<0> a;"}, {"sha": "432fecdc3ac643d2902339db93d4db994228bd8b", "filename": "gcc/testsuite/g++.dg/template/operator10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator10.C?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -3,6 +3,6 @@\n \n struct A {};\n \n-template<A, typename T> int operator-(A, T); // { dg-error \"not a valid type\" }\n+template<A, typename T> int operator-(A, T); // { dg-error \"class type\" \"\" { target c++17_down } }\n \n int i = A() - 0; // { dg-error \"no match\" }"}, {"sha": "19f515d59b3cad43c8cee3dbf764137015670a86", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -1,3 +1,8 @@\n+2018-10-19  Jason Merrill  <jason@redhat.com>\n+\n+\t* demangle.h (enum demangle_component_type): Add\n+\tDEMANGLE_COMPONENT_TPARM_OBJ.\n+\n 2018-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \t* unique-ptr.h (gnu::move): Generalize so it applies to all"}, {"sha": "4f920f2b7f597d4e952c27c4647086e13aea77fa", "filename": "include/demangle.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -392,6 +392,9 @@ enum demangle_component_type\n      template argument, and the right subtree is either NULL or\n      another TEMPLATE_ARGLIST node.  */\n   DEMANGLE_COMPONENT_TEMPLATE_ARGLIST,\n+  /* A template parameter object (C++20).  The left subtree is the\n+     corresponding template argument.  */\n+  DEMANGLE_COMPONENT_TPARM_OBJ,\n   /* An initializer list.  The left subtree is either an explicit type or\n      NULL, and the right subtree is a DEMANGLE_COMPONENT_ARGLIST.  */\n   DEMANGLE_COMPONENT_INITIALIZER_LIST,"}, {"sha": "91211c87e7ddca3c458a625619904b2616ba5cbe", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -1,3 +1,11 @@\n+2018-10-23  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0732R2, class types in non-type template parameters.\n+\t* cp-demangle.c (d_dump, d_make_comp, d_count_templates_scopes)\n+\t(d_print_comp_inner): Handle DEMANGLE_COMPONENT_TPARM_OBJ.\n+\t(d_special_name): Handle TA.\n+\t(d_expresion_1): Fix demangling of brace-enclosed initializer list.\n+\n 2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/82856"}, {"sha": "a1f74a51c9c8aa2e8801c5a30b606dc68e054887", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -625,6 +625,9 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n       printf (\"template parameter %ld\\n\", dc->u.s_number.number);\n       return;\n+    case DEMANGLE_COMPONENT_TPARM_OBJ:\n+      printf (\"template parameter object\\n\");\n+      break;\n     case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n       printf (\"function parameter %ld\\n\", dc->u.s_number.number);\n       return;\n@@ -1007,6 +1010,7 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n     case DEMANGLE_COMPONENT_NULLARY:\n     case DEMANGLE_COMPONENT_TRINARY_ARG2:\n+    case DEMANGLE_COMPONENT_TPARM_OBJ:\n       if (left == NULL)\n \treturn NULL;\n       break;\n@@ -2007,6 +2011,7 @@ d_java_resource (struct d_info *di)\n                   ::= TT <type>\n                   ::= TI <type>\n                   ::= TS <type>\n+\t\t  ::= TA <template-arg>\n                   ::= GV <(object) name>\n                   ::= T <call-offset> <(base) encoding>\n                   ::= Tc <call-offset> <call-offset> <(base) encoding>\n@@ -2099,6 +2104,10 @@ d_special_name (struct d_info *di)\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_WRAPPER,\n \t\t\t      d_name (di), NULL);\n \n+\tcase 'A':\n+\t  return d_make_comp (di, DEMANGLE_COMPONENT_TPARM_OBJ,\n+\t\t\t      d_template_arg (di), NULL);\n+\n \tdefault:\n \t  return NULL;\n \t}\n@@ -3327,11 +3336,11 @@ d_expression_1 (struct d_info *di)\n     {\n       /* Brace-enclosed initializer list, untyped or typed.  */\n       struct demangle_component *type = NULL;\n+      d_advance (di, 2);\n       if (peek == 't')\n \ttype = cplus_demangle_type (di);\n       if (!d_peek_next_char (di))\n \treturn NULL;\n-      d_advance (di, 2);\n       return d_make_comp (di, DEMANGLE_COMPONENT_INITIALIZER_LIST,\n \t\t\t  type, d_exprlist (di, 'E'));\n     }\n@@ -4101,6 +4110,7 @@ d_count_templates_scopes (int *num_templates, int *num_scopes,\n     case DEMANGLE_COMPONENT_VECTOR_TYPE:\n     case DEMANGLE_COMPONENT_ARGLIST:\n     case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n+    case DEMANGLE_COMPONENT_TPARM_OBJ:\n     case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n     case DEMANGLE_COMPONENT_CAST:\n     case DEMANGLE_COMPONENT_CONVERSION:\n@@ -4872,6 +4882,11 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t}\n       return;\n \n+    case DEMANGLE_COMPONENT_TPARM_OBJ:\n+      d_append_string (dpi, \"template parameter object for \");\n+      d_print_comp (dpi, options, d_left (dc));\n+      return;\n+\n     case DEMANGLE_COMPONENT_CTOR:\n       d_print_comp (dpi, options, dc->u.s_ctor.name);\n       return;"}, {"sha": "40038365c83d9d457e92011458716e9b2e67311f", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4be5c72cf3ea3ee98a97ac2e53d21122ad224b10/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=4be5c72cf3ea3ee98a97ac2e53d21122ad224b10", "patch": "@@ -4667,6 +4667,12 @@ void eat<int*, Foo()::{lambda(auto:1*, auto:2*)#6}>(int*&, Foo()::{lambda(auto:1\n _Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_\n void eat<int*, Bar<short>()::{lambda(short*, auto:1*, auto:2*)#2}>(int*&, Bar<short>()::{lambda(short*, auto:1*, auto:2*)#2}&)\n \n+_Z1fP1BIXtl1ALi1EEEE\n+f(B<A{1}>*)\n+\n+_ZTAXtl1ALi1EEE\n+template parameter object for A{1}\n+\n # PR 77489\n _ZZ3foovE8localVar_9\n foo()::localVar"}]}