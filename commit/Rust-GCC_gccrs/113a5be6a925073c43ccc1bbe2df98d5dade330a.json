{"sha": "113a5be6a925073c43ccc1bbe2df98d5dade330a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEzYTViZTZhOTI1MDczYzQzY2NjMWJiZTJkZjk4ZDVkYWRlMzMwYQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2011-05-24T16:14:51Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2011-05-24T16:14:51Z"}, "message": "re PR rtl-optimization/48971 (ICE with -msoft-float -O2)\n\n2011-05-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/48971\n\t* ira.c (setup_pressure_classes): Don't check register move cost\n\tfor classes with one registers.  Don't add pressure class if there\n\tis a pressure class with the same available hard registers.\n\tCheck contains_reg_of_mode.  Fix a typo in collecting\n\ttemp_hard_regset.  Ignore hard registers not belonging to a class.\n\nFrom-SVN: r174123", "tree": {"sha": "c2ac73e43634d744692914b3e9acf0c54d053dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2ac73e43634d744692914b3e9acf0c54d053dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/113a5be6a925073c43ccc1bbe2df98d5dade330a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113a5be6a925073c43ccc1bbe2df98d5dade330a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/113a5be6a925073c43ccc1bbe2df98d5dade330a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113a5be6a925073c43ccc1bbe2df98d5dade330a/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df1f7315c7fbad1fa24e4bf0490e42a9cc090dda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1f7315c7fbad1fa24e4bf0490e42a9cc090dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1f7315c7fbad1fa24e4bf0490e42a9cc090dda"}], "stats": {"total": 105, "additions": 70, "deletions": 35}, "files": [{"sha": "ee5f9f5f85ca6f11c1282444f15b9f85c7772121", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113a5be6a925073c43ccc1bbe2df98d5dade330a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113a5be6a925073c43ccc1bbe2df98d5dade330a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=113a5be6a925073c43ccc1bbe2df98d5dade330a", "patch": "@@ -1,3 +1,12 @@\n+2011-05-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/48971\n+\t* ira.c (setup_pressure_classes): Don't check register move cost\n+\tfor classes with one registers.  Don't add pressure class if there\n+\tis a pressure class with the same available hard registers.\n+\tCheck contains_reg_of_mode.  Fix a typo in collecting\n+\ttemp_hard_regset.  Ignore hard registers not belonging to a class.\n+\n 2011-05-24  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/49133"}, {"sha": "358ad0a37b1d587b24148f0a84d1db0ff6eeb30b", "filename": "gcc/ira.c", "status": "modified", "additions": 61, "deletions": 35, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113a5be6a925073c43ccc1bbe2df98d5dade330a/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113a5be6a925073c43ccc1bbe2df98d5dade330a/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=113a5be6a925073c43ccc1bbe2df98d5dade330a", "patch": "@@ -799,27 +799,30 @@ setup_pressure_classes (void)\n     {\n       if (ira_available_class_regs[cl] == 0)\n \tcontinue;\n-      /* Check that the moves between any hard registers of the\n-\t current class are not more expensive for a legal mode than\n-\t load/store of the hard registers of the current class.  Such\n-\t class is a potential candidate to be a register pressure\n-\t class.  */\n-      for (m = 0; m < NUM_MACHINE_MODES; m++)\n+      if (ira_available_class_regs[cl] != 1)\n \t{\n-\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t  AND_COMPL_HARD_REG_SET (temp_hard_regset,\n-\t\t\t\t  ira_prohibited_class_mode_regs[cl][m]);\n-\t  if (hard_reg_set_empty_p (temp_hard_regset))\n+\t  /* Check that the moves between any hard registers of the\n+\t     current class are not more expensive for a legal mode\n+\t     than load/store of the hard registers of the current\n+\t     class.  Such class is a potential candidate to be a\n+\t     register pressure class.  */\n+\t  for (m = 0; m < NUM_MACHINE_MODES; m++)\n+\t    {\n+\t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n+\t      AND_COMPL_HARD_REG_SET (temp_hard_regset,\n+\t\t\t\t      ira_prohibited_class_mode_regs[cl][m]);\n+\t      if (hard_reg_set_empty_p (temp_hard_regset))\n+\t\tcontinue;\n+\t      ira_init_register_move_cost_if_necessary ((enum machine_mode) m);\n+\t      cost = ira_register_move_cost[m][cl][cl];\n+\t      if (cost <= ira_max_memory_move_cost[m][cl][1]\n+\t\t  || cost <= ira_max_memory_move_cost[m][cl][0])\n+\t\tbreak;\n+\t    }\n+\t  if (m >= NUM_MACHINE_MODES)\n \t    continue;\n-\t  ira_init_register_move_cost_if_necessary ((enum machine_mode) m);\n-\t  cost = ira_register_move_cost[m][cl][cl];\n-\t  if (cost <= ira_max_memory_move_cost[m][cl][1]\n-\t      || cost <= ira_max_memory_move_cost[m][cl][0])\n-\t    break;\n \t}\n-      if (m >= NUM_MACHINE_MODES)\n-\tcontinue;\n       curr = 0;\n       insert_p = true;\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n@@ -848,6 +851,8 @@ setup_pressure_classes (void)\n \t      && (! hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset)\n \t\t  || cl == (int) GENERAL_REGS))\n \t    continue;\n+\t  if (hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset))\n+\t    insert_p = false;\n \t  pressure_classes[curr++] = (enum reg_class) cl2;\n \t}\n       /* If the current candidate is a subset of a so far added\n@@ -858,23 +863,44 @@ setup_pressure_classes (void)\n       n = curr;\n     }\n #ifdef ENABLE_IRA_CHECKING\n-  /* Check pressure classes correctness: here we check that hard\n-     registers from all register pressure classes contains all hard\n-     registers available for the allocation.  */\n-  CLEAR_HARD_REG_SET (temp_hard_regset);\n-  CLEAR_HARD_REG_SET (temp_hard_regset2);\n-  for (cl = 0; cl < LIM_REG_CLASSES; cl++)\n-    {\n-      for (i = 0; i < n; i++)\n-\tif ((int) pressure_classes[i] == cl)\n-\t  break;\n-      IOR_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n-      if (i >= n)\n-\tIOR_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n-    }\n-  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-  AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-  ira_assert (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset));\n+  {\n+    HARD_REG_SET ignore_hard_regs;\n+\n+    /* Check pressure classes correctness: here we check that hard\n+       registers from all register pressure classes contains all hard\n+       registers available for the allocation.  */\n+    CLEAR_HARD_REG_SET (temp_hard_regset);\n+    CLEAR_HARD_REG_SET (temp_hard_regset2);\n+    COPY_HARD_REG_SET (ignore_hard_regs, no_unit_alloc_regs);\n+    for (cl = 0; cl < LIM_REG_CLASSES; cl++)\n+      {\n+\t/* For some targets (like MIPS with MD_REGS), there are some\n+\t   classes with hard registers available for allocation but\n+\t   not able to hold value of any mode.  */\n+\tfor (m = 0; m < NUM_MACHINE_MODES; m++)\n+\t  if (contains_reg_of_mode[cl][m])\n+\t    break;\n+\tif (m >= NUM_MACHINE_MODES)\n+\t  {\n+\t    IOR_HARD_REG_SET (ignore_hard_regs, reg_class_contents[cl]);\n+\t    continue;\n+\t  }\n+\tfor (i = 0; i < n; i++)\n+\t  if ((int) pressure_classes[i] == cl)\n+\t    break;\n+\tIOR_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n+\tif (i < n)\n+\t  IOR_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+      }\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      /* Some targets (like SPARC with ICC reg) have alocatable regs\n+\t for which no reg class is defined.  */\n+      if (REGNO_REG_CLASS (i) == NO_REGS)\n+\tSET_HARD_REG_BIT (ignore_hard_regs, i);\n+    AND_COMPL_HARD_REG_SET (temp_hard_regset, ignore_hard_regs);\n+    AND_COMPL_HARD_REG_SET (temp_hard_regset2, ignore_hard_regs);\n+    ira_assert (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset));\n+  }\n #endif\n   ira_pressure_classes_num = 0;\n   for (i = 0; i < n; i++)"}]}