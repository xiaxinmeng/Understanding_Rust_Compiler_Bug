{"sha": "fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzNzUzNmI5ZGEzMmIzMWRiZTJiYTA5NGNjZmI2MTVlMWZjMzgwYQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-10-07T16:15:46Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-10-07T16:15:46Z"}, "message": "tree-sra.c (struct access): New field grp_assignment_write.\n\n2010-10-07  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (struct access): New field grp_assignment_write.\n\t(dump_access): Dump grp_assignment_write.\n\t(build_accesses_from_assign): Set grp_assignment_write.\n\t(sort_and_splice_var_accesses): Aggregate grp_assignment_write.\n\t(mark_read_status): Renamed to mark_rw_status, individual values\n\trenamed too.\n\t(analyze_access_subtree): Changed type of mark_write to\n\tmark_read_status.  Fixed propagating of mark_read and\n\tmark_write.  Changed benefit estimate.  Updated comment.\n\n\t* testsuite/gcc.dg/tree-ssa/sra-11.c: New test.\n\nFrom-SVN: r165124", "tree": {"sha": "e562607fea656a7506a1bf220722ad90b021fccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e562607fea656a7506a1bf220722ad90b021fccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d163c4f7574e7c330444bd999c02d9ffe05d18f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d163c4f7574e7c330444bd999c02d9ffe05d18f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d163c4f7574e7c330444bd999c02d9ffe05d18f6"}], "stats": {"total": 142, "additions": 123, "deletions": 19}, "files": [{"sha": "479b616356fb5bbb48f71639b0990ed4557b1aff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "patch": "@@ -1,3 +1,15 @@\n+2010-10-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (struct access): New field grp_assignment_write.\n+\t(dump_access): Dump grp_assignment_write.\n+\t(build_accesses_from_assign): Set grp_assignment_write.\n+\t(sort_and_splice_var_accesses): Aggregate grp_assignment_write.\n+\t(mark_read_status): Renamed to mark_rw_status, individual values\n+\trenamed too.\n+\t(analyze_access_subtree): Changed type of mark_write to\n+\tmark_read_status.  Fixed propagating of mark_read and\n+\tmark_write.  Changed benefit estimate.  Updated comment.\n+\n 2010-10-07  Tejas Belagod  <tejas.belagod@arm.com>\n \n \t* tree-vect-patterns.c (vect_recog_widen_mult_pattern): Add NULL"}, {"sha": "12be3690ac20dfa2a60b9021684e794298063faa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "patch": "@@ -1,3 +1,7 @@\n+2010-10-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/sra-11.c: New test.\n+\n 2010-10-07  Tejas Belagod  <tejas.belagod@arm.com>\n \n \t* gcc.dg/vect/pr45847.c: New test."}, {"sha": "c8a90eac59d25c9288a5cb7c2147e80b18f265e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-11.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-11.c?ref=fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-esra-details\" } */\n+\n+struct S\n+{\n+  int i;\n+  int j;\n+  char c[32]; /* this disables total scalarization */\n+};\n+\n+extern struct S bar(void);\n+\n+int foo1 (int b)\n+{\n+   struct S s1;\n+\n+   s1 = bar ();\n+   return s1.i;\n+}\n+\n+extern struct S *g;\n+\n+int foo2 (void)\n+{\n+   struct S s2;\n+\n+   s2 = *g;\n+   return s2.i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Created a replacement for s1\" 0 \"esra\"} } */\n+/* { dg-final { scan-tree-dump-times \"Created a replacement for s2\" 1 \"esra\"} } */\n+/* { dg-final { cleanup-tree-dump \"esra\" } } */"}, {"sha": "06cb6ffaeb03a460b574499015f6d33961da48c5", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc37536b9da32b31dbe2ba094ccfb615e1fc380a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fc37536b9da32b31dbe2ba094ccfb615e1fc380a", "patch": "@@ -189,6 +189,10 @@ struct access\n      statement?  This flag is propagated down the access tree.  */\n   unsigned grp_assignment_read : 1;\n \n+  /* Does this group contain a write access that comes from an assignment\n+     statement?  This flag is propagated down the access tree.  */\n+  unsigned grp_assignment_write : 1;\n+\n   /* Other passes of the analysis use this bit to make function\n      analyze_access_subtree create scalar replacements for this group if\n      possible.  */\n@@ -364,15 +368,17 @@ dump_access (FILE *f, struct access *access, bool grp)\n   if (grp)\n     fprintf (f, \", grp_write = %d, total_scalarization = %d, \"\n \t     \"grp_read = %d, grp_hint = %d, grp_assignment_read = %d,\"\n-\t     \"grp_covered = %d, grp_unscalarizable_region = %d, \"\n-\t     \"grp_unscalarized_data = %d, grp_partial_lhs = %d, \"\n-\t     \"grp_to_be_replaced = %d, grp_maybe_modified = %d, \"\n+\t     \"grp_assignment_write = %d, grp_covered = %d, \"\n+\t     \"grp_unscalarizable_region = %d, grp_unscalarized_data = %d, \"\n+\t     \"grp_partial_lhs = %d, grp_to_be_replaced = %d, \"\n+\t     \"grp_maybe_modified = %d, \"\n \t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n \t     access->grp_write, access->total_scalarization,\n \t     access->grp_read, access->grp_hint, access->grp_assignment_read,\n-\t     access->grp_covered, access->grp_unscalarizable_region,\n-\t     access->grp_unscalarized_data, access->grp_partial_lhs,\n-\t     access->grp_to_be_replaced, access->grp_maybe_modified,\n+\t     access->grp_assignment_write, access->grp_covered,\n+\t     access->grp_unscalarizable_region, access->grp_unscalarized_data,\n+\t     access->grp_partial_lhs, access->grp_to_be_replaced,\n+\t     access->grp_maybe_modified,\n \t     access->grp_not_necessarilly_dereferenced);\n   else\n     fprintf (f, \", write = %d, total_scalarization = %d, \"\n@@ -1019,6 +1025,9 @@ build_accesses_from_assign (gimple stmt)\n   racc = build_access_from_expr_1 (rhs, stmt, false);\n   lacc = build_access_from_expr_1 (lhs, stmt, true);\n \n+  if (lacc)\n+    lacc->grp_assignment_write = 1;\n+\n   if (racc)\n     {\n       racc->grp_assignment_read = 1;\n@@ -1581,6 +1590,7 @@ sort_and_splice_var_accesses (tree var)\n       bool grp_write = access->write;\n       bool grp_read = !access->write;\n       bool grp_assignment_read = access->grp_assignment_read;\n+      bool grp_assignment_write = access->grp_assignment_write;\n       bool multiple_reads = false;\n       bool total_scalarization = access->total_scalarization;\n       bool grp_partial_lhs = access->grp_partial_lhs;\n@@ -1615,6 +1625,7 @@ sort_and_splice_var_accesses (tree var)\n \t\tgrp_read = true;\n \t    }\n \t  grp_assignment_read |= ac2->grp_assignment_read;\n+\t  grp_assignment_write |= ac2->grp_assignment_write;\n \t  grp_partial_lhs |= ac2->grp_partial_lhs;\n \t  unscalarizable_region |= ac2->grp_unscalarizable_region;\n \t  total_scalarization |= ac2->total_scalarization;\n@@ -1634,6 +1645,7 @@ sort_and_splice_var_accesses (tree var)\n       access->grp_write = grp_write;\n       access->grp_read = grp_read;\n       access->grp_assignment_read = grp_assignment_read;\n+      access->grp_assignment_write = grp_assignment_write;\n       access->grp_hint = multiple_reads || total_scalarization;\n       access->grp_partial_lhs = grp_partial_lhs;\n       access->grp_unscalarizable_region = unscalarizable_region;\n@@ -1822,41 +1834,82 @@ expr_with_var_bounded_array_refs_p (tree expr)\n   return false;\n }\n \n-enum mark_read_status { SRA_MR_NOT_READ, SRA_MR_READ, SRA_MR_ASSIGN_READ};\n+enum mark_rw_status { SRA_MRRW_NOTHING, SRA_MRRW_DIRECT, SRA_MRRW_ASSIGN};\n \n /* Analyze the subtree of accesses rooted in ROOT, scheduling replacements when\n    both seeming beneficial and when ALLOW_REPLACEMENTS allows it.  Also set all\n    sorts of access flags appropriately along the way, notably always set\n    grp_read and grp_assign_read according to MARK_READ and grp_write when\n-   MARK_WRITE is true.  */\n+   MARK_WRITE is true.\n+\n+   Creating a replacement for a scalar access is considered beneficial if its\n+   grp_hint is set (this means we are either attempting total scalarization or\n+   there is more than one direct read access) or according to the following\n+   table:\n+\n+   Access written to individually (once or more times)\n+   |\n+   |\tParent written to in an assignment statement\n+   |\t|\n+   |\t|\tAccess read individually _once_\n+   |\t|\t|\n+   |   \t|\t|\tParent read in an assignment statement\n+   |\t|\t|\t|\n+   |   \t|\t|\t|\tScalarize\tComment\n+-----------------------------------------------------------------------------\n+   0\t0\t0\t0\t\t\tNo access for the scalar\n+   0\t0\t0\t1\t\t\tNo access for the scalar\n+   0\t0\t1\t0\tNo\t\tSingle read - won't help\n+   0\t0\t1\t1\tNo\t\tThe same case\n+   0\t1\t0\t0\t\t\tNo access for the scalar\n+   0\t1\t0\t1\t\t\tNo access for the scalar\n+   0\t1\t1\t0\tYes\t\ts = *g; return s.i;\n+   0\t1\t1\t1       Yes\t\tThe same case as above\n+   1\t0\t0\t0\tNo\t\tWon't help\n+   1\t0\t0\t1\tYes\t\ts.i = 1; *g = s;\n+   1\t0\t1\t0\tYes\t\ts.i = 5; g = s.i;\n+   1\t0\t1\t1\tYes\t\tThe same case as above\n+   1\t1\t0\t0\tNo\t\tWon't help.\n+   1\t1\t0\t1\tYes\t\ts.i = 1; *g = s;\n+   1\t1\t1\t0\tYes\t\ts = *g; return s.i;\n+   1\t1\t1\t1\tYes\t\tAny of the above yeses  */\n \n static bool\n analyze_access_subtree (struct access *root, bool allow_replacements,\n-\t\t\tenum mark_read_status mark_read, bool mark_write)\n+\t\t\tenum mark_rw_status mark_read,\n+\t\t\tenum mark_rw_status mark_write)\n {\n   struct access *child;\n   HOST_WIDE_INT limit = root->offset + root->size;\n   HOST_WIDE_INT covered_to = root->offset;\n   bool scalar = is_gimple_reg_type (root->type);\n   bool hole = false, sth_created = false;\n   bool direct_read = root->grp_read;\n+  bool direct_write = root->grp_write;\n \n-  if (mark_read == SRA_MR_ASSIGN_READ)\n+  if (root->grp_assignment_read)\n+    mark_read = SRA_MRRW_ASSIGN;\n+  else if (mark_read == SRA_MRRW_ASSIGN)\n     {\n       root->grp_read = 1;\n       root->grp_assignment_read = 1;\n     }\n-  if (mark_read == SRA_MR_READ)\n+  else if (mark_read == SRA_MRRW_DIRECT)\n     root->grp_read = 1;\n-  else if (root->grp_assignment_read)\n-    mark_read = SRA_MR_ASSIGN_READ;\n   else if (root->grp_read)\n-    mark_read = SRA_MR_READ;\n+    mark_read = SRA_MRRW_DIRECT;\n \n-  if (mark_write)\n-    root->grp_write = true;\n+  if (root->grp_assignment_write)\n+    mark_write = SRA_MRRW_ASSIGN;\n+  else if (mark_write == SRA_MRRW_ASSIGN)\n+    {\n+      root->grp_write = 1;\n+      root->grp_assignment_write = 1;\n+    }\n+  else if (mark_write == SRA_MRRW_DIRECT)\n+    root->grp_write = 1;\n   else if (root->grp_write)\n-    mark_write = true;\n+    mark_write = SRA_MRRW_DIRECT;\n \n   if (root->grp_unscalarizable_region)\n     allow_replacements = false;\n@@ -1881,7 +1934,8 @@ analyze_access_subtree (struct access *root, bool allow_replacements,\n \n   if (allow_replacements && scalar && !root->first_child\n       && (root->grp_hint\n-\t  || (root->grp_write && (direct_read || root->grp_assignment_read))))\n+\t  || ((direct_write || root->grp_assignment_write)\n+\t      && (direct_read || root->grp_assignment_read))))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1920,7 +1974,8 @@ analyze_access_trees (struct access *access)\n \n   while (access)\n     {\n-      if (analyze_access_subtree (access, true, SRA_MR_NOT_READ, false))\n+      if (analyze_access_subtree (access, true,\n+\t\t\t\t  SRA_MRRW_NOTHING, SRA_MRRW_NOTHING))\n \tret = true;\n       access = access->next_grp;\n     }"}]}