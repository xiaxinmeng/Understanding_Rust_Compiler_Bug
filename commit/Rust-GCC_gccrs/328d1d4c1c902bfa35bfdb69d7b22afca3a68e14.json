{"sha": "328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI4ZDFkNGMxYzkwMmJmYTM1YmZkYjY5ZDdiMjJhZmNhM2E2OGUxNA==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2005-02-09T21:33:02Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2005-02-09T21:33:02Z"}, "message": "allchblk.c (GC_allochblk_nth): Dont overlook available space if GC disabled...\n\n\t* allchblk.c (GC_allochblk_nth): Dont overlook available space if\n\t  GC disabled, correctly convert GC_finalizer_mem_freed to byte,\n  \t  total_size to words.\n  \t* dyn_load.c (win32 GC_register_dynamic_libraries): Consider only\n\t  MEM_IMAGE regions.\n  \t* mach_dep.c (GC_with_callee_saves_pushed): separate into new function,\n\t  and indent appropriately.\n  \t* mark_rts.c (GC_approx_sp): Access stack.\n\t* pthread_stop_world.c: (GC_suspend_handler): Explicitly push\n\t  callee-saves registers when appropriate.\n  \t  (GC_stop_world): Handle EINTR from sem_wait (sync with Mono GC).\n\nFrom-SVN: r94776", "tree": {"sha": "740a513131a2bfd49e69843a563d9ce978424f93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/740a513131a2bfd49e69843a563d9ce978424f93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/comments", "author": null, "committer": null, "parents": [{"sha": "dab80c81c6b7fc84a08f1d1d5745c6861c7082c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab80c81c6b7fc84a08f1d1d5745c6861c7082c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dab80c81c6b7fc84a08f1d1d5745c6861c7082c9"}], "stats": {"total": 186, "additions": 125, "deletions": 61}, "files": [{"sha": "b9c7c46ae0599856d27094092c54ab7486b2c76c", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "patch": "@@ -1,3 +1,17 @@\n+2005-02-07  Hans Boehm  <Hans.Boehm@hp.com>\n+\n+\t* allchblk.c (GC_allochblk_nth): Dont overlook available space if\n+\t  GC disabled, correctly convert GC_finalizer_mem_freed to byte,\n+\t  total_size to words.\n+\t* dyn_load.c (win32 GC_register_dynamic_libraries): Consider only\n+\t  MEM_IMAGE regions.\n+\t* mach_dep.c (GC_with_callee_saves_pushed): separate into new function,\n+\t  and indent appropriately.\n+\t* mark_rts.c (GC_approx_sp): Access stack.\n+\t* pthread_stop_world.c: (GC_suspend_handler): Explicitly push\n+\t  callee-saves registers when appropriate.\n+\t  (GC_stop_world): Handle EINTR from sem_wait (sync with Mono GC).\n+\n 2005-01-01  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* configure.ac (AC_CONFIG_HEADERS): Build both include/gc_config.h "}, {"sha": "f9c31e0452726393aed7600771b65b505352793d", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "patch": "@@ -590,8 +590,9 @@ int n;\n \t    GET_HDR(hbp, hhdr);\n \t    size_avail = hhdr->hb_sz;\n \t    if (size_avail < size_needed) continue;\n-\t    if (!GC_use_entire_heap\n-\t\t&& size_avail != size_needed\n+\t    if (size_avail != size_needed\n+\t\t&& !GC_use_entire_heap\n+\t\t&& !GC_dont_gc\n \t\t&& USED_HEAP_SIZE >= GC_requested_heapsize\n \t\t&& !TRUE_INCREMENTAL && GC_should_collect()) {\n #\t\tifdef USE_MUNMAP\n@@ -608,7 +609,8 @@ int n;\n \t\t    /* If we are deallocating lots of memory from\t*/\n \t\t    /* finalizers, fail and collect sooner rather\t*/\n \t\t    /* than later.\t\t\t\t\t*/\n-\t\t    if (GC_finalizer_mem_freed > (GC_heapsize >> 4))  {\n+\t\t    if (WORDS_TO_BYTES(GC_finalizer_mem_freed)\n+\t\t\t> (GC_heapsize >> 4))  {\n \t\t      continue;\n \t\t    }\n #\t\tendif /* !USE_MUNMAP */\n@@ -698,7 +700,7 @@ int n;\n \t              struct hblk * h;\n \t\t      struct hblk * prev = hhdr -> hb_prev;\n \t              \n-\t\t      GC_words_wasted += total_size;\n+\t\t      GC_words_wasted += BYTES_TO_WORDS(total_size);\n \t\t      GC_large_free_bytes -= total_size;\n \t\t      GC_remove_from_fl(hhdr, n);\n \t              for (h = hbp; h < limit; h++) {"}, {"sha": "dfe0a3c87e8166d38e0bb2713451f84114f6d894", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "patch": "@@ -735,6 +735,10 @@ void GC_register_dynamic_libraries()\n   \n # define HAVE_REGISTER_MAIN_STATIC_DATA\n \n+  /* The frame buffer testing code is dead in this version.\t*/\n+  /* We leave it here temporarily in case the switch to just \t*/\n+  /* testing for MEM_IMAGE sections causes un expected \t\t*/\n+  /* problems.\t\t\t\t\t\t\t*/\n   GC_bool GC_warn_fb = TRUE;\t/* Warn about traced likely \t*/\n   \t\t\t\t/* graphics memory.\t\t*/\n   GC_bool GC_disallow_ignore_fb = FALSE;\n@@ -856,7 +860,11 @@ void GC_register_dynamic_libraries()\n \t\t&& (protect == PAGE_EXECUTE_READWRITE\n \t\t    || protect == PAGE_READWRITE)\n \t\t&& !GC_is_heap_base(buf.AllocationBase)\n-\t\t&& !is_frame_buffer(p, buf.RegionSize)) {  \n+\t\t/* This used to check for\n+\t\t * !is_frame_buffer(p, buf.RegionSize, buf.Type)\n+\t\t * instead of just checking for MEM_IMAGE.\n+\t\t * If something breaks, change it back. */\n+\t\t&& buf.Type == MEM_IMAGE) {\n #\t        ifdef DEBUG_VIRTUALQUERY\n \t          GC_dump_meminfo(&buf);\n #\t        endif"}, {"sha": "5412b8b54fd0ebb75d3c38460b7be9c06a5e8485", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 69, "deletions": 54, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "patch": "@@ -400,64 +400,79 @@ void GC_push_regs()\n }\n #endif /* !USE_GENERIC_PUSH_REGS && !USE_ASM_PUSH_REGS */\n \n+void GC_with_callee_saves_pushed(fn, arg)\n+void (*fn)();\n+ptr_t arg;\n+{\n+    word dummy;\n+\n+#   if defined(USE_GENERIC_PUSH_REGS)\n+#     ifdef HAVE_BUILTIN_UNWIND_INIT\n+        /* This was suggested by Richard Henderson as the way to\t*/\n+        /* force callee-save registers and register windows onto\t*/\n+        /* the stack.\t\t\t\t\t\t*/\n+        __builtin_unwind_init();\n+#     else /* !HAVE_BUILTIN_UNWIND_INIT */\n+        /* Generic code                          */\n+        /* The idea is due to Parag Patel at HP. */\n+        /* We're not sure whether he would like  */\n+        /* to be he acknowledged for it or not.  */\n+        jmp_buf regs;\n+        register word * i = (word *) regs;\n+        register ptr_t lim = (ptr_t)(regs) + (sizeof regs);\n+  \n+        /* Setjmp doesn't always clear all of the buffer.\t\t*/\n+        /* That tends to preserve garbage.  Clear it.   \t\t*/\n+  \tfor (; (char *)i < lim; i++) {\n+  \t    *i = 0;\n+  \t}\n+#       if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n+                  || defined(UTS4) || defined(LINUX) || defined(EWS4800)\n+  \t  (void) setjmp(regs);\n+#       else\n+            (void) _setjmp(regs);\n+  \t  /* We don't want to mess with signals. According to\t*/\n+  \t  /* SUSV3, setjmp() may or may not save signal mask.\t*/\n+  \t  /* _setjmp won't, but is less portable.\t\t*/\n+#       endif\n+#     endif /* !HAVE_BUILTIN_UNWIND_INIT */\n+#   elif defined(PTHREADS) && !defined(MSWIN32) /* !USE_GENERIC_PUSH_REGS */\n+      /* We may still need this to save thread contexts.\t*/\n+      /* This should probably be used in all Posix/non-gcc\t*/\n+      /* settings.  We defer that change to minimize risk.\t*/\n+      ucontext_t ctxt;\n+      getcontext(&ctxt);\n+#   else  /* Shouldn't be needed */\n+      ABORT(\"Unexpected call to GC_with_callee_saves_pushed\");\n+#   endif\n+#   if (defined(SPARC) && !defined(HAVE_BUILTIN_UNWIND_INIT)) \\\n+\t|| defined(IA64)\n+      /* On a register window machine, we need to save register\t*/\n+      /* contents on the stack for this to work.  The setjmp\t*/\n+      /* is probably not needed on SPARC, since pointers are\t*/\n+      /* only stored in windowed or scratch registers.  It is\t*/\n+      /* needed on IA64, since some non-windowed registers are\t*/\n+      /* preserved.\t\t\t\t\t\t*/\n+      {\n+        GC_save_regs_ret_val = GC_save_regs_in_stack();\n+\t/* On IA64 gcc, could use __builtin_ia64_flushrs() and\t*/\n+\t/* __builtin_ia64_flushrs().  The latter will be done\t*/\n+\t/* implicitly by __builtin_unwind_init() for gcc3.0.1\t*/\n+\t/* and later.\t\t\t\t\t\t*/\n+      }\n+#   endif\n+    fn(arg);\n+    /* Strongly discourage the compiler from treating the above\t*/\n+    /* as a tail-call, since that would pop the register \t*/\n+    /* contents before we get a chance to look at them.\t\t*/\n+    GC_noop1((word)(&dummy));\n+}\n+\n #if defined(USE_GENERIC_PUSH_REGS)\n void GC_generic_push_regs(cold_gc_frame)\n ptr_t cold_gc_frame;\n {\n-\t{\n-\t    word dummy;\n-\n-#\t    ifdef HAVE_BUILTIN_UNWIND_INIT\n-\t      /* This was suggested by Richard Henderson as the way to\t*/\n-\t      /* force callee-save registers and register windows onto\t*/\n-\t      /* the stack.\t\t\t\t\t\t*/\n-\t      __builtin_unwind_init();\n-#\t    else /* !HAVE_BUILTIN_UNWIND_INIT */\n-\t      /* Generic code                          */\n-\t      /* The idea is due to Parag Patel at HP. */\n-\t      /* We're not sure whether he would like  */\n-\t      /* to be he acknowledged for it or not.  */\n-\t      jmp_buf regs;\n-\t      register word * i = (word *) regs;\n-\t      register ptr_t lim = (ptr_t)(regs) + (sizeof regs);\n-\n-\t      /* Setjmp doesn't always clear all of the buffer.\t\t*/\n-\t      /* That tends to preserve garbage.  Clear it.   \t\t*/\n-\t\tfor (; (char *)i < lim; i++) {\n-\t\t    *i = 0;\n-\t\t}\n-#\t      if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n-                || defined(UTS4) || defined(LINUX) || defined(EWS4800)\n-\t\t  (void) setjmp(regs);\n-#\t      else\n-\t          (void) _setjmp(regs);\n-\t\t  /* We don't want to mess with signals. According to\t*/\n-\t\t  /* SUSV3, setjmp() may or may not save signal mask.\t*/\n-\t\t  /* _setjmp won't, but is less portable.\t\t*/\n-#\t      endif\n-#\t    endif /* !HAVE_BUILTIN_UNWIND_INIT */\n-#           if (defined(SPARC) && !defined(HAVE_BUILTIN_UNWIND_INIT)) \\\n-\t\t|| defined(IA64)\n-\t      /* On a register window machine, we need to save register\t*/\n-\t      /* contents on the stack for this to work.  The setjmp\t*/\n-\t      /* is probably not needed on SPARC, since pointers are\t*/\n-\t      /* only stored in windowed or scratch registers.  It is\t*/\n-\t      /* needed on IA64, since some non-windowed registers are\t*/\n-\t      /* preserved.\t\t\t\t\t\t*/\n-\t      {\n-\t        GC_save_regs_ret_val = GC_save_regs_in_stack();\n-\t\t/* On IA64 gcc, could use __builtin_ia64_flushrs() and\t*/\n-\t\t/* __builtin_ia64_flushrs().  The latter will be done\t*/\n-\t\t/* implicitly by __builtin_unwind_init() for gcc3.0.1\t*/\n-\t\t/* and later.\t\t\t\t\t\t*/\n-\t      }\n-#           endif\n-\t    GC_push_current_stack(cold_gc_frame);\n-\t    /* Strongly discourage the compiler from treating the above\t*/\n-\t    /* as a tail-call, since that would pop the register \t*/\n-\t    /* contents before we get a chance to look at them.\t\t*/\n-\t    GC_noop1((word)(&dummy));\n-\t}\n+    GC_with_callee_saves_pushed(GC_push_current_stack, cold_gc_frame);\n }\n #endif /* USE_GENERIC_PUSH_REGS */\n "}, {"sha": "4074879a71aa90d1f8e638b9ce7521573939bfb4", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "patch": "@@ -368,8 +368,11 @@ ptr_t p;\n \n ptr_t GC_approx_sp()\n {\n-    word dummy;\n+    VOLATILE word dummy;\n \n+    dummy = 42;\t/* Force stack to grow if necessary.\tOtherwise the\t*/\n+    \t\t/* later accesses might cause the kernel to think we're\t*/\n+    \t\t/* doing something wrong.\t\t\t\t*/\n #   ifdef _MSC_VER\n #     pragma warning(disable:4172)\n #   endif"}, {"sha": "b5e7faed5abb761d7ef49f66116c5c81f2599f4c", "filename": "boehm-gc/pthread_stop_world.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fpthread_stop_world.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d1d4c1c902bfa35bfdb69d7b22afca3a68e14/boehm-gc%2Fpthread_stop_world.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_stop_world.c?ref=328d1d4c1c902bfa35bfdb69d7b22afca3a68e14", "patch": "@@ -101,8 +101,28 @@ word GC_stop_count;\t/* Incremented at the beginning of GC_stop_world. */\n \n sem_t GC_suspend_ack_sem;\n \n+void GC_suspend_handler_inner(ptr_t sig_arg);\n+\n+#if defined(IA64) || defined(HP_PA)\n+extern void GC_with_callee_saves_pushed();\n+\n void GC_suspend_handler(int sig)\n {\n+  GC_with_callee_saves_pushed(GC_suspend_handler_inner, (ptr_t)(word)sig);\n+}\n+\n+#else\n+/* We believe that in all other cases the full context is already\t*/\n+/* in the signal handler frame.\t\t\t\t\t\t*/\n+void GC_suspend_handler(int sig)\n+{\n+  GC_suspend_handler_inner((ptr_t)(word)sig);\n+}\n+#endif\n+\n+void GC_suspend_handler_inner(ptr_t sig_arg)\n+{\n+    int sig = (int)(word)sig_arg;\n     int dummy;\n     pthread_t my_thread = pthread_self();\n     GC_thread me;\n@@ -369,9 +389,11 @@ void GC_stop_world()\n \t  }\n       }\n     for (i = 0; i < n_live_threads; i++) {\n-\t  if (0 != (code = sem_wait(&GC_suspend_ack_sem))) {\n+\t  while (0 != (code = sem_wait(&GC_suspend_ack_sem))) {\n+\t    if (errno != EINTR) {\n \t      GC_err_printf1(\"Sem_wait returned %ld\\n\", (unsigned long)code);\n \t      ABORT(\"sem_wait for handler failed\");\n+\t    }\n \t  }\n     }\n #   ifdef PARALLEL_MARK"}]}