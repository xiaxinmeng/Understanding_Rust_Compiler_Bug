{"sha": "84d901be21286abad53306a8e883571ca9258676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkOTAxYmUyMTI4NmFiYWQ1MzMwNmE4ZTg4MzU3MWNhOTI1ODY3Ng==", "commit": {"author": {"name": "Akim Demaille", "email": "akim@epita.fr", "date": "2002-06-20T01:30:57Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-06-20T01:30:57Z"}, "message": "c-parse.in (initelt: identifier ':' initval): Add an empty action to fix a type clash.\n\n2002-06-19  Akim Demaille  <akim@epita.fr>\n\n\t* c-parse.in (initelt: identifier ':' initval): Add an empty\n\taction to fix a type clash.\n\t(aliasdecl, classdef): Add the missing closing `;'.\n\tWhitespace changes.\n\t* gengtype-yacc.y (typedef_struct): Add an empty action to preevnt\n\t$$ = $1 type clashes.\n\ncp:\n\t* parse.y (TYPENAME): Rename as tTYPENAME to avoid the clash with\n\tdecl.h's TYPENAME.\n\t* spew.c, lex.c: Adjust.\n\t* parse.y (explicit_instantiation): Add empty action to override\n\tthe default $$ = $1 where it introduces a type clash.\n\nFrom-SVN: r54811", "tree": {"sha": "8b5f9fd70b4180372f458c943cf1efac75257426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b5f9fd70b4180372f458c943cf1efac75257426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84d901be21286abad53306a8e883571ca9258676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d901be21286abad53306a8e883571ca9258676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d901be21286abad53306a8e883571ca9258676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d901be21286abad53306a8e883571ca9258676/comments", "author": {"login": "akimd", "id": 232441, "node_id": "MDQ6VXNlcjIzMjQ0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/232441?v=4", "gravatar_id": "", "url": "https://api.github.com/users/akimd", "html_url": "https://github.com/akimd", "followers_url": "https://api.github.com/users/akimd/followers", "following_url": "https://api.github.com/users/akimd/following{/other_user}", "gists_url": "https://api.github.com/users/akimd/gists{/gist_id}", "starred_url": "https://api.github.com/users/akimd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/akimd/subscriptions", "organizations_url": "https://api.github.com/users/akimd/orgs", "repos_url": "https://api.github.com/users/akimd/repos", "events_url": "https://api.github.com/users/akimd/events{/privacy}", "received_events_url": "https://api.github.com/users/akimd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef40bc6512a22ab6e963f7c0980bef41082b8fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef40bc6512a22ab6e963f7c0980bef41082b8fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef40bc6512a22ab6e963f7c0980bef41082b8fcb"}], "stats": {"total": 536, "additions": 282, "deletions": 254}, "files": [{"sha": "e4af10f33e96ede36dabf4441822f2bba92a8277", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -1,3 +1,12 @@\n+2002-06-19  Akim Demaille  <akim@epita.fr>\n+\n+\t* c-parse.in (initelt: identifier ':' initval): Add an empty\n+\taction to fix a type clash.\n+\t(aliasdecl, classdef): Add the missing closing `;'.\n+\tWhitespace changes.\n+\t* gengtype-yacc.y (typedef_struct): Add an empty action to preevnt\n+\t$$ = $1 type clashes.\n+\n 2002-06-19  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.c (symbol_operand): New function.\n@@ -70,7 +79,7 @@\n \n 2002-06-19  Andrew Pinski <pinskia@physics.uc.edu>\n \n-        * cpptrad.c (_cpp_replacement_text_len): initialize len.\n+\t* cpptrad.c (_cpp_replacement_text_len): initialize len.\n \n 2002-06-19  Jason Merrill  <jason@redhat.com>\n "}, {"sha": "2a58668e0aac4e634f7c38016075b1753805fb85", "filename": "gcc/c-parse.in", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -49,7 +49,7 @@ end ifc\n #include \"output.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n-  \n+\n #ifdef MULTIBYTE_CHARS\n #include <locale.h>\n #endif\n@@ -255,11 +255,11 @@ ifobjc\n end ifobjc\n \f\n %{\n-/* Number of statements (loosely speaking) and compound statements \n+/* Number of statements (loosely speaking) and compound statements\n    seen so far.  */\n static int stmt_count;\n static int compstmt_count;\n-  \n+\n /* Input file and line number of the end of the body of last simple_if;\n    used by the stmt-rule immediately after simple_if returns.  */\n static const char *if_stmt_file;\n@@ -320,8 +320,8 @@ static enum tree_code objc_inherit_code;\n static int objc_pq_context = 0, objc_public_flag = 0;\n \n /* The following flag is needed to contextualize ObjC lexical analysis.\n-   In some cases (e.g., 'int NSObject;'), it is undesirable to bind \n-   an identifier to an ObjC class, even if a class with that name \n+   In some cases (e.g., 'int NSObject;'), it is undesirable to bind\n+   an identifier to an ObjC class, even if a class with that name\n    exists.  */\n static int objc_need_raw_identifier;\n #define OBJC_NEED_RAW_IDENTIFIER(VAL)\tobjc_need_raw_identifier = VAL\n@@ -404,7 +404,7 @@ datadef:\n \t\t{ if (pedantic)\n \t\t    error (\"ISO C forbids data definition with no type or storage class\");\n \t\t  else\n-\t\t    warning (\"data definition has no type or storage class\"); \n+\t\t    warning (\"data definition has no type or storage class\");\n \n \t\t  POP_DECLSPEC_STACK; }\n         | declspecs_nots setspecs notype_initdecls ';'\n@@ -431,7 +431,7 @@ fndef:\n \t  save_filename save_lineno compstmt_or_error\n \t\t{ DECL_SOURCE_FILE (current_function_decl) = $7;\n \t\t  DECL_SOURCE_LINE (current_function_decl) = $8;\n-\t\t  finish_function (0, 1); \n+\t\t  finish_function (0, 1);\n \t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs declarator error\n \t\t{ POP_DECLSPEC_STACK; }\n@@ -445,7 +445,7 @@ fndef:\n \t  save_filename save_lineno compstmt_or_error\n \t\t{ DECL_SOURCE_FILE (current_function_decl) = $7;\n \t\t  DECL_SOURCE_LINE (current_function_decl) = $8;\n-\t\t  finish_function (0, 1); \n+\t\t  finish_function (0, 1);\n \t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_declarator error\n \t\t{ POP_DECLSPEC_STACK; }\n@@ -459,7 +459,7 @@ fndef:\n \t  save_filename save_lineno compstmt_or_error\n \t\t{ DECL_SOURCE_FILE (current_function_decl) = $6;\n \t\t  DECL_SOURCE_LINE (current_function_decl) = $7;\n-\t\t  finish_function (0, 1); \n+\t\t  finish_function (0, 1);\n \t\t  POP_DECLSPEC_STACK; }\n \t| setspecs notype_declarator error\n \t\t{ POP_DECLSPEC_STACK; }\n@@ -667,7 +667,7 @@ primary:\n \t\t{ $$ = fix_string_type ($$); }\n \t| VAR_FUNC_NAME\n \t\t{ $$ = fname_decl (C_RID_CODE ($$), $$); }\n-\t| '(' typename ')' '{' \n+\t| '(' typename ')' '{'\n \t\t{ start_init (NULL_TREE, NULL, 0);\n \t\t  $2 = groktypename ($2);\n \t\t  really_start_incremental_init ($2); }\n@@ -1431,7 +1431,7 @@ initdcl:\n \t| declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0,\n \t\t\t\t       chainon ($3, all_prefix_attributes));\n-\t\t  finish_decl (d, NULL_TREE, $2); \n+\t\t  finish_decl (d, NULL_TREE, $2);\n                 }\n \t;\n \n@@ -1457,7 +1457,7 @@ maybe_attribute:\n \t| attributes\n \t\t{ $$ = $1; }\n \t;\n- \n+\n attributes:\n       attribute\n \t\t{ $$ = $1; }\n@@ -1476,7 +1476,7 @@ attribute_list:\n \t| attribute_list ',' attrib\n \t\t{ $$ = chainon ($1, $3); }\n \t;\n- \n+\n attrib:\n     /* empty */\n \t\t{ $$ = NULL_TREE; }\n@@ -1544,6 +1544,7 @@ initelt:\n \t\t  if (pedantic)\n \t\t    pedwarn (\"obsolete use of designated initializer with `:'\"); }\n \t  initval\n+\t\t{}\n \t| initval\n \t;\n \n@@ -1604,7 +1605,7 @@ nested_function:\n \t\t  DECL_SOURCE_FILE (decl) = $5;\n \t\t  DECL_SOURCE_LINE (decl) = $6;\n \t\t  finish_function (1, 1);\n-\t\t  pop_function_context (); \n+\t\t  pop_function_context ();\n \t\t  add_decl_stmt (decl); }\n \t;\n \n@@ -1634,7 +1635,7 @@ notype_nested_function:\n \t\t  DECL_SOURCE_FILE (decl) = $5;\n \t\t  DECL_SOURCE_LINE (decl) = $6;\n \t\t  finish_function (1, 1);\n-\t\t  pop_function_context (); \n+\t\t  pop_function_context ();\n \t\t  add_decl_stmt (decl); }\n \t;\n \n@@ -1755,7 +1756,7 @@ structsp_attr:\n \t\t{ $$ = start_struct (RECORD_TYPE, $2);\n \t\t  /* Start scope of tag before parsing components.  */\n \t\t}\n-\t  component_decl_list '}' maybe_attribute \n+\t  component_decl_list '}' maybe_attribute\n \t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n \t| struct_head '{' component_decl_list '}' maybe_attribute\n \t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n@@ -1845,8 +1846,8 @@ component_decl:\n \t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nosc_ts setspecs save_filename save_lineno\n \t\t{\n-\t\t  /* Support for unnamed structs or unions as members of \n-\t\t     structs or unions (which is [a] useful and [b] supports \n+\t\t  /* Support for unnamed structs or unions as members of\n+\t\t     structs or unions (which is [a] useful and [b] supports\n \t\t     MS P-SDK).  */\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C doesn't support unnamed structs/unions\");\n@@ -2102,8 +2103,8 @@ c99_block_end: /* empty */\n                 { if (flag_isoc99)\n \t\t    {\n \t\t      tree scope_stmt = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-\t\t      $$ = poplevel (kept_level_p (), 0, 0); \n-\t\t      SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmt)) \n+\t\t      $$ = poplevel (kept_level_p (), 0, 0);\n+\t\t      SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmt))\n \t\t\t= SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmt))\n \t\t\t= $$;\n \t\t    }\n@@ -2152,8 +2153,8 @@ compstmt_start: '{' { compstmt_count++;\n compstmt_nostart: '}'\n \t\t{ $$ = convert (void_type_node, integer_zero_node); }\n \t| pushlevel maybe_label_decls compstmt_contents_nonempty '}' poplevel\n-\t\t{ $$ = poplevel (kept_level_p (), 1, 0); \n-\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5)) \n+\t\t{ $$ = poplevel (kept_level_p (), 1, 0);\n+\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5))\n \t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($5))\n \t\t    = $$; }\n \t;\n@@ -2182,7 +2183,7 @@ compstmt_primary_start:\n         ;\n \n compstmt: compstmt_start compstmt_nostart\n-\t\t{ RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); \n+\t\t{ RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n \t\t  last_expr_type = NULL_TREE;\n                   $$ = $1; }\n \t;\n@@ -2209,7 +2210,7 @@ if_prefix:\n           IF\n                 { $<ttype>$ = c_begin_if_stmt (); }\n             '(' expr ')'\n-\t\t{ c_expand_start_cond (c_common_truthvalue_conversion ($4), \n+\t\t{ c_expand_start_cond (c_common_truthvalue_conversion ($4),\n \t\t\t\t       compstmt_count,$<ttype>2);\n \t\t  $<itype>$ = stmt_count;\n \t\t  if_stmt_file = $<filename>-2;\n@@ -2223,7 +2224,7 @@ do_stmt_start:\n \t  DO\n \t\t{ stmt_count++;\n \t\t  compstmt_count++;\n-\t\t  $<ttype>$ \n+\t\t  $<ttype>$\n \t\t    = add_stmt (build_stmt (DO_STMT, NULL_TREE,\n \t\t\t\t\t    NULL_TREE));\n \t\t  /* In the event that a parse error prevents\n@@ -2318,7 +2319,7 @@ select_or_iter_stmt:\n \t  we later pass to c_finish_while_stmt_cond to fill\n \t  in the condition and other tidbits.  */\n \t| WHILE\n-                { stmt_count++; \n+                { stmt_count++;\n \t\t  $<ttype>$ = c_begin_while_stmt (); }\n \t  '(' expr ')'\n                 { $4 = c_common_truthvalue_conversion ($4);\n@@ -2335,12 +2336,12 @@ select_or_iter_stmt:\n \t| FOR\n \t\t{ $<ttype>$ = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n \t\t\t\t\t  NULL_TREE, NULL_TREE);\n-\t\t  add_stmt ($<ttype>$); } \n+\t\t  add_stmt ($<ttype>$); }\n \t  '(' for_init_stmt\n \t\t{ stmt_count++;\n \t\t  RECHAIN_STMTS ($<ttype>2, FOR_INIT_STMT ($<ttype>2)); }\n \t  xexpr ';'\n-                { if ($6) \n+                { if ($6)\n \t\t    FOR_COND ($<ttype>2)\n \t\t      = c_common_truthvalue_conversion ($6); }\n \t  xexpr ')'\n@@ -2356,7 +2357,7 @@ select_or_iter_stmt:\n \n for_init_stmt:\n \t  xexpr ';'\n-\t\t{ add_stmt (build_stmt (EXPR_STMT, $1)); } \n+\t\t{ add_stmt (build_stmt (EXPR_STMT, $1)); }\n \t| decl\n \t\t{ check_for_loop_decls (); }\n \t;\n@@ -2567,7 +2568,7 @@ parm:\n \t| declspecs_ts setspecs notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, all_prefix_attributes)); \n+\t\t\t\t\tchainon ($4, all_prefix_attributes));\n \t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts setspecs absdcl_maybe_attribute\n \t\t{ $$ = $3;\n@@ -2594,7 +2595,7 @@ firstparm:\n \t| declspecs_ts_nosa setspecs_fp notype_declarator maybe_attribute\n \t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t $3),\n-\t\t\t\t\tchainon ($4, all_prefix_attributes)); \n+\t\t\t\t\tchainon ($4, all_prefix_attributes));\n \t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_ts_nosa setspecs_fp absdcl_maybe_attribute\n \t\t{ $$ = $3;\n@@ -2708,12 +2709,14 @@ classdecl:\n \t\t{\n \t\t  objc_declare_class ($2);\n \t\t}\n+\t;\n \n aliasdecl:\n \t  ALIAS identifier identifier ';'\n \t\t{\n \t\t  objc_declare_alias ($2, $3);\n \t\t}\n+\t;\n \n classdef:\n \t  INTERFACE identifier protocolrefs '{'\n@@ -3452,7 +3455,7 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_BYCOPY */\tTYPE_QUAL,\n   /* RID_BYREF */\tTYPE_QUAL,\n   /* RID_ONEWAY */\tTYPE_QUAL,\n-  \n+\n   /* C */\n   /* RID_INT */\t\tTYPESPEC,\n   /* RID_CHAR */\tTYPESPEC,\n@@ -3538,7 +3541,7 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_BITAND */\t0,\n   /* RID_BITOR */\t0,\n   /* RID_COMPL */\t0,\n-  \n+\n   /* Objective C */\n   /* RID_ID */\t\t\tOBJECTNAME,\n   /* RID_AT_ENCODE */\t\tENCODE,\n@@ -3618,12 +3621,12 @@ static int\n yylexname ()\n {\n   tree decl;\n-  \n+\n ifobjc\n   int objc_force_identifier = objc_need_raw_identifier;\n   OBJC_NEED_RAW_IDENTIFIER (0);\n end ifobjc\n-  \n+\n   if (C_IS_RESERVED_WORD (yylval.ttype))\n     {\n       enum rid rid_code = C_RID_CODE (yylval.ttype);\n@@ -3648,13 +3651,13 @@ end ifobjc\n \t    /* __FUNCTION__ and __PRETTY_FUNCTION__ get converted\n \t       to string constants.  */\n \t    const char *name = fname_string (rid_code);\n-\t  \n+\n \t    yylval.ttype = build_string (strlen (name) + 1, name);\n \t    C_ARTIFICIAL_STRING_P (yylval.ttype) = 1;\n \t    last_token = CPP_STRING;  /* so yyerror won't choke */\n \t    return STRING;\n \t  }\n-      \n+\n \t/* Return the canonical spelling for this keyword.  */\n \tyylval.ttype = ridpointers[(int) rid_code];\n \treturn yycode;\n@@ -3673,8 +3676,8 @@ ifobjc\n       tree objc_interface_decl = is_class_name (yylval.ttype);\n       /* ObjC class names are in the same namespace as variables and\n \t typedefs, and hence are shadowed by local declarations.  */\n-      if (objc_interface_decl \n-\t  && (global_bindings_p () \n+      if (objc_interface_decl\n+\t  && (global_bindings_p ()\n \t      || (!objc_force_identifier && !decl)))\n \t{\n \t  yylval.ttype = objc_interface_decl;\n@@ -3819,7 +3822,7 @@ _yylex ()\n     case CPP_STRING:\n     case CPP_WSTRING:\n       return yylexstring ();\n-      \n+\n       /* This token is Objective-C specific.  It gives the next token\n \t special significance.  */\n     case CPP_ATSIGN:\n@@ -3885,7 +3888,7 @@ yyprint (file, yychar, yyl)\n   tree t = yyl.ttype;\n \n   fprintf (file, \" [%s]\", NAME(last_token));\n-  \n+\n   switch (yychar)\n     {\n     case IDENTIFIER:"}, {"sha": "b599aba347f49dd528889b808b4060ba2ba77718", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -1,3 +1,11 @@\n+2002-06-19  Akim Demaille  <akim@epita.fr>\n+\n+\t* parse.y (TYPENAME): Rename as tTYPENAME to avoid the clash with\n+\tdecl.h's TYPENAME.\n+\t* spew.c, lex.c: Adjust.\n+\t* parse.y (explicit_instantiation): Add empty action to override\n+\tthe default $$ = $1 where it introduces a type clash.\n+\n 2002-06-14  Jason Merrill  <jason@redhat.com>\n \n \t* semantics.c (begin_for_stmt): Push the 'for' scope before\n@@ -75,8 +83,8 @@\n \t* mangle.c (start_mangling): Allocate G.substitutions here...\n \t(init_mangle): ... rather than here.\n \t(finish_mangling): Clear the varray pointer when done with it.\n-\t* spew.c (yylexstring): Don't use VARRAY_FREE. \n-\t* search.c (bfs_walk): Don't use VARRAY_FREE. \n+\t* spew.c (yylexstring): Don't use VARRAY_FREE.\n+\t* search.c (bfs_walk): Don't use VARRAY_FREE.\n \t* decl2.c (pending_statics): Use gengtype to mark.\n \t(deferred_fns): Likewise.\n \t(ssdf_decls): Likewise.\n@@ -988,7 +996,7 @@\n \n 2002-03-21  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * tree.c (cp_cannot_inline_tree_fn): Same.\n+\t* tree.c (cp_cannot_inline_tree_fn): Same.\n \n 2002-03-21  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n@@ -1306,10 +1314,10 @@\n \n 2002-02-21  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * cp/decl.c (duplicate_decls): Merge always_inline attribute.\n+\t* cp/decl.c (duplicate_decls): Merge always_inline attribute.\n \n-        * cp/tree.c (cp_cannot_inline_tree_fn): Do not inline at -O0\n-        unless DECL_ALWAYS_INLINE.\n+\t* cp/tree.c (cp_cannot_inline_tree_fn): Do not inline at -O0\n+\tunless DECL_ALWAYS_INLINE.\n \n 2002-02-20  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "ae2cd326ac8f262eda77e2f23a8a4ee361512547", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -86,10 +86,11 @@ extern YYSTYPE yylval;\t\t/*  the semantic value of the\t\t*/\n int warn_traditional = 0;\n int flag_digraphs = 1;\n \n-/* the declaration found for the last IDENTIFIER token read in.\n-   yylex must look this up to detect typedefs, which get token type TYPENAME,\n-   so it is left around in case the identifier is not a typedef but is\n-   used in a context which makes it a reference to a variable.  */\n+/* the declaration found for the last IDENTIFIER token read in.  yylex\n+   must look this up to detect typedefs, which get token type\n+   tTYPENAME, so it is left around in case the identifier is not a\n+   typedef but is used in a context which makes it a reference to a\n+   variable.  */\n tree lastiddecl;\n \n /* Array for holding counts of the numbers of tokens seen.  */\n@@ -692,7 +693,7 @@ yyprint (file, yychar, yylval)\n   switch (yychar)\n     {\n     case IDENTIFIER:\n-    case TYPENAME:\n+    case tTYPENAME:\n     case TYPESPEC:\n     case PTYPENAME:\n     case PFUNCNAME:\n@@ -914,7 +915,7 @@ check_for_missing_semicolon (type)\n   if ((yychar > 255\n        && yychar != SCSPEC\n        && yychar != IDENTIFIER\n-       && yychar != TYPENAME\n+       && yychar != tTYPENAME\n        && yychar != CV_QUALIFIER\n        && yychar != SELFNAME)\n       || yychar == 0  /* EOF */)"}, {"sha": "4847b3f7a2231a54a6dc76888890c0ca5846b33b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 164, "deletions": 160, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -138,7 +138,7 @@ empty_parms ()\n   tree parms;\n \n #ifndef NO_IMPLICIT_EXTERN_C\n-  if (in_system_header && current_class_type == NULL \n+  if (in_system_header && current_class_type == NULL\n       && current_lang_name == lang_name_c)\n     parms = NULL_TREE;\n   else\n@@ -163,12 +163,12 @@ frob_specs (specs_attrs, lookups)\n     {\n       /* We have to indicate that there is an \"extern\", but that it\n          was part of a language specifier.  For instance,\n-\t \n+\n     \t    extern \"C\" typedef int (*Ptr) ();\n \n          is well formed.  */\n       current_declspecs = tree_cons (error_mark_node,\n-\t\t\t\t     get_identifier (\"extern\"), \n+\t\t\t\t     get_identifier (\"extern\"),\n \t\t\t\t     current_declspecs);\n       used_extern_spec = 1;\n     }\n@@ -268,10 +268,10 @@ check_class_key (key, aggr)\n %start program\n \n %union { GTY(())\n-  long itype; \n-  tree ttype; \n-  char *strtype; \n-  enum tree_code code; \n+  long itype;\n+  tree ttype;\n+  char *strtype;\n+  enum tree_code code;\n   flagged_type_tree ftype;\n   struct unparsed_text *pi;\n }\n@@ -283,7 +283,7 @@ check_class_key (key, aggr)\n /* All identifiers that are declared typedefs in the current block.\n    In some contexts, they are treated just like IDENTIFIER,\n    but they can also serve as typespecs in declarations.  */\n-%token TYPENAME\n+%token tTYPENAME\n %token SELFNAME\n \n /* A template function.  */\n@@ -345,7 +345,7 @@ check_class_key (key, aggr)\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER PFUNCNAME TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD ATTRIBUTE\n+%left IDENTIFIER PFUNCNAME tTYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD ATTRIBUTE\n \n %left '{' ',' ';'\n \n@@ -375,7 +375,7 @@ check_class_key (key, aggr)\n \n %type <code> unop\n \n-%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n+%type <ttype> identifier IDENTIFIER tTYPENAME CONSTANT expr nonnull_exprlist\n %type <ttype> PFUNCNAME maybe_identifier\n %type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas expr_no_comma_rangle\n@@ -396,14 +396,14 @@ check_class_key (key, aggr)\n %type <ttype> after_type_declarator_intern\n %type <ttype> direct_notype_declarator direct_after_type_declarator\n %type <itype> components notype_components\n-%type <ttype> component_decl component_decl_1 \n+%type <ttype> component_decl component_decl_1\n %type <ttype> component_declarator component_declarator0\n %type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n %type <ttype> absdcl cv_qualifiers\n %type <ttype> direct_abstract_declarator conversion_declarator\n %type <ttype> new_declarator direct_new_declarator\n-%type <ttype> xexpr parmlist parms bad_parm \n+%type <ttype> xexpr parmlist parms bad_parm\n %type <ttype> identifiers_or_typenames\n %type <ttype> fcast_or_absdcl regcast_or_absdcl\n %type <ttype> expr_or_declarator expr_or_declarator_intern\n@@ -412,7 +412,7 @@ check_class_key (key, aggr)\n %type <ttype> template_id do_id object_template_id notype_template_declarator\n %type <ttype> overqualified_id notype_qualified_id any_id\n %type <ttype> complex_direct_notype_declarator functional_cast\n-%type <ttype> complex_parmlist parms_comma \n+%type <ttype> complex_parmlist parms_comma\n %type <ttype> namespace_qualifier namespace_using_decl\n \n %type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs\n@@ -426,7 +426,7 @@ check_class_key (key, aggr)\n %token <ttype> PTYPENAME\n %token <ttype> EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n-%token <pi> PRE_PARSED_FUNCTION_DECL \n+%token <pi> PRE_PARSED_FUNCTION_DECL\n %type <ttype> component_constructor_declarator\n %type <ttype> fn_def2 return_id constructor_declarator\n %type <ttype> begin_function_body_\n@@ -569,7 +569,7 @@ extdef:\n \t;\n \n namespace_alias:\n-          NAMESPACE identifier '=' \n+          NAMESPACE identifier '='\n                 { begin_only_namespace_names (); }\n           any_id ';'\n \t\t{\n@@ -656,7 +656,7 @@ template_parm_header:\n \n template_spec_header:\n \t  TEMPLATE '<' '>'\n-                { begin_specialization(); \n+                { begin_specialization();\n \t\t  $$ = NULL_TREE; }\n \t;\n \n@@ -809,7 +809,7 @@ eat_saved_input:\n function_body:\n \t  begin_function_body_ ctor_initializer_opt save_lineno '{'\n \t\t{ $<ttype>$ = begin_compound_stmt (/*has_no_scope=*/1); }\n-\t  compstmtend \n+\t  compstmtend\n                 {\n \t\t  STMT_LINENO ($<ttype>5) = $3;\n \t\t  finish_compound_stmt (/*has_no_scope=*/1, $<ttype>5);\n@@ -827,36 +827,36 @@ fndef:\n \t;\n \n constructor_declarator:\n-\t  nested_name_specifier SELFNAME '(' \n+\t  nested_name_specifier SELFNAME '('\n                 { $$ = begin_constructor_declarator ($1, $2); }\n \t  parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }\n \t| nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n-                { $$ = begin_constructor_declarator ($1, $2); \n+                { $$ = begin_constructor_declarator ($1, $2);\n \t\t  $$ = make_call_declarator ($$, empty_parms (), $4, $5);\n \t\t}\n-\t| global_scope nested_name_specifier SELFNAME '(' \n+\t| global_scope nested_name_specifier SELFNAME '('\n                 { $$ = begin_constructor_declarator ($2, $3); }\n \t parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }\n \t| global_scope nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n \t\t{ $$ = begin_constructor_declarator ($2, $3);\n \t\t  $$ = make_call_declarator ($$, empty_parms (), $5, $6);\n \t\t}\n-\t| nested_name_specifier self_template_type '(' \n+\t| nested_name_specifier self_template_type '('\n                 { $$ = begin_constructor_declarator ($1, $2); }\n \t  parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }\n \t| nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n \t\t{ $$ = begin_constructor_declarator ($1, $2);\n \t\t  $$ = make_call_declarator ($$, empty_parms (), $4, $5);\n \t\t}\n-\t| global_scope nested_name_specifier self_template_type '(' \n+\t| global_scope nested_name_specifier self_template_type '('\n                 { $$ = begin_constructor_declarator ($2, $3); }\n \t parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }\n \t| global_scope nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n-\t\t{ $$ = begin_constructor_declarator ($2, $3); \n+\t\t{ $$ = begin_constructor_declarator ($2, $3);\n \t\t  $$ = make_call_declarator ($$, empty_parms (), $5, $6);\n \t\t}\n \t;\n@@ -911,19 +911,19 @@ fn_def2:\n \t\t    yychar = YYLEX;\n \t\t  snarf_method ($$); }\n \t| component_constructor_declarator\n-\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n+\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE);\n \t\t  goto rest_of_mdef; }\n \t| typed_declspecs declarator\n \t\t{ $$ = parse_method ($2, $1.t, $1.lookups); goto rest_of_mdef;}\n \t| declmods notype_declarator\n \t\t{ $$ = parse_method ($2, $1.t, $1.lookups); goto rest_of_mdef;}\n \t| notype_declarator\n-\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n+\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE);\n \t\t  goto rest_of_mdef; }\n \t| declmods constructor_declarator\n \t\t{ $$ = parse_method ($2, $1.t, $1.lookups); goto rest_of_mdef;}\n \t| constructor_declarator\n-\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n+\t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE);\n \t\t  goto rest_of_mdef; }\n \t;\n \n@@ -964,20 +964,20 @@ begin_function_body_:\n \n member_init_list:\n \t  /* empty */\n-\t\t{ \n-\t\t  $$.new_type_flag = 0; \n-\t\t  $$.t = NULL_TREE; \n+\t\t{\n+\t\t  $$.new_type_flag = 0;\n+\t\t  $$.t = NULL_TREE;\n \t\t}\n \t| member_init\n-\t\t{ \n-\t\t  $$.new_type_flag = 1; \n-\t\t  $$.t = $1; \n+\t\t{\n+\t\t  $$.new_type_flag = 1;\n+\t\t  $$.t = $1;\n \t\t}\n \t| member_init_list ',' member_init\n-                { \n-\t\t  if ($3) \n+                {\n+\t\t  if ($3)\n \t\t    {\n-\t\t      $$.new_type_flag = 1; \n+\t\t      $$.new_type_flag = 1;\n \t\t      TREE_CHAIN ($3) = $1.t;\n \t\t      $$.t = $3;\n \t\t    }\n@@ -999,7 +999,7 @@ member_init:\n \t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n \t\t  $$ = expand_member_init (current_class_ref,\n-\t\t\t\t\t   NULL_TREE, \n+\t\t\t\t\t   NULL_TREE,\n \t\t\t\t\t   void_type_node);\n \t\t}\n \t| notype_identifier '(' nonnull_exprlist ')'\n@@ -1023,15 +1023,15 @@ member_init:\n \n identifier:\n \t  IDENTIFIER\n-\t| TYPENAME\n+\t| tTYPENAME\n \t| SELFNAME\n \t| PTYPENAME\n \t| NSNAME\n \t;\n \n notype_identifier:\n \t  IDENTIFIER\n-\t| PTYPENAME \n+\t| PTYPENAME\n \t| NSNAME  %prec EMPTY\n \t;\n \n@@ -1060,24 +1060,28 @@ explicit_instantiation:\n \t\t{ do_type_instantiation ($4.t, $1, 1);\n \t\t  yyungetc (';', 1); }\n           end_explicit_instantiation\n-\t| SCSPEC TEMPLATE begin_explicit_instantiation typed_declspecs \n+\t\t{}\n+\t| SCSPEC TEMPLATE begin_explicit_instantiation typed_declspecs\n           declarator\n \t\t{ tree specs = strip_attrs ($4.t);\n \t\t  do_decl_instantiation (specs, $5, $1); }\n           end_explicit_instantiation\n+\t\t{}\n \t| SCSPEC TEMPLATE begin_explicit_instantiation notype_declarator\n \t\t{ do_decl_instantiation (NULL_TREE, $4, $1); }\n           end_explicit_instantiation\n+\t\t{}\n \t| SCSPEC TEMPLATE begin_explicit_instantiation constructor_declarator\n \t\t{ do_decl_instantiation (NULL_TREE, $4, $1); }\n           end_explicit_instantiation\n+\t\t{}\n \t;\n \n-begin_explicit_instantiation: \n+begin_explicit_instantiation:\n       { begin_explicit_instantiation(); }\n         ;\n \n-end_explicit_instantiation: \n+end_explicit_instantiation:\n       { end_explicit_instantiation(); }\n         ;\n \n@@ -1089,7 +1093,7 @@ template_type:\n \t  PTYPENAME '<' template_arg_list_opt template_close_bracket\n \t    finish_template_type_\n                 { $$ = $5; }\n-\t| TYPENAME  '<' template_arg_list_opt template_close_bracket\n+\t| tTYPENAME  '<' template_arg_list_opt template_close_bracket\n \t    finish_template_type_\n                 { $$ = $5; }\n \t| self_template_type\n@@ -1109,18 +1113,18 @@ self_template_type:\n \t;\n \n finish_template_type_:\n-                { \n+                {\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \n-\t\t  $$ = finish_template_type ($<ttype>-3, $<ttype>-1, \n+\t\t  $$ = finish_template_type ($<ttype>-3, $<ttype>-1,\n \t\t\t\t\t     yychar == SCOPE);\n \t\t}\n         ;\n \n template_close_bracket:\n \t  '>'\n-\t| RSHIFT \n+\t| RSHIFT\n \t\t{\n \t\t  /* Handle `Class<Class<Type>>' without space in the `>>' */\n \t\t  pedwarn (\"`>>' should be `> >' in template class name\");\n@@ -1231,11 +1235,11 @@ condition:\n \t\t  $<ttype>$ = parse_decl ($<ttype>2, $4, 1);\n \t\t}\n \t  init\n-\t\t{ \n+\t\t{\n \t\t  parse_end_decl ($<ttype>6, $7, $4);\n-\t\t  $$ = convert_from_reference ($<ttype>6); \n+\t\t  $$ = convert_from_reference ($<ttype>6);\n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n-\t\t    error (\"definition of array `%#D' in condition\", $$); \n+\t\t    error (\"definition of array `%#D' in condition\", $$);\n \t\t}\n \t| expr\n \t;\n@@ -1249,10 +1253,10 @@ compstmtend:\n \n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n-\t\t{ $$ = tree_cons (NULL_TREE, $$, \n+\t\t{ $$ = tree_cons (NULL_TREE, $$,\n \t\t                  build_tree_list (NULL_TREE, $3)); }\n \t| expr_no_commas ',' error\n-\t\t{ $$ = tree_cons (NULL_TREE, $$, \n+\t\t{ $$ = tree_cons (NULL_TREE, $$,\n \t\t                  build_tree_list (NULL_TREE, error_mark_node)); }\n \t| nontrivial_exprlist ',' expr_no_commas\n \t\t{ chainon ($$, build_tree_list (NULL_TREE, $3)); }\n@@ -1292,36 +1296,36 @@ unary_expr:\n \t| ALIGNOF unary_expr  %prec UNARY\n \t\t{ $$ = finish_alignof ($2); }\n \t| ALIGNOF '(' type_id ')'  %prec HYPERUNARY\n-\t\t{ $$ = finish_alignof (groktypename ($3.t)); \n+\t\t{ $$ = finish_alignof (groktypename ($3.t));\n \t\t  check_for_new_type (\"alignof\", $3); }\n \n \t/* The %prec EMPTY's here are required by the = init initializer\n \t   syntax extension; see below.  */\n \t| new new_type_id  %prec EMPTY\n-\t\t{ $$ = build_new (NULL_TREE, $2.t, NULL_TREE, $1); \n+\t\t{ $$ = build_new (NULL_TREE, $2.t, NULL_TREE, $1);\n \t\t  check_for_new_type (\"new\", $2); }\n \t| new new_type_id new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, $2.t, $3, $1); \n+\t\t{ $$ = build_new (NULL_TREE, $2.t, $3, $1);\n \t\t  check_for_new_type (\"new\", $2); }\n \t| new new_placement new_type_id  %prec EMPTY\n-\t\t{ $$ = build_new ($2, $3.t, NULL_TREE, $1); \n+\t\t{ $$ = build_new ($2, $3.t, NULL_TREE, $1);\n \t\t  check_for_new_type (\"new\", $3); }\n \t| new new_placement new_type_id new_initializer\n-\t\t{ $$ = build_new ($2, $3.t, $4, $1); \n+\t\t{ $$ = build_new ($2, $3.t, $4, $1);\n \t\t  check_for_new_type (\"new\", $3); }\n \t| new '(' type_id ')'\n             %prec EMPTY\n \t\t{ $$ = build_new (NULL_TREE, groktypename($3.t),\n-\t\t\t\t  NULL_TREE, $1); \n+\t\t\t\t  NULL_TREE, $1);\n \t\t  check_for_new_type (\"new\", $3); }\n \t| new '(' type_id ')' new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); \n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1);\n \t\t  check_for_new_type (\"new\", $3); }\n \t| new new_placement '(' type_id ')' %prec EMPTY\n-\t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); \n+\t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1);\n \t\t  check_for_new_type (\"new\", $4); }\n \t| new new_placement '(' type_id ')' new_initializer\n-\t\t{ $$ = build_new ($2, groktypename($4.t), $6, $1); \n+\t\t{ $$ = build_new ($2, groktypename($4.t), $6, $1);\n \t\t  check_for_new_type (\"new\", $4); }\n \n \t| delete cast_expr  %prec UNARY\n@@ -1360,7 +1364,7 @@ new_initializer:\n \t\t}\n \t/* GNU extension so people can use initializer lists.  Note that\n \t   this alters the meaning of `new int = 1', which was previously\n-\t   syntactically valid but semantically invalid.  \n+\t   syntactically valid but semantically invalid.\n            This feature is now deprecated and will be removed in a future\n            release.  */\n \t| '=' init\n@@ -1383,7 +1387,7 @@ regcast_or_absdcl:\n \t\t  $$ = make_call_declarator (NULL_TREE, $2.t, NULL_TREE, NULL_TREE);\n \t\t  check_for_new_type (\"cast\", $2); }\n \t| regcast_or_absdcl '(' type_id ')'  %prec EMPTY\n-\t\t{ $3.t = finish_parmlist (build_tree_list (NULL_TREE, $3.t), 0); \n+\t\t{ $3.t = finish_parmlist (build_tree_list (NULL_TREE, $3.t), 0);\n \t\t  $$ = make_call_declarator ($$, $3.t, NULL_TREE, NULL_TREE);\n \t\t  check_for_new_type (\"cast\", $3); }\n \t;\n@@ -1393,9 +1397,9 @@ cast_expr:\n \t| regcast_or_absdcl unary_expr  %prec UNARY\n \t\t{ $$ = reparse_absdcl_as_casts ($$, $2); }\n \t| regcast_or_absdcl '{' initlist maybecomma '}'  %prec UNARY\n-\t\t{ \n+\t\t{\n \t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t\t\t\tnreverse ($3)); \n+\t\t\t\t\tnreverse ($3));\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C++ forbids compound literals\");\n \t\t  /* Indicate that this was a C99 compound literal.  */\n@@ -1539,7 +1543,7 @@ do_id:\n         ;\n \n template_id:\n-          PFUNCNAME '<' do_id template_arg_list_opt template_close_bracket \n+          PFUNCNAME '<' do_id template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($3, $4); }\n         | operator_name '<' do_id template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($3, $4); }\n@@ -1550,14 +1554,14 @@ object_template_id:\n                 { $$ = lookup_template_function ($2, $4); }\n         | TEMPLATE PFUNCNAME '<' template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($2, $4); }\n-        | TEMPLATE operator_name '<' template_arg_list_opt \n+        | TEMPLATE operator_name '<' template_arg_list_opt\n           template_close_bracket\n                 { $$ = lookup_template_function ($2, $4); }\n         ;\n \n unqualified_id:\n \t  notype_unqualified_id\n-\t| TYPENAME\n+\t| tTYPENAME\n \t| SELFNAME\n \t;\n \n@@ -1587,7 +1591,7 @@ notype_template_declarator:\n \t| NSNAME '<' template_arg_list template_close_bracket\n                 { $$ = lookup_template_function ($1, $3); }\n \t;\n-\t\t\n+\n direct_notype_declarator:\n \t  complex_direct_notype_declarator\n \t/* This precedence declaration is to prefer this reduce\n@@ -1603,9 +1607,9 @@ primary:\n \t\t{\n \t\t  if (TREE_CODE ($1) == BIT_NOT_EXPR)\n \t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($1, 0));\n-\t\t  else \n+\t\t  else\n \t\t    $$ = finish_id_expr ($1);\n-\t\t}\t\t\n+\t\t}\n \t| CONSTANT\n \t| boolean_literal\n \t| STRING\n@@ -1639,8 +1643,8 @@ primary:\n \t\t      YYERROR;\n \t\t    }\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ISO C++ forbids braced-groups within expressions\");  \n-\t\t  $<ttype>$ = begin_stmt_expr (); \n+\t\t    pedwarn (\"ISO C++ forbids braced-groups within expressions\");\n+\t\t  $<ttype>$ = begin_stmt_expr ();\n \t\t}\n \t  compstmt_or_stmtexpr ')'\n                { $$ = finish_stmt_expr ($<ttype>2); }\n@@ -1720,8 +1724,8 @@ primary:\n \t| overqualified_id LEFT_RIGHT\n \t\t{ $$ = finish_qualified_call_expr ($1, NULL_TREE); }\n         | object object_template_id %prec UNARY\n-                { \n-\t\t  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); \n+                {\n+\t\t  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1);\n \t\t}\n         | object object_template_id '(' nonnull_exprlist ')'\n                 { $$ = finish_object_call_expr ($2, $1, $4); }\n@@ -1825,7 +1829,7 @@ object:\n \t\t{ got_object = TREE_TYPE ($$); }\n \t| primary POINTSAT\n \t\t{\n-\t\t  $$ = build_x_arrow ($$); \n+\t\t  $$ = build_x_arrow ($$);\n \t\t  got_object = TREE_TYPE ($$);\n \t\t}\n \t;\n@@ -1874,20 +1878,20 @@ fcast_or_absdcl:\n /* ISO type-id (8.1) */\n type_id:\n \t  typed_typespecs absdcl\n-\t\t{ $$.t = build_tree_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers absdcl\n-\t\t{ $$.t = build_tree_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec absdcl\n \t\t{ $$.t = build_tree_list (build_tree_list (NULL_TREE, $1.t),\n-\t\t\t\t\t  $2); \n+\t\t\t\t\t  $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_typespecs  %prec EMPTY\n \t\t{ $$.t = build_tree_list ($1.t, NULL_TREE);\n \t\t  $$.new_type_flag = $1.new_type_flag;  }\n \t| nonempty_cv_qualifiers  %prec EMPTY\n-\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE); \n+\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n \n@@ -1905,23 +1909,23 @@ typed_declspecs:\n \n typed_declspecs1:\n \t  declmods typespec\n-\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, $1.t); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, $1.t);\n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_declspecs  %prec HYPERUNARY\n-\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, $2); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec reserved_typespecquals reserved_declspecs\n-\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, chainon ($2, $3));\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods typespec reserved_declspecs\n-\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t));\n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals\n-\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t));\n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals reserved_declspecs\n \t\t{ $$.t = tree_cons (NULL_TREE, $2.t,\n-\t\t\t\t    chainon ($3, chainon ($4, $1.t))); \n+\t\t\t\t    chainon ($3, chainon ($4, $1.t)));\n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n@@ -1987,16 +1991,16 @@ declmods:\n \n typed_typespecs:\n \t  typespec  %prec EMPTY\n-\t\t{ $$.t = build_tree_list (NULL_TREE, $1.t); \n+\t\t{ $$.t = build_tree_list (NULL_TREE, $1.t);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers typespec\n-\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, $1.t); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, $1.t);\n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_typespecquals\n-\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, $2); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_cv_qualifiers typespec reserved_typespecquals\n-\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t{ $$.t = tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t));\n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n@@ -2119,15 +2123,15 @@ initdcl0_innards:\n \t\t{ $<ttype>$ = parse_decl0 ($<ttype>-1, $<ftype>-2.t,\n \t\t\t\t\t   $<ftype>-2.lookups, $1, 1); }\n           /* Note how the declaration of the variable is in effect\n-\t     while its init is parsed! */ \n+\t     while its init is parsed! */\n \t  init\n \t\t{ parse_end_decl ($<ttype>3, $4, $<ttype>0); }\n \t| maybe_attribute\n \t\t{ tree d = parse_decl0 ($<ttype>-1, $<ftype>-2.t,\n \t\t\t\t\t$<ftype>-2.lookups, $1, 0);\n \t\t  parse_end_decl (d, NULL_TREE, $<ttype>0); }\n   \t;\n-  \n+\n initdcl0:\n \t  declarator maybeasm initdcl0_innards\n                 {}\n@@ -2137,15 +2141,15 @@ notype_initdcl0:\n           notype_declarator maybeasm initdcl0_innards\n                 {}\n         ;\n-  \n+\n nomods_initdcl0:\n           notype_declarator maybeasm\n             { /* Set things up as initdcl0_innards expects.  */\n \t      $<ttype>$ = $2;\n-\t      $2 = $1; \n+\t      $2 = $1;\n               $<ftype>1.t = NULL_TREE;\n \t      $<ftype>1.lookups = NULL_TREE; }\n-          initdcl0_innards \n+          initdcl0_innards\n             {}\n \t| constructor_declarator maybeasm maybe_attribute\n \t\t{ tree d = parse_decl0 ($1, NULL_TREE, NULL_TREE, $3, 0);\n@@ -2160,7 +2164,7 @@ maybe_attribute:\n \t| attributes\n \t\t{ $$ = $1; }\n \t;\n- \n+\n attributes:\n       attribute\n \t\t{ $$ = $1; }\n@@ -2179,7 +2183,7 @@ attribute_list:\n \t| attribute_list ',' attrib\n \t\t{ $$ = chainon ($1, $3); }\n \t;\n- \n+\n attrib:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n@@ -2259,13 +2263,13 @@ pending_inline:\n \t\t  process_next_inline ($1);\n \t\t}\n \t| PRE_PARSED_FUNCTION_DECL maybe_return_init function_try_block\n-\t\t{ \n-\t\t  expand_body (finish_function (2)); \n+\t\t{\n+\t\t  expand_body (finish_function (2));\n                   process_next_inline ($1);\n \t\t}\n \t| PRE_PARSED_FUNCTION_DECL maybe_return_init error\n-\t\t{ \n-\t\t  finish_function (2); \n+\t\t{\n+\t\t  finish_function (2);\n \t\t  process_next_inline ($1); }\n \t;\n \n@@ -2311,14 +2315,14 @@ structsp:\n \t\t  current_enum_type = $<ttype>3;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM identifier\n-\t\t{ $$.t = xref_tag (enum_type_node, $2, 1); \n+\t\t{ $$.t = xref_tag (enum_type_node, $2, 1);\n \t\t  $$.new_type_flag = 0; }\n \t| ENUM complex_type_name\n-\t\t{ $$.t = xref_tag (enum_type_node, $2, 1); \n+\t\t{ $$.t = xref_tag (enum_type_node, $2, 1);\n \t\t  $$.new_type_flag = 0; }\n \t| TYPENAME_KEYWORD typename_sub\n \t\t{ $$.t = $2;\n-\t\t  $$.new_type_flag = 0; \n+\t\t  $$.new_type_flag = 0;\n \t\t  if (!processing_template_decl)\n \t\t    pedwarn (\"using `typename' outside of template\"); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n@@ -2327,7 +2331,7 @@ structsp:\n \t\t  if ($2 && $1.t != error_mark_node)\n \t\t    {\n \t\t      tree type = TREE_TYPE ($1.t);\n-\t\t  \n+\n \t\t      if (TREE_CODE (type) == TYPENAME_TYPE)\n \t\t\t/* In a definition of a member class template,\n                            we will get here with an implicit typename,\n@@ -2336,11 +2340,11 @@ structsp:\n \t\t      maybe_process_partial_specialization (type);\n \t\t      xref_basetypes (current_aggr, $1.t, type, $2);\n \t\t    }\n-\t\t  $1.t = begin_class_definition (TREE_TYPE ($1.t)); \n+\t\t  $1.t = begin_class_definition (TREE_TYPE ($1.t));\n \t\t  check_class_key (current_aggr, $1.t);\n                   current_aggr = NULL_TREE; }\n           opt.component_decl_list '}' maybe_attribute\n-\t\t{ \n+\t\t{\n \t\t  int semi;\n \t\t  tree t;\n \n@@ -2365,7 +2369,7 @@ structsp:\n \t  pending_inlines\n                 {\n \t\t  $$.t = $<ttype>8;\n-\t\t  $$.new_type_flag = 1; \n+\t\t  $$.new_type_flag = 1;\n \t\t}\n \t| class_head_decl\n \t\t{\n@@ -2426,18 +2430,18 @@ class_head:\n \n class_head_apparent_template:\n \t  aggr apparent_template_type\n-\t\t{ \n-\t\t  current_aggr = $1; \n+\t\t{\n+\t\t  current_aggr = $1;\n \t\t  $$ = $2;\n \t\t}\n \t| aggr nested_name_specifier apparent_template_type\n-\t\t{ \n-\t\t  current_aggr = $1; \n+\t\t{\n+\t\t  current_aggr = $1;\n \t\t  $$ = $3;\n \t\t}\n \t| aggr global_scope nested_name_specifier apparent_template_type\n-\t\t{ \n-\t\t  current_aggr = $1; \n+\t\t{\n+\t\t  current_aggr = $1;\n \t\t  $$ = $4;\n \t\t}\n \t;\n@@ -2589,7 +2593,7 @@ base_class_access_list:\n opt.component_decl_list:\n \t| component_decl_list\n \t| opt.component_decl_list access_specifier component_decl_list\n-\t| opt.component_decl_list access_specifier \n+\t| opt.component_decl_list access_specifier\n \t;\n \n access_specifier:\n@@ -2603,13 +2607,13 @@ access_specifier:\n    ARM $9.2 says that the semicolon is optional, and therefore allowed.  */\n component_decl_list:\n \t  component_decl\n-\t\t{ \n+\t\t{\n \t\t  finish_member_declaration ($1);\n \t\t  current_aggr = NULL_TREE;\n \t\t  reset_type_access_control ();\n \t\t}\n \t| component_decl_list component_decl\n-\t\t{ \n+\t\t{\n \t\t  finish_member_declaration ($2);\n \t\t  current_aggr = NULL_TREE;\n \t\t  reset_type_access_control ();\n@@ -2637,7 +2641,7 @@ component_decl:\n \t\t{ $$ = $2;\n \t\t  pedantic = $1; }\n         | template_header component_decl\n-                {  \n+                {\n \t\t  if ($2)\n \t\t    $$ = finish_member_template_decl ($2);\n \t\t  else\n@@ -2647,8 +2651,8 @@ component_decl:\n \t\t  finish_template_decl ($1);\n \t\t}\n \t| template_header typed_declspecs ';'\n-                { \n-\t\t  $$ = finish_member_class_template ($2.t); \n+                {\n+\t\t  $$ = finish_member_class_template ($2.t);\n \t\t  finish_template_decl ($1);\n \t\t}\n \t| bad_decl\n@@ -2681,10 +2685,10 @@ component_decl_1:\n \t\t  $$ = NULL_TREE;\n \t\t}\n \t| declmods notype_components\n-\t\t{ \n+\t\t{\n \t\t  if (!$2)\n \t\t    grok_x_components ($1.t);\n-\t\t  $$ = NULL_TREE; \n+\t\t  $$ = NULL_TREE;\n \t\t}\n \t| notype_declarator maybeasm maybe_attribute maybe_init\n \t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2, $3); }\n@@ -2720,14 +2724,14 @@ components:\n \t  /* empty: possibly anonymous */\n                 { $$ = 0; }\n \t| component_declarator0\n-                { \n+                {\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    $1 = finish_member_template_decl ($1);\n-\t\t  finish_member_declaration ($1); \n+\t\t  finish_member_declaration ($1);\n \t\t  $$ = 1;\n \t\t}\n \t| components ',' component_declarator\n-                { \n+                {\n \t\t  check_multiple_declarators ();\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    $3 = finish_member_template_decl ($3);\n@@ -2740,18 +2744,18 @@ notype_components:\n \t  /* empty: possibly anonymous */\n                 { $$ = 0; }\n \t| notype_component_declarator0\n-                { \n+                {\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    $1 = finish_member_template_decl ($1);\n \t\t  finish_member_declaration ($1);\n \t\t  $$ = 1;\n \t\t}\n \t| notype_components ',' notype_component_declarator\n-                { \n+                {\n \t\t  check_multiple_declarators ();\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    $3 = finish_member_template_decl ($3);\n-\t\t  finish_member_declaration ($3); \n+\t\t  finish_member_declaration ($3);\n \t\t  $$ = 2;\n \t\t}\n \t;\n@@ -2770,7 +2774,7 @@ after_type_component_declarator0:\n \t  after_type_declarator maybeasm maybe_attribute maybe_init\n \t\t{ $$ = parse_field0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n \t\t\t\t     $3, $2, $4); }\n-\t| TYPENAME ':' expr_no_commas maybe_attribute\n+\t| tTYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ $$ = parse_bitfield0 ($1, $<ftype>0.t, $<ftype>0.lookups,\n \t\t\t\t\t$4, $3); }\n \t;\n@@ -2793,7 +2797,7 @@ notype_component_declarator0:\n after_type_component_declarator:\n \t  after_type_declarator maybeasm maybe_attribute maybe_init\n \t\t{ $$ = parse_field ($1, $3, $2, $4); }\n-\t| TYPENAME ':' expr_no_commas maybe_attribute\n+\t| tTYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ $$ = parse_bitfield ($1, $4, $3); }\n \t;\n \n@@ -2830,10 +2834,10 @@ enumerator:\n /* ISO new-type-id (5.3.4) */\n new_type_id:\n \t  type_specifier_seq new_declarator\n-\t\t{ $$.t = build_tree_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| type_specifier_seq  %prec EMPTY\n-\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE); \n+\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t/* GNU extension to allow arrays of arbitrary types with\n \t   non-constant dimension.  */\n@@ -2859,13 +2863,13 @@ nonempty_cv_qualifiers:\n \t\t{ $$.t = hash_tree_cons (NULL_TREE, $1, NULL_TREE);\n \t\t  $$.new_type_flag = 0; }\n \t| nonempty_cv_qualifiers CV_QUALIFIER\n-\t\t{ $$.t = hash_tree_cons (NULL_TREE, $2, $1.t); \n+\t\t{ $$.t = hash_tree_cons (NULL_TREE, $2, $1.t);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| attributes %prec EMPTY\n-\t\t{ $$.t = hash_tree_cons ($1, NULL_TREE, NULL_TREE); \n+\t\t{ $$.t = hash_tree_cons ($1, NULL_TREE, NULL_TREE);\n \t\t  $$.new_type_flag = 0; }\n \t| nonempty_cv_qualifiers attributes %prec EMPTY\n-\t\t{ $$.t = hash_tree_cons ($2, NULL_TREE, $1.t); \n+\t\t{ $$.t = hash_tree_cons ($2, NULL_TREE, $1.t);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n \n@@ -2974,7 +2978,7 @@ notype_declarator_intern:\n \t\t  $$ = tree_cons ($1, $2, NULL_TREE);\n \t\t}\n \t;\n-\t\n+\n notype_declarator:\n \t  '*' nonempty_cv_qualifiers notype_declarator_intern  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n@@ -3022,7 +3026,7 @@ complex_direct_notype_declarator:\n                 { enter_scope_of ($2); $$ = $2;}\n \t| global_scope notype_unqualified_id\n                 { $$ = build_nt (SCOPE_REF, global_namespace, $2);\n-\t\t  enter_scope_of ($$); \n+\t\t  enter_scope_of ($$);\n \t\t}\n         | nested_name_specifier notype_template_declarator\n                 { got_scope = NULL_TREE;\n@@ -3065,7 +3069,7 @@ functional_cast:\n \t;\n \n type_name:\n-\t  TYPENAME\n+\t  tTYPENAME\n \t| SELFNAME\n \t| template_type  %prec EMPTY\n \t;\n@@ -3075,21 +3079,21 @@ nested_name_specifier:\n \t| nested_name_specifier nested_name_specifier_1\n \t\t{ $$ = $2; }\n \t| nested_name_specifier TEMPLATE explicit_template_type SCOPE\n-                { got_scope = $$ \n+                { got_scope = $$\n \t\t    = make_typename_type ($1, $3, tf_error); }\n \t/* Error handling per Core 125.  */\n \t| nested_name_specifier IDENTIFIER SCOPE\n-                { got_scope = $$ \n+                { got_scope = $$\n \t\t    = make_typename_type ($1, $2, tf_error); }\n \t| nested_name_specifier PTYPENAME SCOPE\n-                { got_scope = $$ \n+                { got_scope = $$\n \t\t    = make_typename_type ($1, $2, tf_error); }\n \t;\n \n /* Why the @#$%^& do type_name and notype_identifier need to be expanded\n    inline here?!?  (jason) */\n nested_name_specifier_1:\n-\t  TYPENAME SCOPE\n+\t  tTYPENAME SCOPE\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n \t\t    {\n@@ -3165,17 +3169,17 @@ typename_sub1:\n \t\t    }\n \t\t}\n \t| typename_sub1 explicit_template_type SCOPE\n-                { got_scope = $$ \n+                { got_scope = $$\n \t\t    = make_typename_type ($1, $2, tf_error); }\n \t| typename_sub1 TEMPLATE explicit_template_type SCOPE\n-                { got_scope = $$ \n+                { got_scope = $$\n \t\t    = make_typename_type ($1, $3, tf_error); }\n \t;\n \n /* This needs to return a TYPE_DECL for simple names so that we don't\n    forget what name was used.  */\n typename_sub2:\n-\t  TYPENAME SCOPE\n+\t  tTYPENAME SCOPE\n \t\t{\n \t\t  if (TREE_CODE ($1) != TYPE_DECL)\n \t\t    $$ = lastiddecl;\n@@ -3276,7 +3280,7 @@ absdcl_intern:\n \t\t  $$ = tree_cons ($1, $2, NULL_TREE);\n \t\t}\n \t;\n-\t\n+\n /* ISO abstract-declarator (8.1) */\n absdcl:\n \t  '*' nonempty_cv_qualifiers absdcl_intern\n@@ -3362,7 +3366,7 @@ label_decls:\n \n label_decl:\n \t  LABEL identifiers_or_typenames ';'\n-                { \n+                {\n \t\t  while ($2)\n \t\t    {\n \t\t      finish_label_decl (TREE_VALUE ($2));\n@@ -3374,7 +3378,7 @@ label_decl:\n compstmt_or_stmtexpr:\n \t  save_lineno '{'\n                 { $<ttype>$ = begin_compound_stmt (0); }\n-\t  compstmtend \n+\t  compstmtend\n                 { STMT_LINENO ($<ttype>3) = $1;\n \t\t  finish_compound_stmt (0, $<ttype>3); }\n \t;\n@@ -3397,9 +3401,9 @@ simple_if:\n \n implicitly_scoped_stmt:\n \t  compstmt\n-\t| \n+\t|\n \t\t{ $<ttype>$ = begin_compound_stmt (0); }\n-\t  save_lineno simple_stmt \n+\t  save_lineno simple_stmt\n \t\t{ STMT_LINENO ($<ttype>1) = $2;\n \t\t  if ($3) STMT_LINENO ($3) = $2;\n \t\t  finish_compound_stmt (0, $<ttype>1); }\n@@ -3420,9 +3424,9 @@ simple_stmt:\n \t| simple_if ELSE\n                 { begin_else_clause (); }\n \t  implicitly_scoped_stmt\n-                { \n+                {\n \t\t  $$ = $1;\n-\t\t  finish_else_clause ($1); \n+\t\t  finish_else_clause ($1);\n \t\t  finish_if_stmt ();\n \t\t}\n \t| simple_if  %prec IF\n@@ -3459,7 +3463,7 @@ simple_stmt:\n \t  implicitly_scoped_stmt\n                 { $$ = $<ttype>2;\n \t\t  finish_for_stmt ($<ttype>2); }\n-\t| SWITCH \n+\t| SWITCH\n                 { $<ttype>$ = begin_switch_stmt (); }\n \t    '(' condition ')'\n                 { finish_switch_cond ($4, $<ttype>2); }\n@@ -3510,7 +3514,7 @@ simple_stmt:\n \t  asm_clobbers ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, $6, NULL_TREE, $8); }\n \t| GOTO '*' expr ';'\n-                { \n+                {\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C++ forbids computed gotos\");\n \t\t  $$ = finish_goto_stmt ($3);\n@@ -3601,7 +3605,7 @@ handler_args:\n \t\t  expand_start_catch_block ($2.t, $3); }\n \tThis allows reference parameters...  */\n \t| '(' parm ')'\n-\t\t{ \n+\t\t{\n \t\t  check_for_new_type (\"inside exception declarations\", $2);\n \t\t  $$ = start_handler_parms (TREE_PURPOSE ($2.t),\n \t\t\t\t\t    TREE_VALUE ($2.t));\n@@ -3613,7 +3617,7 @@ label_colon:\n                 { finish_label_stmt ($1); }\n \t| PTYPENAME ':'\n                 { finish_label_stmt ($1); }\n-\t| TYPENAME ':'\n+\t| tTYPENAME ':'\n                 { finish_label_stmt ($1); }\n \t| SELFNAME ':'\n                 { finish_label_stmt ($1); }\n@@ -3704,7 +3708,7 @@ complex_parmlist:\n                 { $$ = finish_parmlist ($1, 1); }\n \t| type_id ELLIPSIS\n                 { $$ = finish_parmlist (build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t $1.t), 1); } \n+\t\t\t\t\t\t\t $1.t), 1); }\n \t| ELLIPSIS\n                 { $$ = finish_parmlist (NULL_TREE, 1); }\n \t| parms ':'\n@@ -3724,7 +3728,7 @@ complex_parmlist:\n \t\t     parenthesis.  */\n \t\t  yyerror (\"possibly missing ')'\");\n \t\t  $$ = finish_parmlist (build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t $1.t), 0); \n+\t\t\t\t\t\t\t $1.t), 0);\n \t\t  yyungetc (':', 0);\n \t\t  yychar = ')';\n \t\t}\n@@ -3776,20 +3780,20 @@ named_parm:\n \t\t{ $$.new_type_flag = $1.new_type_flag;\n \t\t  $$.t = build_tree_list ($1.t, $2); }\n \t| typed_typespecs declarator\n-\t\t{ $$.t = build_tree_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec declarator\n \t\t{ $$.t = build_tree_list (build_tree_list (NULL_TREE, $1.t),\n-\t\t\t\t\t  $2); \n+\t\t\t\t\t  $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_declspecs1 absdcl\n \t\t{ $$.t = build_tree_list ($1.t, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_declspecs1  %prec EMPTY\n-\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE); \n+\t\t{ $$.t = build_tree_list ($1.t, NULL_TREE);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods notype_declarator\n-\t\t{ $$.t = build_tree_list ($1.t, $2); \n+\t\t{ $$.t = build_tree_list ($1.t, $2);\n \t\t  $$.new_type_flag = 0; }\n \t;\n "}, {"sha": "8abf8dcee7b2c537555f53565b6016d6829b4a64", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -86,7 +86,7 @@ struct unparsed_text GTY(())\n   struct token_chunk * tokens; /* Start of the token list.  */\n \n   struct token_chunk *last_chunk; /* End of the token list.  */\n-  short last_pos;\t/* Number of tokens used in the last chunk of \n+  short last_pos;\t/* Number of tokens used in the last chunk of\n \t\t\t   TOKENS. */\n \n   short cur_pos;\t/* Current token in 'cur_chunk', when rescanning.  */\n@@ -126,7 +126,7 @@ static SPEW_INLINE void consume_token PARAMS ((void));\n static SPEW_INLINE int read_process_identifier PARAMS ((YYSTYPE *));\n \n static SPEW_INLINE void feed_input PARAMS ((struct unparsed_text *));\n-static SPEW_INLINE struct token * space_for_token \n+static SPEW_INLINE struct token * space_for_token\n   PARAMS ((struct unparsed_text *t));\n static SPEW_INLINE struct token * remove_last_token\n   PARAMS ((struct unparsed_text *t));\n@@ -161,10 +161,11 @@ static enum cpp_ttype last_token;\n static tree last_token_id;\n \n /* From lex.c: */\n-/* the declaration found for the last IDENTIFIER token read in.\n-   yylex must look this up to detect typedefs, which get token type TYPENAME,\n-   so it is left around in case the identifier is not a typedef but is\n-   used in a context which makes it a reference to a variable.  */\n+/* the declaration found for the last IDENTIFIER token read in.  yylex\n+   must look this up to detect typedefs, which get token type\n+   tTYPENAME, so it is left around in case the identifier is not a\n+   typedef but is used in a context which makes it a reference to a\n+   variable.  */\n extern tree lastiddecl;\t\t/* let our brains leak out here too */\n extern int\tyychar;\t\t/*  the lookahead symbol\t\t*/\n extern YYSTYPE\tyylval;\t\t/*  the semantic value of the\t\t*/\n@@ -178,7 +179,7 @@ static int first_token;\n    through and parse all of them using do_pending_defargs.  Since yacc\n    parsers are not reentrant, we retain defargs state in these two\n    variables so that subsequent calls to do_pending_defargs can resume\n-   where the previous call left off. DEFARG_FNS is a tree_list where \n+   where the previous call left off. DEFARG_FNS is a tree_list where\n    the TREE_TYPE is the current_class_type, TREE_VALUE is the FUNCTION_DECL,\n    and TREE_PURPOSE is the list unprocessed dependent functions.  */\n \n@@ -359,7 +360,7 @@ read_token (t)\n     case CPP_EOF:\n       t->yychar = 0;\n       break;\n-      \n+\n     case CPP_NAME:\n       t->yychar = read_process_identifier (&t->yylval);\n       break;\n@@ -486,12 +487,12 @@ next_token (t)\n \t  feed->input->cur_chunk = feed->input->cur_chunk->next;\n \t  feed->input->cur_pos = 0;\n \t}\n-      memcpy (t, feed->input->cur_chunk->toks + feed->input->cur_pos, \n+      memcpy (t, feed->input->cur_chunk->toks + feed->input->cur_pos,\n \t      sizeof (struct token));\n       feed->input->cur_pos++;\n       return t->yychar;\n     }\n-  \n+\n   memcpy (t, &Teosi, sizeof (struct token));\n   return END_OF_SAVED_INPUT;\n }\n@@ -579,7 +580,7 @@ scan_tokens (n)\n \tgoto pad_tokens;\n     }\n   return;\n-  \n+\n  pad_tokens:\n   while (num_tokens () <= n)\n     obstack_grow (&token_obstack, &Tpad, sizeof (struct token));\n@@ -605,7 +606,7 @@ identifier_type (decl)\n     {\n       if (TREE_CODE (DECL_TEMPLATE_RESULT (decl)) == TYPE_DECL)\n \treturn PTYPENAME;\n-      else if (looking_for_template) \n+      else if (looking_for_template)\n \treturn PFUNCNAME;\n     }\n   if (looking_for_template && really_overloaded_fn (decl))\n@@ -615,7 +616,7 @@ identifier_type (decl)\n \tdecl = TREE_VALUE (decl);\n \n       for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n-\tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t))) \n+\tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t)))\n \t  return PFUNCNAME;\n     }\n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n@@ -636,11 +637,11 @@ identifier_type (decl)\n   if (t && t == decl)\n     return SELFNAME;\n \n-  return TYPENAME;\n+  return tTYPENAME;\n }\n \n /* token[0] == AGGR (struct/union/enum)\n-   Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n+   Thus, token[1] is either a tTYPENAME or a TYPENAME_DEFN.\n    If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n    It's also a definition if it's a forward declaration (as in 'struct Foo;')\n    which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */\n@@ -649,10 +650,10 @@ static SPEW_INLINE void\n do_aggr ()\n {\n   int yc1, yc2;\n-  \n+\n   scan_tokens (2);\n   yc1 = nth_token (1)->yychar;\n-  if (yc1 != TYPENAME && yc1 != IDENTIFIER && yc1 != PTYPENAME)\n+  if (yc1 != tTYPENAME && yc1 != IDENTIFIER && yc1 != PTYPENAME)\n     return;\n   yc2 = nth_token (2)->yychar;\n   if (yc2 == ';')\n@@ -667,7 +668,7 @@ do_aggr ()\n \n   switch (yc1)\n     {\n-    case TYPENAME:\n+    case tTYPENAME:\n       nth_token (1)->yychar = TYPENAME_DEFN;\n       break;\n     case PTYPENAME:\n@@ -679,7 +680,7 @@ do_aggr ()\n     default:\n       abort ();\n     }\n-}  \n+}\n \n void\n see_typename ()\n@@ -739,7 +740,7 @@ yylex ()\n     {\n     case EMPTY:\n       /* This is a lexical no-op.  */\n-#ifdef SPEW_DEBUG    \n+#ifdef SPEW_DEBUG\n       if (spew_debug)\n \tdebug_yychar (yychr);\n #endif\n@@ -758,14 +759,14 @@ yylex ()\n     case IDENTIFIER:\n     {\n       int peek;\n-      \n+\n       scan_tokens (1);\n       peek = nth_token (1)->yychar;\n       yychr = frob_id (yychr, peek, &nth_token (0)->yylval.ttype);\n       break;\n     }\n     case IDENTIFIER_DEFN:\n-    case TYPENAME:\n+    case tTYPENAME:\n     case TYPENAME_DEFN:\n     case PTYPENAME:\n     case PTYPENAME_DEFN:\n@@ -831,13 +832,13 @@ yylex ()\n   yychar = yychr;\n   {\n     struct token *tok = nth_token (0);\n-    \n+\n     yylval = tok->yylval;\n     if (tok->lineno)\n       lineno = tok->lineno;\n   }\n \n-#ifdef SPEW_DEBUG    \n+#ifdef SPEW_DEBUG\n   if (spew_debug)\n     debug_yychar (yychr);\n #endif\n@@ -883,7 +884,7 @@ frob_id (yyc, peek, idp)\n {\n   tree trrr;\n   int old_looking_for_typename = 0;\n-  \n+\n   if (peek == SCOPE)\n     {\n       /* Don't interfere with the setting from an 'aggr' prefix.  */\n@@ -898,7 +899,7 @@ frob_id (yyc, peek, idp)\n       yyc = identifier_type (trrr);\n       switch(yyc)\n         {\n-          case TYPENAME:\n+          case tTYPENAME:\n           case SELFNAME:\n           case NSNAME:\n           case PTYPENAME:\n@@ -1042,7 +1043,7 @@ space_for_token (t)\n   t->last_chunk->next = ggc_alloc (sizeof (*t->last_chunk->next));\n   t->last_chunk = t->last_chunk->next;\n   t->last_chunk->next = NULL;\n-  \n+\n   t->last_pos = 1;\n   return t->last_chunk->toks;\n }\n@@ -1134,7 +1135,7 @@ snarf_block (t)\n \t    {\n \t      if (!look_for_catch)\n \t\tbreak;\n-\t      \n+\n \t      if (next_token (space_for_token (t)) != CATCH)\n \t\t{\n \t\t  push_token (remove_last_token (t));\n@@ -1149,7 +1150,7 @@ snarf_block (t)\n \t  if (look_for_lbrac)\n \t    {\n \t      struct token *fake;\n-\t      \n+\n \t      error (\"function body for constructor missing\");\n \t      /* fake a { } to avoid further errors */\n \t      fake = space_for_token (t);\n@@ -1183,7 +1184,7 @@ snarf_method (decl)\n   struct unparsed_text *meth;\n \n   meth = alloc_unparsed_text (starting_filename, starting_lineno, decl,\n-\t\t\t      (interface_unknown ? 1 \n+\t\t\t      (interface_unknown ? 1\n \t\t\t       : (interface_only ? 0 : 2)));\n \n   snarf_block (meth);\n@@ -1284,7 +1285,7 @@ add_defarg_fn (decl)\n     TREE_VALUE (defarg_fns) = decl;\n   else\n     {\n-      defarg_fns = tree_cons (NULL_TREE, decl, defarg_fns);  \n+      defarg_fns = tree_cons (NULL_TREE, decl, defarg_fns);\n       TREE_TYPE (defarg_fns) = current_class_type;\n     }\n }\n@@ -1313,7 +1314,7 @@ finish_defarg ()\n     error (\"parse error at end of saved function text\");\n \n   end_input ();\n-}  \n+}\n \n /* Main function for deferred parsing of default arguments.  Called from\n    the parser.  */\n@@ -1327,7 +1328,7 @@ do_pending_defargs ()\n   for (; defarg_fns;)\n     {\n       tree current = defarg_fns;\n-      \n+\n       tree defarg_fn = TREE_VALUE (defarg_fns);\n       if (defarg_parm == NULL_TREE)\n \t{\n@@ -1367,16 +1368,16 @@ do_pending_defargs ()\n \n       poplevel (0, 0, 0);\n       pop_nested_class ();\n-      \n+\n       defarg_fns = TREE_CHAIN (defarg_fns);\n       if (defarg_depfns)\n         {\n           /* This function's default args depend on unprocessed default args\n              of defarg_fns. We will need to reprocess this function, and\n              check for circular dependencies.  */\n           tree a, b;\n-          \n-          for (a = defarg_depfns, b = TREE_PURPOSE (current); a && b; \n+\n+          for (a = defarg_depfns, b = TREE_PURPOSE (current); a && b;\n                a = TREE_CHAIN (a), b = TREE_CHAIN (b))\n             if (TREE_VALUE (a) != TREE_VALUE (b))\n               goto different;\n@@ -1392,7 +1393,7 @@ do_pending_defargs ()\n               cp_warning_at (\"circular dependency in default args of `%#D'\", defarg_fn);\n               /* No need to say what else is dependent, as they will be\n                  picked up in another pass.  */\n-              \n+\n               /* Immediately repeat, but marked so that we break the loop. */\n               defarg_fns = current;\n               TREE_PURPOSE (current) = error_mark_node;\n@@ -1413,7 +1414,7 @@ done_pending_defargs ()\n     {\n       tree fn = TREE_VALUE (defarg_fnsdone);\n       tree parms;\n-      \n+\n       if (TREE_CODE (fn) == FUNCTION_DECL)\n         parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n       else\n@@ -1460,7 +1461,7 @@ replace_defarg (arg, init)\n     }\n }\n \n-#ifdef SPEW_DEBUG    \n+#ifdef SPEW_DEBUG\n /* debug_yychar takes a yychar (token number) value and prints its name.  */\n \n static void\n@@ -1469,7 +1470,7 @@ debug_yychar (yy)\n {\n   if (yy<256)\n     fprintf (stderr, \"->%d < %c >\\n\", lineno, yy);\n-  else if (yy == IDENTIFIER || yy == TYPENAME)\n+  else if (yy == IDENTIFIER || yy == tTYPENAME)\n     {\n       const char *id;\n       if (TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)"}, {"sha": "3ff92d345ef82abf9a2a37485430405130b56401", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d901be21286abad53306a8e883571ca9258676/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d901be21286abad53306a8e883571ca9258676/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=84d901be21286abad53306a8e883571ca9258676", "patch": "@@ -73,13 +73,15 @@ typedef_struct: ENT_TYPEDEF_STRUCT options '{' struct_fields '}' ID\n \t\t     lexer_toplevel_done = 1;\n \t\t   }\n \t\t ';'\n+\t\t   {}\n \t\t| ENT_STRUCT options '{' struct_fields '}'\n \t\t   {\n \t\t     new_structure ($1->u.s.tag, UNION_P ($1), &lexer_line,\n \t\t\t\t    $4, $2);\n \t\t     lexer_toplevel_done = 1;\n \t\t   }\n \t\t ';'\n+\t\t   {}\n \t\t;\n \n externstatic: ENT_EXTERNSTATIC options lasttype ID semiequal"}]}