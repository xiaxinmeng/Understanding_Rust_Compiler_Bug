{"sha": "5322d07e9c687b4340c4043a11518973e2d6ed9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMyMmQwN2U5YzY4N2I0MzQwYzQwNDNhMTE1MTg5NzNlMmQ2ZWQ5Zg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2012-07-27T21:01:16Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2012-07-27T21:01:16Z"}, "message": "expmed.h (alg_hash, [...]): Delete macro definitions and re-purpose as inline functions.\n\n\t* expmed.h (alg_hash, alg_hash_used_p, sdiv_pow2_cheap,\n\tsmod_pow2_cheap, zero_cost, add_cost, neg_cost, shift_cost)\n\tshiftadd_cost, shiftsub0_cost, shiftsub1_cost, mul_cost,\n\tsdiv_cost, udiv_cost, mul_widen_cost, mul_highpart_cost): Delete\n\tmacro definitions and re-purpose as inline functions.\n\t(alg_hash_entry_ptr, set_alg_hash_used_p, sdiv_pow2_cheap_ptr,\n\tset_sdiv_pow2_cheap, smod_pow2_cheap_ptr, set_smod_pow2_cheap,\n\tzero_cost_ptr, set_zero_cost, add_cost_ptr, set_add_cost,\n\tneg_cost_ptr, set_neg_cost, shift_cost_ptr, set_shift_cost,\n\tshiftadd_cost_ptr, set_shiftadd_cost, shiftsub0_cost_ptr,\n\tset_shiftsub0_cost, shiftsub1_cost_ptr, set_shiftsub1_cost,\n\tmul_cost_ptr, set_mul_cost, sdiv_cost_ptr, set_sdiv_cost,\n\tudiv_cost_ptr, set_udiv_cost, mul_widen_cost_ptr,\n\tset_mul_widen_cost, mul_highpart_cost_ptr, set_mul_highpart_cost):\n\tNew functions.\n\t(convert_cost_ptr): New function, split out from...\n\t(set_convert_cost, convert_cost): ...here.\n\t* expmed.c, tree-ssa-loop-ivopts.c: Update for new functions.\n\t* gimple-ssa-strength-reduction.c: Likewise.\n\nFrom-SVN: r189919", "tree": {"sha": "e8b3b1b9c2c77f0a8c479de66cf8c543700e8f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8b3b1b9c2c77f0a8c479de66cf8c543700e8f44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5322d07e9c687b4340c4043a11518973e2d6ed9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5322d07e9c687b4340c4043a11518973e2d6ed9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5322d07e9c687b4340c4043a11518973e2d6ed9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5322d07e9c687b4340c4043a11518973e2d6ed9f/comments", "author": null, "committer": null, "parents": [{"sha": "ccbc132f872fbe614066238abd97301248f3d5f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccbc132f872fbe614066238abd97301248f3d5f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccbc132f872fbe614066238abd97301248f3d5f8"}], "stats": {"total": 725, "additions": 556, "deletions": 169}, "files": [{"sha": "bbff917e356917be1e502088b655a6f15e305987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5322d07e9c687b4340c4043a11518973e2d6ed9f", "patch": "@@ -1,3 +1,25 @@\n+2012-07-27  Nathan Froyd  <froydnj@gcc.gnu.org>\n+\n+\t* expmed.h (alg_hash, alg_hash_used_p, sdiv_pow2_cheap,\n+\tsmod_pow2_cheap, zero_cost, add_cost, neg_cost, shift_cost)\n+\tshiftadd_cost, shiftsub0_cost, shiftsub1_cost, mul_cost,\n+\tsdiv_cost, udiv_cost, mul_widen_cost, mul_highpart_cost): Delete\n+\tmacro definitions and re-purpose as inline functions.\n+\t(alg_hash_entry_ptr, set_alg_hash_used_p, sdiv_pow2_cheap_ptr,\n+\tset_sdiv_pow2_cheap, smod_pow2_cheap_ptr, set_smod_pow2_cheap,\n+\tzero_cost_ptr, set_zero_cost, add_cost_ptr, set_add_cost,\n+\tneg_cost_ptr, set_neg_cost, shift_cost_ptr, set_shift_cost,\n+\tshiftadd_cost_ptr, set_shiftadd_cost, shiftsub0_cost_ptr,\n+\tset_shiftsub0_cost, shiftsub1_cost_ptr, set_shiftsub1_cost,\n+\tmul_cost_ptr, set_mul_cost, sdiv_cost_ptr, set_sdiv_cost,\n+\tudiv_cost_ptr, set_udiv_cost, mul_widen_cost_ptr,\n+\tset_mul_widen_cost, mul_highpart_cost_ptr, set_mul_highpart_cost):\n+\tNew functions.\n+\t(convert_cost_ptr): New function, split out from...\n+\t(set_convert_cost, convert_cost): ...here.\n+\t* expmed.c, tree-ssa-loop-ivopts.c: Update for new functions.\n+\t* gimple-ssa-strength-reduction.c: Likewise.\n+\n 2012-07-20  Ryan Mansfield  <rmansfield@qnx.com>\n \n \t* gcc.c (main): Move GCC_DRIVER_HOST_INITIALIZATION after\n@@ -6,7 +28,7 @@\n 2012-07-27  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54089\n-\t* config/sh/sh.c (shiftcosts): Remove case where first operand \n+\t* config/sh/sh.c (shiftcosts): Remove case where first operand\n \tis a const_int.  Move COSTS_N_INSNS usage into caller ...\n \t(sh_rtx_costs) ... here.  Return false when shiftcosts cannot be\n \tcalculated instead of MAX_COST."}, {"sha": "9743fc05ee788246b61892fd72b8a1dd1382e933", "filename": "gcc/expmed.c", "status": "modified", "additions": 123, "deletions": 107, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5322d07e9c687b4340c4043a11518973e2d6ed9f", "patch": "@@ -143,31 +143,35 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n   PUT_MODE (&all->shift_sub1, mode);\n   PUT_MODE (&all->convert, mode);\n \n-  add_cost[speed][mode] = set_src_cost (&all->plus, speed);\n-  neg_cost[speed][mode] = set_src_cost (&all->neg, speed);\n-  mul_cost[speed][mode] = set_src_cost (&all->mult, speed);\n-  sdiv_cost[speed][mode] = set_src_cost (&all->sdiv, speed);\n-  udiv_cost[speed][mode] = set_src_cost (&all->udiv, speed);\n-\n-  sdiv_pow2_cheap[speed][mode] = (set_src_cost (&all->sdiv_32, speed)\n-\t\t\t          <= 2 * add_cost[speed][mode]);\n-  smod_pow2_cheap[speed][mode] = (set_src_cost (&all->smod_32, speed)\n-\t\t\t          <= 4 * add_cost[speed][mode]);\n-\n-  shift_cost[speed][mode][0] = 0;\n-  shiftadd_cost[speed][mode][0] = shiftsub0_cost[speed][mode][0]\n-    = shiftsub1_cost[speed][mode][0] = add_cost[speed][mode];\n+  set_add_cost (speed, mode, set_src_cost (&all->plus, speed));\n+  set_neg_cost (speed, mode, set_src_cost (&all->neg, speed));\n+  set_mul_cost (speed, mode, set_src_cost (&all->mult, speed));\n+  set_sdiv_cost (speed, mode, set_src_cost (&all->sdiv, speed));\n+  set_udiv_cost (speed, mode, set_src_cost (&all->udiv, speed));\n+\n+  set_sdiv_pow2_cheap (speed, mode, (set_src_cost (&all->sdiv_32, speed)\n+\t\t\t\t     <= 2 * add_cost (speed, mode)));\n+  set_smod_pow2_cheap (speed, mode, (set_src_cost (&all->smod_32, speed)\n+\t\t\t\t     <= 4 * add_cost (speed, mode)));\n+\n+  set_shift_cost (speed, mode, 0, 0);\n+  {\n+    int cost = add_cost (speed, mode);\n+    set_shiftadd_cost (speed, mode, 0, cost);\n+    set_shiftsub0_cost (speed, mode, 0, cost);\n+    set_shiftsub1_cost (speed, mode, 0, cost);\n+  }\n \n   n = MIN (MAX_BITS_PER_WORD, mode_bitsize);\n   for (m = 1; m < n; m++)\n     {\n       XEXP (&all->shift, 1) = all->cint[m];\n       XEXP (&all->shift_mult, 1) = all->pow2[m];\n \n-      shift_cost[speed][mode][m] = set_src_cost (&all->shift, speed);\n-      shiftadd_cost[speed][mode][m] = set_src_cost (&all->shift_add, speed);\n-      shiftsub0_cost[speed][mode][m] = set_src_cost (&all->shift_sub0, speed);\n-      shiftsub1_cost[speed][mode][m] = set_src_cost (&all->shift_sub1, speed);\n+      set_shift_cost (speed, mode, m, set_src_cost (&all->shift, speed));\n+      set_shiftadd_cost (speed, mode, m, set_src_cost (&all->shift_add, speed));\n+      set_shiftsub0_cost (speed, mode, m, set_src_cost (&all->shift_sub0, speed));\n+      set_shiftsub1_cost (speed, mode, m, set_src_cost (&all->shift_sub1, speed));\n     }\n \n   if (SCALAR_INT_MODE_P (mode))\n@@ -181,10 +185,8 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n \t  PUT_MODE (&all->wide_lshr, wider_mode);\n \t  XEXP (&all->wide_lshr, 1) = GEN_INT (mode_bitsize);\n \n-\t  mul_widen_cost[speed][wider_mode]\n-\t    = set_src_cost (&all->wide_mult, speed);\n-\t  mul_highpart_cost[speed][mode]\n-\t    = set_src_cost (&all->wide_trunc, speed);\n+\t  set_mul_widen_cost (speed, wider_mode, set_src_cost (&all->wide_mult, speed));\n+\t  set_mul_highpart_cost (speed, mode, set_src_cost (&all->wide_trunc, speed));\n \t}\n \n       for (mode_from = GET_CLASS_NARROWEST_MODE (MODE_INT);\n@@ -295,7 +297,7 @@ init_expmed (void)\n   for (speed = 0; speed < 2; speed++)\n     {\n       crtl->maybe_hot_insn_p = speed;\n-      zero_cost[speed] = set_src_cost (const0_rtx, speed);\n+      set_zero_cost (speed, set_src_cost (const0_rtx, speed));\n \n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   mode != VOIDmode;\n@@ -308,10 +310,13 @@ init_expmed (void)\n \tinit_expmed_one_mode (&all, mode, speed);\n     }\n \n-  if (alg_hash_used_p)\n-    memset (alg_hash, 0, sizeof (alg_hash));\n+  if (alg_hash_used_p ())\n+    {\n+      struct alg_hash_entry *p = alg_hash_entry_ptr (0);\n+      memset (p, 0, sizeof (*p) * NUM_ALG_HASH_ENTRIES);\n+    }\n   else\n-    alg_hash_used_p = true;\n+    set_alg_hash_used_p (true);\n   default_rtl_profile ();\n }\n \n@@ -2259,8 +2264,9 @@ expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n       && INTVAL (op1) > 0\n       && INTVAL (op1) < GET_MODE_PRECISION (mode)\n       && INTVAL (op1) < MAX_BITS_PER_WORD\n-      && shift_cost[speed][mode][INTVAL (op1)] > INTVAL (op1) * add_cost[speed][mode]\n-      && shift_cost[speed][mode][INTVAL (op1)] != MAX_COST)\n+      && (shift_cost (speed, mode, INTVAL (op1))\n+\t  > INTVAL (op1) * add_cost (speed, mode))\n+      && shift_cost (speed, mode, INTVAL (op1)) != MAX_COST)\n     {\n       int i;\n       for (i = 0; i < INTVAL (op1); i++)\n@@ -2436,6 +2442,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   enum alg_code cache_alg = alg_zero;\n   bool speed = optimize_insn_for_speed_p ();\n   enum machine_mode imode;\n+  struct alg_hash_entry *entry_ptr;\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n@@ -2470,13 +2477,13 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n      fail now.  */\n   if (t == 0)\n     {\n-      if (MULT_COST_LESS (cost_limit, zero_cost[speed]))\n+      if (MULT_COST_LESS (cost_limit, zero_cost (speed)))\n \treturn;\n       else\n \t{\n \t  alg_out->ops = 1;\n-\t  alg_out->cost.cost = zero_cost[speed];\n-\t  alg_out->cost.latency = zero_cost[speed];\n+\t  alg_out->cost.cost = zero_cost (speed);\n+\t  alg_out->cost.latency = zero_cost (speed);\n \t  alg_out->op[0] = alg_zero;\n \t  return;\n \t}\n@@ -2492,19 +2499,20 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   hash_index = (t ^ (unsigned int) mode ^ (speed * 256)) % NUM_ALG_HASH_ENTRIES;\n \n   /* See if we already know what to do for T.  */\n-  if (alg_hash[hash_index].t == t\n-      && alg_hash[hash_index].mode == mode\n-      && alg_hash[hash_index].mode == mode\n-      && alg_hash[hash_index].speed == speed\n-      && alg_hash[hash_index].alg != alg_unknown)\n+  entry_ptr = alg_hash_entry_ptr (hash_index);\n+  if (entry_ptr->t == t\n+      && entry_ptr->mode == mode\n+      && entry_ptr->mode == mode\n+      && entry_ptr->speed == speed\n+      && entry_ptr->alg != alg_unknown)\n     {\n-      cache_alg = alg_hash[hash_index].alg;\n+      cache_alg = entry_ptr->alg;\n \n       if (cache_alg == alg_impossible)\n \t{\n \t  /* The cache tells us that it's impossible to synthesize\n-\t     multiplication by T within alg_hash[hash_index].cost.  */\n-\t  if (!CHEAPER_MULT_COST (&alg_hash[hash_index].cost, cost_limit))\n+\t     multiplication by T within entry_ptr->cost.  */\n+\t  if (!CHEAPER_MULT_COST (&entry_ptr->cost, cost_limit))\n \t    /* COST_LIMIT is at least as restrictive as the one\n \t       recorded in the hash table, in which case we have no\n \t       hope of synthesizing a multiplication.  Just\n@@ -2518,7 +2526,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t}\n       else\n \t{\n-\t  if (CHEAPER_MULT_COST (cost_limit, &alg_hash[hash_index].cost))\n+\t  if (CHEAPER_MULT_COST (cost_limit, &entry_ptr->cost))\n \t    /* The cached algorithm shows that this multiplication\n \t       requires more cost than COST_LIMIT.  Just return.  This\n \t       way, we don't clobber this cache entry with\n@@ -2564,10 +2572,10 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  q = t >> m;\n \t  /* The function expand_shift will choose between a shift and\n \t     a sequence of additions, so the observed cost is given as\n-\t     MIN (m * add_cost[speed][mode], shift_cost[speed][mode][m]).  */\n-\t  op_cost = m * add_cost[speed][mode];\n-\t  if (shift_cost[speed][mode][m] < op_cost)\n-\t    op_cost = shift_cost[speed][mode][m];\n+\t     MIN (m * add_cost(speed, mode), shift_cost(speed, mode, m)).  */\n+\t  op_cost = m * add_cost (speed, mode);\n+\t  if (shift_cost (speed, mode, m) < op_cost)\n+\t    op_cost = shift_cost (speed, mode, m);\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, q, &new_limit, mode);\n@@ -2594,11 +2602,11 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      q = ~(~orig_t >> m);\n \t      /* The function expand_shift will choose between a shift\n \t\t and a sequence of additions, so the observed cost is\n-\t\t given as MIN (m * add_cost[speed][mode],\n-\t\t shift_cost[speed][mode][m]).  */\n-\t      op_cost = m * add_cost[speed][mode];\n-\t      if (shift_cost[speed][mode][m] < op_cost)\n-\t\top_cost = shift_cost[speed][mode][m];\n+\t\t given as MIN (m * add_cost(speed, mode),\n+\t\t shift_cost(speed, mode, m)).  */\n+\t      op_cost = m * add_cost (speed, mode);\n+\t      if (shift_cost (speed, mode, m) < op_cost)\n+\t\top_cost = shift_cost (speed, mode, m);\n \t      new_limit.cost = best_cost.cost - op_cost;\n \t      new_limit.latency = best_cost.latency - op_cost;\n \t      synth_mult (alg_in, q, &new_limit, mode);\n@@ -2640,7 +2648,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n \n-\t  op_cost = add_cost[speed][mode];\n+\t  op_cost = add_cost (speed, mode);\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, t + 1, &new_limit, mode);\n@@ -2660,7 +2668,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n \n-\t  op_cost = add_cost[speed][mode];\n+\t  op_cost = add_cost (speed, mode);\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, t - 1, &new_limit, mode);\n@@ -2682,7 +2690,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (-orig_t + 1);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  op_cost = shiftsub1_cost[speed][mode][m];\n+\t  op_cost = shiftsub1_cost (speed, mode, m);\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m,\n@@ -2729,14 +2737,14 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t     equal to its cost, otherwise assume that on superscalar\n \t     hardware the shift may be executed concurrently with the\n \t     earlier steps in the algorithm.  */\n-\t  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];\n-\t  if (shiftadd_cost[speed][mode][m] < op_cost)\n+\t  op_cost = add_cost (speed, mode) + shift_cost (speed, mode, m);\n+\t  if (shiftadd_cost (speed, mode, m) < op_cost)\n \t    {\n-\t      op_cost = shiftadd_cost[speed][mode][m];\n+\t      op_cost = shiftadd_cost (speed, mode, m);\n \t      op_latency = op_cost;\n \t    }\n \t  else\n-\t    op_latency = add_cost[speed][mode];\n+\t    op_latency = add_cost (speed, mode);\n \n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_latency;\n@@ -2768,14 +2776,14 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t     equal to it's cost, otherwise assume that on superscalar\n \t     hardware the shift may be executed concurrently with the\n \t     earlier steps in the algorithm.  */\n-\t  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];\n-\t  if (shiftsub0_cost[speed][mode][m] < op_cost)\n+\t  op_cost = add_cost (speed, mode) + shift_cost (speed, mode, m);\n+\t  if (shiftsub0_cost (speed, mode, m) < op_cost)\n \t    {\n-\t      op_cost = shiftsub0_cost[speed][mode][m];\n+\t      op_cost = shiftsub0_cost (speed, mode, m);\n \t      op_latency = op_cost;\n \t    }\n \t  else\n-\t    op_latency = add_cost[speed][mode];\n+\t    op_latency = add_cost (speed, mode);\n \n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_latency;\n@@ -2809,7 +2817,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  op_cost = shiftadd_cost[speed][mode][m];\n+\t  op_cost = shiftadd_cost (speed, mode, m);\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, (t - 1) >> m, &new_limit, mode);\n@@ -2834,7 +2842,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  op_cost = shiftsub0_cost[speed][mode][m];\n+\t  op_cost = shiftsub0_cost (speed, mode, m);\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, (t + 1) >> m, &new_limit, mode);\n@@ -2863,23 +2871,23 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t we are asked to find an algorithm for T within the same or\n \t lower COST_LIMIT, we can immediately return to the\n \t caller.  */\n-      alg_hash[hash_index].t = t;\n-      alg_hash[hash_index].mode = mode;\n-      alg_hash[hash_index].speed = speed;\n-      alg_hash[hash_index].alg = alg_impossible;\n-      alg_hash[hash_index].cost = *cost_limit;\n+      entry_ptr->t = t;\n+      entry_ptr->mode = mode;\n+      entry_ptr->speed = speed;\n+      entry_ptr->alg = alg_impossible;\n+      entry_ptr->cost = *cost_limit;\n       return;\n     }\n \n   /* Cache the result.  */\n   if (!cache_hit)\n     {\n-      alg_hash[hash_index].t = t;\n-      alg_hash[hash_index].mode = mode;\n-      alg_hash[hash_index].speed = speed;\n-      alg_hash[hash_index].alg = best_alg->op[best_alg->ops];\n-      alg_hash[hash_index].cost.cost = best_cost.cost;\n-      alg_hash[hash_index].cost.latency = best_cost.latency;\n+      entry_ptr->t = t;\n+      entry_ptr->mode = mode;\n+      entry_ptr->speed = speed;\n+      entry_ptr->alg = best_alg->op[best_alg->ops];\n+      entry_ptr->cost.cost = best_cost.cost;\n+      entry_ptr->cost.latency = best_cost.latency;\n     }\n \n   /* If we are getting a too long sequence for `struct algorithm'\n@@ -2925,7 +2933,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n   /* Ensure that mult_cost provides a reasonable upper bound.\n      Any constant multiplication can be performed with less\n      than 2 * bits additions.  */\n-  op_cost = 2 * GET_MODE_UNIT_BITSIZE (mode) * add_cost[speed][mode];\n+  op_cost = 2 * GET_MODE_UNIT_BITSIZE (mode) * add_cost (speed, mode);\n   if (mult_cost > op_cost)\n     mult_cost = op_cost;\n \n@@ -2938,7 +2946,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n      `unsigned int' */\n   if (HOST_BITS_PER_INT >= GET_MODE_UNIT_BITSIZE (mode))\n     {\n-      op_cost = neg_cost[speed][mode];\n+      op_cost = neg_cost(speed, mode);\n       if (MULT_COST_LESS (&alg->cost, mult_cost))\n \t{\n \t  limit.cost = alg->cost.cost - op_cost;\n@@ -2958,7 +2966,7 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n     }\n \n   /* This proves very useful for division-by-constant.  */\n-  op_cost = add_cost[speed][mode];\n+  op_cost = add_cost (speed, mode);\n   if (MULT_COST_LESS (&alg->cost, mult_cost))\n     {\n       limit.cost = alg->cost.cost - op_cost;\n@@ -3249,7 +3257,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t     Exclude cost of op0 from max_cost to match the cost\n \t     calculation of the synth_mult.  */\n \t  max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed)\n-\t\t      - neg_cost[speed][mode]);\n+\t\t      - neg_cost(speed, mode));\n \t  if (max_cost > 0\n \t      && choose_mult_variant (mode, -coeff, &algorithm,\n \t\t\t\t      &variant, max_cost))\n@@ -3350,7 +3358,7 @@ expand_widening_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \n       /* Exclude cost of op0 from max_cost to match the cost\n \t calculation of the synth_mult.  */\n-      max_cost = mul_widen_cost[speed][mode];\n+      max_cost = mul_widen_cost (speed, mode);\n       if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n \t\t\t       max_cost))\n \t{\n@@ -3564,7 +3572,7 @@ expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Firstly, try using a multiplication insn that only generates the needed\n      high part of the product, and in the sign flavor of unsignedp.  */\n-  if (mul_highpart_cost[speed][mode] < max_cost)\n+  if (mul_highpart_cost (speed, mode) < max_cost)\n     {\n       moptab = unsignedp ? umul_highpart_optab : smul_highpart_optab;\n       tem = expand_binop (mode, moptab, op0, narrow_op1, target,\n@@ -3576,8 +3584,9 @@ expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n      Need to adjust the result after the multiplication.  */\n   if (size - 1 < BITS_PER_WORD\n-      && (mul_highpart_cost[speed][mode] + 2 * shift_cost[speed][mode][size-1]\n-\t  + 4 * add_cost[speed][mode] < max_cost))\n+      && (mul_highpart_cost (speed, mode)\n+\t  + 2 * shift_cost (speed, mode, size-1)\n+\t  + 4 * add_cost (speed, mode) < max_cost))\n     {\n       moptab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n       tem = expand_binop (mode, moptab, op0, narrow_op1, target,\n@@ -3591,7 +3600,7 @@ expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n   if (widening_optab_handler (moptab, wider_mode, mode) != CODE_FOR_nothing\n-      && mul_widen_cost[speed][wider_mode] < max_cost)\n+      && mul_widen_cost (speed, wider_mode) < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1, 0,\n \t\t\t  unsignedp, OPTAB_WIDEN);\n@@ -3602,7 +3611,8 @@ expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Try widening the mode and perform a non-widening multiplication.  */\n   if (optab_handler (smul_optab, wider_mode) != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && mul_cost[speed][wider_mode] + shift_cost[speed][mode][size-1] < max_cost)\n+      && (mul_cost (speed, wider_mode) + shift_cost (speed, mode, size-1)\n+\t  < max_cost))\n     {\n       rtx insns, wop0, wop1;\n \n@@ -3629,8 +3639,9 @@ expmed_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n   if (widening_optab_handler (moptab, wider_mode, mode) != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && (mul_widen_cost[speed][wider_mode] + 2 * shift_cost[speed][mode][size-1]\n-\t  + 4 * add_cost[speed][mode] < max_cost))\n+      && (mul_widen_cost (speed, wider_mode)\n+\t  + 2 * shift_cost (speed, mode, size-1)\n+\t  + 4 * add_cost (speed, mode) < max_cost))\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1,\n \t\t\t  NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n@@ -3684,13 +3695,13 @@ expmed_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n     return expmed_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t       unsignedp, max_cost);\n \n-  extra_cost = shift_cost[speed][mode][GET_MODE_BITSIZE (mode) - 1];\n+  extra_cost = shift_cost (speed, mode, GET_MODE_BITSIZE (mode) - 1);\n \n   /* Check whether we try to multiply by a negative constant.  */\n   if (!unsignedp && ((cnst1 >> (GET_MODE_BITSIZE (mode) - 1)) & 1))\n     {\n       sign_adjust = true;\n-      extra_cost += add_cost[speed][mode];\n+      extra_cost += add_cost (speed, mode);\n     }\n \n   /* See whether shift/add multiplication is cheap enough.  */\n@@ -3880,7 +3891,8 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n       temp = gen_reg_rtx (mode);\n       temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, -1);\n-      if (shift_cost[optimize_insn_for_speed_p ()][mode][ushift] > COSTS_N_INSNS (1))\n+      if (shift_cost (optimize_insn_for_speed_p (), mode, ushift)\n+\t  > COSTS_N_INSNS (1))\n \ttemp = expand_binop (mode, and_optab, temp, GEN_INT (d - 1),\n \t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n       else\n@@ -4083,10 +4095,13 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   /* Only deduct something for a REM if the last divide done was\n      for a different constant.   Then set the constant of the last\n      divide.  */\n-  max_cost = unsignedp ? udiv_cost[speed][compute_mode] : sdiv_cost[speed][compute_mode];\n+  max_cost = (unsignedp \n+\t      ? udiv_cost (speed, compute_mode)\n+\t      : sdiv_cost (speed, compute_mode));\n   if (rem_flag && ! (last_div_const != 0 && op1_is_constant\n \t\t     && INTVAL (op1) == last_div_const))\n-    max_cost -= mul_cost[speed][compute_mode] + add_cost[speed][compute_mode];\n+    max_cost -= (mul_cost (speed, compute_mode)\n+\t\t + add_cost (speed, compute_mode));\n \n   last_div_const = ! rem_flag && op1_is_constant ? INTVAL (op1) : 0;\n \n@@ -4200,9 +4215,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      goto fail1;\n \n \t\t\t    extra_cost\n-\t\t\t      = (shift_cost[speed][compute_mode][post_shift - 1]\n-\t\t\t\t + shift_cost[speed][compute_mode][1]\n-\t\t\t\t + 2 * add_cost[speed][compute_mode]);\n+\t\t\t      = (shift_cost (speed, compute_mode, post_shift - 1)\n+\t\t\t\t + shift_cost (speed, compute_mode, 1)\n+\t\t\t\t + 2 * add_cost (speed, compute_mode));\n \t\t\t    t1 = expmed_mult_highpart (compute_mode, op0,\n \t\t\t\t\t\t       GEN_INT (ml),\n \t\t\t\t\t\t       NULL_RTX, 1,\n@@ -4233,8 +4248,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t       pre_shift, NULL_RTX, 1);\n \t\t\t    extra_cost\n-\t\t\t      = (shift_cost[speed][compute_mode][pre_shift]\n-\t\t\t\t + shift_cost[speed][compute_mode][post_shift]);\n+\t\t\t      = (shift_cost (speed, compute_mode, pre_shift)\n+\t\t\t\t + shift_cost (speed, compute_mode, post_shift));\n \t\t\t    t2 = expmed_mult_highpart (compute_mode, t1,\n \t\t\t\t\t\t       GEN_INT (ml),\n \t\t\t\t\t\t       NULL_RTX, 1,\n@@ -4293,8 +4308,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t      goto fail1;\n \t\t  }\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (d)\n-\t\t\t && (rem_flag ? smod_pow2_cheap[speed][compute_mode]\n-\t\t\t\t      : sdiv_pow2_cheap[speed][compute_mode])\n+\t\t\t && (rem_flag\n+\t\t\t     ? smod_pow2_cheap (speed, compute_mode)\n+\t\t\t     : sdiv_pow2_cheap (speed, compute_mode))\n \t\t\t /* We assume that cheap metric is true if the\n \t\t\t    optab has an expander for this mode.  */\n \t\t\t && ((optab_handler ((rem_flag ? smod_optab\n@@ -4314,7 +4330,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n \n-\t\t    if (sdiv_pow2_cheap[speed][compute_mode]\n+\t\t    if (sdiv_pow2_cheap (speed, compute_mode)\n \t\t\t&& ((optab_handler (sdiv_optab, compute_mode)\n \t\t\t     != CODE_FOR_nothing)\n \t\t\t    || (optab_handler (sdivmod_optab, compute_mode)\n@@ -4358,9 +4374,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    || size - 1 >= BITS_PER_WORD)\n \t\t\t  goto fail1;\n \n-\t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n-\t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n-\t\t\t\t      + add_cost[speed][compute_mode]);\n+\t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n+\t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n+\t\t\t\t      + add_cost (speed, compute_mode));\n \t\t\tt1 = expmed_mult_highpart (compute_mode, op0,\n \t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -4393,9 +4409,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n \t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n \t\t\tmlr = gen_int_mode (ml, compute_mode);\n-\t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n-\t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n-\t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n+\t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n+\t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n+\t\t\t\t      + 2 * add_cost (speed, compute_mode));\n \t\t\tt1 = expmed_mult_highpart (compute_mode, op0, mlr,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -4481,9 +4497,9 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t   size - 1, NULL_RTX, 0);\n \t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n-\t\t\textra_cost = (shift_cost[speed][compute_mode][post_shift]\n-\t\t\t\t      + shift_cost[speed][compute_mode][size - 1]\n-\t\t\t\t      + 2 * add_cost[speed][compute_mode]);\n+\t\t\textra_cost = (shift_cost (speed, compute_mode, post_shift)\n+\t\t\t\t      + shift_cost (speed, compute_mode, size - 1)\n+\t\t\t\t      + 2 * add_cost (speed, compute_mode));\n \t\t\tt3 = expmed_mult_highpart (compute_mode, t2,\n \t\t\t\t\t\t   GEN_INT (ml), NULL_RTX, 1,\n \t\t\t\t\t\t   max_cost - extra_cost);"}, {"sha": "97e17f36c40d92171f9761c7d7a127531fb388f8", "filename": "gcc/expmed.h", "status": "modified", "additions": 395, "deletions": 46, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=5322d07e9c687b4340c4043a11518973e2d6ed9f", "patch": "@@ -171,45 +171,393 @@ extern struct target_expmed *this_target_expmed;\n #define this_target_expmed (&default_target_expmed)\n #endif\n \n-#define alg_hash \\\n-  (this_target_expmed->x_alg_hash)\n-#define alg_hash_used_p \\\n-  (this_target_expmed->x_alg_hash_used_p)\n-#define sdiv_pow2_cheap \\\n-  (this_target_expmed->x_sdiv_pow2_cheap)\n-#define smod_pow2_cheap \\\n-  (this_target_expmed->x_smod_pow2_cheap)\n-#define zero_cost \\\n-  (this_target_expmed->x_zero_cost)\n-#define add_cost \\\n-  (this_target_expmed->x_add_cost)\n-#define neg_cost \\\n-  (this_target_expmed->x_neg_cost)\n-#define shift_cost \\\n-  (this_target_expmed->x_shift_cost)\n-#define shiftadd_cost \\\n-  (this_target_expmed->x_shiftadd_cost)\n-#define shiftsub0_cost \\\n-  (this_target_expmed->x_shiftsub0_cost)\n-#define shiftsub1_cost \\\n-  (this_target_expmed->x_shiftsub1_cost)\n-#define mul_cost \\\n-  (this_target_expmed->x_mul_cost)\n-#define sdiv_cost \\\n-  (this_target_expmed->x_sdiv_cost)\n-#define udiv_cost \\\n-  (this_target_expmed->x_udiv_cost)\n-#define mul_widen_cost \\\n-  (this_target_expmed->x_mul_widen_cost)\n-#define mul_highpart_cost \\\n-  (this_target_expmed->x_mul_highpart_cost)\n+/* Return a pointer to the alg_hash_entry at IDX.  */\n \n-/* Set the COST for converting from FROM_MODE to TO_MODE when optimizing\n+static inline struct alg_hash_entry *\n+alg_hash_entry_ptr (int idx)\n+{\n+  return &this_target_expmed->x_alg_hash[idx];\n+}\n+\n+/* Return true if the x_alg_hash field might have been used.  */\n+\n+static inline bool\n+alg_hash_used_p (void)\n+{\n+  return this_target_expmed->x_alg_hash_used_p;\n+}\n+\n+/* Set whether the x_alg_hash field might have been used.  */\n+\n+static inline void\n+set_alg_hash_used_p (bool usedp)\n+{\n+  this_target_expmed->x_alg_hash_used_p = usedp;\n+}\n+\n+/* Subroutine of {set_,}sdiv_pow2_cheap.  Not to be used otherwise.  */\n+\n+static inline bool *\n+sdiv_pow2_cheap_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_sdiv_pow2_cheap[speed][mode];\n+}\n+\n+/* Set whether a signed division by a power of 2 is cheap in MODE\n+   when optimizing for SPEED.  */\n+\n+static inline void\n+set_sdiv_pow2_cheap (bool speed, enum machine_mode mode, bool cheap_p)\n+{\n+  *sdiv_pow2_cheap_ptr (speed, mode) = cheap_p;\n+}\n+\n+/* Return whether a signed division by a power of 2 is cheap in MODE\n+   when optimizing for SPEED.  */\n+\n+static inline bool\n+sdiv_pow2_cheap (bool speed, enum machine_mode mode)\n+{\n+  return *sdiv_pow2_cheap_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}smod_pow2_cheap.  Not to be used otherwise.  */\n+\n+static inline bool *\n+smod_pow2_cheap_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_smod_pow2_cheap[speed][mode];\n+}\n+\n+/* Set whether a signed modulo by a power of 2 is CHEAP in MODE when\n+   optimizing for SPEED.  */\n+\n+static inline void\n+set_smod_pow2_cheap (bool speed, enum machine_mode mode, bool cheap)\n+{\n+  *smod_pow2_cheap_ptr (speed, mode) = cheap;\n+}\n+\n+/* Return whether a signed modulo by a power of 2 is cheap in MODE\n+   when optimizing for SPEED.  */\n+\n+static inline bool\n+smod_pow2_cheap (bool speed, enum machine_mode mode)\n+{\n+  return *smod_pow2_cheap_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}zero_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+zero_cost_ptr (bool speed)\n+{\n+  return &this_target_expmed->x_zero_cost[speed];\n+}\n+\n+/* Set the COST of loading zero when optimizing for SPEED.  */\n+\n+static inline void\n+set_zero_cost (bool speed, int cost)\n+{\n+  *zero_cost_ptr (speed) = cost;\n+}\n+\n+/* Return the COST of loading zero when optimizing for SPEED.  */\n+\n+static inline int\n+zero_cost (bool speed)\n+{\n+  return *zero_cost_ptr (speed);\n+}\n+\n+/* Subroutine of {set_,}add_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+add_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_add_cost[speed][mode];\n+}\n+\n+/* Set the COST of computing an add in MODE when optimizing for SPEED.  */\n+\n+static inline void\n+set_add_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *add_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost of computing an add in MODE when optimizing for SPEED.  */\n+\n+static inline int\n+add_cost (bool speed, enum machine_mode mode)\n+{\n+  return *add_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}neg_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+neg_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_neg_cost[speed][mode];\n+}\n+\n+/* Set the COST of computing a negation in MODE when optimizing for SPEED.  */\n+\n+static inline void\n+set_neg_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *neg_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost of computing a negation in MODE when optimizing for\n+   SPEED.  */\n+\n+static inline int\n+neg_cost (bool speed, enum machine_mode mode)\n+{\n+  return *neg_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}shift_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+shift_cost_ptr (bool speed, enum machine_mode mode, int bits)\n+{\n+  return &this_target_expmed->x_shift_cost[speed][mode][bits];\n+}\n+\n+/* Set the COST of doing a shift in MODE by BITS when optimizing for SPEED.  */\n+\n+static inline void\n+set_shift_cost (bool speed, enum machine_mode mode, int bits, int cost)\n+{\n+  *shift_cost_ptr (speed, mode, bits) = cost;\n+}\n+\n+/* Return the cost of doing a shift in MODE by BITS when optimizing for\n+   SPEED.  */\n+\n+static inline int\n+shift_cost (bool speed, enum machine_mode mode, int bits)\n+{\n+  return *shift_cost_ptr (speed, mode, bits);\n+}\n+\n+/* Subroutine of {set_,}shiftadd_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+shiftadd_cost_ptr (bool speed, enum machine_mode mode, int bits)\n+{\n+  return &this_target_expmed->x_shiftadd_cost[speed][mode][bits];\n+}\n+\n+/* Set the COST of doing a shift in MODE by BITS followed by an add when\n+   optimizing for SPEED.  */\n+\n+static inline void\n+set_shiftadd_cost (bool speed, enum machine_mode mode, int bits, int cost)\n+{\n+  *shiftadd_cost_ptr (speed, mode, bits) = cost;\n+}\n+\n+/* Return the cost of doing a shift in MODE by BITS followed by an add\n+   when optimizing for SPEED.  */\n+\n+static inline int\n+shiftadd_cost (bool speed, enum machine_mode mode, int bits)\n+{\n+  return *shiftadd_cost_ptr (speed, mode, bits);\n+}\n+\n+/* Subroutine of {set_,}shiftsub0_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+shiftsub0_cost_ptr (bool speed, enum machine_mode mode, int bits)\n+{\n+  return &this_target_expmed->x_shiftsub0_cost[speed][mode][bits];\n+}\n+\n+/* Set the COST of doing a shift in MODE by BITS and then subtracting a\n+   value when optimizing for SPEED.  */\n+\n+static inline void\n+set_shiftsub0_cost (bool speed, enum machine_mode mode, int bits, int cost)\n+{\n+  *shiftsub0_cost_ptr (speed, mode, bits) = cost;\n+}\n+\n+/* Return the cost of doing a shift in MODE by BITS and then subtracting\n+   a value when optimizing for SPEED.  */\n+\n+static inline int\n+shiftsub0_cost (bool speed, enum machine_mode mode, int bits)\n+{\n+  return *shiftsub0_cost_ptr (speed, mode, bits);\n+}\n+\n+/* Subroutine of {set_,}shiftsub1_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+shiftsub1_cost_ptr (bool speed, enum machine_mode mode, int bits)\n+{\n+  return &this_target_expmed->x_shiftsub1_cost[speed][mode][bits];\n+}\n+\n+/* Set the COST of subtracting a shift in MODE by BITS from a value when\n+   optimizing for SPEED.  */\n+\n+static inline void\n+set_shiftsub1_cost (bool speed, enum machine_mode mode, int bits, int cost)\n+{\n+  *shiftsub1_cost_ptr (speed, mode, bits) = cost;\n+}\n+\n+/* Return the cost of subtracting a shift in MODE by BITS from a value\n+   when optimizing for SPEED.  */\n+\n+static inline int\n+shiftsub1_cost (bool speed, enum machine_mode mode, int bits)\n+{\n+  return *shiftsub1_cost_ptr (speed, mode, bits);\n+}\n+\n+/* Subroutine of {set_,}mul_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+mul_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_mul_cost[speed][mode];\n+}\n+\n+/* Set the COST of doing a multiplication in MODE when optimizing for\n+   SPEED.  */\n+\n+static inline void\n+set_mul_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *mul_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost of doing a multiplication in MODE when optimizing\n+   for SPEED.  */\n+\n+static inline int\n+mul_cost (bool speed, enum machine_mode mode)\n+{\n+  return *mul_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}sdiv_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+sdiv_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_sdiv_cost[speed][mode];\n+}\n+\n+/* Set the COST of doing a signed division in MODE when optimizing\n    for SPEED.  */\n \n static inline void\n-set_convert_cost (enum machine_mode to_mode, enum machine_mode from_mode,\n-\t\t  bool speed, int cost)\n+set_sdiv_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *sdiv_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost of doing a signed division in MODE when optimizing\n+   for SPEED.  */\n+\n+static inline int\n+sdiv_cost (bool speed, enum machine_mode mode)\n+{\n+  return *sdiv_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}udiv_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+udiv_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_udiv_cost[speed][mode];\n+}\n+\n+/* Set the COST of doing an unsigned division in MODE when optimizing\n+   for SPEED.  */\n+\n+static inline void\n+set_udiv_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *udiv_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost of doing an unsigned division in MODE when\n+   optimizing for SPEED.  */\n+\n+static inline int\n+udiv_cost (bool speed, enum machine_mode mode)\n+{\n+  return *udiv_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}mul_widen_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+mul_widen_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_mul_widen_cost[speed][mode];\n+}\n+\n+/* Set the COST for computing a widening multiplication in MODE when\n+   optimizing for SPEED.  */\n+\n+static inline void\n+set_mul_widen_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *mul_widen_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost for computing a widening multiplication in MODE when\n+   optimizing for SPEED.  */\n+\n+static inline int\n+mul_widen_cost (bool speed, enum machine_mode mode)\n+{\n+  return *mul_widen_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}mul_highpart_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+mul_highpart_cost_ptr (bool speed, enum machine_mode mode)\n+{\n+  return &this_target_expmed->x_mul_highpart_cost[speed][mode];\n+}\n+\n+/* Set the COST for computing the high part of a multiplication in MODE\n+   when optimizing for SPEED.  */\n+\n+static inline void\n+set_mul_highpart_cost (bool speed, enum machine_mode mode, int cost)\n+{\n+  *mul_highpart_cost_ptr (speed, mode) = cost;\n+}\n+\n+/* Return the cost for computing the high part of a multiplication in MODE\n+   when optimizing for SPEED.  */\n+\n+static inline int\n+mul_highpart_cost (bool speed, enum machine_mode mode)\n+{\n+  return *mul_highpart_cost_ptr (speed, mode);\n+}\n+\n+/* Subroutine of {set_,}convert_cost.  Not to be used otherwise.  */\n+\n+static inline int *\n+convert_cost_ptr (enum machine_mode to_mode, enum machine_mode from_mode,\n+\t\t  bool speed)\n {\n   int to_idx, from_idx;\n \n@@ -220,7 +568,17 @@ set_convert_cost (enum machine_mode to_mode, enum machine_mode from_mode,\n \n   to_idx = to_mode - MIN_MODE_INT;\n   from_idx = from_mode - MIN_MODE_INT;\n-  this_target_expmed->x_convert_cost[speed][to_idx][from_idx] = cost;\n+  return &this_target_expmed->x_convert_cost[speed][to_idx][from_idx];\n+}\n+\n+/* Set the COST for converting from FROM_MODE to TO_MODE when optimizing\n+   for SPEED.  */\n+\n+static inline void\n+set_convert_cost (enum machine_mode to_mode, enum machine_mode from_mode,\n+\t\t  bool speed, int cost)\n+{\n+  *convert_cost_ptr (to_mode, from_mode, speed) = cost;\n }\n \n /* Return the cost for converting from FROM_MODE to TO_MODE when optimizing\n@@ -230,16 +588,7 @@ static inline int\n convert_cost (enum machine_mode to_mode, enum machine_mode from_mode,\n \t      bool speed)\n {\n-  int to_idx, from_idx;\n-\n-  gcc_assert (to_mode >= MIN_MODE_INT\n-\t      && to_mode <= MAX_MODE_INT\n-\t      && from_mode >= MIN_MODE_INT\n-\t      && from_mode <= MAX_MODE_INT);\n-\n-  to_idx = to_mode - MIN_MODE_INT;\n-  from_idx = from_mode - MIN_MODE_INT;\n-  return this_target_expmed->x_convert_cost[speed][to_idx][from_idx];\n+  return *convert_cost_ptr (to_mode, from_mode, speed);\n }\n \n extern int mult_by_coeff_cost (HOST_WIDE_INT, enum machine_mode, bool);"}, {"sha": "66ddfd7bde4f66ec676036466effad630bb0161b", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=5322d07e9c687b4340c4043a11518973e2d6ed9f", "patch": "@@ -344,16 +344,16 @@ stmt_cost (gimple gs, bool speed)\n \treturn mult_by_coeff_cost (TREE_INT_CST_LOW (rhs2), lhs_mode, speed);\n \n       gcc_assert (TREE_CODE (rhs1) != INTEGER_CST);\n-      return mul_cost[speed][lhs_mode];\n+      return mul_cost (speed, lhs_mode);\n \n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       rhs2 = gimple_assign_rhs2 (gs);\n-      return add_cost[speed][lhs_mode];\n+      return add_cost (speed, lhs_mode);\n \n     case NEGATE_EXPR:\n-      return neg_cost[speed][lhs_mode];\n+      return neg_cost (speed, lhs_mode);\n \n     case NOP_EXPR:\n       return convert_cost (lhs_mode, TYPE_MODE (TREE_TYPE (rhs1)), speed);"}, {"sha": "41c811fd7e8d31f5c0a4d8e1f92c8f426247d02c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5322d07e9c687b4340c4043a11518973e2d6ed9f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5322d07e9c687b4340c4043a11518973e2d6ed9f", "patch": "@@ -3308,7 +3308,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t If VAR_PRESENT is true, try whether the mode with\n \t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n \t if this is the case, use it.  */\n-      add_c = add_cost[speed][address_mode];\n+      add_c = add_cost (speed, address_mode);\n       for (i = 0; i < 8; i++)\n \t{\n \t  var_p = i & 1;\n@@ -3392,7 +3392,7 @@ get_address_cost (bool symbol_present, bool var_present,\n     cost += mult_by_coeff_cost (ratio, address_mode, speed);\n \n   if (s_offset && !offset_p && !symbol_present)\n-    cost += add_cost[speed][address_mode];\n+    cost += add_cost (speed, address_mode);\n \n   if (may_autoinc)\n     *may_autoinc = autoinc;\n@@ -3422,10 +3422,10 @@ get_shiftadd_cost (tree expr, enum machine_mode mode, comp_cost cost0,\n     return false;\n \n   sa_cost = (TREE_CODE (expr) != MINUS_EXPR\n-             ? shiftadd_cost[speed][mode][m]\n+             ? shiftadd_cost (speed, mode, m)\n              : (mult == op1\n-                ? shiftsub1_cost[speed][mode][m]\n-                : shiftsub0_cost[speed][mode][m]));\n+                ? shiftsub1_cost (speed, mode, m)\n+                : shiftsub0_cost (speed, mode, m)));\n   res = new_cost (sa_cost, 0);\n   res = add_costs (res, mult == op1 ? cost0 : cost1);\n \n@@ -3559,7 +3559,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case NEGATE_EXPR:\n-      cost = new_cost (add_cost[speed][mode], 0);\n+      cost = new_cost (add_cost (speed, mode), 0);\n       if (TREE_CODE (expr) != NEGATE_EXPR)\n         {\n           tree mult = NULL_TREE;\n@@ -3571,8 +3571,8 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n           if (mult != NULL_TREE\n               && cst_and_fits_in_hwi (TREE_OPERAND (mult, 1))\n-              && get_shiftadd_cost (expr, mode, cost0, cost1, mult, speed,\n-                                    &sa_cost))\n+              && get_shiftadd_cost (expr, mode, cost0, cost1, mult,\n+                                    speed, &sa_cost))\n             return sa_cost;\n         }\n       break;\n@@ -4060,7 +4060,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t\t\t &symbol_present, &var_present,\n \t\t\t\t\t &offset, depends_on));\n       cost.cost /= avg_loop_niter (data->current_loop);\n-      cost.cost += add_cost[data->speed][TYPE_MODE (ctype)];\n+      cost.cost += add_cost (data->speed, TYPE_MODE (ctype));\n     }\n \n   if (inv_expr_id)\n@@ -4101,14 +4101,14 @@ get_computation_cost_at (struct ivopts_data *data,\n       are added once to the variable, if present.  */\n   if (var_present && (symbol_present || offset))\n     cost.cost += adjust_setup_cost (data,\n-\t\t\t\t    add_cost[speed][TYPE_MODE (ctype)]);\n+\t\t\t\t    add_cost (speed, TYPE_MODE (ctype)));\n \n   /* Having offset does not affect runtime cost in case it is added to\n      symbol, but it increases complexity.  */\n   if (offset)\n     cost.complexity++;\n \n-  cost.cost += add_cost[speed][TYPE_MODE (ctype)];\n+  cost.cost += add_cost (speed, TYPE_MODE (ctype));\n \n   aratio = ratio > 0 ? ratio : -ratio;\n   if (aratio != 1)\n@@ -4958,7 +4958,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n      or a const set.  */\n   if (cost_base.cost == 0)\n     cost_base.cost = COSTS_N_INSNS (1);\n-  cost_step = add_cost[data->speed][TYPE_MODE (TREE_TYPE (base))];\n+  cost_step = add_cost (data->speed, TYPE_MODE (TREE_TYPE (base)));\n \n   cost = cost_step + adjust_setup_cost (data, cost_base.cost);\n "}]}