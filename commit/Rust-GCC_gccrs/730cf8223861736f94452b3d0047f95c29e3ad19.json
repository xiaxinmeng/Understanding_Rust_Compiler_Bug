{"sha": "730cf8223861736f94452b3d0047f95c29e3ad19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwY2Y4MjIzODYxNzM2Zjk0NDUyYjNkMDA0N2Y5NWMyOWUzYWQxOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-06-17T06:44:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-06-17T06:44:46Z"}, "message": "mips-protos.h (mips_expand_block_move): Declare.\n\n\t* config/mips/mips-protos.h (mips_expand_block_move): Declare.\n\t(expand_block_move, output_block_move): Remove.\n\t* config/mips/mips.h (enum block_move_type): Remove.\n\t* config/mips/mips.c (block_move_call, output_block_move): Remove.\n\t(mips_block_move_straight, mips_adjust_block_mem): New function.\n\t(mips_block_move_loop): Renamed and reworked from block_move_loop.\n\t(mips_expand_block_move): Likewise expand_block_move.  Return false\n\tto fall back on the target-independent code.\n\t* config/mips/mips.md (movstrsi): Use mips_expand_block_move.\n\t(movstrsi_internal*): Remove.\n\nFrom-SVN: r68071", "tree": {"sha": "3ba084a209c8286831867f337fc2a9f720830e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba084a209c8286831867f337fc2a9f720830e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/730cf8223861736f94452b3d0047f95c29e3ad19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730cf8223861736f94452b3d0047f95c29e3ad19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/730cf8223861736f94452b3d0047f95c29e3ad19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730cf8223861736f94452b3d0047f95c29e3ad19/comments", "author": null, "committer": null, "parents": [{"sha": "6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf87ca4e574edb0bf2bcb2cf396adb6e040311d"}], "stats": {"total": 834, "additions": 149, "deletions": 685}, "files": [{"sha": "8410d0ca98ef7e3ec87c763a475fb4de2d456071", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=730cf8223861736f94452b3d0047f95c29e3ad19", "patch": "@@ -1,3 +1,16 @@\n+2003-06-17  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_expand_block_move): Declare.\n+\t(expand_block_move, output_block_move): Remove.\n+\t* config/mips/mips.h (enum block_move_type): Remove.\n+\t* config/mips/mips.c (block_move_call, output_block_move): Remove.\n+\t(mips_block_move_straight, mips_adjust_block_mem): New function.\n+\t(mips_block_move_loop): Renamed and reworked from block_move_loop.\n+\t(mips_expand_block_move): Likewise expand_block_move.  Return false\n+\tto fall back on the target-independent code.\n+\t* config/mips/mips.md (movstrsi): Use mips_expand_block_move.\n+\t(movstrsi_internal*): Remove.\n+\n 2003-06-16  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cpplib.h, cpphash.h, cppcharset.c, cpperror.c, cppexp.c"}, {"sha": "41b30733051cf7b3e60245e8ca842a4e8e216cdb", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=730cf8223861736f94452b3d0047f95c29e3ad19", "patch": "@@ -78,7 +78,7 @@ extern tree\t\tmips_build_va_list PARAMS ((void));\n extern void\t\tmips_va_start PARAMS ((tree, rtx));\n extern struct rtx_def  *mips_va_arg PARAMS ((tree, tree));\n \n-extern void\t\texpand_block_move PARAMS ((rtx *));\n+extern bool\t\tmips_expand_block_move PARAMS ((rtx, rtx, rtx));\n extern bool\t\tmips_expand_unaligned_load PARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t    unsigned int,\n \t\t\t\t\t\t\t    int));\n@@ -98,8 +98,6 @@ extern void\t\tmips_split_64bit_move PARAMS ((rtx, rtx));\n extern const char      *mips_output_move PARAMS ((rtx, rtx));\n extern const char      *mips_emit_prefetch PARAMS ((rtx *));\n extern const char      *mips_restore_gp PARAMS ((rtx *));\n-extern const char      *output_block_move PARAMS ((rtx, rtx *, int,\n-\t\t\t\t\t\t   enum block_move_type));\n extern void\t\toverride_options PARAMS ((void));\n extern void\t\tmips_conditional_register_usage PARAMS ((void));\n extern void\t\tprint_operand_address PARAMS ((FILE *, rtx));"}, {"sha": "c27bfea8788175e628fad5631c75ffee320c5b09", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 127, "deletions": 529, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=730cf8223861736f94452b3d0047f95c29e3ad19", "patch": "@@ -220,11 +220,12 @@ static void mips_legitimize_const_move\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t rtx, rtx));\n static int m16_check_op\t\t\t\tPARAMS ((rtx, int, int, int));\n static bool mips_function_ok_for_sibcall\tPARAMS ((tree, tree));\n-static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t unsigned int,\n-\t\t\t\t\t\t\t int,\n-\t\t\t\t\t\t\t rtx, rtx));\n-static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n+static void mips_block_move_straight\t\tPARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n+static void mips_adjust_block_mem\t\tPARAMS ((rtx, HOST_WIDE_INT,\n+\t\t\t\t\t\t\t rtx *, rtx *));\n+static void mips_block_move_loop\t\tPARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n static void mips_arg_info\t\tPARAMS ((const CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int,\n@@ -3676,569 +3677,166 @@ mips_set_return_address (address, scratch)\n   emit_move_insn (gen_rtx_MEM (GET_MODE (address), scratch), address);\n }\n \f\n-/* Write a loop to move a constant number of bytes.\n-   Generate load/stores as follows:\n-\n-   do {\n-     temp1 = src[0];\n-     temp2 = src[1];\n-     ...\n-     temp<last> = src[MAX_MOVE_REGS-1];\n-     dest[0] = temp1;\n-     dest[1] = temp2;\n-     ...\n-     dest[MAX_MOVE_REGS-1] = temp<last>;\n-     src += MAX_MOVE_REGS;\n-     dest += MAX_MOVE_REGS;\n-   } while (src != final);\n-\n-   This way, no NOP's are needed, and only MAX_MOVE_REGS+3 temp\n-   registers are needed.\n-\n-   Aligned moves move MAX_MOVE_REGS*4 bytes every (2*MAX_MOVE_REGS)+3\n-   cycles, unaligned moves move MAX_MOVE_REGS*4 bytes every\n-   (4*MAX_MOVE_REGS)+3 cycles, assuming no cache misses.  */\n-\n-#define MAX_MOVE_REGS 4\n-#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n+/* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n+   Assume that the areas do not overlap.  */\n \n static void\n-block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src)\n-     rtx dest_reg;\t\t/* register holding destination address */\n-     rtx src_reg;\t\t/* register holding source address */\n-     unsigned int bytes;\t/* # bytes to move */\n-     int align;\t\t\t/* alignment */\n-     rtx orig_dest;\t\t/* original dest */\n-     rtx orig_src;\t\t/* original source for making a reg note */\n-{\n-  rtx dest_mem = replace_equiv_address (orig_dest, dest_reg);\n-  rtx src_mem = replace_equiv_address (orig_src, src_reg);\n-  rtx align_rtx = GEN_INT (align);\n-  rtx label;\n-  rtx final_src;\n-  rtx bytes_rtx;\n-  int leftover;\n-\n-  if (bytes < (unsigned)2 * MAX_MOVE_BYTES)\n-    abort ();\n+mips_block_move_straight (dest, src, length)\n+     rtx dest, src;\n+     HOST_WIDE_INT length;\n+{\n+  HOST_WIDE_INT offset, delta;\n+  unsigned HOST_WIDE_INT bits;\n+  int i;\n+  enum machine_mode mode;\n+  rtx *regs;\n+\n+  /* Work out how many bits to move at a time.  If both operands have\n+     half-word alignment, it is usually better to move in half words.\n+     For instance, lh/lh/sh/sh is usually better than lwl/lwr/swl/swr\n+     and lw/lw/sw/sw is usually better than ldl/ldr/sdl/sdr.\n+     Otherwise move word-sized chunks.  */\n+  if (MEM_ALIGN (src) == BITS_PER_WORD / 2\n+      && MEM_ALIGN (dest) == BITS_PER_WORD / 2)\n+    bits = BITS_PER_WORD / 2;\n+  else\n+    bits = BITS_PER_WORD;\n \n-  leftover = bytes % MAX_MOVE_BYTES;\n-  bytes -= leftover;\n+  mode = mode_for_size (bits, MODE_INT, 0);\n+  delta = bits / BITS_PER_UNIT;\n \n-  label = gen_label_rtx ();\n-  final_src = gen_reg_rtx (Pmode);\n-  bytes_rtx = GEN_INT (bytes);\n+  /* Allocate a buffer for the temporary registers.  */\n+  regs = alloca (sizeof (rtx) * length / delta);\n \n-  if (bytes > 0x7fff)\n-    {\n-      if (Pmode == DImode)\n-\t{\n-\t  emit_insn (gen_movdi (final_src, bytes_rtx));\n-\t  emit_insn (gen_adddi3 (final_src, final_src, src_reg));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_movsi (final_src, bytes_rtx));\n-\t  emit_insn (gen_addsi3 (final_src, final_src, src_reg));\n-\t}\n-    }\n-  else\n+  /* Load as many BITS-sized chunks as possible.  Use a normal load if\n+     the source has enough alignment, otherwise use left/right pairs.  */\n+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n     {\n-      if (Pmode == DImode)\n-\temit_insn (gen_adddi3 (final_src, src_reg, bytes_rtx));\n-      else\n-\temit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));\n-    }\n+      rtx part;\n \n-  emit_label (label);\n-\n-  bytes_rtx = GEN_INT (MAX_MOVE_BYTES);\n-  emit_insn (gen_movstrsi_internal (dest_mem, src_mem, bytes_rtx, align_rtx));\n+      regs[i] = gen_reg_rtx (mode);\n+      part = adjust_address (src, mode, offset);\n+      if (MEM_ALIGN (part) >= bits)\n+\temit_move_insn (regs[i], part);\n+      else if (!mips_expand_unaligned_load (regs[i], part, bits, 0))\n+\tabort ();\n+    }\n \n-  if (Pmode == DImode)\n+  /* Copy the chunks to the destination.  */\n+  for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n     {\n-      emit_insn (gen_adddi3 (src_reg, src_reg, bytes_rtx));\n-      emit_insn (gen_adddi3 (dest_reg, dest_reg, bytes_rtx));\n-      emit_insn (gen_cmpdi (src_reg, final_src));\n+      rtx part;\n+\n+      part = adjust_address (dest, mode, offset);\n+      if (MEM_ALIGN (part) >= bits)\n+\temit_move_insn (part, regs[i]);\n+      else if (!mips_expand_unaligned_store (part, regs[i], bits, 0))\n+\tabort ();\n     }\n-  else\n+\n+  /* Mop up any left-over bytes.  */\n+  if (offset < length)\n     {\n-      emit_insn (gen_addsi3 (src_reg, src_reg, bytes_rtx));\n-      emit_insn (gen_addsi3 (dest_reg, dest_reg, bytes_rtx));\n-      emit_insn (gen_cmpsi (src_reg, final_src));\n+      src = adjust_address (src, mode, offset);\n+      dest = adjust_address (dest, mode, offset);\n+      move_by_pieces (dest, src, length - offset,\n+\t\t      MIN (MEM_ALIGN (src), MEM_ALIGN (dest)), 0);\n     }\n-\n-  emit_jump_insn (gen_bne (label));\n-\n-  if (leftover)\n-    emit_insn (gen_movstrsi_internal (dest_mem, src_mem, GEN_INT (leftover),\n-\t\t\t\t      align_rtx));\n }\n \f\n-/* Use a library function to move some bytes.  */\n-\n-static void\n-block_move_call (dest_reg, src_reg, bytes_rtx)\n-     rtx dest_reg;\n-     rtx src_reg;\n-     rtx bytes_rtx;\n-{\n-  /* We want to pass the size as Pmode, which will normally be SImode\n-     but will be DImode if we are using 64 bit longs and pointers.  */\n-  if (GET_MODE (bytes_rtx) != VOIDmode\n-      && GET_MODE (bytes_rtx) != (unsigned) Pmode)\n-    bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n-\n-#ifdef TARGET_MEM_FUNCTIONS\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n-\t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n-\t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n-\t\t\t\t      TREE_UNSIGNED (sizetype)),\n-\t\t     TYPE_MODE (sizetype));\n-#else\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"bcopy\"), 0,\n-\t\t     VOIDmode, 3, src_reg, Pmode, dest_reg, Pmode,\n-\t\t     convert_to_mode (TYPE_MODE (integer_type_node), bytes_rtx,\n-\t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n-\t\t     TYPE_MODE (integer_type_node));\n-#endif\n-}\n-\f\n-/* Expand string/block move operations.\n+#define MAX_MOVE_REGS 4\n+#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n \n-   operands[0] is the pointer to the destination.\n-   operands[1] is the pointer to the source.\n-   operands[2] is the number of bytes to move.\n-   operands[3] is the alignment.  */\n \n-void\n-expand_block_move (operands)\n-     rtx operands[];\n-{\n-  rtx bytes_rtx\t= operands[2];\n-  rtx align_rtx = operands[3];\n-  int constp = GET_CODE (bytes_rtx) == CONST_INT;\n-  unsigned HOST_WIDE_INT bytes = constp ? INTVAL (bytes_rtx) : 0;\n-  unsigned int align = INTVAL (align_rtx);\n-  rtx orig_src\t= operands[1];\n-  rtx orig_dest\t= operands[0];\n-  rtx src_reg;\n-  rtx dest_reg;\n-\n-  if (constp && bytes == 0)\n-    return;\n+/* Helper function for doing a loop-based block operation on memory\n+   reference MEM.  Each iteration of the loop will operate on LENGTH\n+   bytes of MEM.\n \n-  if (align > (unsigned) UNITS_PER_WORD)\n-    align = UNITS_PER_WORD;\n+   Create a new base register for use within the loop and point it to\n+   the start of MEM.  Create a new memory reference that uses this\n+   register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */\n \n-  /* Move the address into scratch registers.  */\n-  dest_reg = copy_addr_to_reg (XEXP (orig_dest, 0));\n-  src_reg  = copy_addr_to_reg (XEXP (orig_src, 0));\n+static void\n+mips_adjust_block_mem (mem, length, loop_reg, loop_mem)\n+     rtx mem, *loop_reg, *loop_mem;\n+     HOST_WIDE_INT length;\n+{\n+  *loop_reg = copy_addr_to_reg (XEXP (mem, 0));\n \n-  if (TARGET_MEMCPY)\n-    block_move_call (dest_reg, src_reg, bytes_rtx);\n+  /* Although the new mem does not refer to a known location,\n+     it does keep up to LENGTH bytes of alignment.  */\n+  *loop_mem = change_address (mem, BLKmode, *loop_reg);\n+  set_mem_align (*loop_mem, MIN (MEM_ALIGN (mem), length * BITS_PER_UNIT));\n+}\n \n-  else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES\n-\t   && align == (unsigned) UNITS_PER_WORD)\n-    move_by_pieces (orig_dest, orig_src, bytes, align * BITS_PER_WORD, 0);\n \n-  else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES)\n-    emit_insn (gen_movstrsi_internal (replace_equiv_address (orig_dest,\n-\t\t\t\t\t\t\t     dest_reg),\n-\t\t\t\t      replace_equiv_address (orig_src,\n-\t\t\t\t\t\t\t     src_reg),\n-\t\t\t\t      bytes_rtx, align_rtx));\n+/* Move LENGTH bytes from SRC to DEST using a loop that moves MAX_MOVE_BYTES\n+   per iteration.  LENGTH must be at least MAX_MOVE_BYTES.  Assume that the\n+   memory regions do not overlap.  */\n \n-  else if (constp && align >= (unsigned) UNITS_PER_WORD && optimize)\n-    block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src);\n+static void\n+mips_block_move_loop (dest, src, length)\n+     rtx dest, src;\n+     HOST_WIDE_INT length;\n+{\n+  rtx label, src_reg, dest_reg, final_src;\n+  HOST_WIDE_INT leftover;\n \n-  else if (constp && optimize)\n-    {\n-      /* If the alignment is not word aligned, generate a test at\n-\t runtime, to see whether things wound up aligned, and we\n-\t can use the faster lw/sw instead ulw/usw.  */\n+  leftover = length % MAX_MOVE_BYTES;\n+  length -= leftover;\n \n-      rtx temp = gen_reg_rtx (Pmode);\n-      rtx aligned_label = gen_label_rtx ();\n-      rtx join_label = gen_label_rtx ();\n-      int leftover = bytes % MAX_MOVE_BYTES;\n+  /* Create registers and memory references for use within the loop.  */\n+  mips_adjust_block_mem (src, MAX_MOVE_BYTES, &src_reg, &src);\n+  mips_adjust_block_mem (dest, MAX_MOVE_BYTES, &dest_reg, &dest);\n \n-      bytes -= leftover;\n+  /* Calculate the value that SRC_REG should have after the last iteration\n+     of the loop.  */\n+  final_src = expand_simple_binop (Pmode, PLUS, src_reg, GEN_INT (length),\n+\t\t\t\t   0, 0, OPTAB_WIDEN);\n \n-      if (Pmode == DImode)\n-\t{\n-\t  emit_insn (gen_iordi3 (temp, src_reg, dest_reg));\n-\t  emit_insn (gen_anddi3 (temp, temp, GEN_INT (UNITS_PER_WORD - 1)));\n-\t  emit_insn (gen_cmpdi (temp, const0_rtx));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_iorsi3 (temp, src_reg, dest_reg));\n-\t  emit_insn (gen_andsi3 (temp, temp, GEN_INT (UNITS_PER_WORD - 1)));\n-\t  emit_insn (gen_cmpsi (temp, const0_rtx));\n-\t}\n-\n-      emit_jump_insn (gen_beq (aligned_label));\n-\n-      /* Unaligned loop.  */\n-      block_move_loop (dest_reg, src_reg, bytes, 1, orig_dest, orig_src);\n-      emit_jump_insn (gen_jump (join_label));\n-      emit_barrier ();\n+  /* Emit the start of the loop.  */\n+  label = gen_label_rtx ();\n+  emit_label (label);\n \n-      /* Aligned loop.  */\n-      emit_label (aligned_label);\n-      block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD, orig_dest,\n-\t\t       orig_src);\n-      emit_label (join_label);\n+  /* Emit the loop body.  */\n+  mips_block_move_straight (dest, src, MAX_MOVE_BYTES);\n \n-      /* Bytes at the end of the loop.  */\n-      if (leftover)\n-\temit_insn (gen_movstrsi_internal (replace_equiv_address (orig_dest,\n-\t\t\t\t\t\t\t\t dest_reg),\n-\t\t\t\t\t  replace_equiv_address (orig_src,\n-\t\t\t\t\t\t\t\t src_reg),\n-\t\t\t\t\t  GEN_INT (leftover),\n-\t\t\t\t\t  GEN_INT (align)));\n-    }\n+  /* Move on to the next block.  */\n+  emit_move_insn (src_reg, plus_constant (src_reg, MAX_MOVE_BYTES));\n+  emit_move_insn (dest_reg, plus_constant (dest_reg, MAX_MOVE_BYTES));\n \n+  /* Emit the loop condition.  */\n+  if (Pmode == DImode)\n+    emit_insn (gen_cmpdi (src_reg, final_src));\n   else\n-    block_move_call (dest_reg, src_reg, bytes_rtx);\n+    emit_insn (gen_cmpsi (src_reg, final_src));\n+  emit_jump_insn (gen_bne (label));\n+\n+  /* Mop up any left-over bytes.  */\n+  if (leftover)\n+    mips_block_move_straight (dest, src, leftover);\n }\n \f\n-/* Emit load/stores for a small constant block_move.\n-\n-   operands[0] is the memory address of the destination.\n-   operands[1] is the memory address of the source.\n-   operands[2] is the number of bytes to move.\n-   operands[3] is the alignment.\n-   operands[4] is a temp register.\n-   operands[5] is a temp register.\n-   ...\n-   operands[3+num_regs] is the last temp register.\n-\n-   The block move type can be one of the following:\n-\tBLOCK_MOVE_NORMAL\tDo all of the block move.\n-\tBLOCK_MOVE_NOT_LAST\tDo all but the last store.\n-\tBLOCK_MOVE_LAST\t\tDo just the last store.  */\n+/* Expand a movstrsi instruction.  */\n \n-const char *\n-output_block_move (insn, operands, num_regs, move_type)\n-     rtx insn;\n-     rtx operands[];\n-     int num_regs;\n-     enum block_move_type move_type;\n-{\n-  rtx dest_reg = XEXP (operands[0], 0);\n-  rtx src_reg = XEXP (operands[1], 0);\n-  HOST_WIDE_INT bytes = INTVAL (operands[2]);\n-  int align = INTVAL (operands[3]);\n-  int num = 0;\n-  int offset = 0;\n-  int use_lwl_lwr = 0;\n-  int last_operand = num_regs + 4;\n-  int safe_regs = 4;\n-  int i;\n-  rtx xoperands[10];\n-\n-  struct {\n-    const char *load;\t\t/* load insn without nop */\n-    const char *load_nop;\t/* load insn with trailing nop */\n-    const char *store;\t\t/* store insn */\n-    const char *final;\t\t/* if last_store used: NULL or swr */\n-    const char *last_store;\t/* last store instruction */\n-    int offset;\t\t\t/* current offset */\n-    enum machine_mode mode;\t/* mode to use on (MEM) */\n-  } load_store[4];\n-\n-  /* ??? Detect a bug in GCC, where it can give us a register\n-     the same as one of the addressing registers and reduce\n-     the number of registers available.  */\n-  for (i = 4; i < last_operand && safe_regs < (int) ARRAY_SIZE (xoperands); i++)\n-    if (! reg_mentioned_p (operands[i], operands[0])\n-\t&& ! reg_mentioned_p (operands[i], operands[1]))\n-      xoperands[safe_regs++] = operands[i];\n-\n-  if (safe_regs < last_operand)\n-    {\n-      xoperands[0] = operands[0];\n-      xoperands[1] = operands[1];\n-      xoperands[2] = operands[2];\n-      xoperands[3] = operands[3];\n-      return output_block_move (insn, xoperands, safe_regs - 4, move_type);\n-    }\n-\n-  /* If we are given global or static addresses, and we would be\n-     emitting a few instructions, try to save time by using a\n-     temporary register for the pointer.  */\n-  /* ??? The SGI Irix6 assembler fails when a SYMBOL_REF is used in\n-     an ldl/ldr instruction pair.  We play it safe, and always move\n-     constant addresses into registers when generating N32/N64 code, just\n-     in case we might emit an unaligned load instruction.  */\n-  if (num_regs > 2 && (bytes > 2 * align || move_type != BLOCK_MOVE_NORMAL\n-\t\t       || mips_abi == ABI_N32\n-\t\t       || mips_abi == ABI_64))\n-    {\n-      if (CONSTANT_P (src_reg))\n-\t{\n-\t  src_reg = operands[3 + num_regs--];\n-\t  if (move_type != BLOCK_MOVE_LAST)\n-\t    {\n-\t      xoperands[1] = operands[1];\n-\t      xoperands[0] = src_reg;\n-\t      if (Pmode == DImode)\n-\t\toutput_asm_insn (\"dla\\t%0,%1\", xoperands);\n-\t      else\n-\t\toutput_asm_insn (\"la\\t%0,%1\", xoperands);\n-\t    }\n-\t}\n-\n-      if (CONSTANT_P (dest_reg))\n-\t{\n-\t  dest_reg = operands[3 + num_regs--];\n-\t  if (move_type != BLOCK_MOVE_LAST)\n-\t    {\n-\t      xoperands[1] = operands[0];\n-\t      xoperands[0] = dest_reg;\n-\t      if (Pmode == DImode)\n-\t\toutput_asm_insn (\"dla\\t%0,%1\", xoperands);\n-\t      else\n-\t\toutput_asm_insn (\"la\\t%0,%1\", xoperands);\n-\t    }\n-\t}\n-    }\n-\n-  /* ??? We really shouldn't get any LO_SUM addresses here, because they\n-     are not offsettable, however, offsettable_address_p says they are\n-     offsettable. I think this is a bug in offsettable_address_p.\n-     For expediency, we fix this by just loading the address into a register\n-     if we happen to get one.  */\n-\n-  if (GET_CODE (src_reg) == LO_SUM)\n-    {\n-      src_reg = operands[3 + num_regs--];\n-      if (move_type != BLOCK_MOVE_LAST)\n-\t{\n-\t  xoperands[2] = XEXP (XEXP (operands[1], 0), 1);\n-\t  xoperands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t  xoperands[0] = src_reg;\n-\t  if (Pmode == DImode)\n-\t    output_asm_insn (\"daddiu\\t%0,%1,%%lo(%2)\", xoperands);\n-\t  else\n-\t    output_asm_insn (\"addiu\\t%0,%1,%%lo(%2)\", xoperands);\n-\t}\n-    }\n-\n-  if (GET_CODE (dest_reg) == LO_SUM)\n-    {\n-      dest_reg = operands[3 + num_regs--];\n-      if (move_type != BLOCK_MOVE_LAST)\n-\t{\n-\t  xoperands[2] = XEXP (XEXP (operands[0], 0), 1);\n-\t  xoperands[1] = XEXP (XEXP (operands[0], 0), 0);\n-\t  xoperands[0] = dest_reg;\n-\t  if (Pmode == DImode)\n-\t    output_asm_insn (\"daddiu\\t%0,%1,%%lo(%2)\", xoperands);\n-\t  else\n-\t    output_asm_insn (\"addiu\\t%0,%1,%%lo(%2)\", xoperands);\n-\t}\n-    }\n-\n-  if (num_regs > (int) ARRAY_SIZE (load_store))\n-    num_regs = ARRAY_SIZE (load_store);\n-\n-  else if (num_regs < 1)\n-    abort_with_insn (insn,\n-\t\t     \"cannot do block move, not enough scratch registers\");\n-\n-  while (bytes > 0)\n+bool\n+mips_expand_block_move (dest, src, length)\n+     rtx dest, src, length;\n+{\n+  if (GET_CODE (length) == CONST_INT)\n     {\n-      load_store[num].offset = offset;\n-\n-      if (TARGET_64BIT && bytes >= 8 && align >= 8)\n-\t{\n-\t  load_store[num].load = \"ld\\t%0,%1\";\n-\t  load_store[num].load_nop = \"ld\\t%0,%1%#\";\n-\t  load_store[num].store = \"sd\\t%0,%1\";\n-\t  load_store[num].last_store = \"sd\\t%0,%1\";\n-\t  load_store[num].final = 0;\n-\t  load_store[num].mode = DImode;\n-\t  offset += 8;\n-\t  bytes -= 8;\n-\t}\n-\n-      /* ??? Fails because of a MIPS assembler bug?  */\n-      else if (TARGET_64BIT && bytes >= 8\n-\t       && ! TARGET_SR71K\n-\t       && ! TARGET_MIPS16)\n-\t{\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      load_store[num].load = \"ldl\\t%0,%1\\n\\tldr\\t%0,%2\";\n-\t      load_store[num].load_nop = \"ldl\\t%0,%1\\n\\tldr\\t%0,%2%#\";\n-\t      load_store[num].store = \"sdl\\t%0,%1\\n\\tsdr\\t%0,%2\";\n-\t      load_store[num].last_store = \"sdr\\t%0,%2\";\n-\t      load_store[num].final = \"sdl\\t%0,%1\";\n-\t    }\n-\t  else\n-\t    {\n-\t      load_store[num].load = \"ldl\\t%0,%2\\n\\tldr\\t%0,%1\";\n-\t      load_store[num].load_nop = \"ldl\\t%0,%2\\n\\tldr\\t%0,%1%#\";\n-\t      load_store[num].store = \"sdl\\t%0,%2\\n\\tsdr\\t%0,%1\";\n-\t      load_store[num].last_store = \"sdr\\t%0,%1\";\n-\t      load_store[num].final = \"sdl\\t%0,%2\";\n-\t    }\n-\n-\t  load_store[num].mode = DImode;\n-\t  offset += 8;\n-\t  bytes -= 8;\n-\t  use_lwl_lwr = 1;\n-\t}\n-\n-      else if (bytes >= 4 && align >= 4)\n-\t{\n-\t  load_store[num].load = \"lw\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lw\\t%0,%1%#\";\n-\t  load_store[num].store = \"sw\\t%0,%1\";\n-\t  load_store[num].last_store = \"sw\\t%0,%1\";\n-\t  load_store[num].final = 0;\n-\t  load_store[num].mode = SImode;\n-\t  offset += 4;\n-\t  bytes -= 4;\n-\t}\n-\n-      else if (bytes >= 4\n-\t       && ! TARGET_SR71K\n-\t       && ! TARGET_MIPS16)\n-\t{\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      load_store[num].load = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2\";\n-\t      load_store[num].load_nop = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2%#\";\n-\t      load_store[num].store = \"swl\\t%0,%1\\n\\tswr\\t%0,%2\";\n-\t      load_store[num].last_store = \"swr\\t%0,%2\";\n-\t      load_store[num].final = \"swl\\t%0,%1\";\n-\t    }\n-\t  else\n-\t    {\n-\t      load_store[num].load = \"lwl\\t%0,%2\\n\\tlwr\\t%0,%1\";\n-\t      load_store[num].load_nop = \"lwl\\t%0,%2\\n\\tlwr\\t%0,%1%#\";\n-\t      load_store[num].store = \"swl\\t%0,%2\\n\\tswr\\t%0,%1\";\n-\t      load_store[num].last_store = \"swr\\t%0,%1\";\n-\t      load_store[num].final = \"swl\\t%0,%2\";\n-\t    }\n-\n-\t  load_store[num].mode = SImode;\n-\t  offset += 4;\n-\t  bytes -= 4;\n-\t  use_lwl_lwr = 1;\n-\t}\n-\n-      else if (bytes >= 2 && align >= 2)\n+      if (INTVAL (length) <= 2 * MAX_MOVE_BYTES)\n \t{\n-\t  load_store[num].load = \"lh\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lh\\t%0,%1%#\";\n-\t  load_store[num].store = \"sh\\t%0,%1\";\n-\t  load_store[num].last_store = \"sh\\t%0,%1\";\n-\t  load_store[num].final = 0;\n-\t  load_store[num].mode = HImode;\n-\t  offset += 2;\n-\t  bytes -= 2;\n+\t  mips_block_move_straight (dest, src, INTVAL (length));\n+\t  return true;\n \t}\n-      else\n+      else if (optimize)\n \t{\n-\t  load_store[num].load = \"lb\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lb\\t%0,%1%#\";\n-\t  load_store[num].store = \"sb\\t%0,%1\";\n-\t  load_store[num].last_store = \"sb\\t%0,%1\";\n-\t  load_store[num].final = 0;\n-\t  load_store[num].mode = QImode;\n-\t  offset++;\n-\t  bytes--;\n-\t}\n-\n-      /* Emit load/stores now if we have run out of registers or are\n-\t at the end of the move.  */\n-\n-      if (++num == num_regs || bytes == 0)\n-\t{\n-\t  /* If only load/store, we need a NOP after the load.  */\n-\t  if (num == 1)\n-\t    load_store[0].load = load_store[0].load_nop;\n-\n-\t  if (move_type != BLOCK_MOVE_LAST)\n-\t    {\n-\t      for (i = 0; i < num; i++)\n-\t\t{\n-\t\t  int offset;\n-\n-\t\t  if (!operands[i + 4])\n-\t\t    abort ();\n-\n-\t\t  if (GET_MODE (operands[i + 4]) != load_store[i].mode)\n-\t\t    operands[i + 4] = gen_rtx_REG (load_store[i].mode,\n-\t\t\t\t\t\t   REGNO (operands[i + 4]));\n-\n-\t\t  offset = load_store[i].offset;\n-\t\t  xoperands[0] = operands[i + 4];\n-\t\t  xoperands[1] = gen_rtx_MEM (load_store[i].mode,\n-\t\t\t\t\t      plus_constant (src_reg, offset));\n-\n-\t\t  if (use_lwl_lwr)\n-\t\t    {\n-\t\t      int extra_offset\n-\t\t\t= GET_MODE_SIZE (load_store[i].mode) - 1;\n-\n-\t\t      xoperands[2] = gen_rtx_MEM (load_store[i].mode,\n-\t\t\t\t\t\t  plus_constant (src_reg,\n-\t\t\t\t\t\t\t\t extra_offset\n-\t\t\t\t\t\t\t\t + offset));\n-\t\t    }\n-\n-\t\t  output_asm_insn (load_store[i].load, xoperands);\n-\t\t}\n-\t    }\n-\n-\t  for (i = 0; i < num; i++)\n-\t    {\n-\t      int last_p = (i == num-1 && bytes == 0);\n-\t      int offset = load_store[i].offset;\n-\n-\t      xoperands[0] = operands[i + 4];\n-\t      xoperands[1] = gen_rtx_MEM (load_store[i].mode,\n-\t\t\t\t\t  plus_constant (dest_reg, offset));\n-\n-\n-\t      if (use_lwl_lwr)\n-\t\t{\n-\t\t  int extra_offset = GET_MODE_SIZE (load_store[i].mode) - 1;\n-\t\t  xoperands[2] = gen_rtx_MEM (load_store[i].mode,\n-\t\t\t\t\t      plus_constant (dest_reg,\n-\t\t\t\t\t\t\t     extra_offset\n-\t\t\t\t\t\t\t     + offset));\n-\t\t}\n-\n-\t      if (move_type == BLOCK_MOVE_NORMAL)\n-\t\toutput_asm_insn (load_store[i].store, xoperands);\n-\n-\t      else if (move_type == BLOCK_MOVE_NOT_LAST)\n-\t\t{\n-\t\t  if (!last_p)\n-\t\t    output_asm_insn (load_store[i].store, xoperands);\n-\n-\t\t  else if (load_store[i].final != 0)\n-\t\t    output_asm_insn (load_store[i].final, xoperands);\n-\t\t}\n-\n-\t      else if (last_p)\n-\t\toutput_asm_insn (load_store[i].last_store, xoperands);\n-\t    }\n-\n-\t  num = 0;\t\t/* reset load_store */\n-\t  use_lwl_lwr = 0;\n+\t  mips_block_move_loop (dest, src, INTVAL (length));\n+\t  return true;\n \t}\n     }\n-\n-  return \"\";\n+  return false;\n }\n \f\n /* Argument support functions.  */"}, {"sha": "cfb3e72fce99f79df250c9791a3e18f108c6c6fd", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=730cf8223861736f94452b3d0047f95c29e3ad19", "patch": "@@ -94,15 +94,6 @@ enum mips_abicalls_type {\n /* Recast the abicalls class to be the abicalls attribute.  */\n #define mips_abicalls_attr ((enum attr_abicalls)mips_abicalls)\n \n-/* Which type of block move to do (whether or not the last store is\n-   split out so it can fill a branch delay slot).  */\n-\n-enum block_move_type {\n-  BLOCK_MOVE_NORMAL,\t\t\t/* generate complete block move */\n-  BLOCK_MOVE_NOT_LAST,\t\t\t/* generate all but last store */\n-  BLOCK_MOVE_LAST\t\t\t/* generate just the last store */\n-};\n-\n /* Information about one recognized processor.  Defined here for the\n    benefit of TARGET_CPU_CPP_BUILTINS.  */\n struct mips_cpu_info {"}, {"sha": "cbcd2f5d357382ffb27d3249a2b88e5b98909c37", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 8, "deletions": 144, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/730cf8223861736f94452b3d0047f95c29e3ad19/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=730cf8223861736f94452b3d0047f95c29e3ad19", "patch": "@@ -5460,151 +5460,15 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_expand \"movstrsi\"\n   [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n \t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"arith32_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))])]\n-  \"!TARGET_MIPS16\"\n-  \"\n-{\n-  if (operands[0])\t\t/* avoid unused code messages */\n-    {\n-      expand_block_move (operands);\n+\t      (use (match_operand:SI 2 \"\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n+  \"!TARGET_MIPS16 && !TARGET_MEMCPY\"\n+  {\n+    if (mips_expand_block_move (operands[0], operands[1], operands[2]))\n       DONE;\n-    }\n-}\")\n-\n-;; Insn generated by block moves\n-\n-(define_insn \"movstrsi_internal\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\t;; source\n-   (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n-   (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n-   (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n-   (clobber (match_scratch:SI 7 \"=&d\"))\t\t\t;; temp 4\n-   (use (match_operand:SI 2 \"small_int\" \"I\"))\t\t;; # bytes to move\n-   (use (match_operand:SI 3 \"small_int\" \"I\"))\t\t;; alignment\n-   (use (const_int 0))]\t\t\t\t\t;; normal block move\n-  \"\"\n-  \"* return output_block_move (insn, operands, 4, BLOCK_MOVE_NORMAL);\"\n-  [(set_attr \"type\"\t\"store\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"80\")])\n-\n-;; We need mips16 versions, because an offset from the stack pointer\n-;; is not offsettable, since the stack pointer can only handle 4 and 8\n-;; byte loads.\n-\n-(define_insn \"\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\t;; source\n-   (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n-   (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n-   (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n-   (clobber (match_scratch:SI 7 \"=&d\"))\t\t\t;; temp 4\n-   (use (match_operand:SI 2 \"small_int\" \"I\"))\t\t;; # bytes to move\n-   (use (match_operand:SI 3 \"small_int\" \"I\"))\t\t;; alignment\n-   (use (const_int 0))]\t\t\t\t\t;; normal block move\n-  \"TARGET_MIPS16\"\n-  \"* return output_block_move (insn, operands, 4, BLOCK_MOVE_NORMAL);\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"80\")])\n-\n-;; Split a block move into 2 parts, the first part is everything\n-;; except for the last move, and the second part is just the last\n-;; store, which is exactly 1 instruction (ie, not a usw), so it can\n-;; fill a delay slot.  This also prevents a bug in delayed branches\n-;; from showing up, which reuses one of the registers in our clobbers.\n-\n-;; ??? Disabled because it doesn't preserve alias information for\n-;; operands 0 and 1.  Also, the rtl for the second insn doesn't mention\n-;; that it uses the registers clobbered by the first.\n-;;\n-;; It would probably be better to split the block into individual\n-;; instructions instead.\n-(define_split\n-  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n-   (clobber (match_operand:SI 4 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 5 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 6 \"register_operand\" \"\"))\n-   (clobber (match_operand:SI 7 \"register_operand\" \"\"))\n-   (use (match_operand:SI 2 \"small_int\" \"\"))\n-   (use (match_operand:SI 3 \"small_int\" \"\"))\n-   (use (const_int 0))]\n-\n-  \"reload_completed && 0 && INTVAL (operands[2]) > 0\"\n-\n-  ;; All but the last move\n-  [(parallel [(set (mem:BLK (match_dup 0))\n-\t\t   (mem:BLK (match_dup 1)))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 6))\n-\t      (clobber (match_dup 7))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (use (const_int 1))])\n-\n-   ;; The last store, so it can fill a delay slot\n-   (parallel [(set (mem:BLK (match_dup 0))\n-\t\t   (mem:BLK (match_dup 1)))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 6))\n-\t      (clobber (match_dup 7))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (use (const_int 2))])]\n-\n-  \"\")\n-\n-(define_insn \"movstrsi_internal2\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\t;; source\n-   (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n-   (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n-   (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n-   (clobber (match_scratch:SI 7 \"=&d\"))\t\t\t;; temp 4\n-   (use (match_operand:SI 2 \"small_int\" \"I\"))\t\t;; # bytes to move\n-   (use (match_operand:SI 3 \"small_int\" \"I\"))\t\t;; alignment\n-   (use (const_int 1))]\t\t\t\t\t;; all but last store\n-  \"\"\n-  \"* return output_block_move (insn, operands, 4, BLOCK_MOVE_NOT_LAST);\"\n-  [(set_attr \"type\"\t\"store\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"80\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\t;; source\n-   (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n-   (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n-   (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n-   (clobber (match_scratch:SI 7 \"=&d\"))\t\t\t;; temp 4\n-   (use (match_operand:SI 2 \"small_int\" \"I\"))\t\t;; # bytes to move\n-   (use (match_operand:SI 3 \"small_int\" \"I\"))\t\t;; alignment\n-   (use (const_int 1))]\t\t\t\t\t;; all but last store\n-  \"TARGET_MIPS16\"\n-  \"* return output_block_move (insn, operands, 4, BLOCK_MOVE_NOT_LAST);\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"80\")])\n-\n-(define_insn \"movstrsi_internal3\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"m\"))\t;; source\n-   (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n-   (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n-   (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n-   (clobber (match_scratch:SI 7 \"=&d\"))\t\t\t;; temp 4\n-   (use (match_operand:SI 2 \"small_int\" \"I\"))\t\t;; # bytes to move\n-   (use (match_operand:SI 3 \"small_int\" \"I\"))\t\t;; alignment\n-   (use (const_int 2))]\t\t\t\t\t;; just last store of block move\n-  \"\"\n-  \"* return output_block_move (insn, operands, 4, BLOCK_MOVE_LAST);\"\n-  [(set_attr \"type\"\t\"store\")\n-   (set_attr \"mode\"\t\"none\")])\n+    else\n+      FAIL;\n+  })\n \f\n ;;\n ;;  ...................."}]}