{"sha": "e02c9d9116f243643c0daba8dbcc5d1795c827c3", "node_id": "C_kwDOANBUbNoAKGUwMmM5ZDkxMTZmMjQzNjQzYzBkYWJhOGRiY2M1ZDE3OTVjODI3YzM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-31T11:41:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-31T11:41:34Z"}, "message": "range-op-float, value-range: Fix up handling of UN{LT,LE,GT,GE,EQ}_EXPR and handle comparisons in get_tree_range [PR91645]\n\nWhen looking into PR91645, I've noticed we handle UN{LT,LE,GT,GE,EQ}_EXPR\ncomparisons incorrectly.\nAll those are unordered or ..., we correctly return [1, 1] if one or\nboth operands are known NANs, and correctly ask the non-UN prefixed\nop to fold_range if neither operand may be NAN.\nBut for the case where one or both operands may be NAN, we always\nreturn [0, 1].  The UN* fold_range tries to handle it by asking\nthe non-UN prefixed fold_range and if it returns [1, 1] return that,\nif it returns [0, 0] or [0, 1] return [0, 1], which makes sense,\nbecause the maybe NAN means that it is the non-UN prefixed fold_range\nunioned with [1, 1] in case the maybe NAN is actually NAN at runtime.\nThe problem is that the non-UN prefixed fold_range always returns [0, 1]\nbecause those fold_range implementations are like:\n  if (op1.known_isnan () || op2.known_isnan ())\n    r = range_false (type);\n  else if (!maybe_isnan (op1, op2))\n    {\n...\n    }\n  else\n    r = range_true_and_false (type);\nand so if maybe_isnan, they always return [0, 1].  Now, thinking about it,\nthis is unnecessary pessimization, for the case where the ... block\nreturns range_false (type) we actually could do it also if maybe_isnan (op1,\nop2), because if one or both operands are NAN, the comparison will be false,\nand if neither is NAN, the comparison will be also false.  Will fix\nincrementally today.\nAnyway, the following patch fixes it by asking the non-UN prefixed\nfold_range on ranges with NAN cleared, which I think does the right\nthing in all cases.\n\nAnother change in the patch is that range_query::get_tree_range\nalways returned VARYING for comparisons, this patch allows to ask about\nthose as well (they are very much like binary ops, except they take\nthe important type from the types of the operands rather than result).\n\nInitially I've developed this patch together with changes to tree-call-cdce.cc,\nbut those result in one regression and apparently aren't actually needed to\nfix this bug, the range-op-float.cc changes are enough.\n\n2023-03-31  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/91645\n\t* range-op-float.cc (foperator_unordered_lt::fold_range,\n\tfoperator_unordered_le::fold_range,\n\tfoperator_unordered_gt::fold_range,\n\tfoperator_unordered_ge::fold_range,\n\tfoperator_unordered_equal::fold_range): Call the ordered\n\tfold_range on ranges with cleared NaNs.\n\t* value-query.cc (range_query::get_tree_range): Handle also\n\tCOMPARISON_CLASS_P trees.\n\n\t* gcc.target/i386/pr103559-1.c: New test.\n\t* gcc.target/i386/pr103559-2.c: New test.\n\t* gcc.target/i386/pr103559-3.c: New test.\n\t* gcc.target/i386/pr103559-4.c: New test.", "tree": {"sha": "ac5c0989a3fece4c4db150f46bae708ccdf60b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac5c0989a3fece4c4db150f46bae708ccdf60b97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e02c9d9116f243643c0daba8dbcc5d1795c827c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02c9d9116f243643c0daba8dbcc5d1795c827c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02c9d9116f243643c0daba8dbcc5d1795c827c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02c9d9116f243643c0daba8dbcc5d1795c827c3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79d1e0b2c2b8ff4f4b1118549a80945faa1cb356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d1e0b2c2b8ff4f4b1118549a80945faa1cb356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d1e0b2c2b8ff4f4b1118549a80945faa1cb356"}], "stats": {"total": 114, "additions": 103, "deletions": 11}, "files": [{"sha": "cfcb9b0a5dbd436778cdacf25593eb1fc032b9dc", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=e02c9d9116f243643c0daba8dbcc5d1795c827c3", "patch": "@@ -1587,7 +1587,13 @@ class foperator_unordered_lt : public range_operator_float\n \tr = range_true (type);\n \treturn true;\n       }\n-    if (!fop_lt.fold_range (r, type, op1, op2, rel))\n+    frange op1_no_nan = op1;\n+    frange op2_no_nan = op2;\n+    if (op1.maybe_isnan ())\n+      op1_no_nan.clear_nan ();\n+    if (op2.maybe_isnan ())\n+      op2_no_nan.clear_nan ();\n+    if (!fop_lt.fold_range (r, type, op1_no_nan, op2_no_nan, rel))\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n@@ -1692,7 +1698,13 @@ class foperator_unordered_le : public range_operator_float\n \tr = range_true (type);\n \treturn true;\n       }\n-    if (!fop_le.fold_range (r, type, op1, op2, rel))\n+    frange op1_no_nan = op1;\n+    frange op2_no_nan = op2;\n+    if (op1.maybe_isnan ())\n+      op1_no_nan.clear_nan ();\n+    if (op2.maybe_isnan ())\n+      op2_no_nan.clear_nan ();\n+    if (!fop_le.fold_range (r, type, op1_no_nan, op2_no_nan, rel))\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n@@ -1793,7 +1805,13 @@ class foperator_unordered_gt : public range_operator_float\n \tr = range_true (type);\n \treturn true;\n       }\n-    if (!fop_gt.fold_range (r, type, op1, op2, rel))\n+    frange op1_no_nan = op1;\n+    frange op2_no_nan = op2;\n+    if (op1.maybe_isnan ())\n+      op1_no_nan.clear_nan ();\n+    if (op2.maybe_isnan ())\n+      op2_no_nan.clear_nan ();\n+    if (!fop_gt.fold_range (r, type, op1_no_nan, op2_no_nan, rel))\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n@@ -1898,7 +1916,13 @@ class foperator_unordered_ge : public range_operator_float\n \tr = range_true (type);\n \treturn true;\n       }\n-    if (!fop_ge.fold_range (r, type, op1, op2, rel))\n+    frange op1_no_nan = op1;\n+    frange op2_no_nan = op2;\n+    if (op1.maybe_isnan ())\n+      op1_no_nan.clear_nan ();\n+    if (op2.maybe_isnan ())\n+      op2_no_nan.clear_nan ();\n+    if (!fop_ge.fold_range (r, type, op1_no_nan, op2_no_nan, rel))\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs.\n@@ -2002,7 +2026,13 @@ class foperator_unordered_equal : public range_operator_float\n \tr = range_true (type);\n \treturn true;\n       }\n-    if (!fop_equal.fold_range (r, type, op1, op2, rel))\n+    frange op1_no_nan = op1;\n+    frange op2_no_nan = op2;\n+    if (op1.maybe_isnan ())\n+      op1_no_nan.clear_nan ();\n+    if (op2.maybe_isnan ())\n+      op2_no_nan.clear_nan ();\n+    if (!fop_equal.fold_range (r, type, op1_no_nan, op2_no_nan, rel))\n       return false;\n     // The result is the same as the ordered version when the\n     // comparison is true or when the operands cannot be NANs."}, {"sha": "f43aba1485380a7d87ff283fbd890af218bf4bdd", "filename": "gcc/testsuite/gcc.target/i386/pr103559-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-1.c?ref=e02c9d9116f243643c0daba8dbcc5d1795c827c3", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/103559 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump \" = .SQRT \\\\\\(\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \" = sqrtf \\\\\\(\" \"optimized\" } } */\n+\n+float sqrtf (float);\n+\n+float\n+foo (float x)\n+{\n+  return sqrtf (x);\n+}"}, {"sha": "304031b677cb46b0e7e9f0f6c120fe567a1c6049", "filename": "gcc/testsuite/gcc.target/i386/pr103559-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-2.c?ref=e02c9d9116f243643c0daba8dbcc5d1795c827c3", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/103559 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump \" = .SQRT \\\\\\(\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" = sqrtf \\\\\\(\" \"optimized\" } } */\n+\n+float sqrtf (float);\n+\n+float\n+foo (float x)\n+{\n+  if (__builtin_isless (x, 0))\n+    __builtin_unreachable ();\n+  return sqrtf (x);\n+}"}, {"sha": "862990ade880d2e5d55efb829608e51eb29af89e", "filename": "gcc/testsuite/gcc.target/i386/pr103559-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-3.c?ref=e02c9d9116f243643c0daba8dbcc5d1795c827c3", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/103559 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" = .SQRT \\\\\\(\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \" = sqrtf \\\\\\(\" \"optimized\" } } */\n+\n+float sqrtf (float);\n+\n+float\n+foo (float x)\n+{\n+  if (!__builtin_isless (x, 0))\n+    __builtin_unreachable ();\n+  return sqrtf (x);\n+}"}, {"sha": "ec22b564d5397e20cdc059742be06188c656290a", "filename": "gcc/testsuite/gcc.target/i386/pr103559-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103559-4.c?ref=e02c9d9116f243643c0daba8dbcc5d1795c827c3", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/103559 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" = sqrtf \\\\\\(\" \"optimized\" } } */\n+\n+float sqrtf (float);\n+\n+float\n+foo (float x)\n+{\n+  x = x * x;\n+  return sqrtf (x);\n+}"}, {"sha": "50128502102dfbee717ea29d87107d9fd3658ae9", "filename": "gcc/value-query.cc", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c9d9116f243643c0daba8dbcc5d1795c827c3/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=e02c9d9116f243643c0daba8dbcc5d1795c827c3", "patch": "@@ -230,15 +230,21 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n     default:\n       break;\n     }\n-  if (BINARY_CLASS_P (expr))\n+  if (BINARY_CLASS_P (expr) || COMPARISON_CLASS_P (expr))\n     {\n-      range_op_handler op (TREE_CODE (expr), type);\n+      tree op0 = TREE_OPERAND (expr, 0);\n+      tree op1 = TREE_OPERAND (expr, 1);\n+      if (COMPARISON_CLASS_P (expr)\n+\t  && !Value_Range::supports_type_p (TREE_TYPE (op0)))\n+\treturn false;\n+      range_op_handler op (TREE_CODE (expr),\n+\t\t\t   BINARY_CLASS_P (expr) ? type : TREE_TYPE (op0));\n       if (op)\n \t{\n-\t  Value_Range r0 (TREE_TYPE (TREE_OPERAND (expr, 0)));\n-\t  Value_Range r1 (TREE_TYPE (TREE_OPERAND (expr, 1)));\n-\t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n-\t  range_of_expr (r1, TREE_OPERAND (expr, 1), stmt);\n+\t  Value_Range r0 (TREE_TYPE (op0));\n+\t  Value_Range r1 (TREE_TYPE (op1));\n+\t  range_of_expr (r0, op0, stmt);\n+\t  range_of_expr (r1, op1, stmt);\n \t  if (!op.fold_range (r, type, r0, r1))\n \t    r.set_varying (type);\n \t}"}]}