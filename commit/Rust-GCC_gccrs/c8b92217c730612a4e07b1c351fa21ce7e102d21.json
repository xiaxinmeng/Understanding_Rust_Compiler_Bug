{"sha": "c8b92217c730612a4e07b1c351fa21ce7e102d21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhiOTIyMTdjNzMwNjEyYTRlMDdiMWMzNTFmYTIxY2U3ZTEwMmQyMQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-12-13T10:26:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:26:41Z"}, "message": "exp_intr.adb (Expand_Dispatching_Constructor_Call): Add missing support for generic dispatching constructor calls in which we need...\n\n2007-12-06  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_intr.adb (Expand_Dispatching_Constructor_Call): Add missing\n\tsupport for generic dispatching constructor calls in which we need to\n\tlocate the tag of a secondary dispatch table associated with an\n\tinterface type to properly dispatch the call.\n\t(Expand_N_Attribute_Reference [case Address],\n\tExpand_Dispatching_Constructor_Call, Expand_Unc_Deallocation): Fix\n\thandling of VM targets.\n\nFrom-SVN: r130837", "tree": {"sha": "54d3921a3ebaac0fa1069be52ec9f8fca4b3925b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54d3921a3ebaac0fa1069be52ec9f8fca4b3925b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8b92217c730612a4e07b1c351fa21ce7e102d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b92217c730612a4e07b1c351fa21ce7e102d21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8b92217c730612a4e07b1c351fa21ce7e102d21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b92217c730612a4e07b1c351fa21ce7e102d21/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38386aaec109fea3f18074d81894ae16452e47ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38386aaec109fea3f18074d81894ae16452e47ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38386aaec109fea3f18074d81894ae16452e47ff"}], "stats": {"total": 61, "additions": 49, "deletions": 12}, "files": [{"sha": "96e8c2c3acf249b0a6d90a3c423f35367ed47bf8", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8b92217c730612a4e07b1c351fa21ce7e102d21/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8b92217c730612a4e07b1c351fa21ce7e102d21/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=c8b92217c730612a4e07b1c351fa21ce7e102d21", "patch": "@@ -51,6 +51,7 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -136,8 +137,9 @@ package body Exp_Intr is\n       Inst_Pkg   : constant Node_Id    := Parent (Subp_Decl);\n       Act_Rename : Node_Id;\n       Act_Constr : Entity_Id;\n-      Result_Typ : Entity_Id;\n+      Iface_Tag  : Node_Id := Empty;\n       Cnstr_Call : Node_Id;\n+      Result_Typ : Entity_Id;\n \n    begin\n       --  The subprogram is the third actual in the instantiation, and is\n@@ -159,6 +161,30 @@ package body Exp_Intr is\n \n       if Is_Interface (Etype (Act_Constr)) then\n          Set_Etype (Act_Constr, Result_Typ);\n+\n+         --  If the result type is not parent of Tag_Arg then we need to\n+         --  locate the tag of the secondary dispatch table.\n+\n+         if not Is_Parent (Etype (Result_Typ), Etype (Tag_Arg)) then\n+            pragma Assert (not Is_Interface (Etype (Tag_Arg)));\n+\n+            Iface_Tag :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, New_Internal_Name ('V')),\n+                Object_Definition =>\n+                  New_Reference_To (RTE (RE_Tag), Loc),\n+                Expression =>\n+                  Make_Function_Call (Loc,\n+                    Name => New_Reference_To (RTE (RE_Secondary_Tag), Loc),\n+                    Parameter_Associations => New_List (\n+                      Relocate_Node (Tag_Arg),\n+                      New_Reference_To\n+                        (Node (First_Elmt (Access_Disp_Table\n+                                            (Etype (Etype (Act_Constr))))),\n+                         Loc))));\n+            Insert_Action (N, Iface_Tag);\n+         end if;\n       end if;\n \n       --  Create the call to the actual Constructor function\n@@ -173,8 +199,14 @@ package body Exp_Intr is\n       --  should be generated now, to prevent out-of-order insertions during\n       --  the expansion of that call when stack-checking is enabled.\n \n-      Remove_Side_Effects (Tag_Arg);\n-      Set_Controlling_Argument (Cnstr_Call, Relocate_Node (Tag_Arg));\n+      if Present (Iface_Tag) then\n+         Set_Controlling_Argument (Cnstr_Call,\n+           New_Occurrence_Of (Defining_Identifier (Iface_Tag), Loc));\n+      else\n+         Remove_Side_Effects (Tag_Arg);\n+         Set_Controlling_Argument (Cnstr_Call,\n+           Relocate_Node (Tag_Arg));\n+      end if;\n \n       --  Rewrite and analyze the call to the instance as a class-wide\n       --  conversion of the call to the actual constructor.\n@@ -183,9 +215,11 @@ package body Exp_Intr is\n       Analyze_And_Resolve (N, Etype (Act_Constr));\n \n       --  Do not generate a run-time check on the built object if tag\n-      --  checks are suppressed for the result type.\n+      --  checks are suppressed for the result type or VM_Target /= No_VM\n \n-      if Tag_Checks_Suppressed (Etype (Result_Typ)) then\n+      if Tag_Checks_Suppressed (Etype (Result_Typ))\n+        or else VM_Target /= No_VM\n+      then\n          null;\n \n       --  Generate a class-wide membership test to ensure that the call's tag\n@@ -225,7 +259,7 @@ package body Exp_Intr is\n                     Name => New_Occurrence_Of (RTE (RE_IW_Membership), Loc),\n                     Parameter_Associations => New_List (\n                       Make_Attribute_Reference (Loc,\n-                        Prefix => Duplicate_Subexpr (Tag_Arg),\n+                        Prefix         => Duplicate_Subexpr (Tag_Arg),\n                         Attribute_Name => Name_Address),\n \n                       New_Reference_To (\n@@ -345,8 +379,8 @@ package body Exp_Intr is\n       Rewrite (N,\n         Unchecked_Convert_To (Etype (Ent),\n           Make_Attribute_Reference (Loc,\n-            Attribute_Name => Name_Address,\n-            Prefix => Make_Identifier (Loc, Chars (Dum)))));\n+            Prefix         => Make_Identifier (Loc, Chars (Dum)),\n+            Attribute_Name => Name_Address)));\n \n       Analyze_And_Resolve (N, Etype (Ent));\n    end Expand_Import_Call;\n@@ -992,12 +1026,15 @@ package body Exp_Intr is\n \n       --  Ada 2005 (AI-251): In case of abstract interface type we must\n       --  displace the pointer to reference the base of the object to\n-      --  deallocate its memory.\n+      --  deallocate its memory, unless we're targetting a VM, in which case\n+      --  no special processing is required.\n \n       --  Generate:\n       --    free (Base_Address (Obj_Ptr))\n \n-      if Is_Interface (Directly_Designated_Type (Typ)) then\n+      if Is_Interface (Directly_Designated_Type (Typ))\n+        and then VM_Target = No_VM\n+      then\n          Set_Expression (Free_Node,\n            Unchecked_Convert_To (Typ,\n              Make_Function_Call (Loc,\n@@ -1083,8 +1120,8 @@ package body Exp_Intr is\n               Right_Opnd => Make_Null (Loc)),\n             New_Occurrence_Of (RTE (RE_Null_Address), Loc),\n             Make_Attribute_Reference (Loc,\n-              Attribute_Name => Name_Address,\n-              Prefix => Obj))));\n+              Prefix         => Obj,\n+              Attribute_Name => Name_Address))));\n \n       Analyze_And_Resolve (N, RTE (RE_Address));\n    end Expand_To_Address;"}]}