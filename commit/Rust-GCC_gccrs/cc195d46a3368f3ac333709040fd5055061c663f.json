{"sha": "cc195d46a3368f3ac333709040fd5055061c663f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MxOTVkNDZhMzM2OGYzYWMzMzM3MDkwNDBmZDUwNTUwNjFjNjYzZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-03-03T19:32:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-03-03T19:32:01Z"}, "message": "re PR middle-end/79805 (ICE (verify_flow_info failed) with -fnon-call-exceptions -O)\n\n\tPR middle-end/79805\n\t* internal-fn.def (ATOMIC_BIT_TEST_AND_SET, ATOMIC_BIT_TEST_AND_RESET,\n\tATOMIC_BIT_TEST_AND_COMPLEMENT, ATOMIC_COMPARE_EXCHANGE): Remove\n\tECF_NOTHROW.\n\t* gimple-fold.c (fold_builtin_atomic_compare_exchange): Set\n\tgimple_call_nothrow_p flag based on whether original builtin can throw.\n\tIf it can, emit following stmts on the fallthrough edge.\n\t* tree-ssa-ccp.c (optimize_atomic_bit_test_and): Similarly, except\n\tdon't create new bb if inserting just debug stmts on the edge, try to\n\tinsert them on the fallthru bb or just reset debug stmts.\n\n\t* g++.dg/opt/pr79805.C: New test.\n\nFrom-SVN: r245882", "tree": {"sha": "850d9624575d4fb7c5cae0530b162295dd6d438e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/850d9624575d4fb7c5cae0530b162295dd6d438e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc195d46a3368f3ac333709040fd5055061c663f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc195d46a3368f3ac333709040fd5055061c663f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc195d46a3368f3ac333709040fd5055061c663f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc195d46a3368f3ac333709040fd5055061c663f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f325c4567336a2e5c9643e7adb3a152d22022d7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f325c4567336a2e5c9643e7adb3a152d22022d7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f325c4567336a2e5c9643e7adb3a152d22022d7d"}], "stats": {"total": 334, "additions": 312, "deletions": 22}, "files": [{"sha": "ad56f705e787f7067592127b5cb020785d6551c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc195d46a3368f3ac333709040fd5055061c663f", "patch": "@@ -1,3 +1,16 @@\n+2017-03-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/79805\n+\t* internal-fn.def (ATOMIC_BIT_TEST_AND_SET, ATOMIC_BIT_TEST_AND_RESET,\n+\tATOMIC_BIT_TEST_AND_COMPLEMENT, ATOMIC_COMPARE_EXCHANGE): Remove\n+\tECF_NOTHROW.\n+\t* gimple-fold.c (fold_builtin_atomic_compare_exchange): Set\n+\tgimple_call_nothrow_p flag based on whether original builtin can throw.\n+\tIf it can, emit following stmts on the fallthrough edge.\n+\t* tree-ssa-ccp.c (optimize_atomic_bit_test_and): Similarly, except\n+\tdon't create new bb if inserting just debug stmts on the edge, try to\n+\tinsert them on the fallthru bb or just reset debug stmts.\n+\n 2017-03-03  Segher Boesssenkool  <segher@kernel.crashing.org>\n \n \tPR target/43763"}, {"sha": "9fd45d103a4e18614fba5287a53a55283d20f0f7", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=cc195d46a3368f3ac333709040fd5055061c663f", "patch": "@@ -3533,6 +3533,8 @@ fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *gsi)\n   tree itype = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (parmt)));\n   tree ctype = build_complex_type (itype);\n   tree expected = TREE_OPERAND (gimple_call_arg (stmt, 1), 0);\n+  bool throws = false;\n+  edge e = NULL;\n   gimple *g = gimple_build_assign (make_ssa_name (TREE_TYPE (expected)),\n \t\t\t\t   expected);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n@@ -3558,19 +3560,39 @@ fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *gsi)\n   gimple_set_vdef (g, gimple_vdef (stmt));\n   gimple_set_vuse (g, gimple_vuse (stmt));\n   SSA_NAME_DEF_STMT (gimple_vdef (g)) = g;\n-  if (gimple_call_lhs (stmt))\n+  tree oldlhs = gimple_call_lhs (stmt);\n+  if (stmt_can_throw_internal (stmt))\n+    {\n+      throws = true;\n+      e = find_fallthru_edge (gsi_bb (*gsi)->succs);\n+    }\n+  gimple_call_set_nothrow (as_a <gcall *> (g),\n+\t\t\t   gimple_call_nothrow_p (as_a <gcall *> (stmt)));\n+  gimple_call_set_lhs (stmt, NULL_TREE);\n+  gsi_replace (gsi, g, true);\n+  if (oldlhs)\n     {\n-      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n       g = gimple_build_assign (make_ssa_name (itype), IMAGPART_EXPR,\n \t\t\t       build1 (IMAGPART_EXPR, itype, lhs));\n-      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n-      g = gimple_build_assign (gimple_call_lhs (stmt), NOP_EXPR,\n-\t\t\t       gimple_assign_lhs (g));\n+      if (throws)\n+\t{\n+\t  gsi_insert_on_edge_immediate (e, g);\n+\t  *gsi = gsi_for_stmt (g);\n+\t}\n+      else\n+\tgsi_insert_after (gsi, g, GSI_NEW_STMT);\n+      g = gimple_build_assign (oldlhs, NOP_EXPR, gimple_assign_lhs (g));\n+      gsi_insert_after (gsi, g, GSI_NEW_STMT);\n     }\n-  gsi_replace (gsi, g, true);\n   g = gimple_build_assign (make_ssa_name (itype), REALPART_EXPR,\n \t\t\t   build1 (REALPART_EXPR, itype, lhs));\n-  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+  if (throws && oldlhs == NULL_TREE)\n+    {\n+      gsi_insert_on_edge_immediate (e, g);\n+      *gsi = gsi_for_stmt (g);\n+    }\n+  else\n+    gsi_insert_after (gsi, g, GSI_NEW_STMT);\n   if (!useless_type_conversion_p (TREE_TYPE (expected), itype))\n     {\n       g = gimple_build_assign (make_ssa_name (TREE_TYPE (expected)),"}, {"sha": "2ba69c93ca784b62b65633832fa81e6bf02558c5", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=cc195d46a3368f3ac333709040fd5055061c663f", "patch": "@@ -205,11 +205,13 @@ DEF_INTERNAL_FN (GOACC_TILE, ECF_NOTHROW | ECF_LEAF, NULL)\n    current target.  */\n DEF_INTERNAL_FN (SET_EDOM, ECF_LEAF | ECF_NOTHROW, NULL)\n \n-/* Atomic functions.  */\n-DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_SET, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_COMPLEMENT, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_RESET, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (ATOMIC_COMPARE_EXCHANGE, ECF_LEAF | ECF_NOTHROW, NULL)\n+/* Atomic functions.  These don't have ECF_NOTHROW because for\n+   -fnon-call-exceptions they can throw, otherwise we set\n+   gimple_call_nothrow_p on it.  */\n+DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_SET, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_COMPLEMENT, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_RESET, ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (ATOMIC_COMPARE_EXCHANGE, ECF_LEAF, NULL)\n \n /* To implement [[fallthrough]].  */\n DEF_INTERNAL_FN (FALLTHROUGH, ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "522af63f0fb8d68bd6d16303894672cff6e2e4ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc195d46a3368f3ac333709040fd5055061c663f", "patch": "@@ -1,3 +1,8 @@\n+2017-03-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/79805\n+\t* g++.dg/opt/pr79805.C: New test.\n+\n 2017-03-03  Andrew Senkevich  <andrew.senkevich@intel.com>\n \n \t* gcc.target/i386/avx512vpopcntdq-check.h: New."}, {"sha": "728564ed88374e6364fa8f72e690c82b57b50272", "filename": "gcc/testsuite/g++.dg/opt/pr79805.C", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr79805.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr79805.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr79805.C?ref=cc195d46a3368f3ac333709040fd5055061c663f", "patch": "@@ -0,0 +1,219 @@\n+// PR middle-end/79805\n+// { dg-do compile }\n+// { dg-options \"-O2 -fnon-call-exceptions\" }\n+\n+struct A { A (); ~A (); };\n+\n+void bar (void);\n+\n+int\n+f0 (int *d, int f)\n+{\n+  A z;\n+  int e = __atomic_compare_exchange_n (d, &f, 1, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  return e;\n+}\n+\n+int\n+f1 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  return (__sync_fetch_and_or (a, mask) & mask) != 0;\n+}\n+\n+int\n+f2 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  unsigned int t1 = __atomic_fetch_or (a, mask, __ATOMIC_RELAXED);\n+  unsigned int t2 = t1 & mask;\n+  return t2 != 0;\n+}\n+\n+long int\n+f3 (long int *a, int bit)\n+{\n+  A z;\n+  unsigned long int mask = (1ul << bit);\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_SEQ_CST) & mask) == 0;\n+}\n+\n+int\n+f4 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 7);\n+  return (__sync_fetch_and_or (a, mask) & mask) != 0;\n+}\n+\n+int\n+f5 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 13);\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+int\n+f6 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 0);\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+void\n+f7 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  if ((__sync_fetch_and_xor (a, mask) & mask) != 0)\n+    bar ();\n+}\n+\n+void\n+f8 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  if ((__atomic_fetch_xor (a, mask, __ATOMIC_RELAXED) & mask) == 0)\n+    bar ();\n+}\n+\n+int\n+f9 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+int\n+f10 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 7);\n+  return (__sync_fetch_and_xor (a, mask) & mask) != 0;\n+}\n+\n+int\n+f11 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 13);\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+int\n+f12 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 0);\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+int\n+f13 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  return (__sync_fetch_and_and (a, ~mask) & mask) != 0;\n+}\n+\n+int\n+f14 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+int\n+f15 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+int\n+f16 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 7);\n+  return (__sync_fetch_and_and (a, ~mask) & mask) != 0;\n+}\n+\n+int\n+f17 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 13);\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+int\n+f18 (int *a)\n+{\n+  A z;\n+  unsigned int mask = (1u << 0);\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+unsigned long int\n+f19 (unsigned long int *a, int bit)\n+{\n+  A z;\n+  unsigned long int mask = (1ul << bit);\n+  return (__atomic_xor_fetch (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+unsigned long int\n+f20 (unsigned long int *a)\n+{\n+  A z;\n+  unsigned long int mask = (1ul << 7);\n+  return (__atomic_xor_fetch (a, mask, __ATOMIC_SEQ_CST) & mask) == 0;\n+}\n+\n+int\n+f21 (int *a, int bit)\n+{\n+  A z;\n+  unsigned int mask = (1u << bit);\n+  return (__sync_fetch_and_or (a, mask) & mask);\n+}\n+\n+unsigned long int\n+f22 (unsigned long int *a)\n+{\n+  A z;\n+  unsigned long int mask = (1ul << 7);\n+  return (__atomic_xor_fetch (a, mask, __ATOMIC_SEQ_CST) & mask);\n+}\n+\n+unsigned long int\n+f23 (unsigned long int *a)\n+{\n+  A z;\n+  unsigned long int mask = (1ul << 7);\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_SEQ_CST) & mask);\n+}\n+\n+unsigned short int\n+f24 (unsigned short int *a)\n+{\n+  A z;\n+  unsigned short int mask = (1u << 7);\n+  return (__sync_fetch_and_or (a, mask) & mask) != 0;\n+}\n+\n+unsigned short int\n+f25 (unsigned short int *a)\n+{\n+  A z;\n+  unsigned short int mask = (1u << 7);\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}"}, {"sha": "cd238242c015f08a00958e3d1147f95070a28007", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc195d46a3368f3ac333709040fd5055061c663f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=cc195d46a3368f3ac333709040fd5055061c663f", "patch": "@@ -2890,9 +2890,19 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   gimple_set_location (g, gimple_location (call));\n   gimple_set_vuse (g, gimple_vuse (call));\n   gimple_set_vdef (g, gimple_vdef (call));\n+  bool throws = stmt_can_throw_internal (call);\n+  gimple_call_set_nothrow (as_a <gcall *> (g),\n+\t\t\t   gimple_call_nothrow_p (as_a <gcall *> (call)));\n   SSA_NAME_DEF_STMT (gimple_vdef (call)) = g;\n   gimple_stmt_iterator gsi = *gsip;\n   gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+  edge e = NULL;\n+  if (throws)\n+    {\n+      maybe_clean_or_replace_eh_stmt (call, g);\n+      if (after || (use_bool && has_debug_uses))\n+\te = find_fallthru_edge (gsi_bb (gsi)->succs);\n+    }\n   if (after)\n     {\n       /* The internal function returns the value of the specified bit\n@@ -2905,23 +2915,42 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t\t\t       use_bool ? build_int_cst (TREE_TYPE (lhs), 1)\n \t\t\t\t\t: mask);\n       new_lhs = gimple_assign_lhs (g);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      if (throws)\n+\t{\n+\t  gsi_insert_on_edge_immediate (e, g);\n+\t  gsi = gsi_for_stmt (g);\n+\t}\n+      else\n+\tgsi_insert_after (&gsi, g, GSI_NEW_STMT);\n     }\n   if (use_bool && has_debug_uses)\n     {\n-      tree temp = make_node (DEBUG_EXPR_DECL);\n-      DECL_ARTIFICIAL (temp) = 1;\n-      TREE_TYPE (temp) = TREE_TYPE (lhs);\n-      SET_DECL_MODE (temp, TYPE_MODE (TREE_TYPE (lhs)));\n-      tree t = build2 (LSHIFT_EXPR, TREE_TYPE (lhs), new_lhs, bit);\n-      g = gimple_build_debug_bind (temp, t, g);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      tree temp = NULL_TREE;\n+      if (!throws || after || single_pred_p (e->dest))\n+\t{\n+\t  temp = make_node (DEBUG_EXPR_DECL);\n+\t  DECL_ARTIFICIAL (temp) = 1;\n+\t  TREE_TYPE (temp) = TREE_TYPE (lhs);\n+\t  SET_DECL_MODE (temp, TYPE_MODE (TREE_TYPE (lhs)));\n+\t  tree t = build2 (LSHIFT_EXPR, TREE_TYPE (lhs), new_lhs, bit);\n+\t  g = gimple_build_debug_bind (temp, t, g);\n+\t  if (throws && !after)\n+\t    {\n+\t      gsi = gsi_after_labels (e->dest);\n+\t      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t    }\n+\t  else\n+\t    gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t}\n       FOR_EACH_IMM_USE_STMT (g, iter, use_lhs)\n \tif (is_gimple_debug (g))\n \t  {\n \t    use_operand_p use_p;\n-\t    FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t      SET_USE (use_p, temp);\n+\t    if (temp == NULL_TREE)\n+\t      gimple_debug_bind_reset_value (g);\n+\t    else\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\tSET_USE (use_p, temp);\n \t    update_stmt (g);\n \t  }\n     }"}]}