{"sha": "d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU1OWQ1YzY4NmYyZGIzZmVkYzJjMmIxZWM2YTcwMjdjMDNiNzcyZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T12:35:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T12:35:08Z"}, "message": "adaint.c, [...]: Use Windows ACL to deal with file attributes.\n\n2008-08-04  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c, s-os_lib.adb, s-os_lib.ads: Use Windows ACL to deal with\n\tfile attributes.\n\nFrom-SVN: r138613", "tree": {"sha": "4f87dac202e6aafa0b52499817b743d57f1625d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f87dac202e6aafa0b52499817b743d57f1625d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/comments", "author": null, "committer": null, "parents": [{"sha": "a0ac393230b56069de1b28b7fea89ac0dfc708e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ac393230b56069de1b28b7fea89ac0dfc708e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ac393230b56069de1b28b7fea89ac0dfc708e2"}], "stats": {"total": 228, "additions": 220, "deletions": 8}, "files": [{"sha": "fcdd17e1dc14837d87c94b58c8e5a53001aec858", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "patch": "@@ -1,3 +1,12 @@\n+2008-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_res.adb: (Large_Storage_Type): Improve previous change.\n+\n+2008-08-04  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c, s-os_lib.adb, s-os_lib.ads: Use Windows ACL to deal with\n+\tfile attributes.\n+\n 2008-08-04  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch3.adb (Access_Subprogram_Declaration): Adding missing support"}, {"sha": "a6718bd1fa1661583a0dd77184e35b9ba072769c", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 182, "deletions": 7, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "patch": "@@ -187,6 +187,8 @@ struct vstring\n #if defined (_WIN32)\n #include <dir.h>\n #include <windows.h>\n+#include <accctrl.h>\n+#include <aclapi.h>\n #undef DIR_SEPARATOR\n #define DIR_SEPARATOR '\\\\'\n #endif\n@@ -1512,10 +1514,6 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n #endif\n }\n \n-#ifdef _WIN32\n-#include <windows.h>\n-#endif\n-\n /* Get the list of installed standard libraries from the\n    HKEY_LOCAL_MACHINE\\SOFTWARE\\Ada Core Technologies\\GNAT\\Standard Libraries\n    key.  */\n@@ -1685,34 +1683,207 @@ __gnat_is_directory (char *name)\n   return (!ret && S_ISDIR (statbuf.st_mode));\n }\n \n+#if defined (_WIN32) && !defined (RTX)\n+/*  This MingW section contains code to work with ACL. */\n+static int\n+__gnat_check_OWNER_ACL\n+(char *name,\n+ DWORD CheckAccessDesired,\n+ GENERIC_MAPPING CheckGenericMapping)\n+{\n+  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+  DWORD dwAccessDesired, dwAccessAllowed;\n+  PRIVILEGE_SET PrivilegeSet;\n+  DWORD dwPrivSetSize = sizeof (PRIVILEGE_SET);\n+  BOOL fAccessGranted = FALSE;\n+  HANDLE hToken;\n+  DWORD nLength;\n+  SECURITY_DESCRIPTOR* pSD = NULL;\n+\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+\n+  GetFileSecurity\n+    (wname, OWNER_SECURITY_INFORMATION |\n+     GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,\n+     NULL, 0, &nLength);\n+\n+  if ((pSD = (PSECURITY_DESCRIPTOR) HeapAlloc\n+       (GetProcessHeap (), HEAP_ZERO_MEMORY, nLength)) == NULL)\n+    return 0;\n+\n+  /* Obtain the security descriptor. */\n+\n+  if (!GetFileSecurity\n+      (wname, OWNER_SECURITY_INFORMATION |\n+       GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,\n+       pSD, nLength, &nLength))\n+    return 0;\n+\n+  if (!ImpersonateSelf (SecurityImpersonation))\n+    return 0;\n+\n+  if (!OpenThreadToken\n+      (GetCurrentThread(), TOKEN_DUPLICATE | TOKEN_QUERY, FALSE, &hToken))\n+    return 0;\n+\n+  /*  Undoes the effect of ImpersonateSelf. */\n+\n+  RevertToSelf ();\n+\n+  /*  We want to test for write permissions. */\n+\n+  dwAccessDesired = CheckAccessDesired;\n+\n+  MapGenericMask (&dwAccessDesired, &CheckGenericMapping);\n+\n+  if (!AccessCheck\n+      (pSD ,                 /* security descriptor to check */\n+       hToken,               /* impersonation token */\n+       dwAccessDesired,      /* requested access rights */\n+       &CheckGenericMapping, /* pointer to GENERIC_MAPPING */\n+       &PrivilegeSet,        /* receives privileges used in check */\n+       &dwPrivSetSize,       /* size of PrivilegeSet buffer */\n+       &dwAccessAllowed,     /* receives mask of allowed access rights */\n+       &fAccessGranted))\n+    return 0;\n+\n+  return fAccessGranted;\n+}\n+\n+static void\n+__gnat_set_OWNER_ACL\n+(char *name,\n+ DWORD AccessMode,\n+ DWORD AccessPermissions)\n+{\n+  ACL* pOldDACL = NULL;\n+  ACL* pNewDACL = NULL;\n+  SECURITY_DESCRIPTOR* pSD = NULL;\n+  EXPLICIT_ACCESS ea;\n+  TCHAR username [100];\n+  DWORD unsize = 100;\n+\n+  TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n+\n+  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+\n+  HANDLE file = CreateFile\n+    (wname, READ_CONTROL | WRITE_DAC, 0, NULL,\n+     OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+\n+  if (file == INVALID_HANDLE_VALUE)\n+    return;\n+\n+  /*  Get current user, he will act as the owner */\n+\n+  if (!GetUserName (username, &unsize))\n+    return;\n+\n+  if (GetSecurityInfo\n+      (file,\n+       SE_FILE_OBJECT,\n+       DACL_SECURITY_INFORMATION,\n+       NULL, NULL, &pOldDACL, NULL, &pSD) != ERROR_SUCCESS)\n+    return;\n+\n+  ZeroMemory (&ea, sizeof (EXPLICIT_ACCESS));\n+\n+  ea.grfAccessMode = AccessMode;\n+  ea.grfAccessPermissions = AccessPermissions;\n+  ea.grfInheritance = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;\n+  ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n+  ea.Trustee.TrusteeType = TRUSTEE_IS_USER;\n+  ea.Trustee.ptstrName = username;\n+\n+  if (AccessMode == SET_ACCESS)\n+    {\n+      /*  SET_ACCESS, we want to set an explicte set of permissions, do not\n+\t  merge with current DACL.  */\n+      if (SetEntriesInAcl (1, &ea, NULL, &pNewDACL) != ERROR_SUCCESS)\n+\treturn;\n+    }\n+  else\n+    if (SetEntriesInAcl (1, &ea, pOldDACL, &pNewDACL) != ERROR_SUCCESS)\n+      return;\n+\n+  if (SetSecurityInfo\n+      (file, SE_FILE_OBJECT,\n+       DACL_SECURITY_INFORMATION, NULL, NULL, pNewDACL, NULL) != ERROR_SUCCESS)\n+    return;\n+\n+  LocalFree (pSD);\n+  LocalFree (pNewDACL);\n+  CloseHandle (file);\n+}\n+#endif /* defined (_WIN32) && !defined (RTX) */\n+\n int\n __gnat_is_readable_file (char *name)\n {\n+#if defined (_WIN32) && !defined (RTX)\n+  GENERIC_MAPPING GenericMapping;\n+  ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+  GenericMapping.GenericRead = GENERIC_READ;\n+\n+  return __gnat_check_OWNER_ACL (name, FILE_READ_DATA, GenericMapping);\n+#else\n   int ret;\n   int mode;\n   struct stat statbuf;\n \n   ret = __gnat_stat (name, &statbuf);\n   mode = statbuf.st_mode & S_IRUSR;\n   return (!ret && mode);\n+#endif\n }\n \n int\n __gnat_is_writable_file (char *name)\n {\n+#if defined (_WIN32) && !defined (RTX)\n+  GENERIC_MAPPING GenericMapping;\n+  ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+  GenericMapping.GenericWrite = GENERIC_WRITE;\n+\n+  return __gnat_check_OWNER_ACL\n+    (name, FILE_WRITE_DATA | FILE_APPEND_DATA, GenericMapping);\n+#else\n   int ret;\n   int mode;\n   struct stat statbuf;\n \n   ret = __gnat_stat (name, &statbuf);\n   mode = statbuf.st_mode & S_IWUSR;\n   return (!ret && mode);\n+#endif\n+}\n+\n+int\n+__gnat_is_executable_file (char *name)\n+{\n+#if defined (_WIN32) && !defined (RTX)\n+  GENERIC_MAPPING GenericMapping;\n+  ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n+  GenericMapping.GenericExecute = GENERIC_EXECUTE;\n+\n+  return __gnat_check_OWNER_ACL (name, FILE_EXECUTE, GenericMapping);\n+#else\n+  int ret;\n+  int mode;\n+  struct stat statbuf;\n+\n+  ret = __gnat_stat (name, &statbuf);\n+  mode = statbuf.st_mode & S_IXUSR;\n+  return (!ret && mode);\n+#endif\n }\n \n void\n __gnat_set_writable (char *name)\n {\n-#if ! defined (__vxworks) && ! defined(__nucleus__)\n+#if defined (_WIN32) && !defined (RTX)\n+  __gnat_set_OWNER_ACL (name, GRANT_ACCESS, GENERIC_WRITE);\n+#elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n   if (stat (name, &statbuf) == 0)\n@@ -1726,7 +1897,9 @@ __gnat_set_writable (char *name)\n void\n __gnat_set_executable (char *name)\n {\n-#if ! defined (__vxworks) && ! defined(__nucleus__)\n+#if defined (_WIN32) && !defined (RTX)\n+  __gnat_set_OWNER_ACL (name, GRANT_ACCESS, GENERIC_EXECUTE);\n+#elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n   if (stat (name, &statbuf) == 0)\n@@ -1740,7 +1913,9 @@ __gnat_set_executable (char *name)\n void\n __gnat_set_readonly (char *name)\n {\n-#if ! defined (__vxworks) && ! defined(__nucleus__)\n+#if defined (_WIN32) && !defined (RTX)\n+  __gnat_set_OWNER_ACL (name, SET_ACCESS, GENERIC_READ);\n+#elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n   if (stat (name, &statbuf) == 0)"}, {"sha": "ca19e5a973f449058c3015641d3d28cf53e97f6c", "filename": "gcc/ada/s-os_lib.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "patch": "@@ -1316,6 +1316,25 @@ package body System.OS_Lib is\n       return Is_Readable_File (F_Name'Address);\n    end Is_Readable_File;\n \n+   ------------------------\n+   -- Is_Executable_File --\n+   ------------------------\n+\n+   function Is_Executable_File (Name : C_File_Name) return Boolean is\n+      function Is_Executable_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Executable_File, \"__gnat_is_executable_file\");\n+   begin\n+      return Is_Executable_File (Name) /= 0;\n+   end Is_Executable_File;\n+\n+   function Is_Executable_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Executable_File (F_Name'Address);\n+   end Is_Executable_File;\n+\n    ---------------------\n    -- Is_Regular_File --\n    ---------------------"}, {"sha": "f841558627ffd654f6dd283971857e773aaa1fb5", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d559d5c686f2db3fedc2c2b1ec6a7027c03b772e/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=d559d5c686f2db3fedc2c2b1ec6a7027c03b772e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -472,6 +472,14 @@ package System.OS_Lib is\n    --  not actually be readable due to some other process having exclusive\n    --  access.\n \n+   function Is_Executable_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing file\n+   --  that is executable. Returns True if so, False otherwise. Note that this\n+   --  function simply interrogates the file attributes (e.g. using the C\n+   --  function stat), so it does not indicate a situation in which a file may\n+   --  not actually be readable due to some other process having exclusive\n+   --  access.\n+\n    function Is_Writable_File (Name : String) return Boolean;\n    --  Determines if the given string, Name, is the name of an existing file\n    --  that is writable. Returns True if so, False otherwise. Note that this\n@@ -608,6 +616,7 @@ package System.OS_Lib is\n    function Is_Regular_File (Name : C_File_Name) return Boolean;\n    function Is_Directory (Name : C_File_Name) return Boolean;\n    function Is_Readable_File (Name : C_File_Name) return Boolean;\n+   function Is_Executable_File (Name : C_File_Name) return Boolean;\n    function Is_Writable_File (Name : C_File_Name) return Boolean;\n    function Is_Symbolic_Link (Name : C_File_Name) return Boolean;\n "}]}