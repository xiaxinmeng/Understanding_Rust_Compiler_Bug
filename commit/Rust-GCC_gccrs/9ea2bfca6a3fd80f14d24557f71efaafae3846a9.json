{"sha": "9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVhMmJmY2E2YTNmZDgwZjE0ZDI0NTU3ZjcxZWZhYWZhZTM4NDZhOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-05T07:36:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-05T07:36:30Z"}, "message": "omp-low.c (lower_rec_input_clauses): Force max_vf if is_simd and on privatization clauses OMP_CLAUSE_DECL is...\n\n\t* omp-low.c (lower_rec_input_clauses): Force max_vf if is_simd and\n\ton privatization clauses OMP_CLAUSE_DECL is privatized by reference\n\tand references a VLA.  Handle references to non-VLAs if is_simd\n\tall privatization clauses like reductions.\n\t(lower_rec_input_clauses) <case do_private, case do_firstprivate>:\n\tIf omp_is_reference, use always omp simd arrays and set\n\tDECL_VALUE_EXPR in that case, if lower_rec_simd_input_clauses\n\tfails, emit reference initialization.\n\n\t* g++.dg/vect/simd-1.cc: New test.\n\nFrom-SVN: r271947", "tree": {"sha": "4f11b3d2665e2abeafb2f1f15ac22d8375afb747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f11b3d2665e2abeafb2f1f15ac22d8375afb747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5259a047c31c5a8c13eba73c914ca325e85eb699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5259a047c31c5a8c13eba73c914ca325e85eb699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5259a047c31c5a8c13eba73c914ca325e85eb699"}], "stats": {"total": 228, "additions": 224, "deletions": 4}, "files": [{"sha": "0d47c351e6fc38d5ea5200c0a78e0dba621f7794", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "patch": "@@ -1,3 +1,14 @@\n+2019-06-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (lower_rec_input_clauses): Force max_vf if is_simd and\n+\ton privatization clauses OMP_CLAUSE_DECL is privatized by reference\n+\tand references a VLA.  Handle references to non-VLAs if is_simd\n+\tall privatization clauses like reductions.\n+\t(lower_rec_input_clauses) <case do_private, case do_firstprivate>:\n+\tIf omp_is_reference, use always omp simd arrays and set\n+\tDECL_VALUE_EXPR in that case, if lower_rec_simd_input_clauses\n+\tfails, emit reference initialization.\n+\n 2019-06-05  Hongtao Liu  <hongtao.liu@intel.com>\n \n \tPR target/89803"}, {"sha": "8ec8f09f20890114b9b70e9dd554aef23239f853", "filename": "gcc/omp-low.c", "status": "modified", "additions": 95, "deletions": 4, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "patch": "@@ -3831,12 +3831,24 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  if (is_variable_sized (OMP_CLAUSE_DECL (c)))\n \t    sctx.max_vf = 1;\n+\t  else if (omp_is_reference (OMP_CLAUSE_DECL (c)))\n+\t    {\n+\t      tree rtype = TREE_TYPE (TREE_TYPE (OMP_CLAUSE_DECL (c)));\n+\t      if (!TREE_CONSTANT (TYPE_SIZE_UNIT (rtype)))\n+\t\tsctx.max_vf = 1;\n+\t    }\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_IN_REDUCTION:\n \t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF\n \t      || is_variable_sized (OMP_CLAUSE_DECL (c)))\n \t    sctx.max_vf = 1;\n+\t  else if (omp_is_reference (OMP_CLAUSE_DECL (c)))\n+\t    {\n+\t      tree rtype = TREE_TYPE (TREE_TYPE (OMP_CLAUSE_DECL (c)));\n+\t      if (!TREE_CONSTANT (TYPE_SIZE_UNIT (rtype)))\n+\t\tsctx.max_vf = 1;\n+\t    }\n \t  break;\n \tcase OMP_CLAUSE_IF:\n \t  if (integer_zerop (OMP_CLAUSE_IF_EXPR (c)))\n@@ -4665,8 +4677,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  /* For reduction in SIMD loop, defer adding the\n \t\t     initialization of the reference, because if we decide\n \t\t     to use SIMD array for it, the initilization could cause\n-\t\t     expansion ICE.  */\n-\t\t  if (c_kind == OMP_CLAUSE_REDUCTION && is_simd)\n+\t\t     expansion ICE.  Ditto for other privatization clauses.  */\n+\t\t  if (is_simd)\n \t\t    x = NULL_TREE;\n \t\t  else\n \t\t    {\n@@ -4777,10 +4789,21 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  tree y = lang_hooks.decls.omp_clause_dtor (c, new_var);\n \t\t  if ((TREE_ADDRESSABLE (new_var) || nx || y\n \t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n-\t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE__CONDTEMP_)\n+\t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE__CONDTEMP_\n+\t\t       || omp_is_reference (var))\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n \t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n+\t\t      if (omp_is_reference (var))\n+\t\t\t{\n+\t\t\t  gcc_assert (TREE_CODE (new_var) == MEM_REF);\n+\t\t\t  tree new_vard = TREE_OPERAND (new_var, 0);\n+\t\t\t  gcc_assert (DECL_P (new_vard));\n+\t\t\t  SET_DECL_VALUE_EXPR (new_vard,\n+\t\t\t\t\t       build_fold_addr_expr (lvar));\n+\t\t\t  DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t\t\t}\n+\n \t\t      if (nx)\n \t\t\tx = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t\t\t(c, unshare_expr (ivar), x);\n@@ -4838,6 +4861,24 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t}\n \t\t      break;\n \t\t    }\n+\t\t  if (omp_is_reference (var))\n+\t\t    {\n+\t\t      gcc_assert (TREE_CODE (new_var) == MEM_REF);\n+\t\t      tree new_vard = TREE_OPERAND (new_var, 0);\n+\t\t      gcc_assert (DECL_P (new_vard));\n+\t\t      tree type = TREE_TYPE (TREE_TYPE (new_vard));\n+\t\t      x = TYPE_SIZE_UNIT (type);\n+\t\t      if (TREE_CONSTANT (x))\n+\t\t\t{\n+\t\t\t  x = create_tmp_var_raw (type, get_name (var));\n+\t\t\t  gimple_add_tmp_var (x);\n+\t\t\t  TREE_ADDRESSABLE (x) = 1;\n+\t\t\t  x = build_fold_addr_expr_loc (clause_loc, x);\n+\t\t\t  x = fold_convert_loc (clause_loc,\n+\t\t\t\t\t\tTREE_TYPE (new_vard), x);\n+\t\t\t  gimplify_assign (new_vard, x, ilist);\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      if (nx)\n \t\tgimplify_and_add (nx, ilist);\n@@ -4925,6 +4966,28 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t      if (OMP_CLAUSE_LINEAR_ARRAY (c))\n \t\t\t{\n+\t\t\t  if (omp_is_reference (var))\n+\t\t\t    {\n+\t\t\t      gcc_assert (TREE_CODE (new_var) == MEM_REF);\n+\t\t\t      tree new_vard = TREE_OPERAND (new_var, 0);\n+\t\t\t      gcc_assert (DECL_P (new_vard));\n+\t\t\t      tree type = TREE_TYPE (TREE_TYPE (new_vard));\n+\t\t\t      nx = TYPE_SIZE_UNIT (type);\n+\t\t\t      if (TREE_CONSTANT (nx))\n+\t\t\t\t{\n+\t\t\t\t  nx = create_tmp_var_raw (type,\n+\t\t\t\t\t\t\t   get_name (var));\n+\t\t\t\t  gimple_add_tmp_var (nx);\n+\t\t\t\t  TREE_ADDRESSABLE (nx) = 1;\n+\t\t\t\t  nx = build_fold_addr_expr_loc (clause_loc,\n+\t\t\t\t\t\t\t\t nx);\n+\t\t\t\t  nx = fold_convert_loc (clause_loc,\n+\t\t\t\t\t\t\t TREE_TYPE (new_vard),\n+\t\t\t\t\t\t\t nx);\n+\t\t\t\t  gimplify_assign (new_vard, nx, ilist);\n+\t\t\t\t}\n+\t\t\t    }\n+\n \t\t\t  x = lang_hooks.decls.omp_clause_linear_ctor\n \t\t\t\t\t\t\t(c, new_var, x, t);\n \t\t\t  gimplify_and_add (x, ilist);\n@@ -4939,10 +5002,20 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t    }\n \n \t\t  if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR\n-\t\t       || TREE_ADDRESSABLE (new_var))\n+\t\t       || TREE_ADDRESSABLE (new_var)\n+\t\t       || omp_is_reference (var))\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n \t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n+\t\t      if (omp_is_reference (var))\n+\t\t\t{\n+\t\t\t  gcc_assert (TREE_CODE (new_var) == MEM_REF);\n+\t\t\t  tree new_vard = TREE_OPERAND (new_var, 0);\n+\t\t\t  gcc_assert (DECL_P (new_vard));\n+\t\t\t  SET_DECL_VALUE_EXPR (new_vard,\n+\t\t\t\t\t       build_fold_addr_expr (lvar));\n+\t\t\t  DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t\t\t}\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)\n \t\t\t{\n \t\t\t  tree iv = create_tmp_var (TREE_TYPE (new_var));\n@@ -4977,6 +5050,24 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t}\n \t\t      break;\n \t\t    }\n+\t\t  if (omp_is_reference (var))\n+\t\t    {\n+\t\t      gcc_assert (TREE_CODE (new_var) == MEM_REF);\n+\t\t      tree new_vard = TREE_OPERAND (new_var, 0);\n+\t\t      gcc_assert (DECL_P (new_vard));\n+\t\t      tree type = TREE_TYPE (TREE_TYPE (new_vard));\n+\t\t      nx = TYPE_SIZE_UNIT (type);\n+\t\t      if (TREE_CONSTANT (nx))\n+\t\t\t{\n+\t\t\t  nx = create_tmp_var_raw (type, get_name (var));\n+\t\t\t  gimple_add_tmp_var (nx);\n+\t\t\t  TREE_ADDRESSABLE (nx) = 1;\n+\t\t\t  nx = build_fold_addr_expr_loc (clause_loc, nx);\n+\t\t\t  nx = fold_convert_loc (clause_loc,\n+\t\t\t\t\t\t TREE_TYPE (new_vard), nx);\n+\t\t\t  gimplify_assign (new_vard, nx, ilist);\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      x = lang_hooks.decls.omp_clause_copy_ctor\n \t\t\t\t\t\t(c, unshare_expr (new_var), x);"}, {"sha": "c4293bb0ef62790209240c8c71f0235dc3cc21f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "patch": "@@ -1,3 +1,7 @@\n+2019-06-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/vect/simd-1.cc: New test.\n+\n 2019-06-05  Hongtao Liu  <hongtao.liu@intel.com>\n \n \tPR target/89803"}, {"sha": "76ce45d939dca8ddbc4953885ac71cf9f6ad298b", "filename": "gcc/testsuite/g++.dg/vect/simd-1.cc", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ea2bfca6a3fd80f14d24557f71efaafae3846a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-1.cc?ref=9ea2bfca6a3fd80f14d24557f71efaafae3846a9", "patch": "@@ -0,0 +1,114 @@\n+// { dg-require-effective-target vect_simd_clones }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+int w;\n+struct S {\n+  int s, &t;\n+  int *p;\n+  S (int *x) : s (0), t (w), p (x) {};\n+  void foo (short &, int &);\n+  void bar (short &, int &);\n+  void baz (short &, int &);\n+  void qux (short &, int &);\n+};\n+\n+__attribute__((noipa)) void\n+S::foo (short &x, int &y)\n+{\n+  int *q = this->p;\n+  #pragma omp simd lastprivate (x, s, t) private (y)\n+  for (int i = 0; i < 1025; ++i)\n+    {\n+      y = q[i];\n+      x = y;\n+      q[i] = y * 2;\n+      s = q[i] + 3;\n+      t = q[i] + 6;\n+    }\n+}\n+\n+__attribute__((noipa)) void\n+S::bar (short &x, int &y)\n+{\n+  #pragma omp simd linear (x) linear (s, t: 2) private (y)\n+  for (int i = 0; i < 1025; ++i)\n+    {\n+      y = p[i];\n+      x += y - 2 * i + 1;\n+      p[i] = y * 2;\n+      s += 2 * y - 4 * i + 2;\n+      t += 2 * y - 4 * i + 2;\n+    }\n+}\n+\n+__attribute__((noipa)) void\n+S::baz (short &x, int &y)\n+{\n+  int *q = this->p;\n+  #pragma omp simd lastprivate (x, s, t) private (y) if (simd: 0)\n+  for (int i = 0; i < 1025; ++i)\n+    {\n+      y = q[i];\n+      x = y;\n+      q[i] = y * 2;\n+      s = q[i] + 3;\n+      t = q[i] + 6;\n+    }\n+}\n+\n+__attribute__((noipa)) void\n+S::qux (short &x, int &y)\n+{\n+  #pragma omp simd linear (x) linear (s, t: 2) private (y) simdlen (1)\n+  for (int i = 0; i < 1025; ++i)\n+    {\n+      y = p[i];\n+      x += y - 2 * i + 1;\n+      p[i] = y * 2;\n+      s += 2 * y - 4 * i + 2;\n+      t += 2 * y - 4 * i + 2;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  short x;\n+  int a[1025], y;\n+  check_vect ();\n+  S s = a;\n+  for (int i = 0; i < 1025; ++i)\n+    {\n+      a[i] = i;\n+      asm volatile (\"\" : \"+g\" (i));\n+    }\n+  s.foo (x, y);\n+  if (x != 1024 || s.s != 2051 || s.t != 2054)\n+    abort ();\n+  for (int i = 0; i < 1025; ++i)\n+    if (a[i] != 2 * i)\n+      abort ();\n+  s.bar (x, y);\n+  if (x != 2049 || s.s != 4101 || s.t != 4104)\n+    abort ();\n+  for (int i = 0; i < 1025; ++i)\n+    if (a[i] != 4 * i)\n+      abort ();\n+    else\n+      a[i] = i;\n+  s.baz (x, y);\n+  if (x != 1024 || s.s != 2051 || s.t != 2054)\n+    abort ();\n+  for (int i = 0; i < 1025; ++i)\n+    if (a[i] != 2 * i)\n+      abort ();\n+  s.qux (x, y);\n+  if (x != 2049 || s.s != 4101 || s.t != 4104)\n+    abort ();\n+  for (int i = 0; i < 1025; ++i)\n+    if (a[i] != 4 * i)\n+      abort ();\n+}"}]}