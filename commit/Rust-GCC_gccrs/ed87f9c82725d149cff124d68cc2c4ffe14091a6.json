{"sha": "ed87f9c82725d149cff124d68cc2c4ffe14091a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ4N2Y5YzgyNzI1ZDE0OWNmZjEyNGQ2OGNjMmM0ZmZlMTQwOTFhNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-21T09:19:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-21T09:19:13Z"}, "message": "splay-tree.c: New file.\n\n\t* splay-tree.c: New file.\n\t* Makefile.in (CFILES): Add it.\n\t(REQUIRED_OFILES): Likewise.\n\t(splay-tree.o): Add dependencies.\n\nFrom-SVN: r23210", "tree": {"sha": "be250f8b208a9c69cdf3dd5b1278e8ab4b49e366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be250f8b208a9c69cdf3dd5b1278e8ab4b49e366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed87f9c82725d149cff124d68cc2c4ffe14091a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed87f9c82725d149cff124d68cc2c4ffe14091a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed87f9c82725d149cff124d68cc2c4ffe14091a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed87f9c82725d149cff124d68cc2c4ffe14091a6/comments", "author": null, "committer": null, "parents": [{"sha": "7e58a4d3eab44a3bc297069e772625ce973618e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e58a4d3eab44a3bc297069e772625ce973618e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e58a4d3eab44a3bc297069e772625ce973618e9"}], "stats": {"total": 346, "additions": 343, "deletions": 3}, "files": [{"sha": "655edb86f60c91168589a9ed2dd2b2356f635ce8", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed87f9c82725d149cff124d68cc2c4ffe14091a6/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed87f9c82725d149cff124d68cc2c4ffe14091a6/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=ed87f9c82725d149cff124d68cc2c4ffe14091a6", "patch": "@@ -1,3 +1,10 @@\n+1998-10-21  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* splay-tree.c: New file.\n+\t* Makefile.in (CFILES): Add it.\n+\t(REQUIRED_OFILES): Likewise.\n+\t(splay-tree.o): Add dependencies.\n+\n Tue Oct 20 12:29:02 1998  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>\n \n \t* cplus-dem.c (demangle_qualified): Fix off-by-one when checking"}, {"sha": "c38cd260089577492fff6af8d31986d0c215a3b8", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed87f9c82725d149cff124d68cc2c4ffe14091a6/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed87f9c82725d149cff124d68cc2c4ffe14091a6/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=ed87f9c82725d149cff124d68cc2c4ffe14091a6", "patch": "@@ -117,16 +117,17 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c \\\n \tgetruntime.c floatformat.c hex.c index.c insque.c memchr.c \\\n \tmemcmp.c memcpy.c memmove.c memset.c mkstemp.c objalloc.c obstack.c \\\n \tpexecute.c random.c rename.c rindex.c sigsetmask.c spaces.c \\\n-\tstrcasecmp.c strncasecmp.c strchr.c strdup.c strerror.c \\\n+\tsplay-tree.o strcasecmp.c strncasecmp.c strchr.c strdup.c strerror.c \\\n \tstrrchr.c strsignal.c strstr.c strtod.c strtol.c strtoul.c \\\n \ttmpnam.c vasprintf.c vfork.c vfprintf.c vprintf.c vsprintf.c \\\n \twaitpid.c xatexit.c xexit.c xmalloc.c xstrdup.c xstrerror.c\n \n # These are always included in the library.\n REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o \\\n   fdmatch.o fnmatch.o getopt.o getopt1.o getruntime.o hex.o \\\n-  floatformat.o mkstemp.o objalloc.o obstack.o pexecute.o spaces.o strerror.o \\\n-  strsignal.o xatexit.o xexit.o xmalloc.o xstrdup.o xstrerror.o\n+  floatformat.o mkstemp.o objalloc.o obstack.o pexecute.o spaces.o \\\n+  splay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o \\\n+  xstrdup.o xstrerror.o\n \n $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS) $(ALLOCA)\n \trm -f $(TARGETLIB)\n@@ -236,6 +237,7 @@ objalloc.o: $(INCDIR)/objalloc.h\n obstack.o: config.h $(INCDIR)/obstack.h\n pexecute.o: config.h $(INCDIR)/libiberty.h\n spaces.o: $(INCDIR)/libiberty.h\n+splay-tree.o: $(INCDIR)/libiberty.h $(INCDIR)/splay-tree.h $(INCDIR)/ansidecl.h\n strerror.o: config.h $(INCDIR)/libiberty.h\n strsignal.o: config.h $(INCDIR)/libiberty.h\n xatexit.o: $(INCDIR)/libiberty.h"}, {"sha": "ed48116c0633a50b1f80f47a90117a9f53450ac0", "filename": "libiberty/splay-tree.c", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed87f9c82725d149cff124d68cc2c4ffe14091a6/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed87f9c82725d149cff124d68cc2c4ffe14091a6/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=ed87f9c82725d149cff124d68cc2c4ffe14091a6", "patch": "@@ -0,0 +1,331 @@\n+/* A splay-tree datatype.  \n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+\n+   This file is part of GNU CC.\n+   \n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  \n+\n+   For an easily readable description of splay-trees, see:\n+\n+     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n+     Algorithms.  Harper-Collins, Inc.  1991.  */\n+\n+#ifndef IN_GCC\n+#include \"libiberty.h\"\n+#endif /* IN_GCC */\n+#include \"splay-tree.h\"\n+\n+static void splay_tree_delete_helper    PARAMS((splay_tree, \n+\t\t\t\t\t\tsplay_tree_node));\n+static void splay_tree_splay            PARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key));\n+static splay_tree_node splay_tree_splay_helper     \n+                                        PARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key,\n+\t\t\t\t\t\tsplay_tree_node*,\n+\t\t\t\t\t\tsplay_tree_node*,\n+\t\t\t\t\t\tsplay_tree_node*));\n+static int splay_tree_foreach_helper    PARAMS((splay_tree,\n+\t\t\t\t\t        splay_tree_node,\n+\t\t\t\t\t\tsplay_tree_foreach_fn,\n+\t\t\t\t\t\tvoid*));\n+\n+/* Deallocate NODE (a member of SP), and all its sub-trees.  */\n+\n+static void \n+splay_tree_delete_helper (sp, node)\n+     splay_tree sp;\n+     splay_tree_node node;\n+{\n+  if (!node)\n+    return;\n+\n+  splay_tree_delete_helper (sp, node->left);\n+  splay_tree_delete_helper (sp, node->right);\n+\n+  if (sp->delete_key)\n+    (*sp->delete_key)(node->key);\n+  if (sp->delete_value)\n+    (*sp->delete_value)(node->value);\n+\n+  free ((char*) node);\n+}\n+\n+/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n+   and grandparent, respectively, of NODE.  */\n+\n+static splay_tree_node\n+splay_tree_splay_helper (sp, key, node, parent, grandparent)\n+     splay_tree sp;\n+     splay_tree_key key;\n+     splay_tree_node *node;\n+     splay_tree_node *parent;\n+     splay_tree_node *grandparent;\n+{\n+  splay_tree_node *next;\n+  splay_tree_node n;\n+  int comparison;\n+  \n+  n = *node;\n+\n+  if (!n)\n+    return *parent;\n+\n+  comparison = (*sp->comp) (key, n->key);\n+\n+  if (comparison == 0)\n+    /* We've found the target.  */\n+    next = 0;\n+  else if (comparison < 0)\n+    /* The target is to the left.  */\n+    next = &n->left;\n+  else \n+    /* The target is to the right.  */\n+    next = &n->right;\n+\n+  if (next)\n+    {\n+      /* Continue down the tree.  */\n+      n = splay_tree_splay_helper (sp, key, next, node, parent);\n+\n+      /* The recursive call will change the place to which NODE\n+\t points.  */\n+      if (*node != n)\n+\treturn n;\n+    }\n+\n+  if (!parent)\n+    /* NODE is the root.  We are done.  */\n+    return n;\n+\n+  /* First, handle the case where there is no grandparent (i.e.,\n+     *PARENT is the root of the tree.)  */\n+  if (!grandparent) \n+    {\n+      if (n == (*parent)->left)\n+\t{\n+\t  *node = n->right;\n+\t  n->right = *parent;\n+\t}\n+      else\n+\t{\n+\t  *node = n->left;\n+\t  n->left = *parent;\n+\t}\n+      *parent = n;\n+      return n;\n+    }\n+\n+  /* Next handle the cases where both N and *PARENT are left children,\n+     or where both are right children.  */\n+  if (n == (*parent)->left && *parent == (*grandparent)->left)\n+    {\n+      splay_tree_node p = *parent;\n+\n+      (*grandparent)->left = p->right;\n+      p->right = *grandparent;\n+      p->left = n->right;\n+      n->right = p;\n+      *grandparent = n;\n+      return n; \n+    }\n+  else if  (n == (*parent)->right && *parent == (*grandparent)->right)\n+    {\n+      splay_tree_node p = *parent;\n+\n+      (*grandparent)->right = p->left;\n+      p->left = *grandparent;\n+      p->right = n->left;\n+      n->left = p;\n+      *grandparent = n;\n+      return n;\n+    }\n+\n+  /* Finally, deal with the case where N is a left child, but *PARENT\n+     is a right child, or vice versa.  */\n+  if (n == (*parent)->left) \n+    {\n+      (*parent)->left = n->right;\n+      n->right = *parent;\n+      (*grandparent)->right = n->left;\n+      n->left = *grandparent;\n+      *grandparent = n;\n+      return n;\n+    } \n+  else\n+    {\n+      (*parent)->right = n->left;\n+      n->left = *parent;\n+      (*grandparent)->left = n->right;\n+      n->right = *grandparent;\n+      *grandparent = n;\n+      return n;\n+    }\n+}\n+\n+/* Splay SP around KEY.  */\n+\n+static void\n+splay_tree_splay (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  if (sp->root == 0)\n+    return;\n+\n+  splay_tree_splay_helper (sp, key, &sp->root, \n+\t\t\t   /*grandparent=*/0, /*parent=*/0); \n+}\n+\n+/* Call FN, passing it the DATA, for every node below NODE, all of\n+   which are from SP, following an in-order traversal.  If FN every\n+   returns a non-zero value, the iteration ceases immediately, and the\n+   value is returned.  Otherwise, this function returns 0.  */\n+\n+int\n+splay_tree_foreach_helper (sp, node, fn, data)\n+     splay_tree sp;\n+     splay_tree_node node;\n+     splay_tree_foreach_fn fn;\n+     void* data;\n+{\n+  int val;\n+\n+  if (!node)\n+    return 0;\n+\n+  val = splay_tree_foreach_helper (sp, node->left, fn, data);\n+  if (val)\n+    return val;\n+\n+  val = (*fn)(node, data);\n+  if (val)\n+    return val;\n+\n+  return splay_tree_foreach_helper (sp, node->right, fn, data);\n+}\n+\n+/* Allocate a new splay tree, using COMPARE_FN to compare nodes,\n+   DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate\n+   values.  */\n+\n+splay_tree \n+splay_tree_new (compare_fn, delete_key_fn, delete_value_fn)\n+     splay_tree_compare_fn compare_fn;\n+     splay_tree_delete_key_fn delete_key_fn;\n+     splay_tree_delete_value_fn delete_value_fn;\n+{\n+  splay_tree sp = (splay_tree) xmalloc (sizeof (struct splay_tree));\n+  sp->root = 0;\n+  sp->comp = compare_fn;\n+  sp->delete_key = delete_key_fn;\n+  sp->delete_value = delete_value_fn;\n+\n+  return sp;\n+}\n+\n+/* Deallocate SP.  */\n+\n+void \n+splay_tree_delete (sp)\n+     splay_tree sp;\n+{\n+  splay_tree_delete_helper (sp, sp->root);\n+  free ((char*) sp);\n+}\n+\n+/* Insert a new node (associating KEY with DATA) into SP.  If a\n+   previous node with the indicated KEY exists, its data is replaced\n+   with the new value.  */\n+\n+void \n+splay_tree_insert (sp, key, value)\n+     splay_tree sp;\n+     splay_tree_key key;\n+     splay_tree_value value;\n+{\n+  int comparison;\n+\n+  splay_tree_splay (sp, key);\n+\n+  if (sp->root)\n+    comparison = (*sp->comp)(sp->root->key, key);\n+\n+  if (sp->root && comparison == 0)\n+    {\n+      /* If the root of the tree already has the indicated KEY, just\n+\t replace the value with VALUE.  */\n+      if (sp->delete_value)\n+\t(*sp->delete_value)(sp->root->value);\n+      sp->root->value = value;\n+    } \n+  else \n+    {\n+      /* Create a new node, and insert it at the root.  */\n+      splay_tree_node node;\n+      \n+      node = (splay_tree_node) xmalloc (sizeof (struct splay_tree_node));\n+      node->key = key;\n+      node->value = value;\n+      \n+      if (!sp->root)\n+\tnode->left = node->right = 0;\n+      else if (comparison < 0)\n+\t{\n+\t  node->left = sp->root;\n+\t  node->right = node->left->right;\n+\t  node->left->right = 0;\n+\t}\n+      else\n+\t{\n+\t  node->right = sp->root;\n+\t  node->left = node->right->left;\n+\t  node->right->left = 0;\n+\t}\n+\n+    sp->root = node;\n+  }\n+}\n+\n+/* Lookup KEY in SP, returning VALUE if present, and NULL \n+   otherwise.  */\n+\n+splay_tree_node\n+splay_tree_lookup (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  splay_tree_splay (sp, key);\n+\n+  if (sp->root && (*sp->comp)(sp->root->key, key) == 0)\n+    return sp->root;\n+  else\n+    return 0;\n+}\n+\n+/* Call FN, passing it the DATA, for every node in SP, following an\n+   in-order traversal.  If FN every returns a non-zero value, the\n+   iteration ceases immediately, and the value is returned.\n+   Otherwise, this function returns 0.  */\n+\n+int\n+splay_tree_foreach (sp, fn, data)\n+     splay_tree sp;\n+     splay_tree_foreach_fn fn;\n+     void *data;\n+{\n+  return splay_tree_foreach_helper (sp, sp->root, fn, data);\n+}"}]}