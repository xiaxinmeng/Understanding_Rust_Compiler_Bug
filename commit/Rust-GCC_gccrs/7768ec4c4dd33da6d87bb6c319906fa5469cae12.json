{"sha": "7768ec4c4dd33da6d87bb6c319906fa5469cae12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc2OGVjNGM0ZGQzM2RhNmQ4N2JiNmMzMTk5MDZmYTU0NjljYWUxMg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2011-12-04T23:05:23Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2011-12-04T23:05:23Z"}, "message": "linux.h (TARGET_DEFAULT): Add MASK_SOFT_ATOMIC.\n\n\t* config/sh/linux.h (TARGET_DEFAULT): Add MASK_SOFT_ATOMIC.\n\t* config/sh/sync.md: New file.\n\t* config/sh/sh.md: Include sync.md.\n\t* config/sh/sh.opt (msoft-atomic): New option.\n\t* doc/invoke.texi (SH Options): Document it.\n\nFrom-SVN: r181995", "tree": {"sha": "794520c536b8270b7fc6407cbab21e9930d218d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/794520c536b8270b7fc6407cbab21e9930d218d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7768ec4c4dd33da6d87bb6c319906fa5469cae12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7768ec4c4dd33da6d87bb6c319906fa5469cae12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7768ec4c4dd33da6d87bb6c319906fa5469cae12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7768ec4c4dd33da6d87bb6c319906fa5469cae12/comments", "author": null, "committer": null, "parents": [{"sha": "b724567ea68234e4fa748b4373824cf30b3f6845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b724567ea68234e4fa748b4373824cf30b3f6845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b724567ea68234e4fa748b4373824cf30b3f6845"}], "stats": {"total": 337, "additions": 334, "deletions": 3}, "files": [{"sha": "94b426c188ef99f1d01a0f82aee009b907e1d908", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7768ec4c4dd33da6d87bb6c319906fa5469cae12", "patch": "@@ -1,3 +1,11 @@\n+2011-12-04  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/linux.h (TARGET_DEFAULT): Add MASK_SOFT_ATOMIC.\n+\t* config/sh/sync.md: New file.\n+\t* config/sh/sh.md: Include sync.md.\n+\t* config/sh/sh.opt (msoft-atomic): New option.\n+\t* doc/invoke.texi (SH Options): Document it.\n+\n 2011-12-04  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcov-io.h (struct gcov_info): Replace trailing array with"}, {"sha": "a5c2734214b63acef51654e73c094be0cc4e4b4d", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=7768ec4c4dd33da6d87bb6c319906fa5469cae12", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n   (TARGET_CPU_DEFAULT | MASK_USERMODE | TARGET_ENDIAN_DEFAULT \\\n-   | TARGET_OPT_DEFAULT)\n+   | TARGET_OPT_DEFAULT | MASK_SOFT_ATOMIC)\n \n #define TARGET_ASM_FILE_END file_end_indicate_exec_stack\n "}, {"sha": "4e0213495b8d8b59353cb872e75252bce145511d", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=7768ec4c4dd33da6d87bb6c319906fa5469cae12", "patch": "@@ -13667,3 +13667,5 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"ld%M1.q\\t%m1, %0\\;ld%M2.q\\t%m2, %3\\;cmpeq\\t%0, %3, %0\\;movi\\t0, %3\"\n   [(set_attr \"type\" \"other\")\n    (set_attr \"length\" \"16\")])\n+\n+(include \"sync.md\")"}, {"sha": "ea87d259f396d05ca18ab69d61aa174679a65190", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=7768ec4c4dd33da6d87bb6c319906fa5469cae12", "patch": "@@ -1,6 +1,6 @@\n ; Options for the SH port of the compiler.\n \n-; Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+; Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n ; Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n@@ -319,6 +319,10 @@ mrenesas\n Target Mask(HITACHI) MaskExists\n Follow Renesas (formerly Hitachi) / SuperH calling conventions\n \n+msoft-atomic\n+Target Report Mask(SOFT_ATOMIC)\n+Use software atomic sequences supported by kernel\n+\n mspace\n Target RejectNegative Alias(Os)\n Deprecated.  Use -Os instead"}, {"sha": "ec4ec517b45d16c4b349030b7088272ac6d8aa02", "filename": "gcc/config/sh/sync.md", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=7768ec4c4dd33da6d87bb6c319906fa5469cae12", "patch": "@@ -0,0 +1,312 @@\n+;; GCC machine description for SH synchronization instructions.\n+;; Copyright (C) 2011\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_c_enum \"unspec\" [\n+  UNSPEC_ATOMIC\n+])\n+ \n+(define_c_enum \"unspecv\" [\n+  UNSPECV_CMPXCHG_1\n+  UNSPECV_CMPXCHG_2\n+  UNSPECV_CMPXCHG_3\n+])\n+\n+(define_mode_iterator I124 [QI HI SI])\n+\n+(define_mode_attr i124suffix [(QI \"b\") (HI \"w\") (SI \"l\")])\n+(define_mode_attr i124extend_insn [(QI \"exts.b\") (HI \"exts.w\") (SI \"mov\")])\n+\n+(define_code_iterator FETCHOP [plus minus ior xor and])\n+(define_code_attr fetchop_name\n+  [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n+(define_code_attr fetchop_insn\n+  [(plus \"add\") (minus \"sub\") (ior \"or\") (xor \"xor\") (and \"and\")])\n+\n+;; Linux specific atomic patterns for the Renesas / SuperH SH CPUs.\n+;; Linux kernel for SH3/4 has implemented the support for software\n+;; atomic sequences.\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\t\t;; bool success output\n+   (match_operand:I124 1 \"register_operand\" \"\")\t\t;; oldval output\n+   (match_operand:I124 2 \"memory_operand\" \"\")\t\t;; memory\n+   (match_operand:I124 3 \"register_operand\" \"\")\t\t;; expected input\n+   (match_operand:I124 4 \"register_operand\" \"\")\t\t;; newval input\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; failure model\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+{\n+  rtx addr;\n+\n+  addr = force_reg (Pmode, XEXP (operands[2], 0));\n+  emit_insn (gen_atomic_compare_and_swap<mode>_soft\n+\t     (gen_lowpart (SImode, operands[1]), addr, operands[3],\n+\t      operands[4]));\n+  if (<MODE>mode == QImode)\n+    emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[1]),\n+\t\t\t\t     operands[1]));\n+  else if (<MODE>mode == HImode)\n+    emit_insn (gen_zero_extendhisi2 (gen_lowpart (SImode, operands[1]),\n+\t\t\t\t     operands[1]));\n+  emit_insn (gen_movqi (operands[0], gen_rtx_REG (QImode, T_REG)));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_compare_and_swap<mode>_soft\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&u\")\n+\t(unspec_volatile:SI\n+\t  [(mem:I124 (match_operand:SI 1 \"register_operand\" \"u\"))\n+\t   (match_operand:I124 2 \"register_operand\" \"u\")\n+\t   (match_operand:I124 3 \"register_operand\" \"u\")]\n+\t  UNSPECV_CMPXCHG_1))\n+   (set (mem:I124 (match_dup 1))\n+\t(unspec_volatile:I124 [(const_int 0)] UNSPECV_CMPXCHG_2))\n+   (set (reg:QI T_REG)\n+\t(unspec_volatile:QI [(const_int 0)] UNSPECV_CMPXCHG_3))\n+   (clobber (match_scratch:SI 4 \"=&u\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mova\\\\t1f, r0\\\\n\\\\\n+\\\\t<i124extend_insn>\\\\t%2, %4\\\\n\\\\\n+\\\\tmov\\\\tr15, r1\\\\n\\\\\n+\\\\tmov\\\\t#(0f-1f), r15\\\\n\\\\\n+0:\\\\tmov.<i124suffix>\\\\t@%1, %0\\\\n\\\\\n+\\\\tcmp/eq\\\\t%0, %4\\\\n\\\\\n+\\\\tbf\\\\t1f\\\\n\\\\\n+\\\\tmov.<i124suffix>\\\\t%3, @%1\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\tmov\\tr1, r15\\\";\n+}\"\n+  [(set_attr \"length\" \"20\")])\n+\n+(define_expand \"atomic_fetch_<fetchop_name><mode>\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"\")\n+\t(match_operand:I124 1 \"memory_operand\" \"\"))\n+   (set (match_dup 1)\n+\t(unspec:I124\n+\t  [(FETCHOP:I124 (match_dup 1)\n+\t     (match_operand:I124 2 \"register_operand\" \"\"))]\n+\t  UNSPEC_ATOMIC))\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+{\n+  rtx addr;\n+\n+  addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  emit_insn (gen_atomic_fetch_<fetchop_name><mode>_soft\n+\t     (operands[0], addr, operands[2]));\n+  if (<MODE>mode == QImode)\n+    emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  else if (<MODE>mode == HImode)\n+    emit_insn (gen_zero_extendhisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_fetch_<fetchop_name><mode>_soft\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n+\t(mem:I124 (match_operand:SI 1 \"register_operand\" \"u\")))\n+   (set (mem:I124 (match_dup 1))\n+\t(unspec:I124\n+\t  [(FETCHOP:I124 (mem:I124 (match_dup 1))\n+\t     (match_operand:I124 2 \"register_operand\" \"u\"))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:I124 3 \"=&u\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mova\\\\t1f, r0\\\\n\\\\\n+\\\\tmov\\\\tr15, r1\\\\n\\\\\n+\\\\tmov\\\\t#(0f-1f), r15\\\\n\\\\\n+0:\\\\tmov.<i124suffix>\\\\t@%1, %0\\\\n\\\\\n+\\\\tmov\\\\t%0, %3\\\\n\\\\\n+\\\\t<fetchop_insn>\\\\t%2, %3\\\\n\\\\\n+\\\\tmov.<i124suffix>\\\\t%3, @%1\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\tmov\\tr1, r15\\\";\n+}\"\n+  [(set_attr \"length\" \"18\")])\n+\n+(define_expand \"atomic_fetch_nand<mode>\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"\")\n+\t(match_operand:I124 1 \"memory_operand\" \"\"))\n+   (set (match_dup 1)\n+\t(unspec:I124\n+\t  [(not:I124 (and:I124 (match_dup 1)\n+\t     (match_operand:I124 2 \"register_operand\" \"\")))]\n+\t  UNSPEC_ATOMIC))\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+{\n+  rtx addr;\n+\n+  addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  emit_insn (gen_atomic_fetch_nand<mode>_soft\n+\t     (operands[0], addr, operands[2]));\n+  if (<MODE>mode == QImode)\n+    emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  else if (<MODE>mode == HImode)\n+    emit_insn (gen_zero_extendhisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_fetch_nand<mode>_soft\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n+\t(mem:I124 (match_operand:SI 1 \"register_operand\" \"u\")))\n+   (set (mem:I124 (match_dup 1))\n+\t(unspec:I124\n+\t  [(not:I124 (and:I124 (mem:I124 (match_dup 1))\n+\t     (match_operand:I124 2 \"register_operand\" \"u\")))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (match_scratch:I124 3 \"=&u\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mova\\\\t1f, r0\\\\n\\\\\n+\\\\tmov\\\\tr15, r1\\\\n\\\\\n+\\\\tmov\\\\t#(0f-1f), r15\\\\n\\\\\n+0:\\\\tmov.<i124suffix>\\\\t@%1, %0\\\\n\\\\\n+\\\\tmov\\\\t%2, %3\\\\n\\\\\n+\\\\tand\\\\t%0, %3\\\\n\\\\\n+\\\\tnot\\\\t%3, %3\\\\n\\\\\n+\\\\tmov.<i124suffix>\\\\t%3, @%1\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\tmov\\tr1, r15\\\";\n+}\"\n+  [(set_attr \"length\" \"20\")])\n+\n+(define_expand \"atomic_<fetchop_name>_fetch<mode>\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"\")\n+\t(FETCHOP:I124\n+\t  (match_operand:I124 1 \"memory_operand\" \"\")\n+\t  (match_operand:I124 2 \"register_operand\" \"\")))\n+   (set (match_dup 1)\n+\t(unspec:I124\n+\t  [(FETCHOP:I124 (match_dup 1) (match_dup 2))]\n+\t  UNSPEC_ATOMIC))\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+{\n+  rtx addr;\n+\n+  addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  emit_insn (gen_atomic_<fetchop_name>_fetch<mode>_soft\n+\t     (operands[0], addr, operands[2]));\n+  if (<MODE>mode == QImode)\n+    emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  else if (<MODE>mode == HImode)\n+    emit_insn (gen_zero_extendhisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_<fetchop_name>_fetch<mode>_soft\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n+\t(FETCHOP:I124\n+\t  (mem:I124 (match_operand:SI 1 \"register_operand\" \"u\"))\n+\t  (match_operand:I124 2 \"register_operand\" \"u\")))\n+   (set (mem:I124 (match_dup 1))\n+\t(unspec:I124\n+\t  [(FETCHOP:I124 (mem:I124 (match_dup 1)) (match_dup 2))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mova\\\\t1f, r0\\\\n\\\\\n+\\\\tmov\\\\tr15, r1\\\\n\\\\\n+\\\\tmov\\\\t#(0f-1f), r15\\\\n\\\\\n+0:\\\\tmov.<i124suffix>\\\\t@%1, %0\\\\n\\\\\n+\\\\t<fetchop_insn>\\\\t%2, %0\\\\n\\\\\n+\\\\tmov.<i124suffix>\\\\t%0, @%1\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\tmov\\tr1, r15\\\";\n+}\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_expand \"atomic_nand_fetch<mode>\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"\")\n+\t(not:I124 (and:I124\n+\t  (match_operand:I124 1 \"memory_operand\" \"\")\n+\t  (match_operand:I124 2 \"register_operand\" \"\"))))\n+   (set (match_dup 1)\n+\t(unspec:I124\n+\t  [(not:I124 (and:I124 (match_dup 1) (match_dup 2)))]\n+\t  UNSPEC_ATOMIC))\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+{\n+  rtx addr;\n+\n+  addr = force_reg (Pmode, XEXP (operands[1], 0));\n+  emit_insn (gen_atomic_nand_fetch<mode>_soft\n+\t     (operands[0], addr, operands[2]));\n+  if (<MODE>mode == QImode)\n+    emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  else if (<MODE>mode == HImode)\n+    emit_insn (gen_zero_extendhisi2 (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     operands[0]));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_nand_fetch<mode>_soft\"\n+  [(set (match_operand:I124 0 \"register_operand\" \"=&u\")\n+\t(not:I124 (and:I124\n+\t  (mem:I124 (match_operand:SI 1 \"register_operand\" \"u\"))\n+\t  (match_operand:I124 2 \"register_operand\" \"u\"))))\n+   (set (mem:I124 (match_dup 1))\n+\t(unspec:I124\n+\t  [(not:I124 (and:I124 (mem:I124 (match_dup 1)) (match_dup 2)))]\n+\t  UNSPEC_ATOMIC))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_SOFT_ATOMIC && !TARGET_SHMEDIA\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mova\\\\t1f, r0\\\\n\\\\\n+\\\\tmov\\\\tr15, r1\\\\n\\\\\n+\\\\tmov\\\\t#(0f-1f), r15\\\\n\\\\\n+0:\\\\tmov.<i124suffix>\\\\t@%1, %0\\\\n\\\\\n+\\\\tand\\\\t%2, %0\\\\n\\\\\n+\\\\tnot\\\\t%0, %0\\\\n\\\\\n+\\\\tmov.<i124suffix>\\\\t%0, @%1\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\tmov\\tr1, r15\\\";\n+}\"\n+  [(set_attr \"length\" \"18\")])"}, {"sha": "d0d324341377805d1551268c86d0c9c3ba1adbb4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7768ec4c4dd33da6d87bb6c319906fa5469cae12/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7768ec4c4dd33da6d87bb6c319906fa5469cae12", "patch": "@@ -877,7 +877,7 @@ See RS/6000 and PowerPC Options.\n -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol\n -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol\n -madjust-unroll -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol\n--maccumulate-outgoing-args -minvalid-symbols}\n+-maccumulate-outgoing-args -minvalid-symbols -msoft-atomic}\n \n @emph{Solaris 2 Options}\n @gccoptlist{-mimpure-text  -mno-impure-text @gol\n@@ -17547,6 +17547,11 @@ Dump instruction size and location in the assembly code.\n This option is deprecated.  It pads structures to multiple of 4 bytes,\n which is incompatible with the SH ABI@.\n \n+@item -msoft-atomic\n+@opindex msoft-atomic\n+Generate software atomic sequences for the atomic operations.\n+This is the default when the target is @code{sh-*-linux*}.\n+\n @item -mspace\n @opindex mspace\n Optimize for space instead of speed.  Implied by @option{-Os}."}]}