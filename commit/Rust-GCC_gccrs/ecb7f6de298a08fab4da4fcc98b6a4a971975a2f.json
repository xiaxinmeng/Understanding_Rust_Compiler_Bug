{"sha": "ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiN2Y2ZGUyOThhMDhmYWI0ZGE0ZmNjOThiNmE0YTk3MTk3NWEyZg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-12T13:47:26Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-12T13:47:26Z"}, "message": "df-core.c: Update head documentation.\n\n2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* df-core.c: Update head documentation.\n\nFrom-SVN: r147435", "tree": {"sha": "6e3df13555c4155e9dcd8dc5fedfa4488f1fe392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e3df13555c4155e9dcd8dc5fedfa4488f1fe392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c24151ce62585591bfe638ceeed4a19469bcef37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24151ce62585591bfe638ceeed4a19469bcef37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24151ce62585591bfe638ceeed4a19469bcef37"}], "stats": {"total": 37, "additions": 17, "deletions": 20}, "files": [{"sha": "d5f03cd15f50a401d0bda84594ce6f32b3a5a245", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "patch": "@@ -1,3 +1,7 @@\n+2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* df-core.c: Update head documentation.\n+\n 2009-05-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR bootstrap/40118"}, {"sha": "c42b20f2ce70a2c6df942962b9daad18200b6f7a", "filename": "gcc/df-core.c", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb7f6de298a08fab4da4fcc98b6a4a971975a2f/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=ecb7f6de298a08fab4da4fcc98b6a4a971975a2f", "patch": "@@ -170,39 +170,32 @@ There are four ways of doing the incremental scanning:\n    d) If the pass modifies all of the insns, as does register\n       allocation, it is simply better to rescan the entire function.\n \n-   e) If the pass uses either non-standard or ancient techniques to\n-      modify insns, automatic detection of the insns that need to be\n-      rescanned may be impractical.  Cse and regrename fall into this\n-      category.\n-\n 2) Deferred rescanning - Calls to df_insn_rescan, df_notes_rescan, and\n    df_insn_delete do not immediately change the insn but instead make\n    a note that the insn needs to be rescanned.  The next call to\n    df_analyze, df_finish_pass, or df_process_deferred_rescans will\n    cause all of the pending rescans to be processed.\n \n    This is the technique of choice if either 1a, 1b, or 1c are issues\n-   in the pass.  In the case of 1a or 1b, a call to df_remove_problem\n-   (df_chain) should be made before the next call to df_analyze or\n-   df_process_deferred_rescans.\n+   in the pass.  In the case of 1a or 1b, a call to df_finish_pass\n+   (either manually or via TODO_df_finish) should be made before the\n+   next call to df_analyze or df_process_deferred_rescans.\n+\n+   This mode is also used by a few passes that still rely on note_uses,\n+   note_stores and for_each_rtx instead of using the DF data.  This\n+   can be said to fall under case 1c.\n \n    To enable this mode, call df_set_flags (DF_DEFER_INSN_RESCAN).\n    (This mode can be cleared by calling df_clear_flags\n    (DF_DEFER_INSN_RESCAN) but this does not cause the deferred insns to\n    be rescanned.\n \n-   3) Total rescanning - In this mode the rescanning is disabled.\n-   However, the df information associated with deleted insn is delete\n-   at the time the insn is deleted.  At the end of the pass, a call\n-   must be made to df_insn_rescan_all.  This method is used by the\n-   register allocator since it generally changes each insn multiple\n-   times (once for each ref) and does not need to make use of the\n-   updated scanning information.\n-\n-   It is also currently used by two older passes (cse, and regrename)\n-   which change insns in hard to track ways.  It is hoped that this\n-   will be fixed soon since this it is expensive to rescan all of the\n-   insns when only a small number of them have really changed.\n+3) Total rescanning - In this mode the rescanning is disabled.\n+   Only when insns are deleted is the df information associated with\n+   it also deleted.  At the end of the pass, a call must be made to\n+   df_insn_rescan_all.  This method is used by the register allocator\n+   since it generally changes each insn multiple times (once for each ref)\n+   and does not need to make use of the updated scanning information.\n \n 4) Do it yourself - In this mechanism, the pass updates the insns\n    itself using the low level df primitives.  Currently no pass does"}]}