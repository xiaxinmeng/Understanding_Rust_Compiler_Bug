{"sha": "a7721dc03fc45a4b8beef840491759d333b50431", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3MjFkYzAzZmM0NWE0YjhiZWVmODQwNDkxNzU5ZDMzM2I1MDQzMQ==", "commit": {"author": {"name": "Alan Modra", "email": "alan@linuxcare.com.au", "date": "2001-04-03T07:43:27Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-03T07:43:27Z"}, "message": "TARGET_NO_SPACE_REGS no longer affects call sequences.\n\n\t* pa.h: Revise comments for TARGET_NO_SPACE_REGS and\n\tTARGET_FAST_INDIRECT_CALLS.\n\t* pa.c (override_options): TARGET_NO_SPACE_REGS is now OK with\n\t-fPIC.  Don't warn.\n\t(return_addr_rtx): Short circuit export stub matching when\n\tTARGET_NO_SPACE_REGS.\n\t(output_millicode_call): For out of range calls, make -fPIC\n\ttake precedence, then TARGET_PORTABLE_RUNTIME, then ble.  Don't\n\treturn before delay slot checks when TARGET_PORTABLE_RUNTIME.\n\t* pa.md: Modify length attr calculation of all millicode insns to\n\tmatch above.\n\nFrom-SVN: r41042", "tree": {"sha": "c6caea6ff9b476e7af44d63f08933252d5a067b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6caea6ff9b476e7af44d63f08933252d5a067b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7721dc03fc45a4b8beef840491759d333b50431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7721dc03fc45a4b8beef840491759d333b50431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7721dc03fc45a4b8beef840491759d333b50431", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7721dc03fc45a4b8beef840491759d333b50431/comments", "author": null, "committer": null, "parents": [{"sha": "26ebcef1b52a133498c858484304e6c75ed4b454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ebcef1b52a133498c858484304e6c75ed4b454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ebcef1b52a133498c858484304e6c75ed4b454"}], "stats": {"total": 284, "additions": 135, "deletions": 149}, "files": [{"sha": "02f9845ec24e629cd1f7a8dfc6223f708f547f0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7721dc03fc45a4b8beef840491759d333b50431", "patch": "@@ -1,3 +1,17 @@\n+2001-04-03  Alan Modra  <alan@linuxcare.com.au>\n+\n+\t* pa.h: Revise comments for TARGET_NO_SPACE_REGS and\n+\tTARGET_FAST_INDIRECT_CALLS.\n+\t* pa.c (override_options): TARGET_NO_SPACE_REGS is now OK with\n+\t-fPIC.  Don't warn.\n+\t(return_addr_rtx): Short circuit export stub matching when\n+\tTARGET_NO_SPACE_REGS.\n+\t(output_millicode_call): For out of range calls, make -fPIC\n+\ttake precedence, then TARGET_PORTABLE_RUNTIME, then ble.  Don't\n+\treturn before delay slot checks when TARGET_PORTABLE_RUNTIME.\n+\t* pa.md: Modify length attr calculation of all millicode insns to\n+\tmatch above.\n+\n 2001-04-02  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* configure.in (gcc_cv_as_leb128): Correct name of cache variable.\n@@ -7,7 +21,7 @@\n \n 2001-04-03  Alan Modra  <alan@linuxcare.com.au>\n \n-\t* config/pa/pa.c (override_options): Remove PIC profiling warning.\n+\t* pa.c (override_options): Remove PIC profiling warning.\n \t(hp_profile_labelno): Delete.\n \t(hp_profile_label_rtx): Delete.\n \t(hp_profile_label_name): Delete.\n@@ -20,15 +34,15 @@\n \t(hppa_init_pic_save): Emit before tail_recursion_reentry, and\n \tcater for PROFILE_HOOK.\n \t(hppa_profile_hook): New function.\n-\t* config/pa/pa.h (FUNCTION_PROFILER): Now does nothing.\n+\t* pa.h (FUNCTION_PROFILER): Now does nothing.\n \t(PROFILE_HOOK): Define.\n \t(hppa_profile_hook): Declare.\n \t(PROFILE_BEFORE_PROLOGUE): Delete.\n \t(ASM_OUTPUT_REG_PUSH): Delete.\n \t(ASM_OUTPUT_REG_POP): Delete.\n-\t* config/pa/pa.md (call_profiler): Turn it into a call insn, and\n-\tdon't `use' r24.  Accept function name operand, and use this and a\n-\tlocally generated label to calculate pc-rel offset to func start.\n+\t* pa.md (call_profiler): Turn it into a call insn, and don't `use'\n+\tr24.  Accept function name operand, and use this and a locally\n+\tgenerated label to calculate pc-rel offset to func start.\n \n 2001-04-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n@@ -4476,8 +4490,6 @@ Thu Feb  1 07:22:41 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-01-31  Alan Modra <alan@linuxcare.com.au>\n \n-\t* (hppa_init_pic_save): Emit the pic offset table\n-\treg save after last_parm_insn.\n \t* pa.c (hppa_init_pic_save): New function.\n \t* pa.h (hppa_init_pic_save): Declare.\n \t* pa.md (call, call_value, sibcall, sibcall_value): Use"}, {"sha": "26e80966c95c73cc0787d688d7f71783a4e3757e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a7721dc03fc45a4b8beef840491759d333b50431", "patch": "@@ -162,7 +162,7 @@ override_options ()\n       warning (\"PIC code generation is not supported in the portable runtime model\\n\");\n     }\n \n-  if (flag_pic && (TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS))\n+  if (flag_pic && TARGET_FAST_INDIRECT_CALLS)\n    {\n       warning (\"PIC code generation is not compatible with fast indirect calls\\n\");\n    }\n@@ -3402,15 +3402,17 @@ return_addr_rtx (count, frameaddr)\n   rtx saved_rp;\n   rtx ins;\n \n-  saved_rp = gen_reg_rtx (Pmode);\n+  if (TARGET_64BIT)\n+    return gen_rtx_MEM (Pmode, plus_constant (frameaddr, -16));\n+\n+  if (TARGET_NO_SPACE_REGS)\n+    return gen_rtx_MEM (Pmode, plus_constant (frameaddr, -20));\n \n   /* First, we start off with the normal return address pointer from\n      -20[frameaddr].  */\n \n-  if (TARGET_64BIT)\n-    return gen_rtx_MEM (Pmode, plus_constant (frameaddr, -16));\n-  else\n-    emit_move_insn (saved_rp, plus_constant (frameaddr, -5 * UNITS_PER_WORD));\n+  saved_rp = gen_reg_rtx (Pmode);\n+  emit_move_insn (saved_rp, plus_constant (frameaddr, -20));\n \n   /* Get pointer to the instruction stream.  We have to mask out the\n      privilege level from the two low order bits of the return address\n@@ -3461,7 +3463,7 @@ return_addr_rtx (count, frameaddr)\n      but rather the return address that leads back into user code.\n      That return address is stored at -24[frameaddr].  */\n \n-  emit_move_insn (saved_rp, plus_constant (frameaddr, -6 * UNITS_PER_WORD));\n+  emit_move_insn (saved_rp, plus_constant (frameaddr, -24));\n \n   emit_label (label);\n   return gen_rtx_MEM (Pmode, memory_address (Pmode, saved_rp));\n@@ -5559,9 +5561,7 @@ output_millicode_call (insn, call_dest)\n   rtx xoperands[4];\n   rtx seq_insn;\n \n-  xoperands[3] = gen_rtx_REG (SImode, 31);\n-  if (TARGET_64BIT)\n-    xoperands[3] = gen_rtx_REG (SImode, 2);\n+  xoperands[3] = gen_rtx_REG (Pmode, TARGET_64BIT ? 2 : 31);\n \n   /* Handle common case -- empty delay slot or no jump in the delay slot,\n      and we're sure that the branch will reach the beginning of the $CODE$\n@@ -5597,18 +5597,32 @@ output_millicode_call (insn, call_dest)\n \t  delay_insn_deleted = 1;\n \t}\n \n-      /* If we're allowed to use be/ble instructions, then this is the\n-\t best sequence to use for a long millicode call.  */\n-      if (TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\n-\t  || ! (flag_pic  || TARGET_PORTABLE_RUNTIME))\n+      /* PIC long millicode call sequence.  */\n+      if (flag_pic)\n \t{\n \t  xoperands[0] = call_dest;\n-\t  output_asm_insn (\"ldil L%%%0,%3\", xoperands);\n-\t  output_asm_insn (\"{ble|be,l} R%%%0(%%sr4,%3)\", xoperands);\n+\t  xoperands[1] = gen_label_rtx ();\n+\t  /* Get our address + 8 into %r1.  */\n+\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\n+\t  /* Add %r1 to the offset of our target from the next insn.  */\n+\t  output_asm_insn (\"addil L%%%0-%1,%%r1\", xoperands);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t  output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n+\n+\t  /* Get the return address into %r31.  */\n+\t  output_asm_insn (\"blr 0,%3\", xoperands);\n+\n+\t  /* Branch to our target which is in %r1.  */\n+\t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n+\n+\t  /* Empty delay slot.  Note this insn gets fetched twice and\n+\t     executed once.  To be safe we use a nop.  */\n \t  output_asm_insn (\"nop\", xoperands);\n \t}\n       /* Pure portable runtime doesn't allow be/ble; we also don't have\n-\t PIC support int he assembler/linker, so this sequence is needed.  */\n+\t PIC support in the assembler/linker, so this sequence is needed.  */\n       else if (TARGET_PORTABLE_RUNTIME)\n \t{\n \t  xoperands[0] = call_dest;\n@@ -5625,30 +5639,14 @@ output_millicode_call (insn, call_dest)\n \t  /* Empty delay slot.  Note this insn gets fetched twice and\n \t     executed once.  To be safe we use a nop.  */\n \t  output_asm_insn (\"nop\", xoperands);\n-\t  return \"\";\n \t}\n-      /* PIC long millicode call sequence.  */\n+      /* If we're allowed to use be/ble instructions, then this is the\n+\t best sequence to use for a long millicode call.  */\n       else\n \t{\n \t  xoperands[0] = call_dest;\n-\t  xoperands[1] = gen_label_rtx ();\n-\t  /* Get our address + 8 into %r1.  */\n-\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\n-\t  /* Add %r1 to the offset of our target from the next insn.  */\n-\t  output_asm_insn (\"addil L%%%0-%1,%%r1\", xoperands);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-\t  output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n-\n-\t  /* Get the return address into %r31.  */\n-\t  output_asm_insn (\"blr 0,%3\", xoperands);\n-\n-\t  /* Branch to our target which is in %r1.  */\n-\t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n-\n-\t  /* Empty delay slot.  Note this insn gets fetched twice and\n-\t     executed once.  To be safe we use a nop.  */\n+\t  output_asm_insn (\"ldil L%%%0,%3\", xoperands);\n+\t  output_asm_insn (\"{ble|be,l} R%%%0(%%sr4,%3)\", xoperands);\n \t  output_asm_insn (\"nop\", xoperands);\n \t}\n "}, {"sha": "90d0de4b3f9223563e78f67f1aa4ddc2a6576166", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a7721dc03fc45a4b8beef840491759d333b50431", "patch": "@@ -106,13 +106,9 @@ extern int target_flags;\n #define MASK_DISABLE_FPREGS 2\n #define TARGET_DISABLE_FPREGS (target_flags & MASK_DISABLE_FPREGS)\n \n-/* Generate code which assumes that calls through function pointers will\n-   never cross a space boundary.  Such assumptions are generally safe for\n-   building kernels and statically linked executables.  Code compiled with\n-   this option will fail miserably if the executable is dynamically linked\n-   or uses nested functions!\n-\n-   This is also used to trigger aggressive unscaled index addressing.  */\n+/* Generate code which assumes that all space register are equivalent.\n+   Triggers aggressive unscaled index addressing and faster\n+   builtin_return_address.  */\n #define MASK_NO_SPACE_REGS 4\n #define TARGET_NO_SPACE_REGS (target_flags & MASK_NO_SPACE_REGS)\n \n@@ -148,7 +144,12 @@ extern int target_flags;\n #define MASK_LONG_LOAD_STORE 512\n #define TARGET_LONG_LOAD_STORE (target_flags & MASK_LONG_LOAD_STORE)\n \n-/* Use a faster sequence for indirect calls.  */\n+/* Use a faster sequence for indirect calls.  This assumes that calls\n+   through function pointers will never cross a space boundary, and\n+   that the executable is not dynamically linked.  Such assumptions\n+   are generally safe for building kernels and statically linked\n+   executables.  Code compiled with this option will fail miserably if\n+   the executable is dynamically linked or uses nested functions!  */\n #define MASK_FAST_INDIRECT_CALLS 1024\n #define TARGET_FAST_INDIRECT_CALLS (target_flags & MASK_FAST_INDIRECT_CALLS)\n "}, {"sha": "ceea64cfa82fc82ef37bca8a144291099c6f0179", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 72, "deletions": 97, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7721dc03fc45a4b8beef840491759d333b50431/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=a7721dc03fc45a4b8beef840491759d333b50431", "patch": "@@ -3942,21 +3942,18 @@\n                      (const_int 0)))\n             (const_int 4)\n \n-;; NO_SPACE_REGS\n-            (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; Out of reach PIC\n+            (ne (symbol_ref \"flag_pic\")\n                 (const_int 0))\n-            (const_int 8)\n+            (const_int 24)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-;; same as NO_SPACE_REGS code\n-            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0))\n-                 (eq (symbol_ref \"flag_pic\")\n-                     (const_int 0)))\n-            (const_int 8)]\n+;; Out of reach PORTABLE_RUNTIME\n+            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                (const_int 0))\n+            (const_int 20)]\n \n-;; Out of range and either PIC or PORTABLE_RUNTIME\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+          (const_int 12)))])\n \n (define_expand \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4049,21 +4046,18 @@\n                      (const_int 0)))\n             (const_int 4)\n \n-;; NO_SPACE_REGS\n-            (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; Out of reach PIC\n+            (ne (symbol_ref \"flag_pic\")\n                 (const_int 0))\n-            (const_int 8)\n+            (const_int 24)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-;; same as NO_SPACE_REGS code\n-            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0))\n-                 (eq (symbol_ref \"flag_pic\")\n-                     (const_int 0)))\n-            (const_int 8)]\n+;; Out of reach PORTABLE_RUNTIME\n+            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                (const_int 0))\n+            (const_int 20)]\n \n-;; Out of range and either PIC or PORTABLE_RUNTIME\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+          (const_int 12)))])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4107,21 +4101,18 @@\n                      (const_int 0)))\n             (const_int 4)\n \n-;; NO_SPACE_REGS\n-            (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; Out of reach PIC\n+            (ne (symbol_ref \"flag_pic\")\n                 (const_int 0))\n-            (const_int 8)\n+            (const_int 24)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-;; same as NO_SPACE_REGS code\n-            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0))\n-                 (eq (symbol_ref \"flag_pic\")\n-                     (const_int 0)))\n-            (const_int 8)]\n+;; Out of reach PORTABLE_RUNTIME\n+            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                (const_int 0))\n+            (const_int 20)]\n \n-;; Out of range and either PIC or PORTABLE_RUNTIME\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+          (const_int 12)))])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4162,21 +4153,18 @@\n                      (const_int 0)))\n             (const_int 4)\n \n-;; NO_SPACE_REGS\n-            (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; Out of reach PIC\n+            (ne (symbol_ref \"flag_pic\")\n                 (const_int 0))\n-            (const_int 8)\n+            (const_int 24)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-;; same as NO_SPACE_REGS code\n-            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0))\n-                 (eq (symbol_ref \"flag_pic\")\n-                     (const_int 0)))\n-            (const_int 8)]\n+;; Out of reach PORTABLE_RUNTIME\n+            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                (const_int 0))\n+            (const_int 20)]\n \n-;; Out of range and either PIC or PORTABLE_RUNTIME\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+          (const_int 12)))])\n \n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4217,21 +4205,18 @@\n                      (const_int 0)))\n             (const_int 4)\n \n-;; NO_SPACE_REGS\n-            (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; Out of reach PIC\n+            (ne (symbol_ref \"flag_pic\")\n                 (const_int 0))\n-            (const_int 8)\n+            (const_int 24)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-;; same as NO_SPACE_REGS code\n-            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0))\n-                 (eq (symbol_ref \"flag_pic\")\n-                     (const_int 0)))\n-            (const_int 8)]\n+;; Out of reach PORTABLE_RUNTIME\n+            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                (const_int 0))\n+            (const_int 20)]\n \n-;; Out of range and either PIC or PORTABLE_RUNTIME\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+          (const_int 12)))])\n \n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n@@ -5803,7 +5788,7 @@\n   rtx xoperands[2];\n \n   /* First the special case for kernels, level 0 systems, etc.  */\n-  if (TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS)\n+  if (TARGET_FAST_INDIRECT_CALLS)\n     return \\\"ble 0(%%sr4,%%r22)\\;copy %%r31,%%r2\\\";\n \n   /* Now the normal case -- we can reach $$dyncall directly or\n@@ -5838,8 +5823,8 @@\n   [(set_attr \"type\" \"dyncall\")\n    (set (attr \"length\")\n      (cond [\n-;; First NO_SPACE_REGS\n-\t    (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; First FAST_INDIRECT_CALLS\n+\t    (ne (symbol_ref \"TARGET_FAST_INDIRECT_CALLS\")\n \t\t(const_int 0))\n \t    (const_int 8)\n \n@@ -5850,19 +5835,18 @@\n \t\t     (const_int 0)))\n \t    (const_int 8)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-\t    (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t     (const_int 0))\n-\t\t (eq (symbol_ref \"flag_pic\")\n-\t\t     (const_int 0)))\n-\t    (const_int 12)\n+;; Out of reach PIC\n+\t    (ne (symbol_ref \"flag_pic\")\n+\t\t(const_int 0))\n+\t    (const_int 24)\n \n+;; Out of reach PORTABLE_RUNTIME\n \t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n \t\t(const_int 0))\n \t    (const_int 20)]\n \n-;; Out of range PIC case\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+\t  (const_int 12)))])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -5982,7 +5966,7 @@\n   rtx xoperands[2];\n \n   /* First the special case for kernels, level 0 systems, etc.  */\n-  if (TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS)\n+  if (TARGET_FAST_INDIRECT_CALLS)\n     return \\\"ble 0(%%sr4,%%r22)\\;copy %%r31,%%r2\\\";\n \n   /* Now the normal case -- we can reach $$dyncall directly or\n@@ -6017,8 +6001,8 @@\n   [(set_attr \"type\" \"dyncall\")\n    (set (attr \"length\")\n      (cond [\n-;; First NO_SPACE_REGS\n-\t    (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n+;; First FAST_INDIRECT_CALLS\n+\t    (ne (symbol_ref \"TARGET_FAST_INDIRECT_CALLS\")\n \t\t(const_int 0))\n \t    (const_int 8)\n \n@@ -6029,19 +6013,18 @@\n \t\t     (const_int 0)))\n \t    (const_int 8)\n \n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-\t    (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t     (const_int 0))\n-\t\t (eq (symbol_ref \"flag_pic\")\n-\t\t     (const_int 0)))\n-\t    (const_int 12)\n+;; Out of reach PIC\n+\t    (ne (symbol_ref \"flag_pic\")\n+\t\t(const_int 0))\n+\t    (const_int 24)\n \n+;; Out of reach PORTABLE_RUNTIME\n \t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n \t\t(const_int 0))\n \t    (const_int 20)]\n \n-;; Out of range PIC case\n-\t  (const_int 24)))])\n+;; Out of reach, can use ble\n+\t  (const_int 12)))])\n \n ;; Call subroutine returning any type.\n \n@@ -7109,26 +7092,18 @@\n                      (const_int 0)))\n             (const_int 28)\n \n-;; NO_SPACE_REGS\n-            (ne (symbol_ref \"TARGET_NO_SPACE_REGS || TARGET_FAST_INDIRECT_CALLS\")\n-                (const_int 0))\n-            (const_int 32)\n-\n-;; Out of reach, but not PIC or PORTABLE_RUNTIME\n-;; same as NO_SPACE_REGS code\n-            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0))\n-                 (eq (symbol_ref \"flag_pic\")\n-                     (const_int 0)))\n-            (const_int 32)\n+;; Out of reach PIC\n+\t    (ne (symbol_ref \"flag_pic\")\n+\t\t(const_int 0))\n+\t    (const_int 44)\n \n-;; PORTABLE_RUNTIME\n+;; Out of reach PORTABLE_RUNTIME\n \t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n \t\t(const_int 0))\n \t    (const_int 40)]\n \n-;; Out of range and PIC \n-\t  (const_int 44)))])\n+;; Out of reach, can use ble\n+          (const_int 32)))])\n \n ;; On the PA, the PIC register is call clobbered, so it must\n ;; be saved & restored around calls by the caller.  If the call"}]}