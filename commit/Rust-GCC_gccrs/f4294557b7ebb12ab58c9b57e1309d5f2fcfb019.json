{"sha": "f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQyOTQ1NTdiN2ViYjEyYWI1OGM5YjU3ZTEzMDlkNWYyZmNmYjAxOQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-02-22T03:13:35Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-02-22T03:13:35Z"}, "message": "[multiple changes]\n\n2005-02-21  Bryce McKinlay  <mckinlay@redhat.com>\n\n\tMerge serialization from GNU Classpath.\n\t* gcj/method.h: Add missing #includes.\n\t* java/io/ObjectInputStream.java (readClassDescriptor): Check for\n\tprimitive class IDs on the stream here...\n\t(resolveClass): ...not here.\n\t* java/io/ObjectStreamField.java: Use VMObjectStream class calls to set\n\tfields.\n\t* java/io/VMObjectStreamClass.java (setDoubleNative, setFloatNative,\n\tsetLongNative, setIntNative, setShortNative, setCharNative,\n\tsetByteNative, setBooleanNative, setObjectNative): New native methods.\n\t* java/io/natVMObjectStreamClass.java (setDoubleNative, setFloatNative,\n\tsetLongNative, setIntNative, setShortNative, setCharNative,\n\tsetByteNative, setBooleanNative, setObjectNative): Implement them.\n\t* java/io/natObjectInputStream.cc (allocateObject): Add new parameters\n\tfrom Classpath's version. Use _Jv_FromReflectedConstructor(). Call\n\tthe constructor here.\n\t(callConstructor): Removed.\n\t(getCallersClassLoader): Removed.\n\t* java/lang/reflect/Field.java (setByte, setShort, setInt, setLong,\n\tsetFloat, setDouble, setChar, setBoolean): Add 'checkFinal' parameter\n\tto control whether setting final field values is permitted. Call\n\tgetAddr() with checkFinal parameter instead of setAddr().\n\t* java/lang/reflect/natField.cc (getType): Lookup and resolve field\n\tonly if not done already.\n\t(getAddr): Add checkFinal parameter. Do the final field check only if\n\tcheckFinal is set.\n\t(setAddr): Removed.\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\t# Fixes bug #11957\n\t* java/io/ObjectInputStream.java (resolveClass): Don't check \"void\"\n\ttwice.\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\tFixes bug #11618.\n\t* java/io/ObjectInputStream.java (readClassDescriptor): Handle classes\n\twithout a super class and us ObjectStreamClass.lookupForClassObject().\n\t(resolveClass): Check for primitive types.\n\t(lookupClass): Return null when argument is null.\n\n2005-02-21  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/io/ObjectInputStream.java\n\t(readObject): Fix to consume TC_ENDBLOCKDATA after readExternal.\n\n2005-02-21  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/io/ObjectOutputStream.java\n\t(writeObject, callWriteMethod): Replaced reflection with accessing\n\tcached info in ObjectStreamClass.\n\t(getMethod): Removed.\n\t* java/io/ObjectStreamClass.java\n\t(findMethod): Added check to make sure the method found has the\n\tright modifiers.\n\t(cacheMethods): Added writeReplace and writeObject methods.\n\t(setFlags): Look at new writeObjectMethod field instead of doing\n\treflection again.\n\t(writeReplaceMethod): New field.\n\t(writeObjectMethod): New field.\n\n2005-02-21  Guilhem Lavaux  <guilhem@kaffe.org>\n\tJeroen Frijters  <jeroen@frijters.net>\n\n\t* java/io/ObjectInputStream.java\n\t(newObject): Changed prototype. Get a constructor reflect object\n\tdirectly.\n\t(callConstructor): Removed.\n\t(allocateObject): Changed prototype.\n\t(readClassDescriptor): Build the constructor reflection directly.\n\t(readObject): Invoke newObject using the new prototype.\n\n\t* java/io/ObjectStreamClass.java\n\t(firstNonSerializableParent): Removed.\n\t(firstNonSerializableParentConstructor): Added.\n\nFrom-SVN: r95378", "tree": {"sha": "3b41b785f371a92850d3442fff7b7deb7e7ec0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b41b785f371a92850d3442fff7b7deb7e7ec0c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/comments", "author": null, "committer": null, "parents": [{"sha": "bb2e1640492f6b6989131cef45519dfd47a1acbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb2e1640492f6b6989131cef45519dfd47a1acbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb2e1640492f6b6989131cef45519dfd47a1acbb"}], "stats": {"total": 703, "additions": 451, "deletions": 252}, "files": [{"sha": "0d9622712bb92aeec10556944f88becaceb5be58", "filename": "libjava/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -1,3 +1,82 @@\n+2005-02-21  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tMerge serialization from GNU Classpath.\n+\t* gcj/method.h: Add missing #includes.\n+\t* java/io/ObjectInputStream.java (readClassDescriptor): Check for \n+\tprimitive class IDs on the stream here...\n+\t(resolveClass): ...not here.\n+\t* java/io/ObjectStreamField.java: Use VMObjectStream class calls to set\n+\tfields.\n+\t* java/io/VMObjectStreamClass.java (setDoubleNative, setFloatNative,\n+\tsetLongNative, setIntNative, setShortNative, setCharNative,\n+\tsetByteNative, setBooleanNative, setObjectNative): New native methods.\n+\t* java/io/natVMObjectStreamClass.java (setDoubleNative, setFloatNative,\n+\tsetLongNative, setIntNative, setShortNative, setCharNative,\n+\tsetByteNative, setBooleanNative, setObjectNative): Implement them.\n+\t* java/io/natObjectInputStream.cc (allocateObject): Add new parameters\n+\tfrom Classpath's version. Use _Jv_FromReflectedConstructor(). Call\n+\tthe constructor here.\n+\t(callConstructor): Removed.\n+\t(getCallersClassLoader): Removed.\n+\t* java/lang/reflect/Field.java (setByte, setShort, setInt, setLong,\n+\tsetFloat, setDouble, setChar, setBoolean): Add 'checkFinal' parameter\n+\tto control whether setting final field values is permitted. Call\n+\tgetAddr() with checkFinal parameter instead of setAddr().\n+\t* java/lang/reflect/natField.cc (getType): Lookup and resolve field\n+\tonly if not done already.\n+\t(getAddr): Add checkFinal parameter. Do the final field check only if\n+\tcheckFinal is set.\n+\t(setAddr): Removed.\n+\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t# Fixes bug #11957\n+\t* java/io/ObjectInputStream.java (resolveClass): Don't check \"void\"\n+\ttwice.\n+\t\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\tFixes bug #11618.\n+\t* java/io/ObjectInputStream.java (readClassDescriptor): Handle classes\n+\twithout a super class and us ObjectStreamClass.lookupForClassObject().\n+\t(resolveClass): Check for primitive types.\n+\t(lookupClass): Return null when argument is null.\n+\n+2005-02-21  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(readObject): Fix to consume TC_ENDBLOCKDATA after readExternal.\n+\n+2005-02-21  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/io/ObjectOutputStream.java\n+\t(writeObject, callWriteMethod): Replaced reflection with accessing\n+\tcached info in ObjectStreamClass.\n+\t(getMethod): Removed.\n+\t* java/io/ObjectStreamClass.java\n+\t(findMethod): Added check to make sure the method found has the\n+\tright modifiers.\n+\t(cacheMethods): Added writeReplace and writeObject methods.\n+\t(setFlags): Look at new writeObjectMethod field instead of doing\n+\treflection again.\n+\t(writeReplaceMethod): New field.\n+\t(writeObjectMethod): New field.\n+\n+2005-02-21  Guilhem Lavaux  <guilhem@kaffe.org>\n+\tJeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(newObject): Changed prototype. Get a constructor reflect object\n+\tdirectly.\n+\t(callConstructor): Removed.\n+\t(allocateObject): Changed prototype.\n+\t(readClassDescriptor): Build the constructor reflection directly.\n+\t(readObject): Invoke newObject using the new prototype.\n+\n+\t* java/io/ObjectStreamClass.java\n+\t(firstNonSerializableParent): Removed.\n+\t(firstNonSerializableParentConstructor): Added.\t\n+\n 2005-02-21  Mark Wielaard  <mark@klomp.org>\n \n \t* gnu/java/locale/LocaleInformation_en.java: Extend"}, {"sha": "f97f865f920d5b61b12cf743615b7260efbb2552", "filename": "libjava/gcj/method.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fgcj%2Fmethod.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fgcj%2Fmethod.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fmethod.h?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -12,6 +12,8 @@ details.  */\n #define __GCJ_METHOD_H__\n \n #include <java/lang/Class.h>\n+#include <java/lang/reflect/Constructor.h>\n+#include <java/lang/reflect/Method.h>\n \n extern inline jmethodID\n _Jv_FromReflectedMethod (java::lang::reflect::Method *method)"}, {"sha": "2cfe4c99419bdfee8d00a9243de70cece540305c", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -43,6 +43,7 @@\n import gnu.java.io.ObjectIdentityWrapper;\n \n import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n@@ -122,15 +123,6 @@ else if (dump == true && (val == null || val.equals(\"\")))\n    */\n   public final Object readObject() throws ClassNotFoundException, IOException\n   {\n-\tif (callersClassLoader == null)\n-\t  {\n-\t\tcallersClassLoader = getCallersClassLoader ();\n-\t\tif (Configuration.DEBUG && dump)\n-\t\t  {\n-\t\t\tdumpElementln (\"CallersClassLoader = \" + callersClassLoader);\n-\t\t  }\n-\t  }\n-\t\n     if (this.useSubclassMethod)\n       return readObjectOverride();\n \n@@ -272,7 +264,7 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t      readArrayElements(array, componentType);\n \t      if(dump)\n \t        for (int i = 0, len = Array.getLength(array); i < len; i++)\n-\t\t\t  dumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n+\t\t  dumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n \t      ret_val = processResolution(null, array, handle);\n \t      break;\n \t    }\n@@ -302,13 +294,18 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t\t  obj.readExternal(this);\n \t\t  \n \t\t  if (read_from_blocks)\n-\t\t    setBlockDataMode(oldmode);\n+                    {\n+\t\t      setBlockDataMode(oldmode);\n+                      if (!oldmode)\n+\t\t\tif (this.realInputStream.readByte() != TC_ENDBLOCKDATA)\n+\t\t\t    throw new IOException(\"No end of block data seen for class with readExternal (ObjectInputStream) method.\");\n+                    }\n \t\t  \n \t\t  ret_val = processResolution(osc, obj, handle);\n \t\t  break;\n \t\t} // end if (osc.realClassIsExternalizable)\n \n-\t      Object obj = newObject(clazz, osc.firstNonSerializableParent);\n+\t      Object obj = newObject(clazz, osc.firstNonSerializableParentConstructor);\n \t      \n \t      int handle = assignNewHandle(obj);\n \t      Object prevObject = this.currentObject;\n@@ -399,8 +396,6 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \tsetBlockDataMode(old_mode);\n \t\n \tthis.isDeserializing = was_deserializing;\n-\n-\tdepth -= 2;\n \t\n \tdepth -= 2;\n \t\n@@ -506,7 +501,8 @@ protected ObjectStreamClass readClassDescriptor()\n \t\t\t\t\t\t  flags, fields);\n     assignNewHandle(osc);\n \n-    ClassLoader currentLoader = currentLoader();\n+    if (callersClassLoader == null)\n+      callersClassLoader = currentLoader();\n \t      \n     for (int i = 0; i < field_count; i++)\n       {\n@@ -527,12 +523,40 @@ protected ObjectStreamClass readClassDescriptor()\n \t  class_name = String.valueOf(type_code);\n \t\t  \n \tfields[i] =\n-\t  new ObjectStreamField(field_name, class_name, currentLoader);\n+\t  new ObjectStreamField(field_name, class_name, callersClassLoader);\n       }\n \t      \n     /* Now that fields have been read we may resolve the class\n      * (and read annotation if needed). */\n-    Class clazz = resolveClass(osc);\n+    Class clazz;\n+    try\n+      {\n+\tclazz = resolveClass(osc);\n+      }\n+    catch (ClassNotFoundException cnfe)\n+      {\n+\t// Maybe it was an primitive class?\n+\tif (name.equals(\"void\"))\n+\t  clazz = Void.TYPE;\n+\telse if (name.equals(\"boolean\"))\n+\t  clazz = Boolean.TYPE;\n+\telse if (name.equals(\"byte\"))\n+\t  clazz = Byte.TYPE;\n+\telse if (name.equals(\"short\"))\n+\t  clazz = Short.TYPE;\n+\telse if (name.equals(\"char\"))\n+\t  clazz = Character.TYPE;\n+\telse if (name.equals(\"int\"))\n+\t  clazz = Integer.TYPE;\n+\telse if (name.equals(\"long\"))\n+\t  clazz = Long.TYPE;\n+\telse if (name.equals(\"float\"))\n+\t  clazz = Float.TYPE;\n+\telse if (name.equals(\"double\"))\n+\t  clazz = Double.TYPE;\n+\telse\n+\t  throw cnfe;\n+      }\n \n     boolean oldmode = setBlockDataMode(true);\n     osc.setClass(clazz, lookupClass(clazz.getSuperclass()));\n@@ -542,16 +566,45 @@ protected ObjectStreamClass readClassDescriptor()\n     // find the first non-serializable, non-abstract\n     // class in clazz's inheritance hierarchy\n     Class first_nonserial = clazz.getSuperclass();\n-    while (Serializable.class.isAssignableFrom(first_nonserial)\n-\t|| Modifier.isAbstract(first_nonserial.getModifiers()))\n+    // Maybe it is a primitive class, those don't have a super class,\n+    // or Object itself.  Otherwise we can keep getting the superclass\n+    // till we hit the Object class, or some other non-serializable class.\n+\n+    if (first_nonserial == null)\n+      first_nonserial = clazz;\n+    else\n+      while (Serializable.class.isAssignableFrom(first_nonserial)\n+\t     || Modifier.isAbstract(first_nonserial.getModifiers()))\n \tfirst_nonserial = first_nonserial.getSuperclass();\n \n-    osc.firstNonSerializableParent = first_nonserial;\n+    final Class local_constructor_class = first_nonserial;\n+\n+    osc.firstNonSerializableParentConstructor =\n+        (Constructor)AccessController.doPrivileged(new PrivilegedAction()\n+          {\n+            public Object run()\n+            {\n+              try\n+                {\n+                  Constructor c = local_constructor_class.\n+                                    getDeclaredConstructor(new Class[0]);\n+                  if (Modifier.isPrivate(c.getModifiers()))\n+                    return null;\n+                  return c;\n+                }\n+              catch (NoSuchMethodException e)\n+                {\n+                  // error will be reported later, in newObject()\n+                  return null;\n+                }\n+            }\n+          });\n+\n     osc.realClassIsSerializable = Serializable.class.isAssignableFrom(clazz);\n     osc.realClassIsExternalizable = Externalizable.class.isAssignableFrom(clazz);\n \n     ObjectStreamField[] stream_fields = osc.fields;\n-    ObjectStreamField[] real_fields = ObjectStreamClass.lookup(clazz).fields;\n+    ObjectStreamField[] real_fields = ObjectStreamClass.lookupForClassObject(clazz).fields;\n     ObjectStreamField[] fieldmapping = new ObjectStreamField[2 * Math.max(stream_fields.length, real_fields.length)];\n \n     int stream_idx = 0;\n@@ -717,6 +770,15 @@ public void registerValidation(ObjectInputValidation validator,\n   protected Class resolveClass(ObjectStreamClass osc)\n     throws ClassNotFoundException, IOException\n   {\n+    if (callersClassLoader == null)\n+      {\n+\tcallersClassLoader = currentLoader ();\n+\tif (Configuration.DEBUG && dump)\n+\t  {\n+\t    dumpElementln (\"CallersClassLoader = \" + callersClassLoader);\n+\t  }\n+      }\n+\n     return Class.forName(osc.getName(), true, callersClassLoader);\n   }\n \n@@ -750,8 +812,10 @@ private ClassLoader currentLoader()\n    */\n   private ObjectStreamClass lookupClass(Class clazz)\n   {\n-    ObjectStreamClass oclazz;\n+    if (clazz == null)\n+      return null;\n \n+    ObjectStreamClass oclazz;\n     oclazz = (ObjectStreamClass)classLookupTable.get(clazz);\n     if (oclazz == null)\n       return ObjectStreamClass.lookup(clazz);\n@@ -1767,14 +1831,14 @@ private boolean setBlockDataMode (boolean on)\n \n   // returns a new instance of REAL_CLASS that has been constructed\n   // only to the level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)\n-  private Object newObject (Class real_class, Class constructor_class)\n-    throws ClassNotFoundException\n+  private Object newObject (Class real_class, Constructor constructor)\n+    throws ClassNotFoundException, IOException\n   {\n+    if (constructor == null)\n+        throw new InvalidClassException(\"Missing accessible no-arg base class constructor for \" + real_class.getName()); \n     try\n       {\n-\tObject obj = allocateObject (real_class);\n-\tcallConstructor (constructor_class, obj);\n-\treturn obj;\n+\treturn allocateObject(real_class, constructor.getDeclaringClass(), constructor);\n       }\n     catch (InstantiationException e)\n       {\n@@ -1810,8 +1874,6 @@ private void invokeValidators() throws InvalidObjectException\n    * @return The current class loader in the calling stack.\n    */\n   private static native ClassLoader currentClassLoader (SecurityManager sm);\n-  \n-  private native ClassLoader getCallersClassLoader();\n \n   private void callReadMethod (Method readObject, Class klass, Object obj)\n     throws ClassNotFoundException, IOException\n@@ -1844,11 +1906,9 @@ private void callReadMethod (Method readObject, Class klass, Object obj)\n     prereadFields = null;\n   }\n     \n-  private native Object allocateObject (Class clazz)\n+  private native Object allocateObject(Class clazz, Class constr_clazz, Constructor constructor)\n     throws InstantiationException;\n \n-  private native void callConstructor (Class clazz, Object obj);\n-\n   private static final int BUFFER_SIZE = 1024;\n \n   private DataInputStream realInputStream;\n@@ -1870,9 +1930,8 @@ private native Object allocateObject (Class clazz)\n   private Hashtable classLookupTable;\n   private GetField prereadFields;\n \n-  private static boolean dump = false && Configuration.DEBUG;\n-\n   private ClassLoader callersClassLoader;\n+  private static boolean dump;\n \n   // The nesting depth for debugging output\n   private int depth = 0;"}, {"sha": "55763eeddfe3e0082b7f0bd873ee92ac84cda26e", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -250,26 +250,23 @@ public final void writeObject(Object obj) throws IOException\n \t\tbreak;\n \t      }\n \n+\t    Class clazz = obj.getClass();\n+\t    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(clazz);\n+\t    if (osc == null)\n+\t      throw new NotSerializableException(clazz.getName());\n+\t    \n \t    if ((replacementEnabled || obj instanceof Serializable)\n \t\t&& ! replaceDone)\n \t      {\n \t\treplacedObject = obj;\n \t\t\n \t\tif (obj instanceof Serializable)\n \t\t  {\n-\t\t    Method m = null;\n \t\t    try\n \t\t      {\n-\t\t\tClass classArgs[] = {};\n-\t\t\tm = getMethod(obj.getClass(), \"writeReplace\",\n-\t\t\t\t      classArgs);\n-\t\t\t// m can't be null by definition since an\n-\t\t\t// exception would have been thrown so a check\n-\t\t\t// for null is not needed.\n-\t\t\tobj = m.invoke(obj, new Object[] {});\n-\t\t      }\n-\t\t    catch (NoSuchMethodException ignore)\n-\t\t      {\n+                        Method m = osc.writeReplaceMethod;\n+                        if (m != null)\n+                            obj = m.invoke(obj, new Object[0]);\n \t\t      }\n \t\t    catch (IllegalAccessException ignore)\n \t\t      {\n@@ -294,11 +291,6 @@ public final void writeObject(Object obj) throws IOException\n \t\tbreak;\n \t      }\n \n-\t    Class clazz = obj.getClass();\n-\t    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(clazz);\n-\t    if (osc == null)\n-\t      throw new NotSerializableException(clazz.getName());\n-\t    \n \t    if (clazz.isArray ())\n \t      {\n \t\trealOutput.writeByte(TC_ARRAY);\n@@ -347,8 +339,8 @@ public final void writeObject(Object obj) throws IOException\n \t\t    fieldsAlreadyWritten = false;\n \t\t    if (currentObjectStreamClass.hasWriteMethod())\n \t\t      {\n-\t\t\t\tif (dump)\n-\t\t\t\t  dumpElementln (\"WRITE METHOD CALLED FOR: \" + obj);\n+\t\t\tif (dump)\n+\t\t\t  dumpElementln (\"WRITE METHOD CALLED FOR: \" + obj);\n \t\t\tsetBlockDataMode(true);\n \t\t\tcallWriteMethod(obj, currentObjectStreamClass);\n \t\t\tsetBlockDataMode(false);\n@@ -358,10 +350,10 @@ public final void writeObject(Object obj) throws IOException\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\t\tif (dump)\n-\t\t\t\t  dumpElementln (\"WRITE FIELDS CALLED FOR: \" + obj);\n-\t\t\t\twriteFields(obj, currentObjectStreamClass);\n-\t\t\t  }\n+\t\t\tif (dump)\n+\t\t\t  dumpElementln (\"WRITE FIELDS CALLED FOR: \" + obj);\n+\t\t\twriteFields(obj, currentObjectStreamClass);\n+\t\t      }\n \t\t  }\n \n \t\tthis.currentObject = prevObject;\n@@ -1261,18 +1253,11 @@ boolean setBlockDataMode(boolean on) throws IOException\n   private void callWriteMethod(Object obj, ObjectStreamClass osc)\n     throws IOException\n   {\n-    Class klass = osc.forClass();\n     currentPutField = null;\n     try\n       {\n-\tClass classArgs[] = {ObjectOutputStream.class};\n-\tMethod m = getMethod(klass, \"writeObject\", classArgs);\n-\tObject args[] = {this};\n-\tm.invoke(obj, args);\t\n-      }\n-    catch (NoSuchMethodException nsme)\n-      {\n-\t// Nothing.\n+        Object args[] = {this};\n+        osc.writeObjectMethod.invoke(obj, args);\n       }\n     catch (InvocationTargetException x)\n       {\n@@ -1285,15 +1270,17 @@ private void callWriteMethod(Object obj, ObjectStreamClass osc)\n \n \tIOException ioe\n \t  = new IOException(\"Exception thrown from writeObject() on \" +\n-\t\t\t    klass + \": \" + exception.getClass().getName());\n+\t\t\t    osc.forClass().getName() + \": \" +\n+                            exception.getClass().getName());\n \tioe.initCause(exception);\n \tthrow ioe;\n       }\n     catch (Exception x)\n       {\n \tIOException ioe\n \t  = new IOException(\"Failure invoking writeObject() on \" +\n-\t\t\t    klass + \": \" + x.getClass().getName());\n+\t\t\t    osc.forClass().getName() + \": \" +\n+\t\t\t    x.getClass().getName());\n \tioe.initCause(x);\n \tthrow ioe;\n       }\n@@ -1535,15 +1522,6 @@ private Field getField (Class klass, String name)\n       }\n   }\n \n-  private Method getMethod (Class klass, String name, Class[] args)\n-    throws java.lang.NoSuchMethodException\n-  {\n-    final Method m = klass.getDeclaredMethod(name, args);\n-    setAccessible.setMember(m);\n-    AccessController.doPrivileged(setAccessible);\n-    return m;\n-  }\n-\n   private void dumpElementln (String msg)\n   {\n     for (int i = 0; i < depth; i++)"}, {"sha": "8c1a5db7b59fa09bd4573800e749c966318e892c", "filename": "libjava/java/io/ObjectStreamField.java", "status": "modified", "additions": 9, "deletions": 72, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FObjectStreamField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FObjectStreamField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamField.java?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -367,109 +367,46 @@ public String toString ()\n \n   final void setBooleanField(Object obj, boolean val)\n   {\n-    try\n-      {\n-\tfield.setBoolean(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setBooleanNative(field, obj, val);  \n   }\n \n   final void setByteField(Object obj, byte val)\n   {\n-    try\n-      {\n-\tfield.setByte(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setByteNative(field, obj, val);\n   }\n   \n   final void setCharField(Object obj, char val)\n   {\n-    try\n-      {\n-\tfield.setChar(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setCharNative(field, obj, val);\n   }\n   \n   final void setShortField(Object obj, short val)\n   {\n-    try\n-      {\n-\tfield.setShort(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setShortNative(field, obj, val);\n   }\n \n   final void setIntField(Object obj, int val)\n   {\n-    try\n-      {\n-\tfield.setInt(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setIntNative(field, obj, val);\n   }\n   \n   final void setLongField(Object obj, long val)\n   {\n-    try\n-      {\n-\tfield.setLong(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setLongNative(field, obj, val);\n   }\n   \n   final void setFloatField(Object obj, float val)\n   {\n-    try\n-      {\n-\tfield.setFloat(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setFloatNative(field, obj, val);\n   }\n   \n   final void setDoubleField(Object obj, double val)\n   {\n-    try\n-      {\n-\tfield.setDouble(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setDoubleNative(field, obj, val);\n   }\n   \n   final void setObjectField(Object obj, Object val)\n   { \n-    try\n-      {\n-\tfield.set(obj, val);\n-      }\n-    catch(IllegalAccessException x)\n-      {\n-\tthrow new InternalError(x.getMessage());\n-      }\n+    VMObjectStreamClass.setObjectNative(field, obj, val);\n   }\n }"}, {"sha": "d21de72a13077cc79fbd836287d6255e6ddcfcc3", "filename": "libjava/java/io/VMObjectStreamClass.java", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FVMObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FVMObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FVMObjectStreamClass.java?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -38,7 +38,7 @@\n \n package java.io;\n \n-import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n \n final class VMObjectStreamClass\n {\n@@ -47,4 +47,94 @@\n     * (a.k.a. <clinit>).\n     */\n   static native boolean hasClassInitializer (Class clazz);\n+\n+  /**\n+   * Sets the value of the specified \"double\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setDoubleNative(Field field, Object obj, double val);\n+\n+  /**\n+   * Sets the value of the specified \"float\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setFloatNative(Field field, Object obj, float val);\n+\n+  /**\n+   * Sets the value of the specified \"long\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setLongNative(Field field, Object obj, long val);\n+  \n+  /**\n+   * Sets the value of the specified \"int\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setIntNative(Field field, Object obj, int val);\n+  \n+  /**\n+   * Sets the value of the specified \"short\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setShortNative(Field field, Object obj, short val);\n+\n+  /**\n+   * Sets the value of the specified \"char\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setCharNative(Field field, Object obj, char val);\n+\n+  /**\n+   * Sets the value of the specified \"byte\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setByteNative(Field field, Object obj, byte val);\n+\n+  /**\n+   * Sets the value of the specified \"boolean\" field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setBooleanNative(Field field, Object obj, boolean val);\n+\n+  /**\n+   * Sets the value of the specified object field, allowing final values \n+   * to be assigned.\n+   *\n+   * @param field Field to set the value.\n+   * @param obj Instance which will have its field set.\n+   * @param val Value to put in the field.\n+   */\n+  static native void setObjectNative(Field field, Object obj, Object val);\n }"}, {"sha": "0e0d5a719cc7d4409b90cf18163bb2cfc94d9c86", "filename": "libjava/java/io/natObjectInputStream.cc", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -12,6 +12,7 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <gcj/method.h>\n \n #include <java/io/ObjectInputStream$GetField.h>\n #include <java/io/ObjectInputStream.h>\n@@ -21,14 +22,17 @@ details.  */\n #include <java/lang/reflect/Method.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/SecurityManager.h>\n+#include <java/lang/reflect/Constructor.h>\n+#include <java/lang/reflect/Method.h>\n \n #ifdef DEBUG\n #include <java/lang/System.h>\n #include <java/io/PrintStream.h>\n #endif\n \n jobject\n-java::io::ObjectInputStream::allocateObject (jclass klass)\n+java::io::ObjectInputStream::allocateObject (jclass klass, jclass,\n+  ::java::lang::reflect::Constructor *ctr)\n {\n   jobject obj = NULL;\n   using namespace java::lang::reflect;\n@@ -41,58 +45,28 @@ java::io::ObjectInputStream::allocateObject (jclass klass)\n       else\n \t{\n \t  obj = _Jv_AllocObject (klass);\n-\t}\n+\t}\t\n     }\n   catch (jthrowable t)\n     {\n       return NULL;\n     }\n \n-  return obj;\n-}\n-\n+  jmethodID meth = _Jv_FromReflectedConstructor (ctr);\n \n-void \n-java::io::ObjectInputStream::callConstructor (jclass klass, jobject obj)\n-{ \n-  jstring init_name = JvNewStringLatin1 (\"<init>\");\n   // This is a bit inefficient, and a bit of a hack, since we don't\n   // actually use the Method and since what is returned isn't\n   // technically a Method.  We can't use Method.invoke as it looks up\n   // the declared method.\n   JArray<jclass> *arg_types\n     = (JArray<jclass> *) JvNewObjectArray (0, &java::lang::Class::class$,\n \t\t\t\t\t   NULL);\n-  java::lang::reflect::Method *m = klass->getPrivateMethod (init_name,\n-\t\t\t\t\t\t\t    arg_types);\n+\n   // We lie about this being a constructor.  If we put `true' here\n   // then _Jv_CallAnyMethodA would try to allocate the object for us.\n-  jmethodID meth = (jmethodID) ((char *) (klass->methods)\n-\t\t\t\t+ m->offset);\n   _Jv_CallAnyMethodA (obj, JvPrimClass (void), meth, false, arg_types, NULL);\n-}\n \n-java::lang::ClassLoader* \n-java::io::ObjectInputStream::getCallersClassLoader ()\n-{\n-  java::lang::ClassLoader *loader = NULL;\n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(4);\n-  java::lang::Class *klass = NULL;\n-  try\n-    {\n-      for (int i = 2; !klass; i++)\n-\t{\n-\t  klass = t->classAt (i);\n-\t}\n-      loader = klass->getClassLoaderInternal();\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-      // FIXME: RuntimeError\n-    }\n-\n-  return loader;\n+  return obj;\n }\n \n java::lang::ClassLoader*"}, {"sha": "847b540f0be3f17e95d248275008167676dc3ae7", "filename": "libjava/java/io/natVMObjectStreamClass.cc", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FnatVMObjectStreamClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Fio%2FnatVMObjectStreamClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatVMObjectStreamClass.cc?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -13,11 +13,75 @@ details.  */\n \n #include <java/io/VMObjectStreamClass.h>\n #include <java/lang/Class.h>\n+#include <java/lang/reflect/Field.h>\n+\n+using namespace java::lang::reflect;\n \n jboolean\n java::io::VMObjectStreamClass::hasClassInitializer (jclass klass)\n {\n+  if (klass->isPrimitive())\n+    return false;\n   _Jv_Method *meth = _Jv_GetMethodLocal(klass, gcj::clinit_name,\n \t\t\t\t\t       gcj::void_signature);\n   return (meth != NULL);\n }\n+\n+void\n+java::io::VMObjectStreamClass::setDoubleNative (Field *f, jobject obj, \n+\t\t\t\t\t\tjdouble val)\n+{\n+  f->setDouble (NULL, obj, val, false);\n+}\n+\n+void \n+java::io::VMObjectStreamClass::setFloatNative (Field *f, jobject obj, \n+\t\t\t\t\t       jfloat val)\n+{\n+  f->setFloat (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setLongNative (Field *f, jobject obj, jlong val)\n+{\n+  f->setLong (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setIntNative (Field *f, jobject obj, jint val)\n+{\n+  f->setInt (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setShortNative (Field *f, jobject obj, \n+\t\t\t\t\t       jshort val)\n+{\n+  f->setShort (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setCharNative (Field *f, jobject obj, jchar val)\n+{\n+  f->setChar (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setByteNative (Field *f, jobject obj, jbyte val)\n+{\n+  f->setByte (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setBooleanNative (Field *f, jobject obj,\n+\t\t\t\t\t\t jboolean val)\n+{\n+  f->setBoolean (NULL, obj, val, false);\n+}\n+\n+void\n+java::io::VMObjectStreamClass::setObjectNative (Field *f, jobject obj, \n+\t\t\t\t\t\tjobject val)\n+{\n+  f->set (NULL, obj, val, f->getType(), false);\n+}"}, {"sha": "cb852cf2fb2fb4b916a57e677082ff268a8562c0", "filename": "libjava/java/lang/reflect/Field.java", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Flang%2Freflect%2FField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Flang%2Freflect%2FField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FField.java?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -23,6 +23,9 @@ public final class Field extends AccessibleObject implements Member\n   // Offset in bytes from the start of declaringClass's fields array.\n   private int offset;\n \n+  // The Class (or primitive TYPE) of this field.\n+  private Class type;\n+\n   // This is instantiated by Class sometimes, but it uses C++ and\n   // avoids the Java protection check.\n   Field ()\n@@ -136,76 +139,79 @@ private native Object get (Class caller, Object obj)\n   public void setByte (Object obj, byte b)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setByte(null, obj, b);\n+    setByte(null, obj, b, true);\n   }\n \n   public void setShort (Object obj,  short s)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setShort(null, obj, s);\n+    setShort(null, obj, s, true);\n   }\n \n   public void setInt (Object obj, int i)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setInt(null, obj, i);\n+    setInt(null, obj, i, true);\n   }\n \n   public void setLong (Object obj, long l)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setLong(null, obj, l);\n+    setLong(null, obj, l, true);\n   }\n \n   public void setFloat (Object obj, float f)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setFloat(null, obj, f);\n+    setFloat(null, obj, f, true);\n   }\n \n   public void setDouble (Object obj, double d)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setDouble(null, obj, d);\n+    setDouble(null, obj, d, true);\n   }\n \n   public void setChar (Object obj, char c)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setChar(null, obj, c);\n+    setChar(null, obj, c, true);\n   }\n \n   public void setBoolean (Object obj, boolean b)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n-    setBoolean(null, obj, b);\n+    setBoolean(null, obj, b, true);\n   }\n \n-  private native void setByte (Class caller, Object obj, byte b)\n+  native void setByte (Class caller, Object obj, byte b, boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setShort (Class caller, Object obj, short s)\n+  native void setShort (Class caller, Object obj, short s, boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setInt (Class caller, Object obj, int i)\n+  native void setInt (Class caller, Object obj, int i, boolean checkFinal)  \n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setLong (Class caller, Object obj, long l)\n+  native void setLong (Class caller, Object obj, long l, boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setFloat (Class caller, Object obj, float f)\n+  native void setFloat (Class caller, Object obj, float f, boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setDouble (Class caller, Object obj, double d)\n+  native void setDouble (Class caller, Object obj, double d,\n+\t\t\t boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setChar (Class caller, Object obj, char c)\n+  native void setChar (Class caller, Object obj, char c, boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void setBoolean (Class caller, Object obj, boolean b)\n+  native void setBoolean (Class caller, Object obj, boolean b,\n+\t\t\t  boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  private native void set (Class caller, Object obj, Object val, Class type)\n+  native void set (Class caller, Object obj, Object val, Class type, \n+\t\t   boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n   public void set (Object object, Object value)\n@@ -219,23 +225,23 @@ private void set (Class caller, Object object, Object value)\n   {\n     Class type = getType();\n     if (! type.isPrimitive())\n-      set(caller, object, value, type);\n+      set(caller, object, value, type, true);\n     else if (value instanceof Byte)\n-      setByte(caller, object, ((Byte) value).byteValue());\n+      setByte(caller, object, ((Byte) value).byteValue(), true);\n     else if (value instanceof Short)\n-      setShort (caller, object, ((Short) value).shortValue());\n+      setShort (caller, object, ((Short) value).shortValue(), true);\n     else if (value instanceof Integer)\n-      setInt(caller, object, ((Integer) value).intValue());\n+      setInt(caller, object, ((Integer) value).intValue(), true);\n     else if (value instanceof Long)\n-      setLong(caller, object, ((Long) value).longValue());\n+      setLong(caller, object, ((Long) value).longValue(), true);\n     else if (value instanceof Float)\n-      setFloat(caller, object, ((Float) value).floatValue());\n+      setFloat(caller, object, ((Float) value).floatValue(), true);\n     else if (value instanceof Double)\n-      setDouble(caller, object, ((Double) value).doubleValue());\n+      setDouble(caller, object, ((Double) value).doubleValue(), true);\n     else if (value instanceof Character)\n-      setChar(caller, object, ((Character) value).charValue());\n+      setChar(caller, object, ((Character) value).charValue(), true);\n     else if (value instanceof Boolean)\n-      setBoolean(caller, object, ((Boolean) value).booleanValue());\n+      setBoolean(caller, object, ((Boolean) value).booleanValue(), true);\n     else\n       throw new IllegalArgumentException();\n   }"}, {"sha": "9a8107b795d38c4f48130a8cc8d54e30c957f949", "filename": "libjava/java/lang/reflect/natField.cc", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4294557b7ebb12ab58c9b57e1309d5f2fcfb019/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=f4294557b7ebb12ab58c9b57e1309d5f2fcfb019", "patch": "@@ -45,14 +45,19 @@ java::lang::reflect::Field::getName ()\n jclass\n java::lang::reflect::Field::getType ()\n {\n-  jfieldID fld = _Jv_FromReflectedField (this);\n-  JvSynchronize sync (declaringClass);\n-  _Jv_Linker::resolve_field (fld, declaringClass->getClassLoaderInternal ());\n-  return fld->type;\n+  if (type == NULL)\n+    {\n+      jfieldID fld = _Jv_FromReflectedField (this);\n+      JvSynchronize sync (declaringClass);\n+      _Jv_Linker::resolve_field (fld, declaringClass->getClassLoaderInternal ());\n+      type = fld->type;\n+    }\n+  return type;\n }\n \n static void*\n-getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj)\n+getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj,\n+         jboolean checkFinal)\n {\n   // FIXME: we know CALLER is NULL here.  At one point we planned to\n   // have the compiler insert the caller as a hidden argument in some\n@@ -63,6 +68,12 @@ getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj)\n   \n   jfieldID fld = _Jv_FromReflectedField (field);\n   _Jv_ushort flags = fld->getModifiers();\n+\n+  // Setting a final field is usually not allowed.\n+  if (checkFinal\n+      && field->getModifiers() & java::lang::reflect::Modifier::FINAL)\n+    throw new java::lang::IllegalAccessException(JvNewStringUTF \n+      (\"Field is final\"));\n   \n   // Check accessibility, if required.\n   if (! (Modifier::isPublic (flags) || field->isAccessible()))\n@@ -180,56 +191,56 @@ getDouble (jclass cls, void* addr)\n jboolean\n java::lang::reflect::Field::getBoolean (jclass caller, jobject obj)\n {\n-  return ::getBoolean (this->getType(), getAddr (this, caller, obj));\n+  return ::getBoolean (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jchar\n java::lang::reflect::Field::getChar (jclass caller, jobject obj)\n {\n-  return ::getChar (this->getType(), getAddr (this, caller, obj));\n+  return ::getChar (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jbyte\n java::lang::reflect::Field::getByte (jclass caller, jobject obj)\n {\n-  return ::getByte (this->getType(), getAddr (this, caller, obj));\n+  return ::getByte (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jshort\n java::lang::reflect::Field::getShort (jclass caller, jobject obj)\n {\n-  return ::getShort (this->getType(), getAddr (this, caller, obj));\n+  return ::getShort (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jint\n java::lang::reflect::Field::getInt (jclass caller, jobject obj)\n {\n-  return ::getInt (this->getType(), getAddr (this, caller, obj));\n+  return ::getInt (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jlong\n java::lang::reflect::Field::getLong (jclass caller, jobject obj)\n {\n-  return ::getLong (this->getType(), getAddr (this, caller, obj));\n+  return ::getLong (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jfloat\n java::lang::reflect::Field::getFloat (jclass caller, jobject obj)\n {\n-  return ::getFloat (this->getType(), getAddr (this, caller, obj));\n+  return ::getFloat (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jdouble\n java::lang::reflect::Field::getDouble (jclass caller, jobject obj)\n {\n-  return ::getDouble (this->getType(), getAddr (this, caller, obj));\n+  return ::getDouble (this->getType(), getAddr (this, caller, obj, false));\n }\n \n jobject\n java::lang::reflect::Field::get (jclass caller, jobject obj)\n {\n   jclass type = this->getType();\n-  void* addr = getAddr (this, caller, obj);\n+  void* addr = getAddr (this, caller, obj, false);\n   if (! type->isPrimitive ())\n     return * (jobject*) addr;\n   if (type == JvPrimClass (double))\n@@ -257,16 +268,6 @@ java::lang::reflect::Field::get (jclass caller, jobject obj)\n   throw new java::lang::IllegalArgumentException;\n }\n \n-static void*\n-setAddr (java::lang::reflect::Field* field, jclass caller, jobject obj)\n-{\n-  void *addr = getAddr(field, caller, obj);\n-  if  (!field->isAccessible()\n-\t&& field->getModifiers() & java::lang::reflect::Modifier::FINAL)\n-    throw new java::lang::IllegalAccessException();\n-  return addr;\n-}\n-\n static void\n setBoolean (jclass type, void *addr, jboolean value)\n {\n@@ -378,57 +379,66 @@ setDouble (jclass type, void *addr, jdouble value)\n }\n \n void\n-java::lang::reflect::Field::setBoolean (jclass caller, jobject obj, jboolean b)\n+java::lang::reflect::Field::setBoolean (jclass caller, jobject obj, jboolean b,\n+\t\t\t\t\tjboolean checkFinal)\n {\n-  ::setBoolean (this->getType(), setAddr (this, caller, obj), b);\n+  ::setBoolean (this->getType(), getAddr (this, caller, obj, checkFinal), b);\n }\n \n void\n-java::lang::reflect::Field::setChar (jclass caller, jobject obj, jchar c)\n+java::lang::reflect::Field::setChar (jclass caller, jobject obj, jchar c,\n+\t\t\t\t     jboolean checkFinal)\n {\n-  ::setChar (this->getType(), setAddr (this, caller, obj), c);\n+  ::setChar (this->getType(), getAddr (this, caller, obj, checkFinal), c);\n }\n \n void\n-java::lang::reflect::Field::setByte (jclass caller, jobject obj, jbyte b)\n+java::lang::reflect::Field::setByte (jclass caller, jobject obj, jbyte b,\n+\t\t\t\t     jboolean checkFinal)\n {\n-  ::setByte (this->getType(), setAddr (this, caller, obj), b);\n+  ::setByte (this->getType(), getAddr (this, caller, obj, checkFinal), b);\n }\n \n void\n-java::lang::reflect::Field::setShort (jclass caller, jobject obj, jshort s)\n+java::lang::reflect::Field::setShort (jclass caller, jobject obj, jshort s,\n+\t\t\t\t      jboolean checkFinal)\n {\n-  ::setShort (this->getType(), setAddr (this, caller, obj), s);\n+  ::setShort (this->getType(), getAddr (this, caller, obj, checkFinal), s);\n }\n \n void\n-java::lang::reflect::Field::setInt (jclass caller, jobject obj, jint i)\n+java::lang::reflect::Field::setInt (jclass caller, jobject obj, jint i,\n+\t\t\t\t    jboolean checkFinal)\n {\n-  ::setInt (this->getType(), setAddr (this, caller, obj), i);\n+  ::setInt (this->getType(), getAddr (this, caller, obj, checkFinal), i);\n }\n \n void\n-java::lang::reflect::Field::setLong (jclass caller, jobject obj, jlong l)\n+java::lang::reflect::Field::setLong (jclass caller, jobject obj, jlong l,\n+\t\t\t\t     jboolean checkFinal)\n {\n-  ::setLong (this->getType(), setAddr (this, caller, obj), l);\n+  ::setLong (this->getType(), getAddr (this, caller, obj, checkFinal), l);\n }\n+\n void\n-java::lang::reflect::Field::setFloat (jclass caller, jobject obj, jfloat f)\n+java::lang::reflect::Field::setFloat (jclass caller, jobject obj, jfloat f,\n+\t\t\t\t      jboolean checkFinal)\n {\n-  ::setFloat (this->getType(), setAddr (this, caller, obj), f);\n+  ::setFloat (this->getType(), getAddr (this, caller, obj, checkFinal), f);\n }\n \n void\n-java::lang::reflect::Field::setDouble (jclass caller, jobject obj, jdouble d)\n+java::lang::reflect::Field::setDouble (jclass caller, jobject obj, jdouble d,\n+\t\t\t\t       jboolean checkFinal)\n {\n-  ::setDouble (this->getType(), setAddr (this, caller, obj), d);\n+  ::setDouble (this->getType(), getAddr (this, caller, obj, checkFinal), d);\n }\n \n void\n java::lang::reflect::Field::set (jclass caller, jobject object, jobject value,\n-\t\t\t\t jclass type)\n+\t\t\t\t jclass type, jboolean checkFinal)\n {\n-  void* addr = setAddr (this, caller, object);\n+  void* addr = getAddr (this, caller, object, checkFinal);\n   if (value != NULL && ! _Jv_IsInstanceOf (value, type))\n     throw new java::lang::IllegalArgumentException;\n   * (jobject*) addr = value;"}]}