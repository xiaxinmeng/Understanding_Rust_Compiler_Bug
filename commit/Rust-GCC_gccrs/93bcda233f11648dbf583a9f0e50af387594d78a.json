{"sha": "93bcda233f11648dbf583a9f0e50af387594d78a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiY2RhMjMzZjExNjQ4ZGJmNTgzYTlmMGU1MGFmMzg3NTk0ZDc4YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:24:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:24:31Z"}, "message": "[multiple changes]\n\n2009-04-17  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Add documentation about No_Streams restriction\n\n\t* sem_attr.adb (Check_Stream_Attribute): Exclude implicit stream\n\tattributes when checking No_Streams restriction.\n\n2009-04-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* rtsfind.ads (RE_Request_Destroy): New PolyORB s-parint entity.\n\n\t* exp_dist.adb (PolyORB_Support.Build_General_Calling_Stubs): Add\n\tmissing calls to RE_Request_Destroy to deallocate request objects after\n\tuse.\n\n2009-04-17  Nicolas Setton  <setton@adacore.com>\n\n\t* link.c: Fix support for passing a response file under Darwin.\n\n2009-04-17  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb (Free): new subprogram.\n\n2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb: additional initialization on incomplete subtypes.\n\t\n\t* sem_ch6.adb (Process_Formals): if the subprogram is in the private\n\tpart and one of the formals is an incomplete tagged type, attach to\n\tlist of private dependends of the type for later validation.\n\n\t* sem_ch7.adb (Uninstall_Declarations): diagnose attempts to declare\n\tprimitive operations of a Taft-amendmment type.\n\n\t* freeze.adb (Freeze_Entity): Remove tests on formals of an incomplete\n\ttype. The check is performed on package exit, possibly after the\n\tsubprogram is frozen.\n\n2009-04-17  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Get_Directories): Get the object and exec directory\n\tbefore looking for source directories, but make sure that there are nil\n\tif they are not explicitely declared and there is explicitely no\n\tsources in the project.\n\nFrom-SVN: r146227", "tree": {"sha": "3f29dc65f74494cef564daa36014a76c44be4d21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f29dc65f74494cef564daa36014a76c44be4d21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93bcda233f11648dbf583a9f0e50af387594d78a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bcda233f11648dbf583a9f0e50af387594d78a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93bcda233f11648dbf583a9f0e50af387594d78a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bcda233f11648dbf583a9f0e50af387594d78a/comments", "author": null, "committer": null, "parents": [{"sha": "ba4a2f78eeb327397844448956bcc7abd5729050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4a2f78eeb327397844448956bcc7abd5729050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4a2f78eeb327397844448956bcc7abd5729050"}], "stats": {"total": 573, "additions": 346, "deletions": 227}, "files": [{"sha": "6e3db147b45c61df8ee769507aaec2cf63823c3d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -1,3 +1,48 @@\n+2009-04-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Add documentation about No_Streams restriction\n+\n+\t* sem_attr.adb (Check_Stream_Attribute): Exclude implicit stream\n+\tattributes when checking No_Streams restriction.\n+\n+2009-04-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* rtsfind.ads (RE_Request_Destroy): New PolyORB s-parint entity.\n+\n+\t* exp_dist.adb (PolyORB_Support.Build_General_Calling_Stubs): Add\n+\tmissing calls to RE_Request_Destroy to deallocate request objects after\n+\tuse.\n+\n+2009-04-17  Nicolas Setton  <setton@adacore.com>\n+\n+\t* link.c: Fix support for passing a response file under Darwin.\n+\n+2009-04-17  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb (Free): new subprogram.\n+\n+2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb: additional initialization on incomplete subtypes.\n+\t\n+\t* sem_ch6.adb (Process_Formals): if the subprogram is in the private\n+\tpart and one of the formals is an incomplete tagged type, attach to\n+\tlist of private dependends of the type for later validation.\n+\n+\t* sem_ch7.adb (Uninstall_Declarations): diagnose attempts to declare\n+\tprimitive operations of a Taft-amendmment type.\n+\n+\t* freeze.adb (Freeze_Entity): Remove tests on formals of an incomplete\n+\ttype. The check is performed on package exit, possibly after the\n+\tsubprogram is frozen.\n+\n+2009-04-17  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Get_Directories): Get the object and exec directory\n+\tbefore looking for source directories, but make sure that there are nil\n+\tif they are not explicitely declared and there is explicitely no\n+\tsources in the project.\n+\n 2009-04-17  Pascal Obry  <obry@adacore.com>\n \n \t* initialize.c: Set gnat_argv with UTF-8 encoded strings on Windows."}, {"sha": "f1ddc009f5a0d0db7b9f406c29bf749856497ec0", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -7157,13 +7157,37 @@ package body Exp_Dist is\n       is\n          Loc : constant Source_Ptr := Sloc (Nod);\n \n+         Request : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+         --  The request object constructed by these stubs\n+         --  Could we use Name_R instead??? (see GLADE client stubs)\n+\n+         function Make_Request_RTE_Call\n+           (RE      : RE_Id;\n+            Actuals : List_Id := New_List) return Node_Id;\n+         --  Generate a procedure call statement calling RE with the given\n+         --  actuals. Request is appended to the list.\n+\n+         ---------------------------\n+         -- Make_Request_RTE_Call --\n+         ---------------------------\n+\n+         function Make_Request_RTE_Call\n+           (RE      : RE_Id;\n+            Actuals : List_Id := New_List) return Node_Id\n+         is\n+         begin\n+            Append_To (Actuals, New_Occurrence_Of (Request, Loc));\n+            return Make_Procedure_Call_Statement (Loc,\n+                     Name                   =>\n+                       New_Occurrence_Of (RTE (RE), Loc),\n+                     Parameter_Associations => Actuals);\n+         end Make_Request_RTE_Call;\n+\n          Arguments : Node_Id;\n          --  Name of the named values list used to transmit parameters\n          --  to the remote package\n \n-         Request : Node_Id;\n-         --  The request object constructed by these stubs\n-\n          Result : Node_Id;\n          --  Name of the result named value (in non-APC cases) which get the\n          --  result of the remote subprogram.\n@@ -7194,8 +7218,8 @@ package body Exp_Dist is\n          --  after the regular statements for writing out parameters.\n \n          After_Statements : constant List_Id := New_List;\n-         --  Statements to be executed after call returns (to assign\n-         --  in out or out parameter values).\n+         --  Statements to be executed after call returns (to assign IN OUT or\n+         --  OUT parameter values).\n \n          Etyp : Entity_Id;\n          --  The type of the formal parameter being processed\n@@ -7209,7 +7233,6 @@ package body Exp_Dist is\n \n       begin\n          --  ??? document general form of stub subprograms for the PolyORB case\n-         Request := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n \n          Append_To (Decls,\n            Make_Object_Declaration (Loc,\n@@ -7449,19 +7472,13 @@ package body Exp_Dist is\n          Append_List_To (Statements, Extra_Formal_Statements);\n \n          Append_To (Statements,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Occurrence_Of (RTE (RE_Request_Create), Loc),\n-\n-             Parameter_Associations => New_List (\n-               Target_Object,\n-               Subprogram_Id,\n-               New_Occurrence_Of (Arguments, Loc),\n-               New_Occurrence_Of (Result, Loc),\n-               New_Occurrence_Of (RTE (RE_Nil_Exc_List), Loc))));\n-\n-         Append_To (Parameter_Associations (Last (Statements)),\n-               New_Occurrence_Of (Request, Loc));\n+           Make_Request_RTE_Call (RE_Request_Create, New_List (\n+                                    Target_Object,\n+                                    Subprogram_Id,\n+                                    New_Occurrence_Of (Arguments, Loc),\n+                                    New_Occurrence_Of (Result, Loc),\n+                                    New_Occurrence_Of\n+                                      (RTE (RE_Nil_Exc_List), Loc))));\n \n          pragma Assert\n            (not (Is_Known_Non_Asynchronous and Is_Known_Asynchronous));\n@@ -7487,22 +7504,22 @@ package body Exp_Dist is\n                  RTE (RE_Asynchronous_P_To_Sync_Scope), Loc),\n              Expressions => New_List (Asynchronous_P)));\n \n-         Append_To (Statements,\n-             Make_Procedure_Call_Statement (Loc,\n-               Name                   =>\n-                 New_Occurrence_Of (RTE (RE_Request_Invoke), Loc),\n-               Parameter_Associations => New_List (\n-                 New_Occurrence_Of (Request, Loc))));\n+         Append_To (Statements, Make_Request_RTE_Call (RE_Request_Invoke));\n \n-         Non_Asynchronous_Statements := New_List (Make_Null_Statement (Loc));\n-         Asynchronous_Statements := New_List (Make_Null_Statement (Loc));\n+         --  Asynchronous case\n \n-         if not Is_Known_Asynchronous then\n+         if not Is_Known_Non_Asynchronous then\n+            Asynchronous_Statements :=\n+              New_List (Make_Request_RTE_Call (RE_Request_Destroy));\n+         end if;\n \n+         --  Non-asynchronous case\n+\n+         if not Is_Known_Asynchronous then\n             --  Reraise an exception occurrence from the completed request.\n             --  If the exception occurrence is empty, this is a no-op.\n \n-            Append_To (Non_Asynchronous_Statements,\n+            Non_Asynchronous_Statements := New_List (\n               Make_Procedure_Call_Statement (Loc,\n                 Name                   =>\n                   New_Occurrence_Of (RTE (RE_Request_Raise_Occurrence), Loc),\n@@ -7511,6 +7528,9 @@ package body Exp_Dist is\n \n             if Is_Function then\n \n+               Append_To (Non_Asynchronous_Statements,\n+                 Make_Request_RTE_Call (RE_Request_Destroy));\n+\n                --  If this is a function call, read the value and return it\n \n                Append_To (Non_Asynchronous_Statements,\n@@ -7522,11 +7542,18 @@ package body Exp_Dist is\n                           Prefix        => Result,\n                           Selector_Name => Name_Argument),\n                         Decls))));\n+\n+            else\n+\n+               --  Case of a procedure: deal with IN OUT and OUT formals\n+\n+               Append_List_To (Non_Asynchronous_Statements, After_Statements);\n+\n+               Append_To (Non_Asynchronous_Statements,\n+                 Make_Request_RTE_Call (RE_Request_Destroy));\n             end if;\n          end if;\n \n-         Append_List_To (Non_Asynchronous_Statements, After_Statements);\n-\n          if Is_Known_Asynchronous then\n             Append_List_To (Statements, Asynchronous_Statements);\n "}, {"sha": "9530c7578da966d2c69bf18546c09e0ef642f3ff", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 41, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -2483,36 +2483,17 @@ package body Freeze is\n                         Error_Msg_Qual_Level := 0;\n                      end if;\n \n-                     --  Ada 2005 (AI-326): Check wrong use of tag incomplete\n-                     --  types with unknown discriminants. For example:\n-\n-                     --    type T (<>) is tagged;\n-                     --    procedure P (X : access T); -- ERROR\n-                     --    procedure P (X : T);        -- ERROR\n-\n                      if not From_With_Type (F_Type) then\n                         if Is_Access_Type (F_Type) then\n                            F_Type := Designated_Type (F_Type);\n                         end if;\n \n-                        if Ekind (F_Type) = E_Incomplete_Type\n-                          and then Is_Tagged_Type (F_Type)\n-                          and then not Is_Class_Wide_Type (F_Type)\n-                          and then No (Full_View (F_Type))\n-                          and then Unknown_Discriminants_Present\n-                                     (Parent (F_Type))\n-                          and then No (Stored_Constraint (F_Type))\n-                        then\n-                           Error_Msg_N\n-                             (\"(Ada 2005): invalid use of unconstrained tagged\"\n-                              & \" incomplete type\", E);\n-\n                         --  If the formal is an anonymous_access_to_subprogram\n                         --  freeze the  subprogram type as well, to prevent\n                         --  scope anomalies in gigi, because there is no other\n                         --  clear point at which it could be frozen.\n \n-                        elsif Is_Itype (Etype (Formal))\n+                        if Is_Itype (Etype (Formal))\n                           and then Ekind (F_Type) = E_Subprogram_Type\n                         then\n                            Freeze_And_Append (F_Type, Loc, Result);\n@@ -2522,7 +2503,7 @@ package body Freeze is\n                      Next_Formal (Formal);\n                   end loop;\n \n-                  --  Case of function\n+                  --  Case of function: similar checks on return type.\n \n                   if Ekind (E) = E_Function then\n \n@@ -2594,34 +2575,17 @@ package body Freeze is\n                         end if;\n                      end if;\n \n-                     if Is_Array_Type (Etype (E))\n-                       and then not Is_Constrained (Etype (E))\n+                     if Is_Array_Type (R_Type)\n+                       and then not Is_Constrained (R_Type)\n                        and then not Is_Imported (E)\n                        and then Has_Foreign_Convention (E)\n                        and then Warn_On_Export_Import\n                        and then not Has_Warnings_Off (E)\n-                       and then not Has_Warnings_Off (Etype (E))\n+                       and then not Has_Warnings_Off (R_Type)\n                      then\n                         Error_Msg_N\n                           (\"?foreign convention function& should not \" &\n                            \"return unconstrained array!\", E);\n-\n-                     --  Ada 2005 (AI-326): Check wrong use of\n-                     --  incomplete type\n-\n-                     --    type T;   --  tagged or just incomplete.\n-                     --    function F (X : Boolean) return T; -- ERROR\n-\n-                     --  The type must be declared in the current scope for the\n-                     --  use to be legal, and the full view must be available\n-                     --  when the construct that mentions it is frozen.\n-\n-                     elsif Ekind (Etype (E)) = E_Incomplete_Type\n-                       and then No (Full_View (Etype (E)))\n-                       and then not Is_Value_Type (Etype (E))\n-                     then\n-                        Error_Msg_NE\n-                          (\"invalid use of incomplete type&\", E, Etype (E));\n                      end if;\n                   end if;\n                end;"}, {"sha": "9ce6255410a001a1fda7d575f80d3eede12787df", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -8610,6 +8610,12 @@ This restriction does not forbid dependences on the package\n as long as no actual stream objects are created and no\n stream attributes are used.\n \n+Note that the use of restriction allows optimization of tagged types,\n+since they do not need to worry about dispatching stream operations.\n+To take maximum advantage of this space-saving optimization, any\n+unit declaring a tagged type should be compiled with the restriction,\n+though this is not required.\n+\n @item No_Task_Attributes_Package\n @findex No_Task_Attributes_Package\n This restriction ensures at compile time that there are no implicit or"}, {"sha": "5dd2c80d9010dedc87591c833fec66a8e59b44a2", "filename": "gcc/ada/link.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -153,12 +153,12 @@ unsigned char __gnat_using_gnu_linker = 1;\n const char *__gnat_object_library_extension = \".a\";\n \n #elif defined (__APPLE__)\n-const char *__gnat_object_file_option = \"\";\n+const char *__gnat_object_file_option = \"-Wl,-filelist,\";\n const char *__gnat_run_path_option = \"-Wl,-rpath,\";\n char __gnat_shared_libgnat_default = STATIC;\n int __gnat_link_max = 262144;\n unsigned char __gnat_objlist_file_supported = 1;\n-unsigned char __gnat_using_gnu_linker = 1;\n+unsigned char __gnat_using_gnu_linker = 0;\n const char *__gnat_object_library_extension = \".a\";\n \n #elif defined (linux) || defined(__GLIBC__)"}, {"sha": "ce5eccf71a3eb82734f8ccfca5118564a9445853", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 136, "deletions": 143, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -5796,6 +5796,10 @@ package body Prj.Nmsc is\n                       Util.Value_Of\n                         (Name_Source_Files, Data.Decl.Attributes, In_Tree);\n \n+      Languages : constant Variable_Value :=\n+                      Prj.Util.Value_Of\n+                        (Name_Languages, Data.Decl.Attributes, In_Tree);\n+\n       Last_Source_Dir : String_List_Id  := Nil_String;\n \n       procedure Find_Source_Dirs\n@@ -6217,154 +6221,25 @@ package body Prj.Nmsc is\n          Write_Line (\"Starting to look for directories\");\n       end if;\n \n-      --  We set the object directory to its default. It may be set to nil, if\n-      --  there is no sources in the project.\n-\n-      Data.Object_Directory := Data.Directory;\n-\n-      --  Look for the source directories\n-\n-      if Current_Verbosity = High then\n-         Write_Line (\"Starting to look for source directories\");\n-      end if;\n-\n-      pragma Assert (Source_Dirs.Kind = List, \"Source_Dirs is not a list\");\n+      --  Set the object directory to its default which may be nil, if there\n+      --  is no sources in the project.\n \n-      if (not Source_Files.Default) and then\n-        Source_Files.Values = Nil_String\n+      if (((not Source_Files.Default)\n+           and then Source_Files.Values = Nil_String)\n+          or else\n+          ((not Source_Dirs.Default) and then Source_Dirs.Values = Nil_String)\n+           or else\n+          ((not Languages.Default) and then Languages.Values = Nil_String))\n+        and then Data.Extends = No_Project\n       then\n-         Data.Source_Dirs := Nil_String;\n-\n-         if Data.Qualifier = Standard then\n-            Error_Msg\n-              (Project,\n-               In_Tree,\n-               \"a standard project cannot have no sources\",\n-               Source_Files.Location);\n-         end if;\n-\n-         if Data.Extends = No_Project\n-           and then Data.Object_Directory = Data.Directory\n-         then\n-            Data.Object_Directory := No_Path_Information;\n-         end if;\n-\n-      elsif Source_Dirs.Default then\n-\n-         --  No Source_Dirs specified: the single source directory is the one\n-         --  containing the project file\n-\n-         String_Element_Table.Increment_Last\n-           (In_Tree.String_Elements);\n-         Data.Source_Dirs := String_Element_Table.Last\n-           (In_Tree.String_Elements);\n-         In_Tree.String_Elements.Table (Data.Source_Dirs) :=\n-           (Value         => Name_Id (Data.Directory.Name),\n-            Display_Value => Name_Id (Data.Directory.Display_Name),\n-            Location      => No_Location,\n-            Flag          => False,\n-            Next          => Nil_String,\n-            Index         => 0);\n-\n-         if Current_Verbosity = High then\n-            Write_Line (\"Single source directory:\");\n-            Write_Str (\"    \"\"\");\n-            Write_Str (Get_Name_String (Data.Directory.Display_Name));\n-            Write_Line (\"\"\"\");\n-         end if;\n-\n-      elsif Source_Dirs.Values = Nil_String then\n-         if Data.Qualifier = Standard then\n-            Error_Msg\n-              (Project,\n-               In_Tree,\n-               \"a standard project cannot have no source directories\",\n-               Source_Dirs.Location);\n-         end if;\n-\n-         --  If Source_Dirs is an empty string list, this means that this\n-         --  project contains no source. For projects that don't extend other\n-         --  projects, this also means that there is no need for an object\n-         --  directory, if not specified.\n-\n-         if Data.Extends = No_Project\n-           and then  Data.Object_Directory = Data.Directory\n-         then\n-            Data.Object_Directory := No_Path_Information;\n-         end if;\n-\n-         Data.Source_Dirs := Nil_String;\n+         Data.Object_Directory := No_Path_Information;\n \n       else\n-         declare\n-            Source_Dir : String_List_Id;\n-            Element    : String_Element;\n-\n-         begin\n-            --  Process the source directories for each element of the list\n-\n-            Source_Dir := Source_Dirs.Values;\n-            while Source_Dir /= Nil_String loop\n-               Element := In_Tree.String_Elements.Table (Source_Dir);\n-               Find_Source_Dirs\n-                 (File_Name_Type (Element.Value), Element.Location);\n-               Source_Dir := Element.Next;\n-            end loop;\n-         end;\n-      end if;\n-\n-      if not Excluded_Source_Dirs.Default\n-        and then Excluded_Source_Dirs.Values /= Nil_String\n-      then\n-         declare\n-            Source_Dir : String_List_Id;\n-            Element    : String_Element;\n-\n-         begin\n-            --  Process the source directories for each element of the list\n-\n-            Source_Dir := Excluded_Source_Dirs.Values;\n-            while Source_Dir /= Nil_String loop\n-               Element := In_Tree.String_Elements.Table (Source_Dir);\n-               Find_Source_Dirs\n-                 (File_Name_Type (Element.Value),\n-                  Element.Location,\n-                  Removed => True);\n-               Source_Dir := Element.Next;\n-            end loop;\n-         end;\n-      end if;\n-\n-      if Current_Verbosity = High then\n-         Write_Line (\"Putting source directories in canonical cases\");\n+         Data.Object_Directory := Data.Directory;\n       end if;\n \n-      declare\n-         Current : String_List_Id := Data.Source_Dirs;\n-         Element : String_Element;\n-\n-      begin\n-         while Current /= Nil_String loop\n-            Element := In_Tree.String_Elements.Table (Current);\n-            if Element.Value /= No_Name then\n-               if not Osint.File_Names_Case_Sensitive then\n-                  Get_Name_String (Element.Value);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Element.Value := Name_Find;\n-               end if;\n-\n-               In_Tree.String_Elements.Table (Current) := Element;\n-            end if;\n-\n-            Current := Element.Next;\n-         end loop;\n-      end;\n-\n       --  Check the object directory\n \n-      pragma Assert (Object_Dir.Kind = Single,\n-                     \"Object_Dir is not a single string\");\n-\n       if Object_Dir.Value /= Empty_String then\n          Get_Name_String (Object_Dir.Value);\n \n@@ -6452,9 +6327,6 @@ package body Prj.Nmsc is\n \n       --  Check the exec directory\n \n-      pragma Assert (Exec_Dir.Kind = Single,\n-                     \"Exec_Dir is not a single string\");\n-\n       --  We set the object directory to its default\n \n       Data.Exec_Directory   := Data.Object_Directory;\n@@ -6502,6 +6374,127 @@ package body Prj.Nmsc is\n             Write_Line (\"\"\"\");\n          end if;\n       end if;\n+\n+      --  Look for the source directories\n+\n+      if Current_Verbosity = High then\n+         Write_Line (\"Starting to look for source directories\");\n+      end if;\n+\n+      pragma Assert (Source_Dirs.Kind = List, \"Source_Dirs is not a list\");\n+\n+      if (not Source_Files.Default) and then\n+        Source_Files.Values = Nil_String\n+      then\n+         Data.Source_Dirs := Nil_String;\n+\n+         if Data.Qualifier = Standard then\n+            Error_Msg\n+              (Project,\n+               In_Tree,\n+               \"a standard project cannot have no sources\",\n+               Source_Files.Location);\n+         end if;\n+\n+      elsif Source_Dirs.Default then\n+\n+         --  No Source_Dirs specified: the single source directory is the one\n+         --  containing the project file\n+\n+         String_Element_Table.Increment_Last\n+           (In_Tree.String_Elements);\n+         Data.Source_Dirs := String_Element_Table.Last\n+           (In_Tree.String_Elements);\n+         In_Tree.String_Elements.Table (Data.Source_Dirs) :=\n+           (Value         => Name_Id (Data.Directory.Name),\n+            Display_Value => Name_Id (Data.Directory.Display_Name),\n+            Location      => No_Location,\n+            Flag          => False,\n+            Next          => Nil_String,\n+            Index         => 0);\n+\n+         if Current_Verbosity = High then\n+            Write_Line (\"Single source directory:\");\n+            Write_Str (\"    \"\"\");\n+            Write_Str (Get_Name_String (Data.Directory.Display_Name));\n+            Write_Line (\"\"\"\");\n+         end if;\n+\n+      elsif Source_Dirs.Values = Nil_String then\n+         if Data.Qualifier = Standard then\n+            Error_Msg\n+              (Project,\n+               In_Tree,\n+               \"a standard project cannot have no source directories\",\n+               Source_Dirs.Location);\n+         end if;\n+\n+         Data.Source_Dirs := Nil_String;\n+\n+      else\n+         declare\n+            Source_Dir : String_List_Id;\n+            Element    : String_Element;\n+\n+         begin\n+            --  Process the source directories for each element of the list\n+\n+            Source_Dir := Source_Dirs.Values;\n+            while Source_Dir /= Nil_String loop\n+               Element := In_Tree.String_Elements.Table (Source_Dir);\n+               Find_Source_Dirs\n+                 (File_Name_Type (Element.Value), Element.Location);\n+               Source_Dir := Element.Next;\n+            end loop;\n+         end;\n+      end if;\n+\n+      if not Excluded_Source_Dirs.Default\n+        and then Excluded_Source_Dirs.Values /= Nil_String\n+      then\n+         declare\n+            Source_Dir : String_List_Id;\n+            Element    : String_Element;\n+\n+         begin\n+            --  Process the source directories for each element of the list\n+\n+            Source_Dir := Excluded_Source_Dirs.Values;\n+            while Source_Dir /= Nil_String loop\n+               Element := In_Tree.String_Elements.Table (Source_Dir);\n+               Find_Source_Dirs\n+                 (File_Name_Type (Element.Value),\n+                  Element.Location,\n+                  Removed => True);\n+               Source_Dir := Element.Next;\n+            end loop;\n+         end;\n+      end if;\n+\n+      if Current_Verbosity = High then\n+         Write_Line (\"Putting source directories in canonical cases\");\n+      end if;\n+\n+      declare\n+         Current : String_List_Id := Data.Source_Dirs;\n+         Element : String_Element;\n+\n+      begin\n+         while Current /= Nil_String loop\n+            Element := In_Tree.String_Elements.Table (Current);\n+            if Element.Value /= No_Name then\n+               if not Osint.File_Names_Case_Sensitive then\n+                  Get_Name_String (Element.Value);\n+                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+                  Element.Value := Name_Find;\n+               end if;\n+\n+               In_Tree.String_Elements.Table (Current) := Element;\n+            end if;\n+\n+            Current := Element.Next;\n+         end loop;\n+      end;\n    end Get_Directories;\n \n    ---------------"}, {"sha": "e97f1af15ad377b4dc9f748f88ab8acbd4f61f39", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -161,6 +161,9 @@ package body Prj is\n    --  Table to store the path name of all the created temporary files, so that\n    --  they can be deleted at the end, or when the program is interrupted.\n \n+   procedure Free (Project : in out Project_Data);\n+   --  Free memory allocated for Project\n+\n    -------------------\n    -- Add_To_Buffer --\n    -------------------\n@@ -831,6 +834,19 @@ package body Prj is\n    -- Free --\n    ----------\n \n+   procedure Free (Project : in out Project_Data) is\n+   begin\n+      Free (Project.Dir_Path);\n+      Free (Project.Include_Path);\n+      Free (Project.Ada_Include_Path);\n+      Free (Project.Objects_Path);\n+      Free (Project.Ada_Objects_Path);\n+   end Free;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n    procedure Free (Tree : in out Project_Tree_Ref) is\n       procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n         (Project_Tree_Data, Project_Tree_Ref);\n@@ -844,7 +860,6 @@ package body Prj is\n          Array_Table.Free (Tree.Arrays);\n          Package_Table.Free (Tree.Packages);\n          Project_List_Table.Free (Tree.Project_Lists);\n-         Project_Table.Free (Tree.Projects);\n          Source_Data_Table.Free (Tree.Sources);\n          Alternate_Language_Table.Free (Tree.Alt_Langs);\n          Unit_Table.Free (Tree.Units);\n@@ -853,6 +868,13 @@ package body Prj is\n          Source_Paths_Htable.Reset (Tree.Source_Paths_HT);\n          Unit_Sources_Htable.Reset (Tree.Unit_Sources_HT);\n \n+         for P in Project_Table.First ..\n+           Project_Table.Last (Tree.Projects)\n+         loop\n+            Free (Tree.Projects.Table (P));\n+         end loop;\n+         Project_Table.Free (Tree.Projects);\n+\n          --  Private part\n \n          Naming_Table.Free (Tree.Private_Part.Namings);\n@@ -885,7 +907,6 @@ package body Prj is\n       Array_Table.Init              (Tree.Arrays);\n       Package_Table.Init            (Tree.Packages);\n       Project_List_Table.Init       (Tree.Project_Lists);\n-      Project_Table.Init            (Tree.Projects);\n       Source_Data_Table.Init        (Tree.Sources);\n       Alternate_Language_Table.Init (Tree.Alt_Langs);\n       Unit_Table.Init               (Tree.Units);\n@@ -894,6 +915,15 @@ package body Prj is\n       Source_Paths_Htable.Reset     (Tree.Source_Paths_HT);\n       Unit_Sources_Htable.Reset     (Tree.Unit_Sources_HT);\n \n+      if not Project_Table.\"=\" (Tree.Projects.Table, null) then\n+         for P in Project_Table.First ..\n+           Project_Table.Last (Tree.Projects)\n+         loop\n+            Free (Tree.Projects.Table (P));\n+         end loop;\n+      end if;\n+      Project_Table.Init            (Tree.Projects);\n+\n       --  Private part table\n \n       Naming_Table.Init             (Tree.Private_Part.Namings);"}, {"sha": "f3dd1765634d5b5890580abbae37502e1f1c0327", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -1151,6 +1151,7 @@ package Rtsfind is\n      RE_Request_Arguments,               -- System.Partition_Interface\n      RE_Request_Set_Out,                 -- System.Partition_Interface\n      RE_Request_Raise_Occurrence,        -- System.Partition_Interface\n+     RE_Request_Destroy,                 -- System.Partition_Interface\n      RE_Nil_Exc_List,                    -- System.Partition_Interface\n      RE_Servant,                         -- System.Partition_Interface\n      RE_Move_Any_Value,                  -- System.Partition_Interface\n@@ -2294,6 +2295,7 @@ package Rtsfind is\n      RE_Request_Arguments                => System_Partition_Interface,\n      RE_Request_Set_Out                  => System_Partition_Interface,\n      RE_Request_Raise_Occurrence         => System_Partition_Interface,\n+     RE_Request_Destroy                  => System_Partition_Interface,\n      RE_Nil_Exc_List                     => System_Partition_Interface,\n      RE_Servant                          => System_Partition_Interface,\n      RE_Move_Any_Value                   => System_Partition_Interface,"}, {"sha": "38f45a850591537f94f1aa3b7f932af6c01635fe", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -1557,7 +1557,17 @@ package body Sem_Attr is\n \n          --  Check restriction violations\n \n-         Check_Restriction (No_Streams, P);\n+         --  First check the No_Streams restriction, which prohibits the use\n+         --  of explicit stream attributes in the source program. We do not\n+         --  prevent the occurrence of stream attributes in generated code,\n+         --  for instance those generated implicitly for dispatching purposes.\n+\n+         if Comes_From_Source (N) then\n+            Check_Restriction (No_Streams, P);\n+         end if;\n+\n+         --  Check special case of Exception_Id and Exception_Occurrence which\n+         --  are not allowed for restriction No_Exception_Regstriation.\n \n          if Is_RTE (P_Type, RE_Exception_Id)\n               or else\n@@ -2061,6 +2071,7 @@ package body Sem_Attr is\n                         Rewrite (N,\n                           Make_Raise_Program_Error (Loc,\n                             Reason => PE_Address_Of_Intrinsic));\n+\n                      else\n                         Error_Msg_N\n                          (\"cannot take Address of intrinsic subprogram\", N);"}, {"sha": "5a105dbb0ea65489407d7114340165c2f5c1324d", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -7230,10 +7230,11 @@ package body Sem_Ch3 is\n       Set_Etype         (Derived_Type,           Parent_Base);\n       Set_Has_Task      (Derived_Type, Has_Task (Parent_Base));\n \n-      Set_Size_Info     (Derived_Type,                Parent_Type);\n-      Set_RM_Size       (Derived_Type, RM_Size       (Parent_Type));\n-      Set_Convention    (Derived_Type, Convention    (Parent_Type));\n-      Set_Is_Controlled (Derived_Type, Is_Controlled (Parent_Type));\n+      Set_Size_Info      (Derived_Type,                 Parent_Type);\n+      Set_RM_Size        (Derived_Type, RM_Size        (Parent_Type));\n+      Set_Convention     (Derived_Type, Convention     (Parent_Type));\n+      Set_Is_Controlled  (Derived_Type, Is_Controlled  (Parent_Type));\n+      Set_Is_Tagged_Type (Derived_Type, Is_Tagged_Type (Parent_Type));\n \n       --  The derived type inherits the representation clauses of the parent.\n       --  However, for a private type that is completed by a derivation, there\n@@ -13502,6 +13503,9 @@ package body Sem_Ch3 is\n                   Error_Msg_NE (\n                     \"full declaration of } must be a record extension\",\n                     Prev, Id);\n+\n+                  --  Set some attributes to produce a usable full view.\n+\n                   Set_Is_Tagged_Type (Id);\n                   Set_Primitive_Operations (Id, New_Elmt_List);\n                end if;\n@@ -16849,6 +16853,10 @@ package body Sem_Ch3 is\n                  E_Incomplete_Type =>\n                Constrain_Discriminated_Type (Def_Id, S, Related_Nod);\n \n+               if Ekind (Def_Id) = E_Incomplete_Type then\n+                  Set_Private_Dependents (Def_Id, New_Elmt_List);\n+               end if;\n+\n             when Private_Kind =>\n                Constrain_Discriminated_Type (Def_Id, S, Related_Nod);\n                Set_Private_Dependents (Def_Id, New_Elmt_List);"}, {"sha": "2606940a69e5b3ae40ce8a9cd688fcab65ede54a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -7703,10 +7703,22 @@ package body Sem_Ch6 is\n                (Is_Class_Wide_Type (Formal_Type)\n                   and then Is_Incomplete_Type (Root_Type (Formal_Type)))\n             then\n-               --  Ada 2005 (AI-326): Tagged incomplete types allowed\n+               --  Ada 2005 (AI-326): Tagged incomplete types allowed in\n+               --  primitive operations, as long as their completion is\n+               --  in the same declarative part. If in the private part\n+               --  this means that the type cannot be a Taft-amendment type.\n+               --  Check is done on package exit.\n \n                if Is_Tagged_Type (Formal_Type) then\n-                  null;\n+                  if Ekind (Scope (Current_Scope)) = E_Package\n+                    and then In_Private_Part (Scope (Current_Scope))\n+                    and then not From_With_Type (Formal_Type)\n+                    and then not Is_Class_Wide_Type (Formal_Type)\n+                  then\n+                     Append_Elmt\n+                       (Current_Scope,\n+                          Private_Dependents (Base_Type (Formal_Type)));\n+                  end if;\n \n                --  Special handling of Value_Type for CIL case\n "}, {"sha": "7e84f7bd6e2546343ec62dd6a7e83f6e2eaa49e5", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bcda233f11648dbf583a9f0e50af387594d78a/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=93bcda233f11648dbf583a9f0e50af387594d78a", "patch": "@@ -2261,12 +2261,33 @@ package body Sem_Ch7 is\n             end if;\n \n          elsif Ekind (Id) = E_Incomplete_Type\n+           and then Comes_From_Source (Id)\n            and then No (Full_View (Id))\n          then\n-            --  Mark Taft amendment types\n+\n+            --  Mark Taft amendment types. Verify that there are no\n+            --  primitive operations declared for the type (3.10.1 (9)).\n \n             Set_Has_Completion_In_Body (Id);\n \n+            declare\n+               Elmt : Elmt_Id;\n+               Subp : Entity_Id;\n+\n+            begin\n+               Elmt := First_Elmt (Private_Dependents (Id));\n+               while Present (Elmt) loop\n+                  Subp := Node (Elmt);\n+                  if Is_Overloadable (Subp) then\n+                     Error_Msg_NE\n+                       (\"type& must be completed in the private part\",\n+                         Parent (Subp), Id);\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end;\n+\n          elsif not Is_Child_Unit (Id)\n            and then (not Is_Private_Type (Id)\n                       or else No (Full_View (Id)))"}]}