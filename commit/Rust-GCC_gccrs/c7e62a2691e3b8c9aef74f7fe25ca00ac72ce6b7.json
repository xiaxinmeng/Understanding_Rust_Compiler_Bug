{"sha": "c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlNjJhMjY5MWUzYjhjOWFlZjc0ZjdmZTI1Y2EwMGFjNzJjZTZiNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-17T07:51:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-17T07:51:31Z"}, "message": "tree-sra.c (modify_function): Free redirect_callers vector.\n\n2012-08-17  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-sra.c (modify_function): Free redirect_callers vector.\n\t* ipa-split.c (split_function): Free args_to_pass vector.\n\t* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost): Free\n\tbody_cost_vec properly.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t* tree-vect-stmts.c (vectorizable_operation): Do not pre-allocate\n\tvec_oprnds.\n\t(new_stmt_vec_info): Do not pre-allocate STMT_VINFO_SAME_ALIGN_REFS.\n\t* tree-vect-slp.c (vect_free_slp_instance): Free the instance.\n\t(vect_analyze_slp_instance): Free everything.\n\t(destroy_bb_vec_info): Free the SLP instances.\n\nFrom-SVN: r190469", "tree": {"sha": "68c063d8431ef5c64a9a300089536f29b8aeec04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68c063d8431ef5c64a9a300089536f29b8aeec04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62205bebb08d83b461c7ed8073dd9b10eabe2f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62205bebb08d83b461c7ed8073dd9b10eabe2f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62205bebb08d83b461c7ed8073dd9b10eabe2f12"}], "stats": {"total": 53, "additions": 35, "deletions": 18}, "files": [{"sha": "a90ec55ba42d749ac20d0b620d3a8b7bd5a71a2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "patch": "@@ -1,3 +1,17 @@\n+2012-08-17  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-sra.c (modify_function): Free redirect_callers vector.\n+\t* ipa-split.c (split_function): Free args_to_pass vector.\n+\t* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost): Free\n+\tbody_cost_vec properly.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_operation): Do not pre-allocate\n+\tvec_oprnds.\n+\t(new_stmt_vec_info): Do not pre-allocate STMT_VINFO_SAME_ALIGN_REFS.\n+\t* tree-vect-slp.c (vect_free_slp_instance): Free the instance.\n+\t(vect_analyze_slp_instance): Free everything.\n+\t(destroy_bb_vec_info): Free the SLP instances.\n+\n 2012-08-17  Iain Sandoe  <iain@codesourcery.com>\n \n \t* config/rs6000/rs6000.c (macho_branch_islands): Adjust for changes"}, {"sha": "be1d2cce2309626d5cc846ef5b85ee437cf3087c", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "patch": "@@ -1230,6 +1230,7 @@ split_function (struct split_point *split_point)\n       }\n   call = gimple_build_call_vec (node->symbol.decl, args_to_pass);\n   gimple_set_block (call, DECL_INITIAL (current_function_decl));\n+  VEC_free (tree, heap, args_to_pass);\n \n   /* We avoid address being taken on any variable used by split part,\n      so return slot optimization is always possible.  Moreover this is"}, {"sha": "cc7becdc3191c3cfa5d5ce31aa09eca96e0eef08", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "patch": "@@ -4698,6 +4698,8 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n \n   new_node = cgraph_function_versioning (node, redirect_callers, NULL, NULL,\n \t\t\t\t\t false, NULL, NULL, \"isra\");\n+  VEC_free (cgraph_edge_p, heap, redirect_callers);\n+\n   current_function_decl = new_node->symbol.decl;\n   push_cfun (DECL_STRUCT_FUNCTION (new_node->symbol.decl));\n "}, {"sha": "4df2e50f9bf4ab4ccbc12e05c102d2d4bf5bd84d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "patch": "@@ -1368,6 +1368,7 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n     {\n       min->inside_cost = inside_cost;\n       min->outside_cost = outside_cost;\n+      VEC_free (stmt_info_for_cost, heap, min->body_cost_vec);\n       min->body_cost_vec = body_cost_vec;\n       min->peel_info.dr = elem->dr;\n       min->peel_info.npeel = elem->npeel;\n@@ -1880,7 +1881,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           if (!stat)\n             do_peeling = false;\n           else\n-            return stat;\n+\t    {\n+\t      VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n+\t      return stat;\n+\t    }\n         }\n \n       if (do_peeling)\n@@ -1930,6 +1934,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  gcc_assert (stat);\n           return stat;\n         }\n+      else\n+\tVEC_free (stmt_info_for_cost, heap, body_cost_vec);\n     }\n \n "}, {"sha": "01575b43d636f7ba42a17349ed281927ebb7d581", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "patch": "@@ -94,6 +94,7 @@ vect_free_slp_instance (slp_instance instance)\n   VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (instance));\n   VEC_free (slp_tree, heap, SLP_INSTANCE_LOADS (instance));\n   VEC_free (stmt_info_for_cost, heap, SLP_INSTANCE_BODY_COST_VEC (instance));\n+  free (instance);\n }\n \n \n@@ -1581,8 +1582,11 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           if (vect_print_dump_info (REPORT_SLP))\n             fprintf (vect_dump, \"Build SLP failed: unrolling required in basic\"\n                                \" block SLP\");\n+\t  vect_free_slp_tree (node);\n \t  VEC_free (stmt_info_for_cost, heap, body_cost_vec);\n \t  VEC_free (stmt_info_for_cost, heap, prologue_cost_vec);\n+\t  VEC_free (int, heap, load_permutation);\n+\t  VEC_free (slp_tree, heap, loads);\n           return false;\n         }\n \n@@ -1858,8 +1862,11 @@ new_bb_vec_info (basic_block bb)\n static void\n destroy_bb_vec_info (bb_vec_info bb_vinfo)\n {\n+  VEC (slp_instance, heap) *slp_instances;\n+  slp_instance instance;\n   basic_block bb;\n   gimple_stmt_iterator si;\n+  unsigned i;\n \n   if (!bb_vinfo)\n     return;\n@@ -1879,6 +1886,9 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n   free_data_refs (BB_VINFO_DATAREFS (bb_vinfo));\n   free_dependence_relations (BB_VINFO_DDRS (bb_vinfo));\n   VEC_free (gimple, heap, BB_VINFO_GROUPED_STORES (bb_vinfo));\n+  slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n+    vect_free_slp_instance (instance);\n   VEC_free (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo));\n   destroy_cost_data (BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n   free (bb_vinfo);"}, {"sha": "706b0bc6e93406e8361596ad3c8fbb9113c3d8e1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c7e62a2691e3b8c9aef74f7fe25ca00ac72ce6b7", "patch": "@@ -3585,22 +3585,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-  /* Allocate VECs for vector operands.  In case of SLP, vector operands are\n-     created in the previous stages of the recursion, so no allocation is\n-     needed, except for the case of shift with scalar shift argument.  In that\n-     case we store the scalar operand in VEC_OPRNDS1 for every vector stmt to\n-     be created to vectorize the SLP group, i.e., SLP_NODE->VEC_STMTS_SIZE.\n-     In case of loop-based vectorization we allocate VECs of size 1.  We\n-     allocate VEC_OPRNDS1 only in case of binary operation.  */\n-  if (!slp_node)\n-    {\n-      vec_oprnds0 = VEC_alloc (tree, heap, 1);\n-      if (op_type == binary_op || op_type == ternary_op)\n-        vec_oprnds1 = VEC_alloc (tree, heap, 1);\n-      if (op_type == ternary_op)\n-        vec_oprnds2 = VEC_alloc (tree, heap, 1);\n-    }\n-\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n@@ -5866,7 +5850,7 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo,\n   else\n     STMT_VINFO_DEF_TYPE (res) = vect_internal_def;\n \n-  STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n+  STMT_VINFO_SAME_ALIGN_REFS (res) = NULL;\n   STMT_SLP_TYPE (res) = loop_vect;\n   GROUP_FIRST_ELEMENT (res) = NULL;\n   GROUP_NEXT_ELEMENT (res) = NULL;"}]}