{"sha": "57963e3934de387ade6b314a5d72330c28f30806", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5NjNlMzkzNGRlMzg3YWRlNmIzMTRhNWQ3MjMzMGMyOGYzMDgwNg==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-12-11T16:49:17Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-12-11T16:49:17Z"}, "message": "[OpenACC] Consolidate 'GOACC_enter_exit_data' and its helper functions in 'libgomp/oacc-mem.c'\n\n\tlibgomp/\n\t* oacc-parallel.c (find_pointer, GOACC_enter_exit_data): Move...\n\t* oacc-mem.c: ... here.\n\t(gomp_acc_insert_pointer, gomp_acc_remove_pointer): Rename to\n\t'goacc_insert_pointer', 'goacc_remove_pointer', and make 'static'.\n\t* libgomp.h (gomp_acc_insert_pointer, gomp_acc_remove_pointer):\n\tRemove.\n\t* libgomp_g.h: Update.\n\nFrom-SVN: r279233", "tree": {"sha": "4e7779a4a098160c39e5abcb0a2812c81984fec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e7779a4a098160c39e5abcb0a2812c81984fec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57963e3934de387ade6b314a5d72330c28f30806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57963e3934de387ade6b314a5d72330c28f30806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57963e3934de387ade6b314a5d72330c28f30806", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57963e3934de387ade6b314a5d72330c28f30806/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5578b56b632bb21aac5dfdab09c3d24aba41c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5578b56b632bb21aac5dfdab09c3d24aba41c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5578b56b632bb21aac5dfdab09c3d24aba41c44"}], "stats": {"total": 544, "additions": 281, "deletions": 263}, "files": [{"sha": "0a5650ed4384796e6c4b721efc95c5b4a71a44df", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=57963e3934de387ade6b314a5d72330c28f30806", "patch": "@@ -1,5 +1,13 @@\n 2019-12-11  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\t* oacc-parallel.c (find_pointer, GOACC_enter_exit_data): Move...\n+\t* oacc-mem.c: ... here.\n+\t(gomp_acc_insert_pointer, gomp_acc_remove_pointer): Rename to\n+\t'goacc_insert_pointer', 'goacc_remove_pointer', and make 'static'.\n+\t* libgomp.h (gomp_acc_insert_pointer, gomp_acc_remove_pointer):\n+\tRemove.\n+\t* libgomp_g.h: Update.\n+\n \t* oacc-parallel.c (GOACC_wait, goacc_wait): Move...\n \t* oacc-async.c: ... here.\n \t* oacc-int.h (goacc_wait): Declare."}, {"sha": "9f4d0428871919746fe11e35049e5b3856ee514f", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=57963e3934de387ade6b314a5d72330c28f30806", "patch": "@@ -1138,8 +1138,6 @@ enum gomp_map_vars_kind\n   GOMP_MAP_VARS_ENTER_DATA\n };\n \n-extern void gomp_acc_insert_pointer (size_t, void **, size_t *, void *, int);\n-extern void gomp_acc_remove_pointer (void *, size_t, bool, int, int, int);\n extern void gomp_acc_declare_allocate (bool, size_t, void **, size_t *,\n \t\t\t\t       unsigned short *);\n struct gomp_coalesce_buf;"}, {"sha": "c6e1c94caf81f6220b30ea9baeabf5380e2f013d", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=57963e3934de387ade6b314a5d72330c28f30806", "patch": "@@ -361,6 +361,11 @@ extern void GOMP_teams_reg (void (*) (void *), void *, unsigned, unsigned,\n \n extern void GOACC_wait (int, int, ...);\n \n+/* oacc-mem.c */\n+\n+extern void GOACC_enter_exit_data (int, size_t, void **, size_t *,\n+\t\t\t\t   unsigned short *, int, int, ...);\n+\n /* oacc-parallel.c */\n \n extern void GOACC_parallel_keyed (int, void (*) (void *), size_t,\n@@ -370,8 +375,6 @@ extern void GOACC_parallel (int, void (*) (void *), size_t, void **, size_t *,\n extern void GOACC_data_start (int, size_t, void **, size_t *,\n \t\t\t      unsigned short *);\n extern void GOACC_data_end (void);\n-extern void GOACC_enter_exit_data (int, size_t, void **,\n-\t\t\t\t   size_t *, unsigned short *, int, int, ...);\n extern void GOACC_update (int, size_t, void **, size_t *,\n \t\t\t  unsigned short *, int, int, ...);\n extern int GOACC_get_num_threads (void);"}, {"sha": "571e0606ac82cab2aa12c65e1f0a5a4ca89aa05c", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 268, "deletions": 6, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=57963e3934de387ade6b314a5d72330c28f30806", "patch": "@@ -870,9 +870,18 @@ acc_update_self_async (void *h, size_t s, int async)\n   update_dev_host (0, h, s, async);\n }\n \n-void\n-gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n-\t\t\t void *kinds, int async)\n+\n+/* OpenACC 'enter data', 'exit data': 'GOACC_enter_exit_data' and its helper\n+   functions.  */\n+\n+/* Special handling for 'GOMP_MAP_POINTER', 'GOMP_MAP_TO_PSET'.\n+\n+   Only the first mapping is considered in reference counting; the following\n+   ones implicitly follow suit.  */\n+\n+static void\n+goacc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n+\t\t      void *kinds, int async)\n {\n   struct target_mem_desc *tgt;\n   struct goacc_thread *thr = goacc_thread ();\n@@ -914,9 +923,9 @@ gomp_acc_insert_pointer (size_t mapnum, void **hostaddrs, size_t *sizes,\n   tgt->list[0].key->dynamic_refcount = 1;\n }\n \n-void\n-gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n-\t\t\t int finalize, int mapnum)\n+static void\n+goacc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n+\t\t      int finalize, int mapnum)\n {\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n@@ -986,3 +995,256 @@ gomp_acc_remove_pointer (void *h, size_t s, bool force_copyfrom, int async,\n \n   gomp_debug (0, \"  %s: mappings restored\\n\", __FUNCTION__);\n }\n+\n+/* Return the number of mappings associated with 'GOMP_MAP_TO_PSET' or\n+   'GOMP_MAP_POINTER'.  */\n+\n+static int\n+find_pointer (int pos, size_t mapnum, unsigned short *kinds)\n+{\n+  if (pos + 1 >= mapnum)\n+    return 0;\n+\n+  unsigned char kind = kinds[pos+1] & 0xff;\n+\n+  if (kind == GOMP_MAP_TO_PSET)\n+    return 3;\n+  else if (kind == GOMP_MAP_POINTER)\n+    return 2;\n+\n+  return 0;\n+}\n+\n+void\n+GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,\n+\t\t       size_t *sizes, unsigned short *kinds, int async,\n+\t\t       int num_waits, ...)\n+{\n+  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);\n+\n+  struct goacc_thread *thr;\n+  struct gomp_device_descr *acc_dev;\n+  bool data_enter = false;\n+  size_t i;\n+\n+  goacc_lazy_initialize ();\n+\n+  thr = goacc_thread ();\n+  acc_dev = thr->dev;\n+\n+  /* Determine whether \"finalize\" semantics apply to all mappings of this\n+     OpenACC directive.  */\n+  bool finalize = false;\n+  if (mapnum > 0)\n+    {\n+      unsigned char kind = kinds[0] & 0xff;\n+      if (kind == GOMP_MAP_DELETE\n+\t  || kind == GOMP_MAP_FORCE_FROM)\n+\tfinalize = true;\n+    }\n+\n+  /* Determine if this is an \"acc enter data\".  */\n+  for (i = 0; i < mapnum; ++i)\n+    {\n+      unsigned char kind = kinds[i] & 0xff;\n+\n+      if (kind == GOMP_MAP_POINTER || kind == GOMP_MAP_TO_PSET)\n+\tcontinue;\n+\n+      if (kind == GOMP_MAP_FORCE_ALLOC\n+\t  || kind == GOMP_MAP_FORCE_PRESENT\n+\t  || kind == GOMP_MAP_FORCE_TO\n+\t  || kind == GOMP_MAP_TO\n+\t  || kind == GOMP_MAP_ALLOC)\n+\t{\n+\t  data_enter = true;\n+\t  break;\n+\t}\n+\n+      if (kind == GOMP_MAP_RELEASE\n+\t  || kind == GOMP_MAP_DELETE\n+\t  || kind == GOMP_MAP_FROM\n+\t  || kind == GOMP_MAP_FORCE_FROM)\n+\tbreak;\n+\n+      gomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n+\t\t      kind);\n+    }\n+\n+  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n+\n+  acc_prof_info prof_info;\n+  if (profiling_p)\n+    {\n+      thr->prof_info = &prof_info;\n+\n+      prof_info.event_type\n+\t= data_enter ? acc_ev_enter_data_start : acc_ev_exit_data_start;\n+      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n+      prof_info.version = _ACC_PROF_INFO_VERSION;\n+      prof_info.device_type = acc_device_type (acc_dev->type);\n+      prof_info.device_number = acc_dev->target_id;\n+      prof_info.thread_id = -1;\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+      prof_info.src_file = NULL;\n+      prof_info.func_name = NULL;\n+      prof_info.line_no = -1;\n+      prof_info.end_line_no = -1;\n+      prof_info.func_line_no = -1;\n+      prof_info.func_end_line_no = -1;\n+    }\n+  acc_event_info enter_exit_data_event_info;\n+  if (profiling_p)\n+    {\n+      enter_exit_data_event_info.other_event.event_type\n+\t= prof_info.event_type;\n+      enter_exit_data_event_info.other_event.valid_bytes\n+\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n+      enter_exit_data_event_info.other_event.parent_construct\n+\t= data_enter ? acc_construct_enter_data : acc_construct_exit_data;\n+      enter_exit_data_event_info.other_event.implicit = 0;\n+      enter_exit_data_event_info.other_event.tool_info = NULL;\n+    }\n+  acc_api_info api_info;\n+  if (profiling_p)\n+    {\n+      thr->api_info = &api_info;\n+\n+      api_info.device_api = acc_device_api_none;\n+      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n+      api_info.device_type = prof_info.device_type;\n+      api_info.vendor = -1;\n+      api_info.device_handle = NULL;\n+      api_info.context_handle = NULL;\n+      api_info.async_handle = NULL;\n+    }\n+\n+  if (profiling_p)\n+    goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t      &api_info);\n+\n+  if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+      || (flags & GOACC_FLAG_HOST_FALLBACK))\n+    {\n+      prof_info.device_type = acc_device_host;\n+      api_info.device_type = prof_info.device_type;\n+\n+      goto out_prof;\n+    }\n+\n+  if (num_waits)\n+    {\n+      va_list ap;\n+\n+      va_start (ap, num_waits);\n+      goacc_wait (async, num_waits, &ap);\n+      va_end (ap);\n+    }\n+\n+  /* In c, non-pointers and arrays are represented by a single data clause.\n+     Dynamically allocated arrays and subarrays are represented by a data\n+     clause followed by an internal GOMP_MAP_POINTER.\n+\n+     In fortran, scalars and not allocated arrays are represented by a\n+     single data clause. Allocated arrays and subarrays have three mappings:\n+     1) the original data clause, 2) a PSET 3) a pointer to the array data.\n+  */\n+\n+  if (data_enter)\n+    {\n+      for (i = 0; i < mapnum; i++)\n+\t{\n+\t  unsigned char kind = kinds[i] & 0xff;\n+\n+\t  /* Scan for pointers and PSETs.  */\n+\t  int pointer = find_pointer (i, mapnum, kinds);\n+\n+\t  if (!pointer)\n+\t    {\n+\t      switch (kind)\n+\t\t{\n+\t\tcase GOMP_MAP_ALLOC:\n+\t\tcase GOMP_MAP_FORCE_ALLOC:\n+\t\t  acc_create_async (hostaddrs[i], sizes[i], async);\n+\t\t  break;\n+\t\tcase GOMP_MAP_TO:\n+\t\tcase GOMP_MAP_FORCE_TO:\n+\t\t  acc_copyin_async (hostaddrs[i], sizes[i], async);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n+\t\t\t      kind);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      goacc_insert_pointer (pointer, &hostaddrs[i], &sizes[i], &kinds[i],\n+\t\t\t\t    async);\n+\t      /* Increment 'i' by two because OpenACC requires fortran\n+\t\t arrays to be contiguous, so each PSET is associated with\n+\t\t one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and\n+\t\t one MAP_POINTER.  */\n+\t      i += pointer - 1;\n+\t    }\n+\t}\n+    }\n+  else\n+    for (i = 0; i < mapnum; ++i)\n+      {\n+\tunsigned char kind = kinds[i] & 0xff;\n+\n+\tint pointer = find_pointer (i, mapnum, kinds);\n+\n+\tif (!pointer)\n+\t  {\n+\t    switch (kind)\n+\t      {\n+\t      case GOMP_MAP_RELEASE:\n+\t      case GOMP_MAP_DELETE:\n+\t\tif (acc_is_present (hostaddrs[i], sizes[i]))\n+\t\t  {\n+\t\t    if (finalize)\n+\t\t      acc_delete_finalize_async (hostaddrs[i], sizes[i], async);\n+\t\t    else\n+\t\t      acc_delete_async (hostaddrs[i], sizes[i], async);\n+\t\t  }\n+\t\tbreak;\n+\t      case GOMP_MAP_FROM:\n+\t      case GOMP_MAP_FORCE_FROM:\n+\t\tif (finalize)\n+\t\t  acc_copyout_finalize_async (hostaddrs[i], sizes[i], async);\n+\t\telse\n+\t\t  acc_copyout_async (hostaddrs[i], sizes[i], async);\n+\t\tbreak;\n+\t      default:\n+\t\tgomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n+\t\t\t    kind);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    bool copyfrom = (kind == GOMP_MAP_FORCE_FROM\n+\t\t\t     || kind == GOMP_MAP_FROM);\n+\t    goacc_remove_pointer (hostaddrs[i], sizes[i], copyfrom, async,\n+\t\t\t\t  finalize, pointer);\n+\t    /* See the above comment.  */\n+\t    i += pointer - 1;\n+\t  }\n+      }\n+\n+ out_prof:\n+  if (profiling_p)\n+    {\n+      prof_info.event_type\n+\t= data_enter ? acc_ev_enter_data_end : acc_ev_exit_data_end;\n+      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;\n+      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n+\t\t\t\t&api_info);\n+\n+      thr->prof_info = NULL;\n+      thr->api_info = NULL;\n+    }\n+}"}, {"sha": "5c13a7e43487d4d096986efd73f641709b906180", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57963e3934de387ade6b314a5d72330c28f30806/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=57963e3934de387ade6b314a5d72330c28f30806", "patch": "@@ -47,25 +47,6 @@ _Static_assert (GOACC_FLAGS_UNMARSHAL (GOMP_DEVICE_HOST_FALLBACK)\n \t\t\"legacy GOMP_DEVICE_HOST_FALLBACK broken\");\n \n \n-/* Returns the number of mappings associated with the pointer or pset. PSET\n-   have three mappings, whereas pointer have two.  */\n-\n-static int\n-find_pointer (int pos, size_t mapnum, unsigned short *kinds)\n-{\n-  if (pos + 1 >= mapnum)\n-    return 0;\n-\n-  unsigned char kind = kinds[pos+1] & 0xff;\n-\n-  if (kind == GOMP_MAP_TO_PSET)\n-    return 3;\n-  else if (kind == GOMP_MAP_POINTER)\n-    return 2;\n-\n-  return 0;\n-}\n-\n /* Handle the mapping pair that are presented when a\n    deviceptr clause is used with Fortran.  */\n \n@@ -578,240 +559,6 @@ GOACC_data_end (void)\n     }\n }\n \n-void\n-GOACC_enter_exit_data (int flags_m, size_t mapnum,\n-\t\t       void **hostaddrs, size_t *sizes, unsigned short *kinds,\n-\t\t       int async, int num_waits, ...)\n-{\n-  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);\n-\n-  struct goacc_thread *thr;\n-  struct gomp_device_descr *acc_dev;\n-  bool data_enter = false;\n-  size_t i;\n-\n-  goacc_lazy_initialize ();\n-\n-  thr = goacc_thread ();\n-  acc_dev = thr->dev;\n-\n-  /* Determine whether \"finalize\" semantics apply to all mappings of this\n-     OpenACC directive.  */\n-  bool finalize = false;\n-  if (mapnum > 0)\n-    {\n-      unsigned char kind = kinds[0] & 0xff;\n-      if (kind == GOMP_MAP_DELETE\n-\t  || kind == GOMP_MAP_FORCE_FROM)\n-\tfinalize = true;\n-    }\n-\n-  /* Determine if this is an \"acc enter data\".  */\n-  for (i = 0; i < mapnum; ++i)\n-    {\n-      unsigned char kind = kinds[i] & 0xff;\n-\n-      if (kind == GOMP_MAP_POINTER || kind == GOMP_MAP_TO_PSET)\n-\tcontinue;\n-\n-      if (kind == GOMP_MAP_FORCE_ALLOC\n-\t  || kind == GOMP_MAP_FORCE_PRESENT\n-\t  || kind == GOMP_MAP_FORCE_TO\n-\t  || kind == GOMP_MAP_TO\n-\t  || kind == GOMP_MAP_ALLOC)\n-\t{\n-\t  data_enter = true;\n-\t  break;\n-\t}\n-\n-      if (kind == GOMP_MAP_RELEASE\n-\t  || kind == GOMP_MAP_DELETE\n-\t  || kind == GOMP_MAP_FROM\n-\t  || kind == GOMP_MAP_FORCE_FROM)\n-\tbreak;\n-\n-      gomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n-\t\t      kind);\n-    }\n-\n-  bool profiling_p = GOACC_PROFILING_DISPATCH_P (true);\n-\n-  acc_prof_info prof_info;\n-  if (profiling_p)\n-    {\n-      thr->prof_info = &prof_info;\n-\n-      prof_info.event_type\n-\t= data_enter ? acc_ev_enter_data_start : acc_ev_exit_data_start;\n-      prof_info.valid_bytes = _ACC_PROF_INFO_VALID_BYTES;\n-      prof_info.version = _ACC_PROF_INFO_VERSION;\n-      prof_info.device_type = acc_device_type (acc_dev->type);\n-      prof_info.device_number = acc_dev->target_id;\n-      prof_info.thread_id = -1;\n-      prof_info.async = async;\n-      prof_info.async_queue = prof_info.async;\n-      prof_info.src_file = NULL;\n-      prof_info.func_name = NULL;\n-      prof_info.line_no = -1;\n-      prof_info.end_line_no = -1;\n-      prof_info.func_line_no = -1;\n-      prof_info.func_end_line_no = -1;\n-    }\n-  acc_event_info enter_exit_data_event_info;\n-  if (profiling_p)\n-    {\n-      enter_exit_data_event_info.other_event.event_type\n-\t= prof_info.event_type;\n-      enter_exit_data_event_info.other_event.valid_bytes\n-\t= _ACC_OTHER_EVENT_INFO_VALID_BYTES;\n-      enter_exit_data_event_info.other_event.parent_construct\n-\t= data_enter ? acc_construct_enter_data : acc_construct_exit_data;\n-      enter_exit_data_event_info.other_event.implicit = 0;\n-      enter_exit_data_event_info.other_event.tool_info = NULL;\n-    }\n-  acc_api_info api_info;\n-  if (profiling_p)\n-    {\n-      thr->api_info = &api_info;\n-\n-      api_info.device_api = acc_device_api_none;\n-      api_info.valid_bytes = _ACC_API_INFO_VALID_BYTES;\n-      api_info.device_type = prof_info.device_type;\n-      api_info.vendor = -1;\n-      api_info.device_handle = NULL;\n-      api_info.context_handle = NULL;\n-      api_info.async_handle = NULL;\n-    }\n-\n-  if (profiling_p)\n-    goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n-\t\t\t      &api_info);\n-\n-  if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-      || (flags & GOACC_FLAG_HOST_FALLBACK))\n-    {\n-      prof_info.device_type = acc_device_host;\n-      api_info.device_type = prof_info.device_type;\n-\n-      goto out_prof;\n-    }\n-\n-  if (num_waits)\n-    {\n-      va_list ap;\n-\n-      va_start (ap, num_waits);\n-      goacc_wait (async, num_waits, &ap);\n-      va_end (ap);\n-    }\n-\n-  /* In c, non-pointers and arrays are represented by a single data clause.\n-     Dynamically allocated arrays and subarrays are represented by a data\n-     clause followed by an internal GOMP_MAP_POINTER.\n-\n-     In fortran, scalars and not allocated arrays are represented by a\n-     single data clause. Allocated arrays and subarrays have three mappings:\n-     1) the original data clause, 2) a PSET 3) a pointer to the array data.\n-  */\n-\n-  if (data_enter)\n-    {\n-      for (i = 0; i < mapnum; i++)\n-\t{\n-\t  unsigned char kind = kinds[i] & 0xff;\n-\n-\t  /* Scan for pointers and PSETs.  */\n-\t  int pointer = find_pointer (i, mapnum, kinds);\n-\n-\t  if (!pointer)\n-\t    {\n-\t      switch (kind)\n-\t\t{\n-\t\tcase GOMP_MAP_ALLOC:\n-\t\tcase GOMP_MAP_FORCE_ALLOC:\n-\t\t  acc_create_async (hostaddrs[i], sizes[i], async);\n-\t\t  break;\n-\t\tcase GOMP_MAP_TO:\n-\t\tcase GOMP_MAP_FORCE_TO:\n-\t\t  acc_copyin_async (hostaddrs[i], sizes[i], async);\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n-\t\t\t      kind);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      gomp_acc_insert_pointer (pointer, &hostaddrs[i],\n-\t\t\t\t       &sizes[i], &kinds[i], async);\n-\t      /* Increment 'i' by two because OpenACC requires fortran\n-\t\t arrays to be contiguous, so each PSET is associated with\n-\t\t one of MAP_FORCE_ALLOC/MAP_FORCE_PRESET/MAP_FORCE_TO, and\n-\t\t one MAP_POINTER.  */\n-\t      i += pointer - 1;\n-\t    }\n-\t}\n-    }\n-  else\n-    for (i = 0; i < mapnum; ++i)\n-      {\n-\tunsigned char kind = kinds[i] & 0xff;\n-\n-\tint pointer = find_pointer (i, mapnum, kinds);\n-\n-\tif (!pointer)\n-\t  {\n-\t    switch (kind)\n-\t      {\n-\t      case GOMP_MAP_RELEASE:\n-\t      case GOMP_MAP_DELETE:\n-\t\tif (acc_is_present (hostaddrs[i], sizes[i]))\n-\t\t  {\n-\t\t    if (finalize)\n-\t\t      acc_delete_finalize_async (hostaddrs[i], sizes[i], async);\n-\t\t    else\n-\t\t      acc_delete_async (hostaddrs[i], sizes[i], async);\n-\t\t  }\n-\t\tbreak;\n-\t      case GOMP_MAP_FROM:\n-\t      case GOMP_MAP_FORCE_FROM:\n-\t\tif (finalize)\n-\t\t  acc_copyout_finalize_async (hostaddrs[i], sizes[i], async);\n-\t\telse\n-\t\t  acc_copyout_async (hostaddrs[i], sizes[i], async);\n-\t\tbreak;\n-\t      default:\n-\t\tgomp_fatal (\">>>> GOACC_enter_exit_data UNHANDLED kind 0x%.2x\",\n-\t\t\t    kind);\n-\t\tbreak;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    bool copyfrom = (kind == GOMP_MAP_FORCE_FROM\n-\t\t\t     || kind == GOMP_MAP_FROM);\n-\t    gomp_acc_remove_pointer (hostaddrs[i], sizes[i], copyfrom, async,\n-\t\t\t\t     finalize, pointer);\n-\t    /* See the above comment.  */\n-\t    i += pointer - 1;\n-\t  }\n-      }\n-\n- out_prof:\n-  if (profiling_p)\n-    {\n-      prof_info.event_type\n-\t= data_enter ? acc_ev_enter_data_end : acc_ev_exit_data_end;\n-      enter_exit_data_event_info.other_event.event_type = prof_info.event_type;\n-      goacc_profiling_dispatch (&prof_info, &enter_exit_data_event_info,\n-\t\t\t\t&api_info);\n-\n-      thr->prof_info = NULL;\n-      thr->api_info = NULL;\n-    }\n-}\n-\n void\n GOACC_update (int flags_m, size_t mapnum,\n \t      void **hostaddrs, size_t *sizes, unsigned short *kinds,"}]}