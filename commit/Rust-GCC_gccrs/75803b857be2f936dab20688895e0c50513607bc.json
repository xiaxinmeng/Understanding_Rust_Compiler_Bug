{"sha": "75803b857be2f936dab20688895e0c50513607bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU4MDNiODU3YmUyZjkzNmRhYjIwNjg4ODk1ZTBjNTA1MTM2MDdiYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-02-09T17:26:41Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-02-09T17:26:41Z"}, "message": "reload1.c (emit_input_reload_insns): Delete code that tries to inherit using find_equiv_reg.\n\n\t* reload1.c (emit_input_reload_insns): Delete code that tries to\n\tinherit using find_equiv_reg.\n\nFrom-SVN: r110806", "tree": {"sha": "8632af187ed72e1f3998ede5af72010821e287e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8632af187ed72e1f3998ede5af72010821e287e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75803b857be2f936dab20688895e0c50513607bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75803b857be2f936dab20688895e0c50513607bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75803b857be2f936dab20688895e0c50513607bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75803b857be2f936dab20688895e0c50513607bc/comments", "author": null, "committer": null, "parents": [{"sha": "cfb10bd3bad0636ed13ee47ffa9571287ee2d8d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb10bd3bad0636ed13ee47ffa9571287ee2d8d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb10bd3bad0636ed13ee47ffa9571287ee2d8d8"}], "stats": {"total": 70, "additions": 8, "deletions": 62}, "files": [{"sha": "31ab02d34cb22f15eed987de67aca4e096dffe89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75803b857be2f936dab20688895e0c50513607bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75803b857be2f936dab20688895e0c50513607bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75803b857be2f936dab20688895e0c50513607bc", "patch": "@@ -1,3 +1,8 @@\n+2006-02-09  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* reload1.c (emit_input_reload_insns): Delete code that tries to\n+\tinherit using find_equiv_reg.\n+\n 2006-02-09  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* c-common.h (flag_const_strings): Don't declare."}, {"sha": "87cc425e42c1f5ee72533d96ac3b07c28fdd8cec", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75803b857be2f936dab20688895e0c50513607bc/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75803b857be2f936dab20688895e0c50513607bc/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=75803b857be2f936dab20688895e0c50513607bc", "patch": "@@ -1,6 +1,7 @@\n /* Reload pseudo regs into hard regs for insns that require hard regs.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,\n+   Inc.\n \n This file is part of GCC.\n \n@@ -6327,71 +6328,11 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n   if (mode == VOIDmode)\n     mode = rl->inmode;\n \n-  /* If we need a secondary register for this operation, see if\n-     the value is already in a register in that class.  Don't\n-     do this if the secondary register will be used as a scratch\n-     register.  */\n-\n-  if (rl->secondary_in_reload >= 0\n-      && rl->secondary_in_icode == CODE_FOR_nothing\n-      && optimize)\n-    oldequiv\n-      = find_equiv_reg (old, insn,\n-\t\t\trld[rl->secondary_in_reload].class,\n-\t\t\t-1, NULL, 0, mode);\n-\n-  /* If reloading from memory, see if there is a register\n-     that already holds the same value.  If so, reload from there.\n-     We can pass 0 as the reload_reg_p argument because\n-     any other reload has either already been emitted,\n-     in which case find_equiv_reg will see the reload-insn,\n-     or has yet to be emitted, in which case it doesn't matter\n-     because we will use this equiv reg right away.  */\n-\n-  if (oldequiv == 0 && optimize\n-      && (MEM_P (old)\n-\t  || (REG_P (old)\n-\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n-\t      && reg_renumber[REGNO (old)] < 0)))\n-    oldequiv = find_equiv_reg (old, insn, ALL_REGS, -1, NULL, 0, mode);\n-\n-  if (oldequiv)\n-    {\n-      unsigned int regno = true_regnum (oldequiv);\n-\n-      /* Don't use OLDEQUIV if any other reload changes it at an\n-\t earlier stage of this insn or at this stage.  */\n-      if (! free_for_value_p (regno, rl->mode, rl->opnum, rl->when_needed,\n-\t\t\t      rl->in, const0_rtx, j, 0))\n-\toldequiv = 0;\n-\n-      /* If it is no cheaper to copy from OLDEQUIV into the\n-\t reload register than it would be to move from memory,\n-\t don't use it. Likewise, if we need a secondary register\n-\t or memory.  */\n-\n-      if (oldequiv != 0\n-\t  && (((enum reg_class) REGNO_REG_CLASS (regno) != rl->class\n-\t       && (REGISTER_MOVE_COST (mode, REGNO_REG_CLASS (regno),\n-\t\t\t\t       rl->class)\n-\t\t   >= MEMORY_MOVE_COST (mode, rl->class, 1)))\n-\t      || (secondary_reload_class (1, rl->class, mode, oldequiv)\n-\t\t  != NO_REGS)\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (regno),\n-\t\t\t\t\t  rl->class,\n-\t\t\t\t\t  mode)\n-#endif\n-\t      ))\n-\toldequiv = 0;\n-    }\n-\n   /* delete_output_reload is only invoked properly if old contains\n      the original pseudo register.  Since this is replaced with a\n      hard reg when RELOAD_OVERRIDE_IN is set, see if we can\n      find the pseudo in RELOAD_IN_REG.  */\n-  if (oldequiv == 0\n-      && reload_override_in[j]\n+  if (reload_override_in[j]\n       && REG_P (rl->in_reg))\n     {\n       oldequiv = old;"}]}