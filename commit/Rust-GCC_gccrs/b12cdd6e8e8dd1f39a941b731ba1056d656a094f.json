{"sha": "b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyY2RkNmU4ZThkZDFmMzlhOTQxYjczMWJhMTA1NmQ2NTZhMDk0Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:53:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:53:47Z"}, "message": "Add a apply_pass_by_reference_rules helper\n\nThis patch adds a helper routine that applies pass-by-reference\nsemantics to an existing function_arg_info.\n\nThe c6x part means that c6x_function_arg and c6x_function_arg_advance\nsee the same \"named\" value as pass_by_reference did, rather than\npass_by_reference seeing \"true\" and the others seeing \"false\".\nThis doesn't matter because the c6x port doesn't care about namedness.\n\nThe rs6000.c patch removes an assignment to \"type\", but the only\nlater code to use it was the patched promote_mode line.\n\n(The reason for patching these places despite the above is that\noften target code gets used as a basis for new targets or changes\nto existing ones.)\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* calls.h (apply_pass_by_reference_rules): Declare.\n\t* calls.c (apply_pass_by_reference_rules): New function.\n\t* config/c6x/c6x.c (c6x_call_saved_register_used): Use it.\n\t* config/rs6000/rs6000-call.c (rs6000_parm_needs_stack): Likewise.\n\t* config/s390/s390.c (s390_call_saved_register_used): Likewise.\n\t* function.c (assign_parm_find_data_types): Likewise.\n\t* var-tracking.c (prepare_call_arguments): Likewise.\n\nFrom-SVN: r274704", "tree": {"sha": "d93dca858cd33ec6231aff799254ba6497ff9089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d93dca858cd33ec6231aff799254ba6497ff9089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ffef2005fd7536efbc9c3a572701998c8a8080c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffef2005fd7536efbc9c3a572701998c8a8080c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ffef2005fd7536efbc9c3a572701998c8a8080c"}], "stats": {"total": 97, "additions": 47, "deletions": 50}, "files": [{"sha": "8a68093c64a5ac78e0909ed1e48c5757e2c307ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -1,3 +1,13 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* calls.h (apply_pass_by_reference_rules): Declare.\n+\t* calls.c (apply_pass_by_reference_rules): New function.\n+\t* config/c6x/c6x.c (c6x_call_saved_register_used): Use it.\n+\t* config/rs6000/rs6000-call.c (rs6000_parm_needs_stack): Likewise.\n+\t* config/s390/s390.c (s390_call_saved_register_used): Likewise.\n+\t* function.c (assign_parm_find_data_types): Likewise.\n+\t* var-tracking.c (prepare_call_arguments): Likewise.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (must_pass_in_stack): Take a function_arg_info instead"}, {"sha": "6f573f3b26e29c11eff2efe8f05a1cb7406e6e80", "filename": "gcc/calls.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -935,6 +935,22 @@ pass_va_arg_by_reference (tree type)\n   return pass_by_reference (NULL, function_arg_info (type, /*named=*/false));\n }\n \n+/* Decide whether ARG, which occurs in the state described by CA,\n+   should be passed by reference.  Return true if so and update\n+   ARG accordingly.  */\n+\n+bool\n+apply_pass_by_reference_rules (CUMULATIVE_ARGS *ca, function_arg_info &arg)\n+{\n+  if (pass_by_reference (ca, arg))\n+    {\n+      arg.type = build_pointer_type (arg.type);\n+      arg.mode = TYPE_MODE (arg.type);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Return true if ARG, which is passed by reference, should be callee\n    copied instead of caller copied.  */\n "}, {"sha": "01ab3905a3ac0d6a4cf60375b6253212cf40e976", "filename": "gcc/calls.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -118,6 +118,8 @@ extern void fixup_tail_calls (void);\n \n extern bool pass_by_reference (CUMULATIVE_ARGS *, function_arg_info);\n extern bool pass_va_arg_by_reference (tree);\n+extern bool apply_pass_by_reference_rules (CUMULATIVE_ARGS *,\n+\t\t\t\t\t   function_arg_info &);\n extern bool reference_callee_copied (CUMULATIVE_ARGS *,\n \t\t\t\t     const function_arg_info &);\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);"}, {"sha": "8477d35e1e7d419e9b8bfde74d06b47b4f824910", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -1088,8 +1088,6 @@ c6x_call_saved_register_used (tree call_expr)\n   cumulative_args_t cum;\n   HARD_REG_SET call_saved_regset;\n   tree parameter;\n-  machine_mode mode;\n-  tree type;\n   rtx parm_rtx;\n   int i;\n \n@@ -1107,19 +1105,9 @@ c6x_call_saved_register_used (tree call_expr)\n       if (TREE_CODE (parameter) == ERROR_MARK)\n \treturn true;\n \n-      type = TREE_TYPE (parameter);\n-      gcc_assert (type);\n-\n-      mode = TYPE_MODE (type);\n-      gcc_assert (mode);\n-\n-      if (pass_by_reference (&cum_v, function_arg_info (type, /*named=*/true)))\n- \t{\n- \t  mode = Pmode;\n- \t  type = build_pointer_type (type);\n- \t}\n+      function_arg_info arg (TREE_TYPE (parameter), /*named=*/true);\n+      apply_pass_by_reference_rules (&cum_v, arg);\n \n-       function_arg_info arg (type, mode, /*named=*/false);\n        parm_rtx = c6x_function_arg (cum, arg);\n \n        c6x_function_arg_advance (cum, arg);"}, {"sha": "7280a4ed9c86fe6e38baae271d71189a28b6d44b", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -2170,7 +2170,6 @@ rs6000_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n static bool\n rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n {\n-  machine_mode mode;\n   int unsignedp;\n   rtx entry_parm;\n \n@@ -2193,16 +2192,14 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n     type = TREE_TYPE (first_field (type));\n \n   /* See if this arg was passed by invisible reference.  */\n-  if (pass_by_reference (get_cumulative_args (args_so_far),\n-\t\t\t function_arg_info (type, /*named=*/true)))\n-    type = build_pointer_type (type);\n+  function_arg_info arg (type, /*named=*/true);\n+  apply_pass_by_reference_rules (get_cumulative_args (args_so_far), arg);\n \n   /* Find mode as it is passed by the ABI.  */\n   unsignedp = TYPE_UNSIGNED (type);\n-  mode = promote_mode (type, TYPE_MODE (type), &unsignedp);\n+  arg.mode = promote_mode (arg.type, arg.mode, &unsignedp);\n \n   /* If we must pass in stack, we need a stack.  */\n-  function_arg_info arg (type, mode, /*named=*/true);\n   if (rs6000_must_pass_in_stack (arg))\n     return true;\n "}, {"sha": "fa17d7d5d083437a3b802cc7f6b03e16405d5c5d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -13309,8 +13309,6 @@ s390_call_saved_register_used (tree call_expr)\n   CUMULATIVE_ARGS cum_v;\n   cumulative_args_t cum;\n   tree parameter;\n-  machine_mode mode;\n-  tree type;\n   rtx parm_rtx;\n   int reg, i;\n \n@@ -13327,22 +13325,12 @@ s390_call_saved_register_used (tree call_expr)\n       if (TREE_CODE (parameter) == ERROR_MARK)\n \treturn true;\n \n-      type = TREE_TYPE (parameter);\n-      gcc_assert (type);\n-\n-      mode = TYPE_MODE (type);\n-      gcc_assert (mode);\n-\n       /* We assume that in the target function all parameters are\n \t named.  This only has an impact on vector argument register\n \t usage none of which is call-saved.  */\n-      if (pass_by_reference (&cum_v, function_arg_info (type, /*named=*/true)))\n-\t{\n-\t  mode = Pmode;\n-\t  type = build_pointer_type (type);\n-\t}\n+      function_arg_info arg (TREE_TYPE (parameter), /*named=*/true);\n+      apply_pass_by_reference_rules (&cum_v, arg);\n \n-       function_arg_info arg (type, mode, /*named=*/true);\n        parm_rtx = s390_function_arg (cum, arg);\n \n        s390_function_arg_advance (cum, arg);"}, {"sha": "265bcd19f509dcc1bf7b0f26f6b5daf9ca561292", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -2456,11 +2456,11 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n   /* See if this arg was passed by invisible reference.  */\n   {\n     function_arg_info arg (passed_type, passed_mode, data->named_arg);\n-    if (pass_by_reference (&all->args_so_far_v, arg))\n+    if (apply_pass_by_reference_rules (&all->args_so_far_v, arg))\n       {\n-\tpassed_type = nominal_type = build_pointer_type (passed_type);\n+\tpassed_type = nominal_type = arg.type;\n \tdata->passed_pointer = true;\n-\tpassed_mode = nominal_mode = TYPE_MODE (nominal_type);\n+\tpassed_mode = nominal_mode = arg.mode;\n       }\n   }\n "}, {"sha": "af18528b6d78dc3777b5eb10f51723432752e57e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b12cdd6e8e8dd1f39a941b731ba1056d656a094f/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "patch": "@@ -6426,28 +6426,24 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t  }\n \tif (t && t != void_list_node)\n \t  {\n-\t    tree argtype = TREE_VALUE (t);\n \t    rtx reg;\n-\t    function_arg_info orig_arg (argtype, /*named=*/true);\n-\t    if (pass_by_reference (&args_so_far_v, orig_arg))\n-\t      argtype = build_pointer_type (argtype);\n-\t    machine_mode mode = TYPE_MODE (argtype);\n-\t    function_arg_info arg (argtype, /*named=*/true);\n+\t    function_arg_info arg (TREE_VALUE (t), /*named=*/true);\n+\t    apply_pass_by_reference_rules (&args_so_far_v, arg);\n \t    reg = targetm.calls.function_arg (args_so_far, arg);\n-\t    if (TREE_CODE (argtype) == REFERENCE_TYPE\n-\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (argtype))\n+\t    if (TREE_CODE (arg.type) == REFERENCE_TYPE\n+\t\t&& INTEGRAL_TYPE_P (TREE_TYPE (arg.type))\n \t\t&& reg\n \t\t&& REG_P (reg)\n-\t\t&& GET_MODE (reg) == mode\n-\t\t&& (GET_MODE_CLASS (mode) == MODE_INT\n-\t\t    || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t\t&& GET_MODE (reg) == arg.mode\n+\t\t&& (GET_MODE_CLASS (arg.mode) == MODE_INT\n+\t\t    || GET_MODE_CLASS (arg.mode) == MODE_PARTIAL_INT)\n \t\t&& REG_P (x)\n \t\t&& REGNO (x) == REGNO (reg)\n-\t\t&& GET_MODE (x) == mode\n+\t\t&& GET_MODE (x) == arg.mode\n \t\t&& item)\n \t      {\n \t\tmachine_mode indmode\n-\t\t  = TYPE_MODE (TREE_TYPE (argtype));\n+\t\t  = TYPE_MODE (TREE_TYPE (arg.type));\n \t\trtx mem = gen_rtx_MEM (indmode, x);\n \t\tcselib_val *val = cselib_lookup (mem, indmode, 0, VOIDmode);\n \t\tif (val && cselib_preserved_value_p (val))"}]}