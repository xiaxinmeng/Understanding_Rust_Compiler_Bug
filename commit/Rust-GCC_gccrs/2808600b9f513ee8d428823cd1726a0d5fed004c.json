{"sha": "2808600b9f513ee8d428823cd1726a0d5fed004c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwODYwMGI5ZjUxM2VlOGQ0Mjg4MjNjZDE3MjZhMGQ1ZmVkMDA0Yw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2013-01-29T14:14:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:14:48Z"}, "message": "sem_ch3.adb (Analyze_Subtype_Declaration): Inherit Is_Generic_Actual_Type flag in a nested instance.\n\n2013-01-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Inherit\n\tIs_Generic_Actual_Type flag in a nested instance.\n\t* sem_ch12.adb (Restore_Private_Views): Preserve\n\tIs_Generic_Actual_Type flag if actual is a Generic_Actual_Type\n\tof an enclosing instance.\n\t* sem_util.adb (Corresponding_Generic_Type): Handle generic actual\n\twhich is an actual of an enclosing instance.\n\t* sem_type.adb (Real_Actual): If a generic_actual_type is the\n\tformal of an enclosing generic and thus renames the corresponding\n\tactual, use the actual of the enclosing instance to resolve\n\tspurious ambiguities in instantiations when two formals are\n\tinstantiated with the same actual.\n\nFrom-SVN: r195538", "tree": {"sha": "77b5b160aaa011a56fa148406f20b6b5e4e1e814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77b5b160aaa011a56fa148406f20b6b5e4e1e814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2808600b9f513ee8d428823cd1726a0d5fed004c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2808600b9f513ee8d428823cd1726a0d5fed004c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2808600b9f513ee8d428823cd1726a0d5fed004c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2808600b9f513ee8d428823cd1726a0d5fed004c/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8acf832b414c9d5fbcc67f7d60c48fefec0d681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8acf832b414c9d5fbcc67f7d60c48fefec0d681"}], "stats": {"total": 122, "additions": 111, "deletions": 11}, "files": [{"sha": "6985aadd8d7ad8caa045dc5571d991b49c5043a2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2808600b9f513ee8d428823cd1726a0d5fed004c", "patch": "@@ -1,3 +1,18 @@\n+2013-01-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Inherit\n+\tIs_Generic_Actual_Type flag in a nested instance.\n+\t* sem_ch12.adb (Restore_Private_Views): Preserve\n+\tIs_Generic_Actual_Type flag if actual is a Generic_Actual_Type\n+\tof an enclosing instance.\n+\t* sem_util.adb (Corresponding_Generic_Type): Handle generic actual\n+\twhich is an actual of an enclosing instance.\n+\t* sem_type.adb (Real_Actual): If a generic_actual_type is the\n+\tformal of an enclosing generic and thus renames the corresponding\n+\tactual, use the actual of the enclosing instance to resolve\n+\tspurious ambiguities in instantiations when two formals are\n+\tinstantiated with the same actual.\n+\n 2013-01-29  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Document all Ada 2005 and Ada 2012 pragmas as"}, {"sha": "85a863ffff3c51a3e77c951b218707fd15962245", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=2808600b9f513ee8d428823cd1726a0d5fed004c", "patch": "@@ -12677,7 +12677,20 @@ package body Sem_Ch12 is\n          if Is_Type (E)\n            and then Nkind (Parent (E)) = N_Subtype_Declaration\n          then\n-            Set_Is_Generic_Actual_Type (E, False);\n+            --  If the actual for E is itself a generic actual type from\n+            --  an enclosing instance, E is still a generic actual type\n+            --  outside of the current instance. This matter when resolving\n+            --  an overloaded call that may be ambiguous in the enclosing\n+            --  instance, when two of its actuals coincide.\n+\n+            if Is_Entity_Name (Subtype_Indication (Parent (E)))\n+              and then Is_Generic_Actual_Type\n+                         (Entity (Subtype_Indication (Parent (E))))\n+            then\n+               null;\n+            else\n+               Set_Is_Generic_Actual_Type (E, False);\n+            end if;\n \n             --  An unusual case of aliasing: the actual may also be directly\n             --  visible in the generic, and be private there, while it is fully"}, {"sha": "3a5f693384ef862912e05f6e6433db925f47b9b2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2808600b9f513ee8d428823cd1726a0d5fed004c", "patch": "@@ -4375,9 +4375,16 @@ package body Sem_Ch3 is\n \n       --  Some common processing on all types\n \n-      Set_Size_Info      (Id,                 T);\n+      Set_Size_Info      (Id, T);\n       Set_First_Rep_Item (Id, First_Rep_Item (T));\n \n+      --  If the parent type is a generic actual, so is the subtype. This may\n+      --  happen in a nested instance. Why Comes_From_Source test???\n+\n+      if not Comes_From_Source (N) then\n+         Set_Is_Generic_Actual_Type (Id, Is_Generic_Actual_Type (T));\n+      end if;\n+\n       T := Etype (Id);\n \n       Set_Is_Immediately_Visible   (Id, True);"}, {"sha": "5f86561b148c20e1796725841841f022a571b57a", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=2808600b9f513ee8d428823cd1726a0d5fed004c", "patch": "@@ -750,6 +750,12 @@ package body Sem_Type is\n       --  removes spurious errors from nested instantiations that involve,\n       --  among other things, types derived from private types.\n \n+      function Real_Actual (T : Entity_Id) return Entity_Id;\n+      --  If an actual in an inner instance is the formal of an enclosing\n+      --  generic, the actual in the enclosing instance is the one that can\n+      --  create an accidental ambiguity, and the check on compatibily of\n+      --  generic actual types must use this enclosing actual.\n+\n       ----------------------\n       -- Full_View_Covers --\n       ----------------------\n@@ -765,6 +771,33 @@ package body Sem_Type is\n                  or else Base_Type (Typ2) = Typ1);\n       end Full_View_Covers;\n \n+      -----------------\n+      -- Real_Actual --\n+      -----------------\n+\n+      function Real_Actual (T : Entity_Id) return Entity_Id is\n+         Par : constant Node_Id := Parent (T);\n+         RA  : Entity_Id;\n+\n+      begin\n+         --  Retrieve parent subtype from subtype declaration for actual.\n+\n+         if Nkind (Par) = N_Subtype_Declaration\n+           and then not Comes_From_Source (Par)\n+           and then Is_Entity_Name (Subtype_Indication (Par))\n+         then\n+            RA := Entity (Subtype_Indication (Par));\n+\n+            if Is_Generic_Actual_Type (RA) then\n+               return RA;\n+            end if;\n+         end if;\n+\n+         --  Otherwise actual is not the actual of an enclosing instance.\n+\n+         return T;\n+      end Real_Actual;\n+\n    --  Start of processing for Covers\n \n    begin\n@@ -822,21 +855,34 @@ package body Sem_Type is\n       --  Generic actuals require special treatment to avoid spurious ambi-\n       --  guities in an instance, when two formal types are instantiated with\n       --  the same actual, so that different subprograms end up with the same\n-      --  signature in the instance.\n+      --  signature in the instance. If a generic actual is the actual of an\n+      --  enclosing instance, it is that actual that we must compare: generic\n+      --  actuals are only incompatible if they appear in the same instance.\n \n       if BT1 = BT2\n         or else BT1 = T2\n         or else BT2 = T1\n       then\n-         if not Is_Generic_Actual_Type (T1) then\n+         if not Is_Generic_Actual_Type (T1)\n+              or else\n+            not Is_Generic_Actual_Type (T2)\n+         then\n             return True;\n+\n+         --  Both T1 and T2 are generic actual types\n+\n          else\n-            return (not Is_Generic_Actual_Type (T2)\n-                     or else Is_Itype (T1)\n-                     or else Is_Itype (T2)\n-                     or else Is_Constr_Subt_For_U_Nominal (T1)\n-                     or else Is_Constr_Subt_For_U_Nominal (T2)\n-                     or else Scope (T1) /= Scope (T2));\n+            declare\n+               RT1 : constant Entity_Id := Real_Actual (T1);\n+               RT2 : constant Entity_Id := Real_Actual (T2);\n+            begin\n+               return RT1 = RT2\n+                  or else Is_Itype (T1)\n+                  or else Is_Itype (T2)\n+                  or else Is_Constr_Subt_For_U_Nominal (T1)\n+                  or else Is_Constr_Subt_For_U_Nominal (T2)\n+                  or else Scope (RT1) /= Scope (RT2);\n+            end;\n          end if;\n \n       --  Literals are compatible with types in a given \"class\"\n@@ -1267,7 +1313,8 @@ package body Sem_Type is\n       --  Determine whether a subprogram is an actual in an enclosing instance.\n       --  An overloading between such a subprogram and one declared outside the\n       --  instance is resolved in favor of the first, because it resolved in\n-      --  the generic.\n+      --  the generic. Within the instance the eactual is represented by a\n+      --  constructed subprogram renaming.\n \n       function Matches (Actual, Formal : Node_Id) return Boolean;\n       --  Look for exact type match in an instance, to remove spurious\n@@ -1349,6 +1396,14 @@ package body Sem_Type is\n       function Is_Actual_Subprogram (S : Entity_Id) return Boolean is\n       begin\n          return In_Open_Scopes (Scope (S))\n+           and then\n+             Nkind (Unit_Declaration_Node (S)) =\n+               N_Subprogram_Renaming_Declaration\n+\n+           --  Why the Comes_From_Source test here???\n+\n+           and then not Comes_From_Source (Unit_Declaration_Node (S))\n+\n            and then\n              (Is_Generic_Instance (Scope (S))\n                or else Is_Wrapper_Package (Scope (S)));"}, {"sha": "b540169602c18ca56d6432bb1588a0914568b08d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2808600b9f513ee8d428823cd1726a0d5fed004c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2808600b9f513ee8d428823cd1726a0d5fed004c", "patch": "@@ -2538,6 +2538,16 @@ package body Sem_Util is\n       if not Is_Generic_Actual_Type (T) then\n          return Any_Type;\n \n+      --  If the actual is the actual of an enclosing instance, resolution\n+      --  was correct in the generic.\n+\n+      elsif Nkind (Parent (T)) = N_Subtype_Declaration\n+        and then Is_Entity_Name (Subtype_Indication (Parent (T)))\n+        and then\n+          Is_Generic_Actual_Type (Entity (Subtype_Indication (Parent (T))))\n+      then\n+         return Any_Type;\n+\n       else\n          Inst := Scope (T);\n "}]}