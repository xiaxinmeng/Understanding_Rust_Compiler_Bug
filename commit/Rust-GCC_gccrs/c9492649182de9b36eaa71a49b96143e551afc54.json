{"sha": "c9492649182de9b36eaa71a49b96143e551afc54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0OTI2NDkxODJkZTliMzZlYWE3MWE0OWI5NjE0M2U1NTFhZmM1NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-13T13:51:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-13T13:51:23Z"}, "message": "libgo: update to Go 1.10.3 release\n    \n    Reviewed-on: https://go-review.googlesource.com/118495\n\nFrom-SVN: r261549", "tree": {"sha": "bdba262afb63fcaf2f723ec586d3c5f2be9762c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdba262afb63fcaf2f723ec586d3c5f2be9762c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9492649182de9b36eaa71a49b96143e551afc54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9492649182de9b36eaa71a49b96143e551afc54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9492649182de9b36eaa71a49b96143e551afc54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9492649182de9b36eaa71a49b96143e551afc54/comments", "author": null, "committer": null, "parents": [{"sha": "4dea3bff792b49a1eb72ee9ef15d7961fa9150c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dea3bff792b49a1eb72ee9ef15d7961fa9150c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dea3bff792b49a1eb72ee9ef15d7961fa9150c8"}], "stats": {"total": 881, "additions": 553, "deletions": 328}, "files": [{"sha": "e904f7c07ec6d321f45cfa91cb9cbce5221ebffc", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -1,4 +1,4 @@\n-bfe3a9b26c8b2e1b9ef34a7232a2d1529e639bbf\n+6743db0ed81e313acf66c00a4ed0e2dcaaca2c9f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c54da0dcac138fb14958dd400a07bab0114c0d4c", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -1,4 +1,4 @@\n-71bdbf431b79dff61944f22c25c7e085ccfc25d5\n+fe8a0d12b14108cbe2408b417afcaab722b0727c\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "038f0b9313a806d9e57f1570291a82e42d8c7070", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -1 +1 @@\n-go1.10.2\n+go1.10.3"}, {"sha": "97aa1d7e8d6344d2061c01f1de48966ffc24f000", "filename": "libgo/go/cmd/go/internal/get/discovery.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -55,6 +55,13 @@ func parseMetaGoImports(r io.Reader) (imports []metaImport, err error) {\n \t\t\tcontinue\n \t\t}\n \t\tif f := strings.Fields(attrValue(e.Attr, \"content\")); len(f) == 3 {\n+\t\t\t// Ignore VCS type \"mod\", which is new Go modules.\n+\t\t\t// This code is for old go get and must ignore the new mod lines.\n+\t\t\t// Otherwise matchGoImport will complain about two\n+\t\t\t// different metaImport lines for the same Prefix.\n+\t\t\tif f[1] == \"mod\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\timports = append(imports, metaImport{\n \t\t\t\tPrefix:   f[0],\n \t\t\t\tVCS:      f[1],"}, {"sha": "5bfeac387cc6b76addb4956e2e1c273e65ef4c2d", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -209,15 +209,15 @@ var downloadRootCache = map[string]bool{}\n // download runs the download half of the get command\n // for the package named by the argument.\n func download(arg string, parent *load.Package, stk *load.ImportStack, mode int) {\n-\tif mode&load.UseVendor != 0 {\n+\tif mode&load.ResolveImport != 0 {\n \t\t// Caller is responsible for expanding vendor paths.\n \t\tpanic(\"internal error: download mode has useVendor set\")\n \t}\n \tload1 := func(path string, mode int) *load.Package {\n \t\tif parent == nil {\n \t\t\treturn load.LoadPackage(path, stk)\n \t\t}\n-\t\treturn load.LoadImport(path, parent.Dir, parent, stk, nil, mode)\n+\t\treturn load.LoadImport(path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n \t}\n \n \tp := load1(arg, mode)\n@@ -346,12 +346,12 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\t\t\tbase.Errorf(\"%s\", err)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\t// If this is a test import, apply vendor lookup now.\n-\t\t\t// We cannot pass useVendor to download, because\n+\t\t\t// If this is a test import, apply module and vendor lookup now.\n+\t\t\t// We cannot pass ResolveImport to download, because\n \t\t\t// download does caching based on the value of path,\n \t\t\t// so it must be the fully qualified path already.\n \t\t\tif i >= len(p.Imports) {\n-\t\t\t\tpath = load.VendoredImportPath(p, path)\n+\t\t\t\tpath = load.ResolveImportPath(p, path)\n \t\t\t}\n \t\t\tdownload(path, p, stk, 0)\n \t\t}"}, {"sha": "1179d86693acee898af4fb29fe989565f1107ac0", "filename": "libgo/go/cmd/go/internal/get/pkg_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -47,6 +47,20 @@ var parseMetaGoImportsTests = []struct {\n \t\t\t{\"baz/quux\", \"git\", \"http://github.com/rsc/baz/quux\"},\n \t\t},\n \t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t<meta name=\"go-import\" content=\"foo/bar mod http://github.com/rsc/baz/quux\">`,\n+\t\t[]metaImport{\n+\t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n+\t\t},\n+\t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar mod http://github.com/rsc/baz/quux\">\n+\t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\t[]metaImport{\n+\t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n+\t\t},\n+\t},\n \t{\n \t\t`<head>\n \t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">"}, {"sha": "16e7f70d73151cb27fbee094f0353149b49bd2a0", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -218,8 +218,8 @@ func runList(cmd *base.Command, args []string) {\n \n \tfor _, pkg := range pkgs {\n \t\t// Show vendor-expanded paths in listing\n-\t\tpkg.TestImports = pkg.Vendored(pkg.TestImports)\n-\t\tpkg.XTestImports = pkg.Vendored(pkg.XTestImports)\n+\t\tpkg.TestImports = pkg.Resolve(pkg.TestImports)\n+\t\tpkg.XTestImports = pkg.Resolve(pkg.XTestImports)\n \n \t\tdo(&pkg.PackagePublic)\n \t}"}, {"sha": "d8dd66426b429210b4b39d288686f115063e8838", "filename": "libgo/go/cmd/go/internal/load/icfg.go", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dea3bff792b49a1eb72ee9ef15d7961fa9150c8/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dea3bff792b49a1eb72ee9ef15d7961fa9150c8/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go?ref=4dea3bff792b49a1eb72ee9ef15d7961fa9150c8", "patch": "@@ -1,78 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package load\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/json\"\n-\t\"errors\"\n-\t\"io/ioutil\"\n-)\n-\n-// DebugDeprecatedImportcfg is installed as the undocumented -debug-deprecated-importcfg build flag.\n-// It is useful for debugging subtle problems in the go command logic but not something\n-// we want users to depend on. The hope is that the \"deprecated\" will make that clear.\n-// We intend to remove this flag in Go 1.11.\n-var DebugDeprecatedImportcfg debugDeprecatedImportcfgFlag\n-\n-type debugDeprecatedImportcfgFlag struct {\n-\tenabled bool\n-\tImport  map[string]string\n-\tPkg     map[string]*debugDeprecatedImportcfgPkg\n-}\n-\n-type debugDeprecatedImportcfgPkg struct {\n-\tDir    string\n-\tImport map[string]string\n-}\n-\n-var (\n-\tdebugDeprecatedImportcfgMagic = []byte(\"# debug-deprecated-importcfg\\n\")\n-\terrImportcfgSyntax            = errors.New(\"malformed syntax\")\n-)\n-\n-func (f *debugDeprecatedImportcfgFlag) String() string { return \"\" }\n-\n-func (f *debugDeprecatedImportcfgFlag) Set(x string) error {\n-\tif x == \"\" {\n-\t\t*f = debugDeprecatedImportcfgFlag{}\n-\t\treturn nil\n-\t}\n-\tdata, err := ioutil.ReadFile(x)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif !bytes.HasPrefix(data, debugDeprecatedImportcfgMagic) {\n-\t\treturn errImportcfgSyntax\n-\t}\n-\tdata = data[len(debugDeprecatedImportcfgMagic):]\n-\n-\tf.Import = nil\n-\tf.Pkg = nil\n-\tif err := json.Unmarshal(data, &f); err != nil {\n-\t\treturn errImportcfgSyntax\n-\t}\n-\tf.enabled = true\n-\treturn nil\n-}\n-\n-func (f *debugDeprecatedImportcfgFlag) lookup(parent *Package, path string) (dir, newPath string) {\n-\tnewPath = path\n-\tif p := f.Import[path]; p != \"\" {\n-\t\tnewPath = p\n-\t}\n-\tif parent != nil {\n-\t\tif p1 := f.Pkg[parent.ImportPath]; p1 != nil {\n-\t\t\tif p := p1.Import[path]; p != \"\" {\n-\t\t\t\tnewPath = p\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif p2 := f.Pkg[newPath]; p2 != nil {\n-\t\treturn p2.Dir, newPath\n-\t}\n-\treturn \"\", \"\"\n-}"}, {"sha": "dfb1ff63afeb8dd5cbf7597cb016434dde000e8d", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 230, "deletions": 64, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -6,6 +6,7 @@\n package load\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/token\"\n@@ -14,6 +15,7 @@ import (\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"sort\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n@@ -168,7 +170,7 @@ func (e *NoGoError) Error() string {\n \treturn \"no Go files in \" + e.Package.Dir\n }\n \n-// Vendored returns the vendor-resolved version of imports,\n+// Resolve returns the resolved version of imports,\n // which should be p.TestImports or p.XTestImports, NOT p.Imports.\n // The imports in p.TestImports and p.XTestImports are not recursively\n // loaded during the initial load of p, so they list the imports found in\n@@ -178,14 +180,14 @@ func (e *NoGoError) Error() string {\n // can produce better error messages if it starts with the original paths.\n // The initial load of p loads all the non-test imports and rewrites\n // the vendored paths, so nothing should ever call p.vendored(p.Imports).\n-func (p *Package) Vendored(imports []string) []string {\n+func (p *Package) Resolve(imports []string) []string {\n \tif len(imports) > 0 && len(p.Imports) > 0 && &imports[0] == &p.Imports[0] {\n-\t\tpanic(\"internal error: p.vendored(p.Imports) called\")\n+\t\tpanic(\"internal error: p.Resolve(p.Imports) called\")\n \t}\n \tseen := make(map[string]bool)\n \tvar all []string\n \tfor _, path := range imports {\n-\t\tpath = VendoredImportPath(p, path)\n+\t\tpath = ResolveImportPath(p, path)\n \t\tif !seen[path] {\n \t\t\tseen[path] = true\n \t\t\tall = append(all, path)\n@@ -380,16 +382,20 @@ func makeImportValid(r rune) rune {\n \n // Mode flags for loadImport and download (in get.go).\n const (\n-\t// UseVendor means that loadImport should do vendor expansion\n-\t// (provided the vendoring experiment is enabled).\n-\t// That is, useVendor means that the import path came from\n-\t// a source file and has not been vendor-expanded yet.\n-\t// Every import path should be loaded initially with useVendor,\n-\t// and then the expanded version (with the /vendor/ in it) gets\n-\t// recorded as the canonical import path. At that point, future loads\n-\t// of that package must not pass useVendor, because\n+\t// ResolveImport means that loadImport should do import path expansion.\n+\t// That is, ResolveImport means that the import path came from\n+\t// a source file and has not been expanded yet to account for\n+\t// vendoring or possible module adjustment.\n+\t// Every import path should be loaded initially with ResolveImport,\n+\t// and then the expanded version (for example with the /vendor/ in it)\n+\t// gets recorded as the canonical import path. At that point, future loads\n+\t// of that package must not pass ResolveImport, because\n \t// disallowVendor will reject direct use of paths containing /vendor/.\n-\tUseVendor = 1 << iota\n+\tResolveImport = 1 << iota\n+\n+\t// ResolveModule is for download (part of \"go get\") and indicates\n+\t// that the module adjustment should be done, but not vendor adjustment.\n+\tResolveModule\n \n \t// GetTestDeps is for download (part of \"go get\") and indicates\n \t// that test dependencies should be fetched too.\n@@ -412,20 +418,17 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \timportPath := path\n \torigPath := path\n \tisLocal := build.IsLocalImport(path)\n-\tvar debugDeprecatedImportcfgDir string\n \tif isLocal {\n \t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n-\t} else if DebugDeprecatedImportcfg.enabled {\n-\t\tif d, i := DebugDeprecatedImportcfg.lookup(parent, path); d != \"\" {\n-\t\t\tdebugDeprecatedImportcfgDir = d\n-\t\t\timportPath = i\n-\t\t}\n-\t} else if mode&UseVendor != 0 {\n-\t\t// We do our own vendor resolution, because we want to\n+\t} else if mode&ResolveImport != 0 {\n+\t\t// We do our own path resolution, because we want to\n \t\t// find out the key to use in packageCache without the\n \t\t// overhead of repeated calls to buildContext.Import.\n \t\t// The code is also needed in a few other places anyway.\n-\t\tpath = VendoredImportPath(parent, path)\n+\t\tpath = ResolveImportPath(parent, path)\n+\t\timportPath = path\n+\t} else if mode&ResolveModule != 0 {\n+\t\tpath = ModuleImportPath(parent, path)\n \t\timportPath = path\n \t}\n \n@@ -441,26 +444,17 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\t// Load package.\n \t\t// Import always returns bp != nil, even if an error occurs,\n \t\t// in order to return partial information.\n-\t\tvar bp *build.Package\n-\t\tvar err error\n-\t\tif debugDeprecatedImportcfgDir != \"\" {\n-\t\t\tbp, err = cfg.BuildContext.ImportDir(debugDeprecatedImportcfgDir, 0)\n-\t\t} else if DebugDeprecatedImportcfg.enabled {\n-\t\t\tbp = new(build.Package)\n-\t\t\terr = fmt.Errorf(\"unknown import path %q: not in import cfg\", importPath)\n-\t\t} else {\n-\t\t\tbuildMode := build.ImportComment\n-\t\t\tif mode&UseVendor == 0 || path != origPath {\n-\t\t\t\t// Not vendoring, or we already found the vendored path.\n-\t\t\t\tbuildMode |= build.IgnoreVendor\n-\t\t\t}\n-\t\t\tbp, err = cfg.BuildContext.Import(path, srcDir, buildMode)\n+\t\tbuildMode := build.ImportComment\n+\t\tif mode&ResolveImport == 0 || path != origPath {\n+\t\t\t// Not vendoring, or we already found the vendored path.\n+\t\t\tbuildMode |= build.IgnoreVendor\n \t\t}\n+\t\tbp, err := cfg.BuildContext.Import(path, srcDir, buildMode)\n \t\tbp.ImportPath = importPath\n \t\tif cfg.GOBIN != \"\" {\n \t\t\tbp.BinDir = cfg.GOBIN\n \t\t}\n-\t\tif debugDeprecatedImportcfgDir == \"\" && err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n+\t\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n \t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n \t\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n \t\t}\n@@ -469,7 +463,7 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\t\tp = setErrorPos(p, importPos)\n \t\t}\n \n-\t\tif debugDeprecatedImportcfgDir == \"\" && origPath != cleanImport(origPath) {\n+\t\tif origPath != cleanImport(origPath) {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", origPath, pathpkg.Clean(origPath)),\n@@ -482,7 +476,7 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \tif perr := disallowInternal(srcDir, p, stk); perr != p {\n \t\treturn setErrorPos(perr, importPos)\n \t}\n-\tif mode&UseVendor != 0 {\n+\tif mode&ResolveImport != 0 {\n \t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n \t\t\treturn setErrorPos(perr, importPos)\n \t\t}\n@@ -541,46 +535,60 @@ func isDir(path string) bool {\n \treturn result\n }\n \n-// VendoredImportPath returns the expansion of path when it appears in parent.\n-// If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,\n-// x/vendor/path, vendor/path, or else stay path if none of those exist.\n-// VendoredImportPath returns the expanded path or, if no expansion is found, the original.\n-func VendoredImportPath(parent *Package, path string) (found string) {\n-\tif DebugDeprecatedImportcfg.enabled {\n-\t\tif d, i := DebugDeprecatedImportcfg.lookup(parent, path); d != \"\" {\n-\t\t\treturn i\n-\t\t}\n-\t\treturn path\n-\t}\n-\n-\tif parent == nil || parent.Root == \"\" {\n-\t\treturn path\n-\t}\n+// ResolveImportPath returns the true meaning of path when it appears in parent.\n+// There are two different resolutions applied.\n+// First, there is Go 1.5 vendoring (golang.org/s/go15vendor).\n+// If vendor expansion doesn't trigger, then the path is also subject to\n+// Go 1.11 vgo legacy conversion (golang.org/issue/25069).\n+func ResolveImportPath(parent *Package, path string) (found string) {\n+\tfound = VendoredImportPath(parent, path)\n+\tif found != path {\n+\t\treturn found\n+\t}\n+\treturn ModuleImportPath(parent, path)\n+}\n \n-\tdir := filepath.Clean(parent.Dir)\n-\troot := filepath.Join(parent.Root, \"src\")\n-\tif !str.HasFilePathPrefix(dir, root) || parent.ImportPath != \"command-line-arguments\" && filepath.Join(root, parent.ImportPath) != dir {\n+// dirAndRoot returns the source directory and workspace root\n+// for the package p, guaranteeing that root is a path prefix of dir.\n+func dirAndRoot(p *Package) (dir, root string) {\n+\tdir = filepath.Clean(p.Dir)\n+\troot = filepath.Join(p.Root, \"src\")\n+\tif !str.HasFilePathPrefix(dir, root) || p.ImportPath != \"command-line-arguments\" && filepath.Join(root, p.ImportPath) != dir {\n \t\t// Look for symlinks before reporting error.\n \t\tdir = expandPath(dir)\n \t\troot = expandPath(root)\n \t}\n \n-\tif !str.HasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || parent.ImportPath != \"command-line-arguments\" && !parent.Internal.Local && filepath.Join(root, parent.ImportPath) != dir {\n+\tif !str.HasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || p.ImportPath != \"command-line-arguments\" && !p.Internal.Local && filepath.Join(root, p.ImportPath) != dir {\n \t\tbase.Fatalf(\"unexpected directory layout:\\n\"+\n \t\t\t\"\timport path: %s\\n\"+\n \t\t\t\"\troot: %s\\n\"+\n \t\t\t\"\tdir: %s\\n\"+\n \t\t\t\"\texpand root: %s\\n\"+\n \t\t\t\"\texpand dir: %s\\n\"+\n \t\t\t\"\tseparator: %s\",\n-\t\t\tparent.ImportPath,\n-\t\t\tfilepath.Join(parent.Root, \"src\"),\n-\t\t\tfilepath.Clean(parent.Dir),\n+\t\t\tp.ImportPath,\n+\t\t\tfilepath.Join(p.Root, \"src\"),\n+\t\t\tfilepath.Clean(p.Dir),\n \t\t\troot,\n \t\t\tdir,\n \t\t\tstring(filepath.Separator))\n \t}\n \n+\treturn dir, root\n+}\n+\n+// VendoredImportPath returns the vendor-expansion of path when it appears in parent.\n+// If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,\n+// x/vendor/path, vendor/path, or else stay path if none of those exist.\n+// VendoredImportPath returns the expanded path or, if no expansion is found, the original.\n+func VendoredImportPath(parent *Package, path string) (found string) {\n+\tif parent == nil || parent.Root == \"\" {\n+\t\treturn path\n+\t}\n+\n+\tdir, root := dirAndRoot(parent)\n+\n \tvpath := \"vendor/\" + path\n \tfor i := len(dir); i >= len(root); i-- {\n \t\tif i < len(dir) && dir[i] != filepath.Separator {\n@@ -623,6 +631,164 @@ func VendoredImportPath(parent *Package, path string) (found string) {\n \treturn path\n }\n \n+var (\n+\tmodulePrefix   = []byte(\"\\nmodule \")\n+\tgoModPathCache = make(map[string]string)\n+)\n+\n+// goModPath returns the module path in the go.mod in dir, if any.\n+func goModPath(dir string) (path string) {\n+\tpath, ok := goModPathCache[dir]\n+\tif ok {\n+\t\treturn path\n+\t}\n+\tdefer func() {\n+\t\tgoModPathCache[dir] = path\n+\t}()\n+\n+\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"go.mod\"))\n+\tif err != nil {\n+\t\treturn \"\"\n+\t}\n+\tvar i int\n+\tif bytes.HasPrefix(data, modulePrefix[1:]) {\n+\t\ti = 0\n+\t} else {\n+\t\ti = bytes.Index(data, modulePrefix)\n+\t\tif i < 0 {\n+\t\t\treturn \"\"\n+\t\t}\n+\t\ti++\n+\t}\n+\tline := data[i:]\n+\n+\t// Cut line at \\n, drop trailing \\r if present.\n+\tif j := bytes.IndexByte(line, '\\n'); j >= 0 {\n+\t\tline = line[:j]\n+\t}\n+\tif line[len(line)-1] == '\\r' {\n+\t\tline = line[:len(line)-1]\n+\t}\n+\tline = line[len(\"module \"):]\n+\n+\t// If quoted, unquote.\n+\tpath = strings.TrimSpace(string(line))\n+\tif path != \"\" && path[0] == '\"' {\n+\t\ts, err := strconv.Unquote(path)\n+\t\tif err != nil {\n+\t\t\treturn \"\"\n+\t\t}\n+\t\tpath = s\n+\t}\n+\treturn path\n+}\n+\n+// findVersionElement returns the slice indices of the final version element /vN in path.\n+// If there is no such element, it returns -1, -1.\n+func findVersionElement(path string) (i, j int) {\n+\tj = len(path)\n+\tfor i = len(path) - 1; i >= 0; i-- {\n+\t\tif path[i] == '/' {\n+\t\t\tif isVersionElement(path[i:j]) {\n+\t\t\t\treturn i, j\n+\t\t\t}\n+\t\t\tj = i\n+\t\t}\n+\t}\n+\treturn -1, -1\n+}\n+\n+// isVersionElement reports whether s is a well-formed path version element:\n+// v2, v3, v10, etc, but not v0, v05, v1.\n+func isVersionElement(s string) bool {\n+\tif len(s) < 3 || s[0] != '/' || s[1] != 'v' || s[2] == '0' || s[2] == '1' && len(s) == 3 {\n+\t\treturn false\n+\t}\n+\tfor i := 2; i < len(s); i++ {\n+\t\tif s[i] < '0' || '9' < s[i] {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// ModuleImportPath translates import paths found in go modules\n+// back down to paths that can be resolved in ordinary builds.\n+//\n+// Define \u201cnew\u201d code as code with a go.mod file in the same directory\n+// or a parent directory. If an import in new code says x/y/v2/z but\n+// x/y/v2/z does not exist and x/y/go.mod says \u201cmodule x/y/v2\u201d,\n+// then go build will read the import as x/y/z instead.\n+// See golang.org/issue/25069.\n+func ModuleImportPath(parent *Package, path string) (found string) {\n+\tif parent == nil || parent.Root == \"\" {\n+\t\treturn path\n+\t}\n+\n+\t// If there are no vN elements in path, leave it alone.\n+\t// (The code below would do the same, but only after\n+\t// some other file system accesses that we can avoid\n+\t// here by returning early.)\n+\tif i, _ := findVersionElement(path); i < 0 {\n+\t\treturn path\n+\t}\n+\n+\tdir, root := dirAndRoot(parent)\n+\n+\t// Consider dir and parents, up to and including root.\n+\tfor i := len(dir); i >= len(root); i-- {\n+\t\tif i < len(dir) && dir[i] != filepath.Separator {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif goModPath(dir[:i]) != \"\" {\n+\t\t\tgoto HaveGoMod\n+\t\t}\n+\t}\n+\t// This code is not in a tree with a go.mod,\n+\t// so apply no changes to the path.\n+\treturn path\n+\n+HaveGoMod:\n+\t// This import is in a tree with a go.mod.\n+\t// Allow it to refer to code in GOPATH/src/x/y/z as x/y/v2/z\n+\t// if GOPATH/src/x/y/go.mod says module \"x/y/v2\",\n+\n+\t// If x/y/v2/z exists, use it unmodified.\n+\tif bp, _ := cfg.BuildContext.Import(path, \"\", build.IgnoreVendor); bp.Dir != \"\" {\n+\t\treturn path\n+\t}\n+\n+\t// Otherwise look for a go.mod supplying a version element.\n+\t// Some version-like elements may appear in paths but not\n+\t// be module versions; we skip over those to look for module\n+\t// versions. For example the module m/v2 might have a\n+\t// package m/v2/api/v1/foo.\n+\tlimit := len(path)\n+\tfor limit > 0 {\n+\t\ti, j := findVersionElement(path[:limit])\n+\t\tif i < 0 {\n+\t\t\treturn path\n+\t\t}\n+\t\tif bp, _ := cfg.BuildContext.Import(path[:i], \"\", build.IgnoreVendor); bp.Dir != \"\" {\n+\t\t\tif mpath := goModPath(bp.Dir); mpath != \"\" {\n+\t\t\t\t// Found a valid go.mod file, so we're stopping the search.\n+\t\t\t\t// If the path is m/v2/p and we found m/go.mod that says\n+\t\t\t\t// \"module m/v2\", then we return \"m/p\".\n+\t\t\t\tif mpath == path[:j] {\n+\t\t\t\t\treturn path[:i] + path[j:]\n+\t\t\t\t}\n+\t\t\t\t// Otherwise just return the original path.\n+\t\t\t\t// We didn't find anything worth rewriting,\n+\t\t\t\t// and the go.mod indicates that we should\n+\t\t\t\t// not consider parent directories.\n+\t\t\t\treturn path\n+\t\t\t}\n+\t\t}\n+\t\tlimit = i\n+\t}\n+\treturn path\n+}\n+\n // hasGoFiles reports whether dir contains any files with names ending in .go.\n // For a vendor check we must exclude directories that contain no .go files.\n // Otherwise it is not possible to vendor just a/b/c and still import the\n@@ -1087,7 +1253,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\tif path == \"C\" {\n \t\t\tcontinue\n \t\t}\n-\t\tp1 := LoadImport(path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], UseVendor)\n+\t\tp1 := LoadImport(path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], ResolveImport)\n \t\tif p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n@@ -1598,7 +1764,7 @@ func GetTestPackagesFor(p *Package, forceTest bool) (ptest, pxtest *Package, err\n \tstk.Push(p.ImportPath + \" (test)\")\n \trawTestImports := str.StringList(p.TestImports)\n \tfor i, path := range p.TestImports {\n-\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], UseVendor)\n+\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif p1.Error != nil {\n \t\t\treturn nil, nil, p1.Error\n \t\t}\n@@ -1626,7 +1792,7 @@ func GetTestPackagesFor(p *Package, forceTest bool) (ptest, pxtest *Package, err\n \tpxtestNeedsPtest := false\n \trawXTestImports := str.StringList(p.XTestImports)\n \tfor i, path := range p.XTestImports {\n-\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], UseVendor)\n+\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n \t\tif p1.Error != nil {\n \t\t\treturn nil, nil, p1.Error\n \t\t}"}, {"sha": "5adb7df7c482fe9b33282a8ecc6933d994428bf0", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -606,10 +606,10 @@ func runTest(cmd *base.Command, args []string) {\n \t\t\tfor _, path := range p.Imports {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n-\t\t\tfor _, path := range p.Vendored(p.TestImports) {\n+\t\t\tfor _, path := range p.Resolve(p.TestImports) {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n-\t\t\tfor _, path := range p.Vendored(p.XTestImports) {\n+\t\t\tfor _, path := range p.Resolve(p.XTestImports) {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n \t\t}"}, {"sha": "25dfe58d4bf90fa7e90a3dcd63ad5bfccc8d56e7", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -229,7 +229,6 @@ func AddBuildFlags(cmd *base.Command) {\n \n \t// Undocumented, unstable debugging flags.\n \tcmd.Flag.StringVar(&cfg.DebugActiongraph, \"debug-actiongraph\", \"\", \"\")\n-\tcmd.Flag.Var(&load.DebugDeprecatedImportcfg, \"debug-deprecated-importcfg\", \"\")\n }\n \n // fileExtSplit expects a filename and returns the name"}, {"sha": "1b82af9c97cad4fe14a69ea634bf2bd827dcafce", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -41,43 +41,57 @@ var re = regexp.MustCompile\n \n var validCompilerFlags = []*regexp.Regexp{\n \tre(`-D([A-Za-z_].*)`),\n+\tre(`-F([^@\\-].*)`),\n \tre(`-I([^@\\-].*)`),\n \tre(`-O`),\n \tre(`-O([^@\\-].*)`),\n \tre(`-W`),\n \tre(`-W([^@,]+)`), // -Wall but not -Wa,-foo.\n \tre(`-Wa,-mbig-obj`),\n+\tre(`-Wp,-D([A-Za-z_].*)`),\n \tre(`-ansi`),\n+\tre(`-f(no-)?asynchronous-unwind-tables`),\n \tre(`-f(no-)?blocks`),\n+\tre(`-f(no-)builtin-[a-zA-Z0-9_]*`),\n \tre(`-f(no-)?common`),\n \tre(`-f(no-)?constant-cfstrings`),\n \tre(`-fdiagnostics-show-note-include-stack`),\n+\tre(`-f(no-)?eliminate-unused-debug-types`),\n \tre(`-f(no-)?exceptions`),\n+\tre(`-f(no-)?fast-math`),\n \tre(`-f(no-)?inline-functions`),\n \tre(`-finput-charset=([^@\\-].*)`),\n \tre(`-f(no-)?fat-lto-objects`),\n+\tre(`-f(no-)?keep-inline-dllexport`),\n \tre(`-f(no-)?lto`),\n \tre(`-fmacro-backtrace-limit=(.+)`),\n \tre(`-fmessage-length=(.+)`),\n \tre(`-f(no-)?modules`),\n \tre(`-f(no-)?objc-arc`),\n+\tre(`-f(no-)?objc-nonfragile-abi`),\n+\tre(`-f(no-)?objc-legacy-dispatch`),\n \tre(`-f(no-)?omit-frame-pointer`),\n \tre(`-f(no-)?openmp(-simd)?`),\n \tre(`-f(no-)?permissive`),\n \tre(`-f(no-)?(pic|PIC|pie|PIE)`),\n+\tre(`-f(no-)?plt`),\n \tre(`-f(no-)?rtti`),\n \tre(`-f(no-)?split-stack`),\n \tre(`-f(no-)?stack-(.+)`),\n \tre(`-f(no-)?strict-aliasing`),\n \tre(`-f(un)signed-char`),\n \tre(`-f(no-)?use-linker-plugin`), // safe if -B is not used; we don't permit -B\n+\tre(`-f(no-)?visibility-inlines-hidden`),\n \tre(`-fsanitize=(.+)`),\n \tre(`-ftemplate-depth-(.+)`),\n \tre(`-fvisibility=(.+)`),\n \tre(`-g([^@\\-].*)?`),\n \tre(`-m32`),\n \tre(`-m64`),\n-\tre(`-m(arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-m(abi|arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-marm`),\n+\tre(`-mfloat-abi=([^@\\-].*)`),\n+\tre(`-mfpmath=[0-9a-z,+]*`),\n \tre(`-m(no-)?avx[0-9a-z.]*`),\n \tre(`-m(no-)?ms-bitfields`),\n \tre(`-m(no-)?stack-(.+)`),\n@@ -86,12 +100,16 @@ var validCompilerFlags = []*regexp.Regexp{\n \tre(`-miphoneos-version-min=(.+)`),\n \tre(`-mnop-fun-dllimport`),\n \tre(`-m(no-)?sse[0-9.]*`),\n+\tre(`-mthumb(-interwork)?`),\n+\tre(`-mthreads`),\n \tre(`-mwindows`),\n+\tre(`--param=ssp-buffer-size=[0-9]*`),\n \tre(`-pedantic(-errors)?`),\n \tre(`-pipe`),\n \tre(`-pthread`),\n \tre(`-?-std=([^@\\-].*)`),\n \tre(`-?-stdlib=([^@\\-].*)`),\n+\tre(`--sysroot=([^@\\-].*)`),\n \tre(`-w`),\n \tre(`-x([^@\\-].*)`),\n }\n@@ -115,15 +133,20 @@ var validLinkerFlags = []*regexp.Regexp{\n \tre(`-O`),\n \tre(`-O([^@\\-].*)`),\n \tre(`-f(no-)?(pic|PIC|pie|PIE)`),\n+\tre(`-f(no-)?openmp(-simd)?`),\n \tre(`-fsanitize=([^@\\-].*)`),\n \tre(`-g([^@\\-].*)?`),\n-\tre(`-m(arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-headerpad_max_install_names`),\n+\tre(`-m(abi|arch|cpu|fpu|tune)=([^@\\-].*)`),\n+\tre(`-mfloat-abi=([^@\\-].*)`),\n \tre(`-mmacosx-(.+)`),\n \tre(`-mios-simulator-version-min=(.+)`),\n \tre(`-miphoneos-version-min=(.+)`),\n+\tre(`-mthreads`),\n \tre(`-mwindows`),\n \tre(`-(pic|PIC|pie|PIE)`),\n \tre(`-pthread`),\n+\tre(`-rdynamic`),\n \tre(`-shared`),\n \tre(`-?-static([-a-z0-9+]*)`),\n \tre(`-?-stdlib=([^@\\-].*)`),\n@@ -134,29 +157,35 @@ var validLinkerFlags = []*regexp.Regexp{\n \t// in a wildcard would allow tunnelling arbitrary additional\n \t// linker arguments through one of these.\n \tre(`-Wl,--(no-)?allow-multiple-definition`),\n+\tre(`-Wl,--(no-)?allow-shlib-undefined`),\n \tre(`-Wl,--(no-)?as-needed`),\n \tre(`-Wl,-Bdynamic`),\n \tre(`-Wl,-Bstatic`),\n+\tre(`-WL,-O([^@,\\-][^,]*)?`),\n \tre(`-Wl,-d[ny]`),\n \tre(`-Wl,--disable-new-dtags`),\n+\tre(`-Wl,-e[=,][a-zA-Z0-9]*`),\n \tre(`-Wl,--enable-new-dtags`),\n \tre(`-Wl,--end-group`),\n \tre(`-Wl,-framework,[^,@\\-][^,]+`),\n \tre(`-Wl,-headerpad_max_install_names`),\n \tre(`-Wl,--no-undefined`),\n-\tre(`-Wl,-rpath[=,]([^,@\\-][^,]+)`),\n+\tre(`-Wl,-rpath(-link)?[=,]([^,@\\-][^,]+)`),\n+\tre(`-Wl,-s`),\n \tre(`-Wl,-search_paths_first`),\n \tre(`-Wl,-sectcreate,([^,@\\-][^,]+),([^,@\\-][^,]+),([^,@\\-][^,]+)`),\n \tre(`-Wl,--start-group`),\n \tre(`-Wl,-?-static`),\n-\tre(`-Wl,--subsystem,(native|windows|console|posix|xbox)`),\n+\tre(`-Wl,-?-subsystem,(native|windows|console|posix|xbox)`),\n+\tre(`-Wl,-syslibroot[=,]([^,@\\-][^,]+)`),\n \tre(`-Wl,-undefined[=,]([^,@\\-][^,]+)`),\n \tre(`-Wl,-?-unresolved-symbols=[^,]+`),\n \tre(`-Wl,--(no-)?warn-([^,]+)`),\n \tre(`-Wl,-z,(no)?execstack`),\n \tre(`-Wl,-z,relro`),\n \n \tre(`[a-zA-Z0-9_/].*\\.(a|o|obj|dll|dylib|so)`), // direct linker inputs: x.o or libfoo.so (but not -foo.o or @foo.o)\n+\tre(`\\./.*\\.(a|o|obj|dll|dylib|so)`),\n }\n \n var validLinkerFlagsWithNextArg = []string{"}, {"sha": "c3a61b8e70b0ae446497c629863d76e2c71810dc", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -12,6 +12,7 @@ import (\n var goodCompilerFlags = [][]string{\n \t{\"-DFOO\"},\n \t{\"-Dfoo=bar\"},\n+\t{\"-F/Qt\"},\n \t{\"-I/\"},\n \t{\"-I/etc/passwd\"},\n \t{\"-I.\"},\n@@ -62,6 +63,8 @@ var goodCompilerFlags = [][]string{\n var badCompilerFlags = [][]string{\n \t{\"-D@X\"},\n \t{\"-D-X\"},\n+\t{\"-F@dir\"},\n+\t{\"-F-dir\"},\n \t{\"-I@dir\"},\n \t{\"-I-dir\"},\n \t{\"-O@1\"},\n@@ -125,6 +128,7 @@ var goodLinkerFlags = [][]string{\n \t{\"-Wl,--no-warn-error\"},\n \t{\"foo.so\"},\n \t{\"_\u4e16\u754c.dll\"},\n+\t{\"./x.o\"},\n \t{\"libcgosotest.dylib\"},\n \t{\"-F\", \"framework\"},\n \t{\"-l\", \".\"},\n@@ -191,6 +195,7 @@ var badLinkerFlags = [][]string{\n \t{\"-x\", \"--c\"},\n \t{\"-x\", \"@obj\"},\n \t{\"-Wl,-rpath,@foo\"},\n+\t{\"../x.o\"},\n }\n \n func TestCheckLinkerFlags(t *testing.T) {"}, {"sha": "d0dd46d314c6a3b7d81265586d3b268526c968f7", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/go.mod", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fgo.mod?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+module \"new/v2\""}, {"sha": "e99c47a6a8411f729644a051063dec6785cb8130", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/new.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fnew.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fnew.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fnew.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1,3 @@\n+package new\n+\n+import _ \"new/v2/p2\""}, {"sha": "4539f4091965364225880baad21cfd2fb3e90b42", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/p1/p1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fp1%2Fp1.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1,7 @@\n+package p1\n+\n+import _ \"old/p2\"\n+import _ \"new/v2\"\n+import _ \"new/v2/p2\"\n+import _ \"new/sub/v2/x/v1/y\" // v2 is module, v1 is directory in module\n+import _ \"new/sub/inner/x\"   // new/sub/inner/go.mod overrides new/sub/go.mod"}, {"sha": "9b9052f54197e6ea3c7136cf4088e442c8db0434", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/p2/p2.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fp2%2Fp2.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+package p2"}, {"sha": "484d20c6b2ea507a5cbf694c38d99307109c3bf2", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/sub/go.mod", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Fgo.mod?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+module new/sub/v2"}, {"sha": "ba3934541f745ff3f64cc2d019696dafc281bb5d", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/sub/inner/go.mod", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Finner%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Finner%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Finner%2Fgo.mod?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+module new/sub/inner"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/sub/inner/x/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Finner%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Finner%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Finner%2Fx%2Fx.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+package x"}, {"sha": "789ca715ec46017ace27f1f85e8dce8eb3fdae47", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/new/sub/x/v1/y/y.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Fx%2Fv1%2Fy%2Fy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Fx%2Fv1%2Fy%2Fy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fnew%2Fsub%2Fx%2Fv1%2Fy%2Fy.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+package y"}, {"sha": "90527483abf2c2c850396dcd5315edd62490d13a", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/old/p1/p1.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fold%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fold%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fold%2Fp1%2Fp1.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1,5 @@\n+package p1\n+\n+import _ \"old/p2\"\n+import _ \"new/p1\"\n+import _ \"new\""}, {"sha": "9b9052f54197e6ea3c7136cf4088e442c8db0434", "filename": "libgo/go/cmd/go/testdata/modlegacy/src/old/p2/p2.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fold%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fold%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmodlegacy%2Fsrc%2Fold%2Fp2%2Fp2.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -0,0 +1 @@\n+package p2"}, {"sha": "0e7a633240b72d51ec8087df8cafdcfd0334bee3", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"internal/testenv\"\n+\t\"os\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"strings\"\n@@ -328,3 +329,75 @@ func TestVendor12156(t *testing.T) {\n \ttg.grepStderrNot(\"panic\", \"panicked\")\n \ttg.grepStderr(`cannot find package \"x\"`, \"wrong error\")\n }\n+\n+// Module legacy support does path rewriting very similar to vendoring.\n+\n+func TestModLegacy(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/modlegacy\"))\n+\ttg.run(\"list\", \"-f\", \"{{.Imports}}\", \"old/p1\")\n+\ttg.grepStdout(\"new/p1\", \"old/p1 should import new/p1\")\n+\ttg.run(\"list\", \"-f\", \"{{.Imports}}\", \"new/p1\")\n+\ttg.grepStdout(\"new/p2\", \"new/p1 should import new/p2 (not new/v2/p2)\")\n+\ttg.grepStdoutNot(\"new/v2\", \"new/p1 should NOT import new/v2*\")\n+\ttg.grepStdout(\"new/sub/x/v1/y\", \"new/p1 should import new/sub/x/v1/y (not new/sub/v2/x/v1/y)\")\n+\ttg.grepStdoutNot(\"new/sub/v2\", \"new/p1 should NOT import new/sub/v2*\")\n+\ttg.grepStdout(\"new/sub/inner/x\", \"new/p1 should import new/sub/inner/x (no rewrites)\")\n+\ttg.run(\"build\", \"old/p1\", \"new/p1\")\n+}\n+\n+func TestModLegacyGet(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\"d1\"))\n+\ttg.run(\"get\", \"vcs-test.golang.org/git/modlegacy1-old.git/p1\")\n+\ttg.run(\"list\", \"-f\", \"{{.Deps}}\", \"vcs-test.golang.org/git/modlegacy1-old.git/p1\")\n+\ttg.grepStdout(\"new.git/p2\", \"old/p1 should depend on new/p2\")\n+\ttg.grepStdoutNot(\"new.git/v2/p2\", \"old/p1 should NOT depend on new/v2/p2\")\n+\ttg.run(\"build\", \"vcs-test.golang.org/git/modlegacy1-old.git/p1\", \"vcs-test.golang.org/git/modlegacy1-new.git/p1\")\n+\n+\ttg.setenv(\"GOPATH\", tg.path(\"d2\"))\n+\n+\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n+\ttg.run(\"get\", \"github.com/rsc/vgotest5\")\n+\ttg.run(\"get\", \"github.com/rsc/vgotest4\")\n+\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n+\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n+\ttg.run(\"get\", \"github.com/rsc/vgotest4\")\n+\ttg.run(\"get\", \"github.com/rsc/vgotest5\")\n+\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n+\n+\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n+\ttg.run(\"get\", \"github.com/rsc/vgotest4\", \"github.com/rsc/vgotest5\")\n+\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n+\n+\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n+\ttg.run(\"get\", \"github.com/rsc/vgotest5\", \"github.com/rsc/vgotest4\")\n+\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n+\n+\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n+\ttg.run(\"get\", \"github.com/myitcv/vgo_example_compat\")\n+\ttg.run(\"get\", \"github.com/rsc/vgotest4\", \"github.com/rsc/vgotest5\")\n+\n+\tpkgs := []string{\"github.com/myitcv/vgo_example_compat\", \"github.com/rsc/vgotest4\", \"github.com/rsc/vgotest5\"}\n+\tfor i := 0; i < 3; i++ {\n+\t\tfor j := 0; j < 3; j++ {\n+\t\t\tfor k := 0; k < 3; k++ {\n+\t\t\t\tif i == j || i == k || k == j {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\ttg.must(os.RemoveAll(tg.path(\"d2\")))\n+\t\t\t\ttg.run(\"get\", pkgs[i], pkgs[j], pkgs[k])\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "95d55fd7619b4f5ab3310b4fcfbd40e8e4179037", "filename": "libgo/go/crypto/x509/name_constraints_test.go", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcrypto%2Fx509%2Fname_constraints_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcrypto%2Fx509%2Fname_constraints_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fname_constraints_test.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -1222,8 +1222,9 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\t},\n \t},\n \n-\t// #63: A specified key usage in an intermediate forbids other usages\n-\t// in the leaf.\n+\t// #63: An intermediate with enumerated EKUs causes a failure if we\n+\t// test for an EKU not in that set. (ServerAuth is required by\n+\t// default.)\n \tnameConstraintsTest{\n \t\troots: []constraintsSpec{\n \t\t\tconstraintsSpec{},\n@@ -1239,11 +1240,11 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\t\tsans: []string{\"dns:example.com\"},\n \t\t\tekus: []string{\"serverAuth\"},\n \t\t},\n-\t\texpectedError: \"EKU not permitted\",\n+\t\texpectedError: \"incompatible key usage\",\n \t},\n \n-\t// #64: A specified key usage in an intermediate forbids other usages\n-\t// in the leaf, even if we don't recognise them.\n+\t// #64: an unknown EKU in the leaf doesn't break anything, even if it's not\n+\t// correctly nested.\n \tnameConstraintsTest{\n \t\troots: []constraintsSpec{\n \t\t\tconstraintsSpec{},\n@@ -1259,7 +1260,7 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\t\tsans: []string{\"dns:example.com\"},\n \t\t\tekus: []string{\"other\"},\n \t\t},\n-\t\texpectedError: \"EKU not permitted\",\n+\t\trequestedEKUs: []ExtKeyUsage{ExtKeyUsageAny},\n \t},\n \n \t// #65: trying to add extra permitted key usages in an intermediate\n@@ -1284,24 +1285,25 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\t},\n \t},\n \n-\t// #66: EKUs in roots are ignored.\n+\t// #66: EKUs in roots are not ignored.\n \tnameConstraintsTest{\n \t\troots: []constraintsSpec{\n \t\t\tconstraintsSpec{\n-\t\t\t\tekus: []string{\"serverAuth\"},\n+\t\t\t\tekus: []string{\"email\"},\n \t\t\t},\n \t\t},\n \t\tintermediates: [][]constraintsSpec{\n \t\t\t[]constraintsSpec{\n \t\t\t\tconstraintsSpec{\n-\t\t\t\t\tekus: []string{\"serverAuth\", \"email\"},\n+\t\t\t\t\tekus: []string{\"serverAuth\"},\n \t\t\t\t},\n \t\t\t},\n \t\t},\n \t\tleaf: leafSpec{\n \t\t\tsans: []string{\"dns:example.com\"},\n-\t\t\tekus: []string{\"serverAuth\", \"email\"},\n+\t\t\tekus: []string{\"serverAuth\"},\n \t\t},\n+\t\texpectedError: \"incompatible key usage\",\n \t},\n \n \t// #67: in order to support COMODO chains, SGC key usages permit\n@@ -1447,8 +1449,7 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\texpectedError: \"\\\"https://example.com/test\\\" is excluded\",\n \t},\n \n-\t// #75: While serverAuth in a CA certificate permits clientAuth in a leaf,\n-\t// serverAuth in a leaf shouldn't permit clientAuth when requested in\n+\t// #75: serverAuth in a leaf shouldn't permit clientAuth when requested in\n \t// VerifyOptions.\n \tnameConstraintsTest{\n \t\troots: []constraintsSpec{\n@@ -1558,6 +1559,27 @@ var nameConstraintsTests = []nameConstraintsTest{\n \t\t},\n \t\trequestedEKUs: []ExtKeyUsage{ExtKeyUsageClientAuth, ExtKeyUsageEmailProtection},\n \t},\n+\n+\t// #81: EKUs that are not asserted in VerifyOpts are not required to be\n+\t// nested.\n+\tnameConstraintsTest{\n+\t\troots: []constraintsSpec{\n+\t\t\tconstraintsSpec{},\n+\t\t},\n+\t\tintermediates: [][]constraintsSpec{\n+\t\t\t[]constraintsSpec{\n+\t\t\t\tconstraintsSpec{\n+\t\t\t\t\tekus: []string{\"serverAuth\"},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\tleaf: leafSpec{\n+\t\t\tsans: []string{\"dns:example.com\"},\n+\t\t\t// There's no email EKU in the intermediate. This would be rejected if\n+\t\t\t// full nesting was required.\n+\t\t\tekus: []string{\"email\", \"serverAuth\"},\n+\t\t},\n+\t},\n }\n \n func makeConstraintsCACert(constraints constraintsSpec, name string, key *ecdsa.PrivateKey, parent *Certificate, parentKey *ecdsa.PrivateKey) (*Certificate, error) {"}, {"sha": "3621a93abac2e3d63da585202341c1c54ac1695a", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -95,6 +95,12 @@ func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) e\n \treturn nil\n }\n \n+type _CertChainPolicyPara struct {\n+\tSize            uint32\n+\tFlags           uint32\n+\tExtraPolicyPara unsafe.Pointer\n+}\n+\n // checkChainSSLServerPolicy checks that the certificate chain in chainCtx is valid for\n // use as a certificate chain for a SSL/TLS server.\n func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContext, opts *VerifyOptions) error {\n@@ -108,13 +114,13 @@ func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContex\n \t}\n \tsslPara.Size = uint32(unsafe.Sizeof(*sslPara))\n \n-\tpara := &syscall.CertChainPolicyPara{\n-\t\tExtraPolicyPara: uintptr(unsafe.Pointer(sslPara)),\n+\tpara := &_CertChainPolicyPara{\n+\t\tExtraPolicyPara: unsafe.Pointer(sslPara),\n \t}\n \tpara.Size = uint32(unsafe.Sizeof(*para))\n \n \tstatus := syscall.CertChainPolicyStatus{}\n-\terr = syscall.CertVerifyCertificateChainPolicy(syscall.CERT_CHAIN_POLICY_SSL, chainCtx, para, &status)\n+\terr = syscall.CertVerifyCertificateChainPolicy(syscall.CERT_CHAIN_POLICY_SSL, chainCtx, (*syscall.CertChainPolicyPara)(unsafe.Pointer(para)), &status)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "60e415b7ec257cd0f03009dbb3dd790f7971ba40", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 87, "deletions": 150, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -56,8 +56,7 @@ const (\n \t// CPU time to verify.\n \tTooManyConstraints\n \t// CANotAuthorizedForExtKeyUsage results when an intermediate or root\n-\t// certificate does not permit an extended key usage that is claimed by\n-\t// the leaf certificate.\n+\t// certificate does not permit a requested extended key usage.\n \tCANotAuthorizedForExtKeyUsage\n )\n \n@@ -82,7 +81,7 @@ func (e CertificateInvalidError) Error() string {\n \tcase TooManyIntermediates:\n \t\treturn \"x509: too many intermediates for path length constraint\"\n \tcase IncompatibleUsage:\n-\t\treturn \"x509: certificate specifies an incompatible key usage: \" + e.Detail\n+\t\treturn \"x509: certificate specifies an incompatible key usage\"\n \tcase NameMismatch:\n \t\treturn \"x509: issuer name does not match subject from issuing certificate\"\n \tcase NameConstraintsWithoutSANs:\n@@ -185,9 +184,8 @@ type VerifyOptions struct {\n \t// list means ExtKeyUsageServerAuth. To accept any key usage, include\n \t// ExtKeyUsageAny.\n \t//\n-\t// Certificate chains are required to nest extended key usage values,\n-\t// irrespective of this value. This matches the Windows CryptoAPI behavior,\n-\t// but not the spec.\n+\t// Certificate chains are required to nest these extended key usage values.\n+\t// (This matches the Windows CryptoAPI behavior, but not the spec.)\n \tKeyUsages []ExtKeyUsage\n \t// MaxConstraintComparisions is the maximum number of comparisons to\n \t// perform when checking a given certificate's name constraints. If\n@@ -549,51 +547,6 @@ func (c *Certificate) checkNameConstraints(count *int,\n \treturn nil\n }\n \n-const (\n-\tcheckingAgainstIssuerCert = iota\n-\tcheckingAgainstLeafCert\n-)\n-\n-// ekuPermittedBy returns true iff the given extended key usage is permitted by\n-// the given EKU from a certificate. Normally, this would be a simple\n-// comparison plus a special case for the \u201cany\u201d EKU. But, in order to support\n-// existing certificates, some exceptions are made.\n-func ekuPermittedBy(eku, certEKU ExtKeyUsage, context int) bool {\n-\tif certEKU == ExtKeyUsageAny || eku == certEKU {\n-\t\treturn true\n-\t}\n-\n-\t// Some exceptions are made to support existing certificates. Firstly,\n-\t// the ServerAuth and SGC EKUs are treated as a group.\n-\tmapServerAuthEKUs := func(eku ExtKeyUsage) ExtKeyUsage {\n-\t\tif eku == ExtKeyUsageNetscapeServerGatedCrypto || eku == ExtKeyUsageMicrosoftServerGatedCrypto {\n-\t\t\treturn ExtKeyUsageServerAuth\n-\t\t}\n-\t\treturn eku\n-\t}\n-\n-\teku = mapServerAuthEKUs(eku)\n-\tcertEKU = mapServerAuthEKUs(certEKU)\n-\n-\tif eku == certEKU {\n-\t\treturn true\n-\t}\n-\n-\t// If checking a requested EKU against the list in a leaf certificate there\n-\t// are fewer exceptions.\n-\tif context == checkingAgainstLeafCert {\n-\t\treturn false\n-\t}\n-\n-\t// ServerAuth in a CA permits ClientAuth in the leaf.\n-\treturn (eku == ExtKeyUsageClientAuth && certEKU == ExtKeyUsageServerAuth) ||\n-\t\t// Any CA may issue an OCSP responder certificate.\n-\t\teku == ExtKeyUsageOCSPSigning ||\n-\t\t// Code-signing CAs can use Microsoft's commercial and\n-\t\t// kernel-mode EKUs.\n-\t\t(eku == ExtKeyUsageMicrosoftCommercialCodeSigning || eku == ExtKeyUsageMicrosoftKernelCodeSigning) && certEKU == ExtKeyUsageCodeSigning\n-}\n-\n // isValid performs validity checks on c given that it is a candidate to append\n // to the chain in currentChain.\n func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *VerifyOptions) error {\n@@ -708,59 +661,6 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \t\t}\n \t}\n \n-\tcheckEKUs := certType == intermediateCertificate\n-\n-\t// If no extended key usages are specified, then all are acceptable.\n-\tif checkEKUs && (len(c.ExtKeyUsage) == 0 && len(c.UnknownExtKeyUsage) == 0) {\n-\t\tcheckEKUs = false\n-\t}\n-\n-\t// If the \u201cany\u201d key usage is permitted, then no more checks are needed.\n-\tif checkEKUs {\n-\t\tfor _, caEKU := range c.ExtKeyUsage {\n-\t\t\tcomparisonCount++\n-\t\t\tif caEKU == ExtKeyUsageAny {\n-\t\t\t\tcheckEKUs = false\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif checkEKUs {\n-\tNextEKU:\n-\t\tfor _, eku := range leaf.ExtKeyUsage {\n-\t\t\tif comparisonCount > maxConstraintComparisons {\n-\t\t\t\treturn CertificateInvalidError{c, TooManyConstraints, \"\"}\n-\t\t\t}\n-\n-\t\t\tfor _, caEKU := range c.ExtKeyUsage {\n-\t\t\t\tcomparisonCount++\n-\t\t\t\tif ekuPermittedBy(eku, caEKU, checkingAgainstIssuerCert) {\n-\t\t\t\t\tcontinue NextEKU\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\toid, _ := oidFromExtKeyUsage(eku)\n-\t\t\treturn CertificateInvalidError{c, CANotAuthorizedForExtKeyUsage, fmt.Sprintf(\"EKU not permitted: %#v\", oid)}\n-\t\t}\n-\n-\tNextUnknownEKU:\n-\t\tfor _, eku := range leaf.UnknownExtKeyUsage {\n-\t\t\tif comparisonCount > maxConstraintComparisons {\n-\t\t\t\treturn CertificateInvalidError{c, TooManyConstraints, \"\"}\n-\t\t\t}\n-\n-\t\t\tfor _, caEKU := range c.UnknownExtKeyUsage {\n-\t\t\t\tcomparisonCount++\n-\t\t\t\tif caEKU.Equal(eku) {\n-\t\t\t\t\tcontinue NextUnknownEKU\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\treturn CertificateInvalidError{c, CANotAuthorizedForExtKeyUsage, fmt.Sprintf(\"EKU not permitted: %#v\", eku)}\n-\t\t}\n-\t}\n-\n \t// KeyUsage status flags are ignored. From Engineering Security, Peter\n \t// Gutmann: A European government CA marked its signing certificates as\n \t// being valid for encryption only, but no-one noticed. Another\n@@ -861,63 +761,38 @@ func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err e\n \t\t}\n \t}\n \n-\trequestedKeyUsages := make([]ExtKeyUsage, len(opts.KeyUsages))\n-\tcopy(requestedKeyUsages, opts.KeyUsages)\n-\tif len(requestedKeyUsages) == 0 {\n-\t\trequestedKeyUsages = append(requestedKeyUsages, ExtKeyUsageServerAuth)\n+\tvar candidateChains [][]*Certificate\n+\tif opts.Roots.contains(c) {\n+\t\tcandidateChains = append(candidateChains, []*Certificate{c})\n+\t} else {\n+\t\tif candidateChains, err = c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n \n-\t// If no key usages are specified, then any are acceptable.\n-\tcheckEKU := len(c.ExtKeyUsage) > 0\n-\n-\tfor _, eku := range requestedKeyUsages {\n-\t\tif eku == ExtKeyUsageAny {\n-\t\t\tcheckEKU = false\n-\t\t\tbreak\n-\t\t}\n+\tkeyUsages := opts.KeyUsages\n+\tif len(keyUsages) == 0 {\n+\t\tkeyUsages = []ExtKeyUsage{ExtKeyUsageServerAuth}\n \t}\n \n-\tif checkEKU {\n-\t\tfoundMatch := false\n-\tNextUsage:\n-\t\tfor _, eku := range requestedKeyUsages {\n-\t\t\tfor _, leafEKU := range c.ExtKeyUsage {\n-\t\t\t\tif ekuPermittedBy(eku, leafEKU, checkingAgainstLeafCert) {\n-\t\t\t\t\tfoundMatch = true\n-\t\t\t\t\tbreak NextUsage\n-\t\t\t\t}\n-\t\t\t}\n+\t// If any key usage is acceptable then we're done.\n+\tfor _, usage := range keyUsages {\n+\t\tif usage == ExtKeyUsageAny {\n+\t\t\treturn candidateChains, nil\n \t\t}\n+\t}\n \n-\t\tif !foundMatch {\n-\t\t\tmsg := \"leaf contains the following, recognized EKUs: \"\n-\n-\t\t\tfor i, leafEKU := range c.ExtKeyUsage {\n-\t\t\t\toid, ok := oidFromExtKeyUsage(leafEKU)\n-\t\t\t\tif !ok {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tif i > 0 {\n-\t\t\t\t\tmsg += \", \"\n-\t\t\t\t}\n-\t\t\t\tmsg += formatOID(oid)\n-\t\t\t}\n-\n-\t\t\treturn nil, CertificateInvalidError{c, IncompatibleUsage, msg}\n+\tfor _, candidate := range candidateChains {\n+\t\tif checkChainForKeyUsage(candidate, keyUsages) {\n+\t\t\tchains = append(chains, candidate)\n \t\t}\n \t}\n \n-\tvar candidateChains [][]*Certificate\n-\tif opts.Roots.contains(c) {\n-\t\tcandidateChains = append(candidateChains, []*Certificate{c})\n-\t} else {\n-\t\tif candidateChains, err = c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n+\tif len(chains) == 0 {\n+\t\treturn nil, CertificateInvalidError{c, IncompatibleUsage, \"\"}\n \t}\n \n-\treturn candidateChains, nil\n+\treturn chains, nil\n }\n \n func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate {\n@@ -1078,3 +953,65 @@ func (c *Certificate) VerifyHostname(h string) error {\n \n \treturn HostnameError{c, h}\n }\n+\n+func checkChainForKeyUsage(chain []*Certificate, keyUsages []ExtKeyUsage) bool {\n+\tusages := make([]ExtKeyUsage, len(keyUsages))\n+\tcopy(usages, keyUsages)\n+\n+\tif len(chain) == 0 {\n+\t\treturn false\n+\t}\n+\n+\tusagesRemaining := len(usages)\n+\n+\t// We walk down the list and cross out any usages that aren't supported\n+\t// by each certificate. If we cross out all the usages, then the chain\n+\t// is unacceptable.\n+\n+NextCert:\n+\tfor i := len(chain) - 1; i >= 0; i-- {\n+\t\tcert := chain[i]\n+\t\tif len(cert.ExtKeyUsage) == 0 && len(cert.UnknownExtKeyUsage) == 0 {\n+\t\t\t// The certificate doesn't have any extended key usage specified.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor _, usage := range cert.ExtKeyUsage {\n+\t\t\tif usage == ExtKeyUsageAny {\n+\t\t\t\t// The certificate is explicitly good for any usage.\n+\t\t\t\tcontinue NextCert\n+\t\t\t}\n+\t\t}\n+\n+\t\tconst invalidUsage ExtKeyUsage = -1\n+\n+\tNextRequestedUsage:\n+\t\tfor i, requestedUsage := range usages {\n+\t\t\tif requestedUsage == invalidUsage {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor _, usage := range cert.ExtKeyUsage {\n+\t\t\t\tif requestedUsage == usage {\n+\t\t\t\t\tcontinue NextRequestedUsage\n+\t\t\t\t} else if requestedUsage == ExtKeyUsageServerAuth &&\n+\t\t\t\t\t(usage == ExtKeyUsageNetscapeServerGatedCrypto ||\n+\t\t\t\t\t\tusage == ExtKeyUsageMicrosoftServerGatedCrypto) {\n+\t\t\t\t\t// In order to support COMODO\n+\t\t\t\t\t// certificate chains, we have to\n+\t\t\t\t\t// accept Netscape or Microsoft SGC\n+\t\t\t\t\t// usages as equal to ServerAuth.\n+\t\t\t\t\tcontinue NextRequestedUsage\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tusages[i] = invalidUsage\n+\t\t\tusagesRemaining--\n+\t\t\tif usagesRemaining == 0 {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn true\n+}"}, {"sha": "05e8243b2ea50f7548b6b866fdf776d80c7e69af", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -474,7 +474,7 @@ func Map(mapping func(rune) rune, s string) string {\n \t\tb = make([]byte, len(s)+utf8.UTFMax)\n \t\tnbytes = copy(b, s[:i])\n \t\tif r >= 0 {\n-\t\t\tif r <= utf8.RuneSelf {\n+\t\t\tif r < utf8.RuneSelf {\n \t\t\t\tb[nbytes] = byte(r)\n \t\t\t\tnbytes++\n \t\t\t} else {\n@@ -504,7 +504,7 @@ func Map(mapping func(rune) rune, s string) string {\n \t\tr := mapping(c)\n \n \t\t// common case\n-\t\tif (0 <= r && r <= utf8.RuneSelf) && nbytes < len(b) {\n+\t\tif (0 <= r && r < utf8.RuneSelf) && nbytes < len(b) {\n \t\t\tb[nbytes] = byte(r)\n \t\t\tnbytes++\n \t\t\tcontinue"}, {"sha": "92122dbf9b22eb1cbb55a155ee814ea3dd412b2d", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -532,6 +532,7 @@ var upperTests = []StringTest{\n \t{\"longStrinGwitHmixofsmaLLandcAps\", \"LONGSTRINGWITHMIXOFSMALLANDCAPS\"},\n \t{\"long\\u0250string\\u0250with\\u0250nonascii\\u2C6Fchars\", \"LONG\\u2C6FSTRING\\u2C6FWITH\\u2C6FNONASCII\\u2C6FCHARS\"},\n \t{\"\\u0250\\u0250\\u0250\\u0250\\u0250\", \"\\u2C6F\\u2C6F\\u2C6F\\u2C6F\\u2C6F\"}, // grows one byte per char\n+\t{\"a\\u0080\\U0010FFFF\", \"A\\u0080\\U0010FFFF\"},                           // test utf8.RuneSelf and utf8.MaxRune\n }\n \n var lowerTests = []StringTest{\n@@ -542,6 +543,7 @@ var lowerTests = []StringTest{\n \t{\"longStrinGwitHmixofsmaLLandcAps\", \"longstringwithmixofsmallandcaps\"},\n \t{\"LONG\\u2C6FSTRING\\u2C6FWITH\\u2C6FNONASCII\\u2C6FCHARS\", \"long\\u0250string\\u0250with\\u0250nonascii\\u0250chars\"},\n \t{\"\\u2C6D\\u2C6D\\u2C6D\\u2C6D\\u2C6D\", \"\\u0251\\u0251\\u0251\\u0251\\u0251\"}, // shrinks one byte per char\n+\t{\"A\\u0080\\U0010FFFF\", \"a\\u0080\\U0010FFFF\"},                           // test utf8.RuneSelf and utf8.MaxRune\n }\n \n const space = \"\\t\\v\\r\\f\\n\\u0085\\u00a0\\u2000\\u3000\"\n@@ -654,6 +656,27 @@ func TestMap(t *testing.T) {\n \tif m != expect {\n \t\tt.Errorf(\"replace invalid sequence: expected %q got %q\", expect, m)\n \t}\n+\n+\t// 8. Check utf8.RuneSelf and utf8.MaxRune encoding\n+\tencode := func(r rune) rune {\n+\t\tswitch r {\n+\t\tcase utf8.RuneSelf:\n+\t\t\treturn unicode.MaxRune\n+\t\tcase unicode.MaxRune:\n+\t\t\treturn utf8.RuneSelf\n+\t\t}\n+\t\treturn r\n+\t}\n+\ts := string(utf8.RuneSelf) + string(utf8.MaxRune)\n+\tr := string(utf8.MaxRune) + string(utf8.RuneSelf) // reverse of s\n+\tm = Map(encode, s)\n+\tif m != r {\n+\t\tt.Errorf(\"encoding not handled correctly: expected %q got %q\", r, m)\n+\t}\n+\tm = Map(encode, r)\n+\tif m != s {\n+\t\tt.Errorf(\"encoding not handled correctly: expected %q got %q\", s, m)\n+\t}\n }\n \n func TestToUpper(t *testing.T) { runStringTests(t, ToUpper, \"ToUpper\", upperTests) }"}, {"sha": "1a3f1d7545fc2f93ecdaeb20643a7f4e689ac5aa", "filename": "libgo/misc/cgo/testcshared/main2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain2.c?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -9,7 +9,7 @@\n #include <time.h>\n #include <unistd.h>\n \n-#define fd (100)\n+#define fd (30)\n \n // Tests libgo2.so, which does not export any functions.\n // Read a string from the file descriptor and print it."}, {"sha": "e57c93b77d739b5e7ddf180e33234854088b55ff", "filename": "libgo/misc/cgo/testcshared/src/libgo2/libgo2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Flibgo2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9492649182de9b36eaa71a49b96143e551afc54/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Flibgo2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Flibgo2.go?ref=c9492649182de9b36eaa71a49b96143e551afc54", "patch": "@@ -21,7 +21,7 @@ import (\n // that the C code can also use.\n \n const (\n-\tfd = 100\n+\tfd = 30\n )\n \n func init() {"}]}