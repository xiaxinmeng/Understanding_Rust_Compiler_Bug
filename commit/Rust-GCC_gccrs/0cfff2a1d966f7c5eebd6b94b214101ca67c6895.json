{"sha": "0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNmZmYyYTFkOTY2ZjdjNWVlYmQ2Yjk0YjIxNDEwMWNhNjdjNjg5NQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-08-04T09:52:52Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-08-04T09:52:52Z"}, "message": "[AArch64][3/14] Refactor option override code\n\n\t* config/aarch64/aarch64.opt (aarch64_arch_string): Delete.\n\t(aarch64_cpu_string): Likewise.\n\t(aarch64_tune_string): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_parse_opt_result): New enum.\n\t(aarch64_parse_extension): Return aarch64_parse_opt_result.\n\tAdd extra argument to put result into.\n\t(aarch64_parse_arch): Likewise.  Do not set selected_cpu.\n\t(aarch64_parse_cpu): Add arguments to put results into. Return\n\taarch64_parse_opt_result.\n\t(aarch64_parse_tune): Likewise.\n\t(aarch64_override_options_after_change_1): New function.\n\t(aarch64_override_options_internal): New function.\n\t(aarch64_validate_mcpu): Likewise.\n\t(aarch64_validate_march): Likewise.\n\t(aarch64_validate_mtune): Likewise.\n\t(aarch64_override_options): Update to reflect above changes.\n\tMove some logic into aarch64_override_options_internal.\n\tInitialize target_option_default_node and target_option_current_node.\n\t(aarch64_override_options_after_change): Move logic into\n\taarch64_override_options_after_change_1 and call it with global_options.\n\t(initialize_aarch64_code_model): Take a gcc_options pointer and use the\n\tflag values from that.\n\n\t* gcc.target/aarch64/cpu-diagnostics-3.c: Update expected error\n\tmessage.\n\nFrom-SVN: r226554", "tree": {"sha": "a4b781bbb05b0a75112f6fd7881a81d05559c02d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4b781bbb05b0a75112f6fd7881a81d05559c02d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "393ae126e488d3b8d7f6f650752e7f26a2feb2ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393ae126e488d3b8d7f6f650752e7f26a2feb2ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/393ae126e488d3b8d7f6f650752e7f26a2feb2ce"}], "stats": {"total": 485, "additions": 339, "deletions": 146}, "files": [{"sha": "b04e54a2f36f0a47d73bb8e9d818b4af2da52e6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "patch": "@@ -1,3 +1,28 @@\n+2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.opt (aarch64_arch_string): Delete.\n+\t(aarch64_cpu_string): Likewise.\n+\t(aarch64_tune_string): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_parse_opt_result): New enum.\n+\t(aarch64_parse_extension): Return aarch64_parse_opt_result.\n+\tAdd extra argument to put result into.\n+\t(aarch64_parse_arch): Likewise.  Do not set selected_cpu.\n+\t(aarch64_parse_cpu): Add arguments to put results into. Return\n+\taarch64_parse_opt_result.\n+\t(aarch64_parse_tune): Likewise.\n+\t(aarch64_override_options_after_change_1): New function.\n+\t(aarch64_override_options_internal): New function.\n+\t(aarch64_validate_mcpu): Likewise.\n+\t(aarch64_validate_march): Likewise.\n+\t(aarch64_validate_mtune): Likewise.\n+\t(aarch64_override_options): Update to reflect above changes.\n+\tMove some logic into aarch64_override_options_internal.\n+\tInitialize target_option_default_node and target_option_current_node.\n+\t(aarch64_override_options_after_change): Move logic into\n+\taarch64_override_options_after_change_1 and call it with global_options.\n+\t(initialize_aarch64_code_model): Take a gcc_options pointer and use the\n+\tflag values from that.\n+\n 2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.h (TARGET_CPU_CPP_BUILTINS): Define"}, {"sha": "e0ae64d4a44627fb6bd09fe6cba036e192780bf6", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 308, "deletions": 134, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "patch": "@@ -7108,12 +7108,26 @@ aarch64_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n   return retval;\n }\n \n-static void initialize_aarch64_code_model (void);\n+static void initialize_aarch64_code_model (struct gcc_options *);\n \n-/* Parse the architecture extension string.  */\n+/* Enum describing the various ways that the\n+   aarch64_parse_{arch,tune,cpu,extension} functions can fail.\n+   This way their callers can choose what kind of error to give.  */\n \n-static void\n-aarch64_parse_extension (char *str)\n+enum aarch64_parse_opt_result\n+{\n+  AARCH64_PARSE_OK,\t\t\t/* Parsing was successful.  */\n+  AARCH64_PARSE_MISSING_ARG,\t\t/* Missing argument.  */\n+  AARCH64_PARSE_INVALID_FEATURE,\t/* Invalid feature modifier.  */\n+  AARCH64_PARSE_INVALID_ARG\t\t/* Invalid arch, tune, cpu arg.  */\n+};\n+\n+/* Parse the architecture extension string STR and update ISA_FLAGS\n+   with the architecture features turned on or off.  Return a\n+   aarch64_parse_opt_result describing the result.  */\n+\n+static enum aarch64_parse_opt_result\n+aarch64_parse_extension (char *str, unsigned long *isa_flags)\n {\n   /* The extension string is parsed left to right.  */\n   const struct aarch64_option_extension *opt = NULL;\n@@ -7144,11 +7158,8 @@ aarch64_parse_extension (char *str)\n \tadding_ext = 1;\n \n       if (len == 0)\n-\t{\n-\t  error (\"missing feature modifier after %qs\", adding_ext ? \"+\"\n-\t                                                          : \"+no\");\n-\t  return;\n-\t}\n+\treturn AARCH64_PARSE_MISSING_ARG;\n+\n \n       /* Scan over the extensions table trying to find an exact match.  */\n       for (opt = all_extensions; opt->name != NULL; opt++)\n@@ -7157,37 +7168,40 @@ aarch64_parse_extension (char *str)\n \t    {\n \t      /* Add or remove the extension.  */\n \t      if (adding_ext)\n-\t\taarch64_isa_flags |= opt->flags_on;\n+\t\t*isa_flags |= opt->flags_on;\n \t      else\n-\t\taarch64_isa_flags &= ~(opt->flags_off);\n+\t\t*isa_flags &= ~(opt->flags_off);\n \t      break;\n \t    }\n \t}\n \n       if (opt->name == NULL)\n \t{\n \t  /* Extension not found in list.  */\n-\t  error (\"unknown feature modifier %qs\", str);\n-\t  return;\n+\t  return AARCH64_PARSE_INVALID_FEATURE;\n \t}\n \n       str = ext;\n     };\n \n-  return;\n+  return AARCH64_PARSE_OK;\n }\n \n-/* Parse the ARCH string.  */\n+/* Parse the TO_PARSE string and put the architecture struct that it\n+   selects into RES and the architectural features into ISA_FLAGS.\n+   Return an aarch64_parse_opt_result describing the parse result.\n+   If there is an error parsing, RES and ISA_FLAGS are left unchanged.  */\n \n-static void\n-aarch64_parse_arch (void)\n+static enum aarch64_parse_opt_result\n+aarch64_parse_arch (const char *to_parse, const struct processor **res,\n+\t\t    unsigned long *isa_flags)\n {\n   char *ext;\n   const struct processor *arch;\n-  char *str = (char *) alloca (strlen (aarch64_arch_string) + 1);\n+  char *str = (char *) alloca (strlen (to_parse) + 1);\n   size_t len;\n \n-  strcpy (str, aarch64_arch_string);\n+  strcpy (str, to_parse);\n \n   ext = strchr (str, '+');\n \n@@ -7197,55 +7211,52 @@ aarch64_parse_arch (void)\n     len = strlen (str);\n \n   if (len == 0)\n-    {\n-      error (\"missing arch name in -march=%qs\", str);\n-      return;\n-    }\n+    return AARCH64_PARSE_MISSING_ARG;\n+\n \n-  /* Loop through the list of supported ARCHs to find a match.  */\n+  /* Loop through the list of supported ARCHes to find a match.  */\n   for (arch = all_architectures; arch->name != NULL; arch++)\n     {\n       if (strlen (arch->name) == len && strncmp (arch->name, str, len) == 0)\n \t{\n-\t  selected_arch = arch;\n-\t  aarch64_isa_flags = selected_arch->flags;\n-\n-\t  if (!selected_cpu)\n-\t    selected_cpu = &all_cores[selected_arch->ident];\n+\t  unsigned long isa_temp = arch->flags;\n \n \t  if (ext != NULL)\n \t    {\n-\t      /* ARCH string contains at least one extension.  */\n-\t      aarch64_parse_extension (ext);\n-\t    }\n+\t      /* TO_PARSE string contains at least one extension.  */\n+\t      enum aarch64_parse_opt_result ext_res\n+\t\t= aarch64_parse_extension (ext, &isa_temp);\n \n-\t  if (selected_arch->arch != selected_cpu->arch)\n-\t    {\n-\t      warning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n-\t\t       all_architectures[selected_cpu->arch].name,\n-\t\t       selected_arch->name);\n+\t      if (ext_res != AARCH64_PARSE_OK)\n+\t\treturn ext_res;\n \t    }\n-\n-\t  return;\n+\t  /* Extension parsing was successful.  Confirm the result\n+\t     arch and ISA flags.  */\n+\t  *res = arch;\n+\t  *isa_flags = isa_temp;\n+\t  return AARCH64_PARSE_OK;\n \t}\n     }\n \n   /* ARCH name not found in list.  */\n-  error (\"unknown value %qs for -march\", str);\n-  return;\n+  return AARCH64_PARSE_INVALID_ARG;\n }\n \n-/* Parse the CPU string.  */\n+/* Parse the TO_PARSE string and put the result tuning in RES and the\n+   architecture flags in ISA_FLAGS.  Return an aarch64_parse_opt_result\n+   describing the parse result.  If there is an error parsing, RES and\n+   ISA_FLAGS are left unchanged.  */\n \n-static void\n-aarch64_parse_cpu (void)\n+static enum aarch64_parse_opt_result\n+aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n+\t\t   unsigned long *isa_flags)\n {\n   char *ext;\n   const struct processor *cpu;\n-  char *str = (char *) alloca (strlen (aarch64_cpu_string) + 1);\n+  char *str = (char *) alloca (strlen (to_parse) + 1);\n   size_t len;\n \n-  strcpy (str, aarch64_cpu_string);\n+  strcpy (str, to_parse);\n \n   ext = strchr (str, '+');\n \n@@ -7255,56 +7266,62 @@ aarch64_parse_cpu (void)\n     len = strlen (str);\n \n   if (len == 0)\n-    {\n-      error (\"missing cpu name in -mcpu=%qs\", str);\n-      return;\n-    }\n+    return AARCH64_PARSE_MISSING_ARG;\n+\n \n   /* Loop through the list of supported CPUs to find a match.  */\n   for (cpu = all_cores; cpu->name != NULL; cpu++)\n     {\n       if (strlen (cpu->name) == len && strncmp (cpu->name, str, len) == 0)\n \t{\n-\t  selected_cpu = cpu;\n-\t  aarch64_isa_flags = selected_cpu->flags;\n+\t  unsigned long isa_temp = cpu->flags;\n+\n \n \t  if (ext != NULL)\n \t    {\n-\t      /* CPU string contains at least one extension.  */\n-\t      aarch64_parse_extension (ext);\n-\t    }\n+\t      /* TO_PARSE string contains at least one extension.  */\n+\t      enum aarch64_parse_opt_result ext_res\n+\t\t= aarch64_parse_extension (ext, &isa_temp);\n \n-\t  return;\n+\t      if (ext_res != AARCH64_PARSE_OK)\n+\t\treturn ext_res;\n+\t    }\n+\t  /* Extension parsing was successfull.  Confirm the result\n+\t     cpu and ISA flags.  */\n+\t  *res = cpu;\n+\t  *isa_flags = isa_temp;\n+\t  return AARCH64_PARSE_OK;\n \t}\n     }\n \n   /* CPU name not found in list.  */\n-  error (\"unknown value %qs for -mcpu\", str);\n-  return;\n+  return AARCH64_PARSE_INVALID_ARG;\n }\n \n-/* Parse the TUNE string.  */\n+/* Parse the TO_PARSE string and put the cpu it selects into RES.\n+   Return an aarch64_parse_opt_result describing the parse result.\n+   If the parsing fails the RES does not change.  */\n \n-static void\n-aarch64_parse_tune (void)\n+static enum aarch64_parse_opt_result\n+aarch64_parse_tune (const char *to_parse, const struct processor **res)\n {\n   const struct processor *cpu;\n-  char *str = (char *) alloca (strlen (aarch64_tune_string) + 1);\n-  strcpy (str, aarch64_tune_string);\n+  char *str = (char *) alloca (strlen (to_parse) + 1);\n+\n+  strcpy (str, to_parse);\n \n   /* Loop through the list of supported CPUs to find a match.  */\n   for (cpu = all_cores; cpu->name != NULL; cpu++)\n     {\n       if (strcmp (cpu->name, str) == 0)\n \t{\n-\t  selected_tune = cpu;\n-\t  return;\n+\t  *res = cpu;\n+\t  return AARCH64_PARSE_OK;\n \t}\n     }\n \n   /* CPU name not found in list.  */\n-  error (\"unknown value %qs for -mtune\", str);\n-  return;\n+  return AARCH64_PARSE_INVALID_ARG;\n }\n \n /* Parse TOKEN, which has length LENGTH to see if it is an option\n@@ -7480,108 +7497,265 @@ aarch64_parse_override_string (const char* input_string,\n   free (string_root);\n }\n \n-/* Implement TARGET_OPTION_OVERRIDE.  */\n \n static void\n-aarch64_override_options (void)\n+aarch64_override_options_after_change_1 (struct gcc_options *opts)\n {\n-  /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.\n-     If either of -march or -mtune is given, they override their\n-     respective component of -mcpu.\n+  if (opts->x_flag_omit_frame_pointer)\n+    opts->x_flag_omit_leaf_frame_pointer = false;\n+  else if (opts->x_flag_omit_leaf_frame_pointer)\n+    opts->x_flag_omit_frame_pointer = true;\n \n-     So, first parse AARCH64_CPU_STRING, then the others, be careful\n-     with -march as, if -mcpu is not present on the command line, march\n-     must set a sensible default CPU.  */\n-  if (aarch64_cpu_string)\n+  /* If not opzimizing for size, set the default\n+     alignment to what the target wants.  */\n+  if (!opts->x_optimize_size)\n     {\n-      aarch64_parse_cpu ();\n+      if (opts->x_align_loops <= 0)\n+\topts->x_align_loops = aarch64_tune_params.loop_align;\n+      if (opts->x_align_jumps <= 0)\n+\topts->x_align_jumps = aarch64_tune_params.jump_align;\n+      if (opts->x_align_functions <= 0)\n+\topts->x_align_functions = aarch64_tune_params.function_align;\n     }\n+}\n \n-  if (aarch64_arch_string)\n+/* 'Unpack' up the internal tuning structs and update the options\n+    in OPTS.  The caller must have set up selected_tune and selected_arch\n+    as all the other target-specific codegen decisions are\n+    derived from them.  */\n+\n+static void\n+aarch64_override_options_internal (struct gcc_options *opts)\n+{\n+  aarch64_tune_flags = selected_tune->flags;\n+  aarch64_tune = selected_tune->sched_core;\n+  /* Make a copy of the tuning parameters attached to the core, which\n+     we may later overwrite.  */\n+  aarch64_tune_params = *(selected_tune->tune);\n+  aarch64_architecture_version = selected_arch->architecture_version;\n+\n+  if (opts->x_aarch64_override_tune_string)\n+    aarch64_parse_override_string (opts->x_aarch64_override_tune_string,\n+\t\t\t\t  &aarch64_tune_params);\n+\n+  /* This target defaults to strict volatile bitfields.  */\n+  if (opts->x_flag_strict_volatile_bitfields < 0 && abi_version_at_least (2))\n+    opts->x_flag_strict_volatile_bitfields = 1;\n+\n+  if (opts->x_aarch64_fix_a53_err835769 == 2)\n     {\n-      aarch64_parse_arch ();\n+#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT\n+      opts->x_aarch64_fix_a53_err835769 = 1;\n+#else\n+      opts->x_aarch64_fix_a53_err835769 = 0;\n+#endif\n     }\n \n-  if (aarch64_tune_string)\n+  /* -mgeneral-regs-only sets a mask in target_flags, make sure that\n+     aarch64_isa_flags does not contain the FP/SIMD/Crypto feature flags\n+     in case some code tries reading aarch64_isa_flags directly to check if\n+     FP is available.  Reuse the aarch64_parse_extension machinery since it\n+     knows how to disable any other flags that fp implies.  */\n+  if (TARGET_GENERAL_REGS_ONLY_P (opts->x_target_flags))\n     {\n-      aarch64_parse_tune ();\n+      /* aarch64_parse_extension takes char* rather than const char* because\n+\t it is usually called from within other parsing functions.  */\n+      char tmp_str[] = \"+nofp\";\n+      aarch64_parse_extension (tmp_str, &aarch64_isa_flags);\n     }\n \n-#ifndef HAVE_AS_MABI_OPTION\n-  /* The compiler may have been configured with 2.23.* binutils, which does\n-     not have support for ILP32.  */\n-  if (TARGET_ILP32)\n-    error (\"Assembler does not support -mabi=ilp32\");\n-#endif\n+  initialize_aarch64_code_model (opts);\n \n-  initialize_aarch64_code_model ();\n+  aarch64_override_options_after_change_1 (opts);\n+}\n \n-  aarch64_build_bitmask_table ();\n+/* Validate a command-line -mcpu option.  Parse the cpu and extensions (if any)\n+   specified in STR and throw errors if appropriate.  Put the results if\n+   they are valid in RES and ISA_FLAGS.  */\n \n-  /* This target defaults to strict volatile bitfields.  */\n-  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least (2))\n-    flag_strict_volatile_bitfields = 1;\n+static void\n+aarch64_validate_mcpu (const char *str, const struct processor **res,\n+\t\t       unsigned long *isa_flags)\n+{\n+  enum aarch64_parse_opt_result parse_res\n+    = aarch64_parse_cpu (str, res, isa_flags);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    return;\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_MISSING_ARG:\n+\terror (\"missing cpu name in -mcpu=%qs\", str);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_ARG:\n+\terror (\"unknown value %qs for -mcpu\", str);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_FEATURE:\n+\terror (\"invalid feature modifier in -mcpu=%qs\", str);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Validate a command-line -march option.  Parse the arch and extensions\n+   (if any) specified in STR and throw errors if appropriate.  Put the\n+   results, if they are valid, in RES and ISA_FLAGS.  */\n+\n+static void\n+aarch64_validate_march (const char *str, const struct processor **res,\n+\t\t       unsigned long *isa_flags)\n+{\n+  enum aarch64_parse_opt_result parse_res\n+    = aarch64_parse_arch (str, res, isa_flags);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    return;\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_MISSING_ARG:\n+\terror (\"missing arch name in -march=%qs\", str);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_ARG:\n+\terror (\"unknown value %qs for -march\", str);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_FEATURE:\n+\terror (\"invalid feature modifier in -march=%qs\", str);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Validate a command-line -mtune option.  Parse the cpu\n+   specified in STR and throw errors if appropriate.  Put the\n+   result, if it is valid, in RES.  */\n+\n+static void\n+aarch64_validate_mtune (const char *str, const struct processor **res)\n+{\n+  enum aarch64_parse_opt_result parse_res\n+    = aarch64_parse_tune (str, res);\n+\n+  if (parse_res == AARCH64_PARSE_OK)\n+    return;\n+\n+  switch (parse_res)\n+    {\n+      case AARCH64_PARSE_MISSING_ARG:\n+\terror (\"missing cpu name in -mtune=%qs\", str);\n+\tbreak;\n+      case AARCH64_PARSE_INVALID_ARG:\n+\terror (\"unknown value %qs for -mtune\", str);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Implement TARGET_OPTION_OVERRIDE.  This is called once in the beginning\n+   and is used to parse the -m{cpu,tune,arch} strings and setup the initial\n+   tuning structs.  In particular it must set selected_tune and\n+   aarch64_isa_flags that define the available ISA features and tuning\n+   decisions.  It must also set selected_arch as this will be used to\n+   output the .arch asm tags for each function.  */\n+\n+static void\n+aarch64_override_options (void)\n+{\n+  unsigned long cpu_isa = 0;\n+  unsigned long arch_isa = 0;\n+  aarch64_isa_flags = 0;\n+\n+  selected_cpu = NULL;\n+  selected_arch = NULL;\n+  selected_tune = NULL;\n+\n+  /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.\n+     If either of -march or -mtune is given, they override their\n+     respective component of -mcpu.  */\n+  if (aarch64_cpu_string)\n+    aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu, &cpu_isa);\n+\n+  if (aarch64_arch_string)\n+    aarch64_validate_march (aarch64_arch_string, &selected_arch, &arch_isa);\n+\n+  if (aarch64_tune_string)\n+    aarch64_validate_mtune (aarch64_tune_string, &selected_tune);\n \n   /* If the user did not specify a processor, choose the default\n      one for them.  This will be the CPU set during configuration using\n      --with-cpu, otherwise it is \"generic\".  */\n   if (!selected_cpu)\n     {\n-      selected_cpu = &all_cores[TARGET_CPU_DEFAULT & 0x3f];\n-      aarch64_isa_flags = TARGET_CPU_DEFAULT >> 6;\n+      if (selected_arch)\n+\t{\n+\t  selected_cpu = &all_cores[selected_arch->ident];\n+\t  aarch64_isa_flags = arch_isa;\n+\t}\n+      else\n+\t{\n+\t  selected_cpu = &all_cores[TARGET_CPU_DEFAULT & 0x3f];\n+\t  aarch64_isa_flags = TARGET_CPU_DEFAULT >> 6;\n+\t}\n+    }\n+  /* If both -mcpu and -march are specified check that they are architecturally\n+     compatible, warn if they're not and prefer the -march ISA flags.  */\n+  else if (selected_arch)\n+    {\n+      if (selected_arch->arch != selected_cpu->arch)\n+\t{\n+\t  warning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n+\t\t       all_architectures[selected_cpu->arch].name,\n+\t\t       selected_arch->name);\n+\t}\n+      aarch64_isa_flags = arch_isa;\n+    }\n+  else\n+    {\n+      /* -mcpu but no -march.  */\n+      aarch64_isa_flags = cpu_isa;\n     }\n \n-  gcc_assert (selected_cpu);\n+  /* Set the arch as well as we will need it when outputing\n+     the .arch directive in assembly.  */\n+  if (!selected_arch)\n+    {\n+      gcc_assert (selected_cpu);\n+      selected_arch = &all_architectures[selected_cpu->arch];\n+    }\n \n   if (!selected_tune)\n     selected_tune = selected_cpu;\n \n-  aarch64_tune_flags = selected_tune->flags;\n-  aarch64_tune = selected_tune->sched_core;\n-  /* Make a copy of the tuning parameters attached to the core, which\n-     we may later overwrite.  */\n-  aarch64_tune_params = *(selected_tune->tune);\n-  aarch64_architecture_version = selected_cpu->architecture_version;\n+#ifndef HAVE_AS_MABI_OPTION\n+  /* The compiler may have been configured with 2.23.* binutils, which does\n+     not have support for ILP32.  */\n+  if (TARGET_ILP32)\n+    error (\"Assembler does not support -mabi=ilp32\");\n+#endif\n \n-  if (aarch64_override_tune_string)\n-    aarch64_parse_override_string (aarch64_override_tune_string,\n-\t\t\t\t   &aarch64_tune_params);\n+  aarch64_build_bitmask_table ();\n \n-  if (aarch64_fix_a53_err835769 == 2)\n-    {\n-#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT\n-      aarch64_fix_a53_err835769 = 1;\n-#else\n-      aarch64_fix_a53_err835769 = 0;\n-#endif\n-    }\n+  aarch64_override_options_internal (&global_options);\n+\n+  /* Save these options as the default ones in case we push and pop them later\n+     while processing functions with potential target attributes.  */\n+  target_option_default_node = target_option_current_node\n+      = build_target_option_node (&global_options);\n \n   aarch64_register_fma_steering ();\n \n-  aarch64_override_options_after_change ();\n }\n \n /* Implement targetm.override_options_after_change.  */\n \n static void\n aarch64_override_options_after_change (void)\n {\n-  if (flag_omit_frame_pointer)\n-    flag_omit_leaf_frame_pointer = false;\n-  else if (flag_omit_leaf_frame_pointer)\n-    flag_omit_frame_pointer = true;\n-\n-  /* If not optimizing for size, set the default\n-     alignment to what the target wants */\n-  if (!optimize_size)\n-    {\n-      if (align_loops <= 0)\n-\talign_loops = aarch64_tune_params.loop_align;\n-      if (align_jumps <= 0)\n-\talign_jumps = aarch64_tune_params.jump_align;\n-      if (align_functions <= 0)\n-\talign_functions = aarch64_tune_params.function_align;\n-    }\n+  aarch64_override_options_after_change_1 (&global_options);\n }\n \n static struct machine_function *\n@@ -7600,11 +7774,11 @@ aarch64_init_expanders (void)\n \n /* A checking mechanism for the implementation of the various code models.  */\n static void\n-initialize_aarch64_code_model (void)\n+initialize_aarch64_code_model (struct gcc_options *opts)\n {\n-   if (flag_pic)\n+   if (opts->x_flag_pic)\n      {\n-       switch (aarch64_cmodel_var)\n+       switch (opts->x_aarch64_cmodel_var)\n \t {\n \t case AARCH64_CMODEL_TINY:\n \t   aarch64_cmodel = AARCH64_CMODEL_TINY_PIC;\n@@ -7620,13 +7794,13 @@ initialize_aarch64_code_model (void)\n \t   break;\n \t case AARCH64_CMODEL_LARGE:\n \t   sorry (\"code model %qs with -f%s\", \"large\",\n-\t\t  flag_pic > 1 ? \"PIC\" : \"pic\");\n+\t\t  opts->x_flag_pic > 1 ? \"PIC\" : \"pic\");\n \t default:\n \t   gcc_unreachable ();\n \t }\n      }\n    else\n-     aarch64_cmodel = aarch64_cmodel_var;\n+     aarch64_cmodel = opts->x_aarch64_cmodel_var;\n }\n \n /* Return true if SYMBOL_REF X binds locally.  */"}, {"sha": "c9c0afffb9446c8bc5e00893188a1d737db4f0d2", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "patch": "@@ -48,17 +48,6 @@ Enum(cmodel) String(small) Value(AARCH64_CMODEL_SMALL)\n EnumValue\n Enum(cmodel) String(large) Value(AARCH64_CMODEL_LARGE)\n \n-; The cpu/arch option names to use in cpu/arch selection.\n-\n-Variable\n-const char *aarch64_arch_string\n-\n-Variable\n-const char *aarch64_cpu_string\n-\n-Variable\n-const char *aarch64_tune_string\n-\n mbig-endian\n Target Report RejectNegative Mask(BIG_END)\n Assume target CPU is configured as big endian"}, {"sha": "ba6c32d1ba9639283d554da78a68402fd302d01b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "patch": "@@ -1,3 +1,8 @@\n+2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.target/aarch64/cpu-diagnostics-3.c: Update expected error\n+\tmessage.\n+\n 2015-08-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/64022"}, {"sha": "807e3253e30637f73613cdd184dc79bb6f24e7dc", "filename": "gcc/testsuite/gcc.target/aarch64/cpu-diagnostics-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcpu-diagnostics-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cfff2a1d966f7c5eebd6b94b214101ca67c6895/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcpu-diagnostics-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcpu-diagnostics-3.c?ref=0cfff2a1d966f7c5eebd6b94b214101ca67c6895", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-error \"unknown\" \"\" {target \"aarch64*-*-*\" } } */\n+/* { dg-error \"invalid feature\" \"\" {target \"aarch64*-*-*\" } } */\n /* { dg-options \"-O2 -mcpu=cortex-a53+dummy\" } */\n \n void f ()"}]}