{"sha": "e0e82856d535f56c916382f892ed2435dde54d4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBlODI4NTZkNTM1ZjU2YzkxNjM4MmY4OTJlZDI0MzVkZGU1NGQ0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-20T15:26:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-20T15:28:19Z"}, "message": "rs6000: Fix up easy_vector_constant_msb handling [PR101384]\n\nThe following gcc.dg/pr101384.c testcase is miscompiled on\npowerpc64le-linux.\neasy_altivec_constant has code to try construct vector constants with\ndifferent element sizes, perhaps different from CONST_VECTOR's mode.  But as\nwritten, that works fine for vspltis[bhw] cases, but not for the vspltisw\nx,-1; vsl[bhw] x,x,x case, because that creates always a V16QImode, V8HImode\nor V4SImode constant containing broadcasted constant with just the MSB set.\nThe vspltis_constant function etc. expects the vspltis[bhw] instructions\nwhere the small [-16..15] or even [-32..30] constant is sign-extended to the\nremaining step bytes, but that is not the case for the 0x80...00 constants,\nwith step > 1 we can't handle e.g.\n{ 0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff }\nvectors but do want to handle e.g.\n{ 0, 0, 0, 0x80, 0, 0, 0, 0x80, 0, 0, 0, 0x80, 0, 0, 0, 0x80 }\nand similarly with copies > 1 we do want to handle e.g.\n{ 0x80808080, 0x80808080, 0x80808080, 0x80808080 }.\n\n2021-07-20  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/101384\n\t* config/rs6000/rs6000-protos.h (easy_altivec_constant): Change return\n\ttype from bool to int.\n\t* config/rs6000/rs6000.c (vspltis_constant): Fix up handling the\n\tEASY_VECTOR_MSB case if either step or copies is not 1.\n\t(vspltis_shifted): Fix comment typo.\n\t(easy_altivec_constant): Change return type from bool to int, instead\n\tof returning true return byte size of the element mode that should be\n\tused to synthetize the constant.\n\t* config/rs6000/predicates.md (easy_vector_constant_msb): Require\n\tthat vspltis_shifted is 0, handle the case where easy_altivec_constant\n\tassumes using different vector mode from CONST_VECTOR's mode.\n\t* config/rs6000/altivec.md (easy_vector_constant_msb splitter): Use\n\teasy_altivec_constant to determine mode in which -1 >> -1 should be\n\tperformed, use rs6000_expand_vector_init instead of gen_vec_initv4sisi.\n\n\t* gcc.dg/pr101384.c: New test.\n\t* gcc.target/powerpc/pr101384-1.c: New test.\n\t* gcc.target/powerpc/pr101384-2.c: New test.", "tree": {"sha": "83a07cc240c88bbe9bbcf639765e11caaf8f09cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83a07cc240c88bbe9bbcf639765e11caaf8f09cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0e82856d535f56c916382f892ed2435dde54d4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e82856d535f56c916382f892ed2435dde54d4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0e82856d535f56c916382f892ed2435dde54d4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e82856d535f56c916382f892ed2435dde54d4d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89ec3b67dbe856a447d068b053bc19559f136f43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ec3b67dbe856a447d068b053bc19559f136f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ec3b67dbe856a447d068b053bc19559f136f43"}], "stats": {"total": 294, "additions": 268, "deletions": 26}, "files": [{"sha": "d70c17e6bc20e3b36c7867dcf07704df47d5ef2f", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -317,22 +317,33 @@\n   [(const_int 0)]\n {\n   rtx dest = operands[0];\n-  machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode mode;\n   rtvec v;\n   int i, num_elements;\n \n-  if (mode == V4SFmode)\n+  switch (easy_altivec_constant (operands[1], <MODE>mode))\n     {\n+    case 1:\n+      mode = V16QImode;\n+      break;\n+    case 2:\n+      mode = V8HImode;\n+      break;\n+    case 4:\n       mode = V4SImode;\n-      dest = gen_lowpart (V4SImode, dest);\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n+  if (mode != <MODE>mode)\n+    dest = gen_lowpart (mode, dest);\n \n   num_elements = GET_MODE_NUNITS (mode);\n   v = rtvec_alloc (num_elements);\n   for (i = 0; i < num_elements; i++)\n     RTVEC_ELT (v, i) = constm1_rtx;\n \n-  emit_insn (gen_vec_initv4sisi (dest, gen_rtx_PARALLEL (mode, v)));\n+  rs6000_expand_vector_init (dest, gen_rtx_PARALLEL (mode, v));\n   emit_insn (gen_rtx_SET (dest, gen_rtx_ASHIFT (mode, dest, dest)));\n   DONE;\n })"}, {"sha": "956e42bc514a57699dafa9a98aee4d668d7a7a57", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -683,15 +683,26 @@\n (define_predicate \"easy_vector_constant_msb\"\n   (and (match_code \"const_vector\")\n        (and (match_test \"TARGET_ALTIVEC\")\n-\t    (match_test \"easy_altivec_constant (op, mode)\")))\n+\t    (match_test \"easy_altivec_constant (op, mode)\")\n+\t    (match_test \"vspltis_shifted (op) == 0\")))\n {\n   HOST_WIDE_INT val;\n-  int elt;\n+  int elt, sz = easy_altivec_constant (op, mode);\n+  machine_mode inner = GET_MODE_INNER (mode);\n+  int isz = GET_MODE_SIZE (inner);\n   if (mode == V2DImode || mode == V2DFmode)\n     return 0;\n   elt = BYTES_BIG_ENDIAN ? GET_MODE_NUNITS (mode) - 1 : 0;\n+  if (isz < sz)\n+    {\n+      if (const_vector_elt_as_int (op, elt) != 0)\n+\treturn 0;\n+      elt += (BYTES_BIG_ENDIAN ? -1 : 1) * (sz - isz) / isz;\n+    }\n+  else if (isz > sz)\n+    inner = smallest_int_mode_for_size (sz * BITS_PER_UNIT);\n   val = const_vector_elt_as_int (op, elt);\n-  return EASY_VECTOR_MSB (val, GET_MODE_INNER (mode));\n+  return EASY_VECTOR_MSB (val, inner);\n })\n \n ;; Return true if this is an easy altivec constant that we form"}, {"sha": "14f6b31310581e0cc135cb6fbbeea76faaf8f125", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -30,7 +30,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int, int,\n \t\t\t\t  tree, machine_mode);\n #endif /* TREE_CODE */\n \n-extern bool easy_altivec_constant (rtx, machine_mode);\n+extern int easy_altivec_constant (rtx, machine_mode);\n extern bool xxspltib_constant_p (rtx, machine_mode, int *, int *);\n extern int vspltis_shifted (rtx);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);"}, {"sha": "279f00cc648373f51c1be219f3f04a81852c5402", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -6134,6 +6134,27 @@ vspltis_constant (rtx op, unsigned step, unsigned copies)\n   splat_val = val;\n   msb_val = val >= 0 ? 0 : -1;\n \n+  if (val == 0 && step > 1)\n+    {\n+      /* Special case for loading most significant bit with step > 1.\n+\t In that case, match 0s in all but step-1s elements, where match\n+\t EASY_VECTOR_MSB.  */\n+      for (i = 1; i < nunits; ++i)\n+\t{\n+\t  unsigned elt = BYTES_BIG_ENDIAN ? nunits - 1 - i : i;\n+\t  HOST_WIDE_INT elt_val = const_vector_elt_as_int (op, elt);\n+\t  if ((i & (step - 1)) == step - 1)\n+\t    {\n+\t      if (!EASY_VECTOR_MSB (elt_val, inner))\n+\t\tbreak;\n+\t    }\n+\t  else if (elt_val)\n+\t    break;\n+\t}\n+      if (i == nunits)\n+\treturn true;\n+    }\n+\n   /* Construct the value to be splatted, if possible.  If not, return 0.  */\n   for (i = 2; i <= copies; i *= 2)\n     {\n@@ -6146,6 +6167,7 @@ vspltis_constant (rtx op, unsigned step, unsigned copies)\n           | (small_val & mask)))\n \treturn false;\n       splat_val = small_val;\n+      inner = smallest_int_mode_for_size (bitsize);\n     }\n \n   /* Check if SPLAT_VAL can really be the operand of a vspltis[bhw].  */\n@@ -6160,8 +6182,9 @@ vspltis_constant (rtx op, unsigned step, unsigned copies)\n     ;\n \n   /* Also check if are loading up the most significant bit which can be done by\n-     loading up -1 and shifting the value left by -1.  */\n-  else if (EASY_VECTOR_MSB (splat_val, inner))\n+     loading up -1 and shifting the value left by -1.  Only do this for\n+     step 1 here, for larger steps it is done earlier.  */\n+  else if (EASY_VECTOR_MSB (splat_val, inner) && step == 1)\n     ;\n \n   else\n@@ -6271,55 +6294,55 @@ vspltis_shifted (rtx op)\n \t}\n     }\n \n-  /* If all elements are equal, we don't need to do VLSDOI.  */\n+  /* If all elements are equal, we don't need to do VSLDOI.  */\n   return 0;\n }\n \n \n-/* Return true if OP is of the given MODE and can be synthesized\n-   with a vspltisb, vspltish or vspltisw.  */\n+/* Return non-zero (element mode byte size) if OP is of the given MODE\n+   and can be synthesized with a vspltisb, vspltish or vspltisw.  */\n \n-bool\n+int\n easy_altivec_constant (rtx op, machine_mode mode)\n {\n   unsigned step, copies;\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n   else if (mode != GET_MODE (op))\n-    return false;\n+    return 0;\n \n   /* V2DI/V2DF was added with VSX.  Only allow 0 and all 1's as easy\n      constants.  */\n   if (mode == V2DFmode)\n-    return zero_constant (op, mode);\n+    return zero_constant (op, mode) ? 8 : 0;\n \n   else if (mode == V2DImode)\n     {\n       if (!CONST_INT_P (CONST_VECTOR_ELT (op, 0))\n \t  || !CONST_INT_P (CONST_VECTOR_ELT (op, 1)))\n-\treturn false;\n+\treturn 0;\n \n       if (zero_constant (op, mode))\n-\treturn true;\n+\treturn 8;\n \n       if (INTVAL (CONST_VECTOR_ELT (op, 0)) == -1\n \t  && INTVAL (CONST_VECTOR_ELT (op, 1)) == -1)\n-\treturn true;\n+\treturn 8;\n \n-      return false;\n+      return 0;\n     }\n \n   /* V1TImode is a special container for TImode.  Ignore for now.  */\n   else if (mode == V1TImode)\n-    return false;\n+    return 0;\n \n   /* Start with a vspltisw.  */\n   step = GET_MODE_NUNITS (mode) / 4;\n   copies = 1;\n \n   if (vspltis_constant (op, step, copies))\n-    return true;\n+    return 4;\n \n   /* Then try with a vspltish.  */\n   if (step == 1)\n@@ -6328,7 +6351,7 @@ easy_altivec_constant (rtx op, machine_mode mode)\n     step >>= 1;\n \n   if (vspltis_constant (op, step, copies))\n-    return true;\n+    return 2;\n \n   /* And finally a vspltisb.  */\n   if (step == 1)\n@@ -6337,12 +6360,12 @@ easy_altivec_constant (rtx op, machine_mode mode)\n     step >>= 1;\n \n   if (vspltis_constant (op, step, copies))\n-    return true;\n+    return 1;\n \n   if (vspltis_shifted (op) != 0)\n-    return true;\n+    return GET_MODE_SIZE (GET_MODE_INNER (mode));\n \n-  return false;\n+  return 0;\n }\n \n /* Generate a VEC_DUPLICATE representing a vspltis[bhw] instruction whose"}, {"sha": "7030c0a481e6326fa14884397782901f3a836cc7", "filename": "gcc/testsuite/gcc.dg/pr101384.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr101384.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr101384.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr101384.c?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -0,0 +1,39 @@\n+/* PR target/101384 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -Wno-psabi -w\" } */\n+\n+typedef unsigned char __attribute__((__vector_size__ (16))) U;\n+typedef unsigned short __attribute__((__vector_size__ (8 * sizeof (short)))) V;\n+\n+U u;\n+V v;\n+\n+__attribute__((noipa)) U\n+foo (void)\n+{\n+  U y = (U) { 0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff,\n+              0x80, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff } + u;\n+  return y;\n+}\n+\n+__attribute__((noipa)) V\n+bar (void)\n+{\n+  V y = (V) { 0x8000, 0xffff, 0x8000, 0xffff,\n+              0x8000, 0xffff, 0x8000, 0xffff } + v;\n+  return y;\n+}\n+\n+int\n+main ()\n+{\n+  U x = foo ();\n+  for (unsigned i = 0; i < 16; i++)\n+    if (x[i] != ((i & 3) ? 0xff : 0x80))\n+      __builtin_abort ();\n+  V y = bar ();\n+  for (unsigned i = 0; i < 8; i++)\n+    if (y[i] != ((i & 1) ? 0xffff : 0x8000))\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "627d7d7672195904df47beb9acabf76e610b6ba4", "filename": "gcc/testsuite/gcc.target/powerpc/pr101384-1.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101384-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101384-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101384-1.c?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -0,0 +1,79 @@\n+/* PR target/101384 */\n+/* { dg-do compile { target le } } */\n+/* { dg-options \"-O2 -maltivec\" } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-final { scan-assembler-times {\\mvspltis[whb] [^\\n\\r]*,-1\\M} 9 } } */\n+/* { dg-final { scan-assembler-times {\\mvslw\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mvslh\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mvslb\\M} 3 } } */\n+\n+typedef unsigned char __attribute__((__vector_size__ (16))) U;\n+typedef unsigned short __attribute__((__vector_size__ (16))) V;\n+typedef unsigned int __attribute__((__vector_size__ (16))) W;\n+\n+U u;\n+V v;\n+W w;\n+\n+U\n+f1 (void)\n+{\n+  U y = (U) { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 } + u;\n+  return y;\n+}\n+\n+U\n+f2 (void)\n+{\n+  U y = (U) { 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80 } + u;\n+  return y;\n+}\n+\n+U\n+f3 (void)\n+{\n+  U y = (U) { 0, 0, 0, 0x80, 0, 0, 0, 0x80, 0, 0, 0, 0x80, 0, 0, 0, 0x80 } + u;\n+  return y;\n+}\n+\n+V\n+f4 (void)\n+{\n+  V y = (V) { 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080 } + v;\n+  return y;\n+}\n+\n+V\n+f5 (void)\n+{\n+  V y = (V) { 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000 } + v;\n+  return y;\n+}\n+\n+V\n+f6 (void)\n+{\n+  V y = (V) { 0, 0x8000, 0, 0x8000, 0, 0x8000, 0, 0x8000 } + v;\n+  return y;\n+}\n+\n+W\n+f7 (void)\n+{\n+  W y = (W) { 0x80808080, 0x80808080, 0x80808080, 0x80808080 } + w;\n+  return y;\n+}\n+\n+W\n+f8 (void)\n+{\n+  W y = (W) { 0x80008000, 0x80008000, 0x80008000, 0x80008000 } + w;\n+  return y;\n+}\n+\n+W\n+f9 (void)\n+{\n+  W y = (W) { 0x80000000, 0x80000000, 0x80000000, 0x80000000 } + w;\n+  return y;\n+}"}, {"sha": "f3957086b045c1ce003997901b1815790000d1b2", "filename": "gcc/testsuite/gcc.target/powerpc/pr101384-2.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101384-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e82856d535f56c916382f892ed2435dde54d4d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101384-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr101384-2.c?ref=e0e82856d535f56c916382f892ed2435dde54d4d", "patch": "@@ -0,0 +1,79 @@\n+/* PR target/101384 */\n+/* { dg-do compile { target be } } */\n+/* { dg-options \"-O2 -maltivec\" } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-final { scan-assembler-times {\\mvspltis[whb] [^\\n\\r]*,-1\\M} 9 } } */\n+/* { dg-final { scan-assembler-times {\\mvslw\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mvslh\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mvslb\\M} 3 } } */\n+\n+typedef unsigned char __attribute__((__vector_size__ (16))) U;\n+typedef unsigned short __attribute__((__vector_size__ (16))) V;\n+typedef unsigned int __attribute__((__vector_size__ (16))) W;\n+\n+U u;\n+V v;\n+W w;\n+\n+U\n+f1 (void)\n+{\n+  U y = (U) { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 } + u;\n+  return y;\n+}\n+\n+U\n+f2 (void)\n+{\n+  U y = (U) { 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0, 0x80, 0 } + u;\n+  return y;\n+}\n+\n+U\n+f3 (void)\n+{\n+  U y = (U) { 0x80, 0, 0, 0, 0x80, 0, 0, 0, 0x80, 0, 0, 0, 0x80, 0, 0, 0 } + u;\n+  return y;\n+}\n+\n+V\n+f4 (void)\n+{\n+  V y = (V) { 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080 } + v;\n+  return y;\n+}\n+\n+V\n+f5 (void)\n+{\n+  V y = (V) { 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000 } + v;\n+  return y;\n+}\n+\n+V\n+f6 (void)\n+{\n+  V y = (V) { 0x8000, 0, 0x8000, 0, 0x8000, 0, 0x8000, 0 } + v;\n+  return y;\n+}\n+\n+W\n+f7 (void)\n+{\n+  W y = (W) { 0x80808080, 0x80808080, 0x80808080, 0x80808080 } + w;\n+  return y;\n+}\n+\n+W\n+f8 (void)\n+{\n+  W y = (W) { 0x80008000, 0x80008000, 0x80008000, 0x80008000 } + w;\n+  return y;\n+}\n+\n+W\n+f9 (void)\n+{\n+  W y = (W) { 0x80000000, 0x80000000, 0x80000000, 0x80000000 } + w;\n+  return y;\n+}"}]}