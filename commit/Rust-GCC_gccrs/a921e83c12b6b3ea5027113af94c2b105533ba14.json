{"sha": "a921e83c12b6b3ea5027113af94c2b105533ba14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkyMWU4M2MxMmI2YjNlYTUwMjcxMTNhZjk0YzJiMTA1NTMzYmExNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:18:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:18:13Z"}, "message": "[multiple changes]\n\n2015-01-06  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb: Change name Name_Table_Boolean to\n\tName_Table_Boolean1.\n\t* namet.adb: Change name Name_Table_Boolean to Name_Table_Boolean1\n\tIntroduce Name_Table_Boolean2/3.\n\t* namet.ads: Change name Name_Table_Boolean to Name_Table_Boolean1\n\tIntroduce Name_Table_Boolean2/3.\n\t* par-ch13.adb: Change name Name_Table_Boolean to\n\tName_Table_Boolean1.\n\n2015-01-06  Bob Duff  <duff@adacore.com>\n\n\t* gnat_rm.texi: Improve documentation regarding No_Task_Termination.\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregte, Get_Value): For an\n\tothers choice that covers multiple components, analyze each\n\tcopy with the type of the component even in compile-only mode,\n\tto detect potential accessibility errors.\n\n2015-01-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_res.adb (Is_Assignment_Or_Object_Expression): New routine.\n\t(Resolve_Actuals): An effectively volatile out\n\tparameter cannot act as an in or in out actual in a call.\n\t(Resolve_Entity_Name): An effectively volatile out parameter\n\tcannot be read.\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): If the body is\n\tthe expansion of an expression function it may be pre-analyzed\n\tif a 'access attribute is applied to the function, in which case\n\tlast_entity may have been assigned already.\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_One_Call): If formal has an incomplete\n\ttype and actual has the corresponding full view, there is no\n\terror, but a case of use of incomplete type in a predicate or\n\tinvariant expression.\n\n2015-01-06  Vincent Celier  <celier@adacore.com>\n\n\t* makeutl.adb (Insert_No_Roots): Make sure that the same source\n\tin two different project tree is checked in both trees, if they\n\tare sources of two different projects, extended or not.\n\n2015-01-06  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb: Minor code clean up.\n\t(Adjust_Global_Switches): Ignore gnatprove_mode in codepeer_mode.\n\n2015-01-06  Bob Duff  <duff@adacore.com>\n\n\t* osint.adb (Read_Source_File): Don't print out\n\tfile name unless T = Source.\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Is_Variable, Is_OK_Variable_For_Out_Formal):\n\trecognize improper uses of constant_reference types as actuals\n\tfor in-out parameters.\n\t(Check_Function_Call): Do not collect identifiers if function\n\tname is missing because of previous error.\n\nFrom-SVN: r219231", "tree": {"sha": "58e776a5b2adf29b90e597c48cb52509a78cfcb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58e776a5b2adf29b90e597c48cb52509a78cfcb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a921e83c12b6b3ea5027113af94c2b105533ba14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a921e83c12b6b3ea5027113af94c2b105533ba14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a921e83c12b6b3ea5027113af94c2b105533ba14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a921e83c12b6b3ea5027113af94c2b105533ba14/comments", "author": null, "committer": null, "parents": [{"sha": "ac16e74cdf9135046892193eeb6eee7c8a8d4123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac16e74cdf9135046892193eeb6eee7c8a8d4123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac16e74cdf9135046892193eeb6eee7c8a8d4123"}], "stats": {"total": 413, "additions": 343, "deletions": 70}, "files": [{"sha": "dde69e595a25b74c5c18ae3253146dcb96e0ce2f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -1,3 +1,71 @@\n+2015-01-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb: Change name Name_Table_Boolean to\n+\tName_Table_Boolean1.\n+\t* namet.adb: Change name Name_Table_Boolean to Name_Table_Boolean1\n+\tIntroduce Name_Table_Boolean2/3.\n+\t* namet.ads: Change name Name_Table_Boolean to Name_Table_Boolean1\n+\tIntroduce Name_Table_Boolean2/3.\n+\t* par-ch13.adb: Change name Name_Table_Boolean to\n+\tName_Table_Boolean1.\n+\n+2015-01-06  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_rm.texi: Improve documentation regarding No_Task_Termination.\n+\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Record_Aggregte, Get_Value): For an\n+\tothers choice that covers multiple components, analyze each\n+\tcopy with the type of the component even in compile-only mode,\n+\tto detect potential accessibility errors.\n+\n+2015-01-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_res.adb (Is_Assignment_Or_Object_Expression): New routine.\n+\t(Resolve_Actuals): An effectively volatile out\n+\tparameter cannot act as an in or in out actual in a call.\n+\t(Resolve_Entity_Name): An effectively volatile out parameter\n+\tcannot be read.\n+\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): If the body is\n+\tthe expansion of an expression function it may be pre-analyzed\n+\tif a 'access attribute is applied to the function, in which case\n+\tlast_entity may have been assigned already.\n+\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_One_Call): If formal has an incomplete\n+\ttype and actual has the corresponding full view, there is no\n+\terror, but a case of use of incomplete type in a predicate or\n+\tinvariant expression.\n+\n+2015-01-06  Vincent Celier  <celier@adacore.com>\n+\n+\t* makeutl.adb (Insert_No_Roots): Make sure that the same source\n+\tin two different project tree is checked in both trees, if they\n+\tare sources of two different projects, extended or not.\n+\n+2015-01-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb: Minor code clean up.\n+\t(Adjust_Global_Switches): Ignore gnatprove_mode in codepeer_mode.\n+\n+2015-01-06  Bob Duff  <duff@adacore.com>\n+\n+\t* osint.adb (Read_Source_File): Don't print out\n+\tfile name unless T = Source.\n+\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Is_Variable, Is_OK_Variable_For_Out_Formal):\n+\trecognize improper uses of constant_reference types as actuals\n+\tfor in-out parameters.\n+\t(Check_Function_Call): Do not collect identifiers if function\n+\tname is missing because of previous error.\n+\n 2015-01-06  Robert Dewar  <dewar@adacore.com>\n \n \t* ali-util.adb, sem_prag.adb, rtsfind.adb, sem_util.adb, sem_res.adb,"}, {"sha": "47acc6f668cc28e8c21d9ca1420e489b8719c61c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -2963,7 +2963,7 @@ package body Exp_Util is\n       --  If parser detected no address clause for the identifier in question,\n       --  then the answer is a quick NO, without the need for a search.\n \n-      if not Get_Name_Table_Boolean (Chars (Id)) then\n+      if not Get_Name_Table_Boolean1 (Chars (Id)) then\n          return Empty;\n       end if;\n "}, {"sha": "b4e74f4fcc01126e2f732d01a4611f9f645f972b", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -182,6 +182,11 @@ procedure Gnat1drv is\n \n       if CodePeer_Mode then\n \n+         --  Turn off gnatprove mode (if set via e.g. -gnatd.F), not compatible\n+         --  with CodePeer mode.\n+\n+         GNATprove_Mode := False;\n+\n          --  Turn off inlining, confuses CodePeer output and gains nothing\n \n          Front_End_Inlining := False;"}, {"sha": "b78bc51206ff201dad674532edb46a40505b101c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -10972,7 +10972,7 @@ directly on the environment task of the partition.\n @node No_Task_Termination\n @unnumberedsubsec No_Task_Termination\n @findex No_Task_Termination\n-[RM D.7] Tasks which terminate are erroneous.\n+[RM D.7] Tasks that terminate are erroneous.\n \n @node No_Tasking\n @unnumberedsubsec No_Tasking\n@@ -14315,6 +14315,16 @@ allocation.  See D.7(8).\n The only operation that implicitly requires heap storage allocation is\n task creation.\n \n+@sp 1\n+@item\n+@cartouche\n+@noindent\n+What happens when a task terminates in the presence of\n+pragma @code{No_Task_Termination}. See D.7(15).\n+@end cartouche\n+@noindent\n+Execution is erroneous in that case.\n+\n @sp 1\n @item\n @cartouche"}, {"sha": "5960d3e19d6aa786fe8a119e120286526f470902", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -2557,8 +2557,11 @@ package body Makeutl is\n             for J in 1 .. Q.Last loop\n                if Source.Id.Path.Name = Q.Table (J).Info.Id.Path.Name\n                  and then Source.Id.Index = Q.Table (J).Info.Id.Index\n-                 and then Source.Id.Project.Path.Name =\n-                            Q.Table (J).Info.Id.Project.Path.Name\n+                 and then\n+                   Ultimate_Extending_Project_Of (Source.Id.Project).Path.Name\n+                     =\n+                   Ultimate_Extending_Project_Of (Q.Table (J).Info.Id.Project).\n+                                                                     Path.Name\n                then\n                   --  No need to insert this source in the queue, but still\n                   --  return True as we may need to insert its roots."}, {"sha": "0eab3a1d85185d7e00d780717092c56f1b88b23e", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -705,15 +705,35 @@ package body Namet is\n       end loop;\n    end Get_Name_String_And_Append;\n \n-   ----------------------------\n-   -- Get_Name_Table_Boolean --\n-   ----------------------------\n+   -----------------------------\n+   -- Get_Name_Table_Boolean1 --\n+   -----------------------------\n+\n+   function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean is\n+   begin\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      return Name_Entries.Table (Id).Boolean1_Info;\n+   end Get_Name_Table_Boolean1;\n+\n+   -----------------------------\n+   -- Get_Name_Table_Boolean2 --\n+   -----------------------------\n+\n+   function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean is\n+   begin\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      return Name_Entries.Table (Id).Boolean2_Info;\n+   end Get_Name_Table_Boolean2;\n+\n+   -----------------------------\n+   -- Get_Name_Table_Boolean3 --\n+   -----------------------------\n \n-   function Get_Name_Table_Boolean (Id : Name_Id) return Boolean is\n+   function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean is\n    begin\n       pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n-      return Name_Entries.Table (Id).Boolean_Info;\n-   end Get_Name_Table_Boolean;\n+      return Name_Entries.Table (Id).Boolean3_Info;\n+   end Get_Name_Table_Boolean3;\n \n    -------------------------\n    -- Get_Name_Table_Byte --\n@@ -933,7 +953,9 @@ package body Namet is\n           Name_Len              => Short (Name_Len),\n           Byte_Info             => 0,\n           Int_Info              => 0,\n-          Boolean_Info          => False,\n+          Boolean1_Info         => False,\n+          Boolean2_Info         => False,\n+          Boolean3_Info         => False,\n           Name_Has_No_Encodings => False,\n           Hash_Link             => No_Name));\n \n@@ -1037,7 +1059,9 @@ package body Namet is\n              Name_Has_No_Encodings => False,\n              Int_Info              => 0,\n              Byte_Info             => 0,\n-             Boolean_Info          => False));\n+             Boolean1_Info         => False,\n+             Boolean2_Info         => False,\n+             Boolean3_Info         => False));\n \n          --  Set corresponding string entry in the Name_Chars table\n \n@@ -1262,7 +1286,9 @@ package body Namet is\n              Name_Len              => 1,\n              Byte_Info             => 0,\n              Int_Info              => 0,\n-             Boolean_Info          => False,\n+             Boolean1_Info         => False,\n+             Boolean2_Info         => False,\n+             Boolean3_Info         => False,\n              Name_Has_No_Encodings => True,\n              Hash_Link             => No_Name));\n \n@@ -1300,15 +1326,35 @@ package body Namet is\n       Store_Encoded_Character (C);\n    end Set_Character_Literal_Name;\n \n-   ----------------------------\n-   -- Set_Name_Table_Boolean --\n-   ----------------------------\n+   -----------------------------\n+   -- Set_Name_Table_Boolean1 --\n+   -----------------------------\n+\n+   procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean) is\n+   begin\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      Name_Entries.Table (Id).Boolean1_Info := Val;\n+   end Set_Name_Table_Boolean1;\n+\n+   -----------------------------\n+   -- Set_Name_Table_Boolean2 --\n+   -----------------------------\n+\n+   procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean) is\n+   begin\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      Name_Entries.Table (Id).Boolean2_Info := Val;\n+   end Set_Name_Table_Boolean2;\n+\n+   -----------------------------\n+   -- Set_Name_Table_Boolean3 --\n+   -----------------------------\n \n-   procedure Set_Name_Table_Boolean (Id : Name_Id; Val : Boolean) is\n+   procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean) is\n    begin\n       pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n-      Name_Entries.Table (Id).Boolean_Info := Val;\n-   end Set_Name_Table_Boolean;\n+      Name_Entries.Table (Id).Boolean3_Info := Val;\n+   end Set_Name_Table_Boolean3;\n \n    -------------------------\n    -- Set_Name_Table_Byte --"}, {"sha": "b4b68788dc536dcad03a500d744cef5c213c9362", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -115,7 +115,7 @@ package Namet is\n --  character lower case letters in the range a-z, and these names are created\n --  and initialized by the Initialize procedure.\n \n---  Three values, one of type Int, one of type Byte, and one of type Boolean,\n+--  Five values, one of type Int, one of type Byte, and three of type Boolean,\n --  are stored with each names table entry and subprograms are provided for\n --  setting and retrieving these associated values. The usage of these values\n --  is up to the client:\n@@ -128,9 +128,11 @@ package Namet is\n --      The Byte field is used to hold the Token_Type value for reserved words\n --      (see Sem for details).\n \n---      The Boolean field is used to mark address clauses to optimize the\n+--      The Boolean1 field is used to mark address clauses to optimize the\n --      performance of the Exp_Util.Following_Address_Clause function.\n \n+--      The Boolean2/Boolean3 fields are not used\n+\n --    In the binder, we have the following uses:\n \n --      The Int field is used in various ways depending on the name involved,\n@@ -367,8 +369,10 @@ package Namet is\n    pragma Inline (Get_Name_Table_Int);\n    --  Fetches the Int value associated with the given name\n \n-   function Get_Name_Table_Boolean (Id : Name_Id) return Boolean;\n-   --  Fetches the Boolean value associated with the given name\n+   function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean;\n+   function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean;\n+   --  Fetches the Boolean values associated with the given name\n \n    function Is_Operator_Name (Id : Name_Id) return Boolean;\n    --  Returns True if name given is of the form of an operator (that\n@@ -504,7 +508,9 @@ package Namet is\n    pragma Inline (Set_Name_Table_Byte);\n    --  Sets the Byte value associated with the given name\n \n-   procedure Set_Name_Table_Boolean (Id : Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean);\n    --  Sets the Boolean value associated with the given name\n \n    procedure Store_Encoded_Character (C : Char_Code);\n@@ -644,8 +650,10 @@ private\n       Byte_Info : Byte;\n       --  Byte value associated with this name\n \n-      Boolean_Info : Boolean;\n-      --  Boolean value associated with the name\n+      Boolean1_Info : Boolean;\n+      Boolean2_Info : Boolean;\n+      Boolean3_Info : Boolean;\n+      --  Boolean values associated with the name\n \n       Name_Has_No_Encodings : Boolean;\n       --  This flag is set True if the name entry is known not to contain any\n@@ -665,8 +673,10 @@ private\n       Name_Chars_Index      at  0 range 0 .. 31;\n       Name_Len              at  4 range 0 .. 15;\n       Byte_Info             at  6 range 0 .. 7;\n-      Boolean_Info          at  7 range 0 .. 0;\n-      Name_Has_No_Encodings at  7 range 1 .. 7;\n+      Boolean1_Info         at  7 range 0 .. 0;\n+      Boolean2_Info         at  7 range 1 .. 1;\n+      Boolean3_Info         at  7 range 2 .. 2;\n+      Name_Has_No_Encodings at  7 range 3 .. 7;\n       Hash_Link             at  8 range 0 .. 31;\n       Int_Info              at 12 range 0 .. 31;\n    end record;"}, {"sha": "f78a8ea8ffd7c65b090532aa58eabf8c3cda7adc", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -2642,31 +2642,33 @@ package body Osint is\n          return;\n       end if;\n \n-      --  Print out the file name, if requested, and if it's not part of the\n-      --  runtimes, store it in File_Name_Chars.\n+      --  If it's a Source file, print out the file name, if requested, and if\n+      --  it's not part of the runtimes, store it in File_Name_Chars. We don't\n+      --  want to print non-Source files, like GNAT-TEMP-000001.TMP used to\n+      --  pass information from gprbuild to gcc. We don't want to save runtime\n+      --  file names, because we don't want users to send them in bug reports.\n \n-      declare\n-         Name : String renames Name_Buffer (1 .. Name_Len);\n-         Inc  : String renames Include_Dir_Default_Prefix.all;\n-\n-      begin\n-         if Debug.Debug_Flag_Dot_N then\n-            Write_Line (Name);\n-         end if;\n+      if T = Source then\n+         declare\n+            Name : String renames Name_Buffer (1 .. Name_Len);\n+            Inc  : String renames Include_Dir_Default_Prefix.all;\n \n-         if Inc /= \"\"\n-           and then Inc'Length < Name_Len\n-           and then Name_Buffer (1 .. Inc'Length) = Inc\n-         then\n-            --  Part of runtimes, so ignore it\n+            Part_Of_Runtimes : constant Boolean :=\n+              Inc /= \"\"\n+                and then Inc'Length < Name_Len\n+                and then Name_Buffer (1 .. Inc'Length) = Inc;\n \n-            null;\n+         begin\n+            if Debug.Debug_Flag_Dot_N then\n+               Write_Line (Name);\n+            end if;\n \n-         else\n-            File_Name_Chars.Append_All (File_Name_Chars.Table_Type (Name));\n-            File_Name_Chars.Append (ASCII.LF);\n-         end if;\n-      end;\n+            if not Part_Of_Runtimes then\n+               File_Name_Chars.Append_All (File_Name_Chars.Table_Type (Name));\n+               File_Name_Chars.Append (ASCII.LF);\n+            end if;\n+         end;\n+      end if;\n \n       --  Prepare to read data from the file\n "}, {"sha": "5d4f7d2e03ca99cc89fb400703a089a3e2efdd4f", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -741,7 +741,7 @@ package body Ch13 is\n             if Attr_Name = Name_Address\n               and then Nkind (Prefix_Node) = N_Identifier\n             then\n-               Set_Name_Table_Boolean (Chars (Prefix_Node), True);\n+               Set_Name_Table_Boolean1 (Chars (Prefix_Node), True);\n             end if;\n          end loop;\n \n@@ -771,7 +771,7 @@ package body Ch13 is\n             --  Mark occurrence of address clause (used to optimize performance\n             --  of Exp_Util.Following_Address_Clause).\n \n-            Set_Name_Table_Boolean (Chars (Identifier_Node), True);\n+            Set_Name_Table_Boolean1 (Chars (Identifier_Node), True);\n \n          --  RECORD follows USE (Record Representation Clause)\n "}, {"sha": "f6c0bd7c5b58a6fb5077d384d97f33f82a126f39", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -3227,17 +3227,36 @@ package body Sem_Aggr is\n                         if Present (Others_Etype)\n                           and then Base_Type (Others_Etype) /= Base_Type (Typ)\n                         then\n-                           Error_Msg_N\n-                             (\"components in OTHERS choice must \"\n-                              & \"have same type\", Selector_Name);\n+                           --  If the components are of an anonymous access\n+                           --  type they are distinct, but this is legal in\n+                           --  Ada 2012 as long as designated types match.\n+\n+                           if (Ekind (Typ) = E_Anonymous_Access_Type\n+                                or else Ekind (Typ) =\n+                                            E_Anonymous_Access_Subprogram_Type)\n+                             and then Designated_Type (Typ) =\n+                                            Designated_Type (Others_Etype)\n+                           then\n+                              null;\n+                           else\n+                              Error_Msg_N\n+                                (\"components in OTHERS choice must \"\n+                                 & \"have same type\", Selector_Name);\n+                           end if;\n                         end if;\n \n                         Others_Etype := Typ;\n \n-                        if Expander_Active then\n+                        --  Copy expression so that it is resolved\n+                        --  independently for each component, This is needed\n+                        --  for accessibility checks on compoents of anonymous\n+                        --  access types, even in compile_only mode.\n+\n+                        if not Inside_A_Generic then\n                            return\n                              New_Copy_Tree_And_Copy_Dimensions\n                                (Expression (Assoc));\n+\n                         else\n                            return Expression (Assoc);\n                         end if;"}, {"sha": "8ddced82947f29f292f1b6df53691b01fb7fc060", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -3195,6 +3195,18 @@ package body Sem_Ch4 is\n                   Next_Actual (Actual);\n                   Next_Formal (Formal);\n \n+               --  For an Ada 2012 predicate or invariant, a call may mention\n+               --  an incomplete type, while resolution of the corresponding\n+               --  predicate function may see the full view, as a consequence\n+               --  of the delayed resolution of the corresponding expressions.\n+\n+               elsif Ekind (Etype (Formal)) = E_Incomplete_Type\n+                 and then Full_View (Etype (Formal)) = Etype (Actual)\n+               then\n+                  Set_Etype (Formal, Etype (Actual));\n+                  Next_Actual (Actual);\n+                  Next_Formal (Formal);\n+\n                else\n                   if Debug_Flag_E then\n                      Write_Str (\" type checking fails in call \");"}, {"sha": "89620797d2bee5b6028569ec7d80c054a89bdbe0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -3950,8 +3950,17 @@ package body Sem_Ch6 is\n          --  Case where there are no spec entities, in this case there can be\n          --  no body entities either, so just move everything.\n \n+         --  If the body is generated for an expression function, it may have\n+         --  been preanalyzed already, if 'access was applied to it.\n+\n          else\n-            pragma Assert (No (Last_Entity (Body_Id)));\n+            if Nkind (Original_Node (Unit_Declaration_Node (Spec_Id))) /=\n+                                                       N_Expression_Function\n+            then\n+               pragma Assert (No (Last_Entity (Body_Id)));\n+               null;\n+            end if;\n+\n             Set_First_Entity (Body_Id, First_Entity (Spec_Id));\n             Set_Last_Entity  (Body_Id, Last_Entity (Spec_Id));\n             Set_First_Entity (Spec_Id, Empty);"}, {"sha": "445ded40210e0d6d1defa74300df1dac15292aec", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 84, "deletions": 12, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -4250,14 +4250,25 @@ package body Sem_Res is\n                end if;\n \n                --  In Ada 83 we cannot pass an OUT parameter as an IN or IN OUT\n-               --  actual to a nested call, since this is case of reading an\n-               --  out parameter, which is not allowed.\n+               --  actual to a nested call, since this constitutes a reading of\n+               --  the parameter, which is not allowed.\n \n-               if Ada_Version = Ada_83\n-                 and then Is_Entity_Name (A)\n+               if Is_Entity_Name (A)\n                  and then Ekind (Entity (A)) = E_Out_Parameter\n                then\n-                  Error_Msg_N (\"(Ada 83) illegal reading of out parameter\", A);\n+                  if Ada_Version = Ada_83 then\n+                     Error_Msg_N\n+                       (\"(Ada 83) illegal reading of out parameter\", A);\n+\n+                  --  An effectively volatile OUT parameter cannot act as IN or\n+                  --  IN OUT actual in a call (SPARK RM 7.1.3(11)).\n+\n+                  elsif SPARK_Mode = On\n+                    and then Is_Effectively_Volatile (Entity (A))\n+                  then\n+                     Error_Msg_N\n+                       (\"illegal reading of volatile OUT parameter\", A);\n+                  end if;\n                end if;\n             end if;\n \n@@ -5444,8 +5455,8 @@ package body Sem_Res is\n                                          N_Unchecked_Type_Conversion)\n                then\n                   Error_Msg_N\n-                    (\"(Ada 83) fixed-point operation \"\n-                     & \"needs explicit conversion\", N);\n+                    (\"(Ada 83) fixed-point operation needs explicit \"\n+                     & \"conversion\", N);\n                end if;\n \n                --  The expected type is \"any real type\" in contexts like\n@@ -6886,13 +6897,61 @@ package body Sem_Res is\n    --  Used to resolve identifiers and expanded names\n \n    procedure Resolve_Entity_Name (N : Node_Id; Typ : Entity_Id) is\n+      function Is_Assignment_Or_Object_Expression\n+        (Context : Node_Id;\n+         Expr    : Node_Id) return Boolean;\n+      --  Determine whether node Context denotes an assignment statement or an\n+      --  object declaration whose expression is node Expr.\n+\n       function Is_OK_Volatile_Context\n         (Context : Node_Id;\n          Obj_Ref : Node_Id) return Boolean;\n       --  Determine whether node Context denotes a \"non-interfering context\"\n       --  (as defined in SPARK RM 7.1.3(13)) where volatile reference Obj_Ref\n       --  can safely reside.\n \n+      ----------------------------------------\n+      -- Is_Assignment_Or_Object_Expression --\n+      ----------------------------------------\n+\n+      function Is_Assignment_Or_Object_Expression\n+        (Context : Node_Id;\n+         Expr    : Node_Id) return Boolean\n+      is\n+      begin\n+         if Nkind_In (Context, N_Assignment_Statement,\n+                               N_Object_Declaration)\n+           and then Expression (Context) = Expr\n+         then\n+            return True;\n+\n+         --  Check whether a construct that yields a name is the expression of\n+         --  an assignment statement or an object declaration.\n+\n+         elsif (Nkind_In (Context, N_Attribute_Reference,\n+                                   N_Explicit_Dereference,\n+                                   N_Indexed_Component,\n+                                   N_Selected_Component,\n+                                   N_Slice)\n+                  and then Prefix (Context) = Expr)\n+           or else\n+               (Nkind_In (Context, N_Type_Conversion,\n+                                   N_Unchecked_Type_Conversion)\n+                  and then Expression (Context) = Expr)\n+         then\n+            return\n+              Is_Assignment_Or_Object_Expression\n+                (Context => Parent (Context),\n+                 Expr    => Context);\n+\n+         --  Otherwise the context is not an assignment statement or an object\n+         --  declaration.\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Assignment_Or_Object_Expression;\n+\n       ----------------------------\n       -- Is_OK_Volatile_Context --\n       ----------------------------\n@@ -6992,6 +7051,7 @@ package body Sem_Res is\n          --  in a non-interfering context.\n \n          elsif Nkind_In (Context, N_Attribute_Reference,\n+                                  N_Explicit_Dereference,\n                                   N_Indexed_Component,\n                                   N_Selected_Component,\n                                   N_Slice)\n@@ -7107,14 +7167,26 @@ package body Sem_Res is\n       elsif Ekind (E) = E_Generic_Function then\n          Error_Msg_N (\"illegal use of generic function\", N);\n \n+      --  In Ada 83 an OUT parameter cannot be read\n+\n       elsif Ekind (E) = E_Out_Parameter\n-        and then Ada_Version = Ada_83\n         and then (Nkind (Parent (N)) in N_Op\n-                   or else (Nkind (Parent (N)) = N_Assignment_Statement\n-                             and then N = Expression (Parent (N)))\n-                   or else Nkind (Parent (N)) = N_Explicit_Dereference)\n+                   or else Nkind (Parent (N)) = N_Explicit_Dereference\n+                   or else Is_Assignment_Or_Object_Expression\n+                             (Context => Parent (N),\n+                              Expr    => N))\n       then\n-         Error_Msg_N (\"(Ada 83) illegal reading of out parameter\", N);\n+         if Ada_Version = Ada_83 then\n+            Error_Msg_N (\"(Ada 83) illegal reading of out parameter\", N);\n+\n+         --  An effectively volatile OUT parameter cannot be read\n+         --  (SPARK RM 7.1.3(11)).\n+\n+         elsif SPARK_Mode = On\n+           and then Is_Effectively_Volatile (E)\n+         then\n+            Error_Msg_N (\"illegal reading of volatile OUT parameter\", N);\n+         end if;\n \n       --  In all other cases, just do the possible static evaluation\n "}, {"sha": "a93139e3d1aa4cd43f47dade55dcbae197c6ee2d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a921e83c12b6b3ea5027113af94c2b105533ba14/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a921e83c12b6b3ea5027113af94c2b105533ba14", "patch": "@@ -2133,6 +2133,12 @@ package body Sem_Util is\n                   begin\n                      Id := Get_Function_Id (Call);\n \n+                     --  In case of previous error, no check is posible.\n+\n+                     if No (Id) then\n+                        return Abandon;\n+                     end if;\n+\n                      Formal := First_Formal (Id);\n                      Actual := First_Actual (Call);\n                      while Present (Actual) and then Present (Formal) loop\n@@ -11621,6 +11627,18 @@ package body Sem_Util is\n       elsif Is_Variable (AV) then\n          return True;\n \n+      --  Generalized indexing operations are rewritten as explicit\n+      --  dereferences, and it is only during resolution that we can\n+      --  check whether the context requires an access_to_variable type.\n+\n+      elsif Nkind (AV) = N_Explicit_Dereference\n+        and then Ada_Version >= Ada_2012\n+        and then Nkind (Original_Node (AV)) = N_Indexed_Component\n+        and then Present (Etype (Original_Node (AV)))\n+        and then Has_Implicit_Dereference (Etype (Original_Node (AV)))\n+      then\n+         return not Is_Access_Constant (Etype (Prefix (AV)));\n+\n       --  Unchecked conversions are allowed only if they come from the\n       --  generated code, which sometimes uses unchecked conversions for out\n       --  parameters in cases where code generation is unaffected. We tell\n@@ -12857,9 +12875,8 @@ package body Sem_Util is\n         and then Present (Etype (Orig_Node))\n         and then Ada_Version >= Ada_2012\n         and then Has_Implicit_Dereference (Etype (Orig_Node))\n-        and then not Is_Access_Constant (Etype (Prefix (N)))\n       then\n-         return True;\n+         return not Is_Access_Constant (Etype (Prefix (N)));\n \n       --  A function call is never a variable\n "}]}