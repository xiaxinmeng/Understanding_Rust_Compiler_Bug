{"sha": "25a6a8731ca102e1995fe996722a0637b1311445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVhNmE4NzMxY2ExMDJlMTk5NWZlOTk2NzIyYTA2MzdiMTMxMTQ0NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-15T13:16:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-15T13:16:44Z"}, "message": "tree-ssa-structalias.c (struct variable_info): Add is_fn_info flag.\n\n2010-04-15  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (struct variable_info): Add\n\tis_fn_info flag.\n\t(new_var_info): Initialize it.\n\t(dump_constraints): Support printing last added constraints.\n\t(debug_constraints): Adjust.\n\t(dump_constraint_graph): Likewise.\n\t(make_heapvar_for): Check for NULL cfun.\n\t(get_function_part_constraint): New function.\n\t(get_fi_for_callee): Likewise.\n\t(find_func_aliases): Properly implement IPA PTA constraints.\n\t(process_ipa_clobber): New function.\n\t(find_func_clobbers): Likewise.\n\t(insert_into_field_list_sorted): Remove.\n\t(create_function_info_for): Properly allocate vars for IPA mode.\n\tDo not use insert_into_field_list_sorted.\n\t(create_variable_info_for): Properly generate constraints for\n\tglobal vars in IPA mode.\n\t(dump_solution_for_var): Always dump the solution.\n\t(set_uids_in_ptset): Initialize DECL_PT_UID if in ipa-mode.\n\t(find_what_var_points_to): Adjust.\n\t(pt_solution_set): Change.\n\t(pt_solution_ior_into): New function.\n\t(pt_solution_empty_p): Export.\n\t(pt_solution_includes_global): Adjust.\n\t(pt_solution_includes_1): Likewise.\n\t(pt_solutions_intersect_1): Likewise.\n\t(dump_sa_points_to_info): Check some invariants.\n\t(solve_constraints): Move constraint dumping ...\n\t(compute_points_to_sets): ... here.\n\t(ipa_pta_execute): ... and here.\n\t(compute_may_aliases): Do not re-compute points-to info\n\tlocally if IPA info is available.\n\t(ipa_escaped_pt): New global var.\n\t(ipa_pta_execute): Properly implement IPA PTA.\n\t* tree-into-ssa.c (dump_decl_set): Support dumping\n\tdecls not in referenced-vars.\n\t* tree-flow.h (struct gimple_df): Add ipa_pta flag.\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Adjust.\n\t(dump_points_to_solution): Likewise.\n\t* tree-dfa.c (dump_variable): Also dump DECL_PT_UID.\n\t* tree-inline.c (remap_ssa_name): Copy IPA points-to solution.\n\t(remap_gimple_stmt): Reset call clobber/use information if\n\tnecessary.\n\t(copy_decl_to_var): Copy DECL_PT_UID.\n\t(copy_result_decl_to_var): Likewise.\n\t* tree.c (make_node_stat): Initialize DECL_PT_UID.\n\t(copy_node_stat): Copy it.\n\t* tree.h (DECL_PT_UID): New macro.\n\t(SET_DECL_PT_UID): Likewise.\n\t(DECL_PT_UID_SET_P): Likewise.\n\t(struct tree_decl_minimal): Add pt_uid member.\n\t* tree-ssa-alias.h (struct pt_solution): Add ipa_escaped flag.\n\t(pt_solution_empty_p): Declare.\n\t(pt_solution_set): Adjust.\n\t(ipa_escaped_pt): Declare.\n\t* cfgexpand.c (update_alias_info_with_stack_vars): Adjust.\n\t* gimple-pretty-print.c (pp_points_to_solution): New function.\n\t(dump_gimple_call): Dump call clobber/use information.\n\t* tree-dump.c (dump_option_value_in): Add TDF_ALIAS entry.\n\t* tree-pass.h (TDF_ALIAS): New dump option.\n\t* tree-pretty-print.c (dump_decl_name): Dump DECL_PT_UID if asked to.\n\t* doc/invoke.texi (-fipa-pta): Update documentation.\n\n\t* gcc.dg/ipa/ipa-pta-1.c: New testcase.\n\t* gcc.dg/ipa/ipa-pta-2.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-3.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-4.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-5.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-6.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-7.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-8.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-9.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-10.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-11.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-12.c: Likewise.\n\t* gcc.dg/ipa/ipa-pta-13.c: Likewise.\n\t* gcc.dg/torture/ipa-pta-2.c: Likewise.\n\t* gcc.dg/torture/ipa-pta-1.c: Adjust.\n\nFrom-SVN: r158374", "tree": {"sha": "381556e2947cff452ab7c67fc87d183b8ec9da09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381556e2947cff452ab7c67fc87d183b8ec9da09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25a6a8731ca102e1995fe996722a0637b1311445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25a6a8731ca102e1995fe996722a0637b1311445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25a6a8731ca102e1995fe996722a0637b1311445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25a6a8731ca102e1995fe996722a0637b1311445/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbdd87d44471ec0b9099dd8d6e32ae09039a1b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbdd87d44471ec0b9099dd8d6e32ae09039a1b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbdd87d44471ec0b9099dd8d6e32ae09039a1b48"}], "stats": {"total": 1935, "additions": 1755, "deletions": 180}, "files": [{"sha": "b1865d5be9a071a541efa4804dc277e2d3bff543", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -1,3 +1,68 @@\n+2010-04-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Add\n+\tis_fn_info flag.\n+\t(new_var_info): Initialize it.\n+\t(dump_constraints): Support printing last added constraints.\n+\t(debug_constraints): Adjust.\n+\t(dump_constraint_graph): Likewise.\n+\t(make_heapvar_for): Check for NULL cfun.\n+\t(get_function_part_constraint): New function.\n+\t(get_fi_for_callee): Likewise.\n+\t(find_func_aliases): Properly implement IPA PTA constraints.\n+\t(process_ipa_clobber): New function.\n+\t(find_func_clobbers): Likewise.\n+\t(insert_into_field_list_sorted): Remove.\n+\t(create_function_info_for): Properly allocate vars for IPA mode.\n+\tDo not use insert_into_field_list_sorted.\n+\t(create_variable_info_for): Properly generate constraints for\n+\tglobal vars in IPA mode.\n+\t(dump_solution_for_var): Always dump the solution.\n+\t(set_uids_in_ptset): Initialize DECL_PT_UID if in ipa-mode.\n+\t(find_what_var_points_to): Adjust.\n+\t(pt_solution_set): Change.\n+\t(pt_solution_ior_into): New function.\n+\t(pt_solution_empty_p): Export.\n+\t(pt_solution_includes_global): Adjust.\n+\t(pt_solution_includes_1): Likewise.\n+\t(pt_solutions_intersect_1): Likewise.\n+\t(dump_sa_points_to_info): Check some invariants.\n+\t(solve_constraints): Move constraint dumping ...\n+\t(compute_points_to_sets): ... here.\n+\t(ipa_pta_execute): ... and here.\n+\t(compute_may_aliases): Do not re-compute points-to info\n+\tlocally if IPA info is available.\n+\t(ipa_escaped_pt): New global var.\n+\t(ipa_pta_execute): Properly implement IPA PTA.\n+\t* tree-into-ssa.c (dump_decl_set): Support dumping\n+\tdecls not in referenced-vars.\n+\t* tree-flow.h (struct gimple_df): Add ipa_pta flag.\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Adjust.\n+\t(dump_points_to_solution): Likewise.\n+\t* tree-dfa.c (dump_variable): Also dump DECL_PT_UID.\n+\t* tree-inline.c (remap_ssa_name): Copy IPA points-to solution.\n+\t(remap_gimple_stmt): Reset call clobber/use information if\n+\tnecessary.\n+\t(copy_decl_to_var): Copy DECL_PT_UID.\n+\t(copy_result_decl_to_var): Likewise.\n+\t* tree.c (make_node_stat): Initialize DECL_PT_UID.\n+\t(copy_node_stat): Copy it.\n+\t* tree.h (DECL_PT_UID): New macro.\n+\t(SET_DECL_PT_UID): Likewise.\n+\t(DECL_PT_UID_SET_P): Likewise.\n+\t(struct tree_decl_minimal): Add pt_uid member.\n+\t* tree-ssa-alias.h (struct pt_solution): Add ipa_escaped flag.\n+\t(pt_solution_empty_p): Declare.\n+\t(pt_solution_set): Adjust.\n+\t(ipa_escaped_pt): Declare.\n+\t* cfgexpand.c (update_alias_info_with_stack_vars): Adjust.\n+\t* gimple-pretty-print.c (pp_points_to_solution): New function.\n+\t(dump_gimple_call): Dump call clobber/use information.\n+\t* tree-dump.c (dump_option_value_in): Add TDF_ALIAS entry.\n+\t* tree-pass.h (TDF_ALIAS): New dump option.\n+\t* tree-pretty-print.c (dump_decl_name): Dump DECL_PT_UID if asked to.\n+\t* doc/invoke.texi (-fipa-pta): Update documentation.\n+\n 2010-04-15  Richard Guenther  <rguenther@suse.de>\n \n \t* Makefile.in (OBJS-common): Add gimple-fold.o."}, {"sha": "48173d9b992b4e795cc83c1157d41a272f27f7e9", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -500,12 +500,12 @@ update_alias_info_with_stack_vars (void)\n       for (j = i; j != EOC; j = stack_vars[j].next)\n \t{\n \t  tree decl = stack_vars[j].decl;\n-\t  unsigned int uid = DECL_UID (decl);\n+\t  unsigned int uid = DECL_PT_UID (decl);\n \t  /* We should never end up partitioning SSA names (though they\n \t     may end up on the stack).  Neither should we allocate stack\n \t     space to something that is unused and thus unreferenced.  */\n \t  gcc_assert (DECL_P (decl)\n-\t\t      && referenced_var_lookup (uid));\n+\t\t      && referenced_var_lookup (DECL_UID (decl)));\n \t  bitmap_set_bit (part, uid);\n \t  *((bitmap *) pointer_map_insert (decls_to_partitions,\n \t\t\t\t\t   (void *)(size_t) uid)) = part;\n@@ -515,7 +515,7 @@ update_alias_info_with_stack_vars (void)\n \n       /* Make the SSA name point to all partition members.  */\n       pi = get_ptr_info (name);\n-      pt_solution_set (&pi->pt, part);\n+      pt_solution_set (&pi->pt, part, false, false);\n     }\n \n   /* Make all points-to sets that contain one member of a partition"}, {"sha": "ad8eff8a983fb8af005dafc84bbb74d33c74e797", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -6577,8 +6577,10 @@ With this flag, the program debug info reflects a new structure layout.\n \n @item -fipa-pta\n @opindex fipa-pta\n-Perform interprocedural pointer analysis.  This option is experimental\n-and does not affect generated code.\n+Perform interprocedural pointer analysis and interprocedural modification\n+and reference analysis.  This option can cause excessive memory and\n+compile-time usage on large compilation units.  It is not enabled by\n+default at any optimization level.\n \n @item -fipa-cp\n @opindex fipa-cp"}, {"sha": "0f386163ab3ebdc56010c3bd219f8224e3e511f5", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -477,6 +477,60 @@ dump_gimple_call_args (pretty_printer *buffer, gimple gs, int flags)\n     }\n }\n \n+/* Dump the points-to solution *PT to BUFFER.  */\n+\n+static void\n+pp_points_to_solution (pretty_printer *buffer, struct pt_solution *pt)\n+{\n+  if (pt->anything)\n+    {\n+      pp_string (buffer, \"anything \");\n+      return;\n+    }\n+  if (pt->nonlocal)\n+    pp_string (buffer, \"nonlocal \");\n+  if (pt->escaped)\n+    pp_string (buffer, \"escaped \");\n+  if (pt->ipa_escaped)\n+    pp_string (buffer, \"unit-escaped \");\n+  if (pt->null)\n+    pp_string (buffer, \"null \");\n+  if (pt->vars\n+      && !bitmap_empty_p (pt->vars))\n+    {\n+      bitmap_iterator bi;\n+      unsigned i;\n+      pp_string (buffer, \"{ \");\n+      EXECUTE_IF_SET_IN_BITMAP (pt->vars, 0, i, bi)\n+\t{\n+\t  struct tree_decl_minimal in;\n+\t  tree var;\n+\t  in.uid = i;\n+\t  var = (tree) htab_find_with_hash (gimple_referenced_vars (cfun),\n+\t\t\t\t\t    &in, i);\n+\t  if (var)\n+\t    {\n+\t      dump_generic_node (buffer, var, 0, dump_flags, false);\n+\t      if (DECL_PT_UID (var) != DECL_UID (var))\n+\t\t{\n+\t\t  pp_string (buffer, \"ptD.\");\n+\t\t  pp_decimal_int (buffer, DECL_PT_UID (var));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      pp_string (buffer, \"D.\");\n+\t      pp_decimal_int (buffer, i);\n+\t    }\n+\t  pp_character (buffer, ' ');\n+\t}\n+      pp_character (buffer, '}');\n+      if (pt->vars_contains_global)\n+\tpp_string (buffer, \" (glob)\");\n+      if (pt->vars_contains_restrict)\n+\tpp_string (buffer, \" (restr)\");\n+    }\n+}\n \n /* Dump the call statement GS.  BUFFER, SPC and FLAGS are as in\n    dump_gimple_stmt.  */\n@@ -486,6 +540,25 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n   tree lhs = gimple_call_lhs (gs);\n \n+  if (flags & TDF_ALIAS)\n+    {\n+      struct pt_solution *pt;\n+      pt = gimple_call_use_set (gs);\n+      if (!pt_solution_empty_p (pt))\n+\t{\n+\t  pp_string (buffer, \"# USE = \");\n+\t  pp_points_to_solution (buffer, pt);\n+\t  newline_and_indent (buffer, spc);\n+\t}\n+      pt = gimple_call_clobber_set (gs);\n+      if (!pt_solution_empty_p (pt))\n+\t{\n+\t  pp_string (buffer, \"# CLB = \");\n+\t  pp_points_to_solution (buffer, pt);\n+\t  newline_and_indent (buffer, spc);\n+\t}\n+    }\n+\n   if (flags & TDF_RAW)\n     {\n       dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T\","}, {"sha": "c022447779f719237127aec6b73d75204d9781e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -1,3 +1,21 @@\n+2010-04-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/ipa/ipa-pta-1.c: New testcase.\n+\t* gcc.dg/ipa/ipa-pta-2.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-3.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-4.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-5.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-6.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-7.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-8.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-9.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-10.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-11.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-12.c: Likewise.\n+\t* gcc.dg/ipa/ipa-pta-13.c: Likewise.\n+\t* gcc.dg/torture/ipa-pta-2.c: Likewise.\n+\t* gcc.dg/torture/ipa-pta-1.c: Adjust.\n+\n 2010-04-14  Bernd Schmidt  <bernd.schmidt@codesourcery.com>\n \n \tPR target/21803"}, {"sha": "a56e71a4adebc00354c1a20ce81a0edf7eae2b9b", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-1.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -fipa-pta -fdump-ipa-pta-details\" } */\n+\n+static int __attribute__((noinline))\n+foo (int *p, int *q)\n+{\n+  *p = 2;\n+  *q = 1;\n+  return *p;\n+}\n+\n+static int __attribute__((noinline))\n+bar (int *p, int *q)\n+{\n+  *p = -2;\n+  *q = -1;\n+  return *p;\n+}\n+\n+static int __attribute__((noinline,noclone))\n+foobar (int foo_p)\n+{\n+  int a;\n+  int (*fn)(int *, int *);\n+  if (foo_p)\n+    fn = foo;\n+  else\n+    fn = bar;\n+  return (*fn)(&a, &a);\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foobar (1) != 1)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* IPA PTA needs to handle indirect calls properly.  Verify that\n+   both bar and foo get a (and only a) in their arguments points-to sets.  */\n+\n+/* { dg-final { scan-ipa-dump \"fn_1 = { bar foo }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"bar.arg0 = { a }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"bar.arg1 = { a }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"foo.arg0 = { a }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"foo.arg1 = { a }\" \"pta\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "2dc6eae25d25c60eb15d4031324c435b46c9a032", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-10.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-10.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-pta -fdump-ipa-pta-details\" } */\n+\n+#include <stdarg.h>\n+\n+static void __attribute__((noinline,noclone))\n+foo (int i, ...)\n+{\n+  va_list ap;\n+  int *p;\n+  va_start (ap, i);\n+  p = va_arg (ap, int *);\n+  *p = 1;\n+  va_end (ap);\n+}\n+extern void abort (void);\n+int main()\n+{\n+  int i = 0;\n+  foo (0, &i);\n+  if (i != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* Verify we properly handle variadic arguments and do not let escape\n+   stuff through it.  */\n+\n+/* { dg-final { scan-ipa-dump \"ESCAPED = { }\" \"pta\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "947ab816fc9e6e9d78599b59fc05a9e868b29c19", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-11.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-11.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fipa-pta -fdump-ipa-pta-details\" } */\n+\n+static int i;\n+/* i should not escape here, p should point to i only.  */\n+/* { dg-final { scan-ipa-dump \"p = { i }\" \"pta\" } } */\n+static int *p = &i;\n+\n+int j;\n+/* q should point to j only.  */\n+/* { dg-final { scan-ipa-dump \"q = { j }\" \"pta\" } } */\n+static int *q = &j;\n+\n+static int k;\n+/* k should escape here, r should point to NONLOCAL, ESCAPED, k.  */\n+int *r = &k;\n+/* { dg-final { scan-ipa-dump \"r = { ESCAPED NONLOCAL k }\" \"pta\" } } */\n+\n+int l;\n+/* s should point to NONLOCAL, ESCAPED, l.  */\n+int *s = &l;\n+/* { dg-final { scan-ipa-dump \"s = { ESCAPED NONLOCAL l }\" \"pta\" } } */\n+\n+int main()\n+{\n+  return 0;\n+}\n+\n+/* It isn't clear if the escape if l is strictly necessary, if it were\n+   we should have i, r and s in ESCAPED as well.  */\n+\n+/* { dg-final { scan-ipa-dump \"ESCAPED = { ESCAPED NONLOCAL l k }\" \"pta\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "1c773eed027dd6aac73577d0268ddff06a9bcce6", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-12.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-12.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,34 @@\n+static int i, j;\n+\n+static void __attribute__((noinline,noclone))\n+foo (void) { i = 1; }\n+\n+static void __attribute__((noinline,noclone))\n+bar (void) { j = 1; }\n+\n+typedef void (*fn_t)(void);\n+void escapeme (fn_t);\n+fn_t getme (void);\n+\n+extern void link_error (void);\n+\n+int main()\n+{\n+  fn_t fn;\n+  escapeme (foo);\n+  fn = getme();\n+\n+  i = 0;\n+  fn();\n+  if (i != 1)\n+    return 100;\n+  j = 0;\n+  fn();\n+  if (j != 0)\n+    link_error ();\n+  bar();\n+  if (j != 1)\n+    return 200;\n+\n+  return 0;\n+}"}, {"sha": "8c2c8b6183f2a59f635ac5ebf9d0eb57f4b9eb44", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-13.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-13.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fipa-pta -fdump-ipa-pta-details -fdump-tree-fre\" } */\n+\n+static int x, y;\n+\n+static __attribute__((noinline,noclone)) void\n+local (int *p)\n+{\n+  *p = 1;\n+}\n+\n+static __attribute__((noinline,noclone)) void\n+local_address_taken (int *p)\n+{\n+  *p = 1;\n+}\n+\n+/* Even though not referenced in this TU we should have added constraints\n+   for the initializer.  */\n+/* { dg-final { scan-ipa-dump \"ex = &local_address_taken\" \"pta\" } } */\n+void (*ex)(int *) = local_address_taken;\n+\n+extern void link_error (void);\n+\n+int main()\n+{\n+  void (*anyfn)(int *) = (void (*)(int *))(__SIZE_TYPE__)x;\n+  /* The following should cause local_address_taken to get &x\n+     as argument, but not local.  We shouldn't get &x added to\n+     arbitrary special sub-vars of local_address_taken though,\n+     a missed optimization currently.\n+     As local_address_taken escapes the translation unit its\n+     argument points-to set needs to include ESCAPED and NONLOCAL.\n+     We shouldn't get the functions sub-vars in the ESCAPED solution\n+     though, another missed-optimization.  This also causes the functions\n+     uses to be messed up even further.  */\n+  /* { dg-final { scan-ipa-dump \"local_address_taken.arg0 = { ESCAPED NONLOCAL y x }\" \"pta\" } } */\n+  /* { dg-final { scan-ipa-dump \"local_address_taken.clobber = { ESCAPED NONLOCAL y x }\" \"pta\" } } */\n+  /* { dg-final { scan-ipa-dump \"local_address_taken.use = { }\" \"pta\" { xfail *-*-* } } } */\n+  (*anyfn) (&x);\n+  x = 0;\n+  local (&y);\n+  /* Thus we should be able to disambiguate x against the call to local\n+     and CSE the stored value.  */\n+  if (x != 0)\n+    link_error ();\n+  x = 1;\n+  local_address_taken (&y);\n+  /* As we are computing flow- and context-insensitive we may not\n+     CSE the load of x here.  */\n+  /* { dg-final { scan-tree-dump \" = x;\" \"fre\" } } */\n+  return x;\n+}\n+\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "a6c7e4b4786c349218496399702e9c24ab95bcda", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-2.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fipa-pta -fdump-ipa-pta-details\" } */\n+\n+int (*fn)(int *);\n+\n+static int __attribute__((noinline,noclone))\n+foo (int *p)\n+{\n+  return *p;\n+}\n+\n+extern void bar (void);\n+\n+int main()\n+{\n+  fn = foo;\n+  bar ();\n+  return 0;\n+}\n+\n+/* Make sure that when a local function escapes its argument points-to sets\n+   are properly adjusted.  */\n+\n+/* { dg-final { scan-ipa-dump \"foo.arg0 = { ESCAPED NONLOCAL }\" \"pta\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "e73db1c95ac37c6c93c4c23bf3e533fc0f46d68e", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-3.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-pta -fdump-ipa-pta-details -fdump-tree-fre-details\" } */\n+\n+static int __attribute__((noinline,noclone))\n+foo (int *p, int *q)\n+{\n+  *p = 1;\n+  *q = 0;\n+  return *p;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  int a, b;\n+  if (foo (&a, &b) != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* Verify we can disambiguate *p and *q in foo.  */\n+\n+/* { dg-final { scan-ipa-dump \"foo.arg0 = &a\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"foo.arg1 = &b\" \"pta\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\*p_1\\\\\\(D\\\\\\) with 1\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "d2b901cf910967b073d82742a21416a77f937ead", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-4.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-4.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-pta -fdump-ipa-pta-details -fdump-tree-fre-details\" } */\n+\n+int a, b;\n+\n+static int __attribute__((noinline,noclone))\n+foo (int *p, int *q)\n+{\n+  int res;\n+  *p = 1;\n+  *q = 0;\n+  res = *p;\n+  a = 1;\n+  b = 1;\n+  return res;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foo (&a, &b) != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* Verify we can disambiguate *p and *q in foo.  */\n+\n+/* { dg-final { scan-ipa-dump \"foo.arg0 = &a\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"foo.arg1 = &b\" \"pta\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\*p_1\\\\\\(D\\\\\\) with 1\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "3359c534aaba54e5c87db61db71c1e7fcc297bd1", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-5.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-pta -fdump-ipa-pta-details\" } */\n+\n+int **x;\n+\n+static int __attribute__((noinline,noclone))\n+foo (int **q)\n+{\n+  int a = 1;\n+  **q = 0;\n+  *x = &a;\n+  return **q;\n+}\n+\n+extern void abort (void);\n+int main()\n+{\n+  int b;\n+  int *p = &b;\n+  x = &p;\n+  if (foo (&p) != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "aaa6090ddd7225b61e1bbbe3c3fa774285dcc6f2", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-6.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-6.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -fipa-pta -fdump-ipa-pta-details\" } */\n+\n+static void __attribute__((noinline,noclone))\n+foo (int *p)\n+{\n+  *p = 1;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  int i = 0;\n+  foo (&i);\n+  if (i != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* Verify we correctly compute the units ESCAPED set as empty but\n+   still properly account for the store via *p in foo.  */\n+\n+/* { dg-final { scan-ipa-dump \"ESCAPED = { }\" \"pta\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "3cdfd63fa3e305e25185171f8ec153f97a5e7c99", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-7.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-7.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-early-inlining -fipa-pta\" } */\n+\n+static void __attribute__((noinline,noclone))\n+clobber_me (int *p, int how)\n+{\n+  *p = how;\n+}\n+\n+/* When foo is inlined into main we have to make sure to adjust\n+   main()s IPA CLOBBERED set according to the decl remappings\n+   inlining does.  */\n+\n+static int\n+foo (void)\n+{\n+  int a = 0;\n+  clobber_me (&a, 1);\n+  return a;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foo () != 1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "5bedc9d8a6550df8f772982c012a0ba5351f120b", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-8.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-8.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-early-inlining -fipa-pta\" } */\n+\n+static int *__attribute__((noinline,noclone))\n+pass_me (int *p)\n+{\n+  return p;\n+}\n+\n+/* When foo is inlined into main we have to make sure to adjust\n+   main()s IPA CLOBBERED set according to the decl remappings\n+   inlining does.  */\n+\n+static int\n+foo (void)\n+{\n+  int a = 0;\n+  int *p = pass_me (&a);\n+  *p = 1;\n+  return a;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foo () != 1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1a98da3978ec145d8b83b9df9ac73f5e20b8d3f2", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-9.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-9.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fipa-pta\" } */\n+\n+static void __attribute__((noinline,noclone))\n+foo (int *p, int *q)\n+{\n+  __builtin_memcpy (p, q, sizeof (int));\n+}\n+extern void abort (void);\n+int main()\n+{\n+  int i = 0, j = 1;\n+  foo (&i, &j);\n+  if (i != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "6d0d032613f66f6cb48d5803609c415599d3d944", "filename": "gcc/testsuite/gcc.dg/torture/ipa-pta-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-1.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -42,5 +42,5 @@ void test4 (int a4, char b, char c, char d, char e, char f, char g, char h)\n   bar (p);\n }\n \n-/* { dg-final { scan-ipa-dump \"bar.arg0 = { a4 a3 a2 a1 }\" \"pta\" } } */\n+/* { dg-final { scan-ipa-dump \"bar.arg0 = { test4.arg0 test3.arg0 test2.arg0 test1.arg0 }\" \"pta\" } } */\n /* { dg-final { cleanup-ipa-dump \"pta\" } } */"}, {"sha": "768c99e823ea73d71b82c68029c3a08b11136b09", "filename": "gcc/testsuite/gcc.dg/torture/ipa-pta-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fipa-pta-2.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fipa-pta\" } */\n+\n+int **x;\n+\n+static int __attribute__((noinline,noclone))\n+foo (int **p)\n+{\n+  int a = 1;\n+  **p = 0;\n+  *x = &a;\n+  return **p;\n+}\n+\n+extern void abort (void);\n+int main()\n+{\n+  int b;\n+  int *p = &b;\n+  x = &p;\n+  if (foo (&p) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "a8415b5a825ef279cd32debab7b31d7864fa8459", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -269,6 +269,8 @@ dump_variable (FILE *file, tree var)\n   ann = var_ann (var);\n \n   fprintf (file, \", UID D.%u\", (unsigned) DECL_UID (var));\n+  if (DECL_PT_UID (var) != DECL_UID (var))\n+    fprintf (file, \", PT-UID D.%u\", (unsigned) DECL_PT_UID (var));\n \n   fprintf (file, \", \");\n   print_generic_expr (file, TREE_TYPE (var), dump_flags);"}, {"sha": "5467e28b5e8693f964f144c336e786f10c840c2c", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -821,6 +821,7 @@ static const struct dump_option_value_info dump_options[] =\n   {\"memsyms\", TDF_MEMSYMS},\n   {\"verbose\", TDF_VERBOSE},\n   {\"eh\", TDF_EH},\n+  {\"alias\", TDF_ALIAS},\n   {\"nouid\", TDF_NOUID},\n   {\"all\", ~(TDF_RAW | TDF_SLIM | TDF_LINENO | TDF_TREE | TDF_RTL | TDF_IPA\n \t    | TDF_STMTADDR | TDF_GRAPH | TDF_DIAGNOSTIC | TDF_VERBOSE"}, {"sha": "fda7a86f2d03905bb97b5da38af920b4ecacde94", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -76,6 +76,9 @@ struct GTY(()) gimple_df {\n   /* True if the code is in ssa form.  */\n   unsigned int in_ssa_p : 1;\n \n+  /* True if IPA points-to information was computed for this function.  */\n+  unsigned int ipa_pta : 1;\n+\n   struct ssa_operands ssa_operands;\n };\n \n@@ -111,9 +114,10 @@ typedef struct\n ---------------------------------------------------------------------------*/\n \n /* Aliasing information for SSA_NAMEs representing pointer variables.  */\n+\n struct GTY(()) ptr_info_def\n {\n-  /* The points-to solution, TBAA-pruned if the pointer is dereferenced.  */\n+  /* The points-to solution.  */\n   struct pt_solution pt;\n };\n "}, {"sha": "b564fa58a74acd76376a5d59bbac167961a3a9ac", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -211,11 +211,21 @@ remap_ssa_name (tree name, copy_body_data *id)\n       && (TREE_CODE (SSA_NAME_VAR (name)) != RESULT_DECL\n \t  || !id->transform_return_to_modify))\n     {\n+      struct ptr_info_def *pi;\n       new_tree = make_ssa_name (new_tree, NULL);\n       insert_decl_map (id, name, new_tree);\n       SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_tree)\n \t= SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name);\n       TREE_TYPE (new_tree) = TREE_TYPE (SSA_NAME_VAR (new_tree));\n+      /* At least IPA points-to info can be directly transferred.  */\n+      if (id->src_cfun->gimple_df\n+\t  && id->src_cfun->gimple_df->ipa_pta\n+\t  && (pi = SSA_NAME_PTR_INFO (name))\n+\t  && !pi->pt.anything)\n+\t{\n+\t  struct ptr_info_def *new_pi = get_ptr_info (new_tree);\n+\t  new_pi->pt = pi->pt;\n+\t}\n       if (gimple_nop_p (SSA_NAME_DEF_STMT (name)))\n \t{\n \t  /* By inlining function having uninitialized variable, we might\n@@ -1392,12 +1402,11 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t\t    break;\n \t\t  }\n \n-\t      /* Reset alias info.\n-\t         ???  By maintaining DECL_PT_UID this should not\n-\t\t be necessary, but the plan is to only maintain\n-\t\t it when IPA-PTA was run.  It's not too easy to\n-\t\t detect this here ...  */\n-\t      gimple_call_reset_alias_info (copy);\n+\t      /* Reset alias info if we didn't apply measures to\n+\t\t keep it valid over inlining by setting DECL_PT_UID.  */\n+\t      if (!id->src_cfun->gimple_df\n+\t\t  || !id->src_cfun->gimple_df->ipa_pta)\n+\t\tgimple_call_reset_alias_info (copy);\n \t    }\n \t    break;\n \n@@ -4516,6 +4525,8 @@ copy_decl_to_var (tree decl, copy_body_data *id)\n \n   copy = build_decl (DECL_SOURCE_LOCATION (id->dst_fn),\n \t\t     VAR_DECL, DECL_NAME (decl), type);\n+  if (DECL_PT_UID_SET_P (decl))\n+    SET_DECL_PT_UID (copy, DECL_PT_UID (decl));\n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n@@ -4541,6 +4552,8 @@ copy_result_decl_to_var (tree decl, copy_body_data *id)\n \n   copy = build_decl (DECL_SOURCE_LOCATION (id->dst_fn),\n \t\t     VAR_DECL, DECL_NAME (decl), type);\n+  if (DECL_PT_UID_SET_P (decl))\n+    SET_DECL_PT_UID (copy, DECL_PT_UID (decl));\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n   if (!DECL_BY_REFERENCE (decl))"}, {"sha": "ead1244936cdcad167fd820fb95b2d31e01da302", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -1475,7 +1475,15 @@ dump_decl_set (FILE *file, bitmap set)\n \n       EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n \t{\n-\t  print_generic_expr (file, referenced_var (i), 0);\n+\t  struct tree_decl_minimal in;\n+\t  tree var;\n+\t  in.uid = i;\n+\t  var = (tree) htab_find_with_hash (gimple_referenced_vars (cfun),\n+\t\t\t\t\t    &in, i);\n+\t  if (var)\n+\t    print_generic_expr (file, var, 0);\n+\t  else\n+\t    fprintf (file, \"D.%u\", i);\n \t  fprintf (file, \" \");\n \t}\n "}, {"sha": "019b9332b81bae073fa9a5baafccc937f4eb8545", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -78,8 +78,9 @@ enum tree_dump_index\n #define TDF_ASMNAME\t(1 << 18)\t/* display asm names of decls  */\n #define TDF_EH\t\t(1 << 19)\t/* display EH region number\n \t\t\t\t\t   holding this gimple statement.  */\n-\n #define TDF_NOUID\t(1 << 20)\t/* omit UIDs from dumps.  */\n+#define TDF_ALIAS\t(1 << 21)\t/* display alias information  */\n+\n \n /* In tree-dump.c */\n "}, {"sha": "331d93d6178a289a97261728df60ec9c3cc06dbe", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -199,6 +199,13 @@ dump_decl_name (pretty_printer *buffer, tree node, int flags)\n \t    pp_printf (buffer, \"%c.%u\", c, DECL_UID (node));\n \t}\n     }\n+  if ((flags & TDF_ALIAS) && DECL_PT_UID (node) != DECL_UID (node))\n+    {\n+      if (flags & TDF_NOUID)\n+\tpp_printf (buffer, \"ptD.xxxx\");\n+      else\n+\tpp_printf (buffer, \"ptD.%u\", DECL_PT_UID (node));\n+    }\n }\n \n /* Like the above, but used for pretty printing function calls.  */"}, {"sha": "8b1fdc37556574baa41ce47f24869360f39b55a9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -214,7 +214,7 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n   if (DECL_RESTRICTED_P (decl)\n       && TYPE_RESTRICT (TREE_TYPE (ptr))\n       && pi->pt.vars_contains_restrict)\n-    return bitmap_bit_p (pi->pt.vars, DECL_UID (decl));\n+    return bitmap_bit_p (pi->pt.vars, DECL_PT_UID (decl));\n \n   return pt_solution_includes (&pi->pt, decl);\n }\n@@ -401,6 +401,9 @@ dump_points_to_solution (FILE *file, struct pt_solution *pt)\n   if (pt->escaped)\n     fprintf (file, \", points-to escaped\");\n \n+  if (pt->ipa_escaped)\n+    fprintf (file, \", points-to unit escaped\");\n+\n   if (pt->null)\n     fprintf (file, \", points-to NULL\");\n \n@@ -410,6 +413,8 @@ dump_points_to_solution (FILE *file, struct pt_solution *pt)\n       dump_decl_set (file, pt->vars);\n       if (pt->vars_contains_global)\n \tfprintf (file, \" (includes global vars)\");\n+      if (pt->vars_contains_restrict)\n+\tfprintf (file, \" (includes restrict tags)\");\n     }\n }\n "}, {"sha": "147f368843488de9f6c71280f1c440b5fbaaeb25", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -38,9 +38,14 @@ struct GTY(()) pt_solution\n      even if this is zero pt_vars can still include global variables.  */\n   unsigned int nonlocal : 1;\n \n-  /* Nonzero if the points-to set includes any escaped local variable.  */\n+  /* Nonzero if the points-to set includes the local escaped solution by\n+     reference.  */\n   unsigned int escaped : 1;\n \n+  /* Nonzero if the points-to set includes the IPA escaped solution by\n+     reference.  */\n+  unsigned int ipa_escaped : 1;\n+\n   /* Nonzero if the points-to set includes 'nothing', the points-to set\n      includes memory at address NULL.  */\n   unsigned int null : 1;\n@@ -118,14 +123,17 @@ extern void dump_alias_stats (FILE *);\n /* In tree-ssa-structalias.c  */\n extern unsigned int compute_may_aliases (void);\n extern void delete_alias_heapvars (void);\n+extern bool pt_solution_empty_p (struct pt_solution *);\n extern bool pt_solution_includes_global (struct pt_solution *);\n extern bool pt_solution_includes (struct pt_solution *, const_tree);\n extern bool pt_solutions_intersect (struct pt_solution *, struct pt_solution *);\n extern bool pt_solutions_same_restrict_base (struct pt_solution *,\n \t\t\t\t\t     struct pt_solution *);\n extern void pt_solution_reset (struct pt_solution *);\n-extern void pt_solution_set (struct pt_solution *, bitmap);\n+extern void pt_solution_set (struct pt_solution *, bitmap, bool, bool);\n extern void dump_pta_stats (FILE *);\n \n+extern GTY(()) struct pt_solution ipa_escaped_pt;\n+\n \n #endif /* TREE_SSA_ALIAS_H  */"}, {"sha": "ad4c10d326127bd918009919de3c48139bc23053", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1069, "deletions": 160, "changes": 1229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -161,6 +161,48 @@\n   TODO: We could handle unions, but to be honest, it's probably not\n   worth the pain or slowdown.  */\n \n+/* IPA-PTA optimizations possible.\n+\n+   When the indirect function called is ANYTHING we can add disambiguation\n+   based on the function signatures (or simply the parameter count which\n+   is the varinfo size).  We also do not need to consider functions that\n+   do not have their address taken.\n+\n+   The is_global_var bit which marks escape points is overly conservative\n+   in IPA mode.  Split it to is_escape_point and is_global_var - only\n+   externally visible globals are escape points in IPA mode.  This is\n+   also needed to fix the pt_solution_includes_global predicate\n+   (and thus ptr_deref_may_alias_global_p).\n+\n+   The way we introduce DECL_PT_UID to avoid fixing up all points-to\n+   sets in the translation unit when we copy a DECL during inlining\n+   pessimizes precision.  The advantage is that the DECL_PT_UID keeps\n+   compile-time and memory usage overhead low - the points-to sets\n+   do not grow or get unshared as they would during a fixup phase.\n+   An alternative solution is to delay IPA PTA until after all\n+   inlining transformations have been applied.\n+\n+   The way we propagate clobber/use information isn't optimized.\n+   It should use a new complex constraint that properly filters\n+   out local variables of the callee (though that would make\n+   the sets invalid after inlining).  OTOH we might as well\n+   admit defeat to WHOPR and simply do all the clobber/use analysis\n+   and propagation after PTA finished but before we threw away\n+   points-to information for memory variables.  WHOPR and PTA\n+   do not play along well anyway - the whole constraint solving\n+   would need to be done in WPA phase and it will be very interesting\n+   to apply the results to local SSA names during LTRANS phase.\n+\n+   We probably should compute a per-function unit-ESCAPE solution\n+   propagating it simply like the clobber / uses solutions.  The\n+   solution can go alongside the non-IPA espaced solution and be\n+   used to query which vars escape the unit through a function.\n+\n+   We never put function decls in points-to sets so we do not\n+   keep the set of called functions for indirect calls.\n+\n+   And probably more.  */\n+\n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n htab_t heapvar_for_stmt;\n \n@@ -236,6 +278,9 @@ struct variable_info\n   /* True if this represents a global variable.  */\n   unsigned int is_global_var : 1;\n \n+  /* True if this represents a IPA function info.  */\n+  unsigned int is_fn_info : 1;\n+\n   /* A link to the variable for the next field in this structure.  */\n   struct variable_info *next;\n \n@@ -368,6 +413,7 @@ new_var_info (tree t, const char *name)\n   ret->is_restrict_var = false;\n   ret->may_have_pointers = true;\n   ret->is_global_var = (t == NULL_TREE);\n+  ret->is_fn_info = false;\n   if (t && DECL_P (t))\n     ret->is_global_var = is_global_var (t);\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n@@ -677,11 +723,11 @@ debug_constraint (constraint_t c)\n /* Print out all constraints to FILE */\n \n static void\n-dump_constraints (FILE *file)\n+dump_constraints (FILE *file, int from)\n {\n   int i;\n   constraint_t c;\n-  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+  for (i = from; VEC_iterate (constraint_t, constraints, i, c); i++)\n     dump_constraint (file, c);\n }\n \n@@ -690,7 +736,7 @@ dump_constraints (FILE *file)\n void\n debug_constraints (void)\n {\n-  dump_constraints (stderr);\n+  dump_constraints (stderr, 0);\n }\n \n /* Print out to FILE the edge in the constraint graph that is created by\n@@ -741,7 +787,7 @@ dump_constraint_graph (FILE *file)\n   /* Print the constraints used to produce the constraint graph. The\n      constraints will be printed as comments in the dot file:  */\n   fprintf (file, \"\\n\\n/* Constraints used in the constraint graph:\\n\");\n-  dump_constraints (file);\n+  dump_constraints (file, 0);\n   fprintf (file, \"*/\\n\");\n \n   /* Prints the header of the dot file:  */\n@@ -3506,7 +3552,7 @@ make_constraint_from_heapvar (varinfo_t lhs, const char *name)\n \n   /* For global vars we need to add a heapvar to the list of referenced\n      vars of a different function than it was created for originally.  */\n-  if (gimple_referenced_vars (cfun))\n+  if (cfun && gimple_referenced_vars (cfun))\n     add_referenced_var (heapvar);\n \n   vi = new_var_info (heapvar, name);\n@@ -3539,6 +3585,49 @@ make_constraint_from_restrict (varinfo_t lhs, const char *name)\n   vi->may_have_pointers = 0;\n }\n \n+/* In IPA mode there are varinfos for different aspects of reach\n+   function designator.  One for the points-to set of the return\n+   value, one for the variables that are clobbered by the function,\n+   one for its uses and one for each parameter (including a single\n+   glob for remaining variadic arguments).  */\n+\n+enum { fi_clobbers = 1, fi_uses = 2,\n+       fi_static_chain = 3, fi_result = 4, fi_parm_base = 5 };\n+\n+/* Get a constraint for the requested part of a function designator FI\n+   when operating in IPA mode.  */\n+\n+static struct constraint_expr\n+get_function_part_constraint (varinfo_t fi, unsigned part)\n+{\n+  struct constraint_expr c;\n+\n+  gcc_assert (in_ipa_mode);\n+\n+  if (fi->id == anything_id)\n+    {\n+      /* ???  We probably should have a ANYFN special variable.  */\n+      c.var = anything_id;\n+      c.offset = 0;\n+      c.type = SCALAR;\n+    }\n+  else if (TREE_CODE (fi->decl) == FUNCTION_DECL)\n+    {\n+      varinfo_t ai = first_vi_for_offset (fi, part);\n+      c.var = ai ? ai->id : anything_id;\n+      c.offset = 0;\n+      c.type = SCALAR;\n+    }\n+  else\n+    {\n+      c.var = fi->id;\n+      c.offset = part;\n+      c.type = DEREF;\n+    }\n+\n+  return c;\n+}\n+\n /* For non-IPA mode, generate constraints necessary for a call on the\n    RHS.  */\n \n@@ -3728,6 +3817,40 @@ handle_pure_call (gimple stmt, VEC(ce_s, heap) **results)\n   VEC_safe_push (ce_s, heap, *results, &rhsc);\n }\n \n+\n+/* Return the varinfo for the callee of CALL.  */\n+\n+static varinfo_t\n+get_fi_for_callee (gimple call)\n+{\n+  tree decl;\n+\n+  /* If we can directly resolve the function being called, do so.\n+     Otherwise, it must be some sort of indirect expression that\n+     we should still be able to handle.  */\n+  decl = gimple_call_fndecl (call);\n+  if (decl)\n+    return get_vi_for_tree (decl);\n+\n+  decl = gimple_call_fn (call);\n+  /* The function can be either an SSA name pointer or,\n+     worse, an OBJ_TYPE_REF.  In this case we have no\n+     clue and should be getting ANYFN (well, ANYTHING for now).  */\n+  if (TREE_CODE (decl) == SSA_NAME)\n+    {\n+      if (TREE_CODE (decl) == SSA_NAME\n+\t  && TREE_CODE (SSA_NAME_VAR (decl)) == PARM_DECL\n+\t  && SSA_NAME_IS_DEFAULT_DEF (decl))\n+\tdecl = SSA_NAME_VAR (decl);\n+      return get_vi_for_tree (decl);\n+    }\n+  else if (TREE_CODE (decl) == INTEGER_CST\n+\t   || TREE_CODE (decl) == OBJ_TYPE_REF)\n+    return get_varinfo (anything_id);\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Walk statement T setting up aliasing constraints according to the\n    references found in T.  This function is the main part of the\n    constraint builder.  AI points to auxiliary alias information used\n@@ -3740,6 +3863,7 @@ find_func_aliases (gimple origt)\n   VEC(ce_s, heap) *lhsc = NULL;\n   VEC(ce_s, heap) *rhsc = NULL;\n   struct constraint_expr *c;\n+  varinfo_t fi;\n \n   /* Now build constraints expressions.  */\n   if (gimple_code (t) == GIMPLE_PHI)\n@@ -3892,6 +4016,88 @@ find_func_aliases (gimple origt)\n \t  case BUILT_IN_REMQUOL:\n \t  case BUILT_IN_FREE:\n \t    return;\n+\t  /* Trampolines are special - they set up passing the static\n+\t     frame.  */\n+\t  case BUILT_IN_INIT_TRAMPOLINE:\n+\t    {\n+\t      tree tramp = gimple_call_arg (t, 0);\n+\t      tree nfunc = gimple_call_arg (t, 1);\n+\t      tree frame = gimple_call_arg (t, 2);\n+\t      unsigned i;\n+\t      struct constraint_expr lhs, *rhsp;\n+\t      if (in_ipa_mode)\n+\t\t{\n+\t\t  varinfo_t nfi = NULL;\n+\t\t  gcc_assert (TREE_CODE (nfunc) == ADDR_EXPR);\n+\t\t  nfi = lookup_vi_for_tree (TREE_OPERAND (nfunc, 0));\n+\t\t  if (nfi)\n+\t\t    {\n+\t\t      lhs = get_function_part_constraint (nfi, fi_static_chain);\n+\t\t      get_constraint_for (frame, &rhsc);\n+\t\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\t\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t\t      VEC_free (ce_s, heap, rhsc);\n+\n+\t\t      /* Make the frame point to the function for\n+\t\t\t the trampoline adjustment call.  */\n+\t\t      get_constraint_for (tramp, &lhsc);\n+\t\t      do_deref (&lhsc);\n+\t\t      get_constraint_for (nfunc, &rhsc);\n+\t\t      process_all_all_constraints (lhsc, rhsc);\n+\t\t      VEC_free (ce_s, heap, rhsc);\n+\t\t      VEC_free (ce_s, heap, lhsc);\n+\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      /* Else fallthru to generic handling which will let\n+\t         the frame escape.  */\n+\t      break;\n+\t    }\n+\t  case BUILT_IN_ADJUST_TRAMPOLINE:\n+\t    {\n+\t      tree tramp = gimple_call_arg (t, 0);\n+\t      tree res = gimple_call_lhs (t);\n+\t      if (in_ipa_mode && res)\n+\t\t{\n+\t\t  get_constraint_for (res, &lhsc);\n+\t\t  get_constraint_for (tramp, &rhsc);\n+\t\t  do_deref (&rhsc);\n+\t\t  process_all_all_constraints (lhsc, rhsc);\n+\t\t  VEC_free (ce_s, heap, rhsc);\n+\t\t  VEC_free (ce_s, heap, lhsc);\n+\t\t}\n+\t      return;\n+\t    }\n+\t  /* Variadic argument handling needs to be handled in IPA\n+\t     mode as well.  */\n+\t  case BUILT_IN_VA_START:\n+\t    {\n+\t      if (in_ipa_mode)\n+\t\t{\n+\t\t  tree valist = gimple_call_arg (t, 0);\n+\t\t  struct constraint_expr rhs, *lhsp;\n+\t\t  unsigned i;\n+\t\t  /* The va_list gets access to pointers in variadic\n+\t\t     arguments.  */\n+\t\t  fi = lookup_vi_for_tree (cfun->decl);\n+\t\t  gcc_assert (fi != NULL);\n+\t\t  get_constraint_for (valist, &lhsc);\n+\t\t  do_deref (&lhsc);\n+\t\t  rhs = get_function_part_constraint (fi, ~0);\n+\t\t  rhs.type = ADDRESSOF;\n+\t\t  for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\t\t    process_constraint (new_constraint (*lhsp, rhs));\n+\t\t  VEC_free (ce_s, heap, lhsc);\n+\t\t  /* va_list is clobbered.  */\n+\t\t  make_constraint_to (get_call_clobber_vi (t)->id, valist);\n+\t\t  return;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  /* va_end doesn't have any effect that matters.  */\n+\t  case BUILT_IN_VA_END:\n+\t    return;\n \t  /* printf-style functions may have hooks to set pointers to\n \t     point to somewhere into the generated string.  Leave them\n \t     for a later excercise...  */\n@@ -3900,7 +4106,8 @@ find_func_aliases (gimple origt)\n \t  }\n       if (!in_ipa_mode\n \t  || (fndecl\n-\t      && !lookup_vi_for_tree (fndecl)))\n+\t      && (!(fi = lookup_vi_for_tree (fndecl))\n+\t\t  || !fi->is_fn_info)))\n \t{\n \t  VEC(ce_s, heap) *rhsc = NULL;\n \t  int flags = gimple_call_flags (t);\n@@ -3928,24 +4135,9 @@ find_func_aliases (gimple origt)\n       else\n \t{\n \t  tree lhsop;\n-\t  varinfo_t fi;\n-\t  int i = 1;\n-\t  size_t j;\n-\t  tree decl;\n+\t  unsigned j;\n \n-\t  lhsop = gimple_call_lhs (t);\n-\t  decl = gimple_call_fndecl (t);\n-\n-\t  /* If we can directly resolve the function being called, do so.\n-\t     Otherwise, it must be some sort of indirect expression that\n-\t     we should still be able to handle.  */\n-\t  if (decl)\n-\t    fi = get_vi_for_tree (decl);\n-\t  else\n-\t    {\n-\t      decl = gimple_call_fn (t);\n-\t      fi = get_vi_for_tree (decl);\n-\t    }\n+\t  fi = get_fi_for_callee (t);\n \n \t  /* Assign all the passed arguments to the appropriate incoming\n \t     parameters of the function.  */\n@@ -3955,51 +4147,70 @@ find_func_aliases (gimple origt)\n \t      struct constraint_expr *rhsp;\n \t      tree arg = gimple_call_arg (t, j);\n \n+\t      if (!could_have_pointers (arg))\n+\t\tcontinue;\n+\n \t      get_constraint_for (arg, &rhsc);\n-\t      if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t\t{\n-\t\t  lhs.type = DEREF;\n-\t\t  lhs.var = fi->id;\n-\t\t  lhs.offset = i;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  lhs.type = SCALAR;\n-\t\t  lhs.var = first_vi_for_offset (fi, i)->id;\n-\t\t  lhs.offset = 0;\n-\t\t}\n+\t      lhs = get_function_part_constraint (fi, fi_parm_base + j);\n \t      while (VEC_length (ce_s, rhsc) != 0)\n \t\t{\n \t\t  rhsp = VEC_last (ce_s, rhsc);\n \t\t  process_constraint (new_constraint (lhs, *rhsp));\n \t\t  VEC_pop (ce_s, rhsc);\n \t\t}\n-\t      i++;\n \t    }\n \n \t  /* If we are returning a value, assign it to the result.  */\n-\t  if (lhsop)\n+\t  lhsop = gimple_call_lhs (t);\n+\t  if (lhsop\n+\t      && could_have_pointers (lhsop))\n \t    {\n \t      struct constraint_expr rhs;\n \t      struct constraint_expr *lhsp;\n-\t      unsigned int j = 0;\n \n \t      get_constraint_for (lhsop, &lhsc);\n-\t      if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t\t{\n-\t\t  rhs.type = DEREF;\n-\t\t  rhs.var = fi->id;\n-\t\t  rhs.offset = i;\n-\t\t}\n-\t      else\n+\t      rhs = get_function_part_constraint (fi, fi_result);\n+\t      if (fndecl\n+\t\t  && DECL_RESULT (fndecl)\n+\t\t  && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n \t\t{\n-\t\t  rhs.type = SCALAR;\n-\t\t  rhs.var = first_vi_for_offset (fi, i)->id;\n-\t\t  rhs.offset = 0;\n+\t\t  VEC(ce_s, heap) *tem = NULL;\n+\t\t  VEC_safe_push (ce_s, heap, tem, &rhs);\n+\t\t  do_deref (&tem);\n+\t\t  rhs = *VEC_index (ce_s, tem, 0);\n+\t\t  VEC_free(ce_s, heap, tem);\n \t\t}\n \t      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n \t\tprocess_constraint (new_constraint (*lhsp, rhs));\n \t    }\n+\n+\t  /* If we pass the result decl by reference, honor that.  */\n+\t  if (lhsop\n+\t      && fndecl\n+\t      && DECL_RESULT (fndecl)\n+\t      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n+\t    {\n+\t      struct constraint_expr lhs;\n+\t      struct constraint_expr *rhsp;\n+\n+\t      get_constraint_for_address_of (lhsop, &rhsc);\n+\t      lhs = get_function_part_constraint (fi, fi_result);\n+\t      for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); j++)\n+\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t      VEC_free (ce_s, heap, rhsc);\n+\t    }\n+\n+\t  /* If we use a static chain, pass it along.  */\n+\t  if (gimple_call_chain (t))\n+\t    {\n+\t      struct constraint_expr lhs;\n+\t      struct constraint_expr *rhsp;\n+\n+\t      get_constraint_for (gimple_call_chain (t), &rhsc);\n+\t      lhs = get_function_part_constraint (fi, fi_static_chain);\n+\t      for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); j++)\n+\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t    }\n \t}\n     }\n   /* Otherwise, just a regular assignment statement.  Only care about\n@@ -4039,7 +4250,9 @@ find_func_aliases (gimple origt)\n       /* If there is a store to a global variable the rhs escapes.  */\n       if ((lhsop = get_base_address (lhsop)) != NULL_TREE\n \t  && DECL_P (lhsop)\n-\t  && is_global_var (lhsop))\n+\t  && is_global_var (lhsop)\n+\t  && (!in_ipa_mode\n+\t      || DECL_EXTERNAL (lhsop) || TREE_PUBLIC (lhsop)))\n \tmake_escape_constraint (rhsop);\n       /* If this is a conversion of a non-restrict pointer to a\n \t restrict pointer track it with a new heapvar.  */\n@@ -4063,7 +4276,22 @@ find_func_aliases (gimple origt)\n \t   && gimple_return_retval (t) != NULL_TREE\n \t   && could_have_pointers (gimple_return_retval (t)))\n     {\n-      make_escape_constraint (gimple_return_retval (t));\n+      fi = NULL;\n+      if (!in_ipa_mode\n+\t  || !(fi = get_vi_for_tree (cfun->decl)))\n+\tmake_escape_constraint (gimple_return_retval (t));\n+      else if (in_ipa_mode\n+\t       && fi != NULL)\n+\t{\n+\t  struct constraint_expr lhs ;\n+\t  struct constraint_expr *rhsp;\n+\t  unsigned i;\n+\n+\t  lhs = get_function_part_constraint (fi, fi_result);\n+\t  get_constraint_for (gimple_return_retval (t), &rhsc);\n+\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t    process_constraint (new_constraint (lhs, *rhsp));\n+\t}\n     }\n   /* Handle asms conservatively by adding escape constraints to everything.  */\n   else if (gimple_code (t) == GIMPLE_ASM)\n@@ -4132,6 +4360,283 @@ find_func_aliases (gimple origt)\n }\n \n \n+/* Create a constraint adding to the clobber set of FI the memory\n+   pointed to by PTR.  */\n+\n+static void\n+process_ipa_clobber (varinfo_t fi, tree ptr)\n+{\n+  VEC(ce_s, heap) *ptrc = NULL;\n+  struct constraint_expr *c, lhs;\n+  unsigned i;\n+  get_constraint_for (ptr, &ptrc);\n+  lhs = get_function_part_constraint (fi, fi_clobbers);\n+  for (i = 0; VEC_iterate (ce_s, ptrc, i, c); i++)\n+    process_constraint (new_constraint (lhs, *c));\n+  VEC_free (ce_s, heap, ptrc);\n+}\n+\n+/* Walk statement T setting up clobber and use constraints according to the\n+   references found in T.  This function is a main part of the\n+   IPA constraint builder.  */\n+\n+static void\n+find_func_clobbers (gimple origt)\n+{\n+  gimple t = origt;\n+  VEC(ce_s, heap) *lhsc = NULL;\n+  VEC(ce_s, heap) *rhsc = NULL;\n+  varinfo_t fi;\n+\n+  /* Add constraints for clobbered/used in IPA mode.\n+     We are not interested in what automatic variables are clobbered\n+     or used as we only use the information in the caller to which\n+     they do not escape.  */\n+  gcc_assert (in_ipa_mode);\n+\n+  /* If the stmt refers to memory in any way it better had a VUSE.  */\n+  if (gimple_vuse (t) == NULL_TREE)\n+    return;\n+\n+  /* We'd better have function information for the current function.  */\n+  fi = lookup_vi_for_tree (cfun->decl);\n+  gcc_assert (fi != NULL);\n+\n+  /* Account for stores in assignments and calls.  */\n+  if (gimple_vdef (t) != NULL_TREE\n+      && gimple_has_lhs (t))\n+    {\n+      tree lhs = gimple_get_lhs (t);\n+      tree tem = lhs;\n+      while (handled_component_p (tem))\n+\ttem = TREE_OPERAND (tem, 0);\n+      if ((DECL_P (tem)\n+\t   && !auto_var_in_fn_p (tem, cfun->decl))\n+\t  || INDIRECT_REF_P (tem))\n+\t{\n+\t  struct constraint_expr lhsc, *rhsp;\n+\t  unsigned i;\n+\t  lhsc = get_function_part_constraint (fi, fi_clobbers);\n+\t  get_constraint_for_address_of (lhs, &rhsc);\n+\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t    process_constraint (new_constraint (lhsc, *rhsp));\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t}\n+    }\n+\n+  /* Account for uses in assigments and returns.  */\n+  if (gimple_assign_single_p (t)\n+      || (gimple_code (t) == GIMPLE_RETURN\n+\t  && gimple_return_retval (t) != NULL_TREE))\n+    {\n+      tree rhs = (gimple_assign_single_p (t)\n+\t\t  ? gimple_assign_rhs1 (t) : gimple_return_retval (t));\n+      tree tem = rhs;\n+      while (handled_component_p (tem))\n+\ttem = TREE_OPERAND (tem, 0);\n+      if ((DECL_P (tem)\n+\t   && !auto_var_in_fn_p (tem, cfun->decl))\n+\t  || INDIRECT_REF_P (tem))\n+\t{\n+\t  struct constraint_expr lhs, *rhsp;\n+\t  unsigned i;\n+\t  lhs = get_function_part_constraint (fi, fi_uses);\n+\t  get_constraint_for_address_of (rhs, &rhsc);\n+\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t    process_constraint (new_constraint (lhs, *rhsp));\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t}\n+    }\n+\n+  if (is_gimple_call (t))\n+    {\n+      varinfo_t cfi = NULL;\n+      tree decl = gimple_call_fndecl (t);\n+      struct constraint_expr lhs, rhs;\n+      unsigned i, j;\n+\n+      /* For builtins we do not have separate function info.  For those\n+\t we do not generate escapes for we have to generate clobbers/uses.  */\n+      if (decl\n+\t  && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n+\tswitch (DECL_FUNCTION_CODE (decl))\n+\t  {\n+\t  /* The following functions use and clobber memory pointed to\n+\t     by their arguments.  */\n+\t  case BUILT_IN_STRCPY:\n+\t  case BUILT_IN_STRNCPY:\n+\t  case BUILT_IN_BCOPY:\n+\t  case BUILT_IN_MEMCPY:\n+\t  case BUILT_IN_MEMMOVE:\n+\t  case BUILT_IN_MEMPCPY:\n+\t  case BUILT_IN_STPCPY:\n+\t  case BUILT_IN_STPNCPY:\n+\t  case BUILT_IN_STRCAT:\n+\t  case BUILT_IN_STRNCAT:\n+\t    {\n+\t      tree dest = gimple_call_arg (t, (DECL_FUNCTION_CODE (decl)\n+\t\t\t\t\t       == BUILT_IN_BCOPY ? 1 : 0));\n+\t      tree src = gimple_call_arg (t, (DECL_FUNCTION_CODE (decl)\n+\t\t\t\t\t      == BUILT_IN_BCOPY ? 0 : 1));\n+\t      unsigned i;\n+\t      struct constraint_expr *rhsp, *lhsp;\n+\t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n+\t      lhs = get_function_part_constraint (fi, fi_clobbers);\n+\t      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); i++)\n+\t\tprocess_constraint (new_constraint (lhs, *lhsp));\n+\t      VEC_free (ce_s, heap, lhsc);\n+\t      get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n+\t      lhs = get_function_part_constraint (fi, fi_uses);\n+\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t      VEC_free (ce_s, heap, rhsc);\n+\t      return;\n+\t    }\n+\t  /* The following function clobbers memory pointed to by\n+\t     its argument.  */\n+\t  case BUILT_IN_MEMSET:\n+\t    {\n+\t      tree dest = gimple_call_arg (t, 0);\n+\t      unsigned i;\n+\t      ce_s *lhsp;\n+\t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n+\t      lhs = get_function_part_constraint (fi, fi_clobbers);\n+\t      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); i++)\n+\t\tprocess_constraint (new_constraint (lhs, *lhsp));\n+\t      VEC_free (ce_s, heap, lhsc);\n+\t      return;\n+\t    }\n+\t  /* The following functions clobber their second and third\n+\t     arguments.  */\n+\t  case BUILT_IN_SINCOS:\n+\t  case BUILT_IN_SINCOSF:\n+\t  case BUILT_IN_SINCOSL:\n+\t    {\n+\t      process_ipa_clobber (fi, gimple_call_arg (t, 1));\n+\t      process_ipa_clobber (fi, gimple_call_arg (t, 2));\n+\t      return;\n+\t    }\n+\t  /* The following functions clobber their second argument.  */\n+\t  case BUILT_IN_FREXP:\n+\t  case BUILT_IN_FREXPF:\n+\t  case BUILT_IN_FREXPL:\n+\t  case BUILT_IN_LGAMMA_R:\n+\t  case BUILT_IN_LGAMMAF_R:\n+\t  case BUILT_IN_LGAMMAL_R:\n+\t  case BUILT_IN_GAMMA_R:\n+\t  case BUILT_IN_GAMMAF_R:\n+\t  case BUILT_IN_GAMMAL_R:\n+\t  case BUILT_IN_MODF:\n+\t  case BUILT_IN_MODFF:\n+\t  case BUILT_IN_MODFL:\n+\t    {\n+\t      process_ipa_clobber (fi, gimple_call_arg (t, 1));\n+\t      return;\n+\t    }\n+\t  /* The following functions clobber their third argument.  */\n+\t  case BUILT_IN_REMQUO:\n+\t  case BUILT_IN_REMQUOF:\n+\t  case BUILT_IN_REMQUOL:\n+\t    {\n+\t      process_ipa_clobber (fi, gimple_call_arg (t, 2));\n+\t      return;\n+\t    }\n+\t  /* The following functions neither read nor clobber memory.  */\n+\t  case BUILT_IN_FREE:\n+\t    return;\n+\t  /* Trampolines are of no interest to us.  */\n+\t  case BUILT_IN_INIT_TRAMPOLINE:\n+\t  case BUILT_IN_ADJUST_TRAMPOLINE:\n+\t    return;\n+\t  case BUILT_IN_VA_START:\n+\t  case BUILT_IN_VA_END:\n+\t    return;\n+\t  /* printf-style functions may have hooks to set pointers to\n+\t     point to somewhere into the generated string.  Leave them\n+\t     for a later excercise...  */\n+\t  default:\n+\t    /* Fallthru to general call handling.  */;\n+\t  }\n+\n+      /* Parameters passed by value are used.  */\n+      lhs = get_function_part_constraint (fi, fi_uses);\n+      for (i = 0; i < gimple_call_num_args (t); i++)\n+\t{\n+\t  struct constraint_expr *rhsp;\n+\t  tree arg = gimple_call_arg (t, i);\n+\n+\t  if (TREE_CODE (arg) == SSA_NAME\n+\t      || is_gimple_min_invariant (arg))\n+\t    continue;\n+\n+\t  get_constraint_for_address_of (arg, &rhsc);\n+\t  for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); j++)\n+\t    process_constraint (new_constraint (lhs, *rhsp));\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t}\n+\n+      /* Build constraints for propagating clobbers/uses along the\n+\t callgraph edges.  */\n+      cfi = get_fi_for_callee (t);\n+      if (cfi->id == anything_id)\n+\t{\n+\t  if (gimple_vdef (t))\n+\t    make_constraint_from (first_vi_for_offset (fi, fi_clobbers),\n+\t\t\t\t  anything_id);\n+\t  make_constraint_from (first_vi_for_offset (fi, fi_uses),\n+\t\t\t\tanything_id);\n+\t  return;\n+\t}\n+\n+      /* For callees without function info (that's external functions),\n+\t ESCAPED is clobbered and used.  */\n+      if (gimple_call_fndecl (t)\n+\t  && !cfi->is_fn_info)\n+\t{\n+\t  varinfo_t vi;\n+\n+\t  if (gimple_vdef (t))\n+\t    make_copy_constraint (first_vi_for_offset (fi, fi_clobbers),\n+\t\t\t\t  escaped_id);\n+\t  make_copy_constraint (first_vi_for_offset (fi, fi_uses), escaped_id);\n+\n+\t  /* Also honor the call statement use/clobber info.  */\n+\t  if ((vi = lookup_call_clobber_vi (t)) != NULL)\n+\t    make_copy_constraint (first_vi_for_offset (fi, fi_clobbers),\n+\t\t\t\t  vi->id);\n+\t  if ((vi = lookup_call_use_vi (t)) != NULL)\n+\t    make_copy_constraint (first_vi_for_offset (fi, fi_uses),\n+\t\t\t\t  vi->id);\n+\t  return;\n+\t}\n+\n+      /* Otherwise the caller clobbers and uses what the callee does.\n+\t ???  This should use a new complex constraint that filters\n+\t local variables of the callee.  */\n+      if (gimple_vdef (t))\n+\t{\n+\t  lhs = get_function_part_constraint (fi, fi_clobbers);\n+\t  rhs = get_function_part_constraint (cfi, fi_clobbers);\n+\t  process_constraint (new_constraint (lhs, rhs));\n+\t}\n+      lhs = get_function_part_constraint (fi, fi_uses);\n+      rhs = get_function_part_constraint (cfi, fi_uses);\n+      process_constraint (new_constraint (lhs, rhs));\n+    }\n+  else if (gimple_code (t) == GIMPLE_ASM)\n+    {\n+      /* ???  Ick.  We can do better.  */\n+      if (gimple_vdef (t))\n+\tmake_constraint_from (first_vi_for_offset (fi, fi_clobbers),\n+\t\t\t      anything_id);\n+      make_constraint_from (first_vi_for_offset (fi, fi_uses),\n+\t\t\t    anything_id);\n+    }\n+\n+  VEC_free (ce_s, heap, rhsc);\n+}\n+\n+\n /* Find the first varinfo in the same variable as START that overlaps with\n    OFFSET.  Return NULL if we can't find one.  */\n \n@@ -4204,34 +4709,6 @@ insert_into_field_list (varinfo_t base, varinfo_t field)\n   prev->next = field;\n }\n \n-/* Insert the varinfo FIELD into the field list for BASE, ordered by\n-   offset.  */\n-\n-static void\n-insert_into_field_list_sorted (varinfo_t base, varinfo_t field)\n-{\n-  varinfo_t prev = base;\n-  varinfo_t curr = base->next;\n-\n-  if (curr == NULL)\n-    {\n-      prev->next = field;\n-      field->next = NULL;\n-    }\n-  else\n-    {\n-      while (curr)\n-\t{\n-\t  if (field->offset <= curr->offset)\n-\t    break;\n-\t  prev = curr;\n-\t  curr = curr->next;\n-\t}\n-      field->next = prev->next;\n-      prev->next = field;\n-    }\n-}\n-\n /* This structure is used during pushing fields onto the fieldstack\n    to track the offset of the field, since bitpos_of_field gives it\n    relative to its immediate containing type, and we want it relative\n@@ -4432,35 +4909,125 @@ count_num_arguments (tree decl, bool *is_varargs)\n static unsigned int\n create_function_info_for (tree decl, const char *name)\n {\n-  varinfo_t vi;\n+  struct function *fn = DECL_STRUCT_FUNCTION (decl);\n+  varinfo_t vi, prev_vi;\n   tree arg;\n   unsigned int i;\n   bool is_varargs = false;\n+  unsigned int num_args = count_num_arguments (decl, &is_varargs);\n \n   /* Create the variable info.  */\n \n   vi = new_var_info (decl, name);\n   vi->offset = 0;\n   vi->size = 1;\n-  vi->fullsize = count_num_arguments (decl, &is_varargs) + 1;\n+  vi->fullsize = fi_parm_base + num_args;\n+  vi->is_fn_info = 1;\n+  vi->may_have_pointers = false;\n+  if (is_varargs)\n+    vi->fullsize = ~0;\n   insert_vi_for_tree (vi->decl, vi);\n \n   stats.total_vars++;\n \n-  /* If it's varargs, we don't know how many arguments it has, so we\n-     can't do much.  */\n-  if (is_varargs)\n+  prev_vi = vi;\n+\n+  /* Create a variable for things the function clobbers and one for\n+     things the function uses.  */\n     {\n-      vi->fullsize = ~0;\n-      vi->size = ~0;\n-      vi->is_unknown_size_var = true;\n-      return vi->id;\n+      varinfo_t clobbervi, usevi;\n+      const char *newname;\n+      char *tempname;\n+\n+      asprintf (&tempname, \"%s.clobber\", name);\n+      newname = ggc_strdup (tempname);\n+      free (tempname);\n+\n+      clobbervi = new_var_info (NULL, newname);\n+      clobbervi->offset = fi_clobbers;\n+      clobbervi->size = 1;\n+      clobbervi->fullsize = vi->fullsize;\n+      clobbervi->is_full_var = true;\n+      clobbervi->is_global_var = false;\n+      gcc_assert (prev_vi->offset < clobbervi->offset);\n+      prev_vi->next = clobbervi;\n+      prev_vi = clobbervi;\n+      stats.total_vars++;\n+\n+      asprintf (&tempname, \"%s.use\", name);\n+      newname = ggc_strdup (tempname);\n+      free (tempname);\n+\n+      usevi = new_var_info (NULL, newname);\n+      usevi->offset = fi_uses;\n+      usevi->size = 1;\n+      usevi->fullsize = vi->fullsize;\n+      usevi->is_full_var = true;\n+      usevi->is_global_var = false;\n+      gcc_assert (prev_vi->offset < usevi->offset);\n+      prev_vi->next = usevi;\n+      prev_vi = usevi;\n+      stats.total_vars++;\n     }\n \n-  arg = DECL_ARGUMENTS (decl);\n+  /* And one for the static chain.  */\n+  if (fn->static_chain_decl != NULL_TREE)\n+    {\n+      varinfo_t chainvi;\n+      const char *newname;\n+      char *tempname;\n+\n+      asprintf (&tempname, \"%s.chain\", name);\n+      newname = ggc_strdup (tempname);\n+      free (tempname);\n+\n+      chainvi = new_var_info (fn->static_chain_decl, newname);\n+      chainvi->offset = fi_static_chain;\n+      chainvi->size = 1;\n+      chainvi->fullsize = vi->fullsize;\n+      chainvi->is_full_var = true;\n+      chainvi->is_global_var = false;\n+      gcc_assert (prev_vi->offset < chainvi->offset);\n+      prev_vi->next = chainvi;\n+      prev_vi = chainvi;\n+      stats.total_vars++;\n+      insert_vi_for_tree (fn->static_chain_decl, chainvi);\n+    }\n+\n+  /* Create a variable for the return var.  */\n+  if (DECL_RESULT (decl) != NULL\n+      || !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n+    {\n+      varinfo_t resultvi;\n+      const char *newname;\n+      char *tempname;\n+      tree resultdecl = decl;\n+\n+      if (DECL_RESULT (decl))\n+\tresultdecl = DECL_RESULT (decl);\n+\n+      asprintf (&tempname, \"%s.result\", name);\n+      newname = ggc_strdup (tempname);\n+      free (tempname);\n+\n+      resultvi = new_var_info (resultdecl, newname);\n+      resultvi->offset = fi_result;\n+      resultvi->size = 1;\n+      resultvi->fullsize = vi->fullsize;\n+      resultvi->is_full_var = true;\n+      if (DECL_RESULT (decl))\n+\tresultvi->may_have_pointers = could_have_pointers (DECL_RESULT (decl));\n+      gcc_assert (prev_vi->offset < resultvi->offset);\n+      prev_vi->next = resultvi;\n+      prev_vi = resultvi;\n+      stats.total_vars++;\n+      if (DECL_RESULT (decl))\n+\tinsert_vi_for_tree (DECL_RESULT (decl), resultvi);\n+    }\n \n   /* Set up variables for each argument.  */\n-  for (i = 1; i < vi->fullsize; i++)\n+  arg = DECL_ARGUMENTS (decl);\n+  for (i = 0; i < num_args; i++)\n     {\n       varinfo_t argvi;\n       const char *newname;\n@@ -4470,51 +5037,54 @@ create_function_info_for (tree decl, const char *name)\n       if (arg)\n \targdecl = arg;\n \n-      asprintf (&tempname, \"%s.arg%d\", name, i-1);\n+      asprintf (&tempname, \"%s.arg%d\", name, i);\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n       argvi = new_var_info (argdecl, newname);\n-      argvi->offset = i;\n+      argvi->offset = fi_parm_base + i;\n       argvi->size = 1;\n       argvi->is_full_var = true;\n       argvi->fullsize = vi->fullsize;\n-      insert_into_field_list_sorted (vi, argvi);\n-      stats.total_vars ++;\n+      if (arg)\n+\targvi->may_have_pointers = could_have_pointers (arg);\n+      gcc_assert (prev_vi->offset < argvi->offset);\n+      prev_vi->next = argvi;\n+      prev_vi = argvi;\n+      stats.total_vars++;\n       if (arg)\n \t{\n \t  insert_vi_for_tree (arg, argvi);\n \t  arg = TREE_CHAIN (arg);\n \t}\n     }\n \n-  /* Create a variable for the return var.  */\n-  if (DECL_RESULT (decl) != NULL\n-      || !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n+  /* Add one representative for all further args.  */\n+  if (is_varargs)\n     {\n-      varinfo_t resultvi;\n+      varinfo_t argvi;\n       const char *newname;\n       char *tempname;\n-      tree resultdecl = decl;\n-\n-      vi->fullsize ++;\n-\n-      if (DECL_RESULT (decl))\n-\tresultdecl = DECL_RESULT (decl);\n+      tree decl;\n \n-      asprintf (&tempname, \"%s.result\", name);\n+      asprintf (&tempname, \"%s.varargs\", name);\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      resultvi = new_var_info (resultdecl, newname);\n-      resultvi->offset = i;\n-      resultvi->size = 1;\n-      resultvi->fullsize = vi->fullsize;\n-      resultvi->is_full_var = true;\n-      insert_into_field_list_sorted (vi, resultvi);\n-      stats.total_vars ++;\n-      if (DECL_RESULT (decl))\n-\tinsert_vi_for_tree (DECL_RESULT (decl), resultvi);\n+      /* We need sth that can be pointed to for va_start.  */\n+      decl = create_tmp_var_raw (ptr_type_node, name);\n+      get_var_ann (decl);\n+\n+      argvi = new_var_info (decl, newname);\n+      argvi->offset = fi_parm_base + num_args;\n+      argvi->size = ~0;\n+      argvi->is_full_var = true;\n+      argvi->is_heap_var = true;\n+      argvi->fullsize = vi->fullsize;\n+      gcc_assert (prev_vi->offset < argvi->offset);\n+      prev_vi->next = argvi;\n+      prev_vi = argvi;\n+      stats.total_vars++;\n     }\n \n   return vi->id;\n@@ -4575,14 +5145,54 @@ create_variable_info_for (tree decl, const char *name)\n     }\n \n   insert_vi_for_tree (vi->decl, vi);\n+\n+  /* ???  The setting of vi->may_have_pointers is too conservative here\n+     and may get refined below.  Thus we have superfluous constraints\n+     here sometimes which triggers the commented assert in\n+     dump_sa_points_to_info.  */\n   if (vi->is_global_var\n-      && (!flag_whole_program || !in_ipa_mode)\n       && vi->may_have_pointers)\n     {\n+      /* Mark global restrict qualified pointers.  */\n       if (POINTER_TYPE_P (TREE_TYPE (decl))\n \t  && TYPE_RESTRICT (TREE_TYPE (decl)))\n \tmake_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n-      make_copy_constraint (vi, nonlocal_id);\n+\n+      /* For escaped variables initialize them from nonlocal.  */\n+      if (!in_ipa_mode\n+\t  || DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n+\tmake_copy_constraint (vi, nonlocal_id);\n+\n+      /* If this is a global variable with an initializer and we are in\n+\t IPA mode generate constraints for it.  In non-IPA mode\n+\t the initializer from nonlocal is all we need.  */\n+      if (in_ipa_mode\n+\t  && DECL_INITIAL (vi->decl))\n+\t{\n+\t  VEC (ce_s, heap) *rhsc = NULL;\n+\t  struct constraint_expr lhs, *rhsp;\n+\t  unsigned i;\n+\t  get_constraint_for (DECL_INITIAL (vi->decl), &rhsc);\n+\t  lhs.var = vi->id;\n+\t  lhs.offset = 0;\n+\t  lhs.type = SCALAR;\n+\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\t    process_constraint (new_constraint (lhs, *rhsp));\n+\t  /* If this is a variable that escapes from the unit\n+\t     the initializer escapes as well.  */\n+\t  if (DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n+\t    {\n+\t      lhs.var = escaped_id;\n+\t      lhs.offset = 0;\n+\t      lhs.type = SCALAR;\n+\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t    }\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t  /* ???  Force us to not use subfields.  Else we'd have to parse\n+\t     arbitrary initializers.  */\n+\t  VEC_free (fieldoff_s, heap, fieldstack);\n+\t}\n     }\n \n   stats.total_vars++;\n@@ -4638,7 +5248,6 @@ create_variable_info_for (tree decl, const char *name)\n       vi->offset = fo->offset;\n       vi->may_have_pointers = fo->may_have_pointers;\n       if (vi->is_global_var\n-\t  && (!flag_whole_program || !in_ipa_mode)\n \t  && vi->may_have_pointers)\n \t{\n \t  if (fo->only_restrict_pointers)\n@@ -4695,20 +5304,19 @@ dump_solution_for_var (FILE *file, unsigned int var)\n   unsigned int i;\n   bitmap_iterator bi;\n \n-  if (find (var) != var)\n-    {\n-      varinfo_t vipt = get_varinfo (find (var));\n-      fprintf (file, \"%s = same as %s\\n\", vi->name, vipt->name);\n-    }\n-  else\n-    {\n-      fprintf (file, \"%s = { \", vi->name);\n-      EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n-\t{\n-\t  fprintf (file, \"%s \", get_varinfo (i)->name);\n-\t}\n-      fprintf (file, \"}\\n\");\n-    }\n+  /* Dump the solution for unified vars anyway, this avoids difficulties\n+     in scanning dumps in the testsuite.  */\n+  fprintf (file, \"%s = { \", vi->name);\n+  vi = get_varinfo (find (var));\n+  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n+    fprintf (file, \"%s \", get_varinfo (i)->name);\n+  fprintf (file, \"}\");\n+\n+  /* But note when the variable was unified.  */\n+  if (vi->id != var)\n+    fprintf (file, \" same as %s\", vi->name);\n+\n+  fprintf (file, \"\\n\");\n }\n \n /* Print the points-to solution for VAR to stdout.  */\n@@ -4888,9 +5496,15 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n \t  || TREE_CODE (vi->decl) == PARM_DECL\n \t  || TREE_CODE (vi->decl) == RESULT_DECL)\n \t{\n+\t  /* If we are in IPA mode we will not recompute points-to\n+\t     sets after inlining so make sure they stay valid.  */\n+\t  if (in_ipa_mode\n+\t      && !DECL_PT_UID_SET_P (vi->decl))\n+\t    SET_DECL_PT_UID (vi->decl, DECL_UID (vi->decl));\n+\n \t  /* Add the decl to the points-to set.  Note that the points-to\n \t     set contains global variables.  */\n-\t  bitmap_set_bit (into, DECL_UID (vi->decl));\n+\t  bitmap_set_bit (into, DECL_PT_UID (vi->decl));\n \t  if (vi->is_global_var)\n \t    pt->vars_contains_global = true;\n \t}\n@@ -4926,7 +5540,12 @@ find_what_var_points_to (varinfo_t orig_vi, struct pt_solution *pt)\n \t  if (vi->id == nothing_id)\n \t    pt->null = 1;\n \t  else if (vi->id == escaped_id)\n-\t    pt->escaped = 1;\n+\t    {\n+\t      if (in_ipa_mode)\n+\t\tpt->ipa_escaped = 1;\n+\t      else\n+\t\tpt->escaped = 1;\n+\t    }\n \t  else if (vi->id == nonlocal_id)\n \t    pt->nonlocal = 1;\n \t  else if (vi->is_heap_var)\n@@ -5032,30 +5651,53 @@ pt_solution_reset (struct pt_solution *pt)\n }\n \n /* Set the points-to solution *PT to point only to the variables\n-   in VARS.  */\n+   in VARS.  VARS_CONTAINS_GLOBAL specifies whether that contains\n+   global variables and VARS_CONTAINS_RESTRICT specifies whether\n+   it contains restrict tag variables.  */\n \n void\n-pt_solution_set (struct pt_solution *pt, bitmap vars)\n+pt_solution_set (struct pt_solution *pt, bitmap vars,\n+\t\t bool vars_contains_global, bool vars_contains_restrict)\n {\n-  bitmap_iterator bi;\n-  unsigned i;\n-\n   memset (pt, 0, sizeof (struct pt_solution));\n   pt->vars = vars;\n-  EXECUTE_IF_SET_IN_BITMAP (vars, 0, i, bi)\n+  pt->vars_contains_global = vars_contains_global;\n+  pt->vars_contains_restrict = vars_contains_restrict;\n+}\n+\n+/* Computes the union of the points-to solutions *DEST and *SRC and\n+   stores the result in *DEST.  This changes the points-to bitmap\n+   of *DEST and thus may not be used if that might be shared.\n+   The points-to bitmap of *SRC and *DEST will not be shared after\n+   this function if they were not before.  */\n+\n+static void\n+pt_solution_ior_into (struct pt_solution *dest, struct pt_solution *src)\n+{\n+  dest->anything |= src->anything;\n+  if (dest->anything)\n     {\n-      tree var = referenced_var_lookup (i);\n-      if (is_global_var (var))\n-\t{\n-\t  pt->vars_contains_global = true;\n-\t  break;\n-\t}\n+      pt_solution_reset (dest);\n+      return;\n     }\n+\n+  dest->nonlocal |= src->nonlocal;\n+  dest->escaped |= src->escaped;\n+  dest->ipa_escaped |= src->ipa_escaped;\n+  dest->null |= src->null;\n+  dest->vars_contains_global |= src->vars_contains_global;\n+  dest->vars_contains_restrict |= src->vars_contains_restrict;\n+  if (!src->vars)\n+    return;\n+\n+  if (!dest->vars)\n+    dest->vars = BITMAP_GGC_ALLOC ();\n+  bitmap_ior_into (dest->vars, src->vars);\n }\n \n /* Return true if the points-to solution *PT is empty.  */\n \n-static bool\n+bool\n pt_solution_empty_p (struct pt_solution *pt)\n {\n   if (pt->anything\n@@ -5071,6 +5713,11 @@ pt_solution_empty_p (struct pt_solution *pt)\n       && !pt_solution_empty_p (&cfun->gimple_df->escaped))\n     return false;\n \n+  /* If the solution includes ESCAPED, check if that is empty.  */\n+  if (pt->ipa_escaped\n+      && !pt_solution_empty_p (&ipa_escaped_pt))\n+    return false;\n+\n   return true;\n }\n \n@@ -5087,6 +5734,15 @@ pt_solution_includes_global (struct pt_solution *pt)\n   if (pt->escaped)\n     return pt_solution_includes_global (&cfun->gimple_df->escaped);\n \n+  if (pt->ipa_escaped)\n+    return pt_solution_includes_global (&ipa_escaped_pt);\n+\n+  /* ???  This predicate is not correct for the IPA-PTA solution\n+     as we do not properly distinguish between unit escape points\n+     and global variables.  */\n+  if (cfun->gimple_df->ipa_pta)\n+    return true;\n+\n   return false;\n }\n \n@@ -5104,14 +5760,19 @@ pt_solution_includes_1 (struct pt_solution *pt, const_tree decl)\n     return true;\n \n   if (pt->vars\n-      && bitmap_bit_p (pt->vars, DECL_UID (decl)))\n+      && bitmap_bit_p (pt->vars, DECL_PT_UID (decl)))\n     return true;\n \n   /* If the solution includes ESCAPED, check it.  */\n   if (pt->escaped\n       && pt_solution_includes_1 (&cfun->gimple_df->escaped, decl))\n     return true;\n \n+  /* If the solution includes ESCAPED, check it.  */\n+  if (pt->ipa_escaped\n+      && pt_solution_includes_1 (&ipa_escaped_pt, decl))\n+    return true;\n+\n   return false;\n }\n \n@@ -5162,6 +5823,25 @@ pt_solutions_intersect_1 (struct pt_solution *pt1, struct pt_solution *pt2)\n \treturn true;\n     }\n \n+  /* Check the escaped solution if required.\n+     ???  Do we need to check the local against the IPA escaped sets?  */\n+  if ((pt1->ipa_escaped || pt2->ipa_escaped)\n+      && !pt_solution_empty_p (&ipa_escaped_pt))\n+    {\n+      /* If both point to escaped memory and that solution\n+\t is not empty they alias.  */\n+      if (pt1->ipa_escaped && pt2->ipa_escaped)\n+\treturn true;\n+\n+      /* If either points to escaped memory see if the escaped solution\n+\t intersects with the other.  */\n+      if ((pt1->ipa_escaped\n+\t   && pt_solutions_intersect_1 (&ipa_escaped_pt, pt2))\n+\t  || (pt2->ipa_escaped\n+\t      && pt_solutions_intersect_1 (&ipa_escaped_pt, pt1)))\n+\treturn true;\n+    }\n+\n   /* Now both pointers alias if their points-to solution intersects.  */\n   return (pt1->vars\n \t  && pt2->vars\n@@ -5227,7 +5907,18 @@ dump_sa_points_to_info (FILE *outfile)\n     }\n \n   for (i = 0; i < VEC_length (varinfo_t, varmap); i++)\n-    dump_solution_for_var (outfile, i);\n+    {\n+      varinfo_t vi = get_varinfo (i);\n+      if (!vi->may_have_pointers)\n+\t{\n+\t  gcc_assert (find (i) == i\n+\t\t      || !(vi = get_varinfo (find (i)))->may_have_pointers);\n+\t  /* ???  See create_variable_info_for.\n+\t     gcc_assert (bitmap_empty_p (vi->solution));  */\n+\t  continue;\n+\t}\n+      dump_solution_for_var (outfile, i);\n+    }\n }\n \n \n@@ -5499,12 +6190,6 @@ solve_constraints (void)\n {\n   struct scc_info *si;\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n-      dump_constraints (dump_file);\n-    }\n-\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nCollapsing static cycles and doing variable \"\n@@ -5573,7 +6258,7 @@ compute_points_to_sets (void)\n \n   intra_create_variable_infos ();\n \n-  /* Now walk all statements and derive aliases.  */\n+  /* Now walk all statements and build the constraint set.  */\n   FOR_EACH_BB (bb)\n     {\n       gimple_stmt_iterator gsi;\n@@ -5594,6 +6279,12 @@ compute_points_to_sets (void)\n \t}\n     }\n \n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n+      dump_constraints (dump_file, 0);\n+    }\n+\n   /* From the constraints compute the points-to sets.  */\n   solve_constraints ();\n \n@@ -5724,6 +6415,23 @@ delete_points_to_sets (void)\n unsigned int\n compute_may_aliases (void)\n {\n+  if (cfun->gimple_df->ipa_pta)\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\nNot re-computing points-to information \"\n+\t\t   \"because IPA points-to information is available.\\n\\n\");\n+\n+\t  /* But still dump what we have remaining it.  */\n+\t  dump_alias_info (dump_file);\n+\n+\t  if (dump_flags & TDF_DETAILS)\n+\t    dump_referenced_vars (dump_file);\n+\t}\n+\n+      return 0;\n+    }\n+\n   /* For each pointer P_i, determine the sets of variables that P_i may\n      point-to.  Compute the reachability set of escaped and call-used\n      variables.  */\n@@ -5808,11 +6516,17 @@ gate_ipa_pta (void)\n \t  && !(errorcount || sorrycount));\n }\n \n+/* IPA PTA solutions for ESCAPED.  */\n+struct pt_solution ipa_escaped_pt\n+  = { true, false, false, false, false, false, false, NULL };\n+\n /* Execute the driver for IPA PTA.  */\n static unsigned int\n ipa_pta_execute (void)\n {\n   struct cgraph_node *node;\n+  struct varpool_node *var;\n+  int from;\n \n   in_ipa_mode = 1;\n \n@@ -5829,16 +6543,23 @@ ipa_pta_execute (void)\n \t  || node->clone_of)\n \tcontinue;\n \n-      /* It does not make sense to have graph edges into or out of\n-         externally visible functions.  There is no extra information\n-\t we can gather from them.  */\n-      if (node->local.externally_visible)\n-\tcontinue;\n-\n       create_function_info_for (node->decl,\n \t\t\t\tcgraph_node_name (node));\n     }\n \n+  /* Create constraints for global variables and their initializers.  */\n+  for (var = varpool_nodes; var; var = var->next)\n+    get_vi_for_tree (var->decl);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"Generating constraints for global initializers\\n\\n\");\n+      dump_constraints (dump_file, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  from = VEC_length (constraint_t, constraints);\n+\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       struct function *func;\n@@ -5885,16 +6606,204 @@ ipa_pta_execute (void)\n \t      gimple stmt = gsi_stmt (gsi);\n \n \t      find_func_aliases (stmt);\n+\t      find_func_clobbers (stmt);\n \t    }\n \t}\n \n       current_function_decl = old_func_decl;\n       pop_cfun ();\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n\");\n+\t  dump_constraints (dump_file, from);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      from = VEC_length (constraint_t, constraints);\n     }\n \n   /* From the constraints compute the points-to sets.  */\n   solve_constraints ();\n \n+  /* Compute the global points-to sets for ESCAPED.\n+     ???  Note that the computed escape set is not correct\n+     for the whole unit as we fail to consider graph edges to\n+     externally visible functions.  */\n+  find_what_var_points_to (get_varinfo (escaped_id), &ipa_escaped_pt);\n+\n+  /* Make sure the ESCAPED solution (which is used as placeholder in\n+     other solutions) does not reference itself.  This simplifies\n+     points-to solution queries.  */\n+  ipa_escaped_pt.ipa_escaped = 0;\n+\n+  /* Assign the points-to sets to the SSA names in the unit.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree ptr;\n+      struct function *fn;\n+      unsigned i;\n+      varinfo_t fi;\n+      basic_block bb;\n+      struct pt_solution uses, clobbers;\n+      struct cgraph_edge *e;\n+\n+      /* Nodes without a body are not interesting.  */\n+      if (!gimple_has_body_p (node->decl)\n+\t  || node->clone_of)\n+\tcontinue;\n+\n+      fn = DECL_STRUCT_FUNCTION (node->decl);\n+\n+      /* Compute the points-to sets for pointer SSA_NAMEs.  */\n+      for (i = 0; VEC_iterate (tree, fn->gimple_df->ssa_names, i, ptr); ++i)\n+\t{\n+\t  if (ptr\n+\t      && POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\t    find_what_p_points_to (ptr);\n+\t}\n+\n+      /* Compute the call-use and call-clobber sets for all direct calls.  */\n+      fi = lookup_vi_for_tree (node->decl);\n+      gcc_assert (fi->is_fn_info);\n+      find_what_var_points_to (first_vi_for_offset (fi, fi_clobbers),\n+\t\t\t       &clobbers);\n+      find_what_var_points_to (first_vi_for_offset (fi, fi_uses), &uses);\n+      for (e = node->callers; e; e = e->next_caller)\n+\t{\n+\t  if (!e->call_stmt)\n+\t    continue;\n+\n+\t  *gimple_call_clobber_set (e->call_stmt) = clobbers;\n+\t  *gimple_call_use_set (e->call_stmt) = uses;\n+\t}\n+\n+      /* Compute the call-use and call-clobber sets for indirect calls\n+\t and calls to external functions.  */\n+      FOR_EACH_BB_FN (bb, fn)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      struct pt_solution *pt;\n+\t      varinfo_t vi;\n+\t      tree decl;\n+\n+\t      if (!is_gimple_call (stmt))\n+\t\tcontinue;\n+\n+\t      /* Handle direct calls to external functions.  */\n+\t      decl = gimple_call_fndecl (stmt);\n+\t      if (decl\n+\t\t  && (!(fi = lookup_vi_for_tree (decl))\n+\t\t      || !fi->is_fn_info))\n+\t\t{\n+\t\t  pt = gimple_call_use_set (stmt);\n+\t\t  if (gimple_call_flags (stmt) & ECF_CONST)\n+\t\t    memset (pt, 0, sizeof (struct pt_solution));\n+\t\t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n+\t\t    {\n+\t\t      find_what_var_points_to (vi, pt);\n+\t\t      /* Escaped (and thus nonlocal) variables are always\n+\t\t\t implicitly used by calls.  */\n+\t\t      /* ???  ESCAPED can be empty even though NONLOCAL\n+\t\t\t always escaped.  */\n+\t\t      pt->nonlocal = 1;\n+\t\t      pt->ipa_escaped = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* If there is nothing special about this call then\n+\t\t\t we have made everything that is used also escape.  */\n+\t\t      *pt = ipa_escaped_pt;\n+\t\t      pt->nonlocal = 1;\n+\t\t    }\n+\n+\t\t  pt = gimple_call_clobber_set (stmt);\n+\t\t  if (gimple_call_flags (stmt) & (ECF_CONST|ECF_PURE|ECF_NOVOPS))\n+\t\t    memset (pt, 0, sizeof (struct pt_solution));\n+\t\t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n+\t\t    {\n+\t\t      find_what_var_points_to (vi, pt);\n+\t\t      /* Escaped (and thus nonlocal) variables are always\n+\t\t\t implicitly clobbered by calls.  */\n+\t\t      /* ???  ESCAPED can be empty even though NONLOCAL\n+\t\t\t always escaped.  */\n+\t\t      pt->nonlocal = 1;\n+\t\t      pt->ipa_escaped = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* If there is nothing special about this call then\n+\t\t\t we have made everything that is used also escape.  */\n+\t\t      *pt = ipa_escaped_pt;\n+\t\t      pt->nonlocal = 1;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Handle indirect calls.  */\n+\t      if (!decl\n+\t\t  && (fi = get_fi_for_callee (stmt)))\n+\t\t{\n+\t\t  /* We need to accumulate all clobbers/uses of all possible\n+\t\t     callees.  */\n+\t\t  fi = get_varinfo (find (fi->id));\n+\t\t  /* If we cannot constrain the set of functions we'll end up\n+\t\t     calling we end up using/clobbering everything.  */\n+\t\t  if (bitmap_bit_p (fi->solution, anything_id)\n+\t\t      || bitmap_bit_p (fi->solution, nonlocal_id)\n+\t\t      || bitmap_bit_p (fi->solution, escaped_id))\n+\t\t    {\n+\t\t      pt_solution_reset (gimple_call_clobber_set (stmt));\n+\t\t      pt_solution_reset (gimple_call_use_set (stmt));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      bitmap_iterator bi;\n+\t\t      unsigned i;\n+\t\t      struct pt_solution *uses, *clobbers;\n+\n+\t\t      uses = gimple_call_use_set (stmt);\n+\t\t      clobbers = gimple_call_clobber_set (stmt);\n+\t\t      memset (uses, 0, sizeof (struct pt_solution));\n+\t\t      memset (clobbers, 0, sizeof (struct pt_solution));\n+\t\t      EXECUTE_IF_SET_IN_BITMAP (fi->solution, 0, i, bi)\n+\t\t\t{\n+\t\t\t  struct pt_solution sol;\n+\n+\t\t\t  vi = get_varinfo (i);\n+\t\t\t  if (!vi->is_fn_info)\n+\t\t\t    {\n+\t\t\t      /* ???  We could be more precise here?  */\n+\t\t\t      uses->nonlocal = 1;\n+\t\t\t      uses->ipa_escaped = 1;\n+\t\t\t      clobbers->nonlocal = 1;\n+\t\t\t      clobbers->ipa_escaped = 1;\n+\t\t\t      continue;\n+\t\t\t    }\n+\n+\t\t\t  if (!uses->anything)\n+\t\t\t    {\n+\t\t\t      find_what_var_points_to\n+\t\t\t\t  (first_vi_for_offset (vi, fi_uses), &sol);\n+\t\t\t      pt_solution_ior_into (uses, &sol);\n+\t\t\t    }\n+\t\t\t  if (!clobbers->anything)\n+\t\t\t    {\n+\t\t\t      find_what_var_points_to\n+\t\t\t\t  (first_vi_for_offset (vi, fi_clobbers), &sol);\n+\t\t\t      pt_solution_ior_into (clobbers, &sol);\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      fn->gimple_df->ipa_pta = true;\n+    }\n+\n   delete_points_to_sets ();\n \n   in_ipa_mode = 0;"}, {"sha": "6ac1318667517c8ebde35df5bb4f6e27bee5e360", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -883,7 +883,10 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       if (TREE_CODE (t) == DEBUG_EXPR_DECL)\n \tDECL_UID (t) = --next_debug_decl_uid;\n       else\n-\tDECL_UID (t) = next_decl_uid++;\n+\t{\n+\t  DECL_UID (t) = next_decl_uid++;\n+\t  SET_DECL_PT_UID (t, -1);\n+\t}\n       if (TREE_CODE (t) == LABEL_DECL)\n \tLABEL_DECL_UID (t) = -1;\n \n@@ -963,7 +966,11 @@ copy_node_stat (tree node MEM_STAT_DECL)\n       if (code == DEBUG_EXPR_DECL)\n \tDECL_UID (t) = --next_debug_decl_uid;\n       else\n-\tDECL_UID (t) = next_decl_uid++;\n+\t{\n+\t  DECL_UID (t) = next_decl_uid++;\n+\t  if (DECL_PT_UID_SET_P (node))\n+\t    SET_DECL_PT_UID (t, DECL_PT_UID (node));\n+\t}\n       if ((TREE_CODE (node) == PARM_DECL || TREE_CODE (node) == VAR_DECL)\n \t  && DECL_HAS_VALUE_EXPR_P (node))\n \t{"}, {"sha": "ad958119a222689ea5c4964925982b5532f154a3", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25a6a8731ca102e1995fe996722a0637b1311445/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=25a6a8731ca102e1995fe996722a0637b1311445", "patch": "@@ -2489,6 +2489,15 @@ struct function;\n    uses.  */\n #define DEBUG_TEMP_UID(NODE) (-DECL_UID (TREE_CHECK ((NODE), DEBUG_EXPR_DECL)))\n \n+/* Every ..._DECL node gets a unique number that stays the same even\n+   when the decl is copied by the inliner once it is set.  */\n+#define DECL_PT_UID(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.pt_uid == -1u ? (NODE)->decl_minimal.uid : (NODE)->decl_minimal.pt_uid)\n+/* Initialize the ..._DECL node pt-uid to the decls uid.  */\n+#define SET_DECL_PT_UID(NODE, UID) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.pt_uid = (UID))\n+/* Whether the ..._DECL node pt-uid has been initialized and thus needs to\n+   be preserved when copyin the decl.  */\n+#define DECL_PT_UID_SET_P(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.pt_uid != -1u)\n+\n /* These two fields describe where in the source code the declaration\n    was.  If the declaration appears in several places (as for a C\n    function that is declared first and then defined later), this\n@@ -2512,6 +2521,7 @@ struct GTY(()) tree_decl_minimal {\n   struct tree_common common;\n   location_t locus;\n   unsigned int uid;\n+  unsigned int pt_uid;\n   tree name;\n   tree context;\n };"}]}