{"sha": "2f6256e7dccdb422eac496f2fd5503f0a3cd5f11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY2MjU2ZTdkY2NkYjQyMmVhYzQ5NmYyZmQ1NTAzZjBhM2NkNWYxMQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-10-14T17:20:53Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-10-14T17:20:53Z"}, "message": "* PROBLEMS: Remove.\n\nFrom-SVN: r36869", "tree": {"sha": "518ffec5ca7d36dfdcb90311b6940a223e8a0aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/518ffec5ca7d36dfdcb90311b6940a223e8a0aab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f6256e7dccdb422eac496f2fd5503f0a3cd5f11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6256e7dccdb422eac496f2fd5503f0a3cd5f11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6256e7dccdb422eac496f2fd5503f0a3cd5f11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6256e7dccdb422eac496f2fd5503f0a3cd5f11/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb12da9db12edd4a1d80803b0ae5f4b538191fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb12da9db12edd4a1d80803b0ae5f4b538191fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb12da9db12edd4a1d80803b0ae5f4b538191fac"}], "stats": {"total": 119, "additions": 2, "deletions": 117}, "files": [{"sha": "92a3b4e38e776a9f2bf2a67170d2d31c3e64a607", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6256e7dccdb422eac496f2fd5503f0a3cd5f11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6256e7dccdb422eac496f2fd5503f0a3cd5f11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f6256e7dccdb422eac496f2fd5503f0a3cd5f11", "patch": "@@ -1,5 +1,7 @@\n 2000-10-14  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n+\t* PROBLEMS: Remove.\n+\n \t* gcc.texi (Contributing): Update.\n \n 2000-10-13  Alexandre Oliva  <aoliva@redhat.com>"}, {"sha": "bc532e641a8d383cba34c49b98949861fb3026e5", "filename": "gcc/PROBLEMS", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb12da9db12edd4a1d80803b0ae5f4b538191fac/gcc%2FPROBLEMS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb12da9db12edd4a1d80803b0ae5f4b538191fac/gcc%2FPROBLEMS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FPROBLEMS?ref=bb12da9db12edd4a1d80803b0ae5f4b538191fac", "patch": "@@ -1,117 +0,0 @@\n-3. When find_reloads is used to count number of spills needed\n-it does not take into account the fact that a reload may\n-turn out to be a dummy.\n-\n-I'm not sure this really happens any more.  Doesn't it find\n-all the dummies on both passes?\n-\n-10.     movl a3@,a0\n-\tmovl a3@(16),a1\n-\tclrb a0@(a1:l)\n-is generated and may be worse than\n-\tmovl a3@,a0\n-\taddl a3@(16),a0\n-\tclrb a0@\n-If ordering of operands is improved, many more\n-such cases will be generated from typical array accesses.\n-\n-38. Hack expand_mult so that if there is no same-modes multiply\n-it will use a widening multiply and then truncate rather than\n-calling the library.\n-\n-39. Hack expanding of division to notice cases for\n-long -> short division.\n-\n-40. Represent divide insns as (DIV:SI ...) followed by\n-a separate lowpart extract.  Represent remainder insns as DIV:SI\n-followed by a separate highpart extract.  Then cse can work on\n-the DIV:SI part.  Problem is, this may not be desirable on machines\n-where computing the quotient alone does not necessarily give\n-a remainder--such as the 68020 for long operands.\n-\n-52. Reloading can look at how reload_contents got set up.\n-If it was copied from a register, just reload from that register.\n-Otherwise, perhaps can change the previous insn to move the\n-data via the reload reg, thus avoiding one memory ref.\n-\n-63. Potential problem in cc_status.value2, if it ever activates itself\n-after a two-address subtraction (which currently cannot happen).\n-It is supposed to compare the current value of the destination\n-but eliminating it would use the results of the subtraction, equivalent\n-to comparing the previous value of the destination.\n-\n-65. Should loops that neither start nor end with a break\n-be rearranged to end with the last break?\n-\n-69. Define the floating point converting arithmetic instructions\n-for the 68881.\n-\n-74. Combine loop opt with cse opt in one pass.  Do cse on each loop,\n-then loop opt on that loop, and go from innermost loops outward.\n-Make loop invariants available for cse at end of loop.\n-\n-85. pea can force a value to be reloaded into an areg\n-which can make it worse than separate adding and pushing.\n-This can only happen for adding something within addql range\n-and it only loses if the qty becomes dead at that point\n-so it can be added to with no copying.\n-\n-93. If a pseudo doesn't get a hard reg everywhere,\n-can it get one during a loop?\n-\n-96. Can do SImode bitfield insns without reloading, but must\n-alter the operands in special ways.\n-\n-99. final could check loop-entry branches to see if they\n-screw up deletion of a test instruction.  If they do,\n-can put another test instruction before the branch and\n-make it conditional and redirect it.\n-\n-106. Aliasing may be impossible if data types of refs differ\n-and data type of containing objects also differ.\n-(But check this wrt unions.)\n-\n-108. Can speed up flow analysis by making a table saying which\n-register is set and which registers are used by each instruction that\n-only sets one register and only uses two.  This way avoid the tree\n-walk for such instructions (most instructions).\n-\n-109. It is desirable to avoid converting INDEX to SImode if a\n-narrower mode suffices, as HImode does on the 68000.\n-How can this be done?\n-\n-110. Possible special combination pattern:\n-If the two operands to a comparison die there and both come from insns\n-that are identical except for replacing one operand with the other,\n-throw away those insns.  Ok if insns being discarded are known 1 to 1.\n-An andl #1 after a seq is 1 to 1, but how should compiler know that?\n-\n-112. Can convert float to unsigned int by subtracting a constant,\n-converting to signed int, and changing the sign bit.\n-\n-117. Any number of slow zero-extensions in one loop, that have\n-their clr insns moved out of the loop, can share one register\n-if their original life spans are disjoint.\n-But it may be hard to be sure of this since\n-the life span data that regscan produces may be hard to interpret\n-validly or may be incorrect after cse.\n-\n-118. In cse, when a bfext insn refers to a register, if the field\n-corresponds to a halfword or a byte and the register is equivalent\n-to a memory location, it would be possible to detect this and\n-replace it with a simple memory reference.\n-\n-121. Insns that store two values cannot be moved out of loops.\n-The code in scan_loop doesn't even try to deal with them.\n-\n-122. When insn-output.c turns a bit-test into a sign-test,\n-it should see whether the cc is already set up with that sign.\n-\n-123. When a conditional expression is used as a function arg, it would\n-be faster (and in some cases shorter) to push each alternative rather\n-than compute in a register and push that.  This would require\n-being able to specify \"push this\" as a target for expand_expr.\n-\n-124. On the 386, bad code results from foo (bar ()) when bar\n-returns a double, because the pseudo used fails to get preferenced\n-into an fp reg because of the distinction between regs 8 and 9."}]}