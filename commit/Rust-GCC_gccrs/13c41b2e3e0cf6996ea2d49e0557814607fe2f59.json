{"sha": "13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNjNDFiMmUzZTBjZjY5OTZlYTJkNDllMDU1NzgxNDYwN2ZlMmY1OQ==", "commit": {"author": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2015-09-03T11:26:36Z"}, "committer": {"name": "Sebastian Huber", "email": "sh@gcc.gnu.org", "date": "2015-09-03T11:26:36Z"}, "message": "[gomp] Add RTEMS configuration\n\nlibgomp/ChangeLog\n\n\t* config/rtems/bar.c: New.\n\t* config/rtems/bar.h: Likewise.\n\t* config/rtems/mutex.c: Likewise.\n\t* config/rtems/mutex.h: Likewise.\n\t* config/rtems/sem.c: Likewise.\n\t* config/rtems/sem.h: Likewise.\n\t* configure.ac (*-*-rtems*): Check that Newlib provides a proper\n\t<sys/lock.h> header file.\n\t* configure.tgt (*-*-rtems*): Enable RTEMS configuration if\n\tsupported by Newlib.\n\t* configure: Regenerate.\n\nFrom-SVN: r227440", "tree": {"sha": "b8cc0ec94f547152e58b42f867351520f7d48307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8cc0ec94f547152e58b42f867351520f7d48307"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/comments", "author": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7892ec670c1c5d1e4d911ab41903a6af72bc85d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7892ec670c1c5d1e4d911ab41903a6af72bc85d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7892ec670c1c5d1e4d911ab41903a6af72bc85d2"}], "stats": {"total": 583, "additions": 583, "deletions": 0}, "files": [{"sha": "c3e94bfa1bcb23944ad20a8b0e57f36a0222e0af", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -1,3 +1,17 @@\n+2015-09-03  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n+\n+\t* config/rtems/bar.c: New.\n+\t* config/rtems/bar.h: Likewise.\n+\t* config/rtems/mutex.c: Likewise.\n+\t* config/rtems/mutex.h: Likewise.\n+\t* config/rtems/sem.c: Likewise.\n+\t* config/rtems/sem.h: Likewise.\n+\t* configure.ac (*-*-rtems*): Check that Newlib provides a proper\n+\t<sys/lock.h> header file.\n+\t* configure.tgt (*-*-rtems*): Enable RTEMS configuration if\n+\tsupported by Newlib.\n+\t* configure: Regenerate.\n+\n 2015-09-03  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* team.c (gomp_new_thread_pool): Delete and move content to ..."}, {"sha": "e5b3f76c5811a0e6ded1bd634c56cec0530064a2", "filename": "libgomp/config/rtems/bar.c", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fbar.c?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -0,0 +1,255 @@\n+/* Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+   Contributed by Sebastian Huber <sebastian.huber@embedded-brains.de>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the RTEMS implementation of a barrier synchronization\n+   mechanism for libgomp.  It is identical to the Linux implementation, except\n+   that the futex API is slightly different.  This type is private to the\n+   library.  */\n+\n+#include \"libgomp.h\"\n+#include \"bar.h\"\n+#include <limits.h>\n+\n+static gomp_barrier_t *\n+generation_to_barrier (int *addr)\n+{\n+  return (gomp_barrier_t *)\n+\t ((char *) addr - __builtin_offsetof (gomp_barrier_t, generation));\n+}\n+\n+static void\n+futex_wait (int *addr, int val)\n+{\n+  gomp_barrier_t *bar = generation_to_barrier (addr);\n+  _Futex_Wait (&bar->futex, addr, val);\n+}\n+\n+static void\n+futex_wake (int *addr, int count)\n+{\n+  gomp_barrier_t *bar = generation_to_barrier (addr);\n+  _Futex_Wake (&bar->futex, count);\n+}\n+\n+static int\n+do_spin (int *addr, int val)\n+{\n+  unsigned long long i, count = gomp_spin_count_var;\n+\n+  if (__builtin_expect (gomp_managed_threads > gomp_available_cpus, 0))\n+    count = gomp_throttled_spin_count_var;\n+  for (i = 0; i < count; i++)\n+    if (__builtin_expect (__atomic_load_n (addr, MEMMODEL_RELAXED) != val, 0))\n+      return 0;\n+  return 1;\n+}\n+\n+static void\n+do_wait (int *addr, int val)\n+{\n+  if (do_spin (addr, val))\n+    futex_wait (addr, val);\n+}\n+\n+/* Everything below this point should be identical to the Linux\n+   implementation.  */\n+\n+void\n+gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      bar->awaited = bar->total;\n+      __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n+\t\t\tMEMMODEL_RELEASE);\n+      futex_wake ((int *) &bar->generation, INT_MAX);\n+    }\n+  else\n+    {\n+      do\n+\tdo_wait ((int *) &bar->generation, state);\n+      while (__atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE) == state);\n+    }\n+}\n+\n+void\n+gomp_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+/* Like gomp_barrier_wait, except that if the encountering thread\n+   is not the last one to hit the barrier, it returns immediately.\n+   The intended usage is that a thread which intends to gomp_barrier_destroy\n+   this barrier calls gomp_barrier_wait, while all other threads\n+   call gomp_barrier_wait_last.  When gomp_barrier_wait returns,\n+   the barrier can be safely destroyed.  */\n+\n+void\n+gomp_barrier_wait_last (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_start (bar);\n+  if (state & BAR_WAS_LAST)\n+    gomp_barrier_wait_end (bar, state);\n+}\n+\n+void\n+gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n+{\n+  futex_wake ((int *) &bar->generation, count == 0 ? INT_MAX : count);\n+}\n+\n+void\n+gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state &= ~BAR_CANCELLED;\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n+\t  futex_wake ((int *) &bar->generation, INT_MAX);\n+\t  return;\n+\t}\n+    }\n+\n+  generation = state;\n+  state &= ~BAR_CANCELLED;\n+  do\n+    {\n+      do_wait ((int *) &bar->generation, generation);\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+}\n+\n+void\n+gomp_team_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_wait_final (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_final_start (bar);\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    bar->awaited_final = bar->total;\n+  gomp_team_barrier_wait_end (bar, state);\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n+\t\t\t\t   gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      /* BAR_CANCELLED should never be set in state here, because\n+\t cancellation means that at least one of the threads has been\n+\t cancelled, thus on a cancellable barrier we should never see\n+\t all threads to arrive.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n+\t  futex_wake ((int *) &bar->generation, INT_MAX);\n+\t  return false;\n+\t}\n+    }\n+\n+  if (__builtin_expect (state & BAR_CANCELLED, 0))\n+    return true;\n+\n+  generation = state;\n+  do\n+    {\n+      do_wait ((int *) &bar->generation, generation);\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+      if (__builtin_expect (gen & BAR_CANCELLED, 0))\n+\treturn true;\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+\n+  return false;\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)\n+{\n+  return gomp_team_barrier_wait_cancel_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_cancel (struct gomp_team *team)\n+{\n+  gomp_mutex_lock (&team->task_lock);\n+  if (team->barrier.generation & BAR_CANCELLED)\n+    {\n+      gomp_mutex_unlock (&team->task_lock);\n+      return;\n+    }\n+  team->barrier.generation |= BAR_CANCELLED;\n+  gomp_mutex_unlock (&team->task_lock);\n+  futex_wake ((int *) &team->barrier.generation, INT_MAX);\n+}"}, {"sha": "c85dce3c86e48c7176cd060bbe83ed1a537207b5", "filename": "libgomp/config/rtems/bar.h", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fbar.h?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -0,0 +1,170 @@\n+/* Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+   Contributed by Sebastian Huber <sebastian.huber@embedded-brains.de>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the RTEMS implementation of a barrier synchronization\n+   mechanism for libgomp.  It is identical to the Linux implementation, except\n+   that the futex API is slightly different.  This type is private to the\n+   library.  */\n+\n+#ifndef GOMP_BARRIER_H\n+#define GOMP_BARRIER_H 1\n+\n+#include <sys/lock.h>\n+\n+typedef struct\n+{\n+  /* Make sure total/generation is in a mostly read cacheline, while\n+     awaited in a separate cacheline.  */\n+  unsigned total __attribute__((aligned (64)));\n+  unsigned generation;\n+  struct _Futex_Control futex;\n+  unsigned awaited __attribute__((aligned (64)));\n+  unsigned awaited_final;\n+} gomp_barrier_t;\n+\n+typedef unsigned int gomp_barrier_state_t;\n+\n+/* The generation field contains a counter in the high bits, with a few\n+   low bits dedicated to flags.  Note that TASK_PENDING and WAS_LAST can\n+   share space because WAS_LAST is never stored back to generation.  */\n+#define BAR_TASK_PENDING\t1\n+#define BAR_WAS_LAST\t\t1\n+#define BAR_WAITING_FOR_TASK\t2\n+#define BAR_CANCELLED\t\t4\n+#define BAR_INCR\t\t8\n+\n+static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n+{\n+  bar->total = count;\n+  bar->awaited = count;\n+  bar->awaited_final = count;\n+  bar->generation = 0;\n+  _Futex_Initialize (&bar->futex);\n+}\n+\n+static inline void gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n+{\n+  __atomic_add_fetch (&bar->awaited, count - bar->total, MEMMODEL_ACQ_REL);\n+  bar->total = count;\n+}\n+\n+static inline void gomp_barrier_destroy (gomp_barrier_t *bar)\n+{\n+}\n+\n+extern void gomp_barrier_wait (gomp_barrier_t *);\n+extern void gomp_barrier_wait_last (gomp_barrier_t *);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n+extern void gomp_team_barrier_wait (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_final (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n+\t\t\t\t\tgomp_barrier_state_t);\n+extern bool gomp_team_barrier_wait_cancel (gomp_barrier_t *);\n+extern bool gomp_team_barrier_wait_cancel_end (gomp_barrier_t *,\n+\t\t\t\t\t       gomp_barrier_state_t);\n+extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n+struct gomp_team;\n+extern void gomp_team_barrier_cancel (struct gomp_team *);\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* A memory barrier is needed before exiting from the various forms\n+     of gomp_barrier_wait, to satisfy OpenMP API version 3.1 section\n+     2.8.6 flush Construct, which says there is an implicit flush during\n+     a barrier region.  This is a convenient place to add the barrier,\n+     so we use MEMMODEL_ACQ_REL here rather than MEMMODEL_ACQUIRE.  */\n+  if (__atomic_add_fetch (&bar->awaited, -1, MEMMODEL_ACQ_REL) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_cancel_start (gomp_barrier_t *bar)\n+{\n+  return gomp_barrier_wait_start (bar);\n+}\n+\n+/* This is like gomp_barrier_wait_start, except it decrements\n+   bar->awaited_final rather than bar->awaited and should be used\n+   for the gomp_team_end barrier only.  */\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_final_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* See above gomp_barrier_wait_start comment.  */\n+  if (__atomic_add_fetch (&bar->awaited_final, -1, MEMMODEL_ACQ_REL) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline bool\n+gomp_barrier_last_thread (gomp_barrier_state_t state)\n+{\n+  return state & BAR_WAS_LAST;\n+}\n+\n+/* All the inlines below must be called with team->task_lock\n+   held.  */\n+\n+static inline void\n+gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation |= BAR_TASK_PENDING;\n+}\n+\n+static inline void\n+gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation &= ~BAR_TASK_PENDING;\n+}\n+\n+static inline void\n+gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  bar->generation |= BAR_WAITING_FOR_TASK;\n+}\n+\n+static inline bool\n+gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  return (bar->generation & BAR_WAITING_FOR_TASK) != 0;\n+}\n+\n+static inline bool\n+gomp_team_barrier_cancelled (gomp_barrier_t *bar)\n+{\n+  return __builtin_expect ((bar->generation & BAR_CANCELLED) != 0, 0);\n+}\n+\n+static inline void\n+gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  bar->generation = (state & -BAR_INCR) + BAR_INCR;\n+}\n+\n+#endif /* GOMP_BARRIER_H */"}, {"sha": "39bb64da0f90aa4acbb6dd9fd2e96bbf90bc6e85", "filename": "libgomp/config/rtems/mutex.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fmutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fmutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fmutex.c?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -0,0 +1 @@\n+/* Everything is in the header.  */"}, {"sha": "39901ee93bb413769085e21db6b60ad7705122a1", "filename": "libgomp/config/rtems/mutex.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fmutex.h?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Sebastian Huber <sebastian.huber@embedded-brains.de>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the RTEMS implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  */\n+\n+#ifndef GOMP_MUTEX_H\n+#define GOMP_MUTEX_H 1\n+\n+#include <sys/lock.h>\n+\n+typedef struct _Mutex_Control gomp_mutex_t;\n+\n+#define GOMP_MUTEX_INIT_0 1\n+\n+static inline void gomp_mutex_init (gomp_mutex_t *mutex)\n+{\n+  _Mutex_Initialize (mutex);\n+}\n+\n+static inline void gomp_mutex_lock (gomp_mutex_t *mutex)\n+{\n+  _Mutex_Acquire (mutex);\n+}\n+\n+static inline void gomp_mutex_unlock (gomp_mutex_t *mutex)\n+{\n+  _Mutex_Release (mutex);\n+}\n+\n+static inline void gomp_mutex_destroy (gomp_mutex_t *mutex)\n+{\n+  _Mutex_Destroy (mutex);\n+}\n+\n+#endif /* GOMP_MUTEX_H */"}, {"sha": "39bb64da0f90aa4acbb6dd9fd2e96bbf90bc6e85", "filename": "libgomp/config/rtems/sem.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fsem.c?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -0,0 +1 @@\n+/* Everything is in the header.  */"}, {"sha": "0d6765b2ac7ac070e32d5df40c55c5e4ca701dd5", "filename": "libgomp/config/rtems/sem.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fsem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfig%2Frtems%2Fsem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Frtems%2Fsem.h?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -0,0 +1,55 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Sebastian Huber <sebastian.huber@embedded-brains.de>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the RTEMS implementation of a semaphore synchronization\n+   mechanism for libgomp.  This type is private to the library.  */\n+\n+#ifndef GOMP_SEM_H\n+#define GOMP_SEM_H 1\n+\n+#include <sys/lock.h>\n+\n+typedef struct _Semaphore_Control gomp_sem_t;\n+\n+static inline void gomp_sem_init (gomp_sem_t *sem, int value)\n+{\n+  _Semaphore_Initialize (sem, (unsigned int) value);\n+}\n+\n+static inline void gomp_sem_wait (gomp_sem_t *sem)\n+{\n+  _Semaphore_Wait (sem);\n+}\n+\n+static inline void gomp_sem_post (gomp_sem_t *sem)\n+{\n+  _Semaphore_Post (sem);\n+}\n+\n+static inline void gomp_sem_destroy (gomp_sem_t *sem)\n+{\n+  _Semaphore_Destroy (sem);\n+}\n+\n+#endif /* GOMP_SEM_H  */"}, {"sha": "74d4e822c9e426d77267dc0f5900d80bdf450f0a", "filename": "libgomp/configure", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -15340,6 +15340,23 @@ $as_echo \"#define HAVE_BROKEN_POSIX_SEMAPHORES 1\" >>confdefs.h\n     ;;\n esac\n \n+# RTEMS specific checks\n+case \"$host\" in\n+  *-*-rtems*)\n+    ac_fn_c_check_type \"$LINENO\" \"struct _Mutex_Control\" \"ac_cv_type_struct__Mutex_Control\" \"#include <sys/lock.h>\n+\"\n+if test \"x$ac_cv_type_struct__Mutex_Control\" = x\"\"yes; then :\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_STRUCT__MUTEX_CONTROL 1\n+_ACEOF\n+\n+\n+fi\n+\n+    ;;\n+esac\n+\n  # Check whether --enable-linux-futex was given.\n if test \"${enable_linux_futex+set}\" = set; then :\n   enableval=$enable_linux_futex;"}, {"sha": "2e41ca8aee53aa98c773bea1dbd4a21c8ffabc71", "filename": "libgomp/configure.ac", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -216,6 +216,13 @@ case \"$host\" in\n     ;;\n esac\n \n+# RTEMS specific checks\n+case \"$host\" in\n+  *-*-rtems*)\n+    AC_CHECK_TYPES([struct _Mutex_Control],[],[],[#include <sys/lock.h>])\n+    ;;\n+esac\n+\n GCC_LINUX_FUTEX(:)\n \n # Check for pthread_{,attr_}[sg]etaffinity_np."}, {"sha": "f2236aec1207ea11ca46e18b498249b41123f498", "filename": "libgomp/configure.tgt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c41b2e3e0cf6996ea2d49e0557814607fe2f59/libgomp%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.tgt?ref=13c41b2e3e0cf6996ea2d49e0557814607fe2f59", "patch": "@@ -153,6 +153,12 @@ case \"${target}\" in\n \n   nvptx*-*-*)\n \tconfig_path=\"nvptx\"\n+\n+  *-*-rtems*)\n+\t# Use self-contained synchronization objects if provided by Newlib\n+\tif test \"x$ac_cv_type_struct__Mutex_Control\" = xyes ; then\n+\t    config_path=\"rtems posix\"\n+\tfi\n \t;;\n \n   *)"}]}