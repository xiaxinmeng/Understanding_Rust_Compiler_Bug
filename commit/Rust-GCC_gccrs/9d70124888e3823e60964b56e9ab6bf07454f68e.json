{"sha": "9d70124888e3823e60964b56e9ab6bf07454f68e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ3MDEyNDg4OGUzODIzZTYwOTY0YjU2ZTlhYjZiZjA3NDU0ZjY4ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-04-01T17:48:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-04-01T17:48:35Z"}, "message": "haifa-sched.c (prune_ready_list): New function, broken out of schedule_block.\n\n\t* haifa-sched.c (prune_ready_list): New function, broken out of\n\tschedule_block.\n\t(schedule_block): Use it.\n\nFrom-SVN: r171845", "tree": {"sha": "edef32d79349bddad5d4f9ec8edf60d8f3ac7496", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edef32d79349bddad5d4f9ec8edf60d8f3ac7496"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d70124888e3823e60964b56e9ab6bf07454f68e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d70124888e3823e60964b56e9ab6bf07454f68e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d70124888e3823e60964b56e9ab6bf07454f68e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d70124888e3823e60964b56e9ab6bf07454f68e/comments", "author": null, "committer": null, "parents": [{"sha": "eabb8ea4a02d5149fb1d878d75df0265d3e070f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eabb8ea4a02d5149fb1d878d75df0265d3e070f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eabb8ea4a02d5149fb1d878d75df0265d3e070f5"}], "stats": {"total": 119, "additions": 72, "deletions": 47}, "files": [{"sha": "9ca1d953eafa178abc4478f05ca14a6bf0f00d37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d70124888e3823e60964b56e9ab6bf07454f68e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d70124888e3823e60964b56e9ab6bf07454f68e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d70124888e3823e60964b56e9ab6bf07454f68e", "patch": "@@ -32,6 +32,10 @@\n \t* sched-rgn.c (begin_schedule_ready): Remove second argument.\n \t(rgn_const_sched_info): Add NULL entry for the begin_move_insn field.\n \n+\t* haifa-sched.c (prune_ready_list): New function, broken out of\n+\tschedule_block.\n+\t(schedule_block): Use it.\n+\n 2011-04-01  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/spu/t-spu-elf (dp-bit.c): Use > instead of >>."}, {"sha": "d5cc860063465c82b3504e0e87cefe5d47803521", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d70124888e3823e60964b56e9ab6bf07454f68e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d70124888e3823e60964b56e9ab6bf07454f68e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=9d70124888e3823e60964b56e9ab6bf07454f68e", "patch": "@@ -2613,8 +2613,8 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \t    {\n \t      if (state_dead_lock_p (state)\n \t\t  || insn_finishes_cycle_p (insn))\n- \t\t/* We won't issue any more instructions in the next\n- \t\t   choice_state.  */\n+\t\t/* We won't issue any more instructions in the next\n+\t\t   choice_state.  */\n \t\ttop->rest = 0;\n \t      else\n \t\ttop->rest--;\n@@ -2862,6 +2862,52 @@ commit_schedule (rtx prev_head, rtx tail, basic_block *target_bb)\n   VEC_truncate (rtx, scheduled_insns, 0);\n }\n \n+/* Examine all insns on the ready list and queue those which can't be\n+   issued in this cycle.  TEMP_STATE is temporary scheduler state we\n+   can use as scratch space.  If FIRST_CYCLE_INSN_P is true, no insns\n+   have been issued for the current cycle, which means it is valid to\n+   issue an asm statement.  */\n+\n+static void\n+prune_ready_list (state_t temp_state, bool first_cycle_insn_p)\n+{\n+  int i;\n+\n+ restart:\n+  for (i = 0; i < ready.n_ready; i++)\n+    {\n+      rtx insn = ready_element (&ready, i);\n+      int cost = 0;\n+      const char *reason = \"resource conflict\";\n+\n+      if (recog_memoized (insn) < 0)\n+\t{\n+\t  if (!first_cycle_insn_p\n+\t      && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t  || asm_noperands (PATTERN (insn)) >= 0))\n+\t    cost = 1;\n+\t  reason = \"asm\";\n+\t}\n+      else if (flag_sched_pressure)\n+\tcost = 0;\n+      else\n+\t{\n+\t  memcpy (temp_state, curr_state, dfa_state_size);\n+\t  cost = state_transition (temp_state, insn);\n+\t  if (cost < 0)\n+\t    cost = 0;\n+\t  else if (cost == 0)\n+\t    cost = 1;\n+\t}\n+      if (cost >= 1)\n+\t{\n+\t  ready_remove (&ready, i);\n+\t  queue_insn (insn, cost, reason);\n+\t  goto restart;\n+\t}\n+    }\n+}\n+\n /* Use forward list scheduling to rearrange insns of block pointed to by\n    TARGET_BB, possibly bringing insns from subsequent blocks in the same\n    region.  */\n@@ -3013,6 +3059,10 @@ schedule_block (basic_block *target_bb)\n \t}\n       while (advance > 0);\n \n+      prune_ready_list (temp_state, true);\n+      if (ready.n_ready == 0)\n+        continue;\n+\n       if (sort_p)\n \t{\n \t  /* Sort the ready list based on priority.  */\n@@ -3143,44 +3193,6 @@ schedule_block (basic_block *target_bb)\n \t    }\n \n \t  sort_p = TRUE;\n-\t  memcpy (temp_state, curr_state, dfa_state_size);\n-\t  if (recog_memoized (insn) < 0)\n-\t    {\n-\t      asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT\n-\t\t       || asm_noperands (PATTERN (insn)) >= 0);\n-\t      if (!first_cycle_insn_p && asm_p)\n-\t\t/* This is asm insn which is tried to be issued on the\n-\t\t   cycle not first.  Issue it on the next cycle.  */\n-\t\tcost = 1;\n-\t      else\n-\t\t/* A USE insn, or something else we don't need to\n-\t\t   understand.  We can't pass these directly to\n-\t\t   state_transition because it will trigger a\n-\t\t   fatal error for unrecognizable insns.  */\n-\t\tcost = 0;\n-\t    }\n-\t  else if (sched_pressure_p)\n-\t    cost = 0;\n-\t  else\n-\t    {\n-\t      cost = state_transition (temp_state, insn);\n-\t      if (cost < 0)\n-\t\tcost = 0;\n-\t      else if (cost == 0)\n-\t\tcost = 1;\n-\t    }\n-\n-\t  if (cost >= 1)\n-\t    {\n-\t      queue_insn (insn, cost, \"resource conflict\");\n- \t      if (SCHED_GROUP_P (insn))\n- \t\t{\n- \t\t  advance = cost;\n- \t\t  break;\n- \t\t}\n-\n-\t      continue;\n-\t    }\n \n \t  if (current_sched_info->can_schedule_ready_p\n \t      && ! (*current_sched_info->can_schedule_ready_p) (insn))\n@@ -3201,14 +3213,20 @@ schedule_block (basic_block *target_bb)\n \n \t  /* Update counters, etc in the scheduler's front end.  */\n \t  (*current_sched_info->begin_schedule_ready) (insn);\n- \t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n+\t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n \t  last_scheduled_insn = insn;\n \n-\t  if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n-            {\n-              cycle_issued_insns++;\n-              memcpy (curr_state, temp_state, dfa_state_size);\n-            }\n+\t  if (recog_memoized (insn) >= 0)\n+\t    {\n+\t      cost = state_transition (curr_state, insn);\n+\t      if (!flag_sched_pressure)\n+\t\tgcc_assert (cost < 0);\n+\t      cycle_issued_insns++;\n+\t      asm_p = false;\n+\t    }\n+\t  else\n+\t    asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t     || asm_noperands (PATTERN (insn)) >= 0);\n \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n@@ -3229,6 +3247,9 @@ schedule_block (basic_block *target_bb)\n \n \t  first_cycle_insn_p = false;\n \n+\t  if (ready.n_ready > 0)\n+            prune_ready_list (temp_state, false);\n+\n \t  /* Sort the ready list based on priority.  This must be\n \t     redone here, as schedule_insn may have readied additional\n \t     insns that will not be sorted correctly.  */\n@@ -3240,7 +3261,7 @@ schedule_block (basic_block *target_bb)\n \t  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))\n \t      && (*current_sched_info->schedule_more_p) ())\n \t    {\n- \t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n+\t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n \t\t{\n \t\t  insn = ready_remove_first (&ready);\n \t\t  gcc_assert (DEBUG_INSN_P (insn));"}]}