{"sha": "813e0036174c9f5039f522a5e77269066b359aca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEzZTAwMzYxNzRjOWY1MDM5ZjUyMmE1ZTc3MjY5MDY2YjM1OWFjYQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2013-03-20T19:54:47Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-03-20T19:54:47Z"}, "message": "i386.md (*movoi_internal_avx): Emit insn template depending on type attribute.\n\n\t* config/i386/i386.md (*movoi_internal_avx): Emit insn template\n\tdepending on type attribute.\n\t(*movti_internal): Ditto.\n\t(*movtf_internal): Ditto.\n\t(*movxf_internal): Ditto.\n\t(*movdf_internal): Ditto.\n\t(*movsf_internal): Ditto.\n\nFrom-SVN: r196841", "tree": {"sha": "dc7b16a835a5a6a96ae22ca2775b6fef47af6b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc7b16a835a5a6a96ae22ca2775b6fef47af6b8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/813e0036174c9f5039f522a5e77269066b359aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/813e0036174c9f5039f522a5e77269066b359aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/813e0036174c9f5039f522a5e77269066b359aca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/813e0036174c9f5039f522a5e77269066b359aca/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7cf34aaeb6c4094633a7de9a117e5f0f252a0c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cf34aaeb6c4094633a7de9a117e5f0f252a0c08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cf34aaeb6c4094633a7de9a117e5f0f252a0c08"}], "stats": {"total": 180, "additions": 90, "deletions": 90}, "files": [{"sha": "2cd7169932aab5f4906225f5968f0bc4976ed81b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/813e0036174c9f5039f522a5e77269066b359aca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/813e0036174c9f5039f522a5e77269066b359aca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=813e0036174c9f5039f522a5e77269066b359aca", "patch": "@@ -1,3 +1,13 @@\n+2013-03-20  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*movoi_internal_avx): Emit insn template\n+\tdepending on type attribute.\n+\t(*movti_internal): Ditto.\n+\t(*movtf_internal): Ditto.\n+\t(*movxf_internal): Ditto.\n+\t(*movdf_internal): Ditto.\n+\t(*movsf_internal): Ditto.\n+\n 2013-03-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*movti_internal): Set prefix attribute to"}, {"sha": "2a2708ccaae1e023a7d12a6627cec848a40bcf77", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 80, "deletions": 90, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/813e0036174c9f5039f522a5e77269066b359aca/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/813e0036174c9f5039f522a5e77269066b359aca/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=813e0036174c9f5039f522a5e77269066b359aca", "patch": "@@ -1758,12 +1758,12 @@\n \t(match_operand:OI 1 \"vector_move_operand\"  \"C ,xm,x\"))]\n   \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n-  switch (which_alternative)\n+  switch (get_attr_type (insn))\n     {\n-    case 0:\n+    case TYPE_SSELOG1:\n       return standard_sse_constant_opcode (insn, operands[1]);\n-    case 1:\n-    case 2:\n+\n+    case TYPE_SSEMOV:\n       if (misaligned_operand (operands[0], OImode)\n \t  || misaligned_operand (operands[1], OImode))\n \t{\n@@ -1779,6 +1779,7 @@\n \t  else\n \t    return \"vmovdqa\\t{%1, %0|%0, %1}\";\n \t}\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -1800,15 +1801,15 @@\n   \"(TARGET_64BIT || TARGET_SSE)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n-  switch (which_alternative)\n+  switch (get_attr_type (insn))\n     {\n-    case 0:\n-    case 1:\n+    case TYPE_MULTI:\n       return \"#\";\n-    case 2:\n+\n+    case TYPE_SSELOG1:\n       return standard_sse_constant_opcode (insn, operands[1]);\n-    case 3:\n-    case 4:\n+\n+    case TYPE_SSEMOV:\n       /* TDmode values are passed as TImode on the stack.  Moving them\n \t to stack may result in unaligned memory access.  */\n       if (misaligned_operand (operands[0], TImode)\n@@ -1826,12 +1827,13 @@\n \t  else\n \t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n \t}\n+\n     default:\n       gcc_unreachable ();\n     }\n }\n   [(set_attr \"isa\" \"x64,x64,*,*,*\")\n-   (set_attr \"type\" \"*,*,sselog1,ssemov,ssemov\")\n+   (set_attr \"type\" \"multi,multi,sselog1,ssemov,ssemov\")\n    (set (attr \"prefix\")\n      (if_then_else (eq_attr \"type\" \"sselog1,ssemov\")\n        (const_string \"maybe_vex\")\n@@ -1914,7 +1916,7 @@\n     case TYPE_LEA:\n       return \"lea{q}\\t{%E1, %0|%0, %E1}\";\n \n-    default:\n+    case TYPE_IMOV:\n       gcc_assert (!flag_pic || LEGITIMATE_PIC_OPERAND_P (operands[1]));\n       if (get_attr_mode (insn) == MODE_SI)\n \treturn \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n@@ -1924,6 +1926,9 @@\n \treturn \"lea{q}\\t{%E1, %0|%0, %E1}\";\n       else\n \treturn \"mov{q}\\t{%1, %0|%0, %1}\";\n+\n+    default:\n+      gcc_unreachable ();\n     }\n }\n   [(set (attr \"isa\")\n@@ -2018,14 +2023,18 @@\n     case TYPE_SSEMOV:\n       switch (get_attr_mode (insn))\n \t{\n+\tcase MODE_SI:\n+          return \"%vmovd\\t{%1, %0|%0, %1}\";\n \tcase MODE_TI:\n \t  return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\n \tcase MODE_V4SF:\n \t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\tcase MODE_SI:\n-          return \"%vmovd\\t{%1, %0|%0, %1}\";\n+\n \tcase MODE_SF:\n-          return \"%vmovss\\t{%1, %0|%0, %1}\";\n+\t  gcc_assert (!TARGET_AVX);\n+          return \"movss\\t{%1, %0|%0, %1}\";\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -2041,12 +2050,15 @@\n     case TYPE_LEA:\n       return \"lea{l}\\t{%E1, %0|%0, %E1}\";\n \n-    default:\n+    case TYPE_IMOV:\n       gcc_assert (!flag_pic || LEGITIMATE_PIC_OPERAND_P (operands[1]));\n       if (ix86_use_lea_for_mov (insn, operands))\n \treturn \"lea{l}\\t{%E1, %0|%0, %E1}\";\n       else\n \treturn \"mov{l}\\t{%1, %0|%0, %1}\";\n+\n+    default:\n+      gcc_unreachable ();\n     }\n }\n   [(set (attr \"type\")\n@@ -2631,12 +2643,12 @@\n        || (!TARGET_MEMORY_MISMATCH_STALL\n \t   && memory_operand (operands[0], TFmode)))\"\n {\n-  switch (which_alternative)\n+  switch (get_attr_type (insn))\n     {\n-    case 0:\n+    case TYPE_SSELOG1:\n       return standard_sse_constant_opcode (insn, operands[1]);\n-    case 1:\n-    case 2:\n+\n+    case TYPE_SSEMOV:\n       /* Handle misaligned load/store since we\n          don't have movmisaligntf pattern. */\n       if (misaligned_operand (operands[0], TFmode)\n@@ -2655,16 +2667,15 @@\n \t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n \t}\n \n-    case 3:\n-    case 4:\n+    case TYPE_MULTI:\n \treturn \"#\";\n \n     default:\n       gcc_unreachable ();\n     }\n }\n   [(set_attr \"isa\" \"*,*,*,x64,x64\")\n-   (set_attr \"type\" \"sselog1,ssemov,ssemov,*,*\")\n+   (set_attr \"type\" \"sselog1,ssemov,ssemov,multi,multi\")\n    (set (attr \"prefix\")\n      (if_then_else (eq_attr \"type\" \"sselog1,ssemov\")\n        (const_string \"maybe_vex\")\n@@ -2701,18 +2712,14 @@\n        || (!TARGET_MEMORY_MISMATCH_STALL\n \t   && memory_operand (operands[0], XFmode)))\"\n {\n-  switch (which_alternative)\n+  switch (get_attr_type (insn))\n     {\n-    case 0:\n-    case 1:\n+    case TYPE_FMOV:\n+      if (which_alternative == 2)\n+        return standard_80387_constant_opcode (operands[1]);\n       return output_387_reg_move (insn, operands);\n \n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n-    case 5:\n+    case TYPE_MULTI:\n       return \"#\";\n \n     default:\n@@ -2748,57 +2755,46 @@\n        || ((TARGET_64BIT || !TARGET_MEMORY_MISMATCH_STALL)\n \t   && memory_operand (operands[0], DFmode)))\"\n {\n-  switch (which_alternative)\n+  switch (get_attr_type (insn))\n     {\n-    case 0:\n-    case 1:\n+    case TYPE_FMOV:\n+      if (which_alternative == 2)\n+        return standard_80387_constant_opcode (operands[1]);\n       return output_387_reg_move (insn, operands);\n \n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n+    case TYPE_MULTI:\n       return \"#\";\n \n-    case 5:\n-    case 6:\n-      return \"mov{q}\\t{%1, %0|%0, %1}\";\n-\n-    case 7:\n-      return \"mov{l}\\t{%1, %k0|%k0, %1}\";\n-\n-    case 8:\n-      return \"movabs{q}\\t{%1, %0|%0, %1}\";\n+    case TYPE_IMOV:\n+      if (get_attr_mode (insn) == MODE_SI)\n+\treturn \"mov{l}\\t{%1, %k0|%k0, %1}\";\n+      else if (which_alternative == 8)\n+\treturn \"movabs{q}\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"mov{q}\\t{%1, %0|%0, %1}\";\n \n-    case 9:\n-    case 13:\n+    case TYPE_SSELOG1:\n       return standard_sse_constant_opcode (insn, operands[1]);\n \n-    case 10:\n-    case 11:\n-    case 12:\n-    case 14:\n-    case 15:\n-    case 16:\n-    case 17:\n-    case 18:\n+    case TYPE_SSEMOV:\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_DF:\n \t  if (TARGET_AVX && REG_P (operands[0]) && REG_P (operands[1]))\n \t    return \"vmovsd\\t{%1, %0, %0|%0, %0, %1}\";\n \t  return \"%vmovsd\\t{%1, %0|%0, %1}\";\n \n-\tcase MODE_V1DF:\n-\t  return \"%vmovlpd\\t{%1, %d0|%d0, %1}\";\n+\tcase MODE_V4SF:\n+\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \tcase MODE_V2DF:\n \t  return \"%vmovapd\\t{%1, %0|%0, %1}\";\n+\n \tcase MODE_V2SF:\n \t  gcc_assert (!TARGET_AVX);\n \t  return \"movlps\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V4SF:\n-\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\tcase MODE_V1DF:\n+\t  gcc_assert (!TARGET_AVX);\n+\t  return \"movlpd\\t{%1, %0|%0, %1}\";\n \n \tcase MODE_DI:\n \t  /* Handle broken assemblers that require movd instead of movq.  */\n@@ -2858,7 +2854,7 @@\n \t       (eq_attr \"alternative\" \"5,6,8,17,18\")\n \t\t (const_string \"DI\")\n \n-\t       /* xorps is one byte shorter for !TARGET_AVX.  */\n+\t       /* xorps is one byte shorter for non-AVX targets.  */\n \t       (eq_attr \"alternative\" \"9,13\")\n \t\t (cond [(not (match_test \"TARGET_SSE2\"))\n \t\t \t  (const_string \"V4SF\")\n@@ -2872,10 +2868,10 @@\n \t\t       (const_string \"V2DF\"))\n \n \t       /* For architectures resolving dependencies on\n-\t\t  whole SSE registers use APD move to break dependency\n-\t\t  chains, otherwise use short move to avoid extra work.\n+\t\t  whole SSE registers use movapd to break dependency\n+\t\t  chains, otherwise use short move to avoid extra work.  */\n \n-\t\t  movaps encodes one byte shorter for !TARGET_AVX.  */\n+\t       /* movaps is one byte shorter for non-AVX targets.  */\n \t       (eq_attr \"alternative\" \"10,14\")\n \t\t (cond [(ior (not (match_test \"TARGET_SSE2\"))\n \t\t\t     (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n@@ -2895,6 +2891,8 @@\n \t       (eq_attr \"alternative\" \"11,15\")\n \t\t (cond [(not (match_test \"TARGET_SSE2\"))\n \t\t\t  (const_string \"V2SF\")\n+\t\t\t(match_test \"TARGET_AVX\")\n+\t\t\t  (const_string \"DF\")\n \t\t\t(match_test \"TARGET_SSE_SPLIT_REGS\")\n \t\t\t  (const_string \"V1DF\")\n \t\t       ]\n@@ -2922,46 +2920,38 @@\n \t\t   && standard_sse_constant_p (operands[1]))))\n        || memory_operand (operands[0], SFmode))\"\n {\n-  switch (which_alternative)\n+  switch (get_attr_type (insn))\n     {\n-    case 0:\n-    case 1:\n+    case TYPE_FMOV:\n+      if (which_alternative == 2)\n+        return standard_80387_constant_opcode (operands[1]);\n       return output_387_reg_move (insn, operands);\n \n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n+    case TYPE_IMOV:\n       return \"mov{l}\\t{%1, %0|%0, %1}\";\n \n-    case 5:\n+    case TYPE_SSELOG1:\n       return standard_sse_constant_opcode (insn, operands[1]);\n \n-    case 6:\n-    case 7:\n-    case 8:\n+    case TYPE_SSEMOV:\n       switch (get_attr_mode (insn))\n \t{\n-\tcase MODE_V4SF:\n-\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \tcase MODE_SF:\n \t  if (TARGET_AVX && REG_P (operands[0]) && REG_P (operands[1]))\n \t    return \"vmovss\\t{%1, %0, %0|%0, %0, %1}\";\n \t  return \"%vmovss\\t{%1, %0|%0, %1}\";\n+\n+\tcase MODE_V4SF:\n+\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\n+\tcase MODE_SI:\n+\t  return \"%vmovd\\t{%1, %0|%0, %1}\";\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-    case 9:\n-    case 10:\n-      return \"%vmovd\\t{%1, %0|%0, %1}\";\n-\n-    case 11:\n-    case 12:\n-    case 13:\n-    case 14:\n-    case 15:\n+    case TYPE_MMXMOV:\n       if (get_attr_mode (insn) == MODE_DI)\n \treturn \"movq\\t{%1, %0|%0, %1}\";\n       return \"movd\\t{%1, %0|%0, %1}\";"}]}