{"sha": "e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmNjk2MTQyNTRiOWRmMjg3NWM5M2VkNGQ3Y2U1ZWVkMWE1NGM2Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-15T14:51:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-15T14:51:00Z"}, "message": "[multiple changes]\n\n2004-03-15  Jerome Guitton  <guitton@act-europe.fr>\n\n\t* 3zsoccon.ads: Fix multicast options.\n\n\t* s-thread.ads: Move unchecked conversion from ATSD_Access to Address\n\tin the spec.\n\n2004-03-15  Robert Dewar  <dewar@gnat.com>\n\n\t* sem_prag.adb: Make sure No_Strict_Aliasing flag is set right when\n\tpragma used for a private type.\n\n\t* lib-xref.adb (Generate_Reference): Do not generate warning if\n\treference is in a different unit from the pragma Unreferenced.\n\n\t* 5vtpopde.adb: Minor reformatting\n\tFix casing of To_Task_ID\n\n\t* sem_ch13.adb (Validate_Unchecked_Conversion): Set No_Strict_Aliasing\n\tflag if we have an unchecked conversion to an access type in the same\n\tunit.\n\n2004-03-15  Geert Bosch  <bosch@gnat.com>\n\n\t* a-ngcoty.adb (Modulus): In alternate formula for large real or\n\timaginary parts, use Double precision throughout.\n\n\t* a-tifiio.adb (Put_Scaled): Remove remaining pragma Debug. Not only\n\twe want to be able to compile run-time with -gnata for testing, but\n\tthis may also be instantiated in user code that is compiled with -gnata.\n\n2004-03-15  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* s-stalib.ads (Exception_Code): New type, to represent Import/Export\n\tcodes. Having a separate type for this is useful to enforce consistency\n\tthroughout the various run-time units.\n\t(Exception_Data): Use Exception_Code for Import_Code.\n\n\t* s-vmextra.ads, s-vmexta.adb: Use Exception_Code instead of a mix of\n\tNatural and Integer in various places.\n\t(Register_VMS_Exception): Use Base_Code_In to compute the exception code\n\twith the severity bits masked off.\n\t(Register_VMS_Exception): Handle the additional exception data pointer\n\targument.\n\n\t* raise.c (_GNAT_Exception structure): Remove the handled_by_others\n\tcomponent, now reflected by an exported accessor.\n\t(is_handled_by): New routine to compute whether the propagated\n\toccurrence matches some handler choice specification. Extracted out of\n\tget_action_description_for, and expanded to take care of the VMS\n\tspecifities.\n\t(get_action_description_for): Use is_handled_by instead of an explicit\n\tcomplex condition to decide if the current choice at hand catches the\n\tpropagated occurrence.\n\n\t* raise.h (Exception_Code): New type for C.\n\n\t* rtsfind.ads (RE_Id, RE_Unit_Table): Add\n\tSystem.Standard_Library.Exception_Code, to allow references from the\n\tpragma import/export expander.\n\n\t* a-exexpr.adb (Is_Handled_By_Others, Language_For, Import_Code_For):\n\tNew accessors to allow easy access to GNAT exception data\n\tcharacteristics.\n\t(GNAT_GCC_Exception record, Propagate_Exception): Get rid of the\n\tredundant Handled_By_Others component, helper for the personality\n\troutine which will now be able to call the appropriate exception data\n\taccessor instead.\n\n\t* cstand.adb (Create_Standard): Adjust the type of the Import_Code\n\tcomponent of Standard_Exception_Type to be the closest possible to\n\tException_Code in System.Standard_Library, that we cannot get at this\n\tpoint. Expand a ??? comment to notify that this type node should\n\tprobably be rewritten later on.\n\n\t* exp_prag.adb (Expand_Pragma_Import_Export_Exception): Adjust the\n\tregistration call to include a pointer to the exception object in the\n\targuments.\n\n\t* init.c (__gnat_error_handler): Use Exception_Code and Base_Code_In\n\tinstead of int and explicit bitmasks.\n\n2004-03-15  Vincent Celier  <celier@gnat.com>\n\n\t* vms_data.ads: Add new GNAT BIND qualifier /STATIC. Makes /NOSHARED\n\tequivalent to /STATIC and /NOSTATIC equivalent to /SHARED.\n\n\t* a-tasatt.adb (To_Access_Code): Remove this UC instantiation, no\n\tlonger needed now that it is in the spec of\n\tSystem.Tasking.Task_Attributes.\n\n\t* adaint.h, adaint.c: (__gnat_create_output_file): New function\n\n\t* gnatcmd.adb: Fix bug introduced in previous rev: /= instead of =\n\n\t* g-os_lib.ads, g-os_lib.adb (Create_Output_Text_File): New function.\n\n\t* make.adb (Gnatmake): Do not check the executable suffix; it is being\n\ttaken care of in Scan_Make_Arg.\n\t(Scan_Make_Arg): Add the executable suffix only if the argument\n\tfollowing -o, in canonical case, does not end with the executable\n\tsuffix.  When in verbose mode and executable file name does not end\n\twith executable suffix, output the executable name, in canonical case.\n\n\t* s-tataat.ads (Access_Dummy_Wrapper): Add pragma No_Strict_Aliasing\n\tto avoid warnings when instantiating Ada.Task_Attributes.\n\tMinor reformating.\n\n\t* mlib-prj.adb (Process_Imported_Libraries): Get the imported libraries\n\tin the correct order.\n\n\t* prj-makr.adb (Process_Directory): No longer use GNAT.Expect, but\n\tredirect standard output and error to a file for the invocation of the\n\tcompiler, then read the file.\n\n\t* prj-nmsc.adb (Find_Sources): Use the Display_Value for each\n\tdirectory, instead of the Value.\n\t(Find_Source_Dirs): Remove useless code & comments.\n\n2004-03-15  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_ch3.adb (Freeze_Record_Type): If a primitive operation of a\n\ttagged type is inherited, and the parent operation is not frozen yet,\n\tforce generation of a freeze node for the inherited operation, so the\n\tcorresponding dispatch entry is properly initialized.\n\t(Make_Predefined_Primitive_Specs): Check that return type is Boolean\n\twhen looking for user-defined equality operation.\n\n\t* exp_ch4.adb (Expand_Composite_Equality): Check that return type is\n\tboolean when locating primitive equality of tagged component.\n\n\t* exp_ch5.adb (Expand_Assign_Array): If the left-hand side is a\n\tbit-aligned field and the right-hand side a string literal, introduce\n\ta temporary before expanding assignment into a loop.\n\n\t* exp_ch9.adb (Expand_N_Task_Type_Declaration): Copy expression for\n\tpriority in full, to ensure that any expanded subepxressions of it are\n\telaborated in the scope of the init_proc.\n\n\t* exp_prag.adb (Expand_Pragma_Import): Search for initialization call\n\tafter object declaration, skipping over code that may have been\n\tgenerated for validity checks.\n\n\t* sem_ch12.adb (Validate_Private_Type_Instance): If type has unknown\n\tdiscriminants, ignore the known discriminants of its full view, if\n\tany, to check legality.\n\n\t* sem_ch3.adb (Complete_Private_Subtype): Do not create constrained\n\tcomponent if type has unknown discriminants.\n\t(Analyze_Private_Extension_Declaration): Discriminant constraint is\n\tnull if type has unknown discriminants.\n\n\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body): Generate reference\n\tfor end label when present.\n\n\t* s-fileio.adb (Open): When called with a C_Stream, use given name for\n\ttemporary file, rather than an empty string.\n\n2004-03-15  Ed Falis  <falis@gnat.com>\n\n\t* s-thread.adb: Removed, no longer used.\n\n2004-03-15  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* decl.c (target.h): Now include.\n\t(gnat_to_gnu_entity, case E_Access_Type): Use mode derived from ESIZE\n\tin new build_pointer_from_mode calls for non-fat/non-thin pointer.\n\t(validate_size): For POINTER_TYPE, get smallest size permitted on\n\tmachine.\n\n\t* fe.h: Sort Einfo decls and add Set_Mechanism.\n\n\t* Makefile.in: (LIBGNAT_SRCS): Remove types.h.\n\t(ada/decl.o): Depends on target.h.\n\n\t* trans.c (tree_transform, N_Unchecked_Type_Conversion): Do not use\n\tFUNCTION_BOUNDARY; always use TYPE_ALIGN.\n\n2004-03-15  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* 5ztpopsp.adb, 56tpopsp.adb: Fix spelling of Task_ID.\n\n\t* exp_ch4.adb (Expand_N_Indexed_Component): Do not call\n\tInsert_Dereference_Action when rewriting an implicit dereference into\n\tan explicit one, this will be taken care of during expansion of the\n\texplicit dereference.\n\t(Expand_N_Slice): Same. Always do the rewriting, even for the case\n\tof non-packed slices, since the dereference action generated by\n\texpansion of the explicit dereference is needed in any case.\n\t(Expand_N_Selected_Component): When rewriting an implicit dereference,\n\tanalyze and resolve the rewritten explicit dereference so it is seen\n\tby the expander.\n\t(Insert_Dereference_Action): This procedure is now called only for the\n\texpansion of an N_Explcit_Dereference_Node. Do insert a check even for\n\tdereferences that do not come from source (including explicit\n\tdereferences resulting from rewriting implicit ones), but do not\n\trecursively insert a check for the dereference nodes contained within\n\tthe check.\n\t(Insert_Dereference_Action): Clarify and correct comment.\n\nFrom-SVN: r79494", "tree": {"sha": "9642fc9a4af512f1f2cbf83169b8cce469d192b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9642fc9a4af512f1f2cbf83169b8cce469d192b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/comments", "author": null, "committer": null, "parents": [{"sha": "0bb1600af12451af5f158fc058c35ea02ecd80fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb1600af12451af5f158fc058c35ea02ecd80fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb1600af12451af5f158fc058c35ea02ecd80fb"}], "stats": {"total": 1463, "additions": 991, "deletions": 472}, "files": [{"sha": "27dcb0c7a9efd4ed3aef6e3ffac3140d4c4a00f2", "filename": "gcc/ada/3zsoccon.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F3zsoccon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F3zsoccon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F3zsoccon.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -150,9 +150,9 @@ package GNAT.Sockets.Constants is\n    SO_LINGER          : constant :=          128; --  Defer close to flush data\n    SO_ERROR           : constant :=         4103; --  Get/clear error status\n    SO_BROADCAST       : constant :=           32; --  Can send broadcast msgs\n-   IP_ADD_MEMBERSHIP  : constant :=           35; --  Join a multicast group\n-   IP_DROP_MEMBERSHIP : constant :=           36; --  Leave a multicast group\n-   IP_MULTICAST_TTL   : constant :=           33; --  Set/get multicast TTL\n-   IP_MULTICAST_LOOP  : constant :=           34; --  Set/get mcast loopback\n+   IP_ADD_MEMBERSHIP  : constant :=           12; --  Join a multicast group\n+   IP_DROP_MEMBERSHIP : constant :=           13; --  Leave a multicast group\n+   IP_MULTICAST_TTL   : constant :=           10; --  Set/get multicast TTL\n+   IP_MULTICAST_LOOP  : constant :=           11; --  Set/get mcast loopback\n \n end GNAT.Sockets.Constants;"}, {"sha": "2673d0e30b677267329af00a7c2f22b8723ccadc", "filename": "gcc/ada/56tpopsp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F56tpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F56tpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F56tpopsp.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -104,7 +104,7 @@ package body Specific is\n       --  If the key value is Null, then it is a non-Ada task.\n \n       if Value /= System.Null_Address then\n-         return To_Task_Id (Value);\n+         return To_Task_ID (Value);\n       else\n          return Register_Foreign_Thread;\n       end if;"}, {"sha": "001507a07a2a4915be9da630d7206deee9d7bc95", "filename": "gcc/ada/5vtpopde.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F5vtpopde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F5vtpopde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtpopde.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---           Copyright (C) 2000-2003 Free Software Foundation, Inc.         --\n+--           Copyright (C) 2000-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -84,8 +84,7 @@ package body System.Task_Primitives.Operations.DEC is\n \n    procedure Interrupt_AST_Handler (ID : Address) is\n       Result      : Interfaces.C.int;\n-      AST_Self_ID : Task_ID := To_Task_Id (ID);\n-\n+      AST_Self_ID : Task_ID := To_Task_ID (ID);\n    begin\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -122,8 +121,7 @@ package body System.Task_Primitives.Operations.DEC is\n \n    procedure Starlet_AST_Handler (ID : Address) is\n       Result      : Interfaces.C.int;\n-      AST_Self_ID : Task_ID := To_Task_Id (ID);\n-\n+      AST_Self_ID : Task_ID := To_Task_ID (ID);\n    begin\n       AST_Self_ID.Common.LL.AST_Pending := False;\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n@@ -136,6 +134,7 @@ package body System.Task_Primitives.Operations.DEC is\n \n    procedure Task_Synch is\n       Synch_Self_ID : constant Task_ID := Self;\n+\n    begin\n       if Single_Lock then\n          Lock_RTS;"}, {"sha": "02983287d2c7b14812f15c88fd6043596b83b300", "filename": "gcc/ada/5ztpopsp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F5ztpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2F5ztpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ztpopsp.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,7 +68,7 @@ package body Specific is\n \n    function Self return Task_ID is\n    begin\n-      return To_Task_Id (ATCB_Key);\n+      return To_Task_ID (ATCB_Key);\n    end Self;\n \n end Specific;"}, {"sha": "1b923c69e192395119e5e3ab0f84ae25c293b229", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1,3 +1,203 @@\n+2004-03-15  Jerome Guitton  <guitton@act-europe.fr>\n+\n+\t* 3zsoccon.ads: Fix multicast options.\n+\n+\t* s-thread.ads: Move unchecked conversion from ATSD_Access to Address\n+\tin the spec.\n+\n+2004-03-15  Robert Dewar  <dewar@gnat.com>\n+\n+\t* sem_prag.adb: Make sure No_Strict_Aliasing flag is set right when\n+\tpragma used for a private type.\n+\n+\t* lib-xref.adb (Generate_Reference): Do not generate warning if\n+\treference is in a different unit from the pragma Unreferenced.\n+\n+\t* 5vtpopde.adb: Minor reformatting\n+\tFix casing of To_Task_ID\n+\n+\t* sem_ch13.adb (Validate_Unchecked_Conversion): Set No_Strict_Aliasing\n+\tflag if we have an unchecked conversion to an access type in the same\n+\tunit.\n+\n+2004-03-15  Geert Bosch  <bosch@gnat.com>\n+\n+\t* a-ngcoty.adb (Modulus): In alternate formula for large real or\n+\timaginary parts, use Double precision throughout.\n+\n+\t* a-tifiio.adb (Put_Scaled): Remove remaining pragma Debug. Not only\n+\twe want to be able to compile run-time with -gnata for testing, but\n+\tthis may also be instantiated in user code that is compiled with -gnata.\n+\n+2004-03-15  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* s-stalib.ads (Exception_Code): New type, to represent Import/Export\n+\tcodes. Having a separate type for this is useful to enforce consistency\n+\tthroughout the various run-time units.\n+\t(Exception_Data): Use Exception_Code for Import_Code.\n+\n+\t* s-vmextra.ads, s-vmexta.adb: Use Exception_Code instead of a mix of\n+\tNatural and Integer in various places.\n+\t(Register_VMS_Exception): Use Base_Code_In to compute the exception code\n+\twith the severity bits masked off.\n+\t(Register_VMS_Exception): Handle the additional exception data pointer\n+\targument.\n+\n+\t* raise.c (_GNAT_Exception structure): Remove the handled_by_others\n+\tcomponent, now reflected by an exported accessor.\n+\t(is_handled_by): New routine to compute whether the propagated\n+\toccurrence matches some handler choice specification. Extracted out of\n+\tget_action_description_for, and expanded to take care of the VMS\n+\tspecifities.\n+\t(get_action_description_for): Use is_handled_by instead of an explicit\n+\tcomplex condition to decide if the current choice at hand catches the\n+\tpropagated occurrence.\n+\n+\t* raise.h (Exception_Code): New type for C.\n+\n+\t* rtsfind.ads (RE_Id, RE_Unit_Table): Add\n+\tSystem.Standard_Library.Exception_Code, to allow references from the\n+\tpragma import/export expander.\n+\n+\t* a-exexpr.adb (Is_Handled_By_Others, Language_For, Import_Code_For):\n+\tNew accessors to allow easy access to GNAT exception data\n+\tcharacteristics.\n+\t(GNAT_GCC_Exception record, Propagate_Exception): Get rid of the\n+\tredundant Handled_By_Others component, helper for the personality\n+\troutine which will now be able to call the appropriate exception data\n+\taccessor instead.\n+\n+\t* cstand.adb (Create_Standard): Adjust the type of the Import_Code\n+\tcomponent of Standard_Exception_Type to be the closest possible to\n+\tException_Code in System.Standard_Library, that we cannot get at this\n+\tpoint. Expand a ??? comment to notify that this type node should\n+\tprobably be rewritten later on.\n+\n+\t* exp_prag.adb (Expand_Pragma_Import_Export_Exception): Adjust the\n+\tregistration call to include a pointer to the exception object in the\n+\targuments.\n+\n+\t* init.c (__gnat_error_handler): Use Exception_Code and Base_Code_In\n+\tinstead of int and explicit bitmasks.\n+\n+2004-03-15  Vincent Celier  <celier@gnat.com>\n+\n+\t* vms_data.ads: Add new GNAT BIND qualifier /STATIC. Makes /NOSHARED\n+\tequivalent to /STATIC and /NOSTATIC equivalent to /SHARED.\n+\n+\t* a-tasatt.adb (To_Access_Code): Remove this UC instantiation, no\n+\tlonger needed now that it is in the spec of\n+\tSystem.Tasking.Task_Attributes.\n+\n+\t* adaint.h, adaint.c: (__gnat_create_output_file): New function\n+\n+\t* gnatcmd.adb: Fix bug introduced in previous rev: /= instead of =\n+\n+\t* g-os_lib.ads, g-os_lib.adb (Create_Output_Text_File): New function.\n+\n+\t* make.adb (Gnatmake): Do not check the executable suffix; it is being\n+\ttaken care of in Scan_Make_Arg.\n+\t(Scan_Make_Arg): Add the executable suffix only if the argument\n+\tfollowing -o, in canonical case, does not end with the executable\n+\tsuffix.  When in verbose mode and executable file name does not end\n+\twith executable suffix, output the executable name, in canonical case.\n+\n+\t* s-tataat.ads (Access_Dummy_Wrapper): Add pragma No_Strict_Aliasing\n+\tto avoid warnings when instantiating Ada.Task_Attributes.\n+\tMinor reformating.\n+\n+\t* mlib-prj.adb (Process_Imported_Libraries): Get the imported libraries\n+\tin the correct order.\n+\n+\t* prj-makr.adb (Process_Directory): No longer use GNAT.Expect, but\n+\tredirect standard output and error to a file for the invocation of the\n+\tcompiler, then read the file.\n+\n+\t* prj-nmsc.adb (Find_Sources): Use the Display_Value for each\n+\tdirectory, instead of the Value.\n+\t(Find_Source_Dirs): Remove useless code & comments.\n+\n+2004-03-15  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* exp_ch3.adb (Freeze_Record_Type): If a primitive operation of a\n+\ttagged type is inherited, and the parent operation is not frozen yet,\n+\tforce generation of a freeze node for the inherited operation, so the\n+\tcorresponding dispatch entry is properly initialized.\n+\t(Make_Predefined_Primitive_Specs): Check that return type is Boolean\n+\twhen looking for user-defined equality operation.\n+\n+\t* exp_ch4.adb (Expand_Composite_Equality): Check that return type is\n+\tboolean when locating primitive equality of tagged component.\n+\n+\t* exp_ch5.adb (Expand_Assign_Array): If the left-hand side is a\n+\tbit-aligned field and the right-hand side a string literal, introduce\n+\ta temporary before expanding assignment into a loop.\n+\n+\t* exp_ch9.adb (Expand_N_Task_Type_Declaration): Copy expression for\n+\tpriority in full, to ensure that any expanded subepxressions of it are\n+\telaborated in the scope of the init_proc.\n+\n+\t* exp_prag.adb (Expand_Pragma_Import): Search for initialization call\n+\tafter object declaration, skipping over code that may have been\n+\tgenerated for validity checks.\n+\n+\t* sem_ch12.adb (Validate_Private_Type_Instance): If type has unknown\n+\tdiscriminants, ignore the known discriminants of its full view, if\n+\tany, to check legality.\n+\n+\t* sem_ch3.adb (Complete_Private_Subtype): Do not create constrained\n+\tcomponent if type has unknown discriminants.\n+\t(Analyze_Private_Extension_Declaration): Discriminant constraint is\n+\tnull if type has unknown discriminants.\n+\n+\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body): Generate reference\n+\tfor end label when present.\n+\n+\t* s-fileio.adb (Open): When called with a C_Stream, use given name for\n+\ttemporary file, rather than an empty string.\n+\n+2004-03-15  Ed Falis  <falis@gnat.com>\n+\n+\t* s-thread.adb: Removed, no longer used.\n+\n+2004-03-15  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (target.h): Now include.\n+\t(gnat_to_gnu_entity, case E_Access_Type): Use mode derived from ESIZE\n+\tin new build_pointer_from_mode calls for non-fat/non-thin pointer.\n+\t(validate_size): For POINTER_TYPE, get smallest size permitted on\n+\tmachine.\n+\n+\t* fe.h: Sort Einfo decls and add Set_Mechanism.\n+\n+\t* Makefile.in: (LIBGNAT_SRCS): Remove types.h.\n+\t(ada/decl.o): Depends on target.h.\n+\n+\t* trans.c (tree_transform, N_Unchecked_Type_Conversion): Do not use\n+\tFUNCTION_BOUNDARY; always use TYPE_ALIGN.\n+\n+2004-03-15  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* 5ztpopsp.adb, 56tpopsp.adb: Fix spelling of Task_ID.\n+\n+\t* exp_ch4.adb (Expand_N_Indexed_Component): Do not call\n+\tInsert_Dereference_Action when rewriting an implicit dereference into\n+\tan explicit one, this will be taken care of during expansion of the\n+\texplicit dereference.\n+\t(Expand_N_Slice): Same. Always do the rewriting, even for the case\n+\tof non-packed slices, since the dereference action generated by\n+\texpansion of the explicit dereference is needed in any case.\n+\t(Expand_N_Selected_Component): When rewriting an implicit dereference,\n+\tanalyze and resolve the rewritten explicit dereference so it is seen\n+\tby the expander.\n+\t(Insert_Dereference_Action): This procedure is now called only for the\n+\texpansion of an N_Explcit_Dereference_Node. Do insert a check even for\n+\tdereferences that do not come from source (including explicit\n+\tdereferences resulting from rewriting implicit ones), but do not\n+\trecursively insert a check for the dereference nodes contained within\n+\tthe check.\n+\t(Insert_Dereference_Action): Clarify and correct comment.\n+\n 2004-03-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR ada/14131"}, {"sha": "3b0c016d624d5b14362464ebd0a19767c32a8ba4", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1201,9 +1201,10 @@ ada/cuintp.o : ada/cuintp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    ada/elists.h ada/nlists.h ada/fe.h ada/gigi.h\n \n ada/decl.o : ada/decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   flags.h toplev.h convert.h ada/ada.h ada/types.h ada/atree.h ada/nlists.h \\\n-   ada/elists.h ada/uintp.h ada/sinfo.h ada/einfo.h ada/snames.h ada/namet.h \\\n-   ada/stringt.h ada/repinfo.h ada/fe.h $(ADA_TREE_H) ada/gigi.h gt-ada-decl.h\n+   flags.h toplev.h convert.h target.h ada/ada.h ada/types.h ada/atree.h \\\n+   ada/nlists.h ada/elists.h ada/uintp.h ada/sinfo.h ada/einfo.h ada/snames.h \\\n+   ada/namet.h ada/stringt.h ada/repinfo.h ada/fe.h $(ADA_TREE_H) ada/gigi.h \\\n+   gt-ada-decl.h\n \n ada/misc.o : ada/misc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) expr.h insn-codes.h insn-flags.h insn-config.h recog.h flags.h \\"}, {"sha": "48b16e45a0aa4b8b74e978fdfa0ffd0c7ebca57b", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1308,7 +1308,7 @@ endif\n # subdirectory and copied.\n LIBGNAT_SRCS = ada.h adaint.c adaint.h argv.c cio.c cstreams.c \\\n   errno.c exit.c cal.c ctrl_c.c \\\n-  raise.h raise.c sysdep.c types.h aux-io.c init.c \\\n+  raise.h raise.c sysdep.c aux-io.c init.c \\\n   final.c tracebak.c tb-alvms.c tb-alvxw.c expect.c mkdir.c socket.c \\\n   $(EXTRA_LIBGNAT_SRCS)\n "}, {"sha": "faa89a3744cdd1351c7e53ddb30528115a2d7f79", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -145,11 +145,6 @@ package body Exception_Propagation is\n       --  routine to determine if the context it examines contains a\n       --  handler for the exception beeing propagated.\n \n-      Handled_By_Others : Boolean;\n-      --  Is this exception handled by \"when others\" ? This is used by the\n-      --  personality routine to determine if an \"others\" handler in the\n-      --  context it examines may catch the exception beeing propagated.\n-\n       N_Cleanups_To_Trigger : Integer;\n       --  Number of cleanup only frames encountered in SEARCH phase.\n       --  This is used to control the forced unwinding triggered when\n@@ -174,8 +169,7 @@ package body Exception_Propagation is\n \n    function Remove\n      (Top   : EOA;\n-      Excep : GNAT_GCC_Exception_Access)\n-      return  Boolean;\n+      Excep : GNAT_GCC_Exception_Access) return Boolean;\n    --  Remove Excep from the stack starting at Top.\n    --  Return True if Excep was found and removed, false otherwise.\n \n@@ -195,8 +189,7 @@ package body Exception_Propagation is\n       UW_Eclass    : Exception_Class;\n       UW_Exception : access GNAT_GCC_Exception;\n       UW_Context   : System.Address;\n-      UW_Argument  : System.Address)\n-      return         Unwind_Reason_Code;\n+      UW_Argument  : System.Address) return Unwind_Reason_Code;\n    --  Hook called at each step of the forced unwinding we perform to\n    --  trigger cleanups found during the propagation of an unhandled\n    --  exception.\n@@ -215,14 +208,32 @@ package body Exception_Propagation is\n       UW_Argument  : System.Address);\n    pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n \n+   ------------------------------------------------------------\n+   -- Accessors to basic components of a GNAT exception data --\n+   ------------------------------------------------------------\n+\n+   --  As of today, these are only used by the C implementation of the\n+   --  propagation personality routine to avoid having to rely on a C\n+   --  counterpart of the whole exception_data structure, which is both\n+   --  painful and error prone. These subprograms could be moved to a\n+   --  more widely visible location if need be.\n+\n+   function Is_Handled_By_Others (E : Exception_Data_Ptr) return Boolean;\n+   pragma Export (C, Is_Handled_By_Others, \"__gnat_is_handled_by_others\");\n+\n+   function Language_For (E : Exception_Data_Ptr) return Character;\n+   pragma Export (C, Language_For, \"__gnat_language_for\");\n+\n+   function Import_Code_For (E : Exception_Data_Ptr) return Exception_Code;\n+   pragma Export (C, Import_Code_For, \"__gnat_import_code_for\");\n+\n    ------------\n    -- Remove --\n    ------------\n \n    function Remove\n      (Top   : EOA;\n-      Excep : GNAT_GCC_Exception_Access)\n-      return  Boolean\n+      Excep : GNAT_GCC_Exception_Access) return Boolean\n    is\n       Prev          : GNAT_GCC_Exception_Access := null;\n       Iter          : EOA := Top;\n@@ -285,8 +296,7 @@ package body Exception_Propagation is\n       UW_Eclass    : Exception_Class;\n       UW_Exception : access GNAT_GCC_Exception;\n       UW_Context   : System.Address;\n-      UW_Argument  : System.Address)\n-      return         Unwind_Reason_Code\n+      UW_Argument  : System.Address) return Unwind_Reason_Code\n    is\n    begin\n       --  Terminate as soon as we know there is nothing more to run. The\n@@ -401,7 +411,6 @@ package body Exception_Propagation is\n       --  frame via Unwind_RaiseException below.\n \n       GCC_Exception.Id := Excep.Id;\n-      GCC_Exception.Handled_By_Others := not Excep.Id.Not_Handled_By_Others;\n       GCC_Exception.N_Cleanups_To_Trigger := 0;\n \n       --  Compute the backtrace for this occurrence if the corresponding\n@@ -459,6 +468,39 @@ package body Exception_Propagation is\n       Unhandled_Exception_Terminate;\n    end Propagate_Exception;\n \n+   ---------------------\n+   -- Import_Code_For --\n+   ---------------------\n+\n+   function Import_Code_For\n+     (E : SSL.Exception_Data_Ptr) return Exception_Code\n+   is\n+   begin\n+      return E.all.Import_Code;\n+   end Import_Code_For;\n+\n+   --------------------------\n+   -- Is_Handled_By_Others --\n+   --------------------------\n+\n+   function Is_Handled_By_Others\n+     (E : SSL.Exception_Data_Ptr) return Boolean\n+   is\n+   begin\n+      return not E.all.Not_Handled_By_Others;\n+   end Is_Handled_By_Others;\n+\n+   ------------------\n+   -- Language_For --\n+   ------------------\n+\n+   function Language_For\n+     (E : SSL.Exception_Data_Ptr) return Character\n+   is\n+   begin\n+      return E.all.Lang;\n+   end Language_For;\n+\n    -----------\n    -- Notes --\n    -----------"}, {"sha": "09a052b72e04c103a21630d2cbb2b53eecec5bda", "filename": "gcc/ada/a-ngcoty.adb", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-ngcoty.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-ngcoty.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoty.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -566,14 +566,18 @@ package body Ada.Numerics.Generic_Complex_Types is\n          --  we can use an explicit comparison to determine whether to use\n          --  the scaling expression.\n \n+         --  The scaling expression is computed in double format throughout\n+         --  in order to prevent inaccuracies on machines where not all\n+         --  immediate expressions are rounded, such as PowerPC.\n+\n          if Re2 > R'Last then\n             raise Constraint_Error;\n          end if;\n \n       exception\n          when Constraint_Error =>\n-            return abs (X.Re)\n-              * R (Sqrt (Double (R (1.0) + (X.Im / X.Re) ** 2)));\n+            return R (Double (abs (X.Re))\n+              * Sqrt (1.0 + (Double (X.Im) / Double (X.Re)) ** 2));\n       end;\n \n       begin\n@@ -585,8 +589,8 @@ package body Ada.Numerics.Generic_Complex_Types is\n \n       exception\n          when Constraint_Error =>\n-            return abs (X.Im)\n-              * R (Sqrt (Double (R (1.0) + (X.Re / X.Im) ** 2)));\n+            return R (Double (abs (X.Im))\n+              * Sqrt (1.0 + (Double (X.Re) / Double (X.Im)) ** 2));\n       end;\n \n       --  Now deal with cases of underflow. If only one of the squares\n@@ -606,12 +610,12 @@ package body Ada.Numerics.Generic_Complex_Types is\n             else\n                if abs (X.Re) > abs (X.Im) then\n                   return\n-                    abs (X.Re)\n-                      * R (Sqrt (Double (R (1.0) + (X.Im / X.Re) ** 2)));\n+                    R (Double (abs (X.Re))\n+                      * Sqrt (1.0 + (Double (X.Im) / Double (X.Re)) ** 2));\n                else\n                   return\n-                    abs (X.Im)\n-                      * R (Sqrt (Double (R (1.0) + (X.Re / X.Im) ** 2)));\n+                    R (Double (abs (X.Im))\n+                      * Sqrt (1.0 + (Double (X.Re) / Double (X.Im)) ** 2));\n                end if;\n             end if;\n "}, {"sha": "873b3870409762d16e0319425775e37cb7026b51", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--             Copyright (C) 1995-2004, Ada Core Technologies               --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -322,10 +322,6 @@ package body Ada.Task_Attributes is\n      (Access_Node, Access_Address);\n    --  To store pointer to list of indirect attributes\n \n-   function To_Access_Node is new Unchecked_Conversion\n-     (Access_Address, Access_Node);\n-   --  To fetch pointer to list of indirect attributes\n-\n    pragma Warnings (Off);\n    function To_Access_Wrapper is new Unchecked_Conversion\n      (Access_Dummy_Wrapper, Access_Wrapper);"}, {"sha": "9e360386ef952ebc8ea9d9df9bfe8dd99ea0fc5a", "filename": "gcc/ada/a-tifiio.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tifiio.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -432,7 +432,6 @@ package body Ada.Text_IO.Fixed_IO is\n                             + Boolean'Pos (not Exact)\n                                 * (Scale - 1);\n \n-\n       procedure Put_Character (C : Character);\n       pragma Inline (Put_Character);\n       --  Add C to the output string To, updating Last\n@@ -550,7 +549,6 @@ package body Ada.Text_IO.Fixed_IO is\n          E       : Integer)\n       is\n          N  : constant Natural := (A + Max_Digits - 1) / Max_Digits + 1;\n-         pragma Debug (Put_Line (\"N =\" & N'Img));\n          Q  : array (1 .. N) of Int64 := (others => 0);\n \n          XX : Int64 := X;"}, {"sha": "c99c1f0fbecb5c87ef167bc2ecea7c081a63cd41", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -615,6 +615,21 @@ __gnat_open_create (char *path, int fmode)\n   return fd < 0 ? -1 : fd;\n }\n \n+int\n+__gnat_create_output_file (char *path)\n+{\n+  int fd;\n+#if defined (VMS)\n+  fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM,\n+             \"rfm=stmlf\", \"ctx=rec\", \"rat=none\", \"rop=nlk\",\n+             \"shr=del,get,put,upd\");\n+#else\n+  fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM);\n+#endif\n+\n+  return fd < 0 ? -1 : fd;\n+}\n+\n int\n __gnat_open_append (char *path, int fmode)\n {"}, {"sha": "bcfb453e221e14f57299be01a1f70ee2017cf7fc", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2004 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -63,6 +63,7 @@ extern int    __gnat_stat\t\t\t   (char *,\n extern int    __gnat_open_read                     (char *, int);\n extern int    __gnat_open_rw                       (char *, int);\n extern int    __gnat_open_create                   (char *, int);\n+extern int    __gnat_create_output_file            (char *);\n extern int    __gnat_open_append                   (char *, int);\n extern long   __gnat_file_length                   (int);\n extern void   __gnat_tmp_name\t\t\t   (char *);"}, {"sha": "7c133248c0730eab77328584508f6a3325ecbf62", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1100,6 +1100,13 @@ package body CStand is\n       --  Build standard exception type. Note that the type name here is\n       --  actually used in the generated code, so it must be set correctly\n \n+      --  ??? Also note that the Import_Code component is now declared\n+      --  as a System.Standard_Library.Exception_Code to enforce run-time\n+      --  library implementation consistency. It's too early here to resort\n+      --  to rtsfind to get the proper node for that type, so we use the\n+      --  closest possible available type node at hand instead. We should\n+      --  probably be fixing this up at some point.\n+\n       Standard_Exception_Type := New_Standard_Entity;\n       Set_Ekind       (Standard_Exception_Type, E_Record_Type);\n       Set_Etype       (Standard_Exception_Type, Standard_Exception_Type);\n@@ -1120,7 +1127,7 @@ package body CStand is\n                                                              \"Full_Name\");\n       Make_Component  (Standard_Exception_Type, Standard_A_Char,\n                                                             \"HTable_Ptr\");\n-      Make_Component  (Standard_Exception_Type, Standard_Integer,\n+      Make_Component  (Standard_Exception_Type, Standard_Unsigned,\n                                                           \"Import_Code\");\n       Make_Component  (Standard_Exception_Type, Standard_A_Char,\n                                                             \"Raise_Hook\");"}, {"sha": "8891f607b06bba3f6ea7585a072fc3f1970bf1f7", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -34,6 +34,7 @@\n #include \"convert.h\"\n #include \"ggc.h\"\n #include \"obstack.h\"\n+#include \"target.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -2801,6 +2802,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tint got_fat_p = 0;\n \tint made_dummy = 0;\n \ttree gnu_desig_type = 0;\n+\tenum machine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n+\n+\tif (!targetm.valid_pointer_mode (p_mode))\n+\t  p_mode = ptr_mode;\n \n \tif (No (gnat_desig_full)\n \t    && (Ekind (gnat_desig_type) == E_Class_Wide_Type\n@@ -2950,7 +2955,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \telse if (gnat_desig_type == gnat_entity)\n \t  {\n-\t    gnu_type = build_pointer_type (make_node (VOID_TYPE));\n+\t    gnu_type = build_pointer_type_for_mode (make_node (VOID_TYPE),\n+\t\t\t\t\t\t    p_mode);\n \t    TREE_TYPE (gnu_type) = TYPE_POINTER_TO (gnu_type) = gnu_type;\n \t  }\n \telse\n@@ -3002,7 +3008,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  }\n \t      }\n \n-\t    gnu_type = build_pointer_type (gnu_desig_type);\n+\t    gnu_type = build_pointer_type_for_mode (gnu_desig_type, p_mode);\n \t  }\n \n \t/* If we are not defining this object and we made a dummy pointer,\n@@ -5794,12 +5800,8 @@ compute_field_positions (tree gnu_type,\n    it means that a size of zero should be treated as an unspecified size.  */\n \n static tree\n-validate_size (Uint uint_size,\n-               tree gnu_type,\n-               Entity_Id gnat_object,\n-               enum tree_code kind,\n-               int component_p,\n-               int zero_ok)\n+validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n+               enum tree_code kind, int component_p, int zero_ok)\n {\n   Node_Id gnat_error_node;\n   tree type_size\n@@ -5871,6 +5873,20 @@ validate_size (Uint uint_size,\n   else if (TYPE_FAT_POINTER_P (gnu_type))\n     type_size = bitsize_int (POINTER_SIZE);\n \n+  /* If this is an access type, the minimum size is that given by the smallest\n+     integral mode that's valid for pointers.  */\n+  if (TREE_CODE (gnu_type) == POINTER_TYPE)\n+    {\n+      enum machine_mode p_mode;\n+\n+      for (p_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   !targetm.valid_pointer_mode (p_mode);\n+\t   p_mode = GET_MODE_WIDER_MODE (p_mode))\n+\t;\n+\n+      type_size = bitsize_int (GET_MODE_BITSIZE (p_mode));\n+    }\n+\n   /* If the size of the object is a constant, the new size must not be\n      smaller.  */\n   if (TREE_CODE (type_size) != INTEGER_CST"}, {"sha": "e6e42315eb27c4f42724d7465a925fe006cda891", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -4184,23 +4184,35 @@ package body Exp_Ch3 is\n             --  (usually the inherited primitive address is inserted in the\n             --  DT by Inherit_DT)\n \n-            if Is_CPP_Class (Etype (Def_Id)) then\n-               declare\n-                  Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Def_Id));\n-                  Subp : Entity_Id;\n+            --  Similarly, if this is an inherited operation whose parent\n+            --  is not frozen yet, it is not in the DT of the parent, and\n+            --  we generate an explicit freeze node for the inherited\n+            --  operation, so that it is properly inserted in the DT of the\n+            --  current type.\n \n-               begin\n-                  while Present (Elmt) loop\n-                     Subp := Node (Elmt);\n+            declare\n+               Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Def_Id));\n+               Subp : Entity_Id;\n+\n+            begin\n+               while Present (Elmt) loop\n+                  Subp := Node (Elmt);\n+\n+                  if Present (Alias (Subp)) then\n+                     if Is_CPP_Class (Etype (Def_Id)) then\n+                        Set_Has_Delayed_Freeze (Subp);\n \n-                     if Present (Alias (Subp)) then\n+                     elsif Has_Delayed_Freeze (Alias (Subp))\n+                       and then not Is_Frozen (Alias (Subp))\n+                     then\n+                        Set_Is_Frozen (Subp, False);\n                         Set_Has_Delayed_Freeze (Subp);\n                      end if;\n+                  end if;\n \n-                     Next_Elmt (Elmt);\n-                  end loop;\n-               end;\n-            end if;\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end;\n \n             if Underlying_Type (Etype (Def_Id)) = Def_Id then\n                Expand_Tagged_Root (Def_Id);\n@@ -5275,6 +5287,7 @@ package body Exp_Ch3 is\n                                             N_Subprogram_Renaming_Declaration)\n               and then Etype (First_Formal (Node (Prim))) =\n                          Etype (Next_Formal (First_Formal (Node (Prim))))\n+              and then Base_Type (Etype (Node (Prim))) = Standard_Boolean\n \n             then\n                Eq_Needed := False;"}, {"sha": "e1440f2ead616b8a9a96da594509c765d9d3806a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -154,8 +154,9 @@ package body Exp_Ch4 is\n    --  local access type to have a usable finalization list.\n \n    procedure Insert_Dereference_Action (N : Node_Id);\n-   --  N is an expression whose type is an access. When the type is derived\n-   --  from Checked_Pool, expands a call to the primitive 'dereference'.\n+   --  N is an expression whose type is an access. When the type of the\n+   --  associated storage pool is derived from Checked_Pool, generate a\n+   --  call to the 'Dereference' primitive operation.\n \n    function Make_Array_Comparison_Op\n      (Typ : Entity_Id;\n@@ -1401,7 +1402,8 @@ package body Exp_Ch4 is\n             Eq_Op := Node (Prim);\n             exit when Chars (Eq_Op) = Name_Op_Eq\n               and then Etype (First_Formal (Eq_Op)) =\n-                       Etype (Next_Formal (First_Formal (Eq_Op)));\n+                       Etype (Next_Formal (First_Formal (Eq_Op)))\n+              and then Base_Type (Etype (Eq_Op)) = Standard_Boolean;\n             Next_Elmt (Prim);\n             pragma Assert (Present (Prim));\n          end loop;\n@@ -2968,12 +2970,6 @@ package body Exp_Ch4 is\n       --  was necessary, but it cleans up the code to do it all the time.\n \n       if Is_Access_Type (T) then\n-\n-         --  Check whether the prefix comes from a debug pool, and generate\n-         --  the check before rewriting.\n-\n-         Insert_Dereference_Action (P);\n-\n          Rewrite (P,\n            Make_Explicit_Dereference (Sloc (N),\n              Prefix => Relocate_Node (P)));\n@@ -5124,6 +5120,7 @@ package body Exp_Ch4 is\n \n       if Is_Access_Type (Ptyp) then\n          Insert_Explicit_Dereference (P);\n+         Analyze_And_Resolve (P, Designated_Type (Ptyp));\n \n          if Ekind (Etype (P)) = E_Private_Subtype\n            and then Is_For_Access_Subtype (Etype (P))\n@@ -5396,23 +5393,13 @@ package body Exp_Ch4 is\n \n       if Is_Access_Type (Ptp) then\n \n-         --  Check for explicit dereference required for checked pool\n-\n-         Insert_Dereference_Action (Pfx);\n-\n-         --  If we have an access to a packed array type, then put in an\n-         --  explicit dereference. We do this in case the slice must be\n-         --  expanded, and we want to make sure we get an access check.\n-\n          Ptp := Designated_Type (Ptp);\n \n-         if Is_Array_Type (Ptp) and then Is_Packed (Ptp) then\n-            Rewrite (Pfx,\n-              Make_Explicit_Dereference (Sloc (N),\n-                Prefix => Relocate_Node (Pfx)));\n+         Rewrite (Pfx,\n+           Make_Explicit_Dereference (Sloc (N),\n+            Prefix => Relocate_Node (Pfx)));\n \n-            Analyze_And_Resolve (Pfx, Ptp);\n-         end if;\n+         Analyze_And_Resolve (Pfx, Ptp);\n       end if;\n \n       --  Range checks are potentially also needed for cases involving\n@@ -6532,6 +6519,7 @@ package body Exp_Ch4 is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Typ  : constant Entity_Id  := Etype (N);\n       Pool : constant Entity_Id  := Associated_Storage_Pool (Typ);\n+      Pnod : constant Node_Id    := Parent (N);\n \n       function Is_Checked_Storage_Pool (P : Entity_Id) return Boolean;\n       --  Return true if type of P is derived from Checked_Pool;\n@@ -6563,7 +6551,17 @@ package body Exp_Ch4 is\n    --  Start of processing for Insert_Dereference_Action\n \n    begin\n-      if not Comes_From_Source (Parent (N)) then\n+      pragma Assert (Nkind (Pnod) = N_Explicit_Dereference);\n+\n+      --  Do not recursively add a dereference check for the\n+      --  attribute references contained within the generated check.\n+\n+      if not Comes_From_Source (Pnod)\n+        and then Nkind (Pnod) = N_Explicit_Dereference\n+        and then Nkind (Parent (Pnod)) = N_Attribute_Reference\n+        and then (Attribute_Name (Parent (Pnod)) = Name_Size\n+          or else Attribute_Name (Parent (Pnod)) = Name_Alignment)\n+      then\n          return;\n \n       elsif not Is_Checked_Storage_Pool (Pool) then"}, {"sha": "a08cd1f145c200f39712cc5d6f09bf91418a4461", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -478,7 +478,29 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n-      --  Come here to compelete the analysis\n+      --  If the right-hand side is a string literal, introduce a temporary\n+      --  for it, for use in the generated loop that will follow.\n+\n+      if Nkind (Rhs) = N_String_Literal then\n+         declare\n+            Temp : constant Entity_Id :=\n+                     Make_Defining_Identifier (Loc, Name_T);\n+            Decl : Node_Id;\n+\n+         begin\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                 Defining_Identifier => Temp,\n+                 Object_Definition => New_Occurrence_Of (L_Type, Loc),\n+                 Expression => Relocate_Node (Rhs));\n+\n+            Insert_Action (N, Decl);\n+            Rewrite (Rhs, New_Occurrence_Of (Temp, Loc));\n+            R_Type := Etype (Temp);\n+         end;\n+      end if;\n+\n+      --  Come here to complete the analysis\n \n       --    Loop_Required: Set to True if we know that a loop is required\n       --                   regardless of overlap considerations."}, {"sha": "0864da74696984c9f6fbb1d1021f4d7a19878947", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -7237,7 +7237,7 @@ package body Exp_Ch9 is\n                Expr := Expression (Expr);\n             end if;\n \n-            Expr := New_Copy (Expr);\n+            Expr := New_Copy_Tree (Expr);\n \n             --  Add conversion to proper type to do range check if required\n             --  Note that for runtime units, we allow out of range interrupt"}, {"sha": "1ffbf5bc18cdad8aaf8810dd8c1abe2b4ef873b7", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -272,7 +272,9 @@ package body Exp_Prag is\n    --  When applied to a variable, the default initialization must not be\n    --  done. As it is already done when the pragma is found, we just get rid\n    --  of the call the initialization procedure which followed the object\n-   --  declaration.\n+   --  declaration. The call is inserted after the declaration, but validity\n+   --  checks may also have been inserted and the initialization call does\n+   --  not necessarily appear immediately after the object declaration.\n \n    --  We can't use the freezing mechanism for this purpose, since we\n    --  have to elaborate the initialization expression when it is first\n@@ -281,27 +283,37 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Import (N : Node_Id) is\n       Def_Id    : constant Entity_Id := Entity (Expression (Arg2 (N)));\n       Typ       : Entity_Id;\n-      After_Def : Node_Id;\n+      Init_Call : Node_Id;\n \n    begin\n       if Ekind (Def_Id) = E_Variable then\n          Typ  := Etype (Def_Id);\n-         After_Def := Next (Parent (Def_Id));\n \n-         if Has_Non_Null_Base_Init_Proc (Typ)\n-           and then Nkind (After_Def) = N_Procedure_Call_Statement\n-           and then Is_Entity_Name (Name (After_Def))\n-           and then Entity (Name (After_Def)) = Base_Init_Proc (Typ)\n-         then\n-            Remove (After_Def);\n+         --  Loop to ???\n+\n+         Init_Call := Next (Parent (Def_Id));\n+         while Present (Init_Call) and then Init_Call /= N loop\n+            if Has_Non_Null_Base_Init_Proc (Typ)\n+              and then Nkind (Init_Call) = N_Procedure_Call_Statement\n+              and then Is_Entity_Name (Name (Init_Call))\n+              and then Entity (Name (Init_Call)) = Base_Init_Proc (Typ)\n+            then\n+               Remove (Init_Call);\n+               exit;\n+            else\n+               Next (Init_Call);\n+            end if;\n+         end loop;\n \n          --  Any default initialization expression should be removed\n          --  (e.g., null defaults for access objects, zero initialization\n          --  of packed bit arrays). Imported objects aren't allowed to\n          --  have explicit initialization, so the expression must have\n          --  been generated by the compiler.\n \n-         elsif Present (Expression (Parent (Def_Id))) then\n+         if No (Init_Call)\n+           and then Present (Expression (Parent (Def_Id)))\n+         then\n             Set_Expression (Parent (Def_Id), Empty);\n          end if;\n       end if;\n@@ -391,7 +403,7 @@ package body Exp_Prag is\n                        Make_Object_Declaration (Loc,\n                          Defining_Identifier => Excep_Internal,\n                          Object_Definition   =>\n-                           New_Reference_To (Standard_Integer, Loc));\n+                           New_Reference_To (RTE (RE_Exception_Code), Loc));\n \n                      Insert_Action (N, Excep_Object);\n                      Analyze (Excep_Object);\n@@ -453,7 +465,7 @@ package body Exp_Prag is\n \n                   else\n                      Code :=\n-                        Unchecked_Convert_To (Standard_Integer,\n+                        Unchecked_Convert_To (RTE (RE_Exception_Code),\n                           Make_Function_Call (Loc,\n                             Name =>\n                               New_Reference_To (RTE (RE_Import_Value), Loc),\n@@ -466,9 +478,14 @@ package body Exp_Prag is\n                     Make_Procedure_Call_Statement (Loc,\n                       Name => New_Reference_To\n                                 (RTE (RE_Register_VMS_Exception), Loc),\n-                      Parameter_Associations => New_List (Code)));\n-\n-                  Analyze_And_Resolve (Code, Standard_Integer);\n+                      Parameter_Associations => New_List (\n+                        Code,\n+                        Unchecked_Convert_To (RTE (RE_Exception_Data_Ptr),\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => New_Occurrence_Of (Id, Loc),\n+                            Attribute_Name => Name_Unrestricted_Access)))));\n+\n+                  Analyze_And_Resolve (Code, RTE (RE_Exception_Code));\n                   Analyze (Call);\n                end if;\n "}, {"sha": "f3228dc0b3e62b63f53de482fcb0080bf475d88e", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -57,17 +57,19 @@ extern Boolean Debug_Flag_NN;\n    Present_Expr for N_Variant nodes.  */\n \n #define Set_Alignment\t\t\teinfo__set_alignment\n-#define Set_Esize\t\t\teinfo__set_esize\n-#define Set_RM_Size\t\t\teinfo__set_rm_size\n #define Set_Component_Bit_Offset\teinfo__set_component_bit_offset\n #define Set_Component_Size\t\teinfo__set_component_size\n+#define Set_Esize\t\t\teinfo__set_esize\n+#define Set_Mechanism\t\t\teinfo__set_mechanism\n+#define Set_RM_Size\t\t\teinfo__set_rm_size\n #define Set_Present_Expr\t\tsinfo__set_present_expr\n \n extern void Set_Alignment\t\t(Entity_Id, Uint);\n+extern void Set_Component_Bit_Offset\t(Entity_Id, Uint);\n extern void Set_Component_Size\t\t(Entity_Id, Uint);\n extern void Set_Esize\t\t\t(Entity_Id, Uint);\n+extern void Set_Mechanism\t\t(Entity_Id, Mechanism_Type);\n extern void Set_RM_Size\t\t\t(Entity_Id, Uint);\n-extern void Set_Component_Bit_Offset\t(Entity_Id, Uint);\n extern void Set_Present_Expr\t\t(Node_Id, Uint);\n \n /* Test if the node N is the name of an entity (i.e. is an identifier,"}, {"sha": "7c321b64fefb3d64f0811b6001504ab594dc2348", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1995-2003 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1995-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -660,6 +660,23 @@ package body GNAT.OS_Lib is\n       return Create_New_File (C_Name (C_Name'First)'Address, Fmode);\n    end Create_New_File;\n \n+   -----------------------------\n+   -- Create_Output_Text_File --\n+   -----------------------------\n+\n+   function Create_Output_Text_File (Name  : String) return File_Descriptor is\n+      function C_Create_File\n+        (Name  : C_File_Name) return File_Descriptor;\n+      pragma Import (C, C_Create_File, \"__gnat_create_output_file\");\n+\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last)      := ASCII.NUL;\n+      return C_Create_File (C_Name (C_Name'First)'Address);\n+   end Create_Output_Text_File;\n+\n    ----------------------\n    -- Create_Temp_File --\n    ----------------------"}, {"sha": "6cd6b82f787503e0c98e5c2de970e7289514da08", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1995-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -191,7 +191,12 @@ pragma Elaborate_Body (OS_Lib);\n       Fmode : Mode) return File_Descriptor;\n    --  Creates new file with given name for writing, returning file descriptor\n    --  for subsequent use in Write calls. File descriptor returned is\n-   --  Invalid_FD if file cannot be successfully created\n+   --  Invalid_FD if file cannot be successfully created.\n+\n+   function Create_Output_Text_File (Name  : String) return File_Descriptor;\n+   --  Creates new text file with given name suitable to redirect standard\n+   --  output, returning file descriptor. File descriptor returned is\n+   --  Invalid_FD if file cannot be successfully created.\n \n    function Create_New_File\n      (Name  : String;"}, {"sha": "b793b48a7de56c60afcd08c35189c7225b3e94b6", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1338,7 +1338,7 @@ begin\n                --  Check if there is at least one argument that is not a switch\n \n                for Index in 1 .. Last_Switches.Last loop\n-                  if Last_Switches.Table (Index)(1) = '-' then\n+                  if Last_Switches.Table (Index)(1) /= '-' then\n                      Add_Sources := False;\n                      exit;\n                   end if;"}, {"sha": "c3742563299c7545f55404be15b5b869f03d6592", "filename": "gcc/ada/init.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1344,7 +1344,10 @@ extern char *__gnat_error_prehandler_stack;   /* Alternate signal stack */\n extern struct Exception_Data Non_Ada_Error;\n \n #define Coded_Exception system__vms_exception_table__coded_exception\n-extern struct Exception_Data *Coded_Exception (int);\n+extern struct Exception_Data *Coded_Exception (Exception_Code);\n+\n+#define Base_Code_In system__vms_exception_table__base_code_in\n+extern Exception_Code Base_Code_In (Exception_Code);\n #endif\n \n /* Define macro symbols for the VMS conditions that become Ada exceptions.\n@@ -1374,6 +1377,8 @@ long\n __gnat_error_handler (int *sigargs, void *mechargs)\n {\n   struct Exception_Data *exception = 0;\n+  Exception_Code base_code;\n+\n   char *msg = \"\";\n   char message[256];\n   long prvhnd;\n@@ -1410,8 +1415,11 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n   }\n \n #ifdef IN_RTS\n-  /* See if it's an imported exception. Mask off severity bits. */\n-  exception = Coded_Exception (sigargs[1] & 0xfffffff8);\n+  /* See if it's an imported exception. Beware that registered exceptions\n+     are bound to their base code, with the severity bits masked off.  */\n+  base_code = Base_Code_In ((Exception_Code) sigargs [1]);\n+  exception = Coded_Exception (base_code);\n+\n   if (exception)\n     {\n       msgdesc.len = 256;\n@@ -1424,7 +1432,7 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n       exception->Name_Length = 19;\n       /* The full name really should be get sys$getmsg returns. ??? */\n       exception->Full_Name = \"IMPORTED_EXCEPTION\";\n-      exception->Import_Code = sigargs[1] & 0xfffffff8;\n+      exception->Import_Code = base_code;\n     }\n #endif\n "}, {"sha": "200ad6a5730b63bd9c8a9ead24ee313ebe4cc247", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -275,10 +275,12 @@ package body Lib.Xref is\n             Set_Referenced (E);\n          end if;\n \n-         --  Check for pragma Unreferenced given\n-\n-         if Has_Pragma_Unreferenced (E) then\n+         --  Check for pragma Unreferenced given and reference is within\n+         --  this source unit (occasion for possible warning to be issued)\n \n+         if Has_Pragma_Unreferenced (E)\n+           and then In_Same_Extended_Unit (Sloc (E), Sloc (N))\n+         then\n             --  A reference as a named parameter in a call does not count\n             --  as a violation of pragma Unreferenced for this purpose.\n "}, {"sha": "15d6ed01b3e6c61872a13b2b1e018be15ccee071", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 24, "deletions": 46, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -180,7 +180,6 @@ package body Make is\n      Table_Name           => \"Make.Q\");\n    --  This is the actual Q.\n \n-\n    --  Package Mains is used to store the mains specified on the command line\n    --  and to retrieve them when a project file is used, to verify that the\n    --  files exist and that they belong to a project file.\n@@ -4345,39 +4344,6 @@ package body Make is\n                Name_Len := Linker_Switches.Table (J + 1)'Length;\n                Name_Buffer (1 .. Name_Len) :=\n                  Linker_Switches.Table (J + 1).all;\n-\n-               --  Put in canonical case to detect suffixs such as \".EXE\" on\n-               --  Windows or VMS.\n-\n-               Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-\n-               --  If target has an executable suffix and it has not been\n-               --  specified then it is added here.\n-\n-               if Executable_Suffix'Length /= 0\n-                 and then Name_Buffer\n-                          (Name_Len - Executable_Suffix'Length + 1 .. Name_Len)\n-                             /= Executable_Suffix\n-               then\n-                  --  Get back the original name to keep the case on Windows\n-\n-                  Name_Buffer (1 .. Name_Len) :=\n-                    Linker_Switches.Table (J + 1).all;\n-\n-                  --  Add the executable suffix\n-\n-                  Name_Buffer (Name_Len + 1 ..\n-                                       Name_Len + Executable_Suffix'Length) :=\n-                      Executable_Suffix;\n-                  Name_Len := Name_Len + Executable_Suffix'Length;\n-\n-               else\n-                  --  Get back the original name to keep the case on Windows\n-\n-                  Name_Buffer (1 .. Name_Len) :=\n-                    Linker_Switches.Table (J + 1).all;\n-               end if;\n-\n                Executable := Name_Enter;\n \n                Verbose_Msg (Executable, \"final executable\");\n@@ -6493,18 +6459,30 @@ package body Make is\n             --  Automatically add the executable suffix if it has not been\n             --  specified explicitly.\n \n-            if Executable_Suffix'Length /= 0\n-              and then (Argv'Length <= Executable_Suffix'Length\n-                        or else Argv (Argv'Last - Executable_Suffix'Length + 1\n-                                        .. Argv'Last) /= Executable_Suffix)\n-            then\n-               Add_Switch\n-                 (Argv & Executable_Suffix,\n-                  Linker,\n-                  And_Save => And_Save);\n-            else\n-               Add_Switch (Argv, Linker, And_Save => And_Save);\n-            end if;\n+            declare\n+               Canonical_Argv : String := Argv;\n+            begin\n+               --  Get the file name in canonical case to accept as is\n+               --  names ending with \".EXE\" on VMS and Windows.\n+\n+               Canonical_Case_File_Name (Canonical_Argv);\n+\n+               if Executable_Suffix'Length /= 0\n+                 and then (Canonical_Argv'Length <= Executable_Suffix'Length\n+                        or else Canonical_Argv\n+                                  (Canonical_Argv'Last -\n+                                   Executable_Suffix'Length + 1\n+                                   .. Canonical_Argv'Last)\n+                                /= Executable_Suffix)\n+               then\n+                  Add_Switch\n+                    (Argv & Executable_Suffix,\n+                     Linker,\n+                     And_Save => And_Save);\n+               else\n+                  Add_Switch (Argv, Linker, And_Save => And_Save);\n+               end if;\n+            end;\n          end if;\n \n       --  If the previous switch has set the Object_Directory_Present flag"}, {"sha": "4b82ffaef04cec3eebd176d7dd9d87a623b3b613", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -671,14 +671,9 @@ package body MLib.Prj is\n             if not Processed_Projects.Get (Data.Name) then\n                Processed_Projects.Set (Data.Name, True);\n \n-               --  If it is a library project, add it to Library_Projs\n-\n-               if Project /= For_Project and then Data.Library then\n-                  Library_Projs.Increment_Last;\n-                  Library_Projs.Table (Library_Projs.Last) := Project;\n-               end if;\n-\n-               --  Call Process_Project recursively for any imported project\n+               --  Call Process_Project recursively for any imported project.\n+               --  We first process the imported projects to guarantee that\n+               --  we have a proper reverse order for the libraries.\n \n                while Imported /= Empty_Project_List loop\n                   Element := Project_Lists.Table (Imported);\n@@ -689,69 +684,40 @@ package body MLib.Prj is\n \n                   Imported := Element.Next;\n                end loop;\n+\n+               --  If it is a library project, add it to Library_Projs\n+\n+               if Project /= For_Project and then Data.Library then\n+                  Library_Projs.Increment_Last;\n+                  Library_Projs.Table (Library_Projs.Last) := Project;\n+               end if;\n+\n             end if;\n          end Process_Project;\n \n       --  Start of processing for Process_Imported_Libraries\n \n       begin\n-         --  Build list of library projects imported directly or indirectly\n+         --  Build list of library projects imported directly or indirectly,\n+         --  in the reverse order.\n \n          Process_Project (For_Project);\n \n-         --  If there are more that one library project file, make sure\n-         --  that if libA depends on libB, libB is first in order.\n+         --  Add the -L and -l switches and, if the Rpath option is supported,\n+         --  add the directory to the Rpath.\n+         --  As the library projects are in the wrong order, process from the\n+         --  last to the first.\n \n-         if Library_Projs.Last > 1 then\n-            declare\n-               Index : Integer := 1;\n-               Proj1 : Project_Id;\n-               Proj2 : Project_Id;\n-               List  : Project_List := Empty_Project_List;\n-\n-            begin\n-               Library_Loop : while Index < Library_Projs.Last loop\n-                  Proj1 := Library_Projs.Table (Index);\n-                  List  := Projects.Table (Proj1).Imported_Projects;\n-\n-                  List_Loop : while List /= Empty_Project_List loop\n-                     Proj2 := Project_Lists.Table (List).Project;\n-\n-                     for J in Index + 1 .. Library_Projs.Last loop\n-                        if Proj2 = Library_Projs.Table (J) then\n-                           Library_Projs.Table (J) := Proj1;\n-                           Library_Projs.Table (Index) := Proj2;\n-                           exit List_Loop;\n-                        end if;\n-                     end loop;\n-\n-                     List := Project_Lists.Table (List).Next;\n-                  end loop List_Loop;\n-\n-                  if List = Empty_Project_List then\n-                     Index := Index + 1;\n-                  end if;\n-               end loop Library_Loop;\n-            end;\n-         end if;\n-\n-         --  Now that we have a correct order, add the -L and -l switches and,\n-         --  if the Rpath option is supported, add the directory to the Rpath.\n-\n-         for Index in 1 .. Library_Projs.Last loop\n+         for Index in reverse 1 .. Library_Projs.Last loop\n             Current := Library_Projs.Table (Index);\n \n+            Get_Name_String (Projects.Table (Current).Library_Dir);\n             Opts.Increment_Last;\n             Opts.Table (Opts.Last) :=\n-              new String'\n-                (\"-L\" &\n-                 Get_Name_String\n-                   (Projects.Table (Current).Library_Dir));\n+              new String'(\"-L\" & Name_Buffer (1 .. Name_Len));\n \n             if Path_Option /= null then\n-               Add_Rpath\n-                  (Get_Name_String\n-                     (Projects.Table (Current).Library_Dir));\n+               Add_Rpath (Name_Buffer (1 .. Name_Len));\n             end if;\n \n             Opts.Increment_Last;"}, {"sha": "dd16d034bcf29a286446a1ee350218e230269be5", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 255, "deletions": 149, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,18 +34,26 @@ with Prj.Com;\n with Prj.Part;\n with Prj.PP;\n with Prj.Tree; use Prj.Tree;\n+with Prj.Util; use Prj.Util;\n with Snames;   use Snames;\n with Table;    use Table;\n \n with Ada.Characters.Handling;   use Ada.Characters.Handling;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-with GNAT.Expect;               use GNAT.Expect;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n with GNAT.Regexp;               use GNAT.Regexp;\n-with GNAT.Regpat;               use GNAT.Regpat;\n \n package body Prj.Makr is\n \n+   function Dup (Fd : File_Descriptor) return File_Descriptor;\n+   pragma Import (C, Dup);\n+\n+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n+   pragma Import (C, Dup2);\n+\n+   Gcc : constant String := \"gcc\";\n+   Gcc_Path : String_Access := null;\n+\n    Non_Empty_Node : constant Project_Node_Id := 1;\n    --  Used for the With_Clause of the naming project\n \n@@ -123,16 +131,7 @@ package body Prj.Makr is\n \n       Source_List_FD : File_Descriptor;\n \n-      Matcher : constant Pattern_Matcher :=\n-                  Compile (Expression => \"expected|Unit.*\\)|No such\");\n-\n       Args : Argument_List  (1 .. Preproc_Switches'Length + 6);\n---                 (1 => new String'(\"-c\"),\n---                  2 => new String'(\"-gnats\"),\n---                  3 => new String'(\"-gnatu\"),\n---                  4 => new String'(\"-x\"),\n---                  5 => new String'(\"ada\"),\n---                  6 => null);\n \n       type SFN_Pragma is record\n          Unit : String_Access;\n@@ -164,13 +163,9 @@ package body Prj.Makr is\n          Dir      : Dir_Type;\n          Process  : Boolean := True;\n \n-      begin\n-         if Opt.Verbose_Mode then\n-            Output.Write_Str (\"Processing directory \"\"\");\n-            Output.Write_Str (Dir_Name);\n-            Output.Write_Line (\"\"\"\");\n-         end if;\n+         Temp_File_Name : String_Access := null;\n \n+      begin\n          --  Avoid processing several times the same directory.\n \n          for Index in 1 .. Processed_Directories.Last loop\n@@ -181,9 +176,16 @@ package body Prj.Makr is\n          end loop;\n \n          if Process then\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Processing directory \"\"\");\n+               Output.Write_Str (Dir_Name);\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n+\n             Processed_Directories. Increment_Last;\n             Processed_Directories.Table (Processed_Directories.Last) :=\n               new String'(Dir_Name);\n+\n             --  Get the source file names from the directory.\n             --  Fails if the directory does not exist.\n \n@@ -248,158 +250,262 @@ package body Prj.Makr is\n \n                   if Matched = True then\n                      declare\n-                        PD     : Process_Descriptor;\n-                        Result : Expect_Match;\n+                        FD : File_Descriptor;\n+                        Success : Boolean;\n+                        Saved_Output : File_Descriptor;\n+                        Saved_Error  : File_Descriptor;\n \n                      begin\n+                        --  If we don't have yet the path of the compiler,\n+                        --  get it now.\n+\n+                        if Gcc_Path = null then\n+                           Gcc_Path := Locate_Exec_On_Path (Gcc);\n+\n+                           if Gcc_Path = null then\n+                              Prj.Com.Fail (\"could not locate \" & Gcc);\n+                           end if;\n+                        end if;\n+\n+                        --  If we don't have yet the file name of the\n+                        --  temporary file, get it now.\n+\n+                        if Temp_File_Name = null then\n+                           Create_Temp_File (FD, Temp_File_Name);\n+\n+                           if FD = Invalid_FD then\n+                              Prj.Com.Fail\n+                                (\"could not create temporary file\");\n+                           end if;\n+\n+                           Close (FD);\n+                           Delete_File (Temp_File_Name.all, Success);\n+                        end if;\n+\n                         Args (Args'Last) := new String'\n-                                                  (Dir_Name &\n-                                                   Directory_Separator &\n-                                                   Str (1 .. Last));\n+                          (Dir_Name &\n+                           Directory_Separator &\n+                           Str (1 .. Last));\n+\n+                        --  Create the temporary file\n+\n+                        FD := Create_Output_Text_File\n+                          (Name => Temp_File_Name.all);\n+\n+                        if FD = Invalid_FD then\n+                           Prj.Com.Fail\n+                             (\"could not create temporary file\");\n+                        end if;\n+\n+                        --  Save the standard output and error\n+\n+                        Saved_Output := Dup (Standout);\n+                        Saved_Error  := Dup (Standerr);\n+\n+                        --  Set the standard output and error to the temporary\n+                        --  file.\n+\n+                        Dup2 (FD, Standout);\n+                        Dup2 (FD, Standerr);\n+\n+                        --  And spawn the compiler\n+\n+                        Spawn (Gcc_Path.all, Args, Success);\n+\n+                        --  Restore the standard output and error\n+                        Dup2 (Saved_Output, Standout);\n+                        Dup2 (Saved_Error, Standerr);\n+\n+                        --  Close the temporary file\n+\n+                        Close (FD);\n+\n+                        --  And close the saved standard output and error to\n+                        --  avoid too many file descriptors.\n+\n+                        Close (Saved_Output);\n+                        Close (Saved_Error);\n+\n+                        --  Now that standard output is restored, check if\n+                        --  the compiler ran correctly.\n+\n+                        --  Read the first line of the temporary file:\n+                        --  it should contain the kind and name of the unit.\n+\n+                        declare\n+                           File : Text_File;\n+                           Text_Line : String (1 .. 1_000);\n+                           Text_Last : Natural;\n \n                         begin\n-                           Non_Blocking_Spawn\n-                             (PD, \"gcc\", Args, Err_To_Out => True);\n-                           Expect (PD, Result, Matcher);\n+                           Open (File, Temp_File_Name.all);\n+\n+                           if not Is_Valid (File) then\n+                              Prj.Com.Fail\n+                                (\"could not read temporary file\");\n+                           end if;\n \n-                        exception\n-                           when Process_Died =>\n+                           if End_Of_File (File) then\n                               if Opt.Verbose_Mode then\n-                                 Output.Write_Str (\"(process died) \");\n+                                 if not Success then\n+                                    Output.Write_Str (\"(process died) \");\n+                                 end if;\n+\n+                                 Output.Write_Line (\"not a unit\");\n                               end if;\n \n-                              Result := Expect_Timeout;\n-                        end;\n+                           else\n+                              Get_Line (File, Text_Line, Text_Last);\n+                              Close (File);\n \n-                        if Result /= Expect_Timeout then\n+                              --  Now that we have read the line, delete the\n+                              --  temporary file, it is not needed anymore.\n+                              --  On VMS, this avoids several version of the\n+                              --  file, if it were only delete after all\n+                              --  sources were parsed.\n \n-                           --  If we got a unit name, this is a valid source\n-                           --  file.\n+                              Delete_File (Temp_File_Name.all, Success);\n \n-                           declare\n-                              S : constant String := Expect_Out_Match (PD);\n+                              --  Find the first closing parenthesis\n \n-                           begin\n-                              if S'Length >= 13\n-                                and then S (S'First .. S'First + 3) = \"Unit\"\n-                              then\n-                                 if Opt.Verbose_Mode then\n-                                    Output.Write_Str\n-                                      (S (S'Last - 4 .. S'Last - 1));\n-                                    Output.Write_Str (\" of \");\n-                                    Output.Write_Line\n-                                      (S (S'First + 5 .. S'Last - 7));\n+                              for J in 1 .. Text_Last loop\n+                                 if Text_Line (J) = ')' then\n+                                    Text_Last := J;\n+                                    exit;\n                                  end if;\n+                              end loop;\n+\n+                              declare\n+                                 S : constant String :=\n+                                       Text_Line (1 .. Text_Last);\n+\n+                              begin\n+                                 if S'Length >= 13\n+                                   and then S (S'First .. S'First + 3) = \"Unit\"\n+                                 then\n+                                    if Opt.Verbose_Mode then\n+                                       Output.Write_Str\n+                                         (S (S'Last - 4 .. S'Last - 1));\n+                                       Output.Write_Str (\" of \");\n+                                       Output.Write_Line\n+                                         (S (S'First + 5 .. S'Last - 7));\n+                                    end if;\n \n-                                 if Project_File then\n-\n-                                    --  Add the corresponding attribute in the\n-                                    --  Naming package of the naming project.\n-\n-                                    declare\n-                                       Decl_Item : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                         (Of_Kind =>\n-                                            N_Declarative_Item);\n-\n-                                       Attribute : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                         (Of_Kind =>\n-                                            N_Attribute_Declaration);\n-\n-                                       Expression : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                         (Of_Kind => N_Expression,\n-                                          And_Expr_Kind => Single);\n-\n-                                       Term : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                         (Of_Kind => N_Term,\n-                                          And_Expr_Kind => Single);\n-\n-                                       Value : constant Project_Node_Id :=\n-                                         Default_Project_Node\n-                                         (Of_Kind => N_Literal_String,\n-                                          And_Expr_Kind => Single);\n-\n-                                    begin\n-                                       Set_Next_Declarative_Item\n-                                         (Decl_Item,\n-                                          To => First_Declarative_Item_Of\n-                                            (Naming_Package));\n-                                       Set_First_Declarative_Item_Of\n-                                         (Naming_Package, To => Decl_Item);\n-                                       Set_Current_Item_Node\n-                                         (Decl_Item, To => Attribute);\n-\n-                                       if\n-                                         S (S'Last - 5 .. S'Last) = \"(spec)\"\n+                                    if Project_File then\n+\n+                                       --  Add the corresponding attribute in\n+                                       --  the Naming package of the naming\n+                                       --  project.\n+\n+                                       declare\n+                                          Decl_Item : constant Project_Node_Id\n+                                            := Default_Project_Node\n+                                              (Of_Kind =>\n+                                                   N_Declarative_Item);\n+\n+                                          Attribute : constant Project_Node_Id\n+                                            := Default_Project_Node\n+                                              (Of_Kind =>\n+                                                   N_Attribute_Declaration);\n+\n+                                          Expression : constant Project_Node_Id\n+                                            := Default_Project_Node\n+                                              (Of_Kind => N_Expression,\n+                                               And_Expr_Kind => Single);\n+\n+                                          Term : constant Project_Node_Id :=\n+                                                   Default_Project_Node\n+                                                     (Of_Kind => N_Term,\n+                                                      And_Expr_Kind => Single);\n+\n+                                          Value : constant Project_Node_Id :=\n+                                                    Default_Project_Node\n+                                                      (Of_Kind =>\n+                                                         N_Literal_String,\n+                                                       And_Expr_Kind =>\n+                                                         Single);\n+\n+                                       begin\n+                                          Set_Next_Declarative_Item\n+                                            (Decl_Item,\n+                                             To => First_Declarative_Item_Of\n+                                               (Naming_Package));\n+                                          Set_First_Declarative_Item_Of\n+                                            (Naming_Package, To => Decl_Item);\n+                                          Set_Current_Item_Node\n+                                            (Decl_Item, To => Attribute);\n+\n+                                          --  Is it a spec or a body?\n+\n+                                          if S (S'Last - 5 .. S'Last) =\n+                                            \"(spec)\"\n+                                          then\n+                                             Set_Name_Of\n+                                               (Attribute, To => Name_Spec);\n+                                          else\n+                                             Set_Name_Of\n+                                               (Attribute,\n+                                                To => Name_Body);\n+                                          end if;\n+\n+                                          --  Get the name of the unit\n+\n+                                          Name_Len := S'Last - S'First - 11;\n+                                          Name_Buffer (1 .. Name_Len) :=\n+                                            (To_Lower\n+                                               (S (S'First + 5 ..\n+                                                     S'Last - 7)));\n+                                          Set_Associative_Array_Index_Of\n+                                            (Attribute, To => Name_Find);\n+\n+                                          Set_Expression_Of\n+                                            (Attribute, To => Expression);\n+                                          Set_First_Term\n+                                            (Expression, To => Term);\n+                                          Set_Current_Term (Term, To => Value);\n+\n+                                          --  And set the name of the file\n+\n+                                          Name_Len := Last;\n+                                          Name_Buffer (1 .. Name_Len) :=\n+                                            Str (1 .. Last);\n+                                          Set_String_Value_Of\n+                                            (Value, To => Name_Find);\n+                                       end;\n+\n+                                       --  Add source file name to source list\n+                                       --  file.\n+\n+                                       Last := Last + 1;\n+                                       Str (Last) := ASCII.LF;\n+\n+                                       if Write (Source_List_FD,\n+                                                 Str (1)'Address,\n+                                                 Last) /= Last\n                                        then\n-                                          Set_Name_Of\n-                                            (Attribute, To => Name_Spec);\n-                                       else\n-                                          Set_Name_Of\n-                                            (Attribute,\n-                                             To => Name_Body);\n+                                          Prj.Com.Fail (\"disk full\");\n                                        end if;\n-\n-                                       Name_Len := S'Last - S'First - 11;\n-                                       Name_Buffer (1 .. Name_Len) :=\n-                                         (To_Lower\n-                                            (S (S'First + 5 .. S'Last - 7)));\n-                                       Set_Associative_Array_Index_Of\n-                                         (Attribute, To => Name_Find);\n-\n-                                       Set_Expression_Of\n-                                         (Attribute, To => Expression);\n-                                       Set_First_Term (Expression, To => Term);\n-                                       Set_Current_Term (Term, To => Value);\n-\n-                                       Name_Len := Last;\n-                                       Name_Buffer (1 .. Name_Len) :=\n-                                         Str (1 .. Last);\n-                                       Set_String_Value_Of\n-                                         (Value, To => Name_Find);\n-                                    end;\n-\n-                                    --  Add source file name to source list\n-                                    --  file.\n-\n-                                    Last := Last + 1;\n-                                    Str (Last) := ASCII.LF;\n-\n-                                    if Write (Source_List_FD,\n-                                              Str (1)'Address,\n-                                              Last) /= Last\n-                                    then\n-                                       Prj.Com.Fail (\"disk full\");\n+                                    else\n+                                       --  Add an entry in the SFN_Pragmas\n+                                       --  table.\n+\n+                                       SFN_Pragmas.Increment_Last;\n+                                       SFN_Pragmas.Table (SFN_Pragmas.Last) :=\n+                                         (Unit => new String'\n+                                            (S (S'First + 5 .. S'Last - 7)),\n+                                          File => new String'(Str (1 .. Last)),\n+                                          Spec => S (S'Last - 5 .. S'Last)\n+                                          = \"(spec)\");\n                                     end if;\n-                                 else\n-                                    --  Add an entry in the SFN_Pragmas table\n-\n-                                    SFN_Pragmas.Increment_Last;\n-                                    SFN_Pragmas.Table (SFN_Pragmas.Last) :=\n-                                      (Unit => new String'\n-                                         (S (S'First + 5 .. S'Last - 7)),\n-                                       File => new String'(Str (1 .. Last)),\n-                                       Spec => S (S'Last - 5 .. S'Last)\n-                                       = \"(spec)\");\n-                                 end if;\n \n-                              else\n-                                 if Opt.Verbose_Mode then\n-                                    Output.Write_Line (\"not a unit\");\n+                                 else\n+                                    if Opt.Verbose_Mode then\n+                                       Output.Write_Line (\"not a unit\");\n+                                    end if;\n                                  end if;\n-                              end if;\n-                           end;\n-\n-                        else\n-                           if Opt.Verbose_Mode then\n-                              Output.Write_Line (\"not a unit\");\n+                              end;\n                            end if;\n-                        end if;\n-\n-                        Close (PD);\n+                        end;\n                      end;\n \n                   else"}, {"sha": "7ad849b1a4c6919fbf8f367890ac6f748a246b07", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -667,7 +667,7 @@ package body Prj.Nmsc is\n                if Element.Value /= No_Name then\n                   declare\n                      Source_Directory : constant String :=\n-                       Get_Name_String (Element.Value);\n+                       Get_Name_String (Element.Display_Value);\n \n                   begin\n                      if Current_Verbosity = High then\n@@ -691,9 +691,6 @@ package body Prj.Nmsc is\n \n                         exit when Name_Len = 0;\n \n-                        --  Canonical_Case_File_Name\n-                        --    (Name_Buffer (1 .. Name_Len));\n-\n                         declare\n                            File_Name : constant Name_Id := Name_Find;\n                            Dir       : constant String :=\n@@ -2721,15 +2718,6 @@ package body Prj.Nmsc is\n       begin\n          if Current_Verbosity = High then\n             Write_Str (\"Find_Source_Dirs (\"\"\");\n-         end if;\n-\n-         Get_Name_String (From);\n-         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-\n-         --  Directory    := Name_Buffer (1 .. Name_Len);\n-         --  Why is above line commented out ???\n-\n-         if Current_Verbosity = High then\n             Write_Str (Directory);\n             Write_Line (\"\"\")\");\n          end if;"}, {"sha": "9a965ef1515b0ddd1895ed53c3b3d16dbe8eecab", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 57, "deletions": 12, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *             Copyright (C) 1992-2003, Free Software Foundation, Inc.      *\n+ *             Copyright (C) 1992-2004, Free Software Foundation, Inc.      *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -482,12 +482,6 @@ typedef struct\n      This is compared against the ttype entries associated with actions in the\n      examined context to see if one of these actions matches.  */\n \n-  bool handled_by_others;\n-  /* Indicates wether a \"when others\" may catch this exception, also filled by\n-     Propagate_Exception.\n-\n-     This is used to decide if a GNAT_OTHERS ttype entry matches.  */\n-\n   int  n_cleanups_to_trigger;\n   /* Number of cleanups on the propagation way for the occurrence. This is\n      initialized to 0 by Propagate_Exception and computed by the personality\n@@ -846,6 +840,59 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n \n #endif\n \n+/* With CHOICE an exception choice representing an \"exception - when\"\n+   argument, and PROPAGATED_EXCEPTION a pointer to the currently propagated\n+   occurrence, return true iif the latter matches the former, that is, if\n+   PROPAGATED_EXCEPTION is caught by the handling code controlled by CHOICE.\n+   This takes care of the special Non_Ada_Error case on VMS.  */\n+\n+#define Is_Handled_By_Others __gnat_is_handled_by_others\n+#define Language_For __gnat_language_for\n+#define Import_Code_For __gnat_import_code_for\n+\n+extern bool Is_Handled_By_Others (_Unwind_Ptr e);\n+extern char Language_For (_Unwind_Ptr e);\n+\n+extern Exception_Code Import_Code_For (_Unwind_Ptr e);\n+\n+static int\n+is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n+{\n+  /* Pointer to the GNAT exception data corresponding to the propagated\n+     occurrence.  */\n+  _Unwind_Ptr E = propagated_exception->id;\n+\n+  /* Base matching rules: An exception data (id) matches itself, \"when\n+     all_others\" matches anything and \"when others\" matches anything unless\n+     explicitely stated otherwise in the propagated occurrence.  */\n+\n+  bool is_handled =\n+    choice == E\n+    || choice == GNAT_ALL_OTHERS\n+    || (choice == GNAT_OTHERS && Is_Handled_By_Others (E));\n+\n+  /* In addition, on OpenVMS, Non_Ada_Error matches VMS exceptions, and we\n+     may have different exception data pointers that should match for the\n+     same condition code, if both an export and an import have been\n+     registered.  The import code for both the choice and the propagated\n+     occurrence are expected to have been masked off regarding severity\n+     bits already (at registration time for the former and from within the\n+     low level exception vector for the latter).  */\n+#ifdef VMS\n+  #define Non_Ada_Error system__aux_dec__non_ada_error\n+  extern struct Exception_Data Non_Ada_Error;\n+\n+  is_handled |=\n+    (Language_For (E) == 'V'\n+     && choice != GNAT_OTHERS && choice != GNAT_ALL_OTHERS\n+     && ((Language_For (choice) == 'V' && Import_Code_For (choice) != 0\n+\t  && Import_Code_For (choice) == Import_Code_For (E))\n+\t || choice == (_Unwind_Ptr)&Non_Ada_Error));\n+#endif\n+\n+  return is_handled;\n+}\n+\n /* Fill out the ACTION to be taken from propagating UW_EXCEPTION up to\n    UW_CONTEXT in REGION.  */\n \n@@ -907,14 +954,12 @@ get_action_description_for (_Unwind_Context *uw_context,\n \t    {\n \t      /* See if the filter we have is for an exception which matches\n \t\t the one we are propagating.  */\n-\t      _Unwind_Ptr eid = get_ttype_entry_for (region, ar_filter);\n+\t      _Unwind_Ptr choice = get_ttype_entry_for (region, ar_filter);\n \n-\t      if (eid == gnat_exception->id\n-\t\t  || eid == GNAT_ALL_OTHERS\n-\t\t  || (eid == GNAT_OTHERS && gnat_exception->handled_by_others))\n+\t      if (is_handled_by (choice, gnat_exception))\n \t\t{\n \t\t  action->ttype_filter = ar_filter;\n-\t\t  action->ttype_entry = eid;\n+\t\t  action->ttype_entry = choice;\n \t\t  action->kind = handler;\n \t\t  return;\n \t\t}"}, {"sha": "f9eb02aff7264c664eab1b4367a46998b92625b1", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -30,13 +30,17 @@\n  *                                                                          *\n  ****************************************************************************/\n \n+\n+typedef unsigned Exception_Code;\n+/* C counterpart of what System.Standard_Library defines.  */\n+\n struct Exception_Data\n {\n   char  Handled_By_Others;\n   char Lang;\n   int Name_Length;\n   char *Full_Name, Htable_Ptr;\n-  int Import_Code;\n+  Exception_Code Import_Code;\n };\n \n typedef struct Exception_Data *Exception_Id;"}, {"sha": "04ef5b9dcd63f694a953725d518b44253a78e2ec", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1049,6 +1049,7 @@ package Rtsfind is\n      RE_Shared_Var_WOpen,                -- System.Shared_Storage\n \n      RE_Abort_Undefer_Direct,            -- System.Standard_Library\n+     RE_Exception_Code,                  -- System.Standard_Library\n      RE_Exception_Data_Ptr,              -- System.Standard_Library\n \n      RE_Integer_Address,                 -- System.Storage_Elements\n@@ -1989,6 +1990,7 @@ package Rtsfind is\n      RE_Shared_Var_WOpen                 => System_Shared_Storage,\n \n      RE_Abort_Undefer_Direct             => System_Standard_Library,\n+     RE_Exception_Code                   => System_Standard_Library,\n      RE_Exception_Data_Ptr               => System_Standard_Library,\n \n      RE_Integer_Address                  => System_Storage_Elements,"}, {"sha": "006cf9337163d90e245a199ebd8d809585af4d75", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -774,12 +774,12 @@ package body System.File_IO is\n       end;\n \n       --  If we were given a stream (call from xxx.C_Streams.Open), then set\n-      --  full name to null and that is all we have to do in this case so\n-      --  skip to end of processing.\n+      --  the full name to the given one, and skip to end of processing.\n \n       if Stream /= NULL_Stream then\n-         Fullname (1) := ASCII.Nul;\n-         Full_Name_Len := 1;\n+         Full_Name_Len := Name'Length + 1;\n+         Fullname (1 .. Full_Name_Len - 1) := Name;\n+         Fullname (Full_Name_Len) := ASCII.Nul;\n \n       --  Normal case of Open or Create\n "}, {"sha": "84bf0b9e737e21f0910ff460d7904fb00d91748b", "filename": "gcc/ada/s-stalib.ads", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-stalib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-stalib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stalib.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -97,6 +97,20 @@ package System.Standard_Library is\n    type Exception_Data_Ptr is access all Exception_Data;\n    --  An equivalent of Exception_Id that is public\n \n+   type Exception_Code is mod 2 ** 32;\n+   --  A scalar value bound to some exception data. Typically used for\n+   --  imported or exported exceptions on VMS. Having a separate type for this\n+   --  is useful to enforce consistency throughout the various run-time units\n+   --  handling such codes, and having it unsigned is the most appropriate\n+   --  choice for it's currently single use on VMS.\n+\n+   --  ??? The construction in Cstand has no way to access the proper type\n+   --  node for Exception_Code, and currently uses Standard_Unsigned as a\n+   --  fallback. The representations shall match, and the size clause below\n+   --  is aimed at ensuring that.\n+\n+   for Exception_Code'Size use Integer'Size;\n+\n    --  The following record defines the underlying representation of exceptions\n \n    --  WARNING! Any changes to this may need to be reflectd in the following\n@@ -131,7 +145,7 @@ package System.Standard_Library is\n       --  built (by Register_Exception in s-exctab.adb) for converting between\n       --  identities and names.\n \n-      Import_Code : Integer;\n+      Import_Code : Exception_Code;\n       --  Value for imported exceptions. Needed only for the handling of\n       --  Import/Export_Exception for the VMS case, but present in all\n       --  implementations (we might well extend this mechanism for other"}, {"sha": "821197593cca29d589842493fb7351b11c607ed5", "filename": "gcc/ada/s-tataat.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-tataat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-tataat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -57,9 +57,13 @@ package System.Tasking.Task_Attributes is\n \n    type Dummy_Wrapper;\n    type Access_Dummy_Wrapper is access all Dummy_Wrapper;\n+   pragma No_Strict_Aliasing (Access_Dummy_Wrapper);\n+   --  Needed to avoid possible incorrect aliasing situations from\n+   --  instantiation of Unchecked_Conversion in body of Ada.Task_Attributes.\n+\n    for Access_Dummy_Wrapper'Storage_Size use 0;\n-   --  This is a stand-in for the generic type Wrapper defined in\n-   --  Ada.Task_Attributes. The real objects allocated are always\n+   --  Access_Dummy_Wrapper is a stand-in for the generic type Wrapper defined\n+   --  in Ada.Task_Attributes. The real objects allocated are always\n    --  of type Wrapper, no Dummy_Wrapper objects are ever created.\n \n    type Deallocator is access procedure (P : in out Access_Node);"}, {"sha": "6798acbedbec56035bb9d103106dc0b09b170b2b", "filename": "gcc/ada/s-thread.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-thread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-thread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -34,15 +34,18 @@\n --  This package provides facilities to register a thread to the runtime,\n --  and allocate its task specific datas.\n \n---  pragma Thread_Body is currently supported for:\n---  VxWorks AE653 with the restricted / cert runtime\n+--  This package is currently implemented for:\n+--  VxWorks AE653 rts-cert\n+--  VxWorks AE653 rts-full (not rts-kernel)\n \n with Ada.Exceptions;\n --  used for Exception_Occurrence\n \n with System.Soft_Links;\n --  used for TSD\n \n+with Unchecked_Conversion;\n+\n package System.Threads is\n \n    subtype EO is Ada.Exceptions.Exception_Occurrence;\n@@ -54,6 +57,7 @@ package System.Threads is\n    --  by the GNAT runtime.\n \n    type ATSD_Access is access ATSD;\n+   function From_Address is new Unchecked_Conversion (Address, ATSD_Access);\n \n    --  Get/Set for the attributes of the current thread\n "}, {"sha": "935ed1e7a3962af61515fcdf621144b5b5e883d4", "filename": "gcc/ada/s-vmexta.adb", "status": "modified", "additions": 54, "deletions": 33, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-vmexta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-vmexta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vmexta.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@ pragma Elaborate_All (System.HTable);\n \n package body System.VMS_Exception_Table is\n \n-   use System.Standard_Library;\n+   use type SSL.Exception_Code;\n \n    type HTable_Headers is range 1 .. 37;\n \n@@ -49,8 +49,8 @@ package body System.VMS_Exception_Table is\n    --  Ada exception.\n \n    type Exception_Code_Data is record\n-      Code       : Natural;\n-      Except     : Exception_Data_Ptr;\n+      Code       : SSL.Exception_Code;\n+      Except     : SSL.Exception_Data_Ptr;\n       HTable_Ptr : Exception_Code_Data_Ptr;\n    end record;\n \n@@ -61,8 +61,8 @@ package body System.VMS_Exception_Table is\n    function Get_HT_Link (T : Exception_Code_Data_Ptr)\n      return Exception_Code_Data_Ptr;\n \n-   function Hash (F : Natural) return HTable_Headers;\n-   function Get_Key (T : Exception_Code_Data_Ptr) return Natural;\n+   function Hash (F : SSL.Exception_Code) return HTable_Headers;\n+   function Get_Key (T : Exception_Code_Data_Ptr) return SSL.Exception_Code;\n \n    package Exception_Code_HTable is new System.HTable.Static_HTable (\n      Header_Num => HTable_Headers,\n@@ -71,16 +71,29 @@ package body System.VMS_Exception_Table is\n      Null_Ptr   => null,\n      Set_Next   => Set_HT_Link,\n      Next       => Get_HT_Link,\n-     Key        => Natural,\n+     Key        => SSL.Exception_Code,\n      Get_Key    => Get_Key,\n      Hash       => Hash,\n      Equal      => \"=\");\n \n+   ------------------\n+   -- Base_Code_In --\n+   ------------------\n+\n+   function Base_Code_In\n+     (Code : SSL.Exception_Code) return SSL.Exception_Code\n+   is\n+   begin\n+      return Code and not 2#0111#;\n+   end Base_Code_In;\n+\n    ---------------------\n    -- Coded_Exception --\n    ---------------------\n \n-   function Coded_Exception (X : Natural) return Exception_Data_Ptr is\n+   function Coded_Exception\n+     (X : SSL.Exception_Code) return SSL.Exception_Data_Ptr\n+   is\n       Res : Exception_Code_Data_Ptr;\n \n    begin\n@@ -98,8 +111,9 @@ package body System.VMS_Exception_Table is\n    -- Get_HT_Link --\n    -----------------\n \n-   function  Get_HT_Link (T : Exception_Code_Data_Ptr)\n-     return Exception_Code_Data_Ptr is\n+   function Get_HT_Link\n+     (T : Exception_Code_Data_Ptr) return Exception_Code_Data_Ptr\n+   is\n    begin\n       return T.HTable_Ptr;\n    end Get_HT_Link;\n@@ -108,7 +122,9 @@ package body System.VMS_Exception_Table is\n    -- Get_Key --\n    -------------\n \n-   function Get_Key (T : Exception_Code_Data_Ptr) return Natural is\n+   function Get_Key (T : Exception_Code_Data_Ptr)\n+     return SSL.Exception_Code\n+   is\n    begin\n       return T.Code;\n    end Get_Key;\n@@ -117,39 +133,44 @@ package body System.VMS_Exception_Table is\n    -- Hash --\n    ----------\n \n-   function Hash (F : Natural) return HTable_Headers is\n+   function Hash\n+     (F : SSL.Exception_Code) return HTable_Headers\n+   is\n+      Headers_Magnitude : constant SSL.Exception_Code :=\n+        SSL.Exception_Code (HTable_Headers'Last - HTable_Headers'First + 1);\n+\n    begin\n-      return HTable_Headers\n-        (F mod Natural (HTable_Headers'Last - HTable_Headers'First + 1) + 1);\n+      return HTable_Headers (F mod Headers_Magnitude + 1);\n    end Hash;\n \n    ----------------------------\n    -- Register_VMS_Exception --\n    ----------------------------\n \n-   procedure Register_VMS_Exception (Code : Integer) is\n-      Excode : constant Integer := (Code / 8) * 8;\n-      --  Mask off lower 3 bits which are the severity\n+   procedure Register_VMS_Exception\n+     (Code : SSL.Exception_Code;\n+      E    : SSL.Exception_Data_Ptr)\n+   is\n+      --  We bind the exception data with the base code found in the\n+      --  input value, that is with the severity bits masked off.\n+\n+      Excode : constant SSL.Exception_Code := Base_Code_In (Code);\n \n    begin\n-      --  This allocates an empty exception that gets filled in by\n-      --  __gnat_error_handler when the exception is raised. Allocating\n-      --  it here prevents having to allocate it each time the exception\n-      --  is raised.\n+      --  The exception data registered here is mostly filled prior to this\n+      --  call and by __gnat_error_handler when the exception is raised. We\n+      --  still need to fill a couple of components for exceptions that will\n+      --  be used as propagation filters (exception data pointer registered\n+      --  as choices in the unwind tables): in some import/export cases, the\n+      --  exception pointers for the choice and the propagated occurrence may\n+      --  indeed be different for a single import code, and the personality\n+      --  routine attempts to match the import codes in this case.\n+\n+      E.Lang := 'V';\n+      E.Import_Code := Excode;\n \n       if Exception_Code_HTable.Get (Excode) = null then\n-         Exception_Code_HTable.Set\n-           (new Exception_Code_Data'\n-             (Excode,\n-              new Exception_Data'\n-               (Not_Handled_By_Others => False,\n-                Lang                  => 'V',\n-                Name_Length           => 0,\n-                Full_Name             => null,\n-                HTable_Ptr            => null,\n-                Import_Code           => 0,\n-                Raise_Hook            => null),\n-              null));\n+         Exception_Code_HTable.Set (new Exception_Code_Data'(Excode, E, null));\n       end if;\n    end Register_VMS_Exception;\n "}, {"sha": "2aeed8c2a07aa951b0764b519ae1167b2eb59636", "filename": "gcc/ada/s-vmexta.ads", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-vmexta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fs-vmexta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vmexta.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 1997 Free Software Foundation, Inc.             --\n+--           Copyright (C) 1997-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,19 +35,27 @@\n --  where there is at least one Import/Export exception present.\n \n with System.Standard_Library;\n+\n package System.VMS_Exception_Table is\n \n-   procedure Register_VMS_Exception (Code : Integer);\n+   package SSL renames System.Standard_Library;\n+\n+   procedure Register_VMS_Exception\n+     (Code : SSL.Exception_Code;\n+      E    : SSL.Exception_Data_Ptr);\n    --  Register an exception in the hash table mapping with a VMS\n    --  condition code.\n \n    --  LOTS more comments needed here regarding the enire scheme ???\n \n private\n \n-   function Coded_Exception (X : Natural)\n-     return System.Standard_Library.Exception_Data_Ptr;\n+   function Base_Code_In (Code : SSL.Exception_Code) return SSL.Exception_Code;\n+   --  Value of Code with the severity bits masked off.\n+\n+   function Coded_Exception (X : SSL.Exception_Code)\n+     return SSL.Exception_Data_Ptr;\n    --  Given a VMS condition, find and return it's allocated Ada exception\n-   --  (called only from a-init.c).\n+   --  (called only from init.c).\n \n end System.VMS_Exception_Table;"}, {"sha": "90f285c029fd238715944714cd170b7af23688bf", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -7892,6 +7892,7 @@ package body Sem_Ch12 is\n             --  actual must correspond to a discriminant of the formal.\n \n             elsif Has_Discriminants (Act_T)\n+              and then not Has_Unknown_Discriminants (Act_T)\n               and then Has_Discriminants (Ancestor)\n             then\n                Actual_Discr   := First_Discriminant (Act_T);\n@@ -7923,7 +7924,9 @@ package body Sem_Ch12 is\n             --  for constrainedness, but the check here is added for\n             --  completeness.\n \n-            elsif Has_Discriminants (Act_T) then\n+            elsif Has_Discriminants (Act_T)\n+              and then not Has_Unknown_Discriminants (Act_T)\n+            then\n                Error_Msg_NE\n                  (\"actual for & must not have discriminants\", Actual, Gen_T);\n                Abandon_Instantiation (Actual);"}, {"sha": "e89041a0eb7f355490848515a62af6af933dc011", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -3852,15 +3852,16 @@ package body Sem_Ch13 is\n          end if;\n       end if;\n \n-      --  In GNAT mode, if target is an access type, access type must be\n-      --  declared in the same source unit as the unchecked conversion.\n-\n---      if GNAT_Mode and then Is_Access_Type (Target) then\n---         if not In_Same_Source_Unit (Target, N) then\n---            Error_Msg_NE\n---              (\"unchecked conversion not in same unit as&\", N, Target);\n---         end if;\n---      end if;\n+      --  If unchecked conversion to access type, and access type is\n+      --  declared in the same unit as the unchecked conversion, then\n+      --  set the No_Strict_Aliasing flag (no strict aliasing is\n+      --  implicit in this situation).\n+\n+      if Is_Access_Type (Target) and then\n+        In_Same_Source_Unit (Target, N)\n+      then\n+         Set_No_Strict_Aliasing (Implementation_Base_Type (Target));\n+      end if;\n \n       --  Generate N_Validate_Unchecked_Conversion node for back end in\n       --  case the back end needs to perform special validation checks."}, {"sha": "c1cff22e39fbdb392cbd3d48a00ef1af978afc30", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -2142,6 +2142,10 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (T);\n       Make_Class_Wide_Type (T);\n \n+      if Unknown_Discriminants_Present (N) then\n+         Set_Discriminant_Constraint (T, No_Elist);\n+      end if;\n+\n       Build_Derived_Record_Type (N, Parent_Type, T);\n    end Analyze_Private_Extension_Declaration;\n \n@@ -6575,6 +6579,7 @@ package body Sem_Ch3 is\n       if Ekind (Full_Base) = E_Record_Type\n         and then Has_Discriminants (Full_Base)\n         and then Has_Discriminants (Priv) -- might not, if errors\n+        and then not Has_Unknown_Discriminants (Priv)\n         and then not Is_Empty_Elmt_List (Discriminant_Constraint (Priv))\n       then\n          Create_Constrained_Components"}, {"sha": "55dbc2317b28ca6c59f3045e48edcc7104865802", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -401,6 +401,7 @@ package body Sem_Ch6 is\n          Check_References (Gen_Id);\n       end;\n \n+      Process_End_Label (Handled_Statement_Sequence (N), 't', Current_Scope);\n       End_Scope;\n       Check_Subprogram_Order (N);\n "}, {"sha": "3d718d7b800cd50084a2b6168fc3657189b8753f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -7508,7 +7508,7 @@ package body Sem_Prag is\n                   Error_Pragma_Arg (\"pragma% requires access type\", Arg1);\n                end if;\n \n-               Set_No_Strict_Aliasing (Base_Type (E_Id));\n+               Set_No_Strict_Aliasing (Implementation_Base_Type (E_Id));\n             end if;\n          end No_Strict_Alias;\n "}, {"sha": "fb1b766da778b3661240f16b7c39e543935b9166", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -1695,9 +1695,7 @@ tree_transform (Node_Id gnat_node)\n \t{\n \t  unsigned int align = known_alignment (gnu_result);\n \t  tree gnu_obj_type = TREE_TYPE (gnu_result_type);\n-\t  unsigned int oalign\n-\t    = TREE_CODE (gnu_obj_type) == FUNCTION_TYPE\n-\t      ? FUNCTION_BOUNDARY : TYPE_ALIGN (gnu_obj_type);\n+\t  unsigned int oalign = TYPE_ALIGN (gnu_obj_type);\n \n \t  if (align != 0 && align < oalign && ! TYPE_ALIGN_OK (gnu_obj_type))\n \t    post_error_ne_tree_2"}, {"sha": "fd9cb34057db50684958d87a653ce5d092c39dd2", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f69614254b9df2875c93ed4d7ce5eed1a54c62/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=e6f69614254b9df2875c93ed4d7ce5eed1a54c62", "patch": "@@ -517,8 +517,8 @@ package VMS_Data is\n    --   for a directory.\n \n    S_Bind_Shared  : aliased constant S := \"/SHARED \"                       &\n-                                            \"-shared\";\n-   --        /SHARED (D)\n+                                            \"-shared,!-static\";\n+   --        /SHARED\n    --        /NOSHARED\n    --\n    --    Link against a shared GNAT run time when available.\n@@ -537,6 +537,13 @@ package VMS_Data is\n    --\n    --    When looking for source files also look in directories specified.\n \n+   S_Bind_Static  : aliased constant S := \"/STATIC \"                       &\n+                                            \"-static,!-shared\";\n+   --        /STATIC\n+   --        /NOSTATIC\n+   --\n+   --    Link against a static GNAT run time.\n+\n    S_Bind_Store   : aliased constant S := \"/STORE_TRACEBACKS \"             &\n                                             \"-E\";\n    --        /STORE_TRACEBACKS (D)\n@@ -636,6 +643,7 @@ package VMS_Data is\n       S_Bind_Shared  'Access,\n       S_Bind_Slice   'Access,\n       S_Bind_Source  'Access,\n+      S_Bind_Static  'Access,\n       S_Bind_Store   'Access,\n       S_Bind_Time    'Access,\n       S_Bind_Verbose 'Access,"}]}