{"sha": "d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNmOWMxYjliYzhlOWEwZjdkNTY1MDcwYWQ1MjRhMmFlZmE1MGYzOA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2005-02-19T18:06:00Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-02-19T18:06:00Z"}, "message": "*  intrinsic/date_and_time.c: Fix conformance problems.\n\nFrom-SVN: r95284", "tree": {"sha": "15df27fc64a2f700912f24843241d28ad9d1cb1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15df27fc64a2f700912f24843241d28ad9d1cb1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38/comments", "author": null, "committer": null, "parents": [{"sha": "70132ce715586dd58b9167fb0611c0457dbe96e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70132ce715586dd58b9167fb0611c0457dbe96e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70132ce715586dd58b9167fb0611c0457dbe96e3"}], "stats": {"total": 196, "additions": 100, "deletions": 96}, "files": [{"sha": "22de50117988d371bc09d097237e92baf5e2f2a5", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38", "patch": "@@ -1,3 +1,7 @@\n+2005-02-19  Steven G. Kargl  <kargls@comcast.net>\n+\n+      *  intrinsic/date_and_time.c: Fix conformance problems.\n+\n 2005-02-01  Paul Thomas <paulthomas2@wanadoo.fr>\n \n \tPR libgfortran/19363"}, {"sha": "2364186a0d7090621e3dd1f1b77b30677f609a9f", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=d3f9c1b9bc8e9a0f7d565070ad524a2aefa50f38", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the DATE_AND_TIME intrinsic.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Steven Bosscher.\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -67,56 +67,56 @@ Boston, MA 02111-1307, USA.  */\n \n    DATE (optional) shall be scalar and of type default character, and\n    shall be of length at least 8 in order to contain the complete\n-   value. It is an INTENT (OUT) argument. Its leftmost 8 characters\n+   value. It is an INTENT(OUT) argument. Its leftmost 8 characters\n    are assigned a value of the form CCYYMMDD, where CC is the century,\n    YY the year within the century, MM the month within the year, and\n    DD the day within the month. If there is no date available, they\n    are assigned blanks.\n \n    TIME (optional) shall be scalar and of type default character, and\n    shall be of length at least 10 in order to contain the complete\n-   value. It is an INTENT (OUT) argument. Its leftmost 10 characters\n+   value. It is an INTENT(OUT) argument. Its leftmost 10 characters\n    are assigned a value of the form hhmmss.sss, where hh is the hour\n    of the day, mm is the minutes of the hour, and ss.sss is the\n    seconds and milliseconds of the minute. If there is no clock\n    available, they are assigned blanks.\n \n    ZONE (optional) shall be scalar and of type default character, and\n    shall be of length at least 5 in order to contain the complete\n-   value. It is an INTENT (OUT) argument. Its leftmost 5 characters\n-   are assigned a value of the form \u00b1hhmm, where hh and mm are the\n+   value. It is an INTENT(OUT) argument. Its leftmost 5 characters\n+   are assigned a value of the form \ufffdhhmm, where hh and mm are the\n    time difference with respect to Coordinated Universal Time (UTC) in\n    hours and parts of an hour expressed in minutes, respectively. If\n    there is no clock available, they are assigned blanks.\n \n    VALUES (optional) shall be of type default integer and of rank\n-   one. It is an INTENT (OUT) argument. Its size shall be at least\n+   one. It is an INTENT(OUT) argument. Its size shall be at least\n    8. The values returned in VALUES are as follows:\n \n-      VALUES (1) the year (for example, 2003), or HUGE (0) if there is\n+      VALUES(1) the year (for example, 2003), or -HUGE(0) if there is\n       no date available;\n \n-      VALUES (2) the month of the year, or HUGE (0) if there\n+      VALUES(2) the month of the year, or -HUGE(0) if there\n       is no date available;\n \n-      VALUES (3) the day of the month, or HUGE (0) if there is no date\n+      VALUES(3) the day of the month, or -HUGE(0) if there is no date\n       available;\n \n-      VALUES (4) the time difference with respect to Coordinated\n-      Universal Time (UTC) in minutes, or HUGE (0) if this information\n+      VALUES(4) the time difference with respect to Coordinated\n+      Universal Time (UTC) in minutes, or -HUGE(0) if this information\n       is not available;\n \n-      VALUES (5) the hour of the day, in the range of 0 to 23, or HUGE\n-      (0) if there is no clock;\n+      VALUES(5) the hour of the day, in the range of 0 to 23, or\n+      -HUGE(0) if there is no clock;\n \n-      VALUES (6) the minutes of the hour, in the range 0 to 59, or\n-      HUGE (0) if there is no clock;\n+      VALUES(6) the minutes of the hour, in the range 0 to 59, or\n+      -HUGE(0) if there is no clock;\n \n-      VALUES (7) the seconds of the minute, in the range 0 to 60, or\n-      HUGE (0) if there is no clock;\n+      VALUES(7) the seconds of the minute, in the range 0 to 60, or\n+      -HUGE(0) if there is no clock;\n \n-      VALUES (8) the milliseconds of the second, in the range 0 to\n-      999, or HUGE (0) if there is no clock.\n+      VALUES(8) the milliseconds of the second, in the range 0 to\n+      999, or -HUGE(0) if there is no clock.\n \n    NULL pointer represent missing OPTIONAL arguments.  All arguments\n    have INTENT(OUT).  Because of the -i8 option, we must implement\n@@ -129,125 +129,131 @@ Boston, MA 02111-1307, USA.  */\n    - There is no STDC/POSIX way to get VALUES(8).  A GNUish way may\n      be to use ftime.\n */\n+#define DATE_LEN 8\n+#define TIME_LEN 10   \n+#define ZONE_LEN 5\n+#define VALUES_SIZE 8\n \n extern void date_and_time (char *, char *, char *, gfc_array_i4 *,\n \t\t\t   GFC_INTEGER_4, GFC_INTEGER_4, GFC_INTEGER_4);\n export_proto(date_and_time);\n \n void\n-date_and_time (char *__date,\n-\t       char *__time,\n-\t       char *__zone,\n-\t       gfc_array_i4 *__values,\n-\t       GFC_INTEGER_4 __date_len,\n-\t       GFC_INTEGER_4 __time_len,\n-\t       GFC_INTEGER_4 __zone_len)\n+date_and_time (char *__date, char *__time, char *__zone,\n+\t       gfc_array_i4 *__values, GFC_INTEGER_4 __date_len,\n+\t       GFC_INTEGER_4 __time_len, GFC_INTEGER_4 __zone_len)\n {\n-#define DATE_LEN 8\n-#define TIME_LEN 10   \n-#define ZONE_LEN 5\n-#define VALUES_SIZE 8\n+  int i;\n   char date[DATE_LEN + 1];\n   char timec[TIME_LEN + 1];\n   char zone[ZONE_LEN + 1];\n   GFC_INTEGER_4 values[VALUES_SIZE];\n \n #ifndef HAVE_NO_DATE_TIME\n-  time_t lt = time (NULL);\n-  struct tm local_time = *localtime (&lt);\n-  struct tm UTC_time = *gmtime (&lt);\n-\n-  /* All arguments can be derived from VALUES.  */\n-  values[0] = 1900 + local_time.tm_year;\n-  values[1] = 1 + local_time.tm_mon;\n-  values[2] = local_time.tm_mday;\n-  values[3] = (local_time.tm_min - UTC_time.tm_min +\n-\t       60 * (local_time.tm_hour - UTC_time.tm_hour +\n+  time_t lt;\n+  struct tm local_time;\n+  struct tm UTC_time;\n+\n+  lt = time (NULL);\n+\n+  if (lt != (time_t) -1)\n+    {\n+      local_time = *localtime (&lt);\n+      UTC_time = *gmtime (&lt);\n+\n+      /* All arguments can be derived from VALUES.  */\n+      values[0] = 1900 + local_time.tm_year;\n+      values[1] = 1 + local_time.tm_mon;\n+      values[2] = local_time.tm_mday;\n+      values[3] = (local_time.tm_min - UTC_time.tm_min +\n+\t           60 * (local_time.tm_hour - UTC_time.tm_hour +\n \t\t     24 * (local_time.tm_yday - UTC_time.tm_yday)));\n-  values[4] = local_time.tm_hour;\n-  values[5] = local_time.tm_min;\n-  values[6] = local_time.tm_sec;\n+      values[4] = local_time.tm_hour;\n+      values[5] = local_time.tm_min;\n+      values[6] = local_time.tm_sec;\n+      values[7] = 0;\n+\n #if HAVE_GETTIMEOFDAY\n-    {\n-      struct timeval tp;\n+      {\n+\tstruct timeval tp;\n #  if GETTIMEOFDAY_ONE_ARGUMENT\n-      if (!gettimeofday (&tp))\n+\tif (!gettimeofday (&tp))\n #  else\n #    if HAVE_STRUCT_TIMEZONE\n-      struct timezone tzp;\n+\tstruct timezone tzp;\n \n       /* Some systems such as HP-UX, do have struct timezone, but\n \t gettimeofday takes void* as the 2nd arg.  However, the\n \t effect of passing anything other than a null pointer is\n-\t unspecified on HPUX.  Configure checks if gettimeofday\n+\t unspecified on HP-UX.  Configure checks if gettimeofday\n \t actually fails with a non-NULL arg and pretends that\n \t struct timezone is missing if it does fail.  */\n-      if (!gettimeofday (&tp, &tzp))\n+\tif (!gettimeofday (&tp, &tzp))\n #    else\n-      if (!gettimeofday (&tp, (void *) 0))\n+\tif (!gettimeofday (&tp, (void *) 0))\n #    endif /* HAVE_STRUCT_TIMEZONE  */\n #  endif /* GETTIMEOFDAY_ONE_ARGUMENT  */\n \tvalues[7] = tp.tv_usec / 1000;\n-    }\n-#else\n-   values[7] = GFC_INTEGER_4_HUGE;\n+      }\n #endif /* HAVE_GETTIMEOFDAY */\n \n-  if (__date)\n-    {\n #if HAVE_SNPRINTF\n-      snprintf (date, DATE_LEN + 1, \"%04d%02d%02d\",\n-\t\tvalues[0], values[1], values[2]);\n+      if (__date)\n+\tsnprintf (date, DATE_LEN + 1, \"%04d%02d%02d\",\n+\t\t  values[0], values[1], values[2]);\n+      if (__time)\n+\tsnprintf (timec, TIME_LEN + 1, \"%02d%02d%02d.%03d\",\n+\t\t  values[4], values[5], values[6], values[7]);\n+\n+      if (__zone)\n+\tsnprintf (zone, ZONE_LEN + 1, \"%+03d%02d\",\n+\t\t  values[3] / 60, abs (values[3] % 60));\n #else\n-      sprintf (date, \"%04d%02d%02d\",\n-\t       values[0], values[1], values[2]);\n-#endif\n-    }\n+      if (__date)\n+\tsprintf (date, \"%04d%02d%02d\", values[0], values[1], values[2]);\n \n-  if (__time)\n-    {\n-#if HAVE_SNPRINTF\n-      snprintf (timec, TIME_LEN + 1, \"%02d%02d%02d.%03d\",\n-\t\tvalues[4], values[5], values[6], values[7]);\n-#else\n-      sprintf (timec, \"%02d%02d%02d.%03d\",\n-\t       values[4], values[5], values[6], values[7]);\n-#endif\n-    }\n+      if (__time)\n+\tsprintf (timec, \"%02d%02d%02d.%03d\",\n+\t\t values[4], values[5], values[6], values[7]);\n \n-  if (__zone)\n-    {\n-#if HAVE_SNPRINTF\n-      snprintf (zone, ZONE_LEN + 1, \"%+03d%02d\",\n-\t\tvalues[3] / 60, abs (values[3] % 60));\n-#else\n-      sprintf (zone, \"%+03d%02d\",\n-\t       values[3] / 60, abs (values[3] % 60));\n+      if (__zone)\n+\tsprintf (zone, \"%+03d%02d\",\n+\t\t values[3] / 60, abs (values[3] % 60));\n #endif\n     }\n-#else /* if defined HAVE_NO_DATE_TIME  */\n-  /* We really have *nothing* to return, so return blanks and HUGE(0).  */\n+  else\n     {\n-      int i;\n-\n       memset (date, ' ', DATE_LEN);\n       date[DATE_LEN] = '\\0';\n \n       memset (timec, ' ', TIME_LEN);\n-      time[TIME_LEN] = '\\0';\n+      timec[TIME_LEN] = '\\0';\n \n       memset (zone, ' ', ZONE_LEN);\n       zone[ZONE_LEN] = '\\0';\n \n       for (i = 0; i < VALUES_SIZE; i++)\n-        values[i] = GFC_INTEGER_4_HUGE;\n-    }\n+\tvalues[i] = - GFC_INTEGER_4_HUGE;\n+    }   \n+#else /* if defined HAVE_NO_DATE_TIME  */\n+  /* We really have *nothing* to return, so return blanks and HUGE(0).  */\n+      \n+  memset (date, ' ', DATE_LEN);\n+  date[DATE_LEN] = '\\0';\n+\n+  memset (timec, ' ', TIME_LEN);\n+  timec[TIME_LEN] = '\\0';\n+\n+  memset (zone, ' ', ZONE_LEN);\n+  zone[ZONE_LEN] = '\\0';\n+\n+  for (i = 0; i < VALUES_SIZE; i++)\n+    values[i] = - GFC_INTEGER_4_HUGE;\n #endif  /* HAVE_NO_DATE_TIME  */\n \n   /* Copy the values into the arguments.  */\n   if (__values)\n     {\n-      int i;\n       size_t len, delta, elt_size;\n \n       elt_size = GFC_DESCRIPTOR_SIZE (__values);\n@@ -263,18 +269,16 @@ date_and_time (char *__date,\n \t  GFC_INTEGER_4 *vptr4 = __values->data;\n \n \t  for (i = 0; i < VALUES_SIZE; i++, vptr4 += delta)\n-\t    {\n-\t      *vptr4 = values[i];\n-\t    }\n+\t    *vptr4 = values[i];\n \t}\n       else if (elt_size == 8)\n         {\n \t  GFC_INTEGER_8 *vptr8 = (GFC_INTEGER_8 *)__values->data;\n \n \t  for (i = 0; i < VALUES_SIZE; i++, vptr8 += delta)\n \t    {\n-\t      if (values[i] == GFC_INTEGER_4_HUGE)\n-\t\t*vptr8 = GFC_INTEGER_8_HUGE;\n+\t      if (values[i] == - GFC_INTEGER_4_HUGE)\n+\t\t*vptr8 = - GFC_INTEGER_8_HUGE;\n \t      else\n \t\t*vptr8 = values[i];\n \t    }\n@@ -300,8 +304,4 @@ date_and_time (char *__date,\n       assert (__date_len >= DATE_LEN);\n       fstrcpy (__date, DATE_LEN, date, DATE_LEN);\n     }\n-#undef DATE_LEN\n-#undef TIME_LEN   \n-#undef ZONE_LEN\n-#undef VALUES_SIZE\n }"}]}