{"sha": "158d55fa393867c794df5aa43b693f61e5916b83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4ZDU1ZmEzOTM4NjdjNzk0ZGY1YWE0M2I2OTNmNjFlNTkxNmI4Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T17:06:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T17:06:34Z"}, "message": "[multiple changes]\n\n2014-02-24  Robert Dewar  <dewar@adacore.com>\n\n\t* a-tags.adb, s-os_lib.adb: Minor reformatting.\n\n2014-02-24  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-sercom-mingw.adb, g-sercom-linux.adb (Raise_Error): Include\n\tstrerror message, not just numeric errno value.\n\n2014-02-24  Doug Rupp  <rupp@adacore.com>\n\n\t* raise-gcc.c (exception_class_eq): Make endian neutral.\n\n2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* atree.ads, atree,adb (Copy_Separate_Tree): Remove Syntax_Only\n\tflag, and reset Etype and Analyzed attributes unconditionally\n\twhen copying a tree that may be partly analyzed.\n\t* freeze.adb: Change calls to Copy_Separate_Tree accordingly.\n\t* sem_ch6.adb (Check_Inline_Pragma): If the Inline pragma appears\n\twithin a subprogram body and applies to it, remove it from the\n\tbody before making a copy of it, to prevent spurious errors when\n\tanalyzing the copied body.\n\nFrom-SVN: r208086", "tree": {"sha": "7b2b58757fa8dde2e0d1161f993fb42856cfee7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b2b58757fa8dde2e0d1161f993fb42856cfee7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/158d55fa393867c794df5aa43b693f61e5916b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158d55fa393867c794df5aa43b693f61e5916b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158d55fa393867c794df5aa43b693f61e5916b83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158d55fa393867c794df5aa43b693f61e5916b83/comments", "author": null, "committer": null, "parents": [{"sha": "5c20e503ba3644e0037b09db9384f70aaa1daaa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c20e503ba3644e0037b09db9384f70aaa1daaa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c20e503ba3644e0037b09db9384f70aaa1daaa5"}], "stats": {"total": 227, "additions": 117, "deletions": 110}, "files": [{"sha": "dabca5923a1eb5e65e18179184ebaeac52bbd9e9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -1,3 +1,27 @@\n+2014-02-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-tags.adb, s-os_lib.adb: Minor reformatting.\n+\n+2014-02-24  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-sercom-mingw.adb, g-sercom-linux.adb (Raise_Error): Include\n+\tstrerror message, not just numeric errno value.\n+\n+2014-02-24  Doug Rupp  <rupp@adacore.com>\n+\n+\t* raise-gcc.c (exception_class_eq): Make endian neutral.\n+\n+2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* atree.ads, atree,adb (Copy_Separate_Tree): Remove Syntax_Only\n+\tflag, and reset Etype and Analyzed attributes unconditionally\n+\twhen copying a tree that may be partly analyzed.\n+\t* freeze.adb: Change calls to Copy_Separate_Tree accordingly.\n+\t* sem_ch6.adb (Check_Inline_Pragma): If the Inline pragma appears\n+\twithin a subprogram body and applies to it, remove it from the\n+\tbody before making a copy of it, to prevent spurious errors when\n+\tanalyzing the copied body.\n+\n 2014-02-24  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-os_lib.adb (Errno_Message): Do not depend on Integer'Image."}, {"sha": "e60ef19f9bbc8a924d1e883dee85e20901c66d54", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -31,6 +31,7 @@\n \n with Ada.Exceptions;\n with Ada.Unchecked_Conversion;\n+\n with System.HTable;\n with System.Storage_Elements; use System.Storage_Elements;\n with System.WCh_Con;          use System.WCh_Con;\n@@ -58,7 +59,8 @@ package body Ada.Tags is\n \n    function Length (Str : Cstring_Ptr) return Natural;\n    --  Length of string represented by the given pointer (treating the string\n-   --  as a C-style string, which is Nul terminated).\n+   --  as a C-style string, which is Nul terminated). See comment in body\n+   --  explaining why we cannot use the normal strlen built-in.\n \n    function OSD (T : Tag) return Object_Specific_Data_Ptr;\n    --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n@@ -179,7 +181,7 @@ package body Ada.Tags is\n \n    function OSD (T : Tag) return Object_Specific_Data_Ptr is\n       OSD_Ptr : constant Addr_Ptr :=\n-        To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n    begin\n       return To_Object_Specific_Data_Ptr (OSD_Ptr.all);\n    end OSD;\n@@ -190,9 +192,9 @@ package body Ada.Tags is\n \n    function SSD (T : Tag) return Select_Specific_Data_Ptr is\n       TSD_Ptr : constant Addr_Ptr :=\n-        To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n       TSD     : constant Type_Specific_Data_Ptr :=\n-        To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n    begin\n       return TSD.SSD;\n    end SSD;\n@@ -241,8 +243,9 @@ package body Ada.Tags is\n       function Equal (A, B : System.Address) return Boolean is\n          Str1 : constant Cstring_Ptr := To_Cstring_Ptr (A);\n          Str2 : constant Cstring_Ptr := To_Cstring_Ptr (B);\n-         J    : Integer := 1;\n+         J    : Integer;\n       begin\n+         J := 1;\n          loop\n             if Str1 (J) /= Str2 (J) then\n                return False;\n@@ -260,9 +263,9 @@ package body Ada.Tags is\n \n       function Get_HT_Link (T : Tag) return Tag is\n          TSD_Ptr : constant Addr_Ptr :=\n-           To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                     To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n          TSD     : constant Type_Specific_Data_Ptr :=\n-           To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                     To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       begin\n          return TSD.HT_Link.all;\n       end Get_HT_Link;\n@@ -285,9 +288,9 @@ package body Ada.Tags is\n \n       procedure Set_HT_Link (T : Tag; Next : Tag) is\n          TSD_Ptr : constant Addr_Ptr :=\n-           To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                     To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n          TSD     : constant Type_Specific_Data_Ptr :=\n-           To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                     To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       begin\n          TSD.HT_Link.all := Next;\n       end Set_HT_Link;\n@@ -357,10 +360,7 @@ package body Ada.Tags is\n    -- Displace --\n    --------------\n \n-   function Displace\n-     (This : System.Address;\n-      T    : Tag) return System.Address\n-   is\n+   function Displace (This : System.Address; T : Tag) return System.Address is\n       Iface_Table : Interface_Data_Ptr;\n       Obj_Base    : System.Address;\n       Obj_DT      : Dispatch_Table_Ptr;\n@@ -418,7 +418,7 @@ package body Ada.Tags is\n \n    function DT (T : Tag) return Dispatch_Table_Ptr is\n       Offset : constant SSE.Storage_Offset :=\n-        To_Dispatch_Table_Ptr (T).Prims_Ptr'Position;\n+                 To_Dispatch_Table_Ptr (T).Prims_Ptr'Position;\n    begin\n       return To_Dispatch_Table_Ptr (To_Address (T) - Offset);\n    end DT;\n@@ -561,9 +561,9 @@ package body Ada.Tags is\n \n    function Interface_Ancestor_Tags (T : Tag) return Tag_Array is\n       TSD_Ptr     : constant Addr_Ptr :=\n-        To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                      To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n       TSD         : constant Type_Specific_Data_Ptr :=\n-        To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                      To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       Iface_Table : constant Interface_Data_Ptr := TSD.Interfaces_Table;\n \n    begin\n@@ -573,6 +573,7 @@ package body Ada.Tags is\n          begin\n             return Table;\n          end;\n+\n       else\n          declare\n             Table : Tag_Array (1 .. Iface_Table.Nb_Ifaces);\n@@ -605,13 +606,13 @@ package body Ada.Tags is\n \n       if External'Length > Internal_Tag_Header'Length\n         and then\n-         External (External'First ..\n-                     External'First + Internal_Tag_Header'Length - 1)\n-           = Internal_Tag_Header\n+          External (External'First ..\n+                      External'First + Internal_Tag_Header'Length - 1) =\n+                                                        Internal_Tag_Header\n       then\n          declare\n             Addr_First : constant Natural :=\n-              External'First + Internal_Tag_Header'Length;\n+                           External'First + Internal_Tag_Header'Length;\n             Addr_Last  : Natural;\n             Addr       : Integer_Address;\n \n@@ -783,9 +784,9 @@ package body Ada.Tags is\n \n    function Needs_Finalization (T : Tag) return Boolean is\n       TSD_Ptr : constant Addr_Ptr :=\n-        To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n       TSD     : constant Type_Specific_Data_Ptr :=\n-        To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n    begin\n       return TSD.Needs_Finalization;\n    end Needs_Finalization;\n@@ -803,9 +804,9 @@ package body Ada.Tags is\n       --  ancestor tags.\n \n       TSD_Ptr : constant Addr_Ptr :=\n-        To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n       TSD     : constant Type_Specific_Data_Ptr :=\n-        To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n+                  To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n       --  Pointer to the TSD\n \n       Parent_Tag     : constant Tag := TSD.Tags_Table (Parent_Slot);\n@@ -961,6 +962,7 @@ package body Ada.Tags is\n    is\n       Sec_Base : System.Address;\n       Sec_DT   : Dispatch_Table_Ptr;\n+\n    begin\n       --  Save the offset to top field in the secondary dispatch table\n "}, {"sha": "1e4e251b6b576a5b61a3b5400c3bad6f70cdd662", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -772,9 +772,7 @@ package body Atree is\n    -- Copy_Separate_Tree --\n    ------------------------\n \n-   function Copy_Separate_Tree\n-     (Source      : Node_Id;\n-      Syntax_Only : Boolean := False) return Node_Id\n+   function Copy_Separate_Tree (Source : Node_Id) return Node_Id\n    is\n       New_Id  : Node_Id;\n \n@@ -796,9 +794,7 @@ package body Atree is\n          New_Ent : Entity_Id;\n \n       begin\n-         --  Build appropriate node. Note that in this case, we do not need to\n-         --  do any special casing for Syntax_Only, since the new node has no\n-         --  Etype set, and is always unanalyzed.\n+         --  Build appropriate node.\n \n          case N_Entity (Nkind (E)) is\n             when N_Defining_Identifier =>\n@@ -835,7 +831,7 @@ package body Atree is\n                if Has_Extension (E) then\n                   Append (Copy_Entity (E), NL);\n                else\n-                  Append (Copy_Separate_Tree (E, Syntax_Only), NL);\n+                  Append (Copy_Separate_Tree (E), NL);\n                end if;\n \n                Next (E);\n@@ -855,7 +851,7 @@ package body Atree is\n       begin\n          if Field in Node_Range then\n             New_N :=\n-              Union_Id (Copy_Separate_Tree (Node_Id (Field), Syntax_Only));\n+              Union_Id (Copy_Separate_Tree (Node_Id (Field)));\n \n             if Parent (Node_Id (Field)) = Source then\n                Set_Parent (Node_Id (New_N), New_Id);\n@@ -906,45 +902,40 @@ package body Atree is\n             Set_Entity (New_Id, Empty);\n          end if;\n \n-         --  This is the point at which we do the special processing for\n-         --  the Syntax_Only flag being set:\n+         --  Reset all Etype fields and Analyzed flags, because tree may\n+         --  have been partly analyzed.\n \n-         if Syntax_Only then\n-\n-            --  Reset all Etype fields and Analyzed flags\n-\n-            if Nkind (New_Id) in N_Has_Etype then\n-               Set_Etype (New_Id, Empty);\n-            end if;\n+         if Nkind (New_Id) in N_Has_Etype then\n+            Set_Etype (New_Id, Empty);\n+         end if;\n \n-            Set_Analyzed (New_Id, False);\n+         Set_Analyzed (New_Id, False);\n \n-            --  Rather special case, if we have an expanded name, then change\n-            --  it back into a selected component, so that the tree looks the\n-            --  way it did coming out of the parser. This will change back\n-            --  when we analyze the selected component node.\n+         --  Rather special case, if we have an expanded name, then change\n+         --  it back into a selected component, so that the tree looks the\n+         --  way it did coming out of the parser. This will change back\n+         --  when we analyze the selected component node.\n \n-            if Nkind (New_Id) = N_Expanded_Name then\n+         if Nkind (New_Id) = N_Expanded_Name then\n \n-               --  The following code is a bit kludgy. It would be cleaner to\n-               --  Add an entry Change_Expanded_Name_To_Selected_Component to\n-               --  Sinfo.CN, but that's an earthquake, because it has the wrong\n-               --  license, and Atree is used outside the compiler, e.g. in the\n-               --  binder and in ASIS, so we don't want to add that dependency.\n+            --  The following code is a bit kludgy. It would be cleaner to\n+            --  Add an entry Change_Expanded_Name_To_Selected_Component to\n+            --  Sinfo.CN, but that's an earthquake, because it has the wrong\n+            --  license, and Atree is used outside the compiler, e.g. in the\n+            --  binder and in ASIS, so we don't want to add that dependency.\n \n-               --  Consequently we have no choice but to hold our noses and do\n-               --  the change manually. At least we are Atree, so this odd use\n-               --  of Atree.Unchecked_Access is at least all in the family.\n+            --  Consequently we have no choice but to hold our noses and do\n+            --  the change manually. At least we are Atree, so this odd use\n+            --  of Atree.Unchecked_Access is at least all in the family.\n \n-               --  Change the node type\n+            --  Change the node type\n \n-               Atree.Unchecked_Access.Set_Nkind (New_Id, N_Selected_Component);\n+            Atree.Unchecked_Access.Set_Nkind (New_Id, N_Selected_Component);\n \n-               --  Clear the Chars field which is not present in a selected\n-               --  component node, so we don't want a junk value around.\n+            --  Clear the Chars field which is not present in a selected\n+            --  component node, so we don't want a junk value around.\n \n-               Set_Node1 (New_Id, Empty);\n-            end if;\n+            Set_Node1 (New_Id, Empty);\n          end if;\n \n          --  All done, return copied node"}, {"sha": "ee2ecde0b36d65337deb6021c674d724c0dbedce", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -494,9 +494,7 @@ package Atree is\n    --  is thus still attached to the tree. It is valid for Source to be Empty,\n    --  in which case Relocate_Node simply returns Empty as the result.\n \n-   function Copy_Separate_Tree\n-     (Source      : Node_Id;\n-      Syntax_Only : Boolean := False) return Node_Id;\n+   function Copy_Separate_Tree (Source : Node_Id) return Node_Id;\n    --  Given a node that is the root of a subtree, Copy_Separate_Tree copies\n    --  the entire syntactic subtree, including recursively any descendants\n    --  whose parent field references a copied node (descendants not linked to\n@@ -506,34 +504,11 @@ package Atree is\n    --  but has new entities with the same name. Most of the time this routine\n    --  is called on an unanalyzed tree, and no semantic information is copied.\n    --  However, to ensure that no entities are shared between the two when the\n-   --  source is already analyzed, entity fields in the copy are zeroed out.\n-   --\n-   --  In addition, if Syntax_Only is set True, then when Copy_Separate_Tree\n-   --  is applied Identical to Copy_Separate_Tree except that in the case of\n-   --  applying it to an already analyzed tree, all Etype fields are reset,\n-   --  and all Analyzed flags are set False. In addition, Expanded_Name\n-   --  nodes are converted back into the original parser form (where they are\n-   --  Selected_Components), so that renalysis does the right thing.\n-   --\n-   --  Note: it really seems like Copy_Separate_Tree could do these identical\n-   --  steps unconditionally, and that nearly works, except for this one known\n-   --  test case that fails:\n-   --\n-   --    1. procedure III is\n-   --    2.    procedure Proc2 is\n-   --    3.       pragma Inline_Always (Proc2);\n-   --                                   |\n-   --       >>> argument of \"INLINE_ALWAYS\" must be entity in\n-   --           current scope\n-   --\n-   --    4.    begin\n-   --    5.       null;\n-   --    6.    end Proc2;\n-   --    7. begin\n-   --    8.    null;\n-   --    9. end III;\n-   --\n-   --  To be investigated ???\n+   --  source is already analyzed, entity fields in the copy are zeroed out,\n+   --  as well as Etype fields and the Analyzed flag.\n+   --  In addition, Expanded_Name nodes are converted back into the original\n+   --  parser form (where they are Selected_Components), so that renalysis does\n+   --  the right thing.\n \n    function Copy_Separate_List (Source : List_Id) return List_Id;\n    --  Applies Copy_Separate_Tree to each element of the Source list, returning"}, {"sha": "9fdc0216eccdf1ba28e02867f2592272632b3ad0", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -3426,14 +3426,12 @@ package body Freeze is\n             --  Note on calls to Copy_Separate_Tree. The trees we are copying\n             --  here are fully analyzed, but we definitely want fully syntactic\n             --  unanalyzed trees in the body we construct, so that the analysis\n-            --  generates the right visibility. So this is a case in which we\n-            --  set Syntax_Only. See spec of Copy_Separate_Tree for details on\n-            --  the use of this flag.\n+            --  generates the right visibility.\n \n             --  Acquire copy of Inline pragma\n \n             Iprag :=\n-              Copy_Separate_Tree (Import_Pragma (E), Syntax_Only => True);\n+              Copy_Separate_Tree (Import_Pragma (E));\n \n             --  Fix up spec to be not imported any more\n \n@@ -3477,11 +3475,11 @@ package body Freeze is\n             Bod :=\n               Make_Subprogram_Body (Loc,\n                 Specification              =>\n-                  Copy_Separate_Tree (Spec, Syntax_Only => True),\n+                  Copy_Separate_Tree (Spec),\n                 Declarations               => New_List (\n                   Make_Subprogram_Declaration (Loc,\n                     Specification =>\n-                      Copy_Separate_Tree (Spec, Syntax_Only => True)),\n+                      Copy_Separate_Tree (Spec)),\n                     Iprag),\n                 Handled_Statement_Sequence =>\n                   Make_Handled_Sequence_Of_Statements (Loc,"}, {"sha": "a3d866a33071f8d5722f24cdc17a617f4421f53e", "filename": "gcc/ada/g-sercom-linux.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fg-sercom-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fg-sercom-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sercom-linux.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                    Copyright (C) 2007-2012, AdaCore                      --\n+--                    Copyright (C) 2007-2013, AdaCore                      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -132,7 +132,10 @@ package body GNAT.Serial_Communications is\n \n    procedure Raise_Error (Message : String; Error : Integer := Errno) is\n    begin\n-      raise Serial_Error with Message & \" (\" & Integer'Image (Error) & ')';\n+      raise Serial_Error with Message\n+        & (if Error /= 0\n+           then \" (\" & Errno_Message (Err => Error) & ')'\n+           else \"\");\n    end Raise_Error;\n \n    ----------"}, {"sha": "700665feed7292765651851bd000a015fb120819", "filename": "gcc/ada/g-sercom-mingw.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fg-sercom-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fg-sercom-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sercom-mingw.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -41,6 +41,8 @@ with System.OS_Constants;\n with System.Win32;         use System.Win32;\n with System.Win32.Ext;     use System.Win32.Ext;\n \n+with GNAT.OS_Lib;\n+\n package body GNAT.Serial_Communications is\n \n    package OSC renames System.OS_Constants;\n@@ -137,7 +139,10 @@ package body GNAT.Serial_Communications is\n \n    procedure Raise_Error (Message : String; Error : DWORD := GetLastError) is\n    begin\n-      raise Serial_Error with Message & \" (\" & DWORD'Image (Error) & ')';\n+      raise Serial_Error with Message\n+        & (if Error /= 0\n+           then \" (\" & GNAT.OS_Lib.Errno_Message (Err => Integer (Error)) & ')'\n+           else \"\");\n    end Raise_Error;\n \n    ----------"}, {"sha": "f33fd1f7d90cf1e01f6dcf820fc375cacc7995d7", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -84,8 +84,13 @@ extern void __gnat_unhandled_except_handler (_Unwind_Exception *);\n \n /* The known and handled exception classes.  */\n \n+#ifdef __ARM_EABI_UNWINDER__\n+#define CXX_EXCEPTION_CLASS \"GNUCC++\"\n+#define GNAT_EXCEPTION_CLASS \"GNU-Ada\"\n+#else\n #define CXX_EXCEPTION_CLASS 0x474e5543432b2b00ULL\n #define GNAT_EXCEPTION_CLASS 0x474e552d41646100ULL\n+#endif\n \n /* Structure of a C++ exception, represented as a C structure...  See\n    unwind-cxx.h for the full definition.  */\n@@ -863,16 +868,10 @@ extern struct Exception_Data Non_Ada_Error;\n /* Return true iff the exception class of EXCEPT is EC.  */\n \n static int\n-exception_class_eq (const _GNAT_Exception *except, unsigned long long ec)\n+exception_class_eq (const _GNAT_Exception *except, _Unwind_Exception_Class ec)\n {\n #ifdef __ARM_EABI_UNWINDER__\n-  union {\n-    char exception_class[8];\n-    unsigned long long ec;\n-  } u;\n-\n-  u.ec = ec;\n-  return memcmp (except->common.exception_class, u.exception_class, 8) == 0;\n+  return memcmp (except->common.exception_class, ec, 8) == 0;\n #else\n   return except->common.exception_class == ec;\n #endif"}, {"sha": "550c1f5a30105692071ca809bc0ca27616096c4e", "filename": "gcc/ada/s-os_lib.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -932,7 +932,8 @@ package body System.OS_Lib is\n             declare\n                Val   : Integer;\n                First : Integer;\n-               Buf   : String (1 .. 20);\n+\n+               Buf : String (1 .. 20);\n                --  Buffer large enough to hold image of largest Integer values\n \n             begin"}, {"sha": "a6ad965af8bde4219cf9a1f0b235ecea99d3c60b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/158d55fa393867c794df5aa43b693f61e5916b83/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=158d55fa393867c794df5aa43b693f61e5916b83", "patch": "@@ -2352,6 +2352,15 @@ package body Sem_Ch6 is\n                      Set_Has_Pragma_Inline_Always (Subp);\n                   end if;\n \n+                  --  Prior to copying the subprogram body to create a template\n+                  --  for it for subsequent inlining, remove the pragma from\n+                  --  the current body so that the copy that will produce the\n+                  --  new body will start from a completely unanalyzed tree.\n+\n+                  if Nkind (Parent (Prag)) = N_Subprogram_Body then\n+                     Rewrite (Prag, Make_Null_Statement (Sloc (Prag)));\n+                  end if;\n+\n                   Spec := Subp;\n                end;\n             end if;"}]}