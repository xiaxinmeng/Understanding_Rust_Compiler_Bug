{"sha": "d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVkZmQ0NzkzZmViZWU2NTI2ZTljYTg0ZTA2YjVlMjA3ZTBmYmNlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-17T19:30:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-07-17T21:28:28Z"}, "message": "libgo: update to Go 1.14.6 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/243317", "tree": {"sha": "67ee8ec7e6ad1697dfa1546524756140af9c8664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67ee8ec7e6ad1697dfa1546524756140af9c8664"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b6e46c417224887c2f21baa6d4c538a25fe9fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b6e46c417224887c2f21baa6d4c538a25fe9fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b6e46c417224887c2f21baa6d4c538a25fe9fb"}], "stats": {"total": 1947, "additions": 1131, "deletions": 816}, "files": [{"sha": "878df0d233a2bde57486a3464e0a7bbed58f4e1c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -1,4 +1,4 @@\n-9703ad5fa23ca63062cb403bd12bc7da4d7845bd\n+2d105e65cca6b536320284273353b7c640b12c5f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4f8589371d3b097c95316a70eed08dd1eefc32b8", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -1,4 +1,4 @@\n-83b181c68bf332ac7948f145f33d128377a09c42\n+edfd6f28486017dcb136cd3f3ec252706d4b326e\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "398d25321fba0b7ad225b4ae8bd7b0f42eefd03b", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -1 +1 @@\n-go1.14.4\n+go1.14.6"}, {"sha": "40999f22f8d516a58ce770c0728a4512f368e8a3", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -3956,45 +3956,6 @@ func TestCgoFlagContainsSpace(t *testing.T) {\n \ttg.grepStderrNot(`\"-L[^\"]+c flags\".*\"-L[^\"]+c flags\"`, \"found too many quoted ld flags\")\n }\n \n-// Issue 9737: verify that GOARM and GO386 affect the computed build ID.\n-func TestBuildIDContainsArchModeEnv(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"skipping in short mode\")\n-\t}\n-\n-\tvar tg *testgoData\n-\ttestWith := func(before, after func()) func(*testing.T) {\n-\t\treturn func(t *testing.T) {\n-\t\t\ttg = testgo(t)\n-\t\t\tdefer tg.cleanup()\n-\t\t\ttg.tempFile(\"src/mycmd/x.go\", `package main\n-func main() {}`)\n-\t\t\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\n-\t\t\ttg.cd(tg.path(\"src/mycmd\"))\n-\t\t\ttg.setenv(\"GOOS\", \"linux\")\n-\t\t\tbefore()\n-\t\t\ttg.run(\"install\", \"mycmd\")\n-\t\t\tafter()\n-\t\t\ttg.wantStale(\"mycmd\", \"stale dependency\", \"should be stale after environment variable change\")\n-\t\t}\n-\t}\n-\n-\tt.Run(\"386\", testWith(func() {\n-\t\ttg.setenv(\"GOARCH\", \"386\")\n-\t\ttg.setenv(\"GO386\", \"387\")\n-\t}, func() {\n-\t\ttg.setenv(\"GO386\", \"sse2\")\n-\t}))\n-\n-\tt.Run(\"arm\", testWith(func() {\n-\t\ttg.setenv(\"GOARCH\", \"arm\")\n-\t\ttg.setenv(\"GOARM\", \"5\")\n-\t}, func() {\n-\t\ttg.setenv(\"GOARM\", \"7\")\n-\t}))\n-}\n-\n func TestListTests(t *testing.T) {\n \ttooSlow(t)\n \tvar tg *testgoData"}, {"sha": "a616195caba9184b448f248680b5d3b494e94d2a", "filename": "libgo/go/cmd/go/testdata/test_regexps.txt", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftest_regexps.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftest_regexps.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftest_regexps.txt?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -0,0 +1,75 @@\n+go test -cpu=1 -run=X/Y -bench=X/Y -count=2 -v testregexp\n+\n+# Test the following:\n+\n+# TestX is run, twice\n+stdout -count=2 '^=== RUN   TestX$'\n+stdout -count=2 '^    x_test.go:6: LOG: X running$'\n+\n+# TestX/Y is run, twice\n+stdout -count=2 '^=== RUN   TestX/Y$'\n+stdout -count=2 '^    x_test.go:8: LOG: Y running$'\n+\n+# TestXX is run, twice\n+stdout -count=2 '^=== RUN   TestXX$'\n+stdout -count=2 '^    z_test.go:10: LOG: XX running'\n+\n+# TestZ is not run\n+! stdout '^=== RUN   TestZ$'\n+\n+# BenchmarkX is run with N=1 once, only to discover what sub-benchmarks it has,\n+# and should not print a final summary line.\n+stdout -count=1 '^    x_test.go:13: LOG: X running N=1$'\n+! stdout '^\\s+BenchmarkX: x_test.go:13: LOG: X running N=\\d\\d+'\n+! stdout 'BenchmarkX\\s+\\d+'\n+\n+# Same for BenchmarkXX.\n+stdout -count=1 '^    z_test.go:18: LOG: XX running N=1$'\n+! stdout  '^    z_test.go:18: LOG: XX running N=\\d\\d+'\n+! stdout 'BenchmarkXX\\s+\\d+'\n+\n+# BenchmarkX/Y is run in full twice due to -count=2.\n+# \"Run in full\" means that it runs for approximately the default benchtime,\n+# but may cap out at N=1e9.\n+# We don't actually care what the final iteration count is, but it should be\n+# a large number, and the last iteration count prints right before the results.\n+stdout -count=2 '^    x_test.go:15: LOG: Y running N=[1-9]\\d{4,}\\nBenchmarkX/Y\\s+\\d+'\n+\n+-- testregexp/x_test.go --\n+package x\n+\n+import \"testing\"\n+\n+func TestX(t *testing.T) {\n+\tt.Logf(\"LOG: X running\")\n+\tt.Run(\"Y\", func(t *testing.T) {\n+\t\tt.Logf(\"LOG: Y running\")\n+\t})\n+}\n+\n+func BenchmarkX(b *testing.B) {\n+\tb.Logf(\"LOG: X running N=%d\", b.N)\n+\tb.Run(\"Y\", func(b *testing.B) {\n+\t\tb.Logf(\"LOG: Y running N=%d\", b.N)\n+\t})\n+}\n+-- testregexp/z_test.go --\n+package x\n+\n+import \"testing\"\n+\n+func TestZ(t *testing.T) {\n+\tt.Logf(\"LOG: Z running\")\n+}\n+\n+func TestXX(t *testing.T) {\n+\tt.Logf(\"LOG: XX running\")\n+}\n+\n+func BenchmarkZ(b *testing.B) {\n+\tb.Logf(\"LOG: Z running N=%d\", b.N)\n+}\n+\n+func BenchmarkXX(b *testing.B) {\n+\tb.Logf(\"LOG: XX running N=%d\", b.N)\n+}"}, {"sha": "1e0f3acb6700e66d9167a2e056983a4335e23abf", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -88,6 +88,9 @@ func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) e\n \t\tswitch status {\n \t\tcase syscall.CERT_TRUST_IS_NOT_TIME_VALID:\n \t\t\treturn CertificateInvalidError{c, Expired, \"\"}\n+\t\tcase syscall.CERT_TRUST_IS_NOT_VALID_FOR_USAGE:\n+\t\t\treturn CertificateInvalidError{c, IncompatibleUsage, \"\"}\n+\t\t// TODO(filippo): surface more error statuses.\n \t\tdefault:\n \t\t\treturn UnknownAuthorityError{c, nil, nil}\n \t\t}\n@@ -138,11 +141,19 @@ func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContex\n \treturn nil\n }\n \n+// windowsExtKeyUsageOIDs are the C NUL-terminated string representations of the\n+// OIDs for use with the Windows API.\n+var windowsExtKeyUsageOIDs = make(map[ExtKeyUsage][]byte, len(extKeyUsageOIDs))\n+\n+func init() {\n+\tfor _, eku := range extKeyUsageOIDs {\n+\t\twindowsExtKeyUsageOIDs[eku.extKeyUsage] = []byte(eku.oid.String() + \"\\x00\")\n+\t}\n+}\n+\n // systemVerify is like Verify, except that it uses CryptoAPI calls\n // to build certificate chains and verify them.\n func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n-\thasDNSName := opts != nil && len(opts.DNSName) > 0\n-\n \tstoreCtx, err := createStoreContext(c, opts)\n \tif err != nil {\n \t\treturn nil, err\n@@ -152,17 +163,26 @@ func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate\n \tpara := new(syscall.CertChainPara)\n \tpara.Size = uint32(unsafe.Sizeof(*para))\n \n-\t// If there's a DNSName set in opts, assume we're verifying\n-\t// a certificate from a TLS server.\n-\tif hasDNSName {\n-\t\toids := []*byte{\n-\t\t\t&syscall.OID_PKIX_KP_SERVER_AUTH[0],\n-\t\t\t// Both IE and Chrome allow certificates with\n-\t\t\t// Server Gated Crypto as well. Some certificates\n-\t\t\t// in the wild require them.\n-\t\t\t&syscall.OID_SERVER_GATED_CRYPTO[0],\n-\t\t\t&syscall.OID_SGC_NETSCAPE[0],\n+\tkeyUsages := opts.KeyUsages\n+\tif len(keyUsages) == 0 {\n+\t\tkeyUsages = []ExtKeyUsage{ExtKeyUsageServerAuth}\n+\t}\n+\toids := make([]*byte, 0, len(keyUsages))\n+\tfor _, eku := range keyUsages {\n+\t\tif eku == ExtKeyUsageAny {\n+\t\t\toids = nil\n+\t\t\tbreak\n+\t\t}\n+\t\tif oid, ok := windowsExtKeyUsageOIDs[eku]; ok {\n+\t\t\toids = append(oids, &oid[0])\n \t\t}\n+\t\t// Like the standard verifier, accept SGC EKUs as equivalent to ServerAuth.\n+\t\tif eku == ExtKeyUsageServerAuth {\n+\t\t\toids = append(oids, &syscall.OID_SERVER_GATED_CRYPTO[0])\n+\t\t\toids = append(oids, &syscall.OID_SGC_NETSCAPE[0])\n+\t\t}\n+\t}\n+\tif oids != nil {\n \t\tpara.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_OR\n \t\tpara.RequestedUsage.Usage.Length = uint32(len(oids))\n \t\tpara.RequestedUsage.Usage.UsageIdentifiers = &oids[0]\n@@ -208,7 +228,7 @@ func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate\n \t\treturn nil, err\n \t}\n \n-\tif hasDNSName {\n+\tif opts != nil && len(opts.DNSName) > 0 {\n \t\terr = checkChainSSLServerPolicy(c, chainCtx, opts)\n \t\tif err != nil {\n \t\t\treturn nil, err"}, {"sha": "c80b5ac825d6faf241618c50e343a08d5d02604c", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -188,23 +188,32 @@ var errNotParsed = errors.New(\"x509: missing ASN.1 contents; use ParseCertificat\n // VerifyOptions contains parameters for Certificate.Verify. It's a structure\n // because other PKIX verification APIs have ended up needing many options.\n type VerifyOptions struct {\n-\tDNSName       string\n+\t// DNSName, if set, is checked against the leaf certificate with\n+\t// Certificate.VerifyHostname or the platform verifier.\n+\tDNSName string\n+\n+\t// Intermediates is an optional pool of certificates that are not trust\n+\t// anchors, but can be used to form a chain from the leaf certificate to a\n+\t// root certificate.\n \tIntermediates *CertPool\n-\tRoots         *CertPool // if nil, the system roots are used\n-\tCurrentTime   time.Time // if zero, the current time is used\n-\t// KeyUsage specifies which Extended Key Usage values are acceptable. A leaf\n-\t// certificate is accepted if it contains any of the listed values. An empty\n-\t// list means ExtKeyUsageServerAuth. To accept any key usage, include\n-\t// ExtKeyUsageAny.\n-\t//\n-\t// Certificate chains are required to nest these extended key usage values.\n-\t// (This matches the Windows CryptoAPI behavior, but not the spec.)\n+\t// Roots is the set of trusted root certificates the leaf certificate needs\n+\t// to chain up to. If nil, the system roots or the platform verifier are used.\n+\tRoots *CertPool\n+\n+\t// CurrentTime is used to check the validity of all certificates in the\n+\t// chain. If zero, the current time is used.\n+\tCurrentTime time.Time\n+\n+\t// KeyUsages specifies which Extended Key Usage values are acceptable. A\n+\t// chain is accepted if it allows any of the listed values. An empty list\n+\t// means ExtKeyUsageServerAuth. To accept any key usage, include ExtKeyUsageAny.\n \tKeyUsages []ExtKeyUsage\n+\n \t// MaxConstraintComparisions is the maximum number of comparisons to\n \t// perform when checking a given certificate's name constraints. If\n \t// zero, a sensible default is used. This limit prevents pathological\n \t// certificates from consuming excessive amounts of CPU time when\n-\t// validating.\n+\t// validating. It does not apply to the platform verifier.\n \tMaxConstraintComparisions int\n }\n \n@@ -717,18 +726,20 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n // needed. If successful, it returns one or more chains where the first\n // element of the chain is c and the last element is from opts.Roots.\n //\n-// If opts.Roots is nil and system roots are unavailable the returned error\n-// will be of type SystemRootsError.\n+// If opts.Roots is nil, the platform verifier might be used, and\n+// verification details might differ from what is described below. If system\n+// roots are unavailable the returned error will be of type SystemRootsError.\n //\n // Name constraints in the intermediates will be applied to all names claimed\n // in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim\n // example.com if an intermediate doesn't permit it, even if example.com is not\n // the name being validated. Note that DirectoryName constraints are not\n // supported.\n //\n-// Extended Key Usage values are enforced down a chain, so an intermediate or\n-// root that enumerates EKUs prevents a leaf from asserting an EKU not in that\n-// list.\n+// Extended Key Usage values are enforced nested down a chain, so an intermediate\n+// or root that enumerates EKUs prevents a leaf from asserting an EKU not in that\n+// list. (While this is not specified, it is common practice in order to limit\n+// the types of certificates a CA can issue.)\n //\n // WARNING: this function doesn't do any revocation checking.\n func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {"}, {"sha": "bbb68db8578a5d87d13fcf07719b853a9d1ea1f2", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 369, "deletions": 519, "changes": 888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -21,34 +21,24 @@ import (\n )\n \n type verifyTest struct {\n-\tleaf                 string\n-\tintermediates        []string\n-\troots                []string\n-\tcurrentTime          int64\n-\tdnsName              string\n-\tsystemSkip           bool\n-\tkeyUsages            []ExtKeyUsage\n-\ttestSystemRootsError bool\n-\tsha2                 bool\n-\tignoreCN             bool\n-\n-\terrorCallback  func(*testing.T, int, error) bool\n+\tname          string\n+\tleaf          string\n+\tintermediates []string\n+\troots         []string\n+\tcurrentTime   int64\n+\tdnsName       string\n+\tsystemSkip    bool\n+\tsystemLax     bool\n+\tkeyUsages     []ExtKeyUsage\n+\tignoreCN      bool\n+\n+\terrorCallback  func(*testing.T, error)\n \texpectedChains [][]string\n }\n \n var verifyTests = []verifyTest{\n \t{\n-\t\tleaf:                 googleLeaf,\n-\t\tintermediates:        []string{giag2Intermediate},\n-\t\tcurrentTime:          1395785200,\n-\t\tdnsName:              \"www.google.com\",\n-\t\ttestSystemRootsError: true,\n-\n-\t\t// Without any roots specified we should get a system roots\n-\t\t// error.\n-\t\terrorCallback: expectSystemRootsError,\n-\t},\n-\t{\n+\t\tname:          \"Valid\",\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -60,6 +50,7 @@ var verifyTests = []verifyTest{\n \t\t},\n \t},\n \t{\n+\t\tname:          \"MixedCase\",\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -71,6 +62,7 @@ var verifyTests = []verifyTest{\n \t\t},\n \t},\n \t{\n+\t\tname:          \"HostnameMismatch\",\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -80,6 +72,7 @@ var verifyTests = []verifyTest{\n \t\terrorCallback: expectHostnameError(\"certificate is valid for\"),\n \t},\n \t{\n+\t\tname:          \"IPMissing\",\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -89,6 +82,7 @@ var verifyTests = []verifyTest{\n \t\terrorCallback: expectHostnameError(\"doesn't contain any IP SANs\"),\n \t},\n \t{\n+\t\tname:          \"Expired\",\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -98,6 +92,7 @@ var verifyTests = []verifyTest{\n \t\terrorCallback: expectExpired,\n \t},\n \t{\n+\t\tname:        \"MissingIntermediate\",\n \t\tleaf:        googleLeaf,\n \t\troots:       []string{geoTrustRoot},\n \t\tcurrentTime: 1395785200,\n@@ -109,6 +104,7 @@ var verifyTests = []verifyTest{\n \t\terrorCallback: expectAuthorityUnknown,\n \t},\n \t{\n+\t\tname:          \"RootInIntermediates\",\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{geoTrustRoot, giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -119,31 +115,50 @@ var verifyTests = []verifyTest{\n \t\t\t{\"Google\", \"Google Internet Authority\", \"GeoTrust\"},\n \t\t},\n \t\t// CAPI doesn't build the chain with the duplicated GeoTrust\n-\t\t// entry so the results don't match. Thus we skip this test\n-\t\t// until that's fixed.\n+\t\t// entry so the results don't match.\n+\t\tsystemLax: true,\n+\t},\n+\t{\n+\t\tname:          \"dnssec-exp\",\n+\t\tleaf:          dnssecExpLeaf,\n+\t\tintermediates: []string{startComIntermediate},\n+\t\troots:         []string{startComRoot},\n+\t\tcurrentTime:   1302726541,\n+\n+\t\t// The StartCom root is not trusted by Windows when the default\n+\t\t// ServerAuth EKU is requested.\n \t\tsystemSkip: true,\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n+\t\t},\n \t},\n \t{\n+\t\tname:          \"dnssec-exp/AnyEKU\",\n \t\tleaf:          dnssecExpLeaf,\n \t\tintermediates: []string{startComIntermediate},\n \t\troots:         []string{startComRoot},\n \t\tcurrentTime:   1302726541,\n+\t\tkeyUsages:     []ExtKeyUsage{ExtKeyUsageAny},\n \n \t\texpectedChains: [][]string{\n \t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n \t{\n+\t\tname:          \"dnssec-exp/RootInIntermediates\",\n \t\tleaf:          dnssecExpLeaf,\n \t\tintermediates: []string{startComIntermediate, startComRoot},\n \t\troots:         []string{startComRoot},\n \t\tcurrentTime:   1302726541,\n+\t\tsystemSkip:    true, // see dnssec-exp test\n \n \t\texpectedChains: [][]string{\n \t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n \t{\n+\t\tname:          \"InvalidHash\",\n \t\tleaf:          googleLeafWithInvalidHash,\n \t\tintermediates: []string{giag2Intermediate},\n \t\troots:         []string{geoTrustRoot},\n@@ -152,57 +167,60 @@ var verifyTests = []verifyTest{\n \n \t\t// The specific error message may not occur when using system\n \t\t// verification.\n-\t\tsystemSkip:    true,\n+\t\tsystemLax:     true,\n \t\terrorCallback: expectHashError,\n \t},\n+\t// EKULeaf tests use an unconstrained chain leading to a leaf certificate\n+\t// with an E-mail Protection EKU but not a Server Auth one, checking that\n+\t// the EKUs on the leaf are enforced.\n \t{\n-\t\t// The default configuration should reject an S/MIME chain.\n-\t\tleaf:        smimeLeaf,\n-\t\troots:       []string{smimeIntermediate},\n-\t\tcurrentTime: 1339436154,\n+\t\tname:          \"EKULeaf\",\n+\t\tleaf:          smimeLeaf,\n+\t\tintermediates: []string{smimeIntermediate},\n+\t\troots:         []string{smimeRoot},\n+\t\tcurrentTime:   1594673418,\n \n-\t\t// Key usage not implemented for Windows yet.\n-\t\tsystemSkip:    true,\n \t\terrorCallback: expectUsageError,\n \t},\n \t{\n-\t\tleaf:        smimeLeaf,\n-\t\troots:       []string{smimeIntermediate},\n-\t\tcurrentTime: 1339436154,\n-\t\tkeyUsages:   []ExtKeyUsage{ExtKeyUsageServerAuth},\n+\t\tname:          \"EKULeafExplicit\",\n+\t\tleaf:          smimeLeaf,\n+\t\tintermediates: []string{smimeIntermediate},\n+\t\troots:         []string{smimeRoot},\n+\t\tcurrentTime:   1594673418,\n+\t\tkeyUsages:     []ExtKeyUsage{ExtKeyUsageServerAuth},\n \n-\t\t// Key usage not implemented for Windows yet.\n-\t\tsystemSkip:    true,\n \t\terrorCallback: expectUsageError,\n \t},\n \t{\n-\t\tleaf:        smimeLeaf,\n-\t\troots:       []string{smimeIntermediate},\n-\t\tcurrentTime: 1339436154,\n-\t\tkeyUsages:   []ExtKeyUsage{ExtKeyUsageEmailProtection},\n+\t\tname:          \"EKULeafValid\",\n+\t\tleaf:          smimeLeaf,\n+\t\tintermediates: []string{smimeIntermediate},\n+\t\troots:         []string{smimeRoot},\n+\t\tcurrentTime:   1594673418,\n+\t\tkeyUsages:     []ExtKeyUsage{ExtKeyUsageEmailProtection},\n \n-\t\t// Key usage not implemented for Windows yet.\n-\t\tsystemSkip: true,\n \t\texpectedChains: [][]string{\n-\t\t\t{\"Ryan Hurst\", \"GlobalSign PersonalSign 2 CA - G2\"},\n+\t\t\t{\"CORPORATIVO FICTICIO ACTIVO\", \"EAEko Herri Administrazioen CA - CA AAPP Vascas (2)\", \"IZENPE S.A.\"},\n \t\t},\n \t},\n \t{\n+\t\tname:          \"SGCIntermediate\",\n \t\tleaf:          megaLeaf,\n \t\tintermediates: []string{comodoIntermediate1},\n \t\troots:         []string{comodoRoot},\n \t\tcurrentTime:   1360431182,\n \n-\t\t// CryptoAPI can find alternative validation paths so we don't\n-\t\t// perform this test with system validation.\n-\t\tsystemSkip: true,\n+\t\t// CryptoAPI can find alternative validation paths.\n+\t\tsystemLax: true,\n \t\texpectedChains: [][]string{\n \t\t\t{\"mega.co.nz\", \"EssentialSSL CA\", \"COMODO Certification Authority\"},\n \t\t},\n \t},\n \t{\n \t\t// Check that a name constrained intermediate works even when\n \t\t// it lists multiple constraints.\n+\t\tname:          \"MultipleConstraints\",\n \t\tleaf:          nameConstraintsLeaf,\n \t\tintermediates: []string{nameConstraintsIntermediate1, nameConstraintsIntermediate2},\n \t\troots:         []string{globalSignRoot},\n@@ -221,17 +239,16 @@ var verifyTests = []verifyTest{\n \t{\n \t\t// Check that SHA-384 intermediates (which are popping up)\n \t\t// work.\n+\t\tname:          \"SHA-384\",\n \t\tleaf:          moipLeafCert,\n \t\tintermediates: []string{comodoIntermediateSHA384, comodoRSAAuthority},\n \t\troots:         []string{addTrustRoot},\n \t\tcurrentTime:   1397502195,\n \t\tdnsName:       \"api.moip.com.br\",\n \n-\t\t// CryptoAPI can find alternative validation paths so we don't\n-\t\t// perform this test with system validation.\n-\t\tsystemSkip: true,\n+\t\t// CryptoAPI can find alternative validation paths.\n+\t\tsystemLax: true,\n \n-\t\tsha2: true,\n \t\texpectedChains: [][]string{\n \t\t\t{\n \t\t\t\t\"api.moip.com.br\",\n@@ -244,11 +261,12 @@ var verifyTests = []verifyTest{\n \t{\n \t\t// Putting a certificate as a root directly should work as a\n \t\t// way of saying \u201cexactly this\u201d.\n+\t\tname:        \"LeafInRoots\",\n \t\tleaf:        selfSigned,\n \t\troots:       []string{selfSigned},\n \t\tcurrentTime: 1471624472,\n \t\tdnsName:     \"foo.example\",\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\texpectedChains: [][]string{\n \t\t\t{\"Acme Co\"},\n@@ -257,242 +275,227 @@ var verifyTests = []verifyTest{\n \t{\n \t\t// Putting a certificate as a root directly should not skip\n \t\t// other checks however.\n+\t\tname:        \"LeafInRootsInvalid\",\n \t\tleaf:        selfSigned,\n \t\troots:       []string{selfSigned},\n \t\tcurrentTime: 1471624472,\n \t\tdnsName:     \"notfoo.example\",\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\terrorCallback: expectHostnameError(\"certificate is valid for\"),\n \t},\n \t{\n \t\t// The issuer name in the leaf doesn't exactly match the\n \t\t// subject name in the root. Go does not perform\n \t\t// canonicalization and so should reject this. See issue 14955.\n+\t\tname:        \"IssuerSubjectMismatch\",\n \t\tleaf:        issuerSubjectMatchLeaf,\n \t\troots:       []string{issuerSubjectMatchRoot},\n \t\tcurrentTime: 1475787715,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\terrorCallback: expectSubjectIssuerMismatcthError,\n \t},\n \t{\n \t\t// An X.509 v1 certificate should not be accepted as an\n \t\t// intermediate.\n+\t\tname:          \"X509v1Intermediate\",\n \t\tleaf:          x509v1TestLeaf,\n \t\tintermediates: []string{x509v1TestIntermediate},\n \t\troots:         []string{x509v1TestRoot},\n \t\tcurrentTime:   1481753183,\n-\t\tsystemSkip:    true,\n+\t\tsystemSkip:    true, // does not chain to a system root\n \n \t\terrorCallback: expectNotAuthorizedError,\n \t},\n \t{\n \t\t// If any SAN extension is present (even one without any DNS\n \t\t// names), the CN should be ignored.\n+\t\tname:        \"IgnoreCNWithSANs\",\n \t\tleaf:        ignoreCNWithSANLeaf,\n \t\tdnsName:     \"foo.example.com\",\n \t\troots:       []string{ignoreCNWithSANRoot},\n \t\tcurrentTime: 1486684488,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\terrorCallback: expectHostnameError(\"certificate is not valid for any names\"),\n \t},\n \t{\n \t\t// Test that excluded names are respected.\n+\t\tname:          \"ExcludedNames\",\n \t\tleaf:          excludedNamesLeaf,\n \t\tdnsName:       \"bender.local\",\n \t\tintermediates: []string{excludedNamesIntermediate},\n \t\troots:         []string{excludedNamesRoot},\n \t\tcurrentTime:   1486684488,\n-\t\tsystemSkip:    true,\n+\t\tsystemSkip:    true, // does not chain to a system root\n \n \t\terrorCallback: expectNameConstraintsError,\n \t},\n \t{\n \t\t// Test that unknown critical extensions in a leaf cause a\n \t\t// verify error.\n+\t\tname:          \"CriticalExtLeaf\",\n \t\tleaf:          criticalExtLeafWithExt,\n \t\tdnsName:       \"example.com\",\n \t\tintermediates: []string{criticalExtIntermediate},\n \t\troots:         []string{criticalExtRoot},\n \t\tcurrentTime:   1486684488,\n-\t\tsystemSkip:    true,\n+\t\tsystemSkip:    true, // does not chain to a system root\n \n \t\terrorCallback: expectUnhandledCriticalExtension,\n \t},\n \t{\n \t\t// Test that unknown critical extensions in an intermediate\n \t\t// cause a verify error.\n+\t\tname:          \"CriticalExtIntermediate\",\n \t\tleaf:          criticalExtLeaf,\n \t\tdnsName:       \"example.com\",\n \t\tintermediates: []string{criticalExtIntermediateWithExt},\n \t\troots:         []string{criticalExtRoot},\n \t\tcurrentTime:   1486684488,\n-\t\tsystemSkip:    true,\n+\t\tsystemSkip:    true, // does not chain to a system root\n \n \t\terrorCallback: expectUnhandledCriticalExtension,\n \t},\n \t{\n \t\t// Test that invalid CN are ignored.\n+\t\tname:        \"InvalidCN\",\n \t\tleaf:        invalidCNWithoutSAN,\n \t\tdnsName:     \"foo,invalid\",\n \t\troots:       []string{invalidCNRoot},\n \t\tcurrentTime: 1540000000,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\terrorCallback: expectHostnameError(\"Common Name is not a valid hostname\"),\n \t},\n \t{\n \t\t// Test that valid CN are respected.\n+\t\tname:        \"ValidCN\",\n \t\tleaf:        validCNWithoutSAN,\n \t\tdnsName:     \"foo.example.com\",\n \t\troots:       []string{invalidCNRoot},\n \t\tcurrentTime: 1540000000,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\texpectedChains: [][]string{\n \t\t\t{\"foo.example.com\", \"Test root\"},\n \t\t},\n \t},\n \t// Replicate CN tests with ignoreCN = true\n \t{\n+\t\tname:        \"IgnoreCNWithSANs/ignoreCN\",\n \t\tleaf:        ignoreCNWithSANLeaf,\n \t\tdnsName:     \"foo.example.com\",\n \t\troots:       []string{ignoreCNWithSANRoot},\n \t\tcurrentTime: 1486684488,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \t\tignoreCN:    true,\n \n \t\terrorCallback: expectHostnameError(\"certificate is not valid for any names\"),\n \t},\n \t{\n+\t\tname:        \"InvalidCN/ignoreCN\",\n \t\tleaf:        invalidCNWithoutSAN,\n \t\tdnsName:     \"foo,invalid\",\n \t\troots:       []string{invalidCNRoot},\n \t\tcurrentTime: 1540000000,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \t\tignoreCN:    true,\n \n \t\terrorCallback: expectHostnameError(\"Common Name is not a valid hostname\"),\n \t},\n \t{\n+\t\tname:        \"ValidCN/ignoreCN\",\n \t\tleaf:        validCNWithoutSAN,\n \t\tdnsName:     \"foo.example.com\",\n \t\troots:       []string{invalidCNRoot},\n \t\tcurrentTime: 1540000000,\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \t\tignoreCN:    true,\n \n \t\terrorCallback: expectHostnameError(\"not valid for any names\"),\n \t},\n \t{\n \t\t// A certificate with an AKID should still chain to a parent without SKID.\n \t\t// See Issue 30079.\n+\t\tname:        \"AKIDNoSKID\",\n \t\tleaf:        leafWithAKID,\n \t\troots:       []string{rootWithoutSKID},\n \t\tcurrentTime: 1550000000,\n \t\tdnsName:     \"example\",\n-\t\tsystemSkip:  true,\n+\t\tsystemSkip:  true, // does not chain to a system root\n \n \t\texpectedChains: [][]string{\n \t\t\t{\"Acme LLC\", \"Acme Co\"},\n \t\t},\n \t},\n }\n \n-func expectHostnameError(msg string) func(*testing.T, int, error) bool {\n-\treturn func(t *testing.T, i int, err error) (ok bool) {\n+func expectHostnameError(msg string) func(*testing.T, error) {\n+\treturn func(t *testing.T, err error) {\n \t\tif _, ok := err.(HostnameError); !ok {\n-\t\t\tt.Errorf(\"#%d: error was not a HostnameError: %v\", i, err)\n-\t\t\treturn false\n+\t\t\tt.Fatalf(\"error was not a HostnameError: %v\", err)\n \t\t}\n \t\tif !strings.Contains(err.Error(), msg) {\n-\t\t\tt.Errorf(\"#%d: HostnameError did not contain %q: %v\", i, msg, err)\n+\t\t\tt.Fatalf(\"HostnameError did not contain %q: %v\", msg, err)\n \t\t}\n-\t\treturn true\n \t}\n }\n \n-func expectExpired(t *testing.T, i int, err error) (ok bool) {\n+func expectExpired(t *testing.T, err error) {\n \tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != Expired {\n-\t\tt.Errorf(\"#%d: error was not Expired: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not Expired: %v\", err)\n \t}\n-\treturn true\n }\n \n-func expectUsageError(t *testing.T, i int, err error) (ok bool) {\n+func expectUsageError(t *testing.T, err error) {\n \tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != IncompatibleUsage {\n-\t\tt.Errorf(\"#%d: error was not IncompatibleUsage: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not IncompatibleUsage: %v\", err)\n \t}\n-\treturn true\n }\n \n-func expectAuthorityUnknown(t *testing.T, i int, err error) (ok bool) {\n+func expectAuthorityUnknown(t *testing.T, err error) {\n \te, ok := err.(UnknownAuthorityError)\n \tif !ok {\n-\t\tt.Errorf(\"#%d: error was not UnknownAuthorityError: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not UnknownAuthorityError: %v\", err)\n \t}\n \tif e.Cert == nil {\n-\t\tt.Errorf(\"#%d: error was UnknownAuthorityError, but missing Cert: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was UnknownAuthorityError, but missing Cert: %v\", err)\n \t}\n-\treturn true\n }\n \n-func expectSystemRootsError(t *testing.T, i int, err error) bool {\n-\tif _, ok := err.(SystemRootsError); !ok {\n-\t\tt.Errorf(\"#%d: error was not SystemRootsError: %v\", i, err)\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func expectHashError(t *testing.T, i int, err error) bool {\n+func expectHashError(t *testing.T, err error) {\n \tif err == nil {\n-\t\tt.Errorf(\"#%d: no error resulted from invalid hash\", i)\n-\t\treturn false\n+\t\tt.Fatalf(\"no error resulted from invalid hash\")\n \t}\n \tif expected := \"algorithm unimplemented\"; !strings.Contains(err.Error(), expected) {\n-\t\tt.Errorf(\"#%d: error resulting from invalid hash didn't contain '%s', rather it was: %v\", i, expected, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error resulting from invalid hash didn't contain '%s', rather it was: %v\", expected, err)\n \t}\n-\treturn true\n }\n \n-func expectSubjectIssuerMismatcthError(t *testing.T, i int, err error) (ok bool) {\n+func expectSubjectIssuerMismatcthError(t *testing.T, err error) {\n \tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != NameMismatch {\n-\t\tt.Errorf(\"#%d: error was not a NameMismatch: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not a NameMismatch: %v\", err)\n \t}\n-\treturn true\n }\n \n-func expectNameConstraintsError(t *testing.T, i int, err error) (ok bool) {\n+func expectNameConstraintsError(t *testing.T, err error) {\n \tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != CANotAuthorizedForThisName {\n-\t\tt.Errorf(\"#%d: error was not a CANotAuthorizedForThisName: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not a CANotAuthorizedForThisName: %v\", err)\n \t}\n-\treturn true\n }\n \n-func expectNotAuthorizedError(t *testing.T, i int, err error) (ok bool) {\n+func expectNotAuthorizedError(t *testing.T, err error) {\n \tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != NotAuthorizedToSign {\n-\t\tt.Errorf(\"#%d: error was not a NotAuthorizedToSign: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not a NotAuthorizedToSign: %v\", err)\n \t}\n-\treturn true\n }\n \n-func expectUnhandledCriticalExtension(t *testing.T, i int, err error) (ok bool) {\n+func expectUnhandledCriticalExtension(t *testing.T, err error) {\n \tif _, ok := err.(UnhandledCriticalExtension); !ok {\n-\t\tt.Errorf(\"#%d: error was not an UnhandledCriticalExtension: %v\", i, err)\n-\t\treturn false\n+\t\tt.Fatalf(\"error was not an UnhandledCriticalExtension: %v\", err)\n \t}\n-\treturn true\n }\n \n func certificateFromPEM(pemBytes string) (*Certificate, error) {\n@@ -503,115 +506,106 @@ func certificateFromPEM(pemBytes string) (*Certificate, error) {\n \treturn ParseCertificate(block.Bytes)\n }\n \n-func testVerify(t *testing.T, useSystemRoots bool) {\n-\tdefer func(savedIgnoreCN bool) {\n-\t\tignoreCN = savedIgnoreCN\n-\t}(ignoreCN)\n-\tfor i, test := range verifyTests {\n-\t\tif useSystemRoots && test.systemSkip {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif runtime.GOOS == \"windows\" && test.testSystemRootsError {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tignoreCN = test.ignoreCN\n-\t\topts := VerifyOptions{\n-\t\t\tIntermediates: NewCertPool(),\n-\t\t\tDNSName:       test.dnsName,\n-\t\t\tCurrentTime:   time.Unix(test.currentTime, 0),\n-\t\t\tKeyUsages:     test.keyUsages,\n-\t\t}\n+func testVerify(t *testing.T, test verifyTest, useSystemRoots bool) {\n+\tdefer func(savedIgnoreCN bool) { ignoreCN = savedIgnoreCN }(ignoreCN)\n \n-\t\tif !useSystemRoots {\n-\t\t\topts.Roots = NewCertPool()\n-\t\t\tfor j, root := range test.roots {\n-\t\t\t\tok := opts.Roots.AppendCertsFromPEM([]byte(root))\n-\t\t\t\tif !ok {\n-\t\t\t\t\tt.Errorf(\"#%d: failed to parse root #%d\", i, j)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\tignoreCN = test.ignoreCN\n+\topts := VerifyOptions{\n+\t\tIntermediates: NewCertPool(),\n+\t\tDNSName:       test.dnsName,\n+\t\tCurrentTime:   time.Unix(test.currentTime, 0),\n+\t\tKeyUsages:     test.keyUsages,\n+\t}\n \n-\t\tfor j, intermediate := range test.intermediates {\n-\t\t\tok := opts.Intermediates.AppendCertsFromPEM([]byte(intermediate))\n+\tif !useSystemRoots {\n+\t\topts.Roots = NewCertPool()\n+\t\tfor j, root := range test.roots {\n+\t\t\tok := opts.Roots.AppendCertsFromPEM([]byte(root))\n \t\t\tif !ok {\n-\t\t\t\tt.Errorf(\"#%d: failed to parse intermediate #%d\", i, j)\n-\t\t\t\treturn\n+\t\t\t\tt.Fatalf(\"failed to parse root #%d\", j)\n \t\t\t}\n \t\t}\n+\t}\n \n-\t\tleaf, err := certificateFromPEM(test.leaf)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d: failed to parse leaf: %v\", i, err)\n-\t\t\treturn\n-\t\t}\n-\n-\t\tvar oldSystemRoots *CertPool\n-\t\tif test.testSystemRootsError {\n-\t\t\toldSystemRoots = systemRootsPool()\n-\t\t\tsystemRoots = nil\n-\t\t\topts.Roots = nil\n+\tfor j, intermediate := range test.intermediates {\n+\t\tok := opts.Intermediates.AppendCertsFromPEM([]byte(intermediate))\n+\t\tif !ok {\n+\t\t\tt.Fatalf(\"failed to parse intermediate #%d\", j)\n \t\t}\n+\t}\n \n-\t\tchains, err := leaf.Verify(opts)\n+\tleaf, err := certificateFromPEM(test.leaf)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to parse leaf: %v\", err)\n+\t}\n \n-\t\tif test.testSystemRootsError {\n-\t\t\tsystemRoots = oldSystemRoots\n-\t\t}\n+\tchains, err := leaf.Verify(opts)\n \n-\t\tif test.errorCallback == nil && err != nil {\n-\t\t\tt.Errorf(\"#%d: unexpected error: %v\", i, err)\n-\t\t}\n-\t\tif test.errorCallback != nil {\n-\t\t\tif !test.errorCallback(t, i, err) {\n-\t\t\t\treturn\n+\tif test.errorCallback == nil && err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif test.errorCallback != nil {\n+\t\tif useSystemRoots && test.systemLax {\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatalf(\"expected error\")\n \t\t\t}\n+\t\t} else {\n+\t\t\ttest.errorCallback(t, err)\n \t\t}\n+\t}\n \n-\t\tif len(chains) != len(test.expectedChains) {\n-\t\t\tt.Errorf(\"#%d: wanted %d chains, got %d\", i, len(test.expectedChains), len(chains))\n-\t\t}\n+\tif len(chains) != len(test.expectedChains) {\n+\t\tt.Errorf(\"wanted %d chains, got %d\", len(test.expectedChains), len(chains))\n+\t}\n \n-\t\t// We check that each returned chain matches a chain from\n-\t\t// expectedChains but an entry in expectedChains can't match\n-\t\t// two chains.\n-\t\tseenChains := make([]bool, len(chains))\n-\tNextOutputChain:\n-\t\tfor _, chain := range chains {\n-\t\tTryNextExpected:\n-\t\t\tfor j, expectedChain := range test.expectedChains {\n-\t\t\t\tif seenChains[j] {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif len(chain) != len(expectedChain) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tfor k, cert := range chain {\n-\t\t\t\t\tif !strings.Contains(nameToKey(&cert.Subject), expectedChain[k]) {\n-\t\t\t\t\t\tcontinue TryNextExpected\n-\t\t\t\t\t}\n+\t// We check that each returned chain matches a chain from\n+\t// expectedChains but an entry in expectedChains can't match\n+\t// two chains.\n+\tseenChains := make([]bool, len(chains))\n+NextOutputChain:\n+\tfor _, chain := range chains {\n+\tTryNextExpected:\n+\t\tfor j, expectedChain := range test.expectedChains {\n+\t\t\tif seenChains[j] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif len(chain) != len(expectedChain) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor k, cert := range chain {\n+\t\t\t\tif !strings.Contains(nameToKey(&cert.Subject), expectedChain[k]) {\n+\t\t\t\t\tcontinue TryNextExpected\n \t\t\t\t}\n-\t\t\t\t// we matched\n-\t\t\t\tseenChains[j] = true\n-\t\t\t\tcontinue NextOutputChain\n \t\t\t}\n-\t\t\tt.Errorf(\"#%d: No expected chain matched %s\", i, chainToDebugString(chain))\n+\t\t\t// we matched\n+\t\t\tseenChains[j] = true\n+\t\t\tcontinue NextOutputChain\n \t\t}\n+\t\tt.Errorf(\"no expected chain matched %s\", chainToDebugString(chain))\n \t}\n }\n \n func TestGoVerify(t *testing.T) {\n-\ttestVerify(t, false)\n+\tfor _, test := range verifyTests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\ttestVerify(t, test, false)\n+\t\t})\n+\t}\n }\n \n func TestSystemVerify(t *testing.T) {\n \tif runtime.GOOS != \"windows\" {\n \t\tt.Skipf(\"skipping verify test using system APIs on %q\", runtime.GOOS)\n \t}\n \n-\ttestVerify(t, true)\n+\tfor _, test := range verifyTests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tif test.systemSkip {\n+\t\t\t\tt.SkipNow()\n+\t\t\t}\n+\t\t\ttestVerify(t, test, true)\n+\t\t})\n+\t}\n }\n \n func chainToDebugString(chain []*Certificate) string {\n@@ -648,8 +642,7 @@ tQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfOEVEiIuCl6rYVSAlk6l5PdPcF\n PseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQdtqvmlKXBx4Ot2/Un\n hw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeXxx12E6nV\n 5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==\n------END CERTIFICATE-----\n-`\n+-----END CERTIFICATE-----`\n \n const giag2Intermediate = `-----BEGIN CERTIFICATE-----\n MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\n@@ -674,8 +667,7 @@ zG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza\n HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\n WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\n yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\n------END CERTIFICATE-----\n-`\n+-----END CERTIFICATE-----`\n \n const googleLeaf = `-----BEGIN CERTIFICATE-----\n MIIEdjCCA16gAwIBAgIIcR5k4dkoe04wDQYJKoZIhvcNAQEFBQAwSTELMAkGA1UE\n@@ -702,8 +694,7 @@ tJAW0kYGJ+wqKm53wG/JaOADTnnq2Mt/j6F2uvjgN/ouns1nRHufIvd370N0LeH+\n orKqTuAPzXK7imQk6+OycYABbqCtC/9qmwRd8wwn7sF97DtYfK8WuNHtFalCAwyi\n 8LxJJYJCLWoMhZ+V8GZm+FOex5qkQAjnZrtNlbQJ8ro4r+rpKXtmMFFhfa+7L+PA\n Kom08eUK8skxAzfDDijZPh10VtJ66uBoiDPdT+uCBehcBIcmSTrKjFGX\n------END CERTIFICATE-----\n-`\n+-----END CERTIFICATE-----`\n \n // googleLeafWithInvalidHash is the same as googleLeaf, but the signature\n // algorithm in the certificate contains a nonsense OID.\n@@ -732,8 +723,7 @@ tJAW0kYGJ+wqKm53wG/JaOADTnnq2Mt/j6F2uvjgN/ouns1nRHufIvd370N0LeH+\n orKqTuAPzXK7imQk6+OycYABbqCtC/9qmwRd8wwn7sF97DtYfK8WuNHtFalCAwyi\n 8LxJJYJCLWoMhZ+V8GZm+FOex5qkQAjnZrtNlbQJ8ro4r+rpKXtmMFFhfa+7L+PA\n Kom08eUK8skxAzfDDijZPh10VtJ66uBoiDPdT+uCBehcBIcmSTrKjFGX\n------END CERTIFICATE-----\n-`\n+-----END CERTIFICATE-----`\n \n const dnssecExpLeaf = `-----BEGIN CERTIFICATE-----\n MIIGzTCCBbWgAwIBAgIDAdD6MA0GCSqGSIb3DQEBBQUAMIGMMQswCQYDVQQGEwJJ\n@@ -858,58 +848,127 @@ NOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n -----END CERTIFICATE-----`\n \n const smimeLeaf = `-----BEGIN CERTIFICATE-----\n-MIIFBjCCA+6gAwIBAgISESFvrjT8XcJTEe6rBlPptILlMA0GCSqGSIb3DQEBBQUA\n-MFQxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMSowKAYD\n-VQQDEyFHbG9iYWxTaWduIFBlcnNvbmFsU2lnbiAyIENBIC0gRzIwHhcNMTIwMTIz\n-MTYzNjU5WhcNMTUwMTIzMTYzNjU5WjCBlDELMAkGA1UEBhMCVVMxFjAUBgNVBAgT\n-DU5ldyBIYW1zcGhpcmUxEzARBgNVBAcTClBvcnRzbW91dGgxGTAXBgNVBAoTEEds\n-b2JhbFNpZ24sIEluYy4xEzARBgNVBAMTClJ5YW4gSHVyc3QxKDAmBgkqhkiG9w0B\n-CQEWGXJ5YW4uaHVyc3RAZ2xvYmFsc2lnbi5jb20wggEiMA0GCSqGSIb3DQEBAQUA\n-A4IBDwAwggEKAoIBAQC4ASSTvavmsFQAob60ukSSwOAL9nT/s99ltNUCAf5fPH5j\n-NceMKxaQse2miOmRRIXaykcq1p/TbI70Ztce38r2mbOwqDHHPVi13GxJEyUXWgaR\n-BteDMu5OGyWNG1kchVsGWpbstT0Z4v0md5m1BYFnxB20ebJyOR2lXDxsFK28nnKV\n-+5eMj76U8BpPQ4SCH7yTMG6y0XXsB3cCrBKr2o3TOYgEKv+oNnbaoMt3UxMt9nSf\n-9jyIshjqfnT5Aew3CUNMatO55g5FXXdIukAweg1YSb1ls05qW3sW00T3d7dQs9/7\n-NuxCg/A2elmVJSoy8+MLR8JSFEf/aMgjO/TyLg/jAgMBAAGjggGPMIIBizAOBgNV\n-HQ8BAf8EBAMCBaAwTQYDVR0gBEYwRDBCBgorBgEEAaAyASgKMDQwMgYIKwYBBQUH\n-AgEWJmh0dHBzOi8vd3d3Lmdsb2JhbHNpZ24uY29tL3JlcG9zaXRvcnkvMCQGA1Ud\n-EQQdMBuBGXJ5YW4uaHVyc3RAZ2xvYmFsc2lnbi5jb20wCQYDVR0TBAIwADAdBgNV\n-HSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwQwQwYDVR0fBDwwOjA4oDagNIYyaHR0\n-cDovL2NybC5nbG9iYWxzaWduLmNvbS9ncy9nc3BlcnNvbmFsc2lnbjJnMi5jcmww\n-VQYIKwYBBQUHAQEESTBHMEUGCCsGAQUFBzAChjlodHRwOi8vc2VjdXJlLmdsb2Jh\n-bHNpZ24uY29tL2NhY2VydC9nc3BlcnNvbmFsc2lnbjJnMi5jcnQwHQYDVR0OBBYE\n-FFWiECe0/L72eVYqcWYnLV6SSjzhMB8GA1UdIwQYMBaAFD8V0m18L+cxnkMKBqiU\n-bCw7xe5lMA0GCSqGSIb3DQEBBQUAA4IBAQAhQi6hLPeudmf3IBF4IDzCvRI0FaYd\n-BKfprSk/H0PDea4vpsLbWpA0t0SaijiJYtxKjlM4bPd+2chb7ejatDdyrZIzmDVy\n-q4c30/xMninGKokpYA11/Ve+i2dvjulu65qasrtQRGybAuuZ67lrp/K3OMFgjV5N\n-C3AHYLzvNU4Dwc4QQ1BaMOg6KzYSrKbABRZajfrpC9uiePsv7mDIXLx/toBPxWNl\n-a5vJm5DrZdn7uHdvBCE6kMykbOLN5pmEK0UIlwKh6Qi5XD0pzlVkEZliFkBMJgub\n-d/eF7xeg7TKPWC5xyOFp9SdMolJM7LTC3wnSO3frBAev+q/nGs9Xxyvs\n+MIIIPDCCBiSgAwIBAgIQaMDxFS0pOMxZZeOBxoTJtjANBgkqhkiG9w0BAQsFADCB\n+nTELMAkGA1UEBhMCRVMxFDASBgNVBAoMC0laRU5QRSBTLkEuMTowOAYDVQQLDDFB\n+WlogWml1cnRhZ2lyaSBwdWJsaWtvYSAtIENlcnRpZmljYWRvIHB1YmxpY28gU0NB\n+MTwwOgYDVQQDDDNFQUVrbyBIZXJyaSBBZG1pbmlzdHJhemlvZW4gQ0EgLSBDQSBB\n+QVBQIFZhc2NhcyAoMikwHhcNMTcwNzEyMDg1MzIxWhcNMjEwNzEyMDg1MzIxWjCC\n+AQwxDzANBgNVBAoMBklaRU5QRTE4MDYGA1UECwwvWml1cnRhZ2lyaSBrb3Jwb3Jh\n+dGlib2EtQ2VydGlmaWNhZG8gY29ycG9yYXRpdm8xQzBBBgNVBAsMOkNvbmRpY2lv\n+bmVzIGRlIHVzbyBlbiB3d3cuaXplbnBlLmNvbSBub2xhIGVyYWJpbGkgamFraXRl\n+a28xFzAVBgNVBC4TDi1kbmkgOTk5OTk5ODlaMSQwIgYDVQQDDBtDT1JQT1JBVElW\n+TyBGSUNUSUNJTyBBQ1RJVk8xFDASBgNVBCoMC0NPUlBPUkFUSVZPMREwDwYDVQQE\n+DAhGSUNUSUNJTzESMBAGA1UEBRMJOTk5OTk5ODlaMIIBIjANBgkqhkiG9w0BAQEF\n+AAOCAQ8AMIIBCgKCAQEAwVOMwUDfBtsH0XuxYnb+v/L774jMH8valX7RPH8cl2Lb\n+SiqSo0RchW2RGA2d1yuYHlpChC9jGmt0X/g66/E/+q2hUJlfJtqVDJFwtFYV4u2S\n+yzA3J36V4PRkPQrKxAsbzZriFXAF10XgiHQz9aVeMMJ9GBhmh9+DK8Tm4cMF6i8l\n++AuC35KdngPF1x0ealTYrYZplpEJFO7CiW42aLi6vQkDR2R7nmZA4AT69teqBWsK\n+0DZ93/f0G/3+vnWwNTBF0lB6dIXoaz8OMSyHLqGnmmAtMrzbjAr/O/WWgbB/BqhR\n+qjJQ7Ui16cuDldXaWQ/rkMzsxmsAox0UF+zdQNvXUQIDAQABo4IDBDCCAwAwgccG\n+A1UdEgSBvzCBvIYVaHR0cDovL3d3dy5pemVucGUuY29tgQ9pbmZvQGl6ZW5wZS5j\n+b22kgZEwgY4xRzBFBgNVBAoMPklaRU5QRSBTLkEuIC0gQ0lGIEEwMTMzNzI2MC1S\n+TWVyYy5WaXRvcmlhLUdhc3RlaXogVDEwNTUgRjYyIFM4MUMwQQYDVQQJDDpBdmRh\n+IGRlbCBNZWRpdGVycmFuZW8gRXRvcmJpZGVhIDE0IC0gMDEwMTAgVml0b3JpYS1H\n+YXN0ZWl6MB4GA1UdEQQXMBWBE2ZpY3RpY2lvQGl6ZW5wZS5ldXMwDgYDVR0PAQH/\n+BAQDAgXgMCkGA1UdJQQiMCAGCCsGAQUFBwMCBggrBgEFBQcDBAYKKwYBBAGCNxQC\n+AjAdBgNVHQ4EFgQUyeoOD4cgcljKY0JvrNuX2waFQLAwHwYDVR0jBBgwFoAUwKlK\n+90clh/+8taaJzoLSRqiJ66MwggEnBgNVHSAEggEeMIIBGjCCARYGCisGAQQB8zkB\n+AQEwggEGMDMGCCsGAQUFBwIBFidodHRwOi8vd3d3Lml6ZW5wZS5jb20vcnBhc2Nh\n+Y29ycG9yYXRpdm8wgc4GCCsGAQUFBwICMIHBGoG+Wml1cnRhZ2lyaWEgRXVza2Fs\n+IEF1dG9ub21pYSBFcmtpZGVnb2tvIHNla3RvcmUgcHVibGlrb2tvIGVyYWt1bmRl\n+ZW4gYmFybmUtc2FyZWV0YW4gYmFrYXJyaWsgZXJhYmlsIGRhaXRla2UuIFVzbyBy\n+ZXN0cmluZ2lkbyBhbCBhbWJpdG8gZGUgcmVkZXMgaW50ZXJuYXMgZGUgRW50aWRh\n+ZGVzIGRlbCBTZWN0b3IgUHVibGljbyBWYXNjbzAyBggrBgEFBQcBAQQmMCQwIgYI\n+KwYBBQUHMAGGFmh0dHA6Ly9vY3NwLml6ZW5wZS5jb20wOgYDVR0fBDMwMTAvoC2g\n+K4YpaHR0cDovL2NybC5pemVucGUuY29tL2NnaS1iaW4vY3JsaW50ZXJuYTIwDQYJ\n+KoZIhvcNAQELBQADggIBAIy5PQ+UZlCRq6ig43vpHwlwuD9daAYeejV0Q+ZbgWAE\n+GtO0kT/ytw95ZEJMNiMw3fYfPRlh27ThqiT0VDXZJDlzmn7JZd6QFcdXkCsiuv4+\n+ZoXAg/QwnA3SGUUO9aVaXyuOIIuvOfb9MzoGp9xk23SMV3eiLAaLMLqwB5DTfBdt\n+BGI7L1MnGJBv8RfP/TL67aJ5bgq2ri4S8vGHtXSjcZ0+rCEOLJtmDNMnTZxancg3\n+/H5edeNd+n6Z48LO+JHRxQufbC4mVNxVLMIP9EkGUejlq4E4w6zb5NwCQczJbSWL\n+i31rk2orsNsDlyaLGsWZp3JSNX6RmodU4KAUPor4jUJuUhrrm3Spb73gKlV/gcIw\n+bCE7mML1Kss3x1ySaXsis6SZtLpGWKkW2iguPWPs0ydV6RPhmsCxieMwPPIJ87vS\n+5IejfgyBae7RSuAIHyNFy4uI5xwvwUFf6OZ7az8qtW7ImFOgng3Ds+W9k1S2CNTx\n+d0cnKTfA6IpjGo8EeHcxnIXT8NPImWaRj0qqonvYady7ci6U4m3lkNSdXNn1afgw\n+mYust+gxVtOZs1gk2MUCgJ1V1X+g7r/Cg7viIn6TLkLrpS1kS1hvMqkl9M+7XqPo\n+Qd95nJKOkusQpy99X4dF/lfbYAQnnjnqh3DLD2gvYObXFaAYFaiBKTiMTV2X72F+\n -----END CERTIFICATE-----`\n \n const smimeIntermediate = `-----BEGIN CERTIFICATE-----\n-MIIEFjCCAv6gAwIBAgILBAAAAAABL07hL1IwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n-A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n-b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw0xMTA0MTMxMDAw\n-MDBaFw0xOTA0MTMxMDAwMDBaMFQxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n-YWxTaWduIG52LXNhMSowKAYDVQQDEyFHbG9iYWxTaWduIFBlcnNvbmFsU2lnbiAy\n-IENBIC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDBa0H5Nez4\n-En3dIlFpX7e5E0YndxQ74xOBbz7kdBd+DLX0LOQMjVPU3DAgKL9ujhH+ZhHkURbH\n-3X/94TQSUL/z2JjsaQvS0NqyZXHhM5eeuquzOJRzEQ8+odETzHg2G0Erv7yjSeww\n-gkwDWDJnYUDlOjYTDUEG6+i+8Mn425reo4I0E277wD542kmVWeW7+oHv5dZo9e1Q\n-yWwiKTEP6BEQVVSBgThXMG4traSSDRUt3T1eQTZx5EObpiBEBO4OTqiBTJfg4vEI\n-YgkXzKLpnfszTB6YMDpR9/QS6p3ANB3kfAb+t6udSO3WCst0DGrwHDLBFGDR4UeY\n-T5KGGnI7cWL7AgMBAAGjgeUwgeIwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQI\n-MAYBAf8CAQAwHQYDVR0OBBYEFD8V0m18L+cxnkMKBqiUbCw7xe5lMEcGA1UdIARA\n-MD4wPAYEVR0gADA0MDIGCCsGAQUFBwIBFiZodHRwczovL3d3dy5nbG9iYWxzaWdu\n-LmNvbS9yZXBvc2l0b3J5LzAzBgNVHR8ELDAqMCigJqAkhiJodHRwOi8vY3JsLmds\n-b2JhbHNpZ24ubmV0L3Jvb3QuY3JsMB8GA1UdIwQYMBaAFGB7ZhpFDZfKiVAvfQTN\n-NKj//P1LMA0GCSqGSIb3DQEBBQUAA4IBAQBDc3nMpMxJMQMcYUCB3+C73UpvwDE8\n-eCOr7t2F/uaQKKcyqqstqLZc6vPwI/rcE9oDHugY5QEjQzIBIEaTnN6P0vege2IX\n-eCOr7t2F/uaQKKcyqqstqLZc6vPwI/rcE9oDHugY5QEjQzIBIEaTnN6P0vege2IX\n-YEvTWbWwGdPytDFPYIl3/6OqNSXSnZ7DxPcdLJq2uyiga8PB/TTIIHYkdM2+1DE0\n-7y3rH/7TjwDVD7SLu5/SdOfKskuMPTjOEvz3K161mymW06klVhubCIWOro/Gx1Q2\n-2FQOZ7/2k4uYoOdBTSlb8kTAuzZNgIE0rB2BIYCTz/P6zZIKW0ogbRSH\n+MIIHNzCCBSGgAwIBAgIQJMXIqlZvjuhMvqcFXOFkpDALBgkqhkiG9w0BAQswODEL\n+MAkGA1UEBhMCRVMxFDASBgNVBAoMC0laRU5QRSBTLkEuMRMwEQYDVQQDDApJemVu\n+cGUuY29tMB4XDTEwMTAyMDA4MjMzM1oXDTM3MTIxMjIzMDAwMFowgZ0xCzAJBgNV\n+BAYTAkVTMRQwEgYDVQQKDAtJWkVOUEUgUy5BLjE6MDgGA1UECwwxQVpaIFppdXJ0\n+YWdpcmkgcHVibGlrb2EgLSBDZXJ0aWZpY2FkbyBwdWJsaWNvIFNDQTE8MDoGA1UE\n+AwwzRUFFa28gSGVycmkgQWRtaW5pc3RyYXppb2VuIENBIC0gQ0EgQUFQUCBWYXNj\n+YXMgKDIpMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAoIM7nEdI0N1h\n+rR5T4xuV/usKDoMIasaiKvfLhbwxaNtTt+a7W/6wV5bv3svQFIy3sUXjjdzV1nG2\n+To2wo/YSPQiOt8exWvOapvL21ogiof+kelWnXFjWaKJI/vThHYLgIYEMj/y4HdtU\n+ojI646rZwqsb4YGAopwgmkDfUh5jOhV2IcYE3TgJAYWVkj6jku9PLaIsHiarAHjD\n+PY8dig8a4SRv0gm5Yk7FXLmW1d14oxQBDeHZ7zOEXfpafxdEDO2SNaRJjpkh8XRr\n+PGqkg2y1Q3gT6b4537jz+StyDIJ3omylmlJsGCwqT7p8mEqjGJ5kC5I2VnjXKuNn\n+soShc72khWZVUJiJo5SGuAkNE2ZXqltBVm5Jv6QweQKsX6bkcMc4IZok4a+hx8FM\n+8IBpGf/I94pU6HzGXqCyc1d46drJgDY9mXa+6YDAJFl3xeXOOW2iGCfwXqhiCrKL\n+MYvyMZzqF3QH5q4nb3ZnehYvraeMFXJXDn+Utqp8vd2r7ShfQJz01KtM4hgKdgSg\n+jtW+shkVVN5ng/fPN85ovfAH2BHXFfHmQn4zKsYnLitpwYM/7S1HxlT61cdQ7Nnk\n+3LZTYEgAoOmEmdheklT40WAYakksXGM5VrzG7x9S7s1Tm+Vb5LSThdHC8bxxwyTb\n+KsDRDNJ84N9fPDO6qHnzaL2upQ43PycCAwEAAaOCAdkwggHVMIHHBgNVHREEgb8w\n+gbyGFWh0dHA6Ly93d3cuaXplbnBlLmNvbYEPaW5mb0BpemVucGUuY29tpIGRMIGO\n+MUcwRQYDVQQKDD5JWkVOUEUgUy5BLiAtIENJRiBBMDEzMzcyNjAtUk1lcmMuVml0\n+b3JpYS1HYXN0ZWl6IFQxMDU1IEY2MiBTODFDMEEGA1UECQw6QXZkYSBkZWwgTWVk\n+aXRlcnJhbmVvIEV0b3JiaWRlYSAxNCAtIDAxMDEwIFZpdG9yaWEtR2FzdGVpejAP\n+BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUwKlK90cl\n+h/+8taaJzoLSRqiJ66MwHwYDVR0jBBgwFoAUHRxlDqjyJXu0kc/ksbHmvVV0bAUw\n+OgYDVR0gBDMwMTAvBgRVHSAAMCcwJQYIKwYBBQUHAgEWGWh0dHA6Ly93d3cuaXpl\n+bnBlLmNvbS9jcHMwNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8v\n+b2NzcC5pemVucGUuY29tOjgwOTQwMwYDVR0fBCwwKjAooCagJIYiaHR0cDovL2Ny\n+bC5pemVucGUuY29tL2NnaS1iaW4vYXJsMjALBgkqhkiG9w0BAQsDggIBAMbjc3HM\n+3DG9ubWPkzsF0QsktukpujbTTcGk4h20G7SPRy1DiiTxrRzdAMWGjZioOP3/fKCS\n+M539qH0M+gsySNie+iKlbSZJUyE635T1tKw+G7bDUapjlH1xyv55NC5I6wCXGC6E\n+3TEP5B/E7dZD0s9E4lS511ubVZivFgOzMYo1DO96diny/N/V1enaTCpRl1qH1OyL\n+xUYTijV4ph2gL6exwuG7pxfRcVNHYlrRaXWfTz3F6NBKyULxrI3P/y6JAtN1GqT4\n+VF/+vMygx22n0DufGepBwTQz6/rr1ulSZ+eMnuJiTXgh/BzQnkUsXTb8mHII25iR\n+0oYF2qAsk6ecWbLiDpkHKIDHmML21MZE13MS8NSvTHoqJO4LyAmDe6SaeNHtrPlK\n+b6mzE1BN2ug+ZaX8wLA5IMPFaf0jKhb/Cxu8INsxjt00brsErCc9ip1VNaH0M4bi\n+1tGxfiew2436FaeyUxW7Pl6G5GgkNbuUc7QIoRy06DdU/U38BxW3uyJMY60zwHvS\n+FlKAn0OvYp4niKhAJwaBVN3kowmJuOU5Rid+TUnfyxbJ9cttSgzaF3hP/N4zgMEM\n+5tikXUskeckt8LUK96EH0QyssavAMECUEb/xrupyRdYWwjQGvNLq6T5+fViDGyOw\n+k+lzD44wofy8paAy9uC9Owae0zMEzhcsyRm7\n+-----END CERTIFICATE-----`\n+\n+const smimeRoot = `-----BEGIN CERTIFICATE-----\n+MIIF8TCCA9mgAwIBAgIQALC3WhZIX7/hy/WL1xnmfTANBgkqhkiG9w0BAQsFADA4\n+MQswCQYDVQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6\n+ZW5wZS5jb20wHhcNMDcxMjEzMTMwODI4WhcNMzcxMjEzMDgyNzI1WjA4MQswCQYD\n+VQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5j\n+b20wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ03rKDx6sp4boFmVq\n+scIbRTJxldn+EFvMr+eleQGPicPK8lVx93e+d5TzcqQsRNiekpsUOqHnJJAKClaO\n+xdgmlOHZSOEtPtoKct2jmRXagaKH9HtuJneJWK3W6wyyQXpzbm3benhB6QiIEn6H\n+LmYRY2xU+zydcsC8Lv/Ct90NduM61/e0aL6i9eOBbsFGb12N4E3GVFWJGjMxCrFX\n+uaOKmMPsOzTFlUFpfnXCPCDFYbpRR6AgkJOhkEvzTnyFRVSa0QUmQbC1TR0zvsQD\n+yCV8wXDbO/QJLVQnSKwv4cSsPsjLkkxTOTcj7NMB+eAJRE1NZMDhDVqHIrytG6P+\n+JrUV86f8hBnp7KGItERphIPzidF0BqnMC9bC3ieFUCbKF7jJeodWLBoBHmy+E60Q\n+rLUk9TiRodZL2vG70t5HtfG8gfZZa88ZU+mNFctKy6lvROUbQc/hhqfK0GqfvEyN\n+BjNaooXlkDWgYlwWTvDjovoDGrQscbNYLN57C9saD+veIR8GdwYDsMnvmfzAuU8L\n+hij+0rnq49qlw0dpEuDb8PYZi+17cNcC1u2HGCgsBCRMd+RIihrGO5rUD8r6ddIB\n+QFqNeb+Lz0vPqhbBleStTIo+F5HUsWLlguWABKQDfo2/2n+iD5dPDNMN+9fR5XJ+\n+HMh3/1uaD7euBUbl8agW7EekFwIDAQABo4H2MIHzMIGwBgNVHREEgagwgaWBD2lu\n+Zm9AaXplbnBlLmNvbaSBkTCBjjFHMEUGA1UECgw+SVpFTlBFIFMuQS4gLSBDSUYg\n+QTAxMzM3MjYwLVJNZXJjLlZpdG9yaWEtR2FzdGVpeiBUMTA1NSBGNjIgUzgxQzBB\n+BgNVBAkMOkF2ZGEgZGVsIE1lZGl0ZXJyYW5lbyBFdG9yYmlkZWEgMTQgLSAwMTAx\n+MCBWaXRvcmlhLUdhc3RlaXowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\n+AQYwHQYDVR0OBBYEFB0cZQ6o8iV7tJHP5LGx5r1VdGwFMA0GCSqGSIb3DQEBCwUA\n+A4ICAQB4pgwWSp9MiDrAyw6lFn2fuUhfGI8NYjb2zRlrrKvV9pF9rnHzP7MOeIWb\n+laQnIUdCSnxIOvVFfLMMjlF4rJUT3sb9fbgakEyrkgPH7UIBzg/YsfqikuFgba56\n+awmqxinuaElnMIAkejEWOVt+8Rwu3WwJrfIxwYJOubv5vr8qhT/AQKM6WfxZSzwo\n+JNu0FXWuDYi6LnPAvViH5ULy617uHjAimcs30cQhbIHsvm0m5hzkQiCeR7Csg1lw\n+LDXWrzY0tM07+DKo7+N4ifuNRSzanLh+QBxh5z6ikixL8s36mLYp//Pye6kfLqCT\n+VyvehQP5aTfLnnhqBbTFMXiJ7HqnheG5ezzevh55hM6fcA5ZwjUukCox2eRFekGk\n+LhObNA5me0mrZJfQRsN5nXJQY6aYWwa9SG3YOYNw6DXwBdGqvOPbyALqfP2C2sJb\n+UjWumDqtujWTI6cfSN01RpiyEGjkpTHCClguGYEQyVB1/OpaFs4R1+7vUIgtYf8/\n+QnMFlEPVjjxOAToZpR9GTnfQXeWBIiGH/pR9hNiTrdZoQ0iy2+tzJOeRf1SktoA+\n+naM8THLCV8Sg1Mw4J87VBp6iSNnpn86CcDaTmjvfliHjWbcM2pE38P1ZWrOZyGls\n+QyYBNWNgVYkDOnXYukrZVP/u3oDYLdE41V4tC5h9Pmzb/CaIxw==\n -----END CERTIFICATE-----`\n \n var megaLeaf = `-----BEGIN CERTIFICATE-----\n@@ -1315,50 +1374,7 @@ vRAvOtNiKtPzFeQVdbRPOskC4rcHyPeiDAMAMixeLi63+CFty4da3r5lRezeedCE\n cw3ESZzThBwWqvPOtJdpXdm+r57pDW8qD+/0lY8wfImMNkQAyCUCLg/1Lxt/hrBj\n -----END CERTIFICATE-----`\n \n-const issuerSubjectMatchRoot = `\n-Certificate:\n-    Data:\n-        Version: 3 (0x2)\n-        Serial Number: 161640039802297062 (0x23e42c281e55ae6)\n-    Signature Algorithm: sha256WithRSAEncryption\n-        Issuer: O=Golang, CN=Root ca\n-        Validity\n-            Not Before: Jan  1 00:00:00 2015 GMT\n-            Not After : Jan  1 00:00:00 2025 GMT\n-        Subject: O=Golang, CN=Root ca\n-        Subject Public Key Info:\n-            Public Key Algorithm: rsaEncryption\n-                Public-Key: (1024 bit)\n-                Modulus:\n-                    00:e9:0e:7f:11:0c:e6:5a:e6:86:83:70:f6:51:07:\n-                    2e:02:78:11:f5:b2:24:92:38:ee:26:62:02:c7:94:\n-                    f1:3e:a1:77:6a:c0:8f:d5:22:68:b6:5d:e2:4c:da:\n-                    e0:85:11:35:c2:92:72:49:8d:81:b4:88:97:6b:b7:\n-                    fc:b2:44:5b:d9:4d:06:70:f9:0c:c6:8f:e9:b3:df:\n-                    a3:6a:84:6c:43:59:be:9d:b2:d0:76:9b:c3:d7:fa:\n-                    99:59:c3:b8:e5:f3:53:03:bd:49:d6:b3:cc:a2:43:\n-                    fe:ad:c2:0b:b9:01:b8:56:29:94:03:24:a7:0d:28:\n-                    21:29:a9:ae:94:5b:4a:f9:9f\n-                Exponent: 65537 (0x10001)\n-        X509v3 extensions:\n-            X509v3 Key Usage: critical\n-                Certificate Sign\n-            X509v3 Extended Key Usage:\n-                TLS Web Server Authentication, TLS Web Client Authentication\n-            X509v3 Basic Constraints: critical\n-                CA:TRUE\n-            X509v3 Subject Key Identifier:\n-                40:37:D7:01:FB:40:2F:B8:1C:7E:54:04:27:8C:59:01\n-    Signature Algorithm: sha256WithRSAEncryption\n-         6f:84:df:49:e0:99:d4:71:66:1d:32:86:56:cb:ea:5a:6b:0e:\n-         00:6a:d1:5a:6e:1f:06:23:07:ff:cb:d1:1a:74:e4:24:43:0b:\n-         aa:2a:a0:73:75:25:82:bc:bf:3f:a9:f8:48:88:ac:ed:3a:94:\n-         3b:0d:d3:88:c8:67:44:61:33:df:71:6c:c5:af:ed:16:8c:bf:\n-         82:f9:49:bb:e3:2a:07:53:36:37:25:77:de:91:a4:77:09:7f:\n-         6f:b2:91:58:c4:05:89:ea:8e:fa:e1:3b:19:ef:f8:f6:94:b7:\n-         7b:27:e6:e4:84:dd:2b:f5:93:f5:3c:d8:86:c5:38:01:56:5c:\n-         9f:6d\n------BEGIN CERTIFICATE-----\n+const issuerSubjectMatchRoot = `-----BEGIN CERTIFICATE-----\n MIICIDCCAYmgAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwIzEPMA0GA1UE\n ChMGR29sYW5nMRAwDgYDVQQDEwdSb290IGNhMB4XDTE1MDEwMTAwMDAwMFoXDTI1\n MDEwMTAwMDAwMFowIzEPMA0GA1UEChMGR29sYW5nMRAwDgYDVQQDEwdSb290IGNh\n@@ -1373,53 +1389,7 @@ RGEz33Fsxa/tFoy/gvlJu+MqB1M2NyV33pGkdwl/b7KRWMQFieqO+uE7Ge/49pS3\n eyfm5ITdK/WT9TzYhsU4AVZcn20=\n -----END CERTIFICATE-----`\n \n-const issuerSubjectMatchLeaf = `\n-Certificate:\n-    Data:\n-        Version: 3 (0x2)\n-        Serial Number: 16785088708916013734 (0xe8f09d3fe25beaa6)\n-    Signature Algorithm: sha256WithRSAEncryption\n-        Issuer: O=Golang, CN=Root CA\n-        Validity\n-            Not Before: Jan  1 00:00:00 2015 GMT\n-            Not After : Jan  1 00:00:00 2025 GMT\n-        Subject: O=Golang, CN=Leaf\n-        Subject Public Key Info:\n-            Public Key Algorithm: rsaEncryption\n-                Public-Key: (1024 bit)\n-                Modulus:\n-                    00:db:46:7d:93:2e:12:27:06:48:bc:06:28:21:ab:\n-                    7e:c4:b6:a2:5d:fe:1e:52:45:88:7a:36:47:a5:08:\n-                    0d:92:42:5b:c2:81:c0:be:97:79:98:40:fb:4f:6d:\n-                    14:fd:2b:13:8b:c2:a5:2e:67:d8:d4:09:9e:d6:22:\n-                    38:b7:4a:0b:74:73:2b:c2:34:f1:d1:93:e5:96:d9:\n-                    74:7b:f3:58:9f:6c:61:3c:c0:b0:41:d4:d9:2b:2b:\n-                    24:23:77:5b:1c:3b:bd:75:5d:ce:20:54:cf:a1:63:\n-                    87:1d:1e:24:c4:f3:1d:1a:50:8b:aa:b6:14:43:ed:\n-                    97:a7:75:62:f4:14:c8:52:d7\n-                Exponent: 65537 (0x10001)\n-        X509v3 extensions:\n-            X509v3 Key Usage: critical\n-                Digital Signature, Key Encipherment\n-            X509v3 Extended Key Usage:\n-                TLS Web Server Authentication, TLS Web Client Authentication\n-            X509v3 Basic Constraints: critical\n-                CA:FALSE\n-            X509v3 Subject Key Identifier:\n-                9F:91:16:1F:43:43:3E:49:A6:DE:6D:B6:80:D7:9F:60\n-            X509v3 Authority Key Identifier:\n-                keyid:40:37:D7:01:FB:40:2F:B8:1C:7E:54:04:27:8C:59:01\n-\n-    Signature Algorithm: sha256WithRSAEncryption\n-         8d:86:05:da:89:f5:1d:c5:16:14:41:b9:34:87:2b:5c:38:99:\n-         e3:d9:5a:5b:7a:5b:de:0b:5c:08:45:09:6f:1c:9d:31:5f:08:\n-         ca:7a:a3:99:da:83:0b:22:be:4f:02:35:91:4e:5d:5c:37:bf:\n-         89:22:58:7d:30:76:d2:2f:d0:a0:ee:77:9e:77:c0:d6:19:eb:\n-         ec:a0:63:35:6a:80:9b:80:1a:80:de:64:bc:40:38:3c:22:69:\n-         ad:46:26:a2:3d:ea:f4:c2:92:49:16:03:96:ae:64:21:b9:7c:\n-         ee:64:91:47:81:aa:b4:0c:09:2b:12:1a:b2:f3:af:50:b3:b1:\n-         ce:24\n------BEGIN CERTIFICATE-----\n+const issuerSubjectMatchLeaf = `-----BEGIN CERTIFICATE-----\n MIICODCCAaGgAwIBAgIJAOjwnT/iW+qmMA0GCSqGSIb3DQEBCwUAMCMxDzANBgNV\n BAoTBkdvbGFuZzEQMA4GA1UEAxMHUm9vdCBDQTAeFw0xNTAxMDEwMDAwMDBaFw0y\n NTAxMDEwMDAwMDBaMCAxDzANBgNVBAoTBkdvbGFuZzENMAsGA1UEAxMETGVhZjCB\n@@ -1432,11 +1402,9 @@ Q0M+SabebbaA159gMBsGA1UdIwQUMBKAEEA31wH7QC+4HH5UBCeMWQEwDQYJKoZI\n hvcNAQELBQADgYEAjYYF2on1HcUWFEG5NIcrXDiZ49laW3pb3gtcCEUJbxydMV8I\n ynqjmdqDCyK+TwI1kU5dXDe/iSJYfTB20i/QoO53nnfA1hnr7KBjNWqAm4AagN5k\n vEA4PCJprUYmoj3q9MKSSRYDlq5kIbl87mSRR4GqtAwJKxIasvOvULOxziQ=\n------END CERTIFICATE-----\n-`\n+-----END CERTIFICATE-----`\n \n-const x509v1TestRoot = `\n------BEGIN CERTIFICATE-----\n+const x509v1TestRoot = `-----BEGIN CERTIFICATE-----\n MIICIDCCAYmgAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwIzEPMA0GA1UE\n ChMGR29sYW5nMRAwDgYDVQQDEwdSb290IENBMB4XDTE1MDEwMTAwMDAwMFoXDTI1\n MDEwMTAwMDAwMFowIzEPMA0GA1UEChMGR29sYW5nMRAwDgYDVQQDEwdSb290IENB\n@@ -1451,8 +1419,7 @@ h2NtN34ard0hEfHc8qW8mkXdsysVmq6cPvFYaHz+dBtkHuHDoy8YQnC0zdN/WyYB\n /1JmacUUofl+HusHuLkDxmadogI=\n -----END CERTIFICATE-----`\n \n-const x509v1TestIntermediate = `\n------BEGIN CERTIFICATE-----\n+const x509v1TestIntermediate = `-----BEGIN CERTIFICATE-----\n MIIByjCCATMCCQCCdEMsT8ykqTANBgkqhkiG9w0BAQsFADAjMQ8wDQYDVQQKEwZH\n b2xhbmcxEDAOBgNVBAMTB1Jvb3QgQ0EwHhcNMTUwMTAxMDAwMDAwWhcNMjUwMTAx\n MDAwMDAwWjAwMQ8wDQYDVQQKEwZHb2xhbmcxHTAbBgNVBAMTFFguNTA5djEgaW50\n@@ -1465,8 +1432,7 @@ zWE77kJDibzd141u21ZbLsKvEdUJXjla43bdyMmEqf5VGpC3D4sFt3QVH7lGeRur\n x5Wlq1u3YDL/j6s1nU2dQ3ySB/oP7J+vQ9V4QeM+\n -----END CERTIFICATE-----`\n \n-const x509v1TestLeaf = `\n------BEGIN CERTIFICATE-----\n+const x509v1TestLeaf = `-----BEGIN CERTIFICATE-----\n MIICMzCCAZygAwIBAgIJAPo99mqJJrpJMA0GCSqGSIb3DQEBCwUAMDAxDzANBgNV\n BAoTBkdvbGFuZzEdMBsGA1UEAxMUWC41MDl2MSBpbnRlcm1lZGlhdGUwHhcNMTUw\n MTAxMDAwMDAwWhcNMjUwMTAxMDAwMDAwWjArMQ8wDQYDVQQKEwZHb2xhbmcxGDAW\n@@ -1481,8 +1447,7 @@ CwUAA4GBADYzYUvaToO/ucBskPdqXV16AaakIhhSENswYVSl97/sODaxsjishKq9\n /jt8qszOXCv2vYdUTPNuPqufXLWMoirpuXrr1liJDmedCcAHepY/\n -----END CERTIFICATE-----`\n \n-const ignoreCNWithSANRoot = `\n------BEGIN CERTIFICATE-----\n+const ignoreCNWithSANRoot = `-----BEGIN CERTIFICATE-----\n MIIDPzCCAiegAwIBAgIIJkzCwkNrPHMwDQYJKoZIhvcNAQELBQAwMDEQMA4GA1UE\n ChMHVEVTVElORzEcMBoGA1UEAxMTKipUZXN0aW5nKiogUm9vdCBDQTAeFw0xNTAx\n MDEwMDAwMDBaFw0yNTAxMDEwMDAwMDBaMDAxEDAOBgNVBAoTB1RFU1RJTkcxHDAa\n@@ -1503,8 +1468,7 @@ aSLjI/Ya0zwUARMmyZ3RRGCyhIarPb20mKSaMf1/Nb23pS3k1QgmZhk5pAnXYsWu\n BJ6bvwEAasFiLGP6Zbdmxb2hIA==\n -----END CERTIFICATE-----`\n \n-const ignoreCNWithSANLeaf = `\n------BEGIN CERTIFICATE-----\n+const ignoreCNWithSANLeaf = `-----BEGIN CERTIFICATE-----\n MIIDaTCCAlGgAwIBAgIJAONakvRTxgJhMA0GCSqGSIb3DQEBCwUAMDAxEDAOBgNV\n BAoTB1RFU1RJTkcxHDAaBgNVBAMTEyoqVGVzdGluZyoqIFJvb3QgQ0EwHhcNMTUw\n MTAxMDAwMDAwWhcNMjUwMTAxMDAwMDAwWjAsMRAwDgYDVQQKEwdURVNUSU5HMRgw\n@@ -1526,8 +1490,7 @@ j2kBQyvnyKsXHLAKUoUOpd6t/1PHrfXnGj+HmzZNloJ/BZ1kiWb4eLvMljoLGkZn\n xZbqP3Krgjj4XNaXjg==\n -----END CERTIFICATE-----`\n \n-const excludedNamesLeaf = `\n------BEGIN CERTIFICATE-----\n+const excludedNamesLeaf = `-----BEGIN CERTIFICATE-----\n MIID4DCCAsigAwIBAgIHDUSFtJknhzANBgkqhkiG9w0BAQsFADCBnjELMAkGA1UE\n BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBHYXRvczEU\n MBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNlY3VyaXR5\n@@ -1549,11 +1512,9 @@ hDt8MCFJ8eSjCyKdtZh1MPMLrLVymmJV+Rc9JUUYM9TIeERkpl0rskcO1YGewkYt\n qKlWE+0S16+pzsWvKn831uylqwIb8ANBPsCX4aM4muFBHavSWAHgRO+P+yXVw8Q+\n VQDnMHUe5PbZd1/+1KKVs1K/CkBCtoHNHp1d/JT+2zUQJphwja9CcgfFdVhSnHL4\n oEEOFtqVMIuQfR2isi08qW/JGOHc4sFoLYB8hvdaxKWSE19A\n------END CERTIFICATE-----\n-`\n+-----END CERTIFICATE-----`\n \n-const excludedNamesIntermediate = `\n------BEGIN CERTIFICATE-----\n+const excludedNamesIntermediate = `-----BEGIN CERTIFICATE-----\n MIIDzTCCArWgAwIBAgIHDUSFqYeczDANBgkqhkiG9w0BAQsFADCBmTELMAkGA1UE\n BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBHYXRvczEU\n MBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNlY3VyaXR5\n@@ -1577,8 +1538,7 @@ LbIjZCSfgZnk/LK1KU1j91FI2bc2ULYZvAC1PAg8/zvIgxn6YM2Q7ZsdEgWw0FpS\n zMBX1/lk4wkFckeUIlkD55Y=\n -----END CERTIFICATE-----`\n \n-const excludedNamesRoot = `\n------BEGIN CERTIFICATE-----\n+const excludedNamesRoot = `-----BEGIN CERTIFICATE-----\n MIIEGTCCAwGgAwIBAgIHDUSFpInn/zANBgkqhkiG9w0BAQsFADCBozELMAkGA1UE\n BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBHYXRvczEU\n MBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNlY3VyaXR5\n@@ -1603,134 +1563,36 @@ yU1yRHUqUYpN0DWFpsPbBqgM6uUAVO2ayBFhPgWUaqkmSbZ/Nq7isGvknaTmcIwT\n +NQCZDd5eFeU8PpNX7rgaYE4GPq+EEmLVCBYmdctr8QVdqJ//8Xu3+1phjDy\n -----END CERTIFICATE-----`\n \n-const invalidCNRoot = `\n------BEGIN CERTIFICATE-----\n+const invalidCNRoot = `-----BEGIN CERTIFICATE-----\n MIIBFjCBvgIJAIsu4r+jb70UMAoGCCqGSM49BAMCMBQxEjAQBgNVBAsMCVRlc3Qg\n cm9vdDAeFw0xODA3MTExODMyMzVaFw0yODA3MDgxODMyMzVaMBQxEjAQBgNVBAsM\n CVRlc3Qgcm9vdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABF6oDgMg0LV6YhPj\n QXaPXYCc2cIyCdqp0ROUksRz0pOLTc5iY2nraUheRUD1vRRneq7GeXOVNn7uXONg\n oCGMjNwwCgYIKoZIzj0EAwIDRwAwRAIgDSiwgIn8g1lpruYH0QD1GYeoWVunfmrI\n XzZZl0eW/ugCICgOfXeZ2GGy3wIC0352BaC3a8r5AAb2XSGNe+e9wNN6\n------END CERTIFICATE-----\n-`\n-\n-const invalidCNWithoutSAN = `\n-Certificate:\n-    Data:\n-        Version: 1 (0x0)\n-        Serial Number:\n-            07:ba:bc:b7:d9:ab:0c:02:fe:50:1d:4e:15:a3:0d:e4:11:16:14:a2\n-        Signature Algorithm: ecdsa-with-SHA256\n-        Issuer: OU = Test root\n-        Validity\n-            Not Before: Jul 11 18:35:21 2018 GMT\n-            Not After : Jul  8 18:35:21 2028 GMT\n-        Subject: CN = \"foo,invalid\"\n-        Subject Public Key Info:\n-            Public Key Algorithm: id-ecPublicKey\n-                Public-Key: (256 bit)\n-                pub:\n-                    04:a7:a6:7c:22:33:a7:47:7f:08:93:2d:5f:61:35:\n-                    2e:da:45:67:76:f2:97:73:18:b0:01:12:4a:1a:d5:\n-                    b7:6f:41:3c:bb:05:69:f4:06:5d:ff:eb:2b:a7:85:\n-                    0b:4c:f7:45:4e:81:40:7a:a9:c6:1d:bb:ba:d9:b9:\n-                    26:b3:ca:50:90\n-                ASN1 OID: prime256v1\n-                NIST CURVE: P-256\n-    Signature Algorithm: ecdsa-with-SHA256\n-         30:45:02:21:00:85:96:75:b6:72:3c:67:12:a0:7f:86:04:81:\n-         d2:dd:c8:67:50:d7:5f:85:c0:54:54:fc:e6:6b:45:08:93:d3:\n-         2a:02:20:60:86:3e:d6:28:a6:4e:da:dd:6e:95:89:cc:00:76:\n-         78:1c:03:80:85:a6:5a:0b:eb:c5:f3:9c:2e:df:ef:6e:fa\n------BEGIN CERTIFICATE-----\n+-----END CERTIFICATE-----`\n+\n+const invalidCNWithoutSAN = `-----BEGIN CERTIFICATE-----\n MIIBJDCBywIUB7q8t9mrDAL+UB1OFaMN5BEWFKIwCgYIKoZIzj0EAwIwFDESMBAG\n A1UECwwJVGVzdCByb290MB4XDTE4MDcxMTE4MzUyMVoXDTI4MDcwODE4MzUyMVow\n FjEUMBIGA1UEAwwLZm9vLGludmFsaWQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNC\n AASnpnwiM6dHfwiTLV9hNS7aRWd28pdzGLABEkoa1bdvQTy7BWn0Bl3/6yunhQtM\n 90VOgUB6qcYdu7rZuSazylCQMAoGCCqGSM49BAMCA0gAMEUCIQCFlnW2cjxnEqB/\n hgSB0t3IZ1DXX4XAVFT85mtFCJPTKgIgYIY+1iimTtrdbpWJzAB2eBwDgIWmWgvr\n xfOcLt/vbvo=\n------END CERTIFICATE-----\n-`\n-\n-const validCNWithoutSAN = `\n-Certificate:\n-    Data:\n-        Version: 1 (0x0)\n-        Serial Number:\n-            07:ba:bc:b7:d9:ab:0c:02:fe:50:1d:4e:15:a3:0d:e4:11:16:14:a4\n-        Signature Algorithm: ecdsa-with-SHA256\n-        Issuer: OU = Test root\n-        Validity\n-            Not Before: Jul 11 18:47:24 2018 GMT\n-            Not After : Jul  8 18:47:24 2028 GMT\n-        Subject: CN = foo.example.com\n-        Subject Public Key Info:\n-            Public Key Algorithm: id-ecPublicKey\n-                Public-Key: (256 bit)\n-                pub:\n-                    04:a7:a6:7c:22:33:a7:47:7f:08:93:2d:5f:61:35:\n-                    2e:da:45:67:76:f2:97:73:18:b0:01:12:4a:1a:d5:\n-                    b7:6f:41:3c:bb:05:69:f4:06:5d:ff:eb:2b:a7:85:\n-                    0b:4c:f7:45:4e:81:40:7a:a9:c6:1d:bb:ba:d9:b9:\n-                    26:b3:ca:50:90\n-                ASN1 OID: prime256v1\n-                NIST CURVE: P-256\n-    Signature Algorithm: ecdsa-with-SHA256\n-         30:44:02:20:53:6c:d7:b7:59:61:51:72:a5:18:a3:4b:0d:52:\n-         ea:15:fa:d0:93:30:32:54:4b:ed:0f:58:85:b8:a8:1a:82:3b:\n-         02:20:14:77:4b:0e:7e:4f:0a:4f:64:26:97:dc:d0:ed:aa:67:\n-         1d:37:85:da:b4:87:ba:25:1c:2a:58:f7:23:11:8b:3d\n------BEGIN CERTIFICATE-----\n+-----END CERTIFICATE-----`\n+\n+const validCNWithoutSAN = `-----BEGIN CERTIFICATE-----\n MIIBJzCBzwIUB7q8t9mrDAL+UB1OFaMN5BEWFKQwCgYIKoZIzj0EAwIwFDESMBAG\n A1UECwwJVGVzdCByb290MB4XDTE4MDcxMTE4NDcyNFoXDTI4MDcwODE4NDcyNFow\n GjEYMBYGA1UEAwwPZm9vLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\n AQcDQgAEp6Z8IjOnR38Iky1fYTUu2kVndvKXcxiwARJKGtW3b0E8uwVp9AZd/+sr\n p4ULTPdFToFAeqnGHbu62bkms8pQkDAKBggqhkjOPQQDAgNHADBEAiBTbNe3WWFR\n cqUYo0sNUuoV+tCTMDJUS+0PWIW4qBqCOwIgFHdLDn5PCk9kJpfc0O2qZx03hdq0\n h7olHCpY9yMRiz0=\n------END CERTIFICATE-----\n-`\n-\n-const (\n-\trootWithoutSKID = `\n-Certificate:\n-    Data:\n-        Version: 3 (0x2)\n-        Serial Number:\n-            78:29:2a:dc:2f:12:39:7f:c9:33:93:ea:61:39:7d:70\n-        Signature Algorithm: ecdsa-with-SHA256\n-        Issuer: O = Acme Co\n-        Validity\n-            Not Before: Feb  4 22:56:34 2019 GMT\n-            Not After : Feb  1 22:56:34 2029 GMT\n-        Subject: O = Acme Co\n-        Subject Public Key Info:\n-            Public Key Algorithm: id-ecPublicKey\n-                Public-Key: (256 bit)\n-                pub:\n-                    04:84:a6:8c:69:53:af:87:4b:39:64:fe:04:24:e6:\n-                    d8:fc:d6:46:39:35:0e:92:dc:48:08:7e:02:5f:1e:\n-                    07:53:5c:d9:e0:56:c5:82:07:f6:a3:e2:ad:f6:ad:\n-                    be:a0:4e:03:87:39:67:0c:9c:46:91:68:6b:0e:8e:\n-                    f8:49:97:9d:5b\n-                ASN1 OID: prime256v1\n-                NIST CURVE: P-256\n-        X509v3 extensions:\n-            X509v3 Key Usage: critical\n-                Digital Signature, Key Encipherment, Certificate Sign\n-            X509v3 Extended Key Usage:\n-                TLS Web Server Authentication\n-            X509v3 Basic Constraints: critical\n-                CA:TRUE\n-            X509v3 Subject Alternative Name:\n-                DNS:example\n-    Signature Algorithm: ecdsa-with-SHA256\n-         30:46:02:21:00:c6:81:61:61:42:8d:37:e7:d0:c3:72:43:44:\n-         17:bd:84:ff:88:81:68:9a:99:08:ab:3c:3a:c0:1e:ea:8c:ba:\n-         c0:02:21:00:de:c9:fa:e5:5e:c6:e2:db:23:64:43:a9:37:42:\n-         72:92:7f:6e:89:38:ea:9e:2a:a7:fd:2f:ea:9a:ff:20:21:e7\n------BEGIN CERTIFICATE-----\n+-----END CERTIFICATE-----`\n+\n+const rootWithoutSKID = `-----BEGIN CERTIFICATE-----\n MIIBbzCCARSgAwIBAgIQeCkq3C8SOX/JM5PqYTl9cDAKBggqhkjOPQQDAjASMRAw\n DgYDVQQKEwdBY21lIENvMB4XDTE5MDIwNDIyNTYzNFoXDTI5MDIwMTIyNTYzNFow\n EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABISm\n@@ -1739,49 +1601,9 @@ ZwycRpFoaw6O+EmXnVujTDBKMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr\n BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MBIGA1UdEQQLMAmCB2V4YW1wbGUwCgYI\n KoZIzj0EAwIDSQAwRgIhAMaBYWFCjTfn0MNyQ0QXvYT/iIFompkIqzw6wB7qjLrA\n AiEA3sn65V7G4tsjZEOpN0Jykn9uiTjqniqn/S/qmv8gIec=\n------END CERTIFICATE-----\n-`\n-\tleafWithAKID = `\n-\tCertificate:\n-    Data:\n-        Version: 3 (0x2)\n-        Serial Number:\n-            f0:8a:62:f0:03:84:a2:cf:69:63:ad:71:3b:b6:5d:8c\n-        Signature Algorithm: ecdsa-with-SHA256\n-        Issuer: O = Acme Co\n-        Validity\n-            Not Before: Feb  4 23:06:52 2019 GMT\n-            Not After : Feb  1 23:06:52 2029 GMT\n-        Subject: O = Acme LLC\n-        Subject Public Key Info:\n-            Public Key Algorithm: id-ecPublicKey\n-                Public-Key: (256 bit)\n-                pub:\n-                    04:5a:4e:4d:fb:ff:17:f7:b6:13:e8:29:45:34:81:\n-                    39:ff:8c:9c:d9:8c:0a:9f:dd:b5:97:4c:2b:20:91:\n-                    1c:4f:6b:be:53:27:66:ec:4a:ad:08:93:6d:66:36:\n-                    0c:02:70:5d:01:ca:7f:c3:29:e9:4f:00:ba:b4:14:\n-                    ec:c5:c3:34:b3\n-                ASN1 OID: prime256v1\n-                NIST CURVE: P-256\n-        X509v3 extensions:\n-            X509v3 Key Usage: critical\n-                Digital Signature, Key Encipherment\n-            X509v3 Extended Key Usage:\n-                TLS Web Server Authentication\n-            X509v3 Basic Constraints: critical\n-                CA:FALSE\n-            X509v3 Authority Key Identifier:\n-                keyid:C2:2B:5F:91:78:34:26:09:42:8D:6F:51:B2:C5:AF:4C:0B:DE:6A:42\n-\n-            X509v3 Subject Alternative Name:\n-                DNS:example\n-    Signature Algorithm: ecdsa-with-SHA256\n-         30:44:02:20:64:e0:ba:56:89:63:ce:22:5e:4f:22:15:fd:3c:\n-         35:64:9a:3a:6b:7b:9a:32:a0:7f:f7:69:8c:06:f0:00:58:b8:\n-         02:20:09:e4:9f:6d:8b:9e:38:e1:b6:01:d5:ee:32:a4:94:65:\n-         93:2a:78:94:bb:26:57:4b:c7:dd:6c:3d:40:2b:63:90\n------BEGIN CERTIFICATE-----\n+-----END CERTIFICATE-----`\n+\n+const leafWithAKID = `-----BEGIN CERTIFICATE-----\n MIIBjTCCATSgAwIBAgIRAPCKYvADhKLPaWOtcTu2XYwwCgYIKoZIzj0EAwIwEjEQ\n MA4GA1UEChMHQWNtZSBDbzAeFw0xOTAyMDQyMzA2NTJaFw0yOTAyMDEyMzA2NTJa\n MBMxETAPBgNVBAoTCEFjbWUgTExDMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE\n@@ -1791,9 +1613,7 @@ CCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAUwitfkXg0JglCjW9R\n ssWvTAveakIwEgYDVR0RBAswCYIHZXhhbXBsZTAKBggqhkjOPQQDAgNHADBEAiBk\n 4LpWiWPOIl5PIhX9PDVkmjpre5oyoH/3aYwG8ABYuAIgCeSfbYueOOG2AdXuMqSU\n ZZMqeJS7JldLx91sPUArY5A=\n------END CERTIFICATE-----\n-`\n-)\n+-----END CERTIFICATE-----`\n \n var unknownAuthorityErrorTests = []struct {\n \tcert     string\n@@ -2124,3 +1944,33 @@ func TestLongChain(t *testing.T) {\n \t}\n \tt.Logf(\"verification took %v\", time.Since(start))\n }\n+\n+func TestSystemRootsError(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Windows does not use (or support) systemRoots\")\n+\t}\n+\n+\tdefer func(oldSystemRoots *CertPool) { systemRoots = oldSystemRoots }(systemRootsPool())\n+\n+\topts := VerifyOptions{\n+\t\tIntermediates: NewCertPool(),\n+\t\tDNSName:       \"www.google.com\",\n+\t\tCurrentTime:   time.Unix(1395785200, 0),\n+\t}\n+\n+\tif ok := opts.Intermediates.AppendCertsFromPEM([]byte(giag2Intermediate)); !ok {\n+\t\tt.Fatalf(\"failed to parse intermediate\")\n+\t}\n+\n+\tleaf, err := certificateFromPEM(googleLeaf)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to parse leaf: %v\", err)\n+\t}\n+\n+\tsystemRoots = nil\n+\n+\t_, err = leaf.Verify(opts)\n+\tif _, ok := err.(SystemRootsError); !ok {\n+\t\tt.Errorf(\"error was not SystemRootsError: %v\", err)\n+\t}\n+}"}, {"sha": "a0ba7ecf694bfbe52f307d285d3e9dff1c2776f8", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -255,12 +255,9 @@ type ConnBeginTx interface {\n // SessionResetter may be implemented by Conn to allow drivers to reset the\n // session state associated with the connection and to signal a bad connection.\n type SessionResetter interface {\n-\t// ResetSession is called while a connection is in the connection\n-\t// pool. No queries will run on this connection until this method returns.\n-\t//\n-\t// If the connection is bad this should return driver.ErrBadConn to prevent\n-\t// the connection from being returned to the connection pool. Any other\n-\t// error will be discarded.\n+\t// ResetSession is called prior to executing a query on the connection\n+\t// if the connection has been used before. If the driver returns ErrBadConn\n+\t// the connection is discarded.\n \tResetSession(ctx context.Context) error\n }\n "}, {"sha": "0ec72d409d359e97b635532d4a1ae0793b112668", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -390,12 +390,19 @@ func setStrictFakeConnClose(t *testing.T) {\n \n func (c *fakeConn) ResetSession(ctx context.Context) error {\n \tc.dirtySession = false\n+\tc.currTx = nil\n \tif c.isBad() {\n \t\treturn driver.ErrBadConn\n \t}\n \treturn nil\n }\n \n+var _ validator = (*fakeConn)(nil)\n+\n+func (c *fakeConn) IsValid() bool {\n+\treturn !c.isBad()\n+}\n+\n func (c *fakeConn) Close() (err error) {\n \tdrv := fdriver.(*fakeDriver)\n \tdefer func() {\n@@ -728,6 +735,9 @@ var hookExecBadConn func() bool\n func (s *fakeStmt) Exec(args []driver.Value) (driver.Result, error) {\n \tpanic(\"Using ExecContext\")\n }\n+\n+var errFakeConnSessionDirty = errors.New(\"fakedb: session is dirty\")\n+\n func (s *fakeStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {\n \tif s.panic == \"Exec\" {\n \t\tpanic(s.panic)\n@@ -740,7 +750,7 @@ func (s *fakeStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (d\n \t\treturn nil, driver.ErrBadConn\n \t}\n \tif s.c.isDirtyAndMark() {\n-\t\treturn nil, errors.New(\"fakedb: session is dirty\")\n+\t\treturn nil, errFakeConnSessionDirty\n \t}\n \n \terr := checkSubsetTypes(s.c.db.allowAny, args)\n@@ -854,7 +864,7 @@ func (s *fakeStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (\n \t\treturn nil, driver.ErrBadConn\n \t}\n \tif s.c.isDirtyAndMark() {\n-\t\treturn nil, errors.New(\"fakedb: session is dirty\")\n+\t\treturn nil, errFakeConnSessionDirty\n \t}\n \n \terr := checkSubsetTypes(s.c.db.allowAny, args)\n@@ -887,6 +897,37 @@ func (s *fakeStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tif s.table == \"tx_status\" && s.colName[0] == \"tx_status\" {\n+\t\t\ttxStatus := \"autocommit\"\n+\t\t\tif s.c.currTx != nil {\n+\t\t\t\ttxStatus = \"transaction\"\n+\t\t\t}\n+\t\t\tcursor := &rowsCursor{\n+\t\t\t\tparentMem: s.c,\n+\t\t\t\tposRow:    -1,\n+\t\t\t\trows: [][]*row{\n+\t\t\t\t\t[]*row{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tcols: []interface{}{\n+\t\t\t\t\t\t\t\ttxStatus,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tcols: [][]string{\n+\t\t\t\t\t[]string{\n+\t\t\t\t\t\t\"tx_status\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tcolType: [][]string{\n+\t\t\t\t\t[]string{\n+\t\t\t\t\t\t\"string\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\terrPos: -1,\n+\t\t\t}\n+\t\t\treturn cursor, nil\n+\t\t}\n \n \t\tt.mu.Lock()\n "}, {"sha": "a0b7ca8f0875a0e71355449b32ea4409300d78e5", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 110, "deletions": 90, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -421,7 +421,6 @@ type DB struct {\n \t// It is closed during db.Close(). The close tells the connectionOpener\n \t// goroutine to exit.\n \topenerCh          chan struct{}\n-\tresetterCh        chan *driverConn\n \tclosed            bool\n \tdep               map[finalCloser]depSet\n \tlastPut           map[*driverConn]string // stacktrace of last conn's put; debug only\n@@ -458,10 +457,10 @@ type driverConn struct {\n \n \tsync.Mutex  // guards following\n \tci          driver.Conn\n+\tneedReset   bool // The connection session should be reset before use if true.\n \tclosed      bool\n \tfinalClosed bool // ci.Close has been called\n \topenStmt    map[*driverStmt]bool\n-\tlastErr     error // lastError captures the result of the session resetter.\n \n \t// guarded by db.mu\n \tinUse      bool\n@@ -486,6 +485,41 @@ func (dc *driverConn) expired(timeout time.Duration) bool {\n \treturn dc.createdAt.Add(timeout).Before(nowFunc())\n }\n \n+// resetSession checks if the driver connection needs the\n+// session to be reset and if required, resets it.\n+func (dc *driverConn) resetSession(ctx context.Context) error {\n+\tdc.Lock()\n+\tdefer dc.Unlock()\n+\n+\tif !dc.needReset {\n+\t\treturn nil\n+\t}\n+\tif cr, ok := dc.ci.(driver.SessionResetter); ok {\n+\t\treturn cr.ResetSession(ctx)\n+\t}\n+\treturn nil\n+}\n+\n+// validator was introduced for Go1.15, but backported to Go1.14.\n+type validator interface {\n+\tIsValid() bool\n+}\n+\n+// validateConnection checks if the connection is valid and can\n+// still be used. It also marks the session for reset if required.\n+func (dc *driverConn) validateConnection(needsReset bool) bool {\n+\tdc.Lock()\n+\tdefer dc.Unlock()\n+\n+\tif needsReset {\n+\t\tdc.needReset = true\n+\t}\n+\tif cv, ok := dc.ci.(validator); ok {\n+\t\treturn cv.IsValid()\n+\t}\n+\treturn true\n+}\n+\n // prepareLocked prepares the query on dc. When cg == nil the dc must keep track of\n // the prepared statements in a pool.\n func (dc *driverConn) prepareLocked(ctx context.Context, cg stmtConnGrabber, query string) (*driverStmt, error) {\n@@ -511,19 +545,6 @@ func (dc *driverConn) prepareLocked(ctx context.Context, cg stmtConnGrabber, que\n \treturn ds, nil\n }\n \n-// resetSession resets the connection session and sets the lastErr\n-// that is checked before returning the connection to another query.\n-//\n-// resetSession assumes that the embedded mutex is locked when the connection\n-// was returned to the pool. This unlocks the mutex.\n-func (dc *driverConn) resetSession(ctx context.Context) {\n-\tdefer dc.Unlock() // In case of panic.\n-\tif dc.closed {    // Check if the database has been closed.\n-\t\treturn\n-\t}\n-\tdc.lastErr = dc.ci.(driver.SessionResetter).ResetSession(ctx)\n-}\n-\n // the dc.db's Mutex is held.\n func (dc *driverConn) closeDBLocked() func() error {\n \tdc.Lock()\n@@ -713,14 +734,12 @@ func OpenDB(c driver.Connector) *DB {\n \tdb := &DB{\n \t\tconnector:    c,\n \t\topenerCh:     make(chan struct{}, connectionRequestQueueSize),\n-\t\tresetterCh:   make(chan *driverConn, 50),\n \t\tlastPut:      make(map[*driverConn]string),\n \t\tconnRequests: make(map[uint64]chan connRequest),\n \t\tstop:         cancel,\n \t}\n \n \tgo db.connectionOpener(ctx)\n-\tgo db.connectionResetter(ctx)\n \n \treturn db\n }\n@@ -1058,23 +1077,6 @@ func (db *DB) connectionOpener(ctx context.Context) {\n \t}\n }\n \n-// connectionResetter runs in a separate goroutine to reset connections async\n-// to exported API.\n-func (db *DB) connectionResetter(ctx context.Context) {\n-\tfor {\n-\t\tselect {\n-\t\tcase <-ctx.Done():\n-\t\t\tclose(db.resetterCh)\n-\t\t\tfor dc := range db.resetterCh {\n-\t\t\t\tdc.Unlock()\n-\t\t\t}\n-\t\t\treturn\n-\t\tcase dc := <-db.resetterCh:\n-\t\t\tdc.resetSession(ctx)\n-\t\t}\n-\t}\n-}\n-\n // Open one new connection\n func (db *DB) openNewConnection(ctx context.Context) {\n \t// maybeOpenNewConnctions has already executed db.numOpen++ before it sent\n@@ -1155,14 +1157,13 @@ func (db *DB) conn(ctx context.Context, strategy connReuseStrategy) (*driverConn\n \t\t\tconn.Close()\n \t\t\treturn nil, driver.ErrBadConn\n \t\t}\n-\t\t// Lock around reading lastErr to ensure the session resetter finished.\n-\t\tconn.Lock()\n-\t\terr := conn.lastErr\n-\t\tconn.Unlock()\n-\t\tif err == driver.ErrBadConn {\n+\n+\t\t// Reset the session if required.\n+\t\tif err := conn.resetSession(ctx); err == driver.ErrBadConn {\n \t\t\tconn.Close()\n \t\t\treturn nil, driver.ErrBadConn\n \t\t}\n+\n \t\treturn conn, nil\n \t}\n \n@@ -1204,18 +1205,22 @@ func (db *DB) conn(ctx context.Context, strategy connReuseStrategy) (*driverConn\n \t\t\tif !ok {\n \t\t\t\treturn nil, errDBClosed\n \t\t\t}\n-\t\t\tif ret.err == nil && ret.conn.expired(lifetime) {\n+\t\t\t// Only check if the connection is expired if the strategy is cachedOrNewConns.\n+\t\t\t// If we require a new connection, just re-use the connection without looking\n+\t\t\t// at the expiry time. If it is expired, it will be checked when it is placed\n+\t\t\t// back into the connection pool.\n+\t\t\t// This prioritizes giving a valid connection to a client over the exact connection\n+\t\t\t// lifetime, which could expire exactly after this point anyway.\n+\t\t\tif strategy == cachedOrNewConn && ret.err == nil && ret.conn.expired(lifetime) {\n \t\t\t\tret.conn.Close()\n \t\t\t\treturn nil, driver.ErrBadConn\n \t\t\t}\n \t\t\tif ret.conn == nil {\n \t\t\t\treturn nil, ret.err\n \t\t\t}\n-\t\t\t// Lock around reading lastErr to ensure the session resetter finished.\n-\t\t\tret.conn.Lock()\n-\t\t\terr := ret.conn.lastErr\n-\t\t\tret.conn.Unlock()\n-\t\t\tif err == driver.ErrBadConn {\n+\n+\t\t\t// Reset the session if required.\n+\t\t\tif err := ret.conn.resetSession(ctx); err == driver.ErrBadConn {\n \t\t\t\tret.conn.Close()\n \t\t\t\treturn nil, driver.ErrBadConn\n \t\t\t}\n@@ -1275,13 +1280,23 @@ const debugGetPut = false\n // putConn adds a connection to the db's free pool.\n // err is optionally the last error that occurred on this connection.\n func (db *DB) putConn(dc *driverConn, err error, resetSession bool) {\n+\tif err != driver.ErrBadConn {\n+\t\tif !dc.validateConnection(resetSession) {\n+\t\t\terr = driver.ErrBadConn\n+\t\t}\n+\t}\n \tdb.mu.Lock()\n \tif !dc.inUse {\n+\t\tdb.mu.Unlock()\n \t\tif debugGetPut {\n \t\t\tfmt.Printf(\"putConn(%v) DUPLICATE was: %s\\n\\nPREVIOUS was: %s\", dc, stack(), db.lastPut[dc])\n \t\t}\n \t\tpanic(\"sql: connection returned that was never out\")\n \t}\n+\n+\tif err != driver.ErrBadConn && dc.expired(db.maxLifetime) {\n+\t\terr = driver.ErrBadConn\n+\t}\n \tif debugGetPut {\n \t\tdb.lastPut[dc] = stack()\n \t}\n@@ -1305,41 +1320,13 @@ func (db *DB) putConn(dc *driverConn, err error, resetSession bool) {\n \tif putConnHook != nil {\n \t\tputConnHook(db, dc)\n \t}\n-\tif db.closed {\n-\t\t// Connections do not need to be reset if they will be closed.\n-\t\t// Prevents writing to resetterCh after the DB has closed.\n-\t\tresetSession = false\n-\t}\n-\tif resetSession {\n-\t\tif _, resetSession = dc.ci.(driver.SessionResetter); resetSession {\n-\t\t\t// Lock the driverConn here so it isn't released until\n-\t\t\t// the connection is reset.\n-\t\t\t// The lock must be taken before the connection is put into\n-\t\t\t// the pool to prevent it from being taken out before it is reset.\n-\t\t\tdc.Lock()\n-\t\t}\n-\t}\n \tadded := db.putConnDBLocked(dc, nil)\n \tdb.mu.Unlock()\n \n \tif !added {\n-\t\tif resetSession {\n-\t\t\tdc.Unlock()\n-\t\t}\n \t\tdc.Close()\n \t\treturn\n \t}\n-\tif !resetSession {\n-\t\treturn\n-\t}\n-\tselect {\n-\tdefault:\n-\t\t// If the resetterCh is blocking then mark the connection\n-\t\t// as bad and continue on.\n-\t\tdc.lastErr = driver.ErrBadConn\n-\t\tdc.Unlock()\n-\tcase db.resetterCh <- dc:\n-\t}\n }\n \n // Satisfy a connRequest or put the driverConn in the idle pool and return true\n@@ -1701,7 +1688,11 @@ func (db *DB) begin(ctx context.Context, opts *TxOptions, strategy connReuseStra\n // beginDC starts a transaction. The provided dc must be valid and ready to use.\n func (db *DB) beginDC(ctx context.Context, dc *driverConn, release func(error), opts *TxOptions) (tx *Tx, err error) {\n \tvar txi driver.Tx\n+\tkeepConnOnRollback := false\n \twithLock(dc, func() {\n+\t\t_, hasSessionResetter := dc.ci.(driver.SessionResetter)\n+\t\t_, hasConnectionValidator := dc.ci.(validator)\n+\t\tkeepConnOnRollback = hasSessionResetter && hasConnectionValidator\n \t\ttxi, err = ctxDriverBegin(ctx, opts, dc.ci)\n \t})\n \tif err != nil {\n@@ -1713,12 +1704,13 @@ func (db *DB) beginDC(ctx context.Context, dc *driverConn, release func(error),\n \t// The cancel function in Tx will be called after done is set to true.\n \tctx, cancel := context.WithCancel(ctx)\n \ttx = &Tx{\n-\t\tdb:          db,\n-\t\tdc:          dc,\n-\t\treleaseConn: release,\n-\t\ttxi:         txi,\n-\t\tcancel:      cancel,\n-\t\tctx:         ctx,\n+\t\tdb:                 db,\n+\t\tdc:                 dc,\n+\t\treleaseConn:        release,\n+\t\ttxi:                txi,\n+\t\tcancel:             cancel,\n+\t\tkeepConnOnRollback: keepConnOnRollback,\n+\t\tctx:                ctx,\n \t}\n \tgo tx.awaitDone()\n \treturn tx, nil\n@@ -1980,6 +1972,11 @@ type Tx struct {\n \t// Use atomic operations on value when checking value.\n \tdone int32\n \n+\t// keepConnOnRollback is true if the driver knows\n+\t// how to reset the connection's session and if need be discard\n+\t// the connection.\n+\tkeepConnOnRollback bool\n+\n \t// All Stmts prepared for this transaction. These will be closed after the\n \t// transaction has been committed or rolled back.\n \tstmts struct {\n@@ -2005,7 +2002,10 @@ func (tx *Tx) awaitDone() {\n \t// transaction is closed and the resources are released.  This\n \t// rollback does nothing if the transaction has already been\n \t// committed or rolled back.\n-\ttx.rollback(true)\n+\t// Do not discard the connection if the connection knows\n+\t// how to reset the session.\n+\tdiscardConnection := !tx.keepConnOnRollback\n+\ttx.rollback(discardConnection)\n }\n \n func (tx *Tx) isDone() bool {\n@@ -2016,14 +2016,10 @@ func (tx *Tx) isDone() bool {\n // that has already been committed or rolled back.\n var ErrTxDone = errors.New(\"sql: transaction has already been committed or rolled back\")\n \n-// close returns the connection to the pool and\n-// must only be called by Tx.rollback or Tx.Commit.\n-func (tx *Tx) close(err error) {\n-\ttx.cancel()\n-\n-\ttx.closemu.Lock()\n-\tdefer tx.closemu.Unlock()\n-\n+// closeLocked returns the connection to the pool and\n+// must only be called by Tx.rollback or Tx.Commit while\n+// closemu is Locked and tx already canceled.\n+func (tx *Tx) closeLocked(err error) {\n \ttx.releaseConn(err)\n \ttx.dc = nil\n \ttx.txi = nil\n@@ -2090,23 +2086,47 @@ func (tx *Tx) Commit() error {\n \tif !atomic.CompareAndSwapInt32(&tx.done, 0, 1) {\n \t\treturn ErrTxDone\n \t}\n+\n+\t// Cancel the Tx to release any active R-closemu locks.\n+\t// This is safe to do because tx.done has already transitioned\n+\t// from 0 to 1. Hold the W-closemu lock prior to rollback\n+\t// to ensure no other connection has an active query.\n+\ttx.cancel()\n+\ttx.closemu.Lock()\n+\tdefer tx.closemu.Unlock()\n+\n \tvar err error\n \twithLock(tx.dc, func() {\n \t\terr = tx.txi.Commit()\n \t})\n \tif err != driver.ErrBadConn {\n \t\ttx.closePrepared()\n \t}\n-\ttx.close(err)\n+\ttx.closeLocked(err)\n \treturn err\n }\n \n+var rollbackHook func()\n+\n // rollback aborts the transaction and optionally forces the pool to discard\n // the connection.\n func (tx *Tx) rollback(discardConn bool) error {\n \tif !atomic.CompareAndSwapInt32(&tx.done, 0, 1) {\n \t\treturn ErrTxDone\n \t}\n+\n+\tif rollbackHook != nil {\n+\t\trollbackHook()\n+\t}\n+\n+\t// Cancel the Tx to release any active R-closemu locks.\n+\t// This is safe to do because tx.done has already transitioned\n+\t// from 0 to 1. Hold the W-closemu lock prior to rollback\n+\t// to ensure no other connection has an active query.\n+\ttx.cancel()\n+\ttx.closemu.Lock()\n+\tdefer tx.closemu.Unlock()\n+\n \tvar err error\n \twithLock(tx.dc, func() {\n \t\terr = tx.txi.Rollback()\n@@ -2117,7 +2137,7 @@ func (tx *Tx) rollback(discardConn bool) error {\n \tif discardConn {\n \t\terr = driver.ErrBadConn\n \t}\n-\ttx.close(err)\n+\ttx.closeLocked(err)\n \treturn err\n }\n "}, {"sha": "a9e18004fb4a308f5d4ff421924fb09e6e92309b", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -80,6 +80,11 @@ func newTestDBConnector(t testing.TB, fc *fakeConnector, name string) *DB {\n \t\texec(t, db, \"CREATE|magicquery|op=string,millis=int32\")\n \t\texec(t, db, \"INSERT|magicquery|op=sleep,millis=10\")\n \t}\n+\tif name == \"tx_status\" {\n+\t\t// Magic table name and column, known by fakedb_test.go.\n+\t\texec(t, db, \"CREATE|tx_status|tx_status=string\")\n+\t\texec(t, db, \"INSERT|tx_status|tx_status=invalid\")\n+\t}\n \treturn db\n }\n \n@@ -437,6 +442,7 @@ func TestTxContextWait(t *testing.T) {\n \t\t}\n \t\tt.Fatal(err)\n \t}\n+\ttx.keepConnOnRollback = false\n \n \t// This will trigger the *fakeConn.Prepare method which will take time\n \t// performing the query. The ctxDriverPrepare func will check the context\n@@ -449,6 +455,35 @@ func TestTxContextWait(t *testing.T) {\n \twaitForFree(t, db, 5*time.Second, 0)\n }\n \n+// TestTxContextWaitNoDiscard is the same as TestTxContextWait, but should not discard\n+// the final connection.\n+func TestTxContextWaitNoDiscard(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Millisecond)\n+\tdefer cancel()\n+\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\t// Guard against the context being canceled before BeginTx completes.\n+\t\tif err == context.DeadlineExceeded {\n+\t\t\tt.Skip(\"tx context canceled prior to first use\")\n+\t\t}\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// This will trigger the *fakeConn.Prepare method which will take time\n+\t// performing the query. The ctxDriverPrepare func will check the context\n+\t// after this and close the rows and return an error.\n+\t_, err = tx.QueryContext(ctx, \"WAIT|1s|SELECT|people|age,name|\")\n+\tif err != context.DeadlineExceeded {\n+\t\tt.Fatalf(\"expected QueryContext to error with context deadline exceeded but returned %v\", err)\n+\t}\n+\n+\twaitForFree(t, db, 5*time.Second, 1)\n+}\n+\n // TestUnsupportedOptions checks that the database fails when a driver that\n // doesn't implement ConnBeginTx is used with non-default options and an\n // un-cancellable context.\n@@ -1525,6 +1560,37 @@ func TestConnTx(t *testing.T) {\n \t}\n }\n \n+// TestConnIsValid verifies that a database connection that should be discarded,\n+// is actually discarded and does not re-enter the connection pool.\n+// If the IsValid method from *fakeConn is removed, this test will fail.\n+func TestConnIsValid(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tdb.SetMaxOpenConns(1)\n+\n+\tctx := context.Background()\n+\n+\tc, err := db.Conn(ctx)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\terr = c.Raw(func(raw interface{}) error {\n+\t\tdc := raw.(*fakeConn)\n+\t\tdc.stickyBad = true\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.Close()\n+\n+\tif len(db.freeConn) > 0 && db.freeConn[0].ci.(*fakeConn).stickyBad {\n+\t\tt.Fatal(\"bad connection returned to pool; expected bad connection to be discarded\")\n+\t}\n+}\n+\n // Tests fix for issue 2542, that we release a lock when querying on\n // a closed connection.\n func TestIssue2542Deadlock(t *testing.T) {\n@@ -2658,6 +2724,159 @@ func TestManyErrBadConn(t *testing.T) {\n \t}\n }\n \n+// Issue 34755: Ensure that a Tx cannot commit after a rollback.\n+func TestTxCannotCommitAfterRollback(t *testing.T) {\n+\tdb := newTestDB(t, \"tx_status\")\n+\tdefer closeDB(t, db)\n+\n+\t// First check query reporting is correct.\n+\tvar txStatus string\n+\terr := db.QueryRow(\"SELECT|tx_status|tx_status|\").Scan(&txStatus)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, w := txStatus, \"autocommit\"; g != w {\n+\t\tt.Fatalf(\"tx_status=%q, wanted %q\", g, w)\n+\t}\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Ignore dirty session for this test.\n+\t// A failing test should trigger the dirty session flag as well,\n+\t// but that isn't exactly what this should test for.\n+\ttx.txi.(*fakeTx).c.skipDirtySession = true\n+\n+\tdefer tx.Rollback()\n+\n+\terr = tx.QueryRow(\"SELECT|tx_status|tx_status|\").Scan(&txStatus)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, w := txStatus, \"transaction\"; g != w {\n+\t\tt.Fatalf(\"tx_status=%q, wanted %q\", g, w)\n+\t}\n+\n+\t// 1. Begin a transaction.\n+\t// 2. (A) Start a query, (B) begin Tx rollback through a ctx cancel.\n+\t// 3. Check if 2.A has committed in Tx (pass) or outside of Tx (fail).\n+\tsendQuery := make(chan struct{})\n+\thookTxGrabConn = func() {\n+\t\tcancel()\n+\t\t<-sendQuery\n+\t}\n+\trollbackHook = func() {\n+\t\tclose(sendQuery)\n+\t}\n+\tdefer func() {\n+\t\thookTxGrabConn = nil\n+\t\trollbackHook = nil\n+\t}()\n+\n+\terr = tx.QueryRow(\"SELECT|tx_status|tx_status|\").Scan(&txStatus)\n+\tif err != nil {\n+\t\t// A failure here would be expected if skipDirtySession was not set to true above.\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, w := txStatus, \"transaction\"; g != w {\n+\t\tt.Fatalf(\"tx_status=%q, wanted %q\", g, w)\n+\t}\n+}\n+\n+// Issue32530 encounters an issue where a connection may\n+// expire right after it comes out of a used connection pool\n+// even when a new connection is requested.\n+func TestConnExpiresFreshOutOfPool(t *testing.T) {\n+\texecCases := []struct {\n+\t\texpired  bool\n+\t\tbadReset bool\n+\t}{\n+\t\t{false, false},\n+\t\t{true, false},\n+\t\t{false, true},\n+\t}\n+\n+\tt0 := time.Unix(1000000, 0)\n+\toffset := time.Duration(0)\n+\toffsetMu := sync.RWMutex{}\n+\n+\tnowFunc = func() time.Time {\n+\t\toffsetMu.RLock()\n+\t\tdefer offsetMu.RUnlock()\n+\t\treturn t0.Add(offset)\n+\t}\n+\tdefer func() { nowFunc = time.Now }()\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\tdb := newTestDB(t, \"magicquery\")\n+\tdefer closeDB(t, db)\n+\n+\tdb.SetMaxOpenConns(1)\n+\n+\tfor _, ec := range execCases {\n+\t\tec := ec\n+\t\tname := fmt.Sprintf(\"expired=%t,badReset=%t\", ec.expired, ec.badReset)\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tdb.clearAllConns(t)\n+\n+\t\t\tdb.SetMaxIdleConns(1)\n+\t\t\tdb.SetConnMaxLifetime(10 * time.Second)\n+\n+\t\t\tconn, err := db.conn(ctx, alwaysNewConn)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\n+\t\t\tafterPutConn := make(chan struct{})\n+\t\t\twaitingForConn := make(chan struct{})\n+\n+\t\t\tgo func() {\n+\t\t\t\tconn, err := db.conn(ctx, alwaysNewConn)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tdb.putConn(conn, err, false)\n+\t\t\t\tclose(afterPutConn)\n+\t\t\t}()\n+\t\t\tgo func() {\n+\t\t\t\tfor {\n+\t\t\t\t\tdb.mu.Lock()\n+\t\t\t\t\tct := len(db.connRequests)\n+\t\t\t\t\tdb.mu.Unlock()\n+\t\t\t\t\tif ct > 0 {\n+\t\t\t\t\t\tclose(waitingForConn)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n+\t\t\t\t}\n+\t\t\t}()\n+\n+\t\t\t<-waitingForConn\n+\n+\t\t\toffsetMu.Lock()\n+\t\t\tif ec.expired {\n+\t\t\t\toffset = 11 * time.Second\n+\t\t\t} else {\n+\t\t\t\toffset = time.Duration(0)\n+\t\t\t}\n+\t\t\toffsetMu.Unlock()\n+\n+\t\t\tconn.ci.(*fakeConn).stickyBad = ec.badReset\n+\n+\t\t\tdb.putConn(conn, err, true)\n+\n+\t\t\t<-afterPutConn\n+\t\t})\n+\t}\n+}\n+\n // TestIssue20575 ensures the Rows from query does not block\n // closing a transaction. Ensure Rows is closed while closing a trasaction.\n func TestIssue20575(t *testing.T) {"}, {"sha": "86d8a69db7e6d76aa40ca9d4b307ea2f43e909b7", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 32, "deletions": 42, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -213,9 +213,6 @@ type decodeState struct {\n \tsavedError            error\n \tuseNumber             bool\n \tdisallowUnknownFields bool\n-\t// safeUnquote is the number of current string literal bytes that don't\n-\t// need to be unquoted. When negative, no bytes need unquoting.\n-\tsafeUnquote int\n }\n \n // readIndex returns the position of the last byte read.\n@@ -317,27 +314,13 @@ func (d *decodeState) rescanLiteral() {\n Switch:\n \tswitch data[i-1] {\n \tcase '\"': // string\n-\t\t// safeUnquote is initialized at -1, which means that all bytes\n-\t\t// checked so far can be unquoted at a later time with no work\n-\t\t// at all. When reaching the closing '\"', if safeUnquote is\n-\t\t// still -1, all bytes can be unquoted with no work. Otherwise,\n-\t\t// only those bytes up until the first '\\\\' or non-ascii rune\n-\t\t// can be safely unquoted.\n-\t\tsafeUnquote := -1\n \t\tfor ; i < len(data); i++ {\n-\t\t\tif c := data[i]; c == '\\\\' {\n-\t\t\t\tif safeUnquote < 0 { // first unsafe byte\n-\t\t\t\t\tsafeUnquote = int(i - d.off)\n-\t\t\t\t}\n+\t\t\tswitch data[i] {\n+\t\t\tcase '\\\\':\n \t\t\t\ti++ // escaped char\n-\t\t\t} else if c == '\"' {\n-\t\t\t\td.safeUnquote = safeUnquote\n+\t\t\tcase '\"':\n \t\t\t\ti++ // tokenize the closing quote too\n \t\t\t\tbreak Switch\n-\t\t\t} else if c >= utf8.RuneSelf {\n-\t\t\t\tif safeUnquote < 0 { // first unsafe byte\n-\t\t\t\t\tsafeUnquote = int(i - d.off)\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-': // number\n@@ -691,7 +674,7 @@ func (d *decodeState) object(v reflect.Value) error {\n \t\tstart := d.readIndex()\n \t\td.rescanLiteral()\n \t\titem := d.data[start:d.readIndex()]\n-\t\tkey, ok := d.unquoteBytes(item)\n+\t\tkey, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\tpanic(phasePanicMsg)\n \t\t}\n@@ -892,7 +875,7 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\t\td.saveError(&UnmarshalTypeError{Value: val, Type: v.Type(), Offset: int64(d.readIndex())})\n \t\t\treturn nil\n \t\t}\n-\t\ts, ok := d.unquoteBytes(item)\n+\t\ts, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\tif fromQuoted {\n \t\t\t\treturn fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())\n@@ -943,7 +926,7 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\t}\n \n \tcase '\"': // string\n-\t\ts, ok := d.unquoteBytes(item)\n+\t\ts, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\tif fromQuoted {\n \t\t\t\treturn fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())\n@@ -1103,7 +1086,7 @@ func (d *decodeState) objectInterface() map[string]interface{} {\n \t\tstart := d.readIndex()\n \t\td.rescanLiteral()\n \t\titem := d.data[start:d.readIndex()]\n-\t\tkey, ok := d.unquote(item)\n+\t\tkey, ok := unquote(item)\n \t\tif !ok {\n \t\t\tpanic(phasePanicMsg)\n \t\t}\n@@ -1152,7 +1135,7 @@ func (d *decodeState) literalInterface() interface{} {\n \t\treturn c == 't'\n \n \tcase '\"': // string\n-\t\ts, ok := d.unquote(item)\n+\t\ts, ok := unquote(item)\n \t\tif !ok {\n \t\t\tpanic(phasePanicMsg)\n \t\t}\n@@ -1195,33 +1178,40 @@ func getu4(s []byte) rune {\n \n // unquote converts a quoted JSON string literal s into an actual string t.\n // The rules are different than for Go, so cannot use strconv.Unquote.\n-// The first byte in s must be '\"'.\n-func (d *decodeState) unquote(s []byte) (t string, ok bool) {\n-\ts, ok = d.unquoteBytes(s)\n+func unquote(s []byte) (t string, ok bool) {\n+\ts, ok = unquoteBytes(s)\n \tt = string(s)\n \treturn\n }\n \n-func (d *decodeState) unquoteBytes(s []byte) (t []byte, ok bool) {\n-\t// We already know that s[0] == '\"'. However, we don't know that the\n-\t// closing quote exists in all cases, such as when the string is nested\n-\t// via the \",string\" option.\n-\tif len(s) < 2 || s[len(s)-1] != '\"' {\n+func unquoteBytes(s []byte) (t []byte, ok bool) {\n+\tif len(s) < 2 || s[0] != '\"' || s[len(s)-1] != '\"' {\n \t\treturn\n \t}\n \ts = s[1 : len(s)-1]\n \n-\t// If there are no unusual characters, no unquoting is needed, so return\n-\t// a slice of the original bytes.\n-\tr := d.safeUnquote\n-\tif r == -1 {\n+\t// Check for unusual characters. If there are none,\n+\t// then no unquoting is needed, so return a slice of the\n+\t// original bytes.\n+\tr := 0\n+\tfor r < len(s) {\n+\t\tc := s[r]\n+\t\tif c == '\\\\' || c == '\"' || c < ' ' {\n+\t\t\tbreak\n+\t\t}\n+\t\tif c < utf8.RuneSelf {\n+\t\t\tr++\n+\t\t\tcontinue\n+\t\t}\n+\t\trr, size := utf8.DecodeRune(s[r:])\n+\t\tif rr == utf8.RuneError && size == 1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tr += size\n+\t}\n+\tif r == len(s) {\n \t\treturn s, true\n \t}\n-\t// Only perform up to one safe unquote for each re-scanned string\n-\t// literal. In some edge cases, the decoder unquotes a literal a second\n-\t// time, even after another literal has been re-scanned. Thus, only the\n-\t// first unquote can safely use safeUnquote.\n-\td.safeUnquote = 0\n \n \tb := make([]byte, len(s)+2*utf8.UTFMax)\n \tw := copy(b, s[0:r])"}, {"sha": "689cc34c24361ca97b9ca6f4325518040125bcf5", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -2459,4 +2459,20 @@ func TestUnmarshalRescanLiteralMangledUnquote(t *testing.T) {\n \tif t1 != t2 {\n \t\tt.Errorf(\"Marshal and Unmarshal roundtrip mismatch: want %q got %q\", t1, t2)\n \t}\n+\n+\t// See golang.org/issues/39555.\n+\tinput := map[textUnmarshalerString]string{\"FOO\": \"\", `\"`: \"\"}\n+\n+\tencoded, err := Marshal(input)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal unexpected error: %v\", err)\n+\t}\n+\tvar got map[textUnmarshalerString]string\n+\tif err := Unmarshal(encoded, &got); err != nil {\n+\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n+\t}\n+\twant := map[textUnmarshalerString]string{\"foo\": \"\", `\"`: \"\"}\n+\tif !reflect.DeepEqual(want, got) {\n+\t\tt.Fatalf(\"Unexpected roundtrip result:\\nwant: %q\\ngot:  %q\", want, got)\n+\t}\n }"}, {"sha": "e6177f2ea9b89fa76460a06150ffc4000f45109f", "filename": "libgo/go/golang.org/x/tools/go/analysis/passes/printf/printf.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fprintf%2Fprintf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fprintf%2Fprintf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fprintf%2Fprintf.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -801,6 +801,7 @@ var printVerbs = []printVerb{\n \t{'g', sharpNumFlag, argFloat | argComplex},\n \t{'G', sharpNumFlag, argFloat | argComplex},\n \t{'o', sharpNumFlag, argInt | argPointer},\n+\t{'O', sharpNumFlag, argInt | argPointer},\n \t{'p', \"-#\", argPointer},\n \t{'q', \" -+.0#\", argRune | argInt | argString},\n \t{'s', \" -+.0\", argString},"}, {"sha": "b8a68cc460f5bb13dd63ec53a904db1c1661cfda", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -411,6 +411,7 @@ func checkIfNoneMatch(w ResponseWriter, r *Request) condResult {\n \t\t}\n \t\tif buf[0] == ',' {\n \t\t\tbuf = buf[1:]\n+\t\t\tcontinue\n \t\t}\n \t\tif buf[0] == '*' {\n \t\t\treturn condFalse"}, {"sha": "c082ceee71b30af65e573794df79c42b24476095", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -849,6 +849,15 @@ func TestServeContent(t *testing.T) {\n \t\t\twantStatus:      200,\n \t\t\twantContentType: \"text/css; charset=utf-8\",\n \t\t},\n+\t\t\"if_none_match_malformed\": {\n+\t\t\tfile:      \"testdata/style.css\",\n+\t\t\tserveETag: `\"foo\"`,\n+\t\t\treqHeader: map[string]string{\n+\t\t\t\t\"If-None-Match\": `,`,\n+\t\t\t},\n+\t\t\twantStatus:      200,\n+\t\t\twantContentType: \"text/css; charset=utf-8\",\n+\t\t},\n \t\t\"range_good\": {\n \t\t\tfile:      \"testdata/style.css\",\n \t\t\tserveETag: `\"A\"`,"}, {"sha": "6e6514dbddbad81dc7e7ee4f21aa41ce621b9e9c", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -425,6 +425,16 @@ type response struct {\n \twants10KeepAlive bool               // HTTP/1.0 w/ Connection \"keep-alive\"\n \twantsClose       bool               // HTTP request has Connection \"close\"\n \n+\t// canWriteContinue is a boolean value accessed as an atomic int32\n+\t// that says whether or not a 100 Continue header can be written\n+\t// to the connection.\n+\t// writeContinueMu must be held while writing the header.\n+\t// These two fields together synchronize the body reader\n+\t// (the expectContinueReader, which wants to write 100 Continue)\n+\t// against the main writer.\n+\tcanWriteContinue atomicBool\n+\twriteContinueMu  sync.Mutex\n+\n \tw  *bufio.Writer // buffers output in chunks to chunkWriter\n \tcw chunkWriter\n \n@@ -515,6 +525,7 @@ type atomicBool int32\n \n func (b *atomicBool) isSet() bool { return atomic.LoadInt32((*int32)(b)) != 0 }\n func (b *atomicBool) setTrue()    { atomic.StoreInt32((*int32)(b), 1) }\n+func (b *atomicBool) setFalse()   { atomic.StoreInt32((*int32)(b), 0) }\n \n // declareTrailer is called for each Trailer header when the\n // response header is written. It notes that a header will need to be\n@@ -877,21 +888,27 @@ type expectContinueReader struct {\n \tresp       *response\n \treadCloser io.ReadCloser\n \tclosed     bool\n-\tsawEOF     bool\n+\tsawEOF     atomicBool\n }\n \n func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {\n \tif ecr.closed {\n \t\treturn 0, ErrBodyReadAfterClose\n \t}\n-\tif !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked() {\n-\t\tecr.resp.wroteContinue = true\n-\t\tecr.resp.conn.bufw.WriteString(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n-\t\tecr.resp.conn.bufw.Flush()\n+\tw := ecr.resp\n+\tif !w.wroteContinue && w.canWriteContinue.isSet() && !w.conn.hijacked() {\n+\t\tw.wroteContinue = true\n+\t\tw.writeContinueMu.Lock()\n+\t\tif w.canWriteContinue.isSet() {\n+\t\t\tw.conn.bufw.WriteString(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n+\t\t\tw.conn.bufw.Flush()\n+\t\t\tw.canWriteContinue.setFalse()\n+\t\t}\n+\t\tw.writeContinueMu.Unlock()\n \t}\n \tn, err = ecr.readCloser.Read(p)\n \tif err == io.EOF {\n-\t\tecr.sawEOF = true\n+\t\tecr.sawEOF.setTrue()\n \t}\n \treturn\n }\n@@ -1315,7 +1332,7 @@ func (cw *chunkWriter) writeHeader(p []byte) {\n \t// because we don't know if the next bytes on the wire will be\n \t// the body-following-the-timer or the subsequent request.\n \t// See Issue 11549.\n-\tif ecr, ok := w.req.Body.(*expectContinueReader); ok && !ecr.sawEOF {\n+\tif ecr, ok := w.req.Body.(*expectContinueReader); ok && !ecr.sawEOF.isSet() {\n \t\tw.closeAfterReply = true\n \t}\n \n@@ -1565,6 +1582,17 @@ func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err er\n \t\t}\n \t\treturn 0, ErrHijacked\n \t}\n+\n+\tif w.canWriteContinue.isSet() {\n+\t\t// Body reader wants to write 100 Continue but hasn't yet.\n+\t\t// Tell it not to. The store must be done while holding the lock\n+\t\t// because the lock makes sure that there is not an active write\n+\t\t// this very moment.\n+\t\tw.writeContinueMu.Lock()\n+\t\tw.canWriteContinue.setFalse()\n+\t\tw.writeContinueMu.Unlock()\n+\t}\n+\n \tif !w.wroteHeader {\n \t\tw.WriteHeader(StatusOK)\n \t}\n@@ -1876,6 +1904,7 @@ func (c *conn) serve(ctx context.Context) {\n \t\t\tif req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {\n \t\t\t\t// Wrap the Body reader with one that replies on the connection\n \t\t\t\treq.Body = &expectContinueReader{readCloser: req.Body, resp: w}\n+\t\t\t\tw.canWriteContinue.setTrue()\n \t\t\t}\n \t\t} else if req.Header.get(\"Expect\") != \"\" {\n \t\t\tw.sendExpectationFailed()"}, {"sha": "e5ec052f7de74404353e48b37ff87e72282e87c3", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -789,6 +789,11 @@ var loop1, loop2 Loop\n var loopy1, loopy2 Loopy\n var cycleMap1, cycleMap2, cycleMap3 map[string]interface{}\n \n+type structWithSelfPtr struct {\n+\tp *structWithSelfPtr\n+\ts string\n+}\n+\n func init() {\n \tloop1 = &loop2\n \tloop2 = &loop1\n@@ -845,6 +850,7 @@ var deepEqualTests = []DeepEqualTest{\n \t{[]float64{math.NaN()}, self{}, true},\n \t{map[float64]float64{math.NaN(): 1}, map[float64]float64{1: 2}, false},\n \t{map[float64]float64{math.NaN(): 1}, self{}, true},\n+\t{&structWithSelfPtr{p: &structWithSelfPtr{s: \"a\"}}, &structWithSelfPtr{p: &structWithSelfPtr{s: \"b\"}}, false},\n \n \t// Nil vs empty: not the same.\n \t{[]int{}, []int(nil), false},"}, {"sha": "8a2bf8b09e23a42274fc70d741605566c765d323", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -45,8 +45,20 @@ func deepValueEqual(v1, v2 Value, visited map[visit]bool, depth int) bool {\n \t}\n \n \tif hard(v1, v2) {\n-\t\taddr1 := v1.ptr\n-\t\taddr2 := v2.ptr\n+\t\t// For a Ptr or Map value, we need to check flagIndir,\n+\t\t// which we do by calling the pointer method.\n+\t\t// For Slice or Interface, flagIndir is always set,\n+\t\t// and using v.ptr suffices.\n+\t\tptrval := func(v Value) unsafe.Pointer {\n+\t\t\tswitch v.Kind() {\n+\t\t\tcase Ptr, Map:\n+\t\t\t\treturn v.pointer()\n+\t\t\tdefault:\n+\t\t\t\treturn v.ptr\n+\t\t\t}\n+\t\t}\n+\t\taddr1 := ptrval(v1)\n+\t\taddr2 := ptrval(v2)\n \t\tif uintptr(addr1) > uintptr(addr2) {\n \t\t\t// Canonicalize order to reduce number of entries in visited.\n \t\t\t// Assumes non-moving garbage collector."}, {"sha": "2ce1901f5565a0266bd038499bbe0a7c2219eddb", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -2477,6 +2477,7 @@ func ifaceIndir(t *rtype) bool {\n \treturn t.kind&kindDirectIface == 0\n }\n \n+// Note: this type must agree with runtime.bitvector.\n type bitVector struct {\n \tn    uint32 // number of bits\n \tdata []byte"}, {"sha": "7c6a3e8a935c0310b191788417b2d48a2bca76de", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -2175,6 +2175,7 @@ func NewAt(typ Type, p unsafe.Pointer) Value {\n // assignTo returns a value v that can be assigned directly to typ.\n // It panics if v is not assignable to typ.\n // For a conversion to an interface type, target is a suggested scratch space to use.\n+// target must be initialized memory (or nil).\n func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value {\n \tif v.flag&flagMethod != 0 {\n \t\tv = makeMethodValue(context, v)"}, {"sha": "52766005bf6595b99808b2633afe78f8aee14cdb", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -526,6 +526,7 @@ func runBenchmarks(importPath string, matchString func(pat, str string) (bool, e\n \t\t\tname:   \"Main\",\n \t\t\tw:      os.Stdout,\n \t\t\tchatty: *chatty,\n+\t\t\tbench:  true,\n \t\t},\n \t\timportPath: importPath,\n \t\tbenchFunc: func(b *B) {\n@@ -559,6 +560,7 @@ func (ctx *benchContext) processBench(b *B) {\n \t\t\t\t\t\tname:   b.name,\n \t\t\t\t\t\tw:      b.w,\n \t\t\t\t\t\tchatty: b.chatty,\n+\t\t\t\t\t\tbench:  true,\n \t\t\t\t\t},\n \t\t\t\t\tbenchFunc: b.benchFunc,\n \t\t\t\t\tbenchTime: b.benchTime,\n@@ -624,6 +626,7 @@ func (b *B) Run(name string, f func(b *B)) bool {\n \t\t\tcreator: pc[:n],\n \t\t\tw:       b.w,\n \t\t\tchatty:  b.chatty,\n+\t\t\tbench:   true,\n \t\t},\n \t\timportPath: b.importPath,\n \t\tbenchFunc:  f,"}, {"sha": "8eb0084b1c84be712bf07f265f36dfc6a322b26b", "filename": "libgo/go/testing/sub_test.go", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Ftesting%2Fsub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Ftesting%2Fsub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fsub_test.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -438,8 +438,6 @@ func TestTRun(t *T) {\n \t}, {\n \t\t// A chatty test should always log with fmt.Print, even if the\n \t\t// parent test has completed.\n-\t\t// TODO(deklerk) Capture the log of fmt.Print and assert that the\n-\t\t// subtest message is not lost.\n \t\tdesc:   \"log in finished sub test with chatty\",\n \t\tok:     false,\n \t\tchatty: true,\n@@ -477,35 +475,37 @@ func TestTRun(t *T) {\n \t\t},\n \t}}\n \tfor _, tc := range testCases {\n-\t\tctx := newTestContext(tc.maxPar, newMatcher(regexp.MatchString, \"\", \"\"))\n-\t\tbuf := &bytes.Buffer{}\n-\t\troot := &T{\n-\t\t\tcommon: common{\n-\t\t\t\tsignal: make(chan bool),\n-\t\t\t\tname:   \"Test\",\n-\t\t\t\tw:      buf,\n-\t\t\t\tchatty: tc.chatty,\n-\t\t\t},\n-\t\t\tcontext: ctx,\n-\t\t}\n-\t\tok := root.Run(tc.desc, tc.f)\n-\t\tctx.release()\n+\t\tt.Run(tc.desc, func(t *T) {\n+\t\t\tctx := newTestContext(tc.maxPar, newMatcher(regexp.MatchString, \"\", \"\"))\n+\t\t\tbuf := &bytes.Buffer{}\n+\t\t\troot := &T{\n+\t\t\t\tcommon: common{\n+\t\t\t\t\tsignal: make(chan bool),\n+\t\t\t\t\tname:   \"Test\",\n+\t\t\t\t\tw:      buf,\n+\t\t\t\t\tchatty: tc.chatty,\n+\t\t\t\t},\n+\t\t\t\tcontext: ctx,\n+\t\t\t}\n+\t\t\tok := root.Run(tc.desc, tc.f)\n+\t\t\tctx.release()\n \n-\t\tif ok != tc.ok {\n-\t\t\tt.Errorf(\"%s:ok: got %v; want %v\", tc.desc, ok, tc.ok)\n-\t\t}\n-\t\tif ok != !root.Failed() {\n-\t\t\tt.Errorf(\"%s:root failed: got %v; want %v\", tc.desc, !ok, root.Failed())\n-\t\t}\n-\t\tif ctx.running != 0 || ctx.numWaiting != 0 {\n-\t\t\tt.Errorf(\"%s:running and waiting non-zero: got %d and %d\", tc.desc, ctx.running, ctx.numWaiting)\n-\t\t}\n-\t\tgot := strings.TrimSpace(buf.String())\n-\t\twant := strings.TrimSpace(tc.output)\n-\t\tre := makeRegexp(want)\n-\t\tif ok, err := regexp.MatchString(re, got); !ok || err != nil {\n-\t\t\tt.Errorf(\"%s:output:\\ngot:\\n%s\\nwant:\\n%s\", tc.desc, got, want)\n-\t\t}\n+\t\t\tif ok != tc.ok {\n+\t\t\t\tt.Errorf(\"%s:ok: got %v; want %v\", tc.desc, ok, tc.ok)\n+\t\t\t}\n+\t\t\tif ok != !root.Failed() {\n+\t\t\t\tt.Errorf(\"%s:root failed: got %v; want %v\", tc.desc, !ok, root.Failed())\n+\t\t\t}\n+\t\t\tif ctx.running != 0 || ctx.numWaiting != 0 {\n+\t\t\t\tt.Errorf(\"%s:running and waiting non-zero: got %d and %d\", tc.desc, ctx.running, ctx.numWaiting)\n+\t\t\t}\n+\t\t\tgot := strings.TrimSpace(buf.String())\n+\t\t\twant := strings.TrimSpace(tc.output)\n+\t\t\tre := makeRegexp(want)\n+\t\t\tif ok, err := regexp.MatchString(re, got); !ok || err != nil {\n+\t\t\t\tt.Errorf(\"%s:output:\\ngot:\\n%s\\nwant:\\n%s\", tc.desc, got, want)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -655,43 +655,45 @@ func TestBRun(t *T) {\n \t\t},\n \t}}\n \tfor _, tc := range testCases {\n-\t\tvar ok bool\n-\t\tbuf := &bytes.Buffer{}\n-\t\t// This is almost like the Benchmark function, except that we override\n-\t\t// the benchtime and catch the failure result of the subbenchmark.\n-\t\troot := &B{\n-\t\t\tcommon: common{\n-\t\t\t\tsignal: make(chan bool),\n-\t\t\t\tname:   \"root\",\n-\t\t\t\tw:      buf,\n-\t\t\t\tchatty: tc.chatty,\n-\t\t\t},\n-\t\t\tbenchFunc: func(b *B) { ok = b.Run(\"test\", tc.f) }, // Use Run to catch failure.\n-\t\t\tbenchTime: benchTimeFlag{d: 1 * time.Microsecond},\n-\t\t}\n-\t\troot.runN(1)\n-\t\tif ok != !tc.failed {\n-\t\t\tt.Errorf(\"%s:ok: got %v; want %v\", tc.desc, ok, !tc.failed)\n-\t\t}\n-\t\tif !ok != root.Failed() {\n-\t\t\tt.Errorf(\"%s:root failed: got %v; want %v\", tc.desc, !ok, root.Failed())\n-\t\t}\n-\t\t// All tests are run as subtests\n-\t\tif root.result.N != 1 {\n-\t\t\tt.Errorf(\"%s: N for parent benchmark was %d; want 1\", tc.desc, root.result.N)\n-\t\t}\n-\t\tgot := strings.TrimSpace(buf.String())\n-\t\twant := strings.TrimSpace(tc.output)\n-\t\tre := makeRegexp(want)\n-\t\tif ok, err := regexp.MatchString(re, got); !ok || err != nil {\n-\t\t\tt.Errorf(\"%s:output:\\ngot:\\n%s\\nwant:\\n%s\", tc.desc, got, want)\n-\t\t}\n+\t\tt.Run(tc.desc, func(t *T) {\n+\t\t\tvar ok bool\n+\t\t\tbuf := &bytes.Buffer{}\n+\t\t\t// This is almost like the Benchmark function, except that we override\n+\t\t\t// the benchtime and catch the failure result of the subbenchmark.\n+\t\t\troot := &B{\n+\t\t\t\tcommon: common{\n+\t\t\t\t\tsignal: make(chan bool),\n+\t\t\t\t\tname:   \"root\",\n+\t\t\t\t\tw:      buf,\n+\t\t\t\t\tchatty: tc.chatty,\n+\t\t\t\t},\n+\t\t\t\tbenchFunc: func(b *B) { ok = b.Run(\"test\", tc.f) }, // Use Run to catch failure.\n+\t\t\t\tbenchTime: benchTimeFlag{d: 1 * time.Microsecond},\n+\t\t\t}\n+\t\t\troot.runN(1)\n+\t\t\tif ok != !tc.failed {\n+\t\t\t\tt.Errorf(\"%s:ok: got %v; want %v\", tc.desc, ok, !tc.failed)\n+\t\t\t}\n+\t\t\tif !ok != root.Failed() {\n+\t\t\t\tt.Errorf(\"%s:root failed: got %v; want %v\", tc.desc, !ok, root.Failed())\n+\t\t\t}\n+\t\t\t// All tests are run as subtests\n+\t\t\tif root.result.N != 1 {\n+\t\t\t\tt.Errorf(\"%s: N for parent benchmark was %d; want 1\", tc.desc, root.result.N)\n+\t\t\t}\n+\t\t\tgot := strings.TrimSpace(buf.String())\n+\t\t\twant := strings.TrimSpace(tc.output)\n+\t\t\tre := makeRegexp(want)\n+\t\t\tif ok, err := regexp.MatchString(re, got); !ok || err != nil {\n+\t\t\t\tt.Errorf(\"%s:output:\\ngot:\\n%s\\nwant:\\n%s\", tc.desc, got, want)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n func makeRegexp(s string) string {\n \ts = regexp.QuoteMeta(s)\n-\ts = strings.ReplaceAll(s, \":NNN:\", `:\\d\\d\\d:`)\n+\ts = strings.ReplaceAll(s, \":NNN:\", `:\\d\\d\\d\\d?:`)\n \ts = strings.ReplaceAll(s, \"N\\\\.NNs\", `\\d*\\.\\d*s`)\n \treturn s\n }"}, {"sha": "9f47eb8584fb8d82e9c4200f426d8a40e39dbd44", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 65, "deletions": 15, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5dfd4793febee6526e9ca84e06b5e207e0fbcee/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=d5dfd4793febee6526e9ca84e06b5e207e0fbcee", "patch": "@@ -320,6 +320,7 @@ var (\n \tcpuListStr           *string\n \tparallel             *int\n \ttestlog              *string\n+\tprinter              *testPrinter\n \n \thaveExamples bool // are there examples?\n \n@@ -329,6 +330,48 @@ var (\n \tnumFailed uint32 // number of test failures\n )\n \n+type testPrinter struct {\n+\tchatty bool\n+\n+\tlastNameMu sync.Mutex // guards lastName\n+\tlastName   string     // last printed test name in chatty mode\n+}\n+\n+func newTestPrinter(chatty bool) *testPrinter {\n+\treturn &testPrinter{\n+\t\tchatty: chatty,\n+\t}\n+}\n+\n+func (p *testPrinter) Print(testName, out string) {\n+\tp.Fprint(os.Stdout, testName, out)\n+}\n+\n+func (p *testPrinter) Fprint(w io.Writer, testName, out string) {\n+\tp.lastNameMu.Lock()\n+\tdefer p.lastNameMu.Unlock()\n+\n+\tif !p.chatty ||\n+\t\tstrings.HasPrefix(out, \"--- PASS\") ||\n+\t\tstrings.HasPrefix(out, \"--- FAIL\") ||\n+\t\tstrings.HasPrefix(out, \"=== CONT\") ||\n+\t\tstrings.HasPrefix(out, \"=== RUN\") {\n+\t\tp.lastName = testName\n+\t\tfmt.Fprint(w, out)\n+\t\treturn\n+\t}\n+\n+\tif p.lastName == \"\" {\n+\t\tp.lastName = testName\n+\t} else if p.lastName != testName {\n+\t\t// Always printed as-is, with 0 decoration or indentation. So, we skip\n+\t\t// printing to w.\n+\t\tfmt.Printf(\"=== CONT  %s\\n\", testName)\n+\t\tp.lastName = testName\n+\t}\n+\tfmt.Fprint(w, out)\n+}\n+\n // The maximum number of stack frames to go through when skipping helper functions for\n // the purpose of decorating log messages.\n const maxStackLen = 50\n@@ -347,10 +390,11 @@ type common struct {\n \tcleanup func()              // optional function to be called at the end of the test\n \n \tchatty     bool   // A copy of the chatty flag.\n+\tbench      bool   // Whether the current test is a benchmark.\n \tfinished   bool   // Test function has completed.\n-\thasSub     int32  // written atomically\n-\traceErrors int    // number of races detected during test\n-\trunner     string // function name of tRunner running the test\n+\thasSub     int32  // Written atomically.\n+\traceErrors int    // Number of races detected during test.\n+\trunner     string // Function name of tRunner running the test.\n \n \tparent   *common\n \tlevel    int       // Nesting depth of test or benchmark.\n@@ -480,9 +524,6 @@ func (c *common) decorate(s string, skip int) string {\n \tbuf := new(strings.Builder)\n \t// Every line is indented at least 4 spaces.\n \tbuf.WriteString(\"    \")\n-\tif c.chatty {\n-\t\tfmt.Fprintf(buf, \"%s: \", c.name)\n-\t}\n \tfmt.Fprintf(buf, \"%s:%d: \", file, line)\n \tlines := strings.Split(s, \"\\n\")\n \tif l := len(lines); l > 1 && lines[l-1] == \"\" {\n@@ -501,12 +542,12 @@ func (c *common) decorate(s string, skip int) string {\n \n // flushToParent writes c.output to the parent after first writing the header\n // with the given format and arguments.\n-func (c *common) flushToParent(format string, args ...interface{}) {\n+func (c *common) flushToParent(testName, format string, args ...interface{}) {\n \tp := c.parent\n \tp.mu.Lock()\n \tdefer p.mu.Unlock()\n \n-\tfmt.Fprintf(p.w, format, args...)\n+\tprinter.Fprint(p.w, testName, fmt.Sprintf(format, args...))\n \n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -680,7 +721,14 @@ func (c *common) logDepth(s string, depth int) {\n \t\tpanic(\"Log in goroutine after \" + c.name + \" has completed\")\n \t} else {\n \t\tif c.chatty {\n-\t\t\tfmt.Print(c.decorate(s, depth+1))\n+\t\t\tif c.bench {\n+\t\t\t\t// Benchmarks don't print === CONT, so we should skip the test\n+\t\t\t\t// printer and just print straight to stdout.\n+\t\t\t\tfmt.Print(c.decorate(s, depth+1))\n+\t\t\t} else {\n+\t\t\t\tprinter.Print(c.name, c.decorate(s, depth+1))\n+\t\t\t}\n+\n \t\t\treturn\n \t\t}\n \t\tc.output = append(c.output, c.decorate(s, depth+1)...)\n@@ -909,7 +957,7 @@ func (t *T) Parallel() {\n \t\tfor ; root.parent != nil; root = root.parent {\n \t\t}\n \t\troot.mu.Lock()\n-\t\tfmt.Fprintf(root.w, \"=== CONT  %s\\n\", t.name)\n+\t\tprinter.Fprint(root.w, t.name, fmt.Sprintf(\"=== CONT  %s\\n\", t.name))\n \t\troot.mu.Unlock()\n \t}\n \n@@ -968,7 +1016,7 @@ func tRunner(t *T, fn func(t *T)) {\n \t\t\t\troot.duration += time.Since(root.start)\n \t\t\t\td := root.duration\n \t\t\t\troot.mu.Unlock()\n-\t\t\t\troot.flushToParent(\"--- FAIL: %s (%s)\\n\", root.name, fmtDuration(d))\n+\t\t\t\troot.flushToParent(root.name, \"--- FAIL: %s (%s)\\n\", root.name, fmtDuration(d))\n \t\t\t\tif r := root.parent.runCleanup(recoverAndReturnPanic); r != nil {\n \t\t\t\t\tfmt.Fprintf(root.parent.w, \"cleanup panicked with %v\", r)\n \t\t\t\t}\n@@ -1067,7 +1115,7 @@ func (t *T) Run(name string, f func(t *T)) bool {\n \t\tfor ; root.parent != nil; root = root.parent {\n \t\t}\n \t\troot.mu.Lock()\n-\t\tfmt.Fprintf(root.w, \"=== RUN   %s\\n\", t.name)\n+\t\tprinter.Fprint(root.w, t.name, fmt.Sprintf(\"=== RUN   %s\\n\", t.name))\n \t\troot.mu.Unlock()\n \t}\n \t// Instead of reducing the running count of this test before calling the\n@@ -1215,6 +1263,8 @@ func (m *M) Run() int {\n \t\tflag.Parse()\n \t}\n \n+\tprinter = newTestPrinter(Verbose())\n+\n \tif *parallel < 1 {\n \t\tfmt.Fprintln(os.Stderr, \"testing: -parallel can only be given a positive integer\")\n \t\tflag.Usage()\n@@ -1254,12 +1304,12 @@ func (t *T) report() {\n \tdstr := fmtDuration(t.duration)\n \tformat := \"--- %s: %s (%s)\\n\"\n \tif t.Failed() {\n-\t\tt.flushToParent(format, \"FAIL\", t.name, dstr)\n+\t\tt.flushToParent(t.name, format, \"FAIL\", t.name, dstr)\n \t} else if t.chatty {\n \t\tif t.Skipped() {\n-\t\t\tt.flushToParent(format, \"SKIP\", t.name, dstr)\n+\t\t\tt.flushToParent(t.name, format, \"SKIP\", t.name, dstr)\n \t\t} else {\n-\t\t\tt.flushToParent(format, \"PASS\", t.name, dstr)\n+\t\t\tt.flushToParent(t.name, format, \"PASS\", t.name, dstr)\n \t\t}\n \t}\n }"}]}