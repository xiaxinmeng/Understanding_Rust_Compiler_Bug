{"sha": "e3f9a279f5694d662771553180f9fa8e85716e3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNmOWEyNzlmNTY5NGQ2NjI3NzE1NTMxODBmOWZhOGU4NTcxNmUzYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-02T08:52:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-02T08:52:42Z"}, "message": "Make tree-ssa-strlen.c handle partial unterminated strings\n\ntree-ssa-strlen.c looks for cases in which a string is built up using\noperations like:\n\n    memcpy (a, \"foo\", 4);\n    memcpy (a + 3, \"bar\", 4);\n    int x = strlen (a);\n\nAs a side-effect, it optimises the non-final memcpys so that they don't\ninclude the nul terminator.\n\nHowever, after removing some \"& ~0x1\"s from tree-ssa-dse.c, the DSE pass\ndoes this optimisation itself (because it can tell that later memcpys\noverwrite the terminators).  The strlen pass wasn't able to handle these\npre-optimised calls in the same way as the unoptimised ones.\n\nThis patch adds support for tracking unterminated strings.\n\n[Based on the code ARM contributed in branches/ARM/sve-branch@246236]\n\n2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-ssa-strlen.c (strinfo): Rename the length field to\n\tnonzero_chars.  Add a full_string_p field.\n\t(compare_nonzero_chars, zero_length_string_p): New functions.\n\t(get_addr_stridx): Add an offset_out parameter.\n\tUse compare_nonzero_chars.\n\t(get_stridx): Update accordingly.  Use compare_nonzero_chars.\n\t(new_strinfo): Update after above changes to strinfo.\n\t(set_endptr_and_length): Set full_string_p.\n\t(get_string_length): Update after above changes to strinfo.\n\t(unshare_strinfo): Update call to new_strinfo.\n\t(maybe_invalidate): Likewise.\n\t(get_stridx_plus_constant): Change off to unsigned HOST_WIDE_INT.\n\tUse compare_nonzero_chars and zero_string_p.  Treat nonzero_chars\n\tas a uhwi instead of an shwi.  Update after above changes to\n\tstrinfo and new_strinfo.\n\t(zero_length_string): Assert that chainsi contains full strings.\n\tUse zero_length_string_p.  Update call to new_strinfo.\n\t(adjust_related_strinfos): Update after above changes to strinfo.\n\tCopy full_string_p from origsi.\n\t(adjust_last_stmt): Use zero_length_string_p.\n\t(handle_builtin_strlen): Update after above changes to strinfo and\n\tnew_strinfo.  Install the lhs as the string length if the previous\n\tentry didn't describe a full string.\n\t(handle_builtin_strchr): Update after above changes to strinfo\n\tand new_strinfo.\n\t(handle_builtin_strcpy): Likewise.\n\t(handle_builtin_strcat): Likewise.\n\t(handle_builtin_malloc): Likewise.\n\t(handle_pointer_plus): Likewise.\n\t(handle_builtin_memcpy): Likewise.  Track nonzero characters\n\tthat aren't necessarily followed by a nul terminator.\n\t(handle_char_store): Likewise.\n\ngcc/testsuite/\n\t* gcc.dg/strlenopt-32.c: New testcase.\n\t* gcc.dg/strlenopt-33.c: Likewise.\n\t* gcc.dg/strlenopt-33g.c: Likewise.\n\t* gcc.dg/strlenopt-34.c: Likewise.\n\t* gcc.dg/strlenopt-35.c: Likewise.\n\nFrom-SVN: r249880", "tree": {"sha": "079e2f73722db5b22edac56d2ca41ca45acd7c3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/079e2f73722db5b22edac56d2ca41ca45acd7c3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3f9a279f5694d662771553180f9fa8e85716e3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f9a279f5694d662771553180f9fa8e85716e3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f9a279f5694d662771553180f9fa8e85716e3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f9a279f5694d662771553180f9fa8e85716e3a/comments", "author": null, "committer": null, "parents": [{"sha": "862088aa6349851465388eb0c691a79325c5eb7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862088aa6349851465388eb0c691a79325c5eb7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862088aa6349851465388eb0c691a79325c5eb7a"}], "stats": {"total": 911, "additions": 723, "deletions": 188}, "files": [{"sha": "f7c24de6f9daac74d8c75c2f4f90c299ba919b92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -1,3 +1,38 @@\n+2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-ssa-strlen.c (strinfo): Rename the length field to\n+\tnonzero_chars.  Add a full_string_p field.\n+\t(compare_nonzero_chars, zero_length_string_p): New functions.\n+\t(get_addr_stridx): Add an offset_out parameter.\n+\tUse compare_nonzero_chars.\n+\t(get_stridx): Update accordingly.  Use compare_nonzero_chars.\n+\t(new_strinfo): Update after above changes to strinfo.\n+\t(set_endptr_and_length): Set full_string_p.\n+\t(get_string_length): Update after above changes to strinfo.\n+\t(unshare_strinfo): Update call to new_strinfo.\n+\t(maybe_invalidate): Likewise.\n+\t(get_stridx_plus_constant): Change off to unsigned HOST_WIDE_INT.\n+\tUse compare_nonzero_chars and zero_string_p.  Treat nonzero_chars\n+\tas a uhwi instead of an shwi.  Update after above changes to\n+\tstrinfo and new_strinfo.\n+\t(zero_length_string): Assert that chainsi contains full strings.\n+\tUse zero_length_string_p.  Update call to new_strinfo.\n+\t(adjust_related_strinfos): Update after above changes to strinfo.\n+\tCopy full_string_p from origsi.\n+\t(adjust_last_stmt): Use zero_length_string_p.\n+\t(handle_builtin_strlen): Update after above changes to strinfo and\n+\tnew_strinfo.  Install the lhs as the string length if the previous\n+\tentry didn't describe a full string.\n+\t(handle_builtin_strchr): Update after above changes to strinfo\n+\tand new_strinfo.\n+\t(handle_builtin_strcpy): Likewise.\n+\t(handle_builtin_strcat): Likewise.\n+\t(handle_builtin_malloc): Likewise.\n+\t(handle_pointer_plus): Likewise.\n+\t(handle_builtin_memcpy): Likewise.  Track nonzero characters\n+\tthat aren't necessarily followed by a nul terminator.\n+\t(handle_char_store): Likewise.\n+\n 2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/80769"}, {"sha": "07b2c9dd42f106efe6d91ced38e7688f7113dbb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -1,3 +1,11 @@\n+2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/strlenopt-32.c: New testcase.\n+\t* gcc.dg/strlenopt-33.c: Likewise.\n+\t* gcc.dg/strlenopt-33g.c: Likewise.\n+\t* gcc.dg/strlenopt-34.c: Likewise.\n+\t* gcc.dg/strlenopt-35.c: Likewise.\n+\n 2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/80769"}, {"sha": "08eb6bc2b082f4048cd57e8633fb900c4ea8cc59", "filename": "gcc/testsuite/gcc.dg/strlenopt-32.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-32.c?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -0,0 +1,193 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+char temp[30];\n+volatile int v;\n+\n+size_t __attribute__ ((noinline, noclone))\n+f1 (void)\n+{\n+  char a[30];\n+  v += 1;\n+  memcpy (a, \"1234567\", 7);\n+  memcpy (a + 7, \"89abcdefg\", 9);\n+  memcpy (a + 16, \"h\", 2);\n+  return strlen (a);\t// This strlen should be optimized into 17.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f2 (char *a)\n+{\n+  v += 2;\n+  memcpy (a, \"1234567\", 7);\n+  memcpy (a + 7, \"89abcdefg\", 9);\n+  memcpy (a + 16, \"h\", 2);\n+  return strlen (a);\t// This strlen should be optimized into 17.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f3 (void)\n+{\n+  char a[30];\n+  v += 3;\n+  a[0] = '1';\n+  memcpy (a + 1, \"2345678\", 8);\n+  return strlen (a);\t// This strlen should be optimized into 8.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f4 (char *a)\n+{\n+  v += 4;\n+  a[0] = '1';\n+  memcpy (a + 1, \"2345678\", 8);\n+  return strlen (a);\t// This strlen should be optimized into 8.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f5 (void)\n+{\n+  char a[30];\n+  v += 5;\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  memcpy (a + 3, \"456\", 3);\n+  a[6] = '7';\n+  a[7] = 0;\n+  return strlen (a);\t// This strlen should be optimized into 7.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f6 (char *a)\n+{\n+  v += 6;\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  memcpy (a + 3, \"456\", 3);\n+  a[6] = '7';\n+  a[7] = 0;\n+  return strlen (a);\t// This strlen should be optimized into 7.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f7 (void)\n+{\n+  char a[30];\n+  v += 7;\n+  strcpy (a, \"abcde\");\n+  int len1 = strlen (a);\n+  a[2] = '_';\n+  int len2 = strlen (a);\n+  return len1 + len2;\t// This should be optimized into 10.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f8 (char *a)\n+{\n+  v += 8;\n+  strcpy (a, \"abcde\");\n+  int len1 = strlen (a);\n+  a[2] = '_';\n+  int len2 = strlen (a);\n+  return len1 + len2;\t// This should be optimized into 10.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f9 (char b)\n+{\n+  char a[30];\n+  v += 9;\n+  strcpy (a, \"foo.bar\");\n+  a[4] = b;\n+  a[3] = 0;\n+  return strlen (a);\t// This should be optimized into 3.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f10 (char *a, char b)\n+{\n+  v += 10;\n+  strcpy (a, \"foo.bar\");\n+  a[4] = b;\n+  a[3] = 0;\n+  return strlen (a);\t// This should be optimized into 3.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f11 (void)\n+{\n+  char a[30];\n+  v += 11;\n+  strcpy (temp, \"123456\");\n+  memcpy (a, temp, 7);\n+  return strlen (a);\t// This should be optimized into 6.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f12 (char *a)\n+{\n+  v += 12;\n+  strcpy (temp, \"123456\");\n+  memcpy (a, temp, 7);\n+  return strlen (a);\t// This should be optimized into 6.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f13 (void)\n+{\n+  char a[30];\n+  v += 13;\n+  strcpy (temp, \"1234567\");\n+  memcpy (a, temp, 7);\n+  a[7] = 0;\n+  return strlen (a);\t// This should be optimized into 7.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f14 (char *a)\n+{\n+  v += 14;\n+  strcpy (temp, \"1234567\");\n+  memcpy (a, temp, 7);\n+  a[7] = 0;\n+  return strlen (a);\t// This should be optimized into 7.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f15 (void)\n+{\n+  char a[30];\n+  v += 15;\n+  strcpy (temp, \"12345679\");\n+  memcpy (a, temp, 7);\n+  a[7] = 0;\n+  return strlen (a);\t// This should be optimized into 7.\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f16 (char *a)\n+{\n+  v += 16;\n+  strcpy (temp, \"123456789\");\n+  memcpy (a, temp, 7);\n+  a[7] = 0;\n+  return strlen (a);\t// This should be optimized into 7.\n+}\n+\n+int\n+main ()\n+{\n+  char a[30];\n+  if (f1 () != 17 || f2 (a) != 17 || f3 () != 8 || f4 (a) != 8\n+      || f5 () != 7 || f6 (a) != 7 || f7 () != 10 || f8 (a) != 10\n+      || f9 ('_') != 3 || f10 (a, '_') != 3 || f11 () != 6 || f12 (a) != 6\n+      || f13 () != 7 || f14 (a) != 7 || f15 () != 7 || f16 (a) != 7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */"}, {"sha": "1e1c4dee1f8fea1b7d2e15d3fa40069732a45fe1", "filename": "gcc/testsuite/gcc.dg/strlenopt-33.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33.c?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+volatile int v;\n+\n+size_t __attribute__ ((noinline, noclone))\n+f1 (char *b)\n+{\n+  char a[30];\n+  v += 1;\n+  strcpy (a, b);\n+  // This needs to stay.\n+  int len1 = strlen (a);\n+  a[0] = '_';\n+  a[1] = 0;\n+  return len1 + strlen (a);\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f2 (char *a, char *b)\n+{\n+  v += 2;\n+  strcpy (a, b);\n+  // This needs to stay.\n+  int len1 = strlen (a);\n+  a[0] = '_';\n+  a[1] = 0;\n+  return len1 + strlen (a);\n+}\n+\n+int\n+main ()\n+{\n+  char a[30];\n+  if (f1 (\"foo\") != 4 || f2 (a, \"foobar\") != 7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */"}, {"sha": "0223f82f1d172b42b17c75254e7485006e7addec", "filename": "gcc/testsuite/gcc.dg/strlenopt-33g.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-33g.c?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run { target *-*-linux* *-*-gnu* } } */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt.h\"\n+\n+volatile int v;\n+\n+size_t __attribute__ ((noinline, noclone))\n+f1 (char *b)\n+{\n+  char a[30];\n+  v += 1;\n+  // Should be converted to stpcpy.\n+  strcpy (a, b);\n+  int len1 = strlen (a);\n+  a[0] = '_';\n+  a[1] = 0;\n+  return len1 + strlen (a);\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f2 (char *a, char *b)\n+{\n+  v += 2;\n+  // Should be converted to stpcpy.\n+  strcpy (a, b);\n+  int len1 = strlen (a);\n+  a[0] = '_';\n+  a[1] = 0;\n+  return len1 + strlen (a);\n+}\n+\n+int\n+main ()\n+{\n+  char a[30];\n+  if (f1 (\"foo\") != 4 || f2 (a, \"foobar\") != 7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */"}, {"sha": "c9433c0399e01e194dc067a7aada9316f8c06f8d", "filename": "gcc/testsuite/gcc.dg/strlenopt-34.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-34.c?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+volatile int v;\n+\n+size_t __attribute__ ((noinline, noclone))\n+f1 (char b)\n+{\n+  char a[30];\n+  v += 1;\n+  strcpy (a, \"foo.bar\");\n+  a[3] = b;\n+  a[4] = 0;\n+  return strlen (a);\n+}\n+\n+size_t __attribute__ ((noinline, noclone))\n+f2 (char *a, char b)\n+{\n+  v += 2;\n+  strcpy (a, \"foo.bar\");\n+  a[3] = b;\n+  a[4] = 0;\n+  return strlen (a);\n+}\n+\n+int\n+main ()\n+{\n+  char a[30];\n+  if (f1 ('_') != 4 || f1 (0) != 3 || f2 (a, '_') != 4 || f2 (a, 0) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */"}, {"sha": "03b3e13a8e278c510f58b21cd61ef151bdf419b6", "filename": "gcc/testsuite/gcc.dg/strlenopt-35.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-35.c?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+volatile int v;\n+\n+size_t\n+f1 (char *a1)\n+{\n+  v += 1;\n+  size_t x = strlen (a1);\n+  char *a2 = a1 + x;\n+  a2[0] = '1';\n+  a2[1] = '2';\n+  a2[2] = '3';\n+  a2[3] = 0;\n+  return strlen (a1);\n+}\n+\n+int\n+main ()\n+{\n+  char a[30];\n+  strcpy (a, \"abcd\");\n+  if (f1 (a) != 7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */"}, {"sha": "51184602a3fea222e5fcdbe233291eaff5cfbc24", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 331, "deletions": 188, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f9a279f5694d662771553180f9fa8e85716e3a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=e3f9a279f5694d662771553180f9fa8e85716e3a", "patch": "@@ -57,8 +57,13 @@ static int max_stridx;\n /* String information record.  */\n struct strinfo\n {\n-  /* String length of this string.  */\n-  tree length;\n+  /* Number of leading characters that are known to be nonzero.  This is\n+     also the length of the string if FULL_STRING_P.\n+\n+     The values in a list of related string pointers must be consistent;\n+     that is, if strinfo B comes X bytes after strinfo A, it must be\n+     the case that A->nonzero_chars == X + B->nonzero_chars.  */\n+  tree nonzero_chars;\n   /* Any of the corresponding pointers for querying alias oracle.  */\n   tree ptr;\n   /* This is used for two things:\n@@ -105,6 +110,10 @@ struct strinfo\n   /* A flag for the next maybe_invalidate that this strinfo shouldn't\n      be invalidated.  Always cleared by maybe_invalidate.  */\n   bool dont_invalidate;\n+  /* True if the string is known to be nul-terminated after NONZERO_CHARS\n+     characters.  False is useful when detecting strings that are built\n+     up via successive memcpys.  */\n+  bool full_string_p;\n };\n \n /* Pool for allocating strinfo_struct entries.  */\n@@ -150,7 +159,34 @@ struct laststmt_struct\n   int stridx;\n } laststmt;\n \n-static int get_stridx_plus_constant (strinfo *, HOST_WIDE_INT, tree);\n+static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n+\n+/* Return:\n+\n+   - 1 if SI is known to start with more than OFF nonzero characters.\n+\n+   - 0 if SI is known to start with OFF nonzero characters,\n+     but is not known to start with more.\n+\n+   - -1 if SI might not start with OFF nonzero characters.  */\n+\n+static inline int\n+compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off)\n+{\n+  if (si->nonzero_chars\n+      && TREE_CODE (si->nonzero_chars) == INTEGER_CST)\n+    return compare_tree_int (si->nonzero_chars, off);\n+  else\n+    return -1;\n+}\n+\n+/* Return true if SI is known to be a zero-length string.  */\n+\n+static inline bool\n+zero_length_string_p (strinfo *si)\n+{\n+  return si->full_string_p && integer_zerop (si->nonzero_chars);\n+}\n \n /* Return strinfo vector entry IDX.  */\n \n@@ -175,10 +211,13 @@ get_next_strinfo (strinfo *si)\n   return nextsi;\n }\n \n-/* Helper function for get_stridx.  */\n+/* Helper function for get_stridx.  Return the strinfo index of the address\n+   of EXP, which is available in PTR if nonnull.  If OFFSET_OUT, it is\n+   OK to return the index for some X <= &EXP and store &EXP - X in\n+   *OFFSET_OUT.  */\n \n static int\n-get_addr_stridx (tree exp, tree ptr)\n+get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out)\n {\n   HOST_WIDE_INT off;\n   struct stridxlist *list, *last = NULL;\n@@ -198,22 +237,33 @@ get_addr_stridx (tree exp, tree ptr)\n   do\n     {\n       if (list->offset == off)\n-\treturn list->idx;\n+\t{\n+\t  if (offset_out)\n+\t    *offset_out = 0;\n+\t  return list->idx;\n+\t}\n       if (list->offset > off)\n \treturn 0;\n       last = list;\n       list = list->next;\n     }\n   while (list);\n \n-  if (ptr && last && last->idx > 0)\n+  if ((offset_out || ptr) && last && last->idx > 0)\n     {\n+      unsigned HOST_WIDE_INT rel_off\n+\t= (unsigned HOST_WIDE_INT) off - last->offset;\n       strinfo *si = get_strinfo (last->idx);\n-      if (si\n-\t  && si->length\n-\t  && TREE_CODE (si->length) == INTEGER_CST\n-\t  && compare_tree_int (si->length, off - last->offset) != -1)\n-\treturn get_stridx_plus_constant (si, off - last->offset, ptr);\n+      if (si && compare_nonzero_chars (si, rel_off) >= 0)\n+\t{\n+\t  if (offset_out)\n+\t    {\n+\t      *offset_out = rel_off;\n+\t      return last->idx;\n+\t    }\n+\t  else\n+\t    return get_stridx_plus_constant (si, rel_off, ptr);\n+\t}\n     }\n   return 0;\n }\n@@ -253,10 +303,7 @@ get_stridx (tree exp)\n \t    {\n \t      strinfo *si\n \t\t= get_strinfo (ssa_ver_to_stridx[SSA_NAME_VERSION (rhs1)]);\n-\t      if (si\n-\t\t  && si->length\n-\t\t  && TREE_CODE (si->length) == INTEGER_CST\n-\t\t  && compare_tree_int (si->length, off) != -1)\n+\t      if (si && compare_nonzero_chars (si, off) >= 0)\n \t\treturn get_stridx_plus_constant (si, off, exp);\n \t    }\n \t  e = rhs1;\n@@ -266,7 +313,7 @@ get_stridx (tree exp)\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n     {\n-      int idx = get_addr_stridx (TREE_OPERAND (exp, 0), exp);\n+      int idx = get_addr_stridx (TREE_OPERAND (exp, 0), exp, NULL);\n       if (idx != 0)\n \treturn idx;\n     }\n@@ -419,10 +466,10 @@ new_addr_stridx (tree exp)\n /* Create a new strinfo.  */\n \n static strinfo *\n-new_strinfo (tree ptr, int idx, tree length)\n+new_strinfo (tree ptr, int idx, tree nonzero_chars, bool full_string_p)\n {\n   strinfo *si = strinfo_pool.allocate ();\n-  si->length = length;\n+  si->nonzero_chars = nonzero_chars;\n   si->ptr = ptr;\n   si->stmt = NULL;\n   si->endptr = NULL_TREE;\n@@ -433,6 +480,7 @@ new_strinfo (tree ptr, int idx, tree length)\n   si->next = 0;\n   si->writable = false;\n   si->dont_invalidate = false;\n+  si->full_string_p = full_string_p;\n   return si;\n }\n \n@@ -492,17 +540,18 @@ set_endptr_and_length (location_t loc, strinfo *si, tree endptr)\n   si->stmt = NULL;\n   tree start_as_size = fold_convert_loc (loc, size_type_node, si->ptr);\n   tree end_as_size = fold_convert_loc (loc, size_type_node, endptr);\n-  si->length = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n-\t\t\t\tend_as_size, start_as_size);\n+  si->nonzero_chars = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n+\t\t\t\t       end_as_size, start_as_size);\n+  si->full_string_p = true;\n }\n \n /* Return string length, or NULL if it can't be computed.  */\n \n static tree\n get_string_length (strinfo *si)\n {\n-  if (si->length)\n-    return si->length;\n+  if (si->nonzero_chars)\n+    return si->full_string_p ? si->nonzero_chars : NULL;\n \n   if (si->stmt)\n     {\n@@ -595,19 +644,19 @@ get_string_length (strinfo *si)\n \t  for (strinfo *chainsi = verify_related_strinfos (si);\n \t       chainsi != NULL;\n \t       chainsi = get_next_strinfo (chainsi))\n-\t    if (chainsi->length == NULL)\n+\t    if (chainsi->nonzero_chars == NULL)\n \t      set_endptr_and_length (loc, chainsi, lhs);\n \t  break;\n \tcase BUILT_IN_MALLOC:\n \t  break;\n-\t/* BUILT_IN_CALLOC always has si->length set.  */\n+\t/* BUILT_IN_CALLOC always has si->nonzero_chars set.  */\n \tdefault:\n \t  gcc_unreachable ();\n \t  break;\n \t}\n     }\n \n-  return si->length;\n+  return si->nonzero_chars;\n }\n \n /* Invalidate string length information for strings whose length\n@@ -626,7 +675,7 @@ maybe_invalidate (gimple *stmt)\n \tif (!si->dont_invalidate)\n \t  {\n \t    ao_ref r;\n-\t    /* Do not use si->length.  */\n+\t    /* Do not use si->nonzero_chars.  */\n \t    ao_ref_init_from_ptr_and_size (&r, si->ptr, NULL_TREE);\n \t    if (stmt_may_clobber_ref_p_1 (stmt, &r))\n \t      {\n@@ -653,7 +702,7 @@ unshare_strinfo (strinfo *si)\n   if (si->refcount == 1 && !strinfo_shared ())\n     return si;\n \n-  nsi = new_strinfo (si->ptr, si->idx, si->length);\n+  nsi = new_strinfo (si->ptr, si->idx, si->nonzero_chars, si->full_string_p);\n   nsi->stmt = si->stmt;\n   nsi->endptr = si->endptr;\n   nsi->first = si->first;\n@@ -670,39 +719,39 @@ unshare_strinfo (strinfo *si)\n    been created.  */\n \n static int\n-get_stridx_plus_constant (strinfo *basesi, HOST_WIDE_INT off, tree ptr)\n+get_stridx_plus_constant (strinfo *basesi, unsigned HOST_WIDE_INT off,\n+\t\t\t  tree ptr)\n {\n   if (TREE_CODE (ptr) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr))\n     return 0;\n \n-  if (basesi->length == NULL_TREE\n-      || TREE_CODE (basesi->length) != INTEGER_CST\n-      || compare_tree_int (basesi->length, off) == -1\n-      || !tree_fits_shwi_p (basesi->length))\n+  if (compare_nonzero_chars (basesi, off) < 0\n+      || !tree_fits_uhwi_p (basesi->nonzero_chars))\n     return 0;\n \n-  HOST_WIDE_INT len = tree_to_shwi (basesi->length) - off;\n+  unsigned HOST_WIDE_INT nonzero_chars\n+    = tree_to_uhwi (basesi->nonzero_chars) - off;\n   strinfo *si = basesi, *chainsi;\n   if (si->first || si->prev || si->next)\n     si = verify_related_strinfos (basesi);\n   if (si == NULL\n-      || si->length == NULL_TREE\n-      || TREE_CODE (si->length) != INTEGER_CST)\n+      || si->nonzero_chars == NULL_TREE\n+      || TREE_CODE (si->nonzero_chars) != INTEGER_CST)\n     return 0;\n \n   if (TREE_CODE (ptr) == SSA_NAME\n       && ssa_ver_to_stridx.length () <= SSA_NAME_VERSION (ptr))\n     ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n \n-  gcc_checking_assert (compare_tree_int (si->length, off) != -1);\n+  gcc_checking_assert (compare_tree_int (si->nonzero_chars, off) != -1);\n   for (chainsi = si; chainsi->next; chainsi = si)\n     {\n       si = get_next_strinfo (chainsi);\n       if (si == NULL\n-\t  || si->length == NULL_TREE\n-\t  || TREE_CODE (si->length) != INTEGER_CST)\n+\t  || si->nonzero_chars == NULL_TREE\n+\t  || TREE_CODE (si->nonzero_chars) != INTEGER_CST)\n \tbreak;\n-      int r = compare_tree_int (si->length, len);\n+      int r = compare_tree_int (si->nonzero_chars, nonzero_chars);\n       if (r != 1)\n \t{\n \t  if (r == 0)\n@@ -724,7 +773,8 @@ get_stridx_plus_constant (strinfo *basesi, HOST_WIDE_INT off, tree ptr)\n   int idx = new_stridx (ptr);\n   if (idx == 0)\n     return 0;\n-  si = new_strinfo (ptr, idx, build_int_cst (size_type_node, len));\n+  si = new_strinfo (ptr, idx, build_int_cst (size_type_node, nonzero_chars),\n+\t\t    basesi->full_string_p);\n   set_strinfo (idx, si);\n   if (chainsi->next)\n     {\n@@ -736,7 +786,7 @@ get_stridx_plus_constant (strinfo *basesi, HOST_WIDE_INT off, tree ptr)\n   if (chainsi->first == 0)\n     chainsi->first = chainsi->idx;\n   chainsi->next = idx;\n-  if (chainsi->endptr == NULL_TREE && len == 0)\n+  if (chainsi->endptr == NULL_TREE && zero_length_string_p (si))\n     chainsi->endptr = ptr;\n   si->endptr = chainsi->endptr;\n   si->prev = chainsi->idx;\n@@ -769,7 +819,7 @@ zero_length_string (tree ptr, strinfo *chainsi)\n \t  do\n \t    {\n \t      /* We shouldn't mix delayed and non-delayed lengths.  */\n-\t      gcc_assert (si->length);\n+\t      gcc_assert (si->full_string_p);\n \t      if (si->endptr == NULL_TREE)\n \t\t{\n \t\t  si = unshare_strinfo (si);\n@@ -779,7 +829,7 @@ zero_length_string (tree ptr, strinfo *chainsi)\n \t      si = get_next_strinfo (si);\n \t    }\n \t  while (si != NULL);\n-\t  if (chainsi->length && integer_zerop (chainsi->length))\n+\t  if (zero_length_string_p (chainsi))\n \t    {\n \t      if (chainsi->next)\n \t\t{\n@@ -793,7 +843,7 @@ zero_length_string (tree ptr, strinfo *chainsi)\n       else\n \t{\n \t  /* We shouldn't mix delayed and non-delayed lengths.  */\n-\t  gcc_assert (chainsi->length);\n+\t  gcc_assert (chainsi->full_string_p);\n \t  if (chainsi->first || chainsi->prev || chainsi->next)\n \t    {\n \t      chainsi = unshare_strinfo (chainsi);\n@@ -806,7 +856,7 @@ zero_length_string (tree ptr, strinfo *chainsi)\n   idx = new_stridx (ptr);\n   if (idx == 0)\n     return NULL;\n-  si = new_strinfo (ptr, idx, build_int_cst (size_type_node, 0));\n+  si = new_strinfo (ptr, idx, build_int_cst (size_type_node, 0), true);\n   set_strinfo (idx, si);\n   si->endptr = ptr;\n   if (chainsi != NULL)\n@@ -824,9 +874,11 @@ zero_length_string (tree ptr, strinfo *chainsi)\n   return si;\n }\n \n-/* For strinfo ORIGSI whose length has been just updated\n-   update also related strinfo lengths (add ADJ to each,\n-   but don't adjust ORIGSI).  */\n+/* For strinfo ORIGSI whose length has been just updated, adjust other\n+   related strinfos so that they match the new ORIGSI.  This involves:\n+\n+   - adding ADJ to the nonzero_chars fields\n+   - copying full_string_p from the new ORIGSI.  */\n \n static void\n adjust_related_strinfos (location_t loc, strinfo *origsi, tree adj)\n@@ -848,10 +900,12 @@ adjust_related_strinfos (location_t loc, strinfo *origsi, tree adj)\n \t  /* We shouldn't see delayed lengths here; the caller must have\n \t     calculated the old length in order to calculate the\n \t     adjustment.  */\n-\t  gcc_assert (si->length);\n-\t  tem = fold_convert_loc (loc, TREE_TYPE (si->length), adj);\n-\t  si->length = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (si->length),\n-\t\t\t\t\tsi->length, tem);\n+\t  gcc_assert (si->nonzero_chars);\n+\t  tem = fold_convert_loc (loc, TREE_TYPE (si->nonzero_chars), adj);\n+\t  si->nonzero_chars = fold_build2_loc (loc, PLUS_EXPR,\n+\t\t\t\t\t       TREE_TYPE (si->nonzero_chars),\n+\t\t\t\t\t       si->nonzero_chars, tem);\n+\t  si->full_string_p = origsi->full_string_p;\n \n \t  si->endptr = NULL_TREE;\n \t  si->dont_invalidate = true;\n@@ -1020,11 +1074,8 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n \t}\n     }\n \n-  if (!is_strcat)\n-    {\n-      if (si->length == NULL_TREE || !integer_zerop (si->length))\n-\treturn;\n-    }\n+  if (!is_strcat && !zero_length_string_p (si))\n+    return;\n \n   if (is_gimple_assign (last.stmt))\n     {\n@@ -1138,12 +1189,13 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t    }\n \t  if (si != NULL\n-\t      && TREE_CODE (si->length) != SSA_NAME\n-\t      && TREE_CODE (si->length) != INTEGER_CST\n+\t      && TREE_CODE (si->nonzero_chars) != SSA_NAME\n+\t      && TREE_CODE (si->nonzero_chars) != INTEGER_CST\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n \t    {\n \t      si = unshare_strinfo (si);\n-\t      si->length = lhs;\n+\t      si->nonzero_chars = lhs;\n+\t      gcc_assert (si->full_string_p);\n \t    }\n \t  return;\n \t}\n@@ -1152,11 +1204,25 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n     return;\n   if (idx == 0)\n     idx = new_stridx (src);\n-  else if (get_strinfo (idx) != NULL)\n-    return;\n+  else\n+    {\n+      strinfo *si = get_strinfo (idx);\n+      if (si != NULL)\n+\t{\n+\t  if (!si->full_string_p && !si->stmt)\n+\t    {\n+\t      /* Until now we only had a lower bound on the string length.\n+\t\t Install LHS as the actual length.  */\n+\t      si = unshare_strinfo (si);\n+\t      si->nonzero_chars = lhs;\n+\t      si->full_string_p = true;\n+\t    }\n+\t  return;\n+\t}\n+    }\n   if (idx)\n     {\n-      strinfo *si = new_strinfo (src, idx, lhs);\n+      strinfo *si = new_strinfo (src, idx, lhs, true);\n       set_strinfo (idx, si);\n       find_equal_ptrs (src, idx);\n     }\n@@ -1260,7 +1326,7 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n \t  tree srcu = fold_convert_loc (loc, size_type_node, src);\n \t  tree length = fold_build2_loc (loc, MINUS_EXPR,\n \t\t\t\t\t size_type_node, lhsu, srcu);\n-\t  strinfo *si = new_strinfo (src, idx, length);\n+\t  strinfo *si = new_strinfo (src, idx, length, true);\n \t  si->endptr = lhs;\n \t  set_strinfo (idx, si);\n \t  find_equal_ptrs (src, idx);\n@@ -1349,9 +1415,10 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     }\n   if (olddsi != NULL)\n     {\n-      oldlen = olddsi->length;\n+      oldlen = olddsi->nonzero_chars;\n       dsi = unshare_strinfo (olddsi);\n-      dsi->length = srclen;\n+      dsi->nonzero_chars = srclen;\n+      dsi->full_string_p = (srclen != NULL_TREE);\n       /* Break the chain, so adjust_related_strinfo on later pointers in\n \t the chain won't adjust this one anymore.  */\n       dsi->next = 0;\n@@ -1360,14 +1427,14 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     }\n   else\n     {\n-      dsi = new_strinfo (dst, didx, srclen);\n+      dsi = new_strinfo (dst, didx, srclen, srclen != NULL_TREE);\n       set_strinfo (didx, dsi);\n       find_equal_ptrs (dst, didx);\n     }\n   dsi->writable = true;\n   dsi->dont_invalidate = true;\n \n-  if (dsi->length == NULL_TREE)\n+  if (dsi->nonzero_chars == NULL_TREE)\n     {\n       strinfo *chainsi;\n \n@@ -1388,7 +1455,8 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \t\t invalidated.  */\n \t      chainsi = unshare_strinfo (chainsi);\n \t      chainsi->stmt = stmt;\n-\t      chainsi->length = NULL_TREE;\n+\t      chainsi->nonzero_chars = NULL_TREE;\n+\t      chainsi->full_string_p = false;\n \t      chainsi->endptr = NULL_TREE;\n \t      chainsi->dont_invalidate = true;\n \t    }\n@@ -1556,31 +1624,61 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       && !integer_zerop (len))\n     adjust_last_stmt (olddsi, stmt, false);\n \n+  bool full_string_p;\n   if (idx > 0)\n     {\n       gimple *def_stmt;\n \n-      /* Handle memcpy (x, y, l) where l is strlen (y) + 1.  */\n+      /* Handle memcpy (x, y, l) where l's relationship with strlen (y)\n+\t is known.  */\n       si = get_strinfo (idx);\n-      if (si == NULL || si->length == NULL_TREE)\n-\treturn;\n-      if (TREE_CODE (len) != SSA_NAME)\n-\treturn;\n-      def_stmt = SSA_NAME_DEF_STMT (len);\n-      if (!is_gimple_assign (def_stmt)\n-\t  || gimple_assign_rhs_code (def_stmt) != PLUS_EXPR\n-\t  || gimple_assign_rhs1 (def_stmt) != si->length\n-\t  || !integer_onep (gimple_assign_rhs2 (def_stmt)))\n+      if (si == NULL || si->nonzero_chars == NULL_TREE)\n \treturn;\n+      if (TREE_CODE (len) == INTEGER_CST\n+\t  && TREE_CODE (si->nonzero_chars) == INTEGER_CST)\n+\t{\n+\t  if (tree_int_cst_le (len, si->nonzero_chars))\n+\t    {\n+\t      /* Copying LEN nonzero characters, where LEN is constant.  */\n+\t      newlen = len;\n+\t      full_string_p = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Copying the whole of the analyzed part of SI.  */\n+\t      newlen = si->nonzero_chars;\n+\t      full_string_p = si->full_string_p;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (!si->full_string_p)\n+\t    return;\n+\t  if (TREE_CODE (len) != SSA_NAME)\n+\t    return;\n+\t  def_stmt = SSA_NAME_DEF_STMT (len);\n+\t  if (!is_gimple_assign (def_stmt)\n+\t      || gimple_assign_rhs_code (def_stmt) != PLUS_EXPR\n+\t      || gimple_assign_rhs1 (def_stmt) != si->nonzero_chars\n+\t      || !integer_onep (gimple_assign_rhs2 (def_stmt)))\n+\t    return;\n+\t  /* Copying variable-length string SI (and no more).  */\n+\t  newlen = si->nonzero_chars;\n+\t  full_string_p = true;\n+\t}\n     }\n   else\n     {\n       si = NULL;\n       /* Handle memcpy (x, \"abcd\", 5) or\n \t memcpy (x, \"abc\\0uvw\", 7).  */\n-      if (!tree_fits_uhwi_p (len)\n-\t  || tree_to_uhwi (len) <= (unsigned HOST_WIDE_INT) ~idx)\n+      if (!tree_fits_uhwi_p (len))\n \treturn;\n+\n+      unsigned HOST_WIDE_INT clen = tree_to_uhwi (len);\n+      unsigned HOST_WIDE_INT nonzero_chars = ~idx;\n+      newlen = build_int_cst (size_type_node, MIN (nonzero_chars, clen));\n+      full_string_p = clen > nonzero_chars;\n     }\n \n   if (olddsi != NULL && TREE_CODE (len) == SSA_NAME)\n@@ -1592,16 +1690,13 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       if (didx == 0)\n \treturn;\n     }\n-  if (si != NULL)\n-    newlen = si->length;\n-  else\n-    newlen = build_int_cst (size_type_node, ~idx);\n   oldlen = NULL_TREE;\n   if (olddsi != NULL)\n     {\n       dsi = unshare_strinfo (olddsi);\n-      oldlen = olddsi->length;\n-      dsi->length = newlen;\n+      oldlen = olddsi->nonzero_chars;\n+      dsi->nonzero_chars = newlen;\n+      dsi->full_string_p = full_string_p;\n       /* Break the chain, so adjust_related_strinfo on later pointers in\n \t the chain won't adjust this one anymore.  */\n       dsi->next = 0;\n@@ -1610,7 +1705,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     }\n   else\n     {\n-      dsi = new_strinfo (dst, didx, newlen);\n+      dsi = new_strinfo (dst, didx, newlen, full_string_p);\n       set_strinfo (didx, dsi);\n       find_equal_ptrs (dst, didx);\n     }\n@@ -1623,12 +1718,11 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       if (oldlen == NULL_TREE)\n \t;\n       else if (integer_zerop (oldlen))\n-\tadj = dsi->length;\n+\tadj = newlen;\n       else if (TREE_CODE (oldlen) == INTEGER_CST\n-\t       || TREE_CODE (dsi->length) == INTEGER_CST)\n-\tadj = fold_build2_loc (loc, MINUS_EXPR,\n-\t\t\t       TREE_TYPE (dsi->length), dsi->length,\n-\t\t\t       fold_convert_loc (loc, TREE_TYPE (dsi->length),\n+\t       || TREE_CODE (newlen) == INTEGER_CST)\n+\tadj = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (newlen), newlen,\n+\t\t\t       fold_convert_loc (loc, TREE_TYPE (newlen),\n \t\t\t\t\t\t oldlen));\n       if (adj != NULL_TREE)\n \tadjust_related_strinfos (loc, dsi, adj);\n@@ -1640,27 +1734,30 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   if (si != NULL)\n     si->dont_invalidate = true;\n \n-  lhs = gimple_call_lhs (stmt);\n-  switch (bcode)\n+  if (full_string_p)\n     {\n-    case BUILT_IN_MEMCPY:\n-    case BUILT_IN_MEMCPY_CHK:\n-    case BUILT_IN_MEMCPY_CHKP:\n-    case BUILT_IN_MEMCPY_CHK_CHKP:\n-      /* Allow adjust_last_stmt to decrease this memcpy's size.  */\n-      laststmt.stmt = stmt;\n-      laststmt.len = dsi->length;\n-      laststmt.stridx = dsi->idx;\n-      if (lhs)\n-\tssa_ver_to_stridx[SSA_NAME_VERSION (lhs)] = didx;\n-      break;\n-    case BUILT_IN_MEMPCPY:\n-    case BUILT_IN_MEMPCPY_CHK:\n-    case BUILT_IN_MEMPCPY_CHKP:\n-    case BUILT_IN_MEMPCPY_CHK_CHKP:\n-      break;\n-    default:\n-      gcc_unreachable ();\n+      lhs = gimple_call_lhs (stmt);\n+      switch (bcode)\n+\t{\n+\tcase BUILT_IN_MEMCPY:\n+\tcase BUILT_IN_MEMCPY_CHK:\n+\tcase BUILT_IN_MEMCPY_CHKP:\n+\tcase BUILT_IN_MEMCPY_CHK_CHKP:\n+\t  /* Allow adjust_last_stmt to decrease this memcpy's size.  */\n+\t  laststmt.stmt = stmt;\n+\t  laststmt.len = dsi->nonzero_chars;\n+\t  laststmt.stridx = dsi->idx;\n+\t  if (lhs)\n+\t    ssa_ver_to_stridx[SSA_NAME_VERSION (lhs)] = didx;\n+\t  break;\n+\tcase BUILT_IN_MEMPCPY:\n+\tcase BUILT_IN_MEMPCPY_CHK:\n+\tcase BUILT_IN_MEMPCPY_CHKP:\n+\tcase BUILT_IN_MEMPCPY_CHK_CHKP:\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n }\n \n@@ -1709,14 +1806,15 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \t    }\n \t  if (dsi == NULL)\n \t    {\n-\t      dsi = new_strinfo (dst, didx, NULL_TREE);\n+\t      dsi = new_strinfo (dst, didx, NULL_TREE, false);\n \t      set_strinfo (didx, dsi);\n \t      find_equal_ptrs (dst, didx);\n \t    }\n \t  else\n \t    {\n \t      dsi = unshare_strinfo (dsi);\n-\t      dsi->length = NULL_TREE;\n+\t      dsi->nonzero_chars = NULL_TREE;\n+\t      dsi->full_string_p = false;\n \t      dsi->next = 0;\n \t      dsi->endptr = NULL_TREE;\n \t    }\n@@ -1740,7 +1838,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     }\n \n   loc = gimple_location (stmt);\n-  dstlen = dsi->length;\n+  dstlen = dsi->nonzero_chars;\n   endptr = dsi->endptr;\n \n   dsi = unshare_strinfo (dsi);\n@@ -1750,14 +1848,17 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n   if (srclen != NULL_TREE)\n     {\n-      dsi->length = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (dsi->length),\n-\t\t\t\t     dsi->length, srclen);\n+      dsi->nonzero_chars = fold_build2_loc (loc, PLUS_EXPR,\n+\t\t\t\t\t    TREE_TYPE (dsi->nonzero_chars),\n+\t\t\t\t\t    dsi->nonzero_chars, srclen);\n+      gcc_assert (dsi->full_string_p);\n       adjust_related_strinfos (loc, dsi, srclen);\n       dsi->dont_invalidate = true;\n     }\n   else\n     {\n-      dsi->length = NULL;\n+      dsi->nonzero_chars = NULL;\n+      dsi->full_string_p = false;\n       if (lhs == NULL_TREE && builtin_decl_implicit_p (BUILT_IN_STPCPY))\n \tdsi->dont_invalidate = true;\n     }\n@@ -1890,7 +1991,7 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   tree length = NULL_TREE;\n   if (bcode == BUILT_IN_CALLOC)\n     length = build_int_cst (size_type_node, 0);\n-  strinfo *si = new_strinfo (lhs, idx, length);\n+  strinfo *si = new_strinfo (lhs, idx, length, length != NULL_TREE);\n   if (bcode == BUILT_IN_CALLOC)\n     si->endptr = lhs;\n   set_strinfo (idx, si);\n@@ -1932,7 +2033,8 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n       gimple_stmt_iterator gsi1 = gsi_for_stmt (stmt1);\n       update_gimple_call (&gsi1, builtin_decl_implicit (BUILT_IN_CALLOC), 2,\n \t\t\t  size, build_one_cst (size_type_node));\n-      si1->length = build_int_cst (size_type_node, 0);\n+      si1->nonzero_chars = build_int_cst (size_type_node, 0);\n+      si1->full_string_p = true;\n       si1->stmt = gsi_stmt (gsi1);\n     }\n   else\n@@ -2064,18 +2166,20 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n     }\n \n   si = get_strinfo (idx);\n-  if (si == NULL || si->length == NULL_TREE)\n+  if (si == NULL || si->nonzero_chars == NULL_TREE)\n     return;\n \n   off = gimple_assign_rhs2 (stmt);\n   zsi = NULL;\n-  if (operand_equal_p (si->length, off, 0))\n+  if (si->full_string_p && operand_equal_p (si->nonzero_chars, off, 0))\n     zsi = zero_length_string (lhs, si);\n   else if (TREE_CODE (off) == SSA_NAME)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (off);\n       if (gimple_assign_single_p (def_stmt)\n-\t  && operand_equal_p (si->length, gimple_assign_rhs1 (def_stmt), 0))\n+\t  && si->full_string_p\n+\t  && operand_equal_p (si->nonzero_chars,\n+\t\t\t      gimple_assign_rhs1 (def_stmt), 0))\n \tzsi = zero_length_string (lhs, si);\n     }\n   if (zsi != NULL\n@@ -2101,63 +2205,63 @@ handle_char_store (gimple_stmt_iterator *gsi)\n   strinfo *si = NULL;\n   gimple *stmt = gsi_stmt (*gsi);\n   tree ssaname = NULL_TREE, lhs = gimple_assign_lhs (stmt);\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  unsigned HOST_WIDE_INT offset = 0;\n \n   if (TREE_CODE (lhs) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME)\n     {\n-      if (integer_zerop (TREE_OPERAND (lhs, 1)))\n+      tree mem_offset = TREE_OPERAND (lhs, 1);\n+      if (tree_fits_uhwi_p (mem_offset))\n \t{\n-\t  ssaname = TREE_OPERAND (lhs, 0);\n-\t  idx = get_stridx (ssaname);\n+\t  /* Get the strinfo for the base, and use it if it starts with at\n+\t     least OFFSET nonzero characters.  This is trivially true if\n+\t     OFFSET is zero.  */\n+\t  offset = tree_to_uhwi (mem_offset);\n+\t  idx = get_stridx (TREE_OPERAND (lhs, 0));\n+\t  if (idx > 0)\n+\t    si = get_strinfo (idx);\n+\t  if (offset == 0)\n+\t    ssaname = TREE_OPERAND (lhs, 0);\n+\t  else if (si == NULL || compare_nonzero_chars (si, offset) < 0)\n+\t    return true;\n \t}\n     }\n   else\n-    idx = get_addr_stridx (lhs, NULL_TREE);\n+    {\n+      idx = get_addr_stridx (lhs, NULL_TREE, &offset);\n+      if (idx > 0)\n+\tsi = get_strinfo (idx);\n+    }\n \n-  if (idx > 0)\n+  bool storing_zero_p = initializer_zerop (rhs);\n+  bool storing_nonzero_p = (!storing_zero_p\n+\t\t\t    && TREE_CODE (rhs) == INTEGER_CST\n+\t\t\t    && integer_nonzerop (rhs));\n+\n+  if (si != NULL)\n     {\n-      si = get_strinfo (idx);\n-      if (si != NULL && si->length != NULL_TREE && integer_zerop (si->length))\n+      int cmp = compare_nonzero_chars (si, offset);\n+      gcc_assert (offset == 0 || cmp >= 0);\n+      if (storing_zero_p && cmp == 0 && si->full_string_p)\n \t{\n-\t  if (initializer_zerop (gimple_assign_rhs1 (stmt)))\n+\t  /* When overwriting a '\\0' with a '\\0', the store can be removed\n+\t     if we know it has been stored in the current function.  */\n+\t  if (!stmt_could_throw_p (stmt) && si->writable)\n \t    {\n-\t      /* When storing '\\0', the store can be removed\n-\t\t if we know it has been stored in the current function.  */\n-\t      if (!stmt_could_throw_p (stmt) && si->writable)\n-\t\t{\n-\t\t  unlink_stmt_vdef (stmt);\n-\t\t  release_defs (stmt);\n-\t\t  gsi_remove (gsi, true);\n-\t\t  return false;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  si->writable = true;\n-\t\t  gsi_next (gsi);\n-\t\t  return false;\n-\t\t}\n+\t      unlink_stmt_vdef (stmt);\n+\t      release_defs (stmt);\n+\t      gsi_remove (gsi, true);\n+\t      return false;\n \t    }\n \t  else\n-\t    /* Otherwise this statement overwrites the '\\0' with\n-\t       something, if the previous stmt was a memcpy,\n-\t       its length may be decreased.  */\n-\t    adjust_last_stmt (si, stmt, false);\n-\t}\n-      else if (si != NULL && integer_zerop (gimple_assign_rhs1 (stmt)))\n-\t{\n-\t  si = unshare_strinfo (si);\n-\t  si->length = build_int_cst (size_type_node, 0);\n-\t  si->endptr = NULL;\n-\t  si->prev = 0;\n-\t  si->next = 0;\n-\t  si->stmt = NULL;\n-\t  si->first = 0;\n-\t  si->writable = true;\n-\t  if (ssaname && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n-\t    si->endptr = ssaname;\n-\t  si->dont_invalidate = true;\n+\t    {\n+\t      si->writable = true;\n+\t      gsi_next (gsi);\n+\t      return false;\n+\t    }\n \t}\n-      /* If si->length is non-zero constant, we aren't overwriting '\\0',\n+      /* If si->nonzero_chars > OFFSET, we aren't overwriting '\\0',\n \t and if we aren't storing '\\0', we know that the length of the\n \t string and any other zero terminated string in memory remains\n \t the same.  In that case we move to the next gimple statement and\n@@ -2177,35 +2281,74 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t   bar (len, len2, len3, len4);\n         }\n \t*/ \n-      else if (si != NULL && si->length != NULL_TREE\n-\t       && TREE_CODE (si->length) == INTEGER_CST\n-\t       && integer_nonzerop (gimple_assign_rhs1 (stmt)))\n+      else if (storing_nonzero_p && cmp > 0)\n \t{\n \t  gsi_next (gsi);\n \t  return false;\n \t}\n+      else if (storing_zero_p || storing_nonzero_p || (offset != 0 && cmp > 0))\n+\t{\n+\t  /* When storing_nonzero_p, we know that the string now starts\n+\t     with OFFSET + 1 nonzero characters, but don't know whether\n+\t     there's a following nul terminator.\n+\n+\t     When storing_zero_p, we know that the string is now OFFSET\n+\t     characters long.\n+\n+\t     Otherwise, we're storing an unknown value at offset OFFSET,\n+\t     so need to clip the nonzero_chars to OFFSET.  */\n+\t  location_t loc = gimple_location (stmt);\n+\t  tree oldlen = si->nonzero_chars;\n+\t  if (cmp == 0 && si->full_string_p)\n+\t    /* We're overwriting the nul terminator with a nonzero or\n+\t       unknown character.  If the previous stmt was a memcpy,\n+\t       its length may be decreased.  */\n+\t    adjust_last_stmt (si, stmt, false);\n+\t  si = unshare_strinfo (si);\n+\t  if (storing_nonzero_p)\n+\t    si->nonzero_chars = build_int_cst (size_type_node, offset + 1);\n+\t  else\n+\t    si->nonzero_chars = build_int_cst (size_type_node, offset);\n+\t  si->full_string_p = storing_zero_p;\n+\t  if (storing_zero_p\n+\t      && ssaname\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n+\t    si->endptr = ssaname;\n+\t  else\n+\t    si->endptr = NULL;\n+\t  si->next = 0;\n+\t  si->stmt = NULL;\n+\t  si->writable = true;\n+\t  si->dont_invalidate = true;\n+\t  if (oldlen)\n+\t    {\n+\t      tree adj = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n+\t\t\t\t\t  si->nonzero_chars, oldlen);\n+\t      adjust_related_strinfos (loc, si, adj);\n+\t    }\n+\t  else\n+\t    si->prev = 0;\n+\t}\n     }\n-  else if (idx == 0 && initializer_zerop (gimple_assign_rhs1 (stmt)))\n+  else if (idx == 0 && (storing_zero_p || storing_nonzero_p))\n     {\n       if (ssaname)\n-\t{\n-\t  si = zero_length_string (ssaname, NULL);\n-\t  if (si != NULL)\n-\t    si->dont_invalidate = true;\n-\t}\n+\tidx = new_stridx (ssaname);\n       else\n+\tidx = new_addr_stridx (lhs);\n+      if (idx != 0)\n \t{\n-\t  int idx = new_addr_stridx (lhs);\n-\t  if (idx != 0)\n-\t    {\n-\t      si = new_strinfo (build_fold_addr_expr (lhs), idx,\n-\t\t\t\tbuild_int_cst (size_type_node, 0));\n-\t      set_strinfo (idx, si);\n-\t      si->dont_invalidate = true;\n-\t    }\n+\t  tree ptr = (ssaname ? ssaname : build_fold_addr_expr (lhs));\n+\t  tree len = storing_nonzero_p ? size_one_node : size_zero_node;\n+\t  si = new_strinfo (ptr, idx, len, storing_zero_p);\n+\t  set_strinfo (idx, si);\n+\t  if (storing_zero_p\n+\t      && ssaname\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n+\t    si->endptr = ssaname;\n+\t  si->dont_invalidate = true;\n+\t  si->writable = true;\n \t}\n-      if (si != NULL)\n-\tsi->writable = true;\n     }\n   else if (idx == 0\n \t   && TREE_CODE (gimple_assign_rhs1 (stmt)) == STRING_CST\n@@ -2220,14 +2363,14 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t  if (idx != 0)\n \t    {\n \t      si = new_strinfo (build_fold_addr_expr (lhs), idx,\n-\t\t\t\tbuild_int_cst (size_type_node, l));\n+\t\t\t\tbuild_int_cst (size_type_node, l), true);\n \t      set_strinfo (idx, si);\n \t      si->dont_invalidate = true;\n \t    }\n \t}\n     }\n \n-  if (si != NULL && initializer_zerop (gimple_assign_rhs1 (stmt)))\n+  if (si != NULL && offset == 0 && storing_zero_p)\n     {\n       /* Allow adjust_last_stmt to remove it if the stored '\\0'\n \t is immediately overwritten.  */"}]}