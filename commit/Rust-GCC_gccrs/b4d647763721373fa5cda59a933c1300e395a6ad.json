{"sha": "b4d647763721373fa5cda59a933c1300e395a6ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRkNjQ3NzYzNzIxMzczZmE1Y2RhNTlhOTMzYzEzMDBlMzk1YTZhZA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-08-14T16:51:01Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-08-14T16:51:01Z"}, "message": "pointer.h: Add pragma system_header, use _GLIBCXX_USE_LONG_LONG, macro cleanup.\n\n2009-08-14  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/pointer.h: Add pragma system_header, use\n\t_GLIBCXX_USE_LONG_LONG, macro cleanup.\n\nFrom-SVN: r150762", "tree": {"sha": "b5cb746d3745cd20d474ad4a7c044459a50cf0de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5cb746d3745cd20d474ad4a7c044459a50cf0de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4d647763721373fa5cda59a933c1300e395a6ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d647763721373fa5cda59a933c1300e395a6ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d647763721373fa5cda59a933c1300e395a6ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d647763721373fa5cda59a933c1300e395a6ad/comments", "author": null, "committer": null, "parents": [{"sha": "2f440f6abab72e52aed64f86cd1af2ac8d4ece32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f440f6abab72e52aed64f86cd1af2ac8d4ece32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f440f6abab72e52aed64f86cd1af2ac8d4ece32"}], "stats": {"total": 128, "additions": 75, "deletions": 53}, "files": [{"sha": "27757d073326d30ee9d21949167080dbe3dd4aac", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d647763721373fa5cda59a933c1300e395a6ad/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d647763721373fa5cda59a933c1300e395a6ad/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b4d647763721373fa5cda59a933c1300e395a6ad", "patch": "@@ -1,7 +1,15 @@\n+<<<<<<< .mine\n+2009-08-14  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/pointer.h: Add pragma system_header, use\n+\t_GLIBCXX_USE_LONG_LONG, macro cleanup.\n+\n+=======\n 2009-08-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* src/compatibility-ldbl.cc: Include cmath.\n \n+>>>>>>> .r150760\n 2009-08-13  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* src/compatibility-ldbl.cc: Include tr1/functional."}, {"sha": "ddb5f3c84a8ccee08c858cd910451e3840242244", "filename": "libstdc++-v3/include/ext/pointer.h", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d647763721373fa5cda59a933c1300e395a6ad/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d647763721373fa5cda59a933c1300e395a6ad/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h?ref=b4d647763721373fa5cda59a933c1300e395a6ad", "patch": "@@ -34,6 +34,8 @@\n #ifndef _POINTER_H\n #define _POINTER_H 1\n \n+#pragma GCC system_header\n+\n #include <iosfwd>\n #include <bits/stl_iterator_base_types.h>\n #include <ext/cast.h>\n@@ -87,12 +89,12 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    *        the pointer's address as an offset value which is relative to\n    *        its own address.\n    * \n-   * This is intended for pointers\n-   * within shared memory regions which might be mapped at different\n-   * addresses by different processes.  For null pointers, a value of 1 is\n-   * used.  (0 is legitimate sometimes for nodes in circularly linked lists)\n-   * This value was chosen as the least likely to generate an incorrect null,\n-   * As there is no reason why any normal pointer would point 1 byte into\n+   * This is intended for pointers within shared memory regions which\n+   * might be mapped at different addresses by different processes.\n+   * For null pointers, a value of 1 is used.  (0 is legitimate\n+   * sometimes for nodes in circularly linked lists) This value was\n+   * chosen as the least likely to generate an incorrect null, As\n+   * there is no reason why any normal pointer would point 1 byte into\n    * its own pointer address.\n    */\n   template<typename _Tp> \n@@ -133,9 +135,13 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t== reinterpret_cast<_UIntPtrType>(__rarg.get())); }\n \n     private:\n+#ifdef _GLIBCXX_USE_LONG_LONG\n       typedef __gnu_cxx::__conditional_type<\n \t (sizeof(unsigned long) >= sizeof(void*)),\n \t unsigned long, unsigned long long>::__type _UIntPtrType;\n+#else\n+      typedef unsigned long _UIntPtrType;\n+#endif\n       _UIntPtrType _M_diff;\n     };\n   \n@@ -181,16 +187,20 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t== reinterpret_cast<_UIntPtrType>(__rarg.get())); }\n   \n     private:\n-      typedef __gnu_cxx::__conditional_type\n-\t<(sizeof(unsigned long) >= sizeof(void*)),\n+#ifdef _GLIBCXX_USE_LONG_LONG\n+      typedef __gnu_cxx::__conditional_type<\n+\t (sizeof(unsigned long) >= sizeof(void*)),\n \t unsigned long, unsigned long long>::__type _UIntPtrType;\n-      _UIntPtrType _M_diff;\n+#else\n+      typedef unsigned long _UIntPtrType;\n+#endif\n+       _UIntPtrType _M_diff;\n     };\n \n   /**\n    * The specialization on this type helps resolve the problem of\n-   * reference to void, and eliminates the need to specialize _Pointer_adapter\n-   * for cases of void*, const void*, and so on.\n+   * reference to void, and eliminates the need to specialize\n+   * _Pointer_adapter for cases of void*, const void*, and so on.\n    */\n   struct _Invalid_type { };\n   \n@@ -215,8 +225,9 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     { typedef const volatile _Invalid_type&  reference; };\n \n   /**\n-   * This structure accomodates the way in which std::iterator_traits<>\n-   * is normally specialized for const T*, so that value_type is still T.\n+   * This structure accomodates the way in which\n+   * std::iterator_traits<> is normally specialized for const T*, so\n+   * that value_type is still T.\n    */\n   template<typename _Tp> \n     struct _Unqualified_type \n@@ -235,28 +246,31 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     { typedef volatile _Tp type; };\n   \n   /**\n-   * The following provides an 'alternative pointer' that works with the\n-   * containers when specified as the pointer typedef of the allocator.\n+   * The following provides an 'alternative pointer' that works with\n+   * the containers when specified as the pointer typedef of the\n+   * allocator.\n    *\n-   * The pointer type used with the containers doesn't have to be this class,\n-   * but it must support the implicit conversions, pointer arithmetic,\n-   * comparison operators, etc. that are supported by this class, and avoid\n-   * raising compile-time ambiguities.  Because creating a working pointer can\n-   * be challenging, this pointer template was designed to wrapper an \n-   * easier storage policy type, so that it becomes reusable for creating\n-   * other pointer types. \n+   * The pointer type used with the containers doesn't have to be this\n+   * class, but it must support the implicit conversions, pointer\n+   * arithmetic, comparison operators, etc. that are supported by this\n+   * class, and avoid raising compile-time ambiguities.  Because\n+   * creating a working pointer can be challenging, this pointer\n+   * template was designed to wrapper an easier storage policy type,\n+   * so that it becomes reusable for creating other pointer types.\n    *\n-   * A key point of this class is also that it allows container writers to\n-   * 'assume' Alocator::pointer is a typedef for a normal pointer.  This class\n-   * supports most of the conventions of a true pointer, and can, for instance\n-   * handle implicit conversion to const and base class pointer types.  The\n-   * only impositions on container writers to support extended pointers are:\n-   * 1) use the Allocator::pointer typedef appropriately for pointer types.\n-   * 2) if you need pointer casting, use the __pointer_cast<> functions\n-   *    from ext/cast.h.  This allows pointer cast operations to be overloaded\n-   *    is necessary by custom pointers.\n+   * A key point of this class is also that it allows container\n+   * writers to 'assume' Alocator::pointer is a typedef for a normal\n+   * pointer.  This class supports most of the conventions of a true\n+   * pointer, and can, for instance handle implicit conversion to\n+   * const and base class pointer types.  The only impositions on\n+   * container writers to support extended pointers are: 1) use the\n+   * Allocator::pointer typedef appropriately for pointer types.  2)\n+   * if you need pointer casting, use the __pointer_cast<> functions\n+   * from ext/cast.h.  This allows pointer cast operations to be\n+   * overloaded is necessary by custom pointers.\n    *\n-   * Note:  The const qualifier works with this pointer adapter as follows:\n+   * Note: The const qualifier works with this pointer adapter as\n+   * follows:\n    *\n    * _Tp*             == _Pointer_adapter<_Std_pointer_impl<_Tp> >;\n    * const _Tp*       == _Pointer_adapter<_Std_pointer_impl<const _Tp> >;\n@@ -458,32 +472,32 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     }; // class _Pointer_adapter\n \n \n-#define _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(OPERATOR,BLANK) \\\n+#define _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(OPERATOR) \\\n   template<typename _Tp1, typename _Tp2> \\\n     inline bool \\\n-    operator OPERATOR##BLANK (const _Pointer_adapter<_Tp1>& __lhs, _Tp2 __rhs) \\\n-    { return __lhs.get() OPERATOR##BLANK __rhs; } \\\n+    operator OPERATOR(const _Pointer_adapter<_Tp1>& __lhs, _Tp2 __rhs) \\\n+    { return __lhs.get() OPERATOR __rhs; } \\\n \\\n   template<typename _Tp1, typename _Tp2> \\\n     inline bool \\\n-    operator OPERATOR##BLANK (_Tp1 __lhs, const _Pointer_adapter<_Tp2>& __rhs) \\\n-    { return __lhs OPERATOR##BLANK __rhs.get(); } \\\n+    operator OPERATOR(_Tp1 __lhs, const _Pointer_adapter<_Tp2>& __rhs) \\\n+    { return __lhs OPERATOR __rhs.get(); } \\\n \\\n   template<typename _Tp1, typename _Tp2> \\\n     inline bool \\\n-    operator OPERATOR##BLANK (const _Pointer_adapter<_Tp1>& __lhs, \\\n+    operator OPERATOR(const _Pointer_adapter<_Tp1>& __lhs, \\\n                               const _Pointer_adapter<_Tp2>& __rhs) \\\n-    { return __lhs.get() OPERATOR##BLANK __rhs.get(); } \\\n+    { return __lhs.get() OPERATOR __rhs.get(); } \\\n \\\n // End GCC_CXX_POINTER_COMPARISON_OPERATION_SET Macro\n   \n   // Expand into the various comparison operators needed.\n-  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(==,)\n-  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(!=,)\n-  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(<,)\n-  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(<=,)\n-  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>,)\n-  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>=,)\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(==)\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(!=)\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(<)\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(<=)\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>)\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>=)\n \n   // These are here for expressions like \"ptr == 0\", \"ptr != 0\"\n   template<typename _Tp>"}, {"sha": "bab32fa0049f81049cb34ad1241129f73b239b42", "filename": "libstdc++-v3/testsuite/ext/ext_pointer/1_neg.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d647763721373fa5cda59a933c1300e395a6ad/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fext_pointer%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d647763721373fa5cda59a933c1300e395a6ad/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fext_pointer%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fext_pointer%2F1_neg.cc?ref=b4d647763721373fa5cda59a933c1300e395a6ad", "patch": "@@ -91,13 +91,13 @@ void test01(void) {\n   aptr5 = __const_pointer_cast<B_pointer>(cbptr);  // ok\n }\n \n-// { dg-error \"invalid conversion \" \"\" { target *-*-* } 294 }\n-// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 294 }\n-// { dg-error \"invalid conversion \" \"\" { target *-*-* } 300 }\n-// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 300 }\n-// { dg-error \"invalid conversion \" \"\" { target *-*-* } 317 }\n-// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 317 }\n-// { dg-error \"invalid conversion \" \"\" { target *-*-* } 325 }\n-// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 325 }\n+// { dg-error \"invalid conversion \" \"\" { target *-*-* } 314 }\n+// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 314 }\n+// { dg-error \"invalid conversion \" \"\" { target *-*-* } 308 }\n+// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 308 }\n+// { dg-error \"invalid conversion \" \"\" { target *-*-* } 331 }\n+// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 331 }\n+// { dg-error \"invalid conversion \" \"\" { target *-*-* } 339 }\n+// { dg-error \"initializing argument 1 of\" \"\" { target *-*-* } 339 }\n // { dg-excess-errors \"In constructor\" }\n "}]}