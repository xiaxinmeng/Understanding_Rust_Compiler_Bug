{"sha": "b7bbb57472941fa0fd404dde046a1ed9f5c497f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdiYmI1NzQ3Mjk0MWZhMGZkNDA0ZGRlMDQ2YTFlZDlmNWM0OTdmMA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2004-01-26T00:20:07Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2004-01-26T00:20:07Z"}, "message": "c4x.c (c4x_valid_operands): More aggressively reject invalid operand combinations.\n\n\t* config/c4x/c4x.c (c4x_valid_operands): More aggressively reject\n\tinvalid operand combinations.\n\nFrom-SVN: r76607", "tree": {"sha": "0c8b7c14d872d59837183e2439eead3e1f7a972f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c8b7c14d872d59837183e2439eead3e1f7a972f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7bbb57472941fa0fd404dde046a1ed9f5c497f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7bbb57472941fa0fd404dde046a1ed9f5c497f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7bbb57472941fa0fd404dde046a1ed9f5c497f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7bbb57472941fa0fd404dde046a1ed9f5c497f0/comments", "author": null, "committer": null, "parents": [{"sha": "3a03ba747366916b1401a8b26a8fa28a4a97f56f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a03ba747366916b1401a8b26a8fa28a4a97f56f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a03ba747366916b1401a8b26a8fa28a4a97f56f"}], "stats": {"total": 119, "additions": 85, "deletions": 34}, "files": [{"sha": "9173a2ea794b60c1c412ce5fadfefea822e80351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7bbb57472941fa0fd404dde046a1ed9f5c497f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7bbb57472941fa0fd404dde046a1ed9f5c497f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7bbb57472941fa0fd404dde046a1ed9f5c497f0", "patch": "@@ -1,7 +1,13 @@\n+2004-01-26  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (c4x_valid_operands): More aggressively reject\n+\tinvalid operand combinations.\n+\n 2004-01-26  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (c4x_check_legit_addr): Rename to\n \tc4x_legitimate_address_p.  Fix post_modify check.\n+\n \t* config/c4x/c4x-protos.h (c4x_check_legit_addr): Adjust.\n \t* config/c4x/c4x.h (c4x_check_legit_addr): Adjust.\n \t"}, {"sha": "4537711da5a382b6f6ccad86f79f1baceb335114", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 79, "deletions": 34, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7bbb57472941fa0fd404dde046a1ed9f5c497f0/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7bbb57472941fa0fd404dde046a1ed9f5c497f0/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=b7bbb57472941fa0fd404dde046a1ed9f5c497f0", "patch": "@@ -3735,11 +3735,17 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n \t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    int force)\n {\n+  rtx op0;\n   rtx op1;\n   rtx op2;\n   enum rtx_code code1;\n   enum rtx_code code2;\n \n+\n+  /* FIXME, why can't we tighten the operands for IF_THEN_ELSE?  */\n+  if (code == IF_THEN_ELSE)\n+      return 1 || (operands[0] == operands[2] || operands[0] == operands[3]);\n+\n   if (code == COMPARE)\n     {\n       op1 = operands[0];\n@@ -3751,6 +3757,10 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n       op2 = operands[2];\n     }\n \n+  op0 = operands[0];\n+\n+  if (GET_CODE (op0) == SUBREG)\n+    op0 = SUBREG_REG (op0);\n   if (GET_CODE (op1) == SUBREG)\n     op1 = SUBREG_REG (op1);\n   if (GET_CODE (op2) == SUBREG)\n@@ -3759,6 +3769,7 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n   code1 = GET_CODE (op1);\n   code2 = GET_CODE (op2);\n \n+  \n   if (code1 == REG && code2 == REG)\n     return 1;\n \n@@ -3769,6 +3780,7 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n       return c4x_R_indirect (op1) && c4x_R_indirect (op2);\n     }\n \n+  /* We cannot handle two MEMs or two CONSTS, etc.  */\n   if (code1 == code2)\n     return 0;\n \n@@ -3788,6 +3800,7 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n \n \t  /* Any valid memory operand screened by src_operand is OK.  */\n   \tcase MEM:\n+\t  break;\n \t  \n \t  /* After CSE, any remaining (ADDRESSOF:P reg) gets converted\n \t     into a stack slot memory address comprising a PLUS and a\n@@ -3800,54 +3813,86 @@ c4x_valid_operands (enum rtx_code code, rtx *operands,\n \t  break;\n \t}\n       \n+      if (GET_CODE (op0) == SCRATCH)\n+\t  return 1;\n+\n+      if (!REG_P (op0))\n+\t  return 0;\n+\n       /* Check that we have a valid destination register for a two operand\n \t instruction.  */\n-      return ! force || code == COMPARE || REGNO (op1) == REGNO (operands[0]);\n+      return ! force || code == COMPARE || REGNO (op1) == REGNO (op0);\n     }\n \n-  /* We assume MINUS is commutative since the subtract patterns\n-     also support the reverse subtract instructions.  Since op1\n-     is not a register, and op2 is a register, op1 can only\n-     be a restricted memory operand for a shift instruction.  */\n+\n+  /* Check non-commutative operators.  */\n   if (code == ASHIFTRT || code == LSHIFTRT\n       || code == ASHIFT || code == COMPARE)\n     return code2 == REG\n       && (c4x_S_indirect (op1) || c4x_R_indirect (op1));\n-  \n-  switch (code1)\n+\n+\n+  /* Assume MINUS is commutative since the subtract patterns\n+     also support the reverse subtract instructions.  Since op1\n+     is not a register, and op2 is a register, op1 can only\n+     be a restricted memory operand for a shift instruction.  */\n+  if (code2 == REG)\n     {\n-    case CONST_INT:\n-      if (c4x_J_constant (op1) && c4x_R_indirect (op2))\n-\treturn 1;\n-      break;\n+      switch (code1)\n+\t{\n+\tcase CONST_INT:\n+\t  break;\n       \n-    case CONST_DOUBLE:\n-      if (! c4x_H_constant (op1))\n-\treturn 0;\n-      break;\n+\tcase CONST_DOUBLE:\n+\t  if (! c4x_H_constant (op1))\n+\t    return 0;\n+\t  break;\n \n-      /* Any valid memory operand screened by src_operand is OK.  */      \n-    case MEM:\n-#if 0\n-      if (code2 != REG)\n-\treturn 0;\n-#endif\n-      break;\n+\t  /* Any valid memory operand screened by src_operand is OK.  */      \n+\tcase MEM:\n+\t  break;\n+\t  \n+\t  /* After CSE, any remaining (ADDRESSOF:P reg) gets converted\n+\t     into a stack slot memory address comprising a PLUS and a\n+\t     constant.  */\n+\tcase ADDRESSOF:\n+\t  break;\n+\t  \n+\tdefault:\n+\t  abort ();\n+\t  break;\n+\t}\n \n-      /* After CSE, any remaining (ADDRESSOF:P reg) gets converted\n-\t into a stack slot memory address comprising a PLUS and a\n-\t constant.  */\n-    case ADDRESSOF:\n-      break;\n-      \n-    default:\n-      abort ();\n-      break;\n+      if (GET_CODE (op0) == SCRATCH)\n+\t  return 1;\n+\n+      if (!REG_P (op0))\n+\t  return 0;\n+\n+      /* Check that we have a valid destination register for a two operand\n+\t instruction.  */\n+      return ! force || REGNO (op1) == REGNO (op0);\n     }\n       \n-  /* Check that we have a valid destination register for a two operand\n-     instruction.  */\n-  return ! force || REGNO (op1) == REGNO (operands[0]);\n+  if (c4x_J_constant (op1) && c4x_R_indirect (op2))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+\n+int valid_operands (enum rtx_code code, rtx *operands, enum machine_mode mode)\n+{\n+\n+  /* If we are not optimizing then we have to let anything go and let\n+     reload fix things up.  instantiate_decl in function.c can produce\n+     invalid insns by changing the offset of a memory operand from a\n+     valid one into an invalid one, when the second operand is also a\n+     memory operand.  The alternative is not to allow two memory\n+     operands for an insn when not optimizing.  The problem only rarely\n+     occurs, for example with the C-torture program DFcmp.c.  */\n+\n+  return ! optimize || c4x_valid_operands (code, operands, mode, 0);\n }\n \n "}]}