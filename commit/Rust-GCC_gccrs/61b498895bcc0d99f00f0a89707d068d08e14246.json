{"sha": "61b498895bcc0d99f00f0a89707d068d08e14246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFiNDk4ODk1YmNjMGQ5OWYwMGYwYTg5NzA3ZDA2OGQwOGUxNDI0Ng==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-02T09:13:10Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-02T09:13:10Z"}, "message": "Merge with upstream", "tree": {"sha": "86a866a4467c6612ad1b8b68e6395f20aeb2daf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86a866a4467c6612ad1b8b68e6395f20aeb2daf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61b498895bcc0d99f00f0a89707d068d08e14246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b498895bcc0d99f00f0a89707d068d08e14246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b498895bcc0d99f00f0a89707d068d08e14246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b498895bcc0d99f00f0a89707d068d08e14246/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0c8ca2156038b726e2689e9b46be4d8c40c55f"}, {"sha": "e0e49f434423def63312084b04ea0e60e7787e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e49f434423def63312084b04ea0e60e7787e27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0e49f434423def63312084b04ea0e60e7787e27"}], "stats": {"total": 5016, "additions": 3975, "deletions": 1041}, "files": [{"sha": "e0c8fe70dabc6e19b97ddd598c09f81a8d2e2d0f", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/README.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/README.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/README.md?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -5,6 +5,8 @@\n # GCC Rust\n ![GCC Rust](logo.png?raw=true \"GCC rust Logo\")\n \n+Please note, the compiler is in a very early stage and not usable yet for compiling real rust programs.\n+\n gccrs is a full alternative implementation of the Rust language ontop of GCC with the goal\n to become fully upstream with the GNU toolchain.\n \n@@ -14,6 +16,10 @@ Now that the language is stable, it is an excellent time to create alternative c\n the project are keen \u201cRustaceans\u201d with a desire to give back to the Rust community and to learn what GCC is capable\n of when it comes to a modern language.\n \n+## FAQ\n+\n+Please find the answers to frequently asked questions over on: https://github.com/Rust-GCC/gccrs/wiki/Frequently-Asked-Questions\n+\n ## Development Environment\n \n Fetch dependencies for Ubuntu:"}, {"sha": "ddeb176cd506ca0065822d1c8ed65598c62b33fe", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -880,6 +880,8 @@ class Expr\n \n   virtual NodeId get_node_id () const { return node_id; }\n \n+  virtual void set_node_id (NodeId id) { node_id = id; }\n+\n protected:\n   // Constructor\n   Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ())"}, {"sha": "b9a6c881231b967c44d549fd7dbe7e4827d38900", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -1373,6 +1373,8 @@ class TupleExpr : public ExprWithoutBlock\n     return tuple_elems;\n   }\n \n+  bool is_unit () const { return tuple_elems.size () == 0; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1642,6 +1644,8 @@ class StructExprFieldIdentifier : public StructExprField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Identifier get_field_name () const { return field_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "6de37f6e34db2db239564fadd6e1c0591c4ee907", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -1819,13 +1819,14 @@ struct StructField\n \t       Visibility vis,\n \t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_name (std::move (field_name)), field_type (std::move (field_type))\n+      field_name (std::move (field_name)), field_type (std::move (field_type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor\n   StructField (StructField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_name (other.field_name)\n+      field_name (other.field_name), node_id (other.node_id)\n   {\n     // guard to prevent null dereference\n     if (other.field_type != nullptr)\n@@ -1840,6 +1841,7 @@ struct StructField\n     field_name = other.field_name;\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference\n     if (other.field_type != nullptr)\n@@ -1961,6 +1963,7 @@ struct TupleField\n   std::unique_ptr<Type> field_type;\n \n   // should this store location info?\n+  NodeId node_id;\n \n public:\n   // Returns whether tuple field has outer attributes.\n@@ -1974,12 +1977,14 @@ struct TupleField\n   TupleField (std::unique_ptr<Type> field_type, Visibility vis,\n \t      std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_type (std::move (field_type))\n+      field_type (std::move (field_type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor with clone\n   TupleField (TupleField const &other)\n-    : outer_attrs (other.outer_attrs), visibility (other.visibility)\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n+      node_id (other.node_id)\n   {\n     // guard to prevent null dereference (only required if error)\n     if (other.field_type != nullptr)\n@@ -1993,6 +1998,7 @@ struct TupleField\n   {\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference (only required if error)\n     if (other.field_type != nullptr)\n@@ -2018,6 +2024,8 @@ struct TupleField\n \n   std::string as_string () const;\n \n+  NodeId get_node_id () const { return node_id; };\n+\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n@@ -2055,6 +2063,15 @@ class TupleStruct : public Struct\n   std::vector<TupleField> &get_fields () { return fields; }\n   const std::vector<TupleField> &get_fields () const { return fields; }\n \n+  void iterate (std::function<bool (TupleField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "a9e0f0f0b21341c8ce9078fbc3db47b7ac91a369", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -816,6 +816,10 @@ struct MaybeNamedParam\n     rust_assert (param_type != nullptr);\n     return param_type;\n   }\n+\n+  ParamKind get_param_kind () const { return param_kind; }\n+\n+  Identifier get_name () const { return name; }\n };\n \n /* A function pointer type - can be created via coercion from function items and"}, {"sha": "034568fc62613a7523f776690ea44a97e21c5a8a", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 117, "deletions": 13, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-backend.h\"\n #include \"rust-compile-tyty.h\"\n #include \"rust-ast-full.h\"\n+#include \"rust-hir-full.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -223,22 +224,109 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n \n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-\n   void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n \n-  void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n-\n   void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n \n-  void visit (TyTy::ParamType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::FnType &type) override\n+  {\n+    Backend::Btyped_identifier receiver;\n+    std::vector<Backend::Btyped_identifier> parameters;\n+    std::vector<Backend::Btyped_identifier> results;\n+\n+    if (!type.get_return_type ()->is_unit ())\n+      {\n+\tauto hir_type = type.get_return_type ();\n+\tauto ret = TyTyResolveCompile::compile (ctx, hir_type);\n+\tresults.push_back (Backend::Btyped_identifier (\n+\t  \"_\", ret,\n+\t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n+      }\n+\n+    for (auto &param_pair : type.get_params ())\n+      {\n+\tauto param_tyty = param_pair.second;\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+\tauto compiled_param = Backend::Btyped_identifier (\n+\t  param_pair.first->as_string (), compiled_param_type,\n+\t  ctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n+\n+\tparameters.push_back (compiled_param);\n+      }\n+\n+    translated = ctx->get_backend ()->function_type (\n+      receiver, parameters, results, NULL,\n+      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+  }\n+\n+  void visit (TyTy::UnitType &type) override\n+  {\n+    translated = ctx->get_backend ()->void_type ();\n+  }\n \n   void visit (TyTy::ADTType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated);\n+    if (ok)\n+      return;\n+\n+    // create implicit struct\n+    std::vector<Backend::Btyped_identifier> fields;\n+    for (size_t i = 0; i < type.num_fields (); i++)\n+      {\n+\tTyTy::StructFieldType *field = type.get_field (i);\n+\tBtype *compiled_field_ty\n+\t  = TyTyCompile::compile (ctx->get_backend (),\n+\t\t\t\t  field->get_field_type ());\n+\n+\tBackend::Btyped_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t      ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\ttype.get_ty_ref ()));\n+\tfields.push_back (std::move (f));\n+      }\n+\n+    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (type.get_name (), struct_type_record,\n+\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t   type.get_ty_ref ()));\n+\n+    ctx->push_type (named_struct);\n+    ctx->insert_compiled_type (type.get_ty_ref (), named_struct);\n+    translated = named_struct;\n+  }\n+\n+  void visit (TyTy::TupleType &type) override\n+  {\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated);\n+    if (ok)\n+      return;\n+\n+    // create implicit struct\n+    std::vector<Backend::Btyped_identifier> fields;\n+    for (size_t i = 0; i < type.num_fields (); i++)\n+      {\n+\tTyTy::TyBase *field = type.get_field (i);\n+\tBtype *compiled_field_ty\n+\t  = TyTyCompile::compile (ctx->get_backend (), field);\n+\n+\tBackend::Btyped_identifier f (std::to_string (i), compiled_field_ty,\n+\t\t\t\t      ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\ttype.get_ty_ref ()));\n+\tfields.push_back (std::move (f));\n+      }\n+\n+    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n+\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t   type.get_ty_ref ()));\n+\n+    ctx->push_type (named_struct);\n+    ctx->insert_compiled_type (type.get_ty_ref (), named_struct);\n+    translated = named_struct;\n   }\n \n   void visit (TyTy::ArrayType &type) override\n@@ -257,31 +345,47 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n   void visit (TyTy::BoolType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (TyTy::IntType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (TyTy::UintType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (TyTy::FloatType &type) override\n   {\n     ::Btype *compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+  void visit (TyTy::USizeType &type) override\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+  void visit (TyTy::ISizeType &type) override\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }"}, {"sha": "81d778668fd86b3efa3eff79edbab1f30e59fcd4", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 116, "deletions": 36, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -38,7 +38,49 @@ class CompileExpr : public HIRCompileBase\n     return compiler.translated;\n   }\n \n-  virtual ~CompileExpr () {}\n+  void visit (HIR::TupleIndexExpr &expr)\n+  {\n+    HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n+    TupleIndex index = expr.get_tuple_index ();\n+\n+    Bexpression *receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+    translated\n+      = ctx->get_backend ()->struct_field_expression (receiver_ref, index,\n+\t\t\t\t\t\t      expr.get_locus ());\n+  }\n+\n+  void visit (HIR::TupleExpr &expr)\n+  {\n+    if (expr.is_unit ())\n+      {\n+\ttranslated = ctx->get_backend ()->unit_expression ();\n+\treturn;\n+      }\n+\n+    TyTy::TyBase *tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &tyty))\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"did not resolve type for this TupleExpr\");\n+\treturn;\n+      }\n+\n+    Btype *tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n+    rust_assert (tuple_type != nullptr);\n+\n+    // this assumes all fields are in order from type resolution\n+    std::vector<Bexpression *> vals;\n+    for (auto &elem : expr.get_tuple_elems ())\n+      {\n+\tauto e = CompileExpr::Compile (elem.get (), ctx);\n+\tvals.push_back (e);\n+      }\n+\n+    translated\n+      = ctx->get_backend ()->constructor_expression (tuple_type, vals,\n+\t\t\t\t\t\t     expr.get_locus ());\n+  }\n \n   void visit (HIR::ReturnExpr &expr)\n   {\n@@ -55,24 +97,7 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (s);\n   }\n \n-  void visit (HIR::CallExpr &expr)\n-  {\n-    Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n-    rust_assert (fn != nullptr);\n-\n-    std::vector<Bexpression *> args;\n-    expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-      Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-      rust_assert (compiled_expr != nullptr);\n-      args.push_back (compiled_expr);\n-      return true;\n-    });\n-\n-    auto fncontext = ctx->peek_fn ();\n-    translated\n-      = ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n-\t\t\t\t\t      nullptr, expr.get_locus ());\n-  }\n+  void visit (HIR::CallExpr &expr);\n \n   void visit (HIR::IdentifierExpr &expr)\n   {\n@@ -85,10 +110,6 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    printf (\"have ast node id %u ref %u for expr [%s]\\n\",\n-\t    expr.get_mappings ().get_nodeid (), ref_node_id,\n-\t    expr.as_string ().c_str ());\n-\n     // these ref_node_ids will resolve to a pattern declaration but we are\n     // interested in the definition that this refers to get the parent id\n     Resolver::Definition def;\n@@ -106,35 +127,45 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    // this could be a constant reference\n-    if (ctx->lookup_const_decl (ref, &translated))\n-      return;\n-\n-    // must be an identifier\n+    Bfunction *fn = nullptr;\n     Bvariable *var = nullptr;\n-    if (!ctx->lookup_var_decl (ref, &var))\n+    if (ctx->lookup_const_decl (ref, &translated))\n       {\n-\trust_fatal_error (expr.get_locus (),\n-\t\t\t  \"failed to lookup compiled variable\");\n \treturn;\n       }\n-\n-    translated = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+    else if (ctx->lookup_function_decl (ref, &fn))\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->function_code_expression (fn,\n+\t\t\t\t\t\t\t   expr.get_locus ());\n+      }\n+    else if (ctx->lookup_var_decl (ref, &var))\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+      }\n+    else\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"failed to lookup compiled reference\");\n+      }\n   }\n \n   void visit (HIR::LiteralExpr &expr)\n   {\n+    auto literal_value = expr.get_literal ();\n     switch (expr.get_lit_type ())\n       {\n \tcase HIR::Literal::BOOL: {\n-\t  bool bval = expr.as_string ().compare (\"true\") == 0;\n+\t  bool bval = literal_value->as_string ().compare (\"true\") == 0;\n \t  translated = ctx->get_backend ()->boolean_constant_expression (bval);\n \t}\n \treturn;\n \n \tcase HIR::Literal::INT: {\n \t  mpz_t ival;\n-\t  if (mpz_init_set_str (ival, expr.as_string ().c_str (), 10) != 0)\n+\t  if (mpz_init_set_str (ival, literal_value->as_string ().c_str (), 10)\n+\t      != 0)\n \t    {\n \t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n \t      return;\n@@ -157,7 +188,7 @@ class CompileExpr : public HIRCompileBase\n \n \tcase HIR::Literal::FLOAT: {\n \t  mpfr_t fval;\n-\t  if (mpfr_init_set_str (fval, expr.as_string ().c_str (), 10,\n+\t  if (mpfr_init_set_str (fval, literal_value->as_string ().c_str (), 10,\n \t\t\t\t MPFR_RNDN)\n \t      != 0)\n \t    {\n@@ -357,6 +388,25 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t\t expr.get_locus ());\n   }\n \n+  void visit (HIR::NegationExpr &expr)\n+  {\n+    Operator op (OPERATOR_INVALID);\n+    switch (expr.get_negation_type ())\n+      {\n+      case HIR::NegationExpr::NegationType::NEGATE:\n+\top = OPERATOR_MINUS;\n+\tbreak;\n+\n+      case HIR::NegationExpr::NegationType::NOT:\n+\top = OPERATOR_NOT;\n+\tbreak;\n+      }\n+\n+    Bexpression *negated_expr = CompileExpr::Compile (expr.get_expr (), ctx);\n+    translated = ctx->get_backend ()->unary_expression (op, negated_expr,\n+\t\t\t\t\t\t\texpr.get_locus ());\n+  }\n+\n   void visit (HIR::IfExpr &expr)\n   {\n     auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n@@ -401,6 +451,36 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t     struct_expr.get_locus ());\n   }\n \n+  void visit (HIR::GroupedExpr &expr)\n+  {\n+    translated = CompileExpr::Compile (expr.get_expr_in_parens ().get (), ctx);\n+  }\n+\n+  void visit (HIR::FieldAccessExpr &expr)\n+  {\n+    // resolve the receiver back to ADT type\n+    TyTy::TyBase *receiver = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  expr.get_receiver_expr ()->get_mappings ().get_hirid (), &receiver))\n+      {\n+\trust_error_at (expr.get_receiver_expr ()->get_locus_slow (),\n+\t\t       \"unresolved type for receiver\");\n+\treturn;\n+      }\n+    rust_assert (receiver->get_kind () == TyTy::TypeKind::ADT);\n+\n+    TyTy::ADTType *adt = (TyTy::ADTType *) receiver;\n+    size_t index = 0;\n+    adt->get_field (expr.get_field_name (), &index);\n+\n+    Bexpression *struct_ref\n+      = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n+\n+    translated\n+      = ctx->get_backend ()->struct_field_expression (struct_ref, index,\n+\t\t\t\t\t\t      expr.get_locus ());\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n "}, {"sha": "cf6e6f7f909f264baa9f6461201d5dd739a43618", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_FNPARAM\n+#define RUST_COMPILE_FNPARAM\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileFnParam : public HIRCompileBase\n+{\n+public:\n+  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n+\t\t\t     HIR::FunctionParam *param, Btype *decl_type,\n+\t\t\t     Location locus)\n+  {\n+    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+    param->get_param_name ()->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  void visit (HIR::IdentifierPattern &pattern)\n+  {\n+    if (!pattern.is_mut)\n+      decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+    translated\n+      = ctx->get_backend ()->parameter_variable (fndecl, pattern.variable_ident,\n+\t\t\t\t\t\t decl_type,\n+\t\t\t\t\t\t false /* address_taken */,\n+\t\t\t\t\t\t locus);\n+  }\n+\n+private:\n+  CompileFnParam (Context *ctx, ::Bfunction *fndecl, ::Btype *decl_type,\n+\t\t  Location locus)\n+    : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n+      locus (locus), translated (nullptr)\n+  {}\n+\n+  ::Bfunction *fndecl;\n+  ::Btype *decl_type;\n+  Location locus;\n+  ::Bvariable *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_FNPARAM"}, {"sha": "1bb7c91d644761bae3014c0cdcbfa41ef4939b36", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 70, "deletions": 42, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -24,48 +24,46 @@\n #include \"rust-compile-var-decl.h\"\n #include \"rust-compile-stmt.h\"\n #include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n \n namespace Rust {\n namespace Compile {\n \n class CompileItem : public HIRCompileBase\n {\n public:\n-  static void compile (HIR::Item *item, Context *ctx)\n+  static void compile (HIR::Item *item, Context *ctx, bool compile_fns = true)\n   {\n-    CompileItem compiler (ctx);\n+    CompileItem compiler (ctx, compile_fns);\n     item->accept_vis (compiler);\n   }\n \n-  virtual ~CompileItem () {}\n-\n-  void visit (HIR::StructStruct &struct_decl)\n+  void visit (HIR::TupleStruct &struct_decl)\n   {\n-    std::vector<Backend::Btyped_identifier> fields;\n-    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n-      TyTy::TyBase *resolved_type = nullptr;\n-      bool ok\n-\t= ctx->get_tyctx ()->lookup_type (field.get_mappings ().get_hirid (),\n-\t\t\t\t\t  &resolved_type);\n-      rust_assert (ok);\n+    TyTy::TyBase *resolved = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  struct_decl.get_mappings ().get_hirid (), &resolved))\n+      {\n+\trust_fatal_error (struct_decl.get_locus (),\n+\t\t\t  \"Failed to lookup type for struct decl\");\n+\treturn;\n+      }\n \n-      Btype *compiled_field_ty\n-\t= TyTyCompile::compile (ctx->get_backend (), resolved_type);\n+    TyTyResolveCompile::compile (ctx, resolved);\n+  }\n \n-      Backend::Btyped_identifier f (field.field_name, compiled_field_ty,\n-\t\t\t\t    field.get_locus ());\n-      fields.push_back (std::move (f));\n-      return true;\n-    });\n+  void visit (HIR::StructStruct &struct_decl)\n+  {\n+    TyTy::TyBase *resolved = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  struct_decl.get_mappings ().get_hirid (), &resolved))\n+      {\n+\trust_fatal_error (struct_decl.get_locus (),\n+\t\t\t  \"Failed to lookup type for struct decl\");\n+\treturn;\n+      }\n \n-    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n-      = ctx->get_backend ()->named_type (struct_decl.get_identifier (),\n-\t\t\t\t\t struct_type_record,\n-\t\t\t\t\t struct_decl.get_locus ());\n-    ctx->push_type (named_struct);\n-    ctx->insert_compiled_type (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t       named_struct);\n+    TyTyResolveCompile::compile (ctx, resolved);\n   }\n \n   void visit (HIR::StaticItem &var)\n@@ -116,6 +114,9 @@ class CompileItem : public HIRCompileBase\n \n   void visit (HIR::Function &function)\n   {\n+    if (!compile_fns)\n+      return;\n+\n     // items can be forward compiled which means we may not need to invoke this\n     // code\n     Bfunction *lookup = nullptr;\n@@ -127,16 +128,23 @@ class CompileItem : public HIRCompileBase\n \t  return;\n       }\n \n-    TyTy::TyBase *fnType;\n+    TyTy::TyBase *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fnType))\n+\t\t\t\t\t &fntype_tyty))\n       {\n \trust_fatal_error (function.locus, \"failed to lookup function type\");\n \treturn;\n       }\n \n+    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (function.get_locus (), \"invalid TyTy for function item\");\n+\treturn;\n+      }\n+\n+    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n     // convert to the actual function type\n-    auto compiled_fn_type = TyTyCompile::compile (ctx->get_backend (), fnType);\n+    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n     bool is_main_fn = function.function_name.compare (\"main\") == 0;\n@@ -159,18 +167,34 @@ class CompileItem : public HIRCompileBase\n     ctx->insert_function_decl (function.get_mappings ().get_hirid (), fndecl);\n \n     // setup the params\n-    TyTy::TyBase *tyret = TyTyExtractRetFromFnType::compile (fnType);\n-    std::vector<TyTy::ParamType *> typarams\n-      = TyTyExtractParamsFromFnType::compile (fnType);\n+\n+    TyTy::TyBase *tyret = fntype->return_type ();\n     std::vector<Bvariable *> param_vars;\n \n-    for (auto &it : typarams)\n+    size_t i = 0;\n+    for (auto &it : fntype->get_params ())\n       {\n-\tauto compiled_param\n-\t  = TyTyCompileParam::compile (ctx->get_backend (), fndecl, it);\n-\tparam_vars.push_back (compiled_param);\n-\n-\tctx->insert_var_decl (it->get_ref (), compiled_param);\n+\tHIR::FunctionParam &referenced_param = function.function_params.at (i);\n+\tauto param_tyty = it.second;\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+\tLocation param_locus\n+\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n+\tBvariable *compiled_param_var\n+\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t     compiled_param_type, param_locus);\n+\tif (compiled_param_var == nullptr)\n+\t  {\n+\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_param_var);\n+\n+\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t      compiled_param_var);\n+\ti++;\n       }\n \n     if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n@@ -226,7 +250,7 @@ class CompileItem : public HIRCompileBase\n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyCompile::compile (ctx->get_backend (), tyret);\n+\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n \tBstatement *ret_var_stmt = nullptr;\n@@ -246,7 +270,7 @@ class CompileItem : public HIRCompileBase\n       return true;\n     });\n \n-    if (function_body->has_expr ())\n+    if (function_body->has_expr () && function_body->tail_expr_reachable ())\n       {\n \t// the previous passes will ensure this is a valid return\n \t// dead code elimination should remove any bad trailing expressions\n@@ -277,7 +301,11 @@ class CompileItem : public HIRCompileBase\n   }\n \n private:\n-  CompileItem (Context *ctx) : HIRCompileBase (ctx) {}\n+  CompileItem (Context *ctx, bool compile_fns)\n+    : HIRCompileBase (ctx), compile_fns (compile_fns)\n+  {}\n+\n+  bool compile_fns;\n };\n \n } // namespace Compile"}, {"sha": "818d5cbeac3cc1e514106059759f4145f9d8f13d", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -28,24 +28,43 @@ void\n ResolvePathRef::visit (HIR::PathInExpression &expr)\n {\n   // need to look up the reference for this identifier\n-  NodeId ref_node_id;\n-  if (!ctx->get_resolver ()->lookup_resolved_name (\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (ctx->get_resolver ()->lookup_resolved_name (\n \texpr.get_mappings ().get_nodeid (), &ref_node_id))\n     {\n-      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n-      return;\n+      Resolver::Definition def;\n+      if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"unknown reference for resolved name\");\n+\t  return;\n+\t}\n+      ref_node_id = def.parent;\n     }\n \n+  // this can fail because it might be a Constructor for something\n+  // in that case the caller should attempt ResolvePathType::Compile\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    return;\n+\n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (\n \texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n     {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      rust_error_at (expr.get_locus (), \"reverse call path lookup failure\");\n       return;\n     }\n \n-  // assumes paths are functions for now\n-  Bfunction *fn;\n+  // this might be a variable reference or a function reference\n+  Bvariable *var = nullptr;\n+  if (ctx->lookup_var_decl (ref, &var))\n+    {\n+      resolved = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+      return;\n+    }\n+\n+  // must be a function call\n+  Bfunction *fn = nullptr;\n   if (!ctx->lookup_function_decl (ref, &fn))\n     {\n       // this might fail because its a forward decl so we can attempt to\n@@ -54,14 +73,14 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \texpr.get_mappings ().get_crate_num (), ref);\n       if (resolved_item == nullptr)\n \t{\n-\t  rust_fatal_error (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  rust_error_at (expr.get_locus (), \"failed to lookup forward decl\");\n \t  return;\n \t}\n \n       CompileItem::compile (resolved_item, ctx);\n       if (!ctx->lookup_function_decl (ref, &fn))\n \t{\n-\t  rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n \t  return;\n \t}\n     }\n@@ -78,22 +97,21 @@ ResolvePathType::visit (HIR::PathInExpression &expr)\n   if (!ctx->get_resolver ()->lookup_resolved_type (\n \texpr.get_mappings ().get_nodeid (), &ref_node_id))\n     {\n-      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n       return;\n     }\n \n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (\n \texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n     {\n-      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n       return;\n     }\n \n   // assumes paths are functions for now\n   if (!ctx->lookup_compiled_types (ref, &resolved))\n     {\n-      rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+      rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n       return;\n     }\n }"}, {"sha": "2f3cb68e2a7c56b20d146a54c07666806db03b1a", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -32,7 +32,6 @@ class ResolvePathRef : public HIRCompileBase\n   {\n     ResolvePathRef resolver (ctx);\n     expr->accept_vis (resolver);\n-    rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n \n@@ -51,7 +50,6 @@ class ResolvePathType : public HIRCompileBase\n   {\n     ResolvePathType resolver (ctx);\n     expr->accept_vis (resolver);\n-    rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n "}, {"sha": "c52f605c14fa47930a04097d34bb934cf395960f", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -71,6 +71,18 @@ class CompileStmt : public HIRCompileBase\n     if (!stmt.has_init_expr ())\n       return;\n \n+    TyTy::TyBase *ty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t\t &ty))\n+      {\n+\trust_fatal_error (stmt.get_locus (), \"failed to lookup var decl type\");\n+\treturn;\n+      }\n+\n+    // there is an ICE in GCC for void_node\n+    if (ty->get_kind () == TyTy::TypeKind::UNIT)\n+      return;\n+\n     Bvariable *var = nullptr;\n     if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n       {\n@@ -79,7 +91,8 @@ class CompileStmt : public HIRCompileBase\n \treturn;\n       }\n \n-    auto *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+\n     auto fnctx = ctx->peek_fn ();\n     auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n     ctx->add_statement (s);"}, {"sha": "0a16f6a25e542f56f821ea7619ae8123cd59427f", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -38,6 +38,10 @@ class CompileStructExprField : public HIRCompileBase\n \n   void visit (HIR::StructExprFieldIdentifierValue &field);\n \n+  void visit (HIR::StructExprFieldIndexValue &field);\n+\n+  void visit (HIR::StructExprFieldIdentifier &field);\n+\n private:\n   CompileStructExprField (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr)"}, {"sha": "2c54b17c4b95f844cea51f892151e7e6efeeeda4", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 25, "deletions": 133, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-hir-full.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -45,18 +46,21 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n \n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-\n   void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n \n   void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n \n-  void visit (TyTy::ParamType &type) override { gcc_unreachable (); }\n-\n   void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n \n+  void visit (TyTy::TupleType &type) override { gcc_unreachable (); }\n+\n   void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n \n+  void visit (TyTy::UnitType &type) override\n+  {\n+    translated = backend->void_type ();\n+  }\n+\n   void visit (TyTy::FnType &type) override\n   {\n     Backend::Btyped_identifier receiver;\n@@ -71,13 +75,14 @@ class TyTyCompile : public TyTy::TyVisitor\n \t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n       }\n \n-    for (size_t i = 0; i < type.num_params (); i++)\n+    for (auto &params : type.get_params ())\n       {\n-\tauto param_tyty = type.param_at (i);\n-\tauto compiled_param_type\n-\t  = TyTyCompile::compile (backend, param_tyty->get_base_type ());\n+\tauto param_pattern = params.first;\n+\tauto param_tyty = params.second;\n+\tauto compiled_param_type = TyTyCompile::compile (backend, param_tyty);\n+\n \tauto compiled_param = Backend::Btyped_identifier (\n-\t  param_tyty->get_identifier (), compiled_param_type,\n+\t  param_pattern->as_string (), compiled_param_type,\n \t  mappings->lookup_location (param_tyty->get_ref ()));\n \n \tparameters.push_back (compiled_param);\n@@ -185,141 +190,28 @@ class TyTyCompile : public TyTy::TyVisitor\n     gcc_unreachable ();\n   }\n \n-private:\n-  TyTyCompile (::Backend *backend)\n-    : backend (backend), translated (nullptr),\n-      mappings (Analysis::Mappings::get ())\n-  {}\n-\n-  ::Backend *backend;\n-  ::Btype *translated;\n-  Analysis::Mappings *mappings;\n-};\n-\n-class TyTyExtractParamsFromFnType : public TyTy::TyVisitor\n-{\n-public:\n-  static std::vector<TyTy::ParamType *> compile (TyTy::TyBase *ty)\n+  void visit (TyTy::USizeType &type) override\n   {\n-    TyTyExtractParamsFromFnType compiler;\n-    ty->accept_vis (compiler);\n-    rust_assert (compiler.ok);\n-    return compiler.translated;\n+    translated = backend->named_type (\n+      \"usize\", backend->integer_type (true, backend->get_pointer_size ()),\n+      Linemap::predeclared_location ());\n   }\n \n-  ~TyTyExtractParamsFromFnType () {}\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ParamType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnType &type) override\n+  void visit (TyTy::ISizeType &type) override\n   {\n-    ok = true;\n-    for (size_t i = 0; i < type.num_params (); i++)\n-      {\n-\ttranslated.push_back (type.param_at (i));\n-      }\n+    translated = backend->named_type (\n+      \"isize\", backend->integer_type (false, backend->get_pointer_size ()),\n+      Linemap::predeclared_location ());\n   }\n \n private:\n-  TyTyExtractParamsFromFnType () : ok (false) {}\n-\n-  bool ok;\n-  std::vector<TyTy::ParamType *> translated;\n-};\n-\n-class TyTyExtractRetFromFnType : public TyTy::TyVisitor\n-{\n-public:\n-  static TyTy::TyBase *compile (TyTy::TyBase *ty)\n-  {\n-    TyTyExtractRetFromFnType compiler;\n-    ty->accept_vis (compiler);\n-    rust_assert (compiler.ok);\n-    return compiler.translated;\n-  }\n-\n-  ~TyTyExtractRetFromFnType () {}\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ParamType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnType &type) override\n-  {\n-    ok = true;\n-    translated = type.get_return_type ();\n-  }\n-\n-private:\n-  TyTyExtractRetFromFnType () : ok (false), translated (nullptr) {}\n-\n-  bool ok;\n-  TyTy::TyBase *translated;\n-};\n-\n-class TyTyCompileParam : public TyTy::TyVisitor\n-{\n-public:\n-  static ::Bvariable *compile (::Backend *backend, Bfunction *fndecl,\n-\t\t\t       TyTy::TyBase *ty)\n-  {\n-    TyTyCompileParam compiler (backend, fndecl);\n-    ty->accept_vis (compiler);\n-    rust_assert (compiler.translated != nullptr);\n-    return compiler.translated;\n-  }\n-\n-  ~TyTyCompileParam () {}\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ParamType &type) override\n-  {\n-    auto btype = TyTyCompile::compile (backend, type.get_base_type ());\n-    bool tree_addressable = false;\n-    translated = backend->parameter_variable (fndecl, type.get_identifier (),\n-\t\t\t\t\t      btype, tree_addressable,\n-\t\t\t\t\t      mappings->lookup_location (\n-\t\t\t\t\t\ttype.get_ref ()));\n-  }\n-\n-private:\n-  TyTyCompileParam (::Backend *backend, ::Bfunction *fndecl)\n-    : backend (backend), translated (nullptr), fndecl (fndecl),\n+  TyTyCompile (::Backend *backend)\n+    : backend (backend), translated (nullptr),\n       mappings (Analysis::Mappings::get ())\n   {}\n \n   ::Backend *backend;\n-  ::Bvariable *translated;\n-  ::Bfunction *fndecl;\n+  ::Btype *translated;\n   Analysis::Mappings *mappings;\n };\n "}, {"sha": "06ea5a9006454929910060542dc97777bb9a97db", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -42,24 +42,36 @@ class CompileVarDecl : public HIRCompileBase\n \n   void visit (HIR::LetStmt &stmt)\n   {\n+    locus = stmt.get_locus ();\n     TyTy::TyBase *resolved_type = nullptr;\n     bool ok = ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n \t\t\t\t\t      &resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    stmt.get_pattern ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::IdentifierPattern &pattern)\n+  {\n+    if (!pattern.is_mut)\n+      translated_type = ctx->get_backend ()->immutable_type (translated_type);\n \n-    translated = ctx->get_backend ()->local_variable (\n-      fndecl, stmt.get_pattern ()->as_string (), translated_type,\n-      NULL /*decl_var*/, false /*address_taken*/, stmt.get_locus ());\n+    translated\n+      = ctx->get_backend ()->local_variable (fndecl, pattern.variable_ident,\n+\t\t\t\t\t     translated_type, NULL /*decl_var*/,\n+\t\t\t\t\t     false /*address_taken*/, locus);\n   }\n \n private:\n   CompileVarDecl (Context *ctx, ::Bfunction *fndecl)\n-    : HIRCompileBase (ctx), fndecl (fndecl), translated (nullptr)\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (nullptr),\n+      translated (nullptr)\n   {}\n \n   ::Bfunction *fndecl;\n+  ::Btype *translated_type;\n+  Location locus;\n   ::Bvariable *translated;\n };\n "}, {"sha": "ce6d8277063de3afb065e081955b856df2983c1d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -41,8 +41,58 @@ CompileCrate::Compile (HIR::Crate &crate, Context *ctx)\n void\n CompileCrate::go ()\n {\n-  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    CompileItem::compile (it->get (), ctx);\n+  for (auto &item : crate.items)\n+    CompileItem::compile (item.get (), ctx, false);\n+\n+  for (auto &item : crate.items)\n+    CompileItem::compile (item.get (), ctx, true);\n+}\n+\n+// rust-compile-expr.h\n+\n+void\n+CompileExpr::visit (HIR::CallExpr &expr)\n+{\n+  // this can be a function call or it can be a constructor for a tuple struct\n+  Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n+  if (fn != nullptr)\n+    {\n+      std::vector<Bexpression *> args;\n+      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\targs.push_back (compiled_expr);\n+\treturn true;\n+      });\n+\n+      auto fncontext = ctx->peek_fn ();\n+      translated\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n+\t\t\t\t\t\tnullptr, expr.get_locus ());\n+    }\n+  else\n+    {\n+      Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n+      if (type == nullptr)\n+\t{\n+\t  rust_fatal_error (expr.get_locus (),\n+\t\t\t    \"failed to lookup type associated with call\");\n+\t  return;\n+\t}\n+\n+      // this assumes all fields are in order from type resolution and if a base\n+      // struct was specified those fields are filed via accesors\n+      std::vector<Bexpression *> vals;\n+      expr.iterate_params ([&] (HIR::Expr *argument) mutable -> bool {\n+\tBexpression *e = CompileExpr::Compile (argument, ctx);\n+\tvals.push_back (e);\n+\treturn true;\n+      });\n+\n+      translated\n+\t= ctx->get_backend ()->constructor_expression (type, vals,\n+\t\t\t\t\t\t       expr.get_locus ());\n+    }\n }\n \n // rust-compile-block.h\n@@ -90,7 +140,7 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n     return true;\n   });\n \n-  if (expr.has_expr ())\n+  if (expr.has_expr () && expr.tail_expr_reachable ())\n     {\n       // the previous passes will ensure this is a valid return\n       // dead code elimination should remove any bad trailing expressions\n@@ -178,5 +228,21 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifierValue &field)\n   translated = CompileExpr::Compile (field.get_value (), ctx);\n }\n \n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  translated = CompileExpr::Compile (field.get_value (), ctx);\n+}\n+\n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  // we can make the field look like an identifier expr to take advantage of\n+  // existing code\n+  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n+\t\t\t    field.get_locus ());\n+  translated = CompileExpr::Compile (&expr, ctx);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "fc18e27d0d9ec5a1db71424e3e99d9f9119812f0", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 164, "deletions": 1, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -132,7 +132,46 @@ class ASTLoweringExpr : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  virtual ~ASTLoweringExpr () {}\n+  void visit (AST::TupleIndexExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    HIR::Expr *tuple_expr\n+      = ASTLoweringExpr::translate (expr.get_tuple_expr ().get (), &terminated);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TupleIndexExpr (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (tuple_expr),\n+\t\t\t\t expr.get_tuple_index (),\n+\t\t\t\t std::move (outer_attribs), expr.get_locus ());\n+  }\n+\n+  void visit (AST::TupleExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+    std::vector<std::unique_ptr<HIR::Expr> > tuple_elements;\n+    for (auto &e : expr.get_tuple_elems ())\n+      {\n+\tHIR::Expr *t = ASTLoweringExpr::translate (e.get ());\n+\ttuple_elements.push_back (std::unique_ptr<HIR::Expr> (t));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TupleExpr (std::move (mapping), std::move (tuple_elements),\n+\t\t\t    std::move (inner_attribs),\n+\t\t\t    std::move (outer_attribs), expr.get_locus ());\n+  }\n \n   void visit (AST::IfExpr &expr)\n   {\n@@ -465,6 +504,92 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t  expr.get_locus ());\n   }\n \n+  void visit (AST::NegationExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    HIR::NegationExpr::NegationType type;\n+    switch (expr.get_negation_type ())\n+      {\n+      case AST::NegationExpr::NegationType::NEGATE:\n+\ttype = HIR::NegationExpr::NegationType::NEGATE;\n+\tbreak;\n+      case AST::NegationExpr::NegationType::NOT:\n+\ttype = HIR::NegationExpr::NegationType::NOT;\n+\tbreak;\n+      }\n+\n+    HIR::Expr *negated_value\n+      = ASTLoweringExpr::translate (expr.get_negated_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::NegationExpr (mapping,\n+\t\t\t       std::unique_ptr<HIR::Expr> (negated_value), type,\n+\t\t\t       std::move (outer_attribs), expr.get_locus ());\n+  }\n+\n+  void visit (AST::CompoundAssignmentExpr &expr)\n+  {\n+    HIR::ArithmeticOrLogicalExpr::ExprType kind\n+      = HIR::ArithmeticOrLogicalExpr::ExprType::ADD;\n+    switch (expr.get_expr_type ())\n+      {\n+      case AST::CompoundAssignmentExpr::ExprType::ADD:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::ADD;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::SUBTRACT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::SUBTRACT;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::MULTIPLY:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::MULTIPLY;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::DIVIDE:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::DIVIDE;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::MODULUS:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::MODULUS;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::BITWISE_AND:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_AND;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::BITWISE_OR:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_OR;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::BITWISE_XOR:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_XOR;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::LEFT_SHIFT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::LEFT_SHIFT;\n+\tbreak;\n+      case AST::CompoundAssignmentExpr::ExprType::RIGHT_SHIFT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::RIGHT_SHIFT;\n+\tbreak;\n+      }\n+\n+    HIR::Expr *asignee_expr\n+      = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    HIR::Expr *value\n+      = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    HIR::Expr *operator_expr\n+      = new HIR::ArithmeticOrLogicalExpr (mapping, asignee_expr->clone_expr (),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (value),\n+\t\t\t\t\t  kind, expr.get_locus ());\n+    translated\n+      = new HIR::AssignmentExpr (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (asignee_expr),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (operator_expr),\n+\t\t\t\t expr.get_locus ());\n+  }\n+\n   void visit (AST::StructExprStructFields &struct_expr)\n   {\n     std::vector<HIR::Attribute> inner_attribs;\n@@ -505,6 +630,44 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t\t inner_attribs, outer_attribs);\n   }\n \n+  void visit (AST::GroupedExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    HIR::Expr *paren_expr\n+      = ASTLoweringExpr::translate (expr.get_expr_in_parens ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::GroupedExpr (mapping, std::unique_ptr<HIR::Expr> (paren_expr),\n+\t\t\t      std::move (inner_attribs),\n+\t\t\t      std::move (outer_attribs), expr.get_locus ());\n+  }\n+\n+  void visit (AST::FieldAccessExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    HIR::Expr *receiver\n+      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::FieldAccessExpr (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t\t  expr.get_field_name (),\n+\t\t\t\t  std::move (outer_attribs), expr.get_locus ());\n+  }\n+\n private:\n   ASTLoweringExpr ()\n     : translated (nullptr), translated_array_elems (nullptr), terminated (false)"}, {"sha": "ec4ef6bdaa9bb34038f88d9a448d49218cb6f2fd", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 64, "deletions": 7, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -38,10 +38,67 @@ class ASTLoweringItem : public ASTLoweringBase\n   {\n     ASTLoweringItem resolver;\n     item->accept_vis (resolver);\n+\n+    // this is useful for debugging\n+    // if (resolver.translated == nullptr)\n+    //   {\n+    //     rust_fatal_error (item->get_locus_slow (), \"failed to lower: %s\",\n+    //     \t\t  item->as_string ().c_str ());\n+    //     return nullptr;\n+    //   }\n+\n     return resolver.translated;\n   }\n \n-  virtual ~ASTLoweringItem () {}\n+  void visit (AST::TupleStruct &struct_decl)\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+    std::vector<HIR::Attribute> outer_attrs;\n+\n+    std::vector<HIR::TupleField> fields;\n+    struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n+      std::vector<HIR::Attribute> outer_attrs;\n+      HIR::Visibility vis = HIR::Visibility::create_public ();\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      // FIXME\n+      // AST::TupleField is missing Location info\n+      Location field_locus;\n+      HIR::TupleField translated_field (mapping,\n+\t\t\t\t\tstd::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\tfield_locus, outer_attrs);\n+      fields.push_back (std::move (translated_field));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::TupleStruct (mapping, std::move (fields),\n+\t\t\t\t       struct_decl.get_identifier (),\n+\t\t\t\t       std::move (generic_params),\n+\t\t\t\t       std::move (where_clause), vis,\n+\t\t\t\t       std::move (outer_attrs),\n+\t\t\t\t       struct_decl.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       struct_decl.get_locus ());\n+  }\n \n   void visit (AST::StructStruct &struct_decl)\n   {\n@@ -51,7 +108,7 @@ class ASTLoweringItem : public ASTLoweringBase\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n     std::vector<HIR::Attribute> outer_attrs;\n \n-    bool is_unit = false;\n+    bool is_unit = struct_decl.is_unit_struct ();\n     std::vector<HIR::StructField> fields;\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n       std::vector<HIR::Attribute> outer_attrs;\n@@ -190,15 +247,16 @@ class ASTLoweringItem : public ASTLoweringBase\n       = std::unique_ptr<HIR::BlockExpr> (\n \tASTLoweringBlock::translate (function.get_definition ().get (),\n \t\t\t\t     &terminated));\n-    if (!terminated && function.has_return_type ())\n-      rust_error_at (function.get_definition ()->get_locus (),\n-\t\t     \"missing return\");\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n+    mappings->insert_location (crate_num,\n+\t\t\t       function_body->get_mappings ().get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n     auto fn\n       = new HIR::Function (mapping, std::move (function_name),\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n@@ -216,8 +274,7 @@ class ASTLoweringItem : public ASTLoweringBase\n     for (auto &param : fn->function_params)\n       {\n \tmappings->insert_hir_param (mapping.get_crate_num (),\n-\t\t\t\t    param.get_mappings ()->get_hirid (),\n-\t\t\t\t    &param);\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n \tmappings->insert_location (crate_num, mapping.get_hirid (),\n \t\t\t\t   param.get_locus ());\n       }"}, {"sha": "c44c9f972e02531c1d11381c0e68c735de2d3765", "filename": "gcc/rust/hir/rust-ast-lower-struct-field-expr.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -34,10 +34,13 @@ class ASTLowerStructExprField : public ASTLoweringBase\n     field->accept_vis (compiler);\n     rust_assert (compiler.translated != nullptr);\n \n-    // compiler.mappings->insert_hir_expr (\n-    //   compiler.translated->get_mappings ().get_crate_num (),\n-    //   compiler.translated->get_mappings ().get_hirid (),\n-    //   compiler.translated);\n+    compiler.mappings->insert_hir_struct_field (\n+      compiler.translated->get_mappings ().get_crate_num (),\n+      compiler.translated->get_mappings ().get_hirid (), compiler.translated);\n+    compiler.mappings->insert_location (\n+      compiler.translated->get_mappings ().get_crate_num (),\n+      compiler.translated->get_mappings ().get_hirid (),\n+      field->get_locus_slow ());\n \n     return compiler.translated;\n   }\n@@ -46,6 +49,10 @@ class ASTLowerStructExprField : public ASTLoweringBase\n \n   void visit (AST::StructExprFieldIdentifierValue &field);\n \n+  void visit (AST::StructExprFieldIndexValue &field);\n+\n+  void visit (AST::StructExprFieldIdentifier &field);\n+\n private:\n   ASTLowerStructExprField () : translated (nullptr) {}\n "}, {"sha": "e78ae5aaa10b5cc0c9badbb4e8b50909968539fe", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 77, "deletions": 5, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -33,12 +33,85 @@ class ASTLoweringType : public ASTLoweringBase\n   {\n     ASTLoweringType resolver;\n     type->accept_vis (resolver);\n+\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_crate_num (),\n+      resolver.translated->get_mappings ().get_hirid (),\n+      type->get_locus_slow ());\n+\n     return resolver.translated;\n   }\n \n-  virtual ~ASTLoweringType () {}\n+  void visit (AST::BareFunctionType &fntype)\n+  {\n+    bool is_variadic = false;\n+    std::vector<HIR::LifetimeParam> lifetime_params;\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+\n+    std::vector<HIR::MaybeNamedParam> named_params;\n+    for (auto &param : fntype.get_function_params ())\n+      {\n+\tHIR::MaybeNamedParam::ParamKind kind;\n+\tswitch (param.get_param_kind ())\n+\t  {\n+\t  case AST::MaybeNamedParam::ParamKind::UNNAMED:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::UNNAMED;\n+\t    break;\n+\t  case AST::MaybeNamedParam::ParamKind::IDENTIFIER:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::IDENTIFIER;\n+\t    break;\n+\t  case AST::MaybeNamedParam::ParamKind::WILDCARD:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::WILDCARD;\n+\t    break;\n+\t  }\n+\n+\tHIR::Type *param_type\n+\t  = ASTLoweringType::translate (param.get_type ().get ());\n+\n+\tHIR::MaybeNamedParam p (param.get_name (), kind,\n+\t\t\t\tstd::unique_ptr<HIR::Type> (param_type),\n+\t\t\t\tparam.get_locus ());\n+\tnamed_params.push_back (std::move (p));\n+      }\n+\n+    HIR::Type *return_type = nullptr;\n+    if (fntype.has_return_type ())\n+      {\n+\treturn_type\n+\t  = ASTLoweringType::translate (fntype.get_return_type ().get ());\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, fntype.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::BareFunctionType (\n+      std::move (mapping), std::move (lifetime_params), std::move (qualifiers),\n+      std::move (named_params), is_variadic,\n+      std::unique_ptr<HIR::Type> (return_type), fntype.get_locus ());\n+  }\n+\n+  void visit (AST::TupleType &tuple)\n+  {\n+    std::vector<std::unique_ptr<HIR::Type> > elems;\n+    for (auto &e : tuple.get_elems ())\n+      {\n+\tHIR::Type *t = ASTLoweringType::translate (e.get ());\n+\telems.push_back (std::unique_ptr<HIR::Type> (t));\n+      }\n \n-  virtual void visit (AST::TypePathSegment &segment)\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, tuple.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::TupleType (std::move (mapping), std::move (elems),\n+\t\t\t\t     tuple.get_locus ());\n+  }\n+\n+  void visit (AST::TypePathSegment &segment)\n   {\n     HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n     translated_segment\n@@ -47,7 +120,7 @@ class ASTLoweringType : public ASTLoweringBase\n \t\t\t\t  segment.get_locus ());\n   }\n \n-  virtual void visit (AST::TypePath &path)\n+  void visit (AST::TypePath &path)\n   {\n     std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n \n@@ -100,10 +173,9 @@ class ASTLoweringType : public ASTLoweringBase\n   }\n \n private:\n-  ASTLoweringType () : translated (nullptr) {}\n+  ASTLoweringType () : translated (nullptr), translated_segment (nullptr) {}\n \n   HIR::Type *translated;\n-\n   HIR::TypePathSegment *translated_segment;\n };\n "}, {"sha": "dac2320d84abe17362cec2bfe26030f7f139056b", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -89,29 +89,30 @@ ASTLoweringBlock::visit (AST::BlockExpr &expr)\n     return true;\n   });\n \n-  HIR::ExprWithoutBlock *tail_expr = nullptr;\n-  if (expr.has_tail_expr () && !block_did_terminate)\n-    {\n-      tail_expr = (HIR::ExprWithoutBlock *) ASTLoweringExpr::translate (\n-\texpr.get_tail_expr ().get ());\n-    }\n-  else if (expr.has_tail_expr () && block_did_terminate)\n+  bool tail_reachable = expr.has_tail_expr () && !block_did_terminate;\n+  if (expr.has_tail_expr () && block_did_terminate)\n     {\n       // warning unreachable tail expressions\n       rust_warning_at (expr.get_tail_expr ()->get_locus_slow (), 0,\n \t\t       \"unreachable expression\");\n     }\n \n+  HIR::ExprWithoutBlock *tail_expr = nullptr;\n+  if (expr.has_tail_expr ())\n+    {\n+      tail_expr = (HIR::ExprWithoutBlock *) ASTLoweringExpr::translate (\n+\texpr.get_tail_expr ().get ());\n+    }\n+\n   auto crate_num = mappings->get_current_crate ();\n   Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n \t\t\t\t mappings->get_next_hir_id (crate_num),\n \t\t\t\t UNKNOWN_LOCAL_DEFID);\n-\n   translated\n     = new HIR::BlockExpr (mapping, std::move (block_stmts),\n \t\t\t  std::unique_ptr<HIR::ExprWithoutBlock> (tail_expr),\n-\t\t\t  std::move (inner_attribs), std::move (outer_attribs),\n-\t\t\t  expr.get_locus ());\n+\t\t\t  tail_reachable, std::move (inner_attribs),\n+\t\t\t  std::move (outer_attribs), expr.get_locus ());\n \n   terminated = block_did_terminate || expr.has_tail_expr ();\n }\n@@ -211,5 +212,34 @@ ASTLowerStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n     field.get_locus ());\n }\n \n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  HIR::Expr *value = ASTLoweringExpr::translate (field.get_value ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::StructExprFieldIndexValue (mapping, field.get_index (),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (value),\n+\t\t\t\t\t  field.get_locus ());\n+}\n+\n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::StructExprFieldIdentifier (mapping, field.get_field_name (),\n+\t\t\t\t\t  field.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "69b680d27520571b47943f43ab14abf59a403ebf", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 66, "deletions": 85, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -61,7 +61,11 @@ class LiteralExpr : public ExprWithoutBlock\n   Location locus;\n \n public:\n-  std::string as_string () const override { return literal.as_string (); }\n+  std::string as_string () const override\n+  {\n+    return \"( \" + literal.as_string () + \" (\" + get_mappings ().as_string ()\n+\t   + \"))\";\n+  }\n \n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n \n@@ -751,86 +755,6 @@ class AssignmentExpr : public OperatorExpr\n   }\n };\n \n-/* Binary infix compound assignment (arithmetic or logic then assignment)\n- * expressions. */\n-class CompoundAssignmentExpr : public OperatorExpr\n-{\n-public:\n-  enum ExprType\n-  {\n-    ADD,\t // std::ops::AddAssign\n-    SUBTRACT,\t // std::ops::SubAssign\n-    MULTIPLY,\t // std::ops::MulAssign\n-    DIVIDE,\t // std::ops::DivAssign\n-    MODULUS,\t // std::ops::RemAssign\n-    BITWISE_AND, // std::ops::BitAndAssign\n-    BITWISE_OR,\t // std::ops::BitOrAssign\n-    BITWISE_XOR, // std::ops::BitXorAssign\n-    LEFT_SHIFT,\t // std::ops::ShlAssign\n-    RIGHT_SHIFT\t // std::ops::ShrAssign\n-  };\n-\n-private:\n-  // Note: overloading trait specified in comments\n-  ExprType expr_type;\n-  std::unique_ptr<Expr> right_expr;\n-\n-public:\n-  std::string as_string () const override;\n-\n-  ExprType get_expr_type () const { return expr_type; }\n-\n-  // Use pointers in constructor to enable polymorphism\n-  CompoundAssignmentExpr (Analysis::NodeMapping mappings,\n-\t\t\t  std::unique_ptr<Expr> value_to_assign_to,\n-\t\t\t  std::unique_ptr<Expr> value_to_assign,\n-\t\t\t  ExprType expr_kind, Location locus)\n-    : OperatorExpr (std::move (mappings), std::move (value_to_assign_to),\n-\t\t    std::vector<Attribute> (), locus),\n-      expr_type (expr_kind), right_expr (std::move (value_to_assign))\n-  {}\n-  // outer attributes not allowed\n-\n-  // Have clone in copy constructor\n-  CompoundAssignmentExpr (CompoundAssignmentExpr const &other)\n-    : OperatorExpr (other), expr_type (other.expr_type),\n-      right_expr (other.right_expr->clone_expr ())\n-  {}\n-\n-  // Overload assignment operator to clone\n-  CompoundAssignmentExpr &operator= (CompoundAssignmentExpr const &other)\n-  {\n-    OperatorExpr::operator= (other);\n-    // main_or_left_expr = other.main_or_left_expr->clone_expr();\n-    right_expr = other.right_expr->clone_expr ();\n-    expr_type = other.expr_type;\n-    // outer_attrs = other.outer_attrs;\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  CompoundAssignmentExpr (CompoundAssignmentExpr &&other) = default;\n-  CompoundAssignmentExpr &operator= (CompoundAssignmentExpr &&other) = default;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  CompoundAssignmentExpr *clone_expr_impl () const override\n-  {\n-    return new CompoundAssignmentExpr (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  CompoundAssignmentExpr *clone_expr_without_block_impl () const override\n-  {\n-    return new CompoundAssignmentExpr (*this);\n-  }\n-};\n-\n // Expression in parentheses (i.e. like literally just any 3 + (2 * 6))\n class GroupedExpr : public ExprWithoutBlock\n {\n@@ -880,6 +804,12 @@ class GroupedExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_expr_in_parens ()\n+  {\n+    rust_assert (expr_in_parens != nullptr);\n+    return expr_in_parens;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1233,6 +1163,17 @@ class TupleExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  const std::vector<std::unique_ptr<Expr> > &get_tuple_elems () const\n+  {\n+    return tuple_elems;\n+  }\n+  std::vector<std::unique_ptr<Expr> > &get_tuple_elems ()\n+  {\n+    return tuple_elems;\n+  }\n+\n+  bool is_unit () const { return tuple_elems.size () == 0; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1297,6 +1238,12 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_tuple_expr ()\n+  {\n+    rust_assert (tuple_expr != nullptr);\n+    return tuple_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1473,6 +1420,8 @@ class StructExprFieldIdentifier : public StructExprField\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_field_name () const { return field_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1568,6 +1517,8 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  TupleIndex get_tuple_index () const { return index; };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1642,6 +1593,27 @@ class StructExprStructFields : public StructExprStruct\n       }\n   }\n \n+  std::vector<std::unique_ptr<StructExprField> > &get_fields ()\n+  {\n+    return fields;\n+  };\n+\n+  const std::vector<std::unique_ptr<StructExprField> > &get_fields () const\n+  {\n+    return fields;\n+  };\n+\n+  std::vector<std::unique_ptr<StructExprField> > get_fields_as_owner ()\n+  {\n+    return std::move (fields);\n+  };\n+\n+  void set_fields_as_owner (\n+    std::vector<std::unique_ptr<StructExprField> > new_fields)\n+  {\n+    fields = std::move (new_fields);\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2353,6 +2325,14 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_receiver_expr ()\n+  {\n+    rust_assert (receiver != nullptr);\n+    return receiver;\n+  }\n+\n+  Identifier get_field_name () const { return field; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2513,11 +2493,10 @@ class BlockExpr : public ExprWithBlock\n public:\n   std::vector<Attribute> inner_attrs;\n \n-  // bool has_statements;\n   std::vector<std::unique_ptr<Stmt> > statements;\n-  // bool has_expr;\n   std::unique_ptr<ExprWithoutBlock> expr; // inlined from Statements\n \n+  bool tail_reachable;\n   Location locus;\n \n   std::string as_string () const override;\n@@ -2528,15 +2507,17 @@ class BlockExpr : public ExprWithBlock\n   // Returns whether the block contains an expression\n   bool has_expr () const { return expr != nullptr; }\n \n+  bool tail_expr_reachable () const { return tail_reachable; }\n+\n   BlockExpr (Analysis::NodeMapping mappings,\n \t     std::vector<std::unique_ptr<Stmt> > block_statements,\n-\t     std::unique_ptr<ExprWithoutBlock> block_expr,\n+\t     std::unique_ptr<ExprWithoutBlock> block_expr, bool tail_reachable,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n     : ExprWithBlock (std::move (mappings), std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       statements (std::move (block_statements)), expr (std::move (block_expr)),\n-      locus (locus)\n+      tail_reachable (tail_reachable), locus (locus)\n   {}\n \n   // Copy constructor with clone"}, {"sha": "b727917c2f1b53af483d98ee24fe7cd1039d3f1d", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -2032,67 +2032,6 @@ ErrorPropagationExpr::as_string () const\n   return main_or_left_expr->as_string () + \"?\";\n }\n \n-std::string\n-CompoundAssignmentExpr::as_string () const\n-{\n-  std::string operator_str;\n-  operator_str.reserve (1);\n-\n-  // get operator string\n-  switch (expr_type)\n-    {\n-    case ADD:\n-      operator_str = \"+\";\n-      break;\n-    case SUBTRACT:\n-      operator_str = \"-\";\n-      break;\n-    case MULTIPLY:\n-      operator_str = \"*\";\n-      break;\n-    case DIVIDE:\n-      operator_str = \"/\";\n-      break;\n-    case MODULUS:\n-      operator_str = \"%\";\n-      break;\n-    case BITWISE_AND:\n-      operator_str = \"&\";\n-      break;\n-    case BITWISE_OR:\n-      operator_str = \"|\";\n-      break;\n-    case BITWISE_XOR:\n-      operator_str = \"^\";\n-      break;\n-    case LEFT_SHIFT:\n-      operator_str = \"<<\";\n-      break;\n-    case RIGHT_SHIFT:\n-      operator_str = \">>\";\n-      break;\n-    default:\n-      operator_str = \"invalid operator. wtf\";\n-      break;\n-    }\n-\n-  operator_str += \"=\";\n-\n-  std::string str (\"CompoundAssignmentExpr: \");\n-  if (main_or_left_expr == nullptr || right_expr == nullptr)\n-    {\n-      str += \"error. this is probably a parsing failure.\";\n-    }\n-  else\n-    {\n-      str += \"\\n left: \" + main_or_left_expr->as_string ();\n-      str += \"\\n right: \" + right_expr->as_string ();\n-      str += \"\\n operator: \" + operator_str;\n-    }\n-\n-  return str;\n-}\n-\n std::string\n ArithmeticOrLogicalExpr::as_string () const\n {\n@@ -2133,23 +2072,15 @@ ArithmeticOrLogicalExpr::as_string () const\n       operator_str = \">>\";\n       break;\n     default:\n-      operator_str = \"invalid operator. wtf\";\n+      gcc_unreachable ();\n       break;\n     }\n \n-  std::string str (\"ArithmeticOrLogicalExpr: \");\n-  if (main_or_left_expr == nullptr || right_expr == nullptr)\n-    {\n-      str += \"error. this is probably a parsing failure.\";\n-    }\n-  else\n-    {\n-      str += main_or_left_expr->as_string () + \" \";\n-      str += operator_str + \" \";\n-      str += right_expr->as_string ();\n-    }\n+  std::string str = main_or_left_expr->as_string () + \" \";\n+  str += operator_str + \" \";\n+  str += right_expr->as_string ();\n \n-  return str + \"::\" + get_mappings ().as_string ();\n+  return \"( \" + str + \" (\" + get_mappings ().as_string () + \"))\";\n }\n \n std::string\n@@ -5240,12 +5171,6 @@ AssignmentExpr::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-CompoundAssignmentExpr::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n GroupedExpr::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "e99dd389f72a73f246f26dc281e8a15e26a18f27", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -404,13 +404,13 @@ struct FunctionQualifiers\n // A function parameter\n struct FunctionParam\n {\n-public:\n   std::unique_ptr<Pattern> param_name;\n   std::unique_ptr<Type> type;\n \n   Location locus;\n   Analysis::NodeMapping mappings;\n \n+public:\n   FunctionParam (Analysis::NodeMapping mappings,\n \t\t std::unique_ptr<Pattern> param_name,\n \t\t std::unique_ptr<Type> param_type, Location locus)\n@@ -448,7 +448,7 @@ struct FunctionParam\n \n   Type *get_type () { return type.get (); }\n \n-  Analysis::NodeMapping *get_mappings () { return &mappings; }\n+  Analysis::NodeMapping &get_mappings () { return mappings; }\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -1604,7 +1604,9 @@ struct TupleField\n \n   std::unique_ptr<Type> field_type;\n \n-  // should this store location info?\n+  Location locus;\n+\n+  Analysis::NodeMapping mappings;\n \n public:\n   // Returns whether tuple field has outer attributes.\n@@ -1615,16 +1617,18 @@ struct TupleField\n   bool has_visibility () const { return !visibility.is_error (); }\n \n   // Complete constructor\n-  TupleField (std::unique_ptr<Type> field_type, Visibility vis,\n+  TupleField (Analysis::NodeMapping mapping, std::unique_ptr<Type> field_type,\n+\t      Visibility vis, Location locus,\n \t      std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n-      field_type (std::move (field_type))\n+      field_type (std::move (field_type)), locus (locus), mappings (mapping)\n   {}\n \n   // Copy constructor with clone\n   TupleField (TupleField const &other)\n     : outer_attrs (other.outer_attrs), visibility (other.visibility),\n-      field_type (other.field_type->clone_type ())\n+      field_type (other.field_type->clone_type ()), locus (other.locus),\n+      mappings (other.mappings)\n   {}\n \n   ~TupleField () = default;\n@@ -1635,6 +1639,8 @@ struct TupleField\n     field_type = other.field_type->clone_type ();\n     visibility = other.visibility;\n     outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -1646,13 +1652,13 @@ struct TupleField\n   // Returns whether tuple field is in an error state.\n   bool is_error () const { return field_type == nullptr; }\n \n-  // Creates an error state tuple field.\n-  static TupleField create_error ()\n-  {\n-    return TupleField (nullptr, Visibility::create_error ());\n-  }\n-\n   std::string as_string () const;\n+\n+  Analysis::NodeMapping get_mappings () { return mappings; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<HIR::Type> &get_field_type () { return field_type; }\n };\n \n // Rust tuple declared using struct keyword HIR node\n@@ -1677,6 +1683,18 @@ class TupleStruct : public Struct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<TupleField> &get_fields () { return fields; }\n+  const std::vector<TupleField> &get_fields () const { return fields; }\n+\n+  void iterate (std::function<bool (TupleField &)> cb)\n+  {\n+    for (auto &field : fields)\n+      {\n+\tif (!cb (field))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "ebed11987c4565de59f9938bff3dca488139a0f9", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -393,6 +393,12 @@ class TupleType : public TypeNoBounds\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<std::unique_ptr<Type> > &get_elems () { return elems; }\n+  const std::vector<std::unique_ptr<Type> > &get_elems () const\n+  {\n+    return elems;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -785,6 +791,16 @@ struct MaybeNamedParam\n   }\n \n   Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n+\n+  ParamKind get_param_kind () const { return param_kind; }\n+\n+  Identifier get_name () const { return name; }\n };\n \n /* A function pointer type - can be created via coercion from function items and\n@@ -799,9 +815,7 @@ class BareFunctionType : public TypeNoBounds\n   std::vector<MaybeNamedParam> params;\n   bool is_variadic;\n \n-  // bool has_return_type;\n-  // BareFunctionReturnType return_type;\n-  std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+  std::unique_ptr<Type> return_type; // inlined version\n \n   Location locus;\n \n@@ -816,7 +830,7 @@ class BareFunctionType : public TypeNoBounds\n \t\t    std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n \t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n-\t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n+\t\t    std::unique_ptr<Type> type, Location locus)\n     : TypeNoBounds (mappings), for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n@@ -828,8 +842,7 @@ class BareFunctionType : public TypeNoBounds\n     : TypeNoBounds (other.mappings), for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n       is_variadic (other.is_variadic),\n-      return_type (other.return_type->clone_type_no_bounds ()),\n-      locus (other.locus)\n+      return_type (other.return_type->clone_type ()), locus (other.locus)\n   {}\n \n   // Overload assignment operator to deep copy\n@@ -840,7 +853,7 @@ class BareFunctionType : public TypeNoBounds\n     function_qualifiers = other.function_qualifiers;\n     params = other.params;\n     is_variadic = other.is_variadic;\n-    return_type = other.return_type->clone_type_no_bounds ();\n+    return_type = other.return_type->clone_type ();\n     locus = other.locus;\n \n     return *this;\n@@ -856,6 +869,19 @@ class BareFunctionType : public TypeNoBounds\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<MaybeNamedParam> &get_function_params () { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const\n+  {\n+    return params;\n+  }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "7fefb6909ddcc9bc2a8f7cffc362a48b39928cfd", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -77,7 +77,6 @@ class HIRVisitor\n   virtual void visit (LazyBooleanExpr &expr) = 0;\n   virtual void visit (TypeCastExpr &expr) = 0;\n   virtual void visit (AssignmentExpr &expr) = 0;\n-  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n   virtual void visit (GroupedExpr &expr) = 0;\n   // virtual void visit(ArrayElems& elems) = 0;\n   virtual void visit (ArrayElemsValues &elems) = 0;"}, {"sha": "e4a81c501ae1e6887e9ae0e8aa065169c5656566", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -819,16 +819,16 @@ class Expr\n \n   const Analysis::NodeMapping &get_mappings () const { return mappings; }\n \n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n protected:\n   // Constructor\n   Expr (Analysis::NodeMapping mappings,\n \tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attribs)), mappings (std::move (mappings))\n   {}\n \n-  // Clone function implementation as pure virtual method\n-  virtual Expr *clone_expr_impl () const = 0;\n-\n   // TODO: think of less hacky way to implement this kind of thing\n   // Sets outer attributes.\n   void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n@@ -895,7 +895,10 @@ class IdentifierExpr : public ExprWithoutBlock\n       ident (std::move (ident)), locus (locus)\n   {}\n \n-  std::string as_string () const override { return ident; }\n+  std::string as_string () const override\n+  {\n+    return \"( \" + ident + \" (\" + get_mappings ().as_string () + \"))\";\n+  }\n \n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n@@ -908,6 +911,8 @@ class IdentifierExpr : public ExprWithoutBlock\n     return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n   }\n \n+  Identifier get_identifier () const { return ident; }\n+\n protected:\n   // Clone method implementation\n   IdentifierExpr *clone_expr_without_block_impl () const override"}, {"sha": "6dfaea246b467d5a9610db1f3290ecb4b8bc411d", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -466,7 +466,9 @@ Lexer::build_token ()\n \t  if (peek_input () == '=')\n \t    {\n \t      // modulo-assign\n+\t      skip_input ();\n \t      current_column += 2;\n+\n \t      return Token::make (PERCENT_EQ, loc);\n \t    }\n \t  else\n@@ -479,7 +481,9 @@ Lexer::build_token ()\n \t  if (peek_input () == '=')\n \t    {\n \t      // xor-assign?\n+\t      skip_input ();\n \t      current_column += 2;\n+\n \t      return Token::make (CARET_EQ, loc);\n \t    }\n \t  else"}, {"sha": "ffe4e916319c143deb5fe46b4536b401e9d5fd74", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -22,8 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"rust-diagnostics.h\"\n \n-#include <algorithm> // for std::find\n-\n namespace Rust {\n // Left binding powers of operations.\n enum binding_powers\n@@ -12234,10 +12232,9 @@ Parser<ManagedTokenSource>::null_denotation (\n \n \t// HACK: as struct expressions should always be value expressions,\n \t// cannot be referenced\n-\tParseRestrictions entered_from_unary\n-\t  = {/* can_be_struct_expr = */ false, /* entered_from_unary = */ true};\n-\t/*entered_from_unary.entered_from_unary = true;\n-\tentered_from_unary.can_be_struct_expr = false;*/\n+\tParseRestrictions entered_from_unary;\n+\tentered_from_unary.entered_from_unary = true;\n+\tentered_from_unary.can_be_struct_expr = false;\n \n \tif (lexer.peek_token ()->get_id () == MUT)\n \t  {"}, {"sha": "fdad97c52dd0170d56d4d1eaf133da0640f01085", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -41,8 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n // maybe put these back in if compiling no longer works\n \n-#include <algorithm> // for std::find\n-\n /* TODO: move non-essential stuff back here from rust-parse-impl.h after\n  * confirming that it works */\n "}, {"sha": "f62f17c1276f54ca0fa0dc235bb9fa70ced37e6d", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-ast-resolve-base.h\"\n #include \"rust-ast-full.h\"\n #include \"rust-ast-resolve-struct-expr-field.h\"\n+#include \"rust-ast-verify-assignee.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -35,7 +36,19 @@ class ResolveExpr : public ResolverBase\n     expr->accept_vis (resolver);\n   };\n \n-  ~ResolveExpr () {}\n+  void visit (AST::TupleIndexExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_tuple_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::TupleExpr &expr)\n+  {\n+    if (expr.is_unit ())\n+      return;\n+\n+    for (auto &elem : expr.get_tuple_elems ())\n+      ResolveExpr::go (elem.get (), expr.get_node_id ());\n+  }\n \n   void visit (AST::PathInExpression &expr)\n   {\n@@ -76,27 +89,39 @@ class ResolveExpr : public ResolverBase\n       ResolveExpr::go (p, expr.get_node_id ());\n       return true;\n     });\n-    // resolver->insert_resolved_name(NodeId refId,NodeId defId)\n   }\n \n   void visit (AST::AssignmentExpr &expr)\n   {\n     ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n     ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+\n+    // need to verify the assignee\n+    VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IdentifierExpr &expr)\n   {\n-    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+    else if (resolver->get_type_scope ().lookup (expr.as_string (),\n+\t\t\t\t\t\t &resolved_node))\n+      {\n+\tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+    else\n       {\n \trust_error_at (expr.get_locus (), \"failed to find name: %s\",\n \t\t       expr.as_string ().c_str ());\n-\treturn;\n       }\n-\n-    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-    resolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t     Definition{expr.get_node_id (), parent});\n   }\n \n   void visit (AST::ArithmeticOrLogicalExpr &expr)\n@@ -105,6 +130,15 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::CompoundAssignmentExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+\n+    // need to verify the assignee\n+    VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+  }\n+\n   void visit (AST::ComparisonExpr &expr)\n   {\n     ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n@@ -117,6 +151,11 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::NegationExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_negated_expr ().get (), expr.get_node_id ());\n+  }\n+\n   void visit (AST::IfExpr &expr)\n   {\n     ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n@@ -168,13 +207,31 @@ class ResolveExpr : public ResolverBase\n   {\n     ResolveExpr::go (&struct_expr.get_struct_name (),\n \t\t     struct_expr.get_node_id ());\n+\n+    if (struct_expr.has_struct_base ())\n+      {\n+\tAST::StructBase &base = struct_expr.get_struct_base ();\n+\tResolveExpr::go (base.get_base_struct ().get (),\n+\t\t\t struct_expr.get_node_id ());\n+      }\n+\n     struct_expr.iterate (\n       [&] (AST::StructExprField *struct_field) mutable -> bool {\n \tResolveStructExprField::go (struct_field, struct_expr.get_node_id ());\n \treturn true;\n       });\n   }\n \n+  void visit (AST::GroupedExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::FieldAccessExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "0f45ba025b18ba963e9ffb570fe130277482d67d", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -40,10 +40,20 @@ class ResolveItem : public ResolverBase\n \n   ~ResolveItem () {}\n \n+  void visit (AST::TupleStruct &struct_decl)\n+  {\n+    struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n   void visit (AST::StructStruct &struct_decl)\n   {\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n-      ResolveType::go (field.get_field_type ().get (), field.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n       return true;\n     });\n   }\n@@ -52,12 +62,22 @@ class ResolveItem : public ResolverBase\n   {\n     ResolveType::go (var.get_type ().get (), var.get_node_id ());\n     ResolveExpr::go (var.get_expr ().get (), var.get_node_id ());\n+\n+    // the mutability checker needs to verify for immutable decls the number\n+    // of assignments are <1. This marks an implicit assignment\n+    resolver->mark_assignment_to_decl (var.get_node_id (), var.get_node_id ());\n   }\n \n   void visit (AST::ConstantItem &constant)\n   {\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n     ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+\n+    // the mutability checker needs to verify for immutable decls the number\n+    // of assignments are <1. This marks an implicit assignment\n+    resolver->mark_decl_mutability (constant.get_node_id (), false);\n+    resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t       constant.get_node_id ());\n   }\n \n   void visit (AST::Function &function)\n@@ -79,6 +99,11 @@ class ResolveItem : public ResolverBase\n \tResolveType::go (param.get_type ().get (), param.get_node_id ());\n \tPatternDeclaration::go (param.get_pattern ().get (),\n \t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n       }\n \n     // resolve the function body"}, {"sha": "f7618ab8d11d8bbb5bfe757b97127ca3a488b86c", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -86,6 +86,8 @@ class PatternDeclaration : public ResolverBase\n     resolver->insert_new_definition (pattern.get_node_id (),\n \t\t\t\t     Definition{pattern.get_node_id (),\n \t\t\t\t\t\tparent});\n+    resolver->mark_decl_mutability (pattern.get_node_id (),\n+\t\t\t\t    pattern.get_is_mut ());\n   }\n \n private:"}, {"sha": "8904ce99f5725d25f64ea581ce1d485c8202be8e", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -52,7 +52,13 @@ class ResolveStmt : public ResolverBase\n   void visit (AST::LetStmt &stmt)\n   {\n     if (stmt.has_init_expr ())\n-      ResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n+      {\n+\tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n+\n+\t// mark the assignment\n+\tresolver->mark_assignment_to_decl (stmt.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   stmt.get_node_id ());\n+      }\n \n     PatternDeclaration::go (stmt.get_pattern ().get (), stmt.get_node_id ());\n     if (stmt.has_type ())"}, {"sha": "391647327697c99e2aef7f169c5f6e6ffb74fae1", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -26,8 +26,7 @@ namespace Rust {\n namespace Resolver {\n \n // this resolves values being assigned not that the field actually exists yet.\n-// We cant resolve the field to struct until type resolution since the HIR\n-// Mappings don't exist yet.\n+\n class ResolveStructExprField : public ResolverBase\n {\n public:\n@@ -41,7 +40,9 @@ class ResolveStructExprField : public ResolverBase\n \n   void visit (AST::StructExprFieldIdentifierValue &field);\n \n-  // TODO\n+  void visit (AST::StructExprFieldIndexValue &field);\n+\n+  void visit (AST::StructExprFieldIdentifier &field);\n \n private:\n   ResolveStructExprField (NodeId parent) : ResolverBase (parent) {}"}, {"sha": "c3f5e4c26b8937e88d046c9f17decc906eb2512b", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -36,6 +36,13 @@ class ResolveTopLevel : public ResolverBase\n \n   ~ResolveTopLevel () {}\n \n+  void visit (AST::TupleStruct &struct_decl)\n+  {\n+    resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n+\t\t\t\t\tstruct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_locus ());\n+  }\n+\n   void visit (AST::StructStruct &struct_decl)\n   {\n     resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n@@ -50,6 +57,7 @@ class ResolveTopLevel : public ResolverBase\n     resolver->insert_new_definition (var.get_node_id (),\n \t\t\t\t     Definition{var.get_node_id (),\n \t\t\t\t\t\tvar.get_node_id ()});\n+    resolver->mark_decl_mutability (var.get_node_id (), var.is_mutable ());\n   }\n \n   void visit (AST::ConstantItem &constant)\n@@ -67,6 +75,9 @@ class ResolveTopLevel : public ResolverBase\n     resolver->get_name_scope ().insert (function.get_function_name (),\n \t\t\t\t\tfunction.get_node_id (),\n \t\t\t\t\tfunction.get_locus ());\n+    resolver->insert_new_definition (function.get_node_id (),\n+\t\t\t\t     Definition{function.get_node_id (),\n+\t\t\t\t\t\tfunction.get_node_id ()});\n \n     // if this does not get a reference it will be determined to be unused\n     // lets give it a fake reference to itself"}, {"sha": "b303ee905d5aef411a15b2b16bc45c8942e0218d", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -31,28 +31,43 @@ class ResolveType : public ResolverBase\n   static void go (AST::Type *type, NodeId parent)\n   {\n     ResolveType resolver (parent);\n-\n     type->accept_vis (resolver);\n-    if (resolver.resolved_node == UNKNOWN_NODEID)\n+  };\n+\n+  void visit (AST::BareFunctionType &fntype)\n+  {\n+    for (auto &param : fntype.get_function_params ())\n+      ResolveType::go (param.get_type ().get (), fntype.get_node_id ());\n+\n+    if (fntype.has_return_type ())\n+      ResolveType::go (fntype.get_return_type ().get (), fntype.get_node_id ());\n+  }\n+\n+  void visit (AST::TupleType &tuple)\n+  {\n+    if (tuple.is_unit_type ())\n       {\n-\trust_error_at (resolver.locus, \"failed to resolve type %s\",\n-\t\t       type->as_string ().c_str ());\n+\tresolved_node = resolver->get_unit_type_node_id ();\n+\treturn;\n       }\n-  };\n \n-  ~ResolveType () {}\n+    for (auto &elem : tuple.get_elems ())\n+      ResolveType::go (elem.get (), tuple.get_node_id ());\n+  }\n \n   void visit (AST::TypePath &path)\n   {\n     // this will need changed to handle mod/crate/use globs and look\n     // at the segments in granularity\n-    if (resolver->get_type_scope ().lookup (path.as_string (), &resolved_node))\n+    if (!resolver->get_type_scope ().lookup (path.as_string (), &resolved_node))\n       {\n-\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (path.get_node_id (),\n-\t\t\t\t\t Definition{path.get_node_id (),\n-\t\t\t\t\t\t    parent});\n+\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n+\t\t       path.as_string ().c_str ());\n+\treturn;\n       }\n+    resolver->insert_resolved_type (path.get_node_id (), resolved_node);\n+    resolver->insert_new_definition (path.get_node_id (),\n+\t\t\t\t     Definition{path.get_node_id (), parent});\n   }\n \n   void visit (AST::ArrayType &type)"}, {"sha": "c6d71488fde22bc5a8d44fb3f708eb4f59289ce0", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -113,7 +113,7 @@ Resolver::insert_builtin_types (Rib *r)\n \t\t    Linemap::predeclared_location ());\n }\n \n-std::vector<AST::TypePath *> &\n+std::vector<AST::Type *> &\n Resolver::get_builtin_types ()\n {\n   return builtins;\n@@ -146,6 +146,8 @@ Resolver::generate_builtins ()\n     = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n   auto f64\n     = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n+  auto usize = new TyTy::USizeType (mappings->get_next_hir_id ());\n+  auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n \n   MKBUILTIN_TYPE (\"u8\", builtins, u8);\n   MKBUILTIN_TYPE (\"u16\", builtins, u16);\n@@ -160,6 +162,18 @@ Resolver::generate_builtins ()\n   MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n   MKBUILTIN_TYPE (\"f32\", builtins, f32);\n   MKBUILTIN_TYPE (\"f64\", builtins, f64);\n+  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n+  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n+\n+  // unit type ()\n+  TyTy::UnitType *unit_tyty = new TyTy::UnitType (mappings->get_next_hir_id ());\n+  std::vector<std::unique_ptr<AST::Type> > elems;\n+  AST::TupleType *unit_type\n+    = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());\n+  builtins.push_back (unit_type);\n+  tyctx->insert_builtin (unit_tyty->get_ref (), unit_type->get_node_id (),\n+\t\t\t unit_tyty);\n+  set_unit_type_node_id (unit_type->get_node_id ());\n }\n \n void\n@@ -308,5 +322,20 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n   ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n }\n \n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+}\n+\n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  AST::IdentifierExpr expr (field.get_field_name (), field.get_locus ());\n+  expr.set_node_id (field.get_node_id ());\n+\n+  ResolveExpr::go (&expr, field.get_node_id ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "6cfe2c233b653553f25725d96a4f4d200a0617a0", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_VERIFY_ASSIGNEE\n+#define RUST_AST_VERIFY_ASSIGNEE\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class VerifyAsignee : public ResolverBase\n+{\n+public:\n+  static bool go (AST::Expr *assignee, NodeId parent)\n+  {\n+    VerifyAsignee checker (parent);\n+    assignee->accept_vis (checker);\n+    if (!checker.ok)\n+      rust_error_at (assignee->get_locus_slow (),\n+\t\t     \"invalid left-hand side of assignment\");\n+    return checker.ok;\n+  }\n+\n+  void visit (AST::ArrayIndexExpr &expr)\n+  {\n+    expr.get_array_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::FieldAccessExpr &expr)\n+  {\n+    expr.get_receiver_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::TupleIndexExpr &expr)\n+  {\n+    expr.get_tuple_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr)\n+  {\n+    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      return;\n+\n+    ok = true;\n+    // mark the assignment to the name\n+    resolver->mark_assignment_to_decl (resolved_node, parent);\n+\n+    // check is mutable\n+    if (!resolver->decl_is_mutable (resolved_node))\n+      {\n+\t// we only allow a single assignment to immutable decls\n+\tif (resolver->get_num_assignments_to_decl (resolved_node) > 1)\n+\t  rust_error_at (expr.get_locus (), \"cannot assign to immutable\");\n+      }\n+  }\n+\n+private:\n+  VerifyAsignee (NodeId parent) : ResolverBase (parent), ok (false) {}\n+\n+  bool ok;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_VERIFY_ASSIGNEE"}, {"sha": "5bc6abab30957160e0429185e09d9716199ff50a", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -209,7 +209,7 @@ class Resolver\n \n   // these will be required for type resolution passes to\n   // map back to tyty nodes\n-  std::vector<AST::TypePath *> &get_builtin_types ();\n+  std::vector<AST::Type *> &get_builtin_types ();\n \n   void push_new_name_rib (Rib *r);\n   void push_new_type_rib (Rib *r);\n@@ -232,6 +232,40 @@ class Resolver\n \n   NodeId get_global_type_node_id () { return global_type_node_id; }\n \n+  void set_unit_type_node_id (NodeId id) { unit_ty_node_id = id; }\n+  NodeId get_unit_type_node_id () { return unit_ty_node_id; }\n+\n+  void mark_decl_mutability (NodeId id, bool mut)\n+  {\n+    rust_assert (decl_mutability.find (id) == decl_mutability.end ());\n+    decl_mutability[id] = mut;\n+  }\n+\n+  bool decl_is_mutable (NodeId id) const\n+  {\n+    auto it = decl_mutability.find (id);\n+    rust_assert (it != decl_mutability.end ());\n+    return it->second;\n+  }\n+\n+  void mark_assignment_to_decl (NodeId id, NodeId assignment)\n+  {\n+    auto it = assignment_to_decl.find (id);\n+    if (it == assignment_to_decl.end ())\n+      assignment_to_decl[id] = {};\n+\n+    assignment_to_decl[id].insert (assignment);\n+  }\n+\n+  size_t get_num_assignments_to_decl (NodeId id) const\n+  {\n+    auto it = assignment_to_decl.find (id);\n+    if (it == assignment_to_decl.end ())\n+      return 0;\n+\n+    return it->second.size ();\n+  }\n+\n private:\n   Resolver ();\n \n@@ -240,12 +274,13 @@ class Resolver\n   Analysis::Mappings *mappings;\n   TypeCheckContext *tyctx;\n \n-  std::vector<AST::TypePath *> builtins;\n+  std::vector<AST::Type *> builtins;\n \n   Scope name_scope;\n   Scope type_scope;\n \n   NodeId global_type_node_id;\n+  NodeId unit_ty_node_id;\n \n   // map a AST Node to a Rib\n   std::map<NodeId, Rib *> name_ribs;\n@@ -265,6 +300,11 @@ class Resolver\n   // we need two namespaces one for names and ones for types\n   std::map<NodeId, NodeId> resolved_names;\n   std::map<NodeId, NodeId> resolved_types;\n+\n+  // map of resolved names mutability flag\n+  std::map<NodeId, bool> decl_mutability;\n+  // map of resolved names and set of assignments to the decl\n+  std::map<NodeId, std::set<NodeId> > assignment_to_decl;\n };\n \n } // namespace Resolver"}, {"sha": "7b0ccf9047e577f7e9a8141dd71cad7be80eec58", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -98,6 +98,9 @@ class Backend\n   // Get the unnamed boolean type.\n   virtual Btype *bool_type () = 0;\n \n+  // Get the Host pointer size in bits\n+  virtual int get_pointer_size () = 0;\n+\n   // Get an unnamed integer type with the given signedness and number\n   // of bits.\n   virtual Btype *integer_type (bool is_unsigned, int bits) = 0;\n@@ -112,6 +115,9 @@ class Backend\n   // Get a pointer type.\n   virtual Btype *pointer_type (Btype *to_type) = 0;\n \n+  // make type immutable\n+  virtual Btype *immutable_type (Btype *base) = 0;\n+\n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n   // is provided so that the names are available.  This should return\n@@ -254,6 +260,8 @@ class Backend\n   // Create a nil pointer expression.\n   virtual Bexpression *nil_pointer_expression () = 0;\n \n+  virtual Bexpression *unit_expression () = 0;\n+\n   // Create a reference to a variable.\n   virtual Bexpression *var_expression (Bvariable *var, Location) = 0;\n "}, {"sha": "0729b1ebcbc6cacc7046430e919c97ce471b6260", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -165,6 +165,8 @@ class Gcc_backend : public Backend\n \n   Btype *bool_type () { return this->make_type (boolean_type_node); }\n \n+  int get_pointer_size ();\n+\n   Btype *integer_type (bool, int);\n \n   Btype *float_type (int);\n@@ -173,6 +175,8 @@ class Gcc_backend : public Backend\n \n   Btype *pointer_type (Btype *);\n \n+  Btype *immutable_type (Btype *);\n+\n   Btype *function_type (const Btyped_identifier &,\n \t\t\tconst std::vector<Btyped_identifier> &,\n \t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n@@ -225,6 +229,8 @@ class Gcc_backend : public Backend\n     return this->make_expression (null_pointer_node);\n   }\n \n+  Bexpression *unit_expression () { return this->make_expression (void_node); }\n+\n   Bexpression *var_expression (Bvariable *var, Location);\n \n   Bexpression *indirect_expression (Btype *, Bexpression *expr,\n@@ -754,6 +760,12 @@ Gcc_backend::Gcc_backend ()\n \n // Get an unnamed integer type.\n \n+int\n+Gcc_backend::get_pointer_size ()\n+{\n+  return POINTER_SIZE;\n+}\n+\n Btype *\n Gcc_backend::integer_type (bool is_unsigned, int bits)\n {\n@@ -846,6 +858,18 @@ Gcc_backend::pointer_type (Btype *to_type)\n   return this->make_type (type);\n }\n \n+// Get immutable type\n+\n+Btype *\n+Gcc_backend::immutable_type (Btype *base)\n+{\n+  tree type_tree = base->get_tree ();\n+  if (type_tree == error_mark_node)\n+    return this->error_type ();\n+  tree constified = build_qualified_type (type_tree, TYPE_QUAL_CONST);\n+  return this->make_type (constified);\n+}\n+\n // Make a function type.\n \n Btype *"}, {"sha": "afc238b2d077e647b1f4ff77c6a7c44727d7dff1", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -34,6 +34,7 @@\n #include \"rust-ast-resolve.h\"\n #include \"rust-ast-lower.h\"\n #include \"rust-hir-type-check.h\"\n+#include \"rust-tycheck-dump.h\"\n #include \"rust-compile.h\"\n \n extern Linemap *\n@@ -548,6 +549,10 @@ Session::parse_file (const char *filename)\n   // type resolve\n   type_resolution (hir);\n \n+  // FIXME this needs an option of itself\n+  auto buf = Resolver::TypeResolverDump::go (hir);\n+  fprintf (stderr, \"%s\\n\", buf.c_str ());\n+\n   if (saw_errors ())\n     return;\n "}, {"sha": "d62e6763c1df67946b4c501933fdeb10c1b33f0a", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -20,6 +20,7 @@\n #ifndef RUST_SYSTEM_H\n #define RUST_SYSTEM_H\n \n+#define INCLUDE_ALGORITHM\n #include \"config.h\"\n \n /* Define this so that inttypes.h defines the PRI?64 macros even\n@@ -30,7 +31,6 @@\n \n // These must be included before the #poison declarations in system.h.\n \n-#include <algorithm>\n #include <string>\n #include <list>\n #include <map>"}, {"sha": "78f0d0d2ce32ab7df6a6bd3b32a1a70443f4cce2", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 470, "deletions": 62, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -23,7 +23,6 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n-#include \"rust-tyty-resolver.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n \n namespace Rust {\n@@ -36,20 +35,121 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     TypeCheckExpr resolver (is_final_expr);\n     expr->accept_vis (resolver);\n-    if (resolver.infered != nullptr)\n-      resolver.context->insert_type (expr->get_mappings ().get_hirid (),\n-\t\t\t\t     resolver.infered);\n+\n+    if (resolver.infered == nullptr)\n+      {\n+\tresolver.infered\n+\t  = new TyTy::UnitType (expr->get_mappings ().get_hirid ());\n+      }\n+\n+    auto ref = expr->get_mappings ().get_hirid ();\n+    resolver.infered->set_ref (ref);\n+    resolver.context->insert_type (expr->get_mappings (), resolver.infered);\n \n     return resolver.infered;\n   }\n \n+  void visit (HIR::TupleIndexExpr &expr)\n+  {\n+    auto resolved = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get ());\n+    if (resolved == nullptr)\n+      {\n+\trust_error_at (expr.get_tuple_expr ()->get_locus_slow (),\n+\t\t       \"failed to resolve TupleIndexExpr receiver\");\n+\treturn;\n+      }\n+\n+    bool is_valid_type = resolved->get_kind () == TyTy::TypeKind::ADT\n+\t\t\t || resolved->get_kind () == TyTy::TypeKind::TUPLE;\n+    if (!is_valid_type)\n+      {\n+\trust_error_at (expr.get_tuple_expr ()->get_locus_slow (),\n+\t\t       \"Expected Tuple or ADT got: %s\",\n+\t\t       resolved->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    if (resolved->get_kind () == TyTy::TypeKind::TUPLE)\n+      {\n+\tTyTy::TupleType *tuple = (TyTy::TupleType *) resolved;\n+\tTupleIndex index = expr.get_tuple_index ();\n+\tif ((size_t) index >= tuple->num_fields ())\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"unknown field at index %i\",\n+\t\t\t   index);\n+\t    return;\n+\t  }\n+\n+\tauto field_tyty = tuple->get_field ((size_t) index);\n+\tif (field_tyty == nullptr)\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"failed to lookup field type at index %i\", index);\n+\t    return;\n+\t  }\n+\n+\tinfered = field_tyty;\n+\treturn;\n+      }\n+\n+    TyTy::ADTType *adt = (TyTy::ADTType *) resolved;\n+    TupleIndex index = expr.get_tuple_index ();\n+    if ((size_t) index >= adt->num_fields ())\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n+\treturn;\n+      }\n+\n+    auto field_tyty = adt->get_field ((size_t) index);\n+    if (field_tyty == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to lookup field type at index %i\", index);\n+\treturn;\n+      }\n+\n+    infered = field_tyty->get_field_type ();\n+  }\n+\n+  void visit (HIR::TupleExpr &expr)\n+  {\n+    if (expr.is_unit ())\n+      {\n+\tauto unit_node_id = resolver->get_unit_type_node_id ();\n+\tif (!context->lookup_builtin (unit_node_id, &infered))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"failed to lookup builtin unit type\");\n+\t  }\n+\treturn;\n+      }\n+\n+    std::vector<HirId> fields;\n+    for (auto &elem : expr.get_tuple_elems ())\n+      {\n+\tauto field_ty = TypeCheckExpr::Resolve (elem.get ());\n+\tfields.push_back (field_ty->get_ref ());\n+      }\n+    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (), fields);\n+  }\n+\n   void visit (HIR::ReturnExpr &expr)\n   {\n-    auto ret = context->peek_return_type ();\n-    rust_assert (ret != nullptr);\n+    auto fn_return_tyty = context->peek_return_type ();\n+    rust_assert (fn_return_tyty != nullptr);\n \n     auto expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n-    infered = ret->combine (expr_ty);\n+    if (expr_ty == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to resolve type for ReturnExpr\");\n+\treturn;\n+      }\n+\n+    infered = fn_return_tyty->combine (expr_ty);\n+    fn_return_tyty->append_reference (expr_ty->get_ref ());\n+    for (auto &ref : infered->get_combined_refs ())\n+      fn_return_tyty->append_reference (ref);\n   }\n \n   void visit (HIR::CallExpr &expr)\n@@ -58,11 +158,29 @@ class TypeCheckExpr : public TypeCheckBase\n     auto fn_node_id = fn->get_mappings ().get_nodeid ();\n \n     // then lookup the reference_node_id\n-    NodeId ref_node_id;\n-    if (!resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n+      {\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+    else if (!resolver->lookup_resolved_type (fn_node_id, &ref_node_id))\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       \"Failed to lookup type reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -72,7 +190,8 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref_node_id, &ref))\n       {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure for node %u\",\n+\t\t       ref_node_id);\n \treturn;\n       }\n \n@@ -87,7 +206,14 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    infered = TyTy::TypeCheckCallExpr::go (lookup, expr);\n+    infered = TyTy::TypeCheckCallExpr::go (lookup, expr, context);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n+\treturn;\n+      }\n+\n+    infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::AssignmentExpr &expr)\n@@ -96,38 +222,90 @@ class TypeCheckExpr : public TypeCheckBase\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     infered = lhs->combine (rhs);\n-    // need to overrite the lhs type with this combination\n-    context->insert_type (expr.get_lhs ()->get_mappings ().get_hirid (),\n-\t\t\t  infered);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failure in TypeInference AssignmentExpr\");\n+\treturn;\n+      }\n+\n+    // in the case of declare first for an ADT Type:\n+    //\n+    // let a;\n+    // a = Foo{..}\n+    // let b = a.field;\n+    //\n+    // The lhs will have a TyTy of INFER and so when the declaration is\n+    // referenced it will still have an unknown type so we will fail to resolve\n+    // FieldAccessExpr\n+\n+    NodeId ast_node_id = expr.get_lhs ()->get_mappings ().get_nodeid ();\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      return;\n+\n+    Definition def;\n+    if (!resolver->lookup_definition (ref_node_id, &def))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"assignment infer - unknown reference\");\n+\treturn;\n+      }\n+\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       def.parent, &ref))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"assignment infer - reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // FIXME free the old one\n+    context->insert_type (\n+      Analysis::NodeMapping (expr.get_lhs ()->get_mappings ().get_crate_num (),\n+\t\t\t     ref_node_id, ref, UNKNOWN_LOCAL_DEFID),\n+      infered->clone ());\n   }\n \n   void visit (HIR::IdentifierExpr &expr)\n   {\n     NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n \n     // then lookup the reference_node_id\n-    NodeId ref_node_id;\n-    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       \"Failed to lookup type reference for node: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n \n-    // these ref_node_ids will resolve to a pattern declaration but we are\n-    // interested in the definition that this refers to get the parent id\n-    Definition def;\n-    if (!resolver->lookup_definition (ref_node_id, &def))\n+    if (ref_node_id == UNKNOWN_NODEID)\n       {\n-\trust_error_at (expr.get_locus (), \"unknown reference\");\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n \n     // node back to HIR\n     HirId ref;\n     if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       def.parent, &ref))\n+\t\t\t\t       ref_node_id, &ref))\n       {\n \trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n \treturn;\n@@ -143,8 +321,9 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    // FIXME this needs to be cloned for memory management later on\n-    infered = lookup;\n+    lookup->append_reference (lookup->get_ref ());\n+    infered = lookup->clone ();\n+    infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::LiteralExpr &expr)\n@@ -198,7 +377,10 @@ class TypeCheckExpr : public TypeCheckBase\n \t      break;\n \n \t    default:\n-\t      ok = context->lookup_builtin (\"i32\", &infered);\n+\t      ok = true;\n+\t      infered = new TyTy::InferType (\n+\t\texpr.get_mappings ().get_hirid (),\n+\t\tTyTy::InferType::InferTypeKind::INTEGRAL);\n \t      break;\n \t    }\n \t  rust_assert (ok);\n@@ -216,8 +398,12 @@ class TypeCheckExpr : public TypeCheckBase\n \t    case CORETYPE_F64:\n \t      ok = context->lookup_builtin (\"f64\", &infered);\n \t      break;\n+\n \t    default:\n-\t      ok = context->lookup_builtin (\"f32\", &infered);\n+\t      ok = true;\n+\t      infered\n+\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       TyTy::InferType::InferTypeKind::FLOAT);\n \t      break;\n \t    }\n \t  rust_assert (ok);\n@@ -234,94 +420,281 @@ class TypeCheckExpr : public TypeCheckBase\n \tgcc_unreachable ();\n \tbreak;\n       }\n+\n+    infered = infered->clone ();\n   }\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr)\n   {\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+    auto combined = lhs->combine (rhs);\n \n-    infered = lhs->combine (rhs);\n+    // https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators\n+    switch (expr.get_expr_type ())\n+      {\n+\t// integers or floats\n+      case HIR::ArithmeticOrLogicalExpr::ADD:\n+      case HIR::ArithmeticOrLogicalExpr::SUBTRACT:\n+      case HIR::ArithmeticOrLogicalExpr::MULTIPLY:\n+      case HIR::ArithmeticOrLogicalExpr::DIVIDE:\n+\tcase HIR::ArithmeticOrLogicalExpr::MODULUS: {\n+\t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::FLOAT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::INTEGRAL))\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::FLOAT));\n+\t  if (!valid)\n+\t    {\n+\t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n+\t\t\t     combined->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\t// integers or bools\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_AND:\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_OR:\n+\tcase HIR::ArithmeticOrLogicalExpr::BITWISE_XOR: {\n+\t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::BOOL)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::INTEGRAL));\n+\t  if (!valid)\n+\t    {\n+\t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n+\t\t\t     combined->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\t// integers only\n+      case HIR::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n+\tcase HIR::ArithmeticOrLogicalExpr::RIGHT_SHIFT: {\n+\t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::INTEGRAL));\n+\t  if (!valid)\n+\t    {\n+\t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n+\t\t\t     combined->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    infered = combined;\n+    infered->append_reference (lhs->get_ref ());\n+    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::ComparisonExpr &expr)\n   {\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n-    infered = lhs->combine (rhs);\n-    // FIXME this will need to turn into bool\n+    auto result = lhs->combine (rhs);\n+    if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    // we expect this to be\n+    infered = new TyTy::BoolType (expr.get_mappings ().get_hirid ());\n+    infered->append_reference (lhs->get_ref ());\n+    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::LazyBooleanExpr &expr)\n   {\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n+    // we expect the lhs and rhs must be bools at this point\n+    TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n+    lhs = elhs.combine (lhs);\n+    if (lhs == nullptr || lhs->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    TyTy::BoolType rlhs (expr.get_mappings ().get_hirid ());\n+    rhs = elhs.combine (rhs);\n+    if (lhs == nullptr || lhs->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n     infered = lhs->combine (rhs);\n-    // FIXME this will need to turn into bool\n+    infered->append_reference (lhs->get_ref ());\n+    infered->append_reference (rhs->get_ref ());\n+  }\n+\n+  void visit (HIR::NegationExpr &expr)\n+  {\n+    auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n+\n+    // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n+    switch (expr.get_negation_type ())\n+      {\n+\tcase HIR::NegationExpr::NegationType::NEGATE: {\n+\t  bool valid\n+\t    = (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::FLOAT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t      == TyTy::InferType::INTEGRAL))\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t      == TyTy::InferType::FLOAT));\n+\t  if (!valid)\n+\t    {\n+\t      rust_error_at (expr.get_locus (), \"cannot apply unary - to %s\",\n+\t\t\t     negated_expr_ty->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase HIR::NegationExpr::NegationType::NOT: {\n+\t  bool valid\n+\t    = (negated_expr_ty->get_kind () == TyTy::TypeKind::BOOL)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t      == TyTy::InferType::INTEGRAL));\n+\t  if (!valid)\n+\t    {\n+\t      rust_error_at (expr.get_locus (), \"cannot apply unary ! to %s\",\n+\t\t\t     negated_expr_ty->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    infered = negated_expr_ty->clone ();\n+    infered->append_reference (negated_expr_ty->get_ref ());\n   }\n \n   void visit (HIR::IfExpr &expr)\n   {\n     TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    TypeCheckExpr::Resolve (expr.get_if_block ());\n+    auto blk_expr = TypeCheckExpr::Resolve (expr.get_if_block ());\n \n-    // if without else always resolves to unit type\n-    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+    if (is_final_expr\n+\t&& context->peek_return_type ()->get_kind () != TyTy::TypeKind::UNIT)\n+      {\n+\tauto expected_ty = context->peek_return_type ();\n+\tinfered = expected_ty->combine (blk_expr);\n+      }\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    // this must combine to what the type is expected\n-    // this might be a parameter or the last expr in an if + else in a BlockExpr\n-    // then it must resolve to fn return type\n-    // else its a unit-type\n-    infered = is_final_expr\n-\t\t? context->peek_return_type ()\n-\t\t: new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+    // check and resolve all types in the conditional var\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+\n+    auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n+    auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_else_block ());\n+\n+    TyTy::TyBase *if_block_tyty = nullptr;\n+    if (expr.get_if_block ()->has_expr ())\n+      if_block_tyty\n+\t= TypeCheckExpr::Resolve (expr.get_if_block ()->expr.get ());\n+    else\n+      if_block_tyty = if_blk_resolved;\n \n-    TypeCheckExpr::Resolve (expr.get_if_condition (), is_final_expr);\n-    auto if_blk_ty = TypeCheckExpr::Resolve (expr.get_if_block ());\n-    auto else_blk_ty = TypeCheckExpr::Resolve (expr.get_else_block ());\n+    TyTy::TyBase *else_block_tyty = nullptr;\n+    if (expr.get_else_block ()->has_expr ())\n+      else_block_tyty\n+\t= TypeCheckExpr::Resolve (expr.get_else_block ()->expr.get ());\n+    else\n+      else_block_tyty = else_blk_resolved;\n \n-    if (is_final_expr)\n+    if (context->peek_return_type ()->get_kind () != TyTy::TypeKind::UNIT)\n       {\n-\tinfered = infered->combine (if_blk_ty);\n-\tinfered = infered->combine (else_blk_ty);\n+\t// this must combine to what the type is expected\n+\t// this might be a parameter or the last expr in an if + else in a\n+\t// BlockExpr then it must resolve to fn return type else its a unit-type\n+\tauto expected_ty\n+\t  = is_final_expr\n+\t      ? context->peek_return_type ()\n+\t      : new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+\n+\tauto if_blk_combined = expected_ty->combine (if_block_tyty);\n+\tauto else_blk_combined = expected_ty->combine (else_block_tyty);\n+\n+\tinfered = if_blk_combined->combine (else_blk_combined);\n       }\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n     TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    TypeCheckExpr::Resolve (expr.get_if_block ());\n-    TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n+    auto if_blk = TypeCheckExpr::Resolve (expr.get_if_block ());\n+    auto elif_blk = TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n \n-    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+    if (is_final_expr\n+\t&& context->peek_return_type ()->get_kind () != TyTy::TypeKind::UNIT)\n+      {\n+\tauto expected_ty = context->peek_return_type ();\n+\n+\tinfered = expected_ty->combine (if_blk);\n+\tinfered = infered->combine (elif_blk);\n+      }\n   }\n \n   void visit (HIR::BlockExpr &expr);\n \n   void visit (HIR::ArrayIndexExpr &expr)\n   {\n-    // FIXME this should be size type\n-    TyTy::IntType size_ty (expr.get_index_expr ()->get_mappings ().get_hirid (),\n-\t\t\t   TyTy::IntType::I32);\n-    auto resolved\n-      = size_ty.combine (TypeCheckExpr::Resolve (expr.get_index_expr ()));\n-    rust_assert (resolved != nullptr);\n+    TyTy::TyBase *size_ty;\n+    if (!context->lookup_builtin (\"usize\", &size_ty))\n+      {\n+\trust_error_at (\n+\t  expr.get_locus (),\n+\t  \"Failure looking up size type for index in ArrayIndexExpr\");\n+\treturn;\n+      }\n+\n+    auto resolved_index_expr\n+      = size_ty->combine (TypeCheckExpr::Resolve (expr.get_index_expr ()));\n+    if (resolved_index_expr == nullptr)\n+      {\n+\trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t       \"Type Resolver failure in Index for ArrayIndexExpr\");\n+\treturn;\n+      }\n+    context->insert_type (expr.get_index_expr ()->get_mappings (),\n+\t\t\t  resolved_index_expr);\n \n+    // resolve the array reference\n     expr.get_array_expr ()->accept_vis (*this);\n-    if (infered->get_kind () != TyTy::TypeKind::ARRAY)\n+    if (infered == nullptr)\n       {\n-\trust_fatal_error (expr.get_array_expr ()->get_locus_slow (),\n-\t\t\t  \"expected an ArrayType for index expression\");\n+\trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t       \"failed to resolve array reference expression\");\n+\treturn;\n+      }\n+    else if (infered->get_kind () != TyTy::TypeKind::ARRAY)\n+      {\n+\trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t       \"expected an ArrayType got [%s]\",\n+\t\t       infered->as_string ().c_str ());\n+\tinfered = nullptr;\n \treturn;\n       }\n \n-    // extract the element type out now from the base type\n-    infered = TyTyExtractorArray::ExtractElementTypeFromArray (infered);\n+    TyTy::ArrayType *array_type = (TyTy::ArrayType *) infered;\n+    infered = array_type->get_type ()->clone ();\n   }\n \n   void visit (HIR::ArrayExpr &expr)\n@@ -349,6 +722,9 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tinfered_array_elems = infered_array_elems->combine (types.at (i));\n       }\n+\n+    for (auto &elem : types)\n+      infered_array_elems->append_reference (elem->get_ref ());\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems)\n@@ -361,6 +737,38 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = TypeCheckStructExpr::Resolve (&struct_expr);\n   }\n \n+  void visit (HIR::GroupedExpr &expr)\n+  {\n+    infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n+  }\n+\n+  void visit (HIR::FieldAccessExpr &expr)\n+  {\n+    auto struct_base\n+      = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n+\n+    bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n+    if (!is_valid_type)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"expected ADT or Tuple Type got: [%s]\",\n+\t\t       struct_base->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    TyTy::ADTType *adt = (TyTy::ADTType *) struct_base;\n+    auto resolved = adt->get_field (expr.get_field_name ());\n+    if (resolved == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown field [%s] for type [%s]\",\n+\t\t       expr.get_field_name ().c_str (),\n+\t\t       adt->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    infered = resolved->get_field_type ();\n+  }\n+\n private:\n   TypeCheckExpr (bool is_final_expr)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),"}, {"sha": "d7f9af1bd5f449c7d34703e6b066e04bc777f9a4", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -24,44 +24,10 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-stmt.h\"\n #include \"rust-tyty-visitor.h\"\n-#include \"rust-tyty-resolver.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class ResolveFnType : public TyTy::TyVisitor\n-{\n-public:\n-  ResolveFnType (TyTy::TyBase *base) : base (base), state (nullptr) {}\n-\n-  TyTy::TyBase *go ()\n-  {\n-    base->accept_vis (*this);\n-    if (state == nullptr)\n-      gcc_unreachable ();\n-\n-    return state;\n-  }\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ParamType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnType &type) override { state = type.return_type (); }\n-\n-private:\n-  TyTy::TyBase *base;\n-  TyTy::TyBase *state;\n-};\n-\n class TypeCheckItem : public TypeCheckBase\n {\n public:\n@@ -73,18 +39,43 @@ class TypeCheckItem : public TypeCheckBase\n \n   void visit (HIR::Function &function)\n   {\n-    TyTy::TyBase *fnType;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &fnType))\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n       {\n \trust_error_at (function.locus, \"failed to lookup function type\");\n \treturn;\n       }\n \n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (function.get_locus (),\n+\t\t       \"found invalid type for function [%s]\",\n+\t\t       lookup->as_string ().c_str ());\n+\treturn;\n+      }\n+\n     // need to get the return type from this\n-    ResolveFnType resolve_fn_type (fnType);\n-    context->push_return_type (resolve_fn_type.go ());\n+    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n+    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    context->push_return_type (expected_ret_tyty);\n \n     TypeCheckExpr::Resolve (function.function_body.get ());\n+    if (function.function_body->has_expr ())\n+      {\n+\tauto resolved\n+\t  = TypeCheckExpr::Resolve (function.function_body->expr.get ());\n+\n+\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n+\tif (ret_resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.function_body->expr->get_locus_slow (),\n+\t\t\t   \"failed to resolve final expression\");\n+\t    return;\n+\t  }\n+\n+\tcontext->peek_return_type ()->append_reference (\n+\t  ret_resolved->get_ref ());\n+      }\n \n     context->pop_return_type ();\n   }"}, {"sha": "99be0b72d6cdc12dc3c27ee4557504802f9e5e05", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -49,10 +49,19 @@ class TypeCheckStmt : public TypeCheckBase\n \n   void visit (HIR::LetStmt &stmt)\n   {\n+    infered = new TyTy::UnitType (stmt.get_mappings ().get_hirid ());\n+\n     TyTy::TyBase *init_expr_ty = nullptr;\n     if (stmt.has_init_expr ())\n-      init_expr_ty\n-\t= TypeCheckExpr::Resolve (stmt.get_init_expr (), is_final_stmt);\n+      {\n+\tinit_expr_ty\n+\t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), is_final_stmt);\n+\n+\tinit_expr_ty = init_expr_ty->clone ();\n+\tauto ref = init_expr_ty->get_ref ();\n+\tinit_expr_ty->set_ref (stmt.get_mappings ().get_hirid ());\n+\tinit_expr_ty->append_reference (ref);\n+      }\n \n     TyTy::TyBase *specified_ty = nullptr;\n     if (stmt.has_type ())\n@@ -69,35 +78,34 @@ class TypeCheckStmt : public TypeCheckBase\n \t    return;\n \t  }\n \n-\tcontext->insert_type (stmt.get_mappings ().get_hirid (), combined);\n+\tcontext->insert_type (stmt.get_mappings (), combined);\n       }\n     else\n       {\n \t// let x:i32;\n \tif (specified_ty != nullptr)\n \t  {\n-\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t  specified_ty);\n+\t    context->insert_type (stmt.get_mappings (), specified_ty);\n \t  }\n \t// let x = 123;\n \telse if (init_expr_ty != nullptr)\n \t  {\n-\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t  init_expr_ty);\n+\t    context->insert_type (stmt.get_mappings (), init_expr_ty);\n \t  }\n \t// let x;\n \telse\n \t  {\n-\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t  new TyTy::InferType (\n-\t\t\t\t    stmt.get_mappings ().get_hirid ()));\n+\t    context->insert_type (\n+\t      stmt.get_mappings (),\n+\t      new TyTy::InferType (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t   TyTy::InferType::InferTypeKind::GENERAL));\n \t  }\n       }\n   }\n \n private:\n   TypeCheckStmt (bool is_final_stmt)\n-    : TypeCheckBase (), is_final_stmt (is_final_stmt)\n+    : TypeCheckBase (), infered (nullptr), is_final_stmt (is_final_stmt)\n   {}\n \n   TyTy::TyBase *infered;"}, {"sha": "98db278ab82645603689bc5e8a0e3fef4d5305fa", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -44,6 +44,10 @@ class TypeCheckStructExpr : public TypeCheckBase\n \n   void visit (HIR::StructExprFieldIdentifierValue &field);\n \n+  void visit (HIR::StructExprFieldIndexValue &field);\n+\n+  void visit (HIR::StructExprFieldIdentifier &field);\n+\n private:\n   TypeCheckStructExpr ()\n     : TypeCheckBase (), resolved (nullptr), struct_path_resolved (nullptr)\n@@ -53,6 +57,7 @@ class TypeCheckStructExpr : public TypeCheckBase\n   TyTy::ADTType *struct_path_resolved;\n   TyTy::TyBase *resolved_field;\n   std::set<std::string> fields_assigned;\n+  std::map<size_t, HIR::StructExprField *> adtFieldIndexToField;\n };\n \n } // namespace Resolver"}, {"sha": "52b6cded787541c0f8c59ca632ab514171dec90c", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -37,6 +37,30 @@ class TypeCheckTopLevel : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  void visit (HIR::TupleStruct &struct_decl)\n+  {\n+    std::vector<TyTy::StructFieldType *> fields;\n+\n+    size_t idx = 0;\n+    struct_decl.iterate ([&] (HIR::TupleField &field) mutable -> bool {\n+      TyTy::TyBase *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+      return true;\n+    });\n+\n+    TyTy::TyBase *type\n+      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t   struct_decl.get_identifier (), std::move (fields));\n+\n+    context->insert_type (struct_decl.get_mappings (), type);\n+  }\n+\n   void visit (HIR::StructStruct &struct_decl)\n   {\n     std::vector<TyTy::StructFieldType *> fields;\n@@ -47,34 +71,31 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n \t\t\t\t     field.get_field_name (), field_type);\n       fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings ().get_hirid (),\n-\t\t\t    ty_field->get_field_type ());\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n       return true;\n     });\n \n     TyTy::TyBase *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   struct_decl.get_identifier (), std::move (fields));\n \n-    context->insert_type (struct_decl.get_mappings ().get_hirid (), type);\n+    context->insert_type (struct_decl.get_mappings (), type);\n   }\n \n   void visit (HIR::StaticItem &var)\n   {\n     TyTy::TyBase *type = TypeCheckType::Resolve (var.get_type ());\n     TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n \n-    context->insert_type (var.get_mappings ().get_hirid (),\n-\t\t\t  type->combine (expr_type));\n+    context->insert_type (var.get_mappings (), type->combine (expr_type));\n   }\n \n   void visit (HIR::ConstantItem &constant)\n   {\n     TyTy::TyBase *type = TypeCheckType::Resolve (constant.get_type ());\n     TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n \n-    context->insert_type (constant.get_mappings ().get_hirid (),\n-\t\t\t  type->combine (expr_type));\n+    context->insert_type (constant.get_mappings (), type->combine (expr_type));\n   }\n \n   void visit (HIR::Function &function)\n@@ -83,24 +104,34 @@ class TypeCheckTopLevel : public TypeCheckBase\n     if (!function.has_function_return_type ())\n       ret_type = new TyTy::UnitType (function.get_mappings ().get_hirid ());\n     else\n-      ret_type = TypeCheckType::Resolve (function.return_type.get ());\n+      {\n+\tauto resolved = TypeCheckType::Resolve (function.return_type.get ());\n+\tif (resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_locus (),\n+\t\t\t   \"failed to resolve return type\");\n+\t    return;\n+\t  }\n+\n+\tret_type = resolved->clone ();\n+\tret_type->set_ref (function.return_type->get_mappings ().get_hirid ());\n+      }\n \n-    std::vector<TyTy::ParamType *> params;\n+    std::vector<std::pair<HIR::Pattern *, TyTy::TyBase *> > params;\n     for (auto &param : function.function_params)\n       {\n \t// get the name as well required for later on\n-\tauto param_type = TypeCheckType::Resolve (param.type.get ());\n-\tauto param_tyty\n-\t  = new TyTy::ParamType (param.get_mappings ()->get_hirid (),\n-\t\t\t\t param.param_name->as_string (), param_type);\n-\tparams.push_back (param_tyty);\n+\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::TyBase *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n \n-\tcontext->insert_type (param.get_mappings ()->get_hirid (), param_tyty);\n+\tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n \t\t\t\t    params, ret_type);\n-    context->insert_type (function.get_mappings ().get_hirid (), fnType);\n+    context->insert_type (function.get_mappings (), fnType);\n   }\n \n private:"}, {"sha": "28948991081aec8658f153b6562c52fa23ff1ad7", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -40,11 +40,12 @@ class ArrayCapacityConstant : public TypeCheckBase\n \n   void visit (HIR::LiteralExpr &expr)\n   {\n+    auto literal_value = expr.get_literal ();\n     switch (expr.get_lit_type ())\n       {\n \tcase HIR::Literal::LitType::INT: {\n \t  ok = true;\n-\t  std::stringstream ss (expr.as_string ());\n+\t  std::stringstream ss (literal_value->as_string ());\n \t  ss >> result;\n \t}\n \tbreak;\n@@ -70,18 +71,68 @@ class TypeCheckType : public TypeCheckBase\n     type->accept_vis (resolver);\n \n     if (resolver.translated != nullptr)\n-      resolver.context->insert_type (type->get_mappings ().get_hirid (),\n-\t\t\t\t     resolver.translated);\n+      {\n+\tresolver.context->insert_type (type->get_mappings (),\n+\t\t\t\t       resolver.translated);\n+      }\n \n     return resolver.translated;\n   }\n \n-  void visit (HIR::TypePath &path)\n+  void visit (HIR::BareFunctionType &fntype)\n   {\n-    // check if this is already defined or not\n-    if (context->lookup_type (path.get_mappings ().get_hirid (), &translated))\n-      return;\n+    TyTy::TyBase *return_type\n+      = fntype.has_return_type ()\n+\t  ? TypeCheckType::Resolve (fntype.get_return_type ().get ())\n+\t  : new TyTy::UnitType (fntype.get_mappings ().get_hirid ());\n+\n+    std::vector<std::pair<HIR::Pattern *, TyTy::TyBase *> > params;\n+    for (auto &param : fntype.get_function_params ())\n+      {\n+\tstd::unique_ptr<HIR::Pattern> to_bind;\n+\n+\tbool is_ref = false;\n+\tbool is_mut = false;\n+\n+\tHIR::Pattern *pattern\n+\t  = new HIR::IdentifierPattern (param.get_name (), param.get_locus (),\n+\t\t\t\t\tis_ref, is_mut, std::move (to_bind));\n \n+\tTyTy::TyBase *ptype = TypeCheckType::Resolve (param.get_type ().get ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::TyBase *> (pattern, ptype));\n+      }\n+\n+    translated = new TyTy::FnType (fntype.get_mappings ().get_hirid (),\n+\t\t\t\t   std::move (params), return_type);\n+  }\n+\n+  void visit (HIR::TupleType &tuple)\n+  {\n+    if (tuple.is_unit_type ())\n+      {\n+\tauto unit_node_id = resolver->get_unit_type_node_id ();\n+\tif (!context->lookup_builtin (unit_node_id, &translated))\n+\t  {\n+\t    rust_error_at (tuple.get_locus (),\n+\t\t\t   \"failed to lookup builtin unit type\");\n+\t  }\n+\treturn;\n+      }\n+\n+    std::vector<HirId> fields;\n+    for (auto &elem : tuple.get_elems ())\n+      {\n+\tauto field_ty = TypeCheckType::Resolve (elem.get ());\n+\tfields.push_back (field_ty->get_ref ());\n+      }\n+\n+    translated\n+      = new TyTy::TupleType (tuple.get_mappings ().get_hirid (), fields);\n+  }\n+\n+  void visit (HIR::TypePath &path)\n+  {\n     // lookup the Node this resolves to\n     NodeId ref;\n     if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n@@ -98,12 +149,13 @@ class TypeCheckType : public TypeCheckBase\n       {\n \t// we got an HIR node\n \tif (context->lookup_type (hir_lookup, &translated))\n-\t  return;\n+\t  {\n+\t    translated = translated->clone ();\n+\t    auto ref = path.get_mappings ().get_hirid ();\n+\t    translated->set_ref (ref);\n+\t    return;\n+\t  }\n       }\n-\n-    // this might be a struct type (TyTy::ADT) reference\n-    // TODO\n-    printf (\"UNREACHABLE %s\\n\", path.as_string ().c_str ());\n     gcc_unreachable ();\n   }\n "}, {"sha": "cf3a84639051a4826611e6d979d5501489c5f4b2", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 226, "deletions": 37, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -34,6 +34,54 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     TypeCheckItem::Resolve (it->get ());\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = TypeCheckContext::get ();\n+\n+  context->iterate ([&] (HirId id, TyTy::TyBase *ty) mutable -> bool {\n+    // nothing to do\n+    if (ty->get_kind () != TyTy::TypeKind::INFER)\n+      return true;\n+\n+    TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n+    switch (infer_var->get_infer_kind ())\n+      {\n+      case TyTy::InferType::GENERAL:\n+\trust_error_at (mappings->lookup_location (id),\n+\t\t       \"unable to determine type: %u\", id);\n+\tbreak;\n+\n+\tcase TyTy::InferType::INTEGRAL: {\n+\t  TyTy::TyBase *default_integer;\n+\t  bool ok = context->lookup_builtin (\"i32\", &default_integer);\n+\t  rust_assert (ok);\n+\n+\t  auto result = ty->combine (default_integer);\n+\t  result->set_ref (id);\n+\t  context->insert_type (\n+\t    Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID),\n+\t    result);\n+\t}\n+\tbreak;\n+\n+\tcase TyTy::InferType::FLOAT: {\n+\t  TyTy::TyBase *default_float;\n+\t  bool ok = context->lookup_builtin (\"f32\", &default_float);\n+\t  rust_assert (ok);\n+\n+\t  auto result = ty->combine (default_float);\n+\t  result->set_ref (id);\n+\t  context->insert_type (\n+\t    Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID),\n+\t    result);\n+\t}\n+\tbreak;\n+      }\n+\n+    return true;\n+  });\n }\n \n // RUST_HIR_TYPE_CHECK_EXPR\n@@ -47,7 +95,13 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     bool is_final_stmt = expr.is_final_stmt (s);\n     bool is_final_expr = is_final_stmt && !expr.has_expr ();\n \n-    auto infered = TypeCheckStmt::Resolve (s, is_final_stmt);\n+    auto infered = TypeCheckStmt::Resolve (s, is_final_expr);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (s->get_locus_slow (), \"failure to resolve type\");\n+\treturn false;\n+      }\n+\n     if (is_final_expr)\n       {\n \tdelete block_tyty;\n@@ -57,27 +111,21 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     return true;\n   });\n \n-  if (expr.has_expr ())\n-    {\n-      auto tail_tyty = TypeCheckExpr::Resolve (expr.expr.get (), true);\n-\n-      delete block_tyty;\n-      block_tyty = tail_tyty;\n-    }\n+  // tail expression must be checked as part of the caller since\n+  // the result of this is very dependant on what we expect it to be\n \n   // now that the stmts have been resolved we must resolve the block of locals\n   // and make sure the variables have been resolved\n-  auto body_mappings = expr.get_mappings ();\n-  Rib *rib = nullptr;\n-  if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"failed to lookup locals per block\");\n-      return;\n-    }\n-\n-  TyTyResolver::Resolve (rib, mappings, resolver, context);\n-\n-  infered = block_tyty;\n+  // auto body_mappings = expr.get_mappings ();\n+  // Rib *rib = nullptr;\n+  // if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n+  //   {\n+  //     rust_fatal_error (expr.get_locus (), \"failed to lookup locals per\n+  //     block\"); return;\n+  //   }\n+  // TyTyResolver::Resolve (rib, mappings, resolver, context);\n+\n+  infered = block_tyty->clone ();\n }\n \n // RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n@@ -93,42 +141,117 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n       return;\n     }\n \n+  resolved = struct_path_resolved;\n+  if (struct_expr.has_struct_base ())\n+    {\n+      TyTy::TyBase *base_resolved\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n+      resolved = struct_path_resolved->combine (base_resolved);\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_fatal_error (\n+\t    struct_expr.struct_base->base_struct->get_locus_slow (),\n+\t    \"incompatible types for base struct reference\");\n+\t  return;\n+\t}\n+    }\n+\n+  bool ok = true;\n   struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n     resolved_field = nullptr;\n     field->accept_vis (*this);\n     if (resolved_field == nullptr)\n       {\n \trust_fatal_error (field->get_locus (),\n \t\t\t  \"failed to resolve type for field\");\n+\tok = false;\n \treturn false;\n       }\n \n-    context->insert_type (field->get_mappings ().get_hirid (), resolved_field);\n+    context->insert_type (field->get_mappings (), resolved_field);\n     return true;\n   });\n \n-  TyTy::TyBase *expr_type = struct_path_resolved;\n-  if (struct_expr.has_struct_base ())\n+  // something failed setting up the fields\n+  if (!ok)\n+    return;\n+\n+  // check the arguments are all assigned and fix up the ordering\n+  if (fields_assigned.size () != struct_path_resolved->num_fields ())\n     {\n-      TyTy::TyBase *base_resolved\n-\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n-      expr_type = expr_type->combine (base_resolved);\n-      if (resolved == nullptr)\n+      if (!struct_expr.has_struct_base ())\n \t{\n-\t  rust_fatal_error (\n-\t    struct_expr.struct_base->base_struct->get_locus_slow (),\n-\t    \"incompatible types for base struct reference\");\n+\t  rust_error_at (struct_expr.get_locus (),\n+\t\t\t \"constructor is missing fields\");\n \t  return;\n \t}\n+      else\n+\t{\n+\t  // we have a struct base to assign the missing fields from.\n+\t  // the missing fields can be implicit FieldAccessExprs for the value\n+\t  std::set<std::string> missing_fields;\n+\t  struct_path_resolved->iterate_fields (\n+\t    [&] (TyTy::StructFieldType *field) mutable -> bool {\n+\t      auto it = fields_assigned.find (field->get_name ());\n+\t      if (it == fields_assigned.end ())\n+\t\tmissing_fields.insert (field->get_name ());\n+\t      return true;\n+\t    });\n+\n+\t  // we can generate FieldAccessExpr or TupleAccessExpr for the values\n+\t  // of the missing fields.\n+\t  for (auto &missing : missing_fields)\n+\t    {\n+\t      HIR::Expr *receiver\n+\t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n+\n+\t      HIR::StructExprField *implicit_field = nullptr;\n+\n+\t      std::vector<HIR::Attribute> outer_attribs;\n+\t      auto crate_num = mappings->get_current_crate ();\n+\t      Analysis::NodeMapping mapping (\n+\t\tcrate_num,\n+\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n+\t\t  .get_nodeid (),\n+\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n+\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n+\t\tstd::move (outer_attribs),\n+\t\tstruct_expr.struct_base->base_struct->get_locus_slow ());\n+\n+\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n+\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n+\t\tstruct_expr.struct_base->base_struct->get_locus_slow ());\n+\n+\t      size_t field_index;\n+\t      bool ok = struct_path_resolved->get_field (missing, &field_index);\n+\t      rust_assert (ok);\n+\n+\t      adtFieldIndexToField[field_index] = implicit_field;\n+\t      struct_expr.get_fields ().push_back (\n+\t\tstd::unique_ptr<HIR::StructExprField> (implicit_field));\n+\t    }\n+\t}\n     }\n-  else if (fields_assigned.size () != struct_path_resolved->num_fields ())\n+\n+  // everything is ok, now we need to ensure all field values are ordered\n+  // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n+  // assigned field in the constructor is in the same order as the field in the\n+  // type\n+\n+  std::vector<std::unique_ptr<HIR::StructExprField> > expr_fields\n+    = struct_expr.get_fields_as_owner ();\n+  for (auto &f : expr_fields)\n+    f.release ();\n+\n+  std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n+  for (size_t i = 0; i < adtFieldIndexToField.size (); i++)\n     {\n-      rust_fatal_error (struct_expr.get_locus (),\n-\t\t\t\"some fields are not fully assigned\");\n-      return;\n+      ordered_fields.push_back (\n+\tstd::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n     }\n-\n-  resolved = expr_type;\n+  struct_expr.set_fields_as_owner (std::move (ordered_fields));\n }\n \n void\n@@ -187,9 +310,39 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n       return;\n     }\n \n+  size_t field_index;\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value ());\n+  TyTy::StructFieldType *field_type\n+    = struct_path_resolved->get_field (field.field_name, &field_index);\n+  if (field_type == nullptr)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  resolved_field = field_type->get_field_type ()->combine (value);\n+  if (resolved_field != nullptr)\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  std::string field_name (std::to_string (field.get_tuple_index ()));\n+  auto it = fields_assigned.find (field_name);\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n   TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value ());\n   TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field.field_name);\n+    = struct_path_resolved->get_field (field_name, &field_index);\n   if (field_type == nullptr)\n     {\n       rust_error_at (field.get_locus (), \"unknown field\");\n@@ -198,7 +351,43 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n \n   resolved_field = field_type->get_field_type ()->combine (value);\n   if (resolved_field != nullptr)\n-    fields_assigned.insert (field.field_name);\n+    {\n+      fields_assigned.insert (field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n+}\n+\n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  auto it = fields_assigned.find (field.get_field_name ());\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type\n+    = struct_path_resolved->get_field (field.get_field_name (), &field_index);\n+  if (field_type == nullptr)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  // we can make the field look like an identifier expr to take advantage of\n+  // existing code to figure out the type\n+  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n+\t\t\t    field.get_locus ());\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (&expr);\n+\n+  resolved_field = field_type->get_field_type ()->combine (value);\n+  if (resolved_field != nullptr)\n+    {\n+      fields_assigned.insert (field.field_name);\n+      adtFieldIndexToField[field_index] = &field;\n+    }\n }\n \n } // namespace Resolver"}, {"sha": "d033878c98210011862465cbfe51e8e67b617317", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -33,10 +33,11 @@ class TypeCheckContext\n \n   ~TypeCheckContext ();\n \n+  bool lookup_builtin (NodeId id, TyTy::TyBase **type);\n   bool lookup_builtin (std::string name, TyTy::TyBase **type);\n   void insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type);\n \n-  void insert_type (HirId id, TyTy::TyBase *type);\n+  void insert_type (const Analysis::NodeMapping &mappings, TyTy::TyBase *type);\n   bool lookup_type (HirId id, TyTy::TyBase **type);\n \n   void insert_type_by_node_id (NodeId ref, HirId id);\n@@ -46,6 +47,15 @@ class TypeCheckContext\n   void push_return_type (TyTy::TyBase *return_type);\n   void pop_return_type ();\n \n+  void iterate (std::function<bool (HirId, TyTy::TyBase *)> cb)\n+  {\n+    for (auto it = resolved.begin (); it != resolved.end (); it++)\n+      {\n+\tif (!cb (it->first, it->second))\n+\t  return;\n+      }\n+  }\n+\n private:\n   TypeCheckContext ();\n "}, {"sha": "863c2eb376c75054e6debcdc9a20dfbbc8946c59", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,178 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYCHECK_DUMP\n+#define RUST_TYCHECK_DUMP\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeResolverDump : public TypeCheckBase\n+{\n+public:\n+  static std::string go (HIR::Crate &crate)\n+  {\n+    TypeResolverDump dumper;\n+    for (auto &item : crate.items)\n+      item->accept_vis (dumper);\n+\n+    return dumper.dump;\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    dump += indent () + \"fn \" + function.function_name + \" \"\n+\t    + type_string (function.get_mappings ()) + \"\\n\";\n+    dump += indent () + \"{\\n\";\n+\n+    HIR::BlockExpr *function_body = function.function_body.get ();\n+    function_body->accept_vis (*this);\n+\n+    dump += indent () + \"}\\n\";\n+  }\n+\n+  void visit (HIR::BlockExpr &expr)\n+  {\n+    indentation_level++;\n+\n+    expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      s->accept_vis (*this);\n+      dump += \";\\n\";\n+      return true;\n+    });\n+\n+    if (expr.has_expr () && expr.tail_expr_reachable ())\n+      {\n+\texpr.expr->accept_vis (*this);\n+\tdump += \";\\n\";\n+      }\n+\n+    indentation_level--;\n+  }\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    dump += indent () + \"let \" + stmt.get_pattern ()->as_string () + \":\"\n+\t    + type_string (stmt.get_mappings ());\n+    if (stmt.has_init_expr ())\n+      {\n+\tdump += \" = \";\n+\tstmt.get_init_expr ()->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt)\n+  {\n+    dump += indent ();\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  {\n+    dump += indent ();\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr)\n+  {\n+    expr.get_lhs ()->accept_vis (*this);\n+    dump += \" = \";\n+    expr.get_rhs ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    dump += expr.get_literal ()->as_string () + \":\"\n+\t    + type_string (expr.get_mappings ());\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr)\n+  {\n+    dump += expr.get_identifier () + \":\" + type_string (expr.get_mappings ());\n+  }\n+\n+  void visit (HIR::ArrayExpr &expr)\n+  {\n+    dump += type_string (expr.get_mappings ()) + \":[\";\n+\n+    HIR::ArrayElems *elements = expr.get_internal_elements ();\n+    elements->accept_vis (*this);\n+\n+    dump += \"]\";\n+  }\n+\n+  void visit (HIR::ArrayElemsValues &elems)\n+  {\n+    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n+      e->accept_vis (*this);\n+      dump += \",\";\n+      return true;\n+    });\n+  }\n+\n+  void visit (HIR::GroupedExpr &expr)\n+  {\n+    HIR::Expr *paren_expr = expr.get_expr_in_parens ().get ();\n+    dump += \"(\";\n+    paren_expr->accept_vis (*this);\n+    dump += \")\";\n+  }\n+\n+protected:\n+  std::string type_string (const Analysis::NodeMapping &mappings)\n+  {\n+    TyTy::TyBase *lookup = nullptr;\n+    if (!context->lookup_type (mappings.get_hirid (), &lookup))\n+      return \"<error>\";\n+\n+    std::string buf = \"[\";\n+    for (auto &ref : lookup->get_combined_refs ())\n+      {\n+\tbuf += std::to_string (ref);\n+\tbuf += \", \";\n+      }\n+    buf += \"]\";\n+\n+    return \"<\" + lookup->as_string ()\n+\t   + \" RF:\" + std::to_string (lookup->get_ref ()) + \" TF:\"\n+\t   + std::to_string (lookup->get_ty_ref ()) + +\" - \" + buf + \">\";\n+  }\n+\n+  std::string indent ()\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < indentation_level; ++i)\n+      buf += \"    \";\n+\n+    return buf;\n+  }\n+\n+private:\n+  TypeResolverDump () : TypeCheckBase (), indentation_level (0) {}\n+\n+  std::string dump;\n+  size_t indentation_level;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_TYCHECK_DUMP"}, {"sha": "65c55630f05d94130a55459fb44c0c95ae2899e2", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -35,6 +35,21 @@ TypeCheckContext::TypeCheckContext () {}\n \n TypeCheckContext::~TypeCheckContext () {}\n \n+bool\n+TypeCheckContext::lookup_builtin (NodeId id, TyTy::TyBase **type)\n+{\n+  auto ref_it = node_id_refs.find (id);\n+  if (ref_it == node_id_refs.end ())\n+    return false;\n+\n+  auto it = resolved.find (ref_it->second);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n bool\n TypeCheckContext::lookup_builtin (std::string name, TyTy::TyBase **type)\n {\n@@ -58,9 +73,13 @@ TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type)\n }\n \n void\n-TypeCheckContext::insert_type (HirId id, TyTy::TyBase *type)\n+TypeCheckContext::insert_type (const Analysis::NodeMapping &mappings,\n+\t\t\t       TyTy::TyBase *type)\n {\n   rust_assert (type != nullptr);\n+  NodeId ref = mappings.get_nodeid ();\n+  HirId id = mappings.get_hirid ();\n+  node_id_refs[ref] = id;\n   resolved[id] = type;\n }\n "}, {"sha": "2b3cfb651bef67c4c92cd3b2e3091afb8a8eef9e", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -23,40 +23,52 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty-visitor.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace TyTy {\n \n class TypeCheckCallExpr : private TyVisitor\n {\n public:\n-  static TyBase *go (TyBase *ref, HIR::CallExpr &call)\n+  static TyBase *go (TyBase *ref, HIR::CallExpr &call,\n+\t\t     Resolver::TypeCheckContext *context)\n   {\n-    TypeCheckCallExpr checker (call);\n+    TypeCheckCallExpr checker (call, context);\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n   ~TypeCheckCallExpr () {}\n \n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n+  void visit (TupleType &type) override { gcc_unreachable (); }\n   void visit (StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (ADTType &type) override { gcc_unreachable (); }\n-  void visit (ParamType &type) override { gcc_unreachable (); }\n   void visit (ArrayType &type) override { gcc_unreachable (); }\n   void visit (BoolType &type) override { gcc_unreachable (); }\n   void visit (IntType &type) override { gcc_unreachable (); }\n   void visit (UintType &type) override { gcc_unreachable (); }\n   void visit (FloatType &type) override { gcc_unreachable (); }\n+  void visit (USizeType &type) override { gcc_unreachable (); }\n+  void visit (ISizeType &type) override { gcc_unreachable (); }\n   void visit (ErrorType &type) override { gcc_unreachable (); }\n \n+  // tuple-structs\n+  void visit (ADTType &type) override;\n+\n+  // call fns\n   void visit (FnType &type) override;\n \n private:\n-  TypeCheckCallExpr (HIR::CallExpr &c) : resolved (nullptr), call (c) {}\n+  TypeCheckCallExpr (HIR::CallExpr &c, Resolver::TypeCheckContext *context)\n+    : resolved (nullptr), call (c), context (context),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n \n   TyBase *resolved;\n   HIR::CallExpr &call;\n+  Resolver::TypeCheckContext *context;\n+  Analysis::Mappings *mappings;\n };\n \n } // namespace TyTy"}, {"sha": "22c3c9164f60e1c3d8afa1d7313188c09e213b81", "filename": "gcc/rust/typecheck/rust-tyty-resolver.h", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a0c8ca2156038b726e2689e9b46be4d8c40c55f/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h?ref=3a0c8ca2156038b726e2689e9b46be4d8c40c55f", "patch": "@@ -1,177 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYTY_RESOLVER\n-#define RUST_TYTY_RESOLVER\n-\n-#include \"rust-system.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-name-resolver.h\"\n-#include \"rust-hir-type-check.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-tyty-visitor.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-class TyTyResolver\n-{\n-public:\n-  static void Resolve (Rib *rib, Analysis::Mappings *mappings,\n-\t\t       Resolver *resolver, TypeCheckContext *context)\n-  {\n-    TyTyResolver r (mappings, resolver, context);\n-    r.go (rib);\n-  }\n-\n-  virtual ~TyTyResolver () {}\n-\n-  void go (Rib *rib)\n-  {\n-    rib->iterate_decls ([&] (NodeId decl_node_id, Location) mutable -> bool {\n-      // type inference in rust means we need to gather and examine all\n-      // references of this decl and combine each to make sure the type is\n-      // correctly inferred. Consider the example:\n-      // let mut x; x = 1;\n-      // we can only say x is an infer variable then at the assignment\n-      // we think x must be an integer\n-\n-      std::vector<TyTy::TyBase *> gathered_types;\n-      rib->iterate_references_for_def (\n-\tdecl_node_id, [&] (NodeId ref_node) mutable -> bool {\n-\t  HirId hir_node_ref;\n-\t  bool ok\n-\t    = mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t    ref_node, &hir_node_ref);\n-\t  rust_assert (ok);\n-\n-\t  TyTy::TyBase *resolved = nullptr;\n-\t  if (!context->lookup_type (hir_node_ref, &resolved))\n-\t    {\n-\t      // this could be an array/adt type\n-\t      Definition d;\n-\t      bool ok = resolver->lookup_definition (ref_node, &d);\n-\t      rust_assert (ok);\n-\n-\t      ok = mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t\t d.parent, &hir_node_ref);\n-\t      rust_assert (ok);\n-\n-\t      if (!context->lookup_type (hir_node_ref, &resolved))\n-\t\t{\n-\t\t  rust_fatal_error (\n-\t\t    mappings->lookup_location (hir_node_ref),\n-\t\t    \"failed to lookup type for reference at node [%u]\",\n-\t\t    hir_node_ref);\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\n-\t  gathered_types.push_back (resolved);\n-\t  return true;\n-\t});\n-\n-      Definition d;\n-      bool ok = resolver->lookup_definition (decl_node_id, &d);\n-      rust_assert (ok);\n-\n-      HIR::Stmt *decl = nullptr;\n-      ok = mappings->resolve_nodeid_to_stmt (d.parent, &decl);\n-      rust_assert (ok);\n-\n-      TyTy::TyBase *resolved_type = nullptr;\n-      ok = context->lookup_type (decl->get_mappings ().get_hirid (),\n-\t\t\t\t &resolved_type);\n-      rust_assert (ok);\n-\n-      if (resolved_type->get_kind () != TyTy::TypeKind::INFER)\n-\treturn true;\n-\n-      auto resolved_tyty = resolved_type;\n-      for (auto it : gathered_types)\n-\t{\n-\t  auto combined = resolved_tyty->combine (it);\n-\t  if (combined == nullptr)\n-\t    break;\n-\n-\t  resolved_tyty = combined;\n-\t}\n-\n-      // something is not inferred we need to look at all references now\n-      if (resolved_tyty == nullptr || resolved_tyty->is_unit ())\n-\t{\n-\t  rust_fatal_error (decl->get_locus_slow (), \"failed to resolve type\");\n-\t  return false;\n-\t}\n-\n-      // insert the new resolved definition\n-      context->insert_type (decl->get_mappings ().get_hirid (), resolved_tyty);\n-      return true;\n-    });\n-  }\n-\n-protected:\n-private:\n-  TyTyResolver (Analysis::Mappings *mappings, Resolver *resolver,\n-\t\tTypeCheckContext *context)\n-    : mappings (mappings), resolver (resolver), context (context)\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver *resolver;\n-  TypeCheckContext *context;\n-};\n-\n-class TyTyExtractorArray : public TyTy::TyVisitor\n-{\n-public:\n-  static TyTy::TyBase *ExtractElementTypeFromArray (TyTy::TyBase *base)\n-  {\n-    TyTyExtractorArray e;\n-    base->accept_vis (e);\n-    rust_assert (e.extracted != nullptr);\n-    return e.extracted;\n-  }\n-\n-  virtual ~TyTyExtractorArray () {}\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ParamType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ArrayType &type) override { extracted = type.get_type (); }\n-\n-private:\n-  TyTyExtractorArray () : extracted (nullptr) {}\n-\n-  TyTy::TyBase *extracted;\n-};\n-\n-} // namespace Resolver\n-} // namespace Rust\n-\n-#endif // RUST_TYTY_RESOLVER"}, {"sha": "be58805ef280bb10ceb9f6ecef247f0b8f898c24", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 466, "deletions": 105, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace TyTy {\n@@ -32,342 +33,702 @@ class BaseRules : public TyVisitor\n public:\n   virtual ~BaseRules () {}\n \n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    if (resolved != nullptr)\n+      {\n+\tresolved->append_reference (base->get_ref ());\n+\tresolved->append_reference (other->get_ref ());\n+\tfor (auto ref : base->get_combined_refs ())\n+\t  resolved->append_reference (ref);\n+\tfor (auto ref : other->get_combined_refs ())\n+\t  resolved->append_reference (ref);\n+\n+\tbool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+\tif (result_resolved)\n+\t  {\n+\t    for (auto &ref : resolved->get_combined_refs ())\n+\t      {\n+\t\tTyTy::TyBase *ref_tyty = nullptr;\n+\t\tbool ok = context->lookup_type (ref, &ref_tyty);\n+\t\tif (!ok)\n+\t\t  continue;\n+\n+\t\t// if any of the types are inference variables lets fix them\n+\t\tif (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t\t  {\n+\t\t    NodeId ref_node_id = UNKNOWN_NODEID;\n+\t\t    context->insert_type (\n+\t\t      Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t     ref_node_id, ref,\n+\t\t\t\t\t     UNKNOWN_LOCAL_DEFID),\n+\t\t      resolved->clone ());\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+    return resolved;\n+  }\n+\n   virtual void visit (UnitType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n-  virtual void visit (ADTType &type) override\n+  virtual void visit (TupleType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n-  virtual void visit (InferType &type) override\n+  virtual void visit (ADTType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n-  virtual void visit (FnType &type) override\n+  virtual void visit (InferType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n-  virtual void visit (ParamType &type) override\n+  virtual void visit (FnType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n   virtual void visit (ArrayType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n   virtual void visit (BoolType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n   virtual void visit (IntType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n   virtual void visit (UintType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n+  }\n+\n+  virtual void visit (USizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n+\t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ISizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n+\t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n   }\n \n   virtual void visit (FloatType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n   virtual void visit (ErrorType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n   virtual void visit (StructFieldType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_fatal_error (def_locus, \"declared here\");\n   }\n \n protected:\n   BaseRules (TyBase *base)\n-    : mappings (Analysis::Mappings::get ()), base (base),\n-      resolved (new ErrorType (base->get_ref ()))\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()), base (base),\n+      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n   {}\n \n   Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n   TyBase *base;\n   TyBase *resolved;\n };\n \n-class InferRules : protected BaseRules\n+class InferRules : public BaseRules\n {\n public:\n   InferRules (InferType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n-  // we are an inference variable so this means we can take the other as the\n-  // type\n   void visit (UnitType &type) override\n   {\n-    resolved = new UnitType (type.get_ref ());\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n   }\n \n   void visit (BoolType &type) override\n   {\n-    resolved = new BoolType (type.get_ref ());\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n   }\n \n   void visit (IntType &type) override\n   {\n-    resolved = new IntType (type.get_ref (), type.get_kind ());\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n   }\n \n   void visit (UintType &type) override\n   {\n-    resolved = new UintType (type.get_ref (), type.get_kind ());\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = type.clone ();\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseRules::visit (type);\n   }\n \n private:\n   InferType *base;\n };\n \n-class StructFieldTypeRules : protected BaseRules\n+class StructFieldTypeRules : public BaseRules\n {\n public:\n   StructFieldTypeRules (StructFieldType *base) : BaseRules (base), base (base)\n   {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (StructFieldType &type)\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    TyBase *ty = base->get_field_type ()->combine (type.get_field_type ());\n+    if (ty == nullptr)\n+      return;\n+\n+    resolved = new TyTy::StructFieldType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t\t  type.get_name (), ty);\n   }\n \n private:\n   StructFieldType *base;\n };\n \n-class UnitRules : protected BaseRules\n+class UnitRules : public BaseRules\n {\n public:\n   UnitRules (UnitType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (UnitType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    resolved = new UnitType (type.get_ref (), type.get_ty_ref ());\n   }\n \n-  void visit (IntType &type) override { rust_assert (false); }\n-\n private:\n   UnitType *base;\n };\n \n-class FnRules : protected BaseRules\n+class FnRules : public BaseRules\n {\n public:\n   FnRules (FnType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n-private:\n-  FnType *base;\n-};\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n \n-class ParamRules : protected BaseRules\n-{\n-public:\n-  ParamRules (ParamType *base) : BaseRules (base), base (base) {}\n+    // FIXME add an abstract method for is_equal on TyBase\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto combined_param = a->combine (b);\n+\tif (combined_param == nullptr)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    // we only case about the base type of a param\n-    return base->get_base_type ()->combine (other);\n+    auto combined_return\n+      = base->get_return_type ()->combine (type.get_return_type ());\n+    if (combined_return == nullptr)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n private:\n-  ParamType *base;\n+  FnType *base;\n };\n \n-class ArrayRules : protected BaseRules\n+class ArrayRules : public BaseRules\n {\n public:\n   ArrayRules (ArrayType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (ArrayType &type) override\n   {\n     // check base type\n     auto base_resolved = base->get_type ()->combine (type.get_type ());\n     if (base_resolved == nullptr)\n-      return;\n+      {\n+\t// fixme add error message\n+\treturn;\n+      }\n \n     // need to check the base types and capacity\n     if (type.get_capacity () != base->get_capacity ())\n       {\n \tLocation locus = mappings->lookup_location (type.get_ref ());\n \trust_error_at (locus, \"mismatch in array capacity\");\n+\tBaseRules::visit (type);\n \treturn;\n       }\n \n-    resolved\n-      = new ArrayType (type.get_ref (), type.get_capacity (), base_resolved);\n+    resolved = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_capacity (), base_resolved);\n   }\n \n private:\n   ArrayType *base;\n };\n \n-class BoolRules : protected BaseRules\n+class BoolRules : public BaseRules\n {\n public:\n   BoolRules (BoolType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (BoolType &type) override\n   {\n-    resolved = new BoolType (type.get_ref ());\n+    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n   }\n \n private:\n   BoolType *base;\n };\n \n-class IntRules : protected BaseRules\n+class IntRules : public BaseRules\n {\n public:\n   IntRules (IntType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n   void visit (IntType &type) override\n   {\n-    // FIXME we should look at the IntTypeKind and check if i8 vs i16 etc..\n-    resolved = new IntType (type.get_ref (), type.get_kind ());\n+    if (type.get_kind () != base->get_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_kind ());\n   }\n \n private:\n   IntType *base;\n };\n \n-class UintRules : protected BaseRules\n+class UintRules : public BaseRules\n {\n public:\n   UintRules (UintType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n   void visit (UintType &type) override\n   {\n-    // FIXME we should look at the IntTypeKind and check if u8 vs u16 etc..\n-    resolved = new UintType (type.get_ref (), type.get_kind ());\n+    if (type.get_kind () != base->get_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new UintType (type.get_ref (), type.get_ty_ref (), type.get_kind ());\n   }\n \n private:\n   UintType *base;\n };\n \n-class FloatRules : protected BaseRules\n+class FloatRules : public BaseRules\n {\n public:\n   FloatRules (FloatType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n   void visit (FloatType &type) override\n   {\n-    // FIXME we should look at the FloatKind and respect it\n-    resolved = new FloatType (type.get_ref (), type.get_kind ());\n+    if (type.get_kind () != base->get_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new FloatType (type.get_ref (), type.get_ty_ref (), type.get_kind ());\n   }\n \n private:\n   FloatType *base;\n };\n \n+class ADTRules : public BaseRules\n+{\n+public:\n+  ADTRules (ADTType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (ADTType &type)\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (size_t i = 0; i < type.num_fields (); ++i)\n+      {\n+\tTyTy::StructFieldType *base_field = base->get_field (i);\n+\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\n+\tTyBase *combined = base_field->combine (other_field);\n+\tif (combined == nullptr)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+\n+\tfields.push_back ((TyTy::StructFieldType *) combined);\n+      }\n+\n+    resolved = new TyTy::ADTType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t  type.get_name (), fields);\n+  }\n+\n+private:\n+  ADTType *base;\n+};\n+\n+class TupleRules : public BaseRules\n+{\n+public:\n+  TupleRules (TupleType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (TupleType &type)\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    std::vector<HirId> fields;\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tTyBase *bo = base->get_field (i);\n+\tTyBase *fo = type.get_field (i);\n+\n+\tTyBase *combined = bo->combine (fo);\n+\tif (combined == nullptr)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+\n+\tfields.push_back (combined->get_ref ());\n+      }\n+\n+    resolved\n+      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+  }\n+\n+private:\n+  TupleType *base;\n+};\n+\n+class USizeRules : public BaseRules\n+{\n+public:\n+  USizeRules (USizeType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  USizeType *base;\n+};\n+\n+class ISizeRules : public BaseRules\n+{\n+public:\n+  ISizeRules (ISizeType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  ISizeType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "6ae0e80ad0dfcd8e4345b20e7a74db360979d15f", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -31,13 +31,15 @@ class TyVisitor\n   virtual void visit (InferType &type) = 0;\n   virtual void visit (StructFieldType &type) = 0;\n   virtual void visit (ADTType &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n   virtual void visit (FnType &type) = 0;\n-  virtual void visit (ParamType &type) = 0;\n   virtual void visit (ArrayType &type) = 0;\n   virtual void visit (BoolType &type) = 0;\n   virtual void visit (IntType &type) = 0;\n   virtual void visit (UintType &type) = 0;\n   virtual void visit (FloatType &type) = 0;\n+  virtual void visit (USizeType &type) = 0;\n+  virtual void visit (ISizeType &type) = 0;\n   virtual void visit (ErrorType &type) = 0;\n };\n "}, {"sha": "d506415e504cb3acd1843d5926aef77bbdcc7e44", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 272, "deletions": 31, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -44,6 +44,12 @@ UnitType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+UnitType::clone ()\n+{\n+  return new UnitType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n void\n InferType::accept_vis (TyVisitor &vis)\n {\n@@ -53,7 +59,16 @@ InferType::accept_vis (TyVisitor &vis)\n std::string\n InferType::as_string () const\n {\n-  return \"[_]\";\n+  switch (infer_kind)\n+    {\n+    case GENERAL:\n+      return \"T?\";\n+    case INTEGRAL:\n+      return \"<integer>\";\n+    case FLOAT:\n+      return \"<float>\";\n+    }\n+  return \"<infer::error>\";\n }\n \n TyBase *\n@@ -63,6 +78,13 @@ InferType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+InferType::clone ()\n+{\n+  return new InferType (get_ref (), get_ty_ref (), get_infer_kind (),\n+\t\t\tget_combined_refs ());\n+}\n+\n void\n ErrorType::accept_vis (TyVisitor &vis)\n {\n@@ -78,10 +100,17 @@ ErrorType::as_string () const\n TyBase *\n ErrorType::combine (TyBase *other)\n {\n+  // FIXME\n   // rust_error_at ();\n   return this;\n }\n \n+TyBase *\n+ErrorType::clone ()\n+{\n+  return new ErrorType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n void\n StructFieldType::accept_vis (TyVisitor &vis)\n {\n@@ -101,6 +130,14 @@ StructFieldType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+StructFieldType::clone ()\n+{\n+  return new StructFieldType (get_ref (), get_ty_ref (), get_name (),\n+\t\t\t      get_field_type ()->clone (),\n+\t\t\t      get_combined_refs ());\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -110,17 +147,74 @@ ADTType::accept_vis (TyVisitor &vis)\n std::string\n ADTType::as_string () const\n {\n+  if (num_fields () == 0)\n+    return identifier;\n+\n   std::string fields_buffer;\n   for (auto &field : fields)\n-    fields_buffer += field->as_string () + \"\\n\";\n+    fields_buffer += field->as_string () + \", \";\n \n-  return identifier + \"{\\n\" + fields_buffer + \"\\n}\";\n+  return identifier + \"{\" + fields_buffer + \"}\";\n }\n \n TyBase *\n ADTType::combine (TyBase *other)\n {\n-  return nullptr;\n+  ADTRules r (this);\n+  return r.combine (other);\n+}\n+\n+TyBase *\n+ADTType::clone ()\n+{\n+  std::vector<StructFieldType *> cloned_fields;\n+  for (auto &f : fields)\n+    cloned_fields.push_back ((StructFieldType *) f->clone ());\n+\n+  return new ADTType (get_ref (), get_ty_ref (), get_name (), cloned_fields,\n+\t\t      get_combined_refs ());\n+}\n+\n+void\n+TupleType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+TupleType::as_string () const\n+{\n+  std::string fields_buffer;\n+  iterate_fields ([&] (TyBase *field) mutable -> bool {\n+    fields_buffer += field->as_string ();\n+    fields_buffer += \", \";\n+    return true;\n+  });\n+  return \"(\" + fields_buffer + \")\";\n+}\n+\n+TyBase *\n+TupleType::get_field (size_t index) const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  TyBase *lookup = nullptr;\n+  bool ok = context->lookup_type (fields.at (index), &lookup);\n+  rust_assert (ok);\n+  return lookup;\n+}\n+\n+TyBase *\n+TupleType::combine (TyBase *other)\n+{\n+  TupleRules r (this);\n+  return r.combine (other);\n+}\n+\n+TyBase *\n+TupleType::clone ()\n+{\n+  return new TupleType (get_ref (), get_ty_ref (), fields,\n+\t\t\tget_combined_refs ());\n }\n \n void\n@@ -135,7 +229,9 @@ FnType::as_string () const\n   std::string params_str = \"\";\n   for (auto &param : params)\n     {\n-      params_str += param->as_string ();\n+      auto pattern = param.first;\n+      auto ty = param.second;\n+      params_str += pattern->as_string () + \" \" + ty->as_string ();\n       params_str += \",\";\n     }\n \n@@ -150,23 +246,16 @@ FnType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n-void\n-ParamType::accept_vis (TyVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-std::string\n-ParamType::as_string () const\n-{\n-  return \"(\" + identifier + \" :\" + type->as_string () + \")\";\n-}\n-\n TyBase *\n-ParamType::combine (TyBase *other)\n+FnType::clone ()\n {\n-  ParamRules r (this);\n-  return r.combine (other);\n+  std::vector<std::pair<HIR::Pattern *, TyBase *> > cloned_params;\n+  for (auto &p : params)\n+    cloned_params.push_back (\n+      std::pair<HIR::Pattern *, TyBase *> (p.first, p.second->clone ()));\n+\n+  return new FnType (get_ref (), get_ty_ref (), cloned_params,\n+\t\t     get_return_type ()->clone (), get_combined_refs ());\n }\n \n void\n@@ -178,7 +267,8 @@ ArrayType::accept_vis (TyVisitor &vis)\n std::string\n ArrayType::as_string () const\n {\n-  return \"[\" + type->as_string () + \":\" + std::to_string (capacity) + \"]\";\n+  return \"[\" + get_type ()->as_string () + \":\" + std::to_string (capacity)\n+\t + \"]\";\n }\n \n TyBase *\n@@ -188,6 +278,23 @@ ArrayType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+ArrayType::get_type () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  TyBase *lookup = nullptr;\n+  bool ok = context->lookup_type (element_type_id, &lookup);\n+  rust_assert (ok);\n+  return lookup;\n+}\n+\n+TyBase *\n+ArrayType::clone ()\n+{\n+  return new ArrayType (get_ref (), get_ty_ref (), get_capacity (),\n+\t\t\tget_type ()->clone (), get_combined_refs ());\n+}\n+\n void\n BoolType::accept_vis (TyVisitor &vis)\n {\n@@ -207,6 +314,12 @@ BoolType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+BoolType::clone ()\n+{\n+  return new BoolType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n void\n IntType::accept_vis (TyVisitor &vis)\n {\n@@ -240,6 +353,13 @@ IntType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+IntType::clone ()\n+{\n+  return new IntType (get_ref (), get_ty_ref (), get_kind (),\n+\t\t      get_combined_refs ());\n+}\n+\n void\n UintType::accept_vis (TyVisitor &vis)\n {\n@@ -273,6 +393,13 @@ UintType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+UintType::clone ()\n+{\n+  return new UintType (get_ref (), get_ty_ref (), get_kind (),\n+\t\t       get_combined_refs ());\n+}\n+\n void\n FloatType::accept_vis (TyVisitor &vis)\n {\n@@ -300,37 +427,151 @@ FloatType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+FloatType::clone ()\n+{\n+  return new FloatType (get_ref (), get_ty_ref (), get_kind (),\n+\t\t\tget_combined_refs ());\n+}\n+\n void\n-TypeCheckCallExpr::visit (FnType &type)\n+USizeType::accept_vis (TyVisitor &vis)\n {\n-  if (call.num_params () != type.num_params ())\n+  vis.visit (*this);\n+}\n+\n+std::string\n+USizeType::as_string () const\n+{\n+  return \"usize\";\n+}\n+\n+TyBase *\n+USizeType::combine (TyBase *other)\n+{\n+  USizeRules r (this);\n+  return r.combine (other);\n+}\n+\n+TyBase *\n+USizeType::clone ()\n+{\n+  return new USizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+void\n+ISizeType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ISizeType::as_string () const\n+{\n+  return \"isize\";\n+}\n+\n+TyBase *\n+ISizeType::combine (TyBase *other)\n+{\n+  ISizeRules r (this);\n+  return r.combine (other);\n+}\n+\n+TyBase *\n+ISizeType::clone ()\n+{\n+  return new ISizeType (get_ref (), get_ty_ref (), get_combined_refs ());\n+}\n+\n+void\n+TypeCheckCallExpr::visit (ADTType &type)\n+{\n+  if (call.num_params () != type.num_fields ())\n     {\n-      rust_error_at (call.get_locus (), \"differing number of arguments\");\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_fields ());\n       return;\n     }\n \n   size_t i = 0;\n   call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-    TyBase *pt = type.param_at (i);\n-    auto t = Resolver::TypeCheckExpr::Resolve (p);\n-    if (t == nullptr)\n+    StructFieldType *field = type.get_field (i);\n+    TyBase *field_tyty = field->get_field_type ();\n+\n+    TyBase *arg = Resolver::TypeCheckExpr::Resolve (p);\n+    if (arg == nullptr)\n       {\n-\trust_error_at (p->get_locus_slow (), \"failed to resolve type\");\n+\trust_error_at (p->get_locus_slow (), \"failed to resolve argument type\");\n \treturn false;\n       }\n \n-    auto res = pt->combine (t);\n+    auto res = field_tyty->combine (arg);\n     if (res == nullptr)\n       return false;\n \n+    delete res;\n     i++;\n     return true;\n   });\n \n   if (i != call.num_params ())\n-    return;\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnType &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n+    auto fnparam = type.param_at (i);\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param);\n+    if (argument_expr_tyty == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"failed to resolve type for argument expr in CallExpr\");\n+\treturn false;\n+      }\n+\n+    auto resolved_argument_type = fnparam.second->combine (argument_expr_tyty);\n+    if (resolved_argument_type == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"Type Resolution failure on parameter\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (param->get_mappings (), resolved_argument_type);\n+\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n \n-  resolved = type.get_return_type ();\n+  resolved = type.get_return_type ()->clone ();\n }\n \n } // namespace TyTy"}, {"sha": "860ef966786d69b15b3e4b0e9136f963a027163b", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 256, "deletions": 39, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -24,6 +24,7 @@\n namespace Rust {\n namespace TyTy {\n \n+// https://rustc-dev-guide.rust-lang.org/type-inference.html#inference-variables\n // https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants\n enum TypeKind\n {\n@@ -42,6 +43,8 @@ enum TypeKind\n   FLOAT,\n   UNIT,\n   FIELD,\n+  USIZE,\n+  ISIZE,\n   // there are more to add...\n   ERROR\n };\n@@ -54,6 +57,12 @@ class TyBase\n \n   HirId get_ref () const { return ref; }\n \n+  void set_ref (HirId id) { ref = id; }\n+\n+  HirId get_ty_ref () const { return ty_ref; }\n+\n+  void set_ty_ref (HirId id) { ty_ref = id; }\n+\n   virtual void accept_vis (TyVisitor &vis) = 0;\n \n   virtual std::string as_string () const = 0;\n@@ -64,17 +73,44 @@ class TyBase\n \n   TypeKind get_kind () const { return kind; }\n \n+  virtual TyBase *clone () = 0;\n+\n+  std::set<HirId> get_combined_refs () { return combined; }\n+\n+  void append_reference (HirId id) { combined.insert (id); }\n+\n protected:\n-  TyBase (HirId ref, TypeKind kind) : kind (kind), ref (ref) {}\n+  TyBase (HirId ref, HirId ty_ref, TypeKind kind,\n+\t  std::set<HirId> refs = std::set<HirId> ())\n+    : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs)\n+  {}\n \n   TypeKind kind;\n   HirId ref;\n+  HirId ty_ref;\n+\n+  std::set<HirId> combined;\n };\n \n class InferType : public TyBase\n {\n public:\n-  InferType (HirId ref) : TyBase (ref, TypeKind::INFER) {}\n+  enum InferTypeKind\n+  {\n+    GENERAL,\n+    INTEGRAL,\n+    FLOAT\n+  };\n+\n+  InferType (HirId ref, InferTypeKind infer_kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::INFER, refs), infer_kind (infer_kind)\n+  {}\n+\n+  InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::INFER, refs), infer_kind (infer_kind)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -83,12 +119,25 @@ class InferType : public TyBase\n   std::string as_string () const override;\n \n   TyBase *combine (TyBase *other) override;\n+\n+  TyBase *clone () final override;\n+\n+  InferTypeKind get_infer_kind () const { return infer_kind; }\n+\n+private:\n+  InferTypeKind infer_kind;\n };\n \n class ErrorType : public TyBase\n {\n public:\n-  ErrorType (HirId ref) : TyBase (ref, TypeKind::ERROR) {}\n+  ErrorType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ERROR, refs)\n+  {}\n+\n+  ErrorType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ERROR, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -97,12 +146,20 @@ class ErrorType : public TyBase\n   std::string as_string () const override;\n \n   TyBase *combine (TyBase *other) override;\n+\n+  TyBase *clone () final override;\n };\n \n class UnitType : public TyBase\n {\n public:\n-  UnitType (HirId ref) : TyBase (ref, TypeKind::UNIT) {}\n+  UnitType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::UNIT, refs)\n+  {}\n+\n+  UnitType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::UNIT, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -111,13 +168,21 @@ class UnitType : public TyBase\n   std::string as_string () const override;\n \n   TyBase *combine (TyBase *other) override;\n+\n+  TyBase *clone () final override;\n };\n \n class StructFieldType : public TyBase\n {\n public:\n-  StructFieldType (HirId ref, std::string name, TyBase *ty)\n-    : TyBase (ref, TypeKind::FIELD), name (name), ty (ty)\n+  StructFieldType (HirId ref, std::string name, TyBase *ty,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::FIELD, refs), name (name), ty (ty)\n+  {}\n+\n+  StructFieldType (HirId ref, HirId ty_ref, std::string name, TyBase *ty,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::FIELD, refs), name (name), ty (ty)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -132,17 +197,24 @@ class StructFieldType : public TyBase\n \n   TyBase *get_field_type () { return ty; }\n \n+  TyBase *clone () final override;\n+\n private:\n   std::string name;\n   TyBase *ty;\n };\n \n-class ADTType : public TyBase\n+class TupleType : public TyBase\n {\n public:\n-  ADTType (HirId ref, std::string identifier,\n-\t   std::vector<StructFieldType *> fields)\n-    : TyBase (ref, TypeKind::ADT), identifier (identifier), fields (fields)\n+  TupleType (HirId ref, std::vector<HirId> fields,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::TUPLE, refs), fields (fields)\n+  {}\n+\n+  TupleType (HirId ref, HirId ty_ref, std::vector<HirId> fields,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::TUPLE, refs), fields (fields)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -155,50 +227,103 @@ class ADTType : public TyBase\n \n   size_t num_fields () const { return fields.size (); }\n \n-  StructFieldType *get_field (size_t index) { return fields.at (index); }\n+  TyBase *get_field (size_t index) const;\n \n-  StructFieldType *get_field (const std::string &lookup)\n+  TyBase *clone () final override;\n+\n+  void iterate_fields (std::function<bool (TyBase *)> cb) const\n   {\n-    for (auto &field : fields)\n+    for (size_t i = 0; i < num_fields (); i++)\n       {\n-\tif (field->get_name ().compare (lookup) == 0)\n-\t  return field;\n+\tif (!cb (get_field (i)))\n+\t  return;\n       }\n-    return nullptr;\n   }\n \n private:\n-  std::string identifier;\n-  std::vector<StructFieldType *> fields;\n+  std::vector<HirId> fields;\n };\n \n-class ParamType : public TyBase\n+class ADTType : public TyBase\n {\n public:\n-  ParamType (HirId ref, std::string identifier, TyBase *type)\n-    : TyBase (ref, TypeKind::PARAM), identifier (identifier), type (type)\n+  ADTType (HirId ref, std::string identifier,\n+\t   std::vector<StructFieldType *> fields,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ADT, refs), identifier (identifier),\n+      fields (fields)\n+  {}\n+\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier,\n+\t   std::vector<StructFieldType *> fields,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ADT, refs), identifier (identifier),\n+      fields (fields)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n+  bool is_unit () const override { return false; }\n+\n   std::string as_string () const override;\n \n   TyBase *combine (TyBase *other) override;\n \n-  std::string get_identifier () const { return identifier; }\n+  size_t num_fields () const { return fields.size (); }\n+\n+  std::string get_name () const { return identifier; }\n+\n+  StructFieldType *get_field (size_t index) { return fields.at (index); }\n+\n+  StructFieldType *get_field (const std::string &lookup,\n+\t\t\t      size_t *index = nullptr)\n+  {\n+    size_t i = 0;\n+    for (auto &field : fields)\n+      {\n+\tif (field->get_name ().compare (lookup) == 0)\n+\t  {\n+\t    if (index != nullptr)\n+\t      *index = i;\n+\t    return field;\n+\t  }\n+\ti++;\n+      }\n+    return nullptr;\n+  }\n+\n+  TyBase *clone () final override;\n+\n+  std::vector<StructFieldType *> &get_fields () { return fields; }\n+  const std::vector<StructFieldType *> &get_fields () const { return fields; }\n \n-  TyBase *get_base_type () { return type; }\n+  void iterate_fields (std::function<bool (StructFieldType *)> cb)\n+  {\n+    for (auto &f : fields)\n+      {\n+\tif (!cb (f))\n+\t  return;\n+      }\n+  }\n \n private:\n   std::string identifier;\n-  TyBase *type;\n+  std::vector<StructFieldType *> fields;\n };\n \n class FnType : public TyBase\n {\n public:\n-  FnType (HirId ref, std::vector<ParamType *> params, TyBase *type)\n-    : TyBase (ref, TypeKind::FNDEF), params (params), type (type)\n+  FnType (HirId ref, std::vector<std::pair<HIR::Pattern *, TyBase *> > params,\n+\t  TyBase *type, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::FNDEF, refs), params (std::move (params)),\n+      type (type)\n+  {}\n+\n+  FnType (HirId ref, HirId ty_ref,\n+\t  std::vector<std::pair<HIR::Pattern *, TyBase *> > params,\n+\t  TyBase *type, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::FNDEF, refs), params (params), type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -211,20 +336,38 @@ class FnType : public TyBase\n \n   size_t num_params () const { return params.size (); }\n \n-  ParamType *param_at (size_t idx) { return params[idx]; }\n+  std::vector<std::pair<HIR::Pattern *, TyBase *> > &get_params ()\n+  {\n+    return params;\n+  }\n+\n+  std::pair<HIR::Pattern *, TyBase *> &param_at (size_t idx)\n+  {\n+    return params[idx];\n+  }\n \n   TyBase *get_return_type () { return type; }\n \n+  TyBase *clone () final override;\n+\n private:\n-  std::vector<ParamType *> params;\n+  std::vector<std::pair<HIR::Pattern *, TyBase *> > params;\n   TyBase *type;\n };\n \n class ArrayType : public TyBase\n {\n public:\n-  ArrayType (HirId ref, size_t capacity, TyBase *type)\n-    : TyBase (ref, TypeKind::ARRAY), capacity (capacity), type (type)\n+  ArrayType (HirId ref, size_t capacity, TyBase *type,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n+      element_type_id (type->get_ref ())\n+  {}\n+\n+  ArrayType (HirId ref, HirId ty_ref, size_t capacity, TyBase *type,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n+      element_type_id (type->get_ref ())\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -235,23 +378,35 @@ class ArrayType : public TyBase\n \n   size_t get_capacity () const { return capacity; }\n \n-  TyBase *get_type () { return type; }\n+  HirId element_type_ref () const { return element_type_id; }\n+\n+  TyBase *get_type () const;\n+\n+  TyBase *clone () final override;\n \n private:\n   size_t capacity;\n-  TyBase *type;\n+  HirId element_type_id;\n };\n \n class BoolType : public TyBase\n {\n public:\n-  BoolType (HirId ref) : TyBase (ref, TypeKind::BOOL) {}\n+  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::BOOL, refs)\n+  {}\n+\n+  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::BOOL, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n   std::string as_string () const override;\n \n   TyBase *combine (TyBase *other) override;\n+\n+  TyBase *clone () final override;\n };\n \n class IntType : public TyBase\n@@ -266,8 +421,13 @@ class IntType : public TyBase\n     I128\n   };\n \n-  IntType (HirId ref, IntKind kind)\n-    : TyBase (ref, TypeKind::INT), int_kind (kind)\n+  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::INT, refs), int_kind (kind)\n+  {}\n+\n+  IntType (HirId ref, HirId ty_ref, IntKind kind,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::INT, refs), int_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -278,6 +438,8 @@ class IntType : public TyBase\n \n   IntKind get_kind () const { return int_kind; }\n \n+  TyBase *clone () final override;\n+\n private:\n   IntKind int_kind;\n };\n@@ -294,8 +456,13 @@ class UintType : public TyBase\n     U128\n   };\n \n-  UintType (HirId ref, UintKind kind)\n-    : TyBase (ref, TypeKind::UINT), uint_kind (kind)\n+  UintType (HirId ref, UintKind kind, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::UINT, refs), uint_kind (kind)\n+  {}\n+\n+  UintType (HirId ref, HirId ty_ref, UintKind kind,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::UINT, refs), uint_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -306,6 +473,8 @@ class UintType : public TyBase\n \n   UintKind get_kind () const { return uint_kind; }\n \n+  TyBase *clone () final override;\n+\n private:\n   UintKind uint_kind;\n };\n@@ -319,8 +488,14 @@ class FloatType : public TyBase\n     F64\n   };\n \n-  FloatType (HirId ref, FloatKind kind)\n-    : TyBase (ref, TypeKind::FLOAT), float_kind (kind)\n+  FloatType (HirId ref, FloatKind kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::FLOAT, refs), float_kind (kind)\n+  {}\n+\n+  FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::FLOAT, refs), float_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -331,10 +506,52 @@ class FloatType : public TyBase\n \n   FloatKind get_kind () const { return float_kind; }\n \n+  TyBase *clone () final override;\n+\n private:\n   FloatKind float_kind;\n };\n \n+class USizeType : public TyBase\n+{\n+public:\n+  USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::USIZE)\n+  {}\n+\n+  USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::USIZE)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  TyBase *clone () final override;\n+};\n+\n+class ISizeType : public TyBase\n+{\n+public:\n+  ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ISIZE)\n+  {}\n+\n+  ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ISIZE)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  TyBase *clone () final override;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "925130f020a1bceba1f3b2c7b05d5e3f4de412ce", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -159,6 +159,7 @@ Mappings::get_next_hir_id (CrateNum crateNum)\n \n   auto id = it->second + 1;\n   hirIdIter[crateNum] = id;\n+  hirNodesWithinCrate[crateNum].insert (id);\n   return id;\n }\n \n@@ -332,7 +333,7 @@ Mappings::insert_hir_param (CrateNum crateNum, HirId id,\n   rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n \n   hirParamMappings[crateNum][id] = param;\n-  nodeIdToHirMappings[crateNum][param->get_mappings ()->get_nodeid ()] = id;\n+  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n }\n \n HIR::FunctionParam *\n@@ -349,6 +350,30 @@ Mappings::lookup_hir_param (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_struct_field (CrateNum crateNum, HirId id,\n+\t\t\t\t   HIR::StructExprField *field)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  hirStructFieldMappings[crateNum][id] = field;\n+  nodeIdToHirMappings[crateNum][field->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::StructExprField *\n+Mappings::lookup_hir_struct_field (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirStructFieldMappings.find (crateNum);\n+  if (it == hirStructFieldMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n \t\t\t\t      HIR::Item *item)"}, {"sha": "4859d1e6d20d9429a59241e2419cb15a9ef11f8e", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -121,6 +121,10 @@ class Mappings\n   void insert_hir_param (CrateNum crateNum, HirId id, HIR::FunctionParam *type);\n   HIR::FunctionParam *lookup_hir_param (CrateNum crateNum, HirId id);\n \n+  void insert_hir_struct_field (CrateNum crateNum, HirId id,\n+\t\t\t\tHIR::StructExprField *type);\n+  HIR::StructExprField *lookup_hir_struct_field (CrateNum crateNum, HirId id);\n+\n   void walk_local_defids_for_crate (CrateNum crateNum,\n \t\t\t\t    std::function<bool (HIR::Item *)> cb);\n \n@@ -139,6 +143,11 @@ class Mappings\n     return resolve_nodeid_to_stmt (get_current_crate (), id, stmt);\n   }\n \n+  std::set<HirId> &get_hirids_within_crate (CrateNum crate)\n+  {\n+    return hirNodesWithinCrate[crate];\n+  }\n+\n private:\n   Mappings ();\n \n@@ -159,12 +168,17 @@ class Mappings\n   std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Stmt *> > hirStmtMappings;\n   std::map<CrateNum, std::map<HirId, HIR::FunctionParam *> > hirParamMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::StructExprField *> >\n+    hirStructFieldMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;\n \n   // reverse mappings\n   std::map<CrateNum, std::map<NodeId, HirId> > nodeIdToHirMappings;\n+\n+  // all hirid nodes\n+  std::map<CrateNum, std::set<HirId> > hirNodesWithinCrate;\n };\n \n } // namespace Analysis"}, {"sha": "efc63f5641af4a8ad0b5673a03f5d89773be8274", "filename": "gcc/testsuite/rust.test/compilable/arithmetic_expressions1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farithmetic_expressions1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farithmetic_expressions1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farithmetic_expressions1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,28 @@\n+fn main() {\n+    let a: i32 = 1;\n+    let b: f32 = 5f32;\n+    let c: bool = true;\n+\n+    let a1: i32 = a + 1;\n+    let a2: i32 = a - 2;\n+    let a3: i32 = a * 3;\n+    let a4: i32 = a / 4;\n+    let a5: i32 = a % 5;\n+\n+    let b1: f32 = b + 1f32;\n+    let b2: f32 = b - 2f32;\n+    let b3: f32 = b * 3f32;\n+    let b4: f32 = b / 4f32;\n+    // let b5: f32 = b % 5f32;\n+\n+    let aa1: i32 = a & 1;\n+    let aa2: i32 = a | 2;\n+    let aa2: i32 = a ^ 3;\n+\n+    let c1: bool = c & true;\n+    let c2: bool = c | false;\n+    let c3: bool = c ^ true;\n+\n+    let aaa1: i32 = a << 1;\n+    let aaa2: i32 = a >> 2;\n+}"}, {"sha": "f9bee7748ee688ee2527fb2bdab6c778e1155b9a", "filename": "gcc/testsuite/rust.test/compilable/arrays_index2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays_index2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays_index2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Farrays_index2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let mut array: [i32; 3] = [0; 3];\n+    array[0] = 1;\n+}"}, {"sha": "d3c5263854d52c6fd37fae36ca847023cc40ea5f", "filename": "gcc/testsuite/rust.test/compilable/comparison_expr1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcomparison_expr1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcomparison_expr1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcomparison_expr1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,34 @@\n+fn is_zero(x: i32) -> bool {\n+    x == 0\n+}\n+\n+fn is_not_zero(x: i32) -> bool {\n+    x != 0\n+}\n+\n+fn is_positive(x: i32) -> bool {\n+    x > 0\n+}\n+\n+fn is_negative(x: i32) -> bool {\n+    x < 0\n+}\n+\n+fn is_positive_or_zero(x: i32) -> bool {\n+    x >= 0\n+}\n+\n+fn is_negative_or_zero(x: i32) -> bool {\n+    x <= 0\n+}\n+\n+fn main() {\n+    let a: bool = is_zero(1);\n+    let b: bool = is_not_zero(2);\n+    let c: bool = is_positive(3);\n+    let d: bool = is_negative(4);\n+    let e: bool = is_positive_or_zero(5);\n+    let f: bool = is_negative_or_zero(6);\n+    let g: bool = a || b;\n+    let h: bool = c && d;\n+}"}, {"sha": "add4a5f5b492b3385fce083f3b017ba87299515e", "filename": "gcc/testsuite/rust.test/compilable/compound_assignment_expr1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcompound_assignment_expr1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcompound_assignment_expr1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcompound_assignment_expr1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,24 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 2;\n+    let mut c = 3;\n+    let mut d = 4;\n+    let mut e = 5;\n+    let mut f = 6;\n+    let mut g = 7;\n+    let mut h = 8;\n+    let mut i = 9;\n+    let mut j = 10;\n+\n+    a += 1;\n+    b -= 2;\n+    c *= 3;\n+    d /= 4;\n+    e %= 5;\n+    f &= 6;\n+    // https://github.com/Rust-GCC/gccrs/issues/173\n+    // g |= 7;\n+    h ^= 8;\n+    i <<= 9;\n+    j >>= 10;\n+}"}, {"sha": "ba9c96360f3ba23697de5c35ee6a1e386de91620", "filename": "gcc/testsuite/rust.test/compilable/forward_decl_2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let y = x + 1;\n+}\n+\n+static x: i32 = 3;"}, {"sha": "257b0f7442ab0828f75ceb5bc2696bdf33532c61", "filename": "gcc/testsuite/rust.test/compilable/forward_decl_3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let struct_test = Foo { one: 1, two: 2 };\n+}\n+\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}"}, {"sha": "dd8a725949e7c3b42a7bd193fc6d4cc250d3aefb", "filename": "gcc/testsuite/rust.test/compilable/forward_decl_4.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fforward_decl_4.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let mut x = TEST_CONST;\n+    x = x + 1;\n+\n+    let mut y = x + TEST_CONST;\n+}\n+\n+const TEST_CONST: i32 = 10;"}, {"sha": "604bad054d21d7b95bfd385e981424da76c11f94", "filename": "gcc/testsuite/rust.test/compilable/function_reference1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a = test;\n+    let b = a(1);\n+}"}, {"sha": "0b963b27e051d8e45a1c67edd18c3499b8cd8d20", "filename": "gcc/testsuite/rust.test/compilable/function_reference2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a: fn(i32) -> i32 = test;\n+    let b = a(1);\n+}"}, {"sha": "3170c7c4549935bd18fc8b496cc219965e639de4", "filename": "gcc/testsuite/rust.test/compilable/ints_infer1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fints_infer1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fints_infer1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fints_infer1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,18 @@\n+const TEST_CONST: i32 = 10;\n+\n+fn main() {\n+    let mut x = TEST_CONST;\n+    x = x + 1;\n+\n+    let mut y = x + TEST_CONST;\n+\n+    let z = 1u32;\n+\n+    let a = z;\n+\n+    let b;\n+    b = 1;\n+\n+    let c;\n+    c = a;\n+}"}, {"sha": "7bba6c6678a16c216b68722ab293510cc30bf28b", "filename": "gcc/testsuite/rust.test/compilable/parameter_usage1.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fparameter_usage1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fparameter_usage1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fparameter_usage1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,7 @@\n+fn test(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    let a = test(1, 4);\n+}"}, {"sha": "33d9d867e0988d39a2a977c50414dfb63e216f71", "filename": "gcc/testsuite/rust.test/compilable/parens1.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fparens1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fparens1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fparens1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let a = 123;\n+    let b = a + (a * 2);\n+}"}, {"sha": "89c21d09449de7f1d93254089a60a411df3e3bfb", "filename": "gcc/testsuite/rust.test/compilable/recursive_fn1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Frecursive_fn1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Frecursive_fn1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Frecursive_fn1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,11 @@\n+fn gcd(x: i32, y: i32) -> i32 {\n+    if y == 0 {\n+        x\n+    } else {\n+        gcd(y, x % y)\n+    }\n+}\n+\n+fn main() {\n+    let a = gcd(100, 5);\n+}"}, {"sha": "74af41ef16397addfbe1f721cdf23e2b0f1723ce", "filename": "gcc/testsuite/rust.test/compilable/scoping1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fscoping1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fscoping1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fscoping1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let x = 1;\n     {\n-        let x = true;\n+        let mut x = true;\n         {\n             x = false;\n         }"}, {"sha": "bc12b93181f8681e49438928e0c5678b9c58ff65", "filename": "gcc/testsuite/rust.test/compilable/struct_access1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_access1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_access1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_access1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,10 @@\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}\n+\n+fn main() {\n+    let struct_test = Foo { one: 1, two: 2 };\n+    let a = struct_test.one;\n+    let b = struct_test.two;\n+}"}, {"sha": "3c0b24a391339805c0e0a87de3a346c858b1c61a", "filename": "gcc/testsuite/rust.test/compilable/struct_base_init_1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_base_init_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_base_init_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_base_init_1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,12 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn foo() -> Foo {\n+    Foo { a: 42, b: 32 }\n+}\n+\n+fn main() {\n+    let _f = Foo { a: 10, ..foo() };\n+}"}, {"sha": "8d210b8b846c488e03329f29f7af7b9538214f8c", "filename": "gcc/testsuite/rust.test/compilable/struct_init_2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+struct Foo(f32, f32);\n+\n+fn main() {\n+    let a = Foo { 0: 10.0, 1: 20.0 };\n+}"}, {"sha": "fb1e58efcbae7e22ea998ea86f3fe720275dafbd", "filename": "gcc/testsuite/rust.test/compilable/struct_init_3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,10 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = Foo { a, b };\n+}"}, {"sha": "2cc8a19917d4a18419d244320a6121c7e7e9c1e0", "filename": "gcc/testsuite/rust.test/compilable/struct_init_4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_4.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2 };\n+    let b = Foo { a: 3, b: 4, ..a };\n+}"}, {"sha": "c79ea7145bf5eb19bda3e3679b3ab69c33ae4443", "filename": "gcc/testsuite/rust.test/compilable/struct_init_5.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_5.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2 };\n+    let b = Foo { ..a };\n+}"}, {"sha": "51b90bc8b857301cf6769f7c82ab595bd3a3610e", "filename": "gcc/testsuite/rust.test/compilable/struct_init_6.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_6.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2 };\n+    let b = Foo { a: 1, ..a };\n+}"}, {"sha": "615eae7025d9cb075fb1ea3a20113dbd55909c29", "filename": "gcc/testsuite/rust.test/compilable/struct_init_7.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_7.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,9 @@\n+struct Foo {\n+    a: i32,\n+    b: f32,\n+}\n+\n+fn main() {\n+    let a = Foo { a: 1, b: 2f32 };\n+    let b = Foo { b: 4f32, ..a };\n+}"}, {"sha": "e62f40af6de83aadf4e620dadfb6cbd957a230cc", "filename": "gcc/testsuite/rust.test/compilable/struct_init_8.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_8.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,6 @@\n+struct Foo(f32, i32);\n+\n+fn main() {\n+    let a = Foo { 1: 1, 0: 2f32 };\n+    let b = Foo { ..a };\n+}"}, {"sha": "8b8960170f9ef9f4d013547ffc37d4abec367f39", "filename": "gcc/testsuite/rust.test/compilable/tuple1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a: (i32, bool) = (123, true);\n+    let b;\n+    b = (456, 5f32);\n+}"}, {"sha": "51333d8bcf209b9db994822caaa99950b633f346", "filename": "gcc/testsuite/rust.test/compilable/tuple2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let a = 123;\n+    let b = (a,);\n+}"}, {"sha": "d0fb6fc44297bb2cf8e6c8da3632ce78281ba8b1", "filename": "gcc/testsuite/rust.test/compilable/tuple3.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let a = (1, true);\n+\n+    let b;\n+    let c;\n+\n+    b = a.0;\n+    c = a.1;\n+}"}, {"sha": "8d1bbe9906ce1f2b7e7dab259f6f87a280b15785", "filename": "gcc/testsuite/rust.test/compilable/tuple_field_access.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_field_access.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_field_access.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_field_access.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,6 @@\n+struct Foo(i32, i32);\n+\n+fn main() {\n+    let mut a = Foo(1, 2);\n+    a.0 = 22;\n+}"}, {"sha": "65e29f718d8de52534a967404e029be1251b47d9", "filename": "gcc/testsuite/rust.test/compilable/tuple_struct1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+struct Foo(i32, i32, bool);\n+\n+fn main() {\n+    let a = Foo(1, 2, true);\n+}"}, {"sha": "5e0a76e1de89ae91ac8b29f2133f323578581b5d", "filename": "gcc/testsuite/rust.test/compilable/tuple_struct2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftuple_struct2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,11 @@\n+struct Foo(i32, bool);\n+\n+fn main() {\n+    let a = Foo(1, true);\n+\n+    let b;\n+    let c;\n+\n+    b = a.0;\n+    c = a.1;\n+}"}, {"sha": "65c70584bd5cc2e33c308e633b36793ee9aad468", "filename": "gcc/testsuite/rust.test/compilable/type_infer5.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer5.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,11 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo { a: 1, b: 2 };\n+\n+    let b = a.a;\n+}"}, {"sha": "f6eac9e2eb7c3997f9c9f7b17751f61a9d8947a7", "filename": "gcc/testsuite/rust.test/compilable/type_infer6.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer6.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,12 @@\n+fn test(x: u32) -> u32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let a;\n+    a = 1;\n+    let b = test(a);\n+\n+    let c = 1;\n+    let d = test(c + 1);\n+}"}, {"sha": "1ed966617c7cc929dc7e088e9e3e95432a44827e", "filename": "gcc/testsuite/rust.test/compilable/unary_operators.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funary_operators.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funary_operators.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funary_operators.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let a: i32 = -1;\n+    let b: i32 = 3 - -1;\n+    let c: bool = !false;\n+    let d: i32 = !3;\n+}"}, {"sha": "ea1ebb3f0fdf5607039382a35b5ef2c9e8d8c7b5", "filename": "gcc/testsuite/rust.test/compilable/unit_type1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funit_type1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funit_type1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Funit_type1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let a: () = ();\n+\n+    let b;\n+    b = ();\n+}"}, {"sha": "0df0a851a0d34cc2c61883e0aba927a1f0a082e0", "filename": "gcc/testsuite/rust.test/compilable/usize1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fusize1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fusize1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fusize1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a = [1, 2, 3];\n+    let b: usize = 1;\n+    let c = a[b];\n+}"}, {"sha": "eae433aa4da3e16201ab253572d582863099b523", "filename": "gcc/testsuite/rust.test/fail_compilation/func2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,7 @@\n+fn test(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    let a = test(1);\n+}"}, {"sha": "781caf7866e24714f1036c1dbc16873f985471f5", "filename": "gcc/testsuite/rust.test/fail_compilation/func3.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ffunc3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,7 @@\n+fn test(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    let a = test(1, true);\n+}"}, {"sha": "5713d3b144ffe125263d7aa1834ae7d77e0ee508", "filename": "gcc/testsuite/rust.test/fail_compilation/immutable1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+static x: i32 = 3;\n+\n+fn main() {\n+    x = 1;\n+}"}, {"sha": "e316e72985767f840353c1ae41bb48dbb7ad9a01", "filename": "gcc/testsuite/rust.test/fail_compilation/immutable2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+const TEST_CONST: i32 = 10;\n+\n+fn main() {\n+    TEST_CONST = 1;\n+}"}, {"sha": "b310193ae8d4be0ae51a1966714724e6ed01f3da", "filename": "gcc/testsuite/rust.test/fail_compilation/immutable3.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let a = 1;\n+    a += 2;\n+}"}, {"sha": "d2e740fb7d8ccc50a3d76d46b93d25421be6d5bf", "filename": "gcc/testsuite/rust.test/fail_compilation/immutable4.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable4.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let array: [i32; 3] = [0; 3];\n+    array[0] = 1;\n+}"}, {"sha": "c442ba580dd57cc899eaf6f3ed5e7aec52de73bf", "filename": "gcc/testsuite/rust.test/fail_compilation/immutable5.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimmutable5.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,6 @@\n+struct Foo(f32, i32);\n+\n+fn main() {\n+    let a = Foo(1, 2);\n+    a.0 = 22;\n+}"}, {"sha": "b450e1873f715f8aeaff31f387ff97e61a20b1e1", "filename": "gcc/testsuite/rust.test/fail_compilation/implicit_returns_err1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,12 @@\n+fn test(x: i32) -> i32 {\n+    if x > 1 {\n+        1\n+    } else {\n+        2\n+    }\n+    3\n+}\n+\n+fn main() {\n+    let a = test(1);\n+}"}, {"sha": "b5fbd0ac642bf9660a84bbeebbd9292e9805a03c", "filename": "gcc/testsuite/rust.test/fail_compilation/implicit_returns_err2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn test(x: i32) -> i32 {\n+    return 1;\n+    true\n+}\n+\n+fn main() {\n+    let a = test(1);\n+}"}, {"sha": "a83385e8a44a148a2a50930f5f70bee6fec1b8e2", "filename": "gcc/testsuite/rust.test/fail_compilation/implicit_returns_err3.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fimplicit_returns_err3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,9 @@\n+fn test(x: i32) -> i32 {\n+    if x > 1 {\n+        1\n+    }\n+}\n+\n+fn main() {\n+    let a = test(9);\n+}"}, {"sha": "3eadaef1e597909665c647642ab4cd95946f3646", "filename": "gcc/testsuite/rust.test/fail_compilation/struct_init1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fstruct_init1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fstruct_init1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fstruct_init1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+struct Foo {\n+    a: f32,\n+    b: f32,\n+}\n+\n+fn main() {\n+    let a = Foo { 0: 10.0, 1: 20.0 };\n+}"}, {"sha": "d551365200361160659f0688cbd9781381451a49", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a: (i32, bool) = (123, 123);\n+    let b;\n+    b = (456, 5f32);\n+}"}, {"sha": "0df07d9d94792b9a4e7906feb9e7bfd9939f49c1", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple_struct1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+struct Foo {\n+    one: i32,\n+    two: i32,\n+}\n+\n+fn main() {\n+    let a = Foo(1, 2);\n+}"}, {"sha": "6c3c0ab2e59b245d0f2ec33759ce232e1e7e19e4", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple_struct2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct2.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+struct Bar(i32, i32, bool);\n+\n+fn main() {\n+    let a = Bar(1, 2);\n+}"}, {"sha": "832df8bd7bcad5f400eec9e93e52df3ece725d5d", "filename": "gcc/testsuite/rust.test/fail_compilation/tuple_struct3.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Ftuple_struct3.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+struct Foo(i32, i32, bool);\n+\n+fn main() {\n+    let c = Foo(1, 2f32, true);\n+}"}, {"sha": "476b908f0835db3225977b4074cafbd77f0cd47a", "filename": "gcc/testsuite/rust.test/fail_compilation/unary_negation.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Funary_negation.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Funary_negation.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Funary_negation.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let a: i32 = -1;\n+    let b: i32 = 3 - -1;\n+    let c: bool = !false;\n+    let d: i32 = !3;\n+\n+    let e: f32 = -true;\n+}"}, {"sha": "f358f0e9c278a05875361cce34de2b369546f62e", "filename": "gcc/testsuite/rust.test/fail_compilation/unary_not.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Funary_not.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Funary_not.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Funary_not.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let a: i32 = -1;\n+    let b: i32 = 3 - -1;\n+    let c: bool = !false;\n+    let d: i32 = !3;\n+\n+    let e: f32 = !5f32;\n+}"}, {"sha": "92393e7dde9dc1b6de9dddfe3df4e6c9b4d3e9f6", "filename": "gcc/testsuite/rust.test/fail_compilation/usize1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fusize1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b498895bcc0d99f00f0a89707d068d08e14246/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fusize1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fusize1.rs?ref=61b498895bcc0d99f00f0a89707d068d08e14246", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a = [1, 2, 3];\n+    let b: u32 = 1;\n+    let c = a[b];\n+}"}]}