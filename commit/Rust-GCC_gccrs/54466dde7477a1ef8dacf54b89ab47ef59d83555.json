{"sha": "54466dde7477a1ef8dacf54b89ab47ef59d83555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0NjZkZGU3NDc3YTFlZjhkYWNmNTRiODlhYjQ3ZWY1OWQ4MzU1NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-06-09T22:41:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-06-09T22:41:29Z"}, "message": "Use backend interface for zero initialization.\n\n\t* go-gcc.cc (Gcc_backend::zero_expression): New function.\n\nFrom-SVN: r174863", "tree": {"sha": "604567091a09ec16402717021e6d8b77365db436", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/604567091a09ec16402717021e6d8b77365db436"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54466dde7477a1ef8dacf54b89ab47ef59d83555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54466dde7477a1ef8dacf54b89ab47ef59d83555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54466dde7477a1ef8dacf54b89ab47ef59d83555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54466dde7477a1ef8dacf54b89ab47ef59d83555/comments", "author": null, "committer": null, "parents": [{"sha": "3be68b64dbcc0fe2ee75ef00c88f5c7239990f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3be68b64dbcc0fe2ee75ef00c88f5c7239990f66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3be68b64dbcc0fe2ee75ef00c88f5c7239990f66"}], "stats": {"total": 462, "additions": 72, "deletions": 390}, "files": [{"sha": "aac428bfa8b5b9fcf1a9b8d5111a2963eccdf2b2", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -1,3 +1,7 @@\n+2011-06-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::zero_expression): New function.\n+\n 2011-06-07  Richard Guenther  <rguenther@suse.de>\n \n \t* go-lang.c (go_langhook_init): Do not set"}, {"sha": "1299e9b53be29b61b08d3207dd8e3e14d4ea54a4", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -194,6 +194,11 @@ class Gcc_backend : public Backend\n   bool\n   is_circular_pointer_type(Btype*);\n \n+  // Expressions.\n+\n+  Bexpression*\n+  zero_expression(Btype*);\n+\n   // Statements.\n \n   Bstatement*\n@@ -700,6 +705,20 @@ Gcc_backend::is_circular_pointer_type(Btype* btype)\n   return btype->get_tree() == ptr_type_node;\n }\n \n+// Return the zero value for a type.\n+\n+Bexpression*\n+Gcc_backend::zero_expression(Btype* btype)\n+{\n+  tree t = btype->get_tree();\n+  tree ret;\n+  if (t == error_mark_node)\n+    ret = error_mark_node;\n+  else\n+    ret = build_zero_cst(t);\n+  return tree_to_expr(ret);\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "5ece2e698fb024acde7c91ba0a8615353f0d45c7", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -198,6 +198,14 @@ class Backend\n   virtual bool\n   is_circular_pointer_type(Btype*) = 0;\n \n+  // Expressions.\n+\n+  // Return an expression for a zero value of the given type.  This is\n+  // used for cases such as local variable initialization and\n+  // converting nil to other types.\n+  virtual Bexpression*\n+  zero_expression(Btype*) = 0;\n+\n   // Statements.\n \n   // Create an error statement.  This is used for cases which should"}, {"sha": "f656acb90ff5c6c8002dec492e91dba4f9e6a8e6", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -318,7 +318,10 @@ Expression::convert_type_to_interface(Translate_context* context,\n   // When setting an interface to nil, we just set both fields to\n   // NULL.\n   if (rhs_type->is_nil_type())\n-    return lhs_type->get_init_tree(gogo, false);\n+    {\n+      Btype* lhs_btype = lhs_type->get_backend(gogo);\n+      return expr_to_tree(gogo->backend()->zero_expression(lhs_btype));\n+    }\n \n   // This should have been checked already.\n   go_assert(lhs_interface_type->implements_interface(rhs_type, NULL));\n@@ -10046,12 +10049,14 @@ Map_index_expression::do_get_tree(Translate_context* context)\n     }\n   else\n     {\n+      Gogo* gogo = context->gogo();\n+      Btype* val_btype = type->val_type()->get_backend(gogo);\n+      Bexpression* val_zero = gogo->backend()->zero_expression(val_btype);\n       return fold_build3(COND_EXPR, val_type_tree,\n \t\t\t fold_build2(EQ_EXPR, boolean_type_node, valptr,\n \t\t\t\t     fold_convert(TREE_TYPE(valptr),\n \t\t\t\t\t\t  null_pointer_node)),\n-\t\t\t type->val_type()->get_init_tree(context->gogo(),\n-\t\t\t\t\t\t\t false),\n+\t\t\t expr_to_tree(val_zero),\n \t\t\t build_fold_indirect_ref(valptr));\n     }\n }\n@@ -10958,7 +10963,10 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n   Gogo* gogo = context->gogo();\n \n   if (this->vals_ == NULL)\n-    return this->type_->get_init_tree(gogo, false);\n+    {\n+      Btype* btype = this->type_->get_backend(gogo);\n+      return expr_to_tree(gogo->backend()->zero_expression(btype));\n+    }\n \n   tree type_tree = type_to_tree(this->type_->get_backend(gogo));\n   if (type_tree == error_mark_node)\n@@ -10977,12 +10985,14 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n     {\n       go_assert(pf != fields->end());\n \n+      Btype* fbtype = pf->type()->get_backend(gogo);\n+\n       tree val;\n       if (pv == this->vals_->end())\n-\tval = pf->type()->get_init_tree(gogo, false);\n+\tval = expr_to_tree(gogo->backend()->zero_expression(fbtype));\n       else if (*pv == NULL)\n \t{\n-\t  val = pf->type()->get_init_tree(gogo, false);\n+\t  val = expr_to_tree(gogo->backend()->zero_expression(fbtype));\n \t  ++pv;\n \t}\n       else\n@@ -11217,7 +11227,12 @@ Array_construction_expression::get_constructor_tree(Translate_context* context,\n \t  constructor_elt* elt = VEC_quick_push(constructor_elt, values, NULL);\n \t  elt->index = size_int(i);\n \t  if (*pv == NULL)\n-\t    elt->value = element_type->get_init_tree(context->gogo(), false);\n+\t    {\n+\t      Gogo* gogo = context->gogo();\n+\t      Btype* ebtype = element_type->get_backend(gogo);\n+\t      Bexpression *zv = gogo->backend()->zero_expression(ebtype);\n+\t      elt->value = expr_to_tree(zv);\n+\t    }\n \t  else\n \t    {\n \t      tree value_tree = (*pv)->get_tree(context);\n@@ -11363,7 +11378,9 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n       VEC(constructor_elt,gc)* vec = VEC_alloc(constructor_elt, gc, 1);\n       constructor_elt* elt = VEC_quick_push(constructor_elt, vec, NULL);\n       elt->index = size_int(0);\n-      elt->value = element_type->get_init_tree(context->gogo(), false);\n+      Gogo* gogo = context->gogo();\n+      Btype* btype = element_type->get_backend(gogo);\n+      elt->value = expr_to_tree(gogo->backend()->zero_expression(btype));\n       values = build_constructor(constructor_type, vec);\n       if (TREE_CONSTANT(elt->value))\n \tTREE_CONSTANT(values) = 1;"}, {"sha": "8c41f7462e68f2adc4a6d62273924abf8967b1ab", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -1035,9 +1035,10 @@ Variable::get_init_tree(Gogo* gogo, Named_object* function)\n   if (this->init_ == NULL)\n     {\n       go_assert(!this->is_parameter_);\n-      return this->type_->get_init_tree(gogo,\n-\t\t\t\t\t(this->is_global_\n-\t\t\t\t\t || this->is_in_heap()));\n+      if (this->is_global_ || this->is_in_heap())\n+\treturn NULL;\n+      Btype* btype = this->type_->get_backend(gogo);\n+      return expr_to_tree(gogo->backend()->zero_expression(btype));\n     }\n   else\n     {\n@@ -1286,7 +1287,8 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n \t\t\t\t\t\tnull_pointer_node));\n   tree ind = build_fold_indirect_ref_loc(loc, parm_decl);\n   TREE_THIS_NOTRAP(ind) = 1;\n-  tree zero_init = no->var_value()->type()->get_init_tree(gogo, false);\n+  Btype* btype = no->var_value()->type()->get_backend(gogo);\n+  tree zero_init = expr_to_tree(gogo->backend()->zero_expression(btype));\n   tree init = fold_build3_loc(loc, COND_EXPR, TREE_TYPE(ind),\n \t\t\t      check, ind, zero_init);\n \n@@ -1423,7 +1425,10 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t  Type* type = (*p)->result_var_value()->type();\n \t  tree init;\n \t  if (!(*p)->result_var_value()->is_in_heap())\n-\t    init = type->get_init_tree(gogo, false);\n+\t    {\n+\t      Btype* btype = type->get_backend(gogo);\n+\t      init = expr_to_tree(gogo->backend()->zero_expression(btype));\n+\t    }\n \t  else\n \t    {\n \t      source_location loc = (*p)->location();\n@@ -1432,20 +1437,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t\t\t\t\t\t TYPE_SIZE_UNIT(type_tree),\n \t\t\t\t\t\t loc);\n \t      tree ptr_type_tree = build_pointer_type(type_tree);\n-\t      tree subinit = type->get_init_tree(gogo, true);\n-\t      if (subinit == NULL_TREE)\n-\t\tinit = fold_convert_loc(loc, ptr_type_tree, space);\n-\t      else\n-\t\t{\n-\t\t  space = save_expr(space);\n-\t\t  space = fold_convert_loc(loc, ptr_type_tree, space);\n-\t\t  tree spaceref = build_fold_indirect_ref_loc(loc, space);\n-\t\t  TREE_THIS_NOTRAP(spaceref) = 1;\n-\t\t  tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n-\t\t\t\t\t     spaceref, subinit);\n-\t\t  init = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(space),\n-\t\t\t\t\t set, space);\n-\t\t}\n+\t      init = fold_convert_loc(loc, ptr_type_tree, space);\n \t    }\n \n \t  if (var_decl != error_mark_node)"}, {"sha": "c3c014e5962ece63a0fcb3febe4b1c541bc07ccb", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -1498,6 +1498,10 @@ Check_types_traverse::variable(Named_object* named_object)\n   if (named_object->is_variable())\n     {\n       Variable* var = named_object->var_value();\n+\n+      // Give error if variable type is not defined.\n+      var->type()->base();\n+\n       Expression* init = var->init();\n       std::string reason;\n       if (init != NULL"}, {"sha": "37cca8370e5586a5aeba84ecb2268aeb98b90c08", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 306, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -913,17 +913,6 @@ Type::get_btype_without_hash(Gogo* gogo)\n   return this->btype_;\n }\n \n-// Return a tree representing a zero initialization for this type.\n-\n-tree\n-Type::get_init_tree(Gogo* gogo, bool is_clear)\n-{\n-  tree type_tree = type_to_tree(this->get_backend(gogo));\n-  if (type_tree == error_mark_node)\n-    return error_mark_node;\n-  return this->do_get_init_tree(gogo, type_tree, is_clear);\n-}\n-\n // Any type which supports the builtin make function must implement\n // this.\n \n@@ -1609,10 +1598,6 @@ class Error_type : public Type\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->error_type(); }\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool)\n-  { return error_mark_node; }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n   { return Expression::make_error(BUILTINS_LOCATION); }\n@@ -1647,10 +1632,6 @@ class Void_type : public Type\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->void_type(); }\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool)\n-  { go_unreachable(); }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n   { go_unreachable(); }\n@@ -1685,10 +1666,6 @@ class Boolean_type : public Type\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->bool_type(); }\n \n-  tree\n-  do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-  { return is_clear ? NULL : fold_convert(type_tree, boolean_false_node); }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type* name);\n \n@@ -1830,12 +1807,6 @@ Integer_type::do_get_backend(Gogo* gogo)\n   return gogo->backend()->integer_type(this->is_unsigned_, this->bits_);\n }\n \n-tree\n-Integer_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  return is_clear ? NULL : build_int_cst(type_tree, 0);\n-}\n-\n // The type descriptor for an integer type.  Integer types are always\n // named.\n \n@@ -1963,16 +1934,6 @@ Float_type::do_get_backend(Gogo* gogo)\n   return gogo->backend()->float_type(this->bits_);\n }\n \n-tree\n-Float_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-  REAL_VALUE_TYPE r;\n-  real_from_integer(&r, TYPE_MODE(type_tree), 0, 0, 0);\n-  return build_real(type_tree, r);\n-}\n-\n // The type descriptor for a float type.  Float types are always named.\n \n Expression*\n@@ -2099,19 +2060,6 @@ Complex_type::do_get_backend(Gogo* gogo)\n   return gogo->backend()->complex_type(this->bits_);\n }\n \n-// Zero initializer.\n-\n-tree\n-Complex_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-  REAL_VALUE_TYPE r;\n-  real_from_integer(&r, TYPE_MODE(TREE_TYPE(type_tree)), 0, 0, 0);\n-  return build_complex(type_tree, build_real(TREE_TYPE(type_tree), r),\n-\t\t       build_real(TREE_TYPE(type_tree), r));\n-}\n-\n // The type descriptor for a complex type.  Complex types are always\n // named.\n \n@@ -2223,32 +2171,6 @@ String_type::bytes_tree(Gogo*, tree string)\n \t\t     bytes_field, NULL_TREE);\n }\n \n-// We initialize a string to { NULL, 0 }.\n-\n-tree\n-String_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL_TREE;\n-\n-  go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n-\n-  VEC(constructor_elt, gc)* init = VEC_alloc(constructor_elt, gc, 2);\n-\n-  for (tree field = TYPE_FIELDS(type_tree);\n-       field != NULL_TREE;\n-       field = DECL_CHAIN(field))\n-    {\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n-      elt->index = field;\n-      elt->value = fold_convert(TREE_TYPE(field), size_zero_node);\n-    }\n-\n-  tree ret = build_constructor(type_tree, init);\n-  TREE_CONSTANT(ret) = 1;\n-  return ret;\n-}\n-\n // The type descriptor for the string type.\n \n Expression*\n@@ -2330,10 +2252,6 @@ class Sink_type : public Type\n   do_get_backend(Gogo*)\n   { go_unreachable(); }\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool)\n-  { go_unreachable(); }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n   { go_unreachable(); }\n@@ -2704,16 +2622,6 @@ Function_type::convert_types(Gogo* gogo)\n     }\n }\n \n-// Functions are initialized to NULL.\n-\n-tree\n-Function_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-  return fold_convert(type_tree, null_pointer_node);\n-}\n-\n // The type of a function type descriptor.\n \n Type*\n@@ -3109,16 +3017,6 @@ Pointer_type::do_get_backend(Gogo* gogo)\n   return gogo->backend()->pointer_type(to_btype);\n }\n \n-// Initialize a pointer type.\n-\n-tree\n-Pointer_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-  return fold_convert(type_tree, null_pointer_node);\n-}\n-\n // The type of a pointer type descriptor.\n \n Type*\n@@ -3262,10 +3160,6 @@ class Nil_type : public Type\n   do_get_backend(Gogo* gogo)\n   { return gogo->backend()->pointer_type(gogo->backend()->void_type()); }\n \n-  tree\n-  do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-  { return is_clear ? NULL : fold_convert(type_tree, null_pointer_node); }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n   { go_unreachable(); }\n@@ -3316,13 +3210,6 @@ class Call_multiple_result_type : public Type\n     return gogo->backend()->error_type();\n   }\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool)\n-  {\n-    go_assert(saw_errors());\n-    return error_mark_node;\n-  }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n   {\n@@ -3823,63 +3710,6 @@ Struct_type::do_get_backend(Gogo* gogo)\n   return gogo->backend()->struct_type(bfields);\n }\n \n-// Initialize struct fields.\n-\n-tree\n-Struct_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n-{\n-  if (this->fields_ == NULL || this->fields_->empty())\n-    {\n-      if (is_clear)\n-\treturn NULL;\n-      else\n-\t{\n-\t  tree ret = build_constructor(type_tree,\n-\t\t\t\t       VEC_alloc(constructor_elt, gc, 0));\n-\t  TREE_CONSTANT(ret) = 1;\n-\t  return ret;\n-\t}\n-    }\n-\n-  bool is_constant = true;\n-  bool any_fields_set = false;\n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc,\n-\t\t\t\t\t    this->fields_->size());\n-\n-  tree field = TYPE_FIELDS(type_tree);\n-  for (Struct_field_list::const_iterator p = this->fields_->begin();\n-       p != this->fields_->end();\n-       ++p, field = DECL_CHAIN(field))\n-    {\n-      tree value = p->type()->get_init_tree(gogo, is_clear);\n-      if (value == error_mark_node)\n-\treturn error_mark_node;\n-      go_assert(field != NULL_TREE);\n-      if (value != NULL)\n-\t{\n-\t  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n-\t  elt->index = field;\n-\t  elt->value = value;\n-\t  any_fields_set = true;\n-\t  if (!TREE_CONSTANT(value))\n-\t    is_constant = false;\n-\t}\n-    }\n-  go_assert(field == NULL_TREE);\n-\n-  if (!any_fields_set)\n-    {\n-      go_assert(is_clear);\n-      VEC_free(constructor_elt, gc, init);\n-      return NULL;\n-    }\n-\n-  tree ret = build_constructor(type_tree, init);\n-  if (is_constant)\n-    TREE_CONSTANT(ret) = 1;\n-  return ret;\n-}\n-\n // The type of a struct type descriptor.\n \n Type*\n@@ -4503,61 +4333,6 @@ Array_type::get_backend_length(Gogo* gogo)\n   return tree_to_expr(this->get_length_tree(gogo));\n }\n \n-// Return an initializer for an array type.\n-\n-tree\n-Array_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n-{\n-  if (this->length_ == NULL)\n-    {\n-      // Open array.\n-\n-      if (is_clear)\n-\treturn NULL;\n-\n-      go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n-\n-      VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n-\n-      for (tree field = TYPE_FIELDS(type_tree);\n-\t   field != NULL_TREE;\n-\t   field = DECL_CHAIN(field))\n-\t{\n-\t  constructor_elt* elt = VEC_quick_push(constructor_elt, init,\n-\t\t\t\t\t\tNULL);\n-\t  elt->index = field;\n-\t  elt->value = fold_convert(TREE_TYPE(field), size_zero_node);\n-\t}\n-\n-      tree ret = build_constructor(type_tree, init);\n-      TREE_CONSTANT(ret) = 1;\n-      return ret;\n-    }\n-  else\n-    {\n-      // Fixed array.\n-\n-      tree value = this->element_type_->get_init_tree(gogo, is_clear);\n-      if (value == NULL)\n-\treturn NULL;\n-      if (value == error_mark_node)\n-\treturn error_mark_node;\n-\n-      tree length_tree = this->get_length_tree(gogo);\n-      if (length_tree == error_mark_node)\n-\treturn error_mark_node;\n-\n-      length_tree = fold_convert(sizetype, length_tree);\n-      tree range = build2(RANGE_EXPR, sizetype, size_zero_node,\n-\t\t\t  fold_build2(MINUS_EXPR, sizetype,\n-\t\t\t\t      length_tree, size_one_node));\n-      tree ret = build_constructor_single(type_tree, range, value);\n-      if (TREE_CONSTANT(value))\n-\tTREE_CONSTANT(ret) = 1;\n-      return ret;\n-    }\n-}\n-\n // Handle the builtin make function for a slice.\n \n tree\n@@ -4585,10 +4360,6 @@ Array_type::do_make_expression_tree(Translate_context* context,\n     return error_mark_node;\n   tree element_size_tree = TYPE_SIZE_UNIT(element_type_tree);\n \n-  tree value = this->element_type_->get_init_tree(gogo, true);\n-  if (value == error_mark_node)\n-    return error_mark_node;\n-\n   // The first argument is the number of elements, the optional second\n   // argument is the capacity.\n   go_assert(args != NULL && args->size() >= 1 && args->size() <= 2);\n@@ -4670,9 +4441,6 @@ Array_type::do_make_expression_tree(Translate_context* context,\n   tree space = context->gogo()->allocate_memory(this->element_type_,\n \t\t\t\t\t\tsize_tree, location);\n \n-  if (value != NULL_TREE)\n-    space = save_expr(space);\n-\n   space = fold_convert(TREE_TYPE(values_field), space);\n \n   if (bad_index != NULL_TREE && bad_index != boolean_false_node)\n@@ -4685,37 +4453,7 @@ Array_type::do_make_expression_tree(Translate_context* context,\n \t\t     space);\n     }\n \n-  tree constructor = gogo->slice_constructor(type_tree, space, length_tree,\n-\t\t\t\t\t     capacity_tree);\n-\n-  if (value == NULL_TREE)\n-    {\n-      // The array contents are zero initialized.\n-      return constructor;\n-    }\n-\n-  // The elements must be initialized.\n-\n-  tree max = fold_build2_loc(location, MINUS_EXPR, TREE_TYPE(count_field),\n-\t\t\t     capacity_tree,\n-\t\t\t     fold_convert_loc(location, TREE_TYPE(count_field),\n-\t\t\t\t\t      integer_one_node));\n-\n-  tree array_type = build_array_type(element_type_tree,\n-\t\t\t\t     build_index_type(max));\n-\n-  tree value_pointer = fold_convert_loc(location,\n-\t\t\t\t\tbuild_pointer_type(array_type),\n-\t\t\t\t\tspace);\n-\n-  tree range = build2(RANGE_EXPR, sizetype, size_zero_node, max);\n-  tree space_init = build_constructor_single(array_type, range, value);\n-\n-  return build2(COMPOUND_EXPR, TREE_TYPE(constructor),\n-\t\tbuild2(MODIFY_EXPR, void_type_node,\n-\t\t       build_fold_indirect_ref(value_pointer),\n-\t\t       space_init),\n-\t\tconstructor);\n+  return gogo->slice_constructor(type_tree, space, length_tree, capacity_tree);\n }\n \n // Return a tree for a pointer to the values in ARRAY.\n@@ -5128,16 +4866,6 @@ Map_type::do_get_backend(Gogo* gogo)\n   return backend_map_type;\n }\n \n-// Initialize a map.\n-\n-tree\n-Map_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-  return fold_convert(type_tree, null_pointer_node);\n-}\n-\n // Return an expression for a newly allocated map.\n \n tree\n@@ -5374,16 +5102,6 @@ Channel_type::do_get_backend(Gogo* gogo)\n   return backend_channel_type;\n }\n \n-// Initialize a channel variable.\n-\n-tree\n-Channel_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-  return fold_convert(type_tree, null_pointer_node);\n-}\n-\n // Handle the builtin function make for a channel.\n \n tree\n@@ -6113,29 +5831,6 @@ Interface_type::do_get_backend(Gogo* gogo)\n     }\n }\n \n-// Initialization value.\n-\n-tree\n-Interface_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n-{\n-  if (is_clear)\n-    return NULL;\n-\n-  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n-  for (tree field = TYPE_FIELDS(type_tree);\n-       field != NULL_TREE;\n-       field = DECL_CHAIN(field))\n-    {\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n-      elt->index = field;\n-      elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n-    }\n-\n-  tree ret = build_constructor(type_tree, init);\n-  TREE_CONSTANT(ret) = 1;\n-  return ret;\n-}\n-\n // The type of an interface type descriptor.\n \n Type*"}, {"sha": "23e29dc7522cb59a22d2dc3f5d134a0c0aa1c2e4", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54466dde7477a1ef8dacf54b89ab47ef59d83555/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=54466dde7477a1ef8dacf54b89ab47ef59d83555", "patch": "@@ -825,19 +825,6 @@ class Type\n   Btype*\n   get_backend(Gogo*);\n \n-  // Return a tree representing a zero initialization for this type.\n-  // This will be something like an INTEGER_CST or a CONSTRUCTOR.  If\n-  // IS_CLEAR is true, then the memory is known to be zeroed; in that\n-  // case, this will return NULL if there is nothing to be done.\n-  tree\n-  get_init_tree(Gogo*, bool is_clear);\n-\n-  // Like get_init_tree, but passing in the type to use for the\n-  // initializer.\n-  tree\n-  get_typed_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n-  { return this->do_get_init_tree(gogo, type_tree, is_clear); }\n-\n   // Return a tree for a make expression applied to this type.\n   tree\n   make_expression_tree(Translate_context* context, Expression_list* args,\n@@ -895,9 +882,6 @@ class Type\n   virtual Btype*\n   do_get_backend(Gogo*) = 0;\n \n-  virtual tree\n-  do_get_init_tree(Gogo*, tree, bool) = 0;\n-\n   virtual tree\n   do_make_expression_tree(Translate_context*, Expression_list*,\n \t\t\t  source_location);\n@@ -1334,9 +1318,6 @@ class Integer_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -1406,9 +1387,6 @@ class Float_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -1474,9 +1452,6 @@ class Complex_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -1530,9 +1505,6 @@ class String_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo* gogo, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -1650,9 +1622,6 @@ class Function_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -1734,9 +1703,6 @@ class Pointer_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -1988,9 +1954,6 @@ class Struct_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -2105,9 +2068,6 @@ class Array_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   tree\n   do_make_expression_tree(Translate_context*, Expression_list*,\n \t\t\t  source_location);\n@@ -2196,9 +2156,6 @@ class Map_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   tree\n   do_make_expression_tree(Translate_context*, Expression_list*,\n \t\t\t  source_location);\n@@ -2280,9 +2237,6 @@ class Channel_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo*, tree, bool);\n-\n   tree\n   do_make_expression_tree(Translate_context*, Expression_list*,\n \t\t\t  source_location);\n@@ -2398,9 +2352,6 @@ class Interface_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo* gogo, tree, bool);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -2629,10 +2580,6 @@ class Named_type : public Type\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n-  { return this->type_->get_typed_init_tree(gogo, type_tree, is_clear); }\n-\n   tree\n   do_make_expression_tree(Translate_context* context, Expression_list* args,\n \t\t\t  source_location location)\n@@ -2773,10 +2720,6 @@ class Forward_declaration_type : public Type\n   Btype*\n   do_get_backend(Gogo* gogo);\n \n-  tree\n-  do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n-  { return this->base()->get_typed_init_tree(gogo, type_tree, is_clear); }\n-\n   tree\n   do_make_expression_tree(Translate_context* context, Expression_list* args,\n \t\t\t  source_location location)"}]}