{"sha": "4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgwM2EzNGFhMmU4Mzc0OWIwNzJkMWIzMDEwNmZkM2RhZTVmMWNmNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-22T21:22:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-22T21:22:42Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1057", "tree": {"sha": "a6b847e987fecc2c73f24ccdd2508fa88e45a40e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6b847e987fecc2c73f24ccdd2508fa88e45a40e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/comments", "author": null, "committer": null, "parents": [{"sha": "af189bf3f3c775d09ba8c624ff47401556a98761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af189bf3f3c775d09ba8c624ff47401556a98761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af189bf3f3c775d09ba8c624ff47401556a98761"}], "stats": {"total": 186, "additions": 116, "deletions": 70}, "files": [{"sha": "389885def8417d838cff27e458b229e68af7942a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "patch": "@@ -1148,26 +1148,27 @@ SYSCALLS.c.X: $(srcdir)/sys-types.h $(srcdir)/sys-protos.h $(GCC_PASSES)\n \t-rm -f SYSCALLS.c\n \n test-protoize-simple: ./protoize ./unprotoize $(GCC_PASSES)\n-\t-rm -f tmp-proto.*\n+\t-rm -f tmp-proto.[cso]\n \tcp $(srcdir)/protoize.c tmp-proto.c\n \tchmod u+w tmp-proto.c\n-\t./protoize -N -B ./ -c \"-B./ -Wall -Wwrite-strings $(CFLAGS) \\\n-\t  $(INCLUDES) \\\n+\t./protoize -N -B ./ -x getopt.h -c \"-B./ -Wall -Wwrite-strings \\\n+\t  $(CFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=0 \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=0 \\\n \t  -DCROSS_INCLUDE_DIR=0 \\\n \t  -DSTD_PROTO_DIR=0\" tmp-proto.c\n-\t@echo Expect 324 lines of differences.\n-\tdiff $(srcdir)/protoize.c tmp-proto.c | wc -l\n-\t./unprotoize -N -c \"-B./ -Wall -Wwrite-strings $(CFLAGS) \\\n-\t  $(INCLUDES) \\\n+\t@echo '**********' Expect 402 lines of differences.\n+\t-diff $(srcdir)/protoize.c tmp-proto.c > tmp-proto.diff\n+\t-wc -l tmp-proto.diff\n+\t./unprotoize -N -x getopt.h -c \"-B./ -Wall -Wwrite-strings \\\n+\t  $(CFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=0 \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=0 \\\n \t  -DCROSS_INCLUDE_DIR=0 \\\n \t  -DSTD_PROTO_DIR=0\" tmp-proto.c\n \t@echo Expect zero differences.\n \tdiff $(srcdir)/protoize.c tmp-proto.c | cat\n-\t-rm -f tmp-proto.*\n+\t-rm -f tmp-proto.[cso]\n \f\n # Remake the info files.\n \n@@ -1203,8 +1204,8 @@ mostlyclean:\n \t-rm -f tmplibgcc* tmpcopy\n \tfor name in $(LIB1FUNCS); do rm -f $${name}.c; done\n # Delete other temporary files.\n-\t-rm -f tmp-float.h tmp-*proto.1 tmp-gcc.xtar.Z tmp-limits.h gccnew\n-\t-rm -f tmp-foo1 tmp-foo2 tmp-proto.c\n+\t-rm -f tmp-float.h tmp-gcc.xtar.Z tmp-limits.h gccnew\n+\t-rm -f tmp-foo1 tmp-foo2 tmp-proto.*\n # Delete the stamp files.\n \t-rm -f stamp-* tmp-*\n # Delete debugging dump files.\n@@ -1374,7 +1375,9 @@ install-common: native install-dir\n \t  ln $(bindir)/gcc $(bindir)/gcc-$(target)-1; \\\n \t  mv $(bindir)/gcc-$(target)-1 $(bindir)/gcc-$(target); \\\n \tfi\n+\t-rm -f $(bindir)/c++\n \t$(INSTALL_PROGRAM) $(srcdir)/c++ $(bindir)/c++\n+\t-rm -f $(bindir)/g++\n \t$(INSTALL_PROGRAM) $(srcdir)/g++ $(bindir)/g++\n \t-rm -f $(libsubdir)/cpp\n \t$(INSTALL_PROGRAM) cpp $(libsubdir)/cpp"}, {"sha": "c52b462ad4ced7ef410938979632304ce1f7548b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "patch": "@@ -2617,6 +2617,7 @@ builtin_function (name, type, function_code, library_name)\n      char *name;\n      tree type;\n      enum built_in_function function_code;\n+  TREE_NO_UNUSED_WARNING (decl) = 1;\n      char *library_name;\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n@@ -2629,6 +2630,7 @@ builtin_function (name, type, function_code, library_name)\n     DECL_BUILT_IN_NONANSI (decl) = 1;\n   if (library_name)\n     DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n+  TREE_NO_UNUSED_WARNING (decl) = 1;\n   make_decl_rtl (decl, 0, 1);\n   pushdecl (decl);\n   if (function_code != NOT_BUILT_IN)"}, {"sha": "d5473cb0878c933d00e3e04a37b49609903812bf", "filename": "gcc/combine.c", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "patch": "@@ -6572,7 +6572,7 @@ simplify_comparison (code, pop0, pop1)\n \t not on in our mode.  */\n       const_op = INTVAL (op1);\n       if (mode_width <= HOST_BITS_PER_INT)\n-\tconst_op &= GET_MODE_MASK (mode);\n+\tconst_op &= mask;\n \n       /* If we are comparing against a constant power of two and the value\n \t being compared has only that single significant bit (e.g., it was\n@@ -6590,26 +6590,31 @@ simplify_comparison (code, pop0, pop1)\n \t}\n \n       /* Do some canonicalizations based on the comparison code.  We prefer\n-\t comparisons against zero and then prefer equality comparisons.  */\n+\t comparisons against zero and then prefer equality comparisons.  \n+\t If we can reduce the size of a constant, we will do that too.  */\n \n       switch (code)\n \t{\n \tcase LT:\n-\t  /* < 1 is equivalent to <= 0 */\n-\t  if (const_op == 1)\n+\t  /* < C is equivalent to <= (C - 1) */\n+\t  if (const_op > 0)\n \t    {\n-\t      op1 = const0_rtx;\n-\t      const_op = 0;\n+\t      const_op -= 1;\n+\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n \t      code = LE;\n \t      /* ... fall through to LE case below.  */\n \t    }\n \t  else\n \t    break;\n \n \tcase LE:\n-\t  /* <= -1 is equivalent to < 0 */\n-\t  if (op1 == constm1_rtx)\n-\t    op1 = const0_rtx, const_op = 0, code = LT;\n+\t  /* <= C is equivalent to < (C + 1); we do this for C < 0  */\n+\t  if (const_op < 0)\n+\t    {\n+\t      const_op += 1;\n+\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      code = LT;\n+\t    }\n \n \t  /* If we are doing a <= 0 comparison on a value known to have\n \t     a zero sign bit, we can replace this with == 0.  */\n@@ -6621,21 +6626,25 @@ simplify_comparison (code, pop0, pop1)\n \t  break;\n \n \tcase GE:\n-\t  /* >= 1 is equivalent to > 0. */\n-\t  if (const_op == 1)\n+\t  /* >= C is equivalent to > (C - 1). */\n+\t  if (const_op > 0)\n \t    {\n-\t      op1 = const0_rtx;\n-\t      const_op = 0;\n+\t      const_op -= 1;\n+\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n \t      code = GT;\n \t      /* ... fall through to GT below.  */\n \t    }\n \t  else\n \t    break;\n \n \tcase GT:\n-\t  /* > -1 is equivalent to >= 0.  */\n-\t  if (op1 == constm1_rtx)\n-\t    op1 = const0_rtx, const_op = 0, code = GE;\n+\t  /* > C is equivalent to >= (C + 1); we do this for C < 0*/\n+\t  if (const_op < 0)\n+\t    {\n+\t      const_op += 1;\n+\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      code = GE;\n+\t    }\n \n \t  /* If we are doing a > 0 comparison on a value known to have\n \t     a zero sign bit, we can replace this with != 0.  */\n@@ -6646,24 +6655,36 @@ simplify_comparison (code, pop0, pop1)\n \t    code = NE;\n \t  break;\n \n-\tcase GEU:\n-\t  /* unsigned >= 1 is equivalent to != 0 */\n-\t  if (const_op == 1)\n-\t    op1 = const0_rtx, const_op = 0, code = NE;\n-\t  break;\n-\n \tcase LTU:\n-\t  /* unsigned < 1 is equivalent to == 0 */\n-\t  if (const_op == 1)\n-\t    op1 = const0_rtx, const_op = 0, code = EQ;\n-\t  break;\n+\t  /* < C is equivalent to <= (C - 1).  */\n+\t  if (const_op > 0)\n+\t    {\n+\t      const_op -= 1;\n+\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      code = LEU;\n+\t      /* ... fall through ... */\n+\t    }\n+\t  else\n+\t    break;\n \n \tcase LEU:\n \t  /* unsigned <= 0 is equivalent to == 0 */\n \t  if (const_op == 0)\n \t    code = EQ;\n \t  break;\n \n+\tcase GEU:\n+\t  /* >= C is equivalent to < (C - 1).  */\n+\t  if (const_op > 1)\n+\t    {\n+\t      const_op -= 1;\n+\t      op1 = gen_rtx (CONST_INT, VOIDmode, const_op);\n+\t      code = GTU;\n+\t      /* ... fall through ... */\n+\t    }\n+\t  else\n+\t    break;\n+\n \tcase GTU:\n \t  /* unsigned > 0 is equivalent to != 0 */\n \t  if (const_op == 0)"}, {"sha": "526cade581eed02734c8d6cf4752a4ee2203a1be", "filename": "gcc/reload.c", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "patch": "@@ -4264,15 +4264,19 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n     case REG:\n       i = REGNO (x);\n \n-      if (i >= FIRST_PSEUDO_REGISTER && reg_renumber[i] == -1\n-\t  && ((reg_equiv_address[i]\n-\t       && refers_to_regno_for_reload_p (regno, endregno,\n-\t\t\t\t\t\treg_equiv_address[i], 0))\n-\t      || (reg_equiv_mem[i]\n-\t\t  && refers_to_regno_for_reload_p (regno, endregno,\n-\t\t\t\t\t\t   XEXP (reg_equiv_mem[i], 0),\n-\t\t\t\t\t\t   0))))\n-\treturn 1;\n+      /* If this is a pseudo, a hard register must not have been allocated.\n+\t X must therefore either be a constant or be in memory.  */\n+      if (i >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (reg_equiv_memory_loc[i])\n+\t    return refers_to_regno_for_reload_p (regno, endregno,\n+\t\t\t\t\t\t reg_equiv_memory_loc[i], 0);\n+\n+\t  if (reg_equiv_constant[i])\n+\t    return 0;\n+\n+\t  abort ();\n+\t}\n \n       return (endregno > i\n \t      && regno < i + (i < FIRST_PSEUDO_REGISTER \n@@ -4372,34 +4376,23 @@ reg_overlap_mentioned_for_reload_p (x, in)\n   else if (GET_CODE (x) == REG)\n     {\n       regno = REGNO (x);\n-      if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] == -1\n-\t  && ((reg_equiv_address[regno]\n-\t       && reg_overlap_mentioned_for_reload_p (reg_equiv_address[regno],\n-\t\t\t\t\t\t      in))\n-\t      || (reg_equiv_mem[regno]\n-\t\t  && reg_overlap_mentioned_for_reload_p (reg_equiv_mem[regno],\n-\t\t\t\t\t\t\t in))))\n-\treturn 1;\n+\n+      /* If this is a pseudo, it must not have been assigned a hard register.\n+\t Therefore, it must either be in memory or be a constant.  */\n+\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (reg_equiv_memory_loc[regno])\n+\t    return refers_to_mem_for_reload_p (in);\n+\t  else if (reg_equiv_constant[regno])\n+\t    return 0;\n+\t  abort ();\n+\t}\n     }\n   else if (CONSTANT_P (x))\n     return 0;\n   else if (GET_CODE (x) == MEM)\n-    {\n-      char *fmt;\n-      int i;\n-\n-      if (GET_CODE (in) == MEM)\n-\treturn 1;\n-\n-      fmt = GET_RTX_FORMAT (GET_CODE (in));\n-\n-      for (i = GET_RTX_LENGTH (GET_CODE (in)) - 1; i >= 0; i--)\n-\tif (fmt[i] == 'e' && reg_overlap_mentioned_for_reload_p (x,\n-\t\t\t\t\t\t\t\t XEXP (in, i)))\n-\t  return 1;\n-\n-      return 0;\n-    }\n+    return refers_to_mem_for_reload_p (in);\n   else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n \t   || GET_CODE (x) == CC0)\n     return reg_mentioned_p (x, in);\n@@ -4411,6 +4404,33 @@ reg_overlap_mentioned_for_reload_p (x, in)\n \n   return refers_to_regno_for_reload_p (regno, endregno, in, 0);\n }\n+\n+/* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n+   registers.  */\n+\n+int\n+refers_to_mem_for_reload_p (x)\n+     rtx x;\n+{\n+  char *fmt;\n+  int i;\n+\n+  if (GET_CODE (x) == MEM)\n+    return 1;\n+\n+  if (GET_CODE (x) == REG)\n+    return (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t    && reg_equiv_memory_loc[REGNO (x)]);\n+\t\t\t\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e'\n+\t&& (GET_CODE (XEXP (x, i)) == MEM\n+\t    || refers_to_mem_for_reload_p (XEXP (x, i))))\n+      return 1;\n+  \n+  return 0;\n+}\n \f\n #if 0\n "}, {"sha": "7f2a9fc63ffa704d3b1f7ff52281d0e659447748", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4803a34aa2e83749b072d1b30106fd3dae5f1cf5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4803a34aa2e83749b072d1b30106fd3dae5f1cf5", "patch": "@@ -89,7 +89,7 @@ rtx *reg_equiv_constant;\n    prior to any register elimination (such as frame pointer to stack\n    pointer).  Depending on whether or not it is a valid address, this value\n    is transferred to either reg_equiv_address or reg_equiv_mem.  */\n-static rtx *reg_equiv_memory_loc;\n+rtx *reg_equiv_memory_loc;\n \n /* Element N is the address of stack slot to which pseudo reg N is equivalent.\n    This is used when the address is not valid as a memory address"}]}