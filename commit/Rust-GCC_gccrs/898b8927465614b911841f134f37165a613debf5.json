{"sha": "898b8927465614b911841f134f37165a613debf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk4Yjg5Mjc0NjU2MTRiOTExODQxZjEzNGYzNzE2NWE2MTNkZWJmNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-26T22:05:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-26T22:05:50Z"}, "message": "cgraphbuild.c (build_cgraph_edges): Update call of cgraph_create_edge and cgraph_create_indirect_edge.\n\n\n\t* cgraphbuild.c (build_cgraph_edges): Update call\n\tof cgraph_create_edge and cgraph_create_indirect_edge.\n\t* cgraph.c (cgraph_create_edge_including_clones,\n\tcgraph_create_edge_1, cgraph_allocate_init_indirect_info,\n\tcgraph_update_edges_for_call_stmt_node): Do not take nest\n\targument; do not initialize call_stmt_size/time.\n\t(dump_cgraph_node): Do not dump nest.\n\t(cgraph_clone_edge): Do not take loop_nest argument;\n\tdo not propagate it; do not clone call_stmt_size/time.\n\t(cgraph_clone_node): Likewise.\n\t(cgraph_create_virtual_clone): Update.\n\t* cgraph.h (struct cgraph_edge): Remove\n\tcall_stmt_size/call_stmt_time/loop_nest.\n\t(cgraph_create_edge, cgraph_create_indirect_edge,\n\tcgraph_create_edge_including_clones, cgraph_clone_node): Update\n\tprototype.\n\t* tree-emutls.c (gen_emutls_addr): Update.\n\t* ipa-inline-transform.c (update_noncloned_frequencies): Do not handle\n\tloop_nest; handle indirect calls, too.\n\t(clone_inlined_nodes): Do not care about updating inline summaries.\n\t* cgraphunit.c (cgraph_copy_node_for_versioning): Update.\n\t* lto-cgraph.c (lto_output_edge, input_node, input_edge): Do not\n\tstream call_stmt_size/call_stmt_time/loop_nest.\n\t* ipa-inline.c (edge_badness): Update.\n\t(ipa_inline): dump summaries after inlining.\n\t* ipa-inline.h (struct inline_edge_summary, inline_edge_summary_t):\n\tnew.\n\t(inline_edge_summary): New function.\n\t* ipa-inline-analysis.c (edge_duplication_hook_holder): New holder.\n\t(inline_edge_removal_hook): Handle edge summaries.\n\t(inline_edge_duplication_hook): New hook.\n\t(inline_summary_alloc): Alloc hooks.\n\t(initialize_growth_caches): Do not register removal hooks.\n\t(free_growth_caches); Do not free removal hook.\n\t(dump_inline_edge_summary): New function.\n\t(dump_inline_summary): Use it.\n\t(estimate_function_body_sizes, estimate_edge_size_and_time): Update.\n\t(inline_update_callee_summaries): New function.\n\t(inline_merge_summary): Use it.\n\t(do_estimate_edge_time, do_estimate_edge_growth): Update.\n\t(read_inline_edge_summary): New function.\n\t(inline_read_section): Use it.\n\t(write_inline_edge_summary): New function.\n\t(inline_write_summary): Use it.\n\t(inline_free_summary): Free edge new holders.\n\t* tree-inline.c (copy_bb): Update.\n\nFrom-SVN: r172989", "tree": {"sha": "9dd85417eff67af5337a8aed679418604daf66df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dd85417eff67af5337a8aed679418604daf66df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/898b8927465614b911841f134f37165a613debf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898b8927465614b911841f134f37165a613debf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/898b8927465614b911841f134f37165a613debf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898b8927465614b911841f134f37165a613debf5/comments", "author": null, "committer": null, "parents": [{"sha": "ffa037724f62366e4e78b496f182d999ea7b75ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa037724f62366e4e78b496f182d999ea7b75ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa037724f62366e4e78b496f182d999ea7b75ce"}], "stats": {"total": 404, "additions": 291, "deletions": 113}, "files": [{"sha": "1b1f4d26f7292329dd2c2938bbbb3f9e1ab46c59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -1,3 +1,52 @@\n+2011-04-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (build_cgraph_edges): Update call\n+\tof cgraph_create_edge and cgraph_create_indirect_edge.\n+\t* cgraph.c (cgraph_create_edge_including_clones,\n+\tcgraph_create_edge_1, cgraph_allocate_init_indirect_info,\n+\tcgraph_update_edges_for_call_stmt_node): Do not take nest\n+\targument; do not initialize call_stmt_size/time.\n+\t(dump_cgraph_node): Do not dump nest.\n+\t(cgraph_clone_edge): Do not take loop_nest argument;\n+\tdo not propagate it; do not clone call_stmt_size/time.\n+\t(cgraph_clone_node): Likewise.\n+\t(cgraph_create_virtual_clone): Update.\n+\t* cgraph.h (struct cgraph_edge): Remove\n+\tcall_stmt_size/call_stmt_time/loop_nest.\n+\t(cgraph_create_edge, cgraph_create_indirect_edge,\n+\tcgraph_create_edge_including_clones, cgraph_clone_node): Update\n+\tprototype.\n+\t* tree-emutls.c (gen_emutls_addr): Update.\n+\t* ipa-inline-transform.c (update_noncloned_frequencies): Do not handle\n+\tloop_nest; handle indirect calls, too.\n+\t(clone_inlined_nodes): Do not care about updating inline summaries.\n+\t* cgraphunit.c (cgraph_copy_node_for_versioning): Update.\n+\t* lto-cgraph.c (lto_output_edge, input_node, input_edge): Do not\n+\tstream call_stmt_size/call_stmt_time/loop_nest.\n+\t* ipa-inline.c (edge_badness): Update.\n+\t(ipa_inline): dump summaries after inlining.\n+\t* ipa-inline.h (struct inline_edge_summary, inline_edge_summary_t):\n+\tnew.\n+\t(inline_edge_summary): New function.\n+\t* ipa-inline-analysis.c (edge_duplication_hook_holder): New holder.\n+\t(inline_edge_removal_hook): Handle edge summaries.\n+\t(inline_edge_duplication_hook): New hook.\n+\t(inline_summary_alloc): Alloc hooks.\n+\t(initialize_growth_caches): Do not register removal hooks.\n+\t(free_growth_caches); Do not free removal hook.\n+\t(dump_inline_edge_summary): New function.\n+\t(dump_inline_summary): Use it.\n+\t(estimate_function_body_sizes, estimate_edge_size_and_time): Update.\n+\t(inline_update_callee_summaries): New function.\n+\t(inline_merge_summary): Use it.\n+\t(do_estimate_edge_time, do_estimate_edge_growth): Update.\n+\t(read_inline_edge_summary): New function.\n+\t(inline_read_section): Use it.\n+\t(write_inline_edge_summary): New function.\n+\t(inline_write_summary): Use it.\n+\t(inline_free_summary): Free edge new holders.\n+\t* tree-inline.c (copy_bb): Update.\n+\n 2011-04-26  Jason Merrill  <jason@redhat.com>\n \n \t* tree-eh.c (lower_try_finally_switch): Create the label along with"}, {"sha": "da020fe1ab29dc6f32c6aa132726df896d0ad1c3", "filename": "gcc/cgraph.c", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -921,15 +921,15 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n \t\t\t\t     struct cgraph_node *callee,\n \t\t\t\t     gimple old_stmt,\n \t\t\t\t     gimple stmt, gcov_type count,\n-\t\t\t\t     int freq, int loop_depth,\n+\t\t\t\t     int freq,\n \t\t\t\t     cgraph_inline_failed_t reason)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n \n   if (!cgraph_edge (orig, stmt))\n     {\n-      edge = cgraph_create_edge (orig, callee, stmt, count, freq, loop_depth);\n+      edge = cgraph_create_edge (orig, callee, stmt, count, freq);\n       edge->inline_failed = reason;\n     }\n \n@@ -948,7 +948,7 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n \telse if (!cgraph_edge (node, stmt))\n \t  {\n \t    edge = cgraph_create_edge (node, callee, stmt, count,\n-\t\t\t\t       freq, loop_depth);\n+\t\t\t\t       freq);\n \t    edge->inline_failed = reason;\n \t  }\n \n@@ -972,7 +972,7 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n \n static struct cgraph_edge *\n cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t       gimple call_stmt, gcov_type count, int freq, int nest)\n+\t\t       gimple call_stmt, gcov_type count, int freq)\n {\n   struct cgraph_edge *edge;\n \n@@ -1011,11 +1011,8 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n   edge->frequency = freq;\n   gcc_assert (freq >= 0);\n   gcc_assert (freq <= CGRAPH_FREQ_MAX);\n-  edge->loop_nest = nest;\n \n   edge->call_stmt = call_stmt;\n-  edge->call_stmt_size = 0;\n-  edge->call_stmt_time = 0;\n   push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n   edge->can_throw_external\n     = call_stmt ? stmt_can_throw_external (call_stmt) : false;\n@@ -1035,10 +1032,10 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n \n struct cgraph_edge *\n cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    gimple call_stmt, gcov_type count, int freq, int nest)\n+\t\t    gimple call_stmt, gcov_type count, int freq)\n {\n   struct cgraph_edge *edge = cgraph_create_edge_1 (caller, callee, call_stmt,\n-\t\t\t\t\t\t   count, freq, nest);\n+\t\t\t\t\t\t   count, freq);\n \n   edge->indirect_unknown_callee = 0;\n   initialize_inline_failed (edge);\n@@ -1074,10 +1071,10 @@ cgraph_allocate_init_indirect_info (void)\n struct cgraph_edge *\n cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n \t\t\t     int ecf_flags,\n-\t\t\t     gcov_type count, int freq, int nest)\n+\t\t\t     gcov_type count, int freq)\n {\n   struct cgraph_edge *edge = cgraph_create_edge_1 (caller, NULL, call_stmt,\n-\t\t\t\t\t\t   count, freq, nest);\n+\t\t\t\t\t\t   count, freq);\n \n   edge->indirect_unknown_callee = 1;\n   initialize_inline_failed (edge);\n@@ -1244,7 +1241,6 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n       struct cgraph_edge *ne = NULL;\n       gcov_type count;\n       int frequency;\n-      int loop_nest;\n \n       if (e)\n \t{\n@@ -1268,7 +1264,6 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \t     attached to edge is invalid.  */\n \t  count = e->count;\n \t  frequency = e->frequency;\n-\t  loop_nest = e->loop_nest;\n \t  cgraph_remove_edge (e);\n \t}\n       else\n@@ -1278,14 +1273,12 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \t  count = bb->count;\n \t  frequency = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t      bb);\n-\t  loop_nest = bb->loop_depth;\n \t}\n \n       if (new_call)\n \t{\n \t  ne = cgraph_create_edge (node, cgraph_get_create_node (new_call),\n-\t\t\t\t   new_stmt, count, frequency,\n-\t\t\t\t   loop_nest);\n+\t\t\t\t   new_stmt, count, frequency);\n \t  gcc_assert (ne->inline_failed);\n \t}\n     }\n@@ -1915,8 +1908,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n       if (edge->frequency)\n \tfprintf (f, \"(%.2f per call) \",\n \t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n-      if (edge->loop_nest)\n-\tfprintf (f, \"(nested in %i loops) \", edge->loop_nest);\n       if (edge->can_throw_external)\n \tfprintf(f, \"(can throw external) \");\n     }\n@@ -2064,7 +2055,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t   gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n-\t\t   int freq_scale, int loop_nest, bool update_original)\n+\t\t   int freq_scale, bool update_original)\n {\n   struct cgraph_edge *new_edge;\n   gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n@@ -2085,22 +2076,19 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t{\n \t  struct cgraph_node *callee = cgraph_get_node (decl);\n \t  gcc_checking_assert (callee);\n-\t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq,\n-\t\t\t\t\t e->loop_nest + loop_nest);\n+\t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq);\n \t}\n       else\n \t{\n \t  new_edge = cgraph_create_indirect_edge (n, call_stmt,\n \t\t\t\t\t\t  e->indirect_info->ecf_flags,\n-\t\t\t\t\t\t  count, freq,\n-\t\t\t\t\t\t  e->loop_nest + loop_nest);\n+\t\t\t\t\t\t  count, freq);\n \t  *new_edge->indirect_info = *e->indirect_info;\n \t}\n     }\n   else\n     {\n-      new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n-\t\t\t\t     e->loop_nest + loop_nest);\n+      new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq);\n       if (e->indirect_info)\n \t{\n \t  new_edge->indirect_info\n@@ -2109,8 +2097,6 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t}\n     }\n \n-  new_edge->call_stmt_size = e->call_stmt_size;\n-  new_edge->call_stmt_time = e->call_stmt_time;\n   new_edge->inline_failed = e->inline_failed;\n   new_edge->indirect_inlining_edge = e->indirect_inlining_edge;\n   new_edge->lto_stmt_uid = stmt_uid;\n@@ -2137,7 +2123,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n    by node.  */\n struct cgraph_node *\n cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n-\t\t   int loop_nest, bool update_original,\n+\t\t   bool update_original,\n \t\t   VEC(cgraph_edge_p,heap) *redirect_callers)\n {\n   struct cgraph_node *new_node = cgraph_create_node_1 ();\n@@ -2188,11 +2174,11 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \n   for (e = n->callees;e; e=e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n-\t\t       count_scale, freq, loop_nest, update_original);\n+\t\t       count_scale, freq, update_original);\n \n   for (e = n->indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n-\t\t       count_scale, freq, loop_nest, update_original);\n+\t\t       count_scale, freq, update_original);\n   ipa_clone_references (new_node, NULL, &n->ref_list);\n \n   new_node->next_sibling_clone = n->clones;\n@@ -2285,7 +2271,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   SET_DECL_RTL (new_decl, NULL);\n \n   new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n-\t\t\t\tCGRAPH_FREQ_BASE, 0, false,\n+\t\t\t\tCGRAPH_FREQ_BASE, false,\n \t\t\t\tredirect_callers);\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n@@ -2700,7 +2686,7 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n \t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n \t\t     cgraph_node_name (edge->caller));\n \t  maybe_unlikely_executed = false;\n-\t  if (edge->loop_nest)\n+\t  if (inline_edge_summary (edge)->loop_depth)\n \t    {\n \t      maybe_executed_once = false;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "14848b5e6b957a08db66a18dafed280aef6ec09d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -381,11 +381,6 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   int frequency;\n   /* Unique id of the edge.  */\n   int uid;\n-  /* Estimated size and time of the call statement.  */\n-  int call_stmt_size;\n-  int call_stmt_time;\n-  /* Depth of loop nest, 1 means no loop nest.  */\n-  unsigned short int loop_nest;\n   /* Whether this edge was made direct by indirect inlining.  */\n   unsigned int indirect_inlining_edge : 1;\n   /* Whether this edge describes an indirect call with an undetermined\n@@ -504,9 +499,9 @@ void cgraph_release_function_body (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\tgimple, gcov_type, int, int);\n+\t\t\t\t\tgimple, gcov_type, int);\n struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n-\t\t\t\t\t\t int, gcov_type, int, int);\n+\t\t\t\t\t\t int, gcov_type, int);\n struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n struct cgraph_node * cgraph_get_node (const_tree);\n struct cgraph_node * cgraph_get_node_or_alias (const_tree);\n@@ -522,7 +517,7 @@ void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);\n void cgraph_create_edge_including_clones (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *,\n-\t\t\t\t\t  gimple, gimple, gcov_type, int, int,\n+\t\t\t\t\t  gimple, gimple, gcov_type, int,\n \t\t\t\t\t  cgraph_inline_failed_t);\n void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n@@ -531,8 +526,8 @@ struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *, gimple,\n-\t\t\t\t\tunsigned, gcov_type, int, int, bool);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type, int,\n+\t\t\t\t\tunsigned, gcov_type, int, bool);\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n \t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);"}, {"sha": "eb9da7fc16c38b31ab940bcf891ddd4647457522", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -354,12 +354,11 @@ build_cgraph_edges (void)\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n \t\tcgraph_create_edge (node, cgraph_get_create_node (decl),\n-\t\t\t\t    stmt, bb->count, freq, bb->loop_depth);\n+\t\t\t\t    stmt, bb->count, freq);\n \t      else\n \t\tcgraph_create_indirect_edge (node, stmt,\n \t\t\t\t\t     gimple_call_flags (stmt),\n-\t\t\t\t\t     bb->count, freq,\n-\t\t\t\t\t     bb->loop_depth);\n+\t\t\t\t\t     bb->count, freq);\n \t    }\n \t  walk_stmt_load_store_addr_ops (stmt, node, mark_load,\n \t\t\t\t\t mark_store, mark_address);\n@@ -464,12 +463,11 @@ rebuild_cgraph_edges (void)\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n \t\tcgraph_create_edge (node, cgraph_get_create_node (decl), stmt,\n-\t\t\t\t    bb->count, freq, bb->loop_depth);\n+\t\t\t\t    bb->count, freq);\n \t      else\n \t\tcgraph_create_indirect_edge (node, stmt,\n \t\t\t\t\t     gimple_call_flags (stmt),\n-\t\t\t\t\t     bb->count, freq,\n-\t\t\t\t\t     bb->loop_depth);\n+\t\t\t\t\t     bb->count, freq);\n \t    }\n \t  walk_stmt_load_store_addr_ops (stmt, node, mark_load,\n \t\t\t\t\t mark_store, mark_address);"}, {"sha": "1d40d5a49fd1116d1f69ec539a6aa91b867d88ca", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -2001,14 +2001,14 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n        cgraph_clone_edge (e, new_version, e->call_stmt,\n \t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n \t\t\t  CGRAPH_FREQ_BASE,\n-\t\t\t  e->loop_nest, true);\n+\t\t\t  true);\n    for (e = old_version->indirect_calls; e; e=e->next_callee)\n      if (!bbs_to_copy\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n        cgraph_clone_edge (e, new_version, e->call_stmt,\n \t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n \t\t\t  CGRAPH_FREQ_BASE,\n-\t\t\t  e->loop_nest, true);\n+\t\t\t  true);\n    FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n      {\n        /* Redirect calls to the old version node to point to its new"}, {"sha": "8cf9bc3d924d11c3a02074517c010a39cb0bf9e8", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 161, "deletions": 16, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -110,14 +110,20 @@ enum predicate_conditions\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n static void inline_node_removal_hook (struct cgraph_node *, void *);\n static void inline_node_duplication_hook (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *, void *);\n+static void inline_edge_removal_hook (struct cgraph_edge *, void *);\n+static void inline_edge_duplication_hook (struct cgraph_edge *,\n+\t\t\t\t\t  struct cgraph_edge *,\n+\t\t\t\t          void *);\n \n /* VECtor holding inline summaries.  \n    In GGC memory because conditions might point to constant trees.  */\n VEC(inline_summary_t,gc) *inline_summary_vec;\n+VEC(inline_edge_summary_t,heap) *inline_edge_summary_vec;\n \n /* Cached node/edge growths.  */\n VEC(int,heap) *node_growth_cache;\n@@ -512,14 +518,24 @@ inline_summary_alloc (void)\n   if (!node_removal_hook_holder)\n     node_removal_hook_holder =\n       cgraph_add_node_removal_hook (&inline_node_removal_hook, NULL);\n+  if (!edge_removal_hook_holder)\n+    edge_removal_hook_holder =\n+      cgraph_add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n   if (!node_duplication_hook_holder)\n     node_duplication_hook_holder =\n       cgraph_add_node_duplication_hook (&inline_node_duplication_hook, NULL);\n+  if (!edge_duplication_hook_holder)\n+    edge_duplication_hook_holder =\n+      cgraph_add_edge_duplication_hook (&inline_edge_duplication_hook, NULL);\n \n   if (VEC_length (inline_summary_t, inline_summary_vec)\n       <= (unsigned) cgraph_max_uid)\n     VEC_safe_grow_cleared (inline_summary_t, gc,\n \t\t\t   inline_summary_vec, cgraph_max_uid + 1);\n+  if (VEC_length (inline_edge_summary_t, inline_edge_summary_vec)\n+      <= (unsigned) cgraph_edge_max_uid)\n+    VEC_safe_grow_cleared (inline_edge_summary_t, heap,\n+\t\t\t   inline_edge_summary_vec, cgraph_edge_max_uid + 1);\n }\n \n /* Hook that is called by cgraph.c when a node is removed.  */\n@@ -540,6 +556,7 @@ inline_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   memset (info, 0, sizeof (inline_summary_t));\n }\n \n+\n /* Hook that is called by cgraph.c when a node is duplicated.  */\n \n static void\n@@ -556,12 +573,29 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n }\n \n \n+/* Hook that is called by cgraph.c when a node is duplicated.  */\n+\n+static void\n+inline_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n+\t\t\t      ATTRIBUTE_UNUSED void *data)\n+{\n+  struct inline_edge_summary *info;\n+  inline_summary_alloc ();\n+  info = inline_edge_summary (dst);\n+  memcpy (info, inline_edge_summary (src),\n+\t  sizeof (struct inline_edge_summary));\n+}\n+\n+\n /* Keep edge cache consistent across edge removal.  */\n \n static void\n inline_edge_removal_hook (struct cgraph_edge *edge, void *data ATTRIBUTE_UNUSED)\n {\n-  reset_edge_growth_cache (edge);\n+  if (edge_growth_cache)\n+    reset_edge_growth_cache (edge);\n+  if (edge->uid < (int)VEC_length (inline_edge_summary_t, inline_edge_summary_vec))\n+    memset (inline_edge_summary (edge), 0, sizeof (struct inline_edge_summary));\n }\n \n \n@@ -570,9 +604,6 @@ inline_edge_removal_hook (struct cgraph_edge *edge, void *data ATTRIBUTE_UNUSED)\n void\n initialize_growth_caches (void)\n {\n-  if (!edge_removal_hook_holder)\n-    edge_removal_hook_holder =\n-      cgraph_add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n   if (cgraph_edge_max_uid)\n     VEC_safe_grow_cleared (edge_growth_cache_entry, heap, edge_growth_cache,\n \t\t\t   cgraph_edge_max_uid);\n@@ -586,15 +617,49 @@ initialize_growth_caches (void)\n void\n free_growth_caches (void)\n {\n-  if (edge_removal_hook_holder)\n-    cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n   VEC_free (edge_growth_cache_entry, heap, edge_growth_cache);\n   edge_growth_cache = 0;\n   VEC_free (int, heap, node_growth_cache);\n   node_growth_cache = 0;\n }\n \n \n+/* Dump edge summaries associated to NODE and recursively to all clones.\n+   Indent by INDENT.  */\n+\n+static void\n+dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node)\n+{\n+  struct cgraph_edge *edge;\n+  for (edge = node->callees; edge; edge = edge->next_callee)\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (edge);\n+      fprintf (f, \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i time: %2i\\n\",\n+\t       indent, \"\", cgraph_node_name (edge->callee),\n+\t       edge->callee->uid, \n+\t       edge->inline_failed ? \"inlined\"\n+\t       : cgraph_inline_failed_string (edge->inline_failed),\n+\t       indent, \"\",\n+\t       es->loop_depth,\t\n+               edge->frequency,\n+\t       es->call_stmt_size,\n+\t       es->call_stmt_time);\n+      if (!edge->inline_failed)\n+\tdump_inline_edge_summary (f, indent+2, edge->callee);\n+    }\n+  for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (edge);\n+      fprintf (f, \"%*sindirect call loop depth:%2i freq:%4i size:%2i time: %2i\\n\",\n+\t       indent, \"\",\n+\t       es->loop_depth,\t\n+               edge->frequency,\n+\t       es->call_stmt_size,\n+\t       es->call_stmt_time);\n+    }\n+}\n+\n+\n static void\n dump_inline_summary (FILE * f, struct cgraph_node *node)\n {\n@@ -630,6 +695,8 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \t\t   (double) e->time / INLINE_TIME_SCALE);\n \t  dump_predicate (f, s->conds, &e->predicate);\n \t}\n+      fprintf (f, \"  calls:\\n\");\n+      dump_inline_edge_summary (f, 4, node);\n       fprintf (f, \"\\n\");\n     }\n }\n@@ -646,7 +713,7 @@ dump_inline_summaries (FILE *f)\n   struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n+    if (node->analyzed && !node->global.inlined_to)\n       dump_inline_summary (f, node);\n }\n \n@@ -919,8 +986,11 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  if (is_gimple_call (stmt))\n \t    {\n \t      struct cgraph_edge *edge = cgraph_edge (node, stmt);\n-\t      edge->call_stmt_size = this_size;\n-\t      edge->call_stmt_time = this_time;\n+\t      struct inline_edge_summary *es = inline_edge_summary (edge);\n+\n+\t      es->call_stmt_size = this_size;\n+\t      es->call_stmt_time = this_time;\n+\t      es->loop_depth = bb->loop_depth;\n \n \t      /* Do not inline calls where we cannot triviall work around\n \t\t mismatches in argument or return types.  */\n@@ -1076,8 +1146,9 @@ struct gimple_opt_pass pass_inline_parameters =\n static void\n estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time)\n {\n-  *size += e->call_stmt_size * INLINE_SIZE_SCALE;\n-  *time += (e->call_stmt_time\n+  struct inline_edge_summary *es = inline_edge_summary (e);\n+  *size += es->call_stmt_size * INLINE_SIZE_SCALE;\n+  *time += (es->call_stmt_time\n \t    * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE));\n   if (*time > MAX_TIME * INLINE_TIME_SCALE)\n     *time = MAX_TIME * INLINE_TIME_SCALE;\n@@ -1222,6 +1293,38 @@ remap_predicate (struct inline_summary *info, struct inline_summary *callee_info\n }\n \n \n+/* Update summary information of inline clones after inlining.\n+   Compute peak stack usage.  */\n+\n+static void\n+inline_update_callee_summaries (struct cgraph_node *node,\n+\t\t\t        int depth)\n+{\n+  struct cgraph_edge *e;\n+  struct inline_summary *callee_info = inline_summary (node);\n+  struct inline_summary *caller_info = inline_summary (node->callers->caller);\n+  HOST_WIDE_INT peak;\n+\n+  callee_info->stack_frame_offset\n+    = caller_info->stack_frame_offset\n+      + caller_info->estimated_self_stack_size;\n+  peak = callee_info->stack_frame_offset\n+      + callee_info->estimated_self_stack_size;\n+  if (inline_summary (node->global.inlined_to)->estimated_stack_size\n+      < peak)\n+    inline_summary (node->global.inlined_to)->estimated_stack_size = peak;\n+  cgraph_propagate_frequency (node);\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      if (!e->inline_failed)\n+\tinline_update_callee_summaries (e->callee, depth);\n+      inline_edge_summary (e)->loop_depth += depth;\n+    }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    inline_edge_summary (e)->loop_depth += depth;\n+}\n+\n+\n /* We inlined EDGE.  Update summary of the function we inlined into.  */\n \n void\n@@ -1275,6 +1378,10 @@ inline_merge_summary (struct cgraph_edge *edge)\n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n     info->size += e->size, info->time += e->time;\n   estimate_calls_size_and_time (to, &info->size, &info->time);\n+\n+  inline_update_callee_summaries (edge->callee,\n+\t\t\t\t  inline_edge_summary (edge)->loop_depth);\n+\n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n@@ -1293,11 +1400,12 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   int time;\n   int size;\n   gcov_type ret;\n+  struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   gcc_checking_assert (edge->inline_failed);\n   estimate_callee_size_and_time (edge, true, &size, &time);\n \n-  ret = (((gcov_type)time - edge->call_stmt_time) * edge->frequency\n+  ret = (((gcov_type)time - es->call_stmt_time) * edge->frequency\n \t + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   if (ret > MAX_TIME)\n     ret = MAX_TIME;\n@@ -1313,8 +1421,8 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid)->time\n \t= ret + (ret >= 0);\n \n-      ret_size = size - edge->call_stmt_size;\n-      gcc_checking_assert (edge->call_stmt_size);\n+      ret_size = size - es->call_stmt_size;\n+      gcc_checking_assert (es->call_stmt_size);\n       VEC_index (edge_growth_cache_entry, edge_growth_cache, edge->uid)->size\n \t= ret_size + (ret_size >= 0);\n     }\n@@ -1345,8 +1453,8 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n   estimate_callee_size_and_time (edge, true, &size, NULL);\n-  gcc_checking_assert (edge->call_stmt_size);\n-  return size - edge->call_stmt_size;\n+  gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n+  return size - inline_edge_summary (edge)->call_stmt_size;\n }\n \n \n@@ -1494,6 +1602,18 @@ inline_generate_summary (void)\n }\n \n \n+/* Write inline summary for edge E to OB.  */\n+\n+static void\n+read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n+{\n+  struct inline_edge_summary *es = inline_edge_summary (e);\n+  es->call_stmt_size = lto_input_uleb128 (ib);\n+  es->call_stmt_time = lto_input_uleb128 (ib);\n+  es->loop_depth = lto_input_uleb128 (ib);\n+}\n+\n+\n /* Stream in inline summaries from the section.  */\n \n static void\n@@ -1524,6 +1644,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       struct inline_summary *info;\n       lto_cgraph_encoder_t encoder;\n       struct bitpack_d bp;\n+      struct cgraph_edge *e;\n \n       index = lto_input_uleb128 (&ib);\n       encoder = file_data->cgraph_node_encoder;\n@@ -1568,6 +1689,10 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n \t  VEC_safe_push (size_time_entry, gc, info->entry, &e);\n \t}\n+      for (e = node->callees; e; e = e->next_callee)\n+\tread_inline_edge_summary (&ib, e);\n+      for (e = node->indirect_calls; e; e = e->next_callee)\n+\tread_inline_edge_summary (&ib, e);\n     }\n \n   lto_free_section_data (file_data, LTO_section_inline_summary, NULL, data,\n@@ -1611,6 +1736,17 @@ inline_read_summary (void)\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n }\n \n+/* Write inline summary for edge E to OB.  */\n+\n+static void\n+write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n+{\n+  struct inline_edge_summary *es = inline_edge_summary (e);\n+  lto_output_uleb128_stream (ob->main_stream, es->call_stmt_size);\n+  lto_output_uleb128_stream (ob->main_stream, es->call_stmt_time);\n+  lto_output_uleb128_stream (ob->main_stream, es->loop_depth);\n+}\n+\n \n /* Write inline summary for node in SET.\n    Jump functions are shared among ipa-cp and inliner, so when ipa-cp is\n@@ -1638,6 +1774,7 @@ inline_write_summary (cgraph_node_set set,\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n \t  struct bitpack_d bp;\n+\t  struct cgraph_edge *edge;\n \t  int i;\n \t  size_time_entry *e;\n \t  struct condition *c;\n@@ -1684,6 +1821,10 @@ inline_write_summary (cgraph_node_set set,\n \t\t}\n \t      lto_output_uleb128_stream (ob->main_stream, 0);\n \t    }\n+\t  for (edge = node->callees; edge; edge = edge->next_callee)\n+\t    write_inline_edge_summary (ob, edge);\n+\t  for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n+\t    write_inline_edge_summary (ob, edge);\n \t}\n     }\n   lto_output_1_stream (ob->main_stream, 0);\n@@ -1705,9 +1846,13 @@ inline_free_summary (void)\n   function_insertion_hook_holder = NULL;\n   if (node_removal_hook_holder)\n     cgraph_remove_node_removal_hook (node_removal_hook_holder);\n+  if (edge_removal_hook_holder)\n+    cgraph_remove_edge_removal_hook (edge_removal_hook_holder);\n   node_removal_hook_holder = NULL;\n   if (node_duplication_hook_holder)\n     cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n+  if (edge_duplication_hook_holder)\n+    cgraph_remove_edge_duplication_hook (edge_duplication_hook_holder);\n   node_duplication_hook_holder = NULL;\n   VEC_free (inline_summary_t, gc, inline_summary_vec);\n   inline_summary_vec = NULL;"}, {"sha": "7465325a35b59583b01a1e243b3ad41609f62066", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -49,12 +49,11 @@ along with GCC; see the file COPYING3.  If not see\n int ncalls_inlined;\n int nfunctions_inlined;\n \n-/* Scale frequency of NODE edges by FREQ_SCALE and increase loop nest\n-   by NEST.  */\n+/* Scale frequency of NODE edges by FREQ_SCALE.  */\n \n static void\n update_noncloned_frequencies (struct cgraph_node *node,\n-\t\t\t      int freq_scale, int nest)\n+\t\t\t      int freq_scale)\n {\n   struct cgraph_edge *e;\n \n@@ -63,12 +62,17 @@ update_noncloned_frequencies (struct cgraph_node *node,\n     freq_scale = 1;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      e->loop_nest += nest;\n       e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n       if (e->frequency > CGRAPH_FREQ_MAX)\n         e->frequency = CGRAPH_FREQ_MAX;\n       if (!e->inline_failed)\n-        update_noncloned_frequencies (e->callee, freq_scale, nest);\n+        update_noncloned_frequencies (e->callee, freq_scale);\n+    }\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    {\n+      e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n+      if (e->frequency > CGRAPH_FREQ_MAX)\n+        e->frequency = CGRAPH_FREQ_MAX;\n     }\n }\n \n@@ -83,9 +87,6 @@ void\n clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t\t     bool update_original, int *overall_size)\n {\n-  HOST_WIDE_INT peak;\n-  struct inline_summary *caller_info, *callee_info;\n-\n   if (duplicate)\n     {\n       /* We may eliminate the need for out-of-line copy to be output.\n@@ -125,34 +126,22 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    }\n \t  duplicate = false;\n \t  e->callee->local.externally_visible = false;\n-          update_noncloned_frequencies (e->callee, e->frequency, e->loop_nest);\n+          update_noncloned_frequencies (e->callee, e->frequency);\n \t}\n       else\n \t{\n \t  struct cgraph_node *n;\n \t  n = cgraph_clone_node (e->callee, e->callee->decl,\n-\t\t\t\t e->count, e->frequency, e->loop_nest,\n+\t\t\t\t e->count, e->frequency,\n \t\t\t\t update_original, NULL);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }\n \n-  callee_info = inline_summary (e->callee);\n-  caller_info = inline_summary (e->caller);\n-\n   if (e->caller->global.inlined_to)\n     e->callee->global.inlined_to = e->caller->global.inlined_to;\n   else\n     e->callee->global.inlined_to = e->caller;\n-  callee_info->stack_frame_offset\n-    = caller_info->stack_frame_offset\n-      + caller_info->estimated_self_stack_size;\n-  peak = callee_info->stack_frame_offset\n-      + callee_info->estimated_self_stack_size;\n-  if (inline_summary (e->callee->global.inlined_to)->estimated_stack_size\n-      < peak)\n-    inline_summary (e->callee->global.inlined_to)->estimated_stack_size = peak;\n-  cgraph_propagate_frequency (e->callee);\n \n   /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = e->next_callee)\n@@ -187,13 +176,14 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   to = e->caller;\n   if (to->global.inlined_to)\n     to = to->global.inlined_to;\n-  old_size = inline_summary (to)->size;\n-  inline_merge_summary (e);\n-  new_size = inline_summary (to)->size;\n \n   clone_inlined_nodes (e, true, update_original, overall_size);\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n+\n+  old_size = inline_summary (to)->size;\n+  inline_merge_summary (e);\n+  new_size = inline_summary (to)->size;\n   if (overall_size && new_size > old_size)\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;"}, {"sha": "d4052dfa29490de5b8078a86056c2fe58106ac7d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -739,7 +739,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      of functions fully inlined in program.  */\n   else\n     {\n-      int nest = MIN (edge->loop_nest, 8);\n+      int nest = MIN (inline_edge_summary (edge)->loop_depth, 8);\n       badness = estimate_growth (edge->callee) * 256;\n \n       /* Decrease badness if call is nested.  */\n@@ -1027,7 +1027,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t{\n \t  /* We need original clone to copy around.  */\n \t  master_clone = cgraph_clone_node (node, node->decl,\n-\t\t\t\t\t    node->count, CGRAPH_FREQ_BASE, 1,\n+\t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n \t\t\t\t\t    false, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n@@ -1555,6 +1555,8 @@ ipa_inline (void)\n \t     \"\\nInlined %i calls, eliminated %i functions\\n\\n\",\n \t     ncalls_inlined, nfunctions_inlined);\n \n+  if (dump_file)\n+    dump_inline_summaries (dump_file);\n   /* In WPA we use inline summaries for partitioning process.  */\n   if (!flag_wpa)\n     inline_free_summary ();\n@@ -1709,9 +1711,10 @@ early_inliner (void)\n \t     info that might be cleared out for newly discovered edges.  */\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    {\n-\t      edge->call_stmt_size\n+\t      struct inline_edge_summary *es = inline_edge_summary (edge);\n+\t      es->call_stmt_size\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n-\t      edge->call_stmt_time\n+\t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n \t    }\n \t  timevar_pop (TV_INTEGRATION);"}, {"sha": "d27fa46b7b8620e65c1105f660d0564c8afc7a7b", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -101,6 +101,8 @@ struct GTY(()) inline_summary\n   int time;\n   int size;\n \n+  /* Conditional size/time information.  The summaries are being\n+     merged during inlining.  */\n   conditions conds;\n   VEC(size_time_entry,gc) *entry;\n };\n@@ -110,6 +112,21 @@ DEF_VEC_O(inline_summary_t);\n DEF_VEC_ALLOC_O(inline_summary_t,gc);\n extern GTY(()) VEC(inline_summary_t,gc) *inline_summary_vec;\n \n+/* Information kept about callgraph edges.  */\n+struct inline_edge_summary\n+{\n+  /* Estimated size and time of the call statement.  */\n+  int call_stmt_size;\n+  int call_stmt_time;\n+  /* Depth of loop nest, 0 means no nesting.  */\n+  unsigned short int loop_depth;\n+};\n+\n+typedef struct inline_edge_summary inline_edge_summary_t;\n+DEF_VEC_O(inline_edge_summary_t);\n+DEF_VEC_ALLOC_O(inline_edge_summary_t,heap);\n+extern VEC(inline_edge_summary_t,heap) *inline_edge_summary_vec;\n+\n typedef struct edge_growth_cache_entry\n {\n   int time, size;\n@@ -152,6 +169,12 @@ inline_summary (struct cgraph_node *node)\n   return VEC_index (inline_summary_t, inline_summary_vec, node->uid);\n }\n \n+static inline struct inline_edge_summary *\n+inline_edge_summary (struct cgraph_edge *edge)\n+{\n+  return VEC_index (inline_edge_summary_t,\n+\t\t    inline_edge_summary_vec, edge->uid);\n+}\n \n /* Return estimated unit growth after inlning all calls to NODE.\n    Quick accesors to the inline growth caches.  "}, {"sha": "73911f32b83098c93d8ee9c2d4f594a84e38916d", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -285,9 +285,6 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp_pack_value (&bp, uid, HOST_BITS_PER_INT);\n   bp_pack_value (&bp, edge->inline_failed, HOST_BITS_PER_INT);\n   bp_pack_value (&bp, edge->frequency, HOST_BITS_PER_INT);\n-  bp_pack_value (&bp, edge->call_stmt_size, HOST_BITS_PER_INT);\n-  bp_pack_value (&bp, edge->call_stmt_time, HOST_BITS_PER_INT);\n-  bp_pack_value (&bp, edge->loop_nest, 30);\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n   bp_pack_value (&bp, edge->can_throw_external, 1);\n@@ -1003,7 +1000,7 @@ input_node (struct lto_file_decl_data *file_data,\n   if (clone_ref != LCC_NOT_FOUND)\n     {\n       node = cgraph_clone_node (VEC_index (cgraph_node_ptr, nodes, clone_ref), fn_decl,\n-\t\t\t\t0, CGRAPH_FREQ_BASE, 0, false, NULL);\n+\t\t\t\t0, CGRAPH_FREQ_BASE, false, NULL);\n     }\n   else\n     node = cgraph_get_create_node (fn_decl);\n@@ -1164,11 +1161,9 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   unsigned int stmt_id;\n   gcov_type count;\n   int freq;\n-  unsigned int nest;\n   cgraph_inline_failed_t inline_failed;\n   struct bitpack_d bp;\n   int ecf_flags = 0;\n-  int call_stmt_time, call_stmt_size;\n \n   caller = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n   if (caller == NULL || caller->decl == NULL_TREE)\n@@ -1190,22 +1185,17 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   inline_failed = (cgraph_inline_failed_t) bp_unpack_value (&bp,\n \t\t\t\t\t\t\t    HOST_BITS_PER_INT);\n   freq = (int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n-  call_stmt_size = (int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n-  call_stmt_time = (int) bp_unpack_value (&bp, HOST_BITS_PER_INT);\n-  nest = (unsigned) bp_unpack_value (&bp, 30);\n \n   if (indirect)\n-    edge = cgraph_create_indirect_edge (caller, NULL, 0, count, freq, nest);\n+    edge = cgraph_create_indirect_edge (caller, NULL, 0, count, freq);\n   else\n-    edge = cgraph_create_edge (caller, callee, NULL, count, freq, nest);\n+    edge = cgraph_create_edge (caller, callee, NULL, count, freq);\n \n   edge->indirect_inlining_edge = bp_unpack_value (&bp, 1);\n   edge->lto_stmt_uid = stmt_id;\n   edge->inline_failed = inline_failed;\n   edge->call_stmt_cannot_inline_p = bp_unpack_value (&bp, 1);\n   edge->can_throw_external = bp_unpack_value (&bp, 1);\n-  edge->call_stmt_size = call_stmt_size;\n-  edge->call_stmt_time = call_stmt_time;\n   if (indirect)\n     {\n       if (bp_unpack_value (&bp, 1))"}, {"sha": "19f627e16d0cbe48503478f7aee72e8c6cdda8b1", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -437,7 +437,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n       gimple_seq_add_stmt (&d->seq, x);\n \n       cgraph_create_edge (d->cfun_node, d->builtin_node, x,\n-                          d->bb->count, d->bb_freq, d->bb->loop_depth);\n+                          d->bb->count, d->bb_freq);\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */"}, {"sha": "440699f771927da4ab7b8e3cda60b35f7a6746f4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898b8927465614b911841f134f37165a613debf5/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898b8927465614b911841f134f37165a613debf5/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=898b8927465614b911841f134f37165a613debf5", "patch": "@@ -1678,7 +1678,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      edge = cgraph_clone_edge (edge, id->dst_node, stmt,\n \t\t\t\t\t        gimple_uid (stmt),\n \t\t\t\t\t        REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t        edge->frequency, true);\n+\t\t\t\t\t        true);\n \t\t      /* We could also just rescale the frequency, but\n \t\t         doing so would introduce roundoff errors and make\n \t\t\t verifier unhappy.  */\n@@ -1745,13 +1745,12 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      (id->dst_node, dest, orig_stmt, stmt, bb->count,\n \t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n \t\t       \t\t\t\t       copy_basic_block),\n-\t\t       bb->loop_depth, CIF_ORIGINALLY_INDIRECT_CALL);\n+\t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n \t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n \t\t\t\t\tbb->count,\n \t\t\t\t\tcompute_call_stmt_bb_frequency\n-\t\t\t\t\t  (id->dst_node->decl, copy_basic_block),\n-\t\t\t\t\tbb->loop_depth)->inline_failed\n+\t\t\t\t\t  (id->dst_node->decl, copy_basic_block))->inline_failed\n \t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n \t\t  if (dump_file)\n \t\t    {"}]}