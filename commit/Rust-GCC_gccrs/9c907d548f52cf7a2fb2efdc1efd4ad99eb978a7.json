{"sha": "9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM5MDdkNTQ4ZjUyY2Y3YTJmYjJlZmRjMWVmZDRhZDk5ZWI5NzhhNw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-12-15T12:53:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-12-15T12:53:12Z"}, "message": "mn10200.md (abssf2, negsf2): New expanders.\n\n        * mn10200.md (abssf2, negsf2): New expanders.\n        * mn10300.md (absdf2, abssf2, negdf2, negsf2): New expanders.\n\nFrom-SVN: r24330", "tree": {"sha": "38c97ce1c7e9dbd7203327b09c7437c1bbd21277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38c97ce1c7e9dbd7203327b09c7437c1bbd21277"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/comments", "author": null, "committer": null, "parents": [{"sha": "1caa11d3a3c7412737c29e4c98de46dbf729150e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1caa11d3a3c7412737c29e4c98de46dbf729150e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1caa11d3a3c7412737c29e4c98de46dbf729150e"}], "stats": {"total": 198, "additions": 198, "deletions": 0}, "files": [{"sha": "5b0e3ecbae87cd091786a4e3e7c7d92cc91cb046", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "patch": "@@ -1,3 +1,9 @@\n+Tue Dec 15 13:49:55 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* mn10200.md (abssf2, negsf2): New expanders.\n+\n+\t* mn10300.md (absdf2, abssf2, negdf2, negsf2): New expanders.\n+\n Tue Dec 15 11:55:30 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* integrate.c (copy_rtx_and_substitute): If a SUBREG is"}, {"sha": "0bfdca43e82de7143bf48c77929c482a8092ca0c", "filename": "gcc/config/mn10200/mn10200.md", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.md?ref=9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "patch": "@@ -1638,6 +1638,77 @@\n   \"asr %H0\\;ror %L0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n+;; ----------------------------------------------------------------------\n+;; FP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+;;\n+;; The mn102 series does not have floating point instructions, but since\n+;; FP values are held in integer regs, we can clear the high bit easily\n+;; which gives us an efficient inline floating point absolute value.\n+;;\n+;; Similarly for negation of a FP value.\n+;;\n+\n+(define_expand \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (abs:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx target, result, insns;\n+\n+  start_sequence ();\n+  target = operand_subword (operands[0], 0, 1, SFmode);\n+  result = expand_binop (HImode, and_optab,\n+\t\t\t operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t GEN_INT(0x7fff), target, 0, OPTAB_WIDEN);\n+\n+  if (result == 0)\n+    abort ();\n+\n+  if (result != target)\n+    emit_move_insn (result, target);\n+\n+  emit_move_insn (operand_subword (operands[0], 1, 1, SFmode),\n+\t\t  operand_subword_force (operands[1], 1, SFmode));\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+  DONE;\n+}\")\n+\n+(define_expand \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (neg:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx target, result, insns;\n+\n+  start_sequence ();\n+  target = operand_subword (operands[0], 0, 1, SFmode);\n+  result = expand_binop (HImode, xor_optab,\n+\t\t\t operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t GEN_INT(0x8000), target, 0, OPTAB_WIDEN);\n+\n+  if (result == 0)\n+    abort ();\n+\n+  if (result != target)\n+    emit_move_insn (result, target);\n+\n+  emit_move_insn (operand_subword (operands[0], 1, 1, SFmode),\n+\t\t  operand_subword_force (operands[1], 1, SFmode));\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+  DONE;\n+}\")\n+\n ;; ----------------------------------------------------------------------\n ;; PROLOGUE/EPILOGUE\n ;; ----------------------------------------------------------------------"}, {"sha": "0d4e522d8637acfaa297873929a5460effcff0ef", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=9c907d548f52cf7a2fb2efdc1efd4ad99eb978a7", "patch": "@@ -1338,6 +1338,127 @@\n   \"asr %S2,%0\"\n   [(set_attr \"cc\" \"set_zn\")])\n \n+;; ----------------------------------------------------------------------\n+;; FP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+;;\n+;; The mn103 series does not have floating point instructions, but since\n+;; FP values are held in integer regs, we can clear the high bit easily\n+;; which gives us an efficient inline floating point absolute value.\n+;;\n+;; Similarly for negation of a FP value.\n+;;\n+\n+(define_expand \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (abs:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx target, result, insns;\n+\n+  start_sequence ();\n+  target = operand_subword (operands[0], 0, 1, DFmode);\n+  result = expand_binop (SImode, and_optab,\n+\t\t\t operand_subword_force (operands[1], 0, DFmode),\n+\t\t\t GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+\n+  if (result == 0)\n+    abort ();\n+\n+  if (result != target)\n+    emit_move_insn (result, target);\n+\n+  emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t  operand_subword_force (operands[1], 1, DFmode));\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+  DONE;\n+}\")\n+\n+(define_expand \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (abs:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx result;\n+  rtx target;\n+\n+  target = operand_subword_force (operands[0], 0, SFmode);\n+  result = expand_binop (SImode, and_optab,\n+\t\t\t operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t GEN_INT(0x7fffffff), target, 0, OPTAB_WIDEN);\n+  if (result == 0)\n+    abort ();\n+\n+  if (result != target)\n+    emit_move_insn (result, target);\n+\n+  /* Make a place for REG_EQUAL.  */\n+  emit_move_insn (operands[0], operands[0]);\n+  DONE;\n+}\")\n+\n+\n+(define_expand \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx target, result, insns;\n+\n+  start_sequence ();\n+  target = operand_subword (operands[0], 0, 1, DFmode);\n+  result = expand_binop (SImode, xor_optab,\n+\t\t\t operand_subword_force (operands[1], 0, DFmode),\n+\t\t\t GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+\n+  if (result == 0)\n+    abort ();\n+\n+  if (result != target)\n+    emit_move_insn (result, target);\n+\n+  emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t  operand_subword_force (operands[1], 1, DFmode));\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+  DONE;\n+}\")\n+\n+(define_expand \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (neg:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx result;\n+  rtx target;\n+\n+  target = operand_subword_force (operands[0], 0, SFmode);\n+  result = expand_binop (SImode, xor_optab,\n+\t\t\t operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);\n+  if (result == 0)\n+    abort ();\n+\n+  if (result != target)\n+    emit_move_insn (result, target);\n+\n+  /* Make a place for REG_EQUAL.  */\n+  emit_move_insn (operands[0], operands[0]);\n+  DONE;\n+}\")\n+\n+\n ;; ----------------------------------------------------------------------\n ;; PROLOGUE/EPILOGUE\n ;; ----------------------------------------------------------------------"}]}