{"sha": "12f55e030ed068d5c7b14c65a74d102db925dab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJmNTVlMDMwZWQwNjhkNWM3YjE0YzY1YTc0ZDEwMmRiOTI1ZGFiMg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-03-30T23:55:03Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-08T14:13:32Z"}, "message": "c++: Function type and parameter type disagreements [PR92010]\n\nThis resolves parts of Core issues 1001/1322 by rebuilding the function type\nof an instantiated function template in terms of its formal parameter types\nwhenever the original function type and formal parameter types disagree about\nthe type of a parameter after substitution.\n\ngcc/cp/ChangeLog:\n\n\tCore issues 1001 and 1322\n\tPR c++/92010\n\t* pt.c (rebuild_function_or_method_type): Split function out from ...\n\t(tsubst_function_type): ... here.\n\t(maybe_rebuild_function_decl_type): New function.\n\t(tsubst_function_decl): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\tCore issues 1001 and 1322\n\tPR c++/92010\n\t* g++.dg/cpp2a/lambda-uneval11.c: New test.\n\t* g++.dg/template/array33.C: New test.\n\t* g++.dg/template/array34.C: New test.\n\t* g++.dg/template/defarg22.C: New test.", "tree": {"sha": "570b24e3fd05b2ec5433176a9ce735240c3ca17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/570b24e3fd05b2ec5433176a9ce735240c3ca17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f55e030ed068d5c7b14c65a74d102db925dab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f55e030ed068d5c7b14c65a74d102db925dab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f55e030ed068d5c7b14c65a74d102db925dab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f55e030ed068d5c7b14c65a74d102db925dab2/comments", "author": null, "committer": null, "parents": [{"sha": "975e6670c428b032aa6ec600f57082d3cfb57393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975e6670c428b032aa6ec600f57082d3cfb57393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/975e6670c428b032aa6ec600f57082d3cfb57393"}], "stats": {"total": 318, "additions": 281, "deletions": 37}, "files": [{"sha": "cedd157dbf9795d0bbf45dc43e7e57432520b088", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -1,3 +1,12 @@\n+2020-04-08  Patrick Palka  <ppalka@redhat.com>\n+\n+\tCore issues 1001 and 1322\n+\tPR c++/92010\n+\t* pt.c (rebuild_function_or_method_type): Split function out from ...\n+\t(tsubst_function_type): ... here.\n+\t(maybe_rebuild_function_decl_type): New function.\n+\t(tsubst_function_decl): Use it.\n+\n 2020-04-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/94325"}, {"sha": "256a937eace799f87ea2d077b2f92f862c859346", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 114, "deletions": 37, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -13475,6 +13475,116 @@ lookup_explicit_specifier (tree v)\n   return *explicit_specifier_map->get (v);\n }\n \n+/* Given T, a FUNCTION_TYPE or METHOD_TYPE, construct and return a corresponding\n+   FUNCTION_TYPE or METHOD_TYPE whose return type is RETURN_TYPE, argument types\n+   are ARG_TYPES, and exception specification is RAISES, and otherwise is\n+   identical to T.  */\n+\n+static tree\n+rebuild_function_or_method_type (tree t, tree return_type, tree arg_types,\n+\t\t\t\t tree raises, tsubst_flags_t complain)\n+{\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (t));\n+\n+  tree new_type;\n+  if (TREE_CODE (t) == FUNCTION_TYPE)\n+    {\n+      new_type = build_function_type (return_type, arg_types);\n+      new_type = apply_memfn_quals (new_type, type_memfn_quals (t));\n+    }\n+  else\n+    {\n+      tree r = TREE_TYPE (TREE_VALUE (arg_types));\n+      /* Don't pick up extra function qualifiers from the basetype.  */\n+      r = cp_build_qualified_type_real (r, type_memfn_quals (t), complain);\n+      if (! MAYBE_CLASS_TYPE_P (r))\n+\t{\n+\t  /* [temp.deduct]\n+\n+\t     Type deduction may fail for any of the following\n+\t     reasons:\n+\n+\t     -- Attempting to create \"pointer to member of T\" when T\n+\t     is not a class type.  */\n+\t  if (complain & tf_error)\n+\t    error (\"creating pointer to member function of non-class type %qT\",\n+\t\t   r);\n+\t  return error_mark_node;\n+\t}\n+\n+      new_type = build_method_type_directly (r, return_type,\n+\t\t\t\t\t     TREE_CHAIN (arg_types));\n+    }\n+  new_type = cp_build_type_attribute_variant (new_type, TYPE_ATTRIBUTES (t));\n+\n+  cp_ref_qualifier rqual = type_memfn_rqual (t);\n+  bool late_return_type_p = TYPE_HAS_LATE_RETURN_TYPE (t);\n+  return build_cp_fntype_variant (new_type, rqual, raises, late_return_type_p);\n+}\n+\n+/* Check if the function type of DECL, a FUNCTION_DECL, agrees with the type of\n+   each of its formal parameters.  If there is a disagreement then rebuild\n+   DECL's function type according to its formal parameter types, as part of a\n+   resolution for Core issues 1001/1322.  */\n+\n+static void\n+maybe_rebuild_function_decl_type (tree decl)\n+{\n+  bool function_type_needs_rebuilding = false;\n+  if (tree parm_list = FUNCTION_FIRST_USER_PARM (decl))\n+    {\n+      tree parm_type_list = FUNCTION_FIRST_USER_PARMTYPE (decl);\n+      while (parm_type_list && parm_type_list != void_list_node)\n+\t{\n+\t  tree parm_type = TREE_VALUE (parm_type_list);\n+\t  tree formal_parm_type_unqual = strip_top_quals (TREE_TYPE (parm_list));\n+\t  if (!same_type_p (parm_type, formal_parm_type_unqual))\n+\t    {\n+\t      function_type_needs_rebuilding = true;\n+\t      break;\n+\t    }\n+\n+\t  parm_list = DECL_CHAIN (parm_list);\n+\t  parm_type_list = TREE_CHAIN (parm_type_list);\n+\t}\n+    }\n+\n+  if (!function_type_needs_rebuilding)\n+    return;\n+\n+  const tree fntype = TREE_TYPE (decl);\n+  tree parm_list = DECL_ARGUMENTS (decl);\n+  tree old_parm_type_list = TYPE_ARG_TYPES (fntype);\n+  tree new_parm_type_list = NULL_TREE;\n+  tree *q = &new_parm_type_list;\n+  for (int skip = num_artificial_parms_for (decl); skip > 0; skip--)\n+    {\n+      *q = copy_node (old_parm_type_list);\n+      parm_list = DECL_CHAIN (parm_list);\n+      old_parm_type_list = TREE_CHAIN (old_parm_type_list);\n+      q = &TREE_CHAIN (*q);\n+    }\n+  while (old_parm_type_list && old_parm_type_list != void_list_node)\n+    {\n+      *q = copy_node (old_parm_type_list);\n+      tree *new_parm_type = &TREE_VALUE (*q);\n+      tree formal_parm_type_unqual = strip_top_quals (TREE_TYPE (parm_list));\n+      if (!same_type_p (*new_parm_type, formal_parm_type_unqual))\n+\t*new_parm_type = formal_parm_type_unqual;\n+\n+      parm_list = DECL_CHAIN (parm_list);\n+      old_parm_type_list = TREE_CHAIN (old_parm_type_list);\n+      q = &TREE_CHAIN (*q);\n+    }\n+  if (old_parm_type_list == void_list_node)\n+    *q = void_list_node;\n+\n+  TREE_TYPE (decl)\n+    = rebuild_function_or_method_type (fntype,\n+\t\t\t\t       TREE_TYPE (fntype), new_parm_type_list,\n+\t\t\t\t       TYPE_RAISES_EXCEPTIONS (fntype), tf_none);\n+}\n+\n /* Subroutine of tsubst_decl for the case when T is a FUNCTION_DECL.  */\n \n static tree\n@@ -13665,6 +13775,8 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n   DECL_ARGUMENTS (r) = parms;\n   DECL_RESULT (r) = NULL_TREE;\n \n+  maybe_rebuild_function_decl_type (r);\n+\n   TREE_STATIC (r) = 0;\n   TREE_PUBLIC (r) = TREE_PUBLIC (t);\n   DECL_EXTERNAL (r) = 1;\n@@ -14694,7 +14806,6 @@ tsubst_function_type (tree t,\n {\n   tree return_type;\n   tree arg_types = NULL_TREE;\n-  tree fntype;\n \n   /* The TYPE_CONTEXT is not used for function/method types.  */\n   gcc_assert (TYPE_CONTEXT (t) == NULL_TREE);\n@@ -14765,42 +14876,8 @@ tsubst_function_type (tree t,\n     }\n \n   /* Construct a new type node and return it.  */\n-  if (TREE_CODE (t) == FUNCTION_TYPE)\n-    {\n-      fntype = build_function_type (return_type, arg_types);\n-      fntype = apply_memfn_quals (fntype, type_memfn_quals (t));\n-    }\n-  else\n-    {\n-      tree r = TREE_TYPE (TREE_VALUE (arg_types));\n-      /* Don't pick up extra function qualifiers from the basetype.  */\n-      r = cp_build_qualified_type_real (r, type_memfn_quals (t), complain);\n-      if (! MAYBE_CLASS_TYPE_P (r))\n-\t{\n-\t  /* [temp.deduct]\n-\n-\t     Type deduction may fail for any of the following\n-\t     reasons:\n-\n-\t     -- Attempting to create \"pointer to member of T\" when T\n-\t     is not a class type.  */\n-\t  if (complain & tf_error)\n-\t    error (\"creating pointer to member function of non-class type %qT\",\n-\t\t      r);\n-\t  return error_mark_node;\n-\t}\n-\n-      fntype = build_method_type_directly (r, return_type,\n-\t\t\t\t\t   TREE_CHAIN (arg_types));\n-    }\n-  fntype = cp_build_type_attribute_variant (fntype, TYPE_ATTRIBUTES (t));\n-\n-  /* See comment above.  */\n-  tree raises = NULL_TREE;\n-  cp_ref_qualifier rqual = type_memfn_rqual (t);\n-  fntype = build_cp_fntype_variant (fntype, rqual, raises, late_return_type_p);\n-\n-  return fntype;\n+  return rebuild_function_or_method_type (t, return_type, arg_types,\n+\t\t\t\t\t  /*raises=*/NULL_TREE, complain);\n }\n \n /* FNTYPE is a FUNCTION_TYPE or METHOD_TYPE.  Substitute the template"}, {"sha": "40597ed36580b4823803c73fdd1efb43494c3e8c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -1,3 +1,12 @@\n+2020-04-08  Patrick Palka  <ppalka@redhat.com>\n+\n+\tCore issues 1001 and 1322\n+\tPR c++/92010\n+\t* g++.dg/cpp2a/lambda-uneval11.c: New test.\n+\t* g++.dg/template/array33.C: New test.\n+\t* g++.dg/template/array34.C: New test.\n+\t* g++.dg/template/defarg22.C: New test.\n+\n 2020-04-08  Dennis Zhang  <dennis.zhang@arm.com>\n \n \t* gcc.target/arm/pragma_cde.c: New test."}, {"sha": "a04262494c73e5e5dc5b65e7893589c431979328", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-uneval11.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-uneval11.C?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/92010\n+// { dg-do compile { target c++2a } }\n+\n+template <class T> void spam(decltype([]{}) (*s)[sizeof(T)] = nullptr)\n+{ }\n+\n+void foo()\n+{\n+  spam<int>();\n+}"}, {"sha": "0aa587351b4b8315538c0c11346c217f2aa95fad", "filename": "gcc/testsuite/g++.dg/template/array33.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray33.C?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -0,0 +1,63 @@\n+// Verify that top-level cv-qualifiers on parameter types are considered\n+// when determining the function type of an instantiated function template.\n+// This resolves a part of Core issues 1001/1322.\n+// { dg-do compile }\n+// { dg-additional-options \"-Wno-volatile\" }\n+\n+template<typename T>\n+void foo0(T t = 0);\n+\n+template<typename T>\n+void foo1(const T = 0);\n+\n+template<typename T>\n+void foo2(volatile T t = 0);\n+\n+template<typename T>\n+void foo3(const volatile T t = 0);\n+\n+#if __cplusplus >= 201103L\n+#define SA(X) static_assert(X,#X)\n+SA(__is_same(decltype(foo0<char[]>), void(char*)));\n+SA(__is_same(decltype(foo0<const char[]>), void(const char*)));\n+SA(__is_same(decltype(foo0<volatile char[]>), void(volatile char*)));\n+SA(__is_same(decltype(foo0<const volatile char[]>), void(const volatile char*)));\n+\n+SA(__is_same(decltype(foo1<char[]>), void(const char*)));\n+SA(__is_same(decltype(foo1<const char[]>), void(const char*)));\n+SA(__is_same(decltype(foo1<volatile char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo1<const volatile char[]>), void(const volatile char*)));\n+\n+SA(__is_same(decltype(foo2<char[]>), void(volatile char*)));\n+SA(__is_same(decltype(foo2<const char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo2<volatile char[]>), void(volatile char*)));\n+SA(__is_same(decltype(foo2<const volatile char[]>), void(const volatile char*)));\n+\n+SA(__is_same(decltype(foo3<char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo3<const char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo3<volatile char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo3<const volatile char[]>), void(const volatile char*)));\n+#endif\n+\n+int main()\n+{\n+  foo0<char[]>();\n+  foo0<const char[]>();\n+  foo0<volatile char[]>();\n+  foo0<const volatile char[]>();\n+\n+  foo1<char[]>();\n+  foo1<const char[]>();\n+  foo1<volatile char[]>();\n+  foo1<const volatile char[]>();\n+\n+  foo2<char[]>();\n+  foo2<const char[]>();\n+  foo2<volatile char[]>();\n+  foo2<const volatile char[]>();\n+\n+  foo3<char[]>();\n+  foo3<const char[]>();\n+  foo3<volatile char[]>();\n+  foo3<const volatile char[]>();\n+}"}, {"sha": "38c06401974ec260b24ac87657dbdd0353ec1c0d", "filename": "gcc/testsuite/g++.dg/template/array34.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray34.C?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -0,0 +1,63 @@\n+// Verify that top-level cv-qualifiers on parameter types are considered\n+// when determining the function type of an instantiated function template.\n+// This resolves a part of Core issues 1001/1322.\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-Wno-volatile\" }\n+\n+template<typename... Ts>\n+void foo0(Ts... t);\n+\n+template<typename... Ts>\n+void foo1(const Ts... t);\n+\n+template<typename... Ts>\n+void foo2(volatile Ts... t);\n+\n+template<typename... Ts>\n+void foo3(const volatile Ts... t);\n+\n+#if __cplusplus >= 201103L\n+#define SA(X) static_assert(X,#X)\n+SA(__is_same(decltype(foo0<char[]>), void(char*)));\n+SA(__is_same(decltype(foo0<const char[]>), void(const char*)));\n+SA(__is_same(decltype(foo0<volatile char[]>), void(volatile char*)));\n+SA(__is_same(decltype(foo0<const volatile char[]>), void(const volatile char*)));\n+\n+SA(__is_same(decltype(foo1<char[]>), void(const char*)));\n+SA(__is_same(decltype(foo1<const char[]>), void(const char*)));\n+SA(__is_same(decltype(foo1<volatile char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo1<const volatile char[]>), void(const volatile char*)));\n+\n+SA(__is_same(decltype(foo2<char[]>), void(volatile char*)));\n+SA(__is_same(decltype(foo2<const char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo2<volatile char[]>), void(volatile char*)));\n+SA(__is_same(decltype(foo2<const volatile char[]>), void(const volatile char*)));\n+\n+SA(__is_same(decltype(foo3<char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo3<const char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo3<volatile char[]>), void(const volatile char*)));\n+SA(__is_same(decltype(foo3<const volatile char[]>), void(const volatile char*)));\n+#endif\n+\n+int main()\n+{\n+  foo0<char[]>(0);\n+  foo0<const char[]>(0);\n+  foo0<volatile char[]>(0);\n+  foo0<const volatile char[]>(0);\n+\n+  foo1<char[]>(0);\n+  foo1<const char[]>(0);\n+  foo1<volatile char[]>(0);\n+  foo1<const volatile char[]>(0);\n+\n+  foo2<char[]>(0);\n+  foo2<const char[]>(0);\n+  foo2<volatile char[]>(0);\n+  foo2<const volatile char[]>(0);\n+\n+  foo3<char[]>(0);\n+  foo3<const char[]>(0);\n+  foo3<volatile char[]>(0);\n+  foo3<const volatile char[]>(0);\n+}"}, {"sha": "599061cedb0006bac934b2c95005d91c7955ca15", "filename": "gcc/testsuite/g++.dg/template/defarg22.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f55e030ed068d5c7b14c65a74d102db925dab2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg22.C?ref=12f55e030ed068d5c7b14c65a74d102db925dab2", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/92010\n+// { dg-do compile { target c++11 } }\n+\n+template <typename T = char[3]>\n+void foo(const T t = \"; \")\n+{\n+}\n+\n+int main()\n+{\n+  foo ();\n+}\n+"}]}