{"sha": "663eecfd13dbedddf6fccc1a857dd1728078040b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYzZWVjZmQxM2RiZWRkZGY2ZmNjYzFhODU3ZGQxNzI4MDc4MDQwYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-08-12T07:34:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-08-12T07:34:40Z"}, "message": "re PR target/72851 (memory hog with -O3 on s390x-linux-gnu)\n\n2016-08-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/72851\n\t* tree-ssa-propagate.c: Include cfganal.h.  Rewrite block and stmt\n\tworklists to use bitmaps indexed in execution order.\n\t(executable_blocks, cfg_blocks_num, cfg_blocks_tail, cfg_blocks_head,\n\tbb_in_list, interesting_ssa_edges, varying_ssa_edges): Remove.\n\t(cfg_blocks): Make a bitmap.\n\t(bb_to_cfg_order, cfg_order_to_bb, ssa_edge_worklist, uid_to_stmt):\n\tNew globals.\n\t(cfg_blocks_empty_p): Adjust.\n\t(cfg_blocks_add): Likewise.\n\t(cfg_blocks_get): Likewise.\n\t(add_ssa_edge): Likewise.\n\t(add_control_edge): Likewise.\n\t(simulate_stmt): Likewise.\n\t(process_ssa_edge_worklist): Likewise.\n\t(simulate_block): Likewise.\n\t(ssa_prop_init): Compute PRE order and stmt UIDs.\n\t(ssa_prop_fini): Adjust.\n\t(ssa_propagate): Adjust.\n\n\t* gcc.dg/torture/pr72851.c: New testcase.\n\nFrom-SVN: r239405", "tree": {"sha": "3c82bb723f547853f74f2943f3b04ec07a34fca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c82bb723f547853f74f2943f3b04ec07a34fca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/663eecfd13dbedddf6fccc1a857dd1728078040b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/663eecfd13dbedddf6fccc1a857dd1728078040b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/663eecfd13dbedddf6fccc1a857dd1728078040b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/663eecfd13dbedddf6fccc1a857dd1728078040b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2650da88925c04bbab77d45889a7cb460208d95e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2650da88925c04bbab77d45889a7cb460208d95e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2650da88925c04bbab77d45889a7cb460208d95e"}], "stats": {"total": 372, "additions": 153, "deletions": 219}, "files": [{"sha": "518562787f73806ed91e644f772113c31525f659", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=663eecfd13dbedddf6fccc1a857dd1728078040b", "patch": "@@ -1,3 +1,25 @@\n+2016-08-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/72851\n+\t* tree-ssa-propagate.c: Include cfganal.h.  Rewrite block and stmt\n+\tworklists to use bitmaps indexed in execution order.\n+\t(executable_blocks, cfg_blocks_num, cfg_blocks_tail, cfg_blocks_head,\n+\tbb_in_list, interesting_ssa_edges, varying_ssa_edges): Remove.\n+\t(cfg_blocks): Make a bitmap.\n+\t(bb_to_cfg_order, cfg_order_to_bb, ssa_edge_worklist, uid_to_stmt):\n+\tNew globals.\n+\t(cfg_blocks_empty_p): Adjust.\n+\t(cfg_blocks_add): Likewise.\n+\t(cfg_blocks_get): Likewise.\n+\t(add_ssa_edge): Likewise.\n+\t(add_control_edge): Likewise.\n+\t(simulate_stmt): Likewise.\n+\t(process_ssa_edge_worklist): Likewise.\n+\t(simulate_block): Likewise.\n+\t(ssa_prop_init): Compute PRE order and stmt UIDs.\n+\t(ssa_prop_fini): Adjust.\n+\t(ssa_propagate): Adjust.\n+\n 2016-08-12  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vrp.c (vrp_visit_phi_node): Allow a last iteration if"}, {"sha": "bc8e8d4d64bf2ababa498c7f0109f4b1de76c62c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=663eecfd13dbedddf6fccc1a857dd1728078040b", "patch": "@@ -1,3 +1,8 @@\n+2016-08-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/72851\n+\t* gcc.dg/torture/pr72851.c: New testcase.\n+\n 2016-08-12  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR debug/63240"}, {"sha": "3760c4c77abe502b0f6c143d43d39cedb2c26176", "filename": "gcc/testsuite/gcc.dg/torture/pr72851.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr72851.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr72851.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr72851.c?ref=663eecfd13dbedddf6fccc1a857dd1728078040b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+\n+typedef unsigned char uint8_t;\n+typedef unsigned long int uint64_t;\n+union unaligned_64 {\n+    uint64_t l;\n+}\n+__attribute__((packed)) __attribute__((may_alias));\n+typedef struct AVDES {\n+    uint64_t round_keys[3][16];\n+} AVDES;\n+static const uint8_t PC1_shuffle[] = {\n+    64-57,64-49,64-41,64-33,64-25,64-17,64-9,     64-1,64-58,64-50,64-42,64-34,64-26,64-18,     64-10,64-2,64-59,64-51,64-43,64-35,64-27,     64-19,64-11,64-3,64-60,64-52,64-44,64-36,     64-63,64-55,64-47,64-39,64-31,64-23,64-15,     64-7,64-62,64-54,64-46,64-38,64-30,64-22,     64-14,64-6,64-61,64-53,64-45,64-37,64-29,     64-21,64-13,64-5,64-28,64-20,64-12,64-4 };\n+static const uint8_t PC2_shuffle[] = {\n+    56-14,56-17,56-11,56-24,56-1,56-5,     56-3,56-28,56-15,56-6,56-21,56-10,     56-23,56-19,56-12,56-4,56-26,56-8,     56-16,56-7,56-27,56-20,56-13,56-2,     56-41,56-52,56-31,56-37,56-47,56-55,     56-30,56-40,56-51,56-45,56-33,56-48,     56-44,56-49,56-39,56-56,56-34,56-53,     56-46,56-42,56-50,56-36,56-29,56-32 };\n+static uint64_t shuffle(uint64_t in, const uint8_t *shuffle, int shuffle_len)\n+{\n+  int i;\n+  uint64_t res = 0;\n+  for (i = 0; i < shuffle_len; i++)\n+    res += res + ((in >> *shuffle++) & 1);\n+  return res;\n+}\n+void gen_roundkeys(uint64_t K[16], uint64_t key)\n+{\n+  int i;\n+  uint64_t CDn = shuffle(key, PC1_shuffle, sizeof(PC1_shuffle));\n+  for (i = 0; i < 16; i++)\n+    K[i] = shuffle(CDn, PC2_shuffle, sizeof(PC2_shuffle));\n+}"}, {"sha": "6cbcd447de9da9868b6db8dd7894ae5be3dd3abd", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 96, "deletions": 219, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/663eecfd13dbedddf6fccc1a857dd1728078040b/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=663eecfd13dbedddf6fccc1a857dd1728078040b", "patch": "@@ -37,6 +37,7 @@\n #include \"domwalk.h\"\n #include \"cfgloop.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"cfganal.h\"\n \n /* This file implements a generic value propagation engine based on\n    the same propagation used by the SSA-CCP algorithm [1].\n@@ -83,13 +84,8 @@\n \t    Blocks are added to this list if their incoming edges are\n \t    found executable.\n \n-\tVARYING_SSA_EDGES contains the list of statements that feed\n-\t    from statements that produce an SSA_PROP_VARYING result.\n-\t    These are simulated first to speed up processing.\n-\n-\tINTERESTING_SSA_EDGES contains the list of statements that\n-\t    feed from statements that produce an SSA_PROP_INTERESTING\n-\t    result.\n+\tSSA_EDGE_WORKLIST contains the list of statements that we \n+\t    need to revisit.\n \n    5- Simulation terminates when all three work lists are drained.\n \n@@ -116,109 +112,38 @@\n static ssa_prop_visit_stmt_fn ssa_prop_visit_stmt;\n static ssa_prop_visit_phi_fn ssa_prop_visit_phi;\n \n-/* Keep track of statements that have been added to one of the SSA\n-   edges worklists.  This flag is used to avoid visiting statements\n-   unnecessarily when draining an SSA edge worklist.  If while\n-   simulating a basic block, we find a statement with\n-   STMT_IN_SSA_EDGE_WORKLIST set, we clear it to prevent SSA edge\n-   processing from visiting it again.\n-\n-   NOTE: users of the propagation engine are not allowed to use\n-   the GF_PLF_1 flag.  */\n-#define STMT_IN_SSA_EDGE_WORKLIST\tGF_PLF_1\n-\n-/* A bitmap to keep track of executable blocks in the CFG.  */\n-static sbitmap executable_blocks;\n-\n-/* Array of control flow edges on the worklist.  */\n-static vec<basic_block> cfg_blocks;\n-\n-static unsigned int cfg_blocks_num = 0;\n-static int cfg_blocks_tail;\n-static int cfg_blocks_head;\n-\n-static sbitmap bb_in_list;\n+/* Worklist of control flow edge destinations.  This contains\n+   the CFG order number of the blocks so we can iterate in CFG\n+   order by visiting in bit-order.  */\n+static bitmap cfg_blocks;\n+static int *bb_to_cfg_order;\n+static int *cfg_order_to_bb;\n \n /* Worklist of SSA edges which will need reexamination as their\n    definition has changed.  SSA edges are def-use edges in the SSA\n    web.  For each D-U edge, we store the target statement or PHI node\n-   U.  */\n-static vec<gimple *> interesting_ssa_edges;\n-\n-/* Identical to INTERESTING_SSA_EDGES.  For performance reasons, the\n-   list of SSA edges is split into two.  One contains all SSA edges\n-   who need to be reexamined because their lattice value changed to\n-   varying (this worklist), and the other contains all other SSA edges\n-   to be reexamined (INTERESTING_SSA_EDGES).\n-\n-   Since most values in the program are VARYING, the ideal situation\n-   is to move them to that lattice value as quickly as possible.\n-   Thus, it doesn't make sense to process any other type of lattice\n-   value until all VARYING values are propagated fully, which is one\n-   thing using the VARYING worklist achieves.  In addition, if we\n-   don't use a separate worklist for VARYING edges, we end up with\n-   situations where lattice values move from\n-   UNDEFINED->INTERESTING->VARYING instead of UNDEFINED->VARYING.  */\n-static vec<gimple *> varying_ssa_edges;\n-\n+   UID in a bitmap.  UIDs order stmts in execution order.   */\n+static bitmap ssa_edge_worklist;\n+static vec<gimple *> uid_to_stmt;\n \n /* Return true if the block worklist empty.  */\n \n static inline bool\n cfg_blocks_empty_p (void)\n {\n-  return (cfg_blocks_num == 0);\n+  return bitmap_empty_p (cfg_blocks);\n }\n \n \n-/* Add a basic block to the worklist.  The block must not be already\n-   in the worklist, and it must not be the ENTRY or EXIT block.  */\n+/* Add a basic block to the worklist.  The block must not be the ENTRY\n+   or EXIT block.  */\n \n static void\n cfg_blocks_add (basic_block bb)\n {\n-  bool head = false;\n-\n   gcc_assert (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t      && bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n-  gcc_assert (!bitmap_bit_p (bb_in_list, bb->index));\n-\n-  if (cfg_blocks_empty_p ())\n-    {\n-      cfg_blocks_tail = cfg_blocks_head = 0;\n-      cfg_blocks_num = 1;\n-    }\n-  else\n-    {\n-      cfg_blocks_num++;\n-      if (cfg_blocks_num > cfg_blocks.length ())\n-\t{\n-\t  /* We have to grow the array now.  Adjust to queue to occupy\n-\t     the full space of the original array.  We do not need to\n-\t     initialize the newly allocated portion of the array\n-\t     because we keep track of CFG_BLOCKS_HEAD and\n-\t     CFG_BLOCKS_HEAD.  */\n-\t  cfg_blocks_tail = cfg_blocks.length ();\n-\t  cfg_blocks_head = 0;\n-\t  cfg_blocks.safe_grow (2 * cfg_blocks_tail);\n-\t}\n-      /* Minor optimization: we prefer to see blocks with more\n-\t predecessors later, because there is more of a chance that\n-\t the incoming edges will be executable.  */\n-      else if (EDGE_COUNT (bb->preds)\n-\t       >= EDGE_COUNT (cfg_blocks[cfg_blocks_head]->preds))\n-\tcfg_blocks_tail = ((cfg_blocks_tail + 1) % cfg_blocks.length ());\n-      else\n-\t{\n-\t  if (cfg_blocks_head == 0)\n-\t    cfg_blocks_head = cfg_blocks.length ();\n-\t  --cfg_blocks_head;\n-\t  head = true;\n-\t}\n-    }\n-\n-  cfg_blocks[head ? cfg_blocks_head : cfg_blocks_tail] = bb;\n-  bitmap_set_bit (bb_in_list, bb->index);\n+  bitmap_set_bit (cfg_blocks, bb_to_cfg_order[bb->index]);\n }\n \n \n@@ -227,18 +152,10 @@ cfg_blocks_add (basic_block bb)\n static basic_block\n cfg_blocks_get (void)\n {\n-  basic_block bb;\n-\n-  bb = cfg_blocks[cfg_blocks_head];\n-\n   gcc_assert (!cfg_blocks_empty_p ());\n-  gcc_assert (bb);\n-\n-  cfg_blocks_head = ((cfg_blocks_head + 1) % cfg_blocks.length ());\n-  --cfg_blocks_num;\n-  bitmap_clear_bit (bb_in_list, bb->index);\n-\n-  return bb;\n+  int order_index = bitmap_first_set_bit (cfg_blocks);\n+  bitmap_clear_bit (cfg_blocks, order_index);\n+  return BASIC_BLOCK_FOR_FN (cfun, cfg_order_to_bb [order_index]);\n }\n \n \n@@ -247,7 +164,7 @@ cfg_blocks_get (void)\n    them to INTERESTING_SSA_EDGES.  */\n \n static void\n-add_ssa_edge (tree var, bool is_varying)\n+add_ssa_edge (tree var)\n {\n   imm_use_iterator iter;\n   use_operand_p use_p;\n@@ -256,27 +173,19 @@ add_ssa_edge (tree var, bool is_varying)\n     {\n       gimple *use_stmt = USE_STMT (use_p);\n \n+      /* If we did not yet simulate the block wait for this to happen\n+         and do not add the stmt to the SSA edge worklist.  */\n+      if (! (gimple_bb (use_stmt)->flags & BB_VISITED))\n+\tcontinue;\n+\n       if (prop_simulate_again_p (use_stmt)\n-\t  && !gimple_plf (use_stmt, STMT_IN_SSA_EDGE_WORKLIST))\n+\t  && bitmap_set_bit (ssa_edge_worklist, gimple_uid (use_stmt)))\n \t{\n-\t  gimple_set_plf (use_stmt, STMT_IN_SSA_EDGE_WORKLIST, true);\n-\t  if (is_varying)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"varying_ssa_edges: adding SSA use in \");\n-\t\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_SLIM);\n-\t\t}\n-\t      varying_ssa_edges.safe_push (use_stmt);\n-\t    }\n-\t  else\n+\t  uid_to_stmt[gimple_uid (use_stmt)] = use_stmt;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"interesting_ssa_edges: adding SSA use in \");\n-\t\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_SLIM);\n-\t\t}\n-\t      interesting_ssa_edges.safe_push (use_stmt);\n+\t      fprintf (dump_file, \"ssa_edge_worklist: adding SSA use in \");\n+\t      print_gimple_stmt (dump_file, use_stmt, 0, TDF_SLIM);\n \t    }\n \t}\n     }\n@@ -298,10 +207,6 @@ add_control_edge (edge e)\n \n   e->flags |= EDGE_EXECUTABLE;\n \n-  /* If the block is already in the list, we're done.  */\n-  if (bitmap_bit_p (bb_in_list, bb->index))\n-    return;\n-\n   cfg_blocks_add (bb);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -319,6 +224,9 @@ simulate_stmt (gimple *stmt)\n   edge taken_edge = NULL;\n   tree output_name = NULL_TREE;\n \n+  /* Pull the stmt off the SSA edge worklist.  */\n+  bitmap_clear_bit (ssa_edge_worklist, gimple_uid (stmt));\n+\n   /* Don't bother visiting statements that are already\n      considered varying by the propagator.  */\n   if (!prop_simulate_again_p (stmt))\n@@ -339,7 +247,7 @@ simulate_stmt (gimple *stmt)\n       /* If the statement produced a new varying value, add the SSA\n \t edges coming out of OUTPUT_NAME.  */\n       if (output_name)\n-\tadd_ssa_edge (output_name, true);\n+\tadd_ssa_edge (output_name);\n \n       /* If STMT transfers control out of its basic block, add\n \t all outgoing edges to the work list.  */\n@@ -358,7 +266,7 @@ simulate_stmt (gimple *stmt)\n       /* If the statement produced new value, add the SSA edges coming\n \t out of OUTPUT_NAME.  */\n       if (output_name)\n-\tadd_ssa_edge (output_name, false);\n+\tadd_ssa_edge (output_name);\n \n       /* If we know which edge is going to be taken out of this block,\n \t add it to the CFG work list.  */\n@@ -413,54 +321,24 @@ simulate_stmt (gimple *stmt)\n    when an SSA edge is added to it in simulate_stmt.  Return true if a stmt\n    was simulated.  */\n \n-static bool \n-process_ssa_edge_worklist (vec<gimple *> *worklist, const char *edge_list_name)\n+static void\n+process_ssa_edge_worklist ()\n {\n   /* Process the next entry from the worklist.  */\n-  while (worklist->length () > 0)\n-    {\n-      basic_block bb;\n+  unsigned stmt_uid = bitmap_first_set_bit (ssa_edge_worklist);\n+  bitmap_clear_bit (ssa_edge_worklist, stmt_uid);\n+  gimple *stmt = uid_to_stmt[stmt_uid];\n \n-      /* Pull the statement to simulate off the worklist.  */\n-      gimple *stmt = worklist->pop ();\n+  /* We should not have stmts in not yet simulated BBs on the worklist.  */\n+  gcc_assert (gimple_bb (stmt)->flags & BB_VISITED);\n \n-      /* If this statement was already visited by simulate_block, then\n-\t we don't need to visit it again here.  */\n-      if (!gimple_plf (stmt, STMT_IN_SSA_EDGE_WORKLIST))\n-\tcontinue;\n-\n-      /* STMT is no longer in a worklist.  */\n-      gimple_set_plf (stmt, STMT_IN_SSA_EDGE_WORKLIST, false);\n-\n-      bb = gimple_bb (stmt);\n-\n-      /* Visit the statement only if its block is marked executable.\n-         If it is not executable then it will be visited when we simulate\n-\t all statements in the block as soon as an incoming edge gets\n-\t marked executable.  */\n-      if (!bitmap_bit_p (executable_blocks, bb->index))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\nDropping statement from SSA worklist: \");\n-\t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-\t    }\n-\t  continue;\n-\t}\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"\\nSimulating statement (from %s): \",\n-\t\t   edge_list_name);\n-\t  print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-\t}\n-\n-      simulate_stmt (stmt);\n-\n-      return true;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nSimulating statement: \");\n+      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n     }\n \n-  return false;\n+  simulate_stmt (stmt);\n }\n \n \n@@ -486,30 +364,18 @@ simulate_block (basic_block block)\n \n   /* If this is the first time we've simulated this block, then we\n      must simulate each of its statements.  */\n-  if (!bitmap_bit_p (executable_blocks, block->index))\n+  if (! (block->flags & BB_VISITED))\n     {\n       gimple_stmt_iterator j;\n       unsigned int normal_edge_count;\n       edge e, normal_edge;\n       edge_iterator ei;\n \n-      /* Note that we have simulated this block.  */\n-      bitmap_set_bit (executable_blocks, block->index);\n-\n       for (j = gsi_start_bb (block); !gsi_end_p (j); gsi_next (&j))\n-\t{\n-\t  gimple *stmt = gsi_stmt (j);\n-\n-\t  /* If this statement is already in the worklist then\n-\t     \"cancel\" it.  The reevaluation implied by the worklist\n-\t     entry will produce the same value we generate here and\n-\t     thus reevaluating it again from the worklist is\n-\t     pointless.  */\n-\t  if (gimple_plf (stmt, STMT_IN_SSA_EDGE_WORKLIST))\n-\t    gimple_set_plf (stmt, STMT_IN_SSA_EDGE_WORKLIST, false);\n+\tsimulate_stmt (gsi_stmt (j));\n \n-\t  simulate_stmt (stmt);\n-\t}\n+      /* Note that we have simulated this block.  */\n+      block->flags |= BB_VISITED;\n \n       /* We can not predict when abnormal and EH edges will be executed, so\n \t once a block is considered executable, we consider any\n@@ -551,41 +417,55 @@ ssa_prop_init (void)\n   basic_block bb;\n \n   /* Worklists of SSA edges.  */\n-  interesting_ssa_edges.create (20);\n-  varying_ssa_edges.create (20);\n+  ssa_edge_worklist = BITMAP_ALLOC (NULL);\n \n-  executable_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n-  bitmap_clear (executable_blocks);\n-\n-  bb_in_list = sbitmap_alloc (last_basic_block_for_fn (cfun));\n-  bitmap_clear (bb_in_list);\n+  /* Worklist of basic-blocks.  */\n+  bb_to_cfg_order = XNEWVEC (int, last_basic_block_for_fn (cfun) + 1);\n+  cfg_order_to_bb = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+  int n = pre_and_rev_post_order_compute_fn (cfun, cfg_order_to_bb,\n+\t\t\t\t\t     NULL, false);\n+  for (int i = 0; i < n; ++i)\n+    bb_to_cfg_order[cfg_order_to_bb[i]] = i;\n+  cfg_blocks = BITMAP_ALLOC (NULL);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_immediate_uses (dump_file);\n \n-  cfg_blocks.create (20);\n-  cfg_blocks.safe_grow_cleared (20);\n-\n   /* Initially assume that every edge in the CFG is not executable.\n-     (including the edges coming out of the entry block).  */\n-  FOR_ALL_BB_FN (bb, cfun)\n+     (including the edges coming out of the entry block).  Mark blocks\n+     as not visited, blocks not yet visited will have all their statements\n+     simulated once an incoming edge gets executable.  */\n+  set_gimple_stmt_max_uid (cfun, 0);\n+  for (int i = 0; i < n; ++i)\n     {\n       gimple_stmt_iterator si;\n-\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\tgimple_set_plf (gsi_stmt (si), STMT_IN_SSA_EDGE_WORKLIST, false);\n+      bb = BASIC_BLOCK_FOR_FN (cfun, cfg_order_to_bb[i]);\n \n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n-\tgimple_set_plf (gsi_stmt (si), STMT_IN_SSA_EDGE_WORKLIST, false);\n+\t{\n+\t  gimple *stmt = gsi_stmt (si);\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t}\n+\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple *stmt = gsi_stmt (si);\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t}\n \n+      gcc_assert (! (bb->flags & BB_VISITED));\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \te->flags &= ~EDGE_EXECUTABLE;\n     }\n+  uid_to_stmt.safe_grow (gimple_stmt_max_uid (cfun));\n \n   /* Seed the algorithm by adding the successors of the entry block to the\n      edge worklist.  */\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n-    add_control_edge (e);\n+    {\n+      e->flags &= ~EDGE_EXECUTABLE;\n+      add_control_edge (e);\n+    }\n }\n \n \n@@ -594,11 +474,14 @@ ssa_prop_init (void)\n static void\n ssa_prop_fini (void)\n {\n-  interesting_ssa_edges.release ();\n-  varying_ssa_edges.release ();\n-  cfg_blocks.release ();\n-  sbitmap_free (bb_in_list);\n-  sbitmap_free (executable_blocks);\n+  BITMAP_FREE (cfg_blocks);\n+  free (bb_to_cfg_order);\n+  free (cfg_order_to_bb);\n+  BITMAP_FREE (ssa_edge_worklist);\n+  uid_to_stmt.release ();\n+  basic_block bb;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n+    bb->flags &= ~BB_VISITED;\n }\n \n \n@@ -917,26 +800,20 @@ ssa_propagate (ssa_prop_visit_stmt_fn visit_stmt,\n   ssa_prop_init ();\n \n   /* Iterate until the worklists are empty.  */\n-  while (!cfg_blocks_empty_p ()\n-\t || interesting_ssa_edges.length () > 0\n-\t || varying_ssa_edges.length () > 0)\n+  while (! cfg_blocks_empty_p ()\n+\t || ! bitmap_empty_p (ssa_edge_worklist))\n     {\n-      if (!cfg_blocks_empty_p ())\n+      /* First simulate whole blocks.  */\n+      if (! cfg_blocks_empty_p ())\n \t{\n \t  /* Pull the next block to simulate off the worklist.  */\n \t  basic_block dest_block = cfg_blocks_get ();\n \t  simulate_block (dest_block);\n \t  continue;\n \t}\n \n-      /* In order to move things to varying as quickly as\n-\t possible,process the VARYING_SSA_EDGES worklist first.  */\n-      if (process_ssa_edge_worklist (&varying_ssa_edges, \"varying_ssa_edges\"))\n-\tcontinue;\n-\n-      /* Now process the INTERESTING_SSA_EDGES worklist.  */\n-      process_ssa_edge_worklist (&interesting_ssa_edges,\n-\t\t\t\t \"interesting_ssa_edges\");\n+      /* Then simulate from the SSA edge worklist.  */\n+      process_ssa_edge_worklist ();\n     }\n \n   ssa_prop_fini ();"}]}