{"sha": "bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI1MGI4NzBhNGYzMjZiMmNiNWIxZWIxZDhjNjhjM2Y4ZmY4NGYwMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-01-22T21:27:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-01-22T21:27:38Z"}, "message": "re PR tree-optimization/59597 (Performance degradation on Coremark after r205074)\n\n\tPR tree-optimization/59597\n\t* tree-ssa-threadupdate.c (dump_jump_thread_path): Move to earlier\n\tin file.  Accept new argument REGISTERING and use it to modify\n\tdump output appropriately.\n\t(register_jump_thread): Corresponding changes.\n\t(mark_threaded_blocks): Reinstate code to cancel unprofitable\n\tthread paths involving joiner blocks.  Add code to dump cancelled\n\tjump threading paths.\n\n\tPR tree-optimization/59597\n\t* gcc.dg/tree-ssa/pr59597.c: New test.\n\nFrom-SVN: r206941", "tree": {"sha": "b43926888f1ddf150ee2ca98c1a9dd41dda7f2c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b43926888f1ddf150ee2ca98c1a9dd41dda7f2c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/comments", "author": null, "committer": null, "parents": [{"sha": "c3cdd71f455baea8b0c36968239871ab92292577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3cdd71f455baea8b0c36968239871ab92292577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3cdd71f455baea8b0c36968239871ab92292577"}], "stats": {"total": 196, "additions": 157, "deletions": 39}, "files": [{"sha": "f6df113dc00689e4abf9e6a6439e1a31111f7437", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "patch": "@@ -1,3 +1,14 @@\n+2014-01-22  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/59597\n+\t* tree-ssa-threadupdate.c (dump_jump_thread_path): Move to earlier\n+\tin file.  Accept new argument REGISTERING and use it to modify\n+\tdump output appropriately.\n+\t(register_jump_thread): Corresponding changes.\n+\t(mark_threaded_blocks): Reinstate code to cancel unprofitable\n+\tthread paths involving joiner blocks.  Add code to dump cancelled\n+\tjump threading paths.\n+\n 2014-01-22  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/59477"}, {"sha": "6f26f7fe744117df5ef6b94f3e0d601fa2fa2629", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "patch": "@@ -1,3 +1,8 @@\n+2014-01-22  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/59597\n+\t* gcc.dg/tree-ssa/pr59597.c: New test.\n+\n 2014-01-22  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/59477"}, {"sha": "814d299d6463f77b58c6ed434865f0c8b4fd8db3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr59597.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr59597.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr59597.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr59597.c?ref=bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-vrp1-details\" } */\n+\n+typedef unsigned short u16;\n+typedef unsigned char u8;\n+typedef unsigned int u32;\n+#define NNN 10\n+\n+u32 f[NNN], t[NNN];\n+\n+u16 Calc_crc8(u8 data, u16 crc )\n+{\n+  u8 i=0,x16=0,carry=0;\n+  for (i = 0; i < 8; i++)\n+    {\n+      x16 = (u8)((data & 1) ^ ((u8)crc & 1));\n+      data >>= 1;\n+ \n+      if (x16 == 1)\n+\t{\n+\t  crc ^= 0x4002;\n+\t  carry = 1;\n+\t}\n+      else\n+\tcarry = 0;\n+      crc >>= 1;\n+      if (carry)\n+\tcrc |= 0x8000;\n+      else\n+\tcrc &= 0x7fff;\n+    }\n+  return crc;\n+}\n+int main (int argc, char argv[])\n+{\n+  int i, j; u16 crc;\n+  for (j = 0; j < 10000000; j++)\n+    {\n+      for (i = 0; i < NNN; i++)\n+\t{\n+\t  f[i] = random(i);\n+\t  t[i] = random(NNN - i - 1);\n+\t}\n+      for (i=0; i<NNN; i++) \n+\t{\n+\t  crc=Calc_crc8(f[i],(u16)argc);\n+\t  crc=Calc_crc8(t[i],crc);\n+\t}\n+    }\n+  return crc;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Cancelling\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n+"}, {"sha": "f458d6a99856f917ce81ed098e8800e57a44ed38", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 86, "deletions": 39, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=bb50b870a4f326b2cb5b1eb1d8c68c3f8ff84f00", "patch": "@@ -148,6 +148,40 @@ struct redirection_data : typed_free_remove<redirection_data>\n   static inline int equal (const value_type *, const compare_type *);\n };\n \n+/* Dump a jump threading path, including annotations about each\n+   edge in the path.  */\n+\n+static void\n+dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,\n+\t\t       bool registering)\n+{\n+  fprintf (dump_file,\n+\t   \"  %s jump thread: (%d, %d) incoming edge; \",\n+\t   (registering ? \"Registering\" : \"Cancelling\"),\n+\t   path[0]->e->src->index, path[0]->e->dest->index);\n+\n+  for (unsigned int i = 1; i < path.length (); i++)\n+    {\n+      /* We can get paths with a NULL edge when the final destination\n+\t of a jump thread turns out to be a constant address.  We dump\n+\t those paths when debugging, so we have to be prepared for that\n+\t possibility here.  */\n+      if (path[i]->e == NULL)\n+\tcontinue;\n+\n+      if (path[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+\tfprintf (dump_file, \" (%d, %d) joiner; \",\n+\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+      if (path[i]->type == EDGE_COPY_SRC_BLOCK)\n+       fprintf (dump_file, \" (%d, %d) normal;\",\n+\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+      if (path[i]->type == EDGE_NO_COPY_SRC_BLOCK)\n+       fprintf (dump_file, \" (%d, %d) nocopy;\",\n+\t\t path[i]->e->src->index, path[i]->e->dest->index);\n+    }\n+  fputc ('\\n', dump_file);\n+}\n+\n /* Simple hashing function.  For any given incoming edge E, we're going\n    to be most concerned with the final destination of its jump thread\n    path.  So hash on the block index of the final edge in the path.  */\n@@ -1394,16 +1428,61 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   edge e;\n   edge_iterator ei;\n \n-  /* Move the jump threading requests from PATHS to each edge\n-     which starts a jump thread path.  */\n+  /* It is possible to have jump threads in which one is a subpath\n+     of the other.  ie, (A, B), (B, C), (C, D) where B is a joiner\n+     block and (B, C), (C, D) where no joiner block exists.\n+\n+     When this occurs ignore the jump thread request with the joiner\n+     block.  It's totally subsumed by the simpler jump thread request.\n+\n+     This results in less block copying, simpler CFGs.  More importantly,\n+     when we duplicate the joiner block, B, in this case we will create\n+     a new threading opportunity that we wouldn't be able to optimize\n+     until the next jump threading iteration.\n+\n+     So first convert the jump thread requests which do not require a\n+     joiner block.  */\n   for (i = 0; i < paths.length (); i++)\n     {\n       vec<jump_thread_edge *> *path = paths[i];\n-      edge e = (*path)[0]->e;\n-      e->aux = (void *)path;\n-      bitmap_set_bit (tmp, e->dest->index);\n+\n+      if ((*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n+\t{\n+\t  edge e = (*path)[0]->e;\n+\t  e->aux = (void *)path;\n+\t  bitmap_set_bit (tmp, e->dest->index);\n+\t}\n     }\n \n+  /* Now iterate again, converting cases where we want to thread\n+     through a joiner block, but only if no other edge on the path\n+     already has a jump thread attached to it.  */\n+  for (i = 0; i < paths.length (); i++)\n+    {\n+      vec<jump_thread_edge *> *path = paths[i];\n+\n+      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+\t{\n+\t  unsigned int j;\n+\n+\t  for (j = 0; j < path->length (); j++)\n+\t    if ((*path)[j]->e->aux != NULL)\n+\t      break;\n+\n+\t  /* If we iterated through the entire path without exiting the loop,\n+\t     then we are good to go, attach the path to the starting edge.  */\n+\t  if (j == path->length ())\n+\t    {\n+\t      edge e = (*path)[0]->e;\n+\t      e->aux = path;\n+\t      bitmap_set_bit (tmp, e->dest->index);\n+\t    }\n+\t  else if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      dump_jump_thread_path (dump_file, *path, false);\n+\t    }\n+\t}\n+    }\n \n \n   /* If optimizing for size, only thread through block if we don't have\n@@ -1712,38 +1791,6 @@ delete_jump_thread_path (vec<jump_thread_edge *> *path)\n   path->release();\n }\n \n-/* Dump a jump threading path, including annotations about each\n-   edge in the path.  */\n-\n-static void\n-dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path)\n-{\n-  fprintf (dump_file,\n-\t   \"  Registering jump thread: (%d, %d) incoming edge; \",\n-\t   path[0]->e->src->index, path[0]->e->dest->index);\n-\n-  for (unsigned int i = 1; i < path.length (); i++)\n-    {\n-      /* We can get paths with a NULL edge when the final destination\n-\t of a jump thread turns out to be a constant address.  We dump\n-\t those paths when debugging, so we have to be prepared for that\n-\t possibility here.  */\n-      if (path[i]->e == NULL)\n-\tcontinue;\n-\n-      if (path[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-\tfprintf (dump_file, \" (%d, %d) joiner; \",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n-      if (path[i]->type == EDGE_COPY_SRC_BLOCK)\n-       fprintf (dump_file, \" (%d, %d) normal;\",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n-      if (path[i]->type == EDGE_NO_COPY_SRC_BLOCK)\n-       fprintf (dump_file, \" (%d, %d) nocopy;\",\n-\t\t path[i]->e->src->index, path[i]->e->dest->index);\n-    }\n-  fputc ('\\n', dump_file);\n-}\n-\n /* Register a jump threading opportunity.  We queue up all the jump\n    threading opportunities discovered by a pass and update the CFG\n    and SSA form all at once.\n@@ -1770,15 +1817,15 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n \t  {\n \t    fprintf (dump_file,\n \t\t     \"Found NULL edge in jump threading path.  Cancelling jump thread:\\n\");\n-\t    dump_jump_thread_path (dump_file, *path);\n+\t    dump_jump_thread_path (dump_file, *path, false);\n \t  }\n \n \tdelete_jump_thread_path (path);\n \treturn;\n       }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_jump_thread_path (dump_file, *path);\n+    dump_jump_thread_path (dump_file, *path, true);\n \n   if (!paths.exists ())\n     paths.create (5);"}]}