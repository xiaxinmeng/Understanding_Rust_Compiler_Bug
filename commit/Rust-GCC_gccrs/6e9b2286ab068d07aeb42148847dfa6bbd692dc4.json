{"sha": "6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU5YjIyODZhYjA2OGQwN2FlYjQyMTQ4ODQ3ZGZhNmJiZDY5MmRjNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-04-14T23:21:30Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-04-14T23:21:30Z"}, "message": "re PR target/70669 (PowerPC __float128 does not support direct move)\n\n[gcc]\n2016-04-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/70669\n\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Add\n\tdirect move handlers for KFmode. Change TFmode handlers test from\n\tFLOAT128_IEEE_P to FLOAT128_VECTOR_P.\n\n[gcc/testsuite]\n2016-04-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/70669\n\t* gcc.target/powerpc/pr70669.c: New test.\n\nFrom-SVN: r234995", "tree": {"sha": "4abb9954e5d2fa65c3b4e033f037c3bb0daf4430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4abb9954e5d2fa65c3b4e033f037c3bb0daf4430"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/comments", "author": null, "committer": null, "parents": [{"sha": "aadc043f3c1d31fcdfebb4a71821724232465a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aadc043f3c1d31fcdfebb4a71821724232465a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aadc043f3c1d31fcdfebb4a71821724232465a45"}], "stats": {"total": 62, "additions": 57, "deletions": 5}, "files": [{"sha": "f6fdeffcc53538ac63ae0921ba46b893de9acf01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "patch": "@@ -1,3 +1,10 @@\n+2016-04-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/70669\n+\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Add\n+\tdirect move handlers for KFmode. Change TFmode handlers test from\n+\tFLOAT128_IEEE_P to FLOAT128_VECTOR_P.\n+\n 2016-04-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/70594"}, {"sha": "1d0076c41f0f1f08ef10f306efd1ec3aca4ea6a6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "patch": "@@ -3132,16 +3132,20 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_di_load;\n \t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_di_store;\n \t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_di_load;\n-\t  reg_addr[KFmode].reload_store    = CODE_FOR_reload_kf_di_store;\n-\t  reg_addr[KFmode].reload_load     = CODE_FOR_reload_kf_di_load;\n \t  reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_di_store;\n \t  reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_di_load;\n \t  reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_di_store;\n \t  reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_di_load;\n \t  reg_addr[SFmode].reload_store    = CODE_FOR_reload_sf_di_store;\n \t  reg_addr[SFmode].reload_load     = CODE_FOR_reload_sf_di_load;\n \n-\t  if (FLOAT128_IEEE_P (TFmode))\n+\t  if (FLOAT128_VECTOR_P (KFmode))\n+\t    {\n+\t      reg_addr[KFmode].reload_store = CODE_FOR_reload_kf_di_store;\n+\t      reg_addr[KFmode].reload_load  = CODE_FOR_reload_kf_di_load;\n+\t    }\n+\n+\t  if (FLOAT128_VECTOR_P (TFmode))\n \t    {\n \t      reg_addr[TFmode].reload_store = CODE_FOR_reload_tf_di_store;\n \t      reg_addr[TFmode].reload_load  = CODE_FOR_reload_tf_di_load;\n@@ -3182,6 +3186,18 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t      reg_addr[V8HImode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv8hi;\n \t      reg_addr[V16QImode].reload_vsx_gpr = CODE_FOR_reload_vsx_from_gprv16qi;\n \t      reg_addr[SFmode].reload_vsx_gpr    = CODE_FOR_reload_vsx_from_gprsf;\n+\n+\t      if (FLOAT128_VECTOR_P (KFmode))\n+\t\t{\n+\t\t  reg_addr[KFmode].reload_gpr_vsx = CODE_FOR_reload_gpr_from_vsxkf;\n+\t\t  reg_addr[KFmode].reload_vsx_gpr = CODE_FOR_reload_vsx_from_gprkf;\n+\t\t}\n+\n+\t      if (FLOAT128_VECTOR_P (TFmode))\n+\t\t{\n+\t\t  reg_addr[TFmode].reload_gpr_vsx = CODE_FOR_reload_gpr_from_vsxtf;\n+\t\t  reg_addr[TFmode].reload_vsx_gpr = CODE_FOR_reload_vsx_from_gprtf;\n+\t\t}\n \t    }\n \t}\n       else\n@@ -3200,15 +3216,19 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_si_load;\n \t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_si_store;\n \t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_si_load;\n-\t  reg_addr[KFmode].reload_store    = CODE_FOR_reload_kf_si_store;\n-\t  reg_addr[KFmode].reload_load     = CODE_FOR_reload_kf_si_load;\n \t  reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_si_store;\n \t  reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_si_load;\n \t  reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_si_store;\n \t  reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_si_load;\n \t  reg_addr[SFmode].reload_store    = CODE_FOR_reload_sf_si_store;\n \t  reg_addr[SFmode].reload_load     = CODE_FOR_reload_sf_si_load;\n \n+\t  if (FLOAT128_VECTOR_P (KFmode))\n+\t    {\n+\t      reg_addr[KFmode].reload_store = CODE_FOR_reload_kf_si_store;\n+\t      reg_addr[KFmode].reload_load  = CODE_FOR_reload_kf_si_load;\n+\t    }\n+\n \t  if (FLOAT128_IEEE_P (TFmode))\n \t    {\n \t      reg_addr[TFmode].reload_store = CODE_FOR_reload_tf_si_store;"}, {"sha": "4131b9fcfe466d84c6212a6c5193e7df00f7931d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "patch": "@@ -1,5 +1,8 @@\n 2016-04-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n+\tPR target/70669\n+\t* gcc.target/powerpc/pr70669.c: New test.\n+\n \tPR target/70640\n \t* gcc.target/powerpc/pr70640.c: Fix test so it correctly works on\n \ta power7 system that does not have an assembler that supports"}, {"sha": "8054102ee50d21c467e3a9dbdc925c4aef56ba7d", "filename": "gcc/testsuite/gcc.target/powerpc/pr70669.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70669.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9b2286ab068d07aeb42148847dfa6bbd692dc4/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70669.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70669.c?ref=6e9b2286ab068d07aeb42148847dfa6bbd692dc4", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8 -mfloat128\" } */\n+\n+#ifndef TYPE\n+#define TYPE __float128\n+#endif\n+\n+void foo (TYPE *p, TYPE *q)\n+{\n+  TYPE r = *q;\n+#ifndef NO_ASM\n+  __asm__ (\" # %0\" : \"+r\" (r));\n+#endif\n+  *p = r;\n+}\n+\n+/* { dg-final { scan-assembler       \"mfvsrd\"    } } */\n+/* { dg-final { scan-assembler       \"mtvsrd\"    } } */\n+/* { dg-final { scan-assembler-times \"stxvd2x\" 1 } } */\n+/* { dg-final { scan-assembler-times \"lxvd2x\"  1 } } */"}]}