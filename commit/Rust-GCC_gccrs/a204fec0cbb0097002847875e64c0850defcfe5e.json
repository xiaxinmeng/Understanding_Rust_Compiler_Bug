{"sha": "a204fec0cbb0097002847875e64c0850defcfe5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwNGZlYzBjYmIwMDk3MDAyODQ3ODc1ZTY0YzA4NTBkZWZjZmU1ZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@cygnus.com", "date": "2000-04-23T21:40:51Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2000-04-23T21:40:51Z"}, "message": "mn10300.h (REGNO_IN_RANGE_P): New macro.\n\n* config/mn10300/mn10300.h (REGNO_IN_RANGE_P): New macro.\n(REGNO_DATA_P, REGNO_ADDRESS_P, REGNO_SP_P): New macros.\n(REGNO_EXTENDED_P, REGNO_AM33_P): New macros.\n(REGNO_OK_FOR_BASE_P): Define in terms of them.\n(REGNO_OK_FOR_BIT_BASE_P, REGNO_OK_FOR_INDEX_P): Likewise.\n(REG_OK_FOR_BASE_P): Define in terms of the REGNO macro.\n(REG_OK_FOR_BIT_BASE_P, REG_OK_FOR_INDEX_P): Likewise.\n\nFrom-SVN: r33359", "tree": {"sha": "51f555b965dbd58d7e3f2c138b05b4b0fe5cd091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51f555b965dbd58d7e3f2c138b05b4b0fe5cd091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a204fec0cbb0097002847875e64c0850defcfe5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a204fec0cbb0097002847875e64c0850defcfe5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a204fec0cbb0097002847875e64c0850defcfe5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a204fec0cbb0097002847875e64c0850defcfe5e/comments", "author": null, "committer": null, "parents": [{"sha": "96933f43e5d58db7841e3dec6a64b7a168ee517c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96933f43e5d58db7841e3dec6a64b7a168ee517c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96933f43e5d58db7841e3dec6a64b7a168ee517c"}], "stats": {"total": 92, "additions": 49, "deletions": 43}, "files": [{"sha": "9e4789702f112bff33f89f660592caa89b1de960", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a204fec0cbb0097002847875e64c0850defcfe5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a204fec0cbb0097002847875e64c0850defcfe5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a204fec0cbb0097002847875e64c0850defcfe5e", "patch": "@@ -1,3 +1,13 @@\n+Sun Apr 23 18:37:53 2000  Alexandre Oliva  <aoliva@cygnus.com>\n+\n+\t* config/mn10300/mn10300.h (REGNO_IN_RANGE_P): New macro.\n+\t(REGNO_DATA_P, REGNO_ADDRESS_P, REGNO_SP_P): New macros.\n+\t(REGNO_EXTENDED_P, REGNO_AM33_P): New macros.\n+\t(REGNO_OK_FOR_BASE_P): Define in terms of them.\n+\t(REGNO_OK_FOR_BIT_BASE_P, REGNO_OK_FOR_INDEX_P): Likewise.\n+\t(REG_OK_FOR_BASE_P): Define in terms of the REGNO macro.\n+\t(REG_OK_FOR_BIT_BASE_P, REG_OK_FOR_INDEX_P): Likewise.\n+\n Sun Apr 23 22:23:08 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* loop.c (simplify_giv_expr):  Be more agressive on simplifying"}, {"sha": "bbea7b101466be17cb9f6dd70acfad8fc1ac68d3", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a204fec0cbb0097002847875e64c0850defcfe5e/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a204fec0cbb0097002847875e64c0850defcfe5e/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=a204fec0cbb0097002847875e64c0850defcfe5e", "patch": "@@ -292,26 +292,55 @@ enum reg_class {\n \n /* Macros to check register numbers against specific register classes.  */\n \n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n /* These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n- \n+\n+#ifndef REG_OK_STRICT\n+# define REGNO_IN_RANGE_P(regno,min,max) \\\n+  (((regno) >= (min) && (regno) <= (max)) || (regno) >= FIRST_PSEUDO_REGISTER)\n+#else\n+# define REGNO_IN_RANGE_P(regno,min,max) \\\n+  (((regno) >= (min) && (regno) <= (max)) \\\n+   || (reg_renumber \\\n+       && reg_renumber[(regno)] >= (min) && reg_renumber[(regno)] <= (max)))\n+#endif\n+\n+#define REGNO_DATA_P(regno) REGNO_IN_RANGE_P ((regno), 0, 3)\n+#define REGNO_ADDRESS_P(regno) REGNO_IN_RANGE_P ((regno), 4, 8)\n+#define REGNO_SP_P(regno) REGNO_IN_RANGE_P ((regno), 9, 9)\n+#define REGNO_EXTENDED_P(regno) REGNO_IN_RANGE_P ((regno), 10, 17)\n+#define REGNO_AM33_P(regno) \\\n+  (REGNO_DATA_P ((regno)) || REGNO_ADDRESS_P ((regno)) \\\n+   || REGNO_EXTENDED_P ((regno)))\n+\n #define REGNO_OK_FOR_BASE_P(regno) \\\n-  (((regno) > 3 && regno < FIRST_PSEUDO_REGISTER)\t\\\n-   || (reg_renumber[regno] > 3 && reg_renumber[regno] < FIRST_PSEUDO_REGISTER))\n+  (REGNO_SP_P ((regno)) \\\n+   || REGNO_ADDRESS_P ((regno)) || REGNO_EXTENDED_P ((regno)))\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #define REGNO_OK_FOR_BIT_BASE_P(regno) \\\n-  (((regno) > 3 && regno < 10)\t\\\n-   || (reg_renumber[regno] > 3 && reg_renumber[regno] < 10))\n+  (REGNO_SP_P ((regno)) || REGNO_ADDRESS_P ((regno)))\n+#define REG_OK_FOR_BIT_BASE_P(X) REGNO_OK_FOR_BIT_BASE_P (REGNO (X))\n \n #define REGNO_OK_FOR_INDEX_P(regno) \\\n-  (((regno) >= 0 && regno < 4)\t\\\n-   || ((regno) >= 10 && regno < 18)\t\\\n-   || (reg_renumber[regno] >= 10 && reg_renumber[regno] < 18) \\\n-   || (reg_renumber[regno] >= 0 && reg_renumber[regno] < 4))\n-\n+  (REGNO_DATA_P ((regno)) || REGNO_EXTENDED_P ((regno)))\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n@@ -646,39 +675,6 @@ struct cum_arg {int nbytes; };\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X)  \\\n-  ((REGNO (X) >= 0 && REGNO(X) <= 3) || REGNO (X) >= 10)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  ((REGNO (X) >= 4 && REGNO(X) <= 9) || REGNO (X) >= 10)\n-#define REG_OK_FOR_BIT_BASE_P(X) \\\n-  ((REGNO (X) >= 4 && REGNO(X) <= 9))\n-#else\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BIT_BASE_P(X) REGNO_OK_FOR_BIT_BASE_P (REGNO (X))\n-#endif\n-\n \f\n #define HAVE_POST_INCREMENT (TARGET_AM33)\n "}]}