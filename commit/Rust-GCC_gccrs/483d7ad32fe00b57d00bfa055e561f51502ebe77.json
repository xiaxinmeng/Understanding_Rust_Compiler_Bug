{"sha": "483d7ad32fe00b57d00bfa055e561f51502ebe77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzZDdhZDMyZmUwMGI1N2QwMGJmYTA1NWU1NjFmNTE1MDJlYmU3Nw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2011-04-08T16:21:39Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2011-04-08T16:21:39Z"}, "message": "re PR target/48366 (ICE in extract_constrain_insn_cached, at recog.c:2024)\n\n\tPR target/48366\n\t* config/pa/pa.c (hppa_register_move_cost): Increase to 18 cost of\n\tmove from floating point to shift amount register .\n\t(emit_move_sequence): Remove secondary reload support for floating\n\tpoint to shift amount amount register copies.\n\t(pa_secondary_reload): Return GENERAL_REGS for floating point/shift\n\tamount register copies.\n\t* config/pa/pa32-regs.h (HARD_REGNO_MODE_OK): For shift amount\n\tregister, return false if mode isn't a scalar integer mode.\n\t* config/pa/pa64-regs.h (HARD_REGNO_MODE_OK): Likewise.\n\nFrom-SVN: r172197", "tree": {"sha": "6122011a980e9558dd38983393ade53d959a4da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6122011a980e9558dd38983393ade53d959a4da0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/483d7ad32fe00b57d00bfa055e561f51502ebe77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483d7ad32fe00b57d00bfa055e561f51502ebe77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483d7ad32fe00b57d00bfa055e561f51502ebe77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483d7ad32fe00b57d00bfa055e561f51502ebe77/comments", "author": null, "committer": null, "parents": [{"sha": "b89381a2e46d8f62d32729eb59dd5c182c6483b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89381a2e46d8f62d32729eb59dd5c182c6483b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89381a2e46d8f62d32729eb59dd5c182c6483b8"}], "stats": {"total": 63, "additions": 43, "deletions": 20}, "files": [{"sha": "719f8dd14bdc76547d0469d5ba88e457b9d67b25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=483d7ad32fe00b57d00bfa055e561f51502ebe77", "patch": "@@ -1,3 +1,16 @@\n+2011-04-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/48366\n+\t* config/pa/pa.c (hppa_register_move_cost): Increase to 18 cost of\n+\tmove from floating point to shift amount register .\n+\t(emit_move_sequence): Remove secondary reload support for floating\n+\tpoint to shift amount amount register copies.\n+\t(pa_secondary_reload): Return GENERAL_REGS for floating point/shift\n+\tamount register copies.\n+\t* config/pa/pa32-regs.h (HARD_REGNO_MODE_OK): For shift amount\n+\tregister, return false if mode isn't a scalar integer mode.\n+\t* config/pa/pa64-regs.h (HARD_REGNO_MODE_OK): Likewise.\n+\n 2011-04-08  Richard Guenther  <rguenther@suse.de>\n \n \t* gimple.c (gimple_call_flags): Remove kludge."}, {"sha": "21b62de3569700707935e3b7e282ee7cdd2535bf", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=483d7ad32fe00b57d00bfa055e561f51502ebe77", "patch": "@@ -1447,6 +1447,8 @@ hppa_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n {\n   if (from == SHIFT_REGS)\n     return 0x100;\n+  else if (to == SHIFT_REGS && FP_REG_CLASS_P (from))\n+    return 18;\n   else if ((FP_REG_CLASS_P (from) && ! FP_REG_CLASS_P (to))\n            || (FP_REG_CLASS_P (to) && ! FP_REG_CLASS_P (from)))\n     return 16;\n@@ -1790,15 +1792,12 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n       return 1;\n     }\n   /* Handle secondary reloads for SAR.  These occur when trying to load\n-     the SAR from memory, FP register, or with a constant.  */\n+     the SAR from memory or a constant.  */\n   else if (scratch_reg\n \t   && GET_CODE (operand0) == REG\n \t   && REGNO (operand0) < FIRST_PSEUDO_REGISTER\n \t   && REGNO_REG_CLASS (REGNO (operand0)) == SHIFT_REGS\n-\t   && (GET_CODE (operand1) == MEM\n-\t       || GET_CODE (operand1) == CONST_INT\n-\t       || (GET_CODE (operand1) == REG\n-\t\t   && FP_REG_CLASS_P (REGNO_REG_CLASS (REGNO (operand1))))))\n+\t   && (GET_CODE (operand1) == MEM || GET_CODE (operand1) == CONST_INT))\n     {\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n@@ -5863,6 +5862,10 @@ output_arg_descriptor (rtx call_insn)\n   fputc ('\\n', asm_out_file);\n }\n \f\n+/* Inform reload about cases where moving X with a mode MODE to a register in\n+   RCLASS requires an extra scratch or immediate register.  Return the class\n+   needed for the immediate register.  */\n+\n static reg_class_t\n pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t     enum machine_mode mode, secondary_reload_info *sri)\n@@ -5965,24 +5968,29 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n       return NO_REGS;\n     }\n \n-  /* We need a secondary register (GPR) for copies between the SAR\n-     and anything other than a general register.  */\n-  if (rclass == SHIFT_REGS && (regno <= 0 || regno >= 32))\n+  /* A SAR<->FP register copy requires an intermediate general register\n+     and secondary memory.  We need a secondary reload with a general\n+     scratch register for spills.  */\n+  if (rclass == SHIFT_REGS)\n     {\n-      sri->icode = (in_p\n-\t\t    ? direct_optab_handler (reload_in_optab, mode)\n-\t\t    : direct_optab_handler (reload_out_optab, mode));\n-      return NO_REGS;\n+      /* Handle spill.  */\n+      if (regno >= FIRST_PSEUDO_REGISTER || regno < 0)\n+\t{\n+\t  sri->icode = (in_p\n+\t\t\t? direct_optab_handler (reload_in_optab, mode)\n+\t\t\t: direct_optab_handler (reload_out_optab, mode));\n+\t  return NO_REGS;\n+\t}\n+\n+      /* Handle FP copy.  */\n+      if (FP_REG_CLASS_P (REGNO_REG_CLASS (regno)))\n+\treturn GENERAL_REGS;\n     }\n \n-  /* A SAR<->FP register copy requires a secondary register (GPR) as\n-     well as secondary memory.  */\n   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n-      && (REGNO_REG_CLASS (regno) == SHIFT_REGS\n-      && FP_REG_CLASS_P (rclass)))\n-    sri->icode = (in_p\n-\t\t  ? direct_optab_handler (reload_in_optab, mode)\n-\t\t  : direct_optab_handler (reload_out_optab, mode));\n+      && REGNO_REG_CLASS (regno) == SHIFT_REGS\n+      && FP_REG_CLASS_P (rclass))\n+    return GENERAL_REGS;\n \n   return NO_REGS;\n }"}, {"sha": "a209773160a6a9dacdb1f6c4f82fdffa77269451", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=483d7ad32fe00b57d00bfa055e561f51502ebe77", "patch": "@@ -209,6 +209,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    registers.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n+   : (REGNO) == 88 ? SCALAR_INT_MODE_P (MODE)\t\t\t\t\\\n    : !TARGET_PA_11 && FP_REGNO_P (REGNO)\t\t\t\t\\\n      ? (VALID_FP_MODE_P (MODE)\t\t\t\t\t\t\\\n \t&& (GET_MODE_SIZE (MODE) <= 8\t\t\t\t\t\\"}, {"sha": "b5f04309fbc1cc960e274f80ae9a7ab74198a0c8", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483d7ad32fe00b57d00bfa055e561f51502ebe77/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=483d7ad32fe00b57d00bfa055e561f51502ebe77", "patch": "@@ -149,10 +149,11 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n-   force this to be an even register is it cannot hold the full mode.  */\n+   force this to be an even register if it cannot hold the full mode.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0\t\t\t\t\t\t\t\t\\\n    ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\t\t\\\n+   : (REGNO) == 60 ? SCALAR_INT_MODE_P (MODE)\t\t\t\t\\\n    /* Make wide modes be in aligned registers.  */\t\t\t\\\n    : FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n      ? (VALID_FP_MODE_P (MODE)\t\t\t\t\t\t\\"}]}