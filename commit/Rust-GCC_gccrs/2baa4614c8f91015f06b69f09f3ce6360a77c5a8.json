{"sha": "2baa4614c8f91015f06b69f09f3ce6360a77c5a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhYTQ2MTRjOGY5MTAxNWYwNmI2OWYwOWYzY2U2MzYwYTc3YzVhOA==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2020-12-11T10:32:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-29T08:00:42Z"}, "message": "[Ada] Fixes in the use of spans for error locations\n\ngcc/ada/\n\n\t* errout.adb (Error_Msg_NEL): Extract span from node.\n\t(First_And_Last_Nodes): Use spans for subtype indications and\n\tattribute definition clauses.\n\t(Write_Source_Code_Lines): Fix for tabulation characters. Change\n\toutput for large spans to skip intermediate lines.\n\t* sem_case.adb (Check_Choice_Set): Report duplicate choice on\n\tthe Original_Node for the case.\n\t(Generic_Check_Choices): Set the Original_Node for the rewritten\n\tcase, so that the subtree used in spans has the correct\n\tlocations.", "tree": {"sha": "9b288ce29ccdbaca2f9bf6c743bdeb1b9b4c8bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b288ce29ccdbaca2f9bf6c743bdeb1b9b4c8bb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2baa4614c8f91015f06b69f09f3ce6360a77c5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2baa4614c8f91015f06b69f09f3ce6360a77c5a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2baa4614c8f91015f06b69f09f3ce6360a77c5a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2baa4614c8f91015f06b69f09f3ce6360a77c5a8/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d7c874e2c64ebf7631049ace642d246843febae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7c874e2c64ebf7631049ace642d246843febae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d7c874e2c64ebf7631049ace642d246843febae"}], "stats": {"total": 213, "additions": 181, "deletions": 32}, "files": [{"sha": "2b4f278eaf81c03113886bbb7f57415e1f4abdfb", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 169, "deletions": 27, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2baa4614c8f91015f06b69f09f3ce6360a77c5a8/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2baa4614c8f91015f06b69f09f3ce6360a77c5a8/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=2baa4614c8f91015f06b69f09f3ce6360a77c5a8", "patch": "@@ -1430,8 +1430,14 @@ package body Errout is\n       E             : Node_Or_Entity_Id;\n       Flag_Location : Source_Ptr)\n    is\n+      Fst, Lst : Node_Id;\n    begin\n-      Error_Msg_NEL (Msg, N, E, To_Span (Flag_Location));\n+      First_And_Last_Nodes (N, Fst, Lst);\n+      Error_Msg_NEL\n+        (Msg, N, E,\n+         To_Span (Ptr   => Flag_Location,\n+                  First => Source_Ptr'Min (Flag_Location, First_Sloc (Fst)),\n+                  Last  => Source_Ptr'Max (Flag_Location, Last_Sloc (Lst))));\n    end Error_Msg_NEL;\n \n    procedure Error_Msg_NEL\n@@ -1757,7 +1763,7 @@ package body Errout is\n            and then Get_Source_File_Index (Loc) = Sfile\n          then\n             Latest := Norig;\n-            Lloc     := Loc;\n+            Lloc   := Loc;\n          end if;\n \n          return OK_Orig;\n@@ -1782,6 +1788,8 @@ package body Errout is\n                        | N_Pragma\n                        | N_Use_Type_Clause\n                        | N_With_Clause\n+                       | N_Attribute_Definition_Clause\n+                       | N_Subtype_Indication\n       then\n          Earliest := Orig;\n          Eloc := Loc;\n@@ -2284,11 +2292,35 @@ package body Errout is\n \n       procedure Write_Source_Code_Lines (Span : Source_Span) is\n \n+         function Get_Line_End\n+           (Buf : Source_Buffer_Ptr;\n+            Loc : Source_Ptr) return Source_Ptr;\n+         --  Get the source location for the end of the line in Buf for Loc\n+\n+         function Get_Line_Start\n+           (Buf : Source_Buffer_Ptr;\n+            Loc : Source_Ptr) return Source_Ptr;\n+         --  Get the source location for the start of the line in Buf for Loc\n+\n          function Image (X : Positive; Width : Positive) return String;\n          --  Output number X over Width characters, with whitespace padding.\n          --  Only output the low-order Width digits of X, if X is larger than\n          --  Width digits.\n \n+         procedure Write_Buffer\n+           (Buf   : Source_Buffer_Ptr;\n+            First : Source_Ptr;\n+            Last  : Source_Ptr);\n+         --  Output the characters from First to Last position in Buf, using\n+         --  Write_Buffer_Char.\n+\n+         procedure Write_Buffer_Char\n+           (Buf : Source_Buffer_Ptr;\n+            Loc : Source_Ptr);\n+         --  Output the characters at position Loc in Buf, translating ASCII.HT\n+         --  in a suitable number of spaces so that the output is not modified\n+         --  by starting in a different column that 1.\n+\n          procedure Write_Line_Marker\n            (Num   : Pos;\n             Mark  : Boolean;\n@@ -2297,6 +2329,44 @@ package body Errout is\n          --  a Mark to denote the line with the main location when reporting\n          --  a span over multiple lines.\n \n+         ------------------\n+         -- Get_Line_End --\n+         ------------------\n+\n+         function Get_Line_End\n+           (Buf : Source_Buffer_Ptr;\n+            Loc : Source_Ptr) return Source_Ptr\n+         is\n+            Cur_Loc : Source_Ptr := Loc;\n+         begin\n+            while Cur_Loc <= Buf'Last\n+              and then Buf (Cur_Loc) /= ASCII.LF\n+            loop\n+               Cur_Loc := Cur_Loc + 1;\n+            end loop;\n+\n+            return Cur_Loc;\n+         end Get_Line_End;\n+\n+         --------------------\n+         -- Get_Line_Start --\n+         --------------------\n+\n+         function Get_Line_Start\n+           (Buf : Source_Buffer_Ptr;\n+            Loc : Source_Ptr) return Source_Ptr\n+         is\n+            Cur_Loc : Source_Ptr := Loc;\n+         begin\n+            while Cur_Loc > Buf'First\n+              and then Buf (Cur_Loc - 1) /= ASCII.LF\n+            loop\n+               Cur_Loc := Cur_Loc - 1;\n+            end loop;\n+\n+            return Cur_Loc;\n+         end Get_Line_Start;\n+\n          -----------\n          -- Image --\n          -----------\n@@ -2317,6 +2387,50 @@ package body Errout is\n             return Str;\n          end Image;\n \n+         ------------------\n+         -- Write_Buffer --\n+         ------------------\n+\n+         procedure Write_Buffer\n+           (Buf   : Source_Buffer_Ptr;\n+            First : Source_Ptr;\n+            Last  : Source_Ptr)\n+         is\n+         begin\n+            for Loc in First .. Last loop\n+               Write_Buffer_Char (Buf, Loc);\n+            end loop;\n+         end Write_Buffer;\n+\n+         -----------------------\n+         -- Write_Buffer_Char --\n+         -----------------------\n+\n+         procedure Write_Buffer_Char\n+           (Buf : Source_Buffer_Ptr;\n+            Loc : Source_Ptr)\n+         is\n+         begin\n+            --  If the character ASCII.HT is not the last one in the file,\n+            --  output as many spaces as the character represents in the\n+            --  original source file.\n+\n+            if Buf (Loc) = ASCII.HT\n+              and then Loc < Buf'Last\n+            then\n+               for X in Get_Column_Number (Loc) ..\n+                        Get_Column_Number (Loc + 1) - 1\n+               loop\n+                  Write_Char (' ');\n+               end loop;\n+\n+            --  Otherwise output the character itself\n+\n+            else\n+               Write_Char (Buf (Loc));\n+            end if;\n+         end Write_Buffer_Char;\n+\n          -----------------------\n          -- Write_Line_Marker --\n          -----------------------\n@@ -2360,42 +2474,70 @@ package body Errout is\n          if Loc >= First_Source_Ptr then\n             Buf := Source_Text (Get_Source_File_Index (Loc));\n \n-            --  First line of the span with actual source code\n+            --  First line of the span with actual source code. We retrieve\n+            --  the beginning of the line instead of relying on Col_Fst, as\n+            --  ASCII.HT characters change column numbers by possibly more\n+            --  than one.\n \n             Write_Line_Marker\n               (Cur_Line,\n                Line_Fst /= Line_Lst and then Cur_Line = Line,\n                Width);\n-            Write_Str\n-              (String (Buf (Fst - Source_Ptr (Col_Fst) + 1  .. Fst - 1)));\n+            Write_Buffer (Buf, Get_Line_Start (Buf, Cur_Loc), Cur_Loc - 1);\n \n-            --  Output all the lines in the span\n+            --  Output the first/caret/last lines of the span, as well as\n+            --  lines that are directly above/below the caret if they complete\n+            --  the gap with first/last lines, otherwise use ... to denote\n+            --  intermediate lines.\n \n-            while Cur_Loc <= Buf'Last\n-              and then Cur_Loc < Lst\n-            loop\n-               Write_Char (Buf (Cur_Loc));\n-               Cur_Loc := Cur_Loc + 1;\n+            declare\n+               function Do_Write_Line (Cur_Line : Pos) return Boolean is\n+                  (Cur_Line in Line_Fst | Line | Line_Lst\n+                     or else\n+                   (Cur_Line = Line_Fst + 1 and then Cur_Line = Line - 1)\n+                     or else\n+                   (Cur_Line = Line + 1 and then Cur_Line = Line_Lst - 1));\n+            begin\n+               while Cur_Loc <= Buf'Last\n+                 and then Cur_Loc < Lst\n+               loop\n+                  if Do_Write_Line (Cur_Line) then\n+                     Write_Buffer_Char (Buf, Cur_Loc);\n+                  end if;\n \n-               if Buf (Cur_Loc - 1) = ASCII.LF then\n-                  Cur_Line := Cur_Line + 1;\n-                  Write_Line_Marker\n-                    (Cur_Line,\n-                     Line_Fst /= Line_Lst and then Cur_Line = Line,\n-                     Width);\n-               end if;\n-            end loop;\n+                  Cur_Loc := Cur_Loc + 1;\n \n-            --  Output the rest of the last line of the span\n+                  if Buf (Cur_Loc - 1) = ASCII.LF then\n+                     Cur_Line := Cur_Line + 1;\n \n-            while Cur_Loc <= Buf'Last\n-              and then Buf (Cur_Loc) /= ASCII.LF\n-            loop\n-               Write_Char (Buf (Cur_Loc));\n-               Cur_Loc := Cur_Loc + 1;\n-            end loop;\n+                     --  Output ... for skipped lines\n \n-            Write_Eol;\n+                     if (Cur_Line = Line\n+                          and then not Do_Write_Line (Cur_Line - 1))\n+                       or else\n+                        (Cur_Line = Line + 1\n+                          and then not Do_Write_Line (Cur_Line))\n+                     then\n+                        Write_Str ((1 .. Width - 3 => ' ') & \"... | ...\");\n+                        Write_Eol;\n+                     end if;\n+\n+                     --  Display the line marker if the line should be\n+                     --  displayed.\n+\n+                     if Do_Write_Line (Cur_Line) then\n+                        Write_Line_Marker\n+                          (Cur_Line,\n+                           Line_Fst /= Line_Lst and then Cur_Line = Line,\n+                           Width);\n+                     end if;\n+                  end if;\n+               end loop;\n+            end;\n+\n+            --  Output the rest of the last line of the span\n+\n+            Write_Buffer (Buf, Cur_Loc, Get_Line_End (Buf, Cur_Loc));\n \n             --  If the span is on one line, output a second line with caret\n             --  sign pointing to location Loc"}, {"sha": "b69e0ab3e99db69c276bb8fddafd04139d585583", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2baa4614c8f91015f06b69f09f3ce6360a77c5a8/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2baa4614c8f91015f06b69f09f3ce6360a77c5a8/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=2baa4614c8f91015f06b69f09f3ce6360a77c5a8", "patch": "@@ -531,20 +531,23 @@ package body Sem_Case is\n                  and then Compile_Time_Known_Value (C)\n                  and then Expr_Value (C) = Lo\n                then\n-                  Error_Msg_N (\"duplication of choice value: &#!\", C);\n+                  Error_Msg_N\n+                    (\"duplication of choice value: &#!\", Original_Node (C));\n \n                --  Not that special case, so just output the integer value\n \n                else\n                   Error_Msg_Uint_1 := Lo;\n-                  Error_Msg_N (\"duplication of choice value: ^#!\", C);\n+                  Error_Msg_N\n+                    (\"duplication of choice value: ^#!\", Original_Node (C));\n                end if;\n \n             --  Enumeration type\n \n             else\n                Error_Msg_Name_1 := Choice_Image (Lo, Bounds_Type);\n-               Error_Msg_N (\"duplication of choice value: %#!\", C);\n+               Error_Msg_N\n+                 (\"duplication of choice value: %#!\", Original_Node (C));\n             end if;\n \n          --  More than one choice value, so print range of values\n@@ -577,15 +580,18 @@ package body Sem_Case is\n                else\n                   Error_Msg_Uint_1 := Lo;\n                   Error_Msg_Uint_2 := Hi;\n-                  Error_Msg_N (\"duplication of choice values: ^ .. ^#!\", C);\n+                  Error_Msg_N\n+                    (\"duplication of choice values: ^ .. ^#!\",\n+                     Original_Node (C));\n                end if;\n \n             --  Enumeration type\n \n             else\n                Error_Msg_Name_1 := Choice_Image (Lo, Bounds_Type);\n                Error_Msg_Name_2 := Choice_Image (Hi, Bounds_Type);\n-               Error_Msg_N (\"duplication of choice values: % .. %#!\", C);\n+               Error_Msg_N\n+                 (\"duplication of choice values: % .. %#!\", Original_Node (C));\n             end if;\n          end if;\n       end Dup_Choice;\n@@ -1521,6 +1527,7 @@ package body Sem_Case is\n                then\n                   C := New_Copy (P);\n                   Set_Sloc (C, Sloc (Choice));\n+                  Set_Original_Node (C, Choice);\n \n                   if Expr_Value (Low_Bound (C)) < Expr_Value (Lo) then\n                      Set_Low_Bound (C, Lo);"}]}