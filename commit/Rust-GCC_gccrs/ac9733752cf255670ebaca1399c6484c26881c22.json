{"sha": "ac9733752cf255670ebaca1399c6484c26881c22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5NzMzNzUyY2YyNTU2NzBlYmFjYTEzOTljNjQ4NGMyNjg4MWMyMg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-11-21T08:19:38Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-11-21T08:19:38Z"}, "message": "re PR target/53976 ([SH] Unnecessary clrt/sett after bt/bf)\n\n\tPR target/53976\n\t* config/sh/sh_optimize_sett_clrt.cc: New SH specific RTL pass.\n\t* config/sh/sh.c (register_sh_passes): Add sh_optimize_sett_clrt pass.\n\t* config/sh/sh/t-sh (sh_optimize_sett_clrt pass.o): New entry.\n\t* config.gcc (sh[123456789lbe]*-*-* | sh-*-*): Add\n\tsh_optimize_sett_clrt pass.o to\textra_objs.\n\n\tPR target/53976\n\t* gcc.target/sh/pr53976-1.c: New.\n\nFrom-SVN: r205191", "tree": {"sha": "3a02bb347edaffcd765c9df423723ec93cbff917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a02bb347edaffcd765c9df423723ec93cbff917"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac9733752cf255670ebaca1399c6484c26881c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9733752cf255670ebaca1399c6484c26881c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9733752cf255670ebaca1399c6484c26881c22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9733752cf255670ebaca1399c6484c26881c22/comments", "author": null, "committer": null, "parents": [{"sha": "6626665fff31054ae519e8671c85fcd755444bba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6626665fff31054ae519e8671c85fcd755444bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6626665fff31054ae519e8671c85fcd755444bba"}], "stats": {"total": 528, "additions": 525, "deletions": 3}, "files": [{"sha": "ac4cf0b58917a11b4340588ae9e1c5c7391b573a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -1,3 +1,12 @@\n+2013-11-21  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53976\n+\t* config/sh/sh_optimize_sett_clrt.cc: New SH specific RTL pass.\n+\t* config/sh/sh.c (register_sh_passes): Add sh_optimize_sett_clrt pass.\n+\t* config/sh/sh/t-sh (sh_optimize_sett_clrt pass.o): New entry.\n+\t* config.gcc (sh[123456789lbe]*-*-* | sh-*-*): Add\n+\tsh_optimize_sett_clrt pass.o to\textra_objs.\n+\n 2013-11-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cfg.c (dump_edge_info): Remove redundant comment.\n@@ -9301,7 +9310,8 @@\n \n \tPR target/51244\n \t* config/sh/sh_treg_combine.cc: New SH specific RTL pass.\n-\t* config.gcc (SH extra_objs): Add sh_ifcvt.o.\n+\t* config.gcc (sh[123456789lbe]*-*-* | sh-*-*): Add sh_ifcvt.o to\n+\textra_objs.\n \t* config/sh/t-sh (sh_treg_combine.o): New entry.\n \t* config/sh/sh.c (sh_fixed_condition_code_regs): New function that\n \timplements the target hook TARGET_FIXED_CONDITION_CODE_REGS."}, {"sha": "1f20f18aa2c59c520f1d87d6018fed65301c14fc", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -469,7 +469,7 @@ sh[123456789lbe]*-*-* | sh-*-*)\n \tcpu_type=sh\n \tneed_64bit_hwint=yes\n \textra_options=\"${extra_options} fused-madd.opt\"\n-\textra_objs=\"${extra_objs} sh_treg_combine.o sh-mem.o\"\n+\textra_objs=\"${extra_objs} sh_treg_combine.o sh-mem.o sh_optimize_sett_clrt.o\"\n \t;;\n v850*-*-*)\n \tcpu_type=v850"}, {"sha": "6981ab6229a4087924a8e7bfa77b05aec5b5983b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -720,7 +720,9 @@ got_mode_name:;\n \n /* Register SH specific RTL passes.  */\n extern opt_pass* make_pass_sh_treg_combine (gcc::context* ctx, bool split_insns,\n-\t\t\t\t     const char* name);\n+\t\t\t\t\t    const char* name);\n+extern opt_pass* make_pass_sh_optimize_sett_clrt (gcc::context* ctx,\n+\t\t\t\t\t\t  const char* name);\n static void\n register_sh_passes (void)\n {\n@@ -744,6 +746,13 @@ register_sh_passes (void)\n      reordering as this sometimes creates new opportunities.  */\n   register_pass (make_pass_sh_treg_combine (g, true, \"sh_treg_combine3\"),\n \t\t PASS_POS_INSERT_AFTER, \"split4\", 1);\n+\n+  /* Optimize sett and clrt insns, by e.g. removing them if the T bit value\n+     is known after a conditional branch.\n+     This must be done after basic blocks and branch conditions have\n+     stabilized and won't be changed by further passes.  */\n+  register_pass (make_pass_sh_optimize_sett_clrt (g, \"sh_optimize_sett_clrt\"),\n+\t\t PASS_POS_INSERT_BEFORE, \"sched2\", 1);\n }\n \n /* Implement TARGET_OPTION_OVERRIDE macro.  Validate and override "}, {"sha": "abb75672e86eb74a05a0be1d69f5d6de54aa6230", "filename": "gcc/config/sh/sh_optimize_sett_clrt.cc", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_optimize_sett_clrt.cc?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -0,0 +1,453 @@\n+/* An SH specific RTL pass that tries to optimize clrt and sett insns.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"machmode.h\"\n+#include \"basic-block.h\"\n+#include \"df.h\"\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"tree-pass.h\"\n+#include \"target.h\"\n+\n+#include <vector>\n+\n+/*\n+This pass tries to eliminate unnecessary sett or clrt instructions in cases\n+where the ccreg value is already known to be the same as the constant set\n+would set it to.  This is done as follows:\n+\n+Check every BB's insn and see if it's a sett or clrt.\n+Once a sett or clrt insn is hit, walk insns and predecessor basic blocks\n+backwards from that insn and determine all possible ccreg values from all\n+basic block paths.\n+Insns that set the ccreg value in some way (simple set, clobber etc) are\n+recorded.  Conditional branches where one edge leads to the sett / clrt insn\n+are also recorded, since for each edge in the conditional branch the ccreg\n+value is known constant.\n+After collecting all possible ccreg values at the sett / clrt insn, check that\n+all the values are the same.  If that value is the same as the sett / clrt\n+insn would set the ccreg to, the sett / clrt insn can be eliminated.\n+*/\n+\n+\n+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+// Helper functions\n+\n+#define log_msg(...)\\\n+  do { if (dump_file != NULL) fprintf (dump_file, __VA_ARGS__); } while (0)\n+\n+#define log_insn(i)\\\n+  do { if (dump_file != NULL) print_rtl_single (dump_file, \\\n+\t\t\t\t\t\t(const_rtx)i); } while (0)\n+\n+#define log_rtx(r)\\\n+  do { if (dump_file != NULL) print_rtl (dump_file, (const_rtx)r); } while (0)\n+\n+#define log_return(retval, ...)\\\n+  do { if (dump_file != NULL) fprintf (dump_file, __VA_ARGS__); \\\n+       return retval; } while (0)\n+\n+#define log_return_void(...)\\\n+  do { if (dump_file != NULL) fprintf (dump_file, __VA_ARGS__); \\\n+       return; } while (0)\n+\n+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+// RTL pass class\n+\n+class sh_optimize_sett_clrt : public rtl_opt_pass\n+{\n+public:\n+  sh_optimize_sett_clrt (gcc::context* ctx, const char* name);\n+  virtual ~sh_optimize_sett_clrt (void);\n+  virtual bool gate (void);\n+  virtual unsigned int execute (void);\n+\n+private:\n+  static const pass_data default_pass_data;\n+\n+  struct ccreg_value\n+  {\n+    // The insn at which the ccreg value was determined.\n+    rtx insn;\n+\n+    // The basic block where the insn was discovered.\n+    // Notice that the CFG might be invalid at late RTL stages and\n+    // BLOCK_FOR_INSN might return null.  Thus the basic block are recorded\n+    // here while traversing them.\n+    basic_block bb;\n+\n+    // The value of ccreg.  If NULL_RTX, the value is not known, e.g. if the\n+    // ccreg is clobbered.\n+    rtx value;\n+  };\n+\n+  // Update the mode of the captured m_ccreg with the specified mode.\n+  void update_ccreg_mode (machine_mode m);\n+\n+  // Given an insn pattern, check if it sets the ccreg to a constant value\n+  // of either zero or STORE_FLAG_VALUE.  If so, return the value rtx,\n+  // NULL_RTX otherwise.\n+  rtx const_setcc_value (rtx pat) const;\n+\n+  // Given a start insn and its basic block, recursively determine all\n+  // possible ccreg values in all basic block paths that can lead to the\n+  // start insn.\n+  void find_last_ccreg_values (rtx start_insn, basic_block bb,\n+\t\t\t       std::vector<ccreg_value>& values_out,\n+\t\t\t       basic_block prev_visited_bb = NULL) const;\n+\n+  // Given a cbranch insn, its basic block and another basic block, determine\n+  // the value to which the ccreg will be set after jumping/falling through to\n+  // the specified target basic block.\n+  bool sh_cbranch_ccreg_value (rtx cbranch_insn,\n+\t\t\t       basic_block cbranch_insn_bb,\n+\t\t\t       basic_block branch_target_bb) const;\n+\n+  // Check whether all of the ccreg values are the same.\n+  static bool all_ccreg_values_equal (const std::vector<ccreg_value>& values);\n+\n+  // Remove REG_DEAD and REG_UNUSED notes from insns of the specified\n+  // ccreg_value entries.\n+  void remove_ccreg_dead_unused_notes (std::vector<ccreg_value>& values) const;\n+\n+  // rtx of the ccreg that is obtained from the target.\n+  rtx m_ccreg;\n+};\n+\n+const pass_data sh_optimize_sett_clrt::default_pass_data =\n+{\n+  RTL_PASS,\t\t// type\n+  \"\",\t\t\t// name (overwritten by the constructor)\n+  OPTGROUP_NONE,\t// optinfo_flags\n+  true,\t\t\t// has_gate\n+  true,\t\t\t// has_execute\n+  TV_OPTIMIZE,\t\t// tv_id\n+  0,\t\t\t// properties_required\n+  0,\t\t\t// properties_provided\n+  0,\t\t\t// properties_destroyed\n+  0,\t\t\t// todo_flags_start\n+  0\t\t\t// todo_flags_finish\n+};\n+\n+sh_optimize_sett_clrt::sh_optimize_sett_clrt (gcc::context* ctx,\n+\t\t\t\t\t      const char* name)\n+: rtl_opt_pass (default_pass_data, ctx),\n+  m_ccreg (NULL_RTX)\n+{\n+  // Overwrite default name in pass_data base class.\n+  this->name = name;\n+}\n+\n+sh_optimize_sett_clrt::~sh_optimize_sett_clrt (void)\n+{\n+}\n+\n+bool\n+sh_optimize_sett_clrt::gate (void)\n+{\n+  return optimize > 0;\n+}\n+\n+unsigned int\n+sh_optimize_sett_clrt::execute (void)\n+{\n+  unsigned int ccr0 = INVALID_REGNUM;\n+  unsigned int ccr1 = INVALID_REGNUM;\n+\n+  if (targetm.fixed_condition_code_regs (&ccr0, &ccr1)\n+      && ccr0 != INVALID_REGNUM)\n+    {\n+      // Initially create a reg rtx with VOIDmode.\n+      // When the constant setcc is discovered, the mode is changed\n+      // to the mode that is actually used by the target.\n+      m_ccreg = gen_rtx_REG (VOIDmode, ccr0);\n+    }\n+\n+  if (m_ccreg == NULL_RTX)\n+    log_return (0, \"no ccreg.\\n\\n\");\n+\n+  if (STORE_FLAG_VALUE != 1)\n+    log_return (0, \"unsupported STORE_FLAG_VALUE %d\", STORE_FLAG_VALUE);\n+\n+  log_msg (\"ccreg: \");\n+  log_rtx (m_ccreg);\n+  log_msg (\"  STORE_FLAG_VALUE = %d\\n\", STORE_FLAG_VALUE);\n+\n+  if (!df_regs_ever_live_p (ccr0))\n+    log_return (0, \"ccreg never live\\n\\n\");\n+\n+  // Output vector for find_known_ccreg_values.\n+  std::vector<ccreg_value> ccreg_values;\n+  ccreg_values.reserve (32);\n+\n+  // Look for insns that set the ccreg to a constant value and see if it can\n+  // be optimized.\n+  basic_block bb;\n+  FOR_EACH_BB_REVERSE (bb)\n+    for (rtx next_i, i = NEXT_INSN (BB_HEAD (bb));\n+\t i != NULL_RTX && i != BB_END (bb); i = next_i)\n+      {\n+\tnext_i = NEXT_INSN (i);\n+\n+\tif (!INSN_P (i) || !NONDEBUG_INSN_P (i))\n+\t  continue;\n+\n+\trtx setcc_val = const_setcc_value (PATTERN (i));\n+\tif (setcc_val != NULL_RTX)\n+\t  {\n+\t    update_ccreg_mode (GET_MODE (XEXP (PATTERN (i), 0)));\n+\n+\t    log_msg (\"\\n\\nfound const setcc insn in [bb %d]: \\n\", bb->index);\n+\t    log_insn (i);\n+\t    log_msg (\"\\n\");\n+\n+\t    ccreg_values.clear ();\n+\t    find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values);\n+\n+\t    log_msg (\"number of ccreg values collected: %u\\n\",\n+\t\t     (unsigned int)ccreg_values.size ());\n+\n+\t    // If all the collected values are equal and are equal to the\n+\t    // constant value of the setcc insn, the setcc insn can be\n+\t    // removed.\n+\t    if (all_ccreg_values_equal (ccreg_values)\n+\t\t&& rtx_equal_p (ccreg_values.front ().value, setcc_val))\n+\t      {\n+\t\tlog_msg (\"all values are \");\n+\t\tlog_rtx (setcc_val);\n+\t\tlog_msg (\"\\n\");\n+\n+\t\tdelete_insn (i);\n+\t\tremove_ccreg_dead_unused_notes (ccreg_values);\n+\t      }\n+\t  }\n+      }\n+\n+  log_return (0, \"\\n\\n\");\n+}\n+\n+void\n+sh_optimize_sett_clrt::update_ccreg_mode (machine_mode m)\n+{\n+  if (GET_MODE (m_ccreg) == m)\n+    return;\n+\n+  PUT_MODE (m_ccreg, m);\n+  log_msg (\"updated ccreg mode: \");\n+  log_rtx (m_ccreg);\n+  log_msg (\"\\n\\n\");\n+}\n+\n+rtx\n+sh_optimize_sett_clrt::const_setcc_value (rtx pat) const\n+{\n+  if (GET_CODE (pat) == SET\n+      && REG_P (XEXP (pat, 0)) && REGNO (XEXP (pat, 0)) == REGNO (m_ccreg)\n+      && CONST_INT_P (XEXP (pat, 1))\n+      && (INTVAL (XEXP (pat, 1)) == 0\n+\t  || INTVAL (XEXP (pat, 1)) == STORE_FLAG_VALUE))\n+    return XEXP (pat, 1);\n+  else\n+    return NULL_RTX;\n+}\n+\n+bool\n+sh_optimize_sett_clrt\n+::sh_cbranch_ccreg_value (rtx cbranch_insn, basic_block cbranch_insn_bb,\n+\t\t\t  basic_block branch_target_bb) const\n+{\n+  rtx pc_set_rtx = pc_set (cbranch_insn);\n+  gcc_assert (pc_set_rtx != NULL_RTX);\n+  gcc_assert (branch_target_bb != NULL);\n+\n+  rtx cond = XEXP (XEXP (pc_set_rtx, 1), 0);\n+  bool branch_if;\n+\n+  if (GET_CODE (cond) == NE\n+      && REG_P (XEXP (cond, 0)) && REGNO (XEXP (cond, 0)) == REGNO (m_ccreg)\n+      && XEXP (cond, 1) == const0_rtx)\n+    branch_if = true;\n+\n+  else if (GET_CODE (cond) == EQ\n+      && REG_P (XEXP (cond, 0)) && REGNO (XEXP (cond, 0)) == REGNO (m_ccreg)\n+      && XEXP (cond, 1) == const0_rtx)\n+    branch_if = false;\n+\n+  else\n+    gcc_unreachable ();\n+\n+  if (branch_target_bb == BRANCH_EDGE (cbranch_insn_bb)->dest)\n+    return branch_if;\n+  else if (branch_target_bb == FALLTHRU_EDGE (cbranch_insn_bb)->dest)\n+    return !branch_if;\n+  else\n+    gcc_unreachable ();\n+}\n+\n+void\n+sh_optimize_sett_clrt\n+::find_last_ccreg_values (rtx start_insn, basic_block bb,\n+\t\t\t  std::vector<ccreg_value>& values_out,\n+\t\t\t  basic_block prev_visited_bb) const\n+{\n+  if (start_insn == NULL_RTX)\n+    return;\n+\n+  log_msg (\"looking for ccreg values in [bb %d]\\n\", bb->index);\n+\n+  for (rtx i = start_insn; i != NULL_RTX && i != PREV_INSN (BB_HEAD (bb));\n+       i = PREV_INSN (i))\n+    {\n+      if (!INSN_P (i))\n+\tcontinue;\n+\n+      if (reg_set_p (m_ccreg, i))\n+\t{\n+\t  const_rtx set_rtx = set_of (m_ccreg, i);\n+\n+\t  ccreg_value v;\n+\t  v.insn = i;\n+\t  v.bb = bb;\n+\t  v.value = set_rtx != NULL_RTX && GET_CODE (set_rtx) == SET\n+\t\t    ? XEXP (set_rtx, 1)\n+\t\t    : NULL_RTX;\n+\n+\t  log_msg (\"found setcc in [bb %d] in insn:\\n\", bb->index);\n+\t  log_insn (i);\n+\t  log_msg (\"\\nccreg value: \");\n+\t  log_rtx (v.value);\n+\t  log_msg (\"\\n\");\n+\n+\t  values_out.push_back (v);\n+\t  return;\n+\t}\n+\n+      if (any_condjump_p (i) && onlyjump_p (i) && prev_visited_bb != NULL)\n+\t{\n+\t  // For a conditional branch the ccreg value will be a known constant\n+\t  // of either 0 or STORE_FLAG_VALUE after branching/falling through\n+\t  // to one of the two successor BBs.  Record the value for the BB\n+\t  // where we came from.\n+\t  log_msg (\"found cbranch in [bb %d]:\\n\", bb->index);\n+\t  log_insn (i);\n+\n+\t  ccreg_value v;\n+\t  v.insn = i;\n+\t  v.bb = bb;\n+\t  v.value = GEN_INT (sh_cbranch_ccreg_value (i, bb, prev_visited_bb));\n+\n+\t  log_msg (\"    branches to [bb %d] with ccreg value \",\n+\t\t   prev_visited_bb->index);\n+\t  log_rtx (v.value);\n+\t  log_msg (\"\\n\");\n+\n+\t  values_out.push_back (v);\n+\t  return;\n+\t}\n+    }\n+\n+  // If here, we've walked up all the insns of the current basic block\n+  // and none of them seems to modify the ccreg.\n+  // In this case, check the predecessor basic blocks.\n+  unsigned int pred_bb_count = 0;\n+\n+  // If the current basic block is the same as the previous one, it's a loop.\n+  // Don't try to recurse again, as this will result in an infinite loop.\n+  if (bb != prev_visited_bb)\n+    for (edge_iterator ei = ei_start (bb->preds); !ei_end_p (ei); ei_next (&ei))\n+      {\n+\tbasic_block pred_bb = ei_edge (ei)->src;\n+\tif (pred_bb->index == ENTRY_BLOCK)\n+\t  continue;\n+\n+\tpred_bb_count += 1;\n+\tfind_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out, bb);\n+      }\n+\n+  log_msg (\"[bb %d] pred_bb_count = %u\\n\", bb->index, pred_bb_count);\n+\n+  // If here, we've walked up all the predecessor basic blocks without finding\n+  // anything setcc related.  Add an entry for the last insn of the current\n+  // basic block with the ccreg value being set to unknown (NULL_RTX).\n+  if (pred_bb_count == 0)\n+  {\n+    log_msg (\"unknown ccreg value for [bb %d]\\n\", bb->index);\n+\n+    ccreg_value v;\n+    v.insn = BB_END (bb);\n+    v.bb = bb;\n+    v.value = NULL_RTX;\n+\n+    values_out.push_back (v);\n+  }\n+}\n+\n+bool\n+sh_optimize_sett_clrt\n+::all_ccreg_values_equal (const std::vector<ccreg_value>& values)\n+{\n+  if (values.empty ())\n+    return false;\n+\n+  rtx last_value = values.front ().value;\n+\n+  // If the ccreg is modified in the insn but the exact value is not known\n+  // the value rtx might be null.\n+  if (last_value == NULL_RTX)\n+    return false;\n+\n+  for (std::vector<ccreg_value>::const_iterator i = values.begin ();\n+       i != values.end (); ++i)\n+    if (i->value == NULL_RTX || !rtx_equal_p (last_value, i->value))\n+      return false;\n+\n+  return true;\n+}\n+\n+void\n+sh_optimize_sett_clrt\n+::remove_ccreg_dead_unused_notes (std::vector<ccreg_value>& values) const\n+{\n+  for (std::vector<ccreg_value>::iterator i = values.begin ();\n+       i != values.end (); ++i)\n+    {\n+      if (i->insn == NULL_RTX)\n+\tcontinue;\n+\n+      rtx n = find_regno_note (i->insn, REG_DEAD, REGNO (m_ccreg));\n+      if (n != NULL_RTX)\n+\tremove_note (i->insn, n);\n+\n+      n = find_regno_note (i->insn, REG_UNUSED, REGNO (m_ccreg));\n+      if (n != NULL_RTX)\n+\tremove_note (i->insn, n);\n+    }\n+}\n+\n+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+// This allows instantiating the pass somewhere else without having to pull\n+// in a header file.\n+opt_pass*\n+make_pass_sh_optimize_sett_clrt (gcc::context* ctx, const char* name)\n+{\n+  return new sh_optimize_sett_clrt (ctx, name);\n+}"}, {"sha": "405d3142253f471d6b1fb0078572d631c0775b69", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -29,6 +29,10 @@ sh_treg_combine.o: $(srcdir)/config/sh/sh_treg_combine.cc \\\n   $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) $(TM_P_H) coretypes.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n \n+sh_optimize_sett_clrt.o: $(srcdir)/config/sh/sh_optimize_sett_clrt.cc \\\n+  $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) $(TM_P_H) coretypes.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n DEFAULT_ENDIAN = $(word 1,$(TM_ENDIAN_CONFIG))\n OTHER_ENDIAN = $(word 2,$(TM_ENDIAN_CONFIG))\n "}, {"sha": "f7986f2ebbbf80b37a653f004b8a95960398b3e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -1,3 +1,8 @@\n+2013-11-21  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53976\n+\t* gcc.target/sh/pr53976-1.c: New.\n+\n 2013-11-20  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR libfortran/49024"}, {"sha": "4893b0668a5ec1f0a27ac7609d20f18d7d3c9997", "filename": "gcc/testsuite/gcc.target/sh/pr53976-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53976-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9733752cf255670ebaca1399c6484c26881c22/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53976-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53976-1.c?ref=ac9733752cf255670ebaca1399c6484c26881c22", "patch": "@@ -0,0 +1,41 @@\n+/* Check that the SH specific sh_optimize_sett_clrt RTL optimization pass\n+   works as expected.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-times \"clrt\" 2 } } */\n+/* { dg-final { scan-assembler-times \"sett\" 1 } } */\n+\n+long long\n+test_00 (long long a, long long b, long long c, int d)\n+{\n+  /* One of the blocks should have a clrt and the other one should not.  */\n+  if (d > 5)\n+    return a + b;\n+  else\n+    return a + c;\n+}\n+\n+long long\n+test_01 (long long a, long long b)\n+{\n+  /* Must see a clrt because T bit is undefined at function entry.  */\n+  return a + b;\n+}\n+\n+int\n+test_02 (const char* a)\n+{\n+  /* Must not see a sett after the inlined strlen.  */\n+  return __builtin_strlen (a);\n+}\n+\n+int\n+test_03 (int a, int b, int c, int d)\n+{\n+  /* One of the blocks should have a sett and the other one should not.  */\n+  if (d > 4)\n+    return a + b + 1;\n+  else\n+    return a + c + 1;\n+}"}]}