{"sha": "44942965f4eae141bd1f8300e7f77d0c9a3936e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ5NDI5NjVmNGVhZTE0MWJkMWY4MzAwZTdmNzdkMGM5YTM5MzZlNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T17:59:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T17:59:19Z"}, "message": "Remove IOR_HARD_REG_SET\n\nUse \"x |= y\" instead of \"IOR_HARD_REG_SET (x, y)\" (or just \"x | y\"\nif the result is a temporary).\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (HARD_REG_SET::operator|): New function.\n\t(HARD_REG_SET::operator|=): Likewise.\n\t(IOR_HARD_REG_SET): Delete.\n\t* config/gcn/gcn.c (gcn_md_reorg): Use \"|\" instead of\n\tIOR_HARD_REG_SET.\n\t* config/m32c/m32c.c (m32c_register_move_cost): Likewise.\n\t* config/s390/s390.c (s390_adjust_loop_scan_osc): Likewise.\n\t* final.c (collect_fn_hard_reg_usage): Likewise.\n\t* hw-doloop.c (scan_loop, optimize_loop): Likewise.\n\t* ira-build.c (merge_hard_reg_conflicts): Likewise.\n\t(ior_hard_reg_conflicts, create_cap_allocno, propagate_allocno_info)\n\t(propagate_some_info_from_allocno): Likewise.\n\t(copy_info_to_removed_store_destinations): Likewise.\n\t* ira-color.c (add_allocno_hard_regs_to_forest, assign_hard_reg)\n\t(allocno_reload_assign, ira_reassign_pseudos): Likewise.\n\t(fast_allocation): Likewise.\n\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n\t* ira-lives.c (make_object_dead, process_single_reg_class_operands)\n\t(process_bb_node_lives): Likewise.\n\t* ira.c (setup_pressure_classes, setup_reg_class_relations): Likewise.\n\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n\t* lra-constraints.c (process_alt_operands, inherit_in_ebb): Likewise.\n\t* lra-eliminations.c (spill_pseudos, update_reg_eliminate): Likewise.\n\t* lra-lives.c (mark_pseudo_dead, check_pseudos_live_through_calls)\n\t(process_bb_lives): Likewise.\n\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n\t* postreload.c (reload_combine): Likewise.\n\t* reginfo.c (init_reg_sets_1): Likewise.\n\t* regrename.c (merge_overlapping_regs, find_rename_reg)\n\t(merge_chains): Likewise.\n\t* reload1.c (maybe_fix_stack_asms, order_regs_for_reload, find_reg)\n\t(find_reload_regs, finish_spills, choose_reload_regs_init)\n\t(emit_reload_insns): Likewise.\n\t* reorg.c (redundant_insn): Likewise.\n\t* resource.c (find_dead_or_set_registers, mark_set_resources)\n\t(mark_target_live_regs): Likewise.\n\t* rtlanal.c (find_all_hard_reg_sets): Likewise.\n\t* sched-deps.c (sched_analyze_insn): Likewise.\n\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n\t(find_best_reg_for_expr): Likewise.\n\t* shrink-wrap.c (try_shrink_wrapping): Likewise.\n\nFrom-SVN: r275531", "tree": {"sha": "4813d3c9507c4d469a9cc04f2662bae23d1b3e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4813d3c9507c4d469a9cc04f2662bae23d1b3e58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44942965f4eae141bd1f8300e7f77d0c9a3936e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44942965f4eae141bd1f8300e7f77d0c9a3936e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44942965f4eae141bd1f8300e7f77d0c9a3936e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44942965f4eae141bd1f8300e7f77d0c9a3936e4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc333d8ff60909dbed89126443e3024f1592f8a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc333d8ff60909dbed89126443e3024f1592f8a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc333d8ff60909dbed89126443e3024f1592f8a4"}], "stats": {"total": 313, "additions": 166, "deletions": 147}, "files": [{"sha": "c7a6716ae8033dc2f4154cfe031ba89088f2e388", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1,3 +1,48 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (HARD_REG_SET::operator|): New function.\n+\t(HARD_REG_SET::operator|=): Likewise.\n+\t(IOR_HARD_REG_SET): Delete.\n+\t* config/gcn/gcn.c (gcn_md_reorg): Use \"|\" instead of\n+\tIOR_HARD_REG_SET.\n+\t* config/m32c/m32c.c (m32c_register_move_cost): Likewise.\n+\t* config/s390/s390.c (s390_adjust_loop_scan_osc): Likewise.\n+\t* final.c (collect_fn_hard_reg_usage): Likewise.\n+\t* hw-doloop.c (scan_loop, optimize_loop): Likewise.\n+\t* ira-build.c (merge_hard_reg_conflicts): Likewise.\n+\t(ior_hard_reg_conflicts, create_cap_allocno, propagate_allocno_info)\n+\t(propagate_some_info_from_allocno): Likewise.\n+\t(copy_info_to_removed_store_destinations): Likewise.\n+\t* ira-color.c (add_allocno_hard_regs_to_forest, assign_hard_reg)\n+\t(allocno_reload_assign, ira_reassign_pseudos): Likewise.\n+\t(fast_allocation): Likewise.\n+\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n+\t* ira-lives.c (make_object_dead, process_single_reg_class_operands)\n+\t(process_bb_node_lives): Likewise.\n+\t* ira.c (setup_pressure_classes, setup_reg_class_relations): Likewise.\n+\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n+\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n+\t* lra-constraints.c (process_alt_operands, inherit_in_ebb): Likewise.\n+\t* lra-eliminations.c (spill_pseudos, update_reg_eliminate): Likewise.\n+\t* lra-lives.c (mark_pseudo_dead, check_pseudos_live_through_calls)\n+\t(process_bb_lives): Likewise.\n+\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n+\t* postreload.c (reload_combine): Likewise.\n+\t* reginfo.c (init_reg_sets_1): Likewise.\n+\t* regrename.c (merge_overlapping_regs, find_rename_reg)\n+\t(merge_chains): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms, order_regs_for_reload, find_reg)\n+\t(find_reload_regs, finish_spills, choose_reload_regs_init)\n+\t(emit_reload_insns): Likewise.\n+\t* reorg.c (redundant_insn): Likewise.\n+\t* resource.c (find_dead_or_set_registers, mark_set_resources)\n+\t(mark_target_live_regs): Likewise.\n+\t* rtlanal.c (find_all_hard_reg_sets): Likewise.\n+\t* sched-deps.c (sched_analyze_insn): Likewise.\n+\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n+\t(find_best_reg_for_expr): Likewise.\n+\t* shrink-wrap.c (try_shrink_wrapping): Likewise.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* hard-reg-set.h (HARD_REG_SET::operator&): New function."}, {"sha": "8d99eb27e25113322ae69173295a068c3281fdd2", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -4627,7 +4627,7 @@ gcn_md_reorg (void)\n \t     not publish the cycle times for instructions.  */\n \t  prev_insn->age += 1 + nops_rqd;\n \n-\t  IOR_HARD_REG_SET (written, iwrites);\n+\t  written |= iwrites;\n \t  AND_COMPL_HARD_REG_SET (prev_insn->writes, written);\n \t}\n "}, {"sha": "b60044f107b2fd2a2f64e2daeabca3d2e4d05c44", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -2151,8 +2151,7 @@ m32c_register_move_cost (machine_mode mode, reg_class_t from,\n   HARD_REG_SET cc;\n \n /* FIXME: pick real values, but not 2 for now.  */\n-  cc = reg_class_contents[from];\n-  IOR_HARD_REG_SET (cc, reg_class_contents[(int) to]);\n+  cc = reg_class_contents[from] | reg_class_contents[(int) to];\n \n   if (mode == QImode\n       && hard_reg_set_intersect_p (cc, reg_class_contents[R23_REGS]))"}, {"sha": "2c6b5983624832d2029b1e1a5ab50d8fbc848d62", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -14073,7 +14073,7 @@ s390_adjust_loop_scan_osc (struct loop* loop)\n \treturn false;\n \n       find_all_hard_reg_sets (insn, &newregs, true);\n-      IOR_HARD_REG_SET (modregs, newregs);\n+      modregs |= newregs;\n \n       set = single_set (insn);\n       if (!set)\n@@ -14104,7 +14104,7 @@ s390_adjust_loop_scan_osc (struct loop* loop)\n \treturn false;\n \n       find_all_hard_reg_sets (insn, &newregs, true);\n-      IOR_HARD_REG_SET (modregs, newregs);\n+      modregs |= newregs;\n \n       set = single_set (insn);\n       if (!set)"}, {"sha": "6d91aa0075829c14fbe3973903be21ec3bfba780", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -5010,15 +5010,15 @@ collect_fn_hard_reg_usage (void)\n \t\t\t\t       call_used_reg_set))\n \t    return;\n \n-\t  IOR_HARD_REG_SET (function_used_regs, insn_used_regs);\n+\t  function_used_regs |= insn_used_regs;\n \t}\n \n       find_all_hard_reg_sets (insn, &insn_used_regs, false);\n-      IOR_HARD_REG_SET (function_used_regs, insn_used_regs);\n+      function_used_regs |= insn_used_regs;\n     }\n \n   /* Be conservative - mark fixed and global registers as used.  */\n-  IOR_HARD_REG_SET (function_used_regs, fixed_reg_set);\n+  function_used_regs |= fixed_reg_set;\n \n #ifdef STACK_REGS\n   /* Handle STACK_REGS conservatively, since the df-framework does not"}, {"sha": "3f98e770d520306abaa9ae295084890c2e5b2d9c", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -79,6 +79,23 @@ struct HARD_REG_SET\n     return *this;\n   }\n \n+  HARD_REG_SET\n+  operator| (const HARD_REG_SET &other) const\n+  {\n+    HARD_REG_SET res;\n+    for (unsigned int i = 0; i < ARRAY_SIZE (elts); ++i)\n+      res.elts[i] = elts[i] | other.elts[i];\n+    return res;\n+  }\n+\n+  HARD_REG_SET &\n+  operator|= (const HARD_REG_SET &other)\n+  {\n+    for (unsigned int i = 0; i < ARRAY_SIZE (elts); ++i)\n+      elts[i] |= other.elts[i];\n+    return *this;\n+  }\n+\n   HARD_REG_ELT_TYPE elts[HARD_REG_SET_LONGS];\n };\n typedef const HARD_REG_SET &const_hard_reg_set;\n@@ -109,12 +126,10 @@ struct hard_reg_set_container\n    CLEAR_HARD_REG_SET and SET_HARD_REG_SET.\n    These take just one argument.\n \n-   Also define a macro for combining hard reg sets:\n-   IOR_HARD_REG_SET\n-   This takes two arguments TO and FROM; it reads from FROM\n-   and combines bitwise into TO.  Define also\n+   Also define:\n    IOR_COMPL_HARD_REG_SET and AND_COMPL_HARD_REG_SET\n-   which use the complement of the set FROM.\n+   These take two arguments TO and FROM; they read from FROM\n+   and combines its complement bitwise into TO.\n \n    Also define:\n \n@@ -137,7 +152,6 @@ struct hard_reg_set_container\n #define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n #define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n \n-#define IOR_HARD_REG_SET(TO, FROM) ((TO) |= (FROM))\n #define IOR_COMPL_HARD_REG_SET(TO, FROM) ((TO) |= ~ (FROM))\n #define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n \n@@ -209,13 +223,6 @@ AND_COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n     to.elts[i] &= ~from.elts[i];\n }\n \n-inline void\n-IOR_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n-{\n-  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n-    to.elts[i] |= from.elts[i];\n-}\n-\n inline void\n IOR_COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {"}, {"sha": "3ee0b4098345009a9b12b388463e2bb3ccee5a88", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -141,7 +141,7 @@ scan_loop (hwloop_info loop)\n \t    CLEAR_HARD_REG_BIT (set_this_insn, REGNO (loop->iter_reg));\n \t  else if (reg_mentioned_p (loop->iter_reg, PATTERN (insn)))\n \t    loop->iter_reg_used = true;\n-\t  IOR_HARD_REG_SET (loop->regs_set_in_loop, set_this_insn);\n+\t  loop->regs_set_in_loop |= set_this_insn;\n \t}\n     }\n }\n@@ -581,7 +581,7 @@ optimize_loop (hwloop_info loop, struct hw_doloop_hooks *hooks)\n \tinner_depth = inner->depth;\n       /* The set of registers may be changed while optimizing the inner\n \t loop.  */\n-      IOR_HARD_REG_SET (loop->regs_set_in_loop, inner->regs_set_in_loop);\n+      loop->regs_set_in_loop |= inner->regs_set_in_loop;\n     }\n \n   loop->depth = inner_depth + 1;"}, {"sha": "354f989e563a03944fa9071c4c098ac217317e7c", "filename": "gcc/ira-build.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -602,10 +602,10 @@ merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n       ira_object_t to_obj = ALLOCNO_OBJECT (to, i);\n \n       if (!total_only)\n-\tIOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (to_obj),\n-\t\t\t  OBJECT_CONFLICT_HARD_REGS (from_obj));\n-      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj),\n-\t\t\tOBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj));\n+\tOBJECT_CONFLICT_HARD_REGS (to_obj)\n+\t  |= OBJECT_CONFLICT_HARD_REGS (from_obj);\n+      OBJECT_TOTAL_CONFLICT_HARD_REGS (to_obj)\n+\t|= OBJECT_TOTAL_CONFLICT_HARD_REGS (from_obj);\n     }\n #ifdef STACK_REGS\n   if (!total_only && ALLOCNO_NO_STACK_REG_P (from))\n@@ -625,8 +625,8 @@ ior_hard_reg_conflicts (ira_allocno_t a, HARD_REG_SET *set)\n \n   FOR_EACH_ALLOCNO_OBJECT (a, obj, i)\n     {\n-      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), *set);\n-      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), *set);\n+      OBJECT_CONFLICT_HARD_REGS (obj) |= *set;\n+      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= *set;\n     }\n }\n \n@@ -907,8 +907,8 @@ create_cap_allocno (ira_allocno_t a)\n \n   ALLOCNO_CALLS_CROSSED_NUM (cap) = ALLOCNO_CALLS_CROSSED_NUM (a);\n   ALLOCNO_CHEAP_CALLS_CROSSED_NUM (cap) = ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n-  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (cap),\n-\t\t    ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));\n+  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (cap)\n+    |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     {\n       fprintf (ira_dump_file, \"    Creating cap \");\n@@ -2036,8 +2036,8 @@ propagate_allocno_info (void)\n \t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n \t  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n \t    += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n- \t  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a),\n- \t\t\t    ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));\n+\t  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a)\n+\t    |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n \t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t  aclass = ALLOCNO_CLASS (a);\n@@ -2419,8 +2419,8 @@ propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n   ALLOCNO_CALLS_CROSSED_NUM (a) += ALLOCNO_CALLS_CROSSED_NUM (from_a);\n   ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a)\n     += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (from_a);\n-  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a),\n- \t\t    ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (from_a));\n+  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a)\n+    |= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (from_a);\n \n   ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a)\n     += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (from_a);\n@@ -3060,8 +3060,8 @@ copy_info_to_removed_store_destinations (int regno)\n \t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n       ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n \t+= ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n-      IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a),\n- \t\t\tALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));\n+      ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a)\n+\t|= ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a);\n       ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t+= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n       merged_p = true;"}, {"sha": "1078ef77de241f2879a1b4232bd1a152caff6a38", "filename": "gcc/ira-color.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -397,7 +397,7 @@ add_allocno_hard_regs_to_forest (allocno_hard_regs_node_t *roots,\n \t   i++)\n \t{\n \t  node = hard_regs_node_vec[i];\n-\t  IOR_HARD_REG_SET (temp_set, node->hard_regs->set);\n+\t  temp_set |= node->hard_regs->set;\n \t}\n       hv = add_allocno_hard_regs (temp_set, hv->cost);\n       new_node = create_new_allocno_hard_regs_node (hv);\n@@ -1798,9 +1798,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t\t\t\t\t  hard_regno + num);\n \t\t    }\n \t\t  else\n-\t\t    IOR_HARD_REG_SET\n-\t\t      (conflicting_regs[word],\n-\t\t       ira_reg_mode_hard_regset[hard_regno][mode]);\n+\t\t    conflicting_regs[word]\n+\t\t      |= ira_reg_mode_hard_regset[hard_regno][mode];\n \t\t  if (hard_reg_set_subset_p (profitable_hard_regs,\n \t\t\t\t\t     conflicting_regs[word]))\n \t\t    goto fail;\n@@ -4383,10 +4382,9 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n     {\n       ira_object_t obj = ALLOCNO_OBJECT (a, i);\n       saved[i] = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n-      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), forbidden_regs);\n+      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= forbidden_regs;\n       if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n-\tIOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t  call_used_reg_set);\n+\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_reg_set;\n     }\n   ALLOCNO_ASSIGNED_P (a) = false;\n   aclass = ALLOCNO_CLASS (a);\n@@ -4514,9 +4512,9 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n   for (i = 0; i < num; i++)\n     {\n       regno = spilled_pseudo_regs[i];\n-      forbidden_regs = bad_spill_regs;\n-      IOR_HARD_REG_SET (forbidden_regs, pseudo_forbidden_regs[regno]);\n-      IOR_HARD_REG_SET (forbidden_regs, pseudo_previous_regs[regno]);\n+      forbidden_regs = (bad_spill_regs\n+\t\t\t| pseudo_forbidden_regs[regno]\n+\t\t\t| pseudo_previous_regs[regno]);\n       gcc_assert (reg_renumber[regno] < 0);\n       a = ira_regno_allocno_map[regno];\n       ira_mark_allocation_change (regno);\n@@ -4881,11 +4879,10 @@ fast_allocation (void)\n       for (l = 0; l < nr; l++)\n \t{\n \t  ira_object_t obj = ALLOCNO_OBJECT (a, l);\n-\t  IOR_HARD_REG_SET (conflict_hard_regs,\n-\t\t\t    OBJECT_CONFLICT_HARD_REGS (obj));\n+\t  conflict_hard_regs |= OBJECT_CONFLICT_HARD_REGS (obj);\n \t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n \t    for (j = r->start; j <= r->finish; j++)\n-\t      IOR_HARD_REG_SET (conflict_hard_regs, used_hard_regs[j]);\n+\t      conflict_hard_regs |= used_hard_regs[j];\n \t}\n       aclass = ALLOCNO_CLASS (a);\n       ALLOCNO_ASSIGNED_P (a) = true;\n@@ -4933,8 +4930,7 @@ fast_allocation (void)\n \t  ira_object_t obj = ALLOCNO_OBJECT (a, l);\n \t  for (r = OBJECT_LIVE_RANGES (obj); r != NULL; r = r->next)\n \t    for (k = r->start; k <= r->finish; k++)\n-\t      IOR_HARD_REG_SET (used_hard_regs[k],\n-\t\t\t\tira_reg_mode_hard_regset[hard_regno][mode]);\n+\t      used_hard_regs[k] |= ira_reg_mode_hard_regset[hard_regno][mode];\n \t}\n     }\n   ira_free (sorted_allocnos);"}, {"sha": "46ff590e62fb51bf84cd033900d4e2b44ef7580e", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -762,21 +762,15 @@ ira_build_conflicts (void)\n \t\t  && REG_USERVAR_P (allocno_reg)\n \t\t  && ! reg_is_parm_p (allocno_reg)))\n \t    {\n-\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\tcall_used_reg_set);\n-\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t\tcall_used_reg_set);\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= call_used_reg_set;\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= call_used_reg_set;\n \t    }\n \t  else if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t    {\n-\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\tno_caller_save_reg_set);\n-\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\ttemp_hard_reg_set);\n-\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t\tno_caller_save_reg_set);\n-\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t\ttemp_hard_reg_set);\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= no_caller_save_reg_set;\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= temp_hard_reg_set;\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= no_caller_save_reg_set;\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= temp_hard_reg_set;\n \t    }\n \n \t  /* Now we deal with paradoxical subreg cases where certain registers"}, {"sha": "e1d502fd9e277408c4906061bae3ee23b6f2ea7d", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -188,8 +188,8 @@ make_object_dead (ira_object_t obj)\n \t}\n     }\n \n-  IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), hard_regs_live);\n-  IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), hard_regs_live);\n+  OBJECT_CONFLICT_HARD_REGS (obj) |= hard_regs_live;\n+  OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= hard_regs_live;\n \n   /* If IGNORE_REG_FOR_CONFLICTS did not already conflict with OBJ, make\n      sure it still doesn't.  */\n@@ -990,10 +990,8 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t      /* We could increase costs of A instead of making it\n \t\t conflicting with the hard register.  But it works worse\n \t\t because it will be spilled in reload in anyway.  */\n-\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t\treg_class_contents[cl]);\n-\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\treg_class_contents[cl]);\n+\t      OBJECT_CONFLICT_HARD_REGS (obj) |= reg_class_contents[cl];\n+\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) |= reg_class_contents[cl];\n \t    }\n \t}\n     }\n@@ -1275,10 +1273,10 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t    }\n \t\t  if (can_throw_internal (insn))\n \t\t    {\n-\t\t      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t\t\tthis_call_used_reg_set);\n-\t\t      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\t\tthis_call_used_reg_set);\n+\t\t      OBJECT_CONFLICT_HARD_REGS (obj)\n+\t\t\t|= this_call_used_reg_set;\n+\t\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj)\n+\t\t\t|= this_call_used_reg_set;\n \t\t    }\n \n \t\t  if (sparseset_bit_p (allocnos_processed, num))\n@@ -1295,8 +1293,8 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  /* Mark it as saved at the next call.  */\n \t\t  allocno_saved_at_call[num] = last_call_num + 1;\n \t\t  ALLOCNO_CALLS_CROSSED_NUM (a)++;\n-\t\t  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a),\n-\t\t\t\t    this_call_used_reg_set);\n+\t\t  ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a)\n+\t\t    |= this_call_used_reg_set;\n \t\t  if (cheap_reg != NULL_RTX\n \t\t      && ALLOCNO_REGNO (a) == (int) REGNO (cheap_reg))\n \t\t    ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a)++;"}, {"sha": "970cf1da6203f7ca112531d3fdf891a1c0e8164e", "filename": "gcc/ira.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -892,15 +892,15 @@ setup_pressure_classes (void)\n \t    break;\n \tif (m >= NUM_MACHINE_MODES)\n \t  {\n-\t    IOR_HARD_REG_SET (ignore_hard_regs, reg_class_contents[cl]);\n+\t    ignore_hard_regs |= reg_class_contents[cl];\n \t    continue;\n \t  }\n \tfor (i = 0; i < n; i++)\n \t  if ((int) pressure_classes[i] == cl)\n \t    break;\n-\tIOR_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n+\ttemp_hard_regset2 |= reg_class_contents[cl];\n \tif (i < n)\n-\t  IOR_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t  temp_hard_regset |= reg_class_contents[cl];\n       }\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n       /* Some targets (like SPARC with ICC reg) have allocatable regs\n@@ -1264,8 +1264,7 @@ setup_reg_class_relations (void)\n \t  intersection_set = (reg_class_contents[cl1]\n \t\t\t      & reg_class_contents[cl2]);\n \t  AND_COMPL_HARD_REG_SET (intersection_set, no_unit_alloc_regs);\n-\t  union_set = reg_class_contents[cl1];\n-\t  IOR_HARD_REG_SET (union_set, reg_class_contents[cl2]);\n+\t  union_set = reg_class_contents[cl1] | reg_class_contents[cl2];\n \t  AND_COMPL_HARD_REG_SET (union_set, no_unit_alloc_regs);\n \t  for (cl3 = 0; cl3 < N_REG_CLASSES; cl3++)\n \t    {"}, {"sha": "ce6b07b7e74f04b3609ea2c7b45b91dd82b9054b", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -495,16 +495,13 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   if (hard_reg_set_empty_p (regno_set))\n     conflict_set = lra_no_alloc_regs;\n   else\n-    {\n-      conflict_set = ~regno_set;\n-      IOR_HARD_REG_SET (conflict_set, lra_no_alloc_regs);\n-    }\n+    conflict_set = ~regno_set | lra_no_alloc_regs;\n   rclass = regno_allocno_class_array[regno];\n   rclass_intersect_p = ira_reg_classes_intersect_p[rclass];\n   curr_hard_regno_costs_check++;\n   sparseset_clear (conflict_reload_and_inheritance_pseudos);\n   sparseset_clear (live_range_hard_reg_pseudos);\n-  IOR_HARD_REG_SET (conflict_set, lra_reg_info[regno].conflict_hard_regs);\n+  conflict_set |= lra_reg_info[regno].conflict_hard_regs;\n   biggest_mode = lra_reg_info[regno].biggest_mode;\n   for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r->next)\n     {\n@@ -1218,7 +1215,7 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n \t    }\n \t}\n       conflict_set = lra_no_alloc_regs;\n-      IOR_HARD_REG_SET (conflict_set, lra_reg_info[regno].conflict_hard_regs);\n+      conflict_set |= lra_reg_info[regno].conflict_hard_regs;\n       val = lra_reg_info[regno].val;\n       offset = lra_reg_info[regno].offset;\n       EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)"}, {"sha": "d4eea8585a73aa8a70771eac99c989ea85245a80", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -2373,14 +2373,12 @@ process_alt_operands (int only_alternative)\n \t\t  if (mode == BLKmode)\n \t\t    break;\n \t\t  this_alternative = reg_class_subunion[this_alternative][cl];\n-\t\t  IOR_HARD_REG_SET (this_alternative_set,\n-\t\t\t\t    reg_class_contents[cl]);\n+\t\t  this_alternative_set |= reg_class_contents[cl];\n \t\t  if (costly_p)\n \t\t    {\n \t\t      this_costly_alternative\n \t\t\t= reg_class_subunion[this_costly_alternative][cl];\n-\t\t      IOR_HARD_REG_SET (this_costly_alternative_set,\n-\t\t\t\t\treg_class_contents[cl]);\n+\t\t      this_costly_alternative_set |= reg_class_contents[cl];\n \t\t    }\n \t\t  winreg = true;\n \t\t  if (REG_P (op))\n@@ -6245,8 +6243,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n   bitmap_clear (&invalid_invariant_regs);\n   last_processed_bb = NULL;\n   CLEAR_HARD_REG_SET (potential_reload_hard_regs);\n-  live_hard_regs = eliminable_regset;\n-  IOR_HARD_REG_SET (live_hard_regs, lra_no_alloc_regs);\n+  live_hard_regs = eliminable_regset | lra_no_alloc_regs;\n   /* We don't process new insns generated in the loop.\t*/\n   for (curr_insn = tail; curr_insn != PREV_INSN (head); curr_insn = prev_insn)\n     {\n@@ -6316,8 +6313,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t  else\n \t    setup_next_usage_insn (src_regno, curr_insn, reloads_num, false);\n \t  if (hard_reg_set_subset_p (reg_class_contents[cl], live_hard_regs))\n-\t    IOR_HARD_REG_SET (potential_reload_hard_regs,\n-\t\t\t      reg_class_contents[cl]);\n+\t    potential_reload_hard_regs |= reg_class_contents[cl];\n \t}\n       else if (src_regno < 0\n \t       && dst_regno >= lra_constraint_new_regno_start\n@@ -6334,8 +6330,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t  if (process_invariant_for_inheritance (SET_DEST (curr_set), SET_SRC (curr_set)))\n \t    change_p = true;\n \t  if (hard_reg_set_subset_p (reg_class_contents[cl], live_hard_regs))\n-\t    IOR_HARD_REG_SET (potential_reload_hard_regs,\n-\t\t\t      reg_class_contents[cl]);\n+\t    potential_reload_hard_regs |= reg_class_contents[cl];\n \t}\n       else if (src_regno >= lra_constraint_new_regno_start\n \t       && dst_regno < lra_constraint_new_regno_start\n@@ -6357,8 +6352,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t  /* Invalidate.  */\n \t  usage_insns[dst_regno].check = 0;\n \t  if (hard_reg_set_subset_p (reg_class_contents[cl], live_hard_regs))\n-\t    IOR_HARD_REG_SET (potential_reload_hard_regs,\n-\t\t\t      reg_class_contents[cl]);\n+\t    potential_reload_hard_regs |= reg_class_contents[cl];\n \t}\n       else if (INSN_P (curr_insn))\n \t{\n@@ -6593,8 +6587,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t      if (ira_class_hard_regs_num[cl] <= max_small_class_regs_num)\n \t\treloads_num++;\n \t      if (hard_reg_set_subset_p (reg_class_contents[cl], live_hard_regs))\n-\t\tIOR_HARD_REG_SET (potential_reload_hard_regs,\n-\t                          reg_class_contents[cl]);\n+\t\tpotential_reload_hard_regs |= reg_class_contents[cl];\n \t    }\n \t}\n       if (NONDEBUG_INSN_P (curr_insn))"}, {"sha": "7e5fbe3c5a077558f4b5ddc40ba78d66961880a8", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1089,7 +1089,7 @@ spill_pseudos (HARD_REG_SET set)\n \treg_renumber[i] = -1;\n \tbitmap_ior_into (&to_process, &lra_reg_info[i].insn_bitmap);\n       }\n-  IOR_HARD_REG_SET (lra_no_alloc_regs, set);\n+  lra_no_alloc_regs |= set;\n   for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n     if (bitmap_bit_p (&to_process, INSN_UID (insn)))\n       {\n@@ -1202,7 +1202,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t    result = true;\n \t  }\n       }\n-  IOR_HARD_REG_SET (lra_no_alloc_regs, temp_hard_reg_set);\n+  lra_no_alloc_regs |= temp_hard_reg_set;\n   AND_COMPL_HARD_REG_SET (eliminable_regset, temp_hard_reg_set);\n   spill_pseudos (temp_hard_reg_set);\n   return result;"}, {"sha": "e046817204c49a779483544369d386a42d8c49ba", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -327,7 +327,7 @@ static void\n mark_pseudo_dead (int regno)\n {\n   lra_assert (!HARD_REGISTER_NUM_P (regno));\n-  IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs, hard_regs_live);\n+  lra_reg_info[regno].conflict_hard_regs |= hard_regs_live;\n   if (!sparseset_bit_p (pseudos_live, regno))\n     return;\n \n@@ -602,8 +602,7 @@ check_pseudos_live_through_calls (int regno,\n     lra_reg_info[regno].call_insn = call_insn;\n \n   sparseset_clear_bit (pseudos_live_through_calls, regno);\n-  IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs,\n-\t\t    last_call_used_reg_set);\n+  lra_reg_info[regno].conflict_hard_regs |= last_call_used_reg_set;\n \n   for (hr = 0; HARD_REGISTER_NUM_P (hr); hr++)\n     if (targetm.hard_regno_call_part_clobbered (call_insn, hr,\n@@ -945,8 +944,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n \t      EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n \t\t{\n-\t\t  IOR_HARD_REG_SET (lra_reg_info[j].actual_call_used_reg_set,\n-\t\t\t\t    this_call_used_reg_set);\n+\t\t  lra_reg_info[j].actual_call_used_reg_set\n+\t\t    |= this_call_used_reg_set;\n \n \t\t  if (flush)\n \t\t    check_pseudos_live_through_calls (j,"}, {"sha": "0068e52ace1e061ad7582a66e8d69fe7cdffbb06", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -277,7 +277,7 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n       conflict_hard_regs = lra_reg_info[regno].conflict_hard_regs;\n       for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r->next)\n \tfor (p = r->start; p <= r->finish; p++)\n-\t  IOR_HARD_REG_SET (conflict_hard_regs, reserved_hard_regs[p]);\n+\t  conflict_hard_regs |= reserved_hard_regs[p];\n       spill_class_size = ira_class_hard_regs_num[spill_class];\n       mode = lra_reg_info[regno].biggest_mode;\n       for (k = 0; k < spill_class_size; k++)"}, {"sha": "3f2dac34bd61c8609f621e3943f55f46e32428d5", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1268,7 +1268,7 @@ reload_combine (void)\n \t  REG_SET_TO_HARD_REG_SET (live, live_in);\n \t  compute_use_by_pseudos (&live, live_in);\n \t  LABEL_LIVE (insn) = live;\n-\t  IOR_HARD_REG_SET (ever_live_at_start, live);\n+\t  ever_live_at_start |= live;\n \t}\n     }\n "}, {"sha": "9b77261bc13511599d2ee4c5ff3ae97cbdd8bfb9", "filename": "gcc/reginfo.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -298,8 +298,7 @@ init_reg_sets_1 (void)\n \t  HARD_REG_SET c;\n \t  int k;\n \n-\t  c = reg_class_contents[i];\n-\t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n+\t  c = reg_class_contents[i] | reg_class_contents[j];\n \t  for (k = 0; k < N_REG_CLASSES; k++)\n \t    if (hard_reg_set_subset_p (reg_class_contents[k], c)\n \t\t&& !hard_reg_set_subset_p (reg_class_contents[k],\n@@ -321,8 +320,7 @@ init_reg_sets_1 (void)\n \t  HARD_REG_SET c;\n \t  int k;\n \n-\t  c = reg_class_contents[i];\n-\t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n+\t  c = reg_class_contents[i] | reg_class_contents[j];\n \t  for (k = 0; k < N_REG_CLASSES; k++)\n \t    if (hard_reg_set_subset_p (c, reg_class_contents[k]))\n \t      break;"}, {"sha": "c28023ea72d986ffc63ae7389d1c702901a971d1", "filename": "gcc/regrename.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -292,7 +292,7 @@ merge_overlapping_regs (HARD_REG_SET *pset, class du_head *head)\n {\n   bitmap_iterator bi;\n   unsigned i;\n-  IOR_HARD_REG_SET (*pset, head->hard_conflicts);\n+  *pset |= head->hard_conflicts;\n   EXECUTE_IF_SET_IN_BITMAP (&head->conflicts, 0, i, bi)\n     {\n       du_head_p other = regrename_chain_from_id (i);\n@@ -367,7 +367,7 @@ find_rename_reg (du_head_p this_head, enum reg_class super_class,\n      If the chain needs a call-saved register, mark the call-used\n      registers as unavailable.  */\n   if (this_head->need_caller_save_reg)\n-    IOR_HARD_REG_SET (*unavailable, call_used_reg_set);\n+    *unavailable |= call_used_reg_set;\n \n   /* Mark registers that overlap this chain's lifetime as unavailable.  */\n   merge_overlapping_regs (unavailable, this_head);\n@@ -678,7 +678,7 @@ merge_chains (du_head_p c1, du_head_p c2)\n   c2->first = c2->last = NULL;\n   c2->id = c1->id;\n \n-  IOR_HARD_REG_SET (c1->hard_conflicts, c2->hard_conflicts);\n+  c1->hard_conflicts |= c2->hard_conflicts;\n   bitmap_ior_into (&c1->conflicts, &c2->conflicts);\n \n   c1->need_caller_save_reg |= c2->need_caller_save_reg;"}, {"sha": "6c95c9c91c3b80bc73258135fe680fdb07721c7e", "filename": "gcc/reload1.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1364,7 +1364,7 @@ maybe_fix_stack_asms (void)\n \t\t{\n \t\t  /* End of one alternative - mark the regs in the current\n \t\t     class, and reset the class.  */\n-\t\t  IOR_HARD_REG_SET (allowed, reg_class_contents[cls]);\n+\t\t  allowed |= reg_class_contents[cls];\n \t\t  cls = NO_REGS;\n \t\t  p++;\n \t\t  if (c == '#')\n@@ -1745,8 +1745,8 @@ order_regs_for_reload (class insn_chain *chain)\n \n   REG_SET_TO_HARD_REG_SET (used_by_pseudos, &chain->live_throughout);\n   REG_SET_TO_HARD_REG_SET (used_by_pseudos2, &chain->dead_or_set);\n-  IOR_HARD_REG_SET (bad_spill_regs, used_by_pseudos);\n-  IOR_HARD_REG_SET (bad_spill_regs, used_by_pseudos2);\n+  bad_spill_regs |= used_by_pseudos;\n+  bad_spill_regs |= used_by_pseudos2;\n \n   /* Now find out which pseudos are allocated to it, and update\n      hard_reg_n_uses.  */\n@@ -1823,8 +1823,7 @@ find_reg (class insn_chain *chain, int order)\n   static int regno_pseudo_regs[FIRST_PSEUDO_REGISTER];\n   static int best_regno_pseudo_regs[FIRST_PSEUDO_REGISTER];\n \n-  not_usable = bad_spill_regs;\n-  IOR_HARD_REG_SET (not_usable, bad_spill_regs_global);\n+  not_usable = bad_spill_regs | bad_spill_regs_global;\n   IOR_COMPL_HARD_REG_SET (not_usable, reg_class_contents[rl->rclass]);\n \n   CLEAR_HARD_REG_SET (used_by_other_reload);\n@@ -2008,7 +2007,7 @@ find_reload_regs (class insn_chain *chain)\n     }\n \n   chain->used_spill_regs = used_spill_regs_local;\n-  IOR_HARD_REG_SET (used_spill_regs, used_spill_regs_local);\n+  used_spill_regs |= used_spill_regs_local;\n \n   memcpy (chain->rld, rld, n_reloads * sizeof (struct reload));\n }\n@@ -4251,14 +4250,12 @@ finish_spills (int global)\n \t  EXECUTE_IF_SET_IN_REG_SET\n \t    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, i, rsi)\n \t    {\n-\t      IOR_HARD_REG_SET (pseudo_forbidden_regs[i],\n-\t\t\t\tchain->used_spill_regs);\n+\t      pseudo_forbidden_regs[i] |= chain->used_spill_regs;\n \t    }\n \t  EXECUTE_IF_SET_IN_REG_SET\n \t    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, i, rsi)\n \t    {\n-\t      IOR_HARD_REG_SET (pseudo_forbidden_regs[i],\n-\t\t\t\tchain->used_spill_regs);\n+\t      pseudo_forbidden_regs[i] |= chain->used_spill_regs;\n \t    }\n \t}\n \n@@ -4302,7 +4299,7 @@ finish_spills (int global)\n \t{\n \t  REG_SET_TO_HARD_REG_SET (used_by_pseudos, &chain->live_throughout);\n \t  REG_SET_TO_HARD_REG_SET (used_by_pseudos2, &chain->dead_or_set);\n-\t  IOR_HARD_REG_SET (used_by_pseudos, used_by_pseudos2);\n+\t  used_by_pseudos |= used_by_pseudos2;\n \n \t  compute_use_by_pseudos (&used_by_pseudos, &chain->live_throughout);\n \t  compute_use_by_pseudos (&used_by_pseudos, &chain->dead_or_set);\n@@ -6239,9 +6236,9 @@ choose_reload_regs_init (class insn_chain *chain, rtx *save_reload_reg_rtx)\n   {\n     HARD_REG_SET tmp;\n     REG_SET_TO_HARD_REG_SET (tmp, &chain->live_throughout);\n-    IOR_HARD_REG_SET (reg_used_in_insn, tmp);\n+    reg_used_in_insn |= tmp;\n     REG_SET_TO_HARD_REG_SET (tmp, &chain->dead_or_set);\n-    IOR_HARD_REG_SET (reg_used_in_insn, tmp);\n+    reg_used_in_insn |= tmp;\n     compute_use_by_pseudos (&reg_used_in_insn, &chain->live_throughout);\n     compute_use_by_pseudos (&reg_used_in_insn, &chain->dead_or_set);\n   }\n@@ -8420,7 +8417,7 @@ emit_reload_insns (class insn_chain *chain)\n \t    }\n \t}\n     }\n-  IOR_HARD_REG_SET (reg_reloaded_dead, reg_reloaded_died);\n+  reg_reloaded_dead |= reg_reloaded_died;\n }\n \f\n /* Go through the motions to emit INSN and test if it is strictly valid."}, {"sha": "f542a104635bdfe7595cdb4048fae6ee1293d871", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1575,7 +1575,7 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n   /* Insns we pass may not set either NEEDED or SET, so merge them for\n      simpler tests.  */\n   needed.memory |= set.memory;\n-  IOR_HARD_REG_SET (needed.regs, set.regs);\n+  needed.regs |= set.regs;\n \n   /* This insn isn't redundant if it conflicts with an insn that either is\n      or will be in a delay slot of TARGET.  */"}, {"sha": "f13956b963951bdb0485491a110af081106464f5", "filename": "gcc/resource.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -581,7 +581,7 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \t\t  find_dead_or_set_registers (next_insn,\n \t\t\t\t\t      &fallthrough_res, 0, jump_count,\n \t\t\t\t\t      set, needed);\n-\t\t  IOR_HARD_REG_SET (fallthrough_res.regs, target_res.regs);\n+\t\t  fallthrough_res.regs |= target_res.regs;\n \t\t  res->regs &= fallthrough_res.regs;\n \t\t  break;\n \t\t}\n@@ -670,7 +670,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t  res->cc = res->memory = 1;\n \n \t  get_call_reg_set_usage (call_insn, &regs, regs_invalidated_by_call);\n-\t  IOR_HARD_REG_SET (res->regs, regs);\n+\t  res->regs |= regs;\n \n \t  for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n \t       link; link = XEXP (link, 1))\n@@ -1109,7 +1109,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t\t  HARD_REG_SET extra_live;\n \n \t\t  REG_SET_TO_HARD_REG_SET (extra_live, DF_LR_IN (bb));\n-\t\t  IOR_HARD_REG_SET (current_live_regs, extra_live);\n+\t\t  current_live_regs |= extra_live;\n \t\t}\n \t    }\n \n@@ -1118,7 +1118,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t     are implicitly required at that point.  */\n \t  else if (NOTE_P (real_insn)\n \t\t   && NOTE_KIND (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n-\t    IOR_HARD_REG_SET (current_live_regs, start_of_epilogue_needs.regs);\n+\t    current_live_regs |= start_of_epilogue_needs.regs;\n \t}\n \n       res->regs = current_live_regs;\n@@ -1162,12 +1162,12 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \n \t  scratch = needed.regs;\n \t  AND_COMPL_HARD_REG_SET (scratch, set.regs);\n-\t  IOR_HARD_REG_SET (new_resources.regs, scratch);\n+\t  new_resources.regs |= scratch;\n \n \t  mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t}\n \n-      IOR_HARD_REG_SET (res->regs, new_resources.regs);\n+      res->regs |= new_resources.regs;\n     }\n \n   if (tinfo != NULL)"}, {"sha": "3dcdc846cbefd8992f6acfdeb41e56af963dcfdf", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1478,7 +1478,7 @@ find_all_hard_reg_sets (const rtx_insn *insn, HARD_REG_SET *pset, bool implicit)\n   CLEAR_HARD_REG_SET (*pset);\n   note_stores (insn, record_hard_reg_sets, pset);\n   if (CALL_P (insn) && implicit)\n-    IOR_HARD_REG_SET (*pset, call_used_reg_set);\n+    *pset |= call_used_reg_set;\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_INC)\n       record_hard_reg_sets (XEXP (link, 0), NULL, pset);"}, {"sha": "8031d72fa634a9d95f0cd5a6a9ef069dc7ed1ab0", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -2901,7 +2901,7 @@ sched_analyze_insn (class deps_desc *deps, rtx x, rtx_insn *insn)\n     {\n       HARD_REG_SET temp;\n       get_implicit_reg_pending_clobbers (&temp, insn);\n-      IOR_HARD_REG_SET (implicit_reg_pending_clobbers, temp);\n+      implicit_reg_pending_clobbers |= temp;\n     }\n \n   can_start_lhs_rhs_p = (NONJUMP_INSN_P (insn)"}, {"sha": "e5b825a102cde68e3900c8c230cbef611ac9a9ed", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -1221,15 +1221,13 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n      The HARD_REGNO_RENAME_OK covers other cases in condition below.  */\n   if (IN_RANGE (REGNO (orig_dest), FIRST_STACK_REG, LAST_STACK_REG)\n       && REGNO_REG_SET_P (used_regs, FIRST_STACK_REG))\n-    IOR_HARD_REG_SET (reg_rename_p->unavailable_hard_regs,\n-                      sel_hrd.stack_regs);\n+    reg_rename_p->unavailable_hard_regs |= sel_hrd.stack_regs;\n #endif\n \n   /* If there's a call on this path, make regs from call_used_reg_set\n      unavailable.  */\n   if (def->crosses_call)\n-    IOR_HARD_REG_SET (reg_rename_p->unavailable_hard_regs,\n-                      call_used_reg_set);\n+    reg_rename_p->unavailable_hard_regs |= call_used_reg_set;\n \n   /* Stop here before reload: we need FRAME_REGS, STACK_REGS, and crosses_call,\n      but not register classes.  */\n@@ -1684,8 +1682,7 @@ find_best_reg_for_expr (expr_t expr, blist_t bnds, bool *is_orig_reg_p)\n \n \t  /* Join hard registers unavailable due to register class\n \t     restrictions and live range intersection.  */\n-\t  IOR_HARD_REG_SET (hard_regs_used,\n-\t\t\t    reg_rename_data.unavailable_hard_regs);\n+\t  hard_regs_used |= reg_rename_data.unavailable_hard_regs;\n \n \t  best_reg = choose_best_reg (hard_regs_used, &reg_rename_data,\n \t\t\t\t      original_insns, is_orig_reg_p);"}, {"sha": "bf6d045b84cd43613a9de5f75e4a1808fe9ab05d", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44942965f4eae141bd1f8300e7f77d0c9a3936e4/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=44942965f4eae141bd1f8300e7f77d0c9a3936e4", "patch": "@@ -688,7 +688,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \tCLEAR_HARD_REG_SET (this_used);\n \tnote_uses (&PATTERN (insn), record_hard_reg_uses, &this_used);\n \tAND_COMPL_HARD_REG_SET (this_used, prologue_clobbered);\n-\tIOR_HARD_REG_SET (prologue_used, this_used);\n+\tprologue_used |= this_used;\n \tnote_stores (insn, record_hard_reg_sets, &prologue_clobbered);\n       }\n   CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);"}]}